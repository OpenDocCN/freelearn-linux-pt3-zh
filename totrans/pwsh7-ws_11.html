<html><head></head><body>
		<div id="_idContainer219">
			<h1 id="_idParaDest-214" class="chapter-number"><a id="_idTextAnchor218"/>11</h1>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor219"/>Creating Our First Module</h1>
			<p>Most programming languages include the concept of a library – an object that contains code, documentation, programming objects such as classes, message templates, and a host of other things. These libraries extend what we can do with that language by helping us to use other people’s code and reuse our own. In this chapter, we’re going to explore PowerShell modules – a convenient way of distributing <span class="No-Break">PowerShell code.</span></p>
			<p>We’ll start by briefly recapping how to work with modules and the cmdlets we use to do that. Then, we’ll look at the components of a module. We’ll learn how to write a module manually, before wrapping up with a brief look at using a module scaffolding <a id="_idIndexMarker807"/>application <span class="No-Break">called </span><span class="No-Break"><strong class="bold">Plaster</strong></span><span class="No-Break">.</span></p>
			<p>The main topics we will cover in this chapter are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Working <span class="No-Break">with modules</span></li>
				<li>Writing a <span class="No-Break">simple module</span></li>
				<li><span class="No-Break">Module manifests</span></li>
				<li>Using scaffolding tools such <span class="No-Break">as Plaster</span></li>
			</ul>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor220"/>Working with modules</h1>
			<p>Back in <a href="B17600_02.xhtml#_idTextAnchor034"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Exploring PowerShell Cmdlets and Syntax</em>, we spent some time exploring how we can use<a id="_idIndexMarker808"/> modules to find new cmdlets. In this chapter, we’ll be writing modules, but first, let’s recap what we learned previously and place it in some sort <span class="No-Break">of context.</span></p>
			<p>Modules allow us to reuse and distribute code so that it can be easily automated by including the cmdlets that manipulate modules in our scripts. So, if we need a cmdlet from the PowerShell math module in our script, then we can programmatically import that module (or just the required cmdlet) and use it. We can do this in a predictable and controllable fashion, without <span class="No-Break">user intervention.</span></p>
			<p>Modules fulfill three <span class="No-Break">basic functions:</span></p>
			<ul>
				<li><strong class="bold">Configuring the environment</strong>: They provide a repeatable custom work environment – for<a id="_idIndexMarker809"/> example, the PowerShell module for Exchange, as well as Exchange-specific cmdlets – configuring the PowerShell environment to work in a particular way <span class="No-Break">with Exchange</span></li>
				<li><strong class="bold">Code reuse</strong>: They provide libraries of functions that we or other people can use, such as the <span class="No-Break">math module</span></li>
				<li><strong class="bold">Solution engineering</strong>: Because modules can be nested inside other modules, whole groups of modules may be distributed to create an application for redistribution – this is common in Windows <span class="No-Break">administration environments</span></li>
			</ul>
			<p>We can find modules on the internet, in places such as GitHub, where they’ve been distributed with software, in a public repository such as the PowerShell Gallery or internal repositories in our workplace or school, or via friends <span class="No-Break">and colleagues.</span></p>
			<p>By installing the modules in standard locations, we can control access to them on a given machine, or we can add to the default list of places that PowerShell will search for modules. Let’s start by<a id="_idIndexMarker810"/> looking at the common locations for modules on our <span class="No-Break">client device.</span></p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor221"/>Module locations</h2>
			<p>There are three <a id="_idIndexMarker811"/>default locations for modules. These are shown in the <span class="No-Break">following table:</span></p>
			<table id="table001-6" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body"/>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Windows</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Linux</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">System</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>None for PowerShell 7, but Windows PowerShell <span class="No-Break">uses </span><span class="No-Break"><strong class="source-inline">C:\WINDOWS\system32\WindowsPowerShell\v1.0\Modules\</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">opt/Microsoft/PowerShell/7/Modules</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">AllUsers</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<ul>
								<li><span class="No-Break"><strong class="source-inline">C:\Program Files\PowerShell\Modules</strong></span></li>
								<li><span class="No-Break"><strong class="source-inline">C:\Program Files\PowerShell\7\Modules</strong></span></li>
							</ul>
						</td>
						<td class="No-Table-Style T---Body">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">usr/local/share/PowerShell/Modules</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">User</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">C:\Users\&lt;user name&gt;\Documents\PowerShell\Modules</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">home/&lt;username&gt;/.local/share/PowerShell/Modules</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.1 – Default module locations in Windows and Linux</p>
			<p>The System location is reserved for Microsoft modules. The User location does not exist by default in Windows and will need to be created before it can be used. The AllUsers location was introduced in PowerShell v4 to provide a location for non-Microsoft modules that need to run under the system account. This also gives us a place to install modules for any user on the client to use. Modules downloaded from the PowerShell Gallery are placed here <span class="No-Break">by default.</span></p>
			<p>As we saw in <a href="B17600_02.xhtml#_idTextAnchor034"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Exploring PowerShell Cmdlets and Syntax</em>, we can add locations where we may install modules by manipulating the <strong class="source-inline">$ENV:PSModulePath</strong> variable. Locations should be separated by a semicolon (<strong class="source-inline">;</strong>) in Windows and a colon (<strong class="source-inline">:</strong>) in Linux, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/B17600_11_001.jpg" alt="Figure 11.1 – The $env:PSModulePath variable in Linux"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – The $env:PSModulePath variable in Linux</p>
			<p>We can make this listing tidier by calling the <strong class="source-inline">$env:PSModulePath -Split ":"</strong> variable, which will output each location on a separate line. Obviously, on a Windows client, the separator<a id="_idIndexMarker812"/> should be a semicolon (<strong class="source-inline">;</strong>). Paths often get added to this variable when <span class="No-Break">installing applications.</span></p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor222"/>Module autoloading</h2>
			<p>We can load modules <a id="_idIndexMarker813"/>automatically under certain circumstances. Modules in correctly named folders in the module paths defined in <strong class="source-inline">$env:PSModulePath</strong> are automatically discovered by PowerShell. We can do this by doing <span class="No-Break">the following:</span></p>
			<ul>
				<li>Running a cmdlet from <span class="No-Break">the module</span></li>
				<li>Using <strong class="source-inline">Get-Command</strong> for a cmdlet in <span class="No-Break">the module</span></li>
				<li>Using <strong class="source-inline">Get-Help</strong> for a cmdlet in <span class="No-Break">the module</span></li>
			</ul>
			<p>Module autoloading is great for when we’re working interactively in the shell, but we shouldn’t rely on it in a script. The recommended way to load modules inside a script is with the <strong class="source-inline">using</strong> keyword, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
using module &lt;module name&gt;</pre>			<p>Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
Using module ActiveDirectory</pre>			<p>Note that some<a id="_idIndexMarker814"/> caveats on this are covered in the <em class="italic">Nested </em><span class="No-Break"><em class="italic">modules</em></span><span class="No-Break"> section.</span></p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor223"/>Importing modules</h2>
			<p>Autoloading modules<a id="_idIndexMarker815"/> is convenient, but it’s not particularly controlled. For instance, it loads everything in the module, some of which we might not need, and we cannot control the version of the module that is loaded. It can also consume a lot of memory. Therefore, we might choose to manually import modules into a session using the <strong class="source-inline">Import-Module</strong> cmdlet, which gives us several options to control how and what <span class="No-Break">we import:</span></p>
			<ul>
				<li><strong class="source-inline">-Name</strong>: Use this to specify the name of the module to import. We can also include a path here if the module is not in the module path specified <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">$ENV:PSModulePath</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-Cmdlet</strong>: This allows us to import a selection of cmdlets from an array of strings. Similar parameters, such as <strong class="source-inline">-Alias</strong>, <strong class="source-inline">-Function</strong>, and <strong class="source-inline">-Variable</strong>, have the <span class="No-Break">expected effect.</span></li>
				<li><strong class="source-inline">-Force</strong>: This forces a module to reload completely. By default, if a module is already loaded, then <strong class="source-inline">Import-Module</strong> does not reimport it. This is useful if we are developing a module and need to test <span class="No-Break">it repeatedly.</span></li>
				<li><strong class="source-inline">-RequiredVersion</strong>: Use this to specify the version of the module to <span class="No-Break">be imported.</span></li>
				<li><strong class="source-inline">-Prefix</strong>: This parameter adds a prefix to the nouns in cmdlets that are imported from the module, to prevent confusion with cmdlets that already exist in <span class="No-Break">the session.</span></li>
				<li><strong class="source-inline">-NoClobber</strong>: This prevents cmdlets from being imported if they have the same name as cmdlets that already exist in <span class="No-Break">the session.</span></li>
			</ul>
			<p>There are several other parameters, but we won’t consider <span class="No-Break">them here.</span></p>
			<p>We can unload a module using the <strong class="source-inline">Remove-Module</strong> cmdlet. Why might we want to do that? Well, when we first import a module, we import all the nested modules that it requires as well. However, if we then use <strong class="source-inline">Import-Module -Force</strong> to reload the module, it only reloads the named module, not the nested modules. <strong class="source-inline">Remove-Module</strong> also removes the nested modules. In practice, of course, just starting a new session is often quicker <span class="No-Break">and cleaner.</span></p>
			<p>Very often, we’ll see scripts on the internet using the <strong class="source-inline">Import-Module</strong> cmdlet to make module contents available inside a script. I do this too, despite it not being the recommended way of doing it; it just feels more readable to me. Microsoft recommends we do this with<a id="_idIndexMarker816"/> the <strong class="source-inline">using</strong> keyword, though. My doctor recommends I eat less salt; I tend to ignore that advice <span class="No-Break">as well.</span></p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor224"/>PowerShellGet</h2>
			<p>Microsoft has a<a id="_idIndexMarker817"/> module <a id="_idIndexMarker818"/>called <strong class="source-inline">PowerShellGet</strong> that includes a lot of resources for working with repositories and modules. This module is included in PowerShell 7. It allows us to work easily with the PowerShell Gallery so that we can find, register, and unregister other repositories, which allows us to find, install, and uninstall modules and scripts in repositories, as well as manipulate those modules and scripts. We covered the basic uses of <strong class="source-inline">PowerShellGet</strong> at some length in <a href="B17600_02.xhtml#_idTextAnchor034"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>,<em class="italic"> </em><em class="italic">Exploring PowerShell Cmdlets </em><span class="No-Break"><em class="italic">and Syntax</em></span><span class="No-Break">.</span></p>
			<p>From PowerShell 7.4 onwards, the PowerShellGet v2.2.5 module will be accompanied by version 3. The version 3 module is called <strong class="source-inline">Microsoft.Powershell.PSResourceGet</strong> and replaces the <strong class="source-inline">Install-Module</strong> and <strong class="source-inline">Install-Script</strong> cmdlets with the single <strong class="source-inline">Install-PSResource</strong> cmdlet, among many other changes. In PowerShell 7.4, the two modules will ship side by side, allowing any current resources that use <strong class="source-inline">PowerShellGet</strong> to continue working. However, no compatibility layer will be included, so scripts written for v2.2.5 and earlier won’t work with version 3 unless we use the separate <strong class="source-inline">CompatPowerShellGet</strong> module that will be included in <span class="No-Break">PowerShell 7.5.</span></p>
			<p>Next, we’ll learn how to create a module, but first, a word of caution. There is a PowerShell cmdlet <a id="_idIndexMarker819"/>called <strong class="source-inline">New-Module</strong>. This creates a very specific type of module – a <strong class="bold">dynamic module</strong>. Dynamic <a id="_idIndexMarker820"/>modules only exist in memory; they’re not stored in files, and they are session-specific, so when the PowerShell session ends, the module is lost. We’re not going <a id="_idIndexMarker821"/>to<a id="_idIndexMarker822"/> cover those modules or their uses in this chapter – they’re quite advanced. We’re not going to cover <span class="No-Break"><strong class="source-inline">New-Module</strong></span><span class="No-Break">, either.</span></p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor225"/>Writing a simple module</h1>
			<p>A module, at its most<a id="_idIndexMarker823"/> basic, is a script file containing functions, saved with a <strong class="source-inline">.psm1</strong> extension. That’s it. That’s the simplest possible module. Try it – save the following lines as a <strong class="source-inline">.psm1</strong> file, in a folder with the same name as the file, inside your <strong class="source-inline">\users\&lt;username&gt;\documents\powershell\modules</strong> folder (or the <strong class="source-inline">home/&lt;user&gt;/.local/share/powershell/Modules</strong> folder <span class="No-Break">in Linux):</span></p>
			<pre class="source-code">
function Get-Square($a) {
  $result = $a * $a
  return $result
    }</pre>			<p>It doesn’t matter what you call the file, so long as the file and folder name are the same, and the folder is in the module path so that PowerShell can find it, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer199" class="IMG---Figure">
					<img src="image/B17600_11_002.jpg" alt="Figure 11.2 – Saving a module in the module path correctly"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Saving a module in the module path correctly</p>
			<p>Now, if we start a PowerShell session, we can type <span class="No-Break">the following:</span></p>
			<pre class="console">
Import-Module &lt;ModuleName&gt;</pre>			<p>PowerShell will load it. Once it is loaded, we can use the functions inside, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer200" class="IMG---Figure">
					<img src="image/B17600_11_003.jpg" alt="Figure 11.3 – Using our first module"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Using our first module</p>
			<p>As you can see, the <strong class="source-inline">Import-Module</strong> cmdlet produces no output, but the function inside the module is available. If we run <strong class="source-inline">Remove-Module</strong>, the function disappears as well. Or <span class="No-Break">does it?</span></p>
			<p class="callout-heading">Activity 1</p>
			<p class="callout">Try running <strong class="source-inline">Remove-Module</strong> to get rid of the module we’ve just installed, and then running <strong class="source-inline">Get-Square</strong>. What happens? Why does <span class="No-Break">this happen?</span></p>
			<p>Before we look at<a id="_idIndexMarker824"/> ways to create modules, let’s talk about the earliest method of building libraries in PowerShell – <span class="No-Break">dot-sourcing.</span></p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor226"/>A word of caution – dot-sourcing</h2>
			<p>In the very first <a id="_idIndexMarker825"/>version of PowerShell, there was only one way to include the functions in one script inside another: <strong class="bold">dot-sourcing</strong>. Let’s try it. Write the following line in a new script and save it as <strong class="source-inline">Dot-Source.ps1</strong> in a suitable folder – I’m <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">c:\temp\poshbook\ch11</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Write-Message "dot source test"</pre>			<p>It should be obvious that if we run this, it isn’t going to work. There is no cmdlet called <strong class="source-inline">Write-Message</strong>, and the script doesn’t define one. Let’s create a <strong class="source-inline">Write-Message</strong> function in another script, and save it <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">Write-Message.ps1</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$text = "default message"
function Write-Message($text) {
    Write-Output "$text"
}</pre>			<p>Now, let’s go back to <strong class="source-inline">Dot-Source.ps1</strong> and add this line at <span class="No-Break">the start:</span></p>
			<pre class="source-code">
. C:\temp\poshbook\ch11\Write-Message.ps1</pre>			<p>Change the path to reflect the location where you saved <strong class="source-inline">Write-Message.ps1</strong>. Now, when we run <strong class="source-inline">Dot-Source.ps1</strong>, our message should be displayed, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="image/B17600_11_004.jpg" alt="Figure 11.4 – Using dot-sourcing in a script"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Using dot-sourcing in a script</p>
			<p>We can do this<a id="_idIndexMarker826"/> interactively as well, in a PowerShell session, just by dot-sourcing the script, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="image/B17600_11_005.jpg" alt="Figure 11.5 – Interactive dot-sourcing"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Interactive dot-sourcing</p>
			<p>So, if dot-sourcing is so straightforward, why should we bother with modules at all? The reason is the management problems that dot-sourcing introduces. When we dot-source a script, we bring the members of that script, as well as the variables and functions, into the parent scope. We can see this in the preceding screenshot; if we call the <strong class="source-inline">$text</strong> variable, then we get the <strong class="source-inline">default message</strong> string. Remember, the concept of scope was introduced to protect us from ambiguously written code; by dot-sourcing code, we remove that protection. When we interactively dot-sourced <strong class="source-inline">Write-Message.ps1</strong>, we brought a function into the global scope that we now have no easy way of removing. Any variables in that script outside the function would be brought in as well. If those variables are poorly named, they may conflict with important existing variables, leading to, as they say, <span class="No-Break">hilarious consequences.</span></p>
			<p>If we are unsure where a function has come from, we can use the <strong class="source-inline">File</strong> property on the object to check, <span class="No-Break">like this:</span></p>
			<pre class="console">
${function:Write-Message}.File</pre>			<p>This will give us the path of the file that contains that function. We can also remove it from a session with the <strong class="source-inline">Remove-Item</strong> cmdlet, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="image/B17600_11_006.jpg" alt="Figure 11.6 – Finding the source of functions and removing them"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Finding the source of functions and removing them</p>
			<p>Modules allow<a id="_idIndexMarker827"/> us to control what functions and variables are exported from our code, and to control those as a group. Let’s see how we can turn an existing script into <span class="No-Break">a module.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor227"/>Turning a script into a module</h2>
			<p>As we saw at the<a id="_idIndexMarker828"/> start of this section, the basic process for turning a script into a module is to change the file extension from <strong class="source-inline">.ps1</strong> to <strong class="source-inline">.psm1</strong>. Let’s do that now with the <strong class="source-inline">Write-Message.ps1</strong> script we wrote previously, and save a copy of it <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">Write-Message.psm1</strong></span><span class="No-Break">.</span></p>
			<p>Now, we can open a new session and import our module into the session with the <span class="No-Break">following command:</span></p>
			<pre class="console">
Import-Module C:\temp\poshbook\ch11\Write-Message.psm1</pre>			<p>Let’s take a look at this module <span class="No-Break">in detail:</span></p>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="image/B17600_11_007.jpg" alt="Figure 11.7 – Details of the Write-Message module"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Details of the Write-Message module</p>
			<p>In the first line, we imported the module. We used the full path because we haven’t saved it in a location included in the module path. This is to prevent PowerShell from autoloading it. Now, let’s run the <span class="No-Break">following command:</span></p>
			<pre class="console">
Get-Module Write-Message</pre>			<p>We’ll see a script<a id="_idIndexMarker829"/> module, its location, and the exported command – that is, <strong class="source-inline">Write-Module</strong>. Now, let’s run the <span class="No-Break">following command:</span></p>
			<pre class="console">
Get-Module Write-Message | Format-List</pre>			<p>We will see that only the function is exported, not <span class="No-Break">the variable.</span></p>
			<p>We can check the details of the <strong class="source-inline">Write-Message</strong> function with <strong class="source-inline">Get-Command</strong> and see that the source is the <span class="No-Break"><strong class="source-inline">Write-Message</strong></span><span class="No-Break"> module.</span></p>
			<p>Let’s try some other things with this module. Open the module file and add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
function setMessage {
    Write-Output "$text"
}</pre>			<p>Import the module again, using the <strong class="source-inline">-Force</strong> parameter to reload it. Now, we have two functions in our module. If we run <strong class="source-inline">Get-Module</strong> again, we’ll see that they are <span class="No-Break">both visible:</span></p>
			<div>
				<div id="_idContainer205" class="IMG---Figure">
					<img src="image/B17600_11_008.jpg" alt="Figure 11.8 – Multiple exports"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Multiple exports</p>
			<p>As you can <a id="_idIndexMarker830"/>see, the <strong class="source-inline">setMessage</strong> cmdlet is available for us to use. What happens if we don’t want that? The name we’ve used doesn’t conform with cmdlet naming conventions and is generally one we’d use to signify a private function; something that we need to be available to the other functions within the module, but not something we want available for use outside those functions. We can control access using the <strong class="source-inline">Export-ModuleMember</strong> cmdlet. Add the following line to the bottom <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Write-Message.psm1</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Export-ModuleMember -Function Write-Message</pre>			<p>Then, import the module again with the <strong class="source-inline">-Force</strong> parameter. The results are shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="image/B17600_11_009.jpg" alt="Figure 11.9 – Controlling exported functions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Controlling exported functions</p>
			<p>Now, only the <strong class="source-inline">Write-Message</strong> function is exported, and when we try and run <strong class="source-inline">setMessage</strong>, this time, we get an error. We can also use <strong class="source-inline">Export-ModuleMember</strong> to export variables and aliases from the module, which aren’t exported by default, <span class="No-Break">like this:</span></p>
			<pre class="console">
Export-ModuleMember -variable $MyVariable</pre>			<p>If we don’t explicitly use <strong class="source-inline">Export-ModuleMember</strong>, all the functions in a module will be exported, but nothing other <span class="No-Break">than functions.</span></p>
			<p>In the introduction to this chapter, we mentioned one of the use cases for modules: building applications<a id="_idIndexMarker831"/> and solutions. To do this, we will often call a module from within another module – this is called nesting modules, and that’s what we’re going to look <span class="No-Break">at next.</span></p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor228"/>Nested modules</h2>
			<p>In <a href="B17600_09.xhtml#_idTextAnchor184"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Don’t Repeat Yourself – Functions and Scriptblocks</em>, we looked at some functions for writing output to log files. It <a id="_idIndexMarker832"/>would be useful to write those functions in a module so that we could just call them when we needed them, rather than having to write them in every script we create. These are great examples of functions we would want to keep private, rather than export them for general use. Let’s do this. Copy the <strong class="source-inline">Write-Log.ps1</strong> script we wrote previously to a module file called <strong class="source-inline">Write-Log.psm1</strong> in a <a id="_idIndexMarker833"/>suitable location. We’ll need to edit the <strong class="source-inline">.psm1</strong> file to remove the <span class="No-Break">following line:</span></p>
			<pre class="source-code">
Write-Log "Is this thing on?"</pre>			<p>This is how my module <span class="No-Break">file looks:</span></p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="image/B17600_11_010.jpg" alt="Figure 11.10 – The Write-Log.psm1 module"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – The Write-Log.psm1 module</p>
			<p>As we can see, I’ve <a id="_idIndexMarker834"/>remarked line 11, rather than deleting it. We are left with two functions and a variable – that is, <strong class="source-inline">Write-Log</strong>, <strong class="source-inline">Remove-Log</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">$LogFile</strong></span><span class="No-Break">.</span></p>
			<p>We can now add a couple of lines to our <strong class="source-inline">Write-Message.psm1</strong> module so that we can call the <strong class="source-inline">Write-Log</strong> module and run one of the functions in it. Edit your <strong class="source-inline">Write-Message</strong> function, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Import-Module "C:\temp\poshbook\ch11\write-log.psm1"
$text = "default message"
function Write-Message($text) {
    Write-Output "$text"
    Write-Log "$text"
}
function setMessage {
    Write-Output "$text"
}</pre>			<p>I’ve added the first line to import the <strong class="source-inline">Write-Log</strong> module and the fifth line to call the <strong class="source-inline">Write-Log</strong> function from it. I’ve also removed the <strong class="source-inline">Export-ModuleMember</strong> line. Now, let’s see what<a id="_idIndexMarker835"/> happens when we import the <span class="No-Break"><strong class="source-inline">Write-Message</strong></span><span class="No-Break"> module:</span></p>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="image/B17600_11_011.jpg" alt="Figure 11.11 – Nested modules"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – Nested modules</p>
			<p>As we can see, the module is imported as before and works as we expect. We can see from the output of <strong class="source-inline">Get-Module</strong> that there are four exported functions – two from <strong class="source-inline">Write-Message</strong> and two from <strong class="source-inline">Write-Log</strong> – and we can see that the <strong class="source-inline">Write-Log</strong> module is nested. When we attempt to access it with <strong class="source-inline">Get-Command</strong>, however, we don’t see any loaded functions, and <strong class="source-inline">Get-Module Write-Log</strong> returns nothing. However, if we check the log file that was created, we’ll see a message stating <strong class="source-inline">nested module test</strong>, so it <span class="No-Break">is working.</span></p>
			<p>This is because nested modules are only visible to the calling module, so we can’t access <strong class="source-inline">Write-Log</strong> directly. However, because we removed the <strong class="source-inline">Export-ModuleMember</strong> line, all functions are exported, including the functions from nested modules; they appear as functions of the calling module. We’ll be able to see the <strong class="source-inline">Write-Log</strong> module if we use <strong class="source-inline">Get-Module -All</strong>, though, and we can find the real location of the <strong class="source-inline">Write-Log</strong> function as before – that is, by calling the <span class="No-Break"><strong class="source-inline">File</strong></span><span class="No-Break"> property:</span></p>
			<div>
				<div id="_idContainer209" class="IMG---Figure">
					<img src="image/B17600_11_012.jpg" alt="Figure 11.12 – Finding nested modules"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – Finding nested modules</p>
			<p>As we can<a id="_idIndexMarker836"/> see, the <strong class="source-inline">Write-Log</strong> function is defined in the <span class="No-Break"><strong class="source-inline">write-log.psm1</strong></span><span class="No-Break"> file.</span></p>
			<p>Sometimes, we may not want nested modules to be hidden like this; if that’s the case, then we can use the <strong class="source-inline">-Global</strong> parameter of <strong class="source-inline">Import-Module</strong>, <span class="No-Break">like this:</span></p>
			<pre class="console">
Import-Module -Global "C:\temp\poshbook\ch11\write-log.psm1"</pre>			<p>The <strong class="source-inline">Write-Log</strong> module will be imported at the same top level as the <span class="No-Break"><strong class="source-inline">Write-Message</strong></span><span class="No-Break"> module.</span></p>
			<p>Now, let’s look at some other types of modules, including binary and <span class="No-Break">manifest modules.</span></p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor229"/>More modules</h2>
			<p>You may have noticed <a id="_idIndexMarker837"/>that when we create a function in a module, we use it like a cmdlet, but it’s still called a function. It will behave as a cmdlet, with parameters, help, members, and so on, but it’s not a cmdlet. Consider <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer210" class="IMG---Figure">
					<img src="image/B17600_11_013.jpg" alt="Figure 11.13 – Functions and cmdlets"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – Functions and cmdlets</p>
			<p>As we can see, <strong class="source-inline">Write-Message</strong> is of the <strong class="source-inline">Function</strong> type, whereas the Microsoft <strong class="source-inline">Get-Service</strong> command is of the <span class="No-Break"><strong class="source-inline">Cmdlet</strong></span><span class="No-Break"> type.</span></p>
			<p>To write custom cmdlets, we need to write a binary module. Remember that PowerShell is based on .NET and is an interpreted language, written in a compiled language, usually C#, in the same way that Python is an interpreted language written <span class="No-Break">in C.</span></p>
			<p>We’re not going to cover writing modules in C# here, but we will discuss how they work and how they <span class="No-Break">are used.</span></p>
			<p>A binary module does not have a <strong class="source-inline">.psm1</strong> extension – it is a .NET assembly compiled from code such as C# and has a <strong class="source-inline">.dll</strong> extension. We can create it by writing our C# code within a <strong class="source-inline">Here-String</strong> declaration, a block of multi-line text inside the <strong class="source-inline">@"   "@</strong> construct, and then use the <strong class="source-inline">Add-Type -OutputAssembly</strong> cmdlet to <span class="No-Break">compile it:</span></p>
			<pre class="source-code">
$code = @"
using System.Management.Automation;
namespace SendMessage
{
    [Cmdlet(VerbsCommunications.Send, "Message")]
    public class SendMessageCommand : Cmdlet
    {
        [Parameter(Mandatory = true)]
        public string Name { get; set; }
        protected override void ProcessRecord()
        {
            WriteObject(Name + " loves PowerShell!");
        }
    }
}
"@
Add-Type -TypeDefinition $Code -OutputAssembly  c:\temp\MyBinaryModule.dll</pre>			<p>Other than that, we can import it in the same way as a script module <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Import-Module</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
Import-Module c:\temp\MyBinaryModule.dll</pre>			<p>If we were to run <strong class="source-inline">Get-Module</strong> on our fictional <strong class="source-inline">MyBinaryModule</strong>, we would see that <strong class="source-inline">ModuleType</strong> is <strong class="source-inline">Binary</strong> and that it has exported cmdlets, rather than <span class="No-Break">exported functions.</span></p>
			<p>The main difference between <a id="_idIndexMarker838"/>binary modules and script modules is that once they’re loaded into a session, they can’t be unloaded. If we need to make a change to a binary module we are writing, we will need to close <span class="No-Break">PowerShell first.</span></p>
			<p>We may also see PowerShell modules written in CDXML, an XML wrapper for Common Information Model commands. This used to be quite common for Windows administration modules, but it is largely deprecated now since modules written this way are slower to load and run than script modules due to the extra effort required to parse the XML into PowerShell, which then itself needs parsing. In the words of the official documentation, “<em class="italic">Avoid CDXML.</em>” Similarly, we may see references to PowerShell SnapIns. These are deprecated forms of Windows PowerShell that aren’t supported in PowerShell 7, so we don’t need to worry <span class="No-Break">about them.</span></p>
			<p>There’s one more type of module for us to consider – the manifest module. A manifest module is a script or binary module that includes a module manifest. That’s what we’re going to look at in<a id="_idIndexMarker839"/> the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor230"/>Module manifests</h1>
			<p>The script modules <a id="_idIndexMarker840"/>we’ve been playing with so far are monolithic single files, either standalone or nested. That’s fine for hobbyist use, but it’s not great in a production environment, where we might want to split our functions into separate files and include version information and a whole bunch of other metadata and resources, such as XML formatting files or binaries. To organize a more complex module, we need a document that explains how it is to be loaded and implemented; this document is called a module manifest, and it is a hash table saved with a <strong class="source-inline">.psd1</strong> extension. Let’s have a look at an example. if we browse to the PowerShellGet module in <strong class="source-inline">C:\Program Files\PowerShell\7\Modules</strong> (or <strong class="source-inline">/opt/microsoft/PowerShell/7/Modules</strong> in Linux), we will see the following files <span class="No-Break">and folders:</span></p>
			<div>
				<div id="_idContainer211" class="IMG---Figure">
					<img src="image/B17600_11_014.jpg" alt="Figure 11.14 – The PowerShellGet module"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – The PowerShellGet module</p>
			<p>As we can see, there are four files and three folders. These folders contain several <strong class="source-inline">.psm1</strong> and <strong class="source-inline">.psd1</strong> files that define functions and manifests for nested modules. The main code for the module is in <strong class="source-inline">PSModule.psm1</strong>. <strong class="source-inline">PSGet.Format.ps1xml</strong> contains formatting information for displaying the output of functions. <strong class="source-inline">PowerShellGet.psd1</strong> is the module manifest. <strong class="source-inline">PSGet.Resource.psd1</strong> is a set of output strings for the module to use; we won’t worry about it here. If we open the <strong class="source-inline">PSModule.psm1</strong> file, we will see it is written in PowerShell, not C#, so it is a script module. It’s a big file, with a lot of functions defined in it. Let’s take a look at the <span class="No-Break"><strong class="source-inline">PowerShellGet.psd1</strong></span><span class="No-Break"> file.</span></p>
			<p>The first thing to note is that it is given the same name as the folder it’s housed in. This is deliberate; if there is a manifest present in a module folder, it must have the same name as the folder; otherwise, the module won’t load. Giving the same name to the <strong class="source-inline">.psm1</strong> file, in the absence of a manifest, allows PowerShell to easily find it for autoloading, but otherwise, this doesn’t matter. It’s different <span class="No-Break">for manifests.</span></p>
			<p>Let’s open it up and <span class="No-Break">look inside:</span></p>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="image/B17600_11_015.jpg" alt="Figure 11.15 – The PowerShellGet manifest"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15 – The PowerShellGet manifest</p>
			<p>On line 1, we can see<a id="_idIndexMarker841"/> that this is a hash table from <strong class="source-inline">@{</strong>, and that everything after that takes the format of a key-value pair. As we can see, this is a long file with a lot of information in it; over 200 lines, although much of this is a big blob of text with the <span class="No-Break"><strong class="source-inline">ReleaseNotes</strong></span><span class="No-Break"> key.</span></p>
			<p>A manifest consists of up to 37 different key-value pairs that may contain strings or arrays. We can add additional code to a manifest, including comparison and arithmetic operators, basic data types, and the <strong class="source-inline">if</strong> statement, but we’re not going to cover that here; I’ve never needed to do it. Let’s create a new manifest for ourselves and see what’s <span class="No-Break">in it.</span></p>
			<p>In a suitable directory, create a folder called <strong class="source-inline">ManifestModule</strong>. Now, open a PowerShell session and type the <span class="No-Break">following cmdlet:</span></p>
			<pre class="console">
New-ModuleManifest</pre>			<p>At the prompt, supply the path and the name of the new manifest file, <span class="No-Break">like this:</span></p>
			<pre class="console">
C:\temp\poshbook\ch11\ManifestModule\ManifestModule.psd1</pre>			<p>That’s it – this creates a new manifest file for a module called <strong class="source-inline">ManifestModule</strong>. Let’s open it up<a id="_idIndexMarker842"/> in <span class="No-Break">VS Code:</span></p>
			<div>
				<div id="_idContainer213" class="IMG---Figure">
					<img src="image/B17600_11_016.jpg" alt="Figure 11.16 – A basic module manifest"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16 – A basic module manifest</p>
			<p>The first thing to notice is that some of the values have been generated for you. <strong class="source-inline">ModuleVersion</strong> is <strong class="source-inline">0.0.1</strong>, there is an autogenerated <strong class="source-inline">GUID</strong> to ensure that this module can be differentiated from any other modules with the same name, and the <strong class="source-inline">Author</strong>, <strong class="source-inline">CompanyName</strong>, and <strong class="source-inline">Copyright</strong> keys are populated. Other than that, everything is empty and generally <span class="No-Break">remarked out.</span></p>
			<p>The keys in a manifest fall into three groups that cover the <span class="No-Break">following aspects:</span></p>
			<ul>
				<li><strong class="bold">Production data</strong>: Who<a id="_idIndexMarker843"/> wrote it, when, who for, and what sort of systems it will <span class="No-Break">run on.</span></li>
				<li><strong class="bold">Module construction</strong>: Broadly separated into what to load and what to export, these keys cover the loading of nested modules, formatting information, type information, and assemblies. They also define which functions, variables, and aliases are exported. <strong class="source-inline">RootModule</strong> defines the main module file that calls everything else – the main <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">psm1</strong></span><span class="No-Break"> file.</span></li>
				<li><strong class="bold">Module content</strong>: These are lists of all the modules, files, and other assets that are included in the module. These keys are optional, but generally, they should be <span class="No-Break">populated accurately.</span></li>
			</ul>
			<p>We can populate the keys when we call the <strong class="source-inline">New-ModuleManifest</strong> cmdlet, by adding the key name as <span class="No-Break">a parameter:</span></p>
			<pre class="console">
New-ModuleManifest -Path 'C:\temp\newmodule\newmodule.psd1' -ModuleVersion '1.0.0'</pre>			<p>The alternative is to edit the manifest file directly in a text editor or VS Code. If we edit it directly, there is<a id="_idIndexMarker844"/> always the possibility of mistyping something and breaking the file, so it’s a good idea to test our edited manifest, <span class="No-Break">like this:</span></p>
			<pre class="console">
Test-ModuleManifest -Path 'C:\temp\newmodule\newmodule.psd1'</pre>			<p>We can see the results in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="image/B17600_11_017.jpg" alt="Figure 11.17 – Testing a module manifest file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.17 – Testing a module manifest file</p>
			<p>If the module’s information is returned, then the file has been <span class="No-Break">formatted correctly.</span></p>
			<p>As we’ve seen, module construction can get complicated pretty quickly. Let’s finish this chapter by taking a<a id="_idIndexMarker845"/> look at a tool that can make it very much easier – <span class="No-Break">Plaster.</span></p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor231"/>Using scaffolding tools such as Plaster</h1>
			<p>If we are<a id="_idIndexMarker846"/> working long-term on a module, or collaborating with<a id="_idIndexMarker847"/> other people, then it’s a really good idea to use a framework that splits everything up into separate files and assets. This is where a scaffolding tool comes in. My choice of tool is Plaster, a module that was originally produced by Microsoft but is now maintained by PowerShell.Org, one of the most prolific online <span class="No-Break">PowerShell communities.</span></p>
			<p>Plaster uses a template file that consists of a manifest (similar to the module manifest) and a set of content files and directories. The template is written in XML and is highly customizable. The manifest has <span class="No-Break">three sections:</span></p>
			<ul>
				<li>Metadata, which contains information about the template, such as its name, version, <span class="No-Break">and author</span></li>
				<li>Parameters, which defines choices that the user can make about their module structure – what files and folders to create <span class="No-Break">and include</span></li>
				<li>Content, which specifies the actions that Plaster will perform – copying files, modifying files, and checking that required modules <span class="No-Break">are installed.</span></li>
			</ul>
			<p>Let’s start by installing the module from the PowerShell gallery. Type the following to download <span class="No-Break">the module:</span></p>
			<pre class="console">
Install-Module Plaster</pre>			<p>We may need to acknowledge that the PowerShell gallery is an untrusted repository. Now, let’s import <span class="No-Break">the module:</span></p>
			<pre class="console">
Import-Module Plaster</pre>			<p>And that’s it – we’re ready to go. Let’s see what <span class="No-Break">we’ve got:</span></p>
			<div>
				<div id="_idContainer215" class="IMG---Figure">
					<img src="image/B17600_11_018.jpg" alt="Figure 11.18 – Examining the Plaster module"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.18 – Examining the Plaster module</p>
			<p>As we can see, we’ve <a id="_idIndexMarker848"/>installed version 1.1.4 of the module, and <a id="_idIndexMarker849"/>we’ve got four new commands to <span class="No-Break">play with:</span></p>
			<ul>
				<li><strong class="source-inline">Get-PlasterTemplate</strong>: This lists the existing templates available for us to use. We can write or download templates as XML files. Only two are included, and the one we need <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">NewPowerShellScriptModule</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">Invoke-Plaster</strong>: This runs the Plaster <span class="No-Break">scaffolding tool.</span></li>
				<li><strong class="source-inline">New-PlasterManifest</strong>: This command creates a <span class="No-Break">new manifest.</span></li>
				<li><strong class="source-inline">Test-PlasterManifest</strong>: This command tests that the manifest is <span class="No-Break">formatted correctly.</span></li>
			</ul>
			<p>Let’s run it and see what <span class="No-Break">we get:</span></p>
			<pre class="console">
Get-PlasterTemplate</pre>			<p>Then, copy the path for <strong class="source-inline">NewPowerShellScriptModule</strong>. Now, type <span class="No-Break">the following:</span></p>
			<pre class="console">
Invoke-Plaster</pre>			<p>You’ll be asked for the path to the default template and then a destination path; this needs to be a folder, not <span class="No-Break">a file.</span></p>
			<p>You’ll also be asked to provide the module’s name and version, as well as whether you want to set VS Code as the default editor. Here’s how it looked <span class="No-Break">for me:</span></p>
			<div>
				<div id="_idContainer216" class="IMG---Figure">
					<img src="image/B17600_11_019.jpg" alt="Figure 11.19 – Invoking Plaster"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.19 – Invoking Plaster</p>
			<p>As we can see, one of the required modules, Pester, is missing from my sandbox machine. Pester is<a id="_idIndexMarker850"/> a <a id="_idIndexMarker851"/>module that makes it a breeze to do unit testing and test-driven development, but it’s a bit beyond the scope of <span class="No-Break">this book.</span></p>
			<p>Let’s see what has been created in the <span class="No-Break">destination path:</span></p>
			<div>
				<div id="_idContainer217" class="IMG---Figure">
					<img src="image/B17600_11_020.jpg" alt="Figure 11.20 – A module created with the default Plaster template"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.20 – A module created with the default Plaster template</p>
			<p>As we can see, Plaster has created two files – a script module file and a module manifest file – a folder for test scripts, and a folder for VS <span class="No-Break">Code settings.</span></p>
			<p>The <strong class="source-inline">NewPlasterModule.psm1</strong> file looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer218" class="IMG---Figure">
					<img src="image/B17600_11_021.jpg" alt="Figure 11.21 – A basic module file generated by Plaster"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.21 – A basic module file generated by Plaster</p>
			<p>As we can see, it’s very simple, but it includes a great trick – if the functions in the file are named with standard cmdlet naming conventions, such as <strong class="source-inline">Verb-Noun</strong>, then they will be exported. If they are not, like the <strong class="source-inline">setMessage</strong> function we wrote earlier in this chapter, then they will not be <span class="No-Break">exported. Neat.</span></p>
			<p>The beauty of Plaster is how extensible it is; it’s easy to write templates to create folder structures for public and private functions and classes, and it can all be done in a repeatable way. To get some idea of how versatile Plaster is, have a look at Kevin Marquette’s blog at <a href="https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/">https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/</a> and his GitHub page at <a href="https://github.com/KevinMarquette/PlasterTemplates">https://github.com/KevinMarquette/PlasterTemplates</a>. Have a play with his <span class="No-Break">example templates.</span></p>
			<p>That is as much as we’re going to cover regarding Plaster – there are several other scaffolding <a id="_idIndexMarker852"/>modules <a id="_idIndexMarker853"/>available, so if you don’t like Plaster, take a look at some of the others. That also wraps up this chapter; let’s recap what <span class="No-Break">we’ve done.</span></p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor232"/>Summary</h1>
			<p>We started this chapter by reminding ourselves of what we learned in earlier chapters regarding modules and placing that into a more formal context. We looked at the standard module locations and how we can add locations by editing the <strong class="source-inline">$ENV:PSModulePath</strong> variable. We saw how PowerShell uses these locations to facilitate autoloading, and we saw how sometimes, we might not want that to happen. Then, we looked at how we can manually import modules and finished up our review by looking at the <span class="No-Break"><strong class="source-inline">PowerShellGet</strong></span><span class="No-Break"> module.</span></p>
			<p>After, we started to write our own modules. We began by looking at the earliest method for importing code, known as dot-sourcing, and saw why that could be a bad idea. Then, we created our first module by writing a script and converting it. Next, we looked at how we can build applications by nesting modules, before discussing some other types of modules, such as <span class="No-Break">binary modules.</span></p>
			<p>Then, we looked at the most common complex module type – the manifest module. We saw how the manifest file controls what is loaded and exported, and how to write and test a manifest file. Finally, we looked at a tool that can make writing modules much simpler – <span class="No-Break">Plaster.</span></p>
			<p>In the next chapter, we are going to look at the security aspects of PowerShell, and how we can best go about making ourselves and our colleagues and users safe with such a <span class="No-Break">powerful tool.</span></p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor233"/>Exercises</h1>
			<p>Here are the exercis<a id="_idTextAnchor234"/>es for <span class="No-Break">this chapter:</span></p>
			<ol>
				<li>How can you list all imported modules in the current <span class="No-Break">PowerShell session?</span></li>
				<li>What is the purpose of the <strong class="source-inline">-Global</strong> parameter when importing <span class="No-Break">a module?</span></li>
				<li>How do we import a module that isn’t in a path specified in the <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">ENV:PSModulePath</strong></span><span class="No-Break"> variable?</span></li>
				<li>We want to import a module that contains functions that have the same name as cmdlets that already exist in our session. What are two ways we can get <span class="No-Break">around this?</span></li>
				<li>By default, all the functions of a module are exported. What are two ways we can control what functions <span class="No-Break">are exported?</span></li>
				<li>What is the purpose of the <strong class="source-inline">HelpInfoURI</strong> key in a <span class="No-Break">module manifest?</span></li>
				<li>What might be in a file with <span class="No-Break">the</span><span class="No-Break"><strong class="source-inline">.ps1xml</strong></span><span class="No-Break"> extension?</span></li>
				<li>If we load a module with the <strong class="source-inline">.dll</strong> extension, what sort of commands will <span class="No-Break">we get?</span></li>
				<li>Why don’t we write <span class="No-Break">CDXML modules?</span></li>
			</ol>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor235"/>Further reading</h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the <span class="No-Break">following resources:</span></p>
			<ul>
				<li><strong class="source-inline">PowerShellGet</strong> and <span class="No-Break">its replacement:</span><ul><li><a href="https://devblogs.microsoft.com/powershell/powershellget-in-powershell-7-4-updates/"><span class="No-Break">https://devblogs.microsoft.com/powershell/powershellget-in-powershell-7-4-updates/</span></a></li><li><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.psresourceget/?view=powershellget-3.x"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.psresourceget/?view=powershellget-3.x</span></a></li><li><a href="https://learn.microsoft.com/en-us/powershell/module/powershellget/?view=powershellget-2.x"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/powershellget/?view=powershellget-2.x</span></a></li></ul></li>
				<li>Writing module <span class="No-Break">manifests: </span><a href="https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest</span></a></li>
				<li><span class="No-Break">Plaster: </span><a href="https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/#template-folder-and-file-structure"><span class="No-Break">https://powershellexplained.com/2017-05-12-Powershell-Plaster-adventures-in/#template-folder-and-file-structure</span></a></li>
			</ul>
		</div>
	</body></html>