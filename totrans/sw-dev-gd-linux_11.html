<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer062">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 class="chapterTitle" id="_idParaDest-204"><span class="koboSpan" id="kobo.2.1">Pipes and Redirection</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">In this chapter, you’re going to learn how to harness one of the most powerful computing concepts in existence: pipes! </span><span class="koboSpan" id="kobo.3.2">Pipes</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.4.1"> can be used to connect commands, building up complex, customized flows that accomplish a specific task. </span><span class="koboSpan" id="kobo.4.2">By the end of the chapter, you’ll be able to understand (or compose) something like this:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5.1">history | awk '{print $2}' | sort | uniq -c | sort -rn | head -n 10
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6.1">In case you’re curious, this prints out a top-10 list of your most commonly used shell commands; on my machine, it produces this output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.7.1">1000 git
 115 ls
 102 go
  83 gpo (an alias I've set up for pushing a local git branch to the origin)
  68 make
  65 cd
  59 docker
  42 vagrant
  35 GOOS=linux
  30 echo
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.8.1">To really understand pipes, you need to first understand file descriptors and input/output redirection, so that’s where we’ll start. </span><span class="koboSpan" id="kobo.8.2">Some of the information in this chapter is quite dense; just take your time and try out all the examples to make sure you understand everything. </span><span class="koboSpan" id="kobo.8.3">The time you invest in learning these concepts now will save you many hours throughout your career.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">In this chapter, we’ll cover the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">File descriptors</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Connecting commands together with pipes (</span><code class="inlineCode"><span class="koboSpan" id="kobo.12.1">|</span></code><span class="koboSpan" id="kobo.13.1">)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">The CLI tools you need to know</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Practical pipe patterns</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Inspecting file descriptors</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-205"><span class="koboSpan" id="kobo.17.1">File descriptors</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.18.1">You’re </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.19.1">probably familiar with file handles (also known as </span><em class="italic"><span class="koboSpan" id="kobo.20.1">file descriptors</span></em><span class="koboSpan" id="kobo.21.1">) from your software engineering experience. </span><span class="koboSpan" id="kobo.21.2">If not, we recommend you check out </span><em class="chapterRef"><span class="koboSpan" id="kobo.22.1">Chapter 5</span></em><em class="italic"><span class="koboSpan" id="kobo.23.1">, Introducing Files</span></em><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">In short, if your program needs to read or write a file on the operating system, opening that file gives you a “file handle” to it – a pointer, or reference, to that file object.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.25.1">Because the operating system mediates all access to system resources like files, it tracks which file handles, or descriptors, your program is actively referencing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.26.1">But even if a process doesn’t touch a single file on the operating system, it’s got some file handles open. </span><span class="koboSpan" id="kobo.26.2">In Unix-like operating systems, every process has at least three file descriptors:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.27.1">stdin</span></code><span class="koboSpan" id="kobo.28.1">: standard input - or, </span><code class="inlineCode"><span class="koboSpan" id="kobo.29.1">fd 0</span></code><span class="koboSpan" id="kobo.30.1"> (“file descriptor zero”)</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.31.1">stdout</span></code><span class="koboSpan" id="kobo.32.1">: standard output - or, </span><code class="inlineCode"><span class="koboSpan" id="kobo.33.1">fd 1</span></code><span class="koboSpan" id="kobo.34.1"> (“file descriptor one”)</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.35.1">stderr</span></code><span class="koboSpan" id="kobo.36.1">: standard error - or, </span><code class="inlineCode"><span class="koboSpan" id="kobo.37.1">fd 2</span></code><span class="koboSpan" id="kobo.38.1"> (“file descriptor two”)</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.39.1">These first three file descriptors function as standard communication channels to (and from) a process. </span><span class="koboSpan" id="kobo.39.2">As a result, they exist in the same order for every process created on the system. </span><span class="koboSpan" id="kobo.39.3">The first always points to a file which will be used to read in input. </span><span class="koboSpan" id="kobo.39.4">The second points to a file that will be used for writing output. </span><span class="koboSpan" id="kobo.39.5">And the third references a file that will receive error output.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.40.1">Optionally, after those first three standard file descriptors, there can be any number of other file descriptors/handles, based on what the program is doing. </span><span class="koboSpan" id="kobo.40.2">Your process could have:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.41.1">Files it’s working with</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.42.1">Sockets it’s reading from or writing to (think Unix or TCP sockets being written to for networking)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.43.1">Devices like keyboards or disks it needs to use</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-206"><span class="koboSpan" id="kobo.44.1">What do these file descriptors reference?</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.45.1">You now know, from the </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.46.1">perspective of a process, what these file descriptors are used for:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.47.1">0</span></code><span class="koboSpan" id="kobo.48.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.49.1">STDIN</span></code><span class="koboSpan" id="kobo.50.1">): get input from here</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.51.1">1</span></code><span class="koboSpan" id="kobo.52.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.53.1">STDOUT</span></code><span class="koboSpan" id="kobo.54.1">): put regular output here</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.55.1">2</span></code><span class="koboSpan" id="kobo.56.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.57.1">STDERR</span></code><span class="koboSpan" id="kobo.58.1">): put error output here</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.59.1">But if we zoom outside of a single process, which files are these file descriptors actually pointing to? </span><span class="koboSpan" id="kobo.59.2">Where does input come from, and where do output and errors get written to?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.60.1">Let’s use a Bash shell process as an example: by default, it takes input (STDIN) from your terminal (which is represented by a file on the filesystem). </span><span class="koboSpan" id="kobo.60.2">Bash prints output and errors to the same terminal. </span><span class="koboSpan" id="kobo.60.3">In essence, your entire shell session is happening via read and write operations to a single file. </span><span class="koboSpan" id="kobo.60.4">You’ll learn much more about Bash in the next chapter, </span><em class="italic"><span class="koboSpan" id="kobo.61.1">Automating Tasks with Shell Scripts</span></em><span class="koboSpan" id="kobo.62.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.63.1">Let’s look at this kind of input and output redirection in more detail.</span></p>
<h1 class="heading-1" id="_idParaDest-207"><span class="koboSpan" id="kobo.64.1">Input and output redirection (or, playing with file descriptors for fun and profit)</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.65.1">This knowledge comes in handy quite often during real-life development tasks: every time you want to avoid typing lots of input and take it from a file instead, or when you want to log the output of a program, and many more situations. </span><span class="koboSpan" id="kobo.65.2">When you create a process, you can control where its three standard file descriptors point, with powerful results.</span></p>
<h2 class="heading-2" id="_idParaDest-208"><span class="koboSpan" id="kobo.66.1">Input redirection: &lt;</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.67.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.68.1">&lt;</span></code><span class="koboSpan" id="kobo.69.1"> (less-than) symbol </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.70.1">lets you control where a process gets its input from. </span><span class="koboSpan" id="kobo.70.2">For example, you’re used to giving input to Bash with your keyboard, one command at a time. </span><span class="koboSpan" id="kobo.70.3">Let’s try giving Bash input from a file, instead!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.71.1">Assume I have a file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.72.1">commands.txt</span></code><span class="koboSpan" id="kobo.73.1"> with the following content (I’m using </span><code class="inlineCode"><span class="koboSpan" id="kobo.74.1">cat</span></code><span class="koboSpan" id="kobo.75.1"> here to print out my example file):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.76.1"># cat commands.txt
pwd
echo "hello there, friends"
echo $SHELL
cd /tmp
pwd
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.77.1">These are </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.78.1">valid shell commands, as far as Bash is concerned, so I’m going to launch a new Bash process and use this file as standard input:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.79.1"># bash &lt; commands.txt
/tmp/gopsinspect
hello there, friends
/bin/bash
/tmp
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.80.1">Instead of prompting me for input and waiting until I give it, Bash reads and executes one line at a time: it reads input from the file until it comes across a newline (</span><code class="inlineCode"><span class="koboSpan" id="kobo.81.1">\n</span></code><span class="koboSpan" id="kobo.82.1">) character, and just as if you’d hit the </span><em class="italic"><span class="koboSpan" id="kobo.83.1">RETURN</span></em><span class="koboSpan" id="kobo.84.1"> key, it executes the command.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.85.1">In this example, the program’s standard output is still going back to our terminal, where we can read it. </span><span class="koboSpan" id="kobo.85.2">Let’s change that now.</span></p>
<h2 class="heading-2" id="_idParaDest-209"><span class="koboSpan" id="kobo.86.1">Output redirection: &gt;</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.87.1">We</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.88.1"> want to redirect </span><code class="inlineCode"><span class="koboSpan" id="kobo.89.1">STDOUT</span></code><span class="koboSpan" id="kobo.90.1"> (file descriptor </span><code class="inlineCode"><span class="koboSpan" id="kobo.91.1">1</span></code><span class="koboSpan" id="kobo.92.1">) to a file instead of a terminal, logging the output of each command instead of printing it out to the terminal in real time:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.93.1"># bash &lt; commands.txt &gt; output.log
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.94.1">Notice that there is no visible output in the terminal now – because the </span><code class="inlineCode"><span class="koboSpan" id="kobo.95.1">&gt;</span></code><span class="koboSpan" id="kobo.96.1"> character has redirected output to </span><code class="inlineCode"><span class="koboSpan" id="kobo.97.1">output.log</span></code><span class="koboSpan" id="kobo.98.1">. </span><span class="koboSpan" id="kobo.98.2">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.99.1">cat</span></code><span class="koboSpan" id="kobo.100.1"> to print out the log file and confirm that it contains the expected output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.101.1"># cat output.log
/tmp/gopsinspect
hello there, friends
/bin/bash
/tmp
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.102.1">Interestingly, you’ll notice that because file descriptor </span><code class="inlineCode"><span class="koboSpan" id="kobo.103.1">1</span></code><span class="koboSpan" id="kobo.104.1"> is standard output, writing </span><code class="inlineCode"><span class="koboSpan" id="kobo.105.1">&gt;</span></code><span class="koboSpan" id="kobo.106.1"> is the same as writing </span><code class="inlineCode"><span class="koboSpan" id="kobo.107.1">1&gt;</span></code><span class="koboSpan" id="kobo.108.1">. </span><span class="koboSpan" id="kobo.108.2">You’ll rarely see a </span><code class="inlineCode"><span class="koboSpan" id="kobo.109.1">1</span></code><span class="koboSpan" id="kobo.110.1"> used, because it’s assumed that standard output is being redirected. </span><span class="koboSpan" id="kobo.110.2">In other words:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.111.1">date &gt; mydate.log
is equivalent to writing
date 1&gt; mydate.log
</span></code></pre>
<h3 class="heading-3" id="_idParaDest-210"><span class="koboSpan" id="kobo.112.1">Use &gt;&gt; to append output without overwriting</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.113.1">In the previous</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.114.1"> example, we created a log file by redirecting command output with </span><code class="inlineCode"><span class="koboSpan" id="kobo.115.1">&gt;</span></code><span class="koboSpan" id="kobo.116.1">. </span><span class="koboSpan" id="kobo.116.2">If you run the example a few times, you’ll notice that the log file doesn’t grow at all. </span><span class="koboSpan" id="kobo.116.3">Each time you redirect output to a file with </span><code class="inlineCode"><span class="koboSpan" id="kobo.117.1">&gt; filename</span></code><span class="koboSpan" id="kobo.118.1">, anything in that file will be overwritten.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.119.1">To avoid that – as in the case of a long-lived log file that collects output from more than a single process or command – use </span><code class="inlineCode"><span class="koboSpan" id="kobo.120.1">&gt;&gt;</span></code><span class="koboSpan" id="kobo.121.1"> (append). </span><span class="koboSpan" id="kobo.121.2">This will simply append to your output file, instead of overwriting its entire contents each time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.122.1">We’ll cover Bash scripts in more detail in a later chapter, but for now, here’s a quick script that writes a timestamp of the current time to a log file once per second:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.123.1">while true; do
    date &gt;&gt; /tmp/date.log
    sleep 1
done
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.124.1">In this example script, we create an infinite loop (while true; do [ ... </span><span class="koboSpan" id="kobo.124.2">] done) which runs the date command. </span><span class="koboSpan" id="kobo.124.3">It redirects the output of this command to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.125.1">/tmp/date.log</span></code><span class="koboSpan" id="kobo.126.1"> file using </span><code class="inlineCode"><span class="koboSpan" id="kobo.127.1">&gt;&gt;</span></code><span class="koboSpan" id="kobo.128.1">, which appends the output to the file (</span><code class="inlineCode"><span class="koboSpan" id="kobo.129.1">&gt;</span></code><span class="koboSpan" id="kobo.130.1"> would overwrite the file each time). </span><span class="koboSpan" id="kobo.130.2">Then, the script sleeps for one second, and starts again from the beginning.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.131.1">Running the </span><code class="inlineCode"><span class="koboSpan" id="kobo.132.1">date</span></code><span class="koboSpan" id="kobo.133.1"> command once produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.134.1">→  ~ date
Sat Jan  6 16:39:37 EST 2024
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.135.1">Running this script, on the other hand, does nothing visible at first, because the output is being redirected to a file. </span><span class="koboSpan" id="kobo.135.2">Here’s what it looks like when I paste this little script into my terminal, let it run for a bit, kill it with </span><em class="keystroke"><span class="koboSpan" id="kobo.136.1">Ctrl </span></em><span class="koboSpan" id="kobo.137.1">+ </span><em class="keystroke"><span class="koboSpan" id="kobo.138.1">C</span></em><span class="koboSpan" id="kobo.139.1">, and then print out the contents of the file it created:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.140.1">→  ~ while true; do
    date &gt;&gt; /tmp/date.log
    sleep 1
done
^C%
→  ~ cat /tmp/date.log
Sat Jan  6 16:44:01 EST 2024
Sat Jan  6 16:44:02 EST 2024
Sat Jan  6 16:44:03 EST 2024
[ ... </span><span class="koboSpan" id="kobo.140.2">]
Sat Jan  6 16:44:08 EST 2024
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.141.1">You’ll use this kind of simple output redirection in all kinds of everyday situations, like creating an ad hoc log file for a quick debug script you throw together.</span></p>
<h2 class="heading-2" id="_idParaDest-211"><span class="koboSpan" id="kobo.142.1">Error redirection with 2&gt;</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.143.1">Many </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.144.1">command-line programs that have a lot of expected output will also output occasional errors – think of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.145.1">find</span></code><span class="koboSpan" id="kobo.146.1"> command that encounters occasional “permission denied” errors for directories you’re not allowed to peek inside.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.147.1">Although these kinds of errors are minor and expected, you don’t want them mixed in with everything else, polluting your output. </span><span class="koboSpan" id="kobo.147.2">This becomes especially important when you’re not using command-line tools interactively, but rather writing small scripts or larger programs that process the output of the commands you’re running.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.148.1">You’ve seen how to redirect Standard Input (</span><code class="inlineCode"><span class="koboSpan" id="kobo.149.1">fd 0</span></code><span class="koboSpan" id="kobo.150.1">) and Standard Output (</span><code class="inlineCode"><span class="koboSpan" id="kobo.151.1">fd 1</span></code><span class="koboSpan" id="kobo.152.1">). </span><span class="koboSpan" id="kobo.152.2">Let’s look at how to redirect Standard Error (</span><code class="inlineCode"><span class="koboSpan" id="kobo.153.1">fd 2</span></code><span class="koboSpan" id="kobo.154.1">) using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.155.1">2&gt;</span></code><span class="koboSpan" id="kobo.156.1"> (redirect file descriptor 2) syntax:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.157.1">find /etc/ -name php.ini &gt; /tmp/phpinis.log 2&gt;/dev/null
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.158.1">This command searches for any files named </span><code class="inlineCode"><span class="koboSpan" id="kobo.159.1">php.ini</span></code><span class="koboSpan" id="kobo.160.1"> inside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.161.1">/etc</span></code><span class="koboSpan" id="kobo.162.1"> directory tree. </span><span class="koboSpan" id="kobo.162.2">The files it finds (</span><code class="inlineCode"><span class="koboSpan" id="kobo.163.1">find</span></code><span class="koboSpan" id="kobo.164.1">'s </span><code class="inlineCode"><span class="koboSpan" id="kobo.165.1">STDOUT</span></code><span class="koboSpan" id="kobo.166.1">) are written to </span><code class="inlineCode"><span class="koboSpan" id="kobo.167.1">/tmp/phpinis.log</span></code><span class="koboSpan" id="kobo.168.1">, and any errors it encounters are ignored by sending them to a special file called </span><code class="inlineCode"><span class="koboSpan" id="kobo.169.1">/dev/null</span></code><span class="koboSpan" id="kobo.170.1">.</span></p>
<div class="packt_tip">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.171.1">Tip</span></strong></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.172.1">/dev/null</span></code><span class="koboSpan" id="kobo.173.1"> is a special file-like object that returns zeros when you try to read from it and ignores anything written to it – it’s used as a kind of garbage dump for output that engineers want to silence or ignore. </span><span class="koboSpan" id="kobo.173.2">You’ll see it used quite often in scripts.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.174.1">Now that you’ve seen input and output redirection, let’s look at pipes, which put both of those concepts together: they redirect the output of one command to the input of another.</span></p>
<h1 class="heading-1" id="_idParaDest-212"><span class="koboSpan" id="kobo.175.1">Connecting commands together with pipes (|)</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.176.1">You’ve</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.177.1"> learned how to redirect each of the three standard file descriptors to various locations and seen why that’s often useful. </span><span class="koboSpan" id="kobo.177.2">But what if, instead of just redirecting input and output to and from various files, you wanted to connect </span><em class="italic"><span class="koboSpan" id="kobo.178.1">multiple programs</span></em><span class="koboSpan" id="kobo.179.1"> together?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.180.1">On the command line, you can use the pipe character (</span><code class="inlineCode"><span class="koboSpan" id="kobo.181.1">|</span></code><span class="koboSpan" id="kobo.182.1">) to connect the output of one program to the input of another program. </span><span class="koboSpan" id="kobo.182.2">This is an extremely powerful paradigm that is heavily used in Unix and Linux to create custom sorting, filtering, and processing commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.183.1">echo -e "some text \n treasure found \n some more text" | grep treasure
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.184.1">If you paste this into your shell, you’ll see </span><code class="inlineCode"><span class="koboSpan" id="kobo.185.1">treasure found</span></code><span class="koboSpan" id="kobo.186.1"> printed out. </span><span class="koboSpan" id="kobo.186.2">Here’s what happened:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.187.1">The first command, </span><code class="inlineCode"><span class="koboSpan" id="kobo.188.1">echo</span></code><span class="koboSpan" id="kobo.189.1">, runs and produces the output you see between double quotes (the newline characters make this a 3-line string).</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.190.1">The pipe character streams that output (file descriptor 1) to the input of the next command (file descriptor 0), </span><code class="inlineCode"><span class="koboSpan" id="kobo.191.1">grep</span></code><span class="koboSpan" id="kobo.192.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">grep</span></code><span class="koboSpan" id="kobo.194.1">'s input is now hooked up to the output of the previous command.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.195.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.196.1">grep</span></code><span class="koboSpan" id="kobo.197.1"> command looks at each newline-delimited line in turn and finds a match for </span><code class="inlineCode"><span class="koboSpan" id="kobo.198.1">treasure</span></code><span class="koboSpan" id="kobo.199.1"> on the second line. </span><code class="inlineCode"><span class="koboSpan" id="kobo.200.1">grep</span></code><span class="koboSpan" id="kobo.201.1"> prints that second line to its standard output.</span></li>
</ol>
<h2 class="heading-2" id="_idParaDest-213"><span class="koboSpan" id="kobo.202.1">Multi-pipe commands</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.203.1">Here’s</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.204.1"> the – fairly extreme – example you saw at the beginning of the chapter:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.205.1">history | awk '{print $2}' | sort | uniq -c | sort -rn | head -n 10 &gt; /tmp/top10commands
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.206.1">Each pipe in this complex command simply takes the output of the previous command (</span><code class="inlineCode"><span class="koboSpan" id="kobo.207.1">STDOUT</span></code><span class="koboSpan" id="kobo.208.1">) and uses it as the input (</span><code class="inlineCode"><span class="koboSpan" id="kobo.209.1">STDIN</span></code><span class="koboSpan" id="kobo.210.1">) for the next command.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.211.1">Piping the</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.212.1"> output of one command into the input of another is what enables these kinds of flows, filtering and sorting the data streaming between these commands without actually having to write any custom software. </span><span class="koboSpan" id="kobo.212.2">Just because there’s no program called </span><code class="inlineCode"><span class="koboSpan" id="kobo.213.1">top10commands</span></code><span class="koboSpan" id="kobo.214.1"> doesn’t mean you can’t quickly cobble one together with existing, standard commands like this.</span></p>
<h3 class="heading-3" id="_idParaDest-214"><span class="koboSpan" id="kobo.215.1">Reading (and building) complex multi-pipe commands</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.216.1">No </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.217.1">matter how complex or magical some of the piped-together commands you encounter will seem, they were all built the</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.218.1"> same way: one command at a time. </span><span class="koboSpan" id="kobo.218.2">Whether you’re trying to read a complex series of commands like this or creating one of your own, the process is the same:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.219.1">Take the first command and make sure you understand what it does, at a basic level. </span><span class="koboSpan" id="kobo.219.2">Scan the man page or other documentation if you aren’t familiar with it.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.220.1">Run the command and inspect its output.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.221.1">Add the pipe and the command following it.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.222.1">Repeat from </span><em class="italic"><span class="koboSpan" id="kobo.223.1">step 1</span></em><span class="koboSpan" id="kobo.224.1"> until you’ve made it all the way through the commands.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.225.1">You’ll see that even the scariest shell/pipe monstrosities become manageable when you apply this process. </span><span class="koboSpan" id="kobo.225.2">Always remember that you’re just dealing with a data stream, which flows through the pipes from command to command, being shaped, modified, filtered, redirected, and transformed along the way.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.226.1">We’ll discuss this more in </span><em class="chapterRef"><span class="koboSpan" id="kobo.227.1">Chapter 12</span></em><span class="koboSpan" id="kobo.228.1">, </span><em class="italic"><span class="koboSpan" id="kobo.229.1">Automating Tasks with Shell Scripts</span></em><span class="koboSpan" id="kobo.230.1">, but try to be respectful of other programmers who must read your code: limit your statements to two or three pipes, and use well-named variables to store intermediate results for easy reading if your memory constraints allow it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.231.1">Now that you’ve seen how the primitives of file descriptors are exposed as easy-to-use input and output redirection, let’s look at some real-world examples of useful program combinations that rely on this composability that’s built into Unix.</span></p>
<h1 class="heading-1" id="_idParaDest-215"><span class="koboSpan" id="kobo.232.1">The CLI tools you need to know</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.233.1">Before</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.234.1"> we jump into the kinds of wild combinations that you saw at the beginning of the chapter, let’s look at some of the most common Unix helper tools that are used to filter, sort, and glue together these data streams you’ll be creating on the command line.</span></p>
<h2 class="heading-2" id="_idParaDest-216"><span class="koboSpan" id="kobo.235.1">cut</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.236.1">cut</span></code><span class="koboSpan" id="kobo.237.1"> takes</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.238.1"> a </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.239.1">delimiter (</span><code class="inlineCode"><span class="koboSpan" id="kobo.240.1">-d</span></code><span class="koboSpan" id="kobo.241.1">) and splits input on that delimiter, like </span><code class="inlineCode"><span class="koboSpan" id="kobo.242.1">String.Split()</span></code><span class="koboSpan" id="kobo.243.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.244.1">String.Fields()</span></code><span class="koboSpan" id="kobo.245.1"> in many programming languages. </span><span class="koboSpan" id="kobo.245.2">You then select which field (list element) you want to output with </span><code class="inlineCode"><span class="koboSpan" id="kobo.246.1">-f</span></code><span class="koboSpan" id="kobo.247.1">, for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.248.1">f1</span></code><span class="koboSpan" id="kobo.249.1"> for the first field.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.250.1">If you feed </span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">cut</span></code><span class="koboSpan" id="kobo.252.1"> more than one line of input, it will repeat that same operation on all lines:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.253.1">echo "this is a space-delimited line" | cut -d " " -f4
space-delimited
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.254.1">You can see how using different delimiters for cut would work, too; in the following example, we cut on the hyphen character instead of a space:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.255.1">→  ~ echo "this is a space-delimited line" | cut -d "-" -f1
this is a space
→  ~ echo "this is a space-delimited line" | cut -d "-" -f2
delimited line
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.256.1">You can see that this changes the number of fields available as well – two in this case, since there’s only one hyphen in the text. </span><span class="koboSpan" id="kobo.256.2">Trying to print the fourth field with </span><code class="inlineCode"><span class="koboSpan" id="kobo.257.1">–f4</span></code><span class="koboSpan" id="kobo.258.1">, as in the previous example, will just give you an empty line.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.259.1">To get friendly names for all users with root in their names on an macOS machine, you can use the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.260.1"># grep root /etc/passwd | cut -d ":" -f5
System Administrator
System Services
CVMS Root
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-217"><span class="koboSpan" id="kobo.261.1">sort</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.262.1">sort</span></code><span class="koboSpan" id="kobo.263.1"> does a </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.264.1">per-line sorting, alphabetical or numeric.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.265.1">Reverse-sorting</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.266.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.267.1">-r</span></code><span class="koboSpan" id="kobo.268.1"> is often useful when dealing with numeric data (</span><code class="inlineCode"><span class="koboSpan" id="kobo.269.1">-n</span></code><span class="koboSpan" id="kobo.270.1">). </span><span class="koboSpan" id="kobo.270.2">You’ll often want </span><code class="inlineCode"><span class="koboSpan" id="kobo.271.1">-rn</span></code><span class="koboSpan" id="kobo.272.1"> together (see Top X in the Practical pipe patterns section of this chapter).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.273.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.274.1">-h</span></code><span class="koboSpan" id="kobo.275.1"> flag can be very useful for sorting by human-readable output of many other commands, like this:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.276.1"># du -h | sort -rh
1.6M    .
</span><span class="koboSpan" id="kobo.276.2">1.3M    ./.git
1.2M    ./.git/objects
 60K    ./.git/hooks
 28K    ./.git/objects/d8
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-218"><span class="koboSpan" id="kobo.277.1">uniq</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.278.1">Removes</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.279.1"> duplicate lines. </span><span class="koboSpan" id="kobo.279.2">This command needs sorted data to work the way you </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.280.1">expect, otherwise it only checks whether each line is a duplicate of the previous line:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.281.1"># cat /tmp/uniq
one
two
one
one
one
seven
one
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.282.1">Default behavior; probably not what you want:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.283.1"># uniq /tmp/uniq
one
two
one
seven
one
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.284.1">uniq</span></code><span class="koboSpan" id="kobo.285.1"> skips occurrences when they follow each other but leaves them when they’re separated</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.286.1"> by other text. </span><span class="koboSpan" id="kobo.286.2">Now the same thing, with sorted data:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.287.1"># sort /tmp/uniq | uniq
one
seven
two
</span></code></pre>
<h3 class="heading-3" id="_idParaDest-219"><span class="koboSpan" id="kobo.288.1">Counting</span></h3>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.289.1">uniq</span></code><span class="koboSpan" id="kobo.290.1"> also has a </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.291.1">useful “count” option, accessible with </span><code class="inlineCode"><span class="koboSpan" id="kobo.292.1">–c</span></code><span class="koboSpan" id="kobo.293.1">. </span><span class="koboSpan" id="kobo.293.2">The same caveat about sorted input is worth restating here – for example, a file with the following content:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.294.1">arch
alpine
arch
arch
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.295.1">Will produce the following output when run through </span><code class="inlineCode"><span class="koboSpan" id="kobo.296.1">uniq -c</span></code><span class="koboSpan" id="kobo.297.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.298.1">$ uniq -c /tmp/sort1.txt
   1 arch
   1 alpine
   2 arch
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.299.1">This is not what most users expect: there are 3 occurrences of </span><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">arch</span></code><span class="koboSpan" id="kobo.301.1"> in the file, but </span><code class="inlineCode"><span class="koboSpan" id="kobo.302.1">uniq</span></code><span class="koboSpan" id="kobo.303.1"> shows two separate counts for the same word. </span><span class="koboSpan" id="kobo.303.2">To get the behavior you expect (</span><code class="inlineCode"><span class="koboSpan" id="kobo.304.1">uniq</span></code><span class="koboSpan" id="kobo.305.1"> should return output that doesn’t contain any duplicate lines), your input must be sorted.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.306.1">This is annoying for beginners, but very much in line with the Unix philosophy: tools should be small and sharp and shouldn’t duplicate functionality from each other. </span><span class="koboSpan" id="kobo.306.2">If you write a sorting tool, it should only sort, and if you write a uniquifying tool, it is allowed to depend on sorting from another tool to ensure extremely conservative (and consistent) memory usage.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.307.1">Here, we sort before using </span><code class="inlineCode"><span class="koboSpan" id="kobo.308.1">uniq</span></code><span class="koboSpan" id="kobo.309.1">, which gets us the output we expect:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.310.1">$ sort /tmp/sort1.txt | uniq -c
   1 alpine
   3 arch
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.311.1">You’ll notice that this sorts in ascending order, which isn’t what you want for the top-X list of</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.312.1"> commands you saw at the beginning of the chapter. </span><span class="koboSpan" id="kobo.312.2">To solve this, we do a “reverse numeric” sort (</span><code class="inlineCode"><span class="koboSpan" id="kobo.313.1">-rn</span></code><span class="koboSpan" id="kobo.314.1">) of this numbered list (since each line now starts with a </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.315.1">number, thanks to </span><code class="inlineCode"><span class="koboSpan" id="kobo.316.1">uniq –c</span></code><span class="koboSpan" id="kobo.317.1">, this is easy to do). </span><span class="koboSpan" id="kobo.317.2">Here’s an example of this in action, on a file with many more duplicates:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.318.1">$ sort /tmp/sortme.txt | uniq -c | sort -rn
   6 ubuntu
   4 alpine
   3 gentoo
   2 yellow dog
   2 arch
   1 suse
   1 mandrake
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-220"><span class="koboSpan" id="kobo.319.1">wc</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.320.1">With this </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.321.1">command you can measure the word, line, character, and byte input counts. </span><span class="koboSpan" id="kobo.321.2">You </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.322.1">can also count space-delimited words with </span><code class="inlineCode"><span class="koboSpan" id="kobo.323.1">-w</span></code><span class="koboSpan" id="kobo.324.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.325.1"># echo "foo bar baz" | wc -w
       3
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.326.1">Line-counting is extremely common in the following format:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.327.1"># wc -l &lt; /etc/passwd
     123
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-221"><span class="koboSpan" id="kobo.328.1">head</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">Head</span></code> <a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.330.1">returns the first lines of a stream or file – 10 lines by default. </span><span class="koboSpan" id="kobo.330.2">Specify </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.331.1">how many lines you want with </span><code class="inlineCode"><span class="koboSpan" id="kobo.332.1">-n</span></code><span class="koboSpan" id="kobo.333.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.334.1"># head -n 2 /etc/passwd
##
# User Database
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-222"><span class="koboSpan" id="kobo.335.1">tail</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.336.1">This is </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.337.1">the </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.338.1">opposite of </span><code class="inlineCode"><span class="koboSpan" id="kobo.339.1">head</span></code><span class="koboSpan" id="kobo.340.1">: it returns lines from the end of the file or stream. </span><span class="koboSpan" id="kobo.340.2">It takes </span><code class="inlineCode"><span class="koboSpan" id="kobo.341.1">-n</span></code><span class="koboSpan" id="kobo.342.1"> just like </span><code class="inlineCode"><span class="koboSpan" id="kobo.343.1">head</span></code><span class="koboSpan" id="kobo.344.1">.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.345.1">tail</span></code><span class="koboSpan" id="kobo.346.1"> can also be used interactively for following along with a log file, even as that file has new data</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.347.1"> streamed/written to it. </span><span class="koboSpan" id="kobo.347.2">You’ll see it used a lot like this during troubleshooting:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.348.1">tail -f /var/log/ngnix/access.log
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-223"><span class="koboSpan" id="kobo.349.1">tee</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.350.1">Sometimes, one </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.351.1">copy of the data from standard input just isn’t enough. </span><code class="inlineCode"><span class="koboSpan" id="kobo.352.1">tee</span></code><span class="koboSpan" id="kobo.353.1"> copies </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.354.1">standard input to standard output, while also making a copy in a file. </span><span class="koboSpan" id="kobo.354.2">As a software developer, I really like </span><code class="inlineCode"><span class="koboSpan" id="kobo.355.1">tee</span></code><span class="koboSpan" id="kobo.356.1"> for two specific cases.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.357.1">First, for debugging and logging: when I’m running scripts or programs that generate output, </span><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">tee</span></code><span class="koboSpan" id="kobo.359.1"> can be used to both display the output on the screen and log it to a file for later analysis. </span><span class="koboSpan" id="kobo.359.2">We’re using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.360.1">echo</span></code><span class="koboSpan" id="kobo.361.1"> command here, but you’d likely be calling your own program before the first pipe here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.362.1"># echo "Hello" | tee /tmp/greetings.txt
Hello
# cat /tmp/greetings.txt
Hello
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.363.1">The second use case where </span><code class="inlineCode"><span class="koboSpan" id="kobo.364.1">tee</span></code><span class="koboSpan" id="kobo.365.1"> comes in handy is for copying data from a pipeline like the ones we’re learning to construct in this chapter. </span><span class="koboSpan" id="kobo.365.2">You can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.366.1">tee</span></code><span class="koboSpan" id="kobo.367.1"> to intercept this flow at any point in the pipe, and save/inspect the intermediate results without disrupting the pipeline. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.368.1">Here’s the “top 10 commands” example from earlier, but with </span><code class="inlineCode"><span class="koboSpan" id="kobo.369.1">tee</span></code><span class="koboSpan" id="kobo.370.1"> inserted before limiting the results to just 10. </span><span class="koboSpan" id="kobo.370.2">This saves the full results in a temp file before we truncate them:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.371.1">history | awk '{print $2}' | sort | uniq -c | sort -rn | tee /tmp/all_commands.txt | head -n 10
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.372.1">Now if you want to see all of the commands, not just the top 10, you can just use </span><code class="inlineCode"><span class="koboSpan" id="kobo.373.1">cat</span></code><span class="koboSpan" id="kobo.374.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.375.1">less</span></code><span class="koboSpan" id="kobo.376.1"> to inspect the </span><code class="inlineCode"><span class="koboSpan" id="kobo.377.1">/tmp/all_commands.txt</span></code><span class="koboSpan" id="kobo.378.1"> file.</span></p>
<h2 class="heading-2" id="_idParaDest-224"><span class="koboSpan" id="kobo.379.1">awk</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.380.1">awk</span></code><span class="koboSpan" id="kobo.381.1"> is </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.382.1">often</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.383.1"> just used for dealing with columns of data, but it’s actually a whole language.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.384.1">For example, you can grab the second column from each line in the following way:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.385.1"># echo "two columns" | awk '{print $2}'
columns
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-225"><span class="koboSpan" id="kobo.386.1">sed</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.387.1">sed</span></code><span class="koboSpan" id="kobo.388.1"> is a </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.389.1">stream</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.390.1"> editor with tons of options. </span><span class="koboSpan" id="kobo.390.2">Most commonly, it’s used for character replacement in streams or files.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.391.1">Imagine we have a file like this:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.392.1"># cat /tmp/sensitive.txt
Nopasswords
not_a_password_either
sillypasswordtimes
password
ok this works
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.393.1">If we want to redact ONLY the line that has </span><code class="inlineCode"><span class="koboSpan" id="kobo.394.1">password</span></code><span class="koboSpan" id="kobo.395.1">, and nothing else, on it:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.396.1">sed 's/^password$/REDACTED/' /tmp/sensitive.txt
nopasswords
not_a_password_either
sillypasswordtimes
REDACTED
ok this works
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.397.1">This example uses a file rather than an input stream coming from another command. </span><span class="koboSpan" id="kobo.397.2">By default, this will not modify the original file. </span><span class="koboSpan" id="kobo.397.3">If you </span><em class="italic"><span class="koboSpan" id="kobo.398.1">do</span></em><span class="koboSpan" id="kobo.399.1"> want to modify the input file, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.400.1">-i</span></code><span class="koboSpan" id="kobo.401.1"> (in-place) option.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.402.1">Now that you’ve been introduced to pipes and have seen some of the most common command-line tools, let’s put those building blocks together and learn several practical patterns that you can use to make your daily command-line life a bit easier.</span></p>
<h1 class="heading-1" id="_idParaDest-226"><span class="koboSpan" id="kobo.403.1">Practical pipe patterns</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.404.1">As mentioned before, longer</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.405.1"> multi-pipe commands are built iteratively – one command at a time. </span><span class="koboSpan" id="kobo.405.2">However, there are some useful patterns that you’ll see re-used frequently.</span></p>
<h2 class="heading-2" id="_idParaDest-227"><span class="koboSpan" id="kobo.406.1">“Top X”, with count</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.407.1">This pattern sorts the</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.408.1"> input by the number of occurrences, in descending order. </span><span class="koboSpan" id="kobo.408.2">You saw this in the original example from this chapter, which displayed the most frequently used shell commands from Bash’s history file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.409.1">Here’s the pattern:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.410.1">some_input | sort | uniq -c | sort -rn | head -n 3
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.411.1">We can note the following details about this pattern:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.412.1">The input is sorted alphabetically, and then run through </span><code class="inlineCode"><span class="koboSpan" id="kobo.413.1">uniq -c</span></code><span class="koboSpan" id="kobo.414.1">, which needs sorted input to work on.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.415.1">uniq -c</span></code><span class="koboSpan" id="kobo.416.1"> eliminates duplicates, but adds a count (</span><code class="inlineCode"><span class="koboSpan" id="kobo.417.1">-c</span></code><span class="koboSpan" id="kobo.418.1">) of how many duplicates it found for each entry.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.419.1">sort</span></code><span class="koboSpan" id="kobo.420.1"> is run again, this time as a reverse-numeric (</span><code class="inlineCode"><span class="koboSpan" id="kobo.421.1">-r</span></code><span class="koboSpan" id="kobo.422.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.423.1">-n</span></code><span class="koboSpan" id="kobo.424.1">) sort which sorts the unique counts from the input and outputs the lines in reverse (highest number first) sorted order.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.425.1">head</span></code><span class="koboSpan" id="kobo.426.1"> takes that top ranking and cuts it down to three lines (</span><code class="inlineCode"><span class="koboSpan" id="kobo.427.1">-n 3</span></code><span class="koboSpan" id="kobo.428.1">), giving you the top three strings from the original input, along with how often they occurred.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.429.1">This pattern can come in handy when you need to know the most common browser user-agents hitting your website, the IP addresses of the worst offenders who are trying to probe and exploit your website, or any other situation where a sorted, ranked list is useful.</span></p>
<h2 class="heading-2" id="_idParaDest-228"><span class="koboSpan" id="kobo.430.1">curl | bash</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.431.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.432.1">curl | bash</span></code><span class="koboSpan" id="kobo.433.1"> pattern is a</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.434.1"> common shortcut used in Linux to download and execute scripts directly from the internet. </span><span class="koboSpan" id="kobo.434.2">This method combines two powerful command-line tools: </span><code class="inlineCode"><span class="koboSpan" id="kobo.435.1">curl</span></code><span class="koboSpan" id="kobo.436.1">, which fetches the content from a URL, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.437.1">bash</span></code><span class="koboSpan" id="kobo.438.1">, the shell interpreter, which executes the downloaded script. </span><span class="koboSpan" id="kobo.438.2">This pattern is a significant time-saver, allowing developers to quickly deploy applications or run scripts without manually downloading and then executing them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.439.1">As an example, let’s install the Pi-hole adblocking DNS server using this pattern:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.440.1">curl -sSL https://install.pi-hole.net | bash
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.441.1">Let’s </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.442.1">break this down, step by step:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><code class="inlineCode"><span class="koboSpan" id="kobo.443.1">curl -sSL https://install.pi-hole.net</span></code><span class="koboSpan" id="kobo.444.1">: This fetches the Pi-hole installation script, which is hosted at this URL. </span><span class="koboSpan" id="kobo.444.2">We pass two options:</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.445.1">-sS</span></code><span class="koboSpan" id="kobo.446.1">: Silent mode gives you the raw response from the server, but shows errors should they occur.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.447.1">-L</span></code><span class="koboSpan" id="kobo.448.1">: Follow redirects.</span></li>
</ul>
</li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.449.1">|</span></code><span class="koboSpan" id="kobo.450.1">: The pipe symbol passes the output of the previous command (</span><code class="inlineCode"><span class="koboSpan" id="kobo.451.1">curl</span></code><span class="koboSpan" id="kobo.452.1">) as input to the next command (</span><code class="inlineCode"><span class="koboSpan" id="kobo.453.1">bash</span></code><span class="koboSpan" id="kobo.454.1">).</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.455.1">bash</span></code><span class="koboSpan" id="kobo.456.1">: Executes the script fetched by </span><code class="inlineCode"><span class="koboSpan" id="kobo.457.1">curl</span></code><span class="koboSpan" id="kobo.458.1">.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.459.1">This is a tremendously useful pattern for automating things like code deployments or local environment installation/configuration. </span><span class="koboSpan" id="kobo.459.2">However, take special care that the script you download and execute is not malicious. </span><span class="koboSpan" id="kobo.459.3">Blindly running scripts from the internet is extremely bad practice.</span></p>
<h3 class="heading-3" id="_idParaDest-229"><span class="koboSpan" id="kobo.460.1">Security considerations for curl | sudo | bash</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.461.1">Anytime </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.462.1">you trust a third party to run code on your machine, you’re trading some security for convenience. </span><span class="koboSpan" id="kobo.462.2">In that sense, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.463.1">curl | sudo | bash</span></code><span class="koboSpan" id="kobo.464.1"> to install something via a script hosted on a trusted server is not much different from using a package manager. </span><span class="koboSpan" id="kobo.464.2">Most package managers (except for </span><code class="inlineCode"><span class="koboSpan" id="kobo.465.1">nix</span></code><span class="koboSpan" id="kobo.466.1">) don’t have a particularly impressive security design either, but they generally give you a reasonable set of security features. </span><span class="koboSpan" id="kobo.466.2">You’re giving all of these security features up when you </span><code class="inlineCode"><span class="koboSpan" id="kobo.467.1">curl | sudo | bash</span></code><span class="koboSpan" id="kobo.468.1"> an install script:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.469.1">There’s no package that can be checksummed and cryptographically signed to make sure you got the correct and official version.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.470.1">There’s no restriction on – or enforcement of – which servers you download from, and you don’t know how secure those servers are: you have no way to identify a compromised server hosting malicious install scripts.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.471.1">The scripts themselves are just code being run as the root user on your machine, so they can do anything </span><em class="italic"><span class="koboSpan" id="kobo.472.1">you</span></em><span class="koboSpan" id="kobo.473.1"> can on your machine, for better or worse. </span><span class="koboSpan" id="kobo.473.2">To be fair, many popular package managers also have this problem.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.474.1">For all of these </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.475.1">reasons, please heed our warning to split </span><code class="inlineCode"><span class="koboSpan" id="kobo.476.1">curl</span></code><span class="koboSpan" id="kobo.477.1"> into its own step and read through the downloaded install script before running </span><code class="inlineCode"><span class="koboSpan" id="kobo.478.1">sudo</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.479.1">bash</span></code><span class="koboSpan" id="kobo.480.1"> to execute it. </span><span class="koboSpan" id="kobo.480.2">The main things to look out for are:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.481.1">Ensure the server/domain you’re downloading the script from is trustworthy; this should be a reputable developer’s website or a trusted third-party code hosting platform.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.482.1">Ensure you use HTTPS for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.483.1">curl</span></code><span class="koboSpan" id="kobo.484.1"> download (i.e., the URL should start with </span><code class="inlineCode"><span class="koboSpan" id="kobo.485.1">https://</span></code><span class="koboSpan" id="kobo.486.1">).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.487.1">Read through the script carefully, to see which commands it runs and where it pulls additional code or executables from. </span><span class="koboSpan" id="kobo.487.2">If it downloads additional scripts or executables, have a look at those too.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.488.1">I think we’ve established that </span><code class="inlineCode"><span class="koboSpan" id="kobo.489.1">curl | sudo | bash</span></code><span class="koboSpan" id="kobo.490.1"> is not a particularly secure method of installing software. </span><span class="koboSpan" id="kobo.490.2">Following these guidelines can help you be a bit safer if you – like most of us – give into temptation one day and follow this installation method for a specific piece of software (for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.491.1">homebrew</span></code><span class="koboSpan" id="kobo.492.1"> on macOS).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.493.1">Let’s look at another common pattern now: filtering and searching with </span><code class="inlineCode"><span class="koboSpan" id="kobo.494.1">grep</span></code><span class="koboSpan" id="kobo.495.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-230"><span class="koboSpan" id="kobo.496.1">Filtering and searching with grep</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.497.1">When </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.498.1">you run commands that produce a lot of output, it’s generally best practice to filter the output down to just what you need. </span><span class="koboSpan" id="kobo.498.2">The most common tool for this is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.499.1">grep</span></code><span class="koboSpan" id="kobo.500.1">, and you can think of it as a highly configurable text search or string-matching function. </span><span class="koboSpan" id="kobo.500.2">Here’s an example of what filtering might look like.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.501.1">Imagine that you need to find a Linux process’s working directory. </span><span class="koboSpan" id="kobo.501.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">lsof</span></code><span class="koboSpan" id="kobo.503.1"> tool can accomplish this:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.504.1">➜  ~ lsof -p 3243 | grep cwd
vagrant 3243 dcohen  cwd    DIR                1,4      192            51689680 /Users/dcohen/code/my_vagrant_testenv
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.505.1">Here’s a quick description of what’s happening:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.506.1">I’m getting a listing of open file handles for a specific process (PID 3243), using </span><code class="inlineCode"><span class="koboSpan" id="kobo.507.1">lsof</span></code><span class="koboSpan" id="kobo.508.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.509.1">I’m then passing the results (</span><code class="inlineCode"><span class="koboSpan" id="kobo.510.1">|</span></code><span class="koboSpan" id="kobo.511.1">) to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.512.1">grep</span></code><span class="koboSpan" id="kobo.513.1"> utility and using that to search the results for the string </span><code class="inlineCode"><span class="koboSpan" id="kobo.514.1">cwd</span></code><span class="koboSpan" id="kobo.515.1">. </span><span class="koboSpan" id="kobo.515.2">There’s only one line of results that contains the string </span><code class="inlineCode"><span class="koboSpan" id="kobo.516.1">cwd</span></code><span class="koboSpan" id="kobo.517.1">, so that’s the only line that </span><code class="inlineCode"><span class="koboSpan" id="kobo.518.1">grep</span></code><span class="koboSpan" id="kobo.519.1"> prints to the terminal.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.520.1">This </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.521.1">pattern is useful anytime you have a </span><em class="italic"><span class="koboSpan" id="kobo.522.1">lot</span></em><span class="koboSpan" id="kobo.523.1"> of data as input, but you only need a subset of that data that can be identified by a specific string. </span><code class="inlineCode"><span class="koboSpan" id="kobo.524.1">grep</span></code><span class="koboSpan" id="kobo.525.1"> operates on lines of input text, so it’s hugely helpful for picking out data like:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.526.1">Loglines containing the IP address you are following</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.527.1">Occurrences of a username in a piped data stream</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.528.1">Lines that match a pattern (</span><code class="inlineCode"><span class="koboSpan" id="kobo.529.1">grep</span></code><span class="koboSpan" id="kobo.530.1"> is regular-expression aware and can take string patterns in addition to literal search strings)</span></li>
</ul>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">grep</span></code><span class="koboSpan" id="kobo.532.1"> is a large and powerful tool that you’ll have occasion to use almost every day. </span><span class="koboSpan" id="kobo.532.2">For more information, check out the manpage for grep by typing </span><code class="inlineCode"><span class="koboSpan" id="kobo.533.1">man grep</span></code><span class="koboSpan" id="kobo.534.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.535.1">You’ve already seen </span><code class="inlineCode"><span class="koboSpan" id="kobo.536.1">grep</span></code><span class="koboSpan" id="kobo.537.1"> used on files in this book (for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.538.1">grep searchstring hello.txt</span></code><span class="koboSpan" id="kobo.539.1">), but it’s also an invaluable filtering component in piped commands. </span><span class="koboSpan" id="kobo.539.2">Let’s look at a practical example now.</span></p>
<h2 class="heading-2" id="_idParaDest-231"><span class="koboSpan" id="kobo.540.1">grep and tail for log monitoring</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.541.1">When</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.542.1"> you’re looking at production logs to try to figure out what’s wrong, you’ll often only want to see loglines containing certain keywords or search strings. </span><span class="koboSpan" id="kobo.542.2">To do that, you’d run something like:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.543.1">tail -f /var/log/webapp/too_many_logs.log | grep "yourSearchRegex"
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.544.1">This pattern continuously monitors the log file for new entries whose content matches “yourSearchRegex”, so you can see only the logs you need for the task at hand.</span></p>
<h2 class="heading-2" id="_idParaDest-232"><span class="koboSpan" id="kobo.545.1">find and xargs for bulk file operations</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.546.1">xargs</span></code><span class="koboSpan" id="kobo.547.1"> is a</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.548.1"> powerful utility that gives you the power </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.549.1">of iteration (in other words, a “for” loop) inside of a single command. </span><span class="koboSpan" id="kobo.549.2">By default, </span><code class="inlineCode"><span class="koboSpan" id="kobo.550.1">xargs</span></code><span class="koboSpan" id="kobo.551.1"> takes each (space, tab, newline, and end-of-file delimited) chunk of input it receives and executes the specified program using that chunk as input. </span><span class="koboSpan" id="kobo.551.2">For example, if you need to search for specific file content across </span><code class="inlineCode"><span class="koboSpan" id="kobo.552.1">ONLY</span></code><span class="koboSpan" id="kobo.553.1"> the files returned by a certain </span><code class="inlineCode"><span class="koboSpan" id="kobo.554.1">find</span></code><span class="koboSpan" id="kobo.555.1"> query, you can run this command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.556.1">find . </span><span class="koboSpan" id="kobo.556.2">-type f -name "*\.txt" | xargs grep "search_term"
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.557.1">This</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.558.1"> command finds all files whose names end with </span><code class="inlineCode"><span class="koboSpan" id="kobo.559.1">.txt</span></code><span class="koboSpan" id="kobo.560.1"> and then uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.561.1">xargs</span></code><span class="koboSpan" id="kobo.562.1"> to apply the </span><code class="inlineCode"><span class="koboSpan" id="kobo.563.1">grep</span></code><span class="koboSpan" id="kobo.564.1"> command to each file individually. </span><span class="koboSpan" id="kobo.564.2">This </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.565.1">pattern is handy for searching or modifying multiple files at once. </span><span class="koboSpan" id="kobo.565.2">Please be forewarned that </span><code class="inlineCode"><span class="koboSpan" id="kobo.566.1">xargs</span></code><span class="koboSpan" id="kobo.567.1"> is a powerful – and </span><em class="italic"><span class="koboSpan" id="kobo.568.1">large </span></em><span class="koboSpan" id="kobo.569.1">–</span><em class="italic"> </em><span class="koboSpan" id="kobo.570.1">program, capable of doing many things (including string interpolation into the command it executes). </span><span class="koboSpan" id="kobo.570.2">We can’t cover it all here, so please read the manpage and scour the internet for examples if you’re in a situation where this kind of functionality would save the day.</span></p>
<h2 class="heading-2" id="_idParaDest-233"><span class="koboSpan" id="kobo.571.1">sort, uniq, and reverse numerical sort for data analysis</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.572.1">This is a useful </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.573.1">pattern that you saw applied at the beginning of the chapter, where I used it to filter a large command history to get a list of the “top X most popular commands run on this system.” </span><span class="koboSpan" id="kobo.573.2">The core pattern is this:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.574.1">(input stream) | sort | uniq –c | sort -rn
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.575.1">Useful for </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.576.1">analyzing data, this pattern sorts the data from the input stream, deduplicates it while counting unique occurrences, and then performs a reverse numerical sort to give you the deduplicated data, with the most common lines first.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.577.1">This is commonly truncated with </span><code class="inlineCode"><span class="koboSpan" id="kobo.578.1">| head -n $NUMBER</span></code><span class="koboSpan" id="kobo.579.1"> to get only the top </span><code class="inlineCode"><span class="koboSpan" id="kobo.580.1">$NUMBER</span></code><span class="koboSpan" id="kobo.581.1"> of results:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.582.1">history | awk '{print $2}' | sort | uniq -c | sort -rn | head -n 10
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.583.1">Here, we use history to fetch the entire shell command history. </span><span class="koboSpan" id="kobo.583.2">This gives us a series of lines like:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.584.1">   12  brew install --cask emacs
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.585.1">We’re only interested in the top-level command (in this case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.586.1">brew</span></code><span class="koboSpan" id="kobo.587.1">), so we use </span><code class="inlineCode"><span class="koboSpan" id="kobo.588.1">awk</span></code><span class="koboSpan" id="kobo.589.1"> to fetch the second column.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.590.1">Then we sort so that duplicates of the same command occur next to each other in the stream. </span><span class="koboSpan" id="kobo.590.2">Then we remove those duplicates with </span><code class="inlineCode"><span class="koboSpan" id="kobo.591.1">uniq</span></code><span class="koboSpan" id="kobo.592.1">, adding a count of occurrences to each remaining </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.593.1">one. </span><span class="koboSpan" id="kobo.593.2">Now we sort again – this time using </span><code class="inlineCode"><span class="koboSpan" id="kobo.594.1">-rn</span></code><span class="koboSpan" id="kobo.595.1"> for a reverse numerical sort, which gives us the “top X” effect. </span><span class="koboSpan" id="kobo.595.2">Finally, we take the first 10 lines with head.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.596.1">This prints out the aforementioned top-10 list of your most-used shell commands; on my machine, it produces this:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.597.1">1000 git
 115 ls
 102 go
  83 gpo (an alias I've set up for pushing a local git branch to the origin)
  68 make
  65 cd
  59 docker
  42 vagrant
  35 GOOS=linux
  30 echo
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-234"><span class="koboSpan" id="kobo.598.1">awk and sort for reformatting data and field-based processing</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.599.1">awk</span></code><span class="koboSpan" id="kobo.600.1"> is</span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.601.1"> more than a program; it’s a stream-processing language. </span><span class="koboSpan" id="kobo.601.2">If you work with data streams on Unix system, then spending a few days learning the basics can save you weeks of time over your career. </span><span class="koboSpan" id="kobo.601.3">That</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.602.1"> said, just using </span><code class="inlineCode"><span class="koboSpan" id="kobo.603.1">$#</span></code><span class="koboSpan" id="kobo.604.1"> syntax to reference whitespace-delimited columns in each line of the data stream is a good start.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.605.1">Let’s look at an example given a data stream like the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.606.1">Foo bar baz
Some data is nice
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.607.1">When the awk interpreter sees </span><code class="inlineCode"><span class="koboSpan" id="kobo.608.1">$1</span></code><span class="koboSpan" id="kobo.609.1">, it interprets this to mean “the first column” or in this case </span><code class="inlineCode"><span class="koboSpan" id="kobo.610.1">Foo</span></code><span class="koboSpan" id="kobo.611.1"> in line 1 and </span><code class="inlineCode"><span class="koboSpan" id="kobo.612.1">Some</span></code><span class="koboSpan" id="kobo.613.1"> in line 2. </span><code class="inlineCode"><span class="koboSpan" id="kobo.614.1">$2</span></code><span class="koboSpan" id="kobo.615.1"> is the second column (</span><code class="inlineCode"><span class="koboSpan" id="kobo.616.1">bar</span></code><span class="koboSpan" id="kobo.617.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.618.1">data</span></code><span class="koboSpan" id="kobo.619.1">), and so on. </span><span class="koboSpan" id="kobo.619.2">This is an incredibly common feature to use when working with data that’s just a bit too complex for simple </span><code class="inlineCode"><span class="koboSpan" id="kobo.620.1">cut</span></code><span class="koboSpan" id="kobo.621.1"> commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.622.1">cat file.txt | awk '{print $2, $1}'
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.623.1">This would produce output like:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.624.1">bar Foo
data Some
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.625.1">In this case, it prints out column 2 before column 1 for each file, and ignores all other data in each line. </span><span class="koboSpan" id="kobo.625.2">This is often used for reformatting and organizing data based on specific fields.</span></p>
<h2 class="heading-2" id="_idParaDest-235"><span class="koboSpan" id="kobo.626.1">sed and tee for editing and backup</span></h2>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.627.1">sed</span></strong><span class="koboSpan" id="kobo.628.1"> stands for </span><strong class="keyWord"><span class="koboSpan" id="kobo.629.1">Stream EDitor</span></strong><span class="koboSpan" id="kobo.630.1"> and is used when you want to transform a data stream. </span><span class="koboSpan" id="kobo.630.2">You do this ten </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.631.1">times a day in your text editor when you find/replace a symbol. </span><span class="koboSpan" id="kobo.631.2">The following command is essentially the command-line version of that functionality: it transforms</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.632.1"> all occurrences of </span><code class="inlineCode"><span class="koboSpan" id="kobo.633.1">old</span></code><span class="koboSpan" id="kobo.634.1"> in </span><code class="inlineCode"><span class="koboSpan" id="kobo.635.1">file.txt</span></code><span class="koboSpan" id="kobo.636.1"> into the string </span><code class="inlineCode"><span class="koboSpan" id="kobo.637.1">new</span></code><span class="koboSpan" id="kobo.638.1"> and writes the resulting stream to a new file, </span><code class="inlineCode"><span class="koboSpan" id="kobo.639.1">file.txt.changed</span></code><span class="koboSpan" id="kobo.640.1">. </span><span class="koboSpan" id="kobo.640.2">It does this without making changes to the original </span><code class="inlineCode"><span class="koboSpan" id="kobo.641.1">file.txt</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.642.1">file</span></code><span class="koboSpan" id="kobo.643.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.644.1">sed 's/old/new/g' file.txt | tee file.txt.changed
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.645.1">Although editing file content is an easy demonstration of this concept, </span><code class="inlineCode"><span class="koboSpan" id="kobo.646.1">sed</span></code><span class="koboSpan" id="kobo.647.1"> is tremendously useful for transforming stream data as it zips from the output of one command to the input of the next:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.648.1">(input stream) | sed 's/old/new/g' | (next command)
</span></code></pre>
<h3 class="heading-3" id="_idParaDest-236"><span class="koboSpan" id="kobo.649.1">ps, grep, awk, xargs, and kill for process management</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.650.1">Although </span><code class="inlineCode"><span class="koboSpan" id="kobo.651.1">pgrep</span></code><span class="koboSpan" id="kobo.652.1"> is a</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.653.1"> good utility for sending signals to all processes whose name matches a pattern, sometimes</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.654.1"> it’s just not available on </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.655.1">your system. </span><span class="koboSpan" id="kobo.655.2">You can cobble together similar</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.656.1"> functionality (and get much more specific with what you want to target, not just the name) by using this set of piped-together commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.657.1">ps aux | grep "process_name" | awk '{print $2}' | xargs kill
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.658.1">ps</span></code><span class="koboSpan" id="kobo.659.1"> starts you off with a list of running processes, which </span><code class="inlineCode"><span class="koboSpan" id="kobo.660.1">grep</span></code><span class="koboSpan" id="kobo.661.1"> filters to just those containing the pattern </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.662.1">you’re searching for. </span><code class="inlineCode"><span class="koboSpan" id="kobo.663.1">awk</span></code><span class="koboSpan" id="kobo.664.1"> gets the</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.665.1"> second column (the process ID) for each matching line, and then feeds all matched lines to </span><code class="inlineCode"><span class="koboSpan" id="kobo.666.1">xargs</span></code><span class="koboSpan" id="kobo.667.1"> (our quasi for loop), which executes </span><code class="inlineCode"><span class="koboSpan" id="kobo.668.1">kill</span></code><span class="koboSpan" id="kobo.669.1"> on each PID. </span><span class="koboSpan" id="kobo.669.2">This sends a </span><code class="inlineCode"><span class="koboSpan" id="kobo.670.1">SIGTERM</span></code><span class="koboSpan" id="kobo.671.1"> to each matching process and (hopefully) halts it.</span></p>
<h3 class="heading-3" id="_idParaDest-237"><span class="koboSpan" id="kobo.672.1">tar and gzip for backup and compression</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.673.1">Although many </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.674.1">utilities have flags that let you do both, chaining together archiving and compression is another use case that </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.675.1">makes sense. </span><span class="koboSpan" id="kobo.675.2">This gives you the added flexibility of adding additional chained commands. </span><span class="koboSpan" id="kobo.675.3">For example, if you want to add encryption, that’s just a single additional piped command away:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.676.1">tar cvf - /path/to/directory | gzip &gt; backup.tar.gz
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.677.1">This creates a compressed archive of a directory, commonly used for file backup and storage. </span><span class="koboSpan" id="kobo.677.2">You can see larger commands using this kind of pattern:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.678.1">ssh user@mysql-server "mysqldump --add-drop-table database_name | gzip -9c" | gzip –d | mysql
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.679.1">This is an especially fun example that logs into a database server using SSH, dumps out a database, compresses that data stream, shuttles it back to the local machine over SSH, decompresses it again, and finally dumps it into the local MySQL server.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.680.1">Your aim shouldn’t necessarily be to write commands as complex as this one (or some of the others you’ve seen here), but if you know how to put something like this together in a pinch, it can get you out of some extremely tight spots as a developer. </span><span class="koboSpan" id="kobo.680.2">We hope this section has demonstrated that understanding the input and output redirection primitives that Unix systems expose to you – via </span><code class="inlineCode"><span class="koboSpan" id="kobo.681.1">&lt;</span></code><span class="koboSpan" id="kobo.682.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.683.1">&gt;</span></code><span class="koboSpan" id="kobo.684.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.685.1">&gt;&gt;</span></code><span class="koboSpan" id="kobo.686.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.687.1">|</span></code><span class="koboSpan" id="kobo.688.1">, and file descriptors in general – is basically a superpower. </span><span class="koboSpan" id="kobo.688.2">Use it wisely.</span></p>
<h1 class="heading-1" id="_idParaDest-238"><span class="koboSpan" id="kobo.689.1">Advanced: inspecting file descriptors</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.690.1">On Linux, you </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.691.1">can easily </span><em class="italic"><span class="koboSpan" id="kobo.692.1">see</span></em><span class="koboSpan" id="kobo.693.1"> where a process’s file descriptors are pointing. </span><span class="koboSpan" id="kobo.693.2">We’re going to use the slightly magical </span><code class="inlineCode"><span class="koboSpan" id="kobo.694.1">/proc</span></code><span class="koboSpan" id="kobo.695.1"> virtual filesystem to do just that.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.696.1">Procfs (the </span><code class="inlineCode"><span class="koboSpan" id="kobo.697.1">proc</span></code><span class="koboSpan" id="kobo.698.1"> virtual filesystem) is a Linux-only abstraction that represents kernel and process state as files. </span><span class="koboSpan" id="kobo.698.2">The data inside of these files comes straight from the operating system kernel, and only exists while you’re reading them. </span><span class="koboSpan" id="kobo.698.3">Just listing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.699.1">/proc</span></code><span class="koboSpan" id="kobo.700.1"> directory will show </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.701.1">you many files; here’s a selection of some of the more important ones, taken from the Arch Linux wiki:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.702.1">/proc/cpuinfo - information about CPU
/proc/meminfo - information about the physical memory
/proc/vmstats - information about the virtual memory
/proc/mounts - information about the mounts
/proc/filesystems - information about filesystems that have been compiled into the kernel and whose kernel modules are currently loaded
/proc/uptime - current system uptime
/proc/cmdline - kernel command line
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.703.1">What’s most interesting to us with regard to file descriptors is something not shown in the listing above: </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">/proc</span></code><span class="koboSpan" id="kobo.705.1"> contains a directory for every single process running on the machine, named after </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.706.1">each </span><strong class="keyWord"><span class="koboSpan" id="kobo.707.1">process ID</span></strong><span class="koboSpan" id="kobo.708.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.709.1">PID</span></strong><span class="koboSpan" id="kobo.710.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.711.1">In a process’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.712.1">/proc</span></code><span class="koboSpan" id="kobo.713.1"> directory, that process’s file descriptors are represented as symbolic links in a directory called </span><code class="inlineCode"><span class="koboSpan" id="kobo.714.1">fd</span></code><span class="koboSpan" id="kobo.715.1">. </span><span class="koboSpan" id="kobo.715.2">When you do a long listing on this </span><code class="inlineCode"><span class="koboSpan" id="kobo.716.1">/proc/$PID/fd</span></code><span class="koboSpan" id="kobo.717.1"> directory, you’ll see that </span><code class="inlineCode"><span class="koboSpan" id="kobo.718.1">l</span></code><span class="koboSpan" id="kobo.719.1"> is the first character in the long listing, which denotes a special </span><code class="inlineCode"><span class="koboSpan" id="kobo.720.1">link</span></code><span class="koboSpan" id="kobo.721.1"> file, as you’ll recall from </span><em class="chapterRef"><span class="koboSpan" id="kobo.722.1">Chapter 5</span></em><span class="koboSpan" id="kobo.723.1">, </span><em class="italic"><span class="koboSpan" id="kobo.724.1">Introducing Files</span></em><span class="koboSpan" id="kobo.725.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.726.1">Practically speaking, </span><code class="inlineCode"><span class="koboSpan" id="kobo.727.1">/proc/1/</span></code><span class="koboSpan" id="kobo.728.1"> is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.729.1">init</span></code><span class="koboSpan" id="kobo.730.1"> process’s proc directory, and you can view init’s file descriptors by doing a long listing on </span><code class="inlineCode"><span class="koboSpan" id="kobo.731.1">/proc/1/fd</span></code><span class="koboSpan" id="kobo.732.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.733.1">Let’s look at the file descriptors for an interactive Bash shell process running on my machine, which </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">ps aux | grep bash</span></code><span class="koboSpan" id="kobo.735.1"> tells me is PID 9:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.736.1">root@server:/# ls -alh /proc/9/fd
total 0
dr-x------ 2 root root  0 Sep  1 19:16 .
</span><span class="koboSpan" id="kobo.736.2">dr-xr-xr-x 9 root root  0 Sep  1 19:16 ..
</span><span class="koboSpan" id="kobo.736.3">lrwx------ 1 root root 64 Sep  1 19:16 0 -&gt; /dev/pts/1
lrwx------ 1 root root 64 Sep  1 19:16 1 -&gt; /dev/pts/1
lrwx------ 1 root root 64 Sep  1 19:16 2 -&gt; /dev/pts/1
lrwx------ 1 root root 64 Sep  5 00:46 255 -&gt; /dev/pts/1
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.737.1">You’ll notice that it’s an interactive shell session: its standard input is coming from a virtual terminal (</span><code class="inlineCode"><span class="koboSpan" id="kobo.738.1">/dev/pts/1</span></code><span class="koboSpan" id="kobo.739.1">), and its standard error and output are going back to that same terminal. </span><span class="koboSpan" id="kobo.739.2">That checks out.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.740.1">Let’s look at a text editor like vim, which behaves a lot like a terminal – input and output happen via a terminal. </span><span class="koboSpan" id="kobo.740.2">However, there’s an added complication, which is that text editors usually keep one or more files open for writing. </span><span class="koboSpan" id="kobo.740.3">What does that look like?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.741.1">In this </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.742.1">example, I’m running the vim text editor, and editing a file in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.743.1">/tmp</span></code><span class="koboSpan" id="kobo.744.1"> directory. </span><span class="koboSpan" id="kobo.744.2">Let’s find the process ID for vim, so we know which </span><code class="inlineCode"><span class="koboSpan" id="kobo.745.1">/proc</span></code><span class="koboSpan" id="kobo.746.1"> directory to look inside:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.747.1">root@server:/# ps aux | grep vim
root       453  0.0  0.1  17232  9216 pts/1    S+   15:57   0:00 vim /tmp/hello.txt
root       458  0.0  0.0   2884  1536 pts/0    S+   15:58   0:00 grep --color=auto vim
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.748.1">There it is; process 453. </span><span class="koboSpan" id="kobo.748.2">Don’t be misled by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.749.1">grep</span></code><span class="koboSpan" id="kobo.750.1"> command which also includes </span><code class="inlineCode"><span class="koboSpan" id="kobo.751.1">vim</span></code><span class="koboSpan" id="kobo.752.1"> in its command arguments. </span><span class="koboSpan" id="kobo.752.2">Now that we have the PID, let’s look at vim’s file descriptors:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.753.1">root@server:/# ls -l /proc/453/fd
total 0
lrwx------ 1 root root 64 Jan  7 15:58 0 -&gt; /dev/pts/1
lrwx------ 1 root root 64 Jan  7 15:58 1 -&gt; /dev/pts/1
lrwx------ 1 root root 64 Jan  7 15:58 2 -&gt; /dev/pts/1
lrwx------ 1 root root 64 Jan  7 15:58 3 -&gt; /tmp/.hello.txt.swp
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.754.1">We can see that stdin (</span><code class="inlineCode"><span class="koboSpan" id="kobo.755.1">0</span></code><span class="koboSpan" id="kobo.756.1">), stdout (</span><code class="inlineCode"><span class="koboSpan" id="kobo.757.1">1</span></code><span class="koboSpan" id="kobo.758.1">), and stderr (</span><code class="inlineCode"><span class="koboSpan" id="kobo.759.1">2</span></code><span class="koboSpan" id="kobo.760.1">) are all pointing to a terminal device, just like a shell. </span><span class="koboSpan" id="kobo.760.2">And we also see that the editor has a file open, with file descriptor </span><code class="inlineCode"><span class="koboSpan" id="kobo.761.1">3</span></code><span class="koboSpan" id="kobo.762.1"> linked to the file that vim is editing. </span><span class="koboSpan" id="kobo.762.2">When a process opens additional files, new file descriptors are created, and you can view them here.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.763.1">Beyond being interesting for its own sake, this can come in handy when programs are behaving erratically due to bugs, or when you’re trying to trace what a potentially malicious program is doing. </span><code class="inlineCode"><span class="koboSpan" id="kobo.764.1">procfs</span></code><span class="koboSpan" id="kobo.765.1"> is quite interesting and useful if you invest a bit of time in learning it: just type </span><code class="inlineCode"><span class="koboSpan" id="kobo.766.1">man proc</span></code><span class="koboSpan" id="kobo.767.1"> to get started, or read the Arch Linux Wiki page for a gentler introduction at </span><a href="https://wiki.archlinux.org/title/Procfs"><span class="url"><span class="koboSpan" id="kobo.768.1">https://wiki.archlinux.org/title/Procfs</span></span></a><span class="koboSpan" id="kobo.769.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-239"><span class="koboSpan" id="kobo.770.1">Conclusion</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.771.1">In this chapter, we put together all of the previous skills and theory we’ve covered to unlock one of the most powerful features of Unix and Linux systems: streaming data through multiple commands using pipes and input/output redirection.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.772.1">We started by showing you how the operating system exposes primitives like file descriptors, and then started looking at practical uses of input and output redirection. </span><span class="koboSpan" id="kobo.772.2">Then, we covered pipes, which are arguably one of the most useful features of Linux and other Unix operating systems. </span><span class="koboSpan" id="kobo.772.3">After covering the necessary theory and showing you some useful examples, we dove deep into the most common helper tools that people use to slice and dice the data streams that they build up using pipes. </span><span class="koboSpan" id="kobo.772.4">Finally, we showed you some of the most common and useful patterns and program-combinations that people use in the real world.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.773.1">What’s in this chapter is the foundation for much of the advanced command-line usage you’ll encounter and use in your day-to-day work. </span><span class="koboSpan" id="kobo.773.2">You’ve now been exposed to some of the basic theory, tools, and patterns that you’ll see in the wild, which will make it easy to dive in and start building custom commands for common development, troubleshooting, and automation use cases.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.774.1">To grow your skills, use what you’ve seen in this chapter in your day-to-day work! </span><span class="koboSpan" id="kobo.774.2">Use it as a reference for patterns to try, and keep learning new tools and commands that you can add to your own custom recipes and use to filter or otherwise manipulate data on the command line. </span><span class="koboSpan" id="kobo.774.3">You’ll feel like a wizard in no time.</span></p>
<h1 class="heading-1"><span class="koboSpan" id="kobo.775.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.776.1">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SecNet"><span class="url"><span class="koboSpan" id="kobo.777.1">https://packt.link/SecNet</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.778.1"><img alt="" role="presentation" src="../Images/QR_Code1768422420210094187.png"/></span></p>
</div>
</body></html>