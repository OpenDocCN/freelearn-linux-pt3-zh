- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring the Various Boot Options and Kernels in Oracle Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will teach you about **boot** and its options, kernels, and more.
    You will also learn about many exciting opportunities, tools, and applications
    to make your life easier and more enjoyable. For example, you will learn how to
    change your booting kernel and remove and reinstall a kernel on your system. You
    will even learn how to use the boot process to switch between Linux kernels.
  prefs: []
  type: TYPE_NORMAL
- en: Booting involves more than just loading the operating system; it also helps
    secure the system using Secure Boot or TrenchBoot.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter has the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Kernel basics – UEK and RHCK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with UEFI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with Secure Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TrenchBoot – improving boot security and integrity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the RHCK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel basics – UEK and RHCK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started with UEK and RHCK, let's understand what is a Linux kernel.
    A Linux kernel release refers to an updated version of the core component of the
    Linux operating system. Its main function is to act as a bridge between the hardware
    and software layers of a computer system. The Linux kernel is a collaborative
    development effort by a large community of developers worldwide, with Linus Torvalds
    as the original creator and official maintainer of the mainline kernel. These
    kernel updates are introduced periodically to provide new features, improvements,
    bug fixes, security patches, and hardware support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux kernel releases are assigned a version number that consists of three
    components: major version, minor version, and patch level. For instance, a kernel
    version is represented as X.Y.Z, where X represents the major version, Y is the
    minor version, and Z is the patch level. The major version is usually incremented
    for significant changes that may affect compatibility, while the minor version
    and patch level represent incremental updates and bug fixes.'
  prefs: []
  type: TYPE_NORMAL
- en: Linux kernel releases are distributed as source code, and various distributions
    or operating systems based on Linux typically package and distribute their own
    versions of the kernel, incorporating it into their respective releases. In addition,
    users who want to compile and install the kernel directly on their systems can
    access the source code. The following table shows the Linux kernel mainline releases
    for Linux 7, 8, and 9.
  prefs: []
  type: TYPE_NORMAL
- en: '| **OS Version** | **RHCK Release** | **Latest** **UEK Release** |'
  prefs: []
  type: TYPE_TB
- en: '| Linux 7 | Linux 3.x | UEK 6/Linux 5.4 |'
  prefs: []
  type: TYPE_TB
- en: '| Linux 8 | Linux 4.x | UEK 7/Linux 5.15 |'
  prefs: []
  type: TYPE_TB
- en: '| Linux 9 | Linux 5.14 | UEK 7/Linux 5.15 |'
  prefs: []
  type: TYPE_TB
- en: Table 3.1 – Available Kernel options by release
  prefs: []
  type: TYPE_NORMAL
- en: Kernel basics – UEK and RHCK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a fresh installation of Oracle Linux, the **Unbreakable Enterprise Kernel**
    (**UEK**) is the default. However, in some cases, you may want to switch to the
    **Red Hat Compatible** **Kernel** (**RHCK**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The default kernel might not be the correct version to use in some scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: UEK releases are based on newer kernel releases than the **RHCK** version, which
    is the standard for Red Hat servers. With Oracle Linux, you have the option to
    use the UEK, which provides a more up-to-date kernel release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current kernel version might be incompatible with your particular hardware.
    A UEK system will boot on new hardware, while the older RHCK will not. An example
    of this is UEK 7, which supports the **Microsoft Azure Network Adapter** (**MANA**),
    whereas UEK 6 does not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose a UEK beta or technical preview release is installed on the system.
    In that case, UEK needs to be demoted to ensure that the kernel is used only if
    intentionally and manually selected as the boot kernel by an administrator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UEK for Oracle Linux provides many advantages, such as significant performance
    improvements and new features. The Linux operating system is a modular system
    in which the kernel interacts with the hardware and controls and schedules access
    to resources on behalf of applications. Most applications run in what is called
    user space and call only a stable set of system libraries to ask for kernel services.
    The exceptions are applications that directly access the kernel, most commonly
    security applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the UEK does not change system libraries such as glibc, which is
    the interface that nearly all applications, including Oracle Database, use. The
    glibc version is the same whether you run Oracle Linux with the UEK or with the
    RHCK. This is not limited to just gloc, but is the case for all system libraries,
    such as libssl, libcurl, and libcrypt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Multiple versions of the UEK may be available for any baseline operating system
    release. Choosing the version of the UEK is up to the application team and must
    reflect any compatibility requirements.
  prefs: []
  type: TYPE_NORMAL
- en: These examples and similar cases require you to switch between kernel types.
    In older releases, managing the default kernel was performed by configuring the
    GRUB boot loader. However, with Oracle Linux 8 and later, you should use the `grubby`
    command to control and manage the configuration for booting the kernel. `grubby`
    is part of the **Grand Unified Bootloader version 2** (**GRUB 2**) boot loader,
    which is available from the GNU project. GRUB is the default bootloader for many
    Linux distributions on the market. After loading it into memory, it transfers
    control to the operating system kernel.
  prefs: []
  type: TYPE_NORMAL
- en: GRUB 2 is the default bootloader program used on Oracle Linux, and it can load
    many different operating systems, including Microsoft Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by looking deeper at the boot process to better understand it.
  prefs: []
  type: TYPE_NORMAL
- en: The boot process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have an understanding of how Oracle Linux boot options help you troubleshoot
    problems encountered when booting the system. This knowledge is beneficial when
    using new hardware or cloud environments.
  prefs: []
  type: TYPE_NORMAL
- en: As an Oracle Linux system boots, it performs many tasks that may change depending
    on the type of firmware your hardware uses to handle the system boot. It could
    be `.efi` file in a particular partition on the system’s drive. Using the `.efi`
    file gives a user more control of the boot process, including the ability to take
    advantage of new security features. An example of a new security feature is Secure
    Boot, which is covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The UEFI-based booting sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following sequence order is used by UEFI-based booting hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: The system first performs a **power-on self-test** (**POST**), which identifies
    the system’s configuration and all possible boot identifiers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: UEFI searches for a **GUID Partition Table** (**GPT**) partition with a specific
    **Globally Unique Identifier** (**GUID**) that identifies it as the **EFI System
    Partition** (**ESP**), containing **Extensible Firmware Interface** (**EFI**)
    applications such as booters. If there are multiple boot devices, the UEFI boot
    manager determines the appropriate ESP based on the order defined in the boot
    manager. With the **efibootmgr** tool, you can specify a different order if you
    do not use the default definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The UEFI boot manager checks whether Secure Boot is enabled. If Secure Boot
    is not enabled, the boot manager runs the GRUB 2 boot loader on the ESP. Otherwise,
    the boot manager requests a certificate from the boot loader and validates this
    against keys stored in the UEFI Secure Boot key database. The environment is configured
    to perform a two-stage boot process, and the shim to handle the certificate validation
    `process.efi` application that is responsible for the certification is loaded
    first before loading the GRUB 2 boot loader. If the certificate is valid, the
    boot loader runs and, in turn, validates the kernel that it is configured to load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The boot loader first loads the `vmlinuz` kernel image into memory and then
    creates a temporary RAM-based filesystem called `tmpfs`. This is then used to
    extract the contents of the `initramfs` image file. `vmlinuz` is the name of the
    bootable compressed Linux kernel executable. The root filesystem embedded into
    the Linux kernel and loaded early in the boot process is called `initramfs`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Driver modules are then loaded from the `initramfs` filesystem. These are needed
    to allow the kernel to access the root filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system then starts with the first process, systemd. All future processes
    spawn from this process. The systemd process will always have a process ID of
    1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The systemd process will run any additional processes defined for it. You can
    specify any other actions to be processed during the boot process by defining
    your systemd unit. This method is advised to be used instead of the `/etc/rc.
    local` file approach.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The legacy BIOS sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Legacy BIOS booting hardware uses the following sequence order:'
  prefs: []
  type: TYPE_NORMAL
- en: The system first performs a POST, which identifies the configuration of the
    system, tests memory, and identifies all possible boot devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the BIOS has identified the boot device, it reads the first sector of the
    device, which is the **Master Boot Record** (**MBR**). The MBR contains the boot
    loader, which is a small program that is responsible for loading the operating
    system. The MBR reads the partition table, to determine the boot partition. Additionally,
    the MBR includes the pointer to the boot loader program called GRUB 2\. GRUB can
    then run a boot on the same device that GRUB is installed on or a separate device.
    This is helpful when multi-booting the same system with both Linux and Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The boot loader first loads the `vmlinuz` kernel image into memory and then
    creates a temporary RAM-based filesystem called `tmpfs`. This is then used to
    extract the contents of the `initramfs` image file. `vmlinuz` is the name of the
    bootable compressed Linux kernel executable. The root filesystem embedded in the
    Linux kernel and loaded early in the boot process is called initramfs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Driver modules are then loaded from the initramfs filesystem. These modules
    are needed to allow the kernel to access the root filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The kernel then starts the systemd process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The systemd process runs any other processes defined for it. You can specify
    any additional actions to be processed during the boot process by defining your
    systemd unit. This method is recommended instead of the `/etc/rc. local` file
    approach.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have discussed the basics, we can leave behind all the boring parts
    and get to the action. It is time to play and learn!
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the first things we can do is determine the currently loaded kernel
    in our system. The following command will display all kernels that are installed
    and configured within our Linux system (please run as root):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is one example of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – grubby output](img/B18349_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – grubby output
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The sample is done using an Arm system, hence the `aarch64` suffix. x86_64 systems
    will show `x86_64` suffixes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also determine the default kernel in use by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is one example of an output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – grubby default kernel](img/B18349_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – grubby default kernel
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure a specific kernel to be used as the default boot kernel by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here is one example of using the preceding command to change the default kernel
    in use. Knowing that RHCK is going to be a version 4 kernel, we will use `4.18.0-425.13.1.el8_7.x86_64`.
    Next, we need to point to the file in `/boot`, adding `vmlinuz-` to the name.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Changing the default kernel with grubby](img/B18349_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Changing the default kernel with grubby
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possible use of the `grubby` command is to use it to update a kernel
    configuration entry or to add or remove boot arguments that should be passed to
    the kernel by default; the following is one example of it. But first, we will
    show all the information about a specific kernel in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show the details for the specified kernel, including the patch to
    the kernel and any arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – grubby kernel info](img/B18349_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – grubby kernel info
  prefs: []
  type: TYPE_NORMAL
- en: 'With these kernel details, we remove the `rhgb quiet` configuration from the
    kernel arguments and add a new `test` by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we used the kernel name to update the arguments on that kernel
    (we used the `–-remove-args` attribute to remove an argument configuration and
    the `--args` attribute to add a new one). Now, we can check whether the argument’s
    structure changed by running the `grubby –-info=$BOOTENV` command with the boot
    environment as seen in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you can always use the `man grubby` command to review all the options
    available within the `grubby` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – grubby info after making the change](img/B18349_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – grubby info after making the change
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned before, Oracle Linux comes with two flavors of kernels: the UEK,
    which is Oracle’s default flavor of Linux kernel, and the RHCK, which is compatible
    with the RHEL kernel. Regardless of what kernel is used, the rest of the operating
    system is the same; that is, it has the same applications, libraries, and file
    locations.'
  prefs: []
  type: TYPE_NORMAL
- en: This section will teach you how to switch the default kernel (UEK) to the RHCK
    and vice versa. So, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, once again, we will use the `grubby` command to check the default kernel
    in use and, again, to check all kernels available within your system by using
    the `grubby -–info=DEFAULT` and `grubby –-info=ALL` commands. The difference between
    the two commands is with the `DEFAULT` option, only the booting info is shown.
    With the `ALL` option, all available kernels are shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Kernel version before swapping to RHCK](img/B18349_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Kernel version before swapping to RHCK
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, you can see that, in this case, the default kernel
    in use is `/boot/vmlinuz-5.15.0-8.91.4.1.el8uek.x86_64`, which is a UEK flavor
    of the kernel. A UEK system should always have `uek` after `el#`. You can also
    check the current kernel using the `uname -``a` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – uname -a before swapping to the RHCK](img/B18349_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – uname -a before swapping to the RHCK
  prefs: []
  type: TYPE_NORMAL
- en: 'To check all the kernels available on the system, we could use the data from
    the previously run `grubby –info` command, or use the `rpm -qa` `kernel*core*`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Checking the kernels using the rpm command](img/B18349_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Checking the kernels using the rpm command
  prefs: []
  type: TYPE_NORMAL
- en: 'When checking all available kernels, we can quickly identify two versions of
    the UEK and two versions of the RHCK. For this example, we will use the RHCK version
    called `4.18.0-425.13.1.el8_7`, which is found in `boot` at `/boot/vmlinuz-` `4.18.0-425.13.1.el8_7`.
    So now, let’s use the `grubby –-set-default` command to make the selected RHCK
    the new default. We then check the default kernel using the `grubby --``info=DEFAULT`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Switching to the RHCK](img/B18349_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Switching to the RHCK
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it. Now all we need to do is reboot the system to reflect the kernel
    change. Then, if you want to switch it back to the previous RHCK flavor of the
    kernel, all you need to do is run the `grubby –-set-default` command again, but
    this time specify the name of the RHCK version that you want.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with UEFI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way hackers can compromise systems is by attacking the system before it
    boots. In order to prevent this, you must secure the operating system by enabling
    security in UEFI. In other words, you cannot run software if it cannot be trusted
    to execute code correctly because untrusted software can tamper with your bootloader
    or, even worse, compromise your firmware. To solve this, a new, secure method
    is required to boot systems, called UEFI. UEFI is implemented in the firmware
    and has become the interface between your hardware and the operating system, replacing
    the legacy BIOS firmware that was previously the industry default. A feature of
    UEFI is Secure Boot, which ensures that your system boots by only using software
    trusted by the hardware manufacturer of your system. In addition, it provides
    a verification mechanism (by verifying each piece of boot software by using cryptographic
    checksums and signatures) to ensure that the code that is launched is trusted
    by validating the boot loader before executing it (even before loading the operating
    system). If the feature is available, UEFI systems can also boot in legacy BIOS
    mode via a compatibility support module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To boot in UEFI mode, Oracle Linux requires the UEFI firmware to be present
    during the system installation as it is detected at installation time. Next, a
    GPT is automatically set up, creating an ESP on the `/boot/efi` mount, which contains
    the files needed for the UEFI booting. GPT is a way of storing partitioning information
    on a drive that includes information such as where partitions begin and end on
    a physical disk. GPT is a new standard that gradually replaces the MBR standard
    previously widely used. GPT doesn’t suffer from MBR’s limits, such as the number
    of partitions and the drivers’ size, with size limits depending on the operating
    system and its filesystems. Note that GPT is the type of partition table required
    by UEFI and was initiated by Intel.
  prefs: []
  type: TYPE_NORMAL
- en: MBR versus GPT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes to partitioning schemes on storage devices such as hard drives
    and solid-state drives, MBR and GPT are two distinct options. To help distinguish
    between the two, here are the primary differences to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: '**Partitioning capacity**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MBR**: Your computer’s MBR allows either four primary partitions or three
    primary partitions and one extended partition, which can be further divided into
    multiple logical partitions. However, it does have a capacity restriction of a
    maximum disk size of 2 TB.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPT**: By default, GPT can support up to 128 partitions and it is not limited
    in terms of partition count. Additionally, it can accommodate larger disk sizes
    of up to 9.4 ZB.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compatibility**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MBR**: MBR provides improved compatibility with legacy systems and operating
    systems. It is widely supported by BIOS-based computers, as well as old versions
    of Windows and Linux.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPT**: Modern systems, especially those utilizing UEFI instead of BIOS, exhibit
    better compatibility with GPT. This partitioning scheme is backed by most contemporary
    operating systems, such as Windows, macOS, and Linux.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When deciding whether to use MBR or GPT, it’s important to take into account
    factors such as disk size, desired partition count, compatibility needs, and the
    specific system or operating system you plan to use. For large disks and new systems,
    GPT is usually the better choice, while MBR remains viable for old systems or
    small disks that require compatibility with the older booting partition.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s run the `df -h` command to view the partitions in the system. Please
    notice that `/boot/efi` is mounted on the `/dev/sda1` partition in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – df -h command](img/B18349_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – df -h command
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the `ls -l /boot/efi/EFI/redhat` command, this directory contains
    a first-stage bootloader called `shimx64.efi`, a GRUB 2 bootloader called `grubx64.efi`,
    and a GRUB 2 configuration file called `grub.cfg`. The location of the `grub.cfg`
    file is different in BIOS mode as it resides in `/boot/grub2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `/etc/default/grub` file is responsible for containing the user settings
    for the `grub.cfg` file. Note that this file is also located in the same location
    when in BIOS mode. Furthermore, if you make any changes to this file, the `grub.cfg`
    file will need to be rebuilt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To rebuild the `grub.cfg` file, please use the `grub2-mkconfig` command specifying
    the output file, using the `-o` option, such as `/boot/efi/EFI/redhat/grub.cfg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The utility used to manage the UEFI boot process is called `efibootmgr` (it
    provides a boot menu showing the boot entries). It also allows us to manipulate
    boot entries by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Altering the boot order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating boot entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing boot entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the boot entry for the next boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can view a summary of boot entries by running the `efibootmgr` command
    with no options. For more details, add the `-v` option to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, boot `0004` (Oracle Linux) is the boot
    entry used to start the currently running system, called `BootCurrent`. `BootOrder`
    is the boot order used in the boot manager; consequently, the boot manager will
    boot the first active entry in the list. If it’s not successful, it will try the
    next entry, and so on. If you’re using UEFI on your system, `efibootmgr` is a
    handy command-line tool that enables you to manage your EFI boot entries. With
    this utility, you can easily view, create, modify, and delete boot entries in
    the EFI boot manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to delete a boot entry, you can use the `-B` option. In this case,
    we will delete the CDROM record (`0001`) option using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also change the boot order with the `-o` option. In the following command,
    we will change the boot order to make the UFEI shell the default boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Please use the `man` command to learn more about the `efibootmgr` command.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Be very careful when changing the config. Accidentally changing the boot order
    to a device that is not bootable can put you in a situation where you are recovering
    the system. This is even more important if you are running in an environment where
    you do not have access to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with Secure Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Secure Boot** is an additional optional feature implemented in UEFI intended
    to help prevent malware execution during a boot process. To enable or disable
    Secure Boot, you need to access your specific UEFI setup program. This is different
    for each system manufacturer. Check your system documentation to see how to access
    the UEFI configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Secure Boot steps are identical to the regular UEFI booting but an important
    exception is that it requires the components to be signed and authenticated to
    be loaded and executed (private and public key pairs are used for authentication).
    It consists of two launch **Roots of Trust** (**RoT**) to build the transitive
    trust chains:'
  prefs: []
  type: TYPE_NORMAL
- en: The verification RoT is responsible for the signature verification. The verification
    RoT is the launch RoT, which is what most are referring to when speaking about
    Secure Boot, and it will lie on the boot flash drive as the RoT for storage to
    protect the key database. Verify only after the **Driver eXecution Environment**
    (**DXE**) phase, not during the **SECurity** (**SEC**) phase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The measurement RoT is responsible for the measurement collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Secure Boot will establish a chain of trust by following this process:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the first-stage bootloader (shim) signed by Oracle and Microsoft is authenticated;
    then, it loads the GRUB 2 loader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The GRUB 2 bootloader validates the kernel signature signed by Oracle and authenticates
    it before loading and executing the kernel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The kernel signed by Oracle is authenticated and executed. Secure Boot loads
    signed/authenticated kernel modules only (for example, all kernel modules included
    with the kernel RPM and those used with Oracle Ksplice have the corresponding
    Oracle signatures and the signed/authenticated kernel module running validated,
    or they would not be loaded).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have covered some basics of Secure Boot, let’s learn how to sign
    kernel modules with it. First, before you can sign a module, you will need to
    install several required packages, including the source for the kernel. Furthermore,
    you will need to create a signing certificate for a key pair. The private key
    is used to sign the kernel module, and a public key is added to Secure Boot to
    a kernel keyring to allow the system to verify the signature.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to install the UEK development libraries. This is done with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While you can just run `dnf install kernel-uek-devel`, adding the `uname` option
    to the command makes sure that you install the `devel` packages for the kernel
    you are currently running. Also, don’t forget to make sure your `devel` packages
    are updated after you patch.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a good practice, it is always recommended to update the system to ensure
    that you have the most recent kernel and related packages available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This update can take some time, depending on when you last patched the system.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the UEK, the kernel headers required to compile kernel modules
    are available in the `kernel-uek-devel` package. When using the UEFI Secure Boot
    functionality, Oracle recommends installing and using the UEK. When installing
    the UEK, also install the `devel` packages. `uname -r` is added to the command
    to make sure the correct headers are installed. This is important if you are not
    running on the latest kernel version. If you are using the RHCK, use `kernel-devel`
    instead of `kernel-uek-devel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to install the utilities required to perform the module signing
    operations (`openssl`, `keyutils`, `mokutil`, and `pesign`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you require building a module from a source, you can optionally install
    the `Development Tools` group to ensure the option to create tools is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a configuration file that OpenSSL can use to obtain default values when
    generating your certificates. You can create this file at any location, but it
    is useful to keep it with the rest of your OpenSSL configuration in `/etc/ssl/x509.conf`.
    The file should look similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should edit the `O`, `CN`, and `emailAddress` fields to be more appropriate.
    Note that in the `extensions` section of the configuration, the `keyUsage` field
    is set as `digitalSignature`. Additionally, the `extendedKeyUsage` option is set
    to `codeSigning` for compatibility with key verification tools.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Generate a new key pair using this configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This signing certificate is valid for 10 years (3,650 days). Ensure that the
    keys are adequately protected. This can be done by copying the keys off the server
    and storing them in a secure location. Placing the keys on a USB stick and putting
    that in a desk drawer is *not* a secure location. Use a locked location, such
    as a safe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Export the certificate in PEM format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Signing the module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sign-file` utility ensures that the module is signed correctly for the
    kernel. This utility is provided within the kernel source. The following instructions
    assume that you are signing a module for the currently running kernel. If you
    intend to sign a module for a different kernel, you must provide the path to the
    `sign-file` utility within the correct kernel version source. If you do not use
    the right utility, the signature type for your module may not align correctly
    with the expected signature type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sign the module, run the `sign-file` utility for your currently running
    kernel and provide it with the path to your private key and the public key that
    you created for the purpose of signing your modules (for this example, I''ve used
    a public module called `hello`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that the module should already be installed into `/lib/modules/`, and you
    need to provide the correct path to the module.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Machine Owner Key database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Machine Owner Key** (**MOK**) is a security feature designed to protect the
    boot process of a computer system from unauthorized modifications or attacks.
    It is typically used in systems that support **UEFI** and Secure Boot, which require
    all bootloaders and kernel modules to be signed by trusted entities.'
  prefs: []
  type: TYPE_NORMAL
- en: The MOK database is stored in a non-volatile memory location within the system’s
    firmware and contains a list of public keys that are allowed to sign the bootloaders
    and kernel modules. Each key in the MOK database is associated with a unique identifier
    and is used to verify the digital signature of the bootloaders and kernel modules.
    If a digital signature is valid, the boot process continues and the software is
    loaded. If a digital signature is not valid or the key used to sign the software
    is not in the MOK database, the boot process is halted and the system will not
    boot.
  prefs: []
  type: TYPE_NORMAL
- en: To enroll an MOK key, you must manually do so on each target system using the
    UEFI system console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the key that you created is not included in the UEFI Secure Boot key
    database, you must enroll in the MOK database in the shim by using the `mokutil`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The previous command prompts you for a single-use password that you use when
    the MOK management service enrolls the key after you reboot the system.
  prefs: []
  type: TYPE_NORMAL
- en: Reboot the system
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The UEFI shim should automatically start the shim UEFI key manager at boot,
    as shown in the following figure. If you do not hit any key within 10 seconds,
    you will be unable to enroll your MOK key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Shim utility](img/B18349_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Shim utility
  prefs: []
  type: TYPE_NORMAL
- en: Press any key to continue.
  prefs: []
  type: TYPE_NORMAL
- en: Then you should see the shim main menu. Select **Enroll MOK** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Shim main menu](img/B18349_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Shim main menu
  prefs: []
  type: TYPE_NORMAL
- en: This will let you continue to enroll the key or view the key.
  prefs: []
  type: TYPE_NORMAL
- en: Select **View key 0** from the menu (as shown in the following figure) to display
    the key details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.13 – View key](img/B18349_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – View key
  prefs: []
  type: TYPE_NORMAL
- en: 'This will then display the key details. Verify that the values presented match
    the key you used to sign the module and that you inserted into the kernel image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Key details](img/B18349_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Key details
  prefs: []
  type: TYPE_NORMAL
- en: Then press any key to return to the **Enroll** **MOK** menu.
  prefs: []
  type: TYPE_NORMAL
- en: Select **Continue** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Enroll the key(s)?** screen is displayed, and you can now select **Yes**
    from the menu (as shown in the following figure).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Enrolling the key](img/B18349_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Enrolling the key
  prefs: []
  type: TYPE_NORMAL
- en: Select **Yes** to enroll the key.
  prefs: []
  type: TYPE_NORMAL
- en: You will then be prompted for a password. Enter the password you used when you
    imported the key using the `mokutil` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key is enrolled within the UEFI Secure Boot key database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You are now redirected to the main menu. Select **Reboot** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Reboot when done](img/B18349_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – Reboot when done
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After booting the system, you can validate whether a key is included in the
    appropriate kernel keyring. Validation depends on the kernel version that you
    are running. Also, the keyring name that you need to check varies, as the implementation
    has changed across kernel versions.
  prefs: []
  type: TYPE_NORMAL
- en: If the key generated for signing custom modules is listed within the correct
    keyring, you can load modules signed with this key while in Secure Boot mode.
  prefs: []
  type: TYPE_NORMAL
- en: For RHCK on Oracle Linux 8 and UEK R6U3 kernels or later, keys within both the
    `builtin_trusted_keys` keyring and the `platform` keyring are trusted for both
    module signing and for the `kexec` tools, which means you can follow the standard
    procedure to sign a module and add it to the MOK database for the key to appear
    in the `platform` keyring, and it is automatically trusted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because a key can be loaded into the `builtin_trusted_keys` keyring, you should
    check both keyrings for the module signing key. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: TrenchBoot – improving boot security and integrity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**TrenchBoot** is a GitHub cross-community and cross-platform framework integration
    that grew from an idea by Apertus Solutions that originated in 2014 to deal with
    the limitations of using tboot to launch Xen for the OpenXT project and other
    contributors, such as Oracle (Intel), 3mdep (AMD), and Citrix ([https://github.com/TrenchBoot](https://github.com/TrenchBoot)).
    Its primary purpose is to expand the mechanism of security and the integrity of
    the boot process by using a standard and unified approach (between Xen, KVM, Linux,
    BSDs, and potentially proprietary kernels). A common location where you will see
    this being used is Oracle Cloud’s shielded instances.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the main capabilities of TrenchBoot is securely launching Linux. This
    feature enables the Linux kernel to be dynamically launched by AMD and Intel by
    introducing an intermediate phase to the boot launch. Unlike traditional first-launch
    scenarios, such as the bootstrap phase used by open source dynamic launch tools
    such as XMHF, OSLO, OpenText Secure Boot, and tboot, TrenchBoot provides the ability
    to launch kernel upgrades through a key exec. You could then launch an integrity
    kernel that could dynamically inspect the system and establish the integrity of
    the platform before persisting everything to a diskless embedded environment during
    a shutdown. Note that the newly introduced **intermediate p****hase** includes
    an **intermediate loader** called **TrenchBoot Loader** that various bootstrap
    solutions can launch. TrenchBoot Loader contains the **TrenchBoot Security Engine**,
    which implements integrity processing. Please refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – TrenchBoot process overview](img/B18349_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – TrenchBoot process overview
  prefs: []
  type: TYPE_NORMAL
- en: Oracle has added more TrenchBoot support to the Oracle Linux kernel to enable
    a Secure Boot protocol for the Linux kernel for multiple use cases, such as **two-factor
    authentication** (**2FA**) for laptops or crowdsourcing integrity handling; this
    option is the best choice.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can see some of Oracle’s efforts by reading the kernel.org archive at [https://lore.kernel.org/lkml/20230504145023.835096-1-ross.philipson@oracle.com/](mailto:https://lore.kernel.org/lkml/20230504145023.835096-1-ross.philipson@oracle.com/).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The TrenchBoot Loader is composed of well-known components such as Linux and
    u-root. Let’s take a closer look at the main components within it:'
  prefs: []
  type: TYPE_NORMAL
- en: A TrenchBoot-enabled kernel with integrated TrenchBoot u-root initramfs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrated TrenchBoot Security Engine as an extension to u-root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new image that can be launched by the boot loader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This build process is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – TrenchBoot image process](img/B18349_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – TrenchBoot image process
  prefs: []
  type: TYPE_NORMAL
- en: 'The main benefits of using TrenchBoot are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure boot**: TrenchBoot provides a Secure Boot process that ensures that
    only trusted software is executed on the system. This prevents the execution of
    malicious software that could compromise the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime integrity**: TrenchBoot ensures that the system remains secure even
    after booting by verifying the integrity of the software and data at runtime.
    It uses technologies such as Intel SGX and AMD SEV to provide hardware-based isolation
    and attestation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protection against attacks**: TrenchBoot provides protection against various
    types of attacks, including firmware attacks, malware, and kernel rootkits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform-agnostic**: TrenchBoot is platform-agnostic and can be used on different
    hardware platforms, including x86, Arm, and RISC-V.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open source**: TrenchBoot is an open source project, which means that anyone
    can inspect the code and contribute to its development. This makes TrenchBoot
    more transparent and trustworthy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the RHCK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to remove RHCK and its unique package dependencies
    while keeping all of UEK dependencies. Remember that when installing Oracle Linux,
    the installer automatically installs the Oracle UEK as the default kernel, but
    you can install RHCK for compatibility purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Old versions of Oracle Linux required a special tool called the `kernel-transition`
    package to manage dependencies. With new versions of Oracle Linux, a much easier
    process is available. For example, with Oracle Linux 8, this requirement is obsolete.
    All packages are purposely built to avoid any dependencies with regard to the
    system running on a UEK or RHCK. This makes it significantly easier to remove
    the UEK or RHCK from the system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see how to remove RHCK from our system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s check all kernels running within our system by using the `grubby`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Checking the kernels](img/B18349_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – Checking the kernels
  prefs: []
  type: TYPE_NORMAL
- en: We can see in the preceding output that the default kernel in use is `/boot/vmlinuz-5.15.0-8.91.4.1.el8uek.x86_64`,
    which is a UEK; also, we can see that we have a couple of RHCKs installed, `/boot/vmlinuz-4.18.0-425.13.1.el8_7.x86_64`
    and `/boot/vmlinuz-4.18.0-425.3.1.el8.x86_64`, that we can safely remove.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know that we are using a UEK, we can safely remove the desired RHCK
    using the `dnf remove kernel` command as recommended in the Oracle Linux manual.
    It will detect the unused kernels and show the dependencies within them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.20 – dnf remove kernel](img/B18349_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 – dnf remove kernel
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, both installed RHCKs were detected
    and deleted from the system. Now, let’s run the `grubby` command again to see
    whether the RHCKs were really removed from our system boot options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Do not run `dnf remove kernel` a second time. This may accidentally remove the
    booting kernel, resulting in a system that will no longer boot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – RHCK removed](img/B18349_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 – RHCK removed
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, both kernels are still there. The RHCK `kernel-<version>` package is
    merely a metadata package containing no files. It is intended to ensure all dependent
    kernel packages are correctly installed. So, in other words, removing the `"kernel-<version>.el8"`
    RPM does not remove any of the kernel-subpackages, which includes the packages
    that update the `/boot` associated files and the boot loader entries.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this situation, we need to remove the corresponding `kernel-core-<version>`
    packages containing the `/boot/` and all kernel-related files/directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, we will use the `dnf erase kernel-core`
    command to remove all related `kernel-core` packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.22 – dnf erase kernel-core](img/B18349_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 – dnf erase kernel-core
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s rerun the `grubby` command to see whether the RHCKs were removed
    this time from our system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 –  grubby post RHCK removal](img/B18349_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.23 – grubby post RHCK removal
  prefs: []
  type: TYPE_NORMAL
- en: As you can now see, all RHCKs were removed from our system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, if you later decide to restore the deleted RHCKs, you can quickly
    restore them using the `dnf install` `kernel` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 – Reinstalling the RHCK](img/B18349_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.24 – Reinstalling the RHCK
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, with Oracle Linux, switching kernels is a simple task, as is
    removing kernels from the operating system. When you have a chance, compare the
    system performance between the RHCK and UEKs; you will be pleasantly surprised
    how much faster tasks such as I/O are with the more modern UEK.
  prefs: []
  type: TYPE_NORMAL
