- en: Database Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库管理
- en: No application stack is complete without data, and this is commonly stored in
    a database. There is a myriad of databases to choose from when your platform is
    Linux, and the whole topic of database management and administration often warrants
    entire books by itself—in fact, normally one book per database technology. In
    spite of the vastness of this topic, a little knowledge of Ansible can assist
    greatly when it comes to database administration.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 没有数据的应用栈是不完整的，而数据通常存储在数据库中。对于 Linux 平台而言，数据库的选择众多，数据库管理和管理的整个主题通常需要专门的书籍来讨论——实际上，通常每种数据库技术都有一本书。尽管这个话题非常广泛，但了解一些
    Ansible 知识对于数据库管理帮助巨大。
- en: Indeed, whether you are installing a new database server, or performing maintenance
    or administration tasks on an existing one, our original principles discussed
    in [Chapter 1](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml), *Building a Standard
    Operating Environment on Linux* still apply. Indeed, why would you go to all the
    trouble of standardizing your Linux environment and ensuring all changes are automated,
    only to insist on manual management of the database tier? This could easily result
    in a lack of standardization, auditability, and even traceability (for example,
    who made which changes, and when?). Ansible can perform database operations and
    configuration via modules. It is perhaps not a replacement for some of the more
    advanced database management tools available on the market, but if these can be
    driven through the command line, it can execute these on your behalf, as well
    as taking care of many tasks itself. Ultimately, you want all changes to be documented
    (or self-documented) and auditable, and Ansible (combined with Ansible Tower,
    or AWX) can help you achieve this. This chapter explores methods that will help
    you with this.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，无论是安装新的数据库服务器，还是对现有数据库服务器进行维护或管理，我们在[第 1 章](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml)中讨论的原始原则，*在
    Linux 上构建标准操作环境*，仍然适用。的确，你为什么要费力地去标准化你的 Linux 环境并确保所有变更都自动化处理，却还要坚持手动管理数据库层呢？这很可能导致缺乏标准化、审计能力，甚至追溯能力（例如，谁在什么时候做了哪些更改？）。Ansible
    可以通过模块执行数据库操作和配置。它可能无法替代市场上更高级的数据库管理工具，但如果这些工具可以通过命令行操作，Ansible 可以代替你执行这些操作，并且可以自己处理许多任务。最终，你希望所有的更改都能被记录（或自我记录）并可审计，而
    Ansible（结合 Ansible Tower 或 AWX）可以帮助你实现这一目标。本章将探讨一些帮助你实现这一目标的方法。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Installing databases with Ansible
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 安装数据库
- en: Importing and exporting data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入和导出数据
- en: Performing routine maintenance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行常规维护
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter includes examples, based on the following technologies:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括基于以下技术的示例：
- en: Ubuntu Server 18.04 LTS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Server 18.04 LTS
- en: CentOS 7.6
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CentOS 7.6
- en: Ansible 2.8
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.8
- en: 'To run through these examples, you will need access to two servers or virtual
    machines running one each of the operating systems just listed, and also, Ansible.
    Note that the examples given in this chapter may be destructive in nature (for
    example, they add and remove databases and tables, and change database configuration)
    and, if run as is, are only intended to be run in an isolated test environment.
    Once you are satisfied that you have a safe environment in which to operate, let''s
    get started on looking at the installation of new software packages with Ansible.
    All example code discussed in this chapter is available from GitHub, at the following
    URL: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter11](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter11).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些示例，你需要访问两台服务器或虚拟机，每台运行上述提到的操作系统，并且需要安装 Ansible。请注意，本章中的示例可能具有破坏性（例如，它们会添加和删除数据库及表，并更改数据库配置），如果按原样运行，它们仅应在隔离的测试环境中运行。确保你有一个安全的环境来执行这些操作后，我们就可以开始讨论如何使用
    Ansible 安装新的软件包了。本章讨论的所有示例代码可以从 GitHub 获取，网址如下：[https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter11](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter11)。
- en: Installing databases with Ansible
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 安装数据库
- en: In [Chapter 7](200bea26-7066-4feb-a571-481a5f047ae4.xhtml), *Configuration Management
    with Ansible*, we explored a few examples of package installation and used MariaDB
    server in some of our examples. Of course, MariaDB is only one of a myriad of
    databases available on Linux, and there are too many to cover in detail here.
    Nonetheless, Ansible can help you install just about any database server on Linux,
    and in this chapter, we will proceed through a series of examples that will provide
    you with the tools and techniques to install your own database server, no matter
    what it is.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](200bea26-7066-4feb-a571-481a5f047ae4.xhtml)，*使用Ansible进行配置管理*，我们探讨了一些软件包安装的示例，并在其中使用了MariaDB服务器。当然，MariaDB只是Linux上众多可用数据库中的一个，这里无法详细覆盖所有内容。尽管如此，Ansible可以帮助您在Linux上安装几乎任何数据库服务器，在本章中，我们将通过一系列示例为您提供安装自己数据库服务器的工具和技术。
- en: Let's get started in the next section, by building on our example of installing
    MariaDB.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节开始，基于我们安装MariaDB的示例继续进行。
- en: Installing MariaDB server with Ansible
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible安装MariaDB服务器
- en: Although earlier in the book, we installed the native `mariadb-server` package
    that ships with CentOS 7, most enterprises that need a MariaDB server would choose
    to standardize on a specific release directly from MariaDB. This is often more
    up to date than the version shipped with a given Linux release, and hence provides
    newer features and, sometimes, performance improvements. In addition, standardizing
    on a release directly from MariaDB ensures consistency of your platform, a principle
    we have kept to throughout this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在本书的早些章节中，我们安装了随CentOS 7一起提供的本机`mariadb-server`软件包，但大多数需要MariaDB服务器的企业会选择直接从MariaDB标准化到特定版本。这通常比随特定Linux发布版本提供的版本更新，并因此提供了更新的功能和有时的性能改进。此外，标准化到直接从MariaDB获取的版本可以确保平台的一致性，这是我们在本书中始终坚持的原则。
- en: Let's take a simple example—suppose you are running your infrastructure on **Red
    Hat Enterprise** **Linux** (**RHEL**) 7\. This ships with MariaDB version 5.5.64\.
    Now, suppose you want to standardize your infrastructure on the newly released
    RHEL 8—if you are relying on the packages supplied by Red Hat, this suddenly moves
    you to version 10.3.11 of MariaDB, meaning not only an upgrade to your Linux infrastructure
    but also to your databases, too.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个简单的例子——假设您的基础架构正在运行**Red Hat Enterprise Linux**（**RHEL**）7。这个版本预装了MariaDB
    5.5.64。现在，假设您希望将基础架构标准化到新发布的RHEL 8上——如果您依赖Red Hat提供的软件包，那么这将立即升级您的MariaDB版本至10.3.11，这意味着不仅仅是Linux基础架构的升级，还包括数据库的升级。
- en: Instead, it would be better to standardize upfront on a release directly from
    MariaDB itself. At the time of writing, the latest stable release of MariaDB is
    10.4—but let us suppose that you have standardized on the 10.3 release, as it
    is known, and tested successfully in your environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，最好是预先在MariaDB本身的发布上进行标准化。在撰写本文时，MariaDB的最新稳定版本是10.4——但假设您已经标准化到已知并在您的环境中成功测试过的10.3版本。
- en: The installation process is quite straightforward and is well documented on
    the MariaDB website—see [https://mariadb.com/kb/en/library/yum/](https://mariadb.com/kb/en/library/yum/)
    for CentOS- and Red Hat-specific examples. However, this details the manual installation
    process, and we wish to automate this with Ansible. Let's now build this into
    a real, working Ansible example.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程非常简单，并且在MariaDB网站上有很好的文档说明——请参阅[https://mariadb.com/kb/en/library/yum/](https://mariadb.com/kb/en/library/yum/)，获取针对CentOS和Red
    Hat的具体示例。然而，这些详细说明了手动安装过程，而我们希望使用Ansible进行自动化。现在让我们将其构建为一个真实且有效的Ansible示例。
- en: In this example, we will follow the instructions from MariaDB, which includes
    downloading the packages from their repository. Although for simplicity we will
    follow this example through, you could mirror the MariaDB package repositories
    into Pulp or Katello, as detailed in [Chapter 8](56007c92-a39b-4e56-9b01-a137eab2369d.xhtml),
    *Enterprise Repository Management* *with Pulp* and [Chapter 9](f5ffd33a-aabf-419c-95b2-c5a308f24b2f.xhtml),
    *Patching with Katello*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将按照MariaDB的说明进行操作，包括从其存储库下载软件包。尽管出于简单起见，我们将继续按照这个示例进行操作，但您也可以将MariaDB软件包存储库镜像到Pulp或Katello中，详细内容请参见[第8章](56007c92-a39b-4e56-9b01-a137eab2369d.xhtml)，*使用Pulp进行企业存储库管理*
    和 [第9章](f5ffd33a-aabf-419c-95b2-c5a308f24b2f.xhtml)，*使用Katello进行补丁管理*。
- en: First of all, we can see from the installation documentation that we need to
    create a `.repo` file, to tell `yum` where to download the packages from. We can
    use a template to provide this, such that the MariaDB version can be defined by
    a variable and thus changed in the future when migration to version 10.4 (or indeed,
    any other future version) is deemed necessary.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以从安装文档中看到，我们需要创建一个 `.repo` 文件，以告诉 `yum` 从哪里下载软件包。我们可以使用模板来提供这个文件，以便 MariaDB
    版本可以通过变量定义，从而在将来迁移到 10.4 版本（或其他任何未来版本）时能够进行更改。
- en: 'Thus, our template file, defined in `roles/installmariadb/templates/mariadb.repo.j2`,
    would look like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的模板文件，定义在 `roles/installmariadb/templates/mariadb.repo.j2` 中，将如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we have created this, we should also create a default for this variable,
    to prevent any issues or errors if it is not specified when the role is run—this
    will be defined in `roles/installmariadb/defaults/main.yml`. Ordinarily, this
    variable would be provided in the inventory file for a given server or group of
    servers, or by one of the many other supported methods in Ansible, but the `defaults`
    file provides a catch-all, in case it gets overlooked. Run the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了这个文件，我们还应该为这个变量创建一个默认值，以防在执行角色时未指定该变量而导致任何问题或错误——这个默认值将在 `roles/installmariadb/defaults/main.yml`
    中定义。通常情况下，这个变量会在给定服务器或服务器组的库存文件中提供，或者通过 Ansible 支持的其他方法提供，但 `defaults` 文件提供了一种兜底方式，以防它被忽略。运行以下代码：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With this defined, we can now begin to build up the tasks in our role in `roles/installmariadb/tasks/main.yml`,
    as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义好之后，我们可以开始在 `roles/installmariadb/tasks/main.yml` 中构建任务，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will ensure that the correct repository file is written to the server,
    and if it is ever incorrectly modified, restored to its original, desired state.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以确保正确的仓库文件被写入服务器，如果它被错误修改，也能恢复到原来的期望状态。
- en: On CentOS or RHEL, you could also use the `yum_repository` Ansible module to
    perform this task—however, this has the disadvantage of being unable to modify
    an existing repository definition, and so, in a scenario where we might wish to
    change the repository version in future, we are better off using a template.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 或 RHEL 上，你还可以使用 `yum_repository` Ansible 模块来执行此任务——但是，这样做的缺点是无法修改现有的仓库定义，因此，如果将来我们需要更改仓库版本，最好使用模板。
- en: Next, we should clean out the `yum` cache—this is especially important when
    upgrading MariaDB to a new version, as package names will be the same, and cached
    information could cause issues with the installation. At present, cleaning the
    `yum` cache is achieved using the `shell` module, to run the `yum clean all` command.
    However, as this is a shell command, it will always run, and this could be considered
    inefficient—especially as this command being run would result in any future package
    operations needing to update the yum cache again, even if we didn't modify the
    MariaDB repository definition. Thus, we want to run it only when the `template`
    module task results in a changed state.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们应该清理 `yum` 缓存——这在升级 MariaDB 到新版本时尤其重要，因为软件包名称相同，缓存的信息可能会导致安装出现问题。目前，清理
    `yum` 缓存是通过使用 `shell` 模块运行 `yum clean all` 命令来实现的。然而，由于这是一个 shell 命令，它会始终运行，这可能被认为是低效的——尤其是当这个命令运行时，任何未来的包操作都需要再次更新
    yum 缓存，即使我们没有修改 MariaDB 仓库定义。因此，我们希望仅在 `template` 模块任务结果为 changed 状态时才运行它。
- en: 'To do this, we must first add this line to our `template` task, to store the
    results of the task:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们必须先在 `template` 任务中添加这一行，以存储任务的结果：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, when we define our shell command, we can tell Ansible to only run it if
    the `template` task resulted in a `changed` state, as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们定义我们的 shell 命令时，我们可以告诉 Ansible 仅在`template`任务结果为`changed`状态时才运行它，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With our cache appropriately cleared out, we can then install the required
    MariaDB packages—the list used in the task shown in the following code block is
    taken from the MariaDB documentation referenced earlier in this section, but you
    should tailor it to your exact requirements:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理完缓存后，我们可以安装所需的 MariaDB 软件包——以下代码块中使用的列表来自前面本节引用的 MariaDB 文档，但你应该根据自己的具体需求进行调整：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The use of `state: latest` ensures that we always install the latest packages
    from the repository file created by our `template` task. Thus, this role can be
    used equally for initial installation and upgrade to the latest version. However,
    if you do not want this behavior, change this statement to `state: present`—this
    simply ensures that the packages listed are installed on our target host. If they
    are, it does not update them to the latest version—it simply returns an `ok` status
    and proceeds to the next task, even if updates are available.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 `state: latest` 确保我们始终从由 `template` 任务创建的仓库文件中安装最新的包。因此，这个角色可以用于初始安装和升级到最新版本。然而，如果你不希望这种行为，可以将这个语句改为
    `state: present`——这仅仅确保列出的包已安装在我们的目标主机上。如果已经安装，它不会将它们更新到最新版本——它只是返回一个 `ok` 状态并继续执行下一个任务，即使有更新可用。'
- en: 'With the packages installed, we must ensure that the server service is then
    started at boot time. We would probably also want to start it now so that we can
    perform any initial configuration work on it. Thus, we will add a final task to
    our `installmariadb` role that looks like this:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完包后，我们必须确保服务器服务在启动时自动启动。我们可能还想立即启动它，以便进行任何初步配置工作。因此，我们将在 `installmariadb`
    角色的最后添加一个任务，任务内容如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, we know that CentOS 7 has a firewall enabled by default—as such, we must
    change the firewall rules to ensure that our newly installed MariaDB server can
    be accessed. The task to perform this would look something like this:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们知道 CentOS 7 默认启用了防火墙——因此，我们必须更改防火墙规则，以确保我们新安装的 MariaDB 服务器可以被访问。执行此任务的操作看起来如下所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s now run this role and see it in action—the output should look something
    like this:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们运行这个角色并看看它的实际效果——输出应该如下所示：
- en: '![](img/7a175122-a7c8-46f2-918f-9c66561bb41e.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a175122-a7c8-46f2-918f-9c66561bb41e.png)'
- en: The output has been truncated to conserve space, but clearly shows the installation
    in progress. Note that the warning can safely be ignored—the Ansible engine has
    detected our `yum clean all` command and is helpfully advising us to use the `yum`
    module—however, the `yum` module in this instance does not provide the function
    we need, and hence, we used the `shell` module instead.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出已被截断以节省空间，但清晰地显示了安装过程中的进展。请注意，该警告可以安全忽略——Ansible 引擎检测到了我们的 `yum clean all`
    命令，并友好地建议我们使用 `yum` 模块——然而，在这个例子中，`yum` 模块并没有提供我们需要的功能，因此我们使用了 `shell` 模块。
- en: 'With the database installed and running, we have the following three high-level
    tasks to perform next:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并启动数据库后，我们接下来有以下三个高层任务要执行：
- en: Update the MariaDB configuration.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 MariaDB 配置。
- en: Secure the MariaDB installation.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保 MariaDB 安装的安全性。
- en: Load initial data (or schemas) into the database.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向数据库加载初始数据（或模式）。
- en: Of these tasks, we explored, in detail, methods to use the Ansible `template`
    module effectively to manage the MariaDB configuration in [Chapter 7](200bea26-7066-4feb-a571-481a5f047ae4.xhtml),
    *Configuration Management with Ansible* (see the *Making scalable dynamic configuration
    changes* section*)*. As such, we will not go into detail on this here—however,
    check the configuration file structure for your chosen version of MariaDB, as
    it might differ from that shown in the aforementioned chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些任务中，我们详细探讨了如何有效使用 Ansible 的 `template` 模块来管理 MariaDB 配置，详细内容请参见[第7章](200bea26-7066-4feb-a571-481a5f047ae4.xhtml)，《使用
    Ansible 进行配置管理》（参见*进行可扩展的动态配置更改*一节）。因此，我们在这里不会再详细讲解——不过，请检查你所选择版本的 MariaDB 配置文件结构，因为它可能与上述章节中显示的有所不同。
- en: If you have installed MariaDB RPMs on a platform such as CentOS, you can find
    out where the configuration files live, by running the command `rpm -qc MariaDB-server`
    in a root shell.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在像 CentOS 这样的平台上安装了 MariaDB RPM 包，你可以通过在 root shell 中运行命令 `rpm -qc MariaDB-server`
    来查找配置文件的位置。
- en: Thus, assuming that you have the installation and configuration of the database
    server in hand, let us proceed to secure it. This, at a bare minimum, will entail
    changing the `root` password, though good practice states that you should also
    remove remote root access, the `test` database, and the anonymous user accounts
    that come with a default MariaDB installation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，假设你已经掌握了数据库服务器的安装和配置，让我们继续确保它的安全性。最低要求是更改 `root` 密码，尽管良好的实践建议你还应该移除远程 root
    访问、`test` 数据库以及默认 MariaDB 安装时创建的匿名用户账户。
- en: MariaDB comes with a command-line utility called `mysql_secure_installation`,
    to perform exactly these tasks—however, it is an interactive tool and does not
    lend itself to automation with Ansible. Luckily, Ansible provides modules for
    interacting with the database that can assist us in performing exactly these tasks.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: MariaDB 附带了一个名为 `mysql_secure_installation` 的命令行工具，专门执行这些任务——然而，它是一个交互式工具，不适合与
    Ansible 一起自动化运行。幸运的是，Ansible 提供了与数据库交互的模块，可以帮助我们精确地执行这些任务。
- en: 'To separate out these tasks from the installation, we''ll create a new role
    called `securemariadb`. Before we can define the tasks, we must define a variable
    to contain the root password for the MariaDB installation. Note that normally,
    you would provide this in a more secure manner—perhaps through an Ansible Vault
    file, or using some of the advanced features in AWX or Ansible Tower. For simplicity,
    in this example, we will define a variables file in the role (in `roles/securemariadb/vars/main.yml`),
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些任务与安装过程分开，我们将创建一个名为 `securemariadb` 的新角色。在定义任务之前，我们必须定义一个变量来存储 MariaDB
    安装的 root 密码。请注意，通常情况下，您会以更安全的方式提供此信息——也许通过 Ansible Vault 文件，或使用 AWX 或 Ansible
    Tower 中的一些高级功能。为了简化示例，我们将在角色中定义一个变量文件（在 `roles/securemariadb/vars/main.yml` 中），如下所示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, let's build up the tasks for the role. Ansible includes a few native modules
    for use in database management, and we can make use of these here, to make the
    required changes to our MariaDB database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为角色构建任务。Ansible 提供了一些原生模块，可用于数据库管理，我们可以在这里利用它们，对 MariaDB 数据库进行所需的更改。
- en: Note, however, that some modules have certain Python requirements, and in the
    case of our example system—MariaDB on CentOS 7—we must install the `MySQL-python`
    package.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，某些模块有特定的 Python 要求，在我们的示例系统——CentOS 7 上的 MariaDB——的情况下，我们必须安装 `MySQL-python`
    包。
- en: 'Knowing this, the first step in building up our role is to install the prerequisite
    Python package, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点后，构建我们角色的第一步是安装必备的 Python 包，如下所示：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our most immediate task, once this is installed, is to set the password on
    the local root account, and prevent anyone from logging in without authentication.
    Run the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务，一旦安装完成，就是设置本地 root 账户的密码，并防止任何人未经身份验证登录。请运行以下代码：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So far, this is a textbook example of how to use the `mysql_user` module—however,
    there is a twist in our usage from here. The preceding example takes advantage
    of the fact that no root password is set—it is implicitly manipulating the database
    as `root`, by virtue of the fact that we will put `become: yes` in our `site.yml`
    file, and thus, the playbook will be run as `root`. At the time that this task
    is run, the root user has no password, and so, the above task will run satisfactorily.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，这还是一个教科书般的 `mysql_user` 模块使用示例——然而，从这里开始，我们的使用方式有些不同。前面的示例利用了没有设置 root
    密码的事实——它隐式地以 `root` 身份操作数据库，原因是我们将在 `site.yml` 文件中设置 `become: yes`，因此，playbook
    会以 `root` 身份运行。在此任务运行时，root 用户没有密码，因此，上述任务将顺利运行。'
- en: The answer to this is to add the `login_user` and `login_password` parameters
    to the module for all future tasks, to ensure that we have authenticated successfully
    with the database to perform the required tasks.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是为所有未来任务的模块添加 `login_user` 和 `login_password` 参数，以确保我们已经成功地通过身份验证与数据库进行交互，从而执行所需的任务。
- en: 'This role will only run successfully once as it is written—on the second run,
    a password will be set for the root MariaDB user, and the preceding task will
    fail. However, if we specify a `login_password` for the above task, and the password
    is blank (as in the initial run), the task will also fail. There are a number
    of ways around this, such as setting the old password in another variable or,
    indeed, committing to only running this role once. You could also specify `ignore_errors:
    yes` under this task so that, if the root password is already set, we simply carry
    on to the next tasks, which should run successfully.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '这个角色只会在第一次运行时成功——在第二次运行时，root MariaDB 用户的密码将被设置，前面的任务将失败。然而，如果我们为上述任务指定了 `login_password`，且密码为空（如在初次运行时），任务也会失败。有多种方法可以解决这个问题，比如在另一个变量中设置旧密码，或者确实只运行一次此角色。您还可以在该任务下指定
    `ignore_errors: yes`，这样，如果 root 密码已经设置，我们就可以继续执行后续任务，这些任务应该能够顺利运行。'
- en: 'With this condition understood, we now add another task to the role, to remove
    the remote root accounts, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了这个条件之后，我们现在为该角色添加另一个任务，即移除远程根账户，如下所示：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, this code is quite self-explanatory—however, note here too that running
    this task a second time will also yield an error, this time because on the second
    run, these privileges will not exist because we deleted them on the first run.
    Thus, this is almost certainly a role to run once only—or where careful consideration
    must be applied to the code and the error handling logic.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，这段代码自我解释性强——然而，也请注意，在第二次运行时会出现错误，因为第二次运行时，这些权限将不存在，因为我们在第一次运行时已将其删除。因此，这几乎肯定是一个只需运行一次的角色，或者在代码和错误处理逻辑中必须仔细考虑的地方。
- en: 'We now add a task to delete the anonymous user accounts, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加一个任务来删除匿名用户账户，如下所示：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You will see the use of a `loop` here—this is used to remove both the local
    and remote privileges within a single task. Finally, we remove the `test` database,
    which is redundant in most enterprise scenarios, by running the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这里使用了`loop`——这是用来在一个任务中删除本地和远程的权限。最后，我们通过运行以下代码删除`test`数据库，这是大多数企业场景中多余的数据库：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the role fully complete, we can run it in the usual manner, and secure
    our newly installed database. The output should look something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 角色完全完成后，我们可以像往常一样运行它，并保护我们新安装的数据库。输出应该类似于这样：
- en: '![](img/37b03b62-9e01-42aa-8a91-e69708f34d9b.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37b03b62-9e01-42aa-8a91-e69708f34d9b.png)'
- en: 'With these two roles and some input from [Chapter 7](200bea26-7066-4feb-a571-481a5f047ae4.xhtml),
    *Configuration Management with Ansible*, we have successfully installed, configured,
    and secured a MariaDB database on CentOS. This is, obviously, a very specific
    example—however, if you were to perform this on Ubuntu, the process would be very
    similar. The differences would be the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个角色和来自[第7章](200bea26-7066-4feb-a571-481a5f047ae4.xhtml)《使用Ansible进行配置管理》的部分输入，我们成功地在CentOS上安装、配置并加固了MariaDB数据库。显然，这是一个非常具体的示例——然而，如果你在Ubuntu上执行这个过程，方法也非常相似。不同之处在于：
- en: The `apt` module would be used in place of the `yum` module in all tasks.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有任务中，将使用`apt`模块替代`yum`模块。
- en: Package names would have to be changed for Ubuntu.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Ubuntu上，软件包名称需要更改。
- en: Defining the repository source would be performed under `/etc/apt` rather than
    `/etc/yum.repos.d`, with the file format adjusted accordingly.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义仓库源应在`/etc/apt`下进行，而不是在`/etc/yum.repos.d`，并相应调整文件格式。
- en: Configuration paths may be different for MariaDB on Ubuntu.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu上MariaDB的配置路径可能会有所不同。
- en: Ubuntu normally uses `ufw` instead of `firewalld`—by default, you might find
    that `ufw` is disabled, so, this step could be skipped.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu通常使用`ufw`而不是`firewalld`——默认情况下，你可能会发现`ufw`被禁用，因此，这一步可以跳过。
- en: With these changes taken into account, the preceding process can be very quickly
    adapted for Ubuntu (or, indeed, any other platform, provided the appropriate changes
    are made). Once the packages are installed and configured, as the modules such
    as `mysql_user` and `mysql_db` are cross-platform, they will work equally well
    on all supported platforms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些变化，前面的过程可以非常快速地调整为适用于Ubuntu（或者，实际上，任何其他平台，只要做出适当的更改）。一旦软件包安装和配置完成，由于诸如`mysql_user`和`mysql_db`等模块是跨平台的，它们将在所有支持的平台上正常工作。
- en: So far in this book, we have focused very heavily on MariaDB—this is not because
    of any inherent bias toward this database, nor indeed should it be inferred as
    any recommendation. It has simply been chosen as a relevant example and built
    upon throughout the text. Before we proceed to look at the process of loading
    data or schemes into a newly installed database, we will take a brief look in
    the next section at how to apply the processes we have learned so far to another
    popular Linux database—PostgreSQL.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们主要关注MariaDB——这并非因为对这个数据库有任何固有偏好，也不应被解读为任何推荐。它只是作为一个相关的示例，在整本书中不断展开。在我们继续学习如何将数据或模式加载到新安装的数据库中之前，我们将在下一节简要回顾如何将我们目前学到的过程应用于另一个流行的Linux数据库——PostgreSQL。
- en: Installing PostgreSQL Server with Ansible
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible安装PostgreSQL Server
- en: In this section, we will demonstrate how the principles and high-level processes
    we have looked at so far for MariaDB on CentOS can be applied to another platform.
    Taking a high-level view, these processes can be applied to almost any database
    and Linux platform, with the proper attention to detail. Here, we will install
    PostgreSQL Server onto Ubuntu Server, and then secure it by setting the root password—essentially,
    analogous to the process we have performed in the preceding section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示如何将我们到目前为止在 CentOS 上为 MariaDB 所学习的原则和高层流程应用到另一个平台。总体来看，这些流程可以应用于几乎任何数据库和
    Linux 平台，只要注意细节。这里，我们将在 Ubuntu Server 上安装 PostgreSQL Server，然后通过设置 root 密码来确保其安全——本质上，这与我们在前一节中所执行的过程类似。
- en: 'Let us get started by creating a role called `installpostgres`. In this role
    we will again define a template for the package downloads from the official PostgreSQL
    sources, this time—of course—tailoring it to the fact that we''re using Ubuntu
    Server, and not CentOS. The following code shows the template file—note that this
    is specific for Ubuntu Server 18.04 LTS—codename `bionic`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，首先创建一个名为 `installpostgres` 的角色。在这个角色中，我们将再次定义一个来自官方 PostgreSQL 源的软件包下载模板，这次——当然——将其调整为我们使用的是
    Ubuntu Server，而不是 CentOS。以下代码展示了模板文件——请注意，这对于 Ubuntu Server 18.04 LTS（代号 `bionic`）是特定的：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As before, once our package sources are defined, we can proceed to create the
    tasks that will install the database. In the case of Ubuntu, we must add the package-signing
    key manually to the `apt` keyring, in addition to copying the preceding template
    into place. Thus, our tasks within the role begin, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一旦我们定义了软件包源，就可以开始创建将安装数据库的任务。在 Ubuntu 系统中，我们必须手动将软件包签名密钥添加到 `apt` 密钥环中，除此之外，还需要将前面的模板复制到合适的位置。因此，我们在角色中的任务开始如下：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We could also use `apt_repository` here, but, for consistency with the previous
    MariaDB example, we are using template. Both will achieve the same end result.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在这里使用 `apt_repository`，但是为了与之前的 MariaDB 示例保持一致，我们使用了模板。两者都能达到相同的最终结果。
- en: 'When the `template` package is in place, we must then add the package-signing
    key to `apt`''s keyring, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `template` 软件包到位后，我们接着需要将软件包签名密钥添加到 `apt` 的密钥环中，如下所示：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `postgresql-11` and other supporting packages are then installed (as per
    the documentation at [https://www.postgresql.org/download/linux/ubuntu/](https://www.postgresql.org/download/linux/ubuntu/)),
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后安装 `postgresql-11` 及其他支持包（参考文档 [https://www.postgresql.org/download/linux/ubuntu/](https://www.postgresql.org/download/linux/ubuntu/)），如下所示：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As our default Ubuntu Server install is not running a firewall, the final task
    in this playbook is to start the service, and ensure it starts at boot time, as
    follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的默认 Ubuntu Server 安装没有运行防火墙，因此此剧本中的最后一项任务是启动服务，并确保它在启动时自动启动，如下所示：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running this should yield output similar to the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令应该会产生类似以下的输出：
- en: '![](img/e64ead5b-ee7d-4244-bd88-e1c56ff1eb4e.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e64ead5b-ee7d-4244-bd88-e1c56ff1eb4e.png)'
- en: By default, *out-of-the-box* installation of PostgreSQL is much more secure
    than MariaDB. Without additional configuration, no remote logins are allowed at
    all, and although no password is set for the superuser account, it can only be
    accessed on the local machine from the `postgres` user account. Similarly, there
    is no test database to drop.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，*开箱即用*的 PostgreSQL 安装比 MariaDB 更加安全。没有额外的配置时，远程登录完全不被允许，尽管超级用户账户没有设置密码，但它只能从本地机器上的
    `postgres` 用户账户进行访问。同样，也没有测试数据库可供删除。
- en: Thus, although the high-level process is the same, you must be aware of the
    nuances of both the database server you are using and the underlying operating
    system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管高层流程相同，但你必须注意所使用的数据库服务器和底层操作系统的细微差别。
- en: By way of example and to complete this section, let's create a database called
    `production`, and an associated user called `produser` who will be given access
    to it. Although technically, this overlaps with the next section on loading initial
    data, it is provided here to be analogous to the preceding section on MariaDB,
    and to demonstrate how to use the native Ansible modules for PostgreSQL.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例并完成本节内容，我们创建一个名为 `production` 的数据库，并创建一个名为 `produser` 的关联用户，该用户将获得访问权限。虽然从技术上讲，这与下一节关于加载初始数据的内容有所重叠，但这里提供它是为了类比前一节关于
    MariaDB 的内容，并展示如何使用 PostgreSQL 的本地 Ansible 模块。
- en: 'Let''s create a role called `setuppostgres`, and start by defining a task to
    install the Ubuntu package necessary to support the Ansible PostgreSQL modules,
    as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们来创建一个名为`setuppostgres`的角色，并首先定义一个任务来安装支持Ansible PostgreSQL模块所需的Ubuntu软件包，如下所示：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After this, we add a task to create the database (this is a very simple example—you
    will want to tailor it to your exact requirements), as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们添加一个任务来创建数据库（这是一个非常简单的示例—您需要根据您的具体需求进行调整），如下所示：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice how we leverage the local `postgres` account on the target machine for
    database superuser access with the `become_user` statement. Next, we''ll add the
    user, and give them privileges on this database, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们如何利用目标机器上的本地`postgres`账户，通过`become_user`语句实现数据库超级用户访问。接下来，我们将添加用户，并赋予他们该数据库的权限，如下所示：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As usual, you would not just specify the password in plaintext like this—this
    has been done here for simplicity. As usual, substitute appropriate data for variables,
    and if those variables are sensitive, either encrypt them at rest using Ansible
    Vault or prompt the user for them when the playbook is run.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，您不会像这样直接以明文形式指定密码—这里是为了简化而这么做的。通常，您应该为变量替换适当的数据，并且如果这些变量是敏感的，可以使用Ansible
    Vault加密它们，或者在剧本运行时提示用户输入。
- en: 'Now, to get PostgreSQL to listen for remote connections for this user, we need
    to perform two more actions. We need to add a line to `pg_hba.conf`, to tell PostgreSQL
    to allow the user we just created to access this database from the appropriate
    network—the following example is shown, but be sure to tailor it to your network
    and requirements:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了让PostgreSQL监听来自该用户的远程连接，我们还需要执行两个动作。我们需要在`pg_hba.conf`中添加一行，告诉PostgreSQL允许我们刚创建的用户从适当的网络访问该数据库—以下示例已显示，但请确保根据您的网络和需求进行调整：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We must also change the `listen_addresses` parameter in the `postgresql.conf`
    file, which defaults to local connections only. The exact location of this file
    will vary depending on your operating system and version of PostgreSQL—the following
    example shown is suitable for our install of PostgreSQL 11 on Ubuntu Server 18.04:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须更改`postgresql.conf`文件中的`listen_addresses`参数，该参数默认仅支持本地连接。此文件的具体位置会根据您的操作系统和PostgreSQL版本而有所不同—以下示例适用于我们在Ubuntu
    Server 18.04上安装的PostgreSQL 11：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Observant readers will have noticed the use of handlers here too—the `postgresql`
    service must be restarted to pick up any changes to this file. However, this should
    only be performed when the file is changed, and hence we make use of handlers.
    Our `handlers/main.yml` file will look like this:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 细心的读者会注意到这里也使用了处理程序—`postgresql`服务必须重启才能生效对该文件的任何更改。然而，这应仅在文件更改时执行，因此我们使用了处理程序。我们的`handlers/main.yml`文件将如下所示：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With our playbook assembled, we can now run it, and the output should look
    something like the following screenshot:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们组装完剧本后，现在可以运行它，输出应该类似于以下截图：
- en: '![](img/420b017b-3c12-4abc-a370-621bf44f930e.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/420b017b-3c12-4abc-a370-621bf44f930e.png)'
- en: Although this example is not strictly the same as the replication of the `mysql_secure_installation`
    tool in the previous section, it does show how to use native Ansible modules to
    configure and secure a PostgreSQL database and shows how Ansible can powerfully
    assist you in setting up and securing new database servers. These principles can
    be applied to just about any database server that is compatible with Linux, though
    the modules available for each database will vary. A full list of modules can
    be found here: [https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个示例与上一节中`mysql_secure_installation`工具的复制并不完全相同，但它展示了如何使用原生的Ansible模块配置和保护PostgreSQL数据库，并且展示了Ansible如何强力协助您设置和保护新的数据库服务器。这些原则可以应用于几乎任何与Linux兼容的数据库服务器，尽管每个数据库可用的模块可能不同。完整的模块列表可以在这里找到：[https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html)
- en: Now that we have looked at the process of installing a database server, in the
    next section, we will build on our installation work, to load initial data and
    schemas.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了安装数据库服务器的过程，在接下来的部分中，我们将基于安装工作加载初始数据和模式。
- en: Importing and exporting data
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入和导出数据
- en: No database is complete simply by installing the software and configuring it—often,
    there is a very important intermediate stage, which involves loading an initial
    dataset. This might be a backup from a previous database, a sanitized dataset
    for testing purposes, or, simply, a schema into which application data can be
    loaded.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 安装软件并配置数据库并不足以使其完整——通常，存在一个非常重要的中间步骤，涉及加载初始数据集。这可能是来自以前数据库的备份、用于测试的清理数据集，或者只是一个模式，用于加载应用程序数据。
- en: Although Ansible has modules for a limited set of database functions, the functionality
    here is not as complete as that for other automation tasks. The most complete
    support offered for a database by Ansible is for PostgreSQL—with lesser support
    for some other databases. Through some clever use of the `shell` module, any manual
    task that you can perform on the command line can be replicated into an Ansible
    task. It is up to you to apply logic to the tasks to handle errors or conditions
    where, for example, a database already exists, and we shall see an example of
    this in the next section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Ansible有一些模块可以实现有限的数据库功能，但在数据库管理方面，其功能并不像其他自动化任务那样完整。Ansible对数据库的最全面支持是PostgreSQL——对于其他数据库的支持较少。通过巧妙使用`shell`模块，您可以将命令行上执行的任何手动任务转换为Ansible任务。具体如何处理错误或特殊情况（例如数据库已经存在）则取决于您如何为任务应用逻辑，我们将在下一节中看到此类示例。
- en: In the next section, we will look at how you could use Ansible to automate the
    task of loading a sample database into a MariaDB database.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何使用Ansible自动化将示例数据库加载到MariaDB数据库中的任务。
- en: Automating MariaDB data loading with Ansible
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible自动化MariaDB数据加载
- en: MariaDB is a good choice for this chapter because it offers a middle-of-the-road
    view when it comes to database management with Ansible. There is some native module
    support in Ansible, but this is not complete for all tasks you might want to execute.
    As a result, we will develop the following example, which automates the loading
    of a sample set of data, using just the `shell` Ansible modules. We will then
    develop this to show how it would be completed with the `mysql_db` module, to
    provide you with a direct comparison between the two automation techniques.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: MariaDB是本章的一个好选择，因为它提供了一个中等程度的数据库管理视角，尤其是在使用Ansible时。Ansible提供了一些原生模块支持，但对于您可能需要执行的所有任务，它并不完全支持。因此，我们将开发以下示例，使用`shell`
    Ansible模块自动加载示例数据集。然后，我们将扩展这个示例，展示如何使用`mysql_db`模块来完成此任务，以便为您提供这两种自动化技术的直接对比。
- en: Note that the following examples performed using the `shell` module could be
    adapted for almost any database you can manage from the command line, and so it
    is hoped these will provide you with a valuable reference for automating your
    database management tasks.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下示例使用`shell`模块执行的操作可以适用于几乎任何可以通过命令行管理的数据库，因此希望这些示例能为您自动化数据库管理任务提供有价值的参考。
- en: 'In terms of example databases, we will work with the publicly available **Employees**
    sample database, as this is available to everyone reading this book. You can,
    of course, choose your own set of data to work with—however, it is, as ever, hoped
    that this following practical example will teach you the skills you need to load
    data into your newly installed database with Ansible:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例数据库方面，我们将使用公开可用的**Employees**示例数据库，因为这是所有阅读本书的人都可以访问的。您当然可以选择您自己的数据集来使用——然而，正如往常一样，希望以下实践示例能教会您使用Ansible将数据加载到新安装的数据库中的技能：
- en: 'To start with, let''s create a role called `loadmariadb`. Into the `roles`
    directory structure, create a directory called `files/`, and clone the `employees`
    sample database. This is publicly available on GitHub, and, at the time of writing,
    could be cloned using the following command:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为`loadmariadb`的角色。在`roles`目录结构中创建一个名为`files/`的目录，并克隆`employees`示例数据库。该数据库在GitHub上公开提供，在撰写本文时，可以通过以下命令克隆：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'From here, we create a `tasks/` directory within the role and write the code
    for our role tasks themselves. To start with, we need to copy the database files
    across to our database server, by running the following code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里开始，我们在角色目录中创建一个`tasks/`目录，并编写我们角色任务的代码。首先，我们需要通过运行以下代码，将数据库文件复制到我们的数据库服务器：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once the data files are copied to the server, it is simply a matter of loading
    them into the database. However, as there is no module for this task, we must
    revert to a shell command to handle this, as shown in the following code block:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦数据文件被复制到服务器，接下来只需要将其加载到数据库中。然而，由于没有用于此任务的模块，我们必须依赖 shell 命令来处理此操作，如下代码块所示：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The role tasks are simplicity themselves—however, before we can run the playbook,
    we need to set the `mariadb_root_password` variable, ideally in a vault, but for
    simplicity in this book, we will put it in a plaintext `vars` file in the role.
    The file `vars/main.yml` should look like this:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角色任务本身非常简单——然而，在我们运行剧本之前，我们需要设置 `mariadb_root_password` 变量，最好将其放在一个 vault 中，但为了简便起见，在本书中我们会将其放在角色中的纯文本
    `vars` 文件中。`vars/main.yml` 文件应如下所示：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you will have spotted, this playbook assumes that you already installed and
    configured MariaDB in a previous role—the password used in the preceding code
    block is that set in the previous section when we installed MariaDB and secured
    it using Ansible.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经发现的，这个剧本假设你已经在之前的角色中安装并配置了 MariaDB——前面代码块中使用的密码是我们在安装 MariaDB 并使用 Ansible
    安全配置时设置的密码。
- en: 'Running the playbook should yield results like this:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行剧本后，应该得到如下结果：
- en: '![](img/fa4e8d55-7e63-498e-8520-4962c88370d4.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa4e8d55-7e63-498e-8520-4962c88370d4.png)'
- en: Here, we have not only loaded a sample schema, but also sample data, into our
    database. In your enterprise, you could choose to perform either of these tasks
    in isolation, as required.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不仅加载了一个示例架构，还将示例数据加载到了数据库中。在你的企业中，你可以根据需要选择单独执行这两个任务中的任何一个。
- en: You will probably have spotted that this playbook is extremely dangerous. As
    we discussed previously, the issue with using the `shell` module in Ansible playbooks
    is that the results of the task will vary as the shell command is always run,
    whether it needs running or not. Thus, if you ran this playbook against a server
    with an existing database called `employees`, it would overwrite all the data
    in it with the sample data! Contrast this with the `copy` module, which only copies
    the files if they do not already exist on the receiving end.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这个剧本是极其危险的。正如我们之前讨论的，使用 Ansible 剧本中的 `shell` 模块的问题在于，任务的结果会有所不同，因为无论是否需要运行，shell
    命令都会被执行。因此，如果你在一个已有名为 `employees` 的数据库的服务器上运行此剧本，它将覆盖数据库中的所有数据，替换为示例数据！与此相比，`copy`
    模块仅在目标位置不存在文件时才会复制文件。
- en: Given the lack of native database modules at the time of writing, we need to
    devise a more intelligent way of running this command. Here, we can make use of
    some of the clever error handling built into Ansible.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于写作时缺乏原生的数据库模块，我们需要设计一种更智能的方式来运行此命令。在这里，我们可以利用 Ansible 内置的一些巧妙的错误处理机制。
- en: The `shell` module assumes that the command it is running has run successfully
    if it returns exit code zero. This results in the task returning the `changed`
    status we saw in this playbook run. However, if the exit code is not zero, the
    `shell` module will instead return a status of `failed`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`shell` 模块假设它正在运行的命令如果返回退出码为零，则表示命令成功运行。这导致任务返回我们在此剧本运行中看到的 `changed` 状态。然而，如果退出码不为零，`shell`
    模块将返回 `failed` 状态。'
- en: 'We can take advantage of this knowledge, and couple it with a useful MariaDB
    command that will return a zero exit code if the database we query exists, and
    non-zero if it doesn''t. See the following screenshot for an example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这个知识，并结合一个有用的 MariaDB 命令，若查询的数据库存在，则该命令返回零退出码，若不存在则返回非零退出码。请参见下面的截图示例：
- en: '![](img/185c8355-44d3-4a26-b99e-7ad5cbea9fa4.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/185c8355-44d3-4a26-b99e-7ad5cbea9fa4.png)'
- en: We can make use of this command by running it before our task that loads the
    data. We can ignore any errors from the command, and instead register them in
    a variable. We use this to conditionally run the data load, loading it only if
    an error occurred (this is the instance where the database does not exist, and
    so it is safe to load the data).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在加载数据的任务之前运行该命令来利用它。我们可以忽略该命令的任何错误，并将其注册到一个变量中。我们使用这个变量来有条件地运行数据加载，仅在出现错误时加载数据（即数据库不存在时，加载数据是安全的）。
- en: 'The copy task remains the same, but the tail end of the tasks now looks like
    this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy` 任务保持不变，但任务的尾部现在如下所示：'
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, we will only load the data if the database doesn't exist. This code has
    been kept simple for the sake of providing an example, and it is left to you to
    enhance it—for example, by putting the filenames and database name into a variable
    so that the role becomes reusable in a variety of circumstances (which, after
    all, is one of the goals of writing a role).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只在数据库不存在的情况下加载数据。为了提供一个简单的示例，这段代码保持简洁，剩下的部分留给你来增强——例如，可以将文件名和数据库名放入变量中，这样角色在不同情况下就能重用（毕竟，编写可重用角色是编写角色的目标之一）。
- en: 'If we now run this code, we can see that it operates as desired—on the first
    run, the data is loaded, as the following screenshot shows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行这段代码，我们可以看到它按预期工作——第一次运行时，数据被加载，如下图所示：
- en: '![](img/d14854d0-0c2d-4035-8843-ddaa7a583c0d.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d14854d0-0c2d-4035-8843-ddaa7a583c0d.png)'
- en: 'However, on the second run, it is not—the following screenshot shows the playbook
    being run a second time, and the data load task being skipped because the database
    exists:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在第二次运行时，它没有执行——以下截图显示了第二次运行的playbook，以及由于数据库已存在，数据加载任务被跳过的情况：
- en: '![](img/1063129d-0ed5-4518-8e18-e6dc0dcc2404.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1063129d-0ed5-4518-8e18-e6dc0dcc2404.png)'
- en: Although these examples are specific to MariaDB, the high-level process performed
    here should work with just about any database. The key element is to use the `shell`
    module to load the data and/or schema but to do so in a way that reduces the right
    of a valid database getting overwritten, in the event that the playbook gets run
    twice. You should extend this logic to any other task you perform—your ultimate
    goal should be that if your playbook is run unintentionally, then no damage is
    done to the existing database.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些示例特定于MariaDB，但这里执行的高层次过程应该适用于几乎任何数据库。关键是使用`shell`模块来加载数据和/或架构，但以一种减少有效数据库被覆盖的方式，以防playbook被重复运行。你应该将这一逻辑扩展到你执行的任何其他任务——你的最终目标应该是，如果playbook被意外运行，那么不会对现有数据库造成损害。
- en: 'Having completed this example, it is worth noting that Ansible does provide
    a module called `mysql_db`, which can natively handle tasks such as dumping and
    importing database data. Let''s now develop an example that makes use of the native
    `mysql_db` module:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个示例后，值得注意的是，Ansible确实提供了一个名为`mysql_db`的模块，可以原生处理诸如转储和导入数据库数据的任务。现在让我们开发一个使用原生`mysql_db`模块的示例：
- en: 'If we were to develop a role to perform exactly the same task as shown previously,
    but using this native module, we would first of all check to see if the database
    exists as before, registering the result to a variable, like this:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们开发一个角色，执行与之前相同的任务，但使用这个原生模块，首先要做的是像之前一样检查数据库是否存在，并将结果注册到一个变量中，如下所示：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We then create a `block` in our tasks file, as there is no point running any
    of the tasks after this step if the database exists. The `block` uses the `when`
    clause we used before, to determine whether the tasks inside it should run or
    not, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在任务文件中创建一个`block`，因为如果数据库已经存在，那么在这一步之后运行任何任务都没有意义。`block`使用了我们之前使用的`when`条件语句，用于判断其中的任务是否需要执行，如下所示：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Inside the `block`, we copy over all the SQL files to import just as we did
    before, like this:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`block`内部，我们像之前一样将所有SQL文件复制过来进行导入，如下所示：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, an important difference emerges between using the `shell` module, and `mysql_db`.
    When using the `shell` module, we used the `chdir` argument to change the working
    directory to `/tmp`, which is where all our SQL files were copied to. The `mysql_db`
    module has no `chdir` (or equivalent) argument, and so will fail when it comes
    to try to load the `*.dump` files that are sourced via `employees.sql`. To work
    around this, we use the Ansible `replace` module, to add the full path to these
    files into the appropriate lines in `employees.sql`, as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`shell`模块和`mysql_db`模块之间有一个重要的区别。当使用`shell`模块时，我们使用了`chdir`参数将工作目录切换到`/tmp`，这是所有SQL文件被复制到的地方。而`mysql_db`模块没有`chdir`（或等效的）参数，因此在尝试加载通过`employees.sql`引入的`*.dump`文件时会失败。为了解决这个问题，我们使用Ansible的`replace`模块，将这些文件的完整路径添加到`employees.sql`中的相应行，如下所示：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we use the `mysql_db` module to load in the data (this is analogous
    to the shell command we performed in our earlier example), as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`mysql_db`模块加载数据（这类似于我们之前示例中执行的shell命令），如下所示：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we run this code, it achieves the same end result as our previous role
    that used the `shell` module, as the following screenshot shows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，它达到了与我们之前使用`shell`模块的角色相同的最终结果，如下图所示：
- en: '![](img/335f97a1-02fb-4eb6-8e5f-a0fffd5f6e80.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/335f97a1-02fb-4eb6-8e5f-a0fffd5f6e80.png)'
- en: 'This process works equally well for backing up databases, too. If you were
    to use the `shell` module, you could use the `mysqldump` command to back up a
    database, and then copy the backed-up data to your Ansible host (or indeed, another)
    for archiving. A simple piece of example code to achieve this might be constructed
    as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程同样适用于数据库的备份。如果你使用`shell`模块，可以使用`mysqldump`命令来备份数据库，然后将备份的数据复制到你的Ansible主机（或其他主机）进行归档。以下是一段简单的示例代码来实现这一点：
- en: 'As we want the backup filename to be dynamic and include useful information
    such as the current date and hostname on which the backup is being performed,
    we use the `set_fact` module, along with some internal Ansible variables, to define
    a filename for the backup data, as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望备份文件名是动态的，并包含有用的信息，例如当前日期和正在执行备份的主机名，我们使用`set_fact`模块，结合一些内部的Ansible变量，来定义备份数据的文件名，如下所示：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We then use the `shell` module to run `mysqldump`, with the appropriate parameters
    for creating a backup—going into depth on these is beyond the scope of this book,
    but the following example creates a backup of all databases on your server, without
    locking the tables during the backup:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用`shell`模块运行`mysqldump`，并传入适当的参数来创建备份——深入讨论这些参数超出了本书的范围，但以下示例将创建一个服务器上所有数据库的备份，并且在备份过程中不会锁定表：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `fetch` module is then used to retrieve the data for archiving—fetch works
    just like the `copy` module that we used earlier in this section, except that
    it copies data in the reverse direction (that is, from the inventory host to the
    Ansible server). Run the following code:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fetch`模块用于检索数据以进行归档——`fetch`的工作方式与我们在本节前面使用的`copy`模块相同，只是它以相反的方向复制数据（即从库存主机到Ansible服务器）。运行以下代码：'
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Running this in the usual manner results in a complete backup of the database,
    with the resulting file being copied to our Ansible server, as the following screenshot
    shows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照常规方式运行会生成完整的数据库备份，备份文件将被复制到我们的Ansible服务器，以下截图展示了这一过程：
- en: '![](img/58a09392-6801-45a7-bfa7-dc4e2ea207e9.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58a09392-6801-45a7-bfa7-dc4e2ea207e9.png)'
- en: 'This example could also be achieved using the `mysql_db` module, just as we
    did before—the `set_fact` and `fetch` tasks remain exactly the same, while the
    `shell` task is replaced with the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例也可以使用`mysql_db`模块来实现，就像我们之前所做的那样——`set_fact`和`fetch`任务保持完全不变，而`shell`任务则替换为以下代码：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Thus, Ansible can assist you both with loading data into your databases and
    backing it up. As we have discussed previously, it is generally better to use
    the native Ansible modules (such as `mysql_db`) where they are available, but,
    provided you apply the correct logic to it, the `shell` module can assist you,
    if native modules don't exist or provide the functionality you need.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Ansible不仅可以帮助你将数据加载到数据库中，还可以帮助你进行备份。正如我们之前讨论的那样，通常最好使用原生的Ansible模块（如`mysql_db`），但如果原生模块不存在或无法提供所需的功能，只要你应用正确的逻辑，`shell`模块也能为你提供帮助。
- en: Now that we have considered the process of creating databases and loading data
    into them, we will proceed in the next section to demonstrate how to build on
    this work, to perform routine database maintenance with Ansible.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经考虑了创建数据库并加载数据的过程，我们将在下一节展示如何在此基础上进行扩展，使用Ansible执行常规的数据库维护任务。
- en: Performing routine maintenance
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行常规维护
- en: Loading schemas and/or data is not the only task you would perform with Ansible
    on a database. Sometimes, manual intervention is required in a database. For example,
    PostgreSQL requires VACUUM operations from time to time, to free up unused space
    in the database. MariaDB has a maintenance tool called `mysqlcheck` that can be
    used to verify the integrity of tables and perform optimization. Each platform
    will have its own specific tools for maintenance operations, and it is up to you
    to establish the best practices for database maintenance on your chosen platform.
    Furthermore, sometimes it is necessary to make simple changes to a database. For
    example, it might be necessary to delete (or update) a row from a table, to clear
    an error situation that has occurred in an application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 加载架构和/或数据并不是你使用Ansible在数据库上执行的唯一任务。有时，数据库需要手动干预。例如，PostgreSQL需要定期执行VACUUM操作，以释放数据库中未使用的空间。MariaDB有一个名为`mysqlcheck`的维护工具，可以用来验证表的完整性并执行优化。每个平台都会有自己的特定工具来进行维护操作，你需要为你选择的平台建立最佳的数据库维护实践。此外，有时也需要对数据库进行一些简单的修改。例如，可能需要删除（或更新）表中的一行，以清除应用程序中出现的错误情况。
- en: Of course, all these activities could be performed manually—however, this (as
    always) brings about the risk of losing track of what happened, who ran a task,
    and how they ran it (for example, which options were provided). If we move this
    example into the world of Ansible and AWX, suddenly we have a complete audit trail
    of activities, and we know exactly what was run and how it was run. Furthermore,
    if special options are required for a task, these will be stored within the playbooks,
    and thus the *self-documentation* that Ansible provides is available here too.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些操作都可以手动执行——然而，这样做（如同往常一样）会带来丢失操作记录的风险，包括谁执行了任务、如何执行的（例如，提供了哪些选项）。如果我们将这个例子放到Ansible和AWX的环境中，我们就会突然拥有完整的活动审计轨迹，且我们能准确知道执行了什么操作以及是如何执行的。此外，如果任务需要特定选项，这些选项将被存储在playbook中，因此Ansible提供的*自我文档化*功能在这里也能发挥作用。
- en: As our examples thus far have been very MariaDB-centric, let's take a look at
    how you might run a full vacuum on a table in PostgreSQL, with Ansible.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于到目前为止我们的例子非常以MariaDB为中心，让我们看看如何使用Ansible在PostgreSQL中对表执行完整的vacuum操作。
- en: Routine maintenance on PostgreSQL with Ansible
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible对PostgreSQL进行常规维护
- en: 'PostgreSQL is something of a special case on Ansible, as it has more native
    modules to support database activities than most other databases. Let''s consider
    an example case: performing a vacuum on the `sales.creditcard` table in the publicly
    available AdventureWorks sample database (available here: [https://github.com/lorint/AdventureWorks-for-Postgres](https://github.com/lorint/AdventureWorks-for-Postgres)).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible中，PostgreSQL有些特殊，因为它拥有比大多数其他数据库更多的原生模块来支持数据库活动。让我们考虑一个示例：对公开的AdventureWorks样本数据库中的`销售.creditcard`表执行vacuum操作（可以在这里获取：[https://github.com/lorint/AdventureWorks-for-Postgres](https://github.com/lorint/AdventureWorks-for-Postgres)）。
- en: Vacuuming is a PostgreSQL-specific maintenance process and one that you might
    want to consider running on a regular basis, especially if your tables have a
    lot of deletes or modifications. Although a full discussion of this is beyond
    the scope of this book, it is important to consider that tables that are subject
    to these activities can become bloated in size and queries can become slow over
    time, and vacuuming is a way to release unused space and speed up queries again.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Vacuum是PostgreSQL特有的维护过程，你可能希望定期运行它，特别是当你的表有大量删除或修改时。虽然对此的完整讨论超出了本书的范围，但需要考虑到，受这些活动影响的表可能会变得臃肿，查询可能会随着时间变慢，而vacuum操作是一种释放未使用空间并加速查询的方法。
- en: 'Now, to perform a vacuum on this table by hand, you would log in to the `psql`
    client utility with appropriate credentials, and then run the following commands
    to connect to the database and perform the task:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要手动执行vacuum操作，你需要使用适当的凭证登录`psql`客户端工具，然后运行以下命令连接到数据库并执行任务：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In a real enterprise, this would be a task that encompasses many more tables,
    and even databases, but here, we will once again keep the example simple, to demonstrate
    the principles involved. Scaling this up is then left as a task for you to perform.
    Let's automate this, first of all using the `shell` module in Ansible. This is
    a useful example, as this technique will work with most major databases—simply,
    you must establish the command needed for your particular maintenance operation,
    and then run it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际企业中，这将是一个涉及更多表格，甚至数据库的任务，但在这里，我们将再次保持示例简单，以演示所涉及的原则。将其扩展为大规模应用任务就留给你自己去做吧。让我们首先使用Ansible中的`shell`模块来自动化这一过程。这是一个有用的示例，因为该技术适用于大多数主要数据库——你只需确定特定维护操作所需的命令，然后运行它。
- en: 'A simple role to perform this task would look like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此任务的简单角色看起来如下：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note—as before—very simple use of the `shell` module with the appropriate command,
    except that, this time, we are using the `become_user` parameter to switch to
    the `postgres` user account, which has superuser rights on the database on the
    host to which we connect. Let''s see what happens when we run this, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意——与之前一样——我们非常简单地使用了`shell`模块并带有适当的命令，唯一不同的是，这次我们使用了`become_user`参数切换到`postgres`用户账户，该账户对我们连接的主机上的数据库具有超级用户权限。让我们看看运行时会发生什么，具体如下：
- en: '![](img/afb8f821-4b31-4674-a91d-3f3a6e1f90f5.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afb8f821-4b31-4674-a91d-3f3a6e1f90f5.png)'
- en: Naturally, this could be scaled to just about any other database—for example,
    you could use the `mysql` client tool on a MariaDB database, or even run the `mysqlcheck`
    tool, as discussed earlier. The limit really is on what you can script for the
    `shell` module to run, and because Ansible runs the command over SSH on the database
    server itself, you don't need to worry about opening up your database for access
    across the network—it can remain tightly locked down.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这可以扩展到几乎任何其他数据库——例如，你可以在MariaDB数据库上使用`mysql`客户端工具，甚至运行之前讨论过的`mysqlcheck`工具。真正的限制在于你为`shell`模块编写的脚本，而因为Ansible通过SSH在数据库服务器上运行命令，你无需担心开放数据库的网络访问——它可以保持紧密的安全限制。
- en: In addition to using the `shell` module, Ansible offers us the option to actually
    run queries directly from a module called `postgresql_query`. This is unique,
    though such support could be added for any other database if someone was willing
    to write the module and submit it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`shell`模块，Ansible还为我们提供了直接从名为`postgresql_query`的模块运行查询的选项。虽然这种支持是独特的，但如果有人愿意编写并提交模块，也可以为任何其他数据库添加类似支持。
- en: 'Unfortunately for Ansible versions prior to 2.9, it was not possible to extend
    our VACUUM example to this as the `postgresql_query` module runs transactions
    inside a block, and it is not possible to run a VACUUM inside a transaction block.
    If you are running version 2.9 or later, you can now run a VACUUM using example
    code, as shown here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于2.9之前的Ansible版本，我们无法将VACUUM示例扩展到这个模块，因为`postgresql_query`模块会在事务块内运行事务，而无法在事务块内运行VACUUM。如果你正在运行2.9或更高版本，现在可以使用示例代码运行VACUUM，如下所示：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: By way of another simple example, we could also use the `postgresql_query` module
    to directly manipulate the database.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过另一个简单的示例，我们还可以使用`postgresql_query`模块直接操作数据库。
- en: 'Suppose that a bug in the application using this database has occurred, and
    an operator must manually insert a credit card number into the database. The SQL
    code to perform this might look something like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设使用此数据库的应用程序出现了一个错误，操作员必须手动将信用卡号码插入数据库。执行此操作的SQL代码可能如下所示：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We could achieve the same end result in Ansible, using a role that looks like
    the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用如下的角色，在Ansible中实现相同的最终结果：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Naturally, you would use variables for the data values, and sensitive data like
    this should always be stored in a vault (or, perhaps, entered by hand when the
    role is run).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，你会为数据值使用变量，像这样的敏感数据应始终存储在保险库中（或者，也可以在角色运行时手动输入）。
- en: AWX has a feature called **Surveys**, which presents the user with a series
    of predefined questions to answer before a playbook is run. The answers to these
    questions are stored in Ansible variables— thus, a role such as the preceding
    one could be parameterized, and run from AWX with all the values entered into
    a Survey, negating the need for a vault and concerns over sensitive customer data
    being stored in Ansible.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: AWX 有一个叫做 **调查** 的功能，它在执行 playbook 之前会向用户提出一系列预定义的问题。用户对这些问题的回答将存储在 Ansible
    变量中——因此，像前面提到的角色可以被参数化，并且从 AWX 运行时，所有的值都可以通过调查输入，避免使用 vault 以及担心敏感客户数据存储在 Ansible
    中的问题。
- en: 'As you can see here, when we run this role, we actually get a changed status
    when the `INSERT` operation is successful—very useful for monitoring such tasks
    and ensuring they have run as desired. The following screenshot shows this role
    being run, and the `changed` status, denoting the successful insertion of data
    into the `sales.creditcard` table:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，当我们运行这个角色时，实际上在 `INSERT` 操作成功时会显示更改状态——这对于监控此类任务并确保它们按预期执行非常有用。以下截图显示了此角色的运行情况以及
    `changed` 状态，表示数据成功插入到 `sales.creditcard` 表中：
- en: '![](img/118c4804-76c5-4289-be64-5047e307d3a0.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/118c4804-76c5-4289-be64-5047e307d3a0.png)'
- en: The world really is your oyster when it comes to database management with Ansible,
    and, regardless of the task required, it is desirable that all database tasks
    be handled in a standardized, repeatable, and auditable manner, just like the
    rest of your Enterprise Linux estate. It is hoped that this chapter has gone some
    way in showing you how to achieve this.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到使用 Ansible 进行数据库管理时，世界真的是你的舞台，无论需要什么任务，所有数据库任务都应以标准化、可重复和可审计的方式进行，就像您企业的其他
    Linux 系统一样。希望本章能帮助您了解如何实现这一目标。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Databases are a core part of the application stack in most enterprises, and
    there is a multitude of databases available on the Linux platform. Although many
    databases have their own management tools, Ansible is well suited to assist with
    a wide array of database management tasks, from the installation of database services
    and loading of initial data or schemas (or even restoring from backups) to handling
    day-to-day maintenance tasks. Combining Ansible's error handling and secure automation,
    there is virtually no limit to the types of database management tasks you can
    perform with Ansible.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是大多数企业应用堆栈中的核心部分，Linux 平台上有多种数据库可供选择。尽管许多数据库有自己的管理工具，Ansible 非常适合协助执行各种数据库管理任务，从安装数据库服务、加载初始数据或架构（甚至从备份中恢复）到处理日常维护任务。结合
    Ansible 的错误处理和安全自动化，几乎没有任何限制，您可以使用 Ansible 执行各种数据库管理任务。
- en: In this chapter, you learned how to use Ansible to install database servers
    in a consistent and repeatable manner. You then learned how to import initial
    data and schemas, and how to extend this to automate backup tasks. Finally, you
    gained hands-on knowledge of some routine database maintenance tasks with Ansible.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，您学习了如何使用 Ansible 一致且可重复地安装数据库服务器。然后，您学习了如何导入初始数据和架构，并扩展到自动化备份任务。最后，您获得了使用
    Ansible 执行一些常规数据库维护任务的实践知识。
- en: In the next chapter, we will look at how Ansible can assist with the task of
    routine maintenance on your Linux servers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Ansible 如何协助您执行 Linux 服务器的常规维护任务。
- en: Questions
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is it prudent to install and manage your database platform with Ansible?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么使用 Ansible 安装和管理数据库平台是明智的选择？
- en: What are the best practices for database configuration file management with
    Ansible?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Ansible 管理数据库配置文件的最佳实践是什么？
- en: How can Ansible help you keep your database secure on the network?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible 如何帮助您保持数据库在网络上的安全？
- en: When would you use the `shell` module instead of a native database module in
    Ansible?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下，您会使用 Ansible 的 `shell` 模块而不是本地数据库模块？
- en: Why would you want to perform routine maintenance with Ansible?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要使用 Ansible 执行例行维护？
- en: How would you perform a PostgreSQL database backup with Ansible?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 Ansible 执行 PostgreSQL 数据库备份？
- en: Which module would you use to manipulate the users on a MariaDB database?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会使用哪个模块来操作 MariaDB 数据库中的用户？
- en: How is PostgreSQL support unique in Ansible at the present time?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前 Ansible 中对 PostgreSQL 的支持有何独特之处？
- en: Further reading
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For an in-depth understanding of Ansible, please refer to *Mastering Ansible,
    Third Edition—James Freeman* and *Jesse Keating* ([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition)).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要深入了解Ansible，读者请参考*《精通Ansible，第3版》——詹姆斯·弗里曼*和*杰西·基廷*（[https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition)）。
- en: To learn more about the specifics relating to PostgreSQL database management,
    readers may refer to *Learning PostgreSQL 11, Third Edition—Andrey Volkov, Salahadin
    Juba* ([https://www.packtpub.com/gb/big-data-and-business-intelligence/learning-postgresql-11-third-edition](https://www.packtpub.com/gb/big-data-and-business-intelligence/learning-postgresql-11-third-edition)).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于PostgreSQL数据库管理的具体内容，读者可以参考*《学习PostgreSQL 11，第3版》——安德烈·沃尔科夫，萨拉赫丁·朱巴*（[https://www.packtpub.com/gb/big-data-and-business-intelligence/learning-postgresql-11-third-edition](https://www.packtpub.com/gb/big-data-and-business-intelligence/learning-postgresql-11-third-edition)）。
- en: Similarly, to learn more about MariaDB database management, readers can refer
    to *MariaDB Essentials—Federico Razzoli, Emilien Kenler* ([https://www.packtpub.com/gb/application-development/mariadb-essentials](https://www.packtpub.com/gb/application-development/mariadb-essentials)).
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，要了解更多关于MariaDB数据库管理的内容，读者可以参考*《MariaDB Essentials》——费德里科·拉佐利，埃米连·肯勒*（[https://www.packtpub.com/gb/application-development/mariadb-essentials](https://www.packtpub.com/gb/application-development/mariadb-essentials)）。
- en: For a full list of available Ansible modules, readers should refer to [https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html.](https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看所有可用的Ansible模块，读者可以参考[https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html.](https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html)
