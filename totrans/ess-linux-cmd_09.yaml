- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux Monitoring and Debugging Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux monitoring and debugging commands are a crucial set of tools widely employed
    by Linux system administrators for monitoring system performance, troubleshooting
    issues, and debugging problems in Linux environments. These commands provide real-time
    insights into the various components and processes of the system, enabling administrators
    to identify and address potential bottlenecks, errors, or performance issues promptly.
    The importance of these commands lies in their ability to ensure system stability,
    optimize resource utilization, and enhance overall system performance. By leveraging
    monitoring and debugging commands, administrators can proactively manage system
    health, mitigate risks, and maintain a reliable and efficient Linux environment.
    The primary objective of these commands is to equip system administrators with
    essential tools for effectively monitoring and diagnosing the status of their
    Linux systems. They can also provide valuable insights into critical system metrics,
    including CPU usage, memory utilization, disk I/O, network activity, and process
    information. By closely monitoring these metrics, administrators can proactively
    identify any unusual behavior, track system performance trends, and detect potential
    issues before they escalate into significant problems. Additionally, the debugging
    commands offer robust capabilities to investigate and resolve system errors, software
    bugs, and compatibility issues. They empower administrators to trace the execution
    of programs, capture error logs, analyze system logs, and perform troubleshooting
    steps to identify the underlying causes of issues and implement appropriate remedies.
  prefs: []
  type: TYPE_NORMAL
- en: These commands are among the most widely used tools by system administrators
    for several reasons. Firstly, these commands provide administrators with real-time
    and accurate insights into system performance and behavior, enabling them to make
    informed decisions and take proactive measures to optimize system resources. Secondly,
    the commands offer a wide range of functionalities, allowing administrators to
    monitor and analyze specific components or processes based on their requirements.
    This flexibility makes the commands adaptable to various use cases and scenarios.
    Additionally, the commands facilitate efficient troubleshooting and debugging
    processes by providing detailed information and diagnostic capabilities. This
    helps administrators save time and effort in identifying and resolving issues,
    leading to improved system stability and reduced downtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The top, ps, pstree, strace, watch, smartctl, and uptime commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lsof, lsmod, last reboot, last, w, and vmstat commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kill command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pkill command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As Linux gained popularity and became a prominent choice for server and enterprise
    environments, the need for robust monitoring and debugging tools became evident.
    The Linux community recognized the importance of having comprehensive tools that
    could provide insights into system performance, aid in troubleshooting, and enable
    efficient debugging of issues. Over time, numerous command-line utilities, software
    packages, and frameworks were developed to meet these needs. These tools aimed
    to provide administrators with real-time monitoring capabilities, detailed system
    information, and advanced debugging features. The continuous evolution of Linux
    monitoring and debugging commands has been driven by the ever-increasing complexity
    of modern systems, the demand for optimal performance, and the need to quickly
    identify and resolve issues. Today, Linux administrators have a vast array of
    powerful tools at their disposal to effectively monitor and debug their systems,
    ensuring the stability, reliability, and performance of their Linux environments.
  prefs: []
  type: TYPE_NORMAL
- en: The top command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `top` command is a powerful Linux utility that provides real-time monitoring
    of system processes and resource usage. It is the go-to tool for system administrators
    to gain insights into the performance and health of their Linux systems. The primary
    purpose of the `top` command is to display a dynamic and interactive overview
    of system processes, CPU usage, memory utilization, load average, and other critical
    system statistics. By continuously updating this information, administrators can
    quickly identify resource-intensive processes, bottlenecks, or abnormalities that
    may impact system performance. The `top` command is a vital component of Linux
    monitoring, offering a comprehensive view of system activity and facilitating
    efficient troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the key reasons why the `top` command is widely used by system administrators
    is its versatility. It provides a wealth of information in a compact and easy-to-understand
    format, making it an invaluable tool for monitoring system health. Administrators
    can use the `top` command to observe real-time CPU usage, memory allocation, and
    process activity. This allows them to detect potential performance issues, identify
    processes consuming excessive resources, and take appropriate action to optimize
    system performance. Additionally, the `top` command provides information on the
    system load average, indicating the overall system workload and allowing administrators
    to determine if the system is under heavy utilization. The importance of the `top`
    command extends beyond monitoring system resources. It also serves as a diagnostic
    tool for troubleshooting system issues. Administrators can use the `top` command
    to investigate the behavior of specific processes, identify potential bottlenecks,
    and analyze resource consumption patterns. By understanding how system resources
    are allocated and utilized, administrators can make informed decisions to optimize
    system performance and resolve issues. The `top` command also supports interactive
    features, allowing administrators to dynamically adjust the display, sort processes
    based on various criteria, and send signals to individual processes for further
    analysis or control. This level of flexibility and control makes the `top` command
    an essential tool for Linux system administrators. Let’s dive into exploring the
    `top` command on our CentOS terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '`top` command provides real-time insights into system statistics, including
    CPU usage, memory utilization, and system load. This information is dynamically
    updated, offering a comprehensive overview of the system’s performance and resource
    allocation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Viewing overall system statistics](img/B18212_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Viewing overall system statistics
  prefs: []
  type: TYPE_NORMAL
- en: '`top` command also offers the capability to sort a displayed list of processes
    based on their CPU usage. This can be seen in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Sorting processes by CPU usage](img/B18212_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Sorting processes by CPU usage
  prefs: []
  type: TYPE_NORMAL
- en: This feature allows you to quickly identify the process consuming the most CPU
    resources, as it will be listed at the top of the output. Such capability provides
    a convenient way to prioritize and monitor CPU-intensive processes. This, in turn,
    makes it easier for system administrators to identify potential performance bottlenecks
    and take appropriate actions to optimize system resources.
  prefs: []
  type: TYPE_NORMAL
- en: '`-o %MEM` option to monitor memory usage, as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Command for monitoring memory usage](img/B18212_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Command for monitoring memory usage
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Monitoring memory usage](img/B18212_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Monitoring memory usage
  prefs: []
  type: TYPE_NORMAL
- en: The `top` command will display a list of processes sorted by their memory usage,
    allowing you to monitor which processes are utilizing the most memory.
  prefs: []
  type: TYPE_NORMAL
- en: '`username` with the actual username we want to filter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Command to filter processes by user](img/B18212_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Command to filter processes by user
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Using top to filter processes by user](img/B18212_09_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Using top to filter processes by user
  prefs: []
  type: TYPE_NORMAL
- en: The `top` command filters the displayed processes to show only those owned by
    the specified username.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the `top` command is a versatile and essential tool for monitoring
    system processes and resource usage in Linux environments. Its real-time insights
    into system performance, interactive features, and diagnostic capabilities make
    it a valuable asset for system administrators. By utilizing the `top` command,
    system administrators can effectively monitor system health, identify resource-intensive
    processes, troubleshoot issues, and optimize system performance. Its widespread
    use among Linux system administrators is a testament to its importance and effectiveness
    in maintaining the stability, reliability, and optimal functioning of Linux systems.
  prefs: []
  type: TYPE_NORMAL
- en: The ps command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ps` command is a powerful utility in Linux used to provide information
    about the running processes on a system. It stands for `ps` command lies in its
    ability to offer real-time visibility into the system’s running processes. It
    is a valuable tool for monitoring the health and efficiency of a system, allowing
    administrators to identify any misbehaving or resource-intensive processes that
    may be affecting system performance.
  prefs: []
  type: TYPE_NORMAL
- en: The primary use of the `ps` command is for process monitoring and management.
    Administrators can use it to view a snapshot of active processes on the system,
    including their status, resource utilization, and relationships with other processes.
    This information is vital for troubleshooting system issues, identifying potential
    bottlenecks, and optimizing system performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `ps` command can be used for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ps` command displays a list of all running processes in the system. It provides
    information about each process, including the PID, the terminal associated with
    the process, the CPU and memory usage since it was started, and the command that
    started the process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Using the ps command to view all running processes](img/B18212_09_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Using the ps command to view all running processes
  prefs: []
  type: TYPE_NORMAL
- en: '`-e` option with the `ps` command shows a list of processes owned by a specific
    user, where `username` is replaced with the actual username. It is useful for
    providing administrators an overview of processes belonging to a particular user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Viewing processes owned by a specific user](img/B18212_09_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Viewing processes owned by a specific user
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the `ps` command is a cornerstone tool for Linux system administrators,
    providing essential insights into running processes and facilitating process management
    and troubleshooting. Its real-time information about process status, resource
    utilization, and relationships enables administrators to ensure system stability,
    enhance performance, and efficiently allocate system resources. With its versatility
    and broad range of applications, the `ps` command remains an indispensable part
    of the Linux monitoring and management toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: The pstree command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pstree` command is a Linux utility that displays a tree-like representation
    of running processes on the system. It provides a visual and hierarchical view
    of processes, showing their parent-child relationships. The command is particularly
    useful when trying to understand the process structure and how different processes
    are related to each other. By displaying processes in a tree format, administrators
    can quickly identify the parent process (`init` or `system`) and its descendants,
    helping them grasp the overall process hierarchy. This information is crucial
    for system debugging, performance analysis, and troubleshooting scenarios. The
    `pstree` command also aids in process management, as it allows administrators
    to visualize complex process structures and their dependencies, making it easier
    to identify potential issues and optimize system performance. Let’s take a closer
    look at how it can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pstree` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Viewing a process tree with the pstree command](img/B18212_09_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Viewing a process tree with the pstree command
  prefs: []
  type: TYPE_NORMAL
- en: '`pstree -p` command in the terminal, it will show a hierarchical representation
    of all running processes on your system, similar to the standard `pstree` output,
    but with each process’s PID displayed next to its name. The PID is a unique ID
    assigned to each process by the operating system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Viewing a PID with pstree](img/B18212_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Viewing a PID with pstree
  prefs: []
  type: TYPE_NORMAL
- en: The `pstree -p` command can be particularly useful when troubleshooting or investigating
    processes on your system. It allows you to quickly identify the parent-child relationships
    between processes and their corresponding PIDs. This can aid in understanding
    the structure of the processes running on your system and help you identify specific
    processes that might be causing issues or consuming excessive resources.
  prefs: []
  type: TYPE_NORMAL
- en: The strace command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `strace` command is a powerful Linux tool used for tracing and debugging
    system calls made by a process. It intercepts and records the system calls a process
    makes while running, providing detailed information about interactions between
    the process and the Linux kernel. This level of visibility is invaluable for diagnosing
    and resolving issues related to system calls, application behavior, and software
    errors. By analyzing the output of `strace`, administrators can identify issues
    such as file access problems, library dependencies, permission errors, or resource
    conflicts. It is particularly useful for debugging complex applications, troubleshooting
    crashes, and ensuring correct program execution. The `strace` command is widely
    used by system administrators, developers, and support teams as a fundamental
    tool for investigating low-level system interactions and understanding the root
    cause of various software and performance problems. Please note that `sudo` access
    is required when using `strace` to trace processes with elevated permissions or
    system-level access. Both `pstree` and `strace` commands are essential tools in
    the Linux administrator’s arsenal. They provide valuable insights into the process
    hierarchy and system interactions, helping administrators understand system behavior,
    diagnose issues, and optimize performance. `pstree` facilitates a clear visualization
    of process relationships, enabling administrators to comprehend complex process
    structures and identify possible process bottlenecks. On the other hand, `strace`
    offers in-depth tracing of system calls, allowing administrators to monitor the
    interaction between processes and the kernel, thus aiding in debugging and identifying
    problems with software applications. The importance of these commands is evident
    in their ability to streamline the troubleshooting process, enhance system stability,
    and improve overall system performance, making them indispensable tools for Linux
    system administrators. We will explore illustrative examples of each of the commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`strace` command will trace only open and read system calls made by the `ls`
    command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering system calls allows focusing on specific operations and reduces the
    amount of output generated by `strace`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Analyze the filtered output to gain insights into how the `ls` command interacts
    with files by opening and reading them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Filtering system calls with strace](img/B18212_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Filtering system calls with strace
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, both the `pstree` and `strace` commands are indispensable tools
    for Linux system administrators, each serving unique purposes in system monitoring
    and debugging. The `pstree` command offers a clear and hierarchical view of running
    processes, simplifying the understanding of process relationships and dependencies.
    This visual representation aids in troubleshooting, performance analysis, and
    process management tasks, contributing to improved system stability and performance.
    On the other hand, the `strace` command excels in tracing system calls and providing
    detailed insights into process behavior, software errors, and low-level system
    interactions. This powerful level of visibility is crucial for diagnosing complex
    issues and identifying the root cause of software problems. System administrators
    and developers rely on `strace` for troubleshooting crashes, detecting permission
    errors, resolving library dependencies, and ensuring correct program execution.
  prefs: []
  type: TYPE_NORMAL
- en: The watch command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `watch` command is a powerful utility in Linux that's used to execute a
    specified command repeatedly at defined intervals and display its output in the
    terminal. It is particularly useful for real-time monitoring and observing changes
    in system data over time. The command takes a command-line argument and refreshes
    the terminal screen at regular intervals to show the updated output of the given
    command. This continuous refresh provides a dynamic view of the data, making it
    easier for system administrators to track system metrics, analyze processes, or
    observe the behavior of certain commands. The `watch` command is valuable for
    monitoring tasks that require frequent updates, such as checking system resource
    usage, log file updates, or network activity. It streamlines the process of obtaining
    real-time information, allowing administrators to react promptly to any changes
    or anomalies, making it an essential tool in the Linux system administrator’s
    toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can monitor network traffic in real time using the `watch` command with
    the `ifconfig` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Command to monitor network traffic in real time](img/B18212_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Command to monitor network traffic in real time
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Combining the watch and ifconfig commands](img/B18212_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Combining the watch and ifconfig commands
  prefs: []
  type: TYPE_NORMAL
- en: Let us now look at another command – the `smartctl` command.
  prefs: []
  type: TYPE_NORMAL
- en: The smartctl command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `smartctl` command is a vital tool for Linux system administrators responsible
    for managing hard drives and storage devices. It is part of the `smartctl` command,
    administrators can proactively monitor the condition of their storage devices,
    detect signs of imminent failure, and take necessary action to prevent data loss
    and system downtime. This valuable information empowers system administrators
    to make informed decisions about storage maintenance, upgrade planning, and replacement
    strategies, ensuring data integrity and system stability.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve the health and status of a storage device using the `smartctl`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Using smartctl to retrieve the health status of a storage device](img/B18212_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Using smartctl to retrieve the health status of a storage device
  prefs: []
  type: TYPE_NORMAL
- en: The uptime command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `uptime` command is a simple yet essential tool for Linux system administrators
    to quickly check the system’s current uptime and load average. When executed,
    the command displays the current time, the system’s running time since the last
    boot, the number of users currently logged in, and the load average for the last
    1, 5, and 15 minutes. The load average represents the average number of processes
    in the system’s run queue over the specified time intervals. The `uptime` command
    is invaluable for assessing system performance, resource utilization, and system
    responsiveness. By regularly monitoring the uptime and load average, administrators
    can identify periods of high system activity and potential bottlenecks, allowing
    them to make informed decisions about system optimization, capacity planning,
    and resource allocation. This tool is particularly useful when troubleshooting
    performance issues, as it provides a quick snapshot of system health and helps
    administrators detect anomalies or periods of heavy system load.
  prefs: []
  type: TYPE_NORMAL
- en: 'By further exploring the provided examples of the aforementioned command, we
    will delve into how it can be efficiently employed by system administrators:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Monitoring** **CPU usage**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "![Figure 9.15 – Command \uFEFFfor monitor\uFEFFing CPU usage](img/B18212_09_15.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Command for monitoring CPU usage
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Monitoring CPU usage with uptime](img/B18212_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Monitoring CPU usage with uptime
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the `watch`, `smartctl`, and `uptime` commands are indispensable
    tools for Linux system administrators, offering valuable capabilities for real-time
    monitoring, storage device management, and system performance evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: The lsof command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `lsof` command in Linux stands for `lsof` command allows system administrators
    to perform various administrative tasks, such as killing processes that are holding
    locks on critical files or identifying processes associated with specific network
    connections.
  prefs: []
  type: TYPE_NORMAL
- en: The primary use of the `lsof` command lies in its versatility and flexibility.
    It can be used to examine various types of resources, such as regular files, directories,
    network sockets, and character/block devices. This makes it an essential tool
    for investigating network-related issues, analyzing disk usage, managing mounted
    filesystems, and checking for potential resource leaks. Overall, the `lsof` command
    empowers Linux system administrators with a wealth of information about file and
    process interactions, contributing to efficient system management and troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will list all open files in the system using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Using lsof to list all open files in the system](img/B18212_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – Using lsof to list all open files in the system
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lsof`: The executed command is `lsof`. It provides information about files
    and processes currently open and in use by the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>`: This is the redirection operator in Linux. It is used to redirect the
    output of a command to a file instead of displaying it on the terminal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file.txt`: This is the name of the file where the output of the `lsof` command
    will be saved. You can choose any desired filename, but `file.txt` is just an
    example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lsmod command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `lsmod` command in Linux is used to display currently loaded kernel modules
    on the system. Kernel modules are small pieces of code that can be dynamically
    loaded or unloaded into the Linux kernel, adding or removing specific functionalities
    to the operating system. The `lsmod` command provides a concise and organized
    view of the kernel modules, showing their names, sizes, and the number of references
    or dependencies they have. The significance of the `lsmod` command lies in its
    capability to inspect the runtime configuration of the kernel. This command provides
    system administrators with the ability to confirm currently loaded and active
    modules in the kernel. This information holds immense importance when troubleshooting
    hardware-related problems, as kernel modules play a pivotal role in managing device
    drivers and other critical functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will view currently loaded kernel modules using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Using lsmod to view currently loaded kernel modules](img/B18212_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Using lsmod to view currently loaded kernel modules
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an explanation of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: The header row provides the names of the columns in the output. The three main
    columns are `Module`, `Size`, and `Used by`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Module` column lists the names of the loaded kernel modules, and the `Size`
    and `Used by` columns indicate the size of each module in memory and the number
    of kernel components using each module, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output displays information for several kernel modules that are currently
    loaded and in use by the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each row corresponds to a specific kernel module, and the columns provide details
    about that module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, let’s look at the first row:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `nls_utf8` module is loaded, and it occupies 16,384 bytes in memory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There is one kernel component using the `nls_utf8` module
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, the other rows provide information about different modules that are
    currently loaded and their respective sizes and usage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last reboot command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `last reboot` command in Linux is a simple yet crucial utility that provides
    information about the system’s reboot history. It displays the timestamps of previous
    system reboots, along with the time since the last reboot. This information is
    helpful for system administrators to track system availability and uptime. By
    regularly checking the last reboot timestamps, administrators can quickly identify
    if the system experienced any unexpected shutdowns or reboots. This information
    can be vital for diagnosing potential hardware or software issues that may be
    causing system instability.
  prefs: []
  type: TYPE_NORMAL
- en: The primary use of the `last reboot` command is for historical analysis and
    tracking system availability. System administrators can utilize this information
    to calculate the system’s **mean time between failures** (**MTBF**) and **mean
    time to repair** (**MTTR**), which are essential metrics for evaluating system
    reliability.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the system’s reboot history, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Using last reboot to display the system’s reboot history](img/B18212_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – Using last reboot to display the system’s reboot history
  prefs: []
  type: TYPE_NORMAL
- en: The last command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `last` command is a versatile and powerful tool used by Linux system administrators
    to view a history of user login activity on the system. It displays a list of
    previous login sessions, including the date, time, duration, and remote host from
    which the login occurred. This information is essential for monitoring user access
    to the system, identifying potential security breaches, and investigating unauthorized
    access attempts. The `last` command allows administrators to track user activities,
    detect unusual login patterns, and ensure the security and integrity of the system.
    Moreover, it facilitates auditing and compliance efforts by providing a comprehensive
    log of user login events, making it a crucial component of the system administrator’s
    toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the last logged-in users and system shutdown/reboot
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Viewing last logged-in users and system shutdown/reboot times](img/B18212_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – Viewing last logged-in users and system shutdown/reboot times
  prefs: []
  type: TYPE_NORMAL
- en: The w command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `w` command is a valuable utility that provides real-time information about
    logged-in users and their activities on the system. When executed, the `w` command
    displays a list of currently logged-in users, along with details such as their
    username, terminal, login time, idle time, and current processes. This command
    enables system administrators to monitor user sessions, check system load, and
    assess resource utilization. The `w` command is particularly useful for managing
    system resources and ensuring fair distribution of resources among users. It helps
    administrators identify users who may be consuming excessive resources or causing
    system performance issues. By having access to this real-time data, administrators
    can take proactive measures to optimize resource allocation, improve system efficiency,
    and ensure a smooth and responsive user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example displays information about currently logged-in users
    and their activities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Using the w command to display information about currently
    logged-in users and their activities](img/B18212_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – Using the w command to display information about currently logged-in
    users and their activities
  prefs: []
  type: TYPE_NORMAL
- en: The vmstat command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `vmstat` command is a powerful tool for monitoring system performance and
    analyzing resource usage. When executed, the `vmstat` command provides a detailed
    report on various system statistics, including CPU usage, memory usage, virtual
    memory, disk I/O, and system processes. This comprehensive overview allows system
    administrators to identify performance bottlenecks, detect potential issues, and
    make informed decisions about system optimization and resource allocation. The
    `vmstat` command is particularly valuable for performance tuning, capacity planning,
    and troubleshooting system slowdowns or resource constraints. It offers valuable
    insights into the system’s health and performance, enabling administrators to
    proactively address any emerging issues and ensure the smooth operation of the
    Linux environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is to monitor system memory, processor, and I/O statistics
    in real time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22 – Monitoring system memory and processes with vmstat](img/B18212_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – Monitoring system memory and processes with vmstat
  prefs: []
  type: TYPE_NORMAL
- en: This command is used for displaying information about virtual memory statistics,
    system processes, and CPU utilization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a breakdown of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`procs`: This displays information about processes and process states. The
    `r` column represents the number of processes in the `running` state, and the
    `b` column indicates the number of processes in the `uninterruptible sleep` or
    `blocked` state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memory`: This provides details about memory usage. The `swpd` column shows
    the amount of virtual memory used (in KB) that has been swapped to the disk. The
    `free` column displays the amount of free memory (in KB) available for processes.
    The `buff` column shows the amount of memory (in KB) used as buffer cache by the
    kernel. The `cache` column displays the amount of memory (in KB) used as page
    cache by the kernel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swap`: This displays information about swap space usage. The `si` column represents
    the amount of memory (in KB) swapped in from disk per second, and the `so` column
    represents the amount of memory (in KB) swapped out to disk per second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io`: This provides information about I/O operations. The `bi` column shows
    the number of blocks received from a block device (such as a hard disk) per second,
    and the `bo` column shows the number of blocks sent to a block device per second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system`: This section displays system-related statistics. The `in` column
    represents the number of interrupts per second, and the `cs` column represents
    the number of context switches per second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cpu`: This section provides CPU utilization statistics. The `us` column represents
    the percentage of CPU time spent in user-level processes. The `sy` column represents
    the percentage of CPU time spent in system-level processes. The `id` column represents
    the percentage of idle CPU time. The `wa` column represents the percentage of
    CPU time spent waiting for I/O operations. The `st` column represents the percentage
    of CPU time stolen from a **virtual** **machine** (**VM**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kill command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `kill` command is a fundamental and powerful utility in Linux used to terminate
    or send signals to running processes. In many cases, it requires superuser (`sudo`)
    privileges to terminate processes that belong to other users or are critical to
    system operation. Its primary purpose is to gracefully stop or forcibly terminate
    processes based on their PIDs. The `kill` command allows system administrators
    to manage and control the execution of processes, ensuring smooth system operation
    and resource management. One of the most common signals sent by the `kill` command
    is `SIGTERM` (signal 15), which politely asks a process to terminate, giving it
    a chance to perform cleanup tasks before exiting. Additionally, the `kill` command
    can send other signals such as `SIGKILL` (signal 9), which forcefully terminates
    a process without allowing it to perform any cleanup. This is useful in cases
    where a process is unresponsive or causing system instability. The `kill` command
    is crucial for handling unresponsive or problematic processes, preventing resource
    exhaustion, and maintaining system stability. Moreover, the `kill` command plays
    a vital role in process management, enabling administrators to prioritize certain
    processes over others. By sending different signals, administrators can alter
    the behavior of running processes. For example, sending the `SIGSTOP` signal suspends
    a process, while sending the `SIGCONT` signal resumes it. This capability is useful
    for pausing and resuming processes or controlling their execution based on specific
    conditions. The `kill` command is an essential tool for Linux system administrators
    when handling process-related issues, managing system resources, and ensuring
    efficient and reliable system performance.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `kill` command is integral to process coordination and `kill`
    command, administrators can facilitate communication and coordination among processes,
    resulting in better overall system performance and functionality. The `kill` command
    is also commonly used in shell scripts and automation scripts to manage processes,
    making it a valuable tool for automating system tasks and maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for killing a specific process with the `kill` command are set out
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the PID of the target process using the `ps` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `kill` command followed by the PID to terminate the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Killing a specific process with the kill command](img/B18212_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.23 – Killing a specific process with the kill command
  prefs: []
  type: TYPE_NORMAL
- en: 'We verify the process using the `systemctl` command, as demonstrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.24 – Verifying the kill process](img/B18212_09_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.24 – Verifying the kill process
  prefs: []
  type: TYPE_NORMAL
- en: The pkill command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pkill` command is a powerful utility in Linux used to terminate or signal
    processes based on their names or other criteria. Its primary purpose is to provide
    a more user-friendly and efficient way to kill processes compared to using their
    PIDs. One of the key reasons for its importance is its ability to simplify the
    process of terminating multiple instances of a process with the same name. This
    is particularly useful when dealing with applications that run multiple processes,
    such as web servers or database servers. The `pkill` command ensures that all
    relevant processes are terminated without the need to identify and input individual
    PIDs. Its ease of use makes it a valuable tool for system administrators in various
    scenarios, including troubleshooting, process management, and automation.
  prefs: []
  type: TYPE_NORMAL
- en: We can kill multiple processes with the `pkill` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `pkill` command followed by the process name to terminate all processes
    with the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25 – Killing multiple processes with the pkill command](img/B18212_09_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.25 – Killing multiple processes with the pkill command
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, Linux monitoring and debugging commands are indispensable tools
    for Linux system administrators. These commands empower administrators to monitor
    system performance, troubleshoot issues, and ensure the stability and reliability
    of their Linux systems. With a wide range of commands at their disposal, administrators
    can gain valuable insights into system behavior, identify problems, and implement
    effective solutions. By mastering these commands, administrators can optimize
    system performance, enhance security, and deliver a seamless user experience.
    Overall, Linux monitoring and debugging commands are essential for maintaining
    the health and functionality of Linux environments.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter delves into a diverse range of crucial tools designed to empower
    Linux system administrators in efficiently monitoring system performance and identifying
    and resolving potential issues. The chapter covers a wide array of commands, each
    serving a specific purpose in gaining insights into various aspects of the system.
    From real-time monitoring using commands such as `top` and `vmstat` to analyzing
    process relationships with `pstree` and debugging software issues using `strace`,
    this chapter equips administrators with valuable tools to ensure the stability,
    reliability, and optimal performance of their Linux systems.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the chapter explores commands such as `watch`, `smartctl`, `uptime`,
    `kill`, and `pkill` that aid in repetitive command execution, managing storage
    devices, terminating processes, and checking system uptime and load average, respectively.
    The combination of these monitoring and debugging commands equips system administrators
    with comprehensive visibility into system health, resource utilization, and user
    activity, enabling them to make informed decisions and proactively address potential
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve into a comprehensive array of indispensable
    tools designed to facilitate network management and enhance system performance
    in Linux environments. This chapter covers a diverse range of commands, each serving
    a specific purpose in configuring and monitoring network settings. From `iptables`
    for firewall management to commands such as `ifconfig` and `ip` for network interface
    configuration and more, this chapter equips system administrators with essential
    tools to ensure smooth network operations and secure communication.
  prefs: []
  type: TYPE_NORMAL
