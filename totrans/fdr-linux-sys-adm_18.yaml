- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Untangling Security with SELinux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Security*, *Hardening*, *Compliance*, and *Policy*: these are the four horsemen
    of the SysAdmin apocalypse. One of the big battles is maintaining the security
    of the systems. Besides the daily tasks, the security of the systems is part of
    the job, even those systems where the third-party provider asks us to deactivate
    the *enhanced security*. In most of these cases, an analysis is enough to find
    the right troubleshooting method or a workaround.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security-Enhanced Linux** (**SELinux**) is a code that runs in the user space,
    leveraging kernel code (**Linux Security Modules**) to provide **mandatory access
    control** (**MAC**) over system resources. The access to system objects and features
    takes place on a per-domain basis following the principle of *least privilege*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn how to take advantage of the benefits
    of SELinux to secure managed systems, covering the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about mandatory access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labeling and type enforcement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to troubleshoot SELinux issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the development of the topics in this chapter, it is necessary to install
    the packages indicated in each section. In each section, you will find the instructions
    for the different types of installation of each package as required.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about mandatory access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux file permissions control which users or groups of users access specific
    files. But a user with read or write access to a specific file could use that
    file in any way desired, even if that use is not what the file should be used
    for.
  prefs: []
  type: TYPE_NORMAL
- en: Linux *standard file permissions* succeed when files get used by a single owner
    and a single designated group of people.
  prefs: []
  type: TYPE_NORMAL
- en: File permissions fail to prevent some forms of unwanted access. They were not
    designed to control how a file gets used, but only who to allow to read, write,
    or run a file.
  prefs: []
  type: TYPE_NORMAL
- en: Linux standard file permissions are ownership-based, also known as **discretionary
    access** **control** (**DAC**).
  prefs: []
  type: TYPE_NORMAL
- en: The MAC rules are *policy* based, not by ownership.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of MAC:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-level security systems**: The original and simplest form of MAC consists
    of a vertical structure of protection and security levels. Information only flows
    within this area. A level of protection is also assigned to users, who can thus
    only access the same or lower levels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-lateral security systems**: These systems are more complex and assign
    access based on segments. Those segments form associations, which in turn consist
    of protection levels and code words. This results in a horizontal security system
    that also includes vertical levels of protection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux is an example of a MAC application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux offers a special security architecture based on the principles of MAC.
    SELinux *minimizes access* to operating system processes and files through strict
    access control methods and corresponding security measures. The module aims to
    ensure data confidentiality and integrity. Furthermore, with SELinux, the operating
    system and user programs remain delimited.
  prefs: []
  type: TYPE_NORMAL
- en: 'SELinux also relies on two other implementations: **type enforcement** (**TE**)
    and **role-based access control** (**RBAC**). With RBAC, access rights map according
    to a defined role model. The defined user roles abstract the work processes of
    an organization. On a MAC model, TE is the notion that access gets governed through
    clearance based on a *subject-access-object set* *of rules*.'
  prefs: []
  type: TYPE_NORMAL
- en: SELinux defines security measures and sets extra attributes that state under
    what conditions and in what situations a rights holder could access certain operating
    system processes or files. If these conditions or relationships (i.e., attributes)
    are not met, access is denied.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux consists of sets of policies that declare exactly what *actions and
    accesses* are allowed for each object used by an application. It is also known
    as a *targeted policy* since the policy covers the activities of a single application.
    Policies declare predefined labels that apply to individual programs, files, and
    network ports.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux enforces a set of access rules that prevent a security flaw in one application
    from affecting other applications or the system itself. SELinux provides an extra
    layer of security, but it also adds a level of complexity that might seem confusing
    to those unfamiliar with it.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand how it works, let’s walk through the basic concepts that
    SELinux works with.
  prefs: []
  type: TYPE_NORMAL
- en: Labeling and type enforcement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SELinux is a *labeling system*, which tells us that each file, directory, or
    object in the system has a corresponding label. Each file, process, directory,
    and port has a *special security label* called an SELinux context. A **context**
    is a tag name used by the SELinux policy to determine whether a process can access
    a file, directory, or port. Policies control the interaction between these elements.
    By default, the policy does not allow any interaction unless an explicit rule
    grants access. If no permission rule exists, access is not allowed. The Linux
    kernel enforces these rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'SELinux contexts have different labels in their format, separated by colons:
    *user*, *role*, *type*, and *sensitivity level*. They are formed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The *sensitivity level* is the part that is optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'The targeted policy bases its rules on the third context component: the *type*
    context. Type context names usually end with `_t`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – SELinux label example](img/12.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – SELinux label example
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the `/var/www/html/file` file has the following context
    components: `unconfined_u` is the SELinux user, the role is `object_r`, the type
    is `httpd_sys_content_t`, and the sensitivity level is `s0`. So, the context on
    which the access of this file depends is `httpd_sys_content_t`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use a demo example with this file to learn how the SELinux policy works.
  prefs: []
  type: TYPE_NORMAL
- en: How SELinux works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before analyzing the operation of SELinux, let’s determine how SELinux is running
    on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'SELinux runs in three modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enforcing**: SELinux enforces access control rules. This is the Fedora Linux
    default enabled mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permissive**: SELinux is active but instead of enforcing access control rules,
    it *logs warnings* of rules violated. This mode gets used for testing and troubleshooting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disabled**: SELinux is completely *disabled*; no SELinux violations are denied
    or even logged. *This is not recommended under* *any circumstances*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To find out how SELinux is running, use the `sestatus` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The SELinux running mode gets configured in the `/``etc/selinux/config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – SELinux config file](img/12.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – SELinux config file
  prefs: []
  type: TYPE_NORMAL
- en: 'During execution, for testing, the SELinux mode could change. But upon *rebooting*
    the system, it will again take the mode configured in the configuration file to
    set it. Use the `getenforce` command to find out the mode SELinux is running in
    and the `setenforce` command to change the mode, as the `root` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Changing the SELinux run mode](img/12.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Changing the SELinux run mode
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us see how SELinux works.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does SELinux work?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linux was born in the early days of the operating system’s usefulness. It’s
    used as the main operating system running a web server.
  prefs: []
  type: TYPE_NORMAL
- en: The Apache web server (`httpd`) is not insecure, but its *access range* is very
    wide so it is very important to secure it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s start with this example to understand how SELinux works. Follow the
    subsequent steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the **httpd** service is installed and active on the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Status of the httpd service](img/12.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Status of the httpd service
  prefs: []
  type: TYPE_NORMAL
- en: 'If not, use the **dnf** and **systemctl** commands to perform this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Linux kernel integrates an option, in most commands, to know the SELinux
    context type. Use the **ls** command with the **-Z** (or **–context**) option
    to identify the SELinux context type of the binary file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The configuration files for the **httpd** service are found in **/etc/httpd**.
    Let’s see what context type they have:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The logs of the **httpd** service are found in **/var/log/httpd**. Find their
    context type using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The content type directory of the **httpd** service is found in **/var/www/html**.
    Find their context using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The unit file for the **httpd** service startup is found in **/usr/lib/systemd/system/**.
    Find its context type using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the **ps** command to find the context type of the **httpd** service daemon
    while it is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 12.5 – Finding the context of the httpd daemon](img/12.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Finding the context of the httpd daemon
  prefs: []
  type: TYPE_NORMAL
- en: The context type of the service daemon is `httpd_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **netstat** command to find the context type of the **httpd** service
    port while it is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 12.6 – Finding the context of the httpd port](img/12.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Finding the context of the httpd port
  prefs: []
  type: TYPE_NORMAL
- en: The context type of the service port is `httpd_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example can be summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Context type** |'
  prefs: []
  type: TYPE_TB
- en: '| Binary file | `httpd_exec_t` |'
  prefs: []
  type: TYPE_TB
- en: '| Config files | `httpd_config_t` |'
  prefs: []
  type: TYPE_TB
- en: '| Logs | `httpd_log_t` |'
  prefs: []
  type: TYPE_TB
- en: '| Content directory | `httpd_sys_content_t` |'
  prefs: []
  type: TYPE_TB
- en: '| Unit file | `httpd_unit_file_t` |'
  prefs: []
  type: TYPE_TB
- en: '| Process | `httpd_t` |'
  prefs: []
  type: TYPE_TB
- en: '| Port | `httpd_t` `or http_port_t` |'
  prefs: []
  type: TYPE_TB
- en: Table 12.1 – The httpd service contexts
  prefs: []
  type: TYPE_NORMAL
- en: Note the relation of contexts; all belong to the `httpd_t` domain.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, type enforcement is the concept under which it makes sense for a process
    running in the `httpd_t` context to interact with a file labeled as `httpd_sys_content_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what context the `/etc/shadow` file has, where user passwords are
    stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: touch myfile
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: mv myfile /var/www/html/
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: curl http://localhost/myfile
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: grep myfile /var/log/audit/audit.log
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'type=AVC msg=audit(1689045662.823:264): avc:  denied  { getattr } for  pid=1035
    comm="httpd" path="/var/www/html/myfile" dev="vda3" ino=769948 scontext=system_u:system_r:httpd_t:s0
    tcontext=unconfined_u:object_r:admin_home_t:s0 tclass=file permissive=0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: date -d @1689045662.823
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Mon Jul 10 09:21:02 PM CST 2023
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: semanage command applies the httpd_sys_content_t label to the entire contents
    of the /srv/myweb directory and inherits it to the new files created in it. This
    means the (/.*)? characters appear at the end of the command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: -e option of the semanage command, assign the label with reference to another
    known file with the correct label.
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: restorecon -vR /srv/myweb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: chcon -t httpd_system_content_t /var/www/html/myfile
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: chcon --reference /var/www/html/ /var/www/html/myfile
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: chcon command. This is the easiest way to fix it.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there is a custom path, it is necessary to inform SELinux that an alternate
    directory to the policy is going to be used. To change the policy, use the `semanage`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: To save context changes in the policy, use the `restorecon` command.
  prefs: []
  type: TYPE_NORMAL
- en: When there is a customization that modifies the policy, this falls into the
    second case of SELinux failures. If the standard usage of a task changes, then
    SELinux must be informed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at these cases.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux needs to know
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the web server configuration, in the case of using a port other than
    the standard port (`80`) – for example, `8585` – let’s start by finding out the
    *port label*. Use the `semanage` command to ask the policy about the configured
    label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: semanage port -a -t http_port_t -p tcp 8585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: -P option, the Boolean change persists on system restart.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see all Booleans, use the `getsebool` command with the `-``a` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 12.8 – SELinux Booleans](img/12.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – SELinux Booleans
  prefs: []
  type: TYPE_NORMAL
- en: 'To review the Boolean description, use the `semanage boolean` command with
    the `-``l` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 12.9 – Reviewing the Boolean description](img/12.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Reviewing the Boolean description
  prefs: []
  type: TYPE_NORMAL
- en: These two cases, incorrect labeling and custom configuration, are the most common
    causes of errors with SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: There are two other cases that, although not as common, could happen.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the first one.
  prefs: []
  type: TYPE_NORMAL
- en: Policy bugs
  prefs: []
  type: TYPE_NORMAL
- en: 'In some events, the policy might not work when the behavior fails to meet expectations,
    as in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirection of stdout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtered file descriptors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executable memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries built wrongly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unusual paths in the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a high likelihood that the policy or application has bugs. These bugs
    or behavioral flaws should be reported to the developers to get them fixed.
  prefs: []
  type: TYPE_NORMAL
- en: This is an unusual situation as developers pay close attention to SELinux policies
    , but do not rule out the possibility of it happening.
  prefs: []
  type: TYPE_NORMAL
- en: A less common situation is that the system might be *compromised*, and the behavior
    of the policies changes to grant the escape of information or an intrusion.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at this last case of failure with SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: Hack attack
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a risk of a hack attack if the current tools *don’t do a good job*
    of differentiating contexts, or if you detect the case where *confined domains*
    attempt to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Load kernel modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn off SELinux enforcing mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write to **etc_t**/**shadow_t**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change firewall rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this happens, then be careful, because the system could become compromised
    and your information could be in danger.
  prefs: []
  type: TYPE_NORMAL
- en: Hacker attacks are not that common, but rest assured that hackers know how to
    use SELinux. Don’t trust, and follow your instinct. If you notice *unexpected
    behavior* and it is not related to the other SELinux failures, there is a possibility
    that your system might be hacked.
  prefs: []
  type: TYPE_NORMAL
- en: Take it *seriously*, and *thoroughly* inspect your system.
  prefs: []
  type: TYPE_NORMAL
- en: You never know when you might be a target for security attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we gave an overview of the use of SELinux and differentiated
    the types of access control: *discretionary* and *mandatory*. SELinux, as a mandatory
    access control could help us to harden the security of our systems.'
  prefs: []
  type: TYPE_NORMAL
- en: The use of SELinux is considered very complex, but we gave several examples
    that simplify how it works. SELinux is a *labeling system*.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to read the error logs with SELinux and found that there are
    only *four* scenarios where SELinux could fail, as looked at their solutions.
    The most common failures are with labels or when using custom configurations for
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Also, policies could have errors and they should be reported to their developers.
  prefs: []
  type: TYPE_NORMAL
- en: In a less common case, we analyzed that the change of behavior of the policies
    could be due to an *attack* on our system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take an in-depth look at how to virtualize complete
    systems or take them to their smallest expression using containers.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the topics covered in this chapter, you can visit the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A sysadmin’s guide to SELinux: 42 answers to the big* *questions*: [https://opensource.com/article/18/7/sysadmin-guide-selinux](https://opensource.com/article/18/7/sysadmin-guide-selinux)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A sysadmin’s handy cheat sheet for* *SELinux*: [https://opensource.com/article/18/8/cheat-sheet-selinux](https://opensource.com/article/18/8/cheat-sheet-selinux)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SELinux troubleshooting and* *pitfalls*: [https://www.redhat.com/sysadmin/selinux-troubleshooting](https://www.redhat.com/sysadmin/selinux-troubleshooting)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
