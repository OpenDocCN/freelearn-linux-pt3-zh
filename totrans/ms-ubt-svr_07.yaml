- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Controlling and Managing Processes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制和管理进程
- en: On a typical Linux server, there can be over a hundred processes running at
    any given time. The purposes of these processes range from system services, such
    as the **Network Time Protocol** (**NTP**) service, to processes that serve information
    to others, such as the Apache web server. As an administrator of Ubuntu servers,
    you will need to be able to manage these processes, as well as managing the resources
    available to them. In this chapter, we’ll take a look at process management, including
    the `ps` command, managing job control commands, and more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的 Linux 服务器上，任何时候都可能有超过一百个进程在运行。这些进程的用途从系统服务（例如 **网络时间协议**（**NTP**）服务），到为其他进程提供服务的进程（如
    Apache web 服务器）不等。作为 Ubuntu 服务器的管理员，你需要能够管理这些进程，以及管理它们所使用的资源。在本章中，我们将探讨进程管理，包括
    `ps` 命令、管理作业控制命令等。
- en: 'As we work through these concepts, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习这些概念的过程中，我们将涉及以下主题：
- en: Managing jobs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理作业
- en: Understanding the `ps` command
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `ps` 命令
- en: Changing the priority of processes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改进程优先级
- en: Dealing with misbehaving processes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常进程
- en: Managing system processes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理系统进程
- en: Scheduling tasks with `cron`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `cron` 调度任务
- en: To begin our exploration of managing processes, let’s take a look first at managing
    jobs. Not only will this help us understand the concepts better, but it will also
    provide us with a better understanding of backgrounding and foregrounding.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始探索进程管理，首先让我们来看一下作业管理。这不仅有助于我们更好地理解这些概念，还能帮助我们更好地理解后台和前台操作。
- en: Managing jobs
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理作业
- en: Up until now, everything we have been doing on the shell has been right in front
    of us, from execution to completion. We’ve installed applications, run programs,
    and walked through various commands. Each time, we’ve had control of our shell
    taken from us, and we’ve only been able to start a new task when the previous
    one had finished. For example, if we were to install the `vim-nox` package with
    the `apt install` command, we would watch helplessly while `apt` takes care of
    fetching the package and installing it for us.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们在 shell 中做的每一件事都直接呈现在我们面前，从执行到完成。我们安装了应用程序，运行了程序，走过了各种命令。每次，我们的 shell
    控制权都会被夺走，直到上一个任务完成，我们才能开始下一个任务。例如，如果我们用 `apt install` 命令安装 `vim-nox` 包，我们只能眼睁睁看着
    `apt` 为我们获取包并安装它。
- en: While this is going on, our cursor goes away and our shell completes the task
    for us without allowing us to queue up another command. We can always open a new
    shell to the server and multitask by having two windows open at once, each doing
    different tasks. But that’s likely not going to be the most efficient method of
    multitasking when working with the command line.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，我们的光标消失，shell 会为我们完成任务，而不会让我们排队执行其他命令。我们可以随时打开一个新的 shell 会话到服务器，利用同时打开两个窗口来进行多任务处理，每个窗口执行不同的任务。但在使用命令行时，这可能不是最有效的多任务处理方式。
- en: Instead, we can actually background a process without waiting for it to complete
    while working on something else. Then, we can bring that process back to the front
    to return to working on it or to check whether or not it finished successfully.
    Think of this as a similar concept to a windowing desktop environment, or user
    interfaces on the Windows or macOS operating systems. We can work on an application,
    minimize it to get it out of the way, and then maximize it to continue working
    with it. Essentially, that’s the same concept as backgrounding a process in a
    Linux shell.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们实际上可以将一个进程放到后台，而不必等待它完成，然后可以将该进程带回前台，继续处理它，或者检查它是否成功完成。可以将这看作类似于窗口化桌面环境或
    Windows 或 macOS 操作系统上的用户界面。我们可以在使用某个应用程序时，将它最小化以便不妨碍操作，再将其最大化以继续工作。实际上，这与在 Linux
    shell 中将进程放到后台的概念是一样的。
- en: 'So how exactly do you background and foreground a process? This concept can
    be somewhat difficult to explain. In my opinion, the easiest way to learn a new
    concept is to try it out, and the easiest example I can think of is by (yet again)
    using a text editor. I promise that this time, using a text editor as an example
    won’t be boring. In fact, this example is extremely useful and may just become
    a part of your daily workflow. To do this exercise, you can use any command-line
    text editor you prefer, such as Vim or Nano. On Ubuntu Server, `nano` is usually
    installed by default, so you already have it if you want to go with that. If you
    prefer to use Vim, feel free to install the `vim-nox` package if you haven’t already
    installed it:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，究竟如何将进程放入后台或前台呢？这个概念有点难以解释。在我看来，学习新概念最简单的方法是亲自尝试，而我能想到的最简单的例子就是（再次）使用文本编辑器。我保证这次以文本编辑器为例不会无聊。事实上，这个例子非常有用，可能会成为你日常工作流的一部分。为了完成这个练习，你可以使用任何你喜欢的命令行文本编辑器，比如Vim或Nano。在Ubuntu
    Server中，`nano`通常是默认安装的，因此如果你想使用它，你已经有了。如果你更喜欢使用Vim，可以随时安装`vim-nox`包（如果你还没有安装的话）：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can actually install `vim` rather than `vim-nox`, but I always default to
    `vim-nox` since it features built-in support for scripting languages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上可以安装`vim`而不是`vim-nox`，但我总是默认安装`vim-nox`，因为它内置支持脚本语言。
- en: Again, feel free to use whichever text editor you feel comfortable with. In
    the following examples, I’ll be using `nano`, but if you use `vim`, just replace
    `nano` with `vim` every time you see it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，随意使用你感到舒服的文本编辑器。在以下的例子中，我将使用`nano`，但如果你使用`vim`，只需每次看到`nano`时都将其替换为`vim`。
- en: Anyway, to see backgrounding in action, open up your text editor. Feel free
    to open a file or just start a blank session. (If in doubt, type `nano` and press
    *Enter*.) With the text editor open, we can background it at any time by pressing
    *Ctrl + z* on our keyboard.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，为了查看后台操作的实际效果，打开你的文本编辑器。你可以选择打开一个文件，或者只启动一个空白会话。（如果不确定，可以输入`nano`并按*Enter*。）文本编辑器打开后，我们可以随时通过按下键盘上的*Ctrl
    + z*将其放入后台。
- en: If you are using `vim` instead of `nano`, you can only background `vim` when
    you are *not* in *insert mode*, since it captures *Ctrl + z* rather than passing
    it to the shell.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`vim`而不是`nano`，你只能在*非插入模式*下将`vim`放到后台，因为它会捕获*Ctrl + z*，而不是将其传递给shell。
- en: 'Did you see what happened? You were immediately taken away from your editor
    and returned to the shell so you can now get back to executing commands. You should
    have seen some output similar to the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了发生了什么吗？你会立刻被带离编辑器，返回到shell，这样你就可以继续执行命令了。你应该会看到类似以下的输出：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we see the `job` number of our process, its status, and then the name
    of the process. Even though the process of your text editor shows a status of
    `Stopped`, it’s still running. You can confirm this with the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到进程的`job`编号、其状态以及进程名称。即使文本编辑器的进程显示状态为`Stopped`，它仍然在运行。你可以通过以下命令确认这一点：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In my case, I see the `nano` process running with a PID of `43231`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我看到`nano`进程正在运行，PID为`43231`：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At this point, I can execute additional commands, navigate around my filesystem,
    and get additional work done. When I want to bring my text editor back, I can
    use the `fg` command to foreground the process, which will resume it. If I have
    multiple background processes, the `fg` command will bring back the one I was
    working on most recently.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我可以执行其他命令，浏览我的文件系统，并完成其他工作。当我想将文本编辑器恢复到前台时，我可以使用`fg`命令将进程放到前台，这样它就会恢复运行。如果我有多个后台进程，`fg`命令会将我最近操作的那个进程恢复到前台。
- en: I gave you an example of the `ps` command to show that the process was still
    running in the background, but there’s actually a dedicated command for that purpose,
    and that is the `jobs` command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我给你举了一个`ps`命令的例子，展示进程仍在后台运行，但实际上有一个专门的命令用于此目的，那就是`jobs`命令。
- en: 'If you execute the `jobs` command, you’ll see in the output a list of all the
    processes running in the background:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行`jobs`命令，你会看到输出中列出所有后台运行的进程：
- en: '![](img/B18425_07_01.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_07_01.png)'
- en: 'Figure 7.1: Running the jobs command after backgrounding two nano processes'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：在将两个`nano`进程放入后台后运行`jobs`命令
- en: 'The output shows that I have two `nano` sessions in use, one modifying `file1.txt`,
    and the other modifying `file2.txt`. If I were to execute the `fg` command, that
    would bring up the `nano` session that’s editing `file2.txt`, since that was the
    last one I was working in. That may or may not be the one I want to return to
    editing, though. Since I have the job ID on the left, I can bring up a specific
    background process by using its ID with the `fg` command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示我有两个正在使用的`nano`会话，一个在修改`file1.txt`，另一个在修改`file2.txt`。如果我执行`fg`命令，它将把编辑`file2.txt`的`nano`会话调回前台，因为那是我最近在使用的会话。不过，这不一定是我想要返回编辑的文件。由于我左侧有作业ID，我可以通过`fg`命令使用其ID来调回特定的后台进程：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Knowing how to background a process can add quite a bit to your workflow. For
    example, let’s say, hypothetically, that I’m editing a config file for a server
    application, such as Apache. While I’m editing this config file, I need to consult
    the documentation (man page) for Apache because I forgot the syntax for something.
    I could open a new shell and an SSH session to my server and view the documentation
    in another window. This could get very messy if I open up too many shells. It
    would be much simpler to background the current `nano` session, read the documentation,
    and then foreground the process with the `fg` command to return to working on
    it, all from one SSH session!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何将进程放入后台可以极大地提高工作效率。例如，假设我正在编辑一个服务器应用程序的配置文件，如Apache。在编辑配置文件时，我需要查阅Apache的文档（手册页面），因为我忘记了某个语法。我可以打开一个新的Shell和SSH会话，查看另一个窗口中的文档。如果打开太多的Shell窗口，可能会变得非常混乱。将当前的`nano`会话放入后台，查看文档，然后用`fg`命令将进程调回前台继续工作，所有操作都可以在一个SSH会话中完成，这样会更加简便！
- en: To background a process, you don’t have to use *Ctrl + z*; you can actually
    background a process right when you execute it by entering a command with the
    ampersand symbol (`&`) typed at the end. To show you how this works, I’ll use
    `htop` as an example. Admittedly, this may not necessarily be the most practical
    example, but it does work to show you how to start a process and have it backgrounded
    right away.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个进程放入后台，你不一定需要使用*Ctrl + z*；实际上，你可以在执行命令时，直接通过在命令末尾加上&符号（`&`）来将进程放入后台。为了演示这个操作，我将使用`htop`作为示例。虽然这可能不是最实际的例子，但它可以有效地展示如何启动一个进程并立即将其放入后台。
- en: 'We might not have `htop` installed yet, but for now, feel free to install this
    package (if it isn’t already) and then run it with the ampersand symbol:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还没有安装`htop`，但现在如果没有安装，请随意安装此软件包（如果尚未安装），然后使用&符号运行它：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first command, as you already know, installs the `htop` package on our server.
    With the second command, I’m opening `htop` but backgrounding it immediately.
    What I’ll see when it’s backgrounded is its job ID and process ID (more on this
    in the next section). Now, at any time, I can bring `htop` to the foreground with
    `fg`. Since I just backgrounded it, `fg` will bring `htop` back since it considers
    it the most recent. As you know, if it wasn’t the most recent, I could reference
    its job ID with the `fg` command to bring it back even if it wasn’t my most recently
    used job. Go ahead and practice using the ampersand symbol with a command and
    then bringing it back to the foreground. In the case of `htop`, it can be useful
    to start it, background it, and then bring it back anytime you need to check the
    performance of your server.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，第一个命令将在我们的服务器上安装`htop`软件包。第二个命令会打开`htop`，但会立即将其放入后台。当它被放入后台时，我会看到它的作业ID和进程ID（接下来会详细讲解）。现在，在任何时候，我都可以使用`fg`将`htop`调回前台。由于我刚刚将其放入后台，`fg`会将`htop`带回前台，因为它被视为最近的任务。如你所知，如果它不是最近的任务，我可以通过`fg`命令引用它的作业ID来将其带回，即使它不是我最近使用的任务。试着练习一下，使用命令中的&符号并将其带回前台。以`htop`为例，这种操作很有用，启动它、将其放入后台，然后在需要检查服务器性能时随时将其带回前台。
- en: Keep in mind, though, that when you exit your shell, all your backgrounded processes
    will close. If you have unsaved work in your text editors, you’ll lose what you
    were working on. For this reason, if you utilize background processes, you may
    want to check to see if you have any pending jobs still running by executing the
    `jobs` command before logging out.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不过请记住，当你退出Shell时，所有后台进程都会关闭。如果你在文本编辑器中有未保存的工作，你将会丢失正在处理的内容。因此，如果你使用后台进程，在注销之前，最好先执行`jobs`命令检查是否有待处理的任务仍在运行。
- en: In addition, you’ll probably notice that some applications background cleanly,
    while others don’t. In the case of using a text editor and `htop`, those applications
    stay paused in the background, allowing us to perform other tasks and then return
    to those commands later. However, some applications may still spit out diagnostic
    text regularly in your main window, whether they’re backgrounded or not. To get
    even more control over your Bash sessions, you can learn how to use a multiplexer,
    such as `tmux` or `screen`, to allow these processes to run in their own session
    such that they don’t interrupt your work. Going over the use of a program such
    as `tmux` is beyond the scope of this book, but it is a useful utility to learn
    if you’re interested.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能会注意到，一些应用程序能够平稳地置于后台运行，而其他应用程序则不能。以使用文本编辑器和`htop`为例，这些应用会在后台保持暂停状态，允许我们执行其他任务，然后再返回这些命令。然而，一些应用即使被置于后台，仍可能会定期在主窗口输出诊断文本。为了更好地控制你的
    Bash 会话，你可以学习如何使用多路复用器，如`tmux`或`screen`，让这些进程在它们自己的会话中运行，这样就不会打断你的工作。虽然本书不打算详细介绍如何使用`tmux`这类程序，但如果你感兴趣，它是一个非常有用的工具。
- en: Being able to background and foreground a process allows us to manage tasks
    on the command line more effectively, and is definitely useful. Now, we can expand
    this and look at viewing other processes on the server, including those that we
    didn’t manually start such as a text editor. In the next section, we’ll take a
    look at the `ps` command, which can help us understand what is actually running
    on our server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将进程置于后台和前台运行，使我们能更有效地管理命令行上的任务，这绝对是有用的。现在，我们可以扩展这一点，看看如何查看服务器上的其他进程，包括那些我们没有手动启动的进程，比如文本编辑器。在接下来的部分中，我们将详细了解`ps`命令，它可以帮助我们理解服务器上实际运行的进程。
- en: Understanding the ps command
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`ps`命令
- en: While managing our server, we’ll need to understand what processes are running
    and how to manage them. Later in this chapter, we’ll work through starting, stopping,
    and monitoring processes. But before we get to those concepts, we first need to
    be able to determine what is actually running on our server. The `ps` command
    allows us to do this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理我们的服务器时，我们需要了解哪些进程正在运行，并且如何管理它们。在本章后续的部分中，我们将学习如何启动、停止和监控进程。但在讲解这些概念之前，我们首先需要能够确定服务器上实际运行的进程。`ps`命令可以帮助我们完成这项工作。
- en: Viewing running processes with ps
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`ps`查看正在运行的进程
- en: 'When executed by itself, the `ps` command will show a list of processes run
    by the user who called the command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ps`命令单独执行时，它会显示由调用该命令的用户运行的进程列表：
- en: '![](img/B18425_07_02.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_07_02.png)'
- en: 'Figure 7.2: The output of the ps command, when run as a normal user and with
    no options'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：当以普通用户身份运行`ps`命令且没有选项时的输出
- en: In *Figure 7.2*, you can see that when I ran the `ps` command as my own user
    with no options, it showed me a list of processes that I am running as myself.
    In this case, I have a `vim` session open (running in the background), and in
    the last line, we also see `ps` itself, which is also included in the output.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 7.2*中，你可以看到当我作为自己的用户运行`ps`命令且没有任何选项时，它显示了我以自己身份运行的进程列表。在这个例子中，我有一个`vim`会话正在运行（在后台），并且在最后一行，我们还看到了`ps`本身，它也包含在输出中。
- en: On the left side of the output, you’ll see a number for each of the running
    processes. This is known as the **Process ID** (**PID**), which we mentioned in
    the *Managing jobs* section. Before we continue on, the PID is something that
    you really should be familiar with, so we may as well cover it right now.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的左侧，你会看到每个正在运行的进程的编号。这被称为**进程 ID**（**PID**），我们在*管理作业*部分中提到过。为了继续之前，PID是你应该熟悉的内容，所以我们不妨现在就来讲解一下。
- en: Each process running on your server is assigned a PID, which differentiates
    it from other processes on your system. You may understand a process as `vim`,
    or `top`, or some other name. However, our server knows processes by their ID.
    When you open a program or start a process, it’s given a PID by the kernel. As
    you work on managing your server, you’ll find that the PID is useful to know,
    especially for the commands we’ll be covering in this very chapter. If you want
    to kill a misbehaving process, for example, a typical workflow would be for you
    to find the PID of that process and then reference that PID when you go to kill
    the process (which I’ll show you how to do in a later section). PIDs are actually
    more complex than just a number assigned to running processes, but for the purposes
    of this chapter, that’s the main purpose we’ll need to remember.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器上运行的每个进程都会分配一个PID，这使它与系统上的其他进程区分开来。你可能会理解一个进程是`vim`、`top`或其他某个名称。但是，我们的服务器通过进程的ID来识别它们。当你打开一个程序或启动一个进程时，内核会为其分配一个PID。当你管理服务器时，你会发现知道PID非常有用，特别是对于本章将要介绍的命令。例如，如果你想终止一个表现不正常的进程，一个典型的工作流程是先找到该进程的PID，然后在杀死进程时引用该PID（稍后我会展示如何做）。实际上，PID比单纯分配给运行进程的数字要复杂，但本章的主要目的是帮助你记住这个概念。
- en: 'You can also use the `pidof` command to find the PID of a process if you know
    the name of it. For example, I showed you a screenshot of a `vim` process running
    with a PID of `1385`. You can also do so by running the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道进程的名称，你也可以使用`pidof`命令来查找进程的PID。例如，我曾向你展示过一个`vim`进程的截图，PID为`1385`。你也可以通过运行以下命令来做到这一点：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output will give you the PID(s) of the process without you having to use
    the `ps` command.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将给出进程的PID，而无需使用`ps`命令。
- en: Configuring arguments to ps
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置`ps`的参数
- en: 'Continuing with the `ps` command, there are several useful arguments you can
    give in order to change the way in which it produces an output. If you use the
    `a` option, you’ll see more information than you normally would:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用`ps`命令，你可以通过提供几个有用的参数来改变输出的方式。如果你使用`a`选项，你会看到比正常情况更多的信息：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will produce an output something like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下所示的输出：
- en: '![](img/B18425_07_03.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_07_03.png)'
- en: 'Figure 7.3: The output of the ps a command'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：`ps a`命令的输出
- en: With `ps a`, we’re seeing the same output as before, but with additional information,
    as well as column headings at the top. We now see a heading for `PID`, `TTY`,
    `STAT`, `TIME`, and `COMMAND`. From this new output, you can see that the `vim`
    processes I have running are editing a file named `testfile.txt`. This is great
    to know, because if I had more than one `vim` session open and one of them was
    misbehaving, I would probably want to know which one I specifically needed to
    stop.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ps a`，我们看到的输出与之前相同，但附加了更多的信息，并且顶部有了列标题。现在我们看到了`PID`、`TTY`、`STAT`、`TIME`和`COMMAND`的标题。从这个新的输出中，你可以看到我正在运行的`vim`进程正在编辑一个名为`testfile.txt`的文件。这很有用，因为如果我有多个`vim`会话打开，而其中一个会话表现异常，我可能想知道需要停止的是哪一个。
- en: We already saw the `PID` and `COMMAND` fields, although we didn’t see a formal
    heading at the top. The `PID` column we’ve already covered, so I won’t go into
    any additional detail about that. The `COMMAND` field tells us the actual command
    being run, which is very useful if we either want to ensure we’re managing the
    correct process or to see what a particular user is running (I’ll demonstrate
    how to display processes for other users soon).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`PID`和`COMMAND`字段，尽管我们没有看到顶部的正式标题。我们已经讨论过`PID`列，所以我就不再详细介绍了。`COMMAND`字段告诉我们实际正在运行的命令，如果我们想确保管理的是正确的进程，或者想查看某个用户正在运行的程序，这非常有用（稍后我会演示如何显示其他用户的进程）。
- en: 'The `STAT`, field is new; we didn’t see it when we ran `ps` by itself. The
    `STAT` field gives us the status code of the process, which refers to which state
    the process is currently in. The state can be uninterruptible sleep (`D`), defunct
    (`Z`), stopped (`T`), interruptible sleep (`S`), and in the run queue (`R`). There
    is also paging (`W`), but that is not used anymore, so there’s no need to cover
    it. Uninterruptible sleep is a state in which a process is generally waiting on
    input and cannot handle additional signals (we’ll briefly talk about signals later
    on in this chapter). A defunct process (also referred to as a zombie process)
    has, for all intents and purposes, finished its job but is waiting on the parent
    to perform cleanup. Defunct processes aren’t actually running, but remain in the
    process list and should normally close on their own. If such a process remains
    in the list indefinitely and doesn’t close, it can be a candidate for the `kill`
    command, which we will discuss later. A stopped process is generally a process
    that has been sent to the background, which will be discussed in the next section.
    Interruptible sleep means that the program is idle: it’s waiting for input in
    order to awaken.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`STAT` 字段是新的；我们在单独运行 `ps` 时并没有看到它。`STAT` 字段告诉我们进程的状态码，表示该进程当前所处的状态。状态可以是不可中断的睡眠（`D`）、僵尸进程（`Z`）、停止（`T`）、可中断的睡眠（`S`）和运行队列（`R`）。还有分页（`W`），但现在不再使用，因此不需要讨论。不可中断的睡眠是一种进程状态，通常表示该进程在等待输入，无法处理额外的信号（我们稍后会简要介绍信号）。僵尸进程（也称为僵尸进程）在所有实际情况下已经完成了任务，但仍在等待父进程执行清理操作。僵尸进程实际上并没有运行，但会保留在进程列表中，通常会自行关闭。如果这样的进程无限期地保留在列表中并没有关闭，它就可能成为
    `kill` 命令的候选对象，我们稍后会讨论该命令。停止的进程通常是已被发送到后台的进程，这将在下一节中讨论。可中断的睡眠表示程序处于空闲状态：它在等待输入，以便唤醒。'
- en: The `TTY` column tells us which TTY the process is attached to. A TTY refers
    to a **teletypewriter**, which is a term used from a much different time period.
    In the past, during the time of big mainframes, users would use such computers
    using “terminals” – a device consisting of a monitor and keyboard, connected (via
    the wire) to the mainframe. Such devices could only display the output received
    from the mainframe, and receive data typed on the keyboard. Teletypewriter was
    the term used to refer to such devices. Obviously, we don’t use machines like
    these nowadays, but the concept is similar from a virtual standpoint.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`TTY` 列告诉我们进程附加到哪个 TTY。TTY 是指**打字机**，这是一个来自不同历史时期的术语。过去，在大型主机时代，用户使用“终端”来操作计算机——这种终端设备由显示器和键盘组成，通过电缆与主机相连。这些设备只能显示从主机接收到的输出，并接收键盘上输入的数据。打字机就是用来指代这类设备的术语。显然，现在我们不再使用这样的设备，但从虚拟的角度来看，概念是相似的。'
- en: On our server, we’re using our keyboard to send input to a device that then
    displays output to another device. In our case, the input device is our keyboard
    and the output device is our screen, which is either connected directly to our
    server or is located on our computer, which is connected to our server over a
    service such as SSH. On a Linux system, most processes run on a TTY, which is
    (for all intents and purposes) a terminal that grabs input and manages the output,
    similar to a teletypewriter in a virtual sense. A terminal is our method of interacting
    with our server.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的服务器上，我们使用键盘向一个设备发送输入，然后该设备将输出显示到另一个设备上。在我们的例子中，输入设备是我们的键盘，输出设备是我们的屏幕，屏幕要么直接连接到服务器，要么连接到我们的计算机，计算机通过像
    SSH 这样的服务与服务器相连。在 Linux 系统中，大多数进程运行在 TTY 上，TTY 是（从实际应用的角度来说）一个终端，它接收输入并管理输出，类似于虚拟意义上的打字机。终端是我们与服务器交互的方式。
- en: In *Figure 7.3*, we have a process running on a TTY of `tty1`, and the other
    processes are running on `pts/0`. The TTY we see is the actual terminal device,
    and `pts` references a virtual (pseudo) terminal device. Our server is actually
    able to run several `tty` sessions, typically one to seven. Each of these can
    be running its own programs and processes. To understand this better, try pressing
    *Ctrl + Alt +* any function key, from *F1* through *F7* (if you have a physical
    keyboard plugged into a physical server). Each time, you should see your screen
    cleared and then moved to another terminal. Each of these terminals is independent
    of one another. Each of your function keys represents a specific TTY, so by pressing
    *Ctrl + Alt + F6*, you’re switching your display to TTY 6.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7.3*中，我们看到一个进程正在`tty1`的TTY上运行，其他进程则在`pts/0`上运行。我们看到的TTY是实际的终端设备，而`pts`指代的是一个虚拟（伪）终端设备。我们的服务器实际上能够运行多个`tty`会话，通常是1到7个。每个TTY会话都可以运行自己的程序和进程。为了更好地理解这一点，尝试按下*Ctrl
    + Alt +* 任意功能键，从*F1*到*F7*（如果你插入了物理键盘到物理服务器）。每按一次，你应该看到屏幕清空，然后转到另一个终端。每个终端都是独立的。每个功能键代表一个特定的TTY，所以按下*Ctrl
    + Alt + F6*时，你会把显示切换到TTY 6。
- en: Essentially, you’re switching from TTY 1 through to TTY 7, with each being able
    to contain its own running processes. If you run `ps a` again, you’ll see any
    processes you start on those TTYs show up in the output as a `tty` session, such
    as `tty2` or `tty4`. Processes that you start in a terminal emulator will be given
    a designation of `pts`, because they’re not running in an actual TTY, but rather
    a pseudo-TTY.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，你是在从TTY 1切换到TTY 7，每个TTY都可以容纳自己正在运行的进程。如果你再次运行`ps a`，你会看到你在这些TTY上启动的任何进程会以`tty`会话的形式显示在输出中，例如`tty2`或`tty4`。你在终端模拟器中启动的进程会被标记为`pts`，因为它们并不在一个实际的TTY上运行，而是运行在伪TTY上。
- en: This was a long discussion for something that ends up being simple (TTY or pseudo-TTY),
    but with this knowledge, you should be able to differentiate between a process
    running on the actual server or through a shell.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个看似复杂但实际上很简单的讨论（TTY或伪TTY），但通过掌握这些知识，你应该能够区分一个进程是在实际服务器上运行还是通过一个终端外壳运行。
- en: Continuing, let’s take a look at the `TIME` field of our `ps` command output.
    This field represents the total amount of time the CPU has been utilized for that
    particular process. However, the time is `0:00` for each of the processes in the
    screenshot I’ve provided. This may be confusing at first. In my case, the `vim`
    processes in particular have been running for about 15 minutes or so since I took
    the screenshot, and they still show `0:00` utilization time even now. Actually,
    this isn’t the amount of time the process has been running, but rather the amount
    of time the process has been actively engaging with the CPU. In the case of `vim`,
    each of these processes is just a buffer with a file open. For the sake of comparison,
    the Linux machine I’m writing this chapter on has a process ID of `759` with a
    time of `92:51`. PID `759` belongs to my X server, which provides the foundation
    for my **graphical user interface** (**GUI**) and windowing capabilities. However,
    this laptop currently has an uptime of 6 days and 22 hours as I type this, which
    is roughly equivalent to 166 hours, which is not the same amount of time that
    PID `759` is reporting in its `TIME` entry. Therefore, we can deduce that even
    though my laptop has been running for 6 days straight, the X server has only utilized
    92 hours and 51 minutes of actual CPU time. In summary, the `TIME` column refers
    to the amount of time a process needs the CPU in order to calculate something
    and is not necessarily equal to how long something has been running, or for how
    long a graphical process is showing on your screen.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`ps`命令输出中的`TIME`字段。这个字段表示CPU为该特定进程分配的总时间。然而，在我提供的截图中，每个进程的时间显示为`0:00`。刚开始可能会有些困惑。就我而言，特别是`vim`进程自从我截图以来已经运行了大约15分钟，但它们现在仍然显示为`0:00`的利用时间。实际上，这并不是进程运行的时间，而是进程与CPU进行交互的时间。对于`vim`而言，每个进程只是一个打开了文件的缓冲区。为了进行对比，我现在正在写这章的Linux机器的进程ID为`759`，时间为`92:51`。PID
    `759`属于我的X服务器，它提供了我的**图形用户界面**（**GUI**）和窗口功能。然而，当前这台笔记本的正常运行时间为6天22小时，也就是大约166小时，这与PID
    `759`在`TIME`列中报告的时间并不相同。因此，我们可以推测，尽管我的笔记本已经连续运行了6天，但X服务器实际利用的CPU时间仅为92小时51分钟。总结一下，`TIME`列指的是进程需要CPU的时间以便计算某些东西，它不一定等于进程已经运行的时间，也不等于图形进程在屏幕上显示的时间。
- en: 'Let’s continue on with the `ps` command and look at some additional options.
    First, let’s see what we get when we add the `u` option to our previous example,
    which gives us the following example command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨`ps`命令，并查看一些额外的选项。首先，让我们看看当我们在之前的例子中添加`u`选项时，会得到什么结果，下面是相应的命令：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will produce an output that will look similar to the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似于以下内容的输出：
- en: '![](img/B18425_07_04.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_07_04.png)'
- en: 'Figure 7.4: The output of the ps au command'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：`ps au`命令的输出
- en: 'When you run it, you should notice the difference from the `ps a` command right
    away. With this variation, you’ll see processes listed that are being run by your
    user ID, as well as other users. When I run it, I see processes listed in the
    output for my user (`jay`), as well as one for `root`. The `u` option will be
    a common option you’re likely to use, since most of the time while managing servers,
    you’re probably more interested in keeping an eye on what kinds of shenanigans
    your users are getting themselves into. But perhaps the most common use of the
    `ps` command is the following variation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行时，你应该立刻注意到与`ps a`命令的不同。使用这种变体，你会看到列出的是由你的用户ID以及其他用户运行的进程。当我运行时，我看到输出中列出了我的用户（`jay`）的进程，以及一个`root`的进程。`u`选项将是你可能会常用的选项，因为在大多数管理服务器的情况下，你可能更关心的是监控你的用户在做些什么。但是，`ps`命令最常用的变体可能是以下这种：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the `x` option added, we’re no longer limiting our output to processes
    within a TTY (either native or pseudo). The result is that we’ll see a lot more
    processes, including system-level processes that are not tied to a process we
    started ourselves. Go ahead and try it. In practice, though, the `ps aux` command
    is most commonly used with `grep` to look for a particular process or string.
    For example, let’s say you want to see a list of all `nginx` worker processes.
    To do that, you may execute a command such as the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 加上 `x` 选项后，我们不再将输出限制于 TTY 内的进程（无论是本地的还是伪终端的）。结果是我们将看到更多的进程，包括那些不与我们自己启动的进程相关的系统级进程。试试看吧。不过在实践中，`ps
    aux` 命令最常与 `grep` 一起使用，以查找特定的进程或字符串。例如，假设你想查看所有 `nginx` 工作进程的列表。为此，你可以执行如下命令：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we’re executing the `ps aux` command as before, but we’re piping the
    output into `grep`, where we’re looking only for lines of output that include
    the string `nginx`. In practice, this is the way I often use `ps`, as well as
    the way I’ve noticed many other administrators using it. With `ps aux`, we are
    able to see a lot more output, and then we can narrow that down with search criteria
    by piping into `grep`. However, if all we wanted to do was to show processes that
    have a particular string, we could also do the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们像之前一样执行 `ps aux` 命令，但我们将输出通过管道传输到 `grep`，并只查找包含字符串 `nginx` 的输出行。在实践中，这是我常用
    `ps` 的方式，也是我注意到很多其他管理员常用的方式。使用 `ps aux` 后，我们可以看到更多的输出，然后通过管道传输到 `grep` 来用搜索条件进一步缩小范围。然而，如果我们只想显示包含特定字符串的进程，我们也可以执行以下命令：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This would produce output containing a list of processes matching `nginx`,
    and related details. Another useful variation of the `ps` command is to sort the
    output by sorting the processes using the most CPU first:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出匹配 `nginx` 的进程列表及相关详细信息。`ps` 命令的另一个有用变体是通过按 CPU 使用率排序来排序进程：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Unfortunately, that command shows a lot of output, and we would have to scroll
    back to the top in order to see the top processes. Depending on your terminal,
    you may not have the ability to scroll back very far (or at all), so the following
    command will narrow it down further:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，该命令会显示大量的输出，我们需要滚动回到顶部才能看到最上面的进程。根据你的终端配置，你可能无法回滚太多（甚至根本无法回滚），因此以下命令将进一步缩小输出范围：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that is useful! With that example, I’m using the `ps aux` command with
    the `--sort` option, sorting by the percentage of CPU utilization (`-pcpu`). Then
    I’m piping the output into the `head` command, where I’m instructing it to show
    me only five lines (`-n 5`). Essentially, this is giving me a list of the top
    five processes that have used the most CPU since boot time. In fact, I can do
    the same, but with the most-used memory instead:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这可真有用！在这个示例中，我使用 `ps aux` 命令并加上 `--sort` 选项，按照 CPU 使用百分比（`-pcpu`）排序。然后，我将输出传送到
    `head` 命令，指示它只显示前五行（`-n 5`）。本质上，这给了我自开机以来使用最多 CPU 的前五个进程列表。事实上，我也可以做到同样的事情，只不过是按使用最多内存来排序：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you want to determine which processes are misbehaving and using a non-ordinary
    amount of memory or CPU, those commands will help you narrow it down. The `ps`
    command is a very useful command for your admin toolbox. Feel free to experiment
    with it beyond the examples I’ve provided; you can consult the man pages for the
    `ps` command to learn even more tricks. In fact, the second section of the man
    page for `ps` (under *examples*) gives you even more neat examples to try out.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想确定哪些进程表现异常并占用大量内存或 CPU，那么这些命令将帮助你缩小范围。`ps` 命令是管理员工具箱中非常有用的命令。你可以在我提供的示例之外自由实验，想要了解更多技巧，你可以查阅
    `ps` 命令的手册页。实际上，`ps` 命令的手册页第二部分（在 *examples* 下）提供了更多有趣的示例，供你尝试。
- en: Now that we know how to inspect running processes, in the next section, we’ll
    take a look at how to change the priority of the processes to ensure those that
    are more important are given extra attention by the CPU.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何检查正在运行的进程，在接下来的部分中，我们将了解如何更改进程的优先级，确保更重要的进程能够获得 CPU 更多的关注。
- en: Changing the priority of processes
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改进程的优先级
- en: 'Processes on a Linux system can be run with an altered priority, giving some
    processes more priority and others less. This gives you, the administrator, full
    reign when it comes to ensuring that the most important processes on the system
    are running with an adequate level of prioritization. There are dedicated commands
    for this purpose: `nice` and `renice`. These commands allow you to launch a process
    with a specific priority, or change the priority of a process that’s already running.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Linux系统上的进程可以以更改后的优先级运行，从而让某些进程拥有更高的优先级，其他进程则拥有较低的优先级。这为你作为管理员提供了充分的权限，确保系统中最重要的进程得到足够的优先级。为此，我们有专门的命令：`nice`和`renice`。这些命令允许你启动一个具有特定优先级的进程，或者更改已经运行中的进程的优先级。
- en: Nowadays, manually editing the priority of a process is something administrators
    will find themselves doing less often than they used to. A processor with 32 cores
    (or many more) is not all that uncommon, and neither is hundreds of gigabytes
    of RAM. Servers nowadays are certainly more powerful than they used to be, and
    are nowhere near as resource-starved as machines of old. Many servers (such as
    virtual machines) and containers are dedicated to a single task, so process tuning
    may not be of extreme value anymore. However, data processing firms and companies
    utilizing deep learning functions may find themselves needing to fine-tune some
    things.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，管理员们手动编辑进程的优先级已经不像以前那么常见了。拥有32个核心（甚至更多）的处理器已经不是什么稀奇事，几百GB的内存也是如此。如今的服务器无疑比以前更强大，且不像过去的机器那样资源紧张。许多服务器（例如虚拟机）和容器被专门用于执行单一任务，因此进程调优可能已经不再那么重要。然而，数据处理公司和使用深度学习功能的公司可能仍然需要进行某些细节调整。
- en: 'Regardless of whether or not prioritizing processes is something that will
    be immediately useful to you, it’s a good idea to at least understand the concept
    just in case you do find yourself needing to increase or decrease the priority
    of a process some day. Let’s revisit the `ps` command, this time with the `-l`
    argument:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否优先处理进程对你有直接用处，至少理解这一概念是个好主意，免得有一天你需要增加或减少某个进程的优先级时能够应对。让我们重新查看一下`ps`命令，这次加上`-l`参数：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of this command will appear as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出将如下所示：
- en: '![](img/B18425_07_05.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_07_05.png)'
- en: 'Figure 7.5: The output of the ps -l command'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：`ps -l`命令的输出
- en: With the output of the `ps -l` command, notice the `PRI` and `NI` columns. `PRI`
    refers to the priority, and `NI` pertains to the “niceness” value, which we’ll
    discuss in more detail later in this section. In this example, each process that
    I’m running has a `PRI` of `80`, and an `NI` of `0`. I didn’t change or alter
    any of these; these are the values that I get when I start processes with no special
    tweaks. A `PRI` value of `80` is the starting value for that value on all processes,
    and will change as we increase or decrease the niceness value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ps -l`命令的输出中，可以注意到`PRI`和`NI`列。`PRI`表示优先级，`NI`表示“niceness”值，我们稍后将在本节中详细讨论。在这个例子中，我运行的每个进程的`PRI`都是`80`，`NI`是`0`。我没有改变或调整这些值；这些是我启动没有特别调整的进程时的默认值。`PRI`的值`80`是所有进程的初始值，并会随着“niceness”值的增加或减少而变化。
- en: As I mentioned, we have dedicated commands that allow us to alter priorities,
    `nice` and `renice`. To determine which to use, it all comes down to whether or
    not the process is already running. With regard to the processes listed in *Figure
    7.5*, we would want to use `renice` to change the priority for those, since they’re
    all already running. If we wanted to launch a process with a specific priority
    right from the beginning, we would use `nice` instead.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所提到的，我们有专门的命令来允许我们更改优先级，分别是`nice`和`renice`。选择使用哪个命令，取决于进程是否已经在运行。关于*图7.5*中的进程，我们需要使用`renice`来更改它们的优先级，因为这些进程都已经在运行。如果我们想从一开始就启动一个具有特定优先级的进程，我们应该使用`nice`。
- en: 'For example, let’s change the process of the `vim` session I have running.
    Sure, this is a somewhat lame example, as `vim` isn’t a very important process.
    In the real world, you’d be prioritizing processes that are actually important.
    In my case, since the `vim` process has a PID of `1789`, the command I would need
    to run in order to change the niceness would become this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们改变我正在运行的`vim`会话的进程。确实，这是一个有些无聊的例子，因为`vim`并不是一个非常重要的进程。在现实中，你会优先处理那些真正重要的进程。以我为例，既然`vim`进程的PID是`1789`，那么我需要运行的命令来改变优先级将是这个：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of this command will appear as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出将如下所示：
- en: '![](img/B18425_07_06.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_07_06.png)'
- en: 'Figure 7.6: Changing the priority of a process with renice'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：使用renice更改进程优先级
- en: 'If we run `ps -l` again, we can see the new nice value for `vim`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行`ps -l`，可以看到`vim`的新的nice值：
- en: '![](img/B18425_07_07.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_07_07.png)'
- en: 'Figure 7.7: The output of the ps -l command after changing the priority of
    a process'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：更改进程优先级后`ps -l`命令的输出
- en: 'The new nice value of `10` now shows up for `vim` under `NI`, and the `PRI`
    value has increased to `90`. Now, this instance of `vim` will run at a lower priority
    than my other tasks, the reason being that the higher the nice value, the lower
    the priority. Notice that I didn’t use `sudo` with the command when I changed
    the priority. In this example, that’s okay because I’m increasing the nice value
    of the process, and that’s allowed. However, let’s try to decrease the nice value
    without `sudo`, using the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`vim`的新的nice值`10`在`NI`列中显示，`PRI`值也增加到`90`。现在，这个`vim`实例将以比其他任务更低的优先级运行，因为nice值越高，优先级越低。注意，当我更改优先级时，并没有使用`sudo`。在这个例子中，这是可以的，因为我只是增加了进程的nice值，这是允许的。但是，让我们尝试在没有`sudo`的情况下减少nice值，使用以下命令：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see in the following output, I won’t be as successful:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在以下输出中看到的，我并没有成功：
- en: '![](img/B18425_07_08.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_07_08.png)'
- en: 'Figure 7.8: Attempting to decrease the priority of a process'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：尝试降低进程的优先级
- en: My attempt to decrease the nice value from 10 down to 5 was blocked. If I were
    able to lower the niceness, then my process would be running at a higher priority.
    Instead, I received a `Permission denied` error. So essentially, users are allowed
    to increase the niceness of their processes, but are not allowed to decrease it,
    not even for processes they’ve initiated themselves. If you wish to decrease the
    nice value, you’ll need to do so with `sudo`. So essentially, if you want to be
    “nicer,” you can go ahead and do so. If you wish to be “meaner,” you’ll need `root`
    privileges. In addition, a user won’t be able to change the priority of a process
    they don’t own. So, if you attempt to use `renice` to change the niceness of a
    task running as a different user, you’ll receive an `Operation not permitted`
    error.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我尝试将nice值从10降低到5被阻止了。如果我能够降低nice值，那么我的进程将以更高的优先级运行。相反，我收到了一个`Permission denied`错误。所以，本质上，用户可以增加他们进程的nice值，但不能减少，哪怕是自己启动的进程。如果你希望减少nice值，必须使用`sudo`。所以，本质上，如果你想“更友善”一些，你可以继续进行。如果你想“更严苛”一些，你需要`root`权限。此外，用户无法更改他们不拥有的进程的优先级。因此，如果你试图使用`renice`更改另一个用户正在运行的任务的nice值，你将收到`Operation
    not permitted`错误。
- en: 'At this point, we know how to re-prioritize our running processes with `renice`.
    Now, let’s take a look at starting a new process with a specific priority with
    `nice`. Consider the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们知道如何使用`renice`重新调整正在运行的进程的优先级。现在，让我们看一下如何使用`nice`启动一个具有特定优先级的新进程。请看以下命令：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we’re launching a new instance of `vim`, but with the priority set to
    a specific value right from the start. If we want to change the priority of `vim`
    again later, we’ll need to use `renice`. As I mentioned earlier, `nice` is used
    to launch a new process with a specific priority, and `renice` is for changing
    the priority of a pre-existing process. In this example, we launched `vim` and
    set its nice value to `10` in one command.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们启动了一个新的`vim`实例，但一开始就将优先级设置为特定的值。如果我们稍后想再次更改`vim`的优先级，我们需要使用`renice`。正如我之前提到的，`nice`用于启动一个具有特定优先级的新进程，而`renice`则用于更改已存在进程的优先级。在这个例子中，我们通过一个命令启动了`vim`并将其nice值设置为`10`。
- en: Changing the priority of a text editor such as `vim` may seem like an odd choice
    for a test case, and it is. But the `vim` editor is harmless, as the likelihood
    of us changing the priority of it leading to a system halt is extremely minimal.
    There’s no practical reason I can think of where it would be useful to re-prioritize
    something like a text editor. The takeaway, though, is that you *can* change the
    priority of the processes running on your server. On a real server, you may have
    an important process that runs and generates a report, and that report must be
    delivered on time. Or perhaps you have a process that generates an export of data
    that a client needs to have in order to make an on-time deliverable. So, if you
    think of the bigger picture, you can replace `vim` with the name of a process
    that is actually important for you or your organization.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将像`vim`这样的文本编辑器的优先级改变可能看起来是一个奇怪的测试用例，确实是这样。但`vim`编辑器是无害的，因为我们改变它的优先级导致系统崩溃的可能性极小。我想不出有什么实际理由需要重新调整像文本编辑器这样的程序的优先级。不过值得注意的是，你*可以*改变运行在服务器上的进程的优先级。在真实的服务器上，你可能有一个重要的进程，它生成报告并且必须按时交付。或者你可能有一个进程生成一个数据导出，客户需要这些数据来完成按时交付。所以，从更广阔的视角来看，你可以用对你或你的组织真正重要的进程名来替换`vim`。
- en: You might be wondering what “nice” means in the context of the `nice` and `renice`
    commands. The “nice” number essentially refers to how nice a process is to other
    users. The higher the nice value, the lower the priority. So, a value of 20 is
    nicer than a value of 10\. In that case, processes with a niceness of 20 are running
    at a lower priority, and so are kinder to the other processes on the system. The
    niceness can range from -20 to 19\. A process with a nice value of -20 is the
    highest priority possible, while 19 is the lowest priority it can have. The entire
    system is quite a bit more complicated than this simple description. Although
    I refer to the nice value as the priority, it actually isn’t. The nice value is
    used to calculate the actual priority. But for now, if we simplify the nice value
    to be representative of the priority, and the nice value to equate to a lower
    priority, the higher the number gets, that’s enough for now.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇，`nice`和`renice`命令中的“nice”是什么意思。“nice”值本质上指的是一个进程对其他用户的“友好程度”。nice值越高，优先级越低。所以，值为20比值为10更“友好”。在这种情况下，nice值为20的进程以较低的优先级运行，因此对系统中的其他进程更加友好。nice值的范围是从-20到19。nice值为-20的进程优先级最高，而19是最低的优先级。整个系统比这个简单的描述要复杂得多。尽管我将nice值称作优先级，但它实际上并不是。nice值用于计算实际的优先级。不过现在，如果我们将nice值简化为代表优先级，并且假设nice值越高优先级越低，那就足够了。
- en: 'So far, we’ve been using the `nice` and `renice` commands along with the `-n`
    option to set the nice values directly. It may be interesting to note though that
    you can simplify the `renice` command and leave out the `-n` option:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用`nice`和`renice`命令，并结合`-n`选项直接设置nice值。不过值得注意的是，你可以简化`renice`命令，省略`-n`选项：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That command sets the nice value of the process to a positive 10, similar to
    our other examples. We can also use a negative number for the niceness if we want
    to increase the priority:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将进程的nice值设置为正数10，类似于我们之前的其他示例。如果我们想提高优先级，也可以使用负数来设置nice值：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Although it doesn’t save us much typing to leave out the `-n` option, now you
    know that it is a possibility. The other difference with that example was that
    I needed to use `sudo` since I’m decreasing the nice value (more on that later).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然省略`-n`选项并不会大幅减少我们打字的工作量，但现在你知道这是一个可行的选项。与这个例子不同的是，由于我在降低优先级值（稍后会详细介绍），我需要使用`sudo`。
- en: 'When it comes to the `nice` command, we can also leave out the `-n` option,
    but the command works a bit differently in this regard. The following won’t work:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`nice`命令时，我们也可以省略`-n`选项，但在这方面命令的行为略有不同。下面的命令将无法正常工作：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The syntax of `nice` is a bit different, so giving it a positive number directly
    won’t work as it does with `renice`. For that, we’ll need to add a hyphen in front:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`nice`的语法略有不同，所以直接给它一个正数并不会像在`renice`中那样有效。为此，我们需要在数字前面加上一个短横线：'
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you look at that command, you may assume we’re applying a negative number.
    Actually, that’s not true. Since the syntax is different with `nice`, the `-15`
    value we used results in a positive 15\. We needed the hyphen in front of the
    value to signify to `nice` that we’re applying a value as an option. If we actually
    do want to use a negative value with `nice` while also avoiding the `-n` option,
    we would need to use two hyphens:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看这个命令时，可能会认为我们在应用一个负数。实际上，情况并非如此。由于`nice`的语法不同，我们使用的`-15`值实际上会转换为正数15。我们在值前加上连字符是为了告诉`nice`我们正在将该值作为选项应用。如果我们确实想在不使用`-n`选项的情况下使用负值与`nice`命令配合使用，我们需要使用两个连字符：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The difference in syntax between the two commands with the `-n` option is a
    bit confusing in my opinion, so I recommend simply using the `-n` option with
    `nice` and `renice`, as that’s going to be more uniform between them:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这两个命令在使用`-n`选项时的语法差异有点令人困惑，因此我建议直接在`nice`和`renice`中都使用`-n`选项，因为这样它们会更加一致：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Those examples show both `nice` and `renice` using the `-n` option, and setting
    both positive and negative values. Since the `-n` option is used the same way
    between the two commands, it may be easier to focus on committing that to memory
    rather than focusing on the specifics. As previously discussed, I used `sudo`
    with commands that set a negative value for niceness, since only `root` can change
    a process to, or start a process with, a niceness below `0`. You’ll receive the
    following error if you try to do it anyway:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了如何使用`-n`选项分别操作`nice`和`renice`命令，并设置正值和负值。由于这两个命令中`-n`选项的使用方式相同，因此可能更容易将其记住，而不是关注具体的细节。如前所述，我在设置负值时使用了`sudo`，因为只有`root`用户才能将进程的优先级设置为低于`0`。如果你试图这样做，你将收到以下错误：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This type of protection is somewhat important, because you may have some users
    who feel as though their processes are the most important, and try to prioritize
    them all the way to `-19`. At the end of the day, it’s better for a system administrator
    to make decisions on which processes are allowed to reach a niceness value in
    the negative.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的保护是有一定重要性的，因为你可能会遇到一些用户，他们认为自己的进程是最重要的，试图将它们的优先级提升到`-19`。归根结底，最好由系统管理员来决定哪些进程可以将优先级设置为负值。
- en: As an administrator of Ubuntu servers, it’s up to you to decide which processes
    should be running, and at what priority. You’ll then determine the best way to
    achieve the exact system state that’s appropriate, and tuning process priority
    may be a part of that. If nothing else, learning the `nice` and `renice` commands
    gives you another utility for your toolset.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Ubuntu服务器的管理员，决定哪些进程应该运行，且运行时的优先级是多少，是你的责任。然后，你将确定最佳的方式以实现合适的系统状态，调优进程优先级可能是其中的一部分。如果没有别的，学习`nice`和`renice`命令将为你的工具集增添另一项实用功能。
- en: Dealing with misbehaving processes
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理不正常的进程
- en: Regarding the `ps` command, by this point you know how to display processes
    running on your server, as well as how to narrow down the output by string or
    resource usage. But what can you actually do with that knowledge? As much as we
    hate to admit it, sometimes the processes our server runs fail or misbehave and
    you need to restart them. If a process refuses to close normally, you may need
    to kill that process. In this section, we introduce the `kill` and `killall` commands
    to serve that purpose.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`ps`命令，到目前为止你已经知道如何显示服务器上正在运行的进程，并且可以通过字符串或资源使用情况来缩小输出范围。但你实际上能做些什么呢？尽管我们不愿承认，但有时服务器上运行的进程会失败或表现不正常，这时你可能需要重启它们。如果某个进程无法正常关闭，你可能需要终止该进程。在本节中，我们介绍了`kill`和`killall`命令来执行这一操作。
- en: 'The `kill` command accepts a PID as an argument and attempts to close a process
    gracefully. In a typical workflow where you need to terminate a process that won’t
    do so on its own, you will first use the `ps` command to find the PID of the culprit.
    Then, knowing the PID, you can attempt to `kill` the process. For example, if
    PID `31258` needed to be killed, you could execute the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill`命令接受PID作为参数，并尝试优雅地关闭一个进程。在一个典型的工作流中，当你需要终止一个无法自行关闭的进程时，你首先会使用`ps`命令找到该进程的PID。然后，知道PID后，你可以尝试`kill`该进程。例如，如果PID为`31258`的进程需要被终止，你可以执行以下命令：'
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If all goes well, the process will end. You can restart it or investigate why
    it failed by perusing its logs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，进程将结束。你可以重新启动它，或者通过查看日志来调查它为什么失败。
- en: To better understand what the `kill` command does, you first will need to understand
    the basics of **Linux signals**. Signals are used by both administrators and developers
    and can be sent to a process either by the kernel, another process, or manually
    with a command. A signal instructs the process of a request or change, and in
    some cases, to completely terminate. An example of such a signal is `SIGHUP`,
    which tells processes that their controlling terminal has exited. One situation
    in which this may occur is when you have a terminal emulator open, with several
    processes inside it running. If you close the terminal window (without stopping
    the processes you were running), they’ll be sent the `SIGHUP` signal, which basically
    tells them to quit (essentially, it means the shell quit or hung up).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解`kill`命令的作用，你首先需要理解**Linux信号**的基础知识。信号由管理员和开发者使用，可以通过内核、另一个进程或手动命令发送给一个进程。信号指示进程执行请求或更改，有时甚至是完全终止。例如，`SIGHUP`信号告诉进程它们的控制终端已经退出。一个可能发生这种情况的情况是你打开了一个终端模拟器，里面运行着几个进程。如果你关闭终端窗口（而没有停止你正在运行的进程），这些进程将会收到`SIGHUP`信号，基本上告诉它们退出（本质上意味着shell已退出或挂起）。
- en: 'Other examples include `SIGINT` (where an application is running in the foreground
    and is stopped by pressing *Ctrl + c* on the keyboard) and `SIGTERM`, which, when
    sent to a process, asks it to cleanly terminate. Yet another example is `SIGKILL`,
    which forces a process to terminate uncleanly. In addition to a name, each signal
    is also represented by a value, such as `15` for `SIGTERM` and `9` for `SIGKILL`.
    Going over each of the signals is beyond the scope of this chapter (the advanced
    topics of signals are mainly only useful for developers), but you can view more
    information about them by consulting the man page if you’re curious:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 其他示例包括`SIGINT`（当应用程序在前台运行时，按下*Ctrl + c*会停止它），以及`SIGTERM`，当发送到进程时，请求它干净地终止。还有一个例子是`SIGKILL`，它强制进程以不干净的方式终止。除了名称，每个信号还由一个值表示，例如`SIGTERM`的值是`15`，`SIGKILL`的值是`9`。逐一介绍所有信号超出了本章的范围（信号的高级主题主要对开发者有用），但如果你感兴趣的话，可以通过查阅man页查看更多信息：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For the purposes of this section, the two types of signals we are most concerned
    about are `SIGTERM(15)` and `SIGKILL(9)`. When we want to stop a process, we send
    one of these signals to it, and the `kill` command allows us to do just that.
    By default, the `kill` command sends signal `15` (`SIGTERM`), which tells the
    process to cleanly terminate. If successful, the process will free its memory
    and gracefully close. With our previous example `kill` command, we sent signal
    `15` to the process, since we didn’t clarify which signal to send.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们最关注的两种信号是`SIGTERM(15)`和`SIGKILL(9)`。当我们想要停止一个进程时，我们向它发送其中一个信号，而`kill`命令正是允许我们做到这一点。默认情况下，`kill`命令会发送信号`15`（`SIGTERM`），告诉进程干净地终止。如果成功，进程将释放其内存并优雅地关闭。通过我们之前的`kill`命令，我们向进程发送了信号`15`，因为我们没有明确指定发送哪个信号。
- en: Terminating a process with `SIGKILL(9)` is considered an extreme last resort.
    When you send signal `9` to a process, it’s the equivalent of ripping the carpet
    out from underneath it or blowing it up with a stick of dynamite. The process
    will be force-closed without giving it any time to react at all, so it’s one of
    those things you should avoid using unless you’ve literally tried absolutely everything
    you can think of. In theory, sending signal `9` can cause corrupted files, memory
    issues, or other shenanigans to occur. As for me, I’ve never actually run into
    long-term damage to software from using it, but theoretically it can happen, so
    you want to only use it in extreme cases. One case where such a signal may be
    necessary is regarding `defunct` or a **zombie process** in a situation where
    they don’t close on their own. These processes are basically dead already and
    are typically waiting on their parent processes to reap them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SIGKILL(9)`终止进程被认为是一种极端的最后手段。当你向一个进程发送信号`9`时，相当于把地毯从它下面撕掉，或者用一根炸药棍把它炸飞。进程会被强制关闭，完全没有反应的时间，因此，这是一种你应该避免使用的手段，除非你已经尝试了所有能想到的办法。理论上，发送信号`9`可能会导致文件损坏、内存问题或其他异常情况。至于我，虽然我自己使用过它，但从未遇到过长期的损害，但理论上是有可能发生的，因此你只应该在极端情况下使用它。一个可能需要使用此信号的情况是有关`defunct`或**僵尸进程**的情况，当它们无法自行关闭时。这些进程基本上已经“死了”，通常是等待其父进程来回收它们。
- en: If the parent process never attempts to do so, they will remain on the process
    list. This in and of itself may not really be a big issue, since these processes
    aren’t technically doing anything. But if their presence is causing problems and
    you can’t kill them, you could try to send `SIGKILL` to the process. There should
    be no harm in eliminating a zombie process, but you would want to give them time
    to be reaped first.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父进程从未尝试这样做，它们将一直保留在进程列表中。单从这个角度看，这可能并不算什么大问题，因为这些进程技术上并没有做任何事情。但如果它们的存在引发了问题，而你又无法终止它们，可以尝试向进程发送`SIGKILL`信号。消除僵尸进程应该不会带来任何危害，但你还是希望它们能有时间被清除。
- en: 'To send signal `9` to a process, you would use the `-9` option of the `kill`
    command. It should go without saying, though, to make sure you’re executing it
    against the proper process ID:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要向进程发送`9`信号，你需要使用`kill`命令的`-9`选项。尽管不言而喻，但还是要确保你执行的是正确的进程ID。
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Just like that, the process with a PID of `31258` will vanish without a trace.
    Anything it was writing to will be in limbo, and it will be removed from memory
    instantly. If, for some reason, the process still manages to stay running (which
    is extremely rare), you probably would need to reboot the server to get rid of
    it, which is something I’ve only seen in a few, very rare cases. An example of
    this is a zombie process, which is a process that shows up in the process list
    but isn’t impacted by having signals sent to it, since such a process won’t be
    scheduled for CPU time anyway. When it all comes down to it, if `kill` `-9` doesn’t
    get rid of the process, nothing will.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，PID为`31258`的进程会毫无痕迹地消失。它正在写入的任何数据将会处于悬空状态，并且会立即从内存中删除。如果出于某种原因，该进程仍然继续运行（这非常罕见），你可能需要重启服务器来彻底清除它，这种情况我只在极为罕见的几个案例中见过。例如，僵尸进程就是这样一种情况，它出现在进程列表中，但无论发送什么信号，它都不会受到影响，因为这种进程根本不会被调度占用CPU时间。总的来说，如果`kill
    -9`不能清除进程，那么就没有什么能做到的了。
- en: 'Another method of killing a process is with the `killall` command, which is
    probably safer than the `kill` command (if for no other reason than there’s a
    smaller chance you’ll accidentally kill the wrong process). Like `kill`, `killall`
    allows you to send `SIGTERM` to a process, but unlike `kill`, you can do so by
    name. In addition, `killall` doesn’t just kill one process, it kills any process
    it finds with the name you’ve given it as an option. To use `killall`, you would
    simply execute `killall` along with the name of a process:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种终止进程的方法是使用`killall`命令，这比`kill`命令更安全（至少在没有其他原因的情况下，误终止错误进程的可能性较小）。与`kill`类似，`killall`允许你向进程发送`SIGTERM`信号，但与`kill`不同，你可以通过进程名称来执行。此外，`killall`不仅会终止一个进程，它会终止所有与给定名称匹配的进程。要使用`killall`，你只需执行`killall`并指定一个进程的名称：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Just like the `kill` command, you can also send signal `9` to the process as
    well:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 和`kill`命令一样，你也可以向进程发送`9`信号：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Again, use that only when necessary. In practice, though, you probably won’t
    use `killall -9` very often (if ever), because it’s rare for multiple processes
    under the same process name to become locked. If you need to send signal `9`,
    stick to the `kill` command if you can.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，只有在必要时才使用该方法。实际上，你可能不会经常使用`killall -9`（甚至从未使用过），因为多个同名进程被锁住的情况很少发生。如果确实需要发送`9`信号，尽量使用`kill`命令。
- en: The `kill` and `killall` commands can be incredibly useful in the situation
    of a stuck process, but these are commands you would hope you don’t have to use
    very often. Stuck processes can occur in situations where applications encounter
    a situation from which they can’t recover, so if you constantly find yourself
    needing to kill processes, you may want to check for an update to the package
    responsible for the service or check your server for hardware issues.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill`和`killall`命令在进程卡住的情况下非常有用，但这些命令最好不是经常使用的。进程卡住通常发生在应用程序遇到无法恢复的情况时，因此，如果你经常需要终止进程，可能需要检查负责服务的软件包是否有更新，或者检查服务器是否存在硬件问题。'
- en: In the next section, let’s take a look at system processes that run in the background
    and provide a service to us or our users, such as a web server process or DHCP
    server.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看在后台运行并为我们或我们的用户提供服务的系统进程，例如 web 服务器进程或 DHCP 服务器。
- en: Managing system processes
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理系统进程
- en: System processes, also known as **daemons**, are programs that run in the background
    on your server and are typically started automatically when it boots. We don’t
    usually manage these services directly as they run in the background to perform
    their duty, with or without needing our input. For example, if our server is a
    DHCP server and runs the `isc-dhcp-server` process, this process will run in the
    background, listening for DHCP requests and providing new IP assignments to them
    as they come in. Most of the time, when we install an application that runs as
    a service, Ubuntu will configure it to start when we boot our server, so we don’t
    have to start it ourselves. Assuming the service doesn’t run into an issue, it
    will happily continue performing its job forever until we tell it to stop. In
    Linux, services are managed by its init system, also referred to as PID 1 since
    the init system of a Linux system always receives that PID. In recent years, the
    way in which processes are managed in Ubuntu Server has changed considerably.
    Ubuntu has switched to `systemd` for its `init` system, which was previously Upstart
    until a few years ago. Ubuntu 16.04 was the first LTS release of Ubuntu with `systemd`,
    and this continues to be used today in Ubuntu 22.04\. Since `systemd` has been
    the standard for quite some time now, we’ll focus our attention on the commands
    used with it to manage our services. Older `init` systems are aging out.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 系统进程，也称为**守护进程**，是在服务器后台运行的程序，通常会在服务器启动时自动启动。我们通常不会直接管理这些服务，因为它们在后台运行并执行其职责，无论是否需要我们的输入。例如，如果我们的服务器是一个DHCP服务器并且运行`isc-dhcp-server`进程，那么该进程将在后台运行，监听DHCP请求并为它们分配新的IP地址。通常，当我们安装一个作为服务运行的应用程序时，Ubuntu会配置它在启动时自动启动，因此我们不需要手动启动它。假设该服务没有出现问题，它将继续执行其工作，直到我们告诉它停止。在Linux中，服务由init系统管理，也称为PID
    1，因为Linux系统的init系统总是获得该PID。在近年来，Ubuntu Server中进程管理的方式发生了很大变化。Ubuntu已经切换到`systemd`作为其`init`系统，之前一直使用Upstart，直到几年前。Ubuntu
    16.04是首个使用`systemd`的LTS版本，并且这一标准在Ubuntu 22.04中继续沿用。由于`systemd`已经成为标准一段时间，我们将重点介绍与其一起使用的命令来管理服务。旧的`init`系统正在逐渐淘汰。
- en: 'With `systemd`, services are known as **units**, but for all intents and purposes,
    the terms “service,” “daemon,” and “unit” all essentially mean the same thing.
    Since I started using Linux over 20 years ago, I still refer to `systemd` units
    as services, out of habit. To help us manage these “units,” `systemd` includes
    the `systemctl` command, which allows you to start, stop, and view the status
    of units on our server. To help illustrate this, I’ll use OpenSSH as an example.
    The name of the unit doesn’t really matter, as the syntax of the `systemctl` command
    is the same regardless of the name of the unit we’re interacting with. You can
    use `systemctl` to start, stop, or restart your Apache instance, your database
    server, or even use it to restart the entire networking stack. The `systemctl`
    command, with no options or parameters, assumes the `list-units` option, which
    dumps a list of units to your shell. This can be a bit messy, though, so if you
    already know the name of a unit you’d like to search for, you can pipe the output
    into `grep` and search for a string. This is handy in a situation where you may
    not know the exact name of the unit, but you know part of it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`systemd`中，服务被称为**单元**，但在实际使用中，“服务”、“守护进程”和“单元”这几个术语本质上是相同的。自从20多年前开始使用Linux以来，我依然习惯性地将`systemd`的单元称为服务。为了帮助我们管理这些“单元”，`systemd`包括了`systemctl`命令，它允许你启动、停止并查看服务器上单元的状态。为了帮助说明这一点，我将以OpenSSH为例。单元的名称并不重要，因为`systemctl`命令的语法无论我们操作的是哪个单元名称都是相同的。你可以使用`systemctl`启动、停止或重新启动Apache实例、数据库服务器，甚至用它重新启动整个网络堆栈。`systemctl`命令如果没有任何选项或参数，会默认使用`list-units`选项，列出单元的列表到你的shell中。不过，这可能会有点杂乱，所以如果你已经知道你要查找的单元名称，你可以将输出通过管道传递给`grep`，并搜索字符串。在你可能不知道单元的确切名称，但知道部分名称的情况下，这非常方便：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you want to check the health of a unit, the best way is to actually use
    the `status` keyword, which will show you some very useful information regarding
    the unit. This information includes whether or not the unit is running, if it’s
    enabled (meaning it’s configured to start at boot time), as well as the most recent
    log entries for the unit:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查某个单元的健康状况，最好的方法是使用`status`关键字，它会显示有关该单元的一些非常有用的信息。这些信息包括该单元是否正在运行、是否已启用（意味着它已配置为在启动时自动启动），以及该单元的最新日志条目：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This command will produce an output something like the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将产生类似以下的输出：
- en: '![](img/B18425_07_09.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_07_09.png)'
- en: 'Figure 7.9: Checking the status of a unit with systemctl'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：使用 systemctl 检查单元的状态
- en: Most of the time, you can actually check the status of units without needing
    `root` access, but you may not see all the information available. In the screenshot,
    you can see several log entries for the `ssh` service, but some units do not show
    those entries without `sudo`. With the `ssh` unit in particular, we see the log
    entries when checking the status with or without `sudo`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你实际上可以在不需要 `root` 权限的情况下检查单元的状态，但你可能看不到所有可用的信息。在截图中，你可以看到几个关于 `ssh` 服务的日志条目，但某些单元在没有
    `sudo` 权限的情况下不会显示这些条目。特别是对于 `ssh` 单元，我们在使用或不使用 `sudo` 时都会看到日志条目。
- en: 'Another thing you may notice in the screenshot is that the name of the `ssh`
    unit is actually `ssh.service`, but you don’t need to include the `.service` part
    of the name, since that is implied by default. Sometimes, while viewing the status
    of a process with `systemctl`, the output may be condensed to save space on the
    screen. To avoid this and see the full log entries, add the `-l` option:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在截图中注意到的另一件事是，`ssh` 单元的名称实际上是 `ssh.service`，但你不需要包含 `.service` 部分，因为默认情况下它是隐含的。有时，在使用
    `systemctl` 查看进程状态时，输出可能会被压缩以节省屏幕空间。为了避免这种情况并查看完整的日志条目，可以添加 `-l` 选项：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Another thing to pay attention to is the `vendor preset` of the unit. Most packages
    in Ubuntu that include a service file for `systemd` will enable it automatically,
    but other distributions typically don’t start and enable units by default (such
    as CentOS). In the case of the `ssh` example, you can see that the `vendor preset`
    is set to `enabled`. This means that once you install the `openssh-server` package,
    the `ssh.service` unit will automatically be enabled. You can confirm this by
    checking the `Active` line (where the example output says `active (running)`),
    which tells us that the unit is running. The `Loaded` line clarifies that the
    unit is `enabled`, so we know that the next time we start the server, `ssh` will
    be loaded automatically. Although `systemd` units are typically enabled and started
    automatically in Ubuntu when installing their package, this can still vary. When
    you install a new package, make sure you check the status of the unit, so you’ll
    be aware of its settings.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要注意的事情是单元的 `vendor preset`。大多数包含 `systemd` 服务文件的 Ubuntu 软件包会自动启用它，但其他发行版通常默认不会启动和启用单元（例如
    CentOS）。以 `ssh` 为例，你可以看到 `vendor preset` 被设置为 `enabled`。这意味着一旦安装 `openssh-server`
    包，`ssh.service` 单元将自动启用。你可以通过检查 `Active` 行来确认这一点（例如输出中显示 `active (running)`），它告诉我们该单元正在运行。`Loaded`
    行则明确指出该单元是 `enabled`，所以我们知道下次启动服务器时，`ssh` 将会自动加载。虽然在 Ubuntu 中安装包时，`systemd` 单元通常会被自动启用并启动，但这仍然会有所不同。在安装新软件包时，确保检查该单元的状态，以便了解它的设置。
- en: 'Starting and stopping a unit is just as easy; all you have to do is change
    the keyword you use with `systemctl` to `start` or `stop` in order to have the
    desired effect:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 启动和停止单元同样简单；你只需将 `systemctl` 中使用的关键字更改为 `start` 或 `stop`，即可实现所需的效果：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are additional keywords, such as `restart` (which takes care of the previous
    two command examples at the same time), and some units even feature `reload`,
    which allows you to activate new configuration settings without needing to bring
    down the entire application. An example of why this is useful is with Apache,
    which serves web pages to local or external users. If you stop Apache, all users
    will be disconnected from the website you’re serving. If you add a new site, you
    can use `reload` rather than `restart`, which will activate any new configuration
    you may have added without disturbing the existing connections. We’ll take a look
    at Apache in *Chapter 14*, *Serving Web Content*, so don’t worry too much about
    Apache right now. It’s just a good example of a unit with additional functionality.
    Not all units feature a `reload` option, so you should check the documentation
    of the application that provides the unit to be sure.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他关键字，例如 `restart`（它一次性处理前两个命令示例的功能），一些单元甚至提供 `reload`，允许你在不关闭整个应用程序的情况下激活新的配置设置。一个有用的例子是
    Apache，它向本地或外部用户提供网页服务。如果你停止 Apache，所有用户将与网站断开连接。如果你添加了一个新的网站，可以使用 `reload` 而不是
    `restart`，这样可以在不打断现有连接的情况下激活你所做的任何新配置。我们将在*第14章*《提供网页内容》中查看 Apache，所以现在不必过多担心
    Apache。它只是一个具有附加功能的单元的好例子，并不是所有单元都有 `reload` 选项，因此你应当查阅提供该单元的应用程序文档，以确保这一点。
- en: Since I mentioned starting and stopping the unit for OpenSSH in the previous
    examples, an interesting aside is that doing so will not disconnect a current
    SSH session to the server, should you have one open. If you stop the `ssh` service,
    it won’t drop your connection. Open connections are maintained, and stopping SSH
    only prevents new connections from happening. Therefore, SSH is different when
    compared to other units (such as Apache) in that existing connections aren’t dropped
    when restarting the unit.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我在之前的示例中提到了启动和停止 OpenSSH 单元的操作，有一个有趣的补充是，执行这些操作不会中断当前的 SSH 会话，如果你已经打开了 SSH
    会话。停止 `ssh` 服务不会断开你的连接。现有的连接会被保持，停止 SSH 只会阻止新的连接建立。因此，与其他单元（例如 Apache）不同，SSH 在重新启动时不会中断现有连接。
- en: 'As I mentioned before, if you want a unit to automatically start when the server
    boots, the unit will need to be enabled. Units are automatically enabled most
    of the time, but in case you find one that isn’t enabled, you can enable it with
    the `enable` keyword:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所提到的，如果你希望一个单元在服务器启动时自动启动，则该单元需要被启用。大多数单元默认是自动启用的，但如果你遇到一个没有启用的单元，你可以通过
    `enable` 关键字来启用它：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It’s just as easy to disable a unit as well:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用一个单元同样也很简单：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can combine the process of not only enabling a unit, but also starting
    it at the same time:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将启用一个单元的过程与启动它的过程结合在一起：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `--now` argument tells `systemctl` to start the unit immediately after enabling
    it, rather than waiting for the next boot to do so or having you also run the
    `start` argument in a separate command.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`--now` 参数告诉 `systemctl` 在启用单元后立即启动它，而不是等待下次启动时才执行，或者需要你在单独的命令中运行 `start` 参数。'
- en: Even though `systemd` is primarily used for managing units, it’s actually an
    entire platform that manages multiple things on a Linux system, including DNS
    resolving, networking, and more. `systemd` even handles logging as well, and it
    provides us with the `journalctl` command, which we can use to view logging info
    (this is also why the output of `systemctl status ssh` was able to show us log
    entries).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `systemd` 主要用于管理单元，但它实际上是一个管理 Linux 系统多个方面的平台，包括 DNS 解析、网络等。`systemd` 甚至还处理日志记录，并且提供了
    `journalctl` 命令，我们可以使用它来查看日志信息（这也是为什么 `systemctl status ssh` 的输出能够显示日志条目的原因）。
- en: We’ve discussed logging a bit in *Chapter 4*, *Navigating and Essential Commands*,
    and we’ll do so in more detail during *Chapter 22*, *Troubleshooting Ubuntu Servers*
    (which will also include further discussion of the `journalctl` command).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第4章*《导航和基本命令》中已经讨论过一些日志记录内容，接下来在*第22章*《故障排除 Ubuntu 服务器》中，我们将更详细地讨论这方面内容（其中还会包括对
    `journalctl` 命令的进一步讨论）。
- en: For now, just understand that `systemd` is quite extensive when it comes to
    the number of things it helps us manage. For the purposes of this chapter, however,
    if you understand how to start, stop, enable, disable, and check the status of
    a unit, you’re good to go for now.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只需要理解 `systemd` 在管理系统中的各个方面非常广泛。对于本章而言，如果你了解如何启动、停止、启用、禁用并检查单元的状态，那么你现在就可以继续往下进行。
- en: Scheduling tasks with cron
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cron调度任务
- en: 'Earlier in this chapter, we worked through starting processes and enabling
    them to run in the background, and ensuring they start as soon as the server boots.
    In some cases, you may need an application to perform a job at a specific time,
    rather than to have it always running in the background. This is where `cron`
    comes in. With `cron`, you can set a process, program, or script to run at a specific
    time, down to the minute. Each user is able to have their own set of `cron` configurations
    (known as a `crontab`), which can perform any function that a user would be able
    to do normally. The `root` user has a `crontab` as well, which allows system-wide
    administrative tasks to be performed. Each `crontab` includes a list of `cron`
    jobs (one per line), which we’ll get into shortly. To view a `crontab` for a user,
    we can use the `crontab` command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们已经学习了如何启动进程并使其在后台运行，以及确保它们在服务器启动时立即启动。在某些情况下，您可能需要一个应用程序在特定时间执行任务，而不是始终在后台运行。这就是`cron`的用武之地。通过`cron`，您可以设置一个进程、程序或脚本在特定时间运行，甚至到分钟级别。每个用户可以拥有自己的`cron`配置（称为`crontab`），可以执行任何用户通常可以执行的功能。`root`用户也有一个`crontab`，允许执行系统范围的管理任务。每个`crontab`包含一个`cron`任务列表（每行一个），我们马上就会介绍。要查看用户的`crontab`，我们可以使用`crontab`命令：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With the `-l` option, the `crontab` command will show you a list of jobs for
    the user who executed the command. If you execute it as `root`, you’ll see the
    root account’s `crontab`. If you execute it as user `jdoe`, you’ll see the `crontab`
    for `jdoe`, and so on. If you want to view a `crontab` for a user other than yourself,
    you can use the `-u` option and specify a user, but you’ll need to execute it
    as `root` or with `sudo` to view the `crontab` for someone other than the user
    you’re logged in as:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-l`选项，`crontab`命令将显示执行命令的用户的作业列表。如果以`root`身份执行它，您将看到`root`帐户的`crontab`。如果以用户`jdoe`身份执行它，您将看到`jdoe`的`crontab`，依此类推。如果您想查看除您自己以外的用户的`crontab`，您可以使用`-u`选项并指定一个用户，但需要以`root`或`sudo`权限执行才能查看其他用户的`crontab`：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'By default, no user has a `crontab` until you create one or more jobs. Therefore,
    you’ll probably see output such as the following when you check for your current
    users:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，没有用户具有`crontab`，直到您创建一个或多个任务。因此，当您检查当前用户时，您可能会看到类似以下的输出：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To create a `cron` job, first log in as the user account you want the task
    to run under. Then, issue the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`cron`任务，请首先登录为您希望该任务在其下运行的用户帐户。然后，发出以下命令：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you have more than one text editor on your system, you may see output similar
    to the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统上有多个文本编辑器，您可能会看到类似以下的输出：
- en: '![](img/B18425_07_10.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_07_10.png)'
- en: 'Figure 7.10: Selecting an editor for use with the crontab command'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：选择与`crontab`命令一起使用的编辑器
- en: 'In this case, you’ll simply press the number corresponding to the text editor
    you’d like to use when creating your `cron` job. To set an environment variable
    that specifies a specific editor and edit your `crontab` with a single command,
    the following command will do exactly that:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当您创建您的`cron`任务时，您只需按下对应于您想使用的文本编辑器的数字。要设置一个指定编辑器的环境变量，并用单个命令编辑您的`crontab`，以下命令将准确完成此操作：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In this example, you can replace `vim` with whatever text editor you prefer.
    At this point, you should be placed in a text editor with your `crontab` file
    open. The default `crontab` file for each user features some helpful comments
    that give you some useful information regarding how `cron` works. To add a new
    job, you would scroll to the bottom of the file (after all the comments) and insert
    a new line. Formatting is very particular here, and the example comments in the
    file give you some clue as to how each line is laid out. Specifically, this part:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您可以用您喜欢的文本编辑器替换`vim`。此时，您应该进入一个文本编辑器，并打开您的`crontab`文件。每个用户的默认`crontab`文件都包含一些有用的注释，这些注释提供了关于`cron`如何工作的一些有用信息。要添加一个新的任务，您需要滚动到文件的底部（在所有注释之后）并插入一行。格式在这里非常重要，文件中的示例注释会给出每行布局的一些线索。特别是这部分：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Each `cron` job has six fields, each separated by at least one space or tab
    spaces. If you use more than one space, or tab, `cron` is smart enough to parse
    the file properly. In the first field, we have the minute in which we would like
    the job to occur. In the second field, we place the hour in the 24-hour format,
    from 0-23\. The third field represents the day of the month. In this field, you
    can place a 5 (5th of the month), 23 (23rd of the month), and so on. The fourth
    field corresponds to the month, such as 3 for March or 12 for December. The fifth
    field is the day of the week, numbered from 0 to 6 to represent Sunday through
    Saturday. Finally, in the last field, we have the command to be executed. A few
    example `crontab` lines are as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`cron`任务有六个字段，每个字段之间至少由一个空格或制表符分隔。如果你使用多个空格或制表符，`cron`足够智能，能够正确解析文件。在第一个字段中，我们设置任务执行的分钟数。在第二个字段中，我们设置24小时制的小时数，范围从0到23。第三个字段表示月份中的天数。在该字段中，你可以填写5（5号）、23（23号）等。第四个字段对应于月份，比如3代表3月，12代表12月。第五个字段是星期几，数字从0到6，分别表示星期日到星期六。最后一个字段是要执行的命令。以下是几个`crontab`行的示例：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With the first example, the `cleanup.sh` script, located in `/usr/local/bin`,
    will be run at 12:03 a.m. every Thursday. We know this because the minute column
    is set to `3`, the hour column is set to `0` (midnight), the day column is `4`
    (Thursday), and the command column shows a fully qualified command of `/usr/local/bin/cleanup.sh`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，位于`/usr/local/bin`的`cleanup.sh`脚本将在每周四凌晨12:03运行。我们知道这一点，因为分钟列设置为`3`，小时列设置为`0`（午夜），日期列为`4`（星期四），而命令列显示了完全限定的命令`/usr/local/bin/cleanup.sh`。
- en: What does it mean for a command to be *fully qualified*? Basically, a command
    being fully qualified means that the entire path to the binary responsible for
    the command is completely typed out. In the second example, we could have simply
    typed `apt update` for the command and that would’ve probably worked just fine.
    However, not including the full path to the program is considered bad `cron` etiquette.
    While the command may have worked without being fully qualified, its success would
    depend on the application being found in the path of the user who is calling it.
    Not all servers are set up the same, so this might not work depending on how the
    shell is set up. If you include the full path, the job should run regardless of
    how the underlying shell is configured.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的*完全限定*是什么意思？基本上，命令完全限定意味着完全写出负责该命令的二进制文件的完整路径。在第二个例子中，我们本可以简单地输入`apt update`命令，并且可能能够正常运行。然而，不包括程序的完整路径被认为是糟糕的`cron`习惯。虽然没有完全限定的命令可能仍然能成功运行，但其成功与否取决于调用该命令的用户路径中是否能找到该应用程序。并非所有服务器都以相同的方式设置，因此根据外壳的设置，可能无法运行。如果包含完整路径，则无论底层外壳如何配置，任务都应能正常运行。
- en: If you don’t know what the fully qualified command is, all you have to do is
    use the `which` command. This command, when used with the name of a command you’d
    like to run, will give you the fully qualified command if the command is located
    on your system.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道完全限定的命令是什么，只需使用`which`命令。这个命令，当与你想要运行的命令名称一起使用时，将返回该命令在系统中的完全限定路径。
- en: Continuing with the second example, we’re running `/usr/bin/apt update` to update
    our server’s repository index every morning at midnight. The asterisks on each
    line refer to *any*, so with the minute column being simply `*`, that means that
    this task is eligible for any minute. Basically, the only field we clarified was
    the hour field, which we set to `0` in order to represent 12:00 a.m.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 继续第二个例子，我们正在运行`/usr/bin/apt update`来每天凌晨12点更新服务器的仓库索引。每一行的星号代表*任何*，因此分钟列为`*`时，意味着此任务可以在任何分钟执行。基本上，我们唯一明确的是小时字段，我们将其设置为`0`，表示凌晨12点。
- en: With the third example, we’re running the `/usr/local/bin/run_report.sh` script
    on the first day of every month at 01:00 a.m. If you notice, we set the third
    column (**day of month**) to `1`, which is the same as February 1st, March 1st,
    and so on. This job will be run if it’s the first day of the month, but only if
    the current time is also 01:00 a.m., since we filled in the first and second columns,
    which represent the minute and hour, respectively.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个例子中，我们在每个月的第一天凌晨01:00运行`/usr/local/bin/run_report.sh`脚本。如果你注意到，我们将第三列（**日**）设置为`1`，这与2月1日、3月1日等相同。这个任务将在每月的第一天执行，但只有在当前时间也是凌晨01:00时才会执行，因为我们填充了第一列和第二列，分别代表分钟和小时。
- en: Once you finish editing a user’s `crontab` and save it, `cron` is updated and,
    from that point forward, will execute the task at the time you select. The `crontab`
    will be executed according to the current time and date on your server, so you
    want to make sure that that is correct as well, otherwise you’ll have your jobs
    execute at unexpected times. You can view the current date and time on your server
    by simply issuing the `date` command.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你编辑并保存了用户的`crontab`，`cron`会被更新，从那时起，它将在你选择的时间执行任务。`crontab`将根据你服务器上的当前时间和日期执行，所以你要确保时间是正确的，否则你的任务会在意外的时间执行。你可以通过简单地运行`date`命令查看你服务器上的当前日期和时间。
- en: To get the hang of creating jobs with `cron`, the best way (as always) is to
    practice. The second example `cron` job is probably a good one to experiment with,
    as updating your repository index isn’t going to hurt anything.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要掌握使用`cron`创建作业，最好的方法（一如既往）是多加练习。第二个示例`cron`作业可能是一个不错的实验对象，因为更新你的仓库索引不会带来任何坏处。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to manage processes. We began with a look at
    the `ps` command, which we can use to view a list of processes that are currently
    running. We also took a look at managing jobs, as well as killing processes that,
    for one reason or another, are misbehaving. We also discussed methods of changing
    the priority of a process, to ensure we have full control over which processes
    are given more processing time, and we also learned how we can schedule things
    to run at a later time and date with `cron`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何管理进程。我们首先查看了`ps`命令，可以用它来查看当前正在运行的进程列表。我们还了解了如何管理作业，以及如何终止一些因某些原因而不正常的进程。我们还讨论了如何改变进程的优先级，以确保我们可以完全控制哪些进程获得更多的处理时间，并且我们还学会了如何使用`cron`安排任务在稍后的时间和日期执行。
- en: In *Chapter 8*, *Monitoring System Resources*, we’ll take a look at some ways
    we can keep an eye on the resources that are available on our server, where we
    will learn how to check disk usage and understand memory usage and swap space,
    as well as a looking at some utilities that can make resource management a breeze.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第8章*，*监控系统资源*中，我们将探讨一些方法，通过它们我们可以关注服务器上可用的资源，在这里我们将学习如何检查磁盘使用情况，理解内存使用情况和交换空间，同时也会看一些可以让资源管理变得轻松的工具。
- en: Relevant videos
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关视频
- en: 'Getting started with tmux (LearnLinuxTV): [https://linux.video/tmux-guide](https://linux.video/tmux-guide)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用tmux（LearnLinuxTV）：[https://linux.video/tmux-guide](https://linux.video/tmux-guide)
- en: 'Backgrounding and foregrounding processes in Linux (LearnLinuxTV): [https://linux.video/bg-fg](https://linux.video/bg-fg)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux中的后台与前台进程管理（LearnLinuxTV）：[https://linux.video/bg-fg](https://linux.video/bg-fg)
- en: Further reading
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Ham Vocke, *A Quick and Easy Guide to tmux*: [https://learnlinux.link/tmux-article](https://learnlinux.link/tmux-article)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ham Vocke, *tmux快速简易指南*：[https://learnlinux.link/tmux-article](https://learnlinux.link/tmux-article)
- en: 'Tmux cheat sheet and quick reference: [https://learnlinux.link/tcs](https://learnlinux.link/tcs)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tmux备忘单和快速参考：[https://learnlinux.link/tcs](https://learnlinux.link/tcs)
- en: 'crontab guru: [https://learnlinux.link/ctg](https://learnlinux.link/ctg)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: crontab大师：[https://learnlinux.link/ctg](https://learnlinux.link/ctg)
- en: Join our community on Discord
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者讨论：
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code50046724-1955875156.png)'
