- en: '*Chapter 11*: Understanding cgroups Version 1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll introduce you to `cgroups`. (More specifically, we'll
    be looking at cgroups Version 1.) You'll learn what cgroups are, how they're constructed,
    and how you can benefit by taking advantage of them. We'll also briefly look at
    the history of cgroups.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I have to tell you that discussing cgroups can become quite complex and
    convoluted. You might have already seen some online cgroups tutorials that do
    nothing but make your head hurt. My goal is to strip away as much complexity as
    possible and provide you with just enough information to help you manage resources
    on a systemd machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specific topics include:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the history of cgroups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the purpose of cgroups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the structure of cgroups Version 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the cgroup Version 1 filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All right – if you're ready, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make things more interesting, we'll use the same Alma virtual machine that
    we set up in [*Chapter 5*](B17491_05_Final_NM_ePub.xhtml#_idTextAnchor063), *Creating
    and Editing Services*. You might remember that on that virtual machine, we set
    up one WordPress container service that's running in system mode, and another
    WordPress container service that running in user mode. If you don't have that
    virtual machine, go back to [*Chapter 5*](B17491_05_Final_NM_ePub.xhtml#_idTextAnchor063),
    *Creating and Editing Services*, and follow the steps for creating the WordPress
    container services. As always, this chapter will be hands-on. So fire up that
    virtual machine, and let's dig in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3ltmKsO](https://bit.ly/3ltmKsO)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the history of cgroups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This might shock you, but the cgroups technology didn't start as a part of systemd,
    and it wasn't invented by Red Hat. It's actually a component in the Linux kernel
    that can run on non-systemd Linux distros. A pair of Google engineers started
    cgroups development back in 2006, four years before Red Hat engineers started
    developing systemd. The first enterprise-grade Linux distro to include cgroups
    technology was *Red Hat Enterprise Linux 6*, which ran a hybrid upstart/SysV setup
    instead of systemd. Using cgroups on RHEL 6 was optional, and you had to jump
    through some hoops to set them up.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, cgroups are enabled by default on all of the major enterprise-type
    Linux distros and are tightly integrated with systemd. RHEL 7 was the first enterprise
    distro to use systemd and was also the first enterprise distro to always have
    cgroups enabled.
  prefs: []
  type: TYPE_NORMAL
- en: There are currently two versions of the cgroups technology. Version 1 works
    well for the most part, but it does have some flaws, which I won't get into here.
    Version 2 was developed in 2013, primarily by an engineer at Facebook. In this
    chapter, I'll confine the discussion to Version 1\. Even though Version 2 might
    be much better, it still hasn't been widely adopted, and many container technologies
    still depend upon Version 1\. The current versions of all enterprise-grade Linux
    distros run with Version 1 by default.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Fedora, Arch, and Debian 11 are the only Linux distros of which I'm aware that
    run cgroups Version 2 by default. I've also seen some speculation that the next
    non-LTS version of Ubuntu, Ubuntu 21.10, is supposed to come with Version 2\.
    (Of course, you'll likely know that for sure by the time you read this.) So, which
    one should you learn about? Well, if you're an administrator working with any
    of the major enterprise-grade Linux distros, you'll want to concentrate on learning
    Version 1\. If you're a developer, you'll probably want to start learning Version
    2, because Version 2 is the future.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered the history of cgroups, I suppose that I should now make
    some history by explaining what they are and why we need them. So, allow me to
    do just that.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the purpose of cgroups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in the days of single-core CPUs, resource management wasn't such a big
    deal. Servers generally came with anywhere from one to four single-core CPUs installed,
    so they were already limited in the number of services that could run simultaneously.
    All we needed for resource management back then were simple tools such as `nice`,
    `renice`, and `ulimit`.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, it's an entirely different story. Servers now come with one or more
    multi-core CPUs and gobs of memory. (The current king-of-the-hill server CPU is
    the AMD Epyc, which now comes in a 64-core variety that can run 128 simultaneous
    threads. Yeah, that's enough to make us hard-core geeks salivate.) Although it
    might seem counter-intuitive, resource management on these beasts is more important
    than it was on the old systems. That's because one server can now run multiple
    services, multiple virtual machines, multiple containers, and multiple user accounts
    all at the same time. A whole roomful of the old physical servers that could only
    run one or two services can now be replaced by just one physical server. Those
    simple resource management tools that we used to use still have their uses, but
    we also now need something a lot more powerful to ensure that all processes and
    users play nice with each other. Enter cgroups.
  prefs: []
  type: TYPE_NORMAL
- en: 'With cgroups, an administrator can:'
  prefs: []
  type: TYPE_NORMAL
- en: Manage resource usage by either processes or users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep track of resource usage by users on multi-tenant systems to provide accurate
    billing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More easily isolate running processes from each other. This not only makes for
    better security but also allows us to have better containerization technologies
    than we had previously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run servers that are densely packed with virtual machines and containers due
    to better resource management and process isolation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhance performance by ensuring that processes always run on the same CPU core
    or set of CPU cores, instead of allowing the Linux kernel to move them around
    to different cores.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whitelist or blacklist hardware devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up network traffic shaping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've seen the purpose of cgroups, my own purpose now is to show you
    the structure of cgroups.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the structure of cgroups Version 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand the structure of cgroups, you''ll need to understand some of
    the cgroups terminology. Let''s start with just a few terms that you need to know:'
  prefs: []
  type: TYPE_NORMAL
- en: '**cgroups**: The term *cgroup* has two different meanings. What concerns us
    most is that a cgroup is a collection of processes. The processes within each
    cgroup are bound to limits and parameters that are defined within the *cgroup
    filesystem*. (We''ll talk more about the cgroup filesystem in a bit.) The term
    *cgroup* can also refer to the Linux kernel code that implements cgroups technology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`httpd.service` or `apache2.service`. (Okay, you already knew this, but I told
    you again anyway.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**scopes**: A scope is a group of processes that are started by some external
    means. Virtual machines, containers, and user sessions are examples of scopes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-.slice`: This is the *root* slice, which is the root of the whole slice hierarchy.
    Normally, it won''t directly contain any other units. However, you can use it
    to create default settings for the entire slice tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system.slice`: By default, system services that have been started by systemd
    would go here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user.slice`: By default, user-mode services would go here. An implicit slice
    is assigned to each logged-in user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`machine-slice`: If you''re running containers or virtual machines, their services
    will show up here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, the system administrator can define custom slices, and assign scopes
    and services to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see a more graphical representation of all this, use the `systemd-cgls`
    command as a normal user. Just for fun, let''s look at the Alma 8 virtual machine
    that we used to create the WordPress containers back in [*Chapter 5*](B17491_05_Final_NM_ePub.xhtml#_idTextAnchor063),
    *Creating and Editing Services*. The output of `systemd-cgls` should look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I don't have a desktop environment installed on this virtual machine, so we
    can't see any of the Gnome stuff that you would see on a machine that does have
    a desktop. However, we do see the user-mode WordPress container service that we
    created in [*Chapter 5*](B17491_05_Final_NM_ePub.xhtml#_idTextAnchor063), *Creating
    and Editing Services*. (If you have Gnome on your virtual machine, that's fine.
    It just means that you'll have to scroll down a bit more to see your WordPress
    container service.)
  prefs: []
  type: TYPE_NORMAL
- en: The `systemd-cgls` tool shows us a hierarchical listing of the cgroups that
    are running on the system. The first one listed is the `/` cgroup, which is how
    the root cgroup is designated. The second line begins the listing for the root
    slice ( `-.slice` ), and directly under it is `user.slice`. Next, we can see `user-1000.slice`,
    which is a child of `user.slice`. In this case, I'm the only user who's logged
    into the system, so this slice belongs to me. The `user-1000.slice` designation
    corresponds to my User ID number, which is `1000`. Following that, we can see
    the services that are running in my slice, which we'll get to in just a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see user slices, you'll need to run the `systemd-cgls` command
    from *outside* of the cgroup filesystem. If you `cd` into the `/sys/fs/cgroup/`
    directory, you won't see the user slices. The further down you go into the cgroup
    filesystem, the less you'll see with `systemd-cgls`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `user.slice` is defined by the `/lib/systemd/system/user.slice` unit file,
    which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that this slice has to finish starting before the `slices.target`
    can start. The `slices.target` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: According to the `systemd.special` man page, `slices.target` is responsible
    for setting up the slices that are to run when you boot up your machine. By default,
    it starts up `system.slice` and the root slice ( `-.slice` ), as we see here in
    the `Wants=` line, and the `After=` line. We can also add more slices to that
    list, as we've just seen in the `user.slice` file. We'll look at `-.slice` and
    `system.slice` in a moment. For now, let's get back to `user.slice`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my `user-1000.slice`, the first listed service is `user@1000.service`. This
    service is responsible for all the other services that run within my slice. It''s
    set up by the `user@.service` template. The `[Unit]` section of the `user@.service`
    file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When this service runs, the `%i` variable will be replaced with a User ID number.
    The `[Service]` section of the file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ExecStart=`: This line causes systemd to start a new systemd session for each
    user who logs in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slice=`: This line creates a separate slice for each user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TasksMax=`: This line is set to infinity, which means that there''s no limit
    to the number of processes that a user can run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Delegate=`: We''ll discuss this directive in [*Chapter 12*](B17491_12_Final_NM_ePub.xhtml#_idTextAnchor164),
    *Controlling Resource Usage with cgroups Version 1*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next thing we see in the output of `systemd-cgls` is that all of the services
    that are running in my user slice are children of the `user@1000.service`. When
    I scroll down, I''ll eventually get past the list of services, and will see the
    *scope* for my login session. In this case, my login session at the local terminal
    is designated as `session-2.scope`, and my remote login session is designated
    as `session-3.scope`. Here''s what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: According to the `systemd.scope` man page, scopes can't be created by creating
    unit files. Instead, they're created programmatically at runtime. So, don't expect
    to see any `.scope` files in the `/lib/systemd/system/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further down in the `systemd-cgls` output, we finally get past my user slice.
    The next thing we can see after my user slice is the `init.scope` and the `system.slice`,
    as we see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see system services that have nothing to do with my user session.
    One service that we see here is the WordPress container service that's running
    in system mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that I have a system-mode container service running means that there''s
    something in `machine.slice`, as we see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `libpod` branch of this `machine.slice` tree represents our `podman-docker`
    container. (Note that the user-mode container service only shows up directly under
    the user slice, and doesn't show up here under the machine slice.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s shift back to an Alma machine that''s running with the Gnome desktop.
    As we see here, there''s a lot more going on with the output of `systemd-cgls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: On any desktop machine, you'll always have a lot more running services than
    you'd have on a strictly text-mode machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new user account for Frank. Then, have Frank log in to this
    machine via a remote SSH session. The top part of the output of `systemd-cgls`
    now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Frank now has his own user slice, which is `user-1001.slice`. We see that he's
    logged in remotely, as well as the name of the virtual terminal that he used to
    log in. (In case you're wondering, *Frank* is the name of my formerly feral Flame
    Point Siamese kitty, who has been with me for many years. Until just a moment
    ago, he was sleeping on the computer table where my keyboard should be, which
    was making it quite awkward for me to type.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t want to see the entire cgroups tree, you can use `systemctl status`
    to see just one part of it. For example, to just see the `user.slice`, I''d do
    `systemctl status user.slice`. The output would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_11.1_B17491.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – user.slice on Alma Linux with the Gnome desktop
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we see that Frank has logged out and that I''m now the only user who
    is logged in. (After all, Frank is a cat, which means that he spends most of his
    time sleeping.) We can also view information about the other slices, as well as
    about scopes. For example, doing `systemctl status session-3.scope` shows me information
    about the session scope that''s running under my user slice, which would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_11.2_B17491.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Session scope on Alma Linux
  prefs: []
  type: TYPE_NORMAL
- en: All right, that pretty much covers it for the basic structure of cgroups. Now,
    let's move on and look at the cgroup filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the cgroup filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On any system that runs cgroups, you''ll see a `cgroup` directory under the
    `/sys/fs/` virtual filesystem, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As with all virtual filesystems, the cgroup filesystem only exists in memory
    at runtime and disappears when you shut down the machine. There's no permanent
    copy of it on the machine's drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you look inside the `/sys/fs/cgroup/` directory, you''ll see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_11.3_B17491.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – cgroupfs on Alma Linux
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these directories represents a cgroup *susbsystem*. (You''ll also see
    them referred to as either *controllers* or *resource controllers*.) Inside each
    of these directories is a set of files that represent the cgroup''s *tunables*.
    These files hold information about any resource control or tuning parameters that
    you would set. (We''ll talk more about that in [*Chapter 12*](B17491_12_Final_NM_ePub.xhtml#_idTextAnchor164),
    *Controlling Resource Usage with cgroups Version 1*.) For example, here''s what
    we have in the `blkio` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_11.4_B17491.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – The blkio filesystem
  prefs: []
  type: TYPE_NORMAL
- en: Each of these files represents a parameter that can be custom-tuned for the
    best performance. Toward the bottom, we also see directories for `init.scope`,
    `machine.slice`, `system.slice`, and `user.slice`. Each also has its own set of
    tunable parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the `mount` command and pipe it through `grep`, we''ll see that
    each of these resource controllers is mounted on its own virtual partition. Here''s
    what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Okay, I think that that should do it for our basic introduction to cgroups Version
    1\. So, let's wrap up this chapter and move on!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the history of the cgroups technology, what cgroups
    are, and why we need them. We then looked at the structure of cgroups and the
    cgroup filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: A major challenge that comes with learning about cgroup technology is that there
    isn't much available documentation about it. I mean, you'll see a lot of blog
    posts and YouTube videos about it, but much of it either isn't very comprehensive
    or is woefully out of date. Hopefully, I've been able to give you a better understanding
    of cgroup technology and how it works together with systemd.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at controlling resource usage with cgroups Version
    1\. I'll see you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the default location of the cgroup filesystem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `/proc/fs/cgroup/`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. `/sys/cgroup/`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. `/sys/fs/cgroup/`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. `/proc/cgroup/`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What must you do to see user slices with `systemd-cgls`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Run the command only from the local terminal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Run the command only from outside the cgroup filesystem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Run the command with root privileges.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. You can't. User slices never show up.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How can you create your own cgroup scope?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Use `systemctl edit --full --force`, just as you would with other systemd
    units.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Manually create a unit file in the `/etc/systemd/system/` directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. You can't. Scopes are created programmatically, and there are no `.scope`
    unit files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Manually create a unit file in the `/lib/systemd/system/` directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What does a slice do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. It directly manages user mode processes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. It directly manages system mode processes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. It manages processes that are in either scopes or services.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. It manages user login sessions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following links for more information about cgroups:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Linux sysadmin''s introduction to cgroups:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.redhat.com/sysadmin/cgroups-part-one](https://www.redhat.com/sysadmin/cgroups-part-one)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'cgroups documentation at kernel.org:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt](https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
