- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s All Go to the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve come a long way when it comes to virtualization. From segmenting virtual
    slices and striping (precursor to virtualization) DNA sequencers across hundreds
    of university campuses to the most sophisticated virtual farms capable of hosting
    thousands of **virtual machines** (**VMs**) and petabytes of storage, they all
    have one thing in common: complexity. But does it really have to be complex? When
    I think about virtualization, I think of four resources: compute, memory, storage,
    and network. They all intertwine with one another to create that fabric. Without
    compute or memory, you can’t host a workload. Without storage, you can’t host
    or store application or workload components, and without a network, your workload
    can’t go anywhere. Imagine your car is your workload, the highway is your network,
    the passengers are your compute and memory, and the trunk is storage.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will run through how to find, maximize, and use Oracle Linux
    to its full potential in a local environment as well as a public cloud, such as
    **Oracle Cloud Infrastructure** (**OCI**) or **Amazon Web Services** (**AWS**).
    We’ll run through exercises in building out a custom local Oracle Linux 8.x environment
    and walk through the process of moving that VM to OCI as an image, as well as
    to other **cloud service providers** (**CSPs**) including AWS as an AMI. *Cloud
    native* is a huge buzzword and a disruptive technology. The *Making Docker Desktop
    more manageable with Portainer* recipe will walk through creating a Portainer
    environment that can manage your container ecosystem around one application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Linux in the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making Docker Desktop more manageable with Portainer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using VirtualBox to springboard VMs to OCI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For everyone else, let’s make custom images for AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generally, and in this case, it’s easier to build the OS being used with a
    **graphical user interface** (**GUI**). With this being said, you can still install
    a GUI if you didn’t build the server with a GUI originally. The following is a
    list of steps detailing how to add and configure a GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the GUI packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the GUI as the default target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the GUI as the default startup source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Oracle Linux in the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could list all the CSPs here and break apart their pros and cons, but ultimately,
    every CSP has a main competency. What Oracle Linux does is add to that competency,
    making the product stronger and more versatile. Much like any other (open source)
    Linux distribution, Oracle Linux is a versatile and powerful OS. In the case of
    Oracle Linux, the OS was designed with elements that are compatible with RHEL,
    not to compete, but to add functionality as well as a portal into Oracle functionality
    beyond RHEL.
  prefs: []
  type: TYPE_NORMAL
- en: The fluidity of Oracle Linux, much like RHEL, allows it to go beyond just being
    an OS. Oracle Linux extends the playing field, maximizing the Linux toolsets surrounding
    virtualization into VM management through **Oracle Linux Virtualization Manager**
    (**OLVM**), cross-functionality into cloud platforms, and automation, just to
    name a few. What Oracle aims to do is to offer the functionality of an RHEL OS
    but go beyond that and tie that OS into a global business network of toolsets
    to drive business success. Now, after all the fluff comes the real power and versatility
    of Oracle Linux, some of which was mentioned at the beginning of this chapter.
    This recipe is about which CSPs are most compatible with Oracle Linux; however,
    understanding what and how the OS operates is integral to understanding which
    CSPs are more compatible with Oracle Linux and thus maximizing its capability.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle supports and promotes open source technologies for business-critical
    environments. Oracle is a founding member of the Linux Foundation, Eclipse Foundation,
    and Java Community Process, and contributes significantly to open source projects.
    Oracle software combined with open source technologies offers high performance,
    reliability, and data security while reducing computing costs.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram provides a cost-benefit analysis of Oracle Linux “Free”
    (the only paid component is support) versus RHEL with the extended features added
    on, as mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – RHEL versus Oracle Linux](img/B18349_13_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – RHEL versus Oracle Linux
  prefs: []
  type: TYPE_NORMAL
- en: As with any Linux distribution, each CSP has its own flavor or choice of Linux
    platform. For instance, AWS has **Amazon Linux 2** (**AL2**), Azure offers compatibility
    with anything RHEL or Ubuntu based, and Oracle has Oracle Linux, of course. There
    are so many differences between Ubuntu and Oracle Linux, AL2, and so on, but we’re
    not here to discuss the differences. Ultimately, all CSPs can run Linux distributions,
    but not all are optimized for Oracle Linux. With AWS and Azure, you have the option
    of **Buying Your Own Support** (**BYOS**) from Oracle (support includes access
    to patching, upgrades, and OS support) or using these services for free without
    tech support. With OCI Premier, support is included for free. The following diagram
    shows the main CSPs and their differing adoptions of Oracle Linux.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Cloud options](img/B18349_13_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Cloud options
  prefs: []
  type: TYPE_NORMAL
- en: Who’s the fairest of them all? Let’s walk through what Linux distributions are
    offered within AWS. We’ll briefly touch on AWS EC2 Image Builder to visualize
    the versatility of Linux within any environment on AWS and beyond. This will come
    into use later in this chapter, in the *Using VirtualBox to springboard VMs to*
    *OCI* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll first have to have an AWS account, be it personal or through your organization;
    it doesn’t really matter so long as you have the correct authorization to access
    the account and build out the infrastructure. In this case, I selected **Root
    user**, as this is my personal account, and I have those rights.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Root sign-in](img/B18349_13_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Root sign-in
  prefs: []
  type: TYPE_NORMAL
- en: After entering your user type, you’ll want to provide your password and continue
    through the authentication options. I’ve enabled **Multi-Factor Authentication**
    (**MFA**) and would strongly suggest using this method to protect your account.
    If MFA is enabled, you next walk through capturing that code, as shown in the
    following figure. Note that there are other two-factor authentication options,
    but using Google Authenticator is best practice. However, one could use any app,
    such as Microsoft, RSA, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – MFA](img/B18349_13_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – MFA
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’re past the login and MFA sections, you’ll find yourself on the AWS
    landing page. You’ll want to navigate to EC2, AWS Compute Resources in AWS speech
    (CPU, RAM), to understand the flavors of Linux available and what your options
    are beyond the default choices that come as standard Linux images (AMIs). Note
    that just because a flavor isn’t listed doesn’t mean it isn’t available: there
    are other options through the Marketplace or via custom images.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Compute](img/B18349_13_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Compute
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve entered the world of AWS EC2, the easiest way to see what’s on
    offer is **EC2 Image Builder**. Image Builder translates the complex image world
    into easier-to-understand concepts that help transcribe your technical requirements
    into executions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Image Builder](img/B18349_13_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Image Builder
  prefs: []
  type: TYPE_NORMAL
- en: After entering **Image Builder**, you’ll want to navigate to **Image products**,
    under **Amazon Marketplace**. This is the portal to everything else offered under
    the AWS umbrella and will take you directly to the image products.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Image products](img/B18349_13_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – Image products
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when selecting Oracle AMIs. There are third parties that will charge
    you to use AMIs but will not provide Oracle tech support. Some of them can get
    very expensive, costing you hundreds of dollars per year.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the preceding note, you will not find official Oracle Linux
    images on the **AWS Marketplace** tab. Follow the instructions in this recipe
    in the *How to do it…* section to access the official Oracle Linux images.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Search in Marketplace for Oracle Linux](img/B18349_13_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – Search in Marketplace for Oracle Linux
  prefs: []
  type: TYPE_NORMAL
- en: If you search for `oracle linux` on AWS Marketplace as in the preceding screenshot,
    you will only see offerings of Oracle Linux distributions built by other organizations
    and offered to the public through AWS Marketplace. *These are not official Oracle
    Linux images.* Later in this chapter, we’ll walk through building a VM in Oracle
    VirtualBox and converting that image, through AWS, into an AMI.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps you need to follow to find Oracle AMIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Point your browser to [https://console.aws.amazon.com/ec2/](https://console.aws.amazon.com/ec2/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.9 – Find AMIs under the Images dropdown](img/B18349_13_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – Find AMIs under the Images dropdown
  prefs: []
  type: TYPE_NORMAL
- en: 'In the left navigation panel, select **AMIs**, then **Public images** from
    the window that appears:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Public images](img/B18349_13_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.10 – Public images
  prefs: []
  type: TYPE_NORMAL
- en: 'Filter by owner using the ID `131827586825`. The ID is related to official
    Oracle images, and will only show official Oracle Linux AMIs created by Oracle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.11 – Oracle AMIs](img/B18349_13_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.11 – Oracle AMIs
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the official Oracle AMI you wish to use. After choosing the AMI, simply
    launch the AMI to continue the configuration of resources and the OS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.12 – Instance launch](img/B18349_13_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.12 – Instance launch
  prefs: []
  type: TYPE_NORMAL
- en: After launching, this will bring you to the OS image and VM buildout page (see
    the following figure). Here, you add a suitable name for your VM and choose the
    OS and network keypair for your VM, as shown in the following instance launch
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.13 – Instance configuration](img/B18349_13_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.13 – Instance configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve launched your new VM from the chosen AMI, you’ll see the launch
    status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.14 – Launch status](img/B18349_13_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.14 – Launch status
  prefs: []
  type: TYPE_NORMAL
- en: Once your new Oracle Linux VM is created, you can visualize that VM on the **Compute**
    | **EC2** | **Images** tab in OCI. Then, click on the instance ID and copy the
    public IP address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.15 – Public IP](img/B18349_13_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.15 – Public IP
  prefs: []
  type: TYPE_NORMAL
- en: 'Open either PuTTY or a terminal, depending on whether you’re on a Windows machine
    or a Mac, and `ssh` to your machine using OPC as the user (this is the default
    Oracle user; these terms are changeable, but we won’t go into this here). The
    first time, running the `ssh` command will add the key pair permanently for authentication
    to the list of known hosts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Making Docker Desktop more manageable with Portainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Portainer is a container management platform, as mentioned in the introduction
    to this chapter. Portainer was originally designed as a UI for Docker, but now
    it supports several other container environments as well. With over 1 million
    users and a significant presence on GitHub, Portainer offers two versions: the
    free and open source **Community Edition** (**CE**) and a paid **Enterprise Edition**
    (**EE**). In this recipe, we will be working with the free and open source version.'
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer managing your containers through a GUI, Portainer is an excellent
    option. While CLI commands and API endpoints are great for development, a GUI
    is often more user-friendly for managing production applications. With Portainer,
    you can easily monitor multiple endpoints and grant team members access to a shared
    deployment environment. The following figure shows how Portainer and the container
    images align with Docker, and how Portainer makes managing images simpler. Portainer
    offers a UI over the Docker CLI, making it easier for the layman and seasoned
    engineer alike to navigate container management.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.16 – Portainer container mana\uFEFF\uFEFFgement](img/B18349_13_016.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.16 – Portainer container management
  prefs: []
  type: TYPE_NORMAL
- en: 'Portainer is usually deployed within its own container. If you are using Docker,
    this guide will help you get Portainer up and running. However, if you prefer
    to use Kubernetes, you can also run Portainer directly using the official Helm
    chart. Here’s a brief overview of the steps you need to take to set up Portainer:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Docker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and configure a container for Portainer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the necessary ports and configure OCI accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in to the Portainer interface and set up the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following sections will provide a detailed explanation of each step. Before
    proceeding, make sure you have installed Docker. If you’re using a Windows or
    Mac computer, you can download and install the latest version of the Docker Desktop
    installer. Linux users can experiment with the beta version of Docker Desktop
    for Linux or use the following instructions to install Docker Engine. For this
    guide, we’ll be creating an Oracle Linux VM in the OCI cloud and installing Portainer
    on that VM, rather than in a local environment.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s some initial work to carry out. As mentioned previously, Docker is a
    container management environment. Portainer, in this recipe, will reside in a
    Docker container, so we will need to install and configure Docker. You’ll reuse
    some of these skills again later on in this chapter when it comes to creating
    images. Indeed, this foundational work we’re doing here will help you throughout
    this chapter, as these skills lay the groundwork for managing Oracle Linux environments,
    whether they’re in the cloud or on-premises.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.17 – Portainer VM creation](img/B18349_13_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.17 – Portainer VM creation
  prefs: []
  type: TYPE_NORMAL
- en: The information required to log in to the Portainer VM is located in the image
    data, as shown previously. Remember, just like in the previous chapters related
    to creating VMs in OCI, to create and add the public key. As we saw previously,
    this is the only way you’ll be able to log in to this environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to the VM as shown, using the default OPC user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After logging in, you’ll want to update the repositories. To do this, as in
    the other recipes in this cookbook, you’ll need superuser privileges. The following
    output from the update was truncated for length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After updating the repositories, we’re ready to start installing Docker and
    begin our container journey. In order to install Docker, we’ll need to install
    the ZIP utilities to unzip the required files that we have downloaded. To do this,
    we’ll use the `dnf` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing the ZIP utilities, we’ll have to enable the Docker repository
    in order to download Docker. The following is the command to enable the repo and
    add it to the repo list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to eliminate a vulnerability that allows attackers to overwrite the
    host `runc` binary by executing a root command with any type of container. Attackers
    can exploit this vulnerability to use a new container with an attacker-controlled
    image or infiltrate an existing container if they have previous write access:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[root@portainer2 ~]# dnf remove -****y runc**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Docker using the following `dnf` command. The following output has
    been truncated for length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Docker is installed, we can move on to enabling the Docker service and
    starting Docker Engine. In order to enable the Docker service, we need to use
    `systemctl`, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the service is enabled, we can move to start the Docker service/Docker
    Engine. We’ll once again be using `systemctl` to call Docker Engine to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After starting the service, we’ll want to ascertain the status of the service
    to be assured that Docker has started properly and the service is running and
    healthy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our Docker Engine is up and running, we want to see what Docker version
    is running, as well as its health and all other Docker Engine-related data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Portainer requires a later Python environment, we’ll want to be sure
    that the correct version is installed. Python is a prerequisite to the installation.
    The following command output has been truncated for length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To install Python, we use PIP, which is the standard package manager for Python.
    PIP allows you to manage and install all packages that aren’t typically part of
    the standard Python library. Installing Python is an underlying requirement for
    the Portainer installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll want to exit out of root to install this version of Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You’ll want to be root again here to install and update yum packages. Yum requires
    root privileges to execute, so you’ll want to `sudo` or `su` to root.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we’ve updated the Python installation, we need to install and update
    the Python library requirements for Docker and Portainer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll want to exit out of root here to install `docker-compose`, using Python
    pip to execute. Python pip is the standard for installing any Python package and
    is the go-to method for installing those packages in a secure manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’re ready to start installing and configuring our Portainer environment.
    We’ll have to first create a volume for Portainer. We do this by telling Docker
    to create that volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After creating the volume, we install the Portainer container and expose the
    port that the Portainer UI will use, and through which we will access that UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 13.18 – Docker containers running](img/B18349_13_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.18 – Docker containers running
  prefs: []
  type: TYPE_NORMAL
- en: Once Portainer is installed, and `docker ps` shows Portainer is up and running,
    we’ll have to make sure OCI is configured to allow port `9000` to be visible.
    In order to expose this port, we’ll have to inform OCI of the **Virtual Cloud
    Network** (**VCN**) we’re working in to allow that port to open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.19 – Security list navigation](img/B18349_13_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.19 – Security list navigation
  prefs: []
  type: TYPE_NORMAL
- en: After we have navigated to the relevant security list, we’ll want to create
    a rule like that shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.20 – VCN security list rule creation](img/B18349_13_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.20 – VCN security list rule creation
  prefs: []
  type: TYPE_NORMAL
- en: Once the rule is created, we can see the port exposed outside of OCI.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.21 – Security list rule](img/B18349_13_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.21 – Security list rule
  prefs: []
  type: TYPE_NORMAL
- en: We’re able to open a browser and access the Portainer UI. In order to reach
    the UI, we need two items, the VM’s public IP and the port. The following screenshot
    shows the port, `9000`, and the IP is the same IP we used to access the VM when
    we used `ssh` to log in to the VM.
  prefs: []
  type: TYPE_NORMAL
- en: You can also find the IP on the OCI console. Navigate to your VM from the **Compute**
    menu, then go to **Instance**, which will take you to all your created VMs in
    the OCI console menu. Then, copy the IP address of the VM, as shown in the following
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.22 – IP of the VM](img/B18349_13_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.22 – IP of the VM
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the address, open your browser and enter that information in the
    form of `https://<IP>:9000`. In our case, this is `https://132.226.58.24:9000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note: You may have to refresh the Portainer environment if you get a stale
    page like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.23 – Portainer landing page](img/B18349_13_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.23 – Portainer landing page
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to refresh, you’ll need to restart the Portainer environment by running
    the `docker` `restart` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After you’ve restarted Portainer, you can go back to the browser and refresh
    the page. You should be able to hit the Portainer welcome page now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.24 – Portainer initial configuration](img/B18349_13_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.24 – Portainer initial configuration
  prefs: []
  type: TYPE_NORMAL
- en: Portainer will make you set a 12-digit alphanumeric password for the environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.25 – Portainer password creation](img/B18349_13_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.25 – Portainer password creation
  prefs: []
  type: TYPE_NORMAL
- en: You now have a working Portainer environment running inside a container in Docker,
    hosted by a VM in OCI.
  prefs: []
  type: TYPE_NORMAL
- en: Using VirtualBox to springboard VMs to OCI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working 9 to 5 with workloads?
  prefs: []
  type: TYPE_NORMAL
- en: One common factor in a number of these recipes is moving workloads from one
    environment to another. Working between different hypervisor types (e.g., VMware,
    KVM, and Xen) is done using common formats, such as the **Open Virtualization
    Format**/**Open Virtualization Appliance** (**OVF**/**OVA**). Essentially, this
    puts components into a centrally understandable format that most virtualization
    host environments can understand. Images are transferable and interchangeable
    between virtualization formats. In this case, there are a few more puzzle pieces
    that need to be in place, such as network, storage, and a limitation on the number
    of attached drives.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a world where any workload (be it application- or database-based) can
    stay with you throughout the project life cycle, and be transferable between different
    virtualization farms, or CSPs. You can carry these created environments with you
    throughout your environments.
  prefs: []
  type: TYPE_NORMAL
- en: VirtualBox resides on your system as a host and is classified as a “type 2”
    hypervisor, allowing you to host multiple guest machines on your host environment.
    Your host environment, VirtualBox, has every aspect of a virtual farm that one
    would expect from a larger enterprise product, just broken down into much smaller
    and simpler parts. The compute and memory aspects are carved out from your host
    environment (your computer). The storage components are comprised of parts of
    your local hard drive, or external storage environments such as an externally
    attached NVMe drives. Lastly, the network is made up of bridge components, which
    are virtual networks that sit above your physical interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: What comes first, the VM or the OS?
  prefs: []
  type: TYPE_NORMAL
- en: Every evolution begins with a foundation. Before we can even consider migrating
    a VM from VirtualBox to OCI, we must prepare that VM for migration. In the case
    of VirtualBox, there are just a couple of prework items to complete before you
    build a VM to migrate to a cloud environment, such as OCI. We’ll walk through
    these prerequisites throughout this recipe. The following diagram describes the
    stages of configuring, installing, and migrating a VM to a CSP.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.26 – VM configuration stages](img/B18349_13_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.26 – VM configuration stages
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Preparing the OS isn’t any different from setting the foundation before building
    a house. I find it easier to initially configure the OS on the VirtualBox user
    interface configuration, then `ssh` after you bring up networking and have established
    communication, meaning you have connectivity into the virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five stages in preparing a VM image to be imported into OCI as an
    image. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interface names**: This involves standardization to ensure interface names
    are recognized by the host environment. This is translatable to how the host system
    implements networking.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Interface configuration**: Here, we confirm there are no MAC addresses shown,
    among other pre-configuration tasks. Duplicate MAC addresses lead to extra complexity,
    making this a key point in configuration.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**GRUB(2) configuration**: This involves preparing the kernel.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Serial console configuration**: This step is pretty much the number-one error
    on import and use. Without it, your OCI environment will fail on import, or the
    VM will not boot.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Rebooting the OS**; that is, restarting your machine.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram walks through the configuration stages of the OS from
    boot to reboot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.27 – OS configuration stages](img/B18349_13_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.27 – OS configuration stages
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the interface names after the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll need to execute the change on the kernel with the changes shown in the
    following code block, renaming the interface to match. This will require GRUB(2),
    as GRUB is the middleman between the kernel and the OS. We have the current interface
    names now, so where do we go from here? What we’re doing here is renaming the
    interfaces to reflect a more acceptable name, such as `net0` or `Eth0`. So, we
    have to move (`mv`) or rename the interface filenames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After we rename the interfaces, we need to change the entries in the configuration
    files themselves to match the filename. In the following code, we’re renaming
    the configuration of `net0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re doing the same thing here as previously, but in this case, we’re changing
    `net1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we’re using `ip a` to identify the interfaces
    and make sure our changes have taken effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'What does GRUB configuration do? It alters the way the OS boots and loads kernels.
    For example, let’s look at what changing the serial connection details accomplishes.
    (We’re getting a little off-subject here; however, it’s important to understand
    how OCI works in worse-case scenarios.) Imagine you can’t reach your server; the
    network is down, but the server is green and up. You can use a serial connection
    as a back door. The following `console` edit instructs the OS to allow an out-of-band
    connection to the VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command reloads GRUB. As we can’t edit GRUB directly, we edit
    it through a configuration file, and use this to execute edits on GRUB. This tells
    the OS that we’re ready to reload and have entered new data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we edited GRUB and made a couple of other OS changes, it’s good to get
    a fresh start with things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Going through these configuration changes can be confusing. When it comes down
    to it, we’re narrowing the differences between OCI-born instances and the instance
    we’re configuring in this recipe. The GRUB changes are getting the environment
    ready to operate within the OCI tenancy.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few more steps you’ll have to configure on your host machine for
    connectivity between VirtualBox and OCI. The way VirtualBox communicates with
    OCI is through an **Application Programming Interface** (**API**). This connectivity
    requires public and private API keys to be created, and that public key to be
    uploaded to OCI.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several steps in the authentication between VirtualBox and OCI. The
    following are the components, and their OCID/outputs are what will be needed for
    connectivity to OCI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OCI account:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tenancy
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Compartment
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: VCN
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage bucket
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: API keys
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VirtualBox – make sure to create and capture the required keys, as shown after
    this list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API keys
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Host OS (your computer) – make sure to create and capture the required keys,
    as detailed after this list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API keys
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Private and public keys are the gateway components to sharing information from
    one environment with another. A public key can be shared and is used as an encryption
    method to keep a packet. The private key is kept local, is not shared beyond that
    user, and is used to decrypt the packet. When placed together, the private and
    public keys create a lockbox, keeping the packets flowing between two systems
    secret while in transit. `openssl` is used to generate the keys, both public and
    private.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.28 – OpenSSL key creation](img/B18349_13_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.28 – OpenSSL key creation
  prefs: []
  type: TYPE_NORMAL
- en: After creating the preceding key, you need to change the permissions so the
    key can be used only by you. We’ll use `chmod` to configure those permissions
    and allow the key to be used by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.29 – OpenSSL key permissions](img/B18349_13_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.29 – OpenSSL key permissions
  prefs: []
  type: TYPE_NORMAL
- en: After creating the private key, we need to create the public key. This is the
    key you’ll be uploading to OCI so VirtualBox and OCI can communicate with one
    another. We use the private key to create a public key so the two environments
    can communicate with one another.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.30 – Public key creation](img/B18349_13_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.30 – Public key creation
  prefs: []
  type: TYPE_NORMAL
- en: The next steps are to collect the required data from your OCI cloud account
    to enter the VirtualBox configuration. The information entered will help VirtualBox
    integrate, through the OCI API, your OCI tenancy and compartments through your
    VCN. Imagine this as building a highway between VirtualBox and OCI. The keys,
    both public and private, are the keys to the kingdom, allowing packets to traverse
    that highway.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps walk through uploading the key and configuring VirtualBox
    to communicate with OCI:'
  prefs: []
  type: TYPE_NORMAL
- en: First, just as with any other CSP, we need to log in to our account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.31 – Log in to your account](img/B18349_13_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.31 – Log in to your account
  prefs: []
  type: TYPE_NORMAL
- en: And this is where we wait for OCI to log us in…
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.32 – Logging in](img/B18349_13_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.32 – Logging in
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve logged in to your account, you’re ready to log in to the tenancy
    itself. This is where the action begins, and you’ll start to see your efforts
    pay off. We start by identifying our tenancy and continue from there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.33 – Choose and log in to verify your identity provider](img/B18349_13_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.33 – Choose and log in to verify your identity provider
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re logged in and inside the tenancy, most of the data needed will be
    in the user settings and is linked to the public key upload. The keys themselves
    generate a fingerprint, which is the pathway between OCI and VirtualBox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll see your user icon on the right-hand side of the OCI portal. This will
    take you into the area with all your account, tenancy, and personal data. This
    is also where you’ll configure your key access.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.34 – OCI profile](img/B18349_13_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.34 – OCI profile
  prefs: []
  type: TYPE_NORMAL
- en: Once you expand that menu, you’ll see **User settings**. This is the access
    point for all your user access to OCI.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.35 – User settings](img/B18349_13_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.35 – User settings
  prefs: []
  type: TYPE_NORMAL
- en: The **API Keys** section will allow you to enter key values for access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.36 – Administrators’ privileges and API keys](img/B18349_13_036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.36 – Administrators’ privileges and API keys
  prefs: []
  type: TYPE_NORMAL
- en: In the following screenshot, you can see all the keys currently uploaded to
    OCI, reflecting your specific user. If you click **Add API Key**, this will bring
    up the options for adding a key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.37 – API keys](img/B18349_13_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.37 – API keys
  prefs: []
  type: TYPE_NORMAL
- en: Select **Choose Public Key File** and then select the file from your local environment.
    Remember we created a public key in the last section. We’re going to select that
    public key here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.38 – Public key](img/B18349_13_038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.38 – Public key
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve chosen the key and it’s uploaded to OCI, you’ll see that key on
    screen. Click **Add**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.39 – Added key committed](img/B18349_13_039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.39 – Added key committed
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve got past the key imports, we’ve arrived at a point where we can
    start to configure access. A configuration screen will appear after you’ve officially
    added the key. This configuration file is all that you need, aside from a compartment
    OCID, which we’ll talk about later, to configure the VirtualBox/OCI interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.40 – Configuration displayed](img/B18349_13_040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.40 – Configuration displayed
  prefs: []
  type: TYPE_NORMAL
- en: Copy the information under **Configuration File Preview**. You’ll need it to
    configure VirtualBox to communicate with OCI.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re heading back to VirtualBox now. Near the thumbtack icon will be a menu
    bar. This menu is the heart of VirtualBox and allows you to alter everything from
    vdisks, as shown in the following screenshot, to network configurations and, of
    course, settings relating to the cloud. Expand the **Cloud** menu item to access
    the OCI settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.41 – VirtualBox OCI cloud configuration settings](img/B18349_13_041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.41 – VirtualBox OCI cloud configuration settings
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve selected this option, you’ll have to enter a name. I will enter
    `OCI`, since we are using OCI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.42 – Configuration name](img/B18349_13_042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.42 – Configuration name
  prefs: []
  type: TYPE_NORMAL
- en: Now, under **Oracle Cloud Infrastructure**, you’ll see your new profile, **OCI**.
    You can click on **Properties**, which will allow you to configure that OCI profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.43 – Name committed](img/B18349_13_043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.43 – Name committed
  prefs: []
  type: TYPE_NORMAL
- en: This is where it’s handy to have the OCI portal open in another window, or cut
    and paste the variables in a notepad. You’ll need all the info we went over a
    couple of sections ago in *Figure 13**.40*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first OCID you’ll want to copy is that of `user`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.44 – User OCID](img/B18349_13_044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.44 – User OCID
  prefs: []
  type: TYPE_NORMAL
- en: Paste that OCID into the **user** property on the OCI profile, shown in the
    preceding screenshot, into VirtualBox. Hopefully, you’ll now see where we’re going
    with this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.45 – Configuring the user OCID](img/B18349_13_045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.45 – Configuring the user OCID
  prefs: []
  type: TYPE_NORMAL
- en: As previously, but this time with `tenancy`, copy the OCID and go back to VirtualBox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.46 – Tenancy OCID](img/B18349_13_046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.46 – Tenancy OCID
  prefs: []
  type: TYPE_NORMAL
- en: Again, as previously, paste the tenancy OCID in the **tenancy** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.47 – Configuring the tenancy OCID](img/B18349_13_047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.47 – Configuring the tenancy OCID
  prefs: []
  type: TYPE_NORMAL
- en: Go back to your notepad or OCI portal and copy the `region` value, in this case,
    `us-asburn-1`, as the following screenshot will show. Remember, all this will
    make sense shortly. Essentially, what we’re doing is instructing VirtualBox where
    to go, how to get there, and what region, tenancy, user, and key to use for access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.48 – Region](img/B18349_13_048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.48 – Region
  prefs: []
  type: TYPE_NORMAL
- en: As previously, paste the region in the correct field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.49 – Configuring the region](img/B18349_13_049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.49 – Configuring the region
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll need to go to the OCI console or notepad and copy the `fingerprint`
    value to input into VirtualBox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.50 – Fingerprint](img/B18349_13_050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.50 – Fingerprint
  prefs: []
  type: TYPE_NORMAL
- en: Again, paste that fingerprint value into the appropriate field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.51 – Configuring the fingerprint](img/B18349_13_051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.51 – Configuring the fingerprint
  prefs: []
  type: TYPE_NORMAL
- en: One of the last entries is the location of the private key you created. This
    is not in OCI, but rather in your local system, where you created it. Remember,
    the private key is the local key, which shouldn’t be shared. You’ll want to capture
    that path and go back to VirtualBox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.52 – API key location](img/B18349_13_052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.52 – API key location
  prefs: []
  type: TYPE_NORMAL
- en: As shown previously, paste the path into the appropriate field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.53 – Configuration key location](img/B18349_13_053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.53 – Configuration key location
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, you’ll want to go back to your OCI portal and find the **Compartments**
    menu. I find a simple search to be the easiest way of locating this option, but
    if you want to go directly to it, you’ll find it under **Identity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.54 – Compartments](img/B18349_13_054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.54 – Compartments
  prefs: []
  type: TYPE_NORMAL
- en: Expand the compartment you want to use and copy the OCID to enter it into the
    VirtualBox OCI configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.55 – Compartment selection](img/B18349_13_055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.55 – Compartment selection
  prefs: []
  type: TYPE_NORMAL
- en: As shown previously, paste that OCID into the appropriate field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.56 – Configuring the compartment](img/B18349_13_056.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.56 – Configuring the compartment
  prefs: []
  type: TYPE_NORMAL
- en: After all the data is entered, you should see that OCID’s region, user, tenancy,
    key file location, compartment, and fingerprint properties are all populated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.57 – Completed configuration](img/B18349_13_057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.57 – Completed configuration
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve confirmed that everything is complete, apply the settings. You’ll
    see the new profile show up; we named it **OCI**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.58 – VirtualBox OCI](img/B18349_13_058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.58 – VirtualBox OCI
  prefs: []
  type: TYPE_NORMAL
- en: If you expand that profile, you’ll see the tenancy is now empty. If you already
    had infrastructure deployed there, you would see those resources show up here,
    provided they are running in the same compartment as the OCID entered in the profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.59 – Expanded OCI](img/B18349_13_059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.59 – Expanded OCI
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re now ready to start moving over the VM we built earlier in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step in exporting your VM to OCI, once the VirtualBox OCI profile
    is configured, is to click on **Export** in the VirtualBox main welcome menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.60 – Export](img/B18349_13_060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.60 – Export
  prefs: []
  type: TYPE_NORMAL
- en: You’ll next need to select the VM to be exported to OCI, as shown in the following
    screenshot – in this case, it’s called **small-ol8.8**. This will vary depending
    on what you named your VM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.61 – Image selection](img/B18349_13_061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.61 – Image selection
  prefs: []
  type: TYPE_NORMAL
- en: After you choose your VM, you must configure the format in which to export the
    VM. We’re going to expand the `.ova` as the file extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.62 – Image format configuration](img/B18349_13_062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.62 – Image format configuration
  prefs: []
  type: TYPE_NORMAL
- en: As shown previously, choose **Oracle Cloud Infrastructure** for the format and
    **OCI** as the VirtualBox profile, as highlighted in red in the following screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.63 – Profile](img/B18349_13_063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.63 – Profile
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll want to make sure all your variables are correct, as shown in the following
    screenshot, as well as confirming you have an available storage bucket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.64 – Image output](img/B18349_13_064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.64 – Image output
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll want to expand the `VM.Optimized.Flex` will not be recognized by OCI.
    I identified a usable shape, as shown in the following figure, that is available
    and lightweight. Follow the following image for shape selection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.65 – Shape selection](img/B18349_13_065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.65 – Shape selection
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown previously, expanding this section will give you several shape choices.
    As a note, a shape is a predetermined size, reflecting a set number of resources.
    In this case, we’re choosing **VM.Standard.E2.1**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.66 – Image shape](img/B18349_13_066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.66 – Image shape
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`VM.Optimized3.Flex` is not a recognized shape and will not import. You can
    always change the shape after the VM is deployed.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve chosen the appropriate shape, finish configuring the export, then
    click **Finish** to execute the migration to OCI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.67 – Image shape committed](img/B18349_13_067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.67 – Image shape committed
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure your image shape is identified and the correct shape was selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.68 – Image writing](img/B18349_13_068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.68 – Image writing
  prefs: []
  type: TYPE_NORMAL
- en: Once the export is completed, you’ll see your VM running in OCI, and you’ll
    be able to log in to your portal and see that same VM running within your OCI
    tenancy as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.69 – Image running](img/B18349_13_069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.69 – Image running
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, the image is now running as a VM in OCI.
  prefs: []
  type: TYPE_NORMAL
- en: For everyone else, let’s make custom images for AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It seems very simple: build an image, export the image, and import the image
    (wash, rinse, and repeat). The concept isn’t much more complicated than that.
    However, there are steps to go through, and some of those steps have catches.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll first have to walk through the steps of setting up and configuring the
    AWS CLI. Much like the OCI CLI, AWS’s CLI is a direct command line executing against
    the AWS API. After the CLI is installed and configured, we’ll walk through setting
    up an S3 bucket, configuring that bucket, and changing access to allow upload.
    The following figure shows the stages and their touchpoints throughout this recipe.
    The AWS CLI is the common thread in staging and executing, along with the GUI.
    The storage factors in AWS are managed by access control and authentication, which
    allow us to create, store, and manipulate stored objects and buckets.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.70 – AWS CLI storage connections](img/B18349_13_070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.70 – AWS CLI storage connections
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can start using the CLI, we must download and install the requisite
    package. For this recipe, I am using a Mac. You can easily navigate to AWS and
    download the CLI for Windows or Linux. Regardless, once the CLI is installed,
    the commands do not differ other than the locations and some other OS-specific
    changes, which really only apply to Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After downloading the package, you’ll have to install the CLI. This is done
    by executing the install package, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we upgraded the Python version to match what the AWS CLI requires.
    You can check this by running a `which` command at the end, which will show the
    location of the AWS CLI install, and `--version`, which will list the version
    of the AWS CLI, as well as Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After you’ve installed the AWS CLI, we’ll move on to configuring the Oracle
    Linux OS. We’ll later configure the AWS CLI with the details of our AWS account
    and data center location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.71 – Create a new VM](img/B18349_13_077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.71 – Create a new VM
  prefs: []
  type: TYPE_NORMAL
- en: You’ll want to fill in all the fields as we did in previous sections. Make sure
    to name your VM by referencing the disk you created (`/Users/USER/Desktop/<NAME>`).
    This will help keep things in place later. You can always go back to the VM in
    VirtualBox and find the associated media, but it’s easier to name the disk now,
    while creating the VM.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.72 – ISO selection](img/B18349_13_078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.72 – ISO selection
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, in the previous section, we allocated CPU and memory. Just
    like in any other build environment, we need to specify, install, and configure
    resources. Whether they are virtual or physical, we’re still installing resources.
    In this case, we’re configuring this VM with 4 GB of RAM and two vCPUs. Remember,
    a vCPU is the equivalent of a processor thread. So, here we’re installing two
    vCPUs, which is the equivalent of one physical core (two threads (vCPUs) = one
    processor core).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.73 – Resources](img/B18349_13_079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.73 – Resources
  prefs: []
  type: TYPE_NORMAL
- en: After we’ve configured the CPU and memory resources, we’re ready to move on
    to choosing the media (disk) we’re attaching to our VM. In this case, we’re not
    going to choose the default of creating a disk, instead using an existing one.
    Remember, we created our own drive in `.vmdk` format, so let’s select to use an
    existing virtual hard disk file here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.74 – Options to create or use an existing disk](img/B18349_13_080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.74 – Options to create or use an existing disk
  prefs: []
  type: TYPE_NORMAL
- en: Remember to select the drive (assuming you created one before) that matches
    the name of the VM, or create a new one. Note that the `.vmdk` extension should
    be used again in order for it to be recognized.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.75 – Disk selection](img/B18349_13_081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.75 – Disk selection
  prefs: []
  type: TYPE_NORMAL
- en: As in past recipes, we confirm our selections on the **Summary** screen and
    execute the configuration by selecting **Finish**. We won’t be walking through
    the build, as we have other recipes that take you through configuring OSs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.76 – Configuration summary](img/B18349_13_082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.76 – Configuration summary
  prefs: []
  type: TYPE_NORMAL
- en: Once we have built the Linux OS, we can walk through configuring our AWS environment,
    including setting up the CLI to upload and execute our AMI upon its creation,
    from our OVA. Remember, in the previous recipe, we built out a VM and created
    an OCI from that OVA image in VirtualBox. We’ll be doing the same here, exporting
    from VirtualBox and importing into AWS. The difference here is that there isn’t
    a fancy VirtualBox environment to work from. We’ll be using the AWS CLI to import
    that OVA image into our S3 environment. However, as mentioned previously, in order
    to do that, we need to configure that connection and have it in place. We’ll walk
    through those settings on AWS to migrate from VirtualBox to AWS, and see what
    that transformation entails.
  prefs: []
  type: TYPE_NORMAL
- en: While the OVA is exporting, you’ll want to start preparing the AWS CLI configuration.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can upload the exported OVA in one of two ways, either via the command line
    or through the S3 console. Either way, it’s simply an upload to AWS S3 and it
    doesn’t really matter how you do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Uploading through the S3 console is a fairly straightforward process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to your AWS console, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.77 – Sign in as root user](img/B18349_13_083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.77 – Sign in as root user
  prefs: []
  type: TYPE_NORMAL
- en: After signing in, navigate to S3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.78 – AWS menu](img/B18349_13_084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.78 – AWS menu
  prefs: []
  type: TYPE_NORMAL
- en: If S3 isn’t on your most recently visited list, navigate to `S3` in the search
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.79 – S3 storage](img/B18349_13_085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.79 – S3 storage
  prefs: []
  type: TYPE_NORMAL
- en: After navigating to S3, you’ll want to create a bucket for your OVA to be uploaded
    to. A bucket is essentially object storage and a great place to store images and
    the like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.80 – S3 bucket](img/B18349_13_086.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.80 – S3 bucket
  prefs: []
  type: TYPE_NORMAL
- en: After selecting **Create bucket**, you’ll want to name that bucket and configure
    other aspects of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.81 – Bucket name and region](img/B18349_13_087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.81 – Bucket name and region
  prefs: []
  type: TYPE_NORMAL
- en: After naming, choose which region, as per the AWS docs, the bucket should be
    created under. Remember to create the bucket in the same region you’re operating
    in and will be using for this exercise. In this case, we’ll be deploying into
    US East 2 - Ohio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We won’t be enabling any ACLs here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.82 – ACLs](img/B18349_13_088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.82 – ACLs
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously concerning AWS access control, we’re going to uncheck
    **Block all public access** and open the S3 bucket up to direct public (i.e.,
    external) access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This is not generally a best practice; we are just doing this for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.83 – Public access](img/B18349_13_089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.83 – Public access
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to keep versioning disabled (the default), as shown in the following
    screenshot, as this is a one-time bucket and will not be kept perpetually. You’ll
    want to enable versioning when you’re working through the life cycle of a project
    with multiple versions, for example, multiple iterations of an image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.84 – Versioning](img/B18349_13_090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.84 – Versioning
  prefs: []
  type: TYPE_NORMAL
- en: Again, since we’re keeping this basic, we will not be associating any tags either.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.85 – Tags](img/B18349_13_091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.85 – Tags
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to use standard server-side encryption with S3-managed keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.86 – Encryption](img/B18349_13_092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.86 – Encryption
  prefs: []
  type: TYPE_NORMAL
- en: Ignore the advanced options as well and go ahead with creating the bucket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.87 – Bucket display](img/B18349_13_093.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.87 – Bucket display
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the newly created `vb-aws-us-east-2` bucket and click on **Upload**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.88 – Object upload](img/B18349_13_094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.88 – Object upload
  prefs: []
  type: TYPE_NORMAL
- en: Click **Add files**. This will allow you to choose the correct OVA to upload
    to the bucket from your own filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.89 – Add files](img/B18349_13_095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.89 – Add files
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to choose the OVA we created at the beginning of this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.90 – File selection](img/B18349_13_096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.90 – File selection
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve added the file, carry out the upload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.91 – File destination](img/B18349_13_097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.91 – File destination
  prefs: []
  type: TYPE_NORMAL
- en: The status bar will show the progress and the **Summary** section will show
    the destination in S3, as shown in the following screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.92 – Uploading](img/B18349_13_098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.92 – Uploading
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you navigate away from this status page, you will not be able to get back
    to it, so stay on the page until the upload is complete.
  prefs: []
  type: TYPE_NORMAL
- en: After the upload is complete – or, if you’re up for multitasking, open another
    AWS console session in the meantime – you’ll have to set up roles and access for
    the bucket you just created. Navigate to **Identity and Access Management** (**IAM**)
    to access the role data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Roles**, you can create customized roles for access, authentication,
    or any other IAM-related criteria.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.93 – AWS Roles](img/B18349_13_0931.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.93 – AWS Roles
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be configuring roles and permissions from the command line. We must create
    an IAM user and secret as without access or authentication, the CLI won’t operate.
    Then we can configure the CLI to be connected to our account.
  prefs: []
  type: TYPE_NORMAL
- en: To configure and associate the user with that access key, you have to navigate
    back to IAM, as the following steps will walk through.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.94 – Security, Identity, & Compliance menu](img/B18349_13_100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.94 – Security, Identity, & Compliance menu
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve expanded `IAM` in the search bar. As we’re trying to help you become
    familiar with the console, we will detail the specific steps to get to this option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.95 – IAM](img/B18349_13_101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.95 – IAM
  prefs: []
  type: TYPE_NORMAL
- en: In order to access and create keys, we must understand what a key is for, and
    how it related to a user. So, let’s navigate to **Users**. We’ll walk through
    key creation as follows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.96 – Users](img/B18349_13_102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.96 – Users
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll want to create the user as shown in the following screenshot, which
    you can do by navigating to `user-admin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.97 – User name](img/B18349_13_103.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.97 – User name
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve named our user, just like with any other system, we need to define
    the user, add them to a group, and assign privileges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.98 – User definition](img/B18349_13_104.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.98 – User definition
  prefs: []
  type: TYPE_NORMAL
- en: We’ll assign this user to the admin group and click **Next** to continue. You
    can define permissions by creating a group that more closely aligns with your,
    or your organization’s, policies. After creating the user, this is where we can
    generate a key, as shown in the following screenshot, with the secret attached.
    The following steps walk through how to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.99 – Credentials](img/B18349_13_105.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.99 – Credentials
  prefs: []
  type: TYPE_NORMAL
- en: The **Security credentials** tab is where you create the access key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.100 – CLI access control and credentials creation](img/B18349_13_106.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.100 – CLI access control and credentials creation
  prefs: []
  type: TYPE_NORMAL
- en: This access key is specifically for the CLI, so that’s the option we’ll want
    to select, as shown in the preceding screenshot, and then click **Next**. We’re
    not creating any tags in this recipe, so feel free to skip that step and create
    the access key.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Download the `.csv` file (the credential document), or show and copy the secret
    access key by clicking on the two squares next to the secret access key. This
    is the only place where you can copy these keys, whether you write them down or
    paste them into a notepad. **Once you close this page, you won’t be able to recover
    this information.** You could create and reconfigure the CLI without losing the
    data, but that would be a lot of unnecessary work, so just make sure to write
    down the secret.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.101 – Secret](img/B18349_13_107.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.101 – Secret
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to copy the secret access key, which in our case is shown below –
    yours will differ from the one we have here: `eZ5mZxzGhEYM0AfyBznLDqIT6TMsUz//AO2DMQst`.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve created the key and noted down the secret access key, the access
    key will be active.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.102 – Access key](img/B18349_13_1021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.102 – Access key
  prefs: []
  type: TYPE_NORMAL
- en: 'After you’ve added the access key, you’ll be able to run `aws configure` in
    the CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you put `JSON` in all caps, this will fail. It will not report a failure,
    but your command will fail when run against the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you’ve configured the CLI, you can execute the following to convert your
    image from an OVA to an AMI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following command will ascertain the status of the conversion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`import-ami-xxxxxxxx` will change every time you execute a conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: I’ve executed the command and run it several times to show each step of the
    process. After the following steps, you’ll be able to use your newly created AMI
    in your AWS tenancy. When walking through the import tasks, I refreshed here to
    show all the versions of the updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to show the status of the import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`converting`: The image is being converted into an AMI'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`updating`: The AMI import is being updated'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`validating`: The import is being validated'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`validated`: Validation is completed'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`completed`: The AMI is ready to use'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`deleted`: The import task has been canceled'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the AMI is complete, the following will be the end status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: After the process has completed, you will be able to log back in to the AWS
    console and navigate to your EC2 environment. In order to launch a new VM with
    the ability to select your AMI as the template, click **Launch instance**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.103 – Launching an instance](img/B18349_13_109.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.103 – Launching an instance
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re in the launch menu, you can drill down into other AMIs available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.104 – Browse AMIs](img/B18349_13_110.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.104 – Browse AMIs
  prefs: []
  type: TYPE_NORMAL
- en: This will take you to your customized AMIs and (as shown earlier in *Figure
    13**.7, Image products*), the Marketplace. The Marketplace is where you can share
    your own AMIs with the community or use ones that others have uploaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.105 – Created AMI](img/B18349_13_111.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.105 – Created AMI
  prefs: []
  type: TYPE_NORMAL
- en: As shown previously, you’ll see the available AMI, created in this recipe, reflected.
    Also as an aside, besides the AMIs on offer in the Marketplace, you can also find
    a number of OSs, including Oracle Linux.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you navigate to the newly created AMI, you’ll see that you can select that
    image as your AMI to execute and create a VM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.106 – AMI selection](img/B18349_13_1061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.106 – AMI selection
  prefs: []
  type: TYPE_NORMAL
- en: By selecting the AMI, you’re attaching that AMI as your image and executing
    the creation of a VM from the selected image (the AMI).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.107 – Instance launch configuration](img/B18349_13_113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.107 – Instance launch configuration
  prefs: []
  type: TYPE_NORMAL
- en: After selecting the AMI and executing the launch, you’ll enter into the standard
    launch protocols for creating an AWS VM, including creating a key pair, naming
    the pair, and downloading the key. You can pre-create these keys as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.108 – Key pair](img/B18349_13_108.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.108 – Key pair
  prefs: []
  type: TYPE_NORMAL
- en: Once you create the key pair, the private key will download to your local machine
    and you can go ahead and launch your VM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.109 – Success status](img/B18349_13_115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.109 – Success status
  prefs: []
  type: TYPE_NORMAL
- en: You can navigate to your VM by clicking on the instance ID. Once you’re in the
    instance, you’ll be able to capture the IP and log in to your new VM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.110 – Public IP](img/B18349_13_116.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.110 – Public IP
  prefs: []
  type: TYPE_NORMAL
- en: 'To log in to the machine, you can use the key pair or the passwords created
    when you built the machine; either will work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
