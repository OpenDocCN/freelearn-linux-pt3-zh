- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating User Interfaces with yad, dialog, and xdialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I know, you’re thinking that shell scripting consists of nothing but entering
    boring, plain-text commands in a terminal. But, what if I told you that you can
    fancy up your scripts by adding a user interface? What if I told you that you
    can have a graphical interface for desktop systems or a non-graphical interface
    for text-mode servers? Well, you can, and I’m here to show you how.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a graphical user interface with `yad`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating user interfaces with `dialog` and `xdialog`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re ready, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For `yad` and `xdialog`, you’ll need to use a desktop implementation of Linux.
    It doesn’t much matter which distro you use, as long as the `yad` and `xdialog`
    packages are in the repository. Just use your distro’s normal package management
    tool to install them. (The `yad` and `xdialog` packages are also available for
    GhostBSD, which is FreeBSD with either the Mate or Xfce desktop environment. If
    you’re on a Mac, you’ll need to install `yad` or `xdialog` via Homebrew. Alas,
    neither one is available for OpenIndiana, and `yad` isn’t available for any of
    the RHEL 9-type distros.)
  prefs: []
  type: TYPE_NORMAL
- en: For the `dialog` section, you can use either a desktop or a text-mode server
    implementation of Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, as always, you can grab the scripts by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Okay, let’s begin by looking at `yad`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Graphical User Interface with yad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Yet Another Dialog**, or **yad** for short, is a very cool program that allows
    you to add GUI-type interfaces to your shell scripts. There’s a lot you can do
    with it, and I’d like to show you a few simple examples.'
  prefs: []
  type: TYPE_NORMAL
- en: The yad Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `yad` man page, you’ll see a list of pre-defined components that you
    can use in your `yad` scripts. For example, if you do `yad --file`, you’ll open
    the file manager that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_1](img/B21693_16_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: The yad file manager'
  prefs: []
  type: TYPE_NORMAL
- en: 'As it is, this file manager won’t do anything for you. If you click on a file
    and then click the **OK** button, the manager will close and the name of the file
    that you chose will print out on the command line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To make this useful, you’ll need to add code that will perform some desired
    action upon the chosen file. Before we attempt something this complex though,
    let’s begin with something that’s a bit more simple.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Data Entry Forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say that you’re a collector of classic automobiles, and you need to create
    a simple database to keep track of your vast collection. We’ll begin by testing
    the basic script, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s a bit hard to read, though. So, let’s make the `yad-form-auto1.sh` script
    a bit more readable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This `yad` command is actually one long command. To make it more readable, I’ve
    broken it up over several lines, by adding a backslash after each option definition.
    You could leave out the backslashes and just place the entire command on one line,
    as you saw above, but this looks much better.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the first line, I’ve placed both the `--title` and the `--text` definitions,
    which should be self-explanatory. The second line defines a form with a width
    of 400 pixels. Following that are the definitions for the data entry fields. Note
    that the `Year` field can only accept a numerical value, as indicated by the `:NUM`
    parameter. At the end, I’m redirecting the output into the `classic_autos.txt`
    file. (I’m using the `>>` operator so that I can add more than one auto to the
    file.) Here’s how it looks when I run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_2](img/B21693_16_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: Running yad-form-auto1.sh'
  prefs: []
  type: TYPE_NORMAL
- en: 'When I hit the **OK** button, the output will be saved to the `classic_autos.txt`
    file, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By default, `yad` uses the `|` symbol as the output field separator. That’s
    okay, because if you open this file in a spreadsheet program, you can set the
    `|` symbol as the field separator, and it will work just fine. But, you can change
    the field separator if you like. For example, if you want to create `.csv` files,
    just add the `--separator=","` parameter to the `--form` line.
  prefs: []
  type: TYPE_NORMAL
- en: 'One slight problem with this script is that every time you hit the **OK** button
    to create an entry in your text file, the script will exit. Each time you add
    an auto, you’ll need to invoke the script again. Let’s fix that with a `while`
    loop, as you see here in the `yad-form-auto2.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By using a `:` as the while condition, we’re creating what’s known as an infinite
    loop. In other words, this will never quit until you press **Ctrl-c**.
  prefs: []
  type: TYPE_NORMAL
- en: 'While I was at it, I added the `Date Acquired` field with the `:DT` option.
    This option causes a handy-dandy calendar to pop up whenever I click on the calendar
    icon. Here’s how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_3](img/B21693_16_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: The yad-form-auto2.sh script'
  prefs: []
  type: TYPE_NORMAL
- en: This is good, but it’s still not perfect. Due to using a `:` for the while condition,
    the only way to end this script is to **Ctrl-c** out of it, because the **Cancel**
    button won’t do anything. To fix that, you need to understand that the **OK**
    button returns a 0 as the exit code, and the **Cancel** button returns a 1 as
    the exit code.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to review the concept of exit codes, refer back to *Chapter 8, Basic
    Shell Script Construction*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s modify the `while` loop in this `yad-form-auto3.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `$? == 0` parameter retrieves the exit code and verifies that it’s 0\. This
    keeps the script running as long as you don’t click on either the **Cancel** button
    or the **X** at the top corner of the window. (I forgot to mention that hitting
    the **X** returns an exit code of 252.)
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s wrap this section up with one last modification.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Drop-down List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This time, we’ll add a drop-down list for choosing the body style, and a free-form
    text box. Here’s the `yad-form-auto4.sh` script to show you how it’s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `bodystyles=` line, the `--item-separator` parameter in the `--form` line,
    and the `"" "" ""` line all work together to create the drop-down list. The `bodystyles=`
    defines the list of available body styles, separated by commas. This goes along
    with the `--item-separator` parameter, which ensures that the drop-down list appears
    with only one body style per line, instead of having all body styles on one line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `:CBE` parameter at the end of the `--field="Body Style"` line defines
    this field as a drop-down list with the option to edit it if you choose the **other**
    option. The last line in the `while` loop tells `yad` where to place the values
    of the `bodystyles` variable. We see that the `Body Style` field is the fourth
    field. So to represent the first three fields, which are blank by default, we
    place three pairs of double quotes ahead of the `$bodystyles` variable. The last
    item on the line places a line of text in the `Date Acquired` field. The final
    field definition is the free-form text box, as you see by the `:TXT` parameter.
    (The text box field comes after the drop-down list field, which means that you
    don’t have to add another pair of double-quotes to be a placeholder.) Here’s how
    it looks when I choose a body style:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_4](img/B21693_16_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: Using a drop-down list'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can adapt this script for pretty much any purpose. That can include
    keeping inventories of your own personal collections, store merchandise, or software
    licenses. (Let your imagination run wild.)
  prefs: []
  type: TYPE_NORMAL
- en: That wraps it up for this demo. Now, let’s manage some files.
  prefs: []
  type: TYPE_NORMAL
- en: Using the yad File Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to work with files is to create a variable, with its value assigned
    by a `yad` command substitution construct. Then, you can do whatever you want
    with the value of the variable. Let’s see what we can do with that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a File Checksum Utility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the first example, let’s say that you want to create a list of files with
    their `sha512` checksums. Here’s the `yad-file-checksum1.sh` script that does
    just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Clicking on a file assigns the name of that file to the `filetocheck` variable.
    We can then use the value of that variable as the argument for the `sha512sum`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_5](img/B21693_16_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: Opening a file with yad-file-checksum1.sh script'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking the **OK** button creates the `file_checksum.txt` file, which contains
    the SHA512 checksum of the `people.txt` file, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s great, but as always, we can fancy things up a bit. In the `yad-file-checksum2.sh`
    script, we’ll add a `while` loop so that the **Cancel** button will work, and
    also add the ability to choose multiple files. And, while we’re at it, let’s add
    a file preview feature. Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--multiple` and the `--separator=''\n''` options work together. Without
    the `--separator` option, the `--multiple` option will cause all filenames to
    appear as one long line, with filenames separated by a `|` symbol. This will cause
    the `sha512sum` utility to view that line as a single filename, which will cause
    an error. Placing a new line after each filename solves the problem. The `--add-preview`
    and the `--width` options should be self-explanatory, so I won’t comment about
    them. At any rate, here’s how the new script works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_6](img/B21693_16_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: The file selector with the preview and multiple file options'
  prefs: []
  type: TYPE_NORMAL
- en: You can select multiple non-consecutive files by holding down the **Ctrl** key,
    or multiple consecutive files by holding down the **Shift** key. The end result
    will be a text file that contains the SHA512 sum checks of all the selected files.
  prefs: []
  type: TYPE_NORMAL
- en: I have to confess that there’s something weird going on with this script, and
    that it has me stumped. When you click on either the **Cancel** button or the
    **X** button, the dialog box will close down as it’s supposed to do. But, for
    some strange reason the process doesn’t end, which means that the terminal never
    returns to the command-prompt. I’ve tried performing every unnatural act I could
    think of to fix that, but to no avail. So, it appears that whenever you run this
    script, you’ll just have to **Ctrl-c** out of it when you’re done.
  prefs: []
  type: TYPE_NORMAL
- en: All right, let’s move on to the next example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GUI Front-end for ImageMagick
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let’s see if we can create a GUI front-end for the ImageMagick program
    that we talked about back in *Chapter 13, Scripting with ImageMagick*. We’ll begin
    with the `yad-image-resize1.sh` script, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line creates the initial file selection window. It then assigns the
    filename of the selected file to the `imageFile` variable. Here’s how this initial
    window looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_7](img/B21693_16_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.7: The initial file selection window for resizing images'
  prefs: []
  type: TYPE_NORMAL
- en: The second line creates the **Image Resize** window that you’ll use for entering
    the resize and quality parameters. When you enter your desired parameters, they’ll
    get stored in the `dialog` variable as a single line, with the two parameters
    separated by a `|` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two lines create the `size` and `quality` variables, using the values
    that are stored in the `dialog` variable. We need a way to extract each individual
    parameter, and `awk` gives us a handy way to do it. Anyway, here’s how the **Image
    Resize** window looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_8](img/B21693_16_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.8: the Image Resize window'
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the `convert` line, which performs the actual resizing. You see that
    it’s using values from the `size`, `quality`, and `imageFile` variables. When
    I click on the **OK** button, the resizing process will take place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final line creates the **Status** window, which shows that the process
    is complete. By default, `yad` windows have both a **Cancel** and an **OK** button.
    In this case, we only want the **OK** button, so we override the default behavior
    by explicitly creating an **OK** button with the `--button` option. Here’s how
    this window looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_9](img/B21693_16_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.9: The Status window'
  prefs: []
  type: TYPE_NORMAL
- en: Look in your directory, and you should see that the image has indeed been resized.
  prefs: []
  type: TYPE_NORMAL
- en: To give credit where credit is due, I borrowed this script from a *Linux Magazine*
    article that was posted way back in 2012, and made a couple of minor tweaks to
    it. You’ll find the link to the original article in the *Further Reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The major flaw with this script is that it overwrites the original graphics
    file with the resized version. Let’s modify it so that it will save the resized
    version as a new file with a new filename. Here’s the `yad-image-resize2.sh` script
    that does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this work, I created two new variables and used variable expansion
    to assign them their values. The `newfilename=${imageFile%%.*}` line grabs the
    first part of the `imageFile` filename, up to the dot for the filename extension.
    For example, let’s say that the value of `imageFile` is `somegraphic.jpg`. Using
    variable expansion to strip off the `.jpg` would result in assigning a value of
    `somegraphic` to the `newfilename` variable. The `suffix` variable uses the offset
    feature of variable expansion. In this case, the `${imageFile: -4}` construct
    grabs the last four characters of the filename. This results in assigning a value
    of `.jpg` to the `suffix` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to note is how I had to modify the `convert` command. (By the
    way, note that this `convert` command is quite long, and wraps around on the page.)
    All I did was to add the `-delete 1 "$newfilename"_resized"$suffix"` part to the
    end of the command that I had before. You’ve probably figured out that with our
    current example, this would create a new file with the filename, `somegraphic_resized.jpg`.
    But, you might be puzzled by the `-delete 1` part. Well, it’s just that under
    certain conditions, the `convert` command will create two output files, instead
    of just one, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the `-delete 1` parameter just before the output filename parameter
    eliminates that problem, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The final modification I’ll show you, which I’ll put in `yad-image-resize3.sh`,
    causes the file manager to only display certain file types. Since we’re dealing
    with graphics files, we only want the file manager to show us files with the `.JPG`,
    `.jpg`, `.PNG`, and `.png` filename extensions. We’ll do that by just adding the
    `--file-filter "Graphics files | *.JPG *.jpg *.PNG *.png")` option to the `imageFile=`
    line that’s at the top of the script. The new line now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the line is quite long, let’s make it more readable by breaking it
    up with backslashes, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That looks much better, right?
  prefs: []
  type: TYPE_NORMAL
- en: All right, let’s move on to our final example.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Form Buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this scenario, we’re in a software developer’s shop that’s running a small
    fleet of Fedora Linux-powered workstations. We want to create a GUI-type setup
    utility that will simplify the process of setting up a new workstation. Furthermore,
    we want to carry this utility around on a USB memory stick so that we can either
    run it directly from the memory stick, or copy it to each workstation. Fortunately,
    that’s easy with `yad`. Here’s the `yad-system-tool.sh` script that does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this script, you see some options that you haven’t seen before. The `--columns=3`
    option in the first line means that we want to create a form with three buttons
    across on each row. On the second line, you see a `--height` option, as well as
    a `--width` option. In each of the `--field` lines, you see the `:FBTN` option,
    which defines the fields as programmable buttons. The `<b>` and `</b>` tags that
    surround the button text make the button text appear in bold type. The final portion
    of each `--field` line consists of the command that will run when you click on
    the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first button is programmed to perform a system update with the `dnf -y
    upgrade` command. The `-y` causes the command to run without stopping to prompt
    the user about whether he or she really wants to do it. I had to use the `-y`
    option, because without it, the operation would abort at the prompt. The next
    two buttons each install a selected group of software packages. If you want to
    see what’s in each of these groups, just run these two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we’re dealing with administrative commands in this script, we’ll need
    to run it with `sudo`. Here’s how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_10](img/B21693_16_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.10: A yad form with programmable buttons'
  prefs: []
  type: TYPE_NORMAL
- en: Now, just click on a button and watch what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding more software installation choices is easy, by just adding more `--field`
    lines. If you want to see the list of software packages that are available on
    Fedora, just do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: I know, you’re thinking that this type of chore would be more easily accomplished
    with a set of plain, text-mode scripts. And yeah, you’re right. So, just think
    of this example as a template that you can use for your own purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Also, I neglected to mention before that you’ll need to manually install `yad`
    on each system that you want to administer with this script.
  prefs: []
  type: TYPE_NORMAL
- en: That wraps things up for this script, so let’s move on.
  prefs: []
  type: TYPE_NORMAL
- en: Some Final Thoughts about yad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`yad` is a really cool program, and you can do a lot of really cool stuff with
    it. In fact, a person could probably write a whole book on nothing but `yad`.
    I can’t do that at the moment, but I’ve hopefully given you enough to whet your
    appetite.'
  prefs: []
  type: TYPE_NORMAL
- en: The main problem with `yad` is that for whatever reason, its creator has never
    written any real documentation for it, other than a very sparse man page. Fortunately,
    a lot of other people have taken up the challenge, and have created their own
    documentation and tutorials on both the web and on YouTube. (I’ll link to some
    of these resources in the `Further Reading` section.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s turn our attention to `dialog` and `xdialog`, which we can also
    use to create user interfaces for our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating User Interfaces with dialog and xdialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another slight problem with `yad` is that you can only use it on machines that
    have a desktop environment installed. But, many Linux, Unix, and Unix-like servers
    are set up with a full text-mode environment and don’t have to use graphical desktops.
    Another slight problem with `yad` is that even on desktop-type operating systems,
    it’s not always available for installation. However, if `yad` isn’t available
    and you still need a GUI solution, you might be able to use `xdialog`, which is
    more universally available. Let’s begin with a look at `dialog`, which can be
    used on text-mode machines.
  prefs: []
  type: TYPE_NORMAL
- en: The dialog Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`dialog` used to be installed by default on all Linux systems, but it no longer
    is. However, it’s available for installation for pretty much every Linux distro.
    So, you can install it with your distro’s normal package manager. On most Unix
    and Unix-like systems, such as OpenIndiana and FreeBSD, it still comes installed
    by default.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic `dialog` building blocks are known as **widgets**. Each widget has
    a set of parameters that you need to specify when you use it. For example, open
    the `dialog` man page and scroll down to the `--msgbox` paragraph, where you’ll
    see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this widget requires you to specify three parameters. (Unlike `yad`, specifying
    the dimensions of a `dialog` box isn’t optional.) Let’s see how that looks in
    the `dialog-hello.sh script`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you’ve seen before in the `yad` section, I used a backslash to break the
    command into two lines, which makes things a bit more readable. On the `--msgbox`
    line, we see the message text, the height as defined by the number of rows in
    the box, and the width as defined by the number of characters that fit on a line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the script looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_11](img/B21693_16_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.11: Running the dialog-hello.sh script'
  prefs: []
  type: TYPE_NORMAL
- en: To close the window, just hit the **Enter** key, which activates the **OK**
    button by default. (On a desktop machine, you also have the option of clicking
    on the **OK** button with your mouse.) Once the window is closed, run the `clear`
    command to remove the blue background from your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `dialog` windows always appear in the center of your terminal,
    and the blue background won’t clear until you clear it yourself. Fortunately,
    you can change both behaviors. Here’s a slightly modified version of our script,
    which places the window at the top left corner of the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_12](img/B21693_16_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.12: Placing the dialog box in the upper-left corner'
  prefs: []
  type: TYPE_NORMAL
- en: The `--begin` option takes two parameters. The first one denotes the vertical
    position of the box, and the second one denotes the horizontal position. For example,
    by changing the line to `--begin 15 2`, the box would show up in the lower left
    corner. To place it into the upper right corner, you could change it to `--begin
    2 50`. The `clear` command at the end will clear away the blue background when
    you hit the **OK** button.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this script isn’t very useful, but that’s okay. I’ll show you some
    more useful concepts in just a bit. First though, allow me to say a few words
    about `xdialog`.
  prefs: []
  type: TYPE_NORMAL
- en: The xdialog Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need a GUI-type of user interface and `yad` isn’t available for your
    desktop system, `xdialog` could be a good alternative. (I say could be, because
    neither `yad` nor `xdialog` is available for OpenIndiana.) It should be in the
    normal repository of your Linux or Unix-like distro, so just use your normal package
    manager to install it. The reason I can talk about both `dialog` and `xdialog`
    in the same section is because for the most part, code that’s written for `dialog`
    can also run with `xdialog`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s one thing to look out for that could trip you up. For some strange reason,
    the package name is `xdialog`, in all lower-case letters. But, after it’s installed,
    you’ll need to invoke the program by typing `Xdialog`, with an upper-case X. (After
    I installed it, it took me a while to figure out why I couldn’t get it to work.)
  prefs: []
  type: TYPE_NORMAL
- en: 'For the most part, changing a `dialog` script to run as a GUI-type program
    is a simple matter of changing all instances of `dialog` to `Xdialog`, as you
    see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the script on a desktop system gives you this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_13](img/B21693_16_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.13: Running the script with xdialog'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to note is that `xdialog` ignores the `--begin` option, and
    just places the box in the center of the terminal. There’s also the fact that
    `xdialog` often requires you to create boxes with larger dimensions so that you
    can see everything. So, let’s change that in the final `xdialog-hello.sh` script,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see here, this makes things look much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_14](img/B21693_16_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.14: The improved xdialog script'
  prefs: []
  type: TYPE_NORMAL
- en: With `xdialog`, the clear command at the end of the script is no longer necessary,
    but it doesn’t hurt anything to leave it. In fact, we’ll need it for the next
    demo.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically Choosing Either dialog or xdialog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, here’s something that’s really cool. With only a few extra lines of code,
    you can make your script automatically detect whether it’s running on a desktop
    or text-mode machine, and whether `xdialog` is installed. Here’s the `xdialog-hello2.sh`
    script to show how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several ways to detect if a program is installed. In *Chapter 12,
    Automating Scripts with here Documents and expect*, I showed you this method in
    the `system_info.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `pandoc` executable that we needed is in the `/usr/local/bin/` directory
    on FreeBSD, and in the `/usr/bin/` directory on everything else. So, I set up
    this `if..then` construct to detect if the executable is in either place. That
    works, but I’d now like to show you an easier way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `xdialog-hello2.sh` script, the `command -v Xdialog` command detects
    if the `Xdialog` executable file is present, regardless of which directory it’s
    in. If it is, the command will return exit code 0\. If it’s not, the command will
    return exit code 1\. To see how this works, go ahead and run this on the command
    line. Here’s how it looks if the `Xdialog` executable isn’t detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And, here’s how it looks if it is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next line, you see an `if..then` construct that checks for two things.
    First, it checks the exit code from the `command` command, and then it checks
    to see if a graphical desktop environment is installed. If the value of the `DISPLAY`
    environmental variable is of a non-zero length, then a desktop environment is
    installed. You can see how this works by running the `echo $DISPLAY` command yourself.
    Here’s how it looks on a desktop machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'On a text-mode machine, you’ll get no output at all, as you see here on this
    Ubuntu Server virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For our purposes, we can say that the value of `DISPLAY` is zero characters
    long on this text-mode machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take another look at our `if..then` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This means that if the exit code from the `command -v Xdialog` line is 0, and
    the value of the `DISPLAY` environmental variable is of a non-zero length, then
    the value of the `diag` variable becomes `Xdialog`. If either the `Xdialog` executable
    is missing or the value of `DISPLAY` is *not* a non-zero length, then the value
    of `diag` becomes `dialog`. What makes this even more cool is that this works
    the same on all Linux, Unix, or Unix-like systems. I’ve tested this script on
    FreeBSD, GhostBSD, DragonflyBSD, OpenIndiana, and on both desktop and text-mode
    implementations of Linux. On all of them, the script correctly detects everything
    that it’s supposed to detect, and correctly chooses whether to run either `dialog`
    or `Xdialog`.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s something that caused me a bit of consternation. I accidentally found
    out that the order in which you test for things sometimes matters. In the `if..then`
    construct of this script, I originally checked for the value of `DISPLAY` first,
    and then checked for the exit code of the `command` command. The script wouldn’t
    run correctly like that, because the test for the `DISPLAY` value was setting
    the exit code to 0\. When I reversed the order of the tests, everything began
    to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and try running this script on a variety of systems, just to see what
    happens.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s build on what we’ve already done by adding another widget.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can add more functionality by adding more widgets. Take for example the
    `dialog-hello2.sh` script, which you can download from the Github repository.
    I can’t show the entire file at once due to formatting constraints, so I’ll show
    it to you a section at a time. Here’s the top section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve already seen this in the previous script, and I’ve already explained
    it. So, let’s move on. Here’s the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first `$diag` line creates the initial message box in the top left corner,
    as specified by the `--begin 2 2` option. The second `$diag` line creates a box
    with two buttons that are labeled as **Yes** and **No**. The `--begin 4 4` option
    positions the `yesno` box just slightly lower and slightly more to the right of
    where the initial message box was. After `--yesno`, we see the text that we want
    the box to display and the height and width parameters. (Setting the height and
    width to 0 and 0 causes the box to size itself automatically.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have a `case..esac` construct that assigns commands to the two buttons.
    Remember that when clicked, the **Yes** button returns exit code 0, and the **No**
    button returns exit code 1\. Pressing the **Esc** key returns exit code 255\.
    We can use these exit codes to trigger a desired command, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Okay, all this script does is display a message when you press a button. But,
    it does serve to demonstrate the concept, so it’s all good.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve already seen the initial message box, so I won’t show that again. Instead,
    I’ll show the `yesno` box that comes up next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_15](img/B21693_16_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.15: The yesno box'
  prefs: []
  type: TYPE_NORMAL
- en: 'When I click the **Yes** button, I’ll see the appropriate message, as you see
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_16](img/B21693_16_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.16: After clicking on the Yes button'
  prefs: []
  type: TYPE_NORMAL
- en: And of course, this script runs equally well with `xdialog` on a machine that
    supports it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s create something that will actually do some useful work for us.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an SSH Login Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say that you have a fleet of Linux, Unix, or Unix-like servers that you
    need to administer remotely via SSH. Trying to keep track of the server IP addresses
    is a confusing mess, so you’ve decided to simplify things. You’ve decided to create
    the `xdialog-menu-test.sh` to help you out. It’s also too long to show here in
    its entirety, so I’ll break it up into sections. Here’s the top part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same as it was in the previous script, so you already know about
    it. Here’s the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `cmd=` line creates a command within a pair of parentheses, and then assigns
    that command to the `cmd` variable array. This command, which will be invoked
    in the final line of the script, will build either a `dialog` or `xdialog` menu
    window. According to the `dialog` man page, the `--keep-tite` option is desirable
    when running the script in a graphical terminal emulator on a desktop machine,
    because it prevents the script from switching back and forth between the graphical
    terminal and the underlying shell terminal. After the `--menu` option, we see
    the text that is to be displayed, the height and width of the menu box, followed
    by the maximum number of menu entries that will be displayed at a time. (In this
    example, the user would need to scroll down to see past the first 16 menu entries.)
    The menu entries would be designated with a tag and an item string. For example,
    the first menu entry we see has a **1** as the tag, and **Remote SSH to Debian
    miner** as the item.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `options` stanza, which inserts all of the menu entries into
    an array. The `choices=` line uses the `2>&1>` redirection operator to dump the
    contents of the array onto the terminal screen (`/dev/tty`). The `@` in `${options[@]}`
    is a form of variable expansion, because it allows an action to be carried out
    according to which menu item that a user chooses. The `@` represents the index
    number of the array item that corresponds with a menu choice.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 8, Basic Shell Script Construction*, I showed you how to use either
    the `*` or the `@` in place of a specific index number to show all elements in
    an array. In the `cmd=` line, each component of the `$diag --keep-tite --menu
    "Select options:" 22 76 16` command that’s within the parentheses is a separate
    element of the `cmd` array. For this reason, we need to use either the `*` or
    the `@` as the index for the `cmd` array in the `choices=` line at the bottom,
    so that the entire command will get invoked. The same thing is true for the list
    of options that get assigned to the `options` array in the `options=` line, as
    you’ll see in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a menu, we need to make it do something. That comes in the
    next section, which you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is nothing that you haven’t seen before. It’s just a normal `for` loop
    that operates a `case..esac` construct. What is a bit different is that the value
    of the `choices` variable is the index number of the array item that corresponds
    with the chosen menu item. Each of the listed options in the options array consists
    of a number, followed by a complete phrase, such as `1 "Remote SSH to Debian miner"`.
    In this example, the number 1 represents element number 0 of the options array,
    and the following words in the phrase represent elements 1 through 5\. In order
    for the options to properly display in the menu, you’ll have to invoke the array
    with either `*` or `@` in place of the index number. Here’s the complete line
    where that happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Since only one index value is ever assigned to `choices`, the `for` loop exits
    after its first run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that everything is built, let’s see if it works. Here’s how it looks using
    `xdialog` on GhostBSD with the Mate desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_17](img/B21693_16_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.17: The xdialog-menu-test.sh script on GhostBSD'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, here’s the exact same script on Fedora with `dialog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_16_18](img/B21693_16_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.18: The xdialog-menu-test.sh script on Fedora with dialog'
  prefs: []
  type: TYPE_NORMAL
- en: When you choose a menu item, the script will open a remote login prompt in the
    terminal, and then exit. That’s okay, because if you want to connect to multiple
    remote servers at once, you’ll need to open other terminals anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can fancy this script up to make it even more functional. For
    example, you can configure your SSH client to use different profiles or different
    encryption keys for different server sessions, and modify the commands in the
    menu accordingly. Or, you can use this as a template for something else altogether.
    As I keep saying, let your imagination run wild!
  prefs: []
  type: TYPE_NORMAL
- en: All right, I think that this about does it for `yad`, `dialog`, and `xdialog`.
    Let’s wrap up and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, we’ve covered a lot of ground in this chapter, and saw some cool
    stuff. We began with a discussion of `yad`, and how to use it to create graphical
    user interfaces for shell scripts. We then looked at how to use `dialog` to create
    user interfaces for text-mode environments, and `xdialog` for graphical environments.
    As an added bonus, you saw how to create scripts that will run with `xdialog`
    on machines that support it, and `dialog` on machines that don’t.
  prefs: []
  type: TYPE_NORMAL
- en: These actually aren’t the only three utilities that you can use to create user
    interfaces for your scripts. Other choices include `whiptail`, `cdialog`, and
    `zenity`. The good news is that once you’ve learned one, switching to another
    is fairly easy.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can do more with these utilities than I’ve been able to show you here.
    On the other hand, none of these utilities is suitable for creating anything that’s
    really complex. For that, you’ll need to learn a more complex programming language.
    Regardless, if all you need is a simple interface to make things easier for either
    yourself or for your users, these utilities can fill the bill.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at how to run shell scripts with option switches.
    I’ll see you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You want to create a graphical user interface for a shell script that will run
    on a wide variety of Linux, Unix, and Unix-like operating systems. Which of the
    follow utilities would you use for best availability?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`zenity`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cdialog`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`xdialog`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`yad`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following statements is true about this code snippet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It’s good code, and will work just fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It won’t work, because it uses the wrong method to detect if the `Xdialog` executable
    is present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It won’t work, because it’s not possible to detect if a certain executable is
    present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It won’t work, because having the `[[ -n $DISPLAY ]]` test come first ensures
    that `$?` always returns a value of 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dress Up Bash Scripts with YAD: [https://www.linux-magazine.com/Online/Blogs/Productivity-Sauce/Dress-Up-Bash-Scripts-with-YAD](https://www.linux-magazine.com/Online/Blogs/Productivity-Sauce/Dress-Up-Bash-Scripts-with-YAD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'YAD Guide: [https://yad-guide.ingk.se/](https://yad-guide.ingk.se/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to use ncurses widgets in shell scripts on Linux: [https://linuxconfig.org/how-to-use-ncurses-widgets-in-shell-scripts-on-linux](https://linuxconfig.org/how-to-use-ncurses-widgets-in-shell-scripts-on-linux)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Designing Simple front ends with dialog/Xdialog: [https://linuxgazette.net/101/sunil.html](https://linuxgazette.net/101/sunil.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adding dialog boxes to shell scripts: [https://www.linux-magazine.com/Issues/2019/228/Let-s-Dialog](https://www.linux-magazine.com/Issues/2019/228/Let-s-Dialog)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Menu Driven Shell Script - Using Dialog Utility: [http://web.archive.org/web/20120318060251/http://www.bashguru.com/2011/01/menu-driven-shell-script-using-dialog.html](http://web.archive.org/web/20120318060251/http://www.bashguru.com/2011/01/menu-driven-shell-script-using-dialog.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xdialog Documentation: [http://web.mit.edu/outland/share/doc/Xdialog-2.1.2/](http://web.mit.edu/outland/share/doc/Xdialog-2.1.2/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Linux experts, and the author himself.
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10596186092701843.png)'
  prefs: []
  type: TYPE_IMG
