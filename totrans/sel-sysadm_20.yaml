- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Chapter 1*](B16276_01_Final_VK.xhtml#_idTextAnchor018)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important difference is that, with a DAC system, the user has full
    control over who gets which kind of access to the user's data. It is left to the
    discretion of the user, hence the name. With MAC systems, the system administrator
    (or security administrator) defines how accesses are handled and enforced. Access
    is mandated by a policy, and users cannot work around this if the administrator
    does not allow it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Linux has introduced hooks inside its kernel code, which developers can subscribe
    to with their own code. These hooks are part of the **Linux Security Module**
    (**LSM**) framework, an extensible framework that is natively part of the Linux
    kernel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SELinux is one of the MAC technologies that use this LSM framework (and the
    hooks it offers) to provide mandatory access control capabilities to the Linux
    kernel and its applications. Other technologies also exist, including AppArmor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The SELinux subsystem code itself is also made part of the main Linux kernel,
    as are the main other LSM implementations, although this is not a mandatory requirement
    for LSM-capable technologies. It does, however, support the notion that SELinux
    is a well-established, open source technology.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The four fields of an SELinux context are as follows: the SELinux user, the
    SELinux role, the SELinux type, and the sensitivity level (or the sensitivity
    range). The sensitivity level might not always be present: Linux distributions
    might opt to disable support for sensitivities in their policies. In that case,
    the SELinux context will only have the first three fields.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SELinux has the concept of a role, which SELinux types can be associated with.
    As SELinux mostly focuses on the types to handle its enforcement (SELinux is mostly
    a type enforcement system), the role-based access control is implemented by limiting
    the types that a role can be associated with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A user that has a DBA-related role will only be able to interact with the system
    from within DBA-associated types. As that role does not have any associations
    with other types, the user cannot acquire the privileges of these other types
    either.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While there is a project called the reference policy, most Linux distributions
    will deviate from this policy for several reasons. The main reason why no single
    SELinux policy exists is because SELinux is a fine-grained system, and thus can
    be tweaked and adjusted to fit the design and usage principles of a Linux distribution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Asking why no single SELinux policy exists for all Linux distributions is almost
    the same as asking why there are multiple Linux distributions. Each distribution
    has its own focus, design, principles, and decisions behind it, and the SELinux
    policy needs to be aligned with these in order to be successful.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[*Chapter 2*](B16276_02_Final_VK.xhtml#_idTextAnchor045)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Administrators should first analyze the situation to see why a problem is being
    triggered. Perhaps the problem is due to an incorrectly assigned context, or the
    process has not been started using the correct methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the denial itself were to be allowed, administrators should create an update
    to the SELinux policy (just like they would update firewall rules as required).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If this is not feasible, then administrators should consider putting SELinux
    in permissive mode, but only for that particular application that is causing problems.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If that is also not feasible, then administrators should put the system in permissive
    mode, but making sure that this is accepted by the organization and security principles
    of the environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Only if even this is not feasible or solves the problem should an administrator
    shake their head, curse the higher powers, and disable SELinux.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the system has the audit daemon running, then SELinux logging will be part
    of the audit logs. They can be displayed using tools such as `ausearch`, or read
    directly from the system at `/var/log/audit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no audit daemon is running, then the SELinux log events will be picked up
    by the system logger or be available through the kernel ring buffer. The kernel
    ring buffer can be read using the `dmesg` command. If the system logger is picking
    up the events, they will most likely reside in `/var/log/messages`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Applications that actively query the SELinux policy or SELinux system will
    link with the `libselinux` library. If that is the case, then this can be seen
    using `readelf`, `ldd,` or `objdump`, showing that `/lib64/libselinux.so.1` (or
    similar) is used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The AVC, or Access Vector Cache, is a cache that contains the recent and most
    frequently used enforcement checks, allowing the SELinux subsystem to query more
    rapidly whether an action can be granted. Without the AVC, the SELinux subsystem
    would need to go through the entire policy over and over again for each action
    that is taken on the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suffice to say that this would slow down the system tremendously.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: No, there are a couple of other log events that administrators should look out
    for when specifically dealing with SELinux. One is `USER_AVC`, which is used for
    AVC-like events, but triggered from an application that uses the SELinux policy,
    and does the enforcements itself (rather than through the Linux kernel). The other
    one is `SELINUX_ERR`, which is used when an internal error or violation is triggered
    that is not related to regular type enforcement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other event types that are closely related, but are not exclusive to SELinux,
    exist as well. For instance, `MAC_POLICY_LOAD`, `MAC_POLICY_CHANGE`, and `MAC_STATUS`
    are events that are triggered whenever a MAC system state or policy is changed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B16276_03_Final_VK.xhtml#_idTextAnchor071)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an intermediate step needed to associate a role with a Linux account,
    and that is the SELinux user. A Linux account (or login) is mapped to an SELinux
    user. The SELinux user is then mapped to one or more SELinux roles that that SELinux
    user can be in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we want to assign an additional role to a Linux user, we need to add it to
    the SELinux role that that Linux account is mapped to. However, if more Linux
    accounts are mapped to the same SELinux user, then we first need to make sure
    that all these accounts are indeed allowed to use this role. If not, a dedicated
    SELinux user has to be created for the Linux account.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Yes, the mappings are considered when a user logs in through a particular service.
    It is possible for administrators to tune the mappings to be dependent on the
    service, as seen in the *Customizing logins toward services* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most SELinux domains do not allow the SELinux user of a context to be changed.
    This allows the tracking of activities based on the SELinux user, even when the
    regular Linux user has changed their user ID. Note that this is not exclusive
    to SELinux, however. Linux does support a distinction between the real user ID
    (which stays static as much as possible) and the effective user ID (which can
    change, for instance, when executing a setuid application).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SELinux users also allow granularity as regards the SELinux policy, for instance,
    when using user-based access control. In that case, SELinux users cannot access
    resources that are owned by a different SELinux user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PAM is a flexible, modular system that Linux uses to authenticate users. Rather
    than having all the different technologies and services on a system implement
    authentication over and over again, they use PAM to handle the authentication
    flow. Administrators only then need to focus on PAM or PAM-related configurations
    to ensure that their systems are properly accessed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For SELinux, PAM is needed to allow the authentication to check the mappings
    (between Linux users and SELinux users), which is supported through `pam_selinux.so`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B16276_04_Final_VK.xhtml#_idTextAnchor095)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common option is -Z, and is supported by tools such as ls, mv, and
    ps. The same character is also used by systemd's tmpfiles application to explicitly
    set SELinux contexts on resources. However, while this is the most commonly used
    option, not all tools follow this convention, so we recommend to always consult
    the tool's help or manual page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In most cases, the context is stored as an extended attribute of the file or
    directory within the filesystem. This extended attribute is the `security.selinux`
    attribute, and can be queried with tools such as `getfattr` or `stat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, not all filesystems support extended attributes. In that case, the
    SELinux context is obtained through the mount options of that filesystem, and
    all resources on the filesystem then use the same context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `chcon` application directly alters the SELinux context for a file, but
    does not adjust the system's file context definitions. If, at any point in time,
    the system or an administrator relabels the file or the entire filesystem (which
    is a common remediation for SELinux issues), then the SELinux context of the file
    is changed back.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hence, `chcon` is only recommended for transient SELinux context changes or
    to validate whether a context change solves an issue. Once confident that the
    new context is needed, it should be registered in the system's file context definition
    through `semanage fcontext`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Yes. While SELinux's tools have the concept of *most specific rule wins* for
    the context definitions provided by the Linux distribution, this concept does
    not apply to file context definitions that are local to the system (in other words,
    executed by the system administrator).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For locally defined file context definitions, the first rule that matches a
    patch will be used, regardless of the context definitions that follow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you only want to relabel a selected set of files, such as recursive applications
    to a given directory, the `restorecon` command should be used. If the entire filesystem
    needs to be relabeled, either use `fixfiles` (CentOS and related distributions)
    or `rlpkg` (Gentoo).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another method is to create an empty file called `/.autorelabel` and reboot
    the system. The system will detect this file, relabel the entire filesystem, remove
    this file, and then reboot again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The source domain needs the transition privilege vis-à-vis the target domain.
    It also requires the execute privilege on the executable file. This executable
    file has to be marked as an entry point for the target domain. Finally, the role
    for which a transition is to occur has to have the target domain as an allowed
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiple SELinux types can be assigned an SELinux attribute, and the SELinux
    policy can then use this attribute as a source or target for its rules. Such attribute-based
    rules then automatically apply to all types assigned from this attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B16276_05_Final_VK.xhtml#_idTextAnchor138)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The command to apply a type to a TCP port is created with `semanage`. For instance,
    to apply the `ssh_port_t` type to TCP port `10122`, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the port is part of an unreserved range, then it can be altered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: No, SECMARK is local to the system. Once a network packet is received by the
    Linux host, the SECMARK rules will associate a label with that network packet,
    but this label is only retained in memory on the system itself. Once a packet
    leaves the Linux system, it will not show any trace of SECMARK labeling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The subcommands used by `semanage` are `ibendport` (to apply a label or sensitivity
    to an InfiniBand network port) and `ibpkey` (to apply a label or sensitivity to
    a partition key).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While labeled IPsec itself does not require specialized equipment, it does require
    all participating hosts to have the same view on what each label implies. This
    means that all hosts, in the case of SELinux-based labeling, need to have SELinux
    active, and preferably with exactly the same SELinux policy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B16276_06_Final_VK.xhtml#_idTextAnchor174)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible (using `setype` within the file module) and Puppet (using `seltype`
    in its file module) are the only two tools that have native support for explicitly
    setting SELinux contexts on resources. However, Chef will automatically relabel
    resources according to the defined file context rules, but you cannot natively
    override this behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Except for SaltStack, all orchestration tools have support for community-built
    and community-supported modules that extend native support of the tools. Ansible's
    Galaxy, Puppet's Forge, and Chef's Supermarket are the main communities for these
    customizations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All orchestration tools (including SaltStack) are flexible enough to use commands
    and simple checks to check state and make changes, effectively allowing administrators
    to customize the definitions to their liking.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All tools have their own view and design on how they approach things. Ansible,
    for instance, pushes its changes to the remote nodes, whereas the others generally
    use remote agents to connect to the central system to obtain the latest changes.
    SaltStack even supports both approaches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While all tools have some SELinux support included, some have many more SELinux
    features enabled out of the box than others. Luckily, through the use of the community-supported
    additions (modules), the SELinux support for almost all of the orchestration tools
    can easily be augmented.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B16276_07_Final_VK.xhtml#_idTextAnchor216)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The unit files in `/usr/lib/systemd/system` are managed by the Linux distribution
    itself. Whenever a new update to the software is deployed on the system, these
    files are overwritten.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modifications to unit files should be placed in `/etc/systemd/system` instead,
    as they overrule the settings in `/usr/lib/systemd`, and software deployments
    should not place any of their unit files in that location.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The application is tmpfiles, and is part of the systemd suite. To have it reset
    a context, a configuration file has to be created (in `/etc/tmpfiles.d` for locally
    defined changes) and use the `z` directive (to reset the context of a single file)
    or the `Z` directive (to recursively set the context of an entire directory).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `journalctl` command allows filtering on variables that it obtained from
    the event itself. One of these variables is the SELinux context of the service
    that generated the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the SELinux policy itself does not have a proper named file transition rule
    in place (which would automatically have the node created with the correct SELinux
    context), then you can tell udev to do this for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: No. The SELinux policy is only checked by D-Bus if the D-Bus policy file itself
    refers to an SELinux context (using the `busconfig` > `selinux` > `associate`
    XML entities). If no SELinux mapping is defined in the policy, then D-Bus cannot
    know which association to validate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is unlike the message flows, however, which are immediately governed by
    D-Bus through the SELinux policy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Apache can be made SELinux-aware because it has a modular design, and allows
    third-party modules to be applied to its own environment. While no SELinux support
    is enabled within the core Apache code, additional modules (such as `mod_selinux`)
    can be added that do enable SELinux support.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B16276_08_Final_VK.xhtml#_idTextAnchor237)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is, although it is not natively enabled. SEPostgreSQL is offered through
    one of the additionally supplied modules within PostgreSQL called `sepgsql`. As
    such, it is part of the default technology, but not enabled by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the `sepgsql` module requires a session context, the PostgreSQL database
    needs to either only be accessed from the local system (using the Unix domain
    sockets), or labeled networking needs to be enabled and set up in the network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without labeled networking, any remote connection to the database will fail
    to provide any context information, and `sepgsql` will refuse the connection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When a database object is created in PostgreSQL, it will automatically receive
    an SELinux label. Administrators or database owners can change the labels using
    the `SECURITY LABEL` statement in PostgreSQL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `sepgsql` module does not interact with the Linux audit subsystem, relying
    instead on the logging capabilities and interface used by PostgreSQL. As a result,
    any decision logging that `sepgsql` does will be found in the PostgreSQL system
    logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B16276_09_Final_VK.xhtml#_idTextAnchor257)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The unique idea that sVirt has that differentiates it from a more standard SELinux
    configuration is to use SELinux's MCS support to the next level. By randomly assigning
    two categories to a guest, sVirt can deal with isolating thousands of guests even
    when far fewer categories are available to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The two main security measures that SELinux implements on top of the virtualization
    layer are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- Intra-guest isolation, ensuring that guests cannot attack one another, or
    leak information between guests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Guest/host isolation, ensuring that guests can only access and interact with
    the resources on the host that are needed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While both are, of course, also implemented within the hypervisor code, any
    design flaw could lead to high-impact problems. By implementing these isolations
    within SELinux, we use the strength of the SELinux subsystem as an independent
    (and much more flexible) access control system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `virt_image_t` label is used for guest images when the guest is not running.
    Once it is running, the image is relabeled to `svirt_image_t` and assigned the
    correct set of categories. The `virt_content_t` label, on the other hand, is used
    for read-only media, such as CD images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The labels can be changed by editing the guest''s XML information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Vagrant, by default, does not have support for sVirt, but thanks to its plugin
    model, we can install the libvirt plugin for Vagrant. Once installed, Vagrant
    will use libvirt as its virtualization layer, automatically allowing us to use
    sVirt with Vagrant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B16276_10_Final_VK.xhtml#_idTextAnchor279)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SELinux works within the Linux kernel. Xen, however, is a hypervisor that sits
    between the hardware and the operating systems and does not use a full operating
    system as its base (unlike, for instance, QEMU and KVM).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we interact with Xen through Linux, we are actually interacting with Xen
    through the dom0 guest. Within this guest, SELinux can be running (and we even
    recommend it), but SELinux will remain within the virtualized guest.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Xen, however, copied the SELinux approach and implemented it in its Xen Security
    Module framework.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can assign a label to a Xen guest by editing its configuration file (inside
    `/etc/xen`) and adding the `seclabel` parameter, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will need to relaunch the guest for the changes to take effect. Once the
    guest is booted again (using `xl create`), you can see its active label using
    `xl list -Z`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What are the common Xen commands that deal with XSM labels?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The common commands to use are the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- With `xl list -Z`, we can list the guests and their currently assigned labels.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- With `xl getenforce`, we can query the current enforcement state of XSM.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- With `xl setenforce`, we can set the new enforcement state of XSM.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- With `xl dmesg`, we can see the Xen logging, including the XSM AVC log entries.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- With `flask-get-bool`, we can query the current XSM-FLASK Booleans and their
    values.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- With `flask-set-bool`, we can set a new value for an XSM-FLASK Boolean.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- With `flask-label-pci`, we can assign a new XSM-FLASK type to a PCI device.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can also use SELinux tools that can analyze a policy file, such as `seinfo`
    or `sesearch`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The command to load a custom policy is `xl loadpolicy`, or `flask-loadpolicy`.
    As long as the new policy file is not put in `/boot` to be automatically picked
    up, this loaded policy will only be active until a reboot is done, or until a
    new policy is loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B16276_11_Final_VK.xhtml#_idTextAnchor293)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `machinectl` command does not allow administrators to change the SELinux
    type of the running containers. This results in all containers running by default
    under an unconfined domain, whereas we want confined domains to be used—preferably
    even with sVirt support so that containers cannot influence one another either.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When a container is launched with a location mapping, we should use the `:Z`
    option (in case of a private mapping) or the `:z` option (in case of a shared
    mapping) to ensure that the resources are relabeled with a container-accessible
    SELinux type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Without this option, the label of the resource remains untouched, which generally
    means that the container runtime cannot access the resource at all.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can use the `udica` application to generate a custom policy. The application
    uses the information that is provided from a `podman inspect` (or `docker inspect`)
    command, which shows the current container definition, and builds a custom policy
    specific to that container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The policy, once loaded, can then be used by the container through the `--security-opt`
    argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The main place for SELinux settings is inside the manifest under the `spec`
    configuration parameter. There, we can create the `securityContext` definition,
    which supports SELinux options through the `seLinuxOptions` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B16276_12_Final_VK.xhtml#_idTextAnchor312)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When SELinux Booleans are changed through the `/sys/fs/selinux/booleans` filesystem,
    the changes are not automatically committed. For that to occur, you also need
    to write the value `1` into `/sys/fs/selinux/commit_pending_bools`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `sesearch` command is used to query the active policy, and can be used to
    query the impact of SELinux Booleans as well. Add the `-b <boolean>` argument
    to limit the query to rules that are influenced by the SELinux Boolean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When an SELinux policy module is loaded, it is assigned a priority that tells
    the system whether it should be the active module. Administrators can load new
    modules at a higher priority to test them out, and remove them again, without
    risking that no proper SELinux rules are active on the system at all.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Likewise, administrators can load a policy at a lower priority, ensuring that
    it is not yet active, and later on remove the module at the higher priority so
    that the newly loaded policy becomes active.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is unlike enabling or disabling modules, which affects all priorities.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The SELinux utility `audit2allow` transforms all SELinux-related audit events
    into SELinux policy code. The code can use both the legacy style (using `-M`)
    or the reference policy style (using `-R -M`). Regardless of the style chosen,
    a loadable SELinux policy module (with the suffix `.pp`) will be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[*Chapter 13*](B16276_13_Final_VK.xhtml#_idTextAnchor330)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `seinfo` application is used to query the policy for its type content, but
    not for its rules. For instance, you list the types within the policy with `seinfo`,
    but you don't query what these types can do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `sesearch` application, on the other hand, is used to query the rules within
    the policy, but does not reveal anything about the various definitions inside
    the policy that are not really rules (such as attribute definitions and supported
    classes).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hence, the main difference is that `seinfo` focuses on the structure of the
    policy, whereas `sesearch` focuses on the enforcements defined within the policy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reaching a domain implies domain transitions. Hence, what we are looking for
    is how you can transition from your current domain (say `staff_t`) to the target
    domain (say `unconfined_t`) and through which means—generally, this is done by
    executing a binary or script that triggers a type transition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyzing domain transitions can be done using `apol` (the graphical user interface),
    `sedta`, or `sepolicy transition`. However, the latter might not reveal the correct
    paths, so it is recommended to use `sedta` or `apol` for this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Information flow analysis has to take up considerably more paths than a domain
    transition. Domain transitions are between process domains, and only a small number
    of actions can trigger a transition. Information flow, on the other hand, can
    be effected over many, many actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Such analysis not only needs to consider read and write statements, but also
    file descriptor usage, socket usage, signaling, the locking and unlocking of resources,
    and more besides. As a result, information flow analysis uses permission maps
    to identify the various permissions to check, and how important (weight) a permission
    is for an information flow analysis session.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Not using the tools currently at hand. The tool that compares policies, `sediff`,
    shows the differences between the policies, but is not, by itself, capable of
    generating SELinux policies that contain the differences between policies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Furthermore, SELinux policy modules can only add additional rules to the active
    policy, not remove them. Hence, even if `sediff` generated compatible output,
    it would still not be able to generate any statements that would remove existing
    rules from the active policy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B16276_14_Final_VK.xhtml#_idTextAnchor354)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An unconfined domain is still fully controlled and enforced by SELinux. It is
    called unconfined because such domains are granted extensive privileges by the
    SELinux policy. However, unlike what the name implies, they are still somewhat
    confined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Permissive domains, on the contrary, are not confined. SELinux will only log
    violations against the policy, but it will not enforce them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The SELinux sandbox utility can be used to run applications in a very restricted
    domain. The utility will both force the application to run in a very restricted
    domain (`sandbox_t` for regular, non-graphical end user applications, or `sandbox_xserver_t`
    for graphical applications), as well as isolate or hide access to other system
    resources through the use of Linux's namespaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the init system (such as systemd) launches a daemon, it will execute a
    specific binary or script for it. The label of this binary or script will generally
    define the target domain. For instance, if the resource is labeled with `bin_t`,
    then systemd will make sure that the target service runs as `unconfined_service_t`.
    If it is labeled with `postgresql_exec_t`, then the target service will run with
    the `postgresql_t` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While other permissions are also involved (such as the source context requiring
    transition permissions to the target), unless we are building a new policy from
    scratch, switching domains will be as simple as changing the label for its executable
    resource, and relabeling its main locations on the filesystem (such as log locations
    and runtime information).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The default skeleton application that `sepolicy generate` builds contains the
    `permissive` statement, which implies that the policy will run in a permissive
    mode. Since this means SELinux will not enforce any controls, it is very likely
    that the application will work flawlessly with this policy enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That is, however, not the target state, and administrators will need to remove
    the `permissive` setting from the policy and adjust as needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B16276_15_Final_VK.xhtml#_idTextAnchor373)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many Linux distributions add services and tools that fit the distribution's
    purpose and principles, yet which might be contradictory to what the reference
    policy is about. For instance, Red Hat Enterprise Linux and its derived Linux
    distributions will enable unconfined domains for many applications, whereas the
    reference policy will strive toward confinement of all applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, many Linux distributions base their policy on the reference policy,
    but augment and adjust it for their specific purpose.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The three main policy files are the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- A type enforcement file, with the suffix `.te`, which contains the rules
    for the SELinux policy module, focusing on its owned domains.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- An interface file, with the suffix `.if`, which exposes the interaction patterns
    and privileges vis-à-vis the domains and resources owned by this SELinux policy
    module. These interfaces are then used by other SELinux policy modules.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- A context file, with the suffix `.fc`, which contains the file contexts for
    the various paths related to this SELinux policy module.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Policy modules can be created with only a single file. In that case, the build
    system will assume that the other files are empty.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The use of a permission set allows policy developers to easily adjust and extend
    the permission set when needed, without having to change all possible SELinux
    policy module code entries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is especially critical when a new permission is added by Linux (and the
    SELinux subsystem). For instance, suppose that the memory map system call (`map`)
    was not present yet, and is introduced later. We would need to add the map privilege
    to all execute calls. By using permission sets, we can add this to the appropriate
    permission set only.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Interfaces will grant privileges to domains or roles. They do not add or remove
    SELinux objects to the policy. Templates, on the other hand, will generate new
    SELinux types, roles, Booleans, or other objects. As a consequence, templates
    are not allowed to be called from within any Boolean-triggered block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The database administration role does not use `userdom_admin_user_template`
    because it is not a system-wide administration role, but very specific to databases.
    `userdom_admin_user_template` would grant the role many more privileges than are
    needed to administer databases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B16276_16_Final_VK.xhtml#_idTextAnchor391)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The SELinux **Common Intermediate Language** (**CIL**) is not an extension
    to SELinux that can be easily removed. It is at the heart of SELinux policy development
    and support, although mainly under the hood: all SELinux policy modules that are
    loaded on the system are first converted into CIL before actually being loaded
    in memory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CIL format is the only format used to interact with the Linux kernel and
    the SELinux subsystem. Because it is used as part of the SELinux user space utilities,
    it is not always as obvious to administrators or developers, but it is definitely
    a core component within SELinux.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: No, it is not mandatory, but is recommended. The attribute is used to refer
    to types and roles in a modular fashion, and to ensure that these references are
    valid. CIL internally requires types and roles to be defined before they are used,
    and without using an attribute to force such declarations, the order of loading
    modules might result in failures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While other attributes could be declared for this purpose, or other means introduced,
    the use of the `cil_gen_require` attribute is supported through the SELinux user
    space utilities. As such, aligning with this practice is recommended.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With CIL, developers can create additional port mappings, declaring a new type
    and assigning it to an available port. With other SELinux language styles, this
    is only possible when rebuilding the entire policy rather than through the modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another example is to introduce constraints. SELinux constraints are not supported
    to be loaded in SELinux modules using other language styles. However, while constraints
    are a powerful construct within SELinux, they can be confusing for administrators
    as constraint-related failures do not result in obvious messages, and administrators
    who query the current policy for allow rules may notice that allow rules exist
    even though things still fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CIL supports macros, which are made part of the SELinux module (and the namespace),
    and which can be called using the `call` statement from elsewhere in the SELinux
    policy. We can create macros as part of a module to be similar to interfaces in
    reference policy, while creating macros as part of the global namespace to be
    similar to the support macros in reference policy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
