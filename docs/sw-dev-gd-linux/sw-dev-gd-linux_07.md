

# 用户和组

在本章中，我们将研究 Linux 用来管理资源和维护安全的两个构建块：用户和组。在学习了基础知识并介绍了一个特殊的用户 `root` 后，我们将展示 Linux 用户组概念是如何在用户抽象之上添加一个方便的层次。

一旦我们涵盖了必要的理论，你将直接进入实际命令的讲解，学习如何创建和修改用户与组。而且，若在面试中遇到类似问题，你将能够亲眼看到 *一个 Linux 用户究竟是什么构成的*（提示：其实它仅由三行纯文本组成）。

在本章结束时，你将：

+   理解用户是什么以及他们的用途

+   理解 root 用户与普通用户之间的区别，以及如何在需要时切换它们

+   了解如何创建和修改用户和组

+   深入了解用户元数据，看看一个 Linux 用户究竟是什么构成的

# 什么是用户？

在 Unix 系统的上下文中，用户只是一个可以在系统上执行操作的命名实体。用户可以启动和拥有进程、拥有文件和目录，并对它们拥有各种权限，可以被允许或禁止在系统上执行某些操作或使用资源。实际上，用户就是你登录时使用的身份，进程以该身份运行，或文件的所有者。

“用户”一词显然是指具有用户账户、密码等的真实人的隐喻。但是，实际上，大多数在系统中的“用户”并不代表特定的人类。他们是机器账户，目的是为了安全或组织上的需求，将进程和文件等资源进行分组。

但是，比账户是否打算由人工操作员交互使用更为重要的区别是：用户实际上分为两种类型，在我们开始讲解实际的用户管理技能之前，必须先讨论这个区别。

# Root 与其他用户

这个世界有时会很严苛，有时运行某些命令是危险的。例如，`fdisk` 可能会清除磁盘的分区或以其他方式修改硬件。`iptables` 可以打开一个网络端口，允许攻击者利用漏洞。即使是使用一个无害的 `echo` 命令将值发送到文件系统的错误位置，也可能会以微妙且可怕的方式改变操作系统的配置。

为了防止这种情况，运行命令行界面的类 Unix 环境中有一些内建的防护措施。每个 Unix 系统中都有一个“超级用户”叫做 `root`。因此，基本的安全模型如下：

+   首先是 `root`。这个用户相当于其他系统中的系统管理员，是具有最高权限的用户。`root` 几乎可以做任何事。

+   然后是其他所有人。非 root 用户的权限是有限的——他们不能启动可能影响整个系统的进程或编辑文件，但他们可以启动自己的（无特权）应用程序并编辑自己的文件。

为了防止出现问题，只有`root`用户才能执行改变系统重要部分的命令。因为即使是看似无害的命令，如果使用正确的参数，也可能造成潜在的破坏，所以你可能需要 root 权限来编辑一个文本文件。

# sudo

由于每次你想做一些可能对系统有危险的操作时都必须以不同的用户身份登录会很麻烦，因此有了`sudo`命令。在命令前加上`sudo`（代表“替代用户并执行”），可以让你*以 root 用户身份*执行该命令。当该命令执行完并退出后，下一个命令会再次作为你的普通（非 root）用户来解释。

你可以通过运行两个命令亲自观察这种行为。首先，运行`whoami`命令，这是一个打印当前用户的命令：

```
whoami 
```

在这种情况下，我以“`dave`”用户登录，所以这个命令会输出：

```
dave 
```

现在，在那个命令前加上“`sudo`”：

```
sudo whoami 
```

即使你仍然以非 root 用户登录，*有效的*用户 ID 在单个命令执行期间已经改变，因为使用了`sudo`：

```
root 
```

让我们看一个更实际的例子，假设我们想以`root`身份运行一个单独的操作，但之后继续以普通用户身份运行其他命令：

```
sudo systemctl start nginx
<go back to doing regular-user stuff> 
```

第一个命令启动了`nginx` web 服务器（假设已安装 nginx 包），这是只有 root 才能执行的操作。之后的任何命令都会再次作为普通用户执行。

这是一个常见的工作流，确保系统安全——你大部分时间作为普通用户工作，无法在单个命令中破坏整个系统。当你需要 root 权限时，只需在*需要的命令前加上*root。这是一个很好的心理屏障，防止在系统中不小心破坏东西。

你会看到这种模式在系统中用于各种可能有危险的操作，例如编辑系统级配置文件、创建用户家目录之外的目录（本章后面会涉及），等等：

+   `sudo mkdir /var/log/foobar`

+   `sudo vim /etc/hosts`

+   `sudo mount /dev/sdb1`

如果你计划以 root 身份运行多个命令（或者你正在故障排除某些以 root 身份运行的程序，或者模拟`cloud-init`脚本执行的环境），你可以使用`sudo`来获得一个长时间存在的 root shell 会话：

```
sudo -i 
```

这将为你提供一个作为 root 用户的*交互式* shell 会话。小心使用！没有任何东西能阻止你因一个错误或输入错误的命令而破坏系统。

虽然 sudo 默认将当前用户替换为 root 用户，但你也可以通过`–u`选项将其更改为其他用户。例如：

```
sudo –u myuser vim /home/myuser/.bashrc 
```

这将以用户`myuser`的身份在 vim 中打开`/home/myuser/.bashrc`。

哪个用户（或用户组）被允许执行哪些操作，可以在`/etc/sudo.conf`中定义。你永远不应该直接编辑这个文件；应该使用`visudo`命令来修改该文件。

# 什么是组？

组是一个额外的原语，允许一组用户共享权限。组常用于获得权限集或配置文件的功能。例如，在 Linux 中，通常有一个叫做`sudoers`的组，而在 macOS 中，你会遇到一个叫做`wheel`的组。根据惯例，系统中属于`sudoers`或`wheel`组的用户被允许使用`sudo`以 root 身份执行命令。这与在 Windows 中将用户添加到`Administrators`组功能上是相同的。

你可以推断出，如果组对于管理谁可以运行`sudo`命令很有用，那么它们也可能对于将用户分组并管理其他类型的权限非常有用。

# 小项目：用户和组管理

例如，假设我们希望允许公司中的每个软件开发人员都能读取某个特定文件——我们称它为`document.txt`。我们可以简单地创建一个`developers`组，并将所有开发人员用户添加到该组。

然后，在设置`document.txt`的所有权和权限时，我们可以引用`developers`组，而不是试图跟踪每一个可能是该组成员的单个用户。

## 创建用户

在安装了`adduser`命令的 Linux 系统上，你可以使用它*交互式*地创建一个名为`dave`的用户。如果没有，你通常会看到名为`useradd`的包（有关安装包的更多详细信息，请参见*第九章*，*管理已安装的软件*）。

只使用用户名作为唯一参数运行命令将为你提供一个向导式的用户创建过程。请注意，我们在这里使用了`sudo`，因为只有`root`用户可以添加或删除用户：

```
**$ sudo adduser steve**
Adding user `steve' ...
Adding new group `steve' (1000) ...
Adding new user `steve' (1000) with group `steve' ...
Creating home directory `/home/steve' ...
Copying files from `/etc/skel' ...
**New password:**
**Retype new password:**
passwd: password updated successfully
Changing the user information for steve
Enter the new value, or press ENTER for the default
**Full Name []: Steve**
Room Number []:
Work Phone []:
Home Phone []:
Other []:
**Is the information correct? [Y/n] y** 
```

我们已经将需要用户互动的部分加粗——即设置密码、全名以及确认我们要在系统中创建该用户。

这种方式适合添加一两个用户，但如果你正在处理一个 Linux 测试服务器，需要为你 300 个最大客户创建单独的帐户呢？那时你会想要使用非交互式的`useradd`命令，它允许你将用户属性作为参数传递给一个命令。这使得用户变更变得容易脚本化（请参见本章稍后的脚本化说明）：

```
useradd --home-dir /home/dave --create-home --shell /bin/zsh -g dave -G sudoers dave 
```

该命令还会：

+   设置并创建用户的主目录（`--home-dir`和`--create-home`）。

+   设置自定义的 shell（`--shell`）

+   使用`-g`选项将用户的主组设置为`dave`（虽然这也可以是像`employees`这样的组）。

+   将附加的用户组成员身份添加到`sudoers`组（你可以在此传递多个以逗号分隔的组名）。

就是这样——如果命令成功退出，你的新用户已经创建！

但我们还没有完成——这个用户将要在新的、绝密的 `tutorialinux` 应用程序上工作，所以让我们为这个项目创建一个组，并将新用户添加到其中。

## 创建一个组

要创建一个名为 `tutorialinux` 的新组，你可以使用 `groupadd` 命令：

```
groupadd tutorialinux 
```

这会在系统上创建一个新组，并向 `/etc/group` 配置文件中添加一行，该文件记录了 Unix 系统上所有存在的组。你可以通过在该文件中“grep”（搜索）组名来验证该组是否已创建：

```
# grep tutorialinux /etc/group
tutorialinux:x:1001: 
```

你可以看到，名称为 `tutorialinux` 的组现在已经存在，其 **组 ID** (**GID**) 为 1001。

我们不打算深入探讨这里的 `x` 字符的含义；只需要知道该文件由每个组的一行组成，每行以冒号分隔的值。你只需关心组名（第一列）、组 ID（第三列）和成员（最后一列，在本例中为空）。

## 修改 Linux 用户

就像 `useradd` 允许你在创建用户时自由设置用户元数据一样，`usermod` 和 `gpasswd` 允许你修改现有用户的所有方面。让我们将之前创建的 `dave` 用户添加到新的 `tutorialinux` 组中，这样他就可以处理只有组成员才能看到或修改的项目文件。

### 将 Linux 用户添加到组

要更改用户的主组：`sudo usermod -g groupname username`

然而，这并不是我们想要的：`dave` 用户应该继续在同名的 `dave` 组中；我们只是希望 `dave` 也能成为 `tutorialinux` 组的成员。要将用户添加到一个组*而不*将其设置为该用户的主组，可以使用 `-aG` 选项（“**添加**到附加的 **组**”）：

```
sudo usermod –aG tutorialinux dave 
```

如果你再次检查 `/etc/group`，你会看到 `dave` 用户现在是三个组的成员：`dave`、`sudoers` 和 `tutorialinux`：

```
grep dave /etc/group
sudoers:x:27:dave
dave:x:1000:
tutorialinux:x:1001:dave 
```

使用你在上一章中学到的命令修改文件的所有权和权限后，你现在可以控制 `tutorialinux` 组所有成员对某些文件和目录的访问权限。

现在，当特定用户完成 `tutorialinux` 项目工作后，你可以清理并撤销他们的访问权限，而无需修改单独的文件和目录权限。

### 从组中删除用户

要将用户从组中移除，我们可以使用 `gpasswd` 命令，如下所示：

```
gpasswd –delete username groupname 
```

### 删除 Linux 用户

要完全删除一个 Linux 用户，使用 `userdel` 命令：

```
userdel -r account_name 
```

如果你希望保留该用户的主目录，请省略 (`-r` / `--remove`) 标志。

### 删除一个 Linux 组

对于不再需要的组，还有一个 `groupdel` 命令：

```
groupdel groupname 
```

# 高级内容：用户究竟是什么？

用户和组是 Unix 和 Linux 中非常清楚地展示了一些非常棒的特性的地方：这里几乎没有什么魔法。

一个 Linux 用户实际上就是一个 **用户 ID**（**UID**），它是用户的简单数字表示（一个无符号的 32 位整数）。`root` 用户的 UID 是 0。所有其他用户的 UID 都大于 0。组也是如此。

这些信息并不是存储在某个秘密位置、某种二进制格式中，或者某个只有操作系统能够操作的专有数据结构里：用户和组是定义在纯文本文件中的，这些文件通常是通过我们在这里介绍的几个简单命令进行修改的。

这种简单性和缺乏神秘感意味着普通人（例如，一个慌乱的开发者，记忆仅能模糊回忆本章内容）可以快速了解正在运行的系统中用户和组的状态，解决可能由于主机环境准备不当导致的应用错误，特别是缺少必要应用用户的情况。这在开发者面试中的“系统工程”部分也很有帮助。

因此，为了加深你对这些内容如何工作的直观理解，下面是一些关于创建和管理用户与组时，系统底层运作的有用信息。

## 用户元数据 / 属性

仅通过数字定义的用户并不是特别有用——没有一些附加的元数据来增强其功能。例如，我在 Linux 或 macOS 机器上用于日常工作的账户，假设它的 UID 为 `502`，可能还会有：

+   一个友好的登录名（`dave`）

+   它自己的组（`dave` 组）

+   各种组成员身份（`staff`、`developer`、`wheel`）

+   一个登录 shell（`bash`、`zsh` 等）

+   一个主目录（在 macOS 上是 `/Users/dave/`，在 Linux 上是 `/home/dave/`）

如果你感到好奇，可以通过运行 `id` 命令来获取当前用户的信息：

```
# id
uid=0(root) gid=0(root) groups=0(root) 
```

默认情况下，几个文件定义并包含所有这些额外的用户信息：

+   `/etc/passwd` 包含一个用户名、UID、GID、主目录和登录 shell，每个用户一行，以冒号分隔：

    ```
    root@localhost:~# cat /etc/passwd
    root:x:0:0:root:/root:/bin/bash
    daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
    bin:x:2:2:bin:/bin:/usr/sbin/nologin
    sys:x:3:3:sys:/dev:/usr/sbin/nologin
    sync:x:4:65534:sync:/bin:/bin/sync 
    ```

+   `/etc/shadow` 包含用户的哈希加盐密码；该文件仅对 root 用户可读：

    ```
    root@localhost:~# cat /etc/shadow
    root:$6$SPevRPxD94AYwtmF$IOp9k15dnaN8FW8RUpDDQlifLPp9pJ3btgJcMfI
    QEs1kT.ZNjDfX66XBOcPOBZzkRcGOb3Rwq6qTsDQ0jiZNh/:19251:0:99999:7:::
    daemon:*:19251:0:99999:7:::
    bin:*:19251:0:99999:7:::
    sys:*:19251:0:99999:7:::
    sync:*:19251:0:99999:7::: 
    ```

+   `/etc/group` – 与 `/etc/passwd` 相似，但它是为组而非用户提供的。你在本章前面已经看到并使用过这个文件。

可选的主目录，如 `/home/dave`

```
# /etc/passwd username:password:UID:GID:comment:home:shell 
```

**警告**：虽然了解这些文件的内容很有意义，但你绝对不应该手动编辑这些文件。请使用我们在前面章节中提到的工具来创建、删除或修改系统用户和组。

希望这个快速的理论概述——更准确地说，是构成用户和组的静态纯文本文件——能够让你有所启发。我们不仅希望确保你对这个过程有直观的了解，而且我们希望这一节强调 *这个过程其实非常简单*。这里并没有什么魔法！下次在排查应用程序无法启动，或者用户没有权限查看某个具有特定组所有权权限的文件时，你可以更有信心地确认自己没有遗漏什么。

# 关于脚本化的说明

之前，我们提到过偏好使用像`useradd`这样的可自动化工具，而不是像`adduser`这样的交互式向导工具——即便这些自动化工具稍微复杂一些或者不容易学习。或者你可能会问：“为什么不直接使用图形工具，而是这些难记的 CLI 命令呢？”

本书在讲解过程中，我们希望教会你的一件事是：通常优先使用非交互式命令。

因为这些命令在运行时不依赖于实时的用户输入，它们是可以脚本化的：创建一百个用户几乎和创建一个一样简单。这在处理实际问题时特别有用，比如构建 Docker 镜像、反复准备生产环境，或者为你的云实例编写`cloud-init`设置脚本。

作为开发者，这一点应该深有体会：自动化让事情变得更具可重复性、更安全且更快速。通过学习非交互式命令，你能够将该命令作为更大自动化流程的一部分，而不是需要人工干预、容易出错且耗时的步骤。

# 结论

你刚刚学习了 Linux 如何利用用户和组的抽象来管理和控制系统上的进程、文件和其他资源。同样重要的是，你学习了在真实系统上创建和管理用户和组所需的基本命令。你了解了`root`用户与系统上其他普通用户之间的重要区别。

然后，我们通过一个实际练习，带你创建一个用户，添加一个组到系统，修改该用户，最后清理你创建的所有资源。

最后，我们超越了日常命令，向你展示了背后并没有什么魔法：它们只是定义用户和组的 Unix 系统中的纯文本文件。这是好事；无论你是：

+   创建一个 Docker 镜像以便以特定的非 root 用户身份运行你的应用程序。

+   为你的数据科学团队设置一个长期运行的云实例，带有登录和共享组。

+   尽量减少在本地测试环境中犯错的影响范围。

+   解决基于用户和组的错误，例如，在一个需要 root 用户权限才能打开机密文件或执行系统特权操作的 Web 应用程序上。

在下一章，我们将利用所有这些知识深入探讨 Unix 安全模型是如何运作的，通过查看所有权和权限来实现。

# 在 Discord 上了解更多

要加入本书的 Discord 社区——你可以在这里分享反馈，向作者提问，并了解新版本——请扫描下面的二维码：

[`packt.link/SecNet`](https://packt.link/SecNet)

![](img/QR_Code1768422420210094187.png)
