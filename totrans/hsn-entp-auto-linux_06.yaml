- en: Deployment Methodologies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署方法
- en: So far in this book, we have set the groundwork for a stable foundation for
    your Enterprise Linux environment. We have discussed in detail how to ensure your
    Linux environment lends itself well to automation through standardization and
    how to leverage Ansible and AWX to support you on your automation journey. Before
    we get started on the really detailed technical work in this chapter, we must
    take a look at one final piece of detail—your deployment methodology.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经为您的企业 Linux 环境打下了一个稳定的基础。我们详细讨论了如何通过标准化确保您的 Linux 环境能够很好地支持自动化，以及如何利用
    Ansible 和 AWX 来支持您的自动化之旅。在本章深入探讨更详细的技术工作之前，我们必须审视最后一个细节——您的部署方法。
- en: We have already established a need for a small number of consistent Linux builds
    for your environment. There is now a decision-making process for you to go through—how
    to deploy these builds across your enterprise. Most enterprises have several choices
    available to them, ranging from the easiest—downloading publicly available template
    images—through building their own templates, to perhaps the most complex—building
    from scratch using a pre-boot environment. Alternatively, the best approach might
    be some hybrid of these approaches. In this chapter, we will explore these options
    and understand how to ensure you are selecting the best one for your enterprise
    that supports you in your automation journey and is efficient and easy to implement.
    In subsequent chapters, we will then go into greater technical depth on each approach.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了为您的环境建立少量一致的 Linux 构建的需求。现在，您需要通过一个决策过程——如何将这些构建部署到您的企业中。大多数企业有几种选择，从最简单的——下载公开可用的模板镜像——到构建自己的模板，再到可能最复杂的——使用预启动环境从零开始构建。或者，最好的方法可能是这些方法的某种混合。在本章中，我们将探索这些选项，并了解如何确保您选择最适合您的企业、支持您自动化之旅的高效且易于实施的方法。在后续章节中，我们将深入探讨每种方法的技术细节。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Knowing your environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解您的环境
- en: Keeping builds efficient
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持构建高效
- en: Ensuring consistency across Linux images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保 Linux 镜像的一致性
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have access to a virtualization capable environment
    running Ubuntu 18.04 LTS. Some examples are also performed on CentOS 7\. In either
    of these cases, the examples can be run on either a physical machine (or laptop)
    running one of the aforementioned operating systems, with a process that has virtualization
    extensions enabled, or a virtual machine with nested virtualization enabled.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您可以访问运行 Ubuntu 18.04 LTS 的虚拟化环境。一些示例也在 CentOS 7 上执行。在这两种情况下，示例可以在运行上述操作系统之一的物理机器（或笔记本电脑）上运行，该机器启用了虚拟化扩展，或者在启用了嵌套虚拟化的虚拟机上运行。
- en: Ansible 2.8 is also used later in this chapter and it is assumed you have this
    installed on the Linux host you are using.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面还将使用 Ansible 2.8，假设您已在正在使用的 Linux 主机上安装了该版本。
- en: All example code discussed in this book is available from GitHub at: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中讨论的所有示例代码都可以在 GitHub 上获取：[https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux)。
- en: Knowing your environment
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解您的环境
- en: No two enterprise environments are the same. Some businesses still rely heavily
    on bare-metal servers, whilst others now rely on one of a myriad of virtualization
    or cloud providers (either private or public). Knowing which environments are
    available to you is a key part of the decision-making process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 没有两个企业环境是相同的。一些企业仍然在很大程度上依赖裸金属服务器，而其他企业则依赖于各种虚拟化或云服务提供商（无论是私有还是公有）。了解可用的环境是决策过程中的关键部分。
- en: Let's explore the various environments and the relevant build strategies for
    each.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索各种环境以及每种环境的相关构建策略。
- en: Deploying to bare-metal environments
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到裸金属环境
- en: Bare-metal environments are without a doubt the grandfather of all enterprise
    environments. Before the revolution in virtualization and then cloud technologies
    throughout the 21^(st) century, the only way to build an environment was on bare
    metal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 裸金属环境无疑是所有企业环境的“祖父”。在 21 世纪虚拟化和云技术革命之前，构建环境的唯一方式就是在裸金属上构建。
- en: These days it is unusual to find an entire environment which is run on bare
    metal, though it is common to find ones where certain key components are run on
    physical hardware, especially databases or computational tasks that require certain
    physical hardware assistance (for example, GPU acceleration or hardware random
    number generation).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，找到一个完全运行在裸机上的环境已经不常见，但通常会发现某些关键组件运行在物理硬件上，特别是数据库或需要某些物理硬件辅助的计算任务（例如，GPU 加速或硬件随机数生成）。
- en: When building servers from bare metal, two fundamental approaches are suitable
    in most environments. The first is to build the servers manually using either
    optical media or, more commonly now, a USB drive. This is a slow, interactive
    process that is not repeatable at scale, and hence it is not recommended for any
    environments other than those containing just a handful of physical servers, where
    the requirement to build new machines is minimal and infrequent.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在从裸机构建服务器时，大多数环境下适用两种基本方法。第一种是手动使用光盘或现在更常见的 USB 驱动器构建服务器。这是一个缓慢的交互式过程，无法在大规模上重复，因此不推荐用于除少数物理服务器之外的任何环境，在这些环境中，构建新机器的需求很小且不频繁。
- en: The other most viable option for building at scale in the repeatable, consistent
    manner that we have advocated throughout this book so far is to boot physical
    servers over the network, using a **Pre-eXecution Environment** (**PXE**). This
    involves loading a tiny boot environment from a network server, and then using
    this to load the Linux kernel and associated data. In this manner, it is possible
    to bring up an installation environment without the need for any form of physical
    media. Once the environment is up, we would use an unattended installation method
    to allow the installation to complete without any intervention from the user.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 构建大规模、以我们至今在本书中所提倡的一致且可重复的方式的另一个可行选项，是通过网络启动物理服务器，使用 **预执行环境**（**PXE**）。这涉及从网络服务器加载一个小型的启动环境，然后使用它加载
    Linux 内核和相关数据。通过这种方式，可以在没有任何物理介质的情况下启动安装环境。一旦环境启动，我们将使用无人值守安装方法，使安装在无需用户干预的情况下完成。
- en: We will cover these methods in detail later in this book, as well as repeatable
    techniques for configuring the servers once they are built. In the meantime, however,
    it will suffice to simply state that, for building out physical Linux servers
    in an enterprise, PXE booting coupled with an unattended installation is the route
    that is easiest to automate and will produce the most repeatable results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书稍后将详细介绍这些方法，以及一旦构建好服务器后配置服务器的可重复技术。与此同时，简而言之，对于在企业中构建物理 Linux 服务器，结合 PXE 启动和无人值守安装的方法是最容易自动化并且能产生最可重复结果的途径。
- en: Deploying to traditional virtualization environments
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到传统的虚拟化环境
- en: Traditional virtualization environments are those that predate what we know
    today as cloud environments—that is to say, they are straightforward hypervisors
    on which operating systems are run. Commercial examples such as VMware are common,
    as well as their open source counterparts such as Xen and KVM (and frameworks
    built off of these, such as oVirt).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 传统虚拟化环境是指早于我们今天所知的云环境的那些——也就是说，它们是运行操作系统的简单虚拟机监控程序。像 VMware 这样的商业实例很常见，还有像 Xen
    和 KVM 这样的开源实例（以及基于这些的框架，如 oVirt）。
- en: As these technologies were originally built to supplement traditional physical
    environments, they present several possible options for building out your Enterprise
    Linux estate. For example, most of these platforms support the same network-booting
    capabilities as their bare-metal counterparts, and hence we could actually just
    pretend they are bare metal and continue with a network booting methodology.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些技术最初是为补充传统物理环境而构建的，因此它们为构建您的企业 Linux 系统提供了几种可能的选项。例如，这些平台大多数支持与裸机相同的网络启动功能，因此我们实际上可以假装它们是裸机，并继续使用网络启动方法。
- en: 'However, virtualized environments introduced something that was difficult to
    achieve in physical environments because of the differences in hardware between
    the bare-metal devices on which they all ran—templates. A templated virtual machine
    is quite simply a deployable snapshot of a preconfigured virtual machine. Hence,
    you might build out the perfect CentOS 7 image for your enterprise, integrate
    your monitoring platform, perform all of the security hardening required, and
    then, using tools built into the virtualization platform itself, turn it into
    a template. The following is a screenshot of the CentOS 7 templates in the author''s
    lab environment:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虚拟化环境引入了一些在物理环境中很难实现的功能，因为它们运行的裸金属设备之间存在硬件差异——模板。模板化虚拟机可以简单理解为一个可部署的预配置虚拟机快照。因此，你可以为企业构建完美的
    CentOS 7 镜像，集成监控平台，执行所有所需的安全加固，然后使用虚拟化平台本身内置的工具将其转化为模板。以下是作者实验室环境中 CentOS 7 模板的截图：
- en: '![](img/18a0df96-60ff-4339-b5c5-04bc9318fdf6.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18a0df96-60ff-4339-b5c5-04bc9318fdf6.png)'
- en: Each of these templates is a fully configured CentOS 7 base image ready to be
    deployed, with all pre-deployment work such as removal of SSH host keys completed.
    As a result, all an administrator has to do is to select the appropriate template
    and click on the New VM button—the process will be similar in platforms other
    than RHV, as most mainstream virtualization solutions provide this functionality
    in some guise.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模板都是完全配置好的 CentOS 7 基础镜像，准备好进行部署，并且所有部署前的工作（如删除 SSH 主机密钥）都已经完成。因此，管理员只需选择合适的模板并点击“新建虚拟机”按钮——在除
    RHV 外的大多数平台上，这个过程都类似，因为大多数主流虚拟化解决方案都会提供类似的功能。
- en: Note that, to keep the examples accessible, I have used the GUI as the primary
    process for creating a new VM. Nearly all virtualization and cloud platforms have
    APIs, command-line interfaces, and even Ansible modules that can be used to deploy
    virtual machines, and in an enterprise setting, these would scale far better than
    the GUI itself. Given the wide variety of environments available, this is left
    as an exercise for you to explore.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了保持示例的可访问性，我使用了图形用户界面（GUI）作为创建新虚拟机的主要过程。几乎所有虚拟化和云平台都提供 API、命令行接口，甚至 Ansible
    模块，可以用来部署虚拟机，而在企业环境中，这些方法比 GUI 更适合大规模应用。鉴于环境的多样性，这部分内容留给你自行探索。
- en: This is in itself a fairly straightforward process, but it requires a little
    care and attention. For example, nearly all Linux servers these days have SSH
    turned on, and the SSH daemon on each server has a unique host identification
    key that is used to prevent (amongst other things) man-in-the-middle attacks.
    If you template a preconfigured operating system, you will also template these
    keys, which means a distinct possibility of duplicates across your environment.
    This reduces security quite considerably. It is hence very important to perform
    several steps to prepare your virtual machine before turning it into a template,
    and one such common step is to delete the SSH host keys.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程本身相对简单，但需要一些细心和注意。例如，几乎所有的 Linux 服务器现在都启用了 SSH，每台服务器上的 SSH 守护进程都有一个唯一的主机标识密钥，用来防止（除其他之外）中间人攻击。如果你将一个预配置的操作系统模板化，你也将模板化这些密钥，这就意味着在环境中很可能会出现密钥重复的情况，这会显著降低安全性。因此，在将虚拟机转化为模板之前，执行一些准备步骤非常重要，而其中一个常见的步骤就是删除
    SSH 主机密钥。
- en: Servers created using the PXE method do not suffer from this problem, as they
    are all installed from scratch and hence there are no historic log entries to
    clean up and no duplicate SSH keys.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PXE 方法创建的服务器不会遇到这个问题，因为它们都是从头开始安装的，因此没有历史日志需要清理，也没有重复的 SSH 密钥。
- en: In [Chapter 5](3802fb48-9f14-4a52-98c5-280d381260a4.xhtml), *Using Ansible to
    Build Virtual Machine Templates for Deployment*, we will go into detail on creating
    virtual machine templates suitable for templating using Ansible. Although both
    the PXE boot and template deployment methodologies are equally valid for virtualized
    environments, most people find the templated route to be more efficient and easier
    to manage, and for this reason, I also advocate it (for example, most PXE boot
    environments need to know the MAC address of the network interface used on the
    physical or virtual server being deployed—this is not a necessary step in template
    deployment).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](3802fb48-9f14-4a52-98c5-280d381260a4.xhtml)中，*使用 Ansible 构建虚拟机模板进行部署*，我们将详细讲解如何创建适合使用
    Ansible 模板的虚拟机模板。尽管 PXE 启动和模板部署方法在虚拟化环境中都同样有效，大多数人认为模板化的方式更高效、更易于管理，因此我也推荐这种方法（例如，大多数
    PXE 启动环境需要知道部署的物理或虚拟服务器所使用的网络接口的 MAC 地址——但在模板部署中，这不是必须的步骤）。
- en: Deploying to cloud environments
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到云环境
- en: The most recent incumbent to Enterprise Linux architectures (barring of course
    containers, which is another discussion entirely) is the cloud provisioning environment.
    This might be through a *public cloud* solution such as **Amazon Web Services**
    (**AWS**), Microsoft Azure, **Google Cloud Platform** (**GCP**), or one of the
    myriad of smaller providers that have sprung up in recent years. It might equally
    be through an on-premise solution such as one of the variants of the OpenStack
    project or a proprietary platform.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最近对企业 Linux 架构的最新采用者（当然，容器是另一个完全不同的话题）是云资源配置环境。这可能通过一个*公共云*解决方案来实现，例如**Amazon
    Web Services**（**AWS**）、Microsoft Azure、**Google Cloud Platform**（**GCP**）或近年来涌现出的无数小型服务提供商。也可能是通过一个本地部署的解决方案，如
    OpenStack 项目的某个变体或专有平台。
- en: These cloud environments have radically changed the life cycle of Linux machines
    in the enterprise. Whereas on bare-metal or traditional virtualized architectures,
    Linux machines were cared for, nurtured, and repaired if ever they failed, cloud
    architectures are built on the premise that each machine is more or less expendable,
    and that if it fails, a new one is simply deployed in its place.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些云环境彻底改变了 Linux 机器在企业中的生命周期。在裸机或传统虚拟化架构下，Linux 机器需要被照顾、培育和修复（如果它们发生故障），而云架构的前提是每台机器基本上都是可替代的，如果它失败了，只需要在其位置部署一台新的机器。
- en: As a result, PXE deployment methodologies are not even possible in such environments,
    and instead they rely on pre-built operating system images. These are in essence
    just a template either created by a third-party vendor or prepared by the enterprise.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，PXE 部署方法在这样的环境中甚至不可行，它们依赖于预构建的操作系统镜像。这些本质上只是一个由第三方供应商创建的模板，或者由企业准备的模板。
- en: Whether you go with a commercial provider or build an on-premise OpenStack architecture,
    you will find a catalog of available operating system images for you to choose
    from. Generally, those provided by the cloud provider themselves are trustworthy,
    though depending on your security requirements, you may find those provided by
    external parties suitable as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择商业云提供商，还是搭建本地部署的 OpenStack 架构，你都会找到一个可供选择的操作系统镜像目录。通常，云服务提供商自己提供的镜像是值得信赖的，尽管根据你的安全需求，你也可能发现由外部方提供的镜像同样合适。
- en: 'For example, here is a screenshot of the recommended operating system images
    available for OpenStack:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是 OpenStack 可用的推荐操作系统镜像的截图：
- en: '![](img/27b9c9ea-b59a-4827-a9af-4813deb256ae.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27b9c9ea-b59a-4827-a9af-4813deb256ae.png)'
- en: 'As you can see from the table of contents, most of the major Linux distributions
    are represented here, which immediately saves you the task of building the basic
    operating system itself. The same is true of AWS:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从目录中看到的，几乎所有主要的 Linux 发行版都在此列出，这立即为你节省了构建基本操作系统的任务。AWS 也是如此：
- en: '![](img/d9bef8ae-be67-4214-a11d-793c794ae165.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9bef8ae-be67-4214-a11d-793c794ae165.png)'
- en: In short, if you are using a cloud environment, you will be spoiled for choice
    for base operating system images from which to get started. Even so, it is unlikely
    this choice will be sufficient for all enterprises. For example, using a pre-built,
    cloud-ready image does not negate requirements for things such as enterprise security
    standards, monitoring, or log forwarding agent integration, and a myriad of other
    things that are so important for the enterprise. Before we proceed, it is worth
    noting that you can, of course, create your own images for your chosen cloud platforms.
    In the interests of efficiency though, why re-invent the wheel? If someone has
    already completed this step for you, this is something that you can effectively
    delegate elsewhere.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果你正在使用云环境，你将有很多基础操作系统镜像可供选择，以此开始工作。尽管如此，这种选择不太可能满足所有企业的需求。例如，使用预构建的云环境镜像并不意味着可以忽视企业安全标准、监控或日志转发代理集成等要求，以及许多其他对于企业至关重要的事项。在继续之前，值得注意的是，当然你可以为所选的云平台创建自己的镜像。然而，出于效率考虑，为什么要重新发明轮子？如果有人已经为你完成了这一步，你可以有效地将这项工作委托给别人。
- en: Although most ready-made operating system images are trustworthy, you should
    always exercise caution when selecting a new one, especially if it has been created
    by an author you are unfamiliar with. There is no way to know for sure what the
    image comprises and you should always carry out due diligence when selecting an
    image to work with.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数现成的操作系统镜像是可信的，但在选择一个新镜像时你应该始终保持谨慎，特别是当它是由你不熟悉的作者创建时。我们无法确定该镜像具体包含了什么内容，因此在选择要使用的镜像时，你应该始终进行尽职调查。
- en: Assuming that you do choose to proceed with a pre-made cloud-ready image, the
    post-installation configuration work can all be handled neatly by Ansible. In
    fact, the steps required are almost identical to those required to build templates
    for traditional virtualization platforms, and we shall again cover this process
    in detail a little later in this book.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你确实选择继续使用一个预制的云环境镜像，那么后安装配置工作可以通过 Ansible 整理完成。事实上，所需的步骤与构建传统虚拟化平台模板的步骤几乎相同，我们将在本书稍后的部分再次详细介绍这个过程。
- en: Docker deployments
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 部署
- en: Docker deployments are a special case in our discussion on Linux environments.
    In practical terms, they share a lot in common with cloud environments—Docker
    images are built based upon pre-existing minimal OS images and are often built
    using the native Docker toolchains, though automation with Ansible is entirely
    possible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 部署在我们关于 Linux 环境的讨论中是一个特殊案例。从实际操作来看，它与云环境有很多共同点——Docker 镜像是基于现有的最小化操作系统镜像构建的，通常使用原生
    Docker 工具链构建，尽管完全可以使用 Ansible 实现自动化。
- en: As Docker is a special case, we will not be focusing on it in this book, though
    it is important to note that Docker, being a recent incumbent into the presence
    of Linux in the enterprise, is actually designed around many of the principles
    we have already considered in this book. Let's briefly consider the Dockerfile
    used to create the official nginx container.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Docker 是一个特殊案例，我们不会在本书中深入探讨它，尽管值得注意的是，Docker 作为 Linux 在企业中最近的“新成员”，实际上是围绕本书中已经考虑的许多原则设计的。让我们简要地考虑用于创建官方
    nginx 容器的 Dockerfile。
- en: For those not familiar with Docker, a Dockerfile is a flat text file that contains
    all the directives and commands that are required to build up a container image
    for deployment.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉 Docker 的人来说，Dockerfile 是一个纯文本文件，包含了构建容器镜像所需的所有指令和命令，用于部署。
- en: 'At the time of writing, this file contains the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 截至写作时，该文件包含以下内容：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Although not based on Ansible, we can see the following in the preceding code
    block:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不是基于 Ansible，我们可以在前面的代码块中看到以下内容：
- en: The `FROM` line near the top defines a minimal Ubuntu base image on which to
    perform the rest of the configuration—this can be thought of as your SOE Linux
    image that we have discussed for other platforms.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶部的 `FROM` 行定义了一个最小的 Ubuntu 基础镜像，用于执行其余配置——这可以看作是我们在其他平台讨论的 SOE Linux 镜像。
- en: The `RUN` command then performs the steps necessary to install the `nginx` package
    and perform some housekeeping to keep the image tidy and minimal (reducing space
    requirements and clutter).
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RUN` 命令执行安装 `nginx` 包所需的步骤，并进行一些清理工作，以保持镜像的整洁和简洁（减少空间需求和杂乱）。'
- en: 'The code then continues as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 代码继续如下：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Continuing our analysis of this file, we can see the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 继续分析这个文件，我们可以看到以下内容：
- en: The `VOLUME` line defines which directories from the host filesystem can be
    mounted within the container.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VOLUME` 行定义了哪些来自主机文件系统的目录可以挂载到容器内。'
- en: The `WORKDIR` directive tells Docker which directory to run the `CMD` that follows
    it in—think of it as a boot-time configuration.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WORKDIR` 指令告诉 Docker 容器在哪个目录下运行接下来的 `CMD` ——可以把它看作是启动时的配置。'
- en: The `CMD` line defines the command to run when the container starts—a microcosm
    of the process of defining which services will start at boot time in a full Linux
    system image.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMD` 行定义了容器启动时要运行的命令——这与在完整的 Linux 系统镜像中定义在启动时哪些服务会启动的过程是一个缩影。'
- en: Finally, the `EXPOSE` lines define which ports the container should expose to
    the network—perhaps a little like a firewall might allow certain ports through.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`EXPOSE` 行定义了容器应该向网络暴露的端口——这或许有点像防火墙可能允许某些端口通过。
- en: In short, the native process to build a Docker container is very much aligned
    with our defined build process for an Enterprise Linux environment—hence, we can
    proceed in confidence with this process. With this in mind, we will now explore
    the process of ensuring our builds are as tidy and efficient as possible.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，构建 Docker 容器的原生过程与我们为企业 Linux 环境定义的构建过程非常契合——因此，我们可以自信地继续这个过程。考虑到这一点，我们将探讨确保构建尽可能简洁高效的过程。
- en: Keeping builds efficient
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持构建高效
- en: Knowing the fundamentals of your Linux environment, as we discussed in the last
    section, is vital to working out your deployment methodology. Although there exist
    some similarities between the build processes themselves (especially between traditional
    hypervisors and cloud environments), knowing these differences enables you to
    make informed decisions about how to deploy Linux throughout your enterprise.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节中讨论的，了解你 Linux 环境的基本知识对制定部署方法至关重要。尽管构建过程本身（尤其是传统的虚拟化环境与云环境之间）存在一些相似之处，但了解这些差异能帮助你在全企业范围内做出有关如何部署
    Linux 的明智决策。
- en: Once you have chosen the methodologies most appropriate to your environment,
    it's important to consider a few principles to ensure your process is streamlined
    and efficient (again, bywords of Enterprise Linux deployments). We will cover
    these here to proceed into the real in-depth, hands-on work in the remainder of
    this book. Let's get started by looking at the need for simplicity in our builds.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了最适合自己环境的方法，考虑一些原则以确保你的过程流畅高效是非常重要的（这也是企业 Linux 部署的关键要素）。我们将在这里介绍这些原则，以便在本书的后续部分深入探讨实际操作。让我们从构建简洁性的重要性开始。
- en: Keeping your builds simple
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持构建简洁
- en: Let's start to put some practical application of our earlier discussion on the
    importance of SOEs to our Linux build processes. Whatever route you choose and
    whatever your environment looks like, one key facet you should consider is to
    keep your build standard as simple and concise as possible.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始将之前讨论的 SOE（标准操作环境）对 Linux 构建过程的重要性应用到实际中。不论你选择哪条路径，环境如何，其中一个关键方面是确保你的构建标准尽可能简单明了。
- en: 'No two enterprise environments are the same, and hence the build requirements
    for each enterprise will certainly be different. Nonetheless, a common set of
    example requirements is given here to demonstrate the kinds of things that will
    be needed in the build process:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个企业环境都是独一无二的，因此每个企业的构建需求肯定也会不同。尽管如此，这里提供了一组常见的示例需求，以展示在构建过程中可能需要的内容：
- en: Monitoring agents
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控代理
- en: Log forwarding configuration
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志转发配置
- en: Security hardening
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全加固
- en: Core enterprise software requirements
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心企业软件需求
- en: NTP configuration for time synchronization
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于时间同步的 NTP 配置
- en: This list is just a start, and every enterprise will be different, but it gives
    you an idea of the kinds of things that will go into a build. However, let's start
    to look at some of the edge cases to your build process. It is fair to say that
    each Linux server will be built with a purpose in mind and, as such, will run
    some form of application stack.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表只是一个开始，每个企业的需求都不同，但它能让你了解构建过程中可能涉及的内容。不过，接下来我们将开始探讨一些构建过程中的边缘案例。可以公平地说，每个
    Linux 服务器的构建都有其特定的目的，因此将运行某种形式的应用栈。
- en: 'Again, the application stack is certain to vary between enterprises, but examples
    of the kinds of applications that might commonly be required are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，应用栈在不同企业之间肯定会有所不同，但可能常见的应用示例如下：
- en: A web server such as Apache or nginx
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Web 服务器，如 Apache 或 nginx
- en: The OpenJDK environment for Java workloads
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 Java 工作负载的 OpenJDK 环境
- en: A MariaDB database server
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 MariaDB 数据库服务器
- en: A PostgreSQL database server
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 PostgreSQL 数据库服务器
- en: NFS file-sharing tools and kernel extensions
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NFS 文件共享工具和内核扩展
- en: Now, in your standardization process, when you originally defined your SOE,
    you may even have gone to the lengths of already specifying the use of (just as
    an example) OpenJDK 8 and MariaDB 10.1\. Does this mean you should actually include
    these in your build process?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的标准化过程中，当你最初定义 SOE 时，你可能甚至已经指定了使用（仅作为例子）OpenJDK 8 和 MariaDB 10.1。这是否意味着你应该在你的构建过程中实际包含它们？
- en: The answer is almost always, *no*. Quite simply, adding these applications adds
    to the complexity of the build and to post-install configuration and debugging.
    It also reduces security—but more on that shortly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 答案几乎总是*不*。简单来说，添加这些应用程序会增加构建的复杂性以及后期配置和调试的复杂性。它还会降低安全性——稍后会详细解释这一点。
- en: Let's suppose we standardize on MariaDB 10.1 and include that in our base operating
    system image (and hence every single Linux machine deployed contains it), knowing
    that only a subset of the machines in operation will actually ever use it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们标准化使用 MariaDB 10.1，并将其包含在基础操作系统镜像中（因此每台部署的 Linux 机器都包含它），但我们知道，实际使用它的机器仅为一部分。
- en: 'There are several reasons for not including MariaDB in the base image:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不将 MariaDB 包含在基础镜像中的原因有几个：
- en: An install of just the server components of MariaDB 10.1 takes around 120 MB,
    depending on your operating system and packaging—there will also be dependency
    packages but let's just start with this. Although storage is cheap and plentiful
    these days, if you deploy 100 servers across your environment (actually a small
    number for most enterprises), that's approximately 11.7 GB of space dedicated
    to a package you don't need. The actual figure will be far higher as there will
    be dependency packages to install and so on.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装仅包含 MariaDB 10.1 服务器组件的大小大约为 120 MB，具体取决于操作系统和打包方式——还会有依赖包，但我们先从这个数字开始。虽然现在存储便宜且充足，如果你在环境中部署了
    100 台服务器（对于大多数企业来说实际上是很少的），那么大约有 11.7 GB 的空间将被专门用于一个你不需要的包。实际数字会更高，因为还需要安装依赖包等。
- en: This may also have a knock-on effect on backups and the storage required for
    these, and indeed any virtual machine snapshots if you use that in the enterprise.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这也可能对备份和所需的存储空间产生连锁反应，实际上，如果你在企业中使用虚拟机快照，也会有影响。
- en: If an application arrives that requires MariaDB 10.3 (or indeed, the business
    decides to update its standard to 10.3), then the images need to be upgraded or
    possibly version 10.1 uninstalled before 10.3 is installed. This is an unnecessary
    level of complexity when a minimal Linux image could just have received an updated
    MariaDB workload.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有应用程序要求使用 MariaDB 10.3（或者实际上，业务决定将其标准更新为 10.3），那么需要升级镜像，或者可能在安装 10.3 之前卸载版本
    10.1。这会增加不必要的复杂性，因为一个最小的 Linux 镜像本来只需要接收更新后的 MariaDB 工作负载。
- en: You need to ensure that MariaDB is turned off and firewalled off when not required
    to as to prevent any misuse—this is an additional auditing and enforcement requirement
    that again is unnecessary on many servers where MariaDB isn't used.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要确保当不需要时关闭 MariaDB 并对其进行防火墙隔离，以防止任何滥用——这是一个额外的审计和执行要求，而在许多不使用 MariaDB 的服务器上，这种要求是多余的。
- en: There are other security considerations too, but the key message here is that
    it is wasteful on resources and time. This doesn't, of course, only apply to MariaDB
    10.1—that is simply an example, but it serves to show that, as a rule, application
    workloads should not be included in the base operating system definition. Let's
    take a more detailed look at the security requirements for our builds now.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他的安全考虑，但这里的关键是，这样做会浪费资源和时间。当然，这不仅仅适用于 MariaDB 10.1——这只是一个例子，但它表明，一般来说，应用程序工作负载不应该包含在基础操作系统定义中。现在让我们更详细地看看构建的安全要求。
- en: Making your builds secure
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让你的构建更安全
- en: We have already touched on security and not installing or running unnecessary
    packages. Any running service provides a potential attack vector for an intruder,
    and whilst hopefully, you will never have one inside your enterprise network,
    it is still good practice to build the environment in a manner that is as secure
    as possible. This is especially true of services that come configured with default
    passwords (and in some cases, with no password configured at all—though this is
    thankfully becoming rare now).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过安全性以及不安装或运行不必要的软件包。任何正在运行的服务都为入侵者提供了潜在的攻击途径，尽管希望你永远不会在企业网络内遭遇此类入侵，但仍然最好以尽可能安全的方式构建环境。对于那些默认配置了密码的服务（有些情况下甚至没有配置密码——幸运的是，这种情况现在已经变得罕见），尤其如此。
- en: These principles apply when defining the build itself too. Don't create a build
    with weak static passwords, for example. Ideally, every build should be configured
    to obtain even initial credentials from an external source, and although there
    are a myriad of ways to achieve this, you are encouraged to look up `cloud-init`
    if this is a new concept to you. There are cases, especially in legacy environments,
    where you may need some initial credentials to allow access to the newly built
    server, but reusing weak passwords is dangerous and opens up the possibility of
    the newly built server being intercepted before it is configured and some kind
    of malware planted on it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则同样适用于定义构建本身。例如，不要创建具有弱静态密码的构建。理想情况下，每个构建都应该配置为从外部来源获取初始凭证，尽管有许多方法可以实现这一点，但如果这是一个新概念，建议你查阅一下`cloud-init`。在某些情况下，尤其是在旧版环境中，可能需要一些初始凭证来允许访问新构建的服务器，但重用弱密码是危险的，这会让新建的服务器在配置之前被拦截，并可能被植入某种恶意软件。
- en: 'In short, the following list provides some sound guidance on ensuring secure
    builds:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，以下列表提供了一些确保安全构建的有力指导：
- en: Don't install applications or services that are not required.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要安装不需要的应用程序或服务。
- en: Do ensure services that are common to all builds but require post-deployment
    configuration are disabled by default.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有构建中通用的服务（但需要部署后配置的服务）默认情况下是禁用的。
- en: Don't re-use passwords even for initial access and configuration if at all possible.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，不要重用密码，即使是用于初始访问和配置。
- en: Do apply your enterprise security policy as early as possible in the process—in
    the build process of the image or server if possible, but if not, as soon as possible
    after installation.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过程尽早应用你的企业安全政策——如果可能的话，最好在镜像或服务器的构建过程中应用，但如果不行，也要在安装后尽早应用。
- en: These principles are simple yet fundamental, and it is important to adhere to
    them. Hopefully, a situation will never arise where it matters that they have
    been applied, but if it does, they might just stop or sufficiently impede an intrusion
    or attack on your infrastructure. This, of course, is a topic that deserves its
    own book, but it is hoped these pointers, along with the examples in [Chapter
    13](3d4a9c0a-452f-4fbb-85c8-372149303613.xhtml), *Using CIS Benchmarks*, will
    point you in the right direction. Let's take a brief look now at ensuring our
    build processes are efficient.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则简单但至关重要，遵守它们非常重要。希望永远不会出现需要证明这些原则是否得到应用的情况，但如果发生了，这些原则可能会阻止或足够遏制对你基础设施的入侵或攻击。当然，这个话题值得单独写一本书，但希望这些提示以及[第13章](3d4a9c0a-452f-4fbb-85c8-372149303613.xhtml)《使用CIS基准》的示例，能为你指引正确的方向。现在，我们简要了解一下如何确保构建过程高效。
- en: Creating efficient processes
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建高效的流程
- en: Efficient processes are supported heavily by automation, as this ensures minimal
    human involvement and consistent, repeatable end results. Standardization also
    supports this, as it means that much of the decision-making process has already
    been completed, and so all people involved know exactly what they are doing and
    how it should be done.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 高效的流程主要依赖自动化，因为自动化可以确保最小化人为干预，并保证一致且可重复的最终结果。标准化也对此提供支持，因为它意味着大部分决策过程已经完成，因此所有参与的人都清楚自己在做什么以及该怎么做。
- en: In short, stick to these principles outlined in this book and your build processes
    will, by their very nature, be efficient. Some degree of manual intervention is
    inevitable, even if it involves choosing a unique hostname (though this can be
    automated) or perhaps the process of a user requesting a Linux server in the first
    place. However, from here, you want to automate and standardize wherever possible.
    We will follow this mantra throughout this book. For now, though, we will take
    a look at the importance of consistency in our build processes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，遵循本书中概述的这些原则，你的构建流程自然会高效。即使是在选择唯一主机名（尽管这可以自动化）或用户请求一个 Linux 服务器时，某种程度的人工干预是不可避免的。然而，从此以后，你应该尽可能地进行自动化和标准化。我们将在本书中始终遵循这一理念。现在，我们先来看看构建过程中一致性的重要性。
- en: Ensuring consistency across Linux images
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保 Linux 镜像的一致性
- en: In [Chapter 1](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml), *Building a Standard
    Operating Environment on Linux*, we discussed the importance of commonality in
    SOE environments. Now that we are actually looking at the build process itself,
    this comes back to the fore as we are, for the first time, looking at how to actually
    implement commonality. Assuming Ansible is your tool of choice, consider the following
    task. We are writing playbooks for our image build process and have decided that
    our standard image is to synchronize its time with our local time server. Suppose
    that our base operating system of choice is Ubuntu 16.04 LTS for historic reasons.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml)《在 Linux 上构建标准操作环境》中，我们讨论了
    SOE 环境中共性的重要性。现在，我们实际上在查看构建过程本身，这一问题再次浮现，因为我们首次着眼于如何实际实现共性。假设 Ansible 是你首选的工具，考虑以下任务。我们正在为我们的镜像构建过程编写
    playbook，并已决定我们的标准镜像需要与本地时间服务器同步时间。假设由于历史原因，我们选择的基础操作系统是 Ubuntu 16.04 LTS。
- en: Let's create a simple role to ensure NTP is installed and to copy across our
    corporate standard `ntp.conf`, which includes the addresses of our in-house time
    servers. Finally, we need to restart NTP to pick up the changes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的角色，以确保安装 NTP 并复制我们的公司标准 `ntp.conf`，其中包括我们内部时间服务器的地址。最后，我们需要重启 NTP
    以应用这些更改。
- en: The examples in this chapter are purely hypothetical and given to demonstrate
    what Ansible code for a given purpose might look like. We will expand on the tasks
    performed (such as deploying configuration files) in detail in later chapters
    and provide hands-on examples for you to try out.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例纯粹是假设性的，目的是展示某个特定任务所需的 Ansible 代码。我们将在后续章节中详细扩展所执行的任务（如部署配置文件），并提供实际的示例供你尝试。
- en: 'This role could look like the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色可能如下所示：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This role is simple, concise, and to the point. It always ensures the `ntp` package
    is installed, and also ensures we are copying across the same version of our configuration
    file, making sure it is the same on every server. We could improve this further
    by checking this file out of a version control system, but that is left as an
    exercise for you.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色简单、简洁且直截了当。它始终确保安装`ntp`包，并且确保我们复制相同版本的配置文件，确保每台服务器上的配置文件都是一致的。我们可以通过从版本控制系统中检出这个文件进一步改进，但这部分留给你作为练习。
- en: Instantly, you can see the power of writing an Ansible role for this one simple
    step—there is great consistency to be achieved from including this role in a playbook, and
    if you scale this approach up to your entire enterprise, then all configured services
    will be consistently installed and configured.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻，你就能看到为这一个简单步骤编写 Ansible 角色的强大之处——通过在 playbook 中包含这个角色，可以实现很高的一致性，且如果你将这种方法推广到整个企业，那么所有配置的服务将会被一致地安装和配置。
- en: 'However, it gets better. Let''s say that the business decides to rebase the
    standard operating system to Ubuntu 18.04 LTS to make use of newer technologies
    and increase the supported lifespan of the environment. The `ntp` package is still
    available on Ubuntu 18.04, though by default, the `chrony` package is now installed.
    To proceed with NTP, the role would need only minor tweaks to simply ensure that `chrony` is
    removed first (or you could disable it if you prefer)—after this, it is identical,
    for example, consider the following role code that ensures the correct packages
    are absent and present:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事情更好了。假设业务决定将标准操作系统基础重定为Ubuntu 18.04 LTS，以利用更新的技术并延长环境的支持寿命。`ntp`包在Ubuntu
    18.04中仍然可用，但默认情况下，`chrony`包已被安装。为了继续使用NTP，该角色只需要做一些小的调整，确保首先删除（或如果你更喜欢，也可以禁用）`chrony`包——之后，它就完全相同了。例如，考虑以下角色代码，它确保了正确的包被删除或安装：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We would then continue this code by adding two further tasks that copy across
    the configuration and restart the service to ensure it picks up the new configuration:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们会继续添加两个任务，将配置复制过去并重新启动服务，确保它采纳新的配置：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, we could decide to embrace this change and make use of `chrony` on
    the new base image. Hence, we would simply need to create a new `chrony.conf` to
    ensure it talks to our enterprise NTP servers, and then proceed exactly as before:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以决定接受这个变化，并在新的基础镜像上使用`chrony`。因此，我们只需要创建一个新的`chrony.conf`，确保它与我们的企业NTP服务器通信，然后按照之前的步骤继续操作：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice how similar these roles all are? Only minor changes are required even
    when supporting a change in the base operating system or even underlying service.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这些角色有多么相似？即使支持底层操作系统或服务发生变化，也只需做出细微的调整。
- en: 'Although these three roles differ in places, they are all performing the same
    basic tasks, which are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这三种角色在某些地方有所不同，但它们都执行相同的基本任务，具体如下：
- en: Ensure that the correct NTP service is installed.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已安装正确的NTP服务。
- en: Copy across the standard configuration.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制标准配置。
- en: Ensure the service is enabled at boot time and has started.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保该服务在启动时启用并已启动。
- en: Hence, we can be sure that, using this approach, we have consistency.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以确信，采用这种方法，我们能够保持一致性。
- en: 'Even when changing the platform entirely, the high-level approach can still
    be applied. Let''s say that the enterprise has now taken on an application that
    is only supported on CentOS 7\. This means an accepted deviation to our SOE, however,
    even our new CentOS 7 build will need to have the correct time, and as NTP is
    a standard, it will still use the same time servers. Hence, we can write a role
    to support CentOS 7:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 即使完全更换平台，高级方法仍然可以适用。假设企业现在使用了仅支持CentOS 7的应用程序。这意味着我们的SOE发生了一个接受的偏差，但是，即便是新的CentOS
    7构建，也需要确保时间正确。由于NTP是一个标准，它仍然会使用相同的时间服务器。因此，我们可以编写一个角色来支持CentOS 7：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, the changes are incredibly subtle. This is a significant part of the
    reason for embracing Ansible as our automation tool of choice for enterprise automation—we
    can build and adhere to our standards with great ease, and our operating system
    builds are consistent if we change the version or even the entire distribution
    of Linux we are using.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些变化非常微妙。这也是我们选择Ansible作为企业自动化工具的一个重要原因——我们能够轻松地构建并遵循标准，而且当我们更改Linux版本甚至整个发行版时，操作系统的构建仍然保持一致。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At this stage, we have defined our requirement for standardization, established
    which tools to use in our journey toward automation, and now taken a practical
    look at the fundamental types of environments into which enterprises can expect
    to deploy an operating system. This has set the groundwork for our automation
    journey and has provided us with the context for the rest of this book—a hands-on
    journey through the process of building and maintaining a Linux environment in
    the enterprise.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一阶段，我们已经定义了标准化的要求，确定了在实现自动化过程中使用的工具，并且现在对企业可能部署操作系统的基本环境类型进行了实际的探讨。这为我们的自动化之旅奠定了基础，并为本书的其余部分提供了背景——通过动手实践，了解在企业中构建和维护Linux环境的过程。
- en: In this chapter, we learned about the different types of environments into which
    Linux might be deployed and the different build strategies available to each.
    We then looked at some practical examples of ensuring that our builds are of a
    high standard and can be completed efficiently and repeatably. Finally, we started
    to look at the benefits of automation and how it can ensure consistency across
    builds, even when we change the entire underlying Linux distribution.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了 Linux 可能部署的不同类型的环境以及每种环境的不同构建策略。然后，我们查看了一些实际的示例，确保我们的构建符合高标准，并且能够高效且可重复地完成。最后，我们开始探讨自动化的好处，以及它如何确保即使我们更换整个底层
    Linux 发行版，构建的一致性也能得到保证。
- en: In the next chapter, we will begin our hands-on journey into Enterprise Linux
    automation and deployments, looking at how Ansible can be employed to build out
    virtual machine templates, whether from cloud environment images or from scratch.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将开始动手实践企业级 Linux 自动化和部署，探讨如何使用 Ansible 来构建虚拟机模板，无论是从云环境镜像还是从头开始构建。
- en: Questions
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the similarities between building a Docker container and an SOE?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 Docker 容器和 SOE 之间有什么相似之处？
- en: Why would you not include MariaDB in your base build if it is only required
    on a handful of servers?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 MariaDB 仅在少数服务器上需要，为什么不将其包含在基础构建中？
- en: How would you ensure your base operating system image is as small as possible?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何确保您的基础操作系统镜像尽可能小？
- en: Why should you be careful about embedding passwords in your base operating system
    image?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在基础操作系统镜像中嵌入密码时需要小心？
- en: How would you ensure all Linux images send their logs to your centralized logging
    server?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何确保所有 Linux 镜像将其日志发送到您的集中日志服务器？
- en: When would you not use a base image provided by a cloud provider and build your
    own instead?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下您不会使用云提供商提供的基础镜像，而是选择构建自己的镜像？
- en: How would you secure your SSH daemon configuration using Ansible?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 Ansible 安全配置您的 SSH 守护进程？
- en: Further reading
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For an in-depth understanding of Ansible, please refer to *Mastering Ansible,
    Third Edition* by *James Freeman* and *Jesse Keating* ([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition)).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要深入理解 Ansible，请参考*Mastering Ansible, Third Edition*，作者*James Freeman*和*Jesse
    Keating*（[https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition)）。
- en: To gain an understanding of the Docker code and discussion in this chapter,
    please refer to *Mastering Docker, Third Edition* by *Russ McKendrick* and *Scott
    Gallagher* ([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-docker-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-docker-third-edition)).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解本章中的 Docker 代码和讨论，请参考*Mastering Docker, Third Edition*，作者*Russ McKendrick*和*Scott
    Gallagher*（[https://www.packtpub.com/gb/virtualization-and-cloud/mastering-docker-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-docker-third-edition)）。
