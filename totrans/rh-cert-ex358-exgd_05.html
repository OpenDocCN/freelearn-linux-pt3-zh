<html><head></head><body>
		<div id="_idContainer135">
			<h1 id="_idParaDest-57" class="chapter-number"><a id="_idTextAnchor060"/>5</h1>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor061"/>DNS, DHCP, and IP Addressing – Gaining Deeper Knowledge of Red Hat Linux Networking </h1>
			<p>In this chapter, we are going to dig deeper into networking. We will discuss <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) addressing in two ways: static and <strong class="bold">Dynamic Host Configuration Protocol</strong> (<strong class="bold">DHCP</strong>). Static addressing occurs when you set the IP address, such as <strong class="source-inline">192.168.1.10</strong>, with a gateway address of <strong class="source-inline">192.168.1.1</strong>, whereas with DHCP, the IP information is provided by a DHCP server and the system goes through a handshake mechanism to obtain an IP and the DNS and gateway information on the connected subnet. We will go into more detail about static addressing and DHCP addressing later in this chapter. We will also be setting up a DHCP server to provide IP addressing information to systems on your network both manually and through <span class="No-Break">Ansible Automation.</span></p>
			<p>We are then going to look at how we can find other addresses on the internet through the <strong class="bold">Dynamic Name System </strong>(<strong class="bold">DNS</strong>), which attaches <strong class="bold">Fully Qualified Domain Names </strong>(<strong class="bold">FQDNs</strong>) to IP addresses. This translates things such as <a href="http://redhat.com">http://redhat.com</a> to an IP address that your computer can then use to reach from your web browser or other connectivity sources such as Telnet or SSH. This is all handled through domain name registrars where the DNS is associated with the website to IP (and vice versa) information. We will set up a DNS server both manually and through <span class="No-Break">Ansible Automation.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Diving deeper into Linux networking where we look at DNS, DHCP, and static <span class="No-Break">IP addressing</span></li>
				<li>Setting up static IP addresses for times when DHCP is not available but you still need to make that <span class="No-Break">service reachable</span></li>
				<li>Using the basic out-of-the-box DHCP configuration to get online fast when available on <span class="No-Break">your network</span></li>
				<li>Learning what the DNS is and why you need to know <span class="No-Break">about it</span></li>
			</ul>
			<p>The technical requirements for this chapter are covered in the <span class="No-Break">following section.</span></p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor062"/>Setting up GitHub access</h1>
			<p>Please refer to the instructions found in <a href="B18607_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise Linux</em>, to gain access to GitHub. You will find the Ansible Automation playbooks for <a id="_idIndexMarker212"/>this chapter at the following link: <a href="https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter05">https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter05</a>. Remember, these are suggested playbooks and are not the only way you can write them to make the playbooks work <span class="No-Break">for you.</span></p>
			<p>You can always change them up using raw, shell, or CMD to achieve the same results, but we are demonstrating the best way to accomplish our goals. Also keep in mind that we are not using the FQCN that is needed in the future version of Ansible, as that will not be supported in the exam since it is testing against <span class="No-Break">Ansible 2.9.</span></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor063"/>Diving deeper into Linux networking where we look at DNS, DHCP, and static IP addressing</h1>
			<p>So far, we have briefly talked about Linux networking and what it means to you – the ability to provide and gain <a id="_idIndexMarker213"/>access to your servers, applications, and so on that reside on your and other networks. We will take that a step past the initial setup of the IP addressing of an interface and build upon what we have learned so far in this book. We will show you not only how your devices get your IP, gateway, and DNS configurations but also how to provide those services to your servers <span class="No-Break">and applications.</span></p>
			<p>First, we will go over the importance of each aspect of the different items. Your IP address is like your home address. Your gateway is like your driveway out into the world. The DNS is like your GPS because it shows you how to reach your online destination. The configuration of all of these things, either automatically through DHCP or manually through static addressing, is the bare minimum needed to get online and reach <span class="No-Break">your destination.</span></p>
			<p>We have talked previously about IP addressing and how static addressing is done manually through interface configuration. The same is true for DHCP; however, your system talks to another device to automatically obtain the information it needs to get online. This information<a id="_idIndexMarker214"/> includes the DNS, which is the GPS of how you locate the different things you are looking to find online, such as e-commerce websites, news, and so on. We will delve deeper into each of these categories as we move through <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor064"/>Setting up static IP addresses for times when DHCP is not available but you still need to make that service reachable</h1>
			<p>This is for times when you don’t have DHCP or when you need to always ensure the same address. This will provide the IP address, gateway, DNS, and routing that comes along with that setup; you<a id="_idIndexMarker215"/> sometimes need to enable the system via static configurations. You will notice that in the following screenshot, it did get a DHCP address but for our purposes, we are going to assume it received the incorrect address that is needed for the application. We will show the current IP address on the server using the <span class="No-Break">following command:</span></p>
			<pre class="console">
[emcleroy@rhel2 ~]$ ip a | grep enp0s3</pre>
			<p>The following screenshot shows the IP address information that is currently configured on <span class="No-Break">the server:</span></p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/Figure_5.01_B18607.jpg" alt="Figure 5.1 – IP addressing based on DHCP currently"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – IP addressing based on DHCP currently</p>
			<p>So, in order to<a id="_idIndexMarker216"/> resolve this issue, we are going to set the system up statically using the <strong class="source-inline">nmtui</strong> command to gain a GUI-style interface, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/Figure_5.02_B18607.jpg" alt="Figure 5.2 – Initiated GUI using the nmtui command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Initiated GUI using the nmtui command</p>
			<p>Within the GUI, we <a id="_idIndexMarker217"/>are going to choose the <strong class="bold">Edit a connection</strong> option. This will allow us to choose our interface and set the appropriate settings manually. Choosing the right interface after selecting the mentioned option is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/Figure_5.03_B18607.jpg" alt="Figure 5.3 – ﻿The Edit a connection option chosen and the correct interface highlighted"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The Edit a connection option chosen and the correct interface highlighted</p>
			<p>After choosing the<a id="_idIndexMarker218"/> correct interface, we are going to choose the <strong class="bold">Manual</strong> setting so we can open up the needed fields for manipulation, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/Figure_5.04_B18607.jpg" alt="Figure 5.4 – Selecting Manual to open up the Ethernet settings for configuration"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Selecting Manual to open up the Ethernet settings for configuration</p>
			<p>We will then set the <a id="_idIndexMarker219"/>correct configuration for the interface. This might be information that you have to obtain from your network team in some cases. The reason behind that is that you have to know your DNS, gateway, and subnet range. These may not be known to you as a server admin, and that’s why DHCP is preferred, at least for desktop usage, as it auto-populates all of these fields. The following screenshot shows the required configuration to get this interface up and connected to <span class="No-Break">the world:</span></p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/Figure_5.05_B18607.jpg" alt="Figure 5.5 – IP address with subnet range, gateway, and DNS for the required connectivity options"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – IP address with subnet range, gateway, and DNS for the required connectivity options</p>
			<p>From there, you would <a id="_idIndexMarker220"/>save this information and exit the <strong class="source-inline">nmtui</strong> GUI and then run the <span class="No-Break">following command:</span></p>
			<pre class="console">
[emcleroy@rhel2 ~]$ sudo ifdown enp0s3 &amp;&amp; sudo ifup enp0s3</pre>
			<p>The output from the command is shown in the following screenshot from <span class="No-Break">the server:</span></p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/Figure_5.06_B18607.jpg" alt="Figure 5.6 – Command to reload the interface to gain the new settings you specified"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Command to reload the interface to gain the new settings you specified</p>
			<p>Alternatively, you can<a id="_idIndexMarker221"/> run the following command from SSH if you do not have direct access to <span class="No-Break">the server:</span></p>
			<pre class="console">
[emcleroy@rhel2 ~]$ sudo systemctl restart NetworkManager.service</pre>
			<p>In the following screenshot, you can see the output of <span class="No-Break">the command:</span></p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/Figure_5.07_B18607.jpg" alt="Figure 5.7 – Command to reload network manager in order to gain the new static settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Command to reload network manager in order to gain the new static settings</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor065"/>Using the basic out-of-the-box DHCP configuration to get online fast when available on your network</h1>
			<p>Out-of-the-box DHCP addressing <a id="_idIndexMarker222"/>will give you the IP addressing you need when physically connected to a network with a router and DHCP server runn<a id="_idTextAnchor066"/>ing in order to obtain an IP automatically and connect to the network. This allows you to get online quickly without the need to know the connectivity settings such as subnet, gateway, or <span class="No-Break">routing information.</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor067"/>Using DHCP at initial interface connectivity provided by an external source</h2>
			<p>When you first fire up your computer and plug it into the network, by default, most systems are configured to try to use DHCP. This handshake method allows for connectivity to the internet to occur faster and without direct intervention. For instance, in RHEL, when you fire up the<a id="_idIndexMarker223"/> interface when installing it, you will automatically have the configuration set to DHCP. This is due to most users having a serving DHCP server. This means that a handshake occurs between the DHCP server and the RHEL machine to provide it with connectivity information. This occurs in the form of the <strong class="bold">DHCP Discover</strong> message or the computer or client server asking for connectivity. The server replies with a <strong class="bold">DHCP Offer</strong> to provide the information. The client then responds with the <strong class="bold">DHCP Request</strong> for the information to connect. Finally, the DHCP server responds with a <strong class="bold">DHCP Acknowledgement</strong> that includes the information for connectivity. This can be seen in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/Figure_5.08_B18607.jpg" alt="Figure 5.8 – DHCP handshake"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – DHCP handshake</p>
			<p>Once you have the information from the DHCP server, your machine will be configured with an IP address, gateway, and DNS. This allows you to get online quicker and without the hassle of setting up the information yourself. In some cases, this is necessary because you neither have the required information (such as what IP addresses are free on your network) nor do you know what the gateway or DNS addresses are. By using DHCP, you are able to connect to the network reliably and without conflict and reach your <span class="No-Break">local network.</span></p>
			<p>In most enterprise environments, however, you will not use a DHCP server for application servers, but you will in most cases for providing connectivity to workers. Most application production servers are set through static or through automation using the next available application IP. This is why it is such a big deal to be able to set up a DHCP server as you will want the connectivity to be easy for your workers to be able to log in and get right to work. Knowing there is a need for a DHCP server, we will use it as a motivation to set up a DHCP server that will provide connectivity to internal workers at your company or your<a id="_idIndexMarker224"/> family <span class="No-Break">at home.</span></p>
			<p>With a DHCP server running and having connectivity, either through physical Ethernet or Wi-Fi, here is how you can set up DHCP IP addressing for your device. For this, you will need direct access to the server via the console or through the VM manager. Using the following command, you can check what your IP <span class="No-Break">address is:</span></p>
			<pre class="console">
[emcleroy@rhel2 ~]$ ip a | grep enp0s3</pre>
			<p>As the following screenshot demonstrates, your device currently has no <span class="No-Break">IP address:</span></p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/Figure_5.09_B18607.jpg" alt="Figure 5.9 – There is currently no IP address associated with the connected enp0s3 interface"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – There is currently no IP address associated with the connected enp0s3 interface</p>
			<p>We are going<a id="_idIndexMarker225"/> to use <strong class="source-inline">nmtui</strong> again as we did when working with static addresses, but this time, we will choose <strong class="bold">Automatic</strong>, which utilizes DHCP, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/Figure_5.10_B18607.jpg" alt="Figure 5.10 – Choosing the Automatic option within nmtui interface settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – Choosing the Automatic option within nmtui interface settings</p>
			<p>After you<a id="_idIndexMarker226"/> choose the <strong class="bold">Automatic</strong> option and allow it to automatically configure your IP through DHCP, you will need to activate the interface so that it enables the connection. This is shown in the following screenshot from <span class="No-Break">within </span><span class="No-Break"><strong class="source-inline">nmtui</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/Figure_5.11_B18607.jpg" alt="Figure 5.11 – Activating a connection within nmtui"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 – Activating a connection within nmtui</p>
			<p>After you <a id="_idIndexMarker227"/>choose <strong class="bold">Activate a connection</strong>, you then need to choose the interface that is physically connected, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/Figure_5.12_B18607.jpg" alt="Figure 5.12 – Choosing the correct interface you previously set up to enable connectivity"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12 – Choosing the correct interface you previously set up to enable connectivity</p>
			<p>After that is activated, the<a id="_idIndexMarker228"/> interface should come up and complete the DHCP handshake that was outlined previously to gain the information needed to make a network connection. Using the following command, you can see what IP address was <span class="No-Break">obtained automatically:</span></p>
			<pre class="console">
[emcleroy@rhel2 ~]$ ip a | grep enp0s3</pre>
			<p>The connectivity information that was automatically obtained is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/Figure_5.13_B18607.jpg" alt="Figure 5.13 – The IP address and routing of the gateway"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.13 – The IP address and routing of the gateway</p>
			<p>We have just set up<a id="_idIndexMarker229"/> your server or client machine to acquire network connectivity using DHCP. Through the automated system, you will be able to get online fast without having to worry about manually setting anything up. This is a big advantage for things that do not always need to have the same IP but only need network connectivity. Next, we will talk about creating a DHCP server to provide this type <span class="No-Break">of functionality.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor068"/>Setting up DHCP server configuration manually to provide DHCP services</h2>
			<p>In some cases, there will not be a DHCP server already set up on the network. As a system administrator, it may<a id="_idIndexMarker230"/> fall upon you to <a id="_idIndexMarker231"/>set one up. This is due to the need for a DHCP server for desktop support in many cases, and a necessity to get workers online fast and with minimal effort. This could mean that they are physically plugged into the network using Wi-Fi or a <strong class="bold">Virtual Private Network</strong> (<strong class="bold">VPN</strong>) to <a id="_idIndexMarker232"/>connect. Regardless of how they are connecting, if they fall within the authorized connectivity, we need to provide them with the correct addressing information. This allows them access not only to the internet but also to their systems within the intranet of the internal company. Let’s get started with setting up a DHCP <span class="No-Break">server manually.</span></p>
			<p>The first thing you are going to need to do is to install the <strong class="source-inline">dhcp-server</strong> package using the <span class="No-Break">following command:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo dnf install dhcp-server</pre>
			<p>This output can be seen in the commands shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/Figure_5.14_B18607.jpg" alt="Figure 5.14 – Installing the required dhcp-server package"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.14 – Installing the required dhcp-server package</p>
			<p>From there, we will need to set<a id="_idIndexMarker233"/> the parameters within the correct configuration file so that <strong class="source-inline">dhcp-server</strong> knows what<a id="_idIndexMarker234"/> information to provide to the client machines. Using the following command, we can open and edit the <span class="No-Break"><strong class="source-inline">dhcpd.conf</strong></span><span class="No-Break"> file:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo vi /etc/dhcp/dhcpd.conf</pre>
			<p>The command is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/Figure_5.15_B18607.jpg" alt="Figure 5.15 – Editing the dhcpd.conf file to set the required network settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.15 – Editing the dhcpd.conf file to set the required network settings</p>
			<p>In order to save us somewhat of a headache, there is a trick that can be utilized. The trick is to look at the example of a configuration file and copy and paste the options. Once you've done that, you<a id="_idIndexMarker235"/> would then need to edit the options to match what your network requires to have the server <a id="_idIndexMarker236"/>provide the correct information to the clients. Using the following command, we can view the examples of working <span class="No-Break">DHCP servers:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ cat /usr/share/doc/dhcp-server/dhcpd.conf.example</pre>
			<p>This example can be found in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/Figure_5.16_B18607.jpg" alt="Figure 5.16 – Example of a configured dhcp﻿d.conf file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.16 – Example of a configured dhcpd.conf file</p>
			<p>Further <a id="_idIndexMarker237"/>within the example, you <a id="_idIndexMarker238"/>will see the main portion of what is necessary to set up that internal DHCP server for your clients. This portion is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/Figure_5.17_B18607.jpg" alt="Figure 5.17 – The necessary items fall under the “A slightly different configuration” section"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.17 – The necessary items fall under the “A slightly different configuration” section</p>
			<p>By copying the subnet section <a id="_idIndexMarker239"/>and pasting it into the <strong class="source-inline">dhcpd.conf</strong> file, you can then edit it to the values you need easily without<a id="_idIndexMarker240"/> worrying about whether you missed any items. This configuration file is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/Figure_5.18_B18607.jpg" alt="Figure 5.18 – Configuration for dhcp-server that provides a 192.168.1.0/24 network"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.18 – Configuration for dhcp-server that provides a 192.168.1.0/24 network</p>
			<p>After you have all of the correct settings in <a id="_idIndexMarker241"/>your <strong class="source-inline">dhcpd.conf</strong> file, you can then start and enable the <strong class="source-inline">dhcp-server</strong> daemon in order to ensure that the server is running. We will use the following commands <a id="_idIndexMarker242"/>to enable and start the <span class="No-Break"><strong class="source-inline">dhcpd</strong></span><span class="No-Break"> service:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo systemctl enable dhcpd
[emcleroy@rhel1 ~]$ sudo systemctl start dhcpd</pre>
			<p>The results of the commands are shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/Figure_5.19_B18607.jpg" alt="Figure 5.19 – Starting and enabling the service so that it starts at boot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.19 – Starting and enabling the service so that it starts at boot</p>
			<p>After we have started and enabled the service, it is always a good idea to check and ensure that the system has<a id="_idIndexMarker243"/> successfully<a id="_idIndexMarker244"/> started. We can use the following command to view the status of <span class="No-Break">the service:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo systemctl status dhcpd</pre>
			<p>The status of <strong class="source-inline">running</strong> is shown in the following screenshot <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">dhcp-server</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/Figure_5.20_B18607.jpg" alt="Figure 5.20 – The status of running is shown for dhcp-server thus confirming it has been set up correctly"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.20 – The status of running is shown for dhcp-server thus confirming it has been set up correctly</p>
			<p>As with all other services, we want to reach the outside world, for which we need to open a firewall to allow<a id="_idIndexMarker245"/> incoming broadcast requests for a DHCP lease. We will use the following commands to open <a id="_idIndexMarker246"/>and reload <span class="No-Break">the firewall:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo firewall-cmd --permanent --add-service-dhcp
[emcleroy@rhel1 ~]$ sudo firewall-cmd --reload</pre>
			<p>Opening the firewall command output is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/Figure_5.21_B18607.jpg" alt="Figure 5.21 – Opening firewall ports for DHCP and reloading the firewall to allow connectivity"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.21 – Opening firewall ports for DHCP and reloading the firewall to allow connectivity</p>
			<p>Previously, we skipped double-checking to ensure that the firewall rule was actually in place. This time, I wanted to <a id="_idIndexMarker247"/>showcase how you can check and see whether a service is allowed through your firewall. We<a id="_idIndexMarker248"/> will use the following command to view the services currently allowed by <span class="No-Break">the firewall:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo firewall-cmd --list-services</pre>
			<p>In the following screenshot, the command shows that the DHCP service <span class="No-Break">is listed:</span></p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/Figure_5.22_B18607.jpg" alt="Figure 5.22 – Using the ﻿firewall-cmd --list-services command; you can see it includes DHCP"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.22 – Using the firewall-cmd --list-services command; you can see it includes DHCP</p>
			<p>We have set up a DHCP server to provide connectivity to client devices connected to the subnet. This allows you to <a id="_idIndexMarker249"/>control what IP addresses devices receive from static DHCP addressing to next-in-line IP address pools. We briefly showcased options such as <strong class="source-inline">default-lease-time</strong>, which is the time the machine will keep the IP address before making a new request, for example. Also, with static MAC address mapping, it allows you to know ahead of time<a id="_idIndexMarker250"/> what IP address your machine will receive from a DHCP server. This is helpful when setting up Ansible playbooks to run against a specific IP address, for example. Next, we are going to talk about how to set this service up through Ansible Automation to ensure that it is easily repeatable and to lower the possibility of <span class="No-Break">human error.</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor069"/>Automating DHCP server configuration to provide DHCP services</h2>
			<p>We are going to start by setting up Ansible’s inventory of systems, which, in our case, is <a href="https://rhel1.example.com">rhel1.example.com</a> for our<a id="_idIndexMarker251"/> target device for the DHCP server. This will allow us to target only the device we are looking to run against; also, we will call out the server in our playbook to ensure that only <strong class="source-inline">rhel1</strong> is configured. Make a <a id="_idIndexMarker252"/>directory for your playbook, or you can have one directory with all of your playbooks, but it will use the same inventory so keep that in mind. In our case, we are going to make a directory in our <strong class="source-inline">Documents</strong> folder for the playbook and inventory to reside in, <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">dhcp_server_playbook</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
[emcleroy@rhel3 Documents]$ mkdir dhcp_server_playbook
[emcleroy@rhel3 Documents]$ cd dhcp_server_playbook/
[emcleroy@rhel3 dhcp_server_playbook]$ ls
[emcleroy@rhel3 dhcp_server_playbook]$ vi inventory</pre>
			<p>The inventory file should look something like the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/Figure_5.23_B18607.jpg" alt="Figure 5.23 – DHCP server inventory file for the playbook to create the DHCP server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.23 – DHCP server inventory file for the playbook to create the DHCP server</p>
			<p>We will then move on to the playbook<a id="_idIndexMarker253"/> itself, where we will create tasks to install the DHCP server. First, we are <a id="_idIndexMarker254"/>going to want to point toward the inventory group we created so that no other hosts are updated. We will also set the <strong class="source-inline">become</strong> state to <strong class="source-inline">true</strong> in order to escalate our privileges, and <strong class="source-inline">become_method</strong> to <strong class="source-inline">sudo</strong> so that Ansible knows how to <span class="No-Break">escalate privileges:</span></p>
			<pre class="source-code">
---
- name: Install and Configure DHCP Server
  hosts: dhcp_servers
  become: true
  become_method: sudo</pre>
			<p>We then need to add some tasks to start building the DHCP server itself. We will start by installing the <strong class="source-inline">dhcp-server</strong> package using the <strong class="source-inline">package</strong> module. We will set the task to install the latest version of<a id="_idIndexMarker255"/> the package <span class="No-Break">as well:</span></p>
			<pre class="source-code">
  tasks:
    - name: Install dhcp-server package
      package:
        name: dhcp-server
        state: latest</pre>
			<p>After we have installed the<a id="_idIndexMarker256"/> server, we will then set the configuration files using the templating module through the use of a <span class="No-Break">Jinja template.</span></p>
			<p>First, let’s look at the playbook layout, and then we will address the templates. We will use the <strong class="source-inline">template</strong> module to copy a template we have built to the system in order to configure <strong class="source-inline">dhcp-server</strong>. You will notice we are using a predefined variable of <strong class="source-inline">playbook_dir</strong> in order to point to the right location for the file. This is built into Ansible and is not something you need to <span class="No-Break">configure yourself:</span></p>
			<pre class="source-code">
    - name: Set subnet configuration of DHCP-Server
      template:
        src: "{{ playbook_dir }}/templates/dhcpd.conf.j2"
        dest: /etc/dhcp/dhcpd.conf</pre>
			<p>Now, let’s take a look at the <strong class="source-inline">jinja2</strong> template, which shows a normal <strong class="source-inline">dhcpd.conf</strong> layout for the subnet we want to create, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/Figure_5.24_B18607.jpg" alt="Figure 5.24 – dhcpd.conf.j2 file for use with the Ansible playbook"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.24 – dhcpd.conf.j2 file for use with the Ansible playbook</p>
			<p>After this is completed, we will<a id="_idIndexMarker257"/> then start and <a id="_idIndexMarker258"/>enable the service. Open the firewall rules for <strong class="source-inline">dhcp</strong> and reload <span class="No-Break">the firewall:</span></p>
			<pre class="source-code">
    - name: Enable and start dhcp-server service
      service:
        name: dhcpd
        enabled: true
        state: restarted
    - name: Open firewall rules
      firewalld:
        permanent: true
        immediate: true
        service: dhcp
        state: enabled</pre>
			<p>Then, we are going to run the playbook in order to set up the DHCP server. We will use the following command; if<a id="_idIndexMarker259"/> you have keys fully set up, this is not necessary, but I wanted to show you how to do it <span class="No-Break">with</span><span class="No-Break"><a id="_idIndexMarker260"/></span><span class="No-Break"> passwords:</span></p>
			<pre class="console">
[emcleroy@rhel3 dhcp_server_playbook]$ ansible-playbook -i inventory dhcp_server_playbook.yml -u emcleroy -k --ask-become</pre>
			<p>The output from running the playbook is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/Figure_5.25_B18607.jpg" alt="Figure 5.25 – Successful run of the dhcp_server_playbook.yml"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.25 – Successful run of the dhcp_server_playbook.yml</p>
			<p>With this running successfully, you can point your server toward the system to look for a DNS server. Since my<a id="_idIndexMarker261"/> system is currently on a DHCP server, it makes it harder to test as I am bridging the connections, but <a id="_idIndexMarker262"/>you can change the configuration to use a non-bridged connection such as an internal network in VirtualBox and you will be able to test the DHCP to see what <span class="No-Break">it provides.</span></p>
			<p>In this section, we learned how to automate the setup of a DHCP server. This allows us to provide DHCP to systems automatically. This allows the ease of use of connecting to a new network for client computers when running in an enterprise environment. Next, we will discuss the DNS and how that relates to <span class="No-Break">network connectivity.</span></p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor070"/>Learning about the DNS and why you need to know about it</h1>
			<p>DNS is important to learn about as it simplifies how we find addresses of networked devices on the world wide web. Without the DNS to allow FQDNs to translate into IP addresses, we would all have to search<a id="_idIndexMarker263"/> for websites via IP. This would become confusing as there are so many websites we use today that remembering all the IP addresses for them would be hectic and unmanageable. This would inevitably lead to a database that you would have to look at each time you wanted to go to a website. Thus, the DNS was born, and it provides that function allowing you to remember friendly names of websites in order to access them, such <span class="No-Break">as </span><a href="https://google.com"><span class="No-Break">google.com</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor071"/>Setting up DNS server configuration manually to provide DNS services</h2>
			<p>The first thing we will need <a id="_idIndexMarker264"/>to do is install the <strong class="source-inline">bind</strong> package for the DNS to be able to run. This allows for the daemon needed to serve the DNS entries<a id="_idIndexMarker265"/> to the systems. We will start by using <strong class="source-inline">sudo dnf install bind -y</strong>, with the output shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/Figure_5.26_B18607.jpg" alt="Figure 5.26 – Bind ﻿being installed through the package manager"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.26 – Bind being installed through the package manager</p>
			<p>After <strong class="source-inline">bind</strong> is installed, we<a id="_idIndexMarker266"/> are going to go to<a id="_idIndexMarker267"/> the documentation to get a clear look at the items that need to be set. We can find the <strong class="source-inline">named.conf</strong> file example shown at the following path in <span class="No-Break">the screenshot:</span></p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/Figure_5.27_B18607.jpg" alt="Figure 5.27 – Documentation location for bind settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.27 – Documentation location for bind settings</p>
			<p>Once we have installed <strong class="source-inline">bind</strong> for<a id="_idIndexMarker268"/> the DNS, we are <a id="_idIndexMarker269"/>going to configure the <strong class="source-inline">/etc/named.conf</strong> file in order to set up the needed parameters. This file’s location is shown in the following screenshot and edited with the <strong class="source-inline">sudo vi /</strong><span class="No-Break"><strong class="source-inline">etc/named.conf</strong></span><span class="No-Break"> command:</span></p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/Figure_5.28_B18607.jpg" alt="Figure 5.28 – Command to edit the /etc/named.conf file to configure ﻿the DNS"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.28 – Command to edit the /etc/named.conf file to configure the DNS</p>
			<p>You will notice that the<a id="_idIndexMarker270"/> first things<a id="_idIndexMarker271"/> that need to be set up are the listening ports and interfaces. The DNS listens on port <strong class="source-inline">53</strong> as that is the well-known (default) port for the DNS that is set up in the networking world. We are going to adjust the settings so that we listen for incoming requests on port <strong class="source-inline">53</strong> on any interface connected to the network. This configuration is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/Figure_5.29_B18607.jpg" alt="Figure 5.29 – Interface settings for DNS port 53"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.29 – Interface settings for DNS port 53</p>
			<p>The next portion of the <a id="_idIndexMarker272"/>configuration file<a id="_idIndexMarker273"/> we are concerned with is the location of the zone files. A zone file is what tells the DNS what IP addresses to give to an FQDN (these files are what are looked up when you search for a website such as <a href="https://www.google.com">www.google.com</a>), which then returns an IP address to your computer via the DNS so that it can reach the destination. In this case, as you can see in the following screenshot, the location of these files is the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">var/named</strong></span><span class="No-Break"> directory:</span></p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/Figure_5.30_B18607.jpg" alt="Figure 5.30 – Zone file directory location"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.30 – Zone file directory location</p>
			<p>When setting up an<a id="_idIndexMarker274"/> authoritative DNS <a id="_idIndexMarker275"/>server, or what is known as a top-level DNS server, you will want to set <strong class="source-inline">recursion</strong> to <strong class="source-inline">no</strong> for something like a lab environment or even an exam where you would like DNS to learn from other DNS servers' upstream information. Then, to save that information, such as a DNS entry, you will want <strong class="source-inline">recursion</strong> set to <strong class="source-inline">yes</strong>. In our case, for this example, we are setting it to <strong class="source-inline">no</strong> as we want to be top level, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/Figure_5.31_B18607.jpg" alt="Figure 5.31 – Recursion is set to no for authoritative DNS servers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.31 – Recursion is set to no for authoritative DNS servers</p>
			<p>The next thing we are going to<a id="_idIndexMarker276"/> set up is a zone file location for a master forward lookup zone. A forward lookup zone is used to<a id="_idIndexMarker277"/> look up the IP address of the DNS FQDN when provided. This allows for your computer or server to be able to find the item that it is attempting to reach over the internet or intranet. The <strong class="source-inline">example.com</strong> zone is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/Figure_5.32_B18607.jpg" alt="Figure 5.32 – The example.com zone file location provided to the named.conf file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.32 – The example.com zone file location provided to the named.conf file</p>
			<p>Next, we are going to set up a<a id="_idIndexMarker278"/> reverse zone lookup file location within the <strong class="source-inline">named.conf</strong> file. This is <a id="_idIndexMarker279"/>so that if you were to look up the IP address in your system, it would provide the FQDN for that IP address. This <strong class="bold">Pointer Record</strong> (<strong class="bold">PTR</strong>) allows for<a id="_idIndexMarker280"/> these types of lookups to occur and is necessary for things such as SSL certificates. In the following screenshot, we show you the setting up of the <strong class="source-inline">192.168.1.0</strong> PTR record, which, in our case, will point <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">example.com</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/Figure_5.33_B18607.jpg" alt="Figure 5.33 – PTR record location provided to named.conf file for 192.168.1.0 zone"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.33 – PTR record location provided to named.conf file for 192.168.1.0 zone</p>
			<p>Now that we have added the<a id="_idIndexMarker281"/> needed<a id="_idIndexMarker282"/> zone file locations to <strong class="source-inline">named.conf</strong>, we need to create the zone files for DNS to be able to look up information related to the DNS records. We can use the localhost example provided in <strong class="source-inline">/var/named/named.localhost</strong> to showcase the needed items for a zone file. This zone file example is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/Figure_5.34_B18607.jpg" alt="Figure 5.34 – Example zone file for DNS records"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.34 – Example zone file for DNS records</p>
			<p>As shown in the previous screenshot, there are some different items we need to go into detail about. First would <a id="_idIndexMarker283"/>be the <strong class="bold">Time to Live</strong> (<strong class="bold">TTL</strong>), which is how long a record will cache on a system before it needs to be refreshed. The next item is the <strong class="bold">Start of Authority</strong> (<strong class="bold">SOA</strong>), which <a id="_idIndexMarker284"/>dictates the primary authoritative server for the DNS records to be served from. After that, you <a id="_idIndexMarker285"/>will then add the <a id="_idIndexMarker286"/>email address (replacing the <strong class="source-inline">@</strong> with a <strong class="source-inline">.</strong>) of the administrator of the DNS server. The next important items listed in this file are the records themselves. These include <strong class="source-inline">A</strong> records (which are IPV4 DNS records), <strong class="source-inline">AAAA</strong> records (which are IPV6 records), and <strong class="source-inline">NS</strong> records (which are name server records and determine what the DNS servers that are utilized are set at and are needed for all zone files). The serial number is important as it helps to identify whether a DNS record that is retrieved by the host machine is up to date or <a id="_idIndexMarker287"/>not. The end <strong class="source-inline">.</strong> (dot) is used on the named items when they are FQDNs that can be reached. In the following screenshot, you will see how we set up a simple zone file <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">example.com</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/Figure_5.35_B18607.jpg" alt="Figure 5.35 – Zone file configured for example.com with A records and NS records set"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.35 – Zone file configured for example.com with A records and NS records set</p>
			<p>Following that zone setup, we will then set up the PTR zone for reverse DNS lookup. This is accomplished in the<a id="_idIndexMarker288"/> same format but with the reverse DNS layout of the IP address in reverse of the record, which allows servers to be discovered using the IP address instead of the name. This record type and setup are shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/Figure_5.36_B18607.jpg" alt="Figure 5.36 – Zone file for PTR reverse DNS lookup of the 192.168.1.0 subnet for example.com"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.36 – Zone file for PTR reverse DNS lookup of the 192.168.1.0 subnet for example.com</p>
			<p>After our configuration files <a id="_idIndexMarker289"/>are set up<a id="_idIndexMarker290"/> and our zone files are populated, we will then want to enable and start the named service provided by the <strong class="source-inline">bind</strong> package to provide the DNS to systems pointed at it for DNS records. This is accomplished with the commands in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/Figure_5.37_B18607.jpg" alt="Figure 5.37 – Start and enable the named service to provide ﻿the DNS"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.37 – Start and enable the named service to provide the DNS</p>
			<p>To ensure that the DNS is up and running, we will use the <span class="No-Break">following command:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo systemctl status named</pre>
			<p>We can now view the<a id="_idIndexMarker291"/> output status of the <a id="_idIndexMarker292"/>named service, as shown in the following screenshot, which shows it is actively running without <span class="No-Break">any failures:</span></p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/Figure_5.38_B18607.jpg" alt="Figure 5.38 – Status of the named service for ﻿the DNS"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.38 – Status of the named service for the DNS</p>
			<p>In order to ensure that<a id="_idIndexMarker293"/> the DNS<a id="_idIndexMarker294"/> service can be reached by outside systems, we need to allow it within the firewall. We will use the following commands to start, enable, and apply <span class="No-Break">firewall rules:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ sudo systemctl start named
[emcleroy@rhel1 ~]$ sudo systemctl enable named
[emcleroy@rhel1 ~]$ sudo firewall-cmd --permanent --add-service-dns
[emcleroy@rhel1 ~]$ sudo firewall-cmd --reload</pre>
			<p>The <strong class="source-inline">firewalld</strong> setup, start and enable output, and commands are shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/Figure_5.39_B18607.jpg" alt="Figure 5.39 – Allowed DNS and then reloaded the firewall for connectivity"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.39 – Allowed DNS and then reloaded the firewall for connectivity</p>
			<p>To ensure that the system is <a id="_idIndexMarker295"/>providing <a id="_idIndexMarker296"/>the DNS records that we set up in the zone files, we will do a dig lookup on the specific DNS server for a system we propagated in the zone file. Keep in mind that whenever you update a zone file, you need to reload <strong class="source-inline">named.service</strong> as well. We will use the <strong class="source-inline">dig</strong> command to do a <span class="No-Break">DNS lookup:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ dig rhel2.example.com @192.168.1.198</pre>
			<p>The following screenshot shows the <strong class="source-inline">dig or lookup of a record from a DNS server</strong> from the DNS<a id="_idIndexMarker297"/> server we<a id="_idIndexMarker298"/> created the information <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">rhel2.example.com</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/Figure_5.40_B18607.jpg" alt="Figure 5.40 – DNS dig lookup of the rhel2.example.com server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.40 – DNS dig lookup of the rhel2.example.com server</p>
			<p>In this section, we learned how to manually set up a DNS server. This is crucial in enhancing your understanding of how the DNS works and why it is used. We showed how forward and reverse zones are set up to allow for connectivity as well as installing the service needed. Next, we are going to delve into automating a DNS server creation using <span class="No-Break">Ansible Automation.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor072"/>Automating DNS server configuration to provide DNS services</h2>
			<p>Next up, we are going to learn <a id="_idIndexMarker299"/>how to set up a DNS server using Ansible Automation through Jinja templates as we did with our DHCP <a id="_idIndexMarker300"/>setup. <a id="_idTextAnchor073"/>These files might need to be altered for your setup, but you will come to understand the principles of how to complete the <span class="No-Break">Ansible playbook.</span></p>
			<p>We are going to start by creating the directory for the playbook using the <span class="No-Break">following commands:</span></p>
			<pre class="console">
[emcleroy@rhel1 ~]$ ls
[emcleroy@rhel1 ~]$ cd Documents/
[emcleroy@rhel1 ~]$ mkdir dns_server</pre>
			<p>The output of these commands can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/Figure_5.41_B18607.jpg" alt="Figure 5.41 – Creating the playbook directory"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.41 – Creating the playbook directory</p>
			<p>We are then going to create <a id="_idIndexMarker301"/>the inventory inside the new directory. This inventory example can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/Figure_5.42_B18607.jpg" alt="Figure 5.42 – Example of an inventory"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.42 – Example of an inventory</p>
			<p>First, we will start writing our playbook and then move on to creating the Jinja2 templates. As always, we will begin our playbook <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
---
- name: DNS server playbook
  hosts: rhel1.example.com
  become: true
  become_method: sudo</pre>
			<p>Next, we will move on to the tasks that <a id="_idIndexMarker302"/>we need to complete in order to install <strong class="source-inline">bind</strong>, which installs <strong class="source-inline">named.service</strong>, which runs the DNS server. We will then copy over the configuration files for <strong class="source-inline">named.conf</strong> and the zones. Then, we will update the firewall and test the name resolution. Please keep in <a id="_idIndexMarker303"/>mind that you will want to substitute any IP addresses for those of your systems and your DNS server for this playbook. The tasks are <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
  tasks:
    - name: Install dns service
      package:
        name: bind
        state: latest
    - name: Copy dns main config
      template:
        src: "{{ playbook_dir }}/named.conf.j2"
        dest: /etc/named.conf
    - name: Copy dns forward zone configs
      template:
        src: "{{ playbook_dir }}/example.com.zone.j2"
        dest: /var/named/example.com.zone
    - name: Copy dns reverse zone configs
      template:
        src: "{{ playbook_dir }}/1.168.192.zone.j2"
        dest: /var/named/1.168.192.zone
    - name: Start and enable DNS
      service:
        name: named
        state: restarted
        enabled: true
    - name: Enable DNS firewall rule
      command:
        cmd: firewall-cmd --permanent --add-service=dns
    - name: Reload firewall
      command:
        cmd: firewall-cmd --reload
    - name: Install DIG to check configuration
      package:
        name: bind-utils
        state: latest
    - name: Run dig to test configuration
      command:
        cmd: "dig rhel2.example.com @192.168.1.198"</pre>
			<p>Once that is complete, we will <a id="_idIndexMarker304"/>create our <strong class="source-inline">named.conf</strong> and zone files as <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">j2</strong></span><span class="No-Break"> templates.</span></p>
			<p>The <strong class="source-inline">named.conf</strong> file can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/Figure_5.43_B18607.jpg" alt="Figure 5.43 – The named.conf file truncated for reading"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.43 – The named.conf file truncated for reading</p>
			<p>The following screenshot shows<a id="_idIndexMarker305"/> the forward <span class="No-Break">zone file:</span></p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/Figure_5.44_B18607.jpg" alt="Figure 5.44 – Forward zone file example.com.zone.j2"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.44 – Forward zone file example.com.zone.j2</p>
			<p>Finally, we have the reverse <a id="_idIndexMarker306"/>zone file for the PTR records in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/Figure_5.45_B18607.jpg" alt="Figure 5.45 – Reverse zone file 1.168.192.zone.j2"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.45 – Reverse zone file 1.168.192.zone.j2</p>
			<p>After creating that, we will<a id="_idIndexMarker307"/> run the playbook using the following command again, which illustrates if you need to run the command without SSH keys set up. If you have SSH keys set up, you can omit <strong class="source-inline">-k -ask-become</strong>. Also, we are going to add verbosity so that we can see more of the standard out type of logs output by adding <strong class="source-inline">-v</strong>; this command is <span class="No-Break">as follows:</span></p>
			<pre class="console">
$ ansible-playbook -i inventory dns_server_playbook.yml --ask-become -u emcleroy -k -v</pre>
			<p>The following screenshot shows a successful <span class="No-Break">playbook run:</span></p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/Figure_5.46_B18607.jpg" alt="Figure 5.46 – Playbook output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.46 – Playbook output</p>
			<p>This wraps up working with<a id="_idIndexMarker308"/> Ansible Automation to automate your DNS servers. The use of Ansible Automation allows you to create these servers easily, and when you need to replicate them for any reason, such<a id="_idIndexMarker309"/> as <strong class="bold">Disaster Recovery</strong> (<strong class="bold">DR</strong>), you are able to do so quickly. This allows you to ensure that the configurations are copied over correctly every time without errors that can sometimes occur during <span class="No-Break">human intervention.</span></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor074"/>Summary</h1>
			<p>In this chapter, we learned about IP addressing, DHCP, and DNS. We learned what is needed to get you started connecting on the internet and how it applies to you and your company. We were able to set up these programs to establish automatic DNS and DHCP via your very own servers. This allows you to control how your network is set up and how you connect to the intranet or internet. In the next chapter, we are going to learn about printers and email. The ability to set up these services is crucial to normal enterprise infrastructure and an important part of every company. Email servers and print servers are important as they allow the company to perform day-to-day business without faltering. I look forward to seeing you in the <span class="No-Break">next chapter.</span></p>
		</div>
	

		<div id="_idContainer136" class="Content">
			<h1 id="_idParaDest-70"><a id="_idTextAnchor075"/>Part 3: Red Hat Linux 8 – Configuring and Maintaining Applications with Automation and a Comprehensive Review with Exam Tips</h1>
			<p>In this part, you will learn to set up and maintain applications manually and automatically, and we will also provide a comprehensive review and tips and tricks to pass the <span class="No-Break">EX358 exam.</span></p>
			<p>This part contains the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18607_06.xhtml#_idTextAnchor076"><em class="italic">Chapter 6</em></a>, <em class="italic">Printer and Email – Setting up Printers and Email Services on Linux Servers</em></li>
				<li><a href="B18607_07.xhtml#_idTextAnchor085"><em class="italic">Chapter 7</em></a>, <em class="italic">Databases – Setting up and Working with MariaDB SQL Databases</em></li>
				<li><a href="B18607_08.xhtml#_idTextAnchor094"><em class="italic">Chapter 8</em></a>, <em class="italic">Web Servers and Web Traffic – Learning How to Create and Control Traffic </em></li>
				<li><a href="B18607_09.xhtml#_idTextAnchor104"><em class="italic">Chapter 9</em></a>,<em class="italic"> Comprehensive Review and Test Exam Questions</em></li>
				<li><a href="B18607_10.xhtml#_idTextAnchor123"><em class="italic">Chapter 10</em></a>, <em class="italic">Tips and Tricks to Help with the Exam </em></li>
			</ul>
		</div>
	</body></html>