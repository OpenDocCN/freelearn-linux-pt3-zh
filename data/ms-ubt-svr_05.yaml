- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Managing Files and Directories
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理文件和目录
- en: 'In *Chapter 4*, *Navigating and Essential Commands*, we started looking deeper
    into Linux commands. We went over the most essential commands and covered the
    filesystem layout, as well as various methods to view the contents of files. In
    this chapter (as well as the next), we’ll continue to expand on the command line
    and become more efficient while using the terminal. This time around, we’ll expand
    a bit further on file management, take a look at input/output streams, and we’ll
    also develop an understanding of symbolic links. Along the way, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第4章*，*导航和基本命令* 中，我们开始深入了解 Linux 命令。我们回顾了最基本的命令，讲解了文件系统的布局，以及查看文件内容的各种方法。在这一章（以及下一章）中，我们将继续扩展命令行知识，提高使用终端的效率。这一次，我们将进一步讨论文件管理，研究输入/输出流，并了解符号链接。在这个过程中，我们还将涉及：
- en: Copying, moving, and renaming files and directories
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制、移动和重命名文件和目录
- en: Editing files with the Nano and Vim text editors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Nano 和 Vim 文本编辑器编辑文件
- en: Input and output streams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入和输出流
- en: Using symbolic and hard links
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用符号链接和硬链接
- en: Let’s begin the chapter by taking a look at some methods we can use to alter
    the files and directories in the filesystem, such as copying and moving them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些方法开始，看看我们如何在文件系统中修改文件和目录，比如复制和移动它们。
- en: Copying, moving, and renaming files and directories
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制、移动和重命名文件和目录
- en: At this point, you should know how to move around within the filesystem (commands
    such as `cd`), inspect the contents of directories (`ls`), and even how to create
    empty files (the `touch` command). We even know how to remove files as well, such
    as executing the `rm` command against a file or directory. But until now, we haven’t
    looked at moving files around within your Ubuntu filesystem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你应该知道如何在文件系统中移动（例如 `cd` 命令）、检查目录内容（`ls`），甚至如何创建空文件（`touch` 命令）。我们也知道如何删除文件，例如对文件或目录执行
    `rm` 命令。但直到现在，我们还没有深入了解如何在你的 Ubuntu 文件系统中移动文件。
- en: 'First, to make a copy of a file or directory, we use the `cp` command. Copying
    a file is fairly easy, and such a command would look similar to the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要复制文件或目录，我们使用 `cp` 命令。复制文件相对简单，类似于以下的命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In that example, `file2` is created as an exact copy of `file1`. Copying a
    file is useful in many situations, some of the most common of which are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`file2` 是 `file1` 的精确副本。复制文件在许多情况下都很有用，以下是其中一些最常见的情况：
- en: Copying a file to a backup medium, such as an external drive or network share
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件复制到备份介质，例如外部硬盘或网络共享
- en: Creating a copy of a file before making a change, such as before editing a very
    important text file
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行更改之前创建文件的副本，比如在编辑一个非常重要的文本文件之前
- en: Duplicating a log file for a point-in-time analysis
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制日志文件以进行时间点分析
- en: 'Let’s look at the last bullet point as another good example. We can capture
    a copy of the system log and store it in our current working directory by executing
    the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下最后一个要点作为另一个很好的例子。我们可以通过执行以下命令捕获系统日志并将其保存在当前工作目录中：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `cp` command is fairly simple: we give it a path to a file to copy, and
    then we type the path to the destination and desired filename. We also use `sudo`
    due to the fact that the `syslog` may not be readable by normal users by default,
    depending on the configuration. In the case of this command, a copy of the original
    `syslog` file will be saved in your current working directory.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp` 命令相当简单：我们提供一个文件的路径来复制，然后输入目标路径和所需的文件名。由于 `syslog` 默认情况下可能无法被普通用户读取，我们还需要使用
    `sudo`。在这个命令中，原始的 `syslog` 文件副本将保存在当前工作目录中。'
- en: For this particular example, log files are constantly being written to. It can
    sometimes be hard to troubleshoot an issue that occurred during a certain time
    if the file is continually expanding. That’s not the only reason though. We certainly
    wouldn’t want to make an accidental change to the log file and risk contaminating
    it or losing important information.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，日志文件不断地被写入。如果文件一直在扩展，有时很难排查发生在某个特定时间的问题。 但这并不是唯一的原因。我们当然不希望意外更改日志文件，并冒着污染或丢失重要信息的风险。
- en: 'The previous command can actually be simplified a bit:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令实际上可以稍微简化一下：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In that example, we removed the target path and name and replaced it with a
    period. The reason this works is that the period represents our current working
    directory. This isn’t specific to the `cp` command either. There actually is a
    directory named with a period in every directory, which is essentially a pointer
    to the current directory. Therefore, if you’re already inside the directory you
    want the file to be copied to, you don’t have to type the path. You don’t have
    to type the name either if you want the name of the file to be the same as the
    source.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们移除了目标路径和名称，并用一个句点替代。这之所以有效，是因为句点表示我们的当前工作目录。这不仅适用于`cp`命令。实际上，每个目录中都有一个名为句点的目录，它本质上是当前目录的指针。因此，如果你已经进入了希望复制文件的目录，就不需要输入路径。如果你希望文件名和源文件相同，那么也不需要输入名称。
- en: Copying files (as well as moving them, which we’ll look at next) is potentially
    destructive. If the target path and name already exist, then the target will be
    overwritten. By default, you won’t see a confirmation before the target file is
    overwritten. As with all commands, take care that you really want to do whatever
    it is you’re telling the command-line interpreter to do.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 复制文件（以及移动文件，我们接下来将讨论）可能是破坏性的。如果目标路径和名称已经存在，那么目标文件将被覆盖。默认情况下，在目标文件被覆盖之前，你不会看到任何确认提示。和所有命令一样，请小心你所指示命令行解释器执行的操作。
- en: 'When it comes to copying directories, the `cp` command by itself won’t do the
    trick:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到复制目录时，单独使用`cp`命令是无法完成的：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `/var/log/apt` directory contains log files that keep track of transactions
    performed with the `apt` command. It can be useful to keep an eye on what your
    other admins are installing. When it comes to this example though, the previous
    command will fail with the following error:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`/var/log/apt`目录包含记录通过`apt`命令执行的事务的日志文件。保持对其他管理员所安装内容的监控是很有用的。然而，在这个示例中，之前的命令会因为以下错误而失败：'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The error literally tells you what to do about it, and essentially the error
    is telling you that directories are omitted by default. In order to copy directories,
    you’ll need to include the `-r` option. This stands for *recursive*, which is
    an option you’ll see as a possibility for a handful of Linux commands. It tells
    the command-line interpreter to not only grab the object at the path you specified
    but to do so recursively and include child objects as well. Therefore, the following
    command will work:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息会明确告诉你如何处理，它基本上是在告诉你目录默认情况下是被忽略的。为了复制目录，你需要加上`-r`选项。`-r`代表*递归*，这是许多Linux命令可能会使用的选项。它告诉命令行解释器，不仅要抓取你指定路径的对象，还要递归地包含子对象。因此，以下命令将有效：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With that command, a local copy of the `/var/log/apt` directory will be stored
    in your current working directory, along with the contents.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该命令时，`/var/log/apt`目录及其内容将会存储在当前工作目录中。
- en: 'When it comes to moving a file or directory from one place to another, we use
    the `mv` command. The syntax is almost exactly the same as the `cp` command. The
    difference is that instead of copying a file or directory, we’re moving it. In
    that regard, it’s probably self-explanatory how it works. Consider the following
    example commands:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到将文件或目录从一个地方移动到另一个地方时，我们使用`mv`命令。其语法几乎与`cp`命令完全相同。不同之处在于，我们不是复制文件或目录，而是移动它。就这点而言，它的工作原理可能是不言自明的。考虑以下示例命令：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the first example, we’re assuming that `file1` is in our current working
    directory. We’re grabbing that file and moving it to `/path/to/new/directory`
    and giving it the same name of `file1` in that new directory. Just like with the
    `cp` command, we could’ve omitted the filename at the target, since it’s staying
    the same. If the file already exists in the target directory with that name, it
    will be overwritten. So, the `mv` command is also potentially destructive, but
    more so when compared to `cp` since you are moving, instead of copying.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们假设`file1`位于当前工作目录中。我们将该文件抓取并移动到`/path/to/new/directory`，并在新目录中使用相同的文件名`file1`。就像使用`cp`命令一样，我们可以省略目标文件名，因为它保持不变。如果目标目录中已经存在同名文件，它将被覆盖。因此，`mv`命令也是潜在的破坏性命令，但相比于`cp`命令，其破坏性更大，因为你是在移动文件，而不是复制。
- en: The second `mv` command is a bit more interesting, because in that example we’re
    renaming a file. In Linux, there’s no dedicated rename command, so the `mv` command
    is used for that purpose. In fact, `mv` is somewhat of a Swiss Army knife due
    to the fact it serves multiple purposes. With it, you can move a file or directory,
    rename it, and also move a file to overwrite another file in a different location.
    It all depends on the source and destination paths. If the target exists, it will
    be overwritten. If not, the file will be renamed and/or moved to that path.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`mv`命令稍微有点不同，因为在这个例子中我们正在重命名一个文件。在Linux中，没有专门的重命名命令，因此`mv`命令被用来完成这个任务。事实上，`mv`可以算是一把瑞士军刀，因为它具有多种功能。通过它，你可以移动文件或目录、重命名文件，甚至将一个文件移动到另一个位置以覆盖另一个文件。具体操作取决于源路径和目标路径。如果目标文件存在，它将被覆盖；如果目标文件不存在，文件将被重命名和/或移动到该路径。
- en: 'When managing files, you’ll certainly come to a situation where you need to
    manage multiple files or directories. It’s worth noting that the `cp` command,
    as well as the `mv` command, can be used with multiple objects at once; for example,
    if you have three directories, such as `dir1`, `dir2`, and `dir3`, and you need
    to move them into a new sub-directory. You could execute three `mv` commands to
    move each one separately, but you can also move all three with a single `mv` command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理文件时，你肯定会遇到需要管理多个文件或目录的情况。值得注意的是，`cp`命令和`mv`命令都可以一次处理多个对象；例如，如果你有三个目录，比如`dir1`、`dir2`和`dir3`，并且需要将它们移动到一个新的子目录中。你可以执行三条`mv`命令分别移动每个目录，但你也可以用一条`mv`命令一次性将三个目录全部移动：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The same holds true with `cp` and with files; both `cp` and `mv` are set up
    to allow you to move or copy multiple directories or files with a single command.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp`和文件的情况相同；`cp`和`mv`命令都可以让你通过一个命令来移动或复制多个目录或文件。'
- en: Now that we know how to move files around, we should also take a look at how
    to edit them. There are many text editors available to us on the Ubuntu platform,
    with Nano and Vim being among the most common. In the next section, we’ll go over
    the basics of both.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何移动文件了，接下来我们也应该了解如何编辑文件。在Ubuntu平台上，我们有许多可用的文本编辑器，其中Nano和Vim是最常用的。接下来的部分，我们将介绍这两种编辑器的基本操作。
- en: Editing files with the Nano and Vim text editors
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Nano和Vim文本编辑器编辑文件
- en: Now that we know how to copy and move files, it would be useful to know how
    to edit them. There are multiple forms of text editors for Ubuntu, some available
    in the command line, and others in graphical environments such as the text editor
    in the desktop version.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何复制和移动文件了，接下来了解如何编辑文件会非常有用。Ubuntu提供了多种文本编辑器，其中一些在命令行中可用，另一些则是在图形环境下使用的，比如桌面版的文本编辑器。
- en: Some may feel that command-line text editors are more complicated than **Graphical
    User Interface** (**GUI**) editors (and to be honest, they can be), but the main
    benefit is that you can use the same editor regardless of whether or not you have
    a GUI. In a way, this means the non-graphical editors are a bit more portable,
    and you can rely on them more. Almost all installations of Ubuntu will include
    the `nano` text editor, and you can rely on that more often than something like
    a particular GUI editor being available. In addition, the `vim` editor is another
    popular consideration. It’s a bit more advanced than `nano`, but in my opinion,
    much more powerful. In the following sections, we’ll look at both `nano` and `vim`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会觉得命令行文本编辑器比**图形用户界面**（**GUI**）编辑器更复杂（老实说，确实可能如此），但它的主要优点是，无论你是否有GUI，你都可以使用相同的编辑器。从某种意义上来说，这意味着非图形编辑器更具便携性，且更加可靠。几乎所有的Ubuntu安装都包括`nano`文本编辑器，你可以更多地依赖它，而不必担心某个特定的GUI编辑器是否可用。此外，`vim`编辑器也是另一个流行的选择。它比`nano`更为高级，但在我看来，功能也更强大。在接下来的部分，我们将一起学习`nano`和`vim`的使用。
- en: Editing with Nano
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Nano编辑器
- en: 'The `nano` editor, while more basic in terms of features, still has a fairly
    strong following. Actually, if you haven’t already noticed, a person’s choice
    of editor can cause somewhat of a debate in the Linux community. To launch the
    `nano` editor, it’s as simple as running the `nano` command. If you don’t provide
    `nano` with a filename, it simply starts with an empty window, as shown in the
    following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`nano`编辑器虽然在功能上较为基础，但依然有相当多的用户群体。事实上，如果你还没有注意到，选择编辑器其实在Linux社区中能引发一场小小的辩论。启动`nano`编辑器非常简单，只需运行`nano`命令。如果你不提供文件名，`nano`将会启动一个空白的窗口，如下图所示：'
- en: '![](img/B18425_05_01.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_05_01.png)'
- en: 'Figure 5.1: The nano text editor, with no file selected'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：`nano`文本编辑器，未选择文件
- en: You can start typing right away, and when you want to save the file, you can
    simply press *Ctrl + o* to do so. On the bottom of the `nano` screen, you’ll see
    an overview of shortcuts, including the method for saving the file I just mentioned
    (which it refers to as **Write Out**). As you can see then*, Ctrl + x* is how
    you exit the editor and go back to the command line.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以马上开始输入，当你想保存文件时，只需按*Ctrl + o*即可。在`nano`屏幕的底部，你会看到快捷键的概述，包括我刚提到的保存文件的方法（它称之为**写入文件**）。如你所见，*Ctrl
    + x*是退出编辑器并返回命令行的方法。
- en: One trick that I love (which also works well with `vim`) is pressing *t* and
    then *z* while holding *Ctrl* when you have `nano` open, which will make it disappear.
    Normally, you don’t have to press *Ctrl* and *t* in order to background a process,
    but `nano` is the exception in this case.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢的一个技巧是（它也适用于`vim`），当你在使用`nano`时，按住*Ctrl*，然后按*t*再按*z*，这会让它消失。通常，你不需要按*Ctrl*和*t*来将进程放入后台，但在`nano`的情况下是个例外。
- en: Effectively, it’s the same as minimizing it. You can bring the `nano` window
    back by executing `fg`, which is short for *foreground*. The ability to background
    and foreground an application in the terminal is part of process management, which
    is actually something we’ll talk about in *Chapter 7*, *Controlling and Managing
    Processes*, but we’re giving you this tip ahead of time, to help you on your way!
    When it comes to editing files, sometimes it makes sense to send the editor to
    the background and bring it back later.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就像是将其最小化。你可以通过执行`fg`来将`nano`窗口恢复回来，`fg`是*foreground*的缩写。能够在终端中将应用程序放入后台或恢复到前台是进程管理的一部分，实际上这是我们将在*第七章*，*控制与管理进程*中讨论的内容，但我们提前给你这个小技巧，帮助你顺利前进！在编辑文件时，有时将编辑器发送到后台然后稍后再回来是很有意义的。
- en: 'As you can probably guess, you can also use the `nano` command, with a target
    path and filename, to have the editor come up with a file already open. For example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，你也可以使用`nano`命令，并提供目标路径和文件名，使编辑器直接打开一个已打开的文件。例如：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This command will result in the file opening in `nano`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会导致文件在`nano`中打开：
- en: '![](img/B18425_05_02.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_05_02.png)'
- en: 'Figure 5.2: The nano text editor, with the syslog file open'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：`nano`文本编辑器，打开了syslog文件
- en: To be fair, editing a log file directly is probably not a good idea in practice,
    but the example works. The syslog is a file you may want to open and inspect,
    but it would be a good idea to check the size of the syslog file with the `ls
    -lh /var/log/syslog` command to make sure it’s not excessively large in size,
    which can slow down the server.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，直接编辑日志文件在实践中可能不是个好主意，但这个例子是有效的。`syslog`是你可能想要打开并检查的文件，但最好先通过`ls -lh /var/log/syslog`命令检查`syslog`文件的大小，确保它不是过大，否则会拖慢服务器速度。
- en: All of that aside, the takeaway here is that you can open a file with `nano`
    directly by simply providing it with a path to something. Inside the editor window,
    you can move around with the arrow keys, just like you would in a graphical editor.
    You can also search for a specific string of text, by pressing *Ctrl + w* for
    **Where Is**, as is mentioned in the list of actions near the bottom.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 抛开这些不谈，重点是你可以通过直接提供文件路径来用`nano`打开文件。在编辑器窗口内，你可以像在图形化编辑器中一样使用箭头键进行移动。你还可以通过按*Ctrl
    + w*来搜索特定的文本字符串，这在底部的操作列表中有提到。
- en: In addition, note the text in the screenshot that is highlighted in red. It’s
    simply telling us that we don’t have access to edit the file. In that example,
    I didn’t use `sudo` because I didn’t intend on making any changes to the file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，注意截图中以红色高亮显示的文字。它只是告诉我们我们没有权限编辑该文件。在那个示例中，我没有使用`sudo`，因为我并不打算对文件进行任何更改。
- en: Sometimes, I’ll open files in an editor that I don’t have write permission to
    make changes to, which serves as a fail-safe in case I accidentally do make a
    change (I won’t be able to save the file without `sudo`). To make a real change,
    I can close the file and reopen it with `sudo`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我会在一个没有写权限的编辑器中打开文件，这样可以防止我不小心进行更改（如果没有`sudo`，我将无法保存文件）。要进行真正的更改，我可以关闭文件，然后使用`sudo`重新打开它。
- en: Anyway, the `nano` editor is fairly simplistic. Is there more to it than that?
    Sure, but the most important thing to know is how to open files, edit them, and
    save them, which we’ve covered in this section. Of course, you can practice with
    the actions that are presented to you at the bottom of the window to go beyond
    normal usage.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，`nano` 编辑器相当简洁。它除了这些还有更多功能吗？当然有，但最重要的是了解如何打开文件、编辑文件并保存文件，这些我们在本节中已经讲解过了。当然，你可以通过窗口底部提供的操作来练习，超越正常使用。
- en: Now, let’s take a look at Vim.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下 Vim。
- en: Editing with Vim
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Vim 编辑
- en: 'Vim is my favorite editor, and the one I use most often. It’s a little on the
    advanced side, but it’s not to the point where it’s frustrating. By default, it’s
    not actually installed. Personally, I prefer the `vim-nox` package, which can
    be installed by executing the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Vim 是我最喜欢的编辑器，也是我使用最频繁的编辑器。它稍微有些进阶，但并不会让人感到沮丧。默认情况下，它并没有安装。就个人而言，我更喜欢安装 `vim-nox`
    包，可以通过执行以下命令进行安装：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It really doesn’t matter which of the variations of `vim` you install. Each
    variation adds its own features. In the case of `vim-nox`, it has built-in support
    for scripting languages but is not really all that different from standard `vim`
    in other regards. The concepts you’ll learn here are not specific to this version.
    Just like `nano`, the `vim` editor can be called by itself by entering the command
    `vim` with no options, or with a path to a file, such as `vim /home/myuser/myfile.txt`.
    With no file chosen, `vim` will display its default help text. It gives you some
    of the default commands, such as `:q` for quitting the editor:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你安装哪个版本的 `vim` 其实并不重要。每个版本都会添加一些自己的功能。以 `vim-nox` 为例，它内置了对脚本语言的支持，但在其他方面与标准的
    `vim` 并没有太大区别。你在这里学到的概念并不限于这个版本。就像 `nano` 一样，你可以通过输入 `vim` 命令来调用 `vim` 编辑器，不带任何选项，或者带上文件路径，比如
    `vim /home/myuser/myfile.txt`。如果没有选择文件，`vim` 会显示默认的帮助文本。它会给出一些默认命令，比如 `:q` 用于退出编辑器：
- en: '![](img/B18425_05_03.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_05_03.png)'
- en: 'Figure 5.3: The vim text editor, with no file open'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：vim 文本编辑器，未打开文件
- en: When you start `vim`, you start in *command mode*, which is one of several different
    modes the editor can be in. In command mode, you can’t actually edit text. Command
    mode allows you to run commands, as the name implies, which can allow you to manipulate
    text in really neat ways.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 `vim` 时，你会进入 *命令模式*，这是编辑器的多种模式之一。在命令模式下，你不能直接编辑文本。正如其名，命令模式允许你运行命令，这样可以以非常巧妙的方式操作文本。
- en: If you want to edit a file as you were already doing in `nano`, you’ll need
    to switch to *insert mode* to do so. You can switch to insert mode by pressing
    the *Insert* key on your keyboard, or the *i* letter key. Once you’re in insert
    mode, you can start typing as you normally would in any other editor. You’ll move
    the cursor around with the arrow keys, and insert text wherever you want. Outside
    of insert mode, you can also navigate with the *h*, *j*, *k*, and *l* keys in
    place of the arrow keys (which some users actually prefer). To exit insert mode,
    you can press *Esc*. That will bring you back to command mode.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想像在 `nano` 中那样编辑文件，你需要切换到 *插入模式*。你可以通过按键盘上的 *Insert* 键，或 *i* 键来切换到插入模式。一旦进入插入模式，你可以像在任何其他编辑器中那样开始输入文本。你可以用方向键移动光标，并在任何地方插入文本。除了插入模式之外，你也可以使用
    *h*、*j*、*k* 和 *l* 键代替方向键来进行导航（有些用户实际上更喜欢这种方式）。要退出插入模式，你可以按 *Esc* 键。那样就会回到命令模式。
- en: 'At first, the different modes of `vim` can be a bit confusing to newcomers.
    For me, I see it as somewhat of a superpower. With `vim`, you have a mode for
    editing text and another dedicated mode for manipulating it. When it comes to
    text manipulation, that’s one of the strongest features of `vim`. For an example
    of this, consider the following hypothetical file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，`vim` 的不同模式可能会让新手有些困惑。对我来说，它有点像一种超能力。使用 `vim`，你有一个专门用于编辑文本的模式，还有一个专门用于操作文本的模式。谈到文本操作，这也是
    `vim` 最强大的功能之一。比如，考虑以下这个假设文件：
- en: '![](img/B18425_05_04.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_05_04.png)'
- en: 'Figure 5.4: The vim text editor, with a sample file'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：vim 文本编辑器，显示一个示例文件
- en: 'I don’t know why, but something about that file seems off to me. We’ll need
    to make a very important correction to try to fix it. First, you can see from
    the screenshot that the editor was left in insert mode. To do some text manipulation,
    we first need to press *Esc* to go back to command mode. Once there, we can get
    ready to type a command. And the command we want to type is this one:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道为什么，但总觉得这个文件有些不对劲。我们需要做一个非常重要的修改来尝试修复它。首先，你可以从截图中看到编辑器停留在了插入模式。要进行文本操作，我们需要先按
    *Esc* 键返回到命令模式。一旦进入命令模式，我们就可以准备输入一个命令。我们要输入的命令是：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I don’t know about you, but personally, I think the file looks better now after
    running that command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你怎么想，但就我个人而言，我认为在执行了那个命令后，文件看起来更好了：
- en: '![](img/B18425_05_05.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_05_05.png)'
- en: 'Figure 5.5: The vim text editor, after running a sample command'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：运行示例命令后的 vim 文本编辑器
- en: Technically, Linux is a kernel and not an operating system. Ubuntu, a distribution
    of Linux, is the closest equivalent of an operating system for us. But I’m willing
    to let that slide, for now. Other than that, in my opinion, this version of the
    file is more accurate!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，Linux 是一个内核，而不是操作系统。Ubuntu 作为 Linux 的一个发行版，是我们最接近的操作系统。但暂且不提这一点。在我看来，这个版本的文件更准确！
- en: This was a more advanced example of `vim` usage that would normally be outside
    the scope of this book. I wanted to show you an example of the power of this amazing
    editor, and finding and replacing text is just one of the many things we can do
    with it. Some people (including myself) even go as far as to install plugins to
    essentially turn `vim` into an **Integrated Development Environment** (**IDE**).
    In the example we’ve just used, we were able to find and replace all occurrences
    of a string with another string. This was also an example of the types of tasks
    we carry out in command mode, which allows us to manipulate text and enter more
    advanced commands. With this admittedly contrived example, you can immediately
    see the value of having multiple modes in `vim`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更高级的 `vim` 使用示例，通常超出了本书的范围。我想给你展示这个强大编辑器的一个例子，查找和替换文本只是我们可以用它做的众多操作之一。有些人（包括我自己）甚至安装插件，把
    `vim` 转变成 **集成开发环境** (**IDE**)。在我们刚才使用的例子中，我们能够将所有出现的字符串替换成另一个字符串。这也是我们在命令模式下执行的任务之一，命令模式允许我们操控文本并输入更高级的命令。通过这个尽管有些牵强的例子，你可以立刻看到
    `vim` 多模式的价值。
- en: 'I’ve been using `vim` for about a decade or so because I can never seem to
    figure out how to exit it. Okay, to be fair, that joke is getting to be a bit
    old now. If you’ve already been using Ubuntu or any other Linux distribution for
    a while, that joke probably made you cringe a little. If that was the first time
    you’ve seen it, then I’m glad I was the one that introduced you to it—for some
    reason, `vim` has a reputation for being difficult to exit. But that’s not really
    true at all, it’s actually quite easy. In command mode, you simply enter `:q`
    to exit the editor:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经使用 `vim` 大约十年了，因为我似乎永远也弄不明白如何退出它。好吧，公平地说，这个笑话现在有点过时了。如果你已经使用 Ubuntu 或其他 Linux
    发行版一段时间了，可能会对这个笑话有些许反感。如果这是你第一次看到这个笑话，那我很高兴是我向你介绍了它——因为某种原因，`vim` 有个很难退出的声誉。但其实并不是真的，它其实非常简单。在命令模式下，你只需输入
    `:q` 即可退出编辑器：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you’ve made changes, the `:q` command won’t let you exit, but you can force
    exit if you add an exclamation mark, so the command becomes `:q!`. If you’d also
    like to save changes while exiting, add `w`, so the command inside `vim` would
    become:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进行了更改，`:q` 命令将无法退出，但你可以通过添加感叹号强制退出，命令变成 `:q!`。如果你还想在退出时保存更改，可以加上 `w`，那么在
    `vim` 中的命令就变成了：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Essentially, we’re exiting the editor (`q`) and writing the file at the same
    time (`w`). In command mode, commands start with a colon (`:`) and then the actual
    command. There are so many commands available that it’s impossible to talk about
    them all in one chapter. What I’ll do, then, is mention some that I consider to
    be the most important.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，我们是在同时退出编辑器（`q`）并写入文件（`w`）。在命令模式下，命令以冒号（`:`）开头，后跟实际命令。由于有太多命令可以使用，所以不可能在一章中全部讲完。那么我会提到一些我认为最重要的命令。
- en: 'First, it’s actually possible to run a shell command without leaving `vim`
    by using the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，实际上可以通过使用以下命令，在不退出 `vim` 的情况下运行一个 shell 命令：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The exclamation mark allows you to run a command, and then you type the actual
    command. For example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 感叹号允许你运行一个命令，然后输入实际的命令。例如：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous example will show you the contents of the `/var/log` directory,
    and then you can press *Enter* to return back to `vim`. The `:sp` command is short
    for *split*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例会显示`/var/log`目录的内容，然后你可以按*Enter*键返回到`vim`。`:sp`命令是*split*的简写：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this case, `vim` is able to show you more than one file at a time in the
    same window, effectively splitting the window to show you both files. With `:split`,
    or `:sp` for short (both do the same thing), it will either split the file into
    two views (the same file open in each) or it will show a separate file in the
    other split if you give it a filename. This command will split the file horizontally:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`vim`能够在同一窗口中同时显示多个文件，通过有效地分割窗口来展示这两个文件。使用`:split`，或者简写为`:sp`（两者作用相同），它将把文件分成两个视图（每个视图中显示相同的文件），或者如果你提供了文件名，它会在另一个分割视图中显示一个独立的文件。这个命令会水平分割文件：
- en: '![](img/B18425_05_06.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_05_06.png)'
- en: 'Figure 5.6: The vim text editor, with two files open in the same window'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：vim 文本编辑器，两个文件在同一窗口中打开
- en: The previous screenshot shows two files open, `/var/log/apt/history.log` and
    `/var/log/syslog`. You may also notice that the status bar for each file, at the
    bottom, shows `RO`. As you can probably guess, this stands for *read only* and
    displays on the screen because I’m viewing files that only `root` has access to
    change, and I didn’t use `sudo`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了两个文件正在打开，`/var/log/apt/history.log`和`/var/log/syslog`。你可能还注意到，每个文件底部的状态栏显示了`RO`。正如你所猜测的，这表示*只读*，它显示在屏幕上是因为我正在查看只有`root`用户才能更改的文件，并且我没有使用`sudo`。
- en: To switch between the two files, we can press the *w* key twice while holding
    *Ctrl*. When we do that, our insertion point moves from one split to the other.
    To exit each individual buffer (or the editor itself, if we only have one file
    open), we can press *Esc* to return to command mode, and then enter the `:q` or
    `:q!` command to exit without saving changes, or `:wq` to exit while also saving
    changes, just like before.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两个文件之间切换，我们可以按住*Ctrl*键的同时，连续按两次*w*键。这样，我们的插入点就会从一个分割窗口移动到另一个分割窗口。要退出每个独立的缓冲区（或者如果我们只打开了一个文件，就是退出编辑器本身），我们可以按*Esc*键返回到命令模式，然后输入`:q`或`:q!`命令退出而不保存更改，或者输入`:wq`命令退出并保存更改，就像以前一样。
- en: 'An alternative to `:split` is `:vsplit`, or `:vs` for short. It does the same
    thing as `:split`, but it splits the window vertically. Considering most computer
    displays nowadays are widescreen (and even ultra-widescreen), a vertical split
    often works out better in a practical sense:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`:split`的替代命令是`:vsplit`，或者简写为`:vs`。它与`:split`的作用相同，但会垂直分割窗口。考虑到现在大多数计算机显示器都是宽屏（甚至是超宽屏），垂直分割通常在实际使用中更加方便：'
- en: '![](img/B18425_05_07.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_05_07.png)'
- en: 'Figure 5.7: The vim text editor, with two files open in a vertical split'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：vim 文本编辑器，两个文件在垂直分割的窗口中打开
- en: To be honest, the effect doesn’t look all that great in the previous screenshot,
    the reason being the width of a page in a book isn’t enough to really show the
    benefit. Go ahead and give it a shot and see for yourself.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，前面的截图效果看起来并不是特别好，原因在于书本中的一页宽度不足以真正展示这种分割的好处。你可以试试看，亲自体验一下。
- en: So far, we’ve gone over two modes of `vim`—command and insert mode. But there’s
    also another commonly used mode we haven’t discussed yet—*visual mode*. Visual
    mode allows you to select text, which then allows you to perform tasks such as
    copy and paste.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了`vim`的两种模式——命令模式和插入模式。但还有一种我们尚未讨论的常用模式——*可视模式*。可视模式允许你选择文本，然后执行如复制和粘贴等任务。
- en: To do so, make sure you’re in command mode, and then start by moving the cursor
    to the first character in a series of text you want to copy. Then, press the *v*
    letter key on your keyboard, and move the selection with your arrow keys.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，确保你处于命令模式，然后将光标移动到你想要复制的文本的第一个字符。接着，按下键盘上的*v*键，并用箭头键移动选择区域。
- en: You’ll notice that you’ll highlight more text as you move the cursor. Once you’ve
    selected all the text that you’d like to copy, press the *y* key and the highlight
    will go away. At this point, you’ve essentially copied the text you had highlighted
    into the `vim` equivalent of the clipboard, similar to desktop operating systems.
    You can then (while also in command mode) press the *p* key to paste the text
    wherever the cursor is. It may take a few tries to get a hang of the workflow,
    but go ahead and give it a shot. If you make a mistake, you can press *u* while
    in command mode to *undo*, so you can revert any changes you make.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，随着光标的移动，你会选中更多的文本。当你选中想要复制的所有文本后，按 *y* 键，选中的部分会消失。此时，你就相当于将选中的文本复制到了 `vim`
    相当于剪贴板的地方，类似于桌面操作系统的剪贴板。然后，你可以（仍然在命令模式下）按 *p* 键，在光标所在位置粘贴文本。可能需要几次尝试才能掌握这个工作流程，但可以试试。如果你犯了错误，你可以在命令模式下按
    *u* 键来 *撤销*，这样可以恢复任何更改。
- en: 'Again, `vim` is a somewhat advanced editor. Learning the basic functions is
    fairly easy, so knowing how to open, edit, close, and save files is something
    you can learn fairly quickly. The feature set of `vim` is so vast that I’m still
    learning new tricks many years after I started using it. To make sure you understand
    the basics though, let’s summarize the basic workflow of `vim` to help you memorize
    it. It looks something like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`vim` 是一个相对高级的编辑器。学习其基本功能相对简单，因此掌握如何打开、编辑、关闭和保存文件是你可以很快学会的。`vim` 的功能集非常庞大，尽管我已经使用它多年，我依然在不断学习新技巧。不过，为了确保你掌握基本操作，我们可以总结一下
    `vim` 的基本工作流程，帮助你记忆。大致流程如下：
- en: 'Open Vim by either typing `vim` by itself, or with a filename: `vim <filename>`.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Vim 可以通过单独输入 `vim`，或者指定文件名：`vim <filename>`。
- en: You start in *command mode*. This mode is great for running `vim` commands.
    Press the *Insert* or the *i* key to switch to *insert mode*.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你从 *命令模式* 开始。这个模式非常适合运行 `vim` 命令。按 *Insert* 或 *i* 键可以切换到 *插入模式*。
- en: While in insert mode, you can edit the text by typing with your keyboard and
    moving the cursor around with the arrow keys.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在插入模式下，你可以通过键盘输入文本并用箭头键移动光标来编辑文本。
- en: When you’re done editing the file, press *Esc* to return to command mode.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你编辑完文件后，按 *Esc* 键返回命令模式。
- en: To exit without saving changes, enter the `:q` or `:q!` command. If you do want
    to save changes, enter `:w` by itself to save and remain in the editor, or `:wq`
    to save and quit `vim` at the same time.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果想在不保存更改的情况下退出，可以输入 `:q` 或 `:q!` 命令。如果你确实想保存更改，可以单独输入 `:w` 保存并保持在编辑器中，或者输入
    `:wq` 同时保存并退出 `vim`。
- en: Entire books could be written about `vim` (and there have been), so it would
    be outside the scope of this book to go into exhaustive detail. In fact, I even
    have a dedicated video tutorial series about it at [www.learnlinux.tv](http://www.learnlinux.tv)
    if you’re interested in learning more. But for now, I’ll leave you with a few
    more useful tips that I think you should know.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `vim` 可以写整本书（实际上也有这样的书），所以本书不可能详细讲解所有内容。事实上，如果你有兴趣了解更多，我还专门制作了一系列关于 `vim`
    的视频教程，地址是 [www.learnlinux.tv](http://www.learnlinux.tv)。但现在，我会给你一些我认为你应该知道的有用技巧。
- en: While in command mode, you can press the *x* key to delete a single character,
    wherever the cursor is. You can press the *d* letter key *twice* in succession
    to delete an entire line. When you do this, that line is also copied into the
    paste buffer; you can paste that line by pressing *p*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令模式下，你可以按 *x* 键删除光标所在位置的一个字符。你也可以连续按 *d* 键 *两次* 来删除整行。当你这么做时，这一行内容会被复制到粘贴缓冲区；你可以按
    *p* 键将这一行粘贴出来。
- en: In addition, I mentioned several times that you can switch to insert mode by
    pressing *i* or *Insert*. You can also do so by pressing the *a* letter key with
    or without holding *Shift*. If you don’t hold *Shift*, you’ll enter insert mode
    one character to the right. This isn’t very useful to me, but typing a capital
    *A* is something I find myself doing a lot, which enters you into insert mode
    while also taking you to the very end of the current line. Since I often want
    to start typing after the end of a sentence, this works well for me.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我曾多次提到，你可以通过按 *i* 或 *Insert* 键切换到插入模式。你也可以通过按 *a* 键（无论是否按住 *Shift*）来进入插入模式。如果不按
    *Shift*，你将从光标右侧开始插入一个字符。对我来说，这个操作并不是很有用，但我发现自己经常输入大写的 *A*，它可以让你进入插入模式并将光标移至当前行的末尾。由于我常常需要在句子的末尾开始输入，这对我来说非常实用。
- en: Also, while in command mode, you can type *Shift + g* to immediately go to the
    very end of the file. Alternatively, you can press the *g* key *twice* in succession
    to move to the very top of the file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在命令模式下，你可以按*Shift + g*立即跳转到文件的最后一行。或者，你也可以连续按两次*g*键跳转到文件的顶部。
- en: 'Another trick I like is to turn on line numbers. This is useful, especially
    if an error message in a log file is complaining about a file regarding a specific
    line. The following command turns on line numbers:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我喜欢的小技巧是启用行号。这在某些情况下非常有用，尤其是当日志文件中的错误消息提到与特定行相关的文件时。以下命令可以启用行号：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following command disables line numbers:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令禁用行号：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you’d always like to see line numbers by default, you can edit the `.vimrc`
    file inside your home directory. This file is read by `vim` each time you start
    it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望默认情况下始终看到行号，可以编辑你主目录下的`.vimrc`文件。每次启动`vim`时，`vim`都会读取该文件。
- en: Note that the `.vimrc` file begins with a period, which means that the file
    is hidden. Hidden files aren’t normally shown to you when you use `ls` to list
    the contents of a directory. Using the `-a` option with the `ls` command will
    show all files, including the ones that are normally hidden.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`.vimrc`文件以点（.）开头，这意味着该文件是隐藏的。通常情况下，当你使用`ls`命令列出目录内容时，隐藏文件不会显示。使用`ls`命令的`-a`选项可以显示所有文件，包括那些通常隐藏的文件。
- en: 'Go ahead and open the `.vimrc` file in your editor:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以打开编辑器中的`.vimrc`文件：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Most likely, this will be a blank file for you as a `.vimrc` file doesn’t exist
    by default. There are many commands we can add to tweak the behavior of the `vim`
    editor, too many to mention in a single chapter. The following line is very useful
    though, as it ensures that line numbers are enabled by default:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对你来说，这很可能是一个空文件，因为默认情况下`.vimrc`文件并不存在。我们可以在文件中添加许多命令来调整`vim`编辑器的行为，内容繁多，无法在一章中一一列举。不过，以下这一行非常有用，它确保了行号默认启用：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Leaving out the colon at the beginning of the line is intentional; it’s not
    required inside the `.vimrc` file. From this point forward, each new `vim` session
    you open will start off with line numbers enabled. You can still disable line
    numbers as needed with the `:set nonumber` command within `vim` as we did earlier.
    In addition, you can add many more customizations to `vim` with the `.vimrc` file,
    but there are simply too many possibilities to mention here. For now, just know
    that customizing `vim` with the config file is something that you can do.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行前省略冒号是故意的；在`.vimrc`文件中并不需要冒号。从此以后，每次你打开新的`vim`会话时，行号将会默认启用。当然，你仍然可以像之前一样，通过`vim`中的`:set
    nonumber`命令来禁用行号。此外，你还可以通过`.vimrc`文件为`vim`添加许多其他自定义设置，但这里无法一一列举。目前，只需要知道，使用配置文件来定制`vim`是完全可行的。
- en: Now that we know how to edit files, we should also take a closer look at streams,
    which allow us to manipulate both input and output in various ways.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何编辑文件，我们也应该更加深入地了解流，流使我们能够以多种方式操作输入和输出。
- en: Input and output streams
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入输出流
- en: During our journey into Ubuntu Server so far, we’ve worked quite a bit within
    the terminal. We’ve been able to inspect the contents of files, insert text into
    files, and more. We’ve actually been working with **streams** the entire time
    without knowing it. In this section, we’re going to talk about this subject in
    more detail.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对Ubuntu Server的探索过程中，我们已经在终端中做了不少工作。我们能够查看文件内容、向文件中插入文本等等。其实，在整个过程中，我们一直在使用**流**，只是没有意识到而已。在这一部分，我们将更详细地讨论这个话题。
- en: If you’ve studied computer science at all, then you probably already know that
    *output* refers to things that are printed out of the computer (for example, text
    being printed to the screen, or onto paper from a printer) and *input* refers
    to data that is being entered into a computer, whether that be on the command
    line, into a file, or similar.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾学习过计算机科学，你可能已经知道，*输出*指的是从计算机打印出来的内容（例如，文本打印到屏幕上，或从打印机打印到纸上），而*输入*则指的是输入到计算机中的数据，无论是在命令行、文件中还是其他地方。
- en: Linux takes this concept a bit further. Streams in Linux refer to a special
    way to handle what’s going in or out, and beyond the input and output streams,
    we also have a third that refers to errors.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Linux将这个概念延伸得更远。在Linux中，流（streams）指的是一种处理输入和输出的特殊方式，除了输入流和输出流，我们还有第三种流，专门用于处理错误。
- en: Output streams in Linux are referred to as **Standard Output**, and input streams
    are referred to as **Standard Input**. These are abbreviated as **stdout** and
    **stdin**, respectively. The reason for the expansion of the simple concept of
    input/output into a concept of its own is because, on the Linux shell, we can
    handle these streams differently and perform different tasks with them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，输出流被称为**标准输出**，而输入流被称为**标准输入**。这两个术语分别简写为**stdout**和**stdin**。将输入/输出这一简单概念扩展成一个独立概念的原因是，在Linux的shell中，我们可以以不同的方式处理这些流，并且可以对它们执行不同的任务。
- en: We’ve been working with standard output throughout the entire book so far. Everything
    that is printed to the terminal is standard output. For example, when you ran
    the `sudo apt install vim-nox` command earlier, the results of that command (the
    flood of text showing the status of the package installation as it occurred) was
    standard output. When you use the `cat /var/log/syslog` command to have the contents
    of `/var/log/syslog` dumped onto the screen, the contents being displayed are
    standard output. By far, standard output is something you’ll work with the most.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在整本书中一直在处理标准输出。所有打印到终端的内容都是标准输出。例如，当你之前运行了`sudo apt install vim-nox`命令时，那条命令的结果（显示包安装状态的文字信息）就是标准输出。当你使用`cat
    /var/log/syslog`命令将`/var/log/syslog`的内容显示在屏幕上时，显示的内容就是标准输出。标准输出是你最常接触到的部分。
- en: 'To understand the concept of standard output better, let’s take a look at redirection.
    The following command is an example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解标准输出的概念，让我们来看看重定向。以下命令就是一个例子：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With that command, we’re using `cat` to display the contents of `/var/log/syslog`.
    But instead of simply showing the contents onscreen we use the `>` character to
    redirect standard output into a file, `~/logfile.txt`. This means that standard
    output (showing the contents of the file) will not be shown at all, since we redirected
    that into a file. Similarly, we could have also run:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过该命令，我们使用`cat`来显示`/var/log/syslog`的内容。但与其仅仅在屏幕上显示内容，我们使用`>`符号将标准输出重定向到一个文件`~/logfile.txt`。这意味着标准输出（显示文件内容）将完全不再显示，因为我们已经将其重定向到了文件中。类似地，我们也可以运行：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that I added a `1` right before the *greater-than* symbol. Standard output
    is designated by a file descriptor of 1\. So, with that command, I’m specifically
    saying that I want to redirect standard output, and *only* standard output, into
    the file. Standard output is implied, so I didn’t need to include the `1`. That’s
    why simply using the *greater-than* symbol works for redirecting standard output
    to a file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在*大于*符号前添加了一个`1`。标准输出通过文件描述符1来指定。因此，通过这个命令，我特别指定了我要将标准输出，*仅*标准输出，重定向到文件中。标准输出是默认的，因此我没有必要包括`1`。这就是为什么简单地使用*大于*符号就可以将标准输出重定向到文件的原因。
- en: 'If you want to append a file rather than completely overwrite it, you can use
    two *greater-than* symbols (`>>`) to append, rather than overwrite. For example,
    the following command will add the contents of the `syslog` file to the end of
    the `logfile.txt` file, rather than overwrite the entire file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想追加文件而不是完全覆盖它，可以使用两个*大于*符号（`>>`）来追加，而不是覆盖。例如，以下命令会将`syslog`文件的内容追加到`logfile.txt`文件的末尾，而不是覆盖整个文件：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Standard input also has a file descriptor, which is 0\. Standard input is how
    commands receive data. Essentially, commands that accept input from the user do
    so by accepting `stdin`. Standard input is a bit more challenging to show in an
    example, but the following works:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输入也有一个文件描述符，即0。标准输入是命令接收数据的方式。本质上，接受用户输入的命令通过接受`stdin`来获取数据。标准输入在例子中有点难以展示，但以下方式可以实现：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With that command, I’m grabbing the contents of the `/var/log/syslog` file and
    piping that into the `grep` command, which allows me to display only the lines
    that include a specific term. No two `syslog` files will be the same, since every
    server can be configured uniquely. But if you’re attempting to investigate a specific
    application or service, you can `grep` the log for keywords you think might be
    appropriate. If you include the `-i` option, then `grep` will perform a search
    that’s case-insensitive. In this example, the output of the `cat` command becomes
    standard input to the `grep` command. This command can be executed with any search
    term of your choice.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，我正在获取 `/var/log/syslog` 文件的内容，并将其传递给 `grep` 命令，这样可以只显示包含特定术语的行。每个 `syslog`
    文件都不会相同，因为每个服务器都可以有不同的配置。但如果你正在调查某个特定的应用或服务，你可以使用 `grep` 在日志中查找你认为合适的关键词。如果你加上
    `-i` 选项，`grep` 将执行不区分大小写的搜索。在这个例子中，`cat` 命令的输出成为了 `grep` 命令的标准输入。这个命令可以用任何你选择的搜索词来执行。
- en: 'I could have also run:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以运行：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In that example, I’m using the *less-than* symbol to redirect the contents of
    `/var/log/syslog` to be standard input to the `cat` command. The `cat` command
    normally prints whatever text is fed to it to the screen as standard output, but
    instead, I’m using the pipe symbol, `|`, to grab that output and use it as standard
    input to the `grep` command.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我使用 *小于号* 符号将 `/var/log/syslog` 文件的内容重定向为 `cat` 命令的标准输入。`cat` 命令通常将传给它的文本打印到屏幕上作为标准输出，但在这里，我使用管道符号
    `|` 来获取该输出，并将其作为标准输入传递给 `grep` 命令。
- en: 'This concept can be a bit confusing at first, but if you keep practicing it,
    it will definitely make sense. Let’s look at another example, so we can understand
    standard error (**stderr**) as well:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念一开始可能有些令人困惑，但如果你持续练习，它一定会变得清晰。让我们再看一个例子，这样我们也能理解标准错误（**stderr**）：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `find` command allows you to find files that match particular criteria,
    such as looking for files that are named `syslog` in this example. Here, we’re
    searching the entire filesystem, because we used `/` to start the search from.
    The problem is I don’t have permission to read all the files on the filesystem,
    and I didn’t use `sudo`. This is going to result in quite a few errors being printed
    to the screen, errors such as these:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令允许你查找符合特定条件的文件，例如在这个例子中查找名为 `syslog` 的文件。这里，我们正在搜索整个文件系统，因为我们从 `/`
    开始了搜索。问题是我没有权限读取文件系统中的所有文件，并且没有使用 `sudo`。这将导致屏幕上出现许多错误，例如这些：'
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since the `find` command was used to search the entire filesystem, including
    places I don’t have permission to look, our terminal will be flooded with errors.
    These errors are displayed using standard error, which has a file descriptor of
    2\. If we want to hide these errors, we can do this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `find` 命令被用来搜索整个文件系统，包括我没有权限查看的地方，我们的终端将被错误信息淹没。这些错误通过标准错误显示，标准错误的文件描述符是
    2。如果我们想隐藏这些错误，可以这样做：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With that command, no errors will show up when we run it. That’s because we
    instructed the interpreter to capture standard error and redirect it to `/dev/null.
    /dev/null` is a special device where things disappear forever. If you move or
    redirect something there, it’s effectively deleted. Since a standard error has
    a file descriptor of 2, we combined that with the *greater-than* symbol to form
    `2>`, which basically instructs the shell to do a redirect, but to only redirect
    standard error and leave standard output alone. We can also choose to redirect
    more than one stream to different places within a single command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令时，运行时不会显示任何错误。这是因为我们指示解释器捕获标准错误并将其重定向到 `/dev/null`。`/dev/null` 是一个特殊的设备，任何放到那里东西都会永远消失。如果你将某物移到或重定向到那里，它基本上就被删除了。由于标准错误的文件描述符是
    2，我们将其与 *大于号* 符号结合形成 `2>`，这基本上指示 shell 执行重定向，但只重定向标准错误，保持标准输出不变。我们还可以选择在单个命令中将多个流重定向到不同的地方：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With that variation, I’m redirecting successful output to `stdout.txt`, and
    the errors to `stderr.txt`. This allows us full control over where successful
    and unsuccessful messages are printed. This also helps us quite a bit when it
    comes to troubleshooting, because we may want to focus on only the errors, and
    getting rid of the success output may trim the number of lines we’ll have to look
    through.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个变体中，我将成功的输出重定向到 `stdout.txt`，而错误信息则重定向到 `stderr.txt`。这样我们就可以完全控制成功和失败信息的输出位置。这在故障排除时非常有帮助，因为我们可能只想专注于错误信息，去掉成功的输出可以减少我们需要查看的行数。
- en: I recommend that you go ahead and practice this concept as much as you can;
    it’s definitely something you’ll want to commit to memory. You don’t have to master
    this concept right now, but knowing the basics will provide a great foundation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你尽量多练习这个概念；这绝对是你希望牢记的内容。你不必现在就完全掌握这个概念，但了解基本知识会为你提供一个很好的基础。
- en: Next, let’s discuss another aspect of file management—links. Sometimes, you’ll
    need to link one thing to another, and there are a few ways to go about that along
    with some best-practice advice.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来讨论文件管理的另一个方面——链接。有时，你需要将一个东西链接到另一个东西，并且有几种方法可以实现这一点，同时也有一些最佳实践建议。
- en: Using symbolic and hard links
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用符号链接和硬链接
- en: If you’ve used a graphical operating system for more than a week, you’re probably
    more than familiar with the concept of shortcuts. Either on the desktop or within
    a menu, you will have shortcuts to files and applications. This could be a shortcut
    to your home or profile directory, a shortcut to an application, an individual
    file, and so on. We have the same concept in Linux.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用图形操作系统超过一周，那么你可能对快捷方式这个概念非常熟悉。无论是在桌面上还是在菜单中，你都会看到指向文件和应用程序的快捷方式。这些快捷方式可能指向你的主页或个人目录、一个应用程序、单个文件等等。Linux
    中也有相同的概念。
- en: With Linux, we can link files to other files, which gives us the ability to
    create our own shortcuts, which are effectively similar to shortcuts in graphical
    operating systems, but without the requirement of a GUI. This comes in the form
    of *symbolic and hard* links, which are two different methods by which we can
    link things. Symbolic and hard links are very similar, but to explain them, you’ll
    first need to understand the concept of **inodes**.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Linux，我们可以将文件链接到其他文件，这使我们能够创建自己的快捷方式，这实际上类似于图形操作系统中的快捷方式，但不需要 GUI。这些快捷方式以
    *符号链接和硬链接* 的形式存在，它们是两种不同的链接方式。符号链接和硬链接非常相似，但要解释它们，你首先需要理解 **inode** 的概念。
- en: 'An inode is a data object that contains metadata regarding files within your
    filesystem. Although a full walkthrough of the concept of inodes would be quite
    long, think of an inode as a type of database object, containing metadata for
    the actual items you’re storing on your disk. Information stored in inodes includes
    details such as the owner of the file, permissions, last modified date, and type
    (whether it is a directory or a file). Inodes are represented by an integer number,
    which you can view with the `-i` option of the `ls` command. On my system, I created
    two files: `file1` and `file2`. These files are inodes `265416` and `266112`,
    respectively. You can see this output in the following screenshot where I run
    the `ls -i` command. This information will come in handy shortly:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: inode 是一个数据对象，包含有关文件系统中文件的元数据。尽管对 inode 概念的完整讲解会相当长，但可以将 inode 看作一种数据库对象，存储了你磁盘上实际存储项目的元数据。inode
    中存储的信息包括文件的所有者、权限、最后修改日期和类型（是目录还是文件）等详细信息。inode 通过一个整数表示，你可以使用 `ls` 命令的 `-i` 选项查看。在我的系统中，我创建了两个文件：`file1`
    和 `file2`。这两个文件分别是 inode `265416` 和 `266112`。你可以在以下截图中看到运行 `ls -i` 命令的输出。这些信息很快就会派上用场：
- en: '![](img/B18425_05_08.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_05_08.png)'
- en: 'Figure 5.8: Output of ls -i'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：`ls -i` 的输出
- en: 'As I mentioned earlier, there are two types of links in Linux: the symbolic
    link and hard link. While the two types of links approach the concept differently,
    they pretty much serve the same purpose. Basically, a link allows us to reference
    a file somewhere else on our filesystem.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，Linux 中有两种类型的链接：符号链接和硬链接。虽然这两种链接的实现方式不同，但它们的目的几乎相同。基本上，链接允许我们在文件系统的其他地方引用某个文件。
- en: 'For a practical example, let’s create a hard link. In my case, I have a couple
    of files in a `test` directory, so I can create a link to either of them. To create
    a link, we’ll use the `ln` command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 举个实际的例子，让我们创建一个硬链接。在我的例子中，我在一个 `test` 目录下有几个文件，因此我可以为它们中的任何一个创建链接。要创建链接，我们将使用
    `ln` 命令：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, I’m creating a hard link (`file3`) that is linked to `file1`. To play
    around with this, go ahead and create a link to a file on your system. If we use
    `ls` again with the `-i` option, we’ll see something interesting:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我正在创建一个指向 `file1` 的硬链接（`file3`）。为了实验，你可以尝试在系统上创建一个文件的链接。如果我们再次使用 `ls` 命令并加上
    `-i` 选项，我们会看到一些有趣的事情：
- en: '![](img/B18425_05_09.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_05_09.png)'
- en: 'Figure 5.9: Output of second ls -I command'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：第二次 `ls -I` 命令的输出
- en: If you look closely at the output, both `file1` and `file3` have the same inode
    number. Essentially, a hard link is a duplicate directory entry, where both entries
    point to the same data. In this case, we created a hard link that points to another
    file. With this hard link created, we can move `file3` into another location on
    the filesystem and it will still be a link to `file1`. Hard links have a couple
    of limitations, however. First, you cannot create a hard link to a directory,
    only a file. Second, this link cannot be moved to a different filesystem. That
    makes sense, considering each filesystem has its own inodes. Inode `265416` on
    my system would, of course, not point to the same file on another system, if this
    inode number even exists at all.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细观察输出，你会发现`file1`和`file3`具有相同的 inode 编号。从本质上讲，硬链接是一个重复的目录项，两个目录项都指向相同的数据。在这种情况下，我们创建了一个指向另一个文件的硬链接。创建了这个硬链接后，我们可以将`file3`移动到文件系统中的另一个位置，它仍然会指向`file1`。然而，硬链接有几个限制。首先，你不能创建指向目录的硬链接，只能是文件。其次，硬链接不能被移动到不同的文件系统。这是有道理的，因为每个文件系统都有自己的
    inode。在我的系统上，inode `265416`当然不会指向另一个系统上的同一文件，假设该 inode 编号在另一个系统上存在的话。
- en: 'To overcome these limitations, we can consider using a soft link instead. A
    soft link (also known as a **symbolic link** or **symlink**) is an entry that
    points to another directory or file. This is different from a hard link because
    a hard link is a duplicate entry that references an inode, while a symbolic link
    references a specific path. Symbolic links can not only be moved around between
    filesystems; we can also create a symbolic link to a directory as well. To illustrate
    how a symbolic link works, let’s create one. In my case, I’ll delete `file3` and
    recreate it as a symbolic link. We’ll again use the `ln` command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些限制，我们可以考虑使用软链接。软链接（也叫做**符号链接**或**符号连接**）是一个指向另一个目录或文件的条目。这与硬链接不同，因为硬链接是一个引用
    inode 的重复条目，而符号链接引用的是特定的路径。符号链接不仅可以在不同的文件系统之间移动，我们还可以创建指向目录的符号链接。为了说明符号链接是如何工作的，我们来创建一个。在我的情况下，我将删除`file3`并将其重新创建为符号链接。我们将再次使用`ln`命令：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With the `-s` option of `ln`, I’m creating a symbolic link. First, I deleted
    the original hard link with the `rm` command (which doesn’t disturb the original
    file, `file1`) and then created a symbolic link, also named `file3`. If we use
    `ls -i` again, we’ll see that `file3` does not have the same inode number as `file1`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ln`的`-s`选项，我正在创建一个符号链接。首先，我通过`rm`命令删除了原始的硬链接（这不会影响原始文件`file1`），然后创建了一个名为`file3`的符号链接。如果我们再次使用`ls
    -i`，会发现`file3`的 inode 编号与`file1`不同：
- en: '![](img/B18425_05_10.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_05_10.png)'
- en: 'Figure 5.10: Output of ls -i after creating a symbolic link'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：创建符号链接后使用`ls -i`命令的输出
- en: Notice that the inode numbers of each file are all different. At this point,
    the main difference compared with a hard link should become apparent. A symbolic
    link is not a clone of the original file; it’s simply a pointer to the original
    file’s path. Any commands you execute against `file3` are actually being run against
    the target that the link is pointing to. Hard links, on the other hand, point
    directly to the file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个文件的 inode 编号都是不同的。此时，与硬链接相比，主要的区别应该变得显而易见。符号链接并不是原始文件的克隆；它只是指向原始文件路径的一个指针。你对`file3`执行的任何命令，实际上都是针对符号链接指向的目标执行的。而硬链接则直接指向文件。
- en: In practice, symbolic links are incredibly useful when it comes to server administration.
    However, it’s important not to go crazy and create a great number of symbolic
    links all over the filesystem. This certainly won’t be a problem for you if you
    are the only administrator on the server, but if you resign and someone takes
    your place, it will be a headache for them to figure out all of your symbolic
    links and map where they lead to. You can certainly create documentation for your
    symbolic links, but then you’d have to keep track of them and constantly update
    documentation. My recommendation is to only create symbolic links when there are
    no other options, or if doing so benefits your organization and streamlines your
    file layout.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，符号链接在服务器管理中非常有用。然而，重要的是不要疯狂地在整个文件系统中创建大量的符号链接。如果你是服务器上唯一的管理员，这自然不是问题，但如果你辞职，别人接替你的职位，他们会为弄清楚你所有的符号链接并映射它们指向的位置而头疼。当然，你可以为你的符号链接创建文档，但那样你就得追踪它们并不断更新文档。我的建议是，只有在没有其他选项时，或者这样做对你的组织有利并简化文件布局时，才创建符号链接。
- en: Getting back to the subject of symbolic links versus hard links, you’re probably
    wondering which you should use and when to use them. The main benefit of a hard
    link is that you can move either file (the link or the original) to anywhere on
    the same filesystem and the link will not break. This is not true of symbolic
    links; however, if you move the original file, the symbolic link will be pointing
    to a file that no longer exists at that location. Hard links are basically duplicate
    entries pointing to the same object, and thus have the same inode number, so both
    will have the same file size and content. A symbolic link is a pointer to the
    file’s path—nothing more, nothing less.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 回到符号链接与硬链接的话题，你可能在想应该使用哪一种以及何时使用它们。硬链接的主要好处是你可以将任一文件（链接或原始文件）移动到同一文件系统的任何位置，链接都不会断开。然而，符号链接并非如此；如果你移动原始文件，符号链接将指向一个在该位置已不存在的文件。硬链接基本上是指向同一对象的重复条目，因此它们有相同的
    inode 号码，因此两者将具有相同的文件大小和内容。符号链接是指向文件路径的指针——仅此而已。
- en: However, even though I just spoke about the several benefits of hard links,
    I actually recommend symbolic links for most use cases. They can cross filesystems,
    can be linked to directories, and it’s easier to determine from the output where
    they lead. If you move hard links around, you may forget where they were originally
    located or which file actually points to which. Sure, with a few commands you
    can find them and map them easily. But overall, symbolic links are more convenient
    in the long run. As long as you’re mindful of recreating your symbolic link whenever
    you move the original file (and you use them only when you need to), you shouldn’t
    have an issue.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管我刚才谈到了硬链接的几个好处，我实际上推荐在大多数使用场景中使用符号链接。符号链接可以跨文件系统，可以链接到目录，并且从输出中更容易判断它们指向哪里。如果你移动硬链接，可能会忘记它们最初的位置或哪个文件实际上指向哪个。没错，使用几个命令你可以轻松找到并映射它们。但总的来说，从长远来看，符号链接更为方便。只要你在移动原始文件时留意重新创建符号链接（并且仅在需要时使用它们），你就不会遇到问题。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we elevated our terminal kung-fu to another level and looked
    at concepts such as moving and copying files. We continued into a discussion of
    two popular text editors, Nano and Vim. Then, we took a dive into the subject
    of streams, and finished off the chapter with an understanding of the differences
    between symbolic and hard links, as well as how to create them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将终端操作技巧提升到一个新水平，并探讨了移动和复制文件等概念。接着，我们讨论了两个流行的文本编辑器，Nano 和 Vim。然后，我们深入探讨了流的概念，并以理解符号链接和硬链接的区别以及如何创建它们作为本章的结束。
- en: In *Chapter 6*,*Boosting Your Command-line Efficiency*, we’ll dive a bit deeper
    into command-line tips and tricks, which will include a discussion on Bash history,
    writing basic scripts, and more.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第六章*，*提升你的命令行效率*中，我们将深入探讨一些命令行技巧，包括讨论 Bash 历史、编写基础脚本等内容。
- en: Relevant videos
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关视频
- en: 'Linux Crash Course – Data Streams (LearnLinuxTV): [https://linux.video/se-data-streams](https://linux.video/se-data-streams)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux Crash Course – 数据流（LearnLinuxTV）：[https://linux.video/se-data-streams](https://linux.video/se-data-streams)
- en: 'Linux Crash Course – nano (LearnLinuxTV): [https://linux.video/le-nano](https://linux.video/le-nano)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux Crash Course – nano（LearnLinuxTV）：[https://linux.video/le-nano](https://linux.video/le-nano)
- en: 'Linux Crash Course – Symbolic Links (LearnLinuxTV): [https://linux.video/se-symlinks](https://linux.video/se-symlinks%20)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux Crash Course – 符号链接（LearnLinuxTV）：[https://linux.video/se-symlinks](https://linux.video/se-symlinks%20)
- en: 'Vim Text Editor Tutorial Series: [https://learnlinux.link/vim](https://learnlinux.link/vim)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vim 文本编辑器教程系列：[https://learnlinux.link/vim](https://learnlinux.link/vim)
- en: Join our community on Discord
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者及其他读者进行讨论：
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code50046724-1955875156.png)'
