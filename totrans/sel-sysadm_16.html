<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div id="_idContainer042" class="calibre2">
			<h1 id="_idParaDest-326" class="calibre5"><em class="italic"><a id="_idTextAnchor330" class="pcalibre calibre6 pcalibre1"/>Chapter 13</em>: Analyzing Policy Behavior</h1>
			<p class="calibre3">Although SELinux policies enforce the mandatory access controls and application behavior on a system, knowing how a policy will act upfront is useful for administrators to perform assessments and root cause analysis activities.</p>
			<p class="calibre3">Throughout this chapter, we will learn how to query the SELinux policy in depth, using a multitude of tools to query process transitions, analyze information flows, and compare policies. We will consider the <strong class="source-inline">apol</strong> tool, a graphical interface with which we can perform several analyses on a policy, as well as command-line tools such as <strong class="source-inline">sesearch</strong>, <strong class="source-inline">sedta</strong>, <strong class="source-inline">seinfoflow</strong>, and <strong class="source-inline">sepolicy</strong>. Finally, we will use <strong class="source-inline">sediff</strong> to compare policies.</p>
			<p class="calibre3">In this chapter, we're going to cover the following main topics:</p>
			<ul class="calibre8">
				<li class="calibre9">Performing single-step analysis</li>
				<li class="calibre9">Investigating domain transitions</li>
				<li class="calibre9">Analyzing information flow</li>
				<li class="calibre9">Comparing policies</li>
			</ul>
			<h1 id="_idParaDest-327" class="calibre5"><a id="_idTextAnchor331" class="pcalibre calibre6 pcalibre1"/>Technical requirements</h1>
			<p class="calibre3">Check out the following video to see the Code in Action: <a href="https://bit.ly/3lY56LB" class="pcalibre calibre6 pcalibre1">https://bit.ly/3lY56LB</a></p>
			<h1 id="_idParaDest-328" class="calibre5"><a id="_idTextAnchor332" class="pcalibre calibre6 pcalibre1"/>Performing single-step analysis</h1>
			<p class="calibre3">Until now, we've <a id="_idIndexMarker853" class="pcalibre calibre6 pcalibre1"/>covered a few methods of analyzing SELinux policies through command-line utilities such as <strong class="source-inline">seinfo</strong> and <strong class="source-inline">sesearch</strong>. These utilities can assist users in performing single-step analyses: they either provide immediate information about an SELinux object (which is mainly what <strong class="source-inline">seinfo</strong> is about) or are capable of querying direct SELinux rules (which is the scope of <strong class="source-inline">sesearch</strong>).</p>
			<p class="calibre3">Not all capabilities of the <strong class="source-inline">seinfo</strong> and <strong class="source-inline">sesearch</strong> utilities have been discussed yet though, so let's see what other tricks these commands have up their sleeves.</p>
			<h2 id="_idParaDest-329" class="calibre10"><a id="_idTextAnchor333" class="pcalibre calibre6 pcalibre1"/>Using different SELinux policy files</h2>
			<p class="calibre3">Many SELinux <a id="_idIndexMarker854" class="pcalibre calibre6 pcalibre1"/>analysis tools, including <strong class="source-inline">seinfo</strong> and <strong class="source-inline">sesearch</strong>, can access both the currently loaded SELinux policy and a specified SELinux policy file. The latter allows developers to query SELinux policies of systems they do not have direct access to, for which direct access is cumbersome (such as mobile devices), or that have been used in previous situations (backups) and are no longer active.</p>
			<p class="calibre3">For instance, to analyze a policy file called <strong class="source-inline">policy.sepolicy-2</strong>, the following <strong class="source-inline">seinfo</strong> command can be used:</p>
			<p class="source-code">$ seinfo ./policy.sepolicy-2</p>
			<p class="source-code">Statistics for policy file: ./policy.sepolicy-2</p>
			<p class="source-code">Policy Version:             30 (MLS enabled)</p>
			<p class="source-code">Target Policy:              selinux</p>
			<p class="source-code">Handle unknown classes:     deny</p>
			<p class="source-code">  Classes:              63    Permissions:         286</p>
			<p class="source-code">  Sensitivities:         1    Categories:         1024</p>
			<p class="source-code">  Types:              1858    Attributes:           28</p>
			<p class="source-code">  Users:                 1    Roles:                 2</p>
			<p class="source-code">  Booleans:              0    Cond. Expr.:           0</p>
			<p class="source-code">  Allow:            108120    Neverallow:            0</p>
			<p class="source-code">  Auditallow:           24    Dontaudit:           553</p>
			<p class="source-code">  Type_trans:          639    Type_change:           0</p>
			<p class="source-code">  Type_member:           0    Range_trans:           0</p>
			<p class="source-code">  Role allow:            0    Role_trans:            0</p>
			<p class="source-code">  Constraints:           0    Validatetrans:         0</p>
			<p class="source-code">  MLS Constrain:        59    MLS Val. Tran:         0</p>
			<p class="source-code">  Permissives:           0    Polcap:                2</p>
			<p class="source-code">  Defaults:              0    Typebounds:            0</p>
			<p class="source-code">  Allowxperm:          185    Neverallowxperm:       0</p>
			<p class="source-code">  Auditallowxperm:       0    Dontauditxperm:        0</p>
			<p class="source-code">  Initial SIDs:         27    Fs_use:               16</p>
			<p class="source-code">  Genfscon:             83    Portcon:               0</p>
			<p class="source-code">  Netifcon:              0    Nodecon:               0</p>
			<p class="calibre3">When the command is not explicitly told to parse a given policy file, it will try to query the current active policy through the <strong class="source-inline">/sys/fs/selinux/policy</strong> pseudo-file.</p>
			<h2 id="_idParaDest-330" class="calibre10"><a id="_idTextAnchor334" class="pcalibre calibre6 pcalibre1"/>Displaying policy object information</h2>
			<p class="calibre3">The main <a id="_idIndexMarker855" class="pcalibre calibre6 pcalibre1"/>purpose of the <strong class="source-inline">seinfo</strong> application is to display SELinux object information. This information is presented on a per-object basis. Various SELinux object types are supported, ranging from the well-known types, attributes, roles, and users, to the more specialized <strong class="source-inline">fs_use_*</strong> declarations or <strong class="source-inline">genfscon</strong> statements.</p>
			<p class="calibre3">A complete list of supported object types (and their resulting <strong class="source-inline">seinfo</strong> options) can be found on the <strong class="source-inline">seinfo</strong> manual page, or through the direct help:</p>
			<p class="source-code">$ seinfo --help</p>
			<p class="calibre3">Regardless <a id="_idIndexMarker856" class="pcalibre calibre6 pcalibre1"/>of the object type that the user is interested in, <strong class="source-inline">seinfo</strong> has three main modus operandi:</p>
			<ul class="calibre8">
				<li class="calibre9">In the first mode, it lists the objects of a given type. For this, only the option has to be passed on, without additional information. For instance, to list all object classes available in the policy, use the following command:<p class="source-code"><strong class="bold">$ seinfo --class</strong></p></li>
				<li class="calibre9">In the second mode, it can confirm (or deny) the presence of an object instance. To accomplish this, add the instance name to the command. For instance, to validate if the <strong class="source-inline">memprotect</strong> class is available in the policy, use the following command:<p class="source-code"><strong class="bold">$ seinfo --class memprotect</strong></p><p class="source-code"><strong class="bold">Classes: 1</strong></p><p class="source-code"><strong class="bold">  memprotect</strong></p><p class="calibre3">Sadly, regardless of whether the instance is available or not, the return code of the application is the same, so scripts cannot use this without additional statements to verify whether the instance exists. Instead, they will need to check the output of the command (which will state that zero instances exist that match the name).</p></li>
				<li class="calibre9">The third mode displays expanded information about a selected instance. Although not all information objects support an expanded set, most of the common ones do. The expanded information generally shows a list of (different) instances related to the initial query:<p class="source-code"><strong class="bold">$ seinfo --class memprotect -x</strong></p><p class="source-code"><strong class="bold">Classes: 1</strong></p><p class="source-code"><strong class="bold">  class memprotect</strong></p><p class="source-code"><strong class="bold">{</strong></p><p class="source-code"><strong class="bold">    mmap_zero</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
			</ul>
			<p class="calibre3">The supported types that <strong class="source-inline">seinfo</strong> can query are the following:</p>
			<ul class="calibre8">
				<li class="calibre9">With <strong class="source-inline">--attribute</strong> (<strong class="source-inline">-a</strong>), <strong class="source-inline">seinfo</strong> shows all currently known SELinux attributes in the policy. When expanded, it shows the types associated with a given attribute.</li>
				<li class="calibre9">With <strong class="source-inline">--bool</strong> (<strong class="source-inline">-b</strong>), <strong class="source-inline">seinfo</strong> shows all currently known SELinux booleans in the policy. When expanded, it shows the current value of the boolean.</li>
				<li class="calibre9">With <strong class="source-inline">--class</strong> (<strong class="source-inline">-c</strong>), <strong class="source-inline">seinfo</strong> shows the supported SELinux classes. When expanded, it shows the permissions supported by that class.</li>
				<li class="calibre9">With <strong class="source-inline">--role</strong> (<strong class="source-inline">-r</strong>), <strong class="source-inline">seinfo</strong> shows the SELinux roles supported in the policy. When expanded, it shows the domains allowed for that role.</li>
				<li class="calibre9">With <strong class="source-inline">--type</strong> (<strong class="source-inline">-t</strong>), <strong class="source-inline">seinfo</strong> shows the SELinux types in the policy. When expanded, it shows the aliases that the type has, as well as the attributes.</li>
				<li class="calibre9">With <strong class="source-inline">--user</strong> (<strong class="source-inline">-u</strong>), <strong class="source-inline">seinfo</strong> shows the SELinux users (not the Linux users or logins) known by <a id="_idIndexMarker857" class="pcalibre calibre6 pcalibre1"/>the policy. When expanded, it shows the roles and sensitivity range associated with the SELinux user.</li>
				<li class="calibre9">With <strong class="source-inline">--category</strong>, <strong class="source-inline">seinfo</strong> shows the currently supported categories. When expanded, it shows the sensitivities for which the category is associated (only in MLS policies).</li>
				<li class="calibre9">With <strong class="source-inline">--common</strong>, <strong class="source-inline">seinfo</strong> shows the common permission sets. These are sets inherited by different classes. When expanded, it shows the permissions part of that set.</li>
				<li class="calibre9">With <strong class="source-inline">--constrain</strong>, <strong class="source-inline">seinfo</strong> shows the current constraints. There is no expanded information for this query.</li>
				<li class="calibre9">With <strong class="source-inline">--default</strong>, <strong class="source-inline">seinfo</strong> shows the <strong class="source-inline">default_*</strong> rules within the policy. One of these rules, for instance, is the default sensitivity range for a class (<strong class="source-inline">default_range</strong>). There is no expanded information for this query.</li>
				<li class="calibre9">With <strong class="source-inline">--fs_use</strong>, <strong class="source-inline">seinfo</strong> shows the <strong class="source-inline">fs_use_*</strong> rules within the SELinux policy. One of these rules is to allocate a security context for filesystems that support extended attributes (<strong class="source-inline">fs_use_xattr</strong>). There is no expanded information for this query.</li>
				<li class="calibre9">With <strong class="source-inline">--genfscon</strong>, <strong class="source-inline">seinfo</strong> shows the context allocations for filesystems that do not support extended attributes. There is no expanded information for this query.</li>
				<li class="calibre9">With <strong class="source-inline">--initialsid</strong>, <strong class="source-inline">seinfo</strong> shows all the initial <strong class="bold">Security Identifiers</strong> (<strong class="bold">SID</strong>). These are all the <a id="_idIndexMarker858" class="pcalibre calibre6 pcalibre1"/>classes that have predefined contexts set. When expanded, it shows the context associated with the SID.</li>
				<li class="calibre9">With <strong class="source-inline">--netifcon</strong>, <strong class="source-inline">seinfo</strong> shows the contexts currently associated with the network interfaces. This is only applicable when labeled networking is active. There is no expanded information for this query.</li>
				<li class="calibre9">With <strong class="source-inline">--nodecon</strong>, <strong class="source-inline">seinfo</strong> shows the contexts currently associated with the node definitions (hosts). This is only applicable when labeled networking is active. There is no expanded information for this query.</li>
				<li class="calibre9">With <strong class="source-inline">--permissive</strong>, <strong class="source-inline">seinfo</strong> shows which types are currently marked as permissive domains. There <a id="_idIndexMarker859" class="pcalibre calibre6 pcalibre1"/>is no expanded information for this query.</li>
				<li class="calibre9">With <strong class="source-inline">--polcap</strong>, <strong class="source-inline">seinfo</strong> shows the policy capabilities (that is, in-policy settings that define the SELinux subsystem behavior, such as support for SCTP through the <strong class="source-inline">extended_socket_class</strong> policy capability that we saw in <a href="B16276_05_Final_VK.xhtml#_idTextAnchor138" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 5</em></a>, <em class="italic">Controlling Network Communications</em>). When expanded, it shows the actual policy capability statements in the policy.</li>
				<li class="calibre9">With <strong class="source-inline">--portcon</strong>, <strong class="source-inline">seinfo</strong> shows the current port mappings and their associated contexts (which is also interpreted by <strong class="source-inline">semanage port -l</strong>). There is no expanded information for this query.</li>
				<li class="calibre9">With <strong class="source-inline">--sensitivity</strong>, <strong class="source-inline">seinfo</strong> shows the currently supported sensitivity levels. When expanded, it shows the actual policy statements to declare the sensitivities.</li>
				<li class="calibre9">With <strong class="source-inline">--typebounds</strong>, <strong class="source-inline">seinfo</strong> shows the type bounds (SELinux types or domains bounded by a parent domain). There is no expanded information for this query.</li>
				<li class="calibre9">With <strong class="source-inline">--validatetrans</strong>, <strong class="source-inline">seinfo</strong> shows the transition constraints active in the policy (these are constraints that limit when a file transition is allowed). This is not used in most Linux distributions. There is no expanded information for this query.</li>
			</ul>
			<p class="calibre3">The <strong class="source-inline">seinfo</strong> command also has an <strong class="source-inline">--all</strong> option that shows all possible information it can get from a policy file. However, this does not include the expanded information.</p>
			<h2 id="_idParaDest-331" class="calibre10"><a id="_idTextAnchor335" class="pcalibre calibre6 pcalibre1"/>Understanding sesearch</h2>
			<p class="calibre3">Where <strong class="source-inline">seinfo</strong> displays information about SELinux objects, <strong class="source-inline">sesearch</strong> is used to query SELinux rules <a id="_idIndexMarker860" class="pcalibre calibre6 pcalibre1"/>and behavior information between a source and a target resource.</p>
			<p class="calibre3">We have been using <strong class="source-inline">sesearch</strong> to query standard <strong class="source-inline">allow</strong> rules (type enforcement-related access controls) as well as the impact of SELinux booleans on these <strong class="source-inline">allow</strong> rules. The <strong class="source-inline">sesearch</strong> application allows us to not just query rules based on the rule type, but also filter based on additional parameters. Let's see which parameters can be used for <strong class="source-inline">sesearch</strong> filters:</p>
			<ul class="calibre8">
				<li class="calibre9">The most common queries are to filter out the rules that match a given source expression using <strong class="source-inline">--source</strong> (<strong class="source-inline">-s</strong>) and/or target expression using <strong class="source-inline">--target</strong> (<strong class="source-inline">-t</strong>):<p class="source-code"><strong class="bold">$ sesearch -A -s mount_t -t unconfined_t</strong></p><p class="calibre3">The <strong class="source-inline">sesearch</strong> application can also deal with indirect source or target information. For instance, when querying information related to the <strong class="source-inline">svirt_sandbox_domain</strong> attribute, it will also display rules of all types that have this attribute assigned. We can selectively disable this behavior using <strong class="source-inline">-ds</strong> (for source) and <strong class="source-inline">-dt</strong> (for target):</p><p class="source-code"><strong class="bold">$ sesearch -A -s svirt_sandbox_domain -ds</strong></p></li>
				<li class="calibre9">With the <strong class="source-inline">--class</strong> (<strong class="source-inline">-c</strong>) argument, we can search for only those rules affecting a specified resource class (such as <strong class="source-inline">file</strong>, <strong class="source-inline">dir</strong>, <strong class="source-inline">tcp_socket</strong>, and so forth—the list of all possible classes can be obtained using <strong class="source-inline">seinfo --class</strong>):<p class="source-code"><strong class="bold">$ sesearch -A -s svirt_sandbox_domain -c file</strong></p></li>
				<li class="calibre9">If we are interested in only a particular action (or permission), we can use the <strong class="source-inline">--perm</strong> (<strong class="source-inline">-p</strong>) argument. This is particularly useful when we encounter a denial for a certain action (say,  <strong class="source-inline">write</strong>) and want to see which domains are allowed to perform this action, as it might indicate that we are examining the wrong source domain. We can list multiple permissions, in which case <strong class="source-inline">sesearch</strong> will display the rules that have at least one permission in them:<p class="source-code"><strong class="bold">$ sesearch -A -s staff_t -c file -p write</strong></p><p class="calibre3">With the <strong class="source-inline">-ep</strong> option, <strong class="source-inline">sesearch</strong> will only list the rules that have all permissions in them, rather than at least one.</p></li>
				<li class="calibre9">We can also query only those rules influenced by an SELinux boolean using the <strong class="source-inline">--bool</strong> (<strong class="source-inline">-b</strong>) argument, as we saw in <a href="B16276_12_Final_VK.xhtml#_idTextAnchor312" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 12</em></a>, <em class="italic">Tuning SELinux Policies</em>.<p class="calibre3">If we use the <strong class="source-inline">-eb</strong> option, then all booleans listed on the command line must be matched, rather than at least one.</p></li>
				<li class="calibre9">The <strong class="source-inline">sesearch</strong> application can also use regular expressions rather than actual values. This is not the default behavior, but can be activated with <strong class="source-inline">-rs</strong> (for the source type or role), <strong class="source-inline">-rt</strong> (for the target type or role), <strong class="source-inline">-rc</strong> (for the class), <strong class="source-inline">-rd</strong> (for the default type or role), and <strong class="source-inline">-rb</strong> (for the boolean):<p class="source-code"><strong class="bold">$ sesearch -A -s staff_.*_t -c process -p transition -rs</strong></p></li>
			</ul>
			<p class="calibre3">As this <a id="_idIndexMarker861" class="pcalibre calibre6 pcalibre1"/>provides insights into the most common SELinux behavior and access controls, let's go through the various rules and the impact they have on the system.</p>
			<h2 id="_idParaDest-332" class="calibre10"><a id="_idTextAnchor336" class="pcalibre calibre6 pcalibre1"/>Querying allow rules</h2>
			<p class="calibre3">The first set <a id="_idIndexMarker862" class="pcalibre calibre6 pcalibre1"/>of rules are the <strong class="source-inline">allow</strong> rules, of which many subtypes exist. The standard <strong class="source-inline">allow</strong> rule defines which actions a source domain can successfully trigger toward or against a target type:</p>
			<p class="source-code">$ sesearch --allow -s guest_t -t cgroup_t -c dir</p>
			<p class="source-code">allow guest_usertype cgroup_t:dir { getattr ioctl lock open read search };</p>
			<p class="source-code">allow guest_usertype filesystem_type:dir { getattr open search };</p>
			<p class="calibre3">There are a few similar rules that SELinux policies can define, and these can be queried similarly with <strong class="source-inline">sesearch</strong> as follows:</p>
			<ul class="calibre8">
				<li class="calibre9">Using <strong class="source-inline">--auditallow</strong>, we can query which actions are allowed by SELinux but will still result in an audit event.</li>
				<li class="calibre9">Using <strong class="source-inline">--dontaudit</strong>, we can query which actions will not trigger an audit event, even when the action is denied.</li>
				<li class="calibre9">Using <strong class="source-inline">--neverallow</strong>, we can query which actions are forbidden from being declared within the policy. Such actions, when defined, will cause the system to refuse to load new SELinux policies if they violate the rule. It cannot be used to negate existing rules though, and <strong class="source-inline">neverallow</strong> rules that you attempt to add to the policy afterward will fail if the current policy already has deviations against this rule.</li>
			</ul>
			<p class="calibre3">SELinux also <a id="_idIndexMarker863" class="pcalibre calibre6 pcalibre1"/>supports <strong class="bold">extended permission rules</strong>. These rules are similar to regular <strong class="source-inline">allow</strong> rules but take an additional (number) parameter that further limits the applicability of the rule, and are used to provide fine-grained access control for device queries. These queries are generally handled by the <strong class="source-inline">ioctl()</strong> system call, but until its support for extended permissions, SELinux could only control whether a domain was allowed to use the <strong class="source-inline">ioctl()</strong> system call or not, rather than filtering on the explicit query through <strong class="source-inline">ioctl()</strong>.</p>
			<p class="calibre3">With extended permission rules, SELinux policy developers can specify which <strong class="source-inline">ioctl()</strong> queries are allowed and which ones aren't. For instance, we can grant a domain the ability to get a hardware <a id="_idIndexMarker864" class="pcalibre calibre6 pcalibre1"/>address (known as <strong class="source-inline">SIOCGIFHWADDR</strong>, which is defined with number <strong class="source-inline">0x8927</strong>) as follows:</p>
			<p class="source-code">allowxperm &lt;domain&gt; &lt;resource&gt; : tcp_socket ioctl 0x8927;</p>
			<p class="calibre3">Within <strong class="source-inline">sesearch</strong>, we can query these rules using <strong class="source-inline">--allowxperm</strong>. Like regular <strong class="source-inline">allow</strong> rules, we also have the <strong class="source-inline">--auditallowxperm</strong>, <strong class="source-inline">--dontauditxperm</strong>, and <strong class="source-inline">--neverallowxperm</strong> options to cover the extended-permission-equivalent rules. These have the same impact on the query and also on the extended permission rules.</p>
			<h2 id="_idParaDest-333" class="calibre10"><a id="_idTextAnchor337" class="pcalibre calibre6 pcalibre1"/>Querying type transition rules</h2>
			<p class="calibre3">A second <a id="_idIndexMarker865" class="pcalibre calibre6 pcalibre1"/>set of rules are the type transition rules. Rather than informing <a id="_idIndexMarker866" class="pcalibre calibre6 pcalibre1"/>the system which actions are allowed or not, <strong class="bold">type transitions</strong> influence the SELinux context of objects and resources through actions taken by the processes on the system. Type transition rules, for instance, define what context a newly written file receives when it is written by a particular domain within a directory that has a given SELinux type, or what domain a newly created process receives when it is executed from a given source domain:</p>
			<p class="source-code">$ sesearch -T -s guest_t -c process</p>
			<p class="source-code">type_transition guest_t abrt_helper_exec_t:process abrt_helper_t;</p>
			<p class="source-code">type_transition guest_t chfn_exec_t:process chfn_t;</p>
			<p class="source-code">...</p>
			<p class="calibre3">In this output, we can see that when the guest domain successfully executes a binary labeled with <strong class="source-inline">abrt_helper_exec_t</strong>, its resulting process will be assigned the <strong class="source-inline">abrt_helper_t</strong> context.</p>
			<p class="calibre3">These rules are queried and interpreted by various tools in the <em class="italic">Investigating domain transitions</em> section.</p>
			<h2 id="_idParaDest-334" class="calibre10"><a id="_idTextAnchor338" class="pcalibre calibre6 pcalibre1"/>Querying other type rules</h2>
			<p class="calibre3">Alongside <a id="_idIndexMarker867" class="pcalibre calibre6 pcalibre1"/>the <strong class="source-inline">allow</strong> rules and type transition rules, <strong class="source-inline">sesearch</strong> can also query two other type-related rules: <strong class="source-inline">type_change</strong> and <strong class="source-inline">type_member</strong>. These rules are meant for SELinux-aware applications and are not enforced by the in-kernel SELinux subsystem:</p>
			<ul class="calibre8">
				<li class="calibre9">With <strong class="source-inline">type_change</strong> statements (which can be filtered in <strong class="source-inline">sesearch</strong> using the <strong class="source-inline">--type_change</strong> option), developers inform the SELinux-aware application that a target resource should be relabeled with a given type on behalf of the source domain.<p class="calibre3">For instance, when systemd assigns a terminal to a user, it queries the SELinux policy for <strong class="source-inline">type_change</strong> statements for the user domain, given the current terminal's SELinux type, and will return the following <strong class="source-inline">type_change</strong> statement:</p><p class="source-code">type_change guest_t tty_device_t:chr_file user_tty_device_t;</p><p class="calibre3">As the device file itself already exists and is only reassigned to a user, no type transition itself is done. Instead, the <strong class="source-inline">type_change</strong> rule is interpreted by the SELinux-aware application that relabels the device file accordingly.</p></li>
				<li class="calibre9">The <strong class="source-inline">type_member</strong> rule (which can be filtered in <strong class="source-inline">sesearch</strong> using the <strong class="source-inline">--type_member</strong> option) informs SELinux-aware applications that participate in setting up <a id="_idIndexMarker868" class="pcalibre calibre6 pcalibre1"/>polyinstantiated locations (as we saw in <a href="B16276_03_Final_VK.xhtml#_idTextAnchor071" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing User Logins</em>) about the target SELinux type of such directories. For instance, when the <strong class="source-inline">/tmp</strong> location (which is labeled with <strong class="source-inline">tmp_t</strong>) is polyinstantiated for a user, then the following rule is used to understand that the <strong class="source-inline">/tmp</strong> view for this user is to be labeled with <strong class="source-inline">user_tmp_t</strong>:<p class="source-code">type_member guest_t tmp_t:dir user_tmp_t;</p><p class="calibre3">The PAM module responsible for addressing the polyinstantiation is SELinux-aware, and will use these rules to deduce what the target types must be for the created locations.</p></li>
			</ul>
			<p class="calibre3">Alongside the type-related statements, <strong class="source-inline">sesearch</strong> can also handle role-related queries. </p>
			<h2 id="_idParaDest-335" class="calibre10"><a id="_idTextAnchor339" class="pcalibre calibre6 pcalibre1"/>Querying role-related rules</h2>
			<p class="calibre3">SELinux also <a id="_idIndexMarker869" class="pcalibre calibre6 pcalibre1"/>has rules related to role activities and transitions. With the <strong class="source-inline">sesearch</strong> application, we can query which SELinux roles are allowed to be accessed from other roles, and when a role transition (such as switching from a user role to the system role) is performed:</p>
			<p class="source-code">$ sesearch --role_allow -s dbadm_r;</p>
			<p class="source-code">allow dbadm_r sysadm_r;</p>
			<p class="source-code">$ sesearch --role_trans -s dbadm_r;</p>
			<p class="source-code">role_transition dbadm_r mysqld_initrc_exec_t:process system_r;</p>
			<p class="source-code">role_transition dbadm_r postgresql_initrc_exec_t:process system_r;</p>
			<p class="calibre3">The distinction between the two is that the allowed access (using <strong class="source-inline">--role_allow</strong>) shows which roles can be accessed from a given role, but they do not dictate when the change is done. The role transitions (using <strong class="source-inline">--role_trans</strong>) show when the system attempts to automatically change a role (and to what role it would be changed) when executing a script or binary. Hence, they can be compared with the <strong class="source-inline">allow</strong> rules (which specify what is allowed) and type transitions (defining SELinux behavior).</p>
			<p class="calibre3">Analyzing role transitions and role <strong class="source-inline">allow</strong> rules helps administrators deduce which roles are too powerful or could result in potential security issues. For instance, allowing the <strong class="source-inline">dbadm_r</strong> role to switch to the <strong class="source-inline">system_r</strong> role through the <strong class="source-inline">postgresql_initrc_exec_t</strong> type might allow that role to invoke actions outside its scope if it also has the rights to modify <strong class="source-inline">postgresql_initrc_exec_t</strong> resources:</p>
			<p class="source-code">$ sesearch -A -s dbadm_t -t postgresql_initrc_exec_t -c file;</p>
			<p class="source-code">allow dbadm_t postgresql_initrc_exec_t:file { execute execute_no_trans getattr ioctl map open read };</p>
			<p class="calibre3">While directly <a id="_idIndexMarker870" class="pcalibre calibre6 pcalibre1"/>modifying <strong class="source-inline">postgresql_initrc_exec_t</strong> files is thus not allowed, it is not enough to only look at the main user type. A decent analysis needs to include all types reachable by the <strong class="source-inline">dbadm_r</strong> role, which we will cover in the <em class="italic">Investigating domain transitions</em> and <em class="italic">Analyzing information flow</em> sections. These sections will use <strong class="source-inline">apol</strong>, so let's first see what this application is all about.</p>
			<h2 id="_idParaDest-336" class="calibre10"><a id="_idTextAnchor340" class="pcalibre calibre6 pcalibre1"/>Browsing with apol</h2>
			<p class="calibre3">An advanced <a id="_idIndexMarker871" class="pcalibre calibre6 pcalibre1"/>tool to perform policy analysis is <strong class="source-inline">apol</strong>, which can be launched by just executing the command without any arguments. The tool is graphical in nature and allows analysts and administrators to perform a wide range of analytical actions against the SELinux policy.</p>
			<p class="calibre3">Once started, the first action to take with <strong class="source-inline">apol</strong> is to load a target policy (either the currently active policy or a file copied over from a different system). This can be accomplished through the <strong class="bold">Open Policy</strong> button, or by navigating to <strong class="bold">File</strong> | <strong class="bold">Open Policy</strong>.</p>
			<p class="calibre3">The tool will then display a generic overview of the loaded policy:</p>
			<div class="calibre13">
				<div id="_idContainer034" class="img---figure">
					<img src="Images/B16276_13_001.jpg" alt="Figure 13.1 – The apol application after loading a policy file " class="calibre28"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – The apol application after loading a policy file</p>
			<p class="calibre3">Once it <a id="_idIndexMarker872" class="pcalibre calibre6 pcalibre1"/>has been loaded, select <strong class="bold">New Analysis</strong> to initiate the policy analysis functions:</p>
			<div class="calibre13">
				<div id="_idContainer035" class="img---figure">
					<img src="Images/B16276_13_002.jpg" alt="Figure 13.2 – apol's overview of supported analysis methods " class="calibre29"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 – apol's overview of supported analysis methods</p>
			<p class="calibre3">A decent <a id="_idIndexMarker873" class="pcalibre calibre6 pcalibre1"/>number of analysis methods are provided. Let's select <strong class="bold">Types</strong> to browse through the available types, or select an attribute to find out which SELinux types are assigned to that attribute:</p>
			<div class="calibre13">
				<div id="_idContainer036" class="img---figure">
					<img src="Images/B16276_13_003.jpg" alt="Figure 13.3 – Type browsing with apol " class="calibre30"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3 – Type browsing with apol</p>
			<p class="calibre3">Similarly, with <a id="_idIndexMarker874" class="pcalibre calibre6 pcalibre1"/>the <strong class="bold">TE Rules</strong> analysis, we can perform the same analysis as we did with the <strong class="source-inline">sesearch</strong> application:</p>
			<div class="calibre13">
				<div id="_idContainer037" class="img---figure">
					<img src="Images/B16276_13_004.jpg" alt="Figure 13.4 – Querying type enforcement rules with apol " class="calibre31"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4 – Querying type enforcement rules with apol</p>
			<p class="calibre3">The more <a id="_idIndexMarker875" class="pcalibre calibre6 pcalibre1"/>advanced analysis methods are covered in the <em class="italic">Investigating domain transitions</em> and <em class="italic">Analyzing information flow</em> sections.</p>
			<h2 id="_idParaDest-337" class="calibre10"><a id="_idTextAnchor341" class="pcalibre calibre6 pcalibre1"/>Using apol workspaces</h2>
			<p class="calibre3">Analyzing <a id="_idIndexMarker876" class="pcalibre calibre6 pcalibre1"/>SELinux policies can take a while, especially when this involves multiple phases of analysis and fine-tuning. The <strong class="source-inline">apol</strong> tool allows you to save your current workspace to disk, so that you can later get back to the analysis from the point at which you saved it:</p>
			<div class="calibre13">
				<div id="_idContainer038" class="img---figure">
					<img src="Images/B16276_13_005.jpg" alt="Figure 13.5 – Workspace management in apol " class="calibre32"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.5 – Workspace management in apol</p>
			<p class="calibre3">Workspaces <a id="_idIndexMarker877" class="pcalibre calibre6 pcalibre1"/>not only retain the settings of the queries so far, but also the notes you might add. Notes are an important feature within <strong class="source-inline">apol</strong> where you can write down thoughts and observations from the queries you've made. The notes are associated with the tabs you have open, allowing you to switch between different queries as needed.</p>
			<p class="calibre3">Now that we know how the <strong class="source-inline">apol</strong> application works, let's see how we can use it (and other tools) for more in-depth analyses.</p>
			<h1 id="_idParaDest-338" class="calibre5"><a id="_idTextAnchor342" class="pcalibre calibre6 pcalibre1"/>Investigating domain transitions</h1>
			<p class="calibre3">An important <a id="_idIndexMarker878" class="pcalibre calibre6 pcalibre1"/>analytical approach when dealing <a id="_idIndexMarker879" class="pcalibre calibre6 pcalibre1"/>with SELinux policies is to perform a <strong class="bold">domain transition analysis</strong>. Domains are bounded by the access controls in place for a given domain, but users or processes can transition to other domains by executing the right set of applications.</p>
			<p class="calibre3">Analyzing whether and how a transition can occur between two SELinux domains allows administrators to validate the secure state of the policy. Given the mandatory nature of SELinux, adversaries will find it difficult to be able to execute target applications if a domain transition analysis shows that the source domain cannot execute said application, either directly or indirectly.</p>
			<p class="calibre3">Administrators should use domain transition analysis to confirm a domain is correctly confined, and that vulnerabilities within the applications running inside a domain cannot lead to privilege escalations.</p>
			<h2 id="_idParaDest-339" class="calibre10"><a id="_idTextAnchor343" class="pcalibre calibre6 pcalibre1"/>Using apol for domain transition analysis</h2>
			<p class="calibre3">After <a id="_idIndexMarker880" class="pcalibre calibre6 pcalibre1"/>starting <strong class="source-inline">apol</strong>, select <strong class="bold">New Analysis</strong> followed by <strong class="bold">Domain Transition Analysis</strong>. The analysis screen itself will show several possible analytical approaches:</p>
			<div class="calibre13">
				<div id="_idContainer039" class="img---figure">
					<img src="Images/B16276_13_006.jpg" alt="Figure 13.6 – Querying possible transition paths between staff_t and unconfined_t " class="calibre33"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.6 – Querying possible transition paths between staff_t and unconfined_t</p>
			<p class="calibre3">This analysis <a id="_idIndexMarker881" class="pcalibre calibre6 pcalibre1"/>will attempt to find a path between a given source domain and target domain, and display the execution trail that could lead to the transition. Administrators can then verify whether the applications associated with these domain transitions can be trusted or not. Such analysis is sensible when we need to assert that certain domains cannot break out of their confinement, or when we are developing new policies and want to ensure that the confinement is within the boundaries we want.</p>
			<p class="calibre3">The transition analysis can be fine-tuned through the following settings:</p>
			<ul class="calibre8">
				<li class="calibre9">With <strong class="bold">Shortest paths</strong>, <strong class="source-inline">apol</strong> will show domain transitions between the source domain and the target domain, seeking the shortest transitions possible. For instance, a transition from <strong class="source-inline">staff_t</strong> to <strong class="source-inline">staff_sudo_t</strong> to <strong class="source-inline">unconfined_t</strong> is a two-step path. When a path is found, <strong class="source-inline">apol</strong> will not search for longer paths.</li>
				<li class="calibre9">When we select <strong class="bold">All paths up to</strong>, <strong class="source-inline">apol</strong> will perform the analysis up to a certain number of steps. When we use up to one step, then this is similar to doing direct queries with <strong class="source-inline">seinfo</strong> or <strong class="source-inline">sesearch</strong>. </li>
				<li class="calibre9">Using <strong class="bold">Transitions out of the source domain</strong> and <strong class="bold">Transitions into the target domain</strong> will show all transitions that can occur from a given source domain or to the target domain. This is used for a more interactive session, where users can click through the domains to see the next set of domains that can be transitioned to.</li>
			</ul>
			<p class="calibre3">To further <a id="_idIndexMarker882" class="pcalibre calibre6 pcalibre1"/>fine-tune the analysis, a few options can be selected. For instance, we can exclude certain types from being used in the domain transition analysis. This allows us to mark certain domains as trusted (such as the <strong class="source-inline">*_sudo_t</strong> domains), which will make <strong class="source-inline">apol</strong> ignore those domains to find more appropriate transition chains to analyze.</p>
			<h2 id="_idParaDest-340" class="calibre10"><a id="_idTextAnchor344" class="pcalibre calibre6 pcalibre1"/>Using sedta for domain transition analysis</h2>
			<p class="calibre3">The path <a id="_idIndexMarker883" class="pcalibre calibre6 pcalibre1"/>analysis done by <strong class="source-inline">apol</strong> can also be executed from a command-line application called <strong class="source-inline">sedta</strong>. It has the same capabilities as the domain transition analysis functionality within <strong class="source-inline">apol</strong>.</p>
			<p class="calibre3">The type of analysis is selected through command-line arguments: <strong class="source-inline">-S</strong> is used for shortest path analysis, whereas <strong class="source-inline">-A</strong> (followed by a number) runs the equivalent of <strong class="bold">All paths up to</strong>.</p>
			<p class="calibre3">For instance, to check for a domain transition path between the <strong class="source-inline">staff_t</strong> domain and the <strong class="source-inline">unconfined_t</strong> domain, excluding the <strong class="source-inline">staff_sudo_t</strong>, <strong class="source-inline">newrole_t,</strong> and <strong class="source-inline">init_t</strong> domains, use the following command:</p>
			<p class="source-code">$ sedta -S -s staff_t -t unconfined_t staff_sudo_t newrole_t</p>
			<p class="source-code">Domain transition path 1:</p>
			<p class="source-code">Step 1: staff_t -&gt; oddjob_t</p>
			<p class="source-code">Domain transition rule(s):</p>
			<p class="source-code">allow staff_t oddjob_t:process transition;</p>
			<p class="source-code">Set execution context rule(s):</p>
			<p class="source-code">allow staff_t staff_t:process { dyntransition fork getattr getcap getpgid getrlimit getsched getsession noatsecure rlimitinh setcap setcurrent setexec setfscreate setkeycreate setpgid setrlimit setsched setsockcreate share sigchld siginh sigkill signal signull sigstop transition };</p>
			<p class="source-code">Entrypoint oddjob_exec_t:</p>
			<p class="source-code">        Domain entrypoint rule(s):</p>
			<p class="source-code">        allow oddjob_t oddjob_exec_t:file { entrypoint execute getattr ioctl lock map open read };</p>
			<p class="source-code">        File execute rule(s):</p>
			<p class="source-code">        allow staff_t oddjob_exec_t:file { execute execute_no_trans getattr ioctl map open read };</p>
			<p class="source-code">        Type transition rule(s):</p>
			<p class="source-code">        type_transition staff_t oddjob_exec_t:process oddjob_t;</p>
			<p class="source-code">Step 2: oddjob_t -&gt; openshift_initrc_t</p>
			<p class="source-code">...</p>
			<p class="calibre3">We can <a id="_idIndexMarker884" class="pcalibre calibre6 pcalibre1"/>analyze a different policy than the current system policy using the <strong class="source-inline">-p</strong> option.</p>
			<h2 id="_idParaDest-341" class="calibre10"><a id="_idTextAnchor345" class="pcalibre calibre6 pcalibre1"/>Using sepolicy for domain transition analysis</h2>
			<p class="calibre3">The <strong class="source-inline">sepolicy</strong> tool has <a id="_idIndexMarker885" class="pcalibre calibre6 pcalibre1"/>a built-in domain transition analysis capability using the <strong class="source-inline">transition</strong> argument. It is, however, not as flexible as <strong class="source-inline">sedta</strong> or <strong class="source-inline">apol</strong>, as no tuning can be done to the command. It also does not seem to cover all possible paths, often displaying extensive and elaborate routes that could be much simpler:</p>
			<p class="source-code">$ sepolicy transition -s mount_t -t unconfined_t</p>
			<p class="source-code">mount_t ... glusterd_t ... ipsec_t ... ipsec_mgmt_t</p>
			<p class="source-code">  ... initrc_t ... condor_schedd_t ... condor_startd_t</p>
			<p class="source-code">  ... openshift_initrc_t ... stunnel_t ... telnetd_t</p>
			<p class="source-code">  ... remote_login_t @ shell_exec_t --&gt; unconfined_t</p>
			<p class="source-code">  -- Allowed True [ unconfined_login=1 ]</p>
			<p class="source-code">mount_t ... glusterd_t ... ipsec_t ... ipsec_mgmt_t</p>
			<p class="source-code">  ... initrc_t ... condor_schedd_t ... condor_startd_t</p>
			<p class="source-code">  ... openshift_initrc_t ... kmscon_t ... </p>
			<p class="source-code">  local_login_t @ shell_exec_t --&gt; unconfined_t </p>
			<p class="source-code">  -- Allowed True [ unconfined_login=1 ]</p>
			<p class="source-code">mount_t ... glusterd_t ... ipsec_t ... ipsec_mgmt_t</p>
			<p class="source-code">  ... initrc_t ... condor_schedd_t ... condor_startd_t</p>
			<p class="source-code">  ... openshift_initrc_t ... kdumpgui_t ... kdumpctl_t</p>
			<p class="source-code">  ... sge_execd_t ... sge_shepherd_t ...</p>
			<p class="source-code">  sshd_t @ shell_exec_t --&gt; unconfined_t</p>
			<p class="source-code">  -- Allowed True [ ssh_sysadm_login=0 || unconfined_login=1 ]</p>
			<p class="source-code">mount_t ... glusterd_t ... ipsec_t ... ipsec_mgmt_t</p>
			<p class="source-code">  ... initrc_t ... condor_schedd_t ... condor_startd_t</p>
			<p class="source-code">  ... openshift_initrc_t ... kdumpgui_t ... kdumpctl_t ...</p>
			<p class="source-code">  sulogin_t @ shell_exec_t --&gt; unconfined_t</p>
			<p class="source-code">  -- Allowed True [ unconfined_login=1 ]</p>
			<p class="source-code">mount_t ... glusterd_t ... ipsec_t ... ipsec_mgmt_t</p>
			<p class="source-code">  ... initrc_t ... condor_schedd_t ... condor_startd_t</p>
			<p class="source-code">  ... openshift_initrc_t ... kdumpgui_t ... kdumpctl_t</p>
			<p class="source-code">  ... inetd_t ...</p>
			<p class="source-code">  rshd_t @ shell_exec_t --&gt; unconfined_t</p>
			<p class="source-code">  -- Allowed True [ unconfined_login=1 ]</p>
			<p class="source-code">mount_t ... glusterd_t ... ipsec_t ... ipsec_mgmt_t</p>
			<p class="source-code">  ... initrc_t ... condor_schedd_t ... condor_startd_t</p>
			<p class="source-code">  ... openshift_initrc_t ... kdumpgui_t ... kdumpctl_t</p>
			<p class="source-code">  ... piranha_pulse_t ...</p>
			<p class="source-code">  crond_t @ shell_exec_t --&gt; unconfined_t</p>
			<p class="source-code">  -- Allowed True [ cron_userdomain_transition=1 || unconfined_login=1 ]</p>
			<p class="source-code">mount_t ... glusterd_t ... ipsec_t ... ipsec_mgmt_t</p>
			<p class="source-code">  ... initrc_t ... condor_schedd_t ... condor_startd_t</p>
			<p class="source-code">  ... openshift_initrc_t ... kdumpgui_t ... kdumpctl_t</p>
			<p class="source-code">  ... piranha_pulse_t ... cockpit_ws_t ...</p>
			<p class="source-code">  cockpit_session_t @ unconfined_exec_t --&gt; unconfined_t</p>
			<p class="calibre3">Let's <a id="_idIndexMarker886" class="pcalibre calibre6 pcalibre1"/>compare this with <strong class="source-inline">sedta</strong>, which we use against the same policy and for the same domain transition:</p>
			<p class="source-code">$ sedta -S -s mount_t -t unconfined_t | \</p>
			<p class="source-code">  grep -E '(transition path|Step)'</p>
			<p class="source-code">Domain transition path 1:</p>
			<p class="source-code">Step 1: mount_t -&gt; glusterd_t</p>
			<p class="source-code">Step 2: glusterd_t -&gt; sulogin_t</p>
			<p class="source-code">Step 3: sulogin_t -&gt; unconfined_t</p>
			<p class="source-code">Domain transition path 2:</p>
			<p class="source-code">Step 1: mount_t -&gt; glusterd_t</p>
			<p class="source-code">Step 2: glusterd_t -&gt; virtd_lxc_t</p>
			<p class="source-code">Step 3: virtd_lxc_t -&gt; unconfined_t</p>
			<p class="source-code">Domain transition path 3:</p>
			<p class="source-code">Step 1: mount_t -&gt; glusterd_t</p>
			<p class="source-code">Step 2: glusterd_t -&gt; xdm_t</p>
			<p class="source-code">Step 3: xdm_t -&gt; unconfined_t</p>
			<p class="source-code">Domain transition path 4:</p>
			<p class="source-code">Step 1: mount_t -&gt; glusterd_t</p>
			<p class="source-code">Step 2: glusterd_t -&gt; crond_t</p>
			<p class="source-code">Step 3: crond_t -&gt; unconfined_t</p>
			<p class="source-code">Domain transition path 5:</p>
			<p class="source-code">Step 1: mount_t -&gt; glusterd_t</p>
			<p class="source-code">Step 2: glusterd_t -&gt; sshd_t</p>
			<p class="source-code">Step 3: sshd_t -&gt; unconfined_t</p>
			<p class="source-code">Domain transition path 6:</p>
			<p class="source-code">Step 1: mount_t -&gt; glusterd_t</p>
			<p class="source-code">Step 2: glusterd_t -&gt; virtd_t</p>
			<p class="source-code">Step 3: virtd_t -&gt; unconfined_t</p>
			<p class="source-code">6 domain transition path(s) found.</p>
			<p class="calibre3">When <a id="_idIndexMarker887" class="pcalibre calibre6 pcalibre1"/>comparing the transition paths with the ones generated by <strong class="source-inline">sedta</strong>, you will notice that <strong class="source-inline">sedta</strong> often finds shorter domain transitions, which <strong class="source-inline">sepolicy transition</strong> does not. Hence it is not recommended to rely solely on <strong class="source-inline">sepolicy transition</strong> for domain transition analysis.</p>
			<h1 id="_idParaDest-342" class="calibre5"><a id="_idTextAnchor346" class="pcalibre calibre6 pcalibre1"/>Analyzing information flow</h1>
			<p class="calibre3">Another <a id="_idIndexMarker888" class="pcalibre calibre6 pcalibre1"/>analytical investigation that can be carried out on SELinux policies is information flow analysis. Unlike domain transitions, which look at how <a id="_idIndexMarker889" class="pcalibre calibre6 pcalibre1"/>one domain can gain a certain set of permissions through transitions to another domain, <strong class="bold">information flow analysis</strong> looks at how a domain could leak (purposefully or not) information to another domain.</p>
			<p class="calibre3">Information flow analysis is performed by looking at all operations that occur between two types. A source type can be read by a domain, which subsequently can write information <a id="_idIndexMarker890" class="pcalibre calibre6 pcalibre1"/>to another type that can then be accessed by another domain. While this can still be analyzed in a step-wise fashion, it quickly becomes very challenging because we cannot limit ourselves to the read and write operations.</p>
			<p class="calibre3">Information can be leaked through filenames, file descriptors, and more. Information flow analysis must take all these methods into account.</p>
			<h2 id="_idParaDest-343" class="calibre10"><a id="_idTextAnchor347" class="pcalibre calibre6 pcalibre1"/>Using apol for information flow analysis</h2>
			<p class="calibre3">After <a id="_idIndexMarker891" class="pcalibre calibre6 pcalibre1"/>loading an SELinux policy, select <strong class="bold">Information Flow Analysis</strong>. The interface we receive is similar to the domain transition analysis, but now has a few toggles to fine-tune the path analysis specific to information flows:</p>
			<div class="calibre13">
				<div id="_idContainer040" class="img---figure">
					<img src="Images/B16276_13_007.jpg" alt="Figure 13.7 – Analyzing information flow between two domains " class="calibre34"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.7 – Analyzing information flow between two domains</p>
			<p class="calibre3">Unlike <a id="_idIndexMarker892" class="pcalibre calibre6 pcalibre1"/>domain transitions, the number of paths through which information can flow is exponentially bigger. To perform a decent information flow analysis, we need to fine-tune the search criteria:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="bold">Minimum permission weight</strong> option allows users to only look at permissions or actions that have a particular weight. Each action is given a weight in the tool, from a low priority (such as the <strong class="source-inline">lock</strong> operation, which has weight <strong class="source-inline">1</strong>) to a high priority one (such as the <strong class="source-inline">write</strong> operation, which has weight <strong class="source-inline">10</strong>). The purpose of these weights is to define which actions are plausible for information flow and which ones are much harder (but not impossible) to use for deliberate information exchange.</li>
				<li class="calibre9">With <strong class="bold">Excluded Permissions</strong>, we can selectively enable or disable certain permissions from the analysis.</li>
			</ul>
			<p class="calibre3">The other options are similar to those in domain transition analysis.</p>
			<p class="calibre3">The most important area for information flow analysis is the permission map, which we can fine-tune partially while enabling or disabling permissions in the analysis. However, we might not be happy with the weights that the current permission map uses.</p>
			<p class="calibre3">To edit <a id="_idIndexMarker893" class="pcalibre calibre6 pcalibre1"/>the permission map, select <strong class="bold">Permission Map</strong> | <strong class="bold">Edit Permission Map</strong> from the <strong class="source-inline">apol</strong> menu:</p>
			<div class="calibre13">
				<div id="_idContainer041" class="img---figure">
					<img src="Images/B16276_13_008.jpg" alt="Figure 13.8 – Editing the permission map and permission weights " class="calibre35"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.8 – Editing the permission map and permission weights</p>
			<p class="calibre3">Within this editor, we can fine-tune the weights of the permissions to our liking, as well as the <em class="italic">directionality</em> of the action: </p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="source-inline">None</strong> (no information flow)</li>
				<li class="calibre9"><strong class="source-inline">Write</strong> (information flows to the resource)</li>
				<li class="calibre9"><strong class="source-inline">Read</strong> (information is retrieved from the resource)</li>
				<li class="calibre9"><strong class="source-inline">Both</strong> (information can both flow to and from the resource)</li>
			</ul>
			<p class="calibre3">Once we <a id="_idIndexMarker894" class="pcalibre calibre6 pcalibre1"/>are satisfied with the results, we can (and probably should) save the permission map for later reuse (if not, the changes are only applicable to the current session and will be forgotten when <strong class="source-inline">apol</strong> is closed).</p>
			<h2 id="_idParaDest-344" class="calibre10"><a id="_idTextAnchor348" class="pcalibre calibre6 pcalibre1"/>Using seinfoflow for information flow analysis</h2>
			<p class="calibre3">Like the <strong class="source-inline">sedta</strong> application for domain transition analysis, there is also a command-line application <a id="_idIndexMarker895" class="pcalibre calibre6 pcalibre1"/>that offers information flow analysis capabilities similar to <strong class="source-inline">apol</strong>, that is, <strong class="source-inline">seinfoflow</strong>. Every invocation of the <strong class="source-inline">seinfoflow</strong> command requires the permission map to be passed on for its analysis. If you don't have a permission map created and saved yourself, you can use the default one available at <strong class="source-inline">/var/lib/sepolgen/perm_map</strong>.</p>
			<p class="calibre3">Let's analyze the information flow possibilities between the <strong class="source-inline">staff_t</strong> and <strong class="source-inline">guest_t</strong> domains, using the default permission map, and only considering the permissions of weight <strong class="source-inline">10</strong>:</p>
			<p class="source-code">$ seinfoflow -S -m /var/lib/sepolgen/perm_map \</p>
			<p class="source-code">  -s staff_t -t guest_t -w 10</p>
			<p class="calibre3">The more elaborate a permission map is, the more time it takes for the analysis to complete.</p>
			<h2 id="_idParaDest-345" class="calibre10"><a id="_idTextAnchor349" class="pcalibre calibre6 pcalibre1"/>Using sepolicy communicate for simple information flow analysis</h2>
			<p class="calibre3">The <strong class="source-inline">sepolicy</strong> command <a id="_idIndexMarker896" class="pcalibre calibre6 pcalibre1"/>can perform a simple flow analysis using the <strong class="source-inline">communicate</strong> option. Given a source and target domain, <strong class="source-inline">sepolicy</strong> will check through which intermediate types information can flow between the domains:</p>
			<p class="source-code">$ sepolicy communicate -s postgresql_t -t staff_t</p>
			<p class="source-code">krb5_host_rcache_t</p>
			<p class="source-code">cluster_conf_t</p>
			<p class="source-code">security_t</p>
			<p class="source-code">postgresql_t</p>
			<p class="source-code">postgresql_tmp_t</p>
			<p class="source-code">hugetlbfs_t</p>
			<p class="calibre3">The <a id="_idIndexMarker897" class="pcalibre calibre6 pcalibre1"/>preceding flow analysis is basically checking what types can be written to by the source domain, and read by the target domain.</p>
			<h1 id="_idParaDest-346" class="calibre5"><a id="_idTextAnchor350" class="pcalibre calibre6 pcalibre1"/>Comparing policies</h1>
			<p class="calibre3">Until now, we've analyzed a single policy set, finding the domain transitions and information flow paths. The <a id="_idIndexMarker898" class="pcalibre calibre6 pcalibre1"/>commands and applications we've used all focus on this single-policy analysis. Another important analysis is to compare two policies. Policy developers can use this to compare a new policy with an old one, or to compare two system policies to see what additional rules have been added by the administrator.</p>
			<h2 id="_idParaDest-347" class="calibre10"><a id="_idTextAnchor351" class="pcalibre calibre6 pcalibre1"/>Using sediff to compare policies</h2>
			<p class="calibre3">The <strong class="source-inline">sediff</strong> tool looks at the differences between two policy files and reports those to the user. It is <a id="_idIndexMarker899" class="pcalibre calibre6 pcalibre1"/>often not sensible to use this against completely different policies, but is powerful for finding slight differences between policies, which can assist in troubleshooting issues across different systems.</p>
			<p class="calibre3">A common use case for <strong class="source-inline">sediff</strong> is to validate that a source-built policy file is the same as the distribution-provided binary policy file. Administrators can then be certain that the source code they've used to build a policy file is the same as that used by the distribution, even when the binary files themselves (the <strong class="source-inline">policy.##</strong> file) have different checksums:</p>
			<p class="source-code">$ sediff policy.31 /sys/fs/selinux/policy</p>
			<p class="source-code">Policy Properties (0 Modified)</p>
			<p class="source-code">Classes (1 Added, 0 Removed, 4 Modified)</p>
			<p class="source-code">   Added Classes: 1</p>
			<p class="source-code">      + xdp_socket</p>
			<p class="source-code">   Modified Classes: 4</p>
			<p class="source-code">      * capability2 (1 Removed permissions)</p>
			<p class="source-code">          - compromise_kernel</p>
			<p class="source-code">      * process (1 Added permissions, 1 Removed permissions)</p>
			<p class="source-code">          + getrlimit</p>
			<p class="source-code">...</p>
			<p class="calibre3">It is <a id="_idIndexMarker900" class="pcalibre calibre6 pcalibre1"/>possible to direct <strong class="source-inline">sediff</strong> to only show differences for a specified area or part of the SELinux policy (such as the available types, roles, booleans, or type enforcement rules).</p>
			<h1 id="_idParaDest-348" class="calibre5"><a id="_idTextAnchor352" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
			<p class="calibre3">SELinux has quite a few analysis tools that we can use to analyze policies. We've seen how to use <strong class="source-inline">sesearch</strong> to do in-depth assessments of the current policy, but noticed that it fails to validate the more dynamic analysis requirements.</p>
			<p class="calibre3">With <strong class="source-inline">apol</strong>, we have seen a graphical application that is able to do more dynamic analysis, including the domain transitions (examining which domains can be reached from a current point) and information flow analysis (investigating how information can flow from one domain to another). From this experience, we've learned that such analysis is intensive and requires lots of interpretation to be done correctly.</p>
			<p class="calibre3">Next to <strong class="source-inline">apol</strong>, we also learned that command-line utilities exist with similar capabilities: <strong class="source-inline">sedta</strong> for domain transition analysis, <strong class="source-inline">seinfoflow</strong> for information flow analysis, and <strong class="source-inline">sepolicy</strong>, which has a few out-of-the-box functionalities, but not as extensive or flexible as the other options we looked at.</p>
			<p class="calibre3">In the end, we learned how to compare policies using <strong class="source-inline">sediff</strong>. This is useful for when new policies are being developed, which is something we'll do in the remaining chapters. We first start with aligning and extending existing policies for new applications in the next chapter, and move on to full application policy development in the last two.</p>
			<h1 id="_idParaDest-349" class="calibre5"><a id="_idTextAnchor353" class="pcalibre calibre6 pcalibre1"/>Questions</h1>
			<ol class="calibre18">
				<li class="calibre9">What is the difference between <strong class="source-inline">seinfo</strong> and <strong class="source-inline">sesearch</strong>?</li>
				<li class="calibre9">How do you check whether you can reach a domain?</li>
				<li class="calibre9">Why does analyzing information flows take so long?</li>
				<li class="calibre9">Can we generate a delta between policies and load it?</li>
			</ol>
		</div>
	</div></body></html>