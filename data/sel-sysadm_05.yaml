- en: '*Chapter 4*: Using File Contexts and Process Domains'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：使用文件上下文和进程域'
- en: SELinux-enabled systems are strongly dependent on the notion of contexts (on
    resources) and domains (on processes). The access controls that SELinux enforces
    use these contexts to identify the resources, and define the enforcement rules
    within the policy. Because of its inherent reliance on these contexts, this chapter
    will go into detail on file contexts, context definitions, and process domains.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 SELinux 的系统强烈依赖于上下文（资源上的）和域（进程上的）的概念。SELinux 强制实施的访问控制使用这些上下文来识别资源，并在策略中定义强制规则。由于其固有的对这些上下文的依赖，本章将详细讨论文件上下文、上下文定义和进程域。
- en: We will work with the file contexts and learn where they are stored so that
    you can easily adjust your system to work optimally with SELinux. We assign contexts
    to resources both temporarily (for testing purposes) and permanently, and learn
    how these contexts are used to automatically deduce the process domain. Once we
    know how to obtain process domain information, we will query the SELinux policy
    to learn about the current access controls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理文件上下文并了解它们存储的位置，这样你就可以轻松调整系统，以便与 SELinux 最佳配合使用。我们为资源分配上下文，既可以是临时的（用于测试），也可以是永久的，并学习如何利用这些上下文来自动推断进程域。一旦我们知道如何获取进程域信息，我们将查询
    SELinux 策略，以了解当前的访问控制。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Introduction to SELinux file contexts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux 文件上下文简介
- en: Keeping or ignoring contexts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留或忽略上下文
- en: SELinux file context expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux 文件上下文表达式
- en: Modifying file contexts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改文件上下文
- en: The context of a process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程的上下文
- en: Limiting the scope of transitions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制转换的范围
- en: Types, permissions, and constraints
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型、权限和约束
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3m3JzkP](https://bit.ly/3m3JzkP)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请观看以下视频，查看代码的实际应用：[https://bit.ly/3m3JzkP](https://bit.ly/3m3JzkP)
- en: Introduction to SELinux file contexts
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SELinux 文件上下文简介
- en: SELinux file contexts are the most important configuration that a system administrator
    will have to work with when working with SELinux on the system. Contexts for files
    are generally identified through a label that is assigned to the file. Mislabeled
    files are a constant source of headaches for sysadmins, and most common SELinux
    issues are resolved by correcting the SELinux context.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 文件上下文是系统管理员在系统中使用 SELinux 时需要处理的最重要的配置。文件的上下文通常通过分配给文件的标签来识别。标签错误的文件是系统管理员的常见头痛来源，大多数常见的
    SELinux 问题都通过纠正 SELinux 上下文来解决。
- en: 'Knowing where and how SELinux contexts are used is key to understanding and
    resolving SELinux related issues. The following diagram shows how contexts are
    applied on regular Linux resources, and how the LSM subsystem uses these contexts
    for decision making:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 SELinux 上下文的使用方式和位置是理解和解决 SELinux 相关问题的关键。下图展示了上下文如何应用于常规 Linux 资源，以及 LSM
    子系统如何使用这些上下文来做出决策：
- en: '![Figure 4.1 – Distinction between contexts and regular Linux info ](img/B16276_04_001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 上下文与常规 Linux 信息的区别](img/B16276_04_001.jpg)'
- en: Figure 4.1 – Distinction between contexts and regular Linux info
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 上下文与常规 Linux 信息的区别
- en: 'Let''s consider a web-based deployment as an example: DokuWiki. This is a popular
    PHP wiki that uses files rather than a database as its backend system, and is
    easy to install and manage. As a web hosting platform, we will use nginx.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以基于 Web 的部署为例：DokuWiki。DokuWiki 是一个流行的 PHP 维基，它使用文件而不是数据库作为后端系统，且易于安装和管理。作为
    Web 托管平台，我们将使用 nginx。
- en: Getting context information
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取上下文信息
- en: 'Let''s assume that the DokuWiki application will be hosted at `/srv/web/localhost/htdocs/dokuwiki`
    and that it will store its wiki pages (user content) in the `data/` subdirectory.
    We start by downloading the latest DokuWiki tarball from the project site, [http://download.dokuwiki.org](http://download.dokuwiki.org),
    and extract it to this location:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 DokuWiki 应用将托管在 `/srv/web/localhost/htdocs/dokuwiki` 位置，并且它会将其维基页面（用户内容）存储在
    `data/` 子目录中。我们从项目站点下载最新的 DokuWiki tarball，[http://download.dokuwiki.org](http://download.dokuwiki.org)，并将其解压到此位置：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While distributions might have prepackaged DokuWiki installations available,
    we will use the manual installation approach to show the various file context-related
    actions in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些发行版可能提供预打包的 DokuWiki 安装，但我们将使用手动安装的方法来展示本章中的各种文件上下文相关操作。
- en: The contexts of files can easily be acquired using the `-Z` option of the `ls`
    command. Most utilities that can provide feedback on contexts will try to do so
    using the `-Z` option, as we saw with the `id` utility in [*Chapter 1*](B16276_01_Final_VK.xhtml#_idTextAnchor018),
    *Fundamental SELinux Concepts*, and [*Chapter 3*](B16276_03_Final_VK.xhtml#_idTextAnchor071),
    *Managing User Logins*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`ls`命令的`-Z`选项轻松获取文件的上下文。大多数能够提供上下文反馈的工具都会尝试使用`-Z`选项，正如我们在[*第1章*](B16276_01_Final_VK.xhtml#_idTextAnchor018)《基础SELinux概念》和[*第3章*](B16276_03_Final_VK.xhtml#_idTextAnchor071)《管理用户登录》中所看到的`id`工具所示。
- en: 'Let''s look at the current context of the `dokuwiki` directory itself:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`dokuwiki`目录本身的当前上下文：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The context displayed here is `var_t`. In the *Keeping or ignoring contexts*
    section, we will change this to the correct context (as `var_t` is too generic
    and not meant for hosting web content).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的上下文是`var_t`。在*保留或忽略上下文*部分中，我们将把这个上下文改为正确的上下文（因为`var_t`过于通用，不适合托管网页内容）。
- en: File and directory contexts are stored in the filesystem as extended attributes
    when the filesystem supports this. An **extended attribute** (often abbreviated
    to **xattr**) is a key/value combination associated with a resource's inode (an
    information block that represents a file, directory, or symbolic link on a filesystem).
    Each resource can have multiple extended attributes, but only one value per unique
    key. When we talk about assigning a **label** to a file or directory (or relabeling
    a file), then we imply setting or updating this extended attribute, as it is the
    label that SELinux will use to obtain the SELinux context for the file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和目录上下文在文件系统中作为扩展属性存储，当文件系统支持此功能时。**扩展属性**（通常缩写为**xattr**）是与资源的inode（代表文件、目录或符号链接的文件系统信息块）相关联的键/值组合。每个资源可以有多个扩展属性，但每个唯一的键只有一个值。当我们谈论为文件或目录分配**标签**（或重新标记文件）时，我们指的是设置或更新这个扩展属性，因为它是SELinux用于获取文件SELinux上下文的标签。
- en: Important note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Filesystems that do not support extended attributes can still be used on SELinux-enabled
    systems. However, the entire filesystem (including all its files and directories)
    will then be shown with a single context, and differentiation across resources
    on the filesystem is not possible. We explain how to define file contexts on these
    filesystems in the *Using mount options to set SELinux contexts* subsection in
    this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持扩展属性的文件系统仍然可以在启用了SELinux的系统上使用。然而，整个文件系统（包括所有文件和目录）将显示为单一上下文，无法在文件系统上区分资源。我们将在本章的*使用挂载选项设置SELinux上下文*小节中解释如何在这些文件系统上定义文件上下文。
- en: 'By convention, extended attributes on Linux use the following syntax:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据约定，Linux上的扩展属性使用以下语法：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The namespace of an extended attribute allows for additional access controls
    or features. Of the currently supported extended attribute namespaces (`security`,
    `system`, `trusted`, and `user`), the `security` namespace enforces specific restrictions
    on manipulating the attribute: if no security module is loaded (for instance,
    SELinux is not enabled), then only processes with the `CAP_SYS_ADMIN` capability
    (basically root or similarly privileged processes) can modify this parameter.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展属性的命名空间允许进行额外的访问控制或特性。在当前支持的扩展属性命名空间（`security`、`system`、`trusted`和`user`）中，`security`命名空间对操作该属性施加了特定的限制：如果没有加载安全模块（例如，未启用SELinux），则只有具有`CAP_SYS_ADMIN`能力的进程（基本上是root或类似权限的进程）才能修改此参数。
- en: 'We can query the existing extended attributes using the `getfattr` application,
    as shown in the following example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`getfattr`应用程序查询现有的扩展属性，如下例所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, the `security.selinux` extended attribute hosts the SELinux context.
    This ensures that non-administrative users cannot alter the SELinux context of
    a file when SELinux is disabled and that the SELinux policy controls who can manipulate
    contexts when SELinux is enabled.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`security.selinux`扩展属性存储着SELinux上下文。这确保了当SELinux被禁用时，非管理员用户无法更改文件的SELinux上下文，并且当SELinux启用时，SELinux策略控制谁可以操作上下文。
- en: 'The `stat` application can also be used to show SELinux contexts:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`stat`应用程序也可以用来显示SELinux上下文：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Getting context information from a file or directory should be as common to
    an administrator as getting regular access control information (the read (`r`),
    write (`w`), and execute (`x`) flags).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件或目录获取上下文信息应该和获取常规访问控制信息（读取（`r`）、写入（`w`）和执行（`x`）标志）一样常见。
- en: Interpreting SELinux context types
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释SELinux上下文类型
- en: After using SELinux for a while, the motive behind using file labels to assign
    an SELinux context to the file becomes somewhat clearer. SELinux contexts are
    named after their purpose, allowing administrators to more easily see whether
    a context is correctly assigned.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SELinux 一段时间后，使用文件标签为文件分配 SELinux 上下文的动机变得更加清晰。SELinux 上下文根据其目的命名，使管理员更容易看出上下文是否被正确分配。
- en: Consider the context of a user file in its home directory (`user_home_t`), a
    directory in `/tmp` for a Java application (`java_tmp_t`), or a socket of `rpcbind`
    (`rpcbind_var_run_t`). All these files or directories have considerably different
    purposes on the filesystem, and this reflects itself in the assigned contexts.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个用户文件在其主目录中的上下文（`user_home_t`）、一个位于 `/tmp` 目录中的 Java 应用程序目录（`java_tmp_t`），或
    `rpcbind` 的一个套接字（`rpcbind_var_run_t`）。这些文件或目录在文件系统中具有截然不同的用途，这一点体现在它们所分配的上下文中。
- en: Policy writers will always try to name the context consistently, making it easier
    for us to understand the purpose of the file, but also to make the policy almost
    self-explanatory so that administrators can understand the purpose of the policy
    without additional documentation needs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 策略编写者总是尽力一致地命名上下文，使我们更容易理解文件的目的，同时也使得策略几乎是自解释的，管理员可以在不需要额外文档的情况下理解策略的目的。
- en: For the regular filesystem, for instance, files are labeled with a context resembling
    their main location as they have similar security properties. For example, we
    find binaries in the `/bin` folder (and `/usr/bin`) to be associated with the
    `bin_t` type, boot files in `/boot` associated with `boot_t`, and generic system
    resources in `/usr` associated with `usr_t`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规文件系统，例如，文件根据其主要位置进行标签，以便它们具有相似的安全属性。例如，我们发现 `/bin` 文件夹（以及 `/usr/bin`）中的二进制文件与
    `bin_t` 类型相关联，`/boot` 中的启动文件与 `boot_t` 相关联，`/usr` 中的通用系统资源与 `usr_t` 相关联。
- en: 'We can also find more application-specific contexts. For instance, for the
    PostgreSQL database server, we have the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以找到更多应用特定的上下文。例如，对于 PostgreSQL 数据库服务器，我们有以下上下文：
- en: The `postgresql_t` context is meant for the application itself (process type
    or domain).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgresql_t` 上下文是为应用程序本身（进程类型或域）设计的。'
- en: The `postgresql_port_t` context is meant for the TCP port on which the PostgreSQL
    daemon listens.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgresql_port_t` 上下文是为 PostgreSQL 守护进程监听的 TCP 端口设计的。'
- en: The `postgresql_server_packet_t` and `postgresql_client_packet_t` contexts are
    types associated with network packets received (in case of the `postgresql_server_packet_t`
    type) or sent to the PostgreSQL port.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgresql_server_packet_t` 和 `postgresql_client_packet_t` 上下文是与接收的网络数据包（对于
    `postgresql_server_packet_t` 类型）或发送到 PostgreSQL 端口的数据包相关的类型。'
- en: The `postgresql_exec_t` type is assigned to the `postgres` binary.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgresql_exec_t` 类型被分配给 `postgres` 二进制文件。'
- en: The various `postgresql_*_t` types for specific filesystem locations related
    to the daemon, such as `postgresql_var_run_t` (to apply to resources in `/var/run`),
    `postgresql_etc_t` (to apply to resources in `/etc`), `postgresql_log_t` (to apply
    to resources in `/var/log`), and `postgresql_tmp_t` (to apply to resources in
    `/tmp`).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种 `postgresql_*_t` 类型用于与守护进程相关的特定文件系统位置，例如 `postgresql_var_run_t`（适用于 `/var/run`
    中的资源）、`postgresql_etc_t`（适用于 `/etc` 中的资源）、`postgresql_log_t`（适用于 `/var/log` 中的资源）和
    `postgresql_tmp_t`（适用于 `/tmp` 中的资源）。
- en: The `mysqld_db_t` type for the database files themselves.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库文件本身的 `mysqld_db_t` 类型。
- en: Based on the context of a file or resource, administrators can easily detect
    anomalies in the system setup. An example of an anomaly is when we move a file
    from the user's home directory to a web server location. When this occurs, the
    file retains the `user_home_t` context as extended attributes are moved with it.
    As the web server process isn't allowed to access `user_home_t` by default, it
    will not be able to serve this file to its users.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件或资源的上下文，管理员可以轻松地检测系统设置中的异常。异常的一个例子是当我们将文件从用户的主目录移动到 Web 服务器位置时。当这种情况发生时，文件保留了
    `user_home_t` 上下文，因为扩展属性随着文件一起移动。由于 Web 服务器进程默认不允许访问 `user_home_t`，它将无法向用户提供该文件。
- en: Let's see how to properly set contexts during such copy or move operations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在这种复制或移动操作中正确设置上下文。
- en: Keeping or ignoring contexts
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持或忽略上下文
- en: Now that we are aware that file contexts are stored as extended attributes,
    how do we ensure that files receive the correct label when they are written or
    modified? To set an SELinux context on a filesystem resource, a few guidelines
    exist, ranging from inheritance rules to explicit commands.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道文件上下文是作为扩展属性存储的，如何确保文件在写入或修改时获得正确的标签呢？为了在文件系统资源上设置SELinux上下文，存在一些准则，从继承规则到显式命令。
- en: Inheriting the default contexts
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承默认上下文
- en: By default, the SELinux security subsystem uses context inheritance to identify
    which context should be assigned to a file (or directory, socket, and so on) when
    it is created. A file created in a directory with a `var_t` context will be assigned
    the `var_t` context as well. This means that the file inherits the context from
    the parent directory and not from the context of the executing process.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SELinux安全子系统使用上下文继承来确定在创建文件（或目录、套接字等）时应该分配哪个上下文。在具有`var_t`上下文的目录中创建的文件，也将被分配`var_t`上下文。这意味着文件从父目录继承上下文，而不是从执行进程的上下文继承。
- en: 'There are a few exceptions to this though:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一些例外：
- en: SELinux-aware applications can force the context of a file to be different (assuming
    the SELinux policy allows it, of course). As this is within the software code
    itself, this behavior cannot be generally configured.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持SELinux的应用程序可以强制文件的上下文不同（当然，前提是SELinux策略允许这样做）。由于这是在软件代码内部，这种行为无法进行通用配置。
- en: An application called `restorecond` can be used that enforces contexts on various
    paths/files based on SELinux's context rules. We will cover these rules and the
    `restorecond` application in the *SELinux file context expressions* and *Modifying
    file contexts* sections, respectively.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`restorecond`的应用程序可以根据SELinux的上下文规则，在不同的路径/文件上强制执行上下文。我们将在*SELinux文件上下文表达式*和*修改文件上下文*部分分别介绍这些规则和`restorecond`应用程序。
- en: The SELinux policy allows for transition rules that consider the context of
    the process creating new files or directories, as well as the name of the file
    the process is creating.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux策略允许考虑创建新文件或目录的进程的上下文以及进程正在创建的文件名的过渡规则。
- en: It is these transition rules we will cover next.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将介绍这些过渡规则。
- en: Querying transition rules
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询过渡规则
- en: 'Type transition rules are policy rules that force the use of a different type
    upon certain conditions. For file contexts, such a type transition rule can be
    as follows: if a process running in the `httpd_t` domain creates a file in a directory
    labeled with the `var_log_t` SELinux type, then the type identifier of the file
    becomes `httpd_log_t`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 类型过渡规则是策略规则，在某些条件下强制使用不同的类型。对于文件上下文，类似的类型过渡规则可以是这样的：如果在`httpd_t`域中运行的进程在标记为`var_log_t`的目录中创建一个文件，那么该文件的类型标识符将变为`httpd_log_t`。
- en: Basically, this rule assigns the `httpd_log_t` web server log context to any
    file placed in a log directory by web servers, rather than the default `var_log_t`,
    which would be the case when standard inheritance was used.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这条规则将`httpd_log_t`网页服务器日志上下文分配给任何被网页服务器放入日志目录中的文件，而不是使用标准继承时会出现的默认`var_log_t`上下文。
- en: 'We can query these type transition rules using `sesearch`. The `sesearch` application
    is one of the most important tools available to query the current SELinux policy.
    For the previous example, we need the (source) domain and the (target) context
    of the directory: `httpd_t` and `var_log_t`. In the following example, we use
    `sesearch` to find the type transition declaration related to the `httpd_t` domain
    toward the `var_log_t` context:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`sesearch`查询这些类型过渡规则。`sesearch`应用程序是查询当前SELinux策略的最重要工具之一。对于前面的例子，我们需要目录的（源）域和（目标）上下文：`httpd_t`和`var_log_t`。在以下示例中，我们使用`sesearch`来查找与`httpd_t`域过渡到`var_log_t`上下文的类型过渡声明：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `type_transition` line is an SELinux policy rule, which maps perfectly
    to the description. Let''s look at another set of type transition rules for the
    `tmp_t` type (assigned to the directory used for temporary files, such as `/tmp`
    and `/var/tmp`):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`type_transition`行是一个SELinux策略规则，完美地映射到描述中。我们来看一下针对`tmp_t`类型（分配给用于临时文件的目录，如`/tmp`和`/var/tmp`）的另一组类型过渡规则：'
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The policy tells us that, if a file, directory, symbolic link, or socket is
    created in a directory labeled `tmp_t`, then this newly created resource gets
    the `httpd_tmp_t` context assigned (and thus not the default, inherited `tmp_t`
    one). Alongside these rules, it also contains two named file transitions, which
    are more flexible transition rules.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 策略告诉我们，如果在标记为`tmp_t`的目录中创建文件、目录、符号链接或套接字，则该新创建的资源将分配`httpd_tmp_t`上下文（因此不是默认的继承`tmp_t`上下文）。除了这些规则外，它还包含了两个命名的文件转换规则，这些规则是更灵活的转换规则。
- en: With `HTTP_23` or `HTTP_48` is created in a directory labeled `tmp_t`, then
    it does not get the `httpd_tmp_t` context assigned (as would be implied by the
    regular type transition rules), but the `krb5_host_rcache_t` type (used for Kerberos
    implementations) instead.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在标记为`tmp_t`的目录中创建`HTTP_23`或`HTTP_48`，则不会分配`httpd_tmp_t`上下文（根据常规类型转换规则本应分配），而是分配`krb5_host_rcache_t`类型（用于Kerberos实现）。
- en: Type transitions not only give us insight into what labels (and thus also SELinux
    contexts) are going to be assigned, but also give us some clues as to which types
    are related to a particular domain. In the web server example, we found out by
    querying the policy that its log files are most likely labeled `httpd_log_t`,
    and its temporary files `httpd_tmp_t`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换不仅使我们了解哪些标签（因此也包括SELinux上下文）将被分配，还为我们提供了哪些类型与特定域相关的线索。在web服务器的示例中，我们通过查询策略发现，其日志文件很可能被标记为`httpd_log_t`，而临时文件则标记为`httpd_tmp_t`。
- en: Copying and moving files
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制和移动文件
- en: 'File contexts can also be transferred together with the file itself during
    copy or move operations. By default, Linux will do the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 文件上下文也可以在复制或移动操作过程中与文件一起传输。默认情况下，Linux会执行以下操作：
- en: Retain the file context in case of a move (`mv`) operation on the same filesystem
    (as this operation does not touch extended attributes, but merely adjusts the
    metadata of the file).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一文件系统上的移动（`mv`）操作中保留文件上下文（因为此操作不会触及扩展属性，仅调整文件的元数据）。
- en: Ignore the current file context in case of a move operation across a filesystem
    boundary, as this creates a new file, including content and extended attributes.
    Instead, it uses the inheritance (or file transition rules) to define the target
    context.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在跨文件系统边界的移动操作中忽略当前文件上下文，因为这会创建一个新文件，包括内容和扩展属性。相反，使用继承（或文件转换规则）来定义目标上下文。
- en: Ignore the file context in case of a copy (`cp`) operation, instead using the
    inheritance (or file transition rules) to define the target context.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行复制（`cp`）操作时忽略文件上下文，而是使用继承（或文件转换规则）来定义目标上下文。
- en: Luckily, this is just default behavior (based on the extended attribute support
    of these utilities) that can be manipulated freely.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这只是默认行为（基于这些实用程序的扩展属性支持），可以自由操作。
- en: 'We can use the `-Z` option to tell `mv` that the context of the file should
    be set to the default type associated with the target location. For instance,
    in the next example, two files are moved from a user''s home directory to the
    `/srv` directory. The first example will retain its file context (`user_home_t`
    or `admin_home_t`), while the second one will receive the type associated with
    user files placed in `/srv` (`var_t`):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-Z`选项告诉`mv`命令将文件的上下文设置为与目标位置相关联的默认类型。例如，在下一个示例中，两个文件从用户的主目录移动到`/srv`目录。第一个示例将保留其文件上下文（`user_home_t`或`admin_home_t`），而第二个示例将获得与放置在`/srv`中的用户文件相关的类型（`var_t`）：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, we can tell the `cp` command through the `--preserve=context` option
    to preserve the SELinux context while copying files. Using the same example, we
    now get the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以通过`--preserve=context`选项告诉`cp`命令在复制文件时保留SELinux上下文。使用相同的示例，现在我们得到以下结果：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Most of the utilities provided through the `coreutils` package support the
    `-Z` option: `mkdir` (to create a directory), `mknod` (to create a device file),
    `mkfifo` (to create a named pipe), and so on.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`coreutils`包提供的大多数实用程序支持`-Z`选项：`mkdir`（创建目录）、`mknod`（创建设备文件）、`mkfifo`（创建命名管道）等。'
- en: Important note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: If the `mv` command returns `failed to set the security context` when using
    the `-Z` option, then it is very likely that the location either does not have
    a valid context associated with it, or that the filesystem does not support SELinux
    labels. The former is for instances applicable when moving files to `/tmp` as
    the CentOS SELinux policy does not have any default context set for files and
    directories inside `/tmp`. Newly created resources always need to have their own
    affiliated labels applied (such as `user_tmp_t`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在使用`-Z`选项时，`mv`命令返回`failed to set the security context`，那么很可能该位置要么没有与之关联的有效上下文，要么文件系统不支持SELinux标签。前者适用于将文件移动到`/tmp`的情况，因为CentOS
    SELinux策略未为`/tmp`中的文件和目录设置默认上下文。新创建的资源总是需要应用其关联的标签（例如`user_tmp_t`）。
- en: 'Even more so, many of these utilities allow the user to explicitly provide
    a context through the `--context` option. For instance, to create a directory,
    `/srv/foo`, with the context `user_home_t`, using `mkdir` by default would not
    work, as the target context would be set to `var_t`. With the `--context` option,
    we can tell the utility to set a specific context:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，许多这些工具允许用户通过`--context`选项显式地提供上下文。例如，要创建一个上下文为`user_home_t`的目录`/srv/foo`，使用`mkdir`默认情况下是无法实现的，因为目标上下文会被设置为`var_t`。通过`--context`选项，我们可以告诉工具设置特定的上下文：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For other utilities, it is best to consult the manual page and see how the utility
    deals with extended attributes. For instance, the `rsync` command can preserve
    the extended attributes by using the `-X` or `--xattrs` option.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他工具，最好查阅手册页面，了解该工具如何处理扩展属性。例如，`rsync`命令可以通过使用`-X`或`--xattrs`选项来保留扩展属性。
- en: Temporarily changing file contexts
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时更改文件上下文
- en: 'We can use the `chcon` tool to update the context of the file (or files) directly.
    In our previous example, we noticed the `var_t` label on the DokuWiki files. This
    is a generic type for variable data and is not the right context for web content.
    We can use `chcon` to put the `httpd_sys_content_t` label on these files, which
    would allow web servers to have read access on these resources:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`chcon`工具直接更新文件（或文件们）的上下文。在我们之前的示例中，我们注意到DokuWiki文件上的`var_t`标签。这个标签是针对变量数据的通用类型，而不是用于网页内容的正确上下文。我们可以使用`chcon`将`httpd_sys_content_t`标签应用到这些文件上，这样就允许网页服务器对这些资源具有读取权限：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another feature that `chcon` offers is to tell it to label a file or location
    with the same context as a different file. In the next example, we use `chcon`
    to label `/srv/web` and its resources with the same context as used for the `/var/www`
    directory:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`chcon`提供的另一个功能是告诉它用与另一个文件相同的上下文来标记文件或位置。在下一个示例中，我们使用`chcon`将`/srv/web`及其资源标记为与`/var/www`目录相同的上下文：'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we change the context of a file through `chcon` and set it to a context
    different from the one in the context list, then the context might be reverted
    later: package managers might reset the file contexts back to their intended value,
    or the system administrator might trigger a fill filesystem relabeling operation.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过`chcon`更改文件的上下文并将其设置为与上下文列表中不同的上下文，那么该上下文可能会被恢复：包管理器可能会将文件上下文重置回其预定值，或者系统管理员可能会触发一次完整的文件系统标签重命名操作。
- en: 'Until now, we''ve only focused on the type part of a context. Contexts, however,
    also include a role part and an SELinux user part. If UBAC is not enabled, then
    the SELinux user has no influence on any decisions, and resetting it has little
    value. If UBAC is enabled, though, it might be necessary to reset the SELinux
    user values on files. Utilities such as `chcon` can set the SELinux user as well:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只关注了上下文中的类型部分。然而，上下文还包括角色部分和SELinux用户部分。如果未启用UBAC，则SELinux用户对任何决策没有影响，重置它几乎没有价值。然而，如果启用了UBAC，则可能需要重置文件上的SELinux用户值。像`chcon`这样的工具也可以设置SELinux用户：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The role for a file is usually `object_r` as roles currently only make sense
    for users (processes).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的角色通常是`object_r`，因为角色当前只对用户（进程）有意义。
- en: To be able to change contexts, we do need the proper SELinux privileges, named
    `relabelfrom` and `relabelto`. These rights are granted on domains to indicate
    whether the domain can change a label from one type to another. If we find denials
    in the audit log related to these permissions, then this means that the policy
    prohibits the domain from changing the contexts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够更改上下文，我们确实需要适当的SELinux权限，称为`relabelfrom`和`relabelto`。这些权限授予域，以指示该域是否可以将标签从一种类型更改为另一种类型。如果我们在审核日志中找到与这些权限相关的拒绝信息，那么这意味着策略禁止该域更改上下文。
- en: Placing categories on files and directories
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将类别放置在文件和目录上
- en: 'We focused primarily on changing types and briefly touched SELinux users, but
    another important part is to support categories and sensitivity levels. With `chcon`,
    we can add sensitivity levels and categories as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要关注类型的更改，并简要讨论了 SELinux 用户，但另一个重要部分是支持类别和敏感度级别。使用`chcon`，我们可以如下添加敏感度级别和类别：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Another tool that can be used to assign categories is the `chcat` tool. With
    `chcat`, we can assign additional categories rather than having to reiterate them,
    as would be the case with `chcon`, and even enjoy the human-readable category
    levels provided by the `setrans.conf` file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以用来分配类别的工具是`chcat`工具。通过`chcat`，我们可以分配额外的类别，而无需像`chcon`那样反复设置它们，甚至可以享受由`setrans.conf`文件提供的可读性强的类别级别：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To remove a category, just use the minus sign:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除类别，只需使用减号：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To remove all categories, use the `-d` option:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除所有类别，请使用`-d`选项：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Users and administrators should keep in mind that applications generally do
    not set categories themselves, so they need to be added ad hoc.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和管理员应当记住，应用程序通常不会自行设置类别，因此需要根据需要手动添加。
- en: Using multilevel security on files
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在文件上使用多级安全性
- en: 'When the system uses an MLS policy, the `chcon` tool needs to be used. The
    syntax is the same as with categories. For instance, to set the sensitivity `s1`
    and category set `c2` and `c4` to `c10` on all files of a user''s home directory,
    you''d do the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统使用 MLS 策略时，需要使用`chcon`工具。语法与类别相同。例如，要在用户主目录的所有文件上设置敏感度` s1`和类别集` c2`和` c4`到`
    c10`，你可以执行以下操作：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember that both the context of the user executing `chcon` and the context
    of the user who will use the data must be able to deal with the mentioned sensitivity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，执行`chcon`的用户的上下文和将使用数据的用户的上下文必须能够处理提到的敏感度。
- en: Backing up and restoring extended attributes
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份和恢复扩展属性
- en: 'As with the regular file operation tools (such as `mv` and `cp`), backup software,
    too, needs to consider SELinux contexts. Two important requirements exist for
    a backup tool when working with SELinux-enabled systems:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规的文件操作工具（如`mv`和`cp`）一样，备份软件在处理 SELinux 启用的系统时，也需要考虑 SELinux 上下文。备份工具在与 SELinux
    启用的系统一起使用时有两个重要的要求：
- en: The backup tool must run in an SELinux context capable of reading all files
    in scope of the backup, and, of course, of restoring those files as well. If no
    specific SELinux policy for the backup tool exists, then it might need to run
    in an unconfined or highly privileged domain to succeed.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份工具必须在能够读取备份范围内所有文件的 SELinux 上下文中运行，当然，还需要能够恢复这些文件。如果备份工具没有特定的 SELinux 策略，那么它可能需要在未受限制或具有高度权限的域中运行才能成功。
- en: The backup tool must be able to back up and restore extended attributes.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份工具必须能够备份和恢复扩展属性。
- en: 'A popular tool for taking backups (or archives) is the `tar` application, which
    supports SELinux contexts as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的备份（或归档）工具是`tar`应用程序，它支持以下 SELinux 上下文：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When creating a tar archive, add `--selinux` to include SELinux contexts (both
    during the creation of the archive and when extracting files from the archive).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 tar 归档时，添加`--selinux`以包括 SELinux 上下文（在创建归档和提取文件时都会包括）。
- en: Using mount options to set SELinux contexts
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用挂载选项设置 SELinux 上下文
- en: Not all filesystems support extended attributes. When we use a filesystem without
    extended attribute support, then the SELinux context of a file is either based
    on the filesystem type itself (each filesystem has its own associated context)
    or is passed on to the system using a `mount` option.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有文件系统都支持扩展属性。当我们使用不支持扩展属性的文件系统时，文件的 SELinux 上下文要么基于文件系统类型本身（每个文件系统都有自己关联的上下文），要么通过`mount`选项传递给系统。
- en: 'The most commonly used `mount` option in these situations is the `context=`
    option. When set, it will use the mentioned context as the context for all the
    resources in the filesystem. For instance, to mount an external USB drive that
    hosts a FAT filesystem while ensuring that end users can write to it, we could
    mount it with the `user_home_t` context:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，最常用的`mount`选项是`context=`选项。当设置时，它将使用指定的上下文作为文件系统中所有资源的上下文。例如，要挂载一个包含
    FAT 文件系统的外部 USB 驱动器，并确保最终用户可以写入该驱动器，我们可以使用`user_home_t`上下文挂载它：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the filesystem supports extended attributes but doesn''t have all files
    labeled yet, then we can use the `defcontext=` option to tell Linux that, if no
    SELinux context is available, then the default context provided should be used:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件系统支持扩展属性，但尚未对所有文件进行标记，则可以使用 `defcontext=` 选项告诉 Linux，如果没有 SELinux 上下文可用，则应使用提供的默认上下文：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Another mount option is `fscontext=`. This assigns a context on the filesystem
    type rather than the context of the files on the filesystem. For instance, a CD/DVD
    filesystem can be ISO 9660, Joliet, or UDF. SELinux uses this type definition
    on a filesystem to map permissions such as mount operations and file creation.
    With the `fscontext=` option, the filesystem type can be set differently from
    what the default filesystem type would be.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个挂载选项是 `fscontext=`。它为文件系统类型分配上下文，而不是为文件系统中的文件分配上下文。例如，CD/DVD 文件系统可以是 ISO
    9660、Joliet 或 UDF。SELinux 使用此类型定义来映射权限，例如挂载操作和文件创建。通过 `fscontext=` 选项，可以将文件系统类型设置为不同于默认文件系统类型。
- en: 'The last option that can be used when mounting filesystems is the `rootcontext=`
    option. This will force the root inode of the filesystem to have the given context
    even before the filesystem is visible to the user space. Permission checks on
    the location during the mount operation itself can cause havoc when the location
    does not have the expected context (especially when filesystems are mounted outside
    their expected location). The `rootcontext=` option provides a reusable configuration
    option to set the expected context:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当挂载文件系统时，可以使用的最后一个选项是 `rootcontext=` 选项。即使文件系统尚未对用户空间可见，此选项也会强制将文件系统的根 inode
    设置为给定的上下文。挂载操作期间对该位置的权限检查可能会在该位置没有预期上下文时造成混乱（尤其是当文件系统被挂载到预期位置之外时）。`rootcontext=`
    选项提供了一个可重用的配置选项来设置预期的上下文：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That''s it – these are all the context-related mount options. A final note
    though: the `context=` option is mutually exclusive to the `defcontext=` and `fscontext=`
    options. So, while the `defcontext=` and `fscontext=` options can be used together,
    they cannot be used with the `context=` option. Assuming the target filesystem
    allows for extended attributes, then we can use the file context expressions,
    which we will cover in the next section.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——这些就是所有与上下文相关的挂载选项。不过有一点需要注意：`context=` 选项与 `defcontext=` 和 `fscontext=`
    选项是互斥的。因此，虽然 `defcontext=` 和 `fscontext=` 选项可以一起使用，但不能与 `context=` 选项一起使用。假设目标文件系统支持扩展属性，则可以使用文件上下文表达式，我们将在下一节中讨论这个内容。
- en: SELinux file context expressions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SELinux 文件上下文表达式
- en: When we think that the context of a file is wrong, we need to correct the context.
    SELinux offers several methods to do so, and some distributions even add in more.
    We can use tools such as `chcon`, `restorecon` (together with `semanage`), `setfiles`,
    `rlpkg` (Gentoo), and `fixfiles`. Of course, we could also use the `setfattr`
    command, but that would be the least user-friendly approach for setting contexts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们认为文件的上下文不正确时，需要纠正上下文。SELinux 提供了几种方法来实现这一点，一些发行版甚至增加了更多的选项。我们可以使用诸如 `chcon`、`restorecon`（与
    `semanage` 一起使用）、`setfiles`、`rlpkg`（Gentoo）和 `fixfiles` 等工具。当然，我们也可以使用 `setfattr`
    命令，但那是设置上下文的最不友好的方法。
- en: Let's see how we can set context expressions in a more manageable way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何以更可管理的方式设置上下文表达式。
- en: Using context expressions
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用上下文表达式
- en: In the SELinux policy, a list of regular expressions is kept that informs the
    SELinux utilities and libraries what the context of a file (or other filesystem
    resource) should be. Though this expression list is not enforced on the system
    directly, administrators and SELinux utilities use it to see whether a context
    is correct, and to reset contexts to what they are supposed to be. You can find
    the list itself in `/etc/selinux/targeted/contexts/files` in the various `file_contexts.*`
    files.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SELinux 策略中，保存了一组正则表达式，用于通知 SELinux 工具和库文件应该给文件（或其他文件系统资源）分配什么上下文。尽管此表达式列表不会直接在系统上强制执行，但管理员和
    SELinux 工具会使用它来检查上下文是否正确，并将上下文重置为应有的状态。您可以在 `/etc/selinux/targeted/contexts/files`
    目录下的各种 `file_contexts.*` 文件中找到该列表。
- en: 'As an administrator, we can query this list through `semanage fcontext` as
    follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 作为管理员，我们可以通过 `semanage fcontext` 查询此列表，如下所示：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'An example of a tool that queries this information is `matchpathcon`, which
    we introduced in [*Chapter 2*](B16276_02_Final_VK.xhtml#_idTextAnchor045), *Understanding
    SELinux Decisions and Logging*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 查询此信息的工具之一是 `matchpathcon`，我们在[*第2章*](B16276_02_Final_VK.xhtml#_idTextAnchor045)
    *理解 SELinux 决策与日志记录* 中介绍过：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Not all the entries are visible through the `semanage` application though. Entries
    related to specific user home directories (such as `/home/lisa/.ssh`) are not
    shown as these entries depend on the Linux user (and, more importantly, its associated
    SELinux user).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有条目都可以通过`semanage`应用程序查看。与特定用户主目录（例如`/home/lisa/.ssh`）相关的条目不可见，因为这些条目依赖于Linux用户（更重要的是，它相关联的SELinux用户）。
- en: 'But for all other entries, the output of the command contains the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于所有其他条目，命令的输出包含以下内容：
- en: A regular expression that matches one or more paths
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个匹配一个或多个路径的正则表达式
- en: The classes to which the rule is applicable, but translated into a more human-readable
    format
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则适用的类别，但翻译成更易读的格式
- en: The context to assign to the resources that match the expression and class list
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要分配给与表达式和类别列表匹配的资源的上下文
- en: 'The class list allows us to differentiate contexts based on the resource class.
    The `semanage fcontext` output uses human-readable identifiers: resource classes
    can be a regular file (`--`), a directory (`-d`), a socket (`-s`), a named pipe
    (`-p`), a block device (`-b`), a character device (`-c`), or a symbolic link (`-l`).
    When it says all files, the line is valid regardless of the class.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类别列表使我们能够根据资源类别区分上下文。`semanage fcontext`的输出使用人类可读的标识符：资源类别可以是常规文件（`--`）、目录（`-d`）、套接字（`-s`）、命名管道（`-p`）、块设备（`-b`）、字符设备（`-c`）或符号链接（`-l`）。当它说所有文件时，该行在任何类别下都是有效的。
- en: 'Right now, we have not defined such rules yet, but after the next section,
    even defining custom SELinux context expressions will no longer hold any secrets.
    An important property of the context list is how SELinux prioritizes its application
    – after all, we could easily have two expressions that both match a certain resource
    or path. Within SELinux, the most specific rule wins. The logic used is as follows
    (in order):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们还没有定义这样的规则，但在下一节之后，即使定义自定义SELinux上下文表达式也将不再是秘密。上下文列表的一个重要属性是SELinux如何优先应用它——毕竟，我们可能有两个都匹配某个特定资源或路径的表达式。在SELinux中，最具体的规则会获胜。使用的逻辑如下（按顺序）：
- en: If line A has a regular expression and line B doesn't, then line B is more specific.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果行A有正则表达式，而行B没有，则行B更具体。
- en: If the number of characters before the first regular expression in line A is
    less than the number of characters before the first regular expression in line
    B, then line B is more specific.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果行A中第一个正则表达式前的字符数少于行B中第一个正则表达式前的字符数，那么行B更具体。
- en: If the number of characters in line A is less than in line B, then line B is
    more specific.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果行A中的字符数少于行B中的字符数，则行B更具体。
- en: If line A does not map to a specific SELinux type (the policy editor has explicitly
    told SELinux not to assign a type) and line B does, then line B is more specific.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果行A没有映射到特定的SELinux类型（策略编辑器明确告诉SELinux不要分配类型），而行B有，则行B更具体。
- en: There is a caveat with the rule order, however. When additional rules are added
    through `semanage` (which we describe in the next section), then SELinux's utilities
    apply the rules in the order they were added rather than their specificity. So,
    instead of the most specific rule, the most recently added rule that matches the
    path is used.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个规则的顺序有一个警告。当通过`semanage`添加额外的规则时（我们将在下一节中描述），SELinux的工具会按添加的顺序应用这些规则，而不是按规则的具体性来应用。因此，不是使用最具体的规则，而是使用最近添加的、与路径匹配的规则。
- en: Registering file context changes
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册文件上下文更改
- en: 'Because changing an SELinux context using `chcon` is often just a temporary
    measure, it is seriously recommended to only use `chcon` when testing the impact
    of a context change. Once the change is acceptable, we need to register it through
    `semanage`. For instance, to permanently mark `/srv/web` (and all its subdirectories)
    as `httpd_sys_content_t`, and the DokuWiki `data/` and `conf/` folders as `httpd_sys_rw_content_t`
    (to allow the web server to modify these resources), we need to execute the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因为使用`chcon`更改SELinux上下文通常只是一个临时措施，因此强烈建议仅在测试上下文更改的影响时使用`chcon`。一旦更改被接受，我们需要通过`semanage`进行注册。例如，要永久将`/srv/web`（及其所有子目录）标记为`httpd_sys_content_t`，并将DokuWiki的`data/`和`conf/`文件夹标记为`httpd_sys_rw_content_t`（以允许Web服务器修改这些资源），我们需要执行以下命令：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What we do here is register `/srv/web` and its subdirectories as `httpd_sys_content_t`
    and the two writable directories as `httpd_sys_rw_content_t` through `semanage`.
    Then, we use `restorecon` to (recursively) reset the contexts of `/srv/web` to
    the value registered in the context list. This is the recommended approach for
    setting contexts on most resources.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是通过 `semanage` 将 `/srv/web` 及其子目录注册为 `httpd_sys_content_t`，而将两个可写目录注册为
    `httpd_sys_rw_content_t`。然后，我们使用 `restorecon`（递归）重置 `/srv/web` 的上下文为在上下文列表中注册的值。这是为大多数资源设置上下文的推荐方法。
- en: These registrations are local (custom) context expressions and are stored in
    a separate configuration file (`file_contexts.local`). Considering the priority
    of (locally added) expressions, it is important to have the *most specific entries
    added last*, as otherwise the more broadly defined rule for `httpd_sys_content_t`
    would be applied to the entire directory. This is unlike the priority rules for
    (policy added) expressions that do have the concept of *most specific rule wins*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注册是本地（自定义的）上下文表达式，存储在一个单独的配置文件中（`file_contexts.local`）。考虑到（本地添加的）表达式的优先级，重要的是将*最具体的条目最后添加*，否则对于整个目录会应用定义较为宽泛的
    `httpd_sys_content_t` 规则。这不同于（策略添加的）表达式的优先级规则，后者有“*最具体的规则优先*”的概念。
- en: The `semanage fcontext` application can also be used to inform SELinux that
    a part of the filesystem tree should be labeled similarly as a different location
    on the filesystem. Such an `semanage` to apply the same contexts as if the destination
    were the default.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`semanage fcontext` 应用程序还可以用于通知 SELinux，文件系统树的某一部分应该像文件系统上另一个位置一样进行标记。这样的 `semanage`
    会应用相同的上下文，就像目标位置是默认位置一样。'
- en: 'Let''s make this more visible through an example, and have everything under
    `/srv/web` be labeled in a similar manner to the files at `/var/www` (including
    subdirectories), so `/srv/web/icons` gets the same context as `/var/www/icons`.
    We use the `-e` option of `semanage fcontext` to create such an equivalency as
    follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个示例，我们来更清晰地展示这一点，让 `/srv/web` 下的所有内容都像 `/var/www` 下的文件一样进行标记（包括子目录），因此 `/srv/web/icons`
    会获得与 `/var/www/icons` 相同的上下文。我们使用 `semanage fcontext` 的 `-e` 选项来创建这样的等效规则，如下所示：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will create a substitution entry so that anything under `/srv/web` gets
    the same label as if it were at the same location under `/var/www`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个替代条目，使得 `/srv/web` 下的任何内容都与 `/var/www` 下的相同位置获得相同标签。
- en: 'Most distributions already configure a few equivalency rules that we can read
    as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数发行版已经配置了一些等效规则，我们可以按以下方式读取：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `semanage fcontext -l` command will show these equivalent locations at the
    end of its output as well.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`semanage fcontext -l` 命令也会在其输出的最后显示这些等效位置。'
- en: Optimizing recursive context operations
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化递归上下文操作
- en: The `restorecon` application resets the SELinux context of files and other resources
    based on the context definitions managed through the SELinux policy and `semanage
    fcontext`. When applying `restorecon` in a recursive fashion against directories,
    this might take a while. To improve performance in this situation, the SELinux
    authors support the skipping of `restorecon` operations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`restorecon` 应用程序根据通过 SELinux 策略和 `semanage fcontext` 管理的上下文定义，重置文件和其他资源的 SELinux
    上下文。当对目录递归应用 `restorecon` 时，可能需要一段时间。为了在这种情况下提高性能，SELinux 开发者支持跳过 `restorecon`
    操作。'
- en: 'With the `-D` option to `restorecon`, an additional extended attribute will
    be written to the main directory that contains a hash of the file context definitions
    used when invoking the command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `restorecon` 命令中加上 `-D` 选项后，一个额外的扩展属性将写入包含该命令的主要目录，该属性包含当调用该命令时使用的文件上下文定义的哈希值：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Subsequent invocations of `restorecon` with `-D` will check this hash to see
    whether any of the file context definitions that impact this directory have been
    modified (using `semanage fcontext`). If there aren''t, then the restore operation
    will be skipped:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 后续使用 `restorecon` 命令并加上 `-D` 选项时，将检查这个哈希值，以判断影响该目录的文件上下文定义是否有修改（使用 `semanage
    fcontext`）。如果没有修改，恢复操作将被跳过：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once we update a definition that influences the given location, then `restorecon`
    will reset the contexts appropriately:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们更新了影响给定位置的定义，`restorecon` 将相应地重置上下文：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `restorecon_xattr` command can be used to manage these extended attributes
    (view or delete) and show how the attributes are formed:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`restorecon_xattr` 命令可以用来管理这些扩展属性（查看或删除）并显示属性是如何形成的：'
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `digest` referenced is the `security.restorecon_last` or `security.sehash`
    extended attributes. More recent user space tools use the latter, and apply their
    logic to each subdirectory, whereas older user space utilities use the former
    and only apply their logic on the selected directory.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 引用的 `digest` 是 `security.restorecon_last` 或 `security.sehash` 扩展属性。较新的用户空间工具使用后者，并将其逻辑应用于每个子目录，而较旧的用户空间实用程序使用前者，并仅在选定的目录上应用其逻辑。
- en: 'The disadvantage of the `security.restorecon_last` usage is that it does not
    work with subdirectories: if we apply a recursive `restorecon` operation against
    `/`, then this tool will ignore the digest on `/home`. With the `security.sehash`
    usage, a recursive operation against `/` will check the digest for `/home` as
    well.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`security.restorecon_last` 使用的缺点是它不能与子目录一起工作：如果我们对 `/` 应用递归的 `restorecon` 操作，那么此工具将忽略
    `/home` 上的摘要。使用 `security.sehash` 时，对 `/` 的递归操作将检查 `/home` 的摘要。'
- en: Using customizable types
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可定制类型
- en: Some SELinux types are meant for files whose paths cannot be accurately defined
    by administrators or where the administrator does not want the context to be reset
    when a relabeling operation is triggered. For these purposes, SELinux supports
    what it calls `restorecon`) encounter a file with a customizable type set, they
    will not revert its context to the registered context definition.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 某些 SELinux 类型适用于路径无法由管理员准确定义或管理员不希望在触发重新标记操作时重置上下文的文件。为此，SELinux 支持所谓的 `restorecon`）遇到设置为可定制类型的文件时，它们不会将其上下文恢复为注册的上下文定义。
- en: The customizable types are declared in the `customizable_types` file inside
    `/etc/selinux/targeted/contexts`. To have `restorecon` relabel such files, administrators
    need to pass the force reset option (`-F`) before the tool resets the contexts.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 可定制类型声明在 `/etc/selinux/targeted/contexts` 内的 `customizable_types` 文件中。要使 `restorecon`
    重新标记这些文件，管理员需要在工具重置上下文之前传递强制重置选项（`-F`）。
- en: 'Let''s look at the contents of this `customizable_types` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个 `customizable_types` 文件的内容：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As an example, we can mark a file in a home directory as `home_bin_t`, which
    is a customizable type, and as such, this file will not be relabeled back to `user_home_t`
    when a filesystem relabeling operation is done:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将主目录中的文件标记为 `home_bin_t`，这是一种可定制类型，因此，在执行文件系统重新标记操作时，此文件不会重新标记为 `user_home_t`：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Marking other types as customizable requires updating the `customizable_types`
    file, as there is no user command that adds or removes type definitions from this
    list. Because this file can be overwritten when the distribution or administrator
    pushes out a new policy package, it needs to be governed carefully.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将其他类型标记为可定制类型需要更新 `customizable_types` 文件，因为没有用户命令可以从此列表中添加或删除类型定义。因为此文件可能在发行版或管理员推出新策略包时被覆盖，所以需要仔细管理。
- en: That said, the use of customizable types has its advantages. As an administrator,
    we might want to create and support specific types as usable by end users who
    can use `chcon` to set the contexts of individual files in their home directory.
    By having those types marked as customizable types, a relabeling operation against
    `/home` will not reset those contexts.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，使用可定制类型也有其优势。作为管理员，我们可能希望创建和支持特定类型，供最终用户使用 `chcon` 在其主目录中设置单个文件的上下文。通过将这些类型标记为可定制类型，对
    `/home` 的重新标记操作不会重置这些上下文。
- en: 'When the target type is not a customizable type, administrators generally prefer
    to use `semanage fcontext` to add an expression and `restorecon` to fix the context
    of the files. Most administrators will use directory-based labeling: this is much
    easier to maintain, and much easier to explain to end users. Many will even use
    this approach for customizable types:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标类型不是可定制类型时，管理员通常倾向于使用 `semanage fcontext` 添加表达式，并使用 `restorecon` 修复文件的上下文。大多数管理员会使用基于目录的标记：这样更容易维护，也更容易向最终用户解释。许多人甚至会将这种方法用于可定制类型：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this command, user binaries and scripts located in the `~/bin` directory
    will be labeled as `home_bin_t`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，位于 `~/bin` 目录中的用户二进制文件和脚本将被标记为 `home_bin_t`。
- en: Compiling the different file_contexts files
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译不同的 file_contexts 文件
- en: 'Inside the `/etc/selinux/targeted/contexts/files` directory, five different
    `file_contexts` files can be found:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/etc/selinux/targeted/contexts/files` 目录内，可以找到五个不同的 `file_contexts` 文件：
- en: The `file_contexts` file itself (without any suffix) is the basic expression
    file provided by the SELinux policy offered through the Linux distribution.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_contexts` 文件本身（没有任何后缀）是由 Linux 发行版提供的 SELinux 策略所提供的基本表达式文件。'
- en: The `file_contexts.local` file contains the locally added rules (through the
    `semanage fcontext` command, which we covered earlier in this chapter).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_contexts.local` 文件包含本地添加的规则（通过之前章节中介绍的 `semanage fcontext` 命令）。'
- en: The `file_contexts.homedirs` file contains the expressions for the user home
    directories. When new user mappings are created and managed through `semanage
    login` and `semanage user`, this file is adjusted to reflect the new situation.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_contexts.homedirs` 文件包含用户主目录的表达式。当通过 `semanage login` 和 `semanage user`
    创建并管理新的用户映射时，文件会根据新情况进行调整。'
- en: The `file_contexts.subs_dist` file contains equivalency rules, provided by the
    distribution's SELinux policy, which tell SELinux to consider one part of the
    filesystem as having the same labeling rules as another location.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_contexts.subs_dist` 文件包含由发行版的 SELinux 策略提供的等效规则，这些规则告诉 SELinux 将文件系统的一个部分视为与另一个位置具有相同的标签规则。'
- en: The `file_contexts.subs` file contains locally managed equivalency rules (through
    the `semanage fcontext` command, covered earlier in this chapter).
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_contexts.subs` 文件包含本地管理的等效规则（通过之前章节中介绍的 `semanage fcontext` 命令）。'
- en: 'Alongside those files, you will find associated `*.bin` files (so `file_contexts.bin`
    for the `file_contexts` file, `file_contexts.local.bin` for the `file_contexts.local`
    file, and so on). These `*.bin` files are automatically created, but in case of
    a discrepancy, administrators can rebuild the files themselves as well using the
    `sefcontext_compile` command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些文件，你还会发现关联的 `*.bin` 文件（例如 `file_contexts.bin` 对应 `file_contexts` 文件，`file_contexts.local.bin`
    对应 `file_contexts.local` 文件，等等）。这些 `*.bin` 文件是自动创建的，但如果出现不一致，管理员也可以使用 `sefcontext_compile`
    命令重新生成文件：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: These files contain the same information as the main file, but are precompiled
    to make lookups faster. Unless the tools detect that the `*.bin` files are older
    than their source files, the SELinux utilities will use the compiled versions
    of these files.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件包含与主文件相同的信息，但它们是预编译的，能够加速查找。除非工具检测到 `*.bin` 文件比源文件旧，否则 SELinux 工具将使用这些已编译版本的文件。
- en: Exchanging local modifications
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换本地修改
- en: When local modifications are registered through `semanage fcontext`, they only
    apply to a single system. If local definitions need to be reapplied on various
    systems, administrators can extract the local modifications and import them on
    another system.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过 `semanage fcontext` 注册本地修改时，它们只适用于单个系统。如果需要将本地定义重新应用到多个系统，管理员可以提取本地修改并将其导入到另一个系统中。
- en: 'To export the local modifications, use `semanage export`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出本地修改，请使用 `semanage export`：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The file that contains the local modifications (`local-mods.conf` in the example)
    can be adjusted at will. This allows administrators to remove all lines except
    those they want to apply on other systems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 包含本地修改的文件（示例中的`local-mods.conf`）可以根据需要进行调整。这允许管理员移除除他们希望在其他系统上应用的行以外的所有行。
- en: 'With the local modifications stored in the file, transport the file to the
    other system(s) and import the settings:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将本地修改存储在文件中后，将该文件传输到其他系统，并导入设置：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The imported settings are immediately registered. Of course, in case of filesystem
    changes (`semanage fcontext`), don't forget to run `restorecon` against the target
    directories.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的设置会立即注册。当然，如果文件系统发生更改（`semanage fcontext`），别忘了对目标目录运行 `restorecon`。
- en: Modifying file contexts
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改文件上下文
- en: We now know how to set SELinux contexts, both directly through tools such as
    `chcon` as well as through the `restorecon` application, which queries the SELinux
    context list to know what context a file should have. Yet `restorecon` is not
    the only application that considers this context list.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何设置 SELinux 上下文，既可以通过 `chcon` 等工具直接设置，也可以通过 `restorecon` 应用程序设置，该应用程序查询
    SELinux 上下文列表，以确定文件应该具有的上下文。然而，`restorecon` 并不是唯一考虑此上下文列表的应用程序。
- en: Using setfiles, rlpkg, and fixfiles
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 setfiles、rlpkg 和 fixfiles
- en: 'The `setfiles` application is an older one, which requires the path to the
    context list file itself to reset contexts. It is often used under the hood of
    other applications, so most administrators do not need to call `setfiles` directly
    anymore:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`setfiles` 应用程序是一个较旧的程序，它需要上下文列表文件本身的路径来重置上下文。它通常在其他应用程序的后台使用，因此大多数管理员不再需要直接调用
    `setfiles`。'
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Another set of tools are the `rlpkg` (Gentoo) and `fixfiles` (CentOS and related
    distributions) applications. Both these applications have a nice feature: they
    can be used to reset the contexts of the files of an application rather than having
    to iterate over the files manually and run `restorecon` against them.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组工具是`rlpkg`（Gentoo）和`fixfiles`（CentOS及相关发行版）应用程序。这两个应用程序有一个很好的功能：它们可以用于重置一个应用程序的文件上下文，而无需手动遍历文件并对其运行`restorecon`。
- en: 'In the next example, we''re using these tools to restore the contexts of the
    files provided by the `nginx` package:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们使用这些工具恢复由`nginx`包提供的文件的上下文：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Another feature of both applications is that they can be used to relabel the
    entire filesystem without the need to perform a system reboot, like so:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个应用程序的另一个特点是，它们可以用于重新标记整个文件系统，而无需执行系统重启，操作方式如下：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Of course, this is not as fine-grained as the commands before.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不像之前的命令那样细粒度。
- en: Relabeling the entire filesystem
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新标记整个文件系统
- en: 'The `rlpkg` and `fixfiles` commands as listed in the previous section are not
    the only available approaches for relabeling the entire filesystem when working
    with a CentOS (or related) distribution. SELinux offers two other methods to ask
    the system to perform a full filesystem relabeling operation during (re)boot:
    placing a touch file (which the system reads at boot time) or configuring a boot
    parameter.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中列出的`rlpkg`和`fixfiles`命令并不是在 CentOS（或相关）发行版中进行完整文件系统重新标记的唯一方法。SELinux 提供了另外两种方法，在（重新）启动时请求系统执行完整的文件系统重新标记操作：放置一个触摸文件（系统在启动时读取）或配置引导参数。
- en: 'The touch file is called `.autorelabel` and should be placed in the root filesystem.
    Once set, the system needs to be rebooted:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸文件名为`.autorelabel`，应放置在根文件系统中。设置后，系统需要重新启动：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We trigger the same behavior if we add the `autorelabel=1` parameter to the
    boot parameter list (like where we can set the `selinux=` and `enforcing=` parameters
    as discussed earlier).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`autorelabel=1`参数添加到引导参数列表中（就像我们之前讨论过的可以设置`selinux=`和`enforcing=`参数一样），我们也会触发相同的行为。
- en: Asking the system to perform a full filesystem relabeling operation will take
    a while. When finished, the system will reboot again. Touch files will be removed
    automatically after the relabeling operation has finished.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请求系统执行完整的文件系统重新标记操作将需要一段时间。完成后，系统将再次重启。在重新标记操作完成后，触摸文件将被自动移除。
- en: Automatically setting context with restorecond
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 restorecond 自动设置上下文
- en: Contexts can also be applied by the `restorecond` daemon. The purpose of this
    daemon is to enforce the expression list rules onto a configurable set of locations,
    defined in the `/etc/selinux/restorecond.conf` file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文也可以由`restorecond`守护进程应用。该守护进程的目的是将表达式列表规则强制应用到在`/etc/selinux/restorecond.conf`文件中定义的可配置位置。
- en: 'The following set of files and directories is an example list of locations
    configured in the `restorecond.conf` file so that `restorecond` automatically
    applies the SELinux contexts on these files and directories whenever it detects
    a context change in them:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一组文件和目录的示例列表，这些位置在`restorecond.conf`文件中进行了配置，以便每当检测到这些文件和目录中的上下文变化时，`restorecond`
    自动应用 SELinux 上下文：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this case, if a process creates a file that matches any of the previously
    created paths, the Linux inotify subsystem will notify `restorecond` of it. `restorecond`
    will then relabel the file according to the expression list, applying the correct
    label regardless of the process (and context) that created the file.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果一个进程创建了一个与之前创建的路径匹配的文件，Linux 的 inotify 子系统将通知`restorecond`。然后，`restorecond`
    将根据表达式列表重新标记该文件，应用正确的标签，无论是哪个进程（以及上下文）创建了该文件。
- en: The use of `restorecond` is primarily for historical reasons, when SELinux didn't
    support named file transitions. At that time, writing `resolv.conf` in `/etc`
    could not be differentiated from writing to the `passwd` file in `/etc`. The introduction
    of named file transitions has considerably reduced the need for `restorecond`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`restorecond`的使用主要是出于历史原因，当时 SELinux 不支持命名文件转换。在那时，写入`/etc`中的`resolv.conf`无法与写入`/etc`中的`passwd`文件区分开来。命名文件转换的引入大大减少了对`restorecond`的需求。'
- en: Setting SELinux context at boot with tmpfiles
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 tmpfiles 在启动时设置 SELinux 上下文
- en: If the Linux distribution uses `systemd`, then you can use `systemd-tmpfiles`
    to automatically set SELinux context at boot. `systemd` uses the `tmpfiles` application
    to automatically create and manage volatile locations on the system, such as locations
    inside `/run` when `/run` is a `tmpfs`-mounted filesystem (an in-memory filesystem).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Linux发行版使用`systemd`，则可以使用`systemd-tmpfiles`在启动时自动设置SELinux上下文。`systemd`使用`tmpfiles`应用程序来自动创建和管理系统上的易失性位置，例如当`/run`是`tmpfs`挂载的文件系统（内存文件系统）时，管理`/run`内部的位置。
- en: Administrators can configure `tmpfiles` to automatically create files, directories,
    device files, symbolic links, and others at boot, and to reset the permissions
    on resources. It is through this reset operation that we can use `tmpfiles` to
    set the right SELinux context at boot time.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员可以配置`tmpfiles`以在启动时自动创建文件、目录、设备文件、符号链接等，并重置资源的权限。正是通过这个重置操作，我们可以使用`tmpfiles`在启动时设置正确的SELinux上下文。
- en: 'In [*Chapter 3*](B16276_03_Final_VK.xhtml#_idTextAnchor071), *Managing User
    Logins*, we covered polyinstantiation, where users get their own private view
    on filesystem resources. The example we gave used a directory called `/tmp/tmp-inst`,
    which had to have the `000` permission set, and which will host the user-oriented
    `/tmp` views. Rather than having to create and set this permission each time,
    we can configure `tmpfiles` to do this for us, and define the right SELinux context
    up front:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B16276_03_Final_VK.xhtml#_idTextAnchor071)《管理用户登录》中，我们讨论了多实例化，其中用户可以在文件系统资源上获得自己的私有视图。我们举的例子使用了名为`/tmp/tmp-inst`的目录，该目录必须设置为`000`权限，并且将承载用户特定的`/tmp`视图。与其每次都创建并设置这个权限，我们可以配置`tmpfiles`来自动为我们执行此操作，并事先定义正确的SELinux上下文：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In `/etc/tmpfiles.d`, we create a file called `selinux-polyinstantiation.conf`
    with the following content:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/etc/tmpfiles.d`中，我们创建一个名为`selinux-polyinstantiation.conf`的文件，内容如下：
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The name of the file can be chosen freely, but make sure it uses the `.conf`
    suffix. Every time the system boots, `systemd-tmpfiles` will ensure that the `/tmp/tmp-inst`
    directory is created with the appropriate permissions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名可以自由选择，但请确保使用`.conf`后缀。每次系统启动时，`systemd-tmpfiles`会确保以适当的权限创建`/tmp/tmp-inst`目录。
- en: 'If a location does not need to be created, but only its SELinux context reset,
    then you can use the `z` (one resource) or `Z` (recursively) options in the `tmpfiles`
    configuration. This is used, for instance, by the default SELinux `tmpfiles` configuration,
    `selinux-policy.conf`, in `/usr/lib/tmpfiles.d`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个位置不需要创建，只需要重置其SELinux上下文，则可以在`tmpfiles`配置中使用`z`（一个资源）或`Z`（递归）选项。例如，默认的SELinux
    `tmpfiles`配置`selinux-policy.conf`就在`/usr/lib/tmpfiles.d`中使用了该选项：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `-` used is to inform `tmpfiles` not to adjust the permissions and ownership,
    and only to reset the SELinux context.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的`-`表示告知`tmpfiles`不要调整权限和所有权，仅重置SELinux上下文。
- en: The context of a process
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程的上下文
- en: As everything in SELinux works with contexts, even processes are assigned a
    context, also known as the domain. Let's see how we can obtain this information,
    how SELinux transitions from one domain to another, and learn how to query the
    SELinux policy to find more information about these transitions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SELinux中的所有内容都与上下文相关，甚至进程也会分配一个上下文，也就是所谓的域。让我们看看如何获取这些信息，SELinux如何从一个域切换到另一个域，并了解如何查询SELinux策略以获取更多关于这些切换的信息。
- en: Getting a process context
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取进程的上下文
- en: 'We saw that the `nginx` web server runs in the `httpd_t` domain, which can
    be seen with the `ps -eZ` command, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`nginx` Web服务器运行在`httpd_t`域中，可以通过`ps -eZ`命令查看，输出如下：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Several other ways exist to obtain the process context. Although the method
    with `ps` is the most obvious, these other methods can prove useful in scripted
    approaches or through monitoring services.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几种方法可以获取进程的上下文。尽管使用`ps`命令的方法最为直观，但这些其他方法在脚本化处理或通过监控服务时可能会非常有用。
- en: 'A first approach is to read the `/proc/<pid>/attr/current` pseudo-file, which
    we''ve already encountered in [*Chapter 1*](B16276_01_Final_VK.xhtml#_idTextAnchor018),
    *Fundamental SELinux Concepts*. It displays a process''s current security context:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是读取我们在[*第1章*](B16276_01_Final_VK.xhtml#_idTextAnchor018)《SELinux基础概念》中已经遇到的`/proc/<pid>/attr/current`伪文件。它显示一个进程的当前安全上下文：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To receive a somewhat more human-readable output, use the `secon` command for
    the given process ID:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得更易读的输出，可以使用`secon`命令来查询给定进程ID的上下文：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, the SELinux user space project has a helper utility called `getpidcon`,
    which the `libselinux` library optionally provides. Although this utility is not
    available on CentOS (or related distributions), other distributions such as Gentoo
    do have it. The utility requires a single PID and returns its context:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，SELinux用户空间项目有一个名为`getpidcon`的辅助工具，`libselinux`库可以选择提供这个工具。尽管该工具在CentOS（或相关发行版）上不可用，但其他发行版，如Gentoo，确实有该工具。该工具需要一个PID并返回其上下文：
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, the Apache processes don't themselves inform SELinux that they need to
    run in the `httpd_t` (or, for Gentoo, the `nginx_t`) domain. For that, transition
    rules exist in the SELinux policy that govern when and how processes are executed
    in a specific domain.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Apache进程不会自己通知SELinux它们需要在`httpd_t`（或者在Gentoo中是`nginx_t`）域中运行。为此，SELinux策略中存在转换规则，规定了何时以及如何在特定域中执行进程。
- en: Transitioning toward a domain
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向某个域的转换
- en: Just as we have seen with files, if a process forks and creates a new process,
    this process, by default, inherits the context of the parent process. For the
    web server, the main process is running in the `httpd_t` domain, so all the launched
    worker processes inherit the `httpd_t` domain from it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在文件中看到的那样，如果一个进程进行分叉并创建了一个新进程，则该新进程默认会继承父进程的上下文。对于Web服务器，主进程在`httpd_t`域中运行，因此所有启动的工作进程都会继承`httpd_t`域。
- en: To differentiate the domain of one process from another, domain transitions
    can be defined. A `execve()` function, most likely after a `fork()` operation).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分一个进程的域和另一个进程的域，可以定义域转换。一个`execve()`函数，最有可能在`fork()`操作之后执行。
- en: 'Like the file-based transitions, domain transitions can be queried using `sesearch`.
    Let''s investigate the domains allowed to transition to the `httpd_t` domain:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于文件的转换一样，域转换可以使用`sesearch`进行查询。让我们来看看允许转换到`httpd_t`域的域：
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this case, SELinux will switch the context of a launched web server to `httpd_t`
    if the parent process is running in one of the mentioned domains (such as the
    `initrc_t` domain) and is executing a file labeled as `httpd_exec_t` (the label
    assigned to the `httpd` and `nginx` binaries).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果父进程在上述某个域（例如`initrc_t`域）中运行，并且正在执行标记为`httpd_exec_t`（分配给`httpd`和`nginx`二进制文件的标签）的文件，SELinux将把启动的Web服务器的上下文切换到`httpd_t`。
- en: 'But for this to truly happen, several other permissions (next to the domain
    transition) need to be in place. The following list describes these various permissions:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，要真正实现这一点，除了域转换外，还需要其他几种权限。以下列表描述了这些不同的权限：
- en: 'The source process (such as `initrc_t`) needs to be allowed to transition to
    the `httpd_t` domain, governed by the transition privilege on the process class:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源进程（例如`initrc_t`）需要被允许转换到`httpd_t`域，这由进程类上的转换权限来管理：
- en: '[PRE50]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The source process (such as `initrc_t`) needs to have the right of execution
    on the file it is launching (`httpd_exec_t`):'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源进程（例如`initrc_t`）需要在它正在启动的文件上具有执行权限（`httpd_exec_t`）：
- en: '[PRE51]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `httpd_exec_t` type must be identified as an entry point for the `httpd_t`
    domain. SELinux uses an **entry point** to ensure that a domain transition only
    occurs when using the specified file context on the executing binary or script:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须将`httpd_exec_t`类型标识为`httpd_t`域的入口点。SELinux使用**入口点**来确保只有在使用指定的文件上下文运行执行二进制文件或脚本时，域转换才会发生：
- en: '[PRE52]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The target domain must be allowed for the role that the parent process is in.
    In the case of system daemons, the role is `system_r`:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标域必须允许父进程所在角色。在系统守护进程的情况下，角色是`system_r`：
- en: '[PRE53]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A graphical representation of these rights is as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些权限的图形表示如下：
- en: '![Figure 4.2 – Graphical overview of the necessary transition permissions ](img/B16276_04_002.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 必要的域转换权限的图形概览](img/B16276_04_002.jpg)'
- en: Figure 4.2 – Graphical overview of the necessary transition permissions
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 必要的域转换权限的图形概览
- en: Only when all these privileges are allowed will a domain transition occur. If
    not, then either the execution of the application fails (if the domain has no
    `execute` or `execute_no_trans` rights on the file), or it executes but remains
    running in the same domain as the parent process.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在允许所有这些权限的情况下，域转换才会发生。如果没有，那么应用程序的执行将失败（如果该域在文件上没有`execute`或`execute_no_trans`权限），或者它会执行，但仍然在与父进程相同的域中运行。
- en: Domain transitions are an important concept as they inform the administrator
    how an application gets into its privileged context. To analyze this, many security
    administrators look at how one context can transition to another. We explain policy
    analysis in [*Chapter 13*](B16276_13_Final_VK.xhtml#_idTextAnchor330), *Analyzing
    Policy Behavior*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 域转换是一个重要概念，因为它告诉管理员一个应用程序如何进入其特权上下文。为了分析这一点，许多安全管理员会查看一个上下文如何转换到另一个上下文。我们在[*第13章*](B16276_13_Final_VK.xhtml#_idTextAnchor330)，*分析策略行为*中解释了策略分析。
- en: For policy writers, deciding when to create a domain transition and when to
    keep the processes running in the same (source) context is a matter of design.
    Generally, policy developers will try to keep the parent context confined so that
    every additional privilege is a source of consideration for switching to another
    domain (which has that privilege). Basically, policy developers will trigger a
    transition when the target application requires significantly more (or different)
    permissions than the source domain holds.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于策略编写者来说，决定何时创建域转换以及何时保持进程在同一（源）上下文中运行是设计的问题。通常，策略开发者会尽量将父上下文限制在一个范围内，这样每个附加的权限就成为切换到另一个域（该域具有该权限）的考虑因素。基本上，当目标应用程序需要比源域持有的权限更多（或不同）时，策略开发者会触发转换。
- en: 'That is also why the `unconfined_t` domain has fewer transitions when executing
    user applications compared to the confined user domains, `user_t` or `guest_t`:
    the `unconfined_t` domain already holds many privileges, so transitioning to a
    different domain has little value. Note that this is a decision made by the policy
    writers or Linux distribution, not by the SELinux technology itself. All SELinux
    does is enforce the policy rules.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么在执行用户应用程序时，`unconfined_t`域的转换次数比受限用户域`user_t`或`guest_t`少的原因：`unconfined_t`域已经持有许多权限，因此转换到不同的域几乎没有价值。请注意，这是策略编写者或Linux发行版做出的决策，而不是SELinux技术本身做出的决策。所有SELinux做的就是执行策略规则。
- en: Verifying a target context
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证目标上下文
- en: 'When executing applications, the SELinux policy might have the command run
    in a different domain. Although we could start querying all rules with `sesearch`,
    a simpler command exists that tells us what the target context is when we execute
    a command or script: `selinuxexeccon`.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行应用程序时，SELinux策略可能会让命令在不同的域中运行。尽管我们可以使用`sesearch`查询所有规则，但存在一个更简单的命令，它会告诉我们执行命令或脚本时的目标上下文：`selinuxexeccon`。
- en: This command requires at least one argument (the path of the binary or script
    that would be executed) and an optional second (the source context). If we omit
    the second argument, the tool will use the current context as the source context.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令至少需要一个参数（即将执行的二进制文件或脚本的路径），以及一个可选的第二个参数（源上下文）。如果我们省略第二个参数，工具将使用当前上下文作为源上下文。
- en: 'For instance, to find out in which domain the `passwd` command would run when
    executed from the current context, we''d use this command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要找出当在当前上下文中执行`passwd`命令时，命令将在哪个域中运行，我们可以使用以下命令：
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following example shows the target context when the `init_t` domain executes
    the `nginx` binary:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了当`init_t`域执行`nginx`二进制文件时的目标上下文：
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Using `selinuxexeccon` is much faster than querying all appropriate permissions
    separately.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`selinuxexeccon`比单独查询所有适当的权限要快得多。
- en: Other supported transitions
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他支持的转换
- en: Regular domain transitions are the most common transitions in SELinux, but other
    transitions are possible as well. For instance, some applications (such as `cron`
    or `login`) are SELinux-aware and will specify which domain to transition to.
    These applications call the `setexeccon()` method (set execution context) to specify
    the target domain and do not use a type transition rule. The other privilege requirements,
    however, still hold.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 常规域转换是SELinux中最常见的转换，但也有其他可能的转换。例如，一些应用程序（如`cron`或`login`）是SELinux感知的，并会指定要转换到的域。这些应用程序调用`setexeccon()`方法（设置执行上下文）来指定目标域，而不使用类型转换规则。然而，其他的权限要求仍然有效。
- en: Some SELinux-aware applications are even able to change their *current* context
    (and not just the context of the application they execute). To accomplish this,
    the application domain needs the `dyntransition` privilege (one of the privileges
    supported for process-level activities). One example of such an application is
    OpenSSH, which, by default, runs in the `sshd_t` domain but can transition to
    the `sftpd_t` type.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一些支持 SELinux 的应用程序甚至能够更改其*当前*上下文（而不仅仅是它们执行的应用程序的上下文）。为了实现这一点，应用程序域需要 `dyntransition`
    权限（这是支持进程级活动的权限之一）。这样的应用程序的一个例子是 OpenSSH，默认情况下，它在 `sshd_t` 域中运行，但可以切换到 `sftpd_t`
    类型。
- en: Querying initial contexts
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询初始上下文
- en: When SELinux does not have a label yet for a resource, it will assign an initial
    context (or initial **security ID** (**SID**)) to the resource. For a few classes,
    the SELinux policy will have a default initial context from which it can further
    jumpstart and assign labels.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SELinux 尚未为资源分配标签时，它将为该资源分配一个初始上下文（或初始**安全标识符**（**SID**））。对于某些类别，SELinux 策略将具有一个默认的初始上下文，从中可以进一步启动并分配标签。
- en: 'The initial contexts for various SIDs can be queried using `seinfo`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `seinfo` 查询各种 SID 的初始上下文：
- en: '[PRE56]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, not all classes have a default context assigned, as other classes
    have their contexts derived from the contexts of the currently listed initial
    SIDs.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，并不是所有类别都有默认的上下文分配，因为其他类别的上下文是从当前列出的初始 SID 的上下文派生的。
- en: Tweaking memory protections
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整内存保护
- en: Legacy binaries on Linux systems might require execution permissions to be set
    on memory regions when these are used for reading, even when the execute permission
    is not actually used. This read-implies-exec is a nuisance for mandatory access
    controls such as SELinux because they need to document the appropriate permissions
    in their policy. If an application needs read access, does the policy then also
    have to include the implied execute rights? And if the policy does not include
    execute rights, should the read operation then fail because it implied execute
    permissions?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 系统上的遗留二进制文件可能需要为内存区域设置执行权限，当这些区域用于读取时，即使没有实际使用执行权限。读即执行（read-implies-exec）对于强制访问控制（如
    SELinux）来说是个麻烦，因为它们需要在策略中记录适当的权限。如果一个应用程序需要读取访问权限，那么策略是否也必须包含隐含的执行权限？如果策略没有包含执行权限，那么读取操作是否应该失败，因为它隐含了执行权限？
- en: Informational note
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 说明性备注
- en: Read-implies-exec is a legacy support for running old binaries or binaries compiled
    for other Unix systems where applications do not explicitly mark their executable
    memory as executable, assuming that every memory region that is marked as readable
    is executable. This creates a security risk as malicious actors can load in executable
    code dynamically without the system being able to prevent the application to execute
    this code. Many operating systems nowadays have clear memory protection routines
    in place, including preventing data from becoming executable. Sadly, we often
    need to deal with legacy situations, so all operating systems have methods in
    place that selectively disable these memory controls, and within Linux this is
    done through its `man personality` for more information).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 读即执行（read-implies-exec）是对运行旧二进制文件或为其他 Unix 系统编译的二进制文件的遗留支持，其中应用程序没有明确标记其可执行内存为可执行内存，假设所有标记为可读的内存区域都是可执行的。这带来了安全风险，因为恶意行为者可以动态加载可执行代码，而系统无法阻止应用程序执行这些代码。如今，许多操作系统都有明确的内存保护机制，包括防止数据变为可执行代码。遗憾的是，我们往往需要处理遗留情况，因此所有操作系统都有方法选择性地禁用这些内存保护，而在
    Linux 中这是通过其 `man personality` 完成的（更多信息）。
- en: SELinux developers allow administrators to select their most appropriate permission
    handling by introducing a memory protection check that can be tuned. The `checkreqprot`
    option can be set to `0` to check protections as handled by the kernel, or `1`
    to check protections as asked by the application.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 开发者通过引入可以调整的内存保护检查，允许管理员选择最合适的权限处理方式。`checkreqprot` 选项可以设置为 `0`，以检查内核处理的保护，或设置为
    `1`，以检查应用程序请求的保护。
- en: 'On older systems, this option will be set to `1` to support these legacy binaries.
    Recent distributions, however, build their applications appropriately, and the
    more secure setting `0` is used, as displayed by the `sestatus` command:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧系统上，此选项将设置为 `1` 以支持这些遗留二进制文件。然而，最近的发行版适当地构建了它们的应用程序，使用更安全的设置 `0`，如 `sestatus`
    命令所示：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can toggle this support through `/sys/fs/selinux/checkreqprot`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `/sys/fs/selinux/checkreqprot` 来切换此支持：
- en: '[PRE58]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The parameter's default value is configured when building the Linux kernel,
    through the `CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE` kernel configuration
    parameter. Administrators can also boot the system with the `checkreqprot=` boot
    parameter to have the specified value set.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 该参数的默认值在构建 Linux 内核时通过`CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE`内核配置参数进行配置。管理员还可以通过`checkreqprot=`启动参数启动系统，以设置指定的值。
- en: Limiting the scope of transitions
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制转换范围
- en: For security reasons, Linux systems can reduce the ability of processes to gain
    elevated privileges under certain situations or provide additional constraints
    to reduce the likelihood of vulnerabilities to be exploitable. SELinux developers,
    too, honor these situations.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，Linux 系统可以在某些情况下减少进程获取提升权限的能力，或提供额外的约束，以减少漏洞被利用的可能性。SELinux 开发人员也遵守这些情况。
- en: Sanitizing environments on transition
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在转换时清理环境
- en: When we execute a higher-privileged command (be it a `setuid` application or
    one where capabilities are added to the session), the **GNU C library** (**glibc**)
    will sanitize the environment. This means that a set of security-sensitive environment
    variables are discarded to make sure that attackers, malicious persons, or malicious
    applications cannot negatively influence the session.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行一个更高权限的命令（无论是`setuid`应用程序，还是在会话中添加了权限的应用程序）时，**GNU C 库**（**glibc**）会清理环境。这意味着一组安全敏感的环境变量会被丢弃，以确保攻击者、恶意人员或恶意应用程序无法负面影响会话。
- en: This secure execution is controlled through an `LD_PRELOAD`, `LD_AUDIT`, `LD_DEBUG`,
    `TMPDIR`, and `NLSPATH` are removed from the session.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安全执行通过`LD_PRELOAD`、`LD_AUDIT`、`LD_DEBUG`、`TMPDIR`和`NLSPATH`的移除来控制。
- en: SELinux will force this sanitation on domain transitions as well, ensuring that
    the newly executed domain does not have access to these sensitive environment
    variables. Of course, sometimes the transitioned domain requires these variables.
    Not all domains can deal with sanitized environments, or use these environment
    variables to pass along important information, so always dropping the environment
    variables might result in unusable application domains.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 还会强制对域转换进行环境清理，确保新执行的域无法访问这些敏感的环境变量。当然，有时转换后的域需要这些变量。并非所有域都能处理清理过的环境，或者使用这些环境变量传递重要信息，因此始终丢弃环境变量可能会导致应用程序域无法使用。
- en: 'To allow transitions without sanitizing the environment, the `noatsecure` permission
    can be granted to domain transitions. For instance, let''s consider the execution
    of a Firefox plugin:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许在不清理环境的情况下进行域转换，可以为域转换授予`noatsecure`权限。例如，假设我们执行一个 Firefox 插件：
- en: '[PRE59]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When an application running in the `unconfined_t` domain executes the plugin
    (which results in a domain transition to `mozilla_plugin_t`), the environment
    variables need to be kept as otherwise the plugin might not function properly.
    As such, the SELinux policy grants the `noatsecure` permission to the domains
    that invoke Firefox plugins.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`unconfined_t`域中运行的应用程序执行插件（导致转换到`mozilla_plugin_t`域）时，必须保留环境变量，否则插件可能无法正常工作。因此，SELinux
    策略授予调用 Firefox 插件的域`noatsecure`权限。
- en: Disabling unconstrained transitions
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用不受限制的转换
- en: A second security constraint that Linux supports is to mount a filesystem with
    the `nosuid` option. When set, no `setuid` and `setgid` binaries on that filesystem
    will have any effect on the effective user or group ID of the executing session.
    Essentially, a `setuid` application on a filesystem mounted with `nosuid` will
    act as if no `setuid` bit is set.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 支持的第二个安全约束是使用`nosuid`选项挂载文件系统。设置该选项后，该文件系统上的任何`setuid`和`setgid`二进制文件将不会对执行会话的有效用户或组
    ID 产生任何影响。本质上，位于使用`nosuid`挂载的文件系统上的`setuid`应用程序将表现得像没有设置`setuid`位。
- en: 'To ensure that transitions triggered by applications hosted on a `nosuid`-mounted
    filesystem do not allow for elevated privileges, SELinux policy developers must
    explicitly mark a transition as allowed for `nosuid`-mounted filesystems, using
    the `nosuid_transition` permission. This permission is part of the `process2`
    class:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保由托管在`nosuid`挂载文件系统上的应用程序触发的转换不会允许提升的权限，SELinux 策略开发人员必须明确标记一个转换为允许在`nosuid`挂载文件系统上进行，使用`nosuid_transition`权限。该权限属于`process2`类：
- en: '[PRE60]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This allows policy developers to differentiate regular domain transitions from
    `nosuid`-constrained domain transitions.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许策略开发人员区分常规域转换和`nosuid`约束的域转换。
- en: Note
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: SELinux has a limit on the number of privileges that can be assigned to a class.
    When the number of privileges exceeds 32, the SELinux developers will create a
    different class and the permissions continue in this second class. Right now,
    the two classes that have more than 32 permissions are the `capability` class
    and the `process` class.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 对可以分配给某个类别的权限数量有一个限制。当权限数量超过 32 时，SELinux 开发者会创建一个不同的类别，权限将继续存在于第二个类别中。目前，权限超过
    32 的两个类别是 `capability` 类别和 `process` 类别。
- en: 'This permission-based approach might not be in place on all SELinux-enabled
    systems though. It is enabled when the `nnp_nosuid_transition` policy capability
    is defined and set to `1`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种基于权限的方法可能并不是所有启用 SELinux 的系统上都有实现。只有在定义并将 `nnp_nosuid_transition` 策略功能设置为
    `1` 时，才会启用：
- en: '[PRE61]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If this capability value is `0`, then SELinux will use a concept called `nosuid`-mounted
    filesystems. Any executable with a file context that would result in a domain
    transition will only result in a domain transition if the target domain is bounded
    by the parent domain.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此功能值为`0`，则 SELinux 将使用一个叫做 `nosuid` 的挂载文件系统概念。任何具有文件上下文的可执行文件，如果会导致域转换，只有在目标域由父域约束时，才会发生域转换。
- en: Note
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`nnp_nosuid_transition` capability, the policy developer informs the kernel
    that the `nosuid_transition` and `nnp_transition` permission checks should be
    used rather than bounded domains, and that its policy will generally only include
    support for the transitions and not for the bounded domains.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`nnp_nosuid_transition` 功能时，策略开发者通知内核，应该使用 `nosuid_transition` 和 `nnp_transition`
    权限检查，而不是有界域，并且该策略通常仅支持这些转换，而不支持有界域。'
- en: If it is not bounded, then the domain transition will not occur, and the session
    will remain in the current context (or the command will fail to execute if the
    application is not allowed to run in the current context).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有约束，那么域转换将不会发生，且会话将保持在当前上下文中（或者如果应用程序不允许在当前上下文中运行，命令将无法执行）。
- en: A **bounded domain** is not just calculated live based on the permissions though.
    SELinux has an explicit rule that enforces a target domain to be bounded by a
    parent domain. Even when permissions are later added to the bounded domain, they
    will be denied by the SELinux security subsystem if they aren't part of the parent
    domain.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**有界域**不仅仅是根据权限实时计算的。SELinux 有一条明确的规则，强制要求目标域由父域约束。即使后来向有界域添加了权限，如果这些权限不属于父域，它们也会被
    SELinux 安全子系统拒绝。'
- en: 'With `seinfo`, these type bounds can be listed as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `seinfo`，这些类型的边界可以如下列出：
- en: '[PRE62]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Most distributions, however, do not have bounded domains defined in their SELinux
    policy anymore, as the new `nosuid_transition` permission is much more flexible.
    The use of bounded domains required policy developers to extend the permissions
    of the parent domain every time the child domain needed to be extended, which
    was a major nuisance when the parent domain is a generic one (be it a container
    management platform or a system service daemon).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数发行版现在不再在其 SELinux 策略中定义有界域，因为新的 `nosuid_transition` 权限更加灵活。使用有界域要求策略开发者每次需要扩展子域时，都要扩展父域的权限，而当父域是通用的（无论是容器管理平台还是系统服务守护进程）时，这会变得非常麻烦。
- en: Using Linux's NO_NEW_PRIVS
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Linux 的 NO_NEW_PRIVS
- en: The use of filesystems mounted with `nosuid` is a specific case of Linux's `nnp_transition`
    permission, or toward a bounded domain if the `nnp_nosuid_transition` policy capability
    is not set.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用挂载了 `nosuid` 的文件系统是 Linux 的 `nnp_transition` 权限的特定情况，或者如果没有设置 `nnp_nosuid_transition`
    策略功能，则指向一个有界域。
- en: The parameter can be set by applications themselves using the process control
    function `prctl()`, but the user can also influence this. The `setpriv` command
    can be used to launch applications with `PR_SET_NO_NEW_PRIVS` set (the parameter
    that applications can pass through the `prctl()` function).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 该参数可以通过应用程序本身使用进程控制函数 `prctl()` 来设置，但用户也可以影响此值。可以使用 `setpriv` 命令启动应用程序，并设置 `PR_SET_NO_NEW_PRIVS`（这是应用程序可以通过
    `prctl()` 函数传递的参数）。
- en: 'As an example, create the following simple Python-based CGI script in a `cgi-bin`
    directory inside a regular user''s home directory:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，在常规用户的主目录中的`cgi-bin`目录下创建以下简单的基于 Python 的 CGI 脚本：
- en: '[PRE63]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'With this CGI script now available, first launch a simple CGI-capable web server
    (we will pick port `6020` as unprivileged users should be able to bind processes
    to this port) and connect to it:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，该CGI脚本可用，首先启动一个简单的CGI支持网页服务器（我们将选择端口`6020`，因为非特权用户应该能够将进程绑定到该端口），并连接到它：
- en: '[PRE64]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In a different session, connect to the web server and call the newly created
    Python script (here named `test.py`):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个会话中，连接到网页服务器并调用新创建的Python脚本（此处命名为`test.py`）：
- en: '[PRE65]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, launch the same CGI-capable web server, but with NNP enabled:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动同一个CGI支持的网页服务器，但启用NNP：
- en: '[PRE66]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Again, connect to the web server and call the `test.py` CGI script:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 再次连接到网页服务器并调用`test.py` CGI脚本：
- en: '[PRE67]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Because Linux's NNP is enabled, the `ping` command is not able to obtain the
    higher privileges needed to open the socket.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Linux启用了NNP，`ping`命令无法获得打开套接字所需的更高权限。
- en: Sometimes, you'll notice a denial for the `execute_no_trans` permission in the
    SELinux audit logs. This occurs when the SELinux policy does not allow an application
    to be executed without transitioning.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您会在SELinux审计日志中注意到`execute_no_trans`权限的拒绝。这是因为SELinux策略不允许应用程序在没有过渡的情况下执行。
- en: Types, permissions, and constraints
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型、权限和约束
- en: Now that we know more about types (for processes, files, and other resources),
    let's explore how these are used in the SELinux policy in more detail.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对类型（如进程、文件和其他资源）有了更多的了解，接下来我们将更详细地探讨它们在SELinux策略中的应用。
- en: Understanding type attributes
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解类型属性
- en: 'We have discussed the `sesearch` application already and how it can be used
    to query the current SELinux policy. Let''s look at a specific process transition:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了`sesearch`应用程序及其如何用于查询当前SELinux策略。现在让我们看一个具体的进程过渡：
- en: '[PRE68]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Even though we asked for the rules related to the `initrc_t` source domain and
    the `httpd_t` target, we get a rule back for the `initrc_domain` source domain
    and the `daemon` target. What `sesearch` did here was show us how the SELinux
    policy allows the requested permission, but through *attributes* assigned to the
    `initrc_t` and `httpd_t` types.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们请求了与`initrc_t`源域和`httpd_t`目标相关的规则，但我们得到了关于`initrc_domain`源域和`daemon`目标的规则。`sesearch`在这里做的是展示SELinux策略如何通过分配给`initrc_t`和`httpd_t`类型的*属性*来允许请求的权限。
- en: '`initrc_domain`, the following types are all tagged with this attribute, as
    can be seen through the `seinfo` application:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`initrc_domain`，以下类型都被标记为此属性，可以通过`seinfo`应用程序查看：'
- en: '[PRE69]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As we can see, the `initrc_t` type is indeed one of the types tagged with `initrc_domain`.
    Similarly, the `daemon` attribute is assigned to several types (several hundred,
    even). So, the single allow rule mentioned earlier consolidates more than a thousand
    rules into one.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`initrc_t`类型确实是标记为`initrc_domain`的类型之一。类似地，`daemon`属性被分配给多个类型（甚至几百个）。因此，前面提到的单一允许规则将超过一千条规则合并为一条。
- en: Attributes are increasingly used in the policy as a way of consolidating and
    simplifying policy development. With `seinfo -a`, you can get an overview of all
    the attributes supported in the current policy.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 属性在策略中越来越多地被用作整合和简化策略开发的一种方式。通过`seinfo -a`，您可以获得当前策略中支持的所有属性的概览。
- en: Querying domain permissions
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询域权限
- en: 'The most common rules in SELinux are the `allow` rules, informing the SELinux
    subsystem what permissions a domain has. `allow` rules use the following syntax:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux中最常见的规则是`allow`规则，它告知SELinux子系统某个域具有哪些权限。`allow`规则使用以下语法：
- en: '[PRE70]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `<source>` field is almost always a domain, whereas the `<destination>`
    field can be any type.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`<source>`字段几乎总是一个域，而`<destination>`字段可以是任何类型。'
- en: 'The `<class>` field allows us to differentiate privileges based on the resource,
    whether it is for a regular file, a directory, a TCP socket, a capability, and
    so on. A full overview of all supported classes can be obtained from `seinfo -c`.
    Each class has a set of permissions assigned to it that SELinux can control. For
    instance, the `sem` class (used for semaphore access) has the following permissions
    associated with it:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`<class>`字段使我们能够根据资源区分权限，无论它是常规文件、目录、TCP套接字、能力等。可以通过`seinfo -c`获得所有支持的类的完整概览。每个类都有一组权限，SELinux可以控制。例如，`sem`类（用于信号量访问）与之关联的权限如下：'
- en: '[PRE71]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The reference to `ipc` in the output informs us that the class inherits permission
    from the common `ipc` class, which we can query as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的`ipc`引用告知我们该类继承了公共`ipc`类的权限，我们可以通过如下方式查询：
- en: '[PRE72]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the `<permissions>` field, most rules will bundle a set of permissions using
    curly brackets:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<permissions>`字段中，大多数规则会使用大括号将一组权限捆绑在一起：
- en: '[PRE73]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This syntax allows policy developers to make very fine-grained permission controls.
    We can use the `sesearch` command to query these rules. The more options are given
    to the `sesearch` command, the finer-grained our search parameters become. For
    instance, `sesearch -A` would give us all allow rules currently in place. Adding
    a source (`-s`) filters the output to only show the allow rules for this domain.
    Adding a destination or target (`-t`) filters the output even more. Other options
    that can be used to filter through allow rules with `sesearch` are the class (`-c`)
    and permission (`-p`) options.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法允许策略开发人员进行非常精细的权限控制。我们可以使用`sesearch`命令查询这些规则。向`sesearch`命令提供的选项越多，我们的搜索参数就越细化。例如，`sesearch
    -A`会列出当前生效的所有允许规则。添加源（`-s`）会将输出筛选为仅显示此域的允许规则。添加目标（`-t`）则进一步筛选输出。其他可用于通过`sesearch`筛选允许规则的选项包括类（`-c`）和权限（`-p`）选项。
- en: As you might have guessed by now, `sesearch` is an extremely versatile command
    for querying the active policy, showing us the SELinux policy rules that match
    the options given.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如你现在可能已经猜到，`sesearch`是一个非常强大的命令，用于查询活动策略，显示与给定选项匹配的SELinux策略规则。
- en: Learning about constraints
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解约束
- en: The `allow` statements in SELinux, however, only focus on type-related permissions.
    Sometimes though, we need to restrict certain actions based on the user or role
    information. SELinux supports this through constraints.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，SELinux中的`allow`语句只关注与类型相关的权限。但有时我们需要根据用户或角色信息来限制某些操作。SELinux通过约束支持这一点。
- en: '**Constraints** in SELinux are rules applied against a class and a set of its
    permissions that must be true for SELinux to further allow the request. Consider
    the following constraint on process transitions:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**SELinux中的约束**是应用于一个类及其权限集的规则，必须满足这些规则，SELinux才会进一步允许请求。考虑以下关于进程转换的约束：'
- en: '[PRE74]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This constraint says that at least one of the following rules must be true
    if a `transition`, `dyntransition`, or any of the other three mentioned process
    permissions is invoked:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束表示，如果调用了`transition`、`dyntransition`或其他提到的三种进程权限中的任何一个，以下规则至少有一个必须为真：
- en: The SELinux user of the source (`u1`) and that of the target (`u2`) must be
    the same.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源（`u1`）的SELinux用户和目标（`u2`）的SELinux用户必须相同。
- en: The SELinux type of the source (`t1`) must have the `can_change_process_identity`
    attribute set, and the SELinux type of the target (`t2`) must have the `process_user_target`
    attribute set.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源（`t1`）的SELinux类型必须设置`can_change_process_identity`属性，且目标（`t2`）的SELinux类型必须设置`process_user_target`属性。
- en: The SELinux type of the source (`t1`) must have the `cron_source_domain` attribute
    set, and either the target type (`t2`) should have `cron_job_domain` as an attribute,
    or the target SELinux user (`u2`) should be `system_u`.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源（`t1`）的SELinux类型必须设置`cron_source_domain`属性，且目标类型（`t2`）应具有`cron_job_domain`属性，或者目标SELinux用户（`u2`）应为`system_u`。
- en: The SELinux type of the source (`t1`) must have the `can_system_change` attribute
    set, and the SELinux user of the target (`u2`) must be `system_u`.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源（`t1`）的SELinux类型必须设置`can_system_change`属性，目标（`u2`）的SELinux用户必须是`system_u`。
- en: The SELinux type of the source (`t1`) must have the `process_uncond_exempt`
    attribute set.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源（`t1`）的SELinux类型必须设置`process_uncond_exempt`属性。
- en: 'It is through constraints that UBAC is implemented as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 正是通过约束，UBAC得以实现，如下所示：
- en: '[PRE75]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You can list the currently enabled constraints using `seinfo --constrain`. Multiple
    constraints can be active for the same class and permission set. In that case,
    all the constraints need to be true for the permission to go through.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`seinfo --constrain`列出当前启用的约束。对于同一个类和权限集，可以同时激活多个约束。在这种情况下，所有约束都必须为真，权限才能通过。
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how file contexts are stored as extended attributes
    on the filesystem and how we can manipulate the contexts of files and other filesystem
    resources. Next, we found out where SELinux keeps the definitions that describe
    which SELinux contexts to assign to the files.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将文件上下文作为扩展属性存储在文件系统中，以及如何操作文件和其他文件系统资源的上下文。接下来，我们了解了SELinux在哪里存储描述将哪个SELinux上下文分配给文件的定义。
- en: We also learned to work with the `semanage` tool to manipulate this information
    and worked with a few tools that use this information to enforce contexts on resources.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何使用`semanage`工具来操作这些信息，并使用几个利用这些信息来强制资源上下文的工具。
- en: On the process level, we got our first taste of SELinux policies, identifying
    when a process launches inside a certain SELinux domain. With it, we covered the
    `sesearch` and `seinfo` applications to query the SELinux policy. Finally, we
    looked at some of Linux's security implementations that limit the transition scope
    of applications, which also influences SELinux domain transitions.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程级别上，我们初次接触了SELinux策略，识别进程何时在特定的SELinux域内启动。我们使用`sesearch`和`seinfo`应用程序来查询SELinux策略。最后，我们看了一些限制应用程序转换范围的Linux安全实现，这也影响SELinux域转换。
- en: In the next chapter, we will expand our knowledge of protecting the operating
    system through the networking-related features of SELinux.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过SELinux与网络相关的功能扩展我们的保护操作系统的知识。
- en: Questions
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the most common option for Linux tools to display or explicitly set
    SELinux contexts?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux工具用于显示或明确设置SELinux上下文的最常见选项是什么？
- en: How is an SELinux context for a file or directory stored on the system?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件或目录的SELinux上下文是如何存储在系统中的？
- en: Why is `chcon` not recommended to persist SELinux context changes?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不建议使用`chcon`来持久化SELinux上下文更改？
- en: Is the order of context definitions using the `semanage fcontext` command important?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`semanage fcontext`命令定义上下文的顺序重要吗？
- en: How do you relabel files on the filesystem?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在文件系统上重新标记文件？
- en: What privileges does a domain need before it can transition to another domain?
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个域可以转换到另一个域之前，该域需要什么特权？
- en: How do SELinux policies bundle multiple types together to facilitate policy
    development?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SELinux策略如何将多种类型捆绑在一起以便于策略开发？
