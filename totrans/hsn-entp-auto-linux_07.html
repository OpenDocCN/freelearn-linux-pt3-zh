<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using Ansible to Build Virtual Machine Templates for Deployment</h1>
                </header>
            
            <article>
                
<p>So far in this book, we have covered in detail the groundwork for the remainder—that is to say, we have set the rationale for what we intend to do next and provided a <em>crash course</em> in our automation tool of choice, Ansible. From the preceding chapter, we know that, in an enterprise-scale environment, there are two fundamental methods for deploying Linux, and which of these to use is determined by the technologies in use in your environment and your intended goals.</p>
<p>In this chapter, we will cover in detail how to build virtual machine images that will serve on most virtualization and cloud platforms. The differences between these two platforms are subtle but distinct as we shall find out, and by the end of this chapter, you will know how to handle both environments with ease. We will start with a discussion on the initial build requirements, and then move on to configure and prepare the images for use in your chosen environment.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Performing the initial build</li>
<li>Using Ansible to build and standardize the template</li>
<li>Cleaning up the build with Ansible</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter assumes that you have access to a virtualization-capable environment running Ubuntu 18.04 LTS. Some examples are also performed on CentOS 7. In either of these cases, the examples can be run on either a physical machine (or laptop) running one of the aforementioned operating systems, with a process that has virtualization extensions enabled or a virtual machine with nested virtualization enabled.</p>
<p>Ansible 2.8 is also used later in this chapter and it is assumed you have this installed on the Linux host you are using.</p>
<p><span>All example code discussed in this chapter is available from GitHub at:</span><span> <a href="https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter05">https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter05</a></span>.</p>
<p> </p>
<p> </p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performing the initial build</h1>
                </header>
            
            <article>
                
<p>As discussed in <a href="2b6b6bcd-287a-4ce9-a2fa-1ecccf3a174b.xhtml" target="_blank">Chapter 4</a>, <em>Deployment Methodologies</em>, whether you are using a traditional virtualization platform such as oVirt or VMware or a cloud-based one such as OpenStack or Amazon's EC2, your starting point for any Linux deployments (and hence further automation) will be a templated image.</p>
<p>In terms of the SOE we defined in <a href="c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml" target="_blank">Chapter 1</a>, <em>Building a Standard Operating Environment on Linux</em>, the templated image is the very real initial manifestation of this. It is usually a small virtual machine image, with just enough software installed and configuration completed that it is useful in almost all scenarios it might be deployed in for the enterprise. As long as the image boots up cleanly with a unique hostname, SSH host keys, and such, then it can be customized almost immediately using further automation as we shall discover from <a href="200bea26-7066-4feb-a571-481a5f047ae4.xhtml" target="_blank">Chapter 7</a>, <em>Configuration Management with Ansible</em>, later in this book. Let's dive into the build process by taking a ready-made template image (provided by a third party) as our starting point.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using ready-made template images</h1>
                </header>
            
            <article>
                
<p>For most platforms, there are a large number of readily available images for you to download, and again, we discussed a few of these in the previous chapter. For many enterprises, these images will be sufficient. However, what if you absolutely need full control over your image definition? Perhaps you are adopting a new standard (at the time of writing, Red Hat Enterprise Linux 8 has just been released, and CentOS 8 will surely follow in due course), and you want to implement it early to gain experience and test workloads. What if you operate in a secure environment (perhaps payment card industry-compliant), and you absolutely have to have 100% confidence in how the image was built and there can be no risk of compromise?</p>
<p>This, of course, is not to say that any publicly available images are compromised or even likely to be, but historically there have been a handful of <em>man-in-the-middle</em> or <em>supply chain</em> attacks where attackers have compromised services not directly, but rather indirectly by attacking common components that are used as building blocks.</p>
<p>Most publicly available images come from trustworthy sources that have put in place a variety of checks and controls to ensure their integrity. Provided you make use of these checks, and perform due diligence on any images you download, most enterprises will find little need to create their own images from scratch, as automation tools such as Ansible will take care of all post-deployment configuration.</p>
<p>Let's take a practical example: suppose that, for a new set of deployments, we have decided to create an SOE based upon the Fedora 30 server image, and we will be running this on an OpenStack infrastructure:</p>
<ol>
<li>We would download the cloud image from the official Fedora project web site—details can be found here, though note that the version number will change over time as new releases of Fedora arrive, at <a href="https://alt.fedoraproject.org/cloud/">https://alt.fedoraproject.org/cloud/</a>.</li>
</ol>
<p style="padding-left: 60px">Upon establishing the correct Fedora cloud image for our environment, we can download our required image with a command such as this:</p>
<pre style="padding-left: 60px"><strong>$ wget https://download.fedoraproject.org/pub/fedora/linux/releases/30/Cloud/x86_64/images/Fedora-Cloud-Base-30-1.2.x86_64.qcow2</strong></pre>
<ol start="2">
<li>Simple enough<span>—</span>now, let's verify it. Verification instructions are normally provided with all major Linux releases, whether for ISOs or complete images, and those for our Fedora image download can be found at <a href="https://alt.fedoraproject.org/en/verify.html">https://alt.fedoraproject.org/en/verify.html</a>.</li>
</ol>
<p style="padding-left: 60px">Let's run through the process and validate our image. First of all, we will import the official Fedora GPG key to validate the checksum file to make sure it hasn't been tampered with:</p>
<pre style="padding-left: 60px"><strong>$ curl https://getfedora.org/static/fedora.gpg | gpg --import</strong></pre>
<ol start="3">
<li>Now we will download the checksum file for the cloud base images and verify it:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ wget https://alt.fedoraproject.org/en/static/checksums/Fedora-Cloud-30-1.2-x86_64-CHECKSUM</strong><br/><strong>$ gpg --verify-files *-CHECKSUM</strong></pre>
<ol start="4">
<li>Although you may get a warning about the key not being certified by a trusted signature (this is a facet of the way GPG key trust is established), the important thing is that the signature of the file is validated as good—see the following screenshot for an example of the output:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/68e73909-46e1-444f-9321-e319b0c49493.png" style="width:53.00em;height:36.75em;"/></p>
<ol start="5">
<li>As long as the signature verifies successfully, the last step is to validate the actual image against the checksums themselves, with the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sha256sum -c *-CHECKSUM</strong></pre>
<p style="padding-left: 60px">You will get errors for any files that are in the <kbd>*-CHECKSUM</kbd> file that you haven't downloaded, but as you can see in the following screenshot, our downloaded image matches the checksum in the file and so we can proceed to use it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/80e48215-c119-48d2-9e3c-27370deea527.png"/></p>
<p>With these steps completed, we can proceed to use the downloaded image in our OpenStack platform. You may, of course, want to customize this image after deployment, and we will look at ways to do this later in this book. Just because you have chosen an <em>off-the-shelf</em> image does not mean it has to remain that way. Note that these steps will vary slightly for each Linux distribution, but the high-level procedure should be the same. The important thing is to validate all downloaded images.</p>
<p>There is also an issue of trust surrounding the use of publicly available operating system images. How do you know that the author removed all redundant services and sysprepped the image correctly? How do you know that there are no back doors or other vulnerabilities? Although there are many excellent publicly available images out there, you should always perform due diligence on any that you download and ensure they are fit for your environment.</p>
<p>What if you absolutely have to generate your own image, however? We will explore this in the next part of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating your own virtual machine images</h1>
                </header>
            
            <article>
                
<p>The preceding process described will be fine for many enterprises, but sooner or later, the requirement will come about to create your own completely customized virtual machine image. Fortunately, modern Linux distributions make it easy to achieve this, and you don't need to even be on the same platform as you are building.</p>
<p>Let's take a look at building a CentOS 7.6 virtual machine image using an Ubuntu 18.04 Server host:</p>
<ol>
<li>The first step before we begin is to ensure that the build host is capable of running virtual machines—this is normally a set of CPU extensions that are included with most modern x86 systems. It is also possible to build virtual machine images using nested virtualization, that is, to create a virtual machine within another virtual machine. However, to do this, you will have to enable virtualization support in your build VM. The process for this varies from one hypervisor to another, and so we will not go into detail on this here.</li>
</ol>
<div class="packt_tip">If you are using a VMware hypervisor to perform nested virtualization, you will need to enable <strong>code profiling</strong> support for the CPU as well as enabling <strong>hypervisor applications</strong><span>—</span>some of the steps in this process will fail otherwise.</div>
<ol start="2">
<li>Once you have your build host up and running, you will need to install the Linux <strong>Kernel-based Virtual Machine</strong> (<strong>KVM</strong>) toolset—the commands to do this will vary depending upon your build host version of Linux, but on our Ubuntu host, we need to run the following commands:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo apt-get install libvirt-bin libvirt-doc libvirt-clients virtinst libguestfs-tools libosinfo-bin</strong><br/><strong>$ sudo gpasswd -a &lt;your account&gt; libvirt</strong><br/><strong>$ sudo gpasswd -a &lt;your account&gt; kvm</strong><br/><strong>$ logout</strong></pre>
<p style="padding-left: 60px">Note the need to add your user account to two KVM-related groups—you will also need to log out and back in again for these group changes to take effect.</p>
<ol start="3">
<li>Once this is complete, you will also need to download a local copy of the ISO image for your chosen Linux image. I use the following command to download an ISO image as it is sufficient for the CentOS 7.6 SOE image I am going to create: </li>
</ol>
<pre style="padding-left: 60px"><strong>$ wget http://vault.centos.org/7.6.1810/isos/x86_64/CentOS-7-x86_64-Minimal-1810.iso</strong></pre>
<ol start="4">
<li>With all of these pieces in place, you will now create an empty virtual machine disk image. The best format to choose for this is the <strong>Quick Copy On Write</strong> (<strong>QCOW2</strong>) format, which is compatible with OpenStack and most public cloud platforms. Hence, we will make this image as generic as possible to enable the widest array of support possible.</li>
</ol>
<p style="padding-left: 60px">To create a blank 20 GB QCOW2 image in the current directory, we would run the following command:</p>
<pre style="padding-left: 60px"><strong>$ qemu-img create -f qcow2 centos76-soe.qcow2 20G</strong></pre>
<p>Note that other image formats are available. If, for example, you were building exclusively for VMware, it would make sense to use the VMDK format instead:</p>
<pre><strong>$ qemu-img create -f vmdk centos76-soe.vmdk 20G</strong></pre>
<p>Note that both these commands create sparse images—that is, they are only as big as the data and metadata they contain. They can be turned later into pre-allocated images by your chosen hypervisor platform if you wish:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6a50e71b-ae66-42ef-b2ec-7ea8e0f67efd.png" style="width:37.33em;height:11.42em;"/></p>
<p>With the empty disk images created, it's time to install the VM image:</p>
<ol>
<li class="mce-root"><span>We will use the</span><span> </span><kbd>virt-install</kbd><span> </span><span>command to achieve this, which basically runs up a temporary VM for OS installation. Don't worry about parameters such as CPU and memory—as long as these are sufficient for the OS installation to be run, they will be fine—they do not have any bearing on the deployed virtual machine.</span></li>
</ol>
<div class="packt_tip">Note the use of VNC in the <kbd>--graphics vnc,listen=0.0.0.0</kbd> option<span>—</span>we will use this to remotely control the virtual machine and complete the installation. You can choose another graphics option, such as SPICE, if you prefer.</div>
<ol start="2">
<li>The following command is an example of how to use <kbd>virt-install</kbd> to create a CentOS 7 image from the ISO we downloaded earlier, using the preceding 20 GB QCOW2 disk image we created:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ virt-install --virt-type kvm \</strong><br/><strong>--name centos-76-soe \</strong><br/><strong>--ram 1024 \</strong><br/><strong>--cdrom=CentOS-7-x86_64-Minimal-1810.iso \</strong><br/><strong>--disk path=/home/james/centos76-soe.qcow2,size=20,format=qcow2 \</strong><br/><strong>--network network=default \</strong><br/><strong>--graphics vnc,listen=0.0.0.0 \</strong><br/><strong>--noautoconsole \</strong><br/><strong>--os-type=linux \</strong><br/><strong>--os-variant=centos7.0 \</strong><br/><strong>--wait=-1</strong></pre>
<p style="padding-left: 60px">Most of these parameters are self-explanatory, but pay particular attention to your environment. For example, if you have edited or removed the <kbd>default</kbd> network, the preceding command will fail. Similarly, ensure the correct paths for all files referenced.</p>
<div class="packt_tip">To see the list of supported<span> </span><kbd>--os-variant</kbd><span> </span>parameters, run the <kbd>osinfo-query os</kbd> command<span>.</span></div>
<p style="padding-left: 60px">Naturally, you would vary these parameters according to the operating system you are installing, your disk image name, and so on.</p>
<ol start="3">
<li>For now, let's run this command—when successful, it should inform you that you can connect to the virtual machine console to continue:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eb890b7d-29e5-4b31-9335-642fcde2a1df.png"/></p>
<ol start="4">
<li>We will now connect to it from another shell using the<span> </span><kbd>virt-viewer</kbd><span> </span>utility:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ virt-viewer centos-76-soe</strong></pre>
<p>From here, you will install the operating system in the normal way. As we have discussed in <a href="2b6b6bcd-287a-4ce9-a2fa-1ecccf3a174b.xhtml" target="_blank">Chapter 4</a>, <em>Deployment Methodologies</em>, try to go for the most minimal install that you can. Don't worry too much about hostname and such, as these should get set later as part of the deployment process; specify the following:</p>
<ol>
<li>Choose <span class="packt_screen">KEYBOARD</span> and <span class="packt_screen">LANGUAGE SUPPORT</span> most relevant to your locale.</li>
<li>Choose the appropriate <span class="packt_screen">DATE &amp; TIME</span> settings for your country.</li>
<li>Ensure <span class="packt_screen">SOFTWARE SELECTION</span> is <span class="packt_screen">Minimal Install</span> (this is the default).</li>
<li>Set <span class="packt_screen">INSTALLATION DESTINATION</span>—there will only be one virtual hard drive attached to this VM using the preceding <kbd>virt-install</kbd> command, so this is simply a matter of selecting it.</li>
<li>Enable or disable <span class="packt_screen">KDUMP</span> as appropriate.</li>
<li>Ensure networking is enabled under <span class="packt_screen">NETWORK &amp; HOST NAME</span>.</li>
</ol>
<p>The resulting CentOS 7 installation settings screen should look something like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7ff215f0-0956-47b4-a09b-f255467de7e3.png" style="width:43.92em;height:32.08em;"/></p>
<p>Allow the installation to complete as normal, and then log into the VM you have just created. Once logged into the running VM, you should perform any and all customization that you want to appear in the final version of the VM template. In the next section of this chapter, we will go into the use of Ansible for configuring deployed virtual machines, and using it to build templates is no different—hence, to prevent overlap with later chapters, we will not go into details of Ansible configuration work here.</p>
<p>When your VM goes to reboot after the initial installation, you may find that it shuts down. If it does, you will need to<span> </span>undefine<span> </span>it using the<span> </span><kbd>virsh</kbd><span> </span>utility, and then run it again using a slight variant on our previous<span> </span><kbd>virt-install</kbd><span> </span>command, telling<span> </span><kbd>virt-install</kbd><span> </span>to boot this time from the hard drive image rather than the CD:</p>
<pre><strong>$ virsh undefine centos-76-soe</strong><br/><strong>$ virt-install --virt-type kvm \</strong><br/><strong>--name centos-76-soe \</strong><br/><strong>--ram 1024 \</strong><br/><strong>--disk path=/home/james/centos76-soe.qcow2,size=20,format=qcow2 \</strong><br/><strong>--network network=default \</strong><br/><strong>--graphics vnc,listen=0.0.0.0 \</strong><br/><strong>--noautoconsole \</strong><br/><strong>--os-type=linux \</strong><br/><strong>--os-variant=centos7.0 \</strong><br/><strong>--boot=hd</strong></pre>
<p>It is worth noting at this stage that most cloud platforms, whether OpenStack, <strong>Amazon Web Services</strong> (<strong>AWS</strong>) or otherwise, all make use of the <kbd>cloud-init</kbd> utility to perform the initial configuration of the virtual machine image once it is deployed and running. Hence, as a bare minimum, we will install this in our VM image before we shut it down. The following are the listed commands required to install this manually and, in the next section, we will turn this into an Ansible role for installation:</p>
<pre><strong>$ yum -y install epel-release</strong><br/><strong>$ yum -y install cloud-init cloud-utils-growpart dracut-modules-growroot</strong></pre>
<p>When you have completed these commands successfully, you will probably need to customize <kbd>/etc/cloud/cloud.cfg</kbd> to configure <kbd>cloud-init</kbd> for the environment you will use it in, although the default configuration serves as a good start for many environments.</p>
<div class="packt_infobox">Configuring <kbd>cloud-init</kbd> is left as an exercise for you, given the wide variety of cloud platforms.</div>
<p>Finally, when you have performed any other customization you need, you can now shut the virtual machine down. Make sure to shut it down cleanly rather than simply powering it off, as this is going to become a template to be deployed at scale.</p>
<p>Once the virtual machine has been shut down, the next step is to run <strong>system preparation</strong> (<strong>sysprep</strong>) on the image, and then to compact the sparse image file to make it as small as possible for distribution and archival. </p>
<p>The process of sysprepping is to prepare an image for deployment at scale. Hence, all uniquely identifiable parameters <span>will be wiped to produce a clean image for deployment at scale, </span>such as the following:</p>
<ul>
<li>SSH host keys</li>
<li>History files</li>
<li>Local session configuration</li>
<li>Log files</li>
<li>MAC address references in network configuration</li>
</ul>
<p>The preceding list is not exhaustive though—there are numerous items to clean up for an image to be considered truly clean and ready for deployment, and it would warrant an entire chapter by itself to explain them all. Fortunately for us, there are two commands in the suite of KVM tools that perform exactly these tasks for us:</p>
<pre><strong>$ sudo virt-sysprep -a centos76-soe.qcow2</strong><br/><strong>$ sudo virt-sparsify --compress centos76-soe.qcow2 centos76-soe-final.qcow2</strong></pre>
<p>Although the output from the first command is too lengthy to fit in a single screenshot, it shows the wide variety of tasks that are considered necessary as part of sysprep, and if you find yourself running through this process either manually or with Ansible, the<span> </span><kbd>virt-sysprep</kbd><span> </span>utility should give you a good guideline as to the tasks you should perform:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/82944a6d-dce7-43a5-b01e-f29bd8eefc68.png" style="width:34.42em;height:45.33em;"/></p>
<p>Finally, we re-sparsify the disk image, effectively compacting it for efficient storage. Note that if you get any free space warnings when running this tool (it requires a great deal of space in<span> </span><kbd>/tmp</kbd><span> </span>by default—the exact amount will be determined by the size of your virtual disk image), you should generally not ignore them, as there is a chance the utility will fill up your partition, hence stopping your build host from working correctly:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8f5bb278-21b5-4515-961a-50d27b21df6d.png" style="width:34.83em;height:13.33em;"/></p>
<p>The steps performed in this part of this chapter should work for just about any Linux distribution, being built on just about any Linux host. As ever, refer to the documentation for your preferred distribution for guidance on package names. Nonetheless, by following this process, you have now successfully built yourself a completely bespoke cloud image, which you should be able to upload to many of the popular cloud and hypervisor platforms.</p>
<p>From here, we will take a more detailed look at customizing the template with Ansible, rather than entering commands manually as we did in this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Ansible to build and standardize the template</h1>
                </header>
            
            <article>
                
<p>You should, by now, have a base Linux image for deployment in your enterprise. If you chose to download a ready-made template (or indeed, to make use of one provided by a public cloud provider), then your image will be very much a blank template, ready for customization. If you chose to build your own, then you may have already chosen to perform a small amount of customization such as the installation of<span> </span><kbd>cloud-init</kbd><span> </span>that we performed earlier. You will note, however, that we did this by hand, which is hardly along the line of the scalable, repeatable, auditable processes that we have lauded throughout the early parts of this book. As we proceed through this section of this chapter, we will take a look at how to customize a base template, regardless of its origin, using Ansible.</p>
<p>There is no one-size-fits-all Linux image that will suit everyone, and as a result, this chapter is not definitive. We will, however, look at some of the more common tasks that might be associated with customizing as an image for deployment, such as the following:</p>
<ul>
<li>Transferring files into the image</li>
<li>Installing packages</li>
<li>Editing configuration files</li>
<li>Validating the image</li>
</ul>
<p>Through a combination of these examples, most readers should be able to customize their own images to their requirements with ease. Let's start exploring this in greater depth with a look at how to transfer files into the virtual machine image we created previously using Ansible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Transferring files into the image</h1>
                </header>
            
            <article>
                
<p>It is commonplace, in the experience of the author, to need to <em>inject</em> files into an operating system image to ensure it meets a given set of requirements. These files might be a simple text file, such as an enterprise-standard <em>message of the day</em>, a configuration file for an existing package, or perhaps even a binary file that is not available in a package. Ansible can handle all of these with ease, so let's look at some specific examples. As it is generally good practice to write your Ansible code in roles to support reuse and readability, we will define a role for our example here. In this example, I am making the following assumptions:</p>
<ul>
<li>We have downloaded/built our Linux template as outlined in the previous section of this chapter.</li>
<li>We are running this bare template in a virtual machine.</li>
<li>The IP address of this virtual machine is <kbd>192.168.81.141</kbd>.</li>
<li>The virtual machine has a user account already set up with the following credentials:
<ul>
<li>Username:<span> </span><kbd>imagebuild</kbd>.</li>
<li>Password:<span> </span><kbd>password</kbd>.</li>
<li>This account is sudo-enabled.</li>
</ul>
</li>
</ul>
<p>Naturally, we would not distribute a cloud image with a sudo-enabled account that uses a weak password like this, so we are assuming we will use this account during the build phase only and then will remove it during the cleanup phase. Ansible needs to be able to connect to a remote host to perform its magic, but the account it uses can be transient in nature and removed after use:</p>
<ol>
<li>Under our example, we would create an inventory file that looks like this—yours will undoubtedly be different and customizing it for your image and environment is left as an exercise for you:</li>
</ol>
<pre style="padding-left: 60px">[imagesetup]<br/>192.168.81.141<br/><br/>[imagesetup:vars]<br/>ansible_user=imagebuild<br/>ansible_password=password<br/>ansible_sudo_pass=password</pre>
<p style="padding-left: 60px">This is a very simple example; in many ways, it is the bare minimum needed for this process when we do not have SSH key authentication configured. Often SSH keys are the best way to handle SSH authentication as they offer several benefits, not least that tasks can run without a password prompt.</p>
<div class="packt_tip">Although this inventory file is intended to be transient in nature, it is still best practice to use <kbd>ansible-vault</kbd> to store passwords and this is recommended here. For the sake of simplicity in this chapter and to reduce the number of steps that you need to complete, we will leave the passwords unencrypted (in cleartext).</div>
<ol start="2">
<li>Next, we'll create the basic directory structure for our role:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ mkdir -p roles/filecopyexample/tasks</strong><br/><strong>$ mkdir -p roles/filecopyexample/files</strong></pre>
<ol start="3">
<li>Now, let's create a few sample files to copy across. First of all, create a customized message to append to the message of the day in<span> </span><kbd>roles/filecopyexample/files/motd</kbd>:</li>
</ol>
<pre style="padding-left: 60px">------------------------<br/>Enteprise Linux Template<br/>Created with Ansible<br/>------------------------</pre>
<ol start="4">
<li>Let's also create a new configuration file for the<span> </span><kbd>chrony</kbd><span> </span>service to synchronize time to our corporate time servers in<span> </span><kbd>roles/filecopyexample/files/chrony.conf</kbd>:</li>
</ol>
<pre style="padding-left: 60px">pool ntp.example.com iburst maxsources 4<br/><br/>keyfile /etc/chrony/chrony.keys<br/><br/>driftfile /var/lib/chrony/chrony.drift<br/><br/>logdir /var/log/chrony<br/><br/>maxupdateskew 100.0<br/><br/>rtcsync<br/><br/>makestep 1 3</pre>
<p>We intend to copy these two files across to the remote server. However, Ansible is not limited to copying files from the Ansible host—it can also download files from a remote server directly to the target host:</p>
<ol>
<li>Let's suppose your build is going to need<span> </span><kbd>docker-compose</kbd><span>—</span>we could download this from an internal server, or even directly from the internet if your image machine has access to the internet. Suppose we want to install<span> </span><kbd>docker-compose</kbd><span> </span>1.18.0 into our images, we can instruct Ansible to download this directly from <a href="https://github.com/docker/compose/releases/download/1.18.0/docker-compose-Linux-x86_64">https://github.com/docker/compose/releases/download/1.18.0/docker-compose-Linux-x86_64</a>.</li>
<li>Now, let's build our role to copy across our two files and download<span> </span><kbd>docker-compose</kbd><span> </span><span>into our image—this must be written in</span><span> </span><kbd>roles/filecopyexample/tasks/main.yml</kbd><span>. The first part of this role is shown in the following code, and serves to copy across the two configuration files we discussed earlier:</span></li>
</ol>
<pre style="padding-left: 60px">---<br/>- name: Copy new MOTD file, and backup any existing file if it             exists<br/>  copy:<br/>    src: files/motd<br/>    dest: /etc/motd<br/>    owner: root<br/>    group: root<br/>    mode: '0644'<br/>    backup: yes<br/>- name: Copy across new chrony configuration, and backup any existing file if it exists<br/>  copy:<br/>    src: files/chrony.conf<br/>    dest: /etc/chrony.conf<br/>    owner: root<br/>    group: root<br/>    mode: '0644'<br/>    backup: yes</pre>
<p style="padding-left: 60px">The role then continues, with the task of installing <kbd>docker-compose</kbd> on the VM image:</p>
<pre style="padding-left: 60px">- name: Install docker-compose 1.18.0<br/>  get_url:<br/>    url: https://github.com/docker/compose/releases/download/1.18.0/docker-compose-Linux-x86_64<br/>    dest: /usr/local/bin/docker-compose<br/>    mode: 0755<br/>    owner: root<br/>    group: root</pre>
<p style="padding-left: 60px">Hence, our role is now complete, though be sure to customize it correctly for your environment. For example, it is likely a newer version of <kbd>docker-compose</kbd> might be available and this will mean a change to the <kbd>url</kbd> parameter of the preceding <kbd>get_url</kbd> module.</p>
<div class="packt_tip">The path of the <kbd>chrony</kbd> configuration file may vary depending on your operating system<span>—</span>check this before running the preceding playbook. <span>The path shown in the example is suitable for a CentOS 7 system like the one we built earlier.</span></div>
<ol start="3">
<li>Finally, we will create a file in the top-level directory (where the<span> </span><kbd>roles/</kbd><span> </span>directory was created) called <kbd>site.yml</kbd> to call and run this role. This should contain the following:</li>
</ol>
<pre style="padding-left: 60px">---<br/>- name: Run example roles<br/>  hosts: all<br/>  become: yes<br/><br/>  roles:<br/>    - filecopyexample</pre>
<ol start="4">
<li>Finally, let's run our example with the <kbd>ansible-playbook -i hosts site.yml</kbd><span> </span>command and see what happens:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/95176795-3eef-4217-91fa-9184a6a6388f.png" style="width:52.00em;height:39.25em;"/></p>
<p>As we can see, the<span> </span><kbd>changed</kbd><span> </span>statuses tell us that all three of our files were transferred or downloaded successfully, and by way of example, we can see that it is now possible to run<span> </span><kbd>docker-compose</kbd>,<span> </span>which was installed during the playbook run (though this would require Docker to run correctly, which we have not installed as part of this example).</p>
<p>Obviously this example has made a fundamental assumption<span>—</span>that the<span> </span><kbd>chrony</kbd><span> </span>package was installed on our example image during the build phase. Although it makes sense to start with a minimal operating system image for the reasons we have discussed previously, there is almost certainly going to be a requirement to install a few supplemental packages on the basic build, and we will explore this in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing packages</h1>
                </header>
            
            <article>
                
<p>We have looked at how to install a standalone binary such as<span> </span><kbd>docker-compose</kbd><span> </span>in the previous section<span>—</span>but what if we need to actually install some additional operating system packages that were not installed in our base image? For example,<span> </span><kbd>cloud-init</kbd><span> </span>is incredibly useful in most cloud environments but was not included in our minimal CentOS 7 install that we performed earlier.</p>
<p>Here, again, Ansible can help<span>—</span>this time, we will <span>define a role to install the packages we require. We'll reuse the inventory file from the previous section and create a new role called</span><span> </span><kbd>packageinstall</kbd><span> </span><span>in the same manner that we did before: </span></p>
<ol>
<li>Now, the preceding example on copying files would work on all Linux distributions—the only thing you need to be mindful of is where destination files might life. For example, our CentOS 7 VM image will have the <kbd>chrony</kbd> configuration file installed in<span> </span><kbd>/etc/chrony.conf</kbd>, whilst an Ubuntu 18.04 LTS server would have it in<span> </span><kbd>/etc/chrony/chrony.conf</kbd>. Apart from this small change to the<span> </span><kbd>dest:</kbd><span> </span>parameter of the<span> </span><kbd>copy</kbd><span> </span>module, the code would remain the same.</li>
</ol>
<p style="padding-left: 60px">Unfortunately, it gets a little more complex with package installation.</p>
<ol start="2">
<li>Let's suppose we want to install<span> </span><kbd>cloud-init</kbd><span> </span>and<span> </span><kbd>docker</kbd><span> </span>on our CentOS 7 example image—the role required to do this might look like this:</li>
</ol>
<pre style="padding-left: 60px">---<br/>- name: Install the epel-release package<br/>  yum:<br/>    name: epel-release<br/>    state: present<br/><br/>- name: Install cloud-init and docker<br/>  yum:<br/>    name: "{{ item }}"<br/>    state: present<br/>  loop:<br/>    - cloud-init<br/>    - docker</pre>
<ol start="3">
<li>We must install the EPEL repository first, and then we can install the required packages. When we run it, the output should look something like this:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/118e82be-2c14-41ed-85f8-006698478d55.png" style="width:56.92em;height:29.25em;"/></p>
<p>If you are using a different Linux distribution, then you need to vary the package manager accordingly. For example, on distributions that use the <kbd>apt</kbd> package manager such as Debian or Ubuntu, the equivalent Ansible role would look like the following block of code:</p>
<pre>---<br/>- name: Install cloud-init and docker<br/>  apt:<br/>    name: "{{ item }}"<br/>    state: present<br/>  loop:<br/>    - cloud-init<br/>    - docker.io</pre>
<p>Note the change in module from<span> </span><kbd>yum</kbd><span> </span>to<span> </span><kbd>apt</kbd>, and the different package name used for the Docker container service. Other than that, the playbook is almost identical.</p>
<p>We can improve on this further—this different results in the need to maintain two different roles for two different operating system bases—but what if we could intelligently combine them into one? Fortunately, the facts that Ansible gathers when it first runs can be used to identify the operating system and, as such, run the correct code.</p>
<p class="mce-root"/>
<p>We will repurpose our earlier example code to combine both of these installations into one Ansible role:</p>
<ol>
<li>The first part of the code is almost identical to the preceding example, except that we have now specified the <kbd>when</kbd> clause to ensure it is only run on Debian- or Ubuntu-based Linux distributions:</li>
</ol>
<pre style="padding-left: 60px">---<br/>- name: Install cloud-init and docker<br/>  apt:<br/>    name: "{{ item }}"<br/>    state: present<br/>  loop:<br/>    - cloud-init<br/>    - docker.io<br/>  when: ansible_distribution == 'Debian' or ansible_distribution == 'Ubuntu'</pre>
<ol start="2">
<li>We then add two further tasks that perform the required steps to install Docker on CentOS or Red Hat Enterprise Linux:</li>
</ol>
<pre style="padding-left: 60px">- name: Install the epel-release package<br/>  yum:<br/>    name: epel-release<br/>    state: present<br/>  when: ansible_distribution == 'CentOS' or ansible_distribution == 'Red Hat enterprise Linux'<br/><br/>- name: Install cloud-init and docker<br/>  yum:<br/>    name: "{{ item }}"<br/>    state: present<br/>  loop:<br/>    - cloud-init<br/>    - docker<br/>  when: ansible_distribution == 'CentOS' or ansible_distribution == 'Red Hat enterprise Linux'</pre>
<p style="padding-left: 60px">Notice again the<span> </span><kbd>when</kbd><span> </span>clauses under each task—these specific examples are used to determine whether the tasks should be run depending on the facts that Ansible obtained during the initial part of the run. Hence, if we now run this role on an Ubuntu system, we see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/310c40fb-430c-4466-b821-3344f81faa97.png" style="width:45.25em;height:27.75em;"/></p>
<ol start="3">
<li>As you can see, the first task related to<span> </span><kbd>apt</kbd><span> </span>was run, but the two following ones based on<span> </span><kbd>yum</kbd><span> </span>were skipped because the conditions of the <kbd>when</kbd> clause were not met. Now, if we run it on a CentOS 7 target instead, we see this:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/03714111-8f66-426d-9fe6-a83fe2a30983.png" style="width:41.75em;height:25.75em;"/></p>
<p>The inverse is now true: the<span> </span><kbd>apt</kbd><span> </span>task was skipped, but the two<span> </span><kbd>yum</kbd><span> </span>related tasks were run. In this way, it is possible to maintain a single role for installing a common set of package requirements, even when dealing with several different base operating systems. Combining <kbd>when</kbd> clauses with Ansible facts is a very powerful way to ensure the correct behavior of a single code base across a variety of systems, and hence if your SOE does extend to both Debian and Red Hat-based systems, you can still maintain code with ease and simplicity. </p>
<p>Once supplemental packages have been installed, they often must be configured for them to be useful. In the next section, we will explore the use of Ansible in editing configuration files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Editing configuration files</h1>
                </header>
            
            <article>
                
<p>So far, all of the configuration work we have performed has been very black and white<span>—</span>we are either installing something (be that a file or a package), or we could equally and just as easily delete it (more on this in the section on cleaning up). However, what if something more subtle is required? Earlier in this chapter, in the section entitled <em>Transferring files into the image</em>, we replaced the entire<span> </span><kbd>chrony.conf</kbd><span> </span>file with our own version. This, however, might be a bit too much brute force—for example, we might only need to change one line in a file, and replacing the entire file to change one line is a bit heavy-handed, especially when you consider that the configuration file might get updated in a future package version.</p>
<p>Let's take another common operating system image configuration requirement: SSH daemon security. By default, CentOS 7 installations like the one we created earlier allow remote logins from the<span> </span>root<span> </span>account. This is not desirable for security reasons, so the question is, how do we update the SSH daemon configuration without having to replace the entire file? Luckily, Ansible has modules for just such a task. </p>
<p>To perform this task, the<span> </span><kbd>lineinfile</kbd><span> </span>module will come in handy. Consider the following role, which we'll call<span> </span><kbd>securesshd</kbd>:</p>
<pre>---<br/>- name: Disable root logins over SSH<br/>  lineinfile:<br/>    dest: /etc/ssh/sshd_config<br/>    regexp: "^PermitRootLogin"<br/>    line: "PermitRootLogin no"<br/>    state: present</pre>
<p>Here, we are using the<span> </span><kbd>lineinfile</kbd><span> </span>module to process the<span> </span><kbd>/etc/ssh/sshd_config</kbd><span> </span>file. We are telling it to look for lines beginning with<span> </span><kbd>PermitRootLogin</kbd> (this prevents us from accidentally editing commented-out lines), and then to replace this line with<span> </span><kbd>PermitRootLogin no</kbd>.</p>
<p>Let's try that against a CentOS 7 test system:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/af064e87-0bc9-496d-847b-5ab293aaf16b.png" style="width:35.92em;height:14.92em;"/></p>
<p>This works just as desired. Regular expressions require a great deal of care though. For example, the SSH daemon will process configuration lines that contain whitespace at the beginning of the line. However, our simple regular expression in the preceding code does not take account of whitespace, and so could easily miss an otherwise valid SSH configuration directive. To craft regular expressions that take account of all possible situations and permutations of a file is an art in itself and so caution is most definitely advised in their creation and use.</p>
<div class="packt_tip">Note that, on a live system, you would also need to restart the SSH service to make this change effective; however, as this is an image that we will clean up and then shut down for future deployment, there is no need to do this here.</div>
<p>A halfway house between uploading an entire file and editing an existing one is the use of templates. Ansible Jinja2 templating is incredibly powerful and very useful where files might have to have contents that vary with some variable parameter.</p>
<p>Consider again our<span> </span><kbd>chrony</kbd><span> </span><span>configuration example from earlier—here, we transferred a static file with a hardcoded NTP server address. This is fine if your enterprise relies on a static NTP server (or a set of them), but some will rely on different NTP servers depending on where the image is to be deployed.</span></p>
<p><span>Let's demonstrate this with a new role called </span><kbd>templatentp</kbd>. For this, we will define a templates directory in<span> </span><kbd>roles/templatentp/templates</kbd><span> </span>and place into it a file called<span> </span><kbd>chrony.conf.j2</kbd><span> </span>with the following contents:</p>
<pre>pool {{ ntpserver }} iburst maxsources 4<br/><br/>keyfile /etc/chrony/chrony.keys<br/><br/>driftfile /var/lib/chrony/chrony.drift<br/><br/>logdir /var/log/chrony<br/><br/>maxupdateskew 100.0<br/><br/>rtcsync<br/><br/>makestep 1 3</pre>
<p>Notice that the file is almost identical to the previous example, except that we now have an Ansible variable name in place of the static hostname on the first line of the file.</p>
<p>Let's create the <kbd>main.yml</kbd> file for the role as follows:</p>
<pre>---<br/>- name: Deploy chrony configuration template<br/>  template:<br/>    src: templates/chrony.conf.j2<br/>    dest: /etc/chrony.conf<br/>    owner: root<br/>    group: root<br/>    mode: '0644'<br/>    backup: yes</pre>
<p>Notice how similar it is to the<span> </span><kbd>copy</kbd><span> </span>example. Our<span> </span><kbd>site.yml</kbd><span> </span>is also only slightly different—in it, we will define the variable with the NTP server hostname. There are many places in Ansible where this variable could be defined, and it is left to the user to figure out the best place for them to define it:</p>
<pre>---<br/>- name: Run example roles<br/>  hosts: all<br/>  become: yes<br/><br/>  vars:<br/>    ntpserver: time.example.com<br/><br/>  roles:<br/>    - templatentp</pre>
<p>Finally, we can run the playbook and see the results:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7de0ec1f-25fc-4092-b80c-ebeb2e8d8f65.png" style="width:37.17em;height:15.33em;"/></p>
<p>In this way, Ansible provides you with powerful tools to not only copy or download entire configurations into place, but also to manipulate existing ones to suit your environment. Let's suppose that our image is now complete. We could take this on faith, but good practice suggests we should always test the result of any build process, especially an automated one. Thankfully, Ansible can help us to validate the image we have created according to our requirements, and we will explore this in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validating the image build</h1>
                </header>
            
            <article>
                
<p>As well as installing and configuring your image, you might also wish to verify that certain components that are critical, and that you assume to be present, are actually present. This is especially true when you download an image that was created by someone else.</p>
<p>There are many ways to perform this task in Ansible—let's take a simple example. Suppose you have an archival script that makes use of the<span> </span><kbd>bzip2</kbd><span> </span>compression utility to compress files. This is just a small tool but if you rely on it for certain purposes, your scripts would break if it was not present. It is also a pertinent example, as the minimal install of CentOS 7 (as we performed earlier) does not actually include it!</p>
<p>How can Ansible solve this problem? There are two approaches we can take. First of all, we know from our earlier background work on Ansible that most modules are idempotent<span>—</span>that is, they are designed to achieve a desired state on the target host and not repeat actions that have already been performed.</p>
<p>Hence, we could have very easily included a role such as this in our configuration playbook:</p>
<pre>---<br/>- name: Ensure bzip2 is installed<br/>  yum:<br/>    name: bzip2<br/>    state: present</pre>
<p>When this role is run and<span> </span><kbd>bzip2</kbd><span> </span>is not installed, it will perform the installation and return the result<span> </span><kbd>changed</kbd>. When it detects that<span> </span><kbd>bzip2</kbd><span> </span>is installed, it will return<span> </span><kbd>ok</kbd><span> </span>and perform no further actions. However, what if we truly want to check for something rather than just perform an action, perhaps as a post-build step? Later in this book, we'll look at more detailed ways of auditing systems, but for now, let's further this example with Ansible.</p>
<p>If you were using shell commands, you would check for the presence of<span> </span><kbd>bzip2</kbd><span> </span>in one of two ways, that is, query the RPM database to see whether the<span> </span><kbd>bzip2</kbd><span> </span>package is installed or check for the presence of<span> </span><kbd>/bin/bzip2</kbd><span> </span>on the filesystem.</p>
<ol>
<li>Let's look at the latter example in Ansible. The Ansible<span> </span><kbd>stat</kbd><span> </span>module can be used to verify the existence of a file. Consider the following code, which we'll create in a role called<span> </span><kbd>checkbzip2</kbd><span> </span>in the usual manner:</li>
</ol>
<pre style="padding-left: 60px">---<br/>- name: Check for the existence of bzip2<br/>  stat:<br/>    path: /bin/bzip2<br/>  register: bzip2result<br/>  failed_when: bzip2result.stat.exists == false<br/><br/>- name: Display a message if bzip2 exists<br/>  debug:<br/>    msg: bzip2 installed.</pre>
<p style="padding-left: 60px">Here, we are using the<span> </span><kbd>stat</kbd><span> </span>module to tell us about the <kbd>/bin/bzip2</kbd><span> </span><span>file</span><span> </span><span>(if it exists). We</span><span> </span><kbd>register</kbd><span> </span><span>the result of the module</span> run i<span>n a variable called</span><span> </span><kbd>bzip2result</kbd><span>, and then we define a custom failure condition on the task that will cause it to fail (and hence fail the entire the playbook run) if the file does not exist. Note that when a failure condition is encountered, Ansible halts the entire playbook run, forcing you to address the issue before continuing. Obviously, this may or may not be the behavior you desire, but it is easy to vary the failure condition accordingly.</span></p>
<ol start="2">
<li>Let's take a look at this in action:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3d627adc-f501-46ab-a37b-6474a298e5a7.png" style="width:33.58em;height:14.75em;"/></p>
<p style="padding-left: 60px">As you can see, the debug statement was never run because of the failure encountered. Hence, we can be absolutely sure when running this role that our image is going to have<span> </span><kbd>bzip2</kbd><span> </span>installed—if it doesn't, our playbook will fail.</p>
<ol start="3">
<li>Once<span> </span><kbd>bzip2</kbd><span> </span>is installed, the run looks quite different:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/85c4f010-3e8f-4b78-9f21-b39d247d77f2.png" style="width:31.17em;height:16.92em;"/></p>
<p class="mce-root"/>
<p>This is quite definitive in its behavior, which is exactly what we would want. Ansible is not just limited to checking for files though—we could also check that our<span> </span><kbd>sshd_config</kbd><span> </span>file has the<span> </span><kbd>PermitRootLogin no</kbd><span> </span>line we looked at earlier:</p>
<ol>
<li>We could do this with a role as follows:</li>
</ol>
<pre style="padding-left: 60px">---<br/>- name: Check root login setting in sshd_config<br/>  command: grep -e "^PermitRootLogin no" /etc/ssh/sshd_config<br/>  register: grepresult<br/>  failed_when: grepresult.rc != 0<br/><br/>- name: Display a message if root login is disabled<br/>  debug:<br/>    msg: root login disabled for SSH</pre>
<ol start="2">
<li>Now, running this when the setting is not in place again yields a failure:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/05d02a35-5796-4186-9d62-3dbdcce8cb43.png" style="width:51.25em;height:26.17em;"/></p>
<ol start="3">
<li>Yet if we put this setting in place, we see the following:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a643a45e-26cb-4d34-8b7c-a0ea4317a81b.png" style="width:34.33em;height:18.50em;"/></p>
<p>Again, it's very definitive. Note the<span> </span><kbd>changed</kbd><span> </span>status in the preceding output—this is so because we used the <kbd>command</kbd> module, which successfully ran <kbd>command</kbd><span>—</span>hence, it always returns<span> </span><kbd>changed</kbd>. We could alter this behavior with a<span> </span><kbd>changed_when</kbd><span> </span>clause to this task if we wanted.</p>
<p>In this manner, Ansible playbooks can be put together that not only customize your build but also validate the end result. This is especially useful for testing purposes, and where security is a consideration.</p>
<p>Before completing this chapter, let's take a look, in the next section, at how we pull together all of the disparate roles and pieces of code we have discussed so far to form a cohesive automated solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Putting it all together</h1>
                </header>
            
            <article>
                
<p>Throughout this section of this chapter, you will note that we have used roles for all of our examples. Naturally, when it comes to building out your final image, you don't want to end up running lots of playbooks individually as we have done here. Luckily, if we were to combine everything, all we would need to do is put all of the roles together in the<span> </span><kbd>roles/</kbd><span> </span>subdirectory, and then reference them all in the<span> </span><kbd>site.yml</kbd><span> </span>playbook. The <kbd>roles</kbd> directory should look something like this:</p>
<pre>~/hands-on-automation/chapter05/example09/roles&gt; tree -d<br/>.<br/>├── checkbzip2<br/>│   └── tasks<br/>├── checksshdroot<br/>│   └── tasks<br/>├── filecopyexample<br/>│   ├── files<br/>│   └── tasks<br/>├── installbzip2<br/>│   └── tasks<br/>├── packageinstall<br/>│   └── tasks<br/>├── securesshd<br/>│   └── tasks<br/>└── templatentp<br/>    ├── tasks<br/>    └── templates</pre>
<p>Then, our<span> </span><kbd>site.yml</kbd><span> </span>file will look like this:</p>
<pre>---<br/>- name: Run example roles<br/>  hosts: all<br/>  become: yes<br/><br/>  roles:<br/>    - filecopyexample<br/>    - packageinstall<br/>    - templatentp<br/>    - installbzip2<br/>    - securesshd<br/>    - checkbzip2<br/>    - checksshdroot</pre>
<p>Running this code is left as an exercise for the reader, as we have already run all of the component parts earlier in this chapter. However, if all goes well then, when all roles have completed, there should be no<span> </span><kbd>failed</kbd><span> </span>statuses—just a mixture of<span> </span><kbd>changed</kbd><span> </span>and<span> </span><kbd>ok</kbd>.</p>
<p>If you have run through the process of post-build customization, as detailed in this chapter, the resulting image will likely need cleaning up a second time. We could resort to the <kbd>virt-sysprep</kbd> command again, however, Ansible can help us here too. In the next section, we will explore the use of Ansible for cleaning up images for large scale deployment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cleaning up the build with Ansible</h1>
                </header>
            
            <article>
                
<p>By now, you should have a pretty good idea of how to build or validate a base image, and then customize it with Ansible. Before we close this chapter, it is worth revisiting the task of cleaning up your image for deployment. Whether you have built an image from scratch or downloaded a ready-made one, if you have booted it up and run commands on it, either manually or using Ansible, you are likely to have a whole load of items that you really don't want present every time you deploy the image. For example, do you really want all of the system log files from every configuration task you performed and the initial boot to be present on every single virtual machine deployed? If you had to run any commands by hand (even if it was to set up authentication to allow Ansible to run), do you want those commands in the<span> </span><kbd>.bash_history</kbd><span> </span>file of the account you ran them in on every deployment?</p>
<p>The answer to these is, of course, no. Then there are those files that could actually cause problems if cloned—for example, duplicate SSH host keys or MAC address-specific configurations such as<span> </span><kbd>udev</kbd><span> </span>configuration data. All of this should be cleaned out before you consider the image ready for distribution.</p>
<p>Ansible can help with this task too, although it is recommended that you use the<span> </span><kbd>virt-sysprep</kbd><span> </span>tool that we demonstrated earlier in this chapter, as this takes care of all of these steps for you. There might be a reason why you don't want to use this tool<span>—</span>perhaps you don't have access to it in your environment, or there isn't a build for your preferred distribution of Linux. In this instance, you can use Ansible to perform the final cleanup. The great thing about Ansible is that you can use the built-in modules, as we have demonstrated so far in this chapter, but you can equally use raw shell commands—this can be especially useful when you need to perform wildcard operations across a filesystem.</p>
<p>The following is an example of a role that relies on raw shell commands to clean up an image in preparation for deployment. It is not as complete as the job performed by<span> </span><kbd>virt-sysprep</kbd>, but does serve as a good example of how this could be performed using Ansible. Note that this example is specific to CentOS 7—if using a different operating system, then it will be necessary to change paths, package database cleanup commands, and so on. Hence, this playbook is presented to the reader very much as a practical example of how the cleanup could be performed in Ansible, though it is intended that the reader takes this further depending on their own requirements. First of all, we clean out the package database, as this data need not be replicated across deployments:</p>
<pre>---<br/>- name: Clean out yum cache<br/>  shell: yum clean all</pre>
<p class="mce-root"/>
<p>We then continue by clearing out the logs—this is achieved by stopping the logging daemon, forcing a rotation of the logs, and then recursively deleting the directory containing them:</p>
<pre>- name: Stop syslog<br/>  shell: service rsyslog stop<br/><br/>- name: Force log rotation<br/>  shell: /sbin/logrotate -f /etc/logrotate.conf<br/>  ignore_errors: yes<br/><br/>- name: Clean out logs<br/>  shell: /bin/rm -f /var/log/*-???????? /var/log/*.gz /var/log/*.[0-9] /var/log/**/*.gz /var/log/**/*.[0-9]<br/><br/>- name: Truncate log files<br/>  shell: truncate -s 0 /var/log/*.log<br/><br/>- name: Truncate more logs<br/>  shell: truncate -s 0 /var/log/**/*.log<br/><br/>- name: Clear the audit log<br/>  shell: /bin/cat /dev/null &gt; /var/log/audit/audit.log<br/><br/>- name: Clear wtmp<br/>  shell: /bin/cat /dev/null &gt; /var/log/wtmp</pre>
<p>We then clear our hardware and MAC address-specific configurations that would be invalid on a deployed VM image:</p>
<pre>- name: Remove the udev persistent device rules<br/>  shell: /bin/rm -f /etc/udev/rules.d/70*<br/><br/>- name: Remove network related MAC addresses and UUID's<br/>  shell: /bin/sed -i '/^\(HWADDR\|UUID\)=/d' /etc/sysconfig/network-scripts/ifcfg-*</pre>
<p>Following this, we clear out<span> </span><kbd>/tmp</kbd> and remove any history files from user home directories. The following example is not complete, but does show some pertinent examples:</p>
<pre>- name: Clear out /tmp<br/>  shell: /bin/rm -rf /tmp/* /var/tmp/*<br/><br/>- name: Remove user history<br/>  shell: /bin/rm -f ~root/.bash_history /home/**/.bash_history<br/><br/>- name: Remove any viminfo files<br/>  shell: rm -f /root/.viminfo /home/**/.viminfo<br/><br/>- name: Remove .ssh directories<br/>  shell: rm -rf ~root/.ssh m -rf /home/**/.ssh</pre>
<p>Finally, we perform our final task—in this case, the removal of the SSH host keys. Note that following this, we also shut down the VM—this is performed as part of this command to prevent accidental creation of any additional history or logging data. Note also the<span> </span><kbd>ignore_errors</kbd><span> </span>clause, which prevents the playbook from failing when the shutdown occurs and the SSH connection is terminated:</p>
<pre>- name: Remove SSH keys and shut down the VM (this kills SSH connection)<br/>  shell: /bin/rm -f /etc/ssh/*key* &amp;&amp; shutdown -h now<br/>  ignore_errors: yes</pre>
<p>Running this code on a CentOS 7 VM will result is a fairly well-cleaned image, but there are specifics not covered here. For example, we have cleared out all bash history, but if any alternate shells were used, their data would not be cleaned. Similarly, we have cleaned out VIM application data from root's home directory, but not any other applications that may or may not have been used during the image creation. Hence, it is up to you to extend this role as you require in your environment.</p>
<p>By this stage, you will have run through the entire process, end-to-end, of creating, customizing, and cleaning up a Linux operating system for our proposed SOE. Effective use of Ansible means that the entire process can be automated, and hence enables us to make a strong start toward automation in the enterprise. All that remains is to deploy the template we have created into your environment, and from here, you can clone it and build on it to your heart's content.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We have seen several hands-on examples of how to obtain or build Linux virtual machine images for use in a wide variety of scenarios and environments. We have seen how Ansible lends itself to automating this process, and hence how it complements the image build process to support the good practices we have previously discussed for automation in the enterprise and, in particular, the creation and management of an SOE.</p>
<p>In this chapter, you learned how to build Linux images for templating purposes and indeed obtain and verify ready-made ones. You then learned through practical examples how to customize these template images with Ansible, covering key concepts such as package installation and configuration file management. Finally, you learned how to ensure that image builds are clean and tidy and do not contain data that would either be wasteful or harmful to replicate across and infrastructure.</p>
<p>In the next chapter of this book, we will look at how to create standardized images for use on bare metal servers and in some traditional virtualization environments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the purpose of system preparation (sysprep)?</li>
<li>When would you need to make use of Ansible facts in your roles?</li>
<li>How would you deploy a new configuration file to a virtual machine image using Ansible?</li>
<li>Which Ansible module is used to download a file from the internet directly into a virtual machine image?</li>
<li>How would you write a single Ansible role that will install packages on both Ubuntu and CentOS?</li>
<li>Why would you wish to validate an ISO image you have downloaded?</li>
<li>How does the use of Ansible roles at this stage benefit the environment once it is deployed?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><span>For an in-depth understanding of Ansible, please refer to </span><em>Mastering Ansible</em>, <em>Third Edition</em> by <em>James Freeman</em> and <em>Jesse Keating</em>, available at <a href="https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition">https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition</a></li>
<li>For more details on the use of KVM for virtualization on Linux, please refer to <em>Mastering KVM Virtualization</em> by <em>Prasad Mukhedkar</em>, <em>Anil Vettathu</em>, <em>Humble Devassy Chirammal</em>, available at <a href="https://www.packtpub.com/gb/networking-and-servers/mastering-kvm-virtualization">https://www.packtpub.com/gb/networking-and-servers/mastering-kvm-virtualization</a></li>
</ul>


            </article>

            
        </section>
    </body></html>