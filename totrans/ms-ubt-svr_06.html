<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer085">
<h1 class="chapterNumber">6</h1>
<h1 class="chapterTitle" id="_idParaDest-91">Boosting Your Command-line Efficiency</h1>
<p class="normal">Throughout this book, we’ve been using the command line quite heavily. Using the shell, we’ve installed packages, created users, edited configuration files, and more. In the last chapter, we took a look at file management to enhance our terminal skills further. This time around, we’ll dedicate an entire chapter to the shell, with the goal of becoming more efficient with it. Here, we’ll take what we already know and add some useful time-saving tips, some information on looping, variables, and we’ll even look into writing scripts.</p>
<p class="normal">In this chapter, we will cover the following topics:</p>
<ul>
<li class="bulletList">Understanding the Linux shell</li>
<li class="bulletList">Understanding Bash history</li>
<li class="bulletList">Learning some useful command-line tricks</li>
<li class="bulletList">Understanding variables</li>
<li class="bulletList">Writing simple scripts</li>
<li class="bulletList">Putting it all together: Writing an <code class="inlineCode">rsync</code> backup script</li>
</ul>
<p class="normal">Let’s begin this chapter with further discussion regarding the Linux shell, which will help us better understand how we’re interacting with the server while we enter commands.</p>
<h1 class="heading-1" id="_idParaDest-92">Understanding the Linux shell</h1>
<p class="normal">When it comes <a id="_idIndexMarker315"/>to the Linux shell, it’s important to understand what exactly the term pertains to. We’ve been using the command line repeatedly throughout the book, but we haven’t yet had any formal discussion about the actual interface through which our commands are entered.</p>
<p class="normal">Essentially, we’ve been entering our commands into a command interpreter known as the <strong class="keyWord">Bourne Again Shell</strong>, or<a id="_idIndexMarker316"/> simply <strong class="keyWord">Bash</strong>. Bash<a id="_idIndexMarker317"/> is just one of many different <em class="italic">shells</em> that you can use to enter commands. </p>
<p class="normal">There are other options, including <strong class="keyWord">Zsh</strong>, <strong class="keyWord">Fish</strong>, and <strong class="keyWord">ksh</strong>, but<a id="_idIndexMarker318"/> Bash <a id="_idIndexMarker319"/>is<a id="_idIndexMarker320"/> the default command shell for the majority of Linux distributions. It’s even available on macOS (although the default on that platform is Zsh nowadays), as well as on Windows by installing the Windows Subsystem for Linux. Therefore, by understanding the basics of Bash, your knowledge will be compatible with other distributions and platforms. While it’s fun to learn other shells such as Zsh, Bash is definitely the one to focus the most attention on if you’re just starting.</p>
<p class="normal">You may wonder, then, where you configure the shell that your user account will use. If you recall from <em class="chapterRef">Chapter 2</em>, <em class="italic">Managing Users and Permissions</em>, we looked at the <code class="inlineCode">/etc/passwd</code> file. As I’m sure you remember, this file keeps a list of user accounts available on the system. Go<a id="_idIndexMarker321"/> ahead and take a look at this file to refresh yourself by entering the following command:</p>
<pre class="programlisting con"><code class="hljs-con">cat /etc/passwd
</code></pre>
<p class="normal">This will produce an output like the one shown in <em class="italic">Figure 6.1</em>:</p>
<figure class="mediaobject"><img alt="Text  Description automatically generated" height="208" src="../Images/B18425_06_01.png" width="755"/></figure>
<p class="packt_figref">Figure 6.1: The last several lines of a sample /etc/passwd file</p>
<p class="normal">See the last field in every entry? That’s where we configure which shell is launched when a user logs in or starts a new terminal session. Unless you’ve already changed it, the entry for your user account should read <code class="inlineCode">/bin/bash</code>.</p>
<p class="normal">You’ll see other variations in this file, such as <code class="inlineCode">/bin/false</code> or <code class="inlineCode">/usr/sbin/nologin</code>. These are actually invalid shells that will prevent a user from logging in to the system if one of these is set as the default for that user. While it may seem strange to set a user’s shell to one that prevents them from logging in, this practice is fairly common – not all user accounts need to log in to a server.</p>
<p class="normal">System accounts also exist alongside normal user accounts, which are created for background jobs. These system users won’t need to actually log in to the system in order to do their work, so it’s common to take that a step further and set the shell of a system user to an invalid shell, so that way, the account cannot be used to log in to the server if it’s taken over by an outside threat actor (the less an account can do, the safer it is).</p>
<p class="normal">The shell program <a id="_idIndexMarker322"/>itself is responsible for reading the commands you type and having the Linux kernel execute them. Some shells, Bash notably, have additional features, such as <em class="italic">history</em>, that are very useful to administrators.</p>
<h1 class="heading-1" id="_idParaDest-93">Understanding Bash history</h1>
<p class="normal">Speaking of history, let’s<a id="_idIndexMarker323"/> dive right into that concept. By default, Bash keeps track of all the commands you enter during your sessions, so that if you need to recall a previously entered command, you can definitely do so. History also serves another purpose, and that is seeing what other users have been up to. However, since users can edit their own history to cover their tracks, it’s not always useful for that purpose.</p>
<p class="normal">You may have already seen Bash’s history feature in some form, if you’ve ever pressed the up and down arrows on the shell to recall a previously used command. If you didn’t already know you could do that, go ahead and give it a try. You should see that by pressing the up and down arrows, you can cycle through commands that you’ve used previously.</p>
<p class="normal">Another trick is that you can also simply type <code class="inlineCode">history</code> in the shell and see a list of previously entered commands, as shown in <em class="italic">Figure 6.2</em>:</p>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated with medium confidence" height="208" src="../Images/B18425_06_02.png" width="498"/></figure>
<p class="packt_figref">Figure 6.2: Output from the history command</p>
<p class="normal">At this point, you can copy and paste a command you’ve used previously from this list to run it again. In fact, there’s an even easier way. Do you notice the number on the left of each command? We can utilize that number to quickly recall a previously used command. In my screenshot, item <code class="inlineCode">566</code> is where I ran <code class="inlineCode">sudo apt update</code>. If I wanted to run that same command <a id="_idIndexMarker324"/>again, I could simply enter the following command:</p>
<pre class="programlisting con"><code class="hljs-con">!566
</code></pre>
<p class="normal">In this case, I typed just four characters, and I was able to recall the previously used command, which performs the same action as typing this:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt update
</code></pre>
<p class="normal">That saves a lot of typing, which is great because we administrators want to type as little as possible (unless we’re writing a book).</p>
<p class="normal">Let’s look at a few additional history commands we can use. First, if we want to delete something from the history, we can simply do this:</p>
<pre class="programlisting con"><code class="hljs-con">history -d 566
</code></pre>
<p class="normal">In this example, we deleted item <code class="inlineCode">563</code> from Bash’s history. To delete a different history entry, simply replace <code class="inlineCode">563</code> with whatever the number is for the item we would want to remove. You may be wondering why deleting something from the history would be necessary. The answer to that is simple: sometimes we make mistakes. Perhaps we mistyped something, and we don’t want a junior administrator to look at the history and rerun an invalid command. Worse, if we accidentally saved a password to the history, it would be there for all to see. We would definitely want to remove that item so that the password isn’t saved in plain text in the history file. One very common example of this is with MySQL or MariaDB. When you enter the MySQL or MariaDB shell, you can use the <code class="inlineCode">-p</code> option and type the password in one line. It would look something like this:</p>
<pre class="programlisting con"><code class="hljs-con">mariadb -u root -pSuperSecretPassword
</code></pre>
<p class="normal">That command may appear useful, because in one command you’d be logged in to your database server as its own version of the <code class="inlineCode">root user</code>. However, this is one of my pet peeves—I really don’t like it when people run commands that include a password in the clear. Having the <code class="inlineCode">root</code> password in your shell’s history is a HUGE security risk. This is just one example of something you won’t want in our Bash history, though. My main goal here is to<a id="_idIndexMarker325"/> demonstrate that you should think about security when entering commands. If you have a potentially sensitive item in your command history, you should remove it. In fact, you can actually enter a command and not have it saved in the history at all. Simply prefix the command with a space. If you do, it will not be recorded in the history file. Go ahead, give it a try and see for yourself.</p>
<p class="normal">Having commands prefixed with a space ignored in Bash is actually a custom option enabled by default in Ubuntu Server. Not all distributions include this feature enabled by default. If you’re using a distribution that doesn’t have this enabled already, add the following to your <code class="inlineCode">.bashrc</code> file (we will talk about this file in greater detail later).</p>
<pre class="programlisting con"><code class="hljs-con">HISTCONTROL=ignoreboth
</code></pre>
<p class="normal">This configuration line also causes duplicate commands to not be entered into the history file as well, which can condense the history file.</p>
<p class="normal">So, you might be wondering, where is this history information actually stored? Check out the <code class="inlineCode">.bash_history</code> file, which is found in your home directory (or <code class="inlineCode">/root</code> for the <code class="inlineCode">root</code> user). When you exit your shell, your history is copied to that file. If you remove that file, you’re effectively clearing your history. I don’t recommend you make a habit of that, though. Having a history of commands is very useful, especially when you may not remember how you solved a problem last time. History in Bash can save you from looking up a command again. To find out more about what the <code class="inlineCode">history</code> command can do, check out the relevant man page with <code class="inlineCode">man history</code>.</p>
<p class="normal">Learning new tricks with the command line that allow me to work more efficiently is a great feeling, at least for me. In the next section, we’ll explore some useful tricks we can utilize while<a id="_idIndexMarker326"/> working with the shell.</p>
<h1 class="heading-1" id="_idParaDest-94">Learning some useful command-line tricks</h1>
<p class="normal">Productivity hacks <a id="_idIndexMarker327"/>utilizing the shell are some of my favorite things in this world, right up there with music, video games, and Diet Pepsi. There’s nothing like the feeling you get when you discover a useful feature that saves you time or increases your efficiency. There are many things I’ve discovered along the way that I wish I had known earlier on. One of my goals while writing this book is to teach you as many things as I can that took me longer to learn than I’m comfortable admitting to. In this section, in no particular order, I’ll go over a few tricks that increased my workflow.</p>
<p class="normal">First, entering <code class="inlineCode">!!</code> (two exclamation marks) in your terminal will repeat the command you last used. By itself, this may not seem like much. After all, you can press the up arrow key once and press <em class="keystroke">Enter</em> to recall the previous command and execute it. But, when paired with <code class="inlineCode">sudo</code>, <code class="inlineCode">!!</code> becomes more interesting. Imagine for a moment that you entered a command that needs <code class="inlineCode">root</code> privileges, but you forgot to use <code class="inlineCode">sudo</code>. We’ve all made this mistake. In fact, as of the time I’m writing this chapter, I’ve been using Linux for 20 years and I <em class="italic">still</em> forget to use <code class="inlineCode">sudo</code> from time to time. When we forget <code class="inlineCode">sudo</code>, we have to type the command all over again. Or, we can just do this:</p>
<pre class="programlisting con"><code class="hljs-con">sudo !!
</code></pre>
<p class="normal">And just like that, you prefixed the previously used command with <code class="inlineCode">sudo</code> without having to completely retype it.</p>
<p class="normal">Speaking of avoiding unnecessary typing, a very easy (yet incredibly useful) feature is <strong class="keyWord">Tab Completion</strong>. Often, the<a id="_idIndexMarker328"/> Bash shell will be able to automatically complete part of your commands. If you start typing a few characters of a command or path, press <em class="keystroke">Tab</em> on your keyboard, and if the characters you’ve typed are enough to narrow down the result, the shell will complete the path for you. You can also press <em class="keystroke">Tab</em> twice in succession to see a list of possibilities that match the characters you’ve typed so far. Go ahead and give it a shot. By way of a quick example, you can type <code class="inlineCode">ls</code> along with the path to your home directory, leaving some characters out on purpose. Then press <em class="keystroke">Tab</em>, and see whether the command automatically completes. For example, I can type the following into the terminal:</p>
<pre class="programlisting con"><code class="hljs-con">ls /home/j
</code></pre>
<p class="normal">And after I press <em class="keystroke">Tab</em>, it completes the command for me:</p>
<pre class="programlisting con"><code class="hljs-con">ls /home/jay
</code></pre>
<p class="normal">In addition, there are other special keyboard keys that will help you to navigate the command line quicker. Here’s <a id="_idIndexMarker329"/>a table containing some of the most useful keyboard shortcuts:</p>
<table class="table-container" id="table001-2">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Keyboard shortcut</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Result</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><em class="keystroke">Ctrl + a</em></p>
</td>
<td class="table-cell">
<p class="normal">Moves the cursor to the beginning of the line</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><em class="keystroke">Ctrl + e</em></p>
</td>
<td class="table-cell">
<p class="normal">Moves the cursor to the end of the line</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><em class="keystroke">Ctrl + l</em></p>
</td>
<td class="table-cell">
<p class="normal">Clears the screen</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><em class="keystroke">Ctrl + k</em></p>
</td>
<td class="table-cell">
<p class="normal">Deletes characters from the cursor to the end of the line</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><em class="keystroke">Ctrl + u</em></p>
</td>
<td class="table-cell">
<p class="normal">Deletes everything you’ve typed on that line (also works to clear text while entering a password)</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><em class="keystroke">Ctrl + w</em></p>
</td>
<td class="table-cell">
<p class="normal">Deletes the word to the left of the cursor</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">Going a bit further into the command history, we can also press <em class="keystroke">Ctrl + r</em> on the shell to initiate a search. After pressing these keys, we can start typing a command, and we’ll get a preview of a command that matches what we’re typing, which will be narrowed down further as we type more characters of it. This is one of those things that is hard for me to describe, and screenshots certainly don’t help here, so go ahead and just give it a shot. For example, press <em class="keystroke">Ctrl + r</em> and then start typing <code class="inlineCode">sudo apt</code>. The last time you used that command should appear, and you can press <em class="keystroke">Ctrl + r</em> again, and again, and again to see additional examples of commands that you’ve typed in the past that contain those characters. When you get efficient with this, it’s actually faster than the <code class="inlineCode">history</code> command, but it takes a bit to get used to this.</p>
<p class="normal">Another fun trick is editing a command you’ve previously typed in a text editor. I know this sounds strange, but hear me out. Assume you pressed the up arrow, you have a very long command, and you just want to edit part of it without having to execute the entire thing, perhaps a command like this:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt update &amp;&amp; sudo apt install apache2
</code></pre>
<p class="normal">Let’s assume you want to install <code class="inlineCode">nginx</code> instead of <code class="inlineCode">apache2</code>, but the rest of the command is right. If you hold <em class="keystroke">Ctrl</em> and then press <em class="keystroke">x</em> followed by <em class="keystroke">e</em>, the command will open in a text editor. There, you can change the command. Once you’re done making your changes, the command will execute once you save the file. Admittedly, this is usually only useful when you have a very long command and you need to just change part of it. It’s also a little weird, but so are computers.</p>
<p class="normal">Did you notice the two <code class="inlineCode">&amp;</code> symbols in the previous command? This is another useful trick; you can actually chain commands together. In the previous example command, we’re telling the shell to<a id="_idIndexMarker330"/> execute <code class="inlineCode">sudo apt update</code>. Next, we’re telling the shell to then execute <code class="inlineCode">sudo apt install apache2</code>. The double ampersand is known as the logical <code class="inlineCode">AND</code> operator, so the second command is run if the first was successful. If the first command was successful, the second command will execute right after. Another method to chain commands is this:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt update; sudo apt install apache2
</code></pre>
<p class="normal">The difference with the semicolon is that we’re telling the shell to execute the second command <em class="italic">regardless</em> of whether the first command was successful. You may then be wondering, what constitutes success on the shell? An obvious answer to this question might be “it’s successful if there are no error messages.” While that’s often true, the shell utilizes exit codes to programmatically attribute success or failure. You can see the exit code of a command by typing this immediately after the previous command finishes:</p>
<pre class="programlisting con"><code class="hljs-con">echo $?
</code></pre>
<p class="normal">An exit code of <code class="inlineCode">0</code> means success; anything else is some sort of error. Different programs will attribute different codes to different types of failures, but <code class="inlineCode">0</code> is always a success. With this command, what we’re actually doing is printing the content of a variable. <code class="inlineCode">$?</code> is actually a variable, which in this case only exists to hold an exit code. The <code class="inlineCode">echo</code> command itself can be used to print text to the shell, but it’s often used to print the contents of a variable (we’ll get into this in more detail in the <em class="italic">Understanding variables</em> section).</p>
<p class="normal">Now, it’s time for my favorite time-saving trick of them all—command aliases. The concept of an alias is simple: it allows you to create a command that is just another name for another command. This allows you to simplify commands down to just one word or a few letters. Consider this command, for example:</p>
<pre class="programlisting con"><code class="hljs-con">alias install="sudo apt install"
</code></pre>
<p class="normal">When you enter the previous command, you will receive no actual output. But what happens is now you have a new command available—<code class="inlineCode">install</code>. This command isn’t normally available; you just created it with this command.</p>
<p class="normal">You can verify that the alias was created successfully by simply running the <code class="inlineCode">alias</code> command, which will show you a list of aliases present in the shell. If you create a new alias, you should see it in the output. You’ll also see additional aliases in the output that you did not create. This<a id="_idIndexMarker331"/> is because Ubuntu sets up some by default. In fact, even the <code class="inlineCode">ls</code> command is an alias!</p>
<p class="normal">With this new alias created, any time you execute <code class="inlineCode">install</code> on the command line, you’re instead executing <code class="inlineCode">sudo apt install</code>. Now, installing packages becomes simpler:</p>
<pre class="programlisting con"><code class="hljs-con">install tmux
</code></pre>
<p class="normal">Just like that, you installed <code class="inlineCode">tmux</code>. You didn’t have to type <code class="inlineCode">sudo apt install tmux</code>; you just simplified the first three words in the command into <code class="inlineCode">install</code>. In fact, you can simplify it even further:</p>
<pre class="programlisting con"><code class="hljs-con">alias i='sudo apt install'
</code></pre>
<p class="normal">Now, you can install a package with this:</p>
<pre class="programlisting con"><code class="hljs-con">i tmux
</code></pre>
<p class="normal">With aliases, you can get very creative. Here are some of my personal favorites.</p>
<p class="normal">View the top 10 most-CPU-consuming processes:</p>
<pre class="programlisting con"><code class="hljs-con">alias cpu10='ps -L aux | sort -nr -k 3 | head -10'
</code></pre>
<p class="normal">View the top 10 most-RAM-consuming processes:</p>
<pre class="programlisting con"><code class="hljs-con">alias mem10='ps -L aux | sort -nr -k 4 | head -10'
</code></pre>
<p class="normal">View all mounted filesystems, and present the information in a clean tabbed layout:</p>
<pre class="programlisting con"><code class="hljs-con">alias lsmount='mount | column -t'
</code></pre>
<p class="normal">Clear the screen by simply typing <code class="inlineCode">c</code>:</p>
<pre class="programlisting con"><code class="hljs-con">alias c=clear
</code></pre>
<p class="normal">What other aliases can you come up with? Think of a command you may use on a regular basis and simplify it.</p>
<p class="normal">There’s one issue though, and that is the fact that when you exit your terminal window, your aliases are wiped out. How do you retain them? That leads me to my next productivity trick, editing your <code class="inlineCode">.bashrc</code> file. This file is present in your home directory and is read every time you start a new terminal session. You can add all of your <code class="inlineCode">alias</code> commands there; just add them somewhere in the file (for example, at the end). You will need to include the entire command, beginning with <code class="inlineCode">alias</code> and ending with the commands in quotes. If you wanted to steal my example aliases, you would enter the following lines somewhere in your <code class="inlineCode">.bashrc</code> file:</p>
<pre class="programlisting con"><code class="hljs-con">alias i='sudo apt install'
alias cpu10='ps -L aux | sort -nr -k 3 | head -10'
alias mem10='ps -L aux | sort -nr -k 4 | head -10'
alias lsmount='mount |column -t'
</code></pre>
<p class="normal">There are, of course, additional time-saving tricks that we could talk about here, but then again, Bash is so complex that we can write an entire book about it (and many people have). As we go along in this chapter, I’ll give you even more tips. For now, here’s a final trick, which changes your working directory back to the previous directory you were in:</p>
<pre class="programlisting con"><code class="hljs-con">cd -
</code></pre>
<p class="normal">That simple command was mentioned in <em class="chapterRef">Chapter 4</em>, <em class="italic">Navigating and Essential Commands</em>, but it’s <a id="_idIndexMarker332"/>worth a second mention—you’re welcome! Next, let’s take a look at shell variables, which allow us to store information for easy access in other commands.</p>
<h1 class="heading-1" id="_idParaDest-95">Understanding variables</h1>
<p class="normal">Bash is more than<a id="_idIndexMarker333"/> just a shell. You could argue that it is very similar to a complete programming language, and you wouldn’t be wrong. Bash has a built-in scripting engine (we will get into scripting later) and there are many debates as to what distinguishes a scripting language from a programming language, and that line becomes more and more blurred as new languages come out. </p>
<p class="normal">As with any scripting language, Bash supports variables. The concept of variables is very simple in Bash, but I figured I’d give it its own (relatively short) section to make sure you understand the basics. You can set a variable with a command such as the following:</p>
<pre class="programlisting con"><code class="hljs-con">myvar='Hello world!'
</code></pre>
<p class="normal">When Bash encounters an equal sign after a string, it assumes you’re creating a variable. Here, we’re creating a variable named <code class="inlineCode">myvar</code> and setting it equal to <code class="inlineCode">Hello world!</code> Whenever we refer to a variable, though, we need to specifically clarify to Bash that we’re requesting <a id="_idIndexMarker334"/>a variable, and we do that by prefixing it with a dollar symbol (<code class="inlineCode">$</code>). Consider this command:</p>
<pre class="programlisting con"><code class="hljs-con">echo $myvar
</code></pre>
<p class="normal">If you’ve set the variable as I have, executing that command will print <code class="inlineCode">Hello world!</code> to <code class="inlineCode">stdout</code>. The <code class="inlineCode">echo</code> command is very useful for printing the contents of variables. The key thing to remember here is that when you <em class="italic">set</em> a variable, you don’t include the <code class="inlineCode">$</code> symbol, but you do when you retrieve it. Also, keep in mind that there’s no space on either side of the equals sign.</p>
<p class="normal">You will see variations of variable name formats as you work with various Linux servers. For example, you may see variable names in all caps, camel case (<code class="inlineCode">MyVar</code>), as well as other variations. These variations are all valid, and depending on the background of the individual creating them (developers, administrators, and so on), you may see different forms of variable naming. It’s also extremely common that built-in variables created as part of the distribution will be named in all upper case.</p>
<p class="normal">Variables work in other aspects of the shell as well, not just with <code class="inlineCode">echo</code>. Consider this:</p>
<pre class="programlisting con"><code class="hljs-con">mydir="/etc"
ls $mydir
</code></pre>
<p class="normal">Here, we’re storing a directory name in a variable and using the <code class="inlineCode">ls</code> command against it to list its contents. This may seem relatively useless, but when you’re scripting, this will save you time. Anytime you need to refer to something more than once, it should be in a variable. That way, in a script, you can change the contents of that variable just one time and everywhere in the script will reference it.</p>
<p class="normal">There are also variables that are automatically present in your shell that you did not explicitly set yourself. Enter this command for fun:</p>
<pre class="programlisting con"><code class="hljs-con">env
</code></pre>
<p class="normal">Wow! You should see a lot of variables, especially if you enter it in a desktop version of Ubuntu.</p>
<p class="normal">These variables are set by the system, but can still be accessed via <code class="inlineCode">echo</code> as you would any other. Some notable ones include <code class="inlineCode">$SHELL</code> (stores the name of the binary that currently handles your shell), <code class="inlineCode">$USER</code> (stores your current username), and <code class="inlineCode">$HOST</code> (stores the hostname for your device). Any of these variables can be accessed at any time, and may even prove beneficial in scripts.</p>
<p class="normal">We’ve <a id="_idIndexMarker335"/>already <a id="_idIndexMarker336"/>gone <a id="_idIndexMarker337"/>over <strong class="keyWord">standard output</strong> (<strong class="keyWord">stdout</strong>), <strong class="keyWord">standard error</strong> (<strong class="keyWord">stderr</strong>), and <strong class="keyWord">standard input</strong> (<strong class="keyWord">stdin</strong>) in the previous chapter. We’ll use standard input again here, when we capture input to store it as a variable. Try this command for example:</p>
<pre class="programlisting con"><code class="hljs-con">read age
</code></pre>
<p class="normal">When you run this <a id="_idIndexMarker338"/>command, you’ll just be brought to a blank line, with no indication as to what you should be doing. Go ahead and enter your age, and then press <em class="keystroke">Enter</em>. Next, run this:</p>
<pre class="programlisting con"><code class="hljs-con">echo $age
</code></pre>
<p class="normal">In a script, you would want to inform the user what they should be entering, so you would probably use something similar to these commands:</p>
<pre class="programlisting con"><code class="hljs-con">echo "Please enter your age"
read age
echo "Your age is $age"
</code></pre>
<p class="normal">We’ve discussed standard input in the previous chapter, and we can see it in action again here as we capture input from the user and store it in a variable.</p>
<p class="normal">Automation is a subject we’ll explore multiple times throughout the remainder of the book, which will include more advanced subjects such as configuration management. Writing scripts is the simplest form of automation, which gives you the ability to type commands in a text file and have them all execute. That’s what we’ll explore next.</p>
<h1 class="heading-1" id="_idParaDest-96">Writing simple scripts</h1>
<p class="normal">This is the<a id="_idIndexMarker339"/> section where everything we’ve talked about so far starts to come together. Writing scripts can be very fun and rewarding, as they allow you to automate large jobs or just simplify something that you find yourself doing over and over. The most important point about scripting is this: if it’s something you’ll be doing more than once, you really should be making it into a script. This is a great habit to get into.</p>
<p class="normal">A script is a very simple concept; it’s just a text file that contains commands for your shell to execute one by one. A script written to be executed by Bash is known as a Bash script, and that’s what we’ll work on creating in this section.</p>
<p class="normal">At this point, I’m assuming that you’ve practiced a bit with a text editor in Linux. It doesn’t matter if you use Vim or Nano. Since we’ve edited text files before (we went over that in <em class="chapterRef">Chapter 5</em>, <em class="italic">Managing Files and Directories</em>), I’m under the assumption that you already know how to create and edit files. We’ll be using a text editor to create a simple script as an example, using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">nano ~/myscript.sh
</code></pre>
<p class="normal">If you weren’t already aware, a tilde (<code class="inlineCode">~</code>) is just a shortcut for a user’s home directory. Therefore, on my system, the previous command would be the same as if I had typed:</p>
<pre class="programlisting con"><code class="hljs-con">nano /home/jay/myscript.sh
</code></pre>
<p class="normal">Inside the file, type the following:</p>
<pre class="programlisting code"><code class="hljs-code">#!/bin/bash
echo "My name is $USER"
echo "My home directory is $HOME"
</code></pre>
<p class="normal">Save the file and exit the editor. In order to run this file as a script, we need to mark it as executable:</p>
<pre class="programlisting con"><code class="hljs-con">chmod +x ~/myscript.sh
</code></pre>
<p class="normal">To execute it, we simply call the path to the file and the filename:</p>
<pre class="programlisting con"><code class="hljs-con">~/myscript.sh
</code></pre>
<p class="normal">The output should look similar to the following:</p>
<pre class="programlisting con"><code class="hljs-con">My name is jay
My home directory is /home/jay
</code></pre>
<p class="normal">The first line, <code class="inlineCode">#!/bin/bash</code>, might seem strange if you haven’t seen it before. Normally, lines starting with a hash symbol (<code class="inlineCode">#</code>) are ignored by the interpreter. The one on the first line is an exception to this. The <code class="inlineCode">#!/bin/bash</code> entry we see on the first line is known as a <strong class="keyWord">hash bang</strong>, or <strong class="keyWord">shebang</strong>. Basically, it<a id="_idIndexMarker340"/> just<a id="_idIndexMarker341"/> tells the kernel which interpreter to use in order to run the commands inside the script. There are other interpreters we could be using, such as <code class="inlineCode">#!/usr/bin/python</code> if we were writing a script in the Python language. Since we’re writing a Bash script, we used <code class="inlineCode">#!/bin/bash</code>.</p>
<p class="normal">The lines that followed were simple print statements. Each one used a system variable, so you didn’t have to declare any of those variables as they already existed. Here, we printed the current user’s username and home directory.</p>
<p class="normal">The concept of scripting becomes more valuable when you start to think of things you do on a regular basis that you can instead automate. To be an effective Linux administrator, it’s important to adopt the automation mindset. Again, if you are going to do a job more than once, script it. Here’s another example script to help drive this concept home. This time, the<a id="_idIndexMarker342"/> script will actually be somewhat useful:</p>
<pre class="programlisting code"><code class="hljs-code">#!/bin/bash
sudo apt install -y apache2
sudo apt install -y libapache2-mod-php8.1
sudo a2enmod php8.1
sudo systemctl restart apache2
</code></pre>
<p class="normal">What we’ve done here is theoretically scripted the setup of a web server. We could extend this script further by having it copy site content to <code class="inlineCode">/var/www/html</code>, enable a configuration file, and so on. But from the preceding script, you can probably see how scripting can be useful in condensing the amount of work you do. This script could be an advanced web server install script that you could simply copy to a new server and then run.</p>
<p class="normal">Notice that the example uses the <code class="inlineCode">-y</code> option with <code class="inlineCode">apt</code>. If you weren’t already aware, that automatically answers <em class="italic">yes</em> to prompts that may come up as part of the process. Scripts are typically not interactive, meaning there may not be an administrator sitting in front of it to answer prompts when they appear. Also, using the <code class="inlineCode">a2enmod</code> command to enable <code class="inlineCode">php8.1</code> was not really necessary, as it would’ve been enabled automatically as part of installing the <code class="inlineCode">libapache2-mod-php8.1</code> package. But I think you get the idea; we want to be explicit in scripts and type instructions for the exact state we want things to be in.</p>
<p class="normal">Now, let’s get a bit more advanced with scripting. The previous script only installed some packages, something we probably could’ve done just as easily by copying and pasting the commands into the shell. Let’s take this script a bit further. Let’s write a conditional statement. Here’s a modified version of the previous script:</p>
<pre class="programlisting code"><code class="hljs-code">#!/bin/bash
# Install Apache if it's not already present
if [ ! -f /usr/sbin/apache2 ]; then
    sudo apt install -y apache2
    sudo apt install -y libapache2-mod-php8.1
    sudo a2enmod php8.1
    sudo systemctl restart apache2
fi
</code></pre>
<p class="normal">Now it’s getting a bit more interesting. The first line after the hash bang is a comment, letting us know what the script does:</p>
<pre class="programlisting code"><code class="hljs-code"># Install Apache if it's not already present
</code></pre>
<p class="normal">Comments are ignored<a id="_idIndexMarker343"/> by the interpreter, but are useful in letting us know what a block of code is doing.</p>
<p class="normal">Next, we start an <code class="inlineCode">if</code> statement:</p>
<pre class="programlisting code"><code class="hljs-code">if [ ! -f /usr/sbin/apache2 ]; then
</code></pre>
<p class="normal">Bash, like any scripting language, supports<a id="_idIndexMarker344"/> branching and the <code class="inlineCode">if</code> statement is one way of doing that. Here, it’s checking for the existence of the <code class="inlineCode">apache2</code> binary. The <code class="inlineCode">-f</code> option here specifies that we’re looking for a file. We can change this to <code class="inlineCode">-d</code> to check for the existence of a directory instead. The exclamation mark is an inverse. It basically means we’re checking if something is <em class="italic">not</em> present. If we wanted to check if something <em class="italic">is</em> present, we would omit the exclamation mark. Basically, we’re setting up the script to do nothing if Apache is already installed. In this case, inside the brackets we are just executing a shell command, and then the result is checked. The commands sandwiched inside the <code class="inlineCode">if</code> statement are simply installing packages.</p>
<p class="normal">Finally, we close out our <code class="inlineCode">if</code> statement with the word <em class="italic">if</em> backward (<code class="inlineCode">fi</code>). If you forget to do this, the script will fail.</p>
<p class="normal">With regard to the concept of <code class="inlineCode">if</code> statements, we can compare values as well. Consider the following example:</p>
<pre class="programlisting code"><code class="hljs-code">#!/bin/bash
myvar=1
if [ $myvar -eq 1]; then
    echo <span class="hljs-string">"</span>The variable equals 1"
fi
</code></pre>
<p class="normal">With this script, we’re merely checking the contents of a variable, and taking action if it equals a certain number. Notice we didn’t use quotation marks when creating the variable, since we just set a number (integer) here. We would’ve only used quotation marks if we wanted to set the<a id="_idIndexMarker345"/> variable value to a string. We can also take action if the <code class="inlineCode">if</code> statement doesn’t match:</p>
<pre class="programlisting code"><code class="hljs-code">#!/bin/bash
myvar=10
if [ $myvar -eq 1]; then 
    echo "The variable equals 1" 
else 
    echo "The variable doesn't equal 1" 
fi 
</code></pre>
<p class="normal">This was a silly example, I know, but it works as far as illustrating how to create an <code class="inlineCode">if</code>/<code class="inlineCode">else</code> logic block in Bash. The <code class="inlineCode">if</code> statement checks to see whether the variable was equal to <code class="inlineCode">1</code>. It isn’t, so the <code class="inlineCode">else</code> block executes instead.</p>
<p class="normal">The <code class="inlineCode">-eq</code> portion of the command is similar to <code class="inlineCode">==</code> in most programming languages. It’s checking to see whether the value is equal to something. Alternatively, we can use <code class="inlineCode">-ne</code> (not equal), <code class="inlineCode">-gt</code> (greater than), <code class="inlineCode">-ge</code> (greater than or equal to), <code class="inlineCode">-lt</code> (less than), and so on.</p>
<p class="normal">At this point, I recommend you take a break from reading to further practice scripting (practice is key to committing concepts to memory). Try the following challenges:</p>
<ul>
<li class="bulletList">Ask the user to enter input, such as their age, and save it to a variable. If the user enters a number less than 30, tell them they’re young. If the number is equal to or greater than 30, <code class="inlineCode">echo</code> a statement telling them that they’re old.</li>
<li class="bulletList">Write a script that copies a file from one place to another. Make the script check to see whether that file exists first, and have an <code class="inlineCode">else</code> statement printing an error if the file doesn’t exist.</li>
<li class="bulletList">Think about any topic we’ve already worked on during this book, and attempt to automate it.</li>
</ul>
<p class="normal">Now, let’s take a look at another concept, which is looping. The basic idea behind looping is simply doing something repeatedly until a condition has been met. Consider the following example script:</p>
<pre class="programlisting code"><code class="hljs-code">#!/bin/bash
myvar=1
while [ $myvar -le 15 ] 
do 
    echo $myvar 
    ((myvar++)) 
done 
</code></pre>
<p class="normal">Let’s go through the script line by line to understand what it’s doing.</p>
<pre class="programlisting code"><code class="hljs-code">myvar=1 
</code></pre>
<p class="normal">With this new script, we’re<a id="_idIndexMarker346"/> creating a control<a id="_idIndexMarker347"/> variable, called <code class="inlineCode">myvar</code>, and setting it equal to <code class="inlineCode">1</code>.</p>
<pre class="programlisting code"><code class="hljs-code">while [ $myvar -le 15 ]
</code></pre>
<p class="normal">Next, we set up a <code class="inlineCode">while</code> loop. A <code class="inlineCode">while</code> loop will continue until a condition is met. Here, we’re telling it to execute the statements in the block over and over until <code class="inlineCode">$myvar</code> becomes equal to <code class="inlineCode">15</code>. In fact, a <code class="inlineCode">while</code> loop can continue forever if you enter something incorrectly, which is known as <a id="_idIndexMarker348"/>an <strong class="keyWord">infinite loop</strong>. An infinite loop is dangerous, and can cause your server to stop responding. If you used <code class="inlineCode">-ge 0</code> instead, you would’ve created exactly that.</p>
<pre class="programlisting code"><code class="hljs-code">do
</code></pre>
<p class="normal">With <code class="inlineCode">do</code>, we’re telling the <code class="inlineCode">for</code> loop to prepare itself to start doing something.</p>
<pre class="programlisting code"><code class="hljs-code">    echo $myvar
</code></pre>
<p class="normal">Here, we’re printing the current content of the <code class="inlineCode">$myvar</code> variable—nothing surprising here.</p>
<pre class="programlisting code"><code class="hljs-code">    ((myvar++))
</code></pre>
<p class="normal">With this statement, we’re using what’s known as an incrementor to increase the value of our variable by <code class="inlineCode">1</code>. The double parenthesis tells the shell that we’re doing an arithmetic operation, so the interpreter doesn’t think that we’re working with strings.</p>
<pre class="programlisting code"><code class="hljs-code">done
</code></pre>
<p class="normal">When we’re done writing a <code class="inlineCode">while</code> loop, we must close the block with <code class="inlineCode">done</code>. If you’ve typed the script properly, it should count from <code class="inlineCode">1</code> to <code class="inlineCode">15</code>.</p>
<p class="normal">Another type of loop<a id="_idIndexMarker349"/> is a <code class="inlineCode">for</code> loop. A <code class="inlineCode">for</code> loop executes a statement for every item in a set. For example, you can have the <code class="inlineCode">for</code> loop execute a command against every file in a directory. Consider this example:</p>
<pre class="programlisting code"><code class="hljs-code">#!/bin/bash
turtles='Donatello Leonardo Michelangelo Raphael'
for t in $turtles
do
    echo $t
done
</code></pre>
<p class="normal">Let’s take a deeper<a id="_idIndexMarker350"/> look into what we’ve done here:</p>
<pre class="programlisting code"><code class="hljs-code">turtles='Donatello Leonardo Michelangelo Raphael'
</code></pre>
<p class="normal">Here, we’re creating a list and populating it with names. Each name is one item in the list. We’re calling this list <code class="inlineCode">turtles</code>. We can see the contents of this list with <code class="inlineCode">echo</code> as we would with any other variable:</p>
<pre class="programlisting con"><code class="hljs-con">echo $turtles
</code></pre>
<p class="normal">Next, let’s look at how we set up the <code class="inlineCode">for</code> loop:</p>
<pre class="programlisting code"><code class="hljs-code">for t in $turtles
</code></pre>
<p class="normal">Now, we’re telling the interpreter to prepare to do something for every item in the list. The <code class="inlineCode">t</code> here is arbitrary, we could’ve used any letter here or even a longer string. We’re just setting up a temporary variable we want to use in order to hold the current item the script is working on.</p>
<pre class="programlisting code"><code class="hljs-code">do
</code></pre>
<p class="normal">With <code class="inlineCode">do</code>, we’re telling the <code class="inlineCode">for</code> loop to prepare itself to start doing something.</p>
<pre class="programlisting code"><code class="hljs-code">    echo $t
</code></pre>
<p class="normal">Now, we’re printing the current value of <code class="inlineCode">$t</code> to <code class="inlineCode">stdout</code>.</p>
<pre class="programlisting code"><code class="hljs-code">done
</code></pre>
<p class="normal">Just as we did with the <code class="inlineCode">while</code> loop, we type <code class="inlineCode">done</code> to let the interpreter know this is the end of the <code class="inlineCode">for</code> loop. Effectively, we just created a <code class="inlineCode">for</code> loop to print each item in a list independently:</p>
<pre class="programlisting con"><code class="hljs-con">Donatello
Leonardo
Michelangelo
Raphael
</code></pre>
<p class="normal">We included four turtle names in our list, and we were able to iterate through them and print them out, one by one.</p>
<p class="normal">As much as I love turtles (especially the teenage mutant ninja variety), that script isn’t very practical or <a id="_idIndexMarker351"/>useful to us for server administration. Next, we’re going to write a script that can actually be quite useful.</p>
<h1 class="heading-1" id="_idParaDest-97">Putting it all together – Writing an rsync backup script</h1>
<p class="normal">Let’s close this <a id="_idIndexMarker352"/>chapter with a Bash script that will not only prove to be very useful but will also help you enhance your skills. The <code class="inlineCode">rsync</code> utility is one of my favorites; it’s very useful for copying data from one place to another, as well as being helpful for setting up a backup job. Let’s use the following example <code class="inlineCode">rsync</code> command to practice automation:</p>
<pre class="programlisting con"><code class="hljs-con">rsync -avb --delete --backup-dir=/backup/incremental/08-17-2022 /src /target
</code></pre>
<p class="normal">This example <code class="inlineCode">rsync</code> command uses the <code class="inlineCode">-a</code> (archive) option, which retains the metadata of the file(s) it copies to the target, such as the timestamp and owner. The <code class="inlineCode">-v</code> option gives us verbose output, so we can see exactly what <code class="inlineCode">rsync</code> is doing. The <code class="inlineCode">-b</code> option enables backup mode, which means that if a file on the target will be overwritten by a file from the source, the previous version of that file will be renamed so it won’t be overwritten. Combining these three options, we simplify it to <code class="inlineCode">-avb</code> rather than typing <code class="inlineCode">-a -v -b</code>. The <code class="inlineCode">--delete</code> option tells <code class="inlineCode">rsync</code> to delete any files in the target that aren’t present in the source (since we used <code class="inlineCode">-b</code>, any file that is deleted will be retained). </p>
<p class="normal">The <code class="inlineCode">--backup-dir</code> option tells <code class="inlineCode">rsync</code> that any time a file would have been renamed in this way (or deleted), to instead just copy it to another directory. In this case, we send any files that would have been overwritten to the <code class="inlineCode">/backup/incremental/08-16-2022</code> directory.</p>
<p class="normal">Let’s script this <code class="inlineCode">rsync</code> job. One problem we can fix in our script right away is the date that is present inside the directory we’re using for the <code class="inlineCode">--backup-dir</code>. The date changes every day, so we shouldn’t be hardcoding this. Therefore, let’s start our script by addressing this:</p>
<pre class="programlisting code"><code class="hljs-code">#/bin/bash
curdate=$(date +%m-%d-%Y) 
</code></pre>
<p class="normal">We’re creating a <a id="_idIndexMarker353"/>variable called <code class="inlineCode">curdate</code>. We’re setting it equal to the output of the <code class="inlineCode">$(date +%m-%d-%Y)</code> command. You can execute <code class="inlineCode">date +%m-%d-%Y</code> in your terminal window to see exactly what that does. In this case, putting a command (such as <code class="inlineCode">date</code>) in parentheses<a id="_idIndexMarker354"/> and a dollar symbol means that we’re executing the command in a <strong class="keyWord">sub-shell</strong>. The command<a id="_idIndexMarker355"/> will run, and we’re going to capture the result of that command and store it in the <code class="inlineCode">curdate</code> variable.</p>
<p class="normal">Next, let’s make sure <code class="inlineCode">rsync</code> is actually installed, and install it if it’s not:</p>
<pre class="programlisting code"><code class="hljs-code">if [ ! -f /usr/bin/rsync ]; then 
    sudo apt install -y rsync 
fi 
</code></pre>
<p class="normal">Here, we’re simply checking to see whether <code class="inlineCode">rsync</code> is <em class="italic">not</em> installed. If it’s not, we’ll install it via <code class="inlineCode">apt</code>. This is similar to how we checked for the existence of <code class="inlineCode">apache2</code> earlier in this chapter.</p>
<p class="normal">Now, we add the final line:</p>
<pre class="programlisting code"><code class="hljs-code">rsync -avb --delete --backup-dir=/backup/incremental/$curdate /src /target
</code></pre>
<p class="normal">You can definitely see the magic of variables in Bash now, if you haven’t already. We’re including <code class="inlineCode">$curdate</code> in our command, which is set to whatever the current date actually is. When we put it all together, our script looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">#/bin/bash
curdate=$(date +%m-%d-%Y)
if [ ! -f /usr/bin/rsync ]; then 
    sudo apt install -y rsync 
fi
rsync -avb --delete --backup-dir=/backup/incremental/$curdate /src /target 
</code></pre>
<p class="normal">This script, when run, will run an <code class="inlineCode">rsync</code> job that will copy the contents from <code class="inlineCode">/src</code> to <code class="inlineCode">/target</code>. (Be sure to change these directories to match the source directory you want to back up and the target where you want to copy it to.) The beauty of this is that <code class="inlineCode">/target</code> can be an external hard drive or network share. So, in a nutshell, you can automate a nightly backup. This backup, since we used the <code class="inlineCode">-b</code> option along with <code class="inlineCode">--backup-dir</code>, will allow you to retrieve previous versions of a file from the <code class="inlineCode">/backup/incremental</code> directory. Feel free to get creative here as far as where to place previous file versions and where to send the backup.</p>
<p class="normal">Of course, don’t forget to mark the script as executable, assuming it was saved with a name like <code class="inlineCode">backup.sh</code>:</p>
<pre class="programlisting con"><code class="hljs-con">chmod +x backup.sh
</code></pre>
<p class="normal">At this point, you can put this script in a cron job to automate its run. To do so, it’s best to put the script in a central location where it can be found, such as in <code class="inlineCode">/usr/local/bin</code>:</p>
<pre class="programlisting con"><code class="hljs-con">sudo mv backup.sh /usr/local/bin
</code></pre>
<p class="normal">You can consider creating a cron job for this script to be run periodically. We’ll cover that in <em class="chapterRef">Chapter 7</em>, <em class="italic">Controlling and Monitoring Processes</em>, which is the very next chapter. With a cron job, you<a id="_idIndexMarker356"/> can set up various tasks to run at different times in order to make your server essentially do your work for you.</p>
<h1 class="heading-1" id="_idParaDest-98">Summary</h1>
<p class="normal">In this chapter, we dived into a number of more advanced concepts relating to shell commands, such as redirection, Bash history, command aliases, some command-line tricks, and more. Working with the shell is definitely something you’ll continue to improve upon, so don’t be worried if you have any trouble committing all of this knowledge to memory. After over 20 years of working with Linux, I’m still learning new things myself. The main takeaway in this chapter is to serve as a starting point to broaden your command-line techniques and also serve as the basis for future exploration into the subject.</p>
<p class="normal">In the next chapter, we’ll take a look at managing processes, which will include job management, taming misbehaving processes, and more. See you there!</p>
<h1 class="heading-1" id="_idParaDest-99">Relevant videos</h1>
<ul>
<li class="bulletList">Linux Crash Course – Bash History (LearnLinuxTV): <a href="https://linux.video/le-bash-history"><span class="url">https://linux.video/le-bash-history</span></a></li>
<li class="bulletList">Linux Command-Line Tips &amp; Tricks (LearnLinuxTV): <a href="https://linux.video/cli-tips"><span class="url">https://linux.video/cli-tips</span></a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-100">Further reading</h1>
<ul>
<li class="bulletList">Comparison operators for Bash: <a href="https://learnlinux.link/c-ops"><span class="url">https://learnlinux.link/c-ops</span></a></li>
<li class="bulletList">Commandlinefu: <a href="https://learnlinux.link/c-fu"><span class="url">https://learnlinux.link/c-fu</span></a></li>
<li class="bulletList">Bash reference manual: <a href="https://learnlinux.link/bash-man"><span class="url">https://learnlinux.link/bash-man</span></a></li>
</ul>
<h1 class="heading-1">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers: </p>
<p class="normal"><a href="https://packt.link/LWaZ0"><span class="url">https://packt.link/LWaZ0</span></a></p>
<p class="normal"><img alt="" height="177" src="../Images/QR_Code50046724-1955875156.png" width="177"/></p>
</div>
</div></body></html>