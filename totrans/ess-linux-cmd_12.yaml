- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Linux Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the ever-evolving landscape of information technology, the security of systems
    and data stands as an unwavering priority. As the backbone of countless infrastructures,
    Linux operating systems have solidified their presence in various domains, from
    servers to embedded devices. Within this realm, this chapter embarks on a comprehensive
    journey, delving into the realm of Linux security. This exploration isn’t just
    an exercise in fortifying digital fortresses; it’s a pivotal pursuit that safeguards
    sensitive information, guarantees operational integrity, and upholds user trust.
    In the contemporary digital era, where interconnectedness dominates, the importance
    of Linux security cannot be overstated. Organizations of all sizes rely on Linux-based
    systems to manage databases, power websites, and orchestrate complex networks.
    These systems contain troves of sensitive information, from proprietary algorithms
    to personal user data. Ensuring the security of this data is imperative not only
    to maintain the competitive edge but also to safeguard the reputation of the entity
    in question. Breaches in security can lead to dire consequences, including financial
    losses, legal ramifications, and the erosion of customer confidence.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this exploration transcends the realm of routine system administration.
    It’s a proactive stance against potential threats that could exploit vulnerabilities
    and wreak havoc. Linux administrators, armed with a profound understanding of
    security mechanisms, can erect potent defenses against a multitude of cyber threats,
    from malware and ransomware to data breaches and denial-of-service attacks. By
    comprehending the intricacies of Linux security, administrators can effectively
    mitigate risks, respond swiftly to emerging threats, and prevent security incidents
    that could otherwise cripple operations.
  prefs: []
  type: TYPE_NORMAL
- en: Linux security isn’t just a technical checklist – it’s an integral component
    of responsible administration. First and foremost, Linux is an open source ecosystem,
    meaning that its source code is publicly accessible. While this fosters collaboration
    and rapid development, it also exposes the system to potential scrutiny and exploitation.
    Hence, understanding Linux security is paramount to identify and rectify vulnerabilities
    that might otherwise go unnoticed. Moreover, the diverse applications of Linux,
    from personal computing to corporate servers, demand a nuanced approach to security.
    Administrators must navigate this spectrum while factoring in the unique security
    requirements of each scenario. This necessitates a deep comprehension of Linux
    security mechanisms, such as access controls, encryption, authentication protocols,
    and intrusion detection systems. By harnessing these tools effectively, administrators
    can customize security strategies that align with specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, this chapter serves as a compass in the labyrinth of Linux administration.
    It equips administrators with the knowledge and strategies needed to uphold the
    resilience and integrity of Linux-based systems, fostering a digital landscape
    where security stands as an unwavering pillar of operational success.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will delve into the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing enforcing and permissive modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling or disabling SELinux Boolean values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking user accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing enforcing and permissive modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the realm of access control and security management, the concepts of **enforcing**
    and **permissive** modes assume crucial roles, particularly within the context
    of operating systems such as Linux. These modes pertain to the behavior of security
    mechanisms, such as **Mandatory Access Control** (**MAC**) frameworks. For instance,
    RHEL and Fedora Linux use **Security-Enhanced Linux** (**SELinux**) as their MAC
    framework, while Ubuntu employs AppArmor for similar purposes. Enforcing mode
    signifies a state where strict adherence to security policies is upheld, disallowing
    any actions that contravene these rules. On the other hand, permissive mode adopts
    a more lenient stance, allowing actions that would typically be denied under “enforcing.”
    The purpose of these modes lies in striking a balance between maintaining system
    integrity and facilitating essential operations without undue hindrance. These
    modes are essential for system administrators aiming to enhance system security
    while ensuring the smooth operation of their systems. By utilizing enforcing mode,
    administrators can ensure that all actions, whether initiated by users or applications,
    adhere rigidly to established security policies. This prevents unauthorized access,
    reduces the potential attack surface, and mitigates the risks associated with
    breaches, malware infiltration, and unauthorized data manipulation. Conversely,
    permissive mode proves invaluable in scenarios where the immediate implementation
    of strict security measures might disrupt critical operations or lead to unintended
    consequences. Administrators can temporarily switch to the permissive mode to
    identify potential issues that would arise under enforcing mode. This approach
    aids in fine-tuning security policies without causing system-wide disruptions.
    Additionally, permissive mode allows administrators to understand the scope and
    impact of security policy changes before fully committing to them.
  prefs: []
  type: TYPE_NORMAL
- en: A short introduction to Linux hardening and the role of SELinux’s enforcing
    and passive modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the ever-evolving landscape of cybersecurity, the term **Linux hardening**
    emerges as a critical practice to enhance the security posture of Linux-based
    systems. Linux hardening refers to the systematic process of fortifying the security
    of a Linux operating system by minimizing vulnerabilities, reducing attack surfaces,
    and implementing robust defense mechanisms. At its core, Linux hardening seeks
    to create an environment that withstands a broad spectrum of threats, ranging
    from cyberattacks to unauthorized data breaches. In this intricate dance between
    technology and security, the roles of SELinux’s enforcing and permissive modes
    stand out as pivotal players, shaping the defense strategies adopted by system
    administrators.
  prefs: []
  type: TYPE_NORMAL
- en: The role of enforcing mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the realm of MAC, SELinux stands as a pioneering framework that enforces
    fine-grained security policies within a Linux system. SELinux’s enforcing mode
    assumes a role akin to an unyielding guardian, allowing only actions that align
    with meticulously defined security rules. When operating in enforcing mode, SELinux
    rigidly enforces access controls and security contexts, thereby confining potentially
    malicious actions and reducing the likelihood of unauthorized intrusion. This
    mode ensures that even if an attacker gains access, their ability to maneuver
    and exploit vulnerabilities is severely curtailed, thereby enhancing the overall
    resilience of the system to enable enforcing mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – SELinux’s enforcing mode](img/B18212_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – SELinux’s enforcing mode
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: The `setenforce` command is used to modify SELinux’s enforcing mode. By running
    `sudo setenforce 1`, you are instructing SELinux to switch to enforcing mode.
    In this mode, SELinux will strictly enforce the defined security policies, denying
    actions that violate those policies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To verify that SELinux is in enforcing mode, you can use the `getenforce` command.
    The `getenforce` command provides a simple way to query the status of SELinux
    and determine whether it’s currently operating in enforcing mode or permissive
    mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The role of permissive mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In contrast, SELinux’s permissive mode serves as an insightful observer in
    the security landscape. When switched to permissive mode, SELinux refrains from
    blocking actions that breach security policies, but it actively logs these incidents.
    This mode serves as an essential tool for system administrators seeking to fine-tune
    their security policies without abruptly disrupting operations. By analyzing the
    logs generated in permissive mode, administrators can identify potential issues
    that would arise if the system were operating in enforcing mode. This invaluable
    feedback loop empowers administrators to iteratively refine security policies,
    ensuring they strike an optimal balance between stringent security and operational
    functionality to enable SELinux’s permissive mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – SELinux’s permissive mode](img/B18212_12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – SELinux’s permissive mode
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: This time, by running `sudo setenforce 0`, you are instructing SELinux to switch
    to permissive mode. In permissive mode, SELinux does not actively block actions
    that violate security policies. Instead, it logs these actions for later analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To verify that SELinux is in enforcing mode, you can use the `getenforce` command
    to verify whether it’s switched to permissive mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, the dynamic interplay of SELinux’s enforcing and permissive modes
    exemplifies the delicate art of Linux hardening. These modes offer administrators
    a granular approach to security, allowing them to choose between airtight enforcement
    and pragmatic observation. By judiciously deploying these modes, administrators
    can navigate the labyrinthine world of Linux security, creating fortified environments
    that confidently withstand the evolving landscape of cyber threats.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling or disabling SELinux Boolean values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the intricate landscape of Linux security, SELinux emerges as a dynamic framework
    that empowers administrators to finely tune access controls and enforce security
    policies. At the heart of SELinux’s configurational arsenal lie Boolean values,
    encapsulating binary settings that enable or disable specific security features.
    These Boolean values serve as cryptographic keys that can unlock a multitude of
    security configurations, allowing administrators to sculpt the behavior of the
    system with precision. From enabling network connectivity for web servers to permitting
    specific user interactions, Boolean values offer a nuanced approach to tailoring
    security protocols, ensuring that the system operates within the desired security
    boundaries. The importance of enabling or disabling SELinux Boolean values transcends
    the realm of mere customization. It plays a pivotal role in aligning system security
    with the ever-evolving operational demands of the digital landscape. A tangible
    example of their significance is found in web server scenarios. When deploying
    a web application, certain functionalities might require network connectivity,
    such as sending emails or accessing remote databases. By manipulating Boolean
    values, administrators can enable specific network-related permissions for the
    web server process while keeping other potentially vulnerable actions locked down.
    This granular control not only mitigates risks but also ensures that security
    is an enabler, not an inhibitor, of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of SELinux Boolean values extends to scenarios where system administrators
    need to balance security and usability. For instance, when introducing a new software
    package, it might demand unconventional access rights to function optimally. Rather
    than compromising the overall system security, administrators can modify Boolean
    values to grant temporary permissions. This empowers administrators to evaluate
    the software’s behavior in a controlled environment while preserving the integrity
    of the larger system. Moreover, the ability to enable or disable specific Boolean
    values facilitates the implementation of security policies that are congruent
    with organizational policies and regulatory requirements. This not only enhances
    security posture but also streamlines compliance efforts by allowing administrators
    to cater to unique operational needs. Now, let’s take a look at the current values
    for all SELinux Boolean settings and understand the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Output of current Boolean values](img/B18212_12_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Output of current Boolean values
  prefs: []
  type: TYPE_NORMAL
- en: 'The provided outputs are the results of running the `getsebool -a` command.
    This command is used to display the current values of all SELinux Boolean settings.
    SELinux Boolean values are binary settings that determine whether a specific security
    feature or permission is enabled (on) or disabled (off). These Boolean values
    allow administrators to finely control the behavior and security policies enforced
    by SELinux. Let’s break down the output and explain each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`abrt_anon_write --> off`: This indicates that the SELinux Boolean value for
    allowing the **Automatic Bug Reporting Tool** (**ABRT**) to write to anonymous
    memory is currently disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abrt_handle_event --> off`: This Boolean value controls whether ABRT can handle
    events is disabled. ABRT handles system events such as crashes or abnormal terminations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abrt_upload_watch_anon_write --> on`: This means that the Boolean value that
    allows ABRT to watch for uploads with anonymous write access is enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`antivirus_can_scan_system --> off`: This states that the Boolean value that
    permits antivirus software to scan the entire system is currently disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`antivirus_use_jit --> off`: The Boolean value controlling whether antivirus
    software can use **Just-In-Time** (**JIT**) scanning is disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auditadm_exec_content --> on`: This indicates that the Boolean value allowing
    the `auditadm` user to execute content is enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`authlogin_nsswitch_use_ldap --> off`: The Boolean value that determines whether
    the `authlogin` program should use the **Network Security Services** (**NSS**)
    LDAP module is disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`authlogin_radius --> off`: The Boolean value that controls whether the `authlogin`
    program can use the `radius` protocol for authentication is disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`authlogin_yubikey --> off`: This means that the Boolean value permitting the
    `authlogin` program to use YubiKey for authentication is disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awstats_purge_apache_log_files --> off`: The Boolean value that decides whether
    `awstats` should be allowed to purge Apache log files is disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these lines represents a specific SELinux Boolean value and its current
    status. The value next to the arrow (that is, `on` or `off`) indicates whether
    the Boolean is enabled or disabled. These Boolean values allow system administrators
    to tailor the security policies of their systems to match their specific operational
    requirements while maintaining a robust security posture.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for a Boolean and getting its information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re not sure about the exact name of a Boolean but want to search for
    it, you can use the `semanage boolean -``l` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Searching for Booleans](img/B18212_12_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Searching for Booleans
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the status of a specific SELinux Boolean, use the `getsebool` command
    followed by the name of the Boolean. For example, to check its status, you can
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Checking a specific Boolean’s status](img/B18212_12_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Checking a specific Boolean’s status
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run a command to get information about a Boolean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Getting information about a Boolean](img/B18212_12_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Getting information about a Boolean
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command searches through the list of SELinux Booleans, finds the
    one named `xguest_connect_network`, and displays its current status as `on`, indicating
    that network connections are allowed for the `xguest` user or process. The comment
    provides additional context about why this particular Boolean exists and what
    it controls.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s enable and disable a Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling a SELinux Boolean value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable a SELinux Boolean value, you can use the `setsebool` command with
    the `-P` option (which makes the change permanent), followed by the name of the
    Boolean and `1` to indicate `on`. For instance, if you want to enable the `xguest_use_bluetooth`
    Boolean, you can run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Enabling Boolean values](img/B18212_12_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – Enabling Boolean values
  prefs: []
  type: TYPE_NORMAL
- en: After executing this command, we used the `semanage` command to get information
    about the changes that were made. This command sets the `xguest_use_bluetooth`
    Boolean to `on` and makes the change permanent across system reboots.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling a SELinux Boolean value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To disable an SELinux Boolean value, use the `setsebool` command with the `-P`
    option, followed by the name of the Boolean and `0` to indicate `off`. For example,
    to disable the `mount_anyfile` boolean, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Query the current state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`semanage boolean -l | grep mount_anyfile`: This command lists all SELinux
    Boolean values and filters the output using `grep` to find the line containing
    `mount_anyfile`. This line shows that the `mount_anyfile` Boolean is currently
    enabled, as indicated by (`on, on`). Additionally, it provides a description,
    `Allow mount to anyfile`, which explains the purpose of this Boolean.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Disable the Boolean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`setsebool -P mount_anyfile 0`: This command uses `setsebool` to change the
    status of the `mount_anyfile` Boolean. The `-P` flag makes this change permanent
    (persisting across reboots), and `0` signifies `off`. After running this command,
    SELinux is configured to disallow the `mount` command to mount any file as a filesystem.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify the change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`semanage boolean -l | grep mount_anyfile`: This command is used to query the
    status of the `mount_anyfile` Boolean after it has been modified. Now, it shows
    (`off, off`) for this Boolean, confirming that it has been disabled. The description
    remains the same, indicating that the `mount` command is not allowed to mount
    any file as a filesystem:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Disabling Boolean values](img/B18212_12_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – Disabling Boolean values
  prefs: []
  type: TYPE_NORMAL
- en: This command sets the `mount_anyfile` Boolean to `off` and ensures that the
    change persists after the system reboots.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the command checks the status of the `mount_anyfile` SELinux Boolean,
    disables it, and verifies that the change took effect. SELinux Booleans allow
    administrators to finely control access and permissions within the system, and
    modifying them should be done with a clear understanding of the security implications
    for the system’s operation.
  prefs: []
  type: TYPE_NORMAL
- en: Locking user accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In SELinux, the concept of locking user accounts is often associated with standard
    Linux account management practices, such as using the `passwd` command. SELinux
    itself does not directly handle account locking; rather, it relies on Linux’s
    account management tools to lock and unlock user accounts. Here are some Terminal
    examples of how to lock and unlock a user account:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Locking a user account:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To lock a user account, you typically disable the account by changing the account’s
    password. This can be achieved by using the `passwd` command with the `-l` (lock)
    option:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Locking a user account](img/B18212_12_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Locking a user account
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlocking a user account:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To unlock a user account that has been locked, you can use the `passwd` command
    again, with `-u` to unlock and `f` for the force option:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Unlocking a user account](img/B18212_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Unlocking a user account
  prefs: []
  type: TYPE_NORMAL
- en: The first command unlocks the password for the `intruder` user, and the output
    confirms that the account was unlocked successfully. The second command provides
    information about the user’s current password status, indicating that they have
    a password set and it is securely encrypted using SHA-512\. This scenario ensures
    that the `intruder` user can now access their account with their password.
  prefs: []
  type: TYPE_NORMAL
- en: Securing SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Secure Shell** (**SSH**) is a widely used protocol for secure remote access
    and secure file transfers over an insecure network. It plays a pivotal role in
    modern IT infrastructures, enabling administrators, developers, and users to access
    remote systems securely. However, to harness the full potential of SSH and maintain
    the confidentiality and integrity of data during remote connections, it’s paramount
    to implement robust security measures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary purpose of securing SSH is to protect sensitive information and
    prevent unauthorized access to remote systems. SSH achieves this by encrypting
    data during transmission and employing strong authentication mechanisms. By utilizing
    cryptographic protocols, SSH ensures that data that’s exchanged between the client
    and server remains confidential and is not susceptible to eavesdropping by malicious
    actors. Furthermore, SSH’s public-key authentication and password-based authentication
    mechanisms enhance the security of remote access, reducing the risk of unauthorized
    logins. The ability to securely tunnel various network services through SSH, known
    as SSH tunneling, also extends its use beyond remote access, making it a versatile
    tool for secure data transfer and network management. In essence, securing SSH
    is integral to safeguarding sensitive data, protecting against malicious intrusions,
    and ensuring the trustworthiness of remote connections. The importance of SSH
    security is underscored by its ubiquity in enterprise environments and the critical
    role it plays in securing remote access to servers, networking devices, and cloud
    infrastructure. Inadequate SSH security can lead to devastating consequences,
    including data breaches, unauthorized system access, and exposure to confidential
    information. This underscores the necessity of implementing best practices, such
    as enforcing strong password policies, using multi-factor authentication, and
    configuring SSH servers to allow only trusted users and hosts. SSH security also
    aligns with compliance requirements and regulatory standards, making it indispensable
    for organizations subject to data protection regulations such as GDPR or HIPAA.
    Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the default SSH port:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the default SSH port (`22`) to a non-standard port can help deter automated
    scanning and brute-force attacks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To change the SSH port to `2222`, edit the SSH configuration file, `/etc/ssh/sshd_config`,
    located in the corner of the shell, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Changing the default port](img/B18212_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – Changing the default port
  prefs: []
  type: TYPE_NORMAL
- en: Inside the file, locate the line with `Port 22` and change it to `Port 2222`
    or any other port number of your choice. Save the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update SELinux rules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When SELinux is enabled, it’s important to note that SELinux policies are designed
    to enhance system security by enforcing strict rules and restrictions on various
    system resources, including network ports. These policies might initially prevent
    SSH traffic on a new port that you’ve configured.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To ensure that SSH traffic can flow smoothly on the new port, you’ll need to
    update the SELinux policy to allow it. You can achieve this using the `semanage`
    command, which is a powerful tool for managing SELinux policies. Specifically,
    you’ll need to use `semanage` to modify the SELinux port policy to permit SSH
    communication on the new port.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you’ve made the necessary policy adjustments, it’s crucial to apply these
    changes and then restart the SSH service to put the new configuration into effect.
    This ensures that SSH connections on the modified port are allowed as per the
    updated SELinux policy. Here’s how you can accomplish this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Updating SELinux rules and restarting sshd](img/B18212_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Updating SELinux rules and restarting sshd
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify this by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Verifying the changes](img/B18212_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Verifying the changes
  prefs: []
  type: TYPE_NORMAL
- en: 'Disable password authentication:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling password-based authentication in favor of public key authentication
    enhances security by eliminating the risk of password-guessing attacks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit the SSH configuration file, `/etc/ssh/sshd_config`, located in the corner
    of the shell, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.14 – Disabling password authentication](img/B18212_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – Disabling password authentication
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the line with `PasswordAuthentication yes` and change it to `Password`
    **Authentication no**. Save the file and restart SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – Restarting sshd](img/B18212_12_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.15 – Restarting sshd
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, securing SSH is not only a matter of technological implementation
    but a fundamental component of comprehensive cybersecurity strategies, contributing
    to the resilience and trustworthiness of IT systems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided Linux administrators with a deep understanding of SELinux
    modes and how they influence system security. We explored the concepts of enforcing
    and permissive modes and their significance in the context of Linux administration.
    Administrators need to learn to leverage these modes to strike a balance between
    security and system functionality, ensuring that SELinux policies are effectively
    enforced. This chapter also covered the crucial topic of *enabling or disabling
    SELinux Boolean values*. We delved into the reasons, importance, and practical
    use of SELinux Boolean values, demonstrating how they allow administrators to
    fine-tune security policies to meet specific system requirements. By enabling
    or disabling Boolean values, administrators gain flexibility in tailoring SELinux
    policies to their system’s needs while maintaining a high level of security. Another
    essential aspect of system security that we explored in this chapter was *locking
    user accounts in SELinux security*. Here, you discovered the reasons for locking
    user accounts, the importance of doing so, and the methods to achieve it within
    the SELinux framework. This knowledge should have equipped you to effectively
    manage user access and enhance the overall security posture of your system.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we delved into securing SSH, a critical component of remote system
    administration. Administrators learn best practices for securing SSH, including
    changing the default SSH port, disabling password authentication in favor of public
    key authentication, and limiting SSH access to specific users or groups. By implementing
    these security measures, administrators bolster the security of remote access
    to their Linux systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore the world of cloud computing and how Linux
    plays a pivotal role in it. This chapter will take you on a journey through running
    Linux machines on the cloud, creating Linux instances, and various administrative
    tasks within a cloud-based Linux environment. By the end, you will have the knowledge
    and skills to thrive in the cloud computing era.
  prefs: []
  type: TYPE_NORMAL
