- en: '*Chapter 7*: Network-Based File Synchronization'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：基于网络的文件同步'
- en: Copying content over a network is usually done manually. For example, we just
    use SCP or FTP to transfer a file and that's that. But what happens if we need
    to make this process a permanent one? We then need to figure out a way to do file/directory
    synchronization, which is what `rsync` is all about. That being said, with all
    of the security-related incidents in the past few years, it's always a good idea
    to implement some kind of encryption, so using `SSH` and `SCP` seems like a reasonable
    approach, and that's exactly what we are going to do.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络复制内容通常是手动进行的。例如，我们只是使用 SCP 或 FTP 来传输文件，仅此而已。但是，如果我们需要使这个过程变成一个永久性的操作该怎么办呢？这时我们就需要找到一种方法来实现文件/目录同步，这正是
    `rsync` 的用途。话虽如此，考虑到过去几年中的安全相关事件，实施某种加密措施总是明智的做法，因此使用 `SSH` 和 `SCP` 似乎是一个合理的选择，这正是我们接下来要做的。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Learning how to use SSH and SCP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用 SSH 和 SCP
- en: Learning how to use `rsync`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用`rsync`
- en: Using `vsftpd`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `vsftpd`
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For these recipes, we're going to use two Linux machines – we can use the `client1`
    and `gui1` virtual machines from our previous chapters. These recipes will work
    on both CentOS and Ubuntu, so there is no reason to use separate virtual machines
    for these scenarios.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些操作，我们将使用两台 Linux 机器——可以使用我们之前章节中的 `client1` 和 `gui1` 虚拟机。这些操作适用于 CentOS
    和 Ubuntu，因此没有必要为这些场景使用不同的虚拟机。
- en: So, let's start our virtual machines and let's get cracking!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们启动虚拟机并开始吧！
- en: Learning how to use SSH and SCP
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何使用 SSH 和 SCP
- en: Back in the 1990s, it was a pretty natural thing to use the `T``elnet`, `rlogin`,
    and FTP protocols. Come to think of it, using (anonymous) FTP is still done a
    lot. Bearing in mind that most local networks in the 1990s were based around network
    hubs (not switches) and the fact that all of these protocols are plain-text protocols
    that are easy to eavesdrop on via network sniffers, it really isn't all that strange
    that we're not using these devices and/or protocols as much anymore. As book authors,
    we haven't heard of anyone using rlogin since the late 1990s, although Telnet
    is still widely used to configure network devices (mostly switches and routers).
    This is the reason why SSH was developed (as a Telnet/rlogin replacement), and,
    along with SSH, SCP was developed (as a replacement for FTP). To put things into
    perspective, the first version of SSH was released in the mid-1990s. Let's see
    how it works.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1990 年代，使用 `Telnet`、`rlogin` 和 FTP 协议是非常自然的事情。想一想，使用（匿名）FTP 到现在仍然是很常见的。考虑到
    1990 年代大多数局域网都是基于网络集线器（而非交换机），以及这些协议都是明文协议，容易通过网络嗅探器进行窃听，实际上我们现在不再频繁使用这些设备和/或协议也并不奇怪。作为书籍作者，我们从
    1990 年代末期就没听说过有人在使用 rlogin，尽管 Telnet 仍然广泛用于配置网络设备（主要是交换机和路由器）。这就是 SSH 开发的原因（作为
    Telnet/rlogin 的替代品），并且随之而来的是 SCP 的开发（作为 FTP 的替代品）。为了让大家有个大致了解，第一版 SSH 是在 1990
    年代中期发布的。让我们来看看它是如何工作的。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We just need one Ubuntu and one CentOS machine for this recipe. Let's say we
    are going to use `cli1` and `cli2` to master these commands.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一台 Ubuntu 机器和一台 CentOS 机器来进行这次操作。假设我们将使用 `cli1` 和 `cli2` 来掌握这些命令。
- en: How to do it…
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Our first scenario is going to be connecting from one machine to another by
    using `SSH`. We are going to presume that we don't have all of the necessary packages
    installed – just enough to cover our bases. We know that there are a lot of IT
    people out there who try to install the smallest number of packages possible on
    their servers/containers, so these extra steps shouldn't be much of a problem.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个场景将是通过使用 `SSH` 从一台机器连接到另一台机器。我们假设我们没有安装所有必要的软件包——仅安装了足够的基础包。我们知道很多 IT
    人员会尽量减少服务器/容器上安装的软件包数量，因此这些额外的步骤应该不会成为大问题。
- en: 'On an Ubuntu-based machine, we can do it like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Ubuntu 的机器上，我们可以这样做：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On a CentOS machine, we can do it like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 机器上，我们可以这样做：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For both of them, we need to start the service and enable it if we want to
    use it permanently:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种情况，如果我们希望永久使用该服务，需要启动服务并启用它：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As a replacement for insecure technologies such as Telnet, rlogin, and FTP,
    SSH is pretty straightforward to use. We just need to learn the basic syntax.
    Let''s say that we want to log in *from* a user called `student` on Linux machine
    `cli1` *to* a user called `student` on Linux machine `cli2`. As we''re logging
    in from a user called `student` to a user called `student`, there are two ways
    to do that. Here''s the first:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为不安全技术（如 Telnet、rlogin 和 FTP）的替代方案，SSH 使用起来非常简单。我们只需要学习基本的语法。假设我们想从 Linux 主机
    `cli1` 上的 `student` 用户登录到 Linux 主机 `cli2` 上的 `student` 用户。由于我们是从名为 `student` 的用户登录到同样是名为
    `student` 的用户，因此有两种方法可以实现。这里是第一种方法：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And here''s the second:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二种方法：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The reason is simple: if we''re logging in to the same user that we''re using
    on our source Linux machine, we don''t need to explicitly say which account we''re
    logging in to.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很简单：如果我们登录的是与源 Linux 机器上的用户相同的用户，就不需要明确指定登录的账户。
- en: 'If we, however, wanted to go from the `student` user on `cli1` to some other
    user on `cli2`, then we have to use the remote username as a parameter. Again,
    we can do it in two ways. Here''s the first:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想从 `cli1` 上的 `student` 用户登录到 `cli2` 上的其他用户，则必须使用远程用户名作为参数。我们可以用两种方式来实现。这里是第一种方法：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And here''s the second:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个方法：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can generalize that to cover any remote user on any remote machine. Commands
    for that scenario would look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个命令进行一般化，适用于任何远程用户和远程机器。该场景下的命令如下：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是这样：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another part of the SSH stack is a command called `SCP`. We use SCP to copy
    files from one machine to another machine by using SSH as a backend (secure copy).
    So, let''s use an example. Let''s say that we want to copy a file called `source.txt`
    from the `student` user''s home directory on `cli1` to the `student` user''s home
    directory on `cli2`. We would use the following command to do that:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 堆栈的另一个部分是一个名为 `SCP` 的命令。我们使用 SCP 通过 SSH 后端（安全拷贝）将文件从一台机器复制到另一台机器。假设我们想将
    `cli1` 上 `student` 用户的主目录中的文件 `source.txt` 复制到 `cli2` 上 `student` 用户的主目录。我们可以使用以下命令来实现：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or, if we were already in the `/home/student` directory on the source machine,
    we would use this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们已经在源机器上的 `/home/student` 目录中，我们可以使用以下命令：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Generally speaking, `SCP` has a simple syntax:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，`SCP` 语法很简单：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It''s just that the source and destination can have a lot of letters that need
    to be typed. Let''s explain that point by using another interesting use case for
    SCP. We can use it to download files from remote machines to local machines as
    well. The syntax is similar but can be a bit confusing when we''re doing it the
    first couple of times. So, let''s say that we want to copy a file called `source.txt`
    from the home directory of the `student` user on `cli2` to the `/tmp` directory
    on `cli1`, logged in as the `student` user on `cli1`. We would use the following
    command to do that:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 只是源和目标可能有很多字母需要输入。我们可以通过另一个有趣的 SCP 使用案例来解释这一点。我们还可以使用 SCP 将文件从远程机器下载到本地机器。语法类似，但在我们第一次使用时可能会有些困惑。所以，假设我们想将
    `cli2` 上 `student` 用户的主目录中的文件 `source.txt` 复制到 `cli1` 上 `/tmp` 目录中（已登录为 `cli1`
    上的 `student` 用户）。我们可以使用以下命令来实现：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The syntax follows the same rule (`scp` source destination), it's just that
    the source is now a remote file, and the destination is a local directory. It
    makes sense, when we think about it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 语法遵循相同的规则（`scp` 源 目标），只是源现在是远程文件，目标是本地目录。当我们考虑到这一点时，这一逻辑就显得合理了。
- en: 'The next step in our process is going to be installing secure shell keys. This
    means that – in our example – we will enable `passwordless login` from one server
    to the other. We can avoid that, but let''s forget about that for the time being;
    we are going to cover it in a second as we are not discussing security implications
    here. We are only trying to get the environment ready for SSH and SCP from a local
    user (let''s say, `student`) to a remote user (let''s say, `student`). So, let''s
    do that:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们过程中的下一步是安装安全的 Shell 密钥。这意味着——在我们的示例中——我们将启用从一台服务器到另一台服务器的 `无密码登录`。我们可以避免这样做，但暂时先不讨论这个问题；我们会在接下来讨论它，因为我们现在并不讨论安全问题。我们只是在为从本地用户（假设为
    `student`）到远程用户（假设为 `student`）的 SSH 和 SCP 环境做好准备。现在，让我们开始吧：
- en: '![Figure 7.1 – Creating an SSH key with an empty private key'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – 创建一个空的私钥的 SSH 密钥](img/Figure_7.1_B16269.jpg)'
- en: '](img/Figure_7.1_B16269.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B16269.jpg)'
- en: Figure 7.1 – Creating an SSH key with an empty private key
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 创建一个空的私钥的 SSH 密钥
- en: 'Let''s now copy this key to the remote machine (`cli2`) and test if the `SSH`
    key copying process worked by trying to log in as that user. For the first part,
    we are going to use the command called `ssh-copy-id` (to copy the key to the remote
    machine), and then use SSH to try to log in to test if the `SSH` key was properly
    copied:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将此密钥复制到远程机器（`cli2`）并通过尝试以该用户身份登录来测试 `SSH` 密钥复制过程是否有效。对于第一部分，我们将使用名为 `ssh-copy-id`
    的命令（将密钥复制到远程机器），然后使用 SSH 尝试登录以测试 `SSH` 密钥是否正确复制：
- en: '![Figure 7.2 – Copying the SSH key to the remote machine and testing if it
    works'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – 将 SSH 密钥复制到远程机器并测试其是否有效'
- en: '](img/Figure_7.2_B16269.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B16269.jpg)'
- en: Figure 7.2 – Copying the SSH key to the remote machine and testing if it works
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 将 SSH 密钥复制到远程机器并测试其是否有效
- en: 'As we can see, everything works from `cli1` to `cli2`. Let''s now repeat the
    same process in the opposite direction, because we are going to need that a bit
    later for another part of this recipe. First, let''s create an `SSH` key:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`cli1` 到 `cli2` 一切正常。现在让我们反方向重复相同的过程，因为稍后我们需要它来完成本食谱的另一部分。首先，让我们创建一个 `SSH`
    密钥：
- en: '![Figure 7.3 – Creating an SSH key for student@cli2'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – 为 student@cli2 创建 SSH 密钥'
- en: '](img/Figure_7.3_B16269.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B16269.jpg)'
- en: Figure 7.3 – Creating an SSH key for student@cli2
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 为 student@cli2 创建 SSH 密钥
- en: 'Then, let''s copy it to the remote server:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们将其复制到远程服务器：
- en: '![Figure 7.4 – Copying the SSH key from cli2 to cli1 and testing if it works'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – 将 SSH 密钥从 cli2 复制到 cli1 并测试其是否有效'
- en: '](img/Figure_7.4_B16269.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.4_B16269.jpg)'
- en: Figure 7.4 – Copying the SSH key from cli2 to cli1 and testing if it works
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 将 SSH 密钥从 cli2 复制到 cli1 并测试其是否有效
- en: 'We can see that in both of these examples, the remote server that we''re connecting
    to doesn''t ask us for a password. The reason for that is simple: when we were
    creating an `SSH` key, `ssh-keygen` gave us two very important things to input:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在这两个示例中，连接到的远程服务器并没有要求我们输入密码。原因很简单：当我们创建 `SSH` 密钥时，`ssh-keygen` 给了我们两个非常重要的输入内容：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we pressed the *Enter* key on the first question and confirmed it by pressing
    *Enter* again on the second one, that means that we created an `SSH` key that
    has an empty private key. And that's exactly what we did in our example. We didn't
    select any specific passphrase, therefore leaving it empty. If we wanted to use
    a custom private key, we just needed to type it in those two steps.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在第一个问题上按下 *Enter* 键，并在第二个问题上再次按 *Enter* 键确认，那就意味着我们创建了一个没有私钥的 `SSH` 密钥。正如我们在示例中所做的那样，我们没有选择任何特定的密码短语，因此将其留空。如果我们想使用自定义私钥，我们只需要在这两步中输入它。
- en: How it works…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As a protocol, SSH is an encrypted answer to the non-existent security of Telnet,
    `rlogin`, and FTP. These three plain-text protocols were easy to hack, especially
    in the good old days before we started using network switches (while we were still
    mostly using network hubs). Its first implementation goes way back to 1995\. It
    can also be used as a tunneling protocol, and it was heavily used for that back
    in the day – for example, for proxying FTP and HTTP traffic. Nowadays, it's used
    more for tunneling for remote X applications (XDMCP) or even connections to SSH
    to servers behind an SSH-based tunneling host.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种协议，SSH 是对 Telnet、`rlogin` 和 FTP 这些不存在安全性的协议的加密回应。这三种纯文本协议很容易被黑客攻击，特别是在我们开始使用网络交换机之前的那个“好日子”（那时我们大多使用的是网络集线器）。它的第一次实现可以追溯到
    1995 年。它还可以作为隧道协议使用，过去曾广泛用于此——例如，用于代理 FTP 和 HTTP 流量。如今，它更多用于为远程 X 应用程序（XDMCP）或甚至
    SSH 连接到通过基于 SSH 的隧道主机连接的服务器提供隧道服务。
- en: 'In simple terms, SSH works like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，SSH 的工作方式如下：
- en: The SSH client connects to the SSH server, therefore starting the connection.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH 客户端连接到 SSH 服务器，从而启动连接。
- en: The server responds and gives the client its public key.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器响应并将其公钥提供给客户端。
- en: The server and client then try to negotiate the necessary encryption parameters,
    followed by a secure channel being opened between the server and client.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，服务器和客户端尝试协商必要的加密参数，接着在服务器和客户端之间打开安全通道。
- en: The application or user logs in the server.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序或用户登录到服务器。
- en: For those of us familiar with SSL/TLS, it's kind of similar to both of these
    protocols as all of these protocols are TCP-based; they have a negotiating mechanism
    and are generally used for security purposes. Yes, they go about it in a slightly
    different way and their use cases are a bit different, but that still doesn't
    mean that they're vastly different in terms of the general principle.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉SSL/TLS的朋友来说，它有点类似这两种协议，因为这些协议都是基于TCP的；它们有协商机制，并且通常用于安全目的。是的，它们以略有不同的方式工作，使用场景也略有不同，但这并不意味着它们在总体原理上有很大差异。
- en: The next stop on our journey is `rsync`, and we are going to explicitly use
    `SSH` as a backend to `rsync`. That's the reason why we made our `SSH` keys, especially
    the ones without an additional private key (passphrase). Let's now learn how to
    work with `rsync`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们旅程中的下一站是`rsync`，并且我们将明确地使用`SSH`作为`rsync`的后端。这就是我们制作`SSH`密钥的原因，尤其是那些没有额外私钥（密码短语）的密钥。现在，让我们学习如何使用`rsync`。
- en: There's more…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'If you need more information about networking in CentOS and Ubuntu, make sure
    that you check out the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于CentOS和Ubuntu网络的资料，请确保查看以下内容：
- en: 'How does SSH work: [https://www.hostinger.com/tutorials/ssh-tutorial-how-does-ssh-work](https://www.hostinger.com/tutorials/ssh-tutorial-how-does-ssh-work)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSH是如何工作的：[https://www.hostinger.com/tutorials/ssh-tutorial-how-does-ssh-work](https://www.hostinger.com/tutorials/ssh-tutorial-how-does-ssh-work)
- en: 'What is the **Secure Shell** (**SSH**) protocol: [https://www.sdxcentral.com/security/definitions/what-is-the-secure-shell-ssh-protocol/](https://www.sdxcentral.com/security/definitions/what-is-the-secure-shell-ssh-protocol/)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全外壳协议** (**SSH**) 是什么：[https://www.sdxcentral.com/security/definitions/what-is-the-secure-shell-ssh-protocol/](https://www.sdxcentral.com/security/definitions/what-is-the-secure-shell-ssh-protocol/)'
- en: Learning how to use rsync
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何使用rsync
- en: In our previous recipe, we worked with SSH from the client standpoint. We used
    SSH and `SCP` to both log in and copy files from source to destination. We discussed
    how to use a username/password combination to log in to a remote system, as well
    as how to use SSH key-based authentication. If we focus on SCP for a second, there's
    one thing that we didn't discuss, and that is how to *synchronize* the local source
    to the local destination, or, even better, how to create a scenario in which we
    synchronize the local source to a remote destination and vice versa between two
    Linux servers in place. This is where it's best to use `rsync`, a tool that's
    meant to do just that. Let's get cracking.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们从客户端的角度使用了SSH。我们使用SSH和`SCP`同时登录并将文件从源复制到目标。我们讨论了如何使用用户名/密码组合登录远程系统，以及如何使用基于SSH密钥的身份验证。如果我们稍微集中讨论SCP，有一件事情我们没有讨论，那就是如何*同步*本地源到本地目标，或者更好的是，如何在两个Linux服务器之间创建一个同步本地源到远程目标，反之亦然的场景。这时使用`rsync`，一个专门用于完成这一任务的工具，是最好的选择。让我们开始吧。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will continue using our `cli1` and `cli2` machines, running Ubuntu and CentOS.
    Let''s get ready by making sure that the necessary packages are installed. We
    need to use this command for Ubuntu:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用我们的`cli1`和`cli2`机器，分别运行Ubuntu和CentOS。让我们先确保安装了必要的软件包。我们需要使用以下命令来操作Ubuntu：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We use the following command for CentOS:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令来操作CentOS：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After that, we are ready to start.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们准备开始。
- en: How to do it…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We are going to talk about a couple of scenarios:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论几个场景：
- en: Synchronization between local source and local destination
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地源和本地目标之间的同步
- en: Synchronization between local source and remote destination, or vice versa
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地源和远程目标之间的同步，或反之亦然
- en: There could be a number of other sub-scenarios, such as dealing with one-way
    sync and deleting files on source, `rsync` is just one subdirectory, and so on.
    We are just going to deal with these two in detail, and then add a couple of bits
    and pieces from these sub-scenarios.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还会有许多其他子场景，例如处理单向同步和删除源上的文件，`rsync`只是一个子目录等等。我们将详细处理这两个场景，然后从这些子场景中补充一些细节。
- en: 'Let''s deal with the simple scenario first: how to synchronize a folder that''s
    placed locally to another locally placed folder. Let''s say that we want to synchronize
    (basically, create a backup of) the `/etc` folder, and that we want to synchronize
    it to the `/root/etc` folder. We can do that by using the following commands as
    `root` (using the `cli1` machine as an example):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先处理一个简单的场景：如何将一个本地文件夹同步到另一个本地文件夹。假设我们要同步（基本上是创建一个备份）`/etc` 文件夹，并且我们想将它同步到
    `/root/etc` 文件夹。我们可以通过以下命令作为 `root` 用户来实现（以 `cli1` 机器为例）：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The two options used, `a` and `v`, are there to use archiving mode (preserve
    permissions and ownerships) and verbose mode so that we can see the output of
    every copy operation. We don't need to create the `/etc` folder in the `/root`
    directory up front or put `/root/etc` as the destination folder because a folder
    named `etc` is going to be created automatically in `/root` upon command execution.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的两个选项，`a` 和 `v`，分别是为了启用归档模式（保留权限和所有权）和详细模式，以便我们能够看到每次复制操作的输出。我们不需要提前在 `/root`
    目录中创建 `/etc` 文件夹或将 `/root/etc` 作为目标文件夹，因为在执行命令时，名为 `etc` 的文件夹会自动在 `/root` 中创建。
- en: 'If we wanted to exclude some files from copying (for example, all files that
    have the `.conf` extension), we can do it like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想排除某些文件不进行复制（例如，所有以 `.conf` 扩展名结尾的文件），我们可以这样做：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are other cool options available in `rsync` that could make certain scenarios
    possible. Let''s say that we want to copy files that are a maximum of 5 MB in
    size, or a minimum of 3 MB in size. We could do that by using the following syntax:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `rsync` 中，还有一些其他很酷的选项可以使某些场景成为可能。假设我们想要复制最大为 5 MB，或最小为 3 MB 的文件。我们可以通过以下语法来实现：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For example, if the source directory has a lot of large files in the second
    example (minimum size), we might want to add a `--progress` option to the `rsync`
    command so that we can have interactive output telling us about the progress being
    made.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果源目录在第二个示例中有很多大文件（最小大小），我们可能想要为 `rsync` 命令添加一个 `--progress` 选项，这样我们就能通过交互式输出看到进度。
- en: 'Now let''s work on one-way sync from a remote to a local destination. The opposite
    direction is almost the same, we just need to change the source and destination
    fields in `rsync`. So, let''s say that we have a source directory on `cli2` called
    `/home/student/source`. That directory has files and subfolders; it has a hierarchy
    of files and folders. We want to synchronize that content to `cli1`, specifically,
    to the `/tmp` directory. Here''s the content of our source directory:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理从远程到本地目标的单向同步。相反的方向几乎是一样的，我们只需要在 `rsync` 中交换源和目标字段。所以，假设我们在 `cli2` 上有一个名为
    `/home/student/source` 的源目录。该目录包含文件和子文件夹，它有一个文件和文件夹的层次结构。我们希望将这些内容同步到 `cli1`，具体来说，同步到
    `/tmp` 目录。下面是我们的源目录内容：
- en: '![Figure 7.5 – Source directory on cli2, located at /home/student/source'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5 – 位于 /home/student/source 的 cli2 上的源目录'
- en: '](img/Figure_7.5_B16269.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.5_B16269.jpg)'
- en: Figure 7.5 – Source directory on cli2, located at /home/student/source
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 位于 /home/student/source 的 cli2 上的源目录
- en: 'This is what we should do, provided that we have the source material ready:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们应该做的，前提是我们已经准备好了源文件：
- en: '![Figure 7.6 – rsync from the remote source directory'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – 从远程源目录使用 rsync'
- en: '](img/Figure_7.6_B16269.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.6_B16269.jpg)'
- en: Figure 7.6 – rsync from the remote source directory
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 从远程源目录使用 rsync
- en: So, we just used one simple command, `rsync -rt` (`-r` means recursive, `-t`
    is to preserve times), with the source and destination as parameters, and the
    source directory was successfully transferred to our local directory. This is
    because we copied the `SSH` keys in the previous recipe, so we didn't need to
    do any authentication, which makes the overall process very easy and straightforward.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们只用了一个简单的命令，`rsync -rt`（`-r` 表示递归，`-t` 用来保留时间），将源和目标作为参数，源目录成功地被传输到本地目录。这是因为我们在前面的操作中复制了
    `SSH` 密钥，所以我们不需要进行身份验证，这使得整个过程变得非常简单和直接。
- en: 'The next scenario is going to be about syncing the source and destination and
    then deleting source files. Specifically, we''re syncing *files*, *not folders*,
    as there are different options for those scenarios. Let''s see how that''s done:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个场景将讨论同步源和目标后删除源文件。具体来说，我们是同步 *文件*，*而不是文件夹*，因为这些场景有不同的选项。让我们看看如何做到这一点：
- en: '![Figure 7.7 – rsync from the remote server using SSH keys,'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7 – 使用 SSH 密钥从远程服务器同步文件,'
- en: and deleting source files after the download is done
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 并在下载完成后删除源文件
- en: '](img/Figure_7.7_B16269.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.7_B16269.jpg)'
- en: Figure 7.7 – rsync from the remote server using SSH keys, and deleting source
    files after the download is done
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 使用SSH密钥从远程服务器`rsync`，并在下载完成后删除源文件
- en: 'Now, if we wanted to run the same scenario but delete all of the files and
    folders from `cli2` after the transfer is done, we''d need to separate that into
    two commands. Here''s how it works:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要运行相同的场景，但在传输完成后从`cli2`中删除所有文件和文件夹，我们需要将其分成两个命令。下面是它的工作方式：
- en: '![Figure 7.8 – Removing source files from the remote source directory,'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8 – 从远程源目录中删除源文件，'
- en: and then all subdirectories in the source directory
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后删除源目录中的所有子目录
- en: '](img/Figure_7.8_B16269.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.8_B16269.jpg)'
- en: Figure 7.8 – Removing source files from the remote source directory, and then
    all subdirectories in the source directory
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 从远程源目录中删除源文件，然后删除源目录中的所有子目录
- en: Now that we've shown this, we can also note a couple of other projects that
    will make it easier to do two-way sync. Projects such as Unison ([https://www.cis.upenn.edu/~bcpierce/unison/](https://www.cis.upenn.edu/~bcpierce/unison/))
    and `bsync` ([https://github.com/dooblem/bsync](https://github.com/dooblem/bsync))
    have implemented two-way sync methods that are very difficult to achieve by using
    `rsync`. Make sure that you check them out if you need two-way sync.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经展示了这一点，我们还可以注意到其他几个项目，这些项目将使双向同步变得更加容易。像Unison（[https://www.cis.upenn.edu/~bcpierce/unison/](https://www.cis.upenn.edu/~bcpierce/unison/)）和`bsync`（[https://github.com/dooblem/bsync](https://github.com/dooblem/bsync)）这样的项目已经实现了非常难以通过`rsync`实现的双向同步方法。如果您需要双向同步，请务必查看它们。
- en: How it works…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理……
- en: '`rsync` is a source-destination type of command, and that covers its syntax
    and mode of operation if we''re using it interactively (no destination `rsync`
    service is involved). There can also be an `rsync` service involved, which usually
    changes the mode of operation significantly. It''s important to point out that
    using `rsync` as a command (in combination with SSH) is most commonly done for
    backups. We''ve been using it in this fashion for 15 or more years in some of
    our environments, and it works perfectly.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`rsync`是一种源-目标类型的命令，涵盖了其交互使用时的语法和操作模式（不涉及目标`rsync`服务）。也可以涉及`rsync`服务，这通常显著改变了操作模式。重要的是要指出，作为命令使用`rsync`（结合SSH）最常用于备份。我们在某些环境中使用这种方式已经超过15年了，效果非常完美。'
- en: '`rsyncd` (the `rsync` service) is usually aimed at a completely different usage
    model – most commonly, software mirrors. If we want to create a local CentOS or
    Ubuntu mirror, the rule of the thumb is that we''ll use `rsyncd`, as it allows
    us to do much more finely grained configuration in terms of what needs to be done
    as part of the `rsync` process. There might be other reasons to do it – for example,
    we can configure `rsyncd` to not use `SSH` and gain a bit of speed in doing so.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`rsyncd`（`rsync`服务）通常针对完全不同的使用模型，最常见的是软件镜像。如果我们想创建本地的CentOS或Ubuntu镜像，一般会使用`rsyncd`，因为它允许我们在`rsync`过程中进行更精细的配置。可能还有其他原因，比如我们可以配置`rsyncd`而不使用`SSH`，从而提高一些速度。'
- en: Now that we have discussed some of the key concepts of SSH, SCP, and `rsync`,
    it's time to move on to their – at least by default – much more insecure cousin,
    called `vsftpd`. We are going to make sure that we make it more secure, though,
    as there's absolutely no reason not to. So, let's get ready to configure `vsftpd`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了SSH、SCP和`rsync`的一些关键概念，是时候继续介绍它们——至少默认情况下——更不安全的表兄`vsftpd`。尽管如此，我们将确保将其更安全化，因为绝对没有理由不这样做。所以，让我们准备好配置`vsftpd`。
- en: There's more…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'If you need to learn more about `rsync`, we recommend the following links:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要了解更多关于`rsync`的信息，我们建议查阅以下链接：
- en: 'How to set up an `rsync` daemon on your Linux server: [https://www.atlantic.net/vps-hosting/how-to-setup-rsync-daemon-linux-server/](https://www.atlantic.net/vps-hosting/how-to-setup-rsync-daemon-linux-server/)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在您的Linux服务器上设置`rsync`守护程序：[https://www.atlantic.net/vps-hosting/how-to-setup-rsync-daemon-linux-server/](https://www.atlantic.net/vps-hosting/how-to-setup-rsync-daemon-linux-server/)
- en: '10 practical examples of the `rsync` command in Linux: [https://www.tecmint.com/rsync-local-remote-file-synchronization-commands/](https://www.tecmint.com/rsync-local-remote-file-synchronization-commands/)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux中`rsync`命令的10个实际示例：[https://www.tecmint.com/rsync-local-remote-file-synchronization-commands/](https://www.tecmint.com/rsync-local-remote-file-synchronization-commands/)
- en: '17 useful `rsync` (remote sync) command examples in Linux: [https://www.linuxtechi.com/rsync-command-examples-linux/](https://www.linuxtechi.com/rsync-command-examples-linux/)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 17个有用的`rsync`（远程同步）命令示例：[https://www.linuxtechi.com/rsync-command-examples-linux/](https://www.linuxtechi.com/rsync-command-examples-linux/)
- en: Using vsftpd
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用vsftpd
- en: 'The FTP service has been around for decades. Back in the mid-1990s, FTP was
    actually the vast majority of internet traffic. Yes, its importance in terms of
    traffic volume decreased over time, but it''s not only that. FTP, all by itself,
    is a completely open, plain-text protocol. The latest revision that''s been included
    in all major distributions is called `vsftpd`, and it''s been there for more than
    a decade now. We are going to focus on three scenarios in this recipe: getting
    `vsftpd` to work, getting `vsftpd` to work with a user''s home directories, and
    – last but not least – making `vsftpd` secure by implementing TLS and certificates.
    Let''s start!'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: FTP服务已经存在了几十年。早在1990年代中期，FTP实际上占据了互联网流量的绝大部分。是的，随着时间的推移，它在流量量级上的重要性下降了，但情况并不仅仅如此。FTP本身就是一个完全开放、明文传输的协议。所有主要发行版中包含的最新版本叫做`vsftpd`，它已经存在了十多年。我们将在本篇中关注三种场景：让`vsftpd`正常工作、让`vsftpd`与用户的主目录一起工作，以及——最后但同样重要——通过实施TLS和证书来使`vsftpd`变得更加安全。让我们开始吧！
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Keep the `cli1` and `cli2` virtual machines powered on and let''s continue
    using our shell. Let''s make sure that the necessary packages are installed by
    using our standard commands. So, for Ubuntu, use this command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 保持`cli1`和`cli2`虚拟机开机，并继续使用我们的Shell。让我们通过使用标准命令来确保必要的包已经安装。对于Ubuntu，可以使用以下命令：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For CentOS, let''s use this command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CentOS，我们可以使用以下命令：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, let''s enable them and start it. We''re going to use the Ubuntu machine
    to show how `vsftpd` configuration should be done, but it''s almost 100% the same
    on CentOS. So `cli1` (Ubuntu) is going to act as a `vsftpd` server, and `cli2`
    (CentOS) is going to act as an `FTP` client. So, let''s run these commands on
    `cli1`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们启用它们并启动服务。我们将使用Ubuntu机器来展示`vsftpd`配置应该如何设置，但在CentOS上几乎是100%相同的。所以，`cli1`（Ubuntu）将作为`vsftpd`服务器，`cli2`（CentOS）将作为`FTP`客户端。那么，让我们在`cli1`上运行这些命令：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It would be prudent to configure firewalls to allow connections to necessary
    FTP ports (20, 21). So, on `cli1`, we need to do this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 配置防火墙允许连接到必要的FTP端口（20, 21）是明智之举。所以，在`cli1`上，我们需要执行以下操作：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'On the client side (`cli2`), let''s install `lftp`, a nice and simple-to-use
    `ftp` client, by using the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端（`cli2`）上，让我们使用以下命令安装`lftp`，一个既简单又好用的`ftp`客户端：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's now configure `vsftpd` in accordance with the three scenarios that we
    mentioned.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们根据我们提到的三种场景来配置`vsftpd`。
- en: How to do it…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Now that we have installed our packages, it's time to start configuring `vsftpd`
    on `cli1`. That means we need to go through some of the options in `/etc/vsftpd.conf`
    (usually, it's `/etc/vsftpd/vsftpd.conf` on CentOS).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了必要的包，是时候在`cli1`上开始配置`vsftpd`了。这意味着我们需要查看`/etc/vsftpd.conf`中的一些选项（通常，在CentOS上是`/etc/vsftpd/vsftpd.conf`）。
- en: 'Generally speaking, this configuration file is very well documented all by
    itself, so we should have no trouble configuring it to suit our needs. By default,
    it should let us use the `FTP` client to connect to it, but let''s make a couple
    of changes from the very start. Let''s allow anonymous FTP and not allow local
    users to log in. If we check the configuration file, that means that we need to
    configure the `anon_root`, `anonymous_enable`, and `local_enable` configuration
    options, so let''s do that. Let''s make sure that those two configuration lines
    look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，这个配置文件本身就有很好的文档说明，因此我们应该不会在配置它以适应我们的需求时遇到任何问题。默认情况下，它应该允许我们使用`FTP`客户端连接，但从一开始我们就做一些改变。让我们允许匿名FTP并禁止本地用户登录。如果我们检查配置文件，这意味着我们需要配置`anon_root`、`anonymous_enable`和`local_enable`这几个选项，所以我们就这么做。让我们确保这两行配置看起来是这样的：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also need to create some directories for this configuration to work:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一些目录，以确保此配置能够正常工作：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Restart the `vsftpd` service so that it works with the latest configuration:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动`vsftpd`服务，以便它能够与最新的配置一起工作：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On `cli2`, we have already installed `lftp`, and it is going to try to log
    in to the remote FTP server (`cli1`) anonymously by default. Let''s see how that
    works:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cli2`上，我们已经安装了`lftp`，它默认会尝试匿名登录到远程FTP服务器（`cli1`）。让我们来看看它是如何工作的：
- en: '![Figure 7.9 – Testing the FTP connection by using lftp'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.9 – 使用lftp测试FTP连接](img/Figure_7.9_B16269.jpg)'
- en: '](img/Figure_7.9_B16269.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.9_B16269.jpg)'
- en: Figure 7.9 – Testing the FTP connection by using lftp
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 使用lftp测试FTP连接
- en: 'We can see that we have no errors, but we also don''t have any content in the
    directory that the anonymous FTP service uses. On Ubuntu, that directory is located
    at `/srv/ftp`, but we already changed the anonymous root directory to `/var/ftp`.
    Let''s add a couple of files there and try to list the directory content in `lftp`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到没有错误，但在匿名FTP服务使用的目录中我们没有任何内容。在Ubuntu中，该目录位于`/srv/ftp`，但我们已经将匿名根目录更改为`/var/ftp`。让我们在这里添加几个文件，并尝试在`lftp`中列出目录内容：
- en: '![Figure 7.10 – Checking if we can see the files we created on cli1 by using
    the touch command'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.10 – 检查我们是否能看到通过touch命令在cli1上创建的文件'
- en: '](img/Figure_7.10_B16269.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.10_B16269.jpg)'
- en: Figure 7.10 – Checking if we can see the files we created on cli1 by using the
    touch command
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 检查我们是否能看到通过touch命令在cli1上创建的文件
- en: 'Let''s now try to download these files. To do that, FTP has a command called
    `get` (similar to how HTTP has a `get` command). Let''s now download these four
    files that we used the `touch` command on:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试下载这些文件。为此，FTP有一个叫做`get`的命令（类似于HTTP的`get`命令）。现在让我们下载这些我们用`touch`命令创建的四个文件：
- en: '![Figure 7.11 – Using FTP''s get command to retrieve multiple files from the
    FTP server'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.11 – 使用FTP的get命令从FTP服务器检索多个文件'
- en: '](img/Figure_7.11_B16269.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.11_B16269.jpg)'
- en: Figure 7.11 – Using FTP's get command to retrieve multiple files from the FTP
    server
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 使用FTP的get命令从FTP服务器检索多个文件
- en: If we wanted to upload files, we would need to use the `put` command but, of
    course, that wouldn't work as anonymous upload is forbidden by default (as it
    should be).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想上传文件，我们需要使用`put`命令，但当然，这不会生效，因为默认情况下匿名上传是禁止的（这是应该的）。
- en: 'The next part of our scenario is to allow the user to log in to the user''s
    home directory. That shouldn''t be too hard, as we already mentioned the first
    option that we need to change, `local_enable`, and it needs to be set to `YES`.
    After that, we need to restart the `vsftpd` service. After we do that, we need
    to log in to the FTP server as a local user on the FTP server. Bearing in mind
    that we have a user called `student` there, let''s log in to that one:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们场景的下一部分是允许用户登录到用户的主目录。这应该不会太难，因为我们已经提到过需要更改的第一个选项，`local_enable`，它需要设置为`YES`。之后，我们需要重启`vsftpd`服务。完成后，我们需要以本地用户身份登录到FTP服务器。考虑到我们有一个叫做`student`的用户，我们就用这个账户登录：
- en: '![Figure 7.12 – Logging in as the student user via lftp (by using the -u option)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.12 – 通过lftp以student用户身份登录（使用-u选项）'
- en: '](img/Figure_7.12_B16269.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.12_B16269.jpg)'
- en: Figure 7.12 – Logging in as the student user via lftp (by using the -u option)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 通过lftp以student用户身份登录（使用-u选项）
- en: No problems so far. But all of these recipes were done on the premise that we're
    doing all this within the limits of our internal, secure network. What happens
    if our FTP server needs to be exposed to the internet? We don't want to use just
    regular, plain-text FTP as it would lead to disaster. So, the next step in our
    recipe is going to be to configure FTP with TLS.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止没有问题。但是所有这些步骤的前提是我们在一个内部的安全网络范围内进行操作。如果我们的FTP服务器需要暴露到互联网上会怎样？我们不想仅仅使用普通的明文FTP，因为那样会带来灾难。所以，我们的下一步是将FTP配置为使用TLS。
- en: 'We need to configure a couple of options in `vsftpd.conf`, and we can freely
    put these options at the end of that file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`vsftpd.conf`中配置几个选项，我们可以自由地将这些选项放在文件的末尾：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We need to configure these options in accordance with our security requirements.
    Most commonly, we want to enable TLS 1.2 or 1.3 (`ssl_ciphers=HIGH`, `SSLv2`,
    and `v3=no`). We can always not allow anonymous users to use `SSL`, and if we
    don't want to run client certificate-based authentication, we have to make sure
    to use the `ssl_request_cert=NO` option.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要根据我们的安全要求配置这些选项。最常见的是，我们希望启用TLS 1.2或1.3（`ssl_ciphers=HIGH`，`SSLv2`和`v3=no`）。我们总是可以不允许匿名用户使用`SSL`，如果我们不想运行基于客户端证书的认证，我们必须确保使用`ssl_request_cert=NO`选项。
- en: At the beginning of this configuration, we can see the `cert` file and the corresponding
    private key configuration options. We just used the built-in, self-signed certificates.
    Of course, we can create Let's Encrypt certificates or buy commercial ones instead
    and put them in the configuration here. It's all about the corporate security
    policy where we want to run this sort of configuration.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置的开始部分，我们可以看到`cert`文件以及相应的私钥配置选项。我们只是使用了内置的自签名证书。当然，我们也可以创建Let's Encrypt证书，或者购买商业证书并将其放入这里的配置中。这完全取决于我们想要运行此类配置的企业安全策略。
- en: 'A quick note on FTP clients on Windows: a lot of people are using WinSCP to
    upload and download files and directories by using SCP, SFTP, FTP, WebDav, and
    Amazon S3 sources. If we use WinSCP, we have to use FTP configuration, TLS/SSL
    explicit encryption, and other relevant parameters accordingly. There are also
    other options available if we click on the `1.2` for both the minimum and maximum
    versions. But if we''ve set up our `vsftpd.conf` as we recommended, there''s no
    need to touch those options as **TLS v1.2** will be the only option available.
    We just wanted to mention these advanced options in case you need them.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Windows上的FTP客户端的简要说明：许多人使用WinSCP通过SCP、SFTP、FTP、WebDav和Amazon S3等协议上传和下载文件与目录。如果我们使用WinSCP，我们需要根据情况使用FTP配置、TLS/SSL显式加密以及其他相关参数。如果我们点击`1.2`，还可以选择最小版本和最大版本。但如果我们已经按推荐设置了`vsftpd.conf`，则无需调整这些选项，因为**TLS
    v1.2**将是唯一可用的选项。我们只是想提到这些高级选项，以防万一你需要它们。
- en: 'That being said, here''s a screenshot that will help in terms of basic options:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，这里有一张截图，能帮助了解基本选项：
- en: '![Figure 7.13 – How to connect to vsftpd with TLS 1.2 enabled'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.13 – 如何连接到启用TLS 1.2的vsftpd'
- en: '](img/Figure_7.13_B16269.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.13_B16269.jpg)'
- en: Figure 7.13 – How to connect to vsftpd with TLS 1.2 enabled
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 – 如何连接到启用TLS 1.2的vsftpd
- en: '`192.168.0.16` is the IP address of the `cli1` machine. By using all of the
    options mentioned previously, we''re able to log in anonymously to our `vsftpd`
    server and use it, just as we used it before we did the TLS configuration. But,
    bearing in mind that there were dozens and dozens of various types of attacks
    on the `SSL` protocol in the past couple of years (POODLE, BEAST, CRIME, BREACH,
    Heartbleed, SSL Stripping, using untrusted and fake certificate authorities, and
    so on), it''s absolutely crucial that we pay close attention to every new attack
    and take all the necessary steps to mitigate those threats.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`192.168.0.16`是`cli1`机器的IP地址。通过使用之前提到的所有选项，我们可以匿名登录到`vsftpd`服务器并使用它，就像在进行TLS配置之前一样。但是，考虑到过去几年中`SSL`协议遭遇了成百上千种不同类型的攻击（如POODLE、BEAST、CRIME、BREACH、Heartbleed、SSL
    Stripping、使用不受信任的虚假证书颁发机构等），我们必须密切关注每一个新出现的攻击，并采取一切必要措施来减轻这些威胁。'
- en: How it works…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`vsftpd` is an implementation of FTP, which means it''s a TCP-based service
    that''s used to upload and download files. Seeing as it''s a TCP-based service,
    that means socket connections and reliable data transfer, which are essential
    to this service. Imagine if our file download or upload were to be unreliable;
    we definitely wouldn''t like that. If we were to add an additional layer of security
    to it by using TLS, we''d still be using the same basic service, it''s just that
    it''d be way more protected.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`vsftpd`是FTP的一种实现，意味着它是一个基于TCP的服务，用于上传和下载文件。由于它是一个基于TCP的服务，这意味着它涉及套接字连接和可靠的数据传输，这对该服务至关重要。想象一下，如果我们的文件下载或上传不可靠，我们肯定不希望发生这种情况。如果我们通过使用TLS为其增加一层额外的安全性，我们仍然在使用相同的基本服务，只是它将更加受保护。'
- en: FTP uses ports `20` (`ftp-data`) and `21` (`ftp`). Both of these ports need
    to be allowed through the firewall for the FTP service to work. Port `21` is used
    as the *command* communication channel, while port `20` is used for data transfer,
    although there are implementations where port `21` can be used for both. There
    are some other options when using the FTP service (active FTP and passive FTP)
    but they are way beyond the scope of this book. Generally speaking, there's a
    reason why almost everybody uses SCP for file upload and download nowadays. Also,
    there's a reason why most of the distribution repositories and mirrors switched
    to using HTTPS-based delivery methods instead of FTP-based methods. There are
    exceptions, but they are more the *exception to the rule* types of situations,
    definitely not the standard.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: FTP 使用端口 `20`（`ftp-data`）和 `21`（`ftp`）。这两个端口需要通过防火墙放行，以便 FTP 服务能够正常工作。端口 `21`
    用作*命令*通信通道，而端口 `20` 用于数据传输，尽管也有一些实现中端口 `21` 被同时用于两者。使用 FTP 服务时有其他选项（主动 FTP 和被动
    FTP），但这些超出了本书的范围。一般来说，几乎每个人如今都使用 SCP 进行文件上传和下载是有原因的。此外，绝大多数的发行版仓库和镜像站点也转而使用基于
    HTTPS 的交付方式而非 FTP。虽然也有例外情况，但这些更多是*例外情况*，绝不是标准做法。
- en: 'FTP uses `put` and `get` commands to do two of its basic functions: upload
    (`put`) and download (`get`). These are two basic commands/methods that FTP uses,
    although we can create and delete content via FTP as well.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: FTP 使用 `put` 和 `get` 命令来完成其基本功能：上传（`put`）和下载（`get`）。这两个是 FTP 使用的基本命令/方法，尽管我们也可以通过
    FTP 创建和删除内容。
- en: There's more
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'If you want to learn more about `vsftpd`, make sure that you check the following
    links:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于`vsftpd`的信息，确保查看以下链接：
- en: '`vsftpd` home page: [https://security.appspot.com/vsftpd.html](https://security.appspot.com/vsftpd.html)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vsftpd` 官方页面：[https://security.appspot.com/vsftpd.html](https://security.appspot.com/vsftpd.html)'
- en: '`vsftpd.conf` man page: [https://security.appspot.com/vsftpd/vsftpd_conf.html](https://security.appspot.com/vsftpd/vsftpd_conf.html)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vsftpd.conf` 手册页：[https://security.appspot.com/vsftpd/vsftpd_conf.html](https://security.appspot.com/vsftpd/vsftpd_conf.html)'
- en: 'How does an FTP server work and what are its benefits: [https://www.ftptoday.com/blog/how-does-an-ftp-server-work-the-benefits](https://www.ftptoday.com/blog/how-does-an-ftp-server-work-the-benefits)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTP 服务器是如何工作的，以及它有哪些好处：[https://www.ftptoday.com/blog/how-does-an-ftp-server-work-the-benefits](https://www.ftptoday.com/blog/how-does-an-ftp-server-work-the-benefits)
- en: 'How to set up `vsftpd` for anonymous downloads on Ubuntu 16.04: https://www.digitalocean.com/community/tutorials/how-to-set-up-vsftpd-for-anonymous-downloads-on-ubuntu-16-04'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Ubuntu 16.04 上设置 `vsftpd` 进行匿名下载：[https://www.digitalocean.com/community/tutorials/how-to-set-up-vsftpd-for-anonymous-downloads-on-ubuntu-16-04](https://www.digitalocean.com/community/tutorials/how-to-set-up-vsftpd-for-anonymous-downloads-on-ubuntu-16-04)
