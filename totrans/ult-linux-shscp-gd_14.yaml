- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using awk – Part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I’ll show you a bit about `awk`. It’s a programming environment
    with a long and storied history that dates back to the 1970s, when it was invented
    by Alfred Aho, Peter Weinberger, and Brian Kernighan for use with the early Unix
    operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways in which you can use `awk`. It is a full-blown programming
    language, so you can use it to write very complex, stand-alone programs. You can
    also create simple `awk` commands that you can either run from the command-line
    or from within normal shell scripts. There’s a lot to `awk`, and entire books
    have been written about it. The goal for this chapter is to show you how to use
    `awk` in normal shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing `awk`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding patterns and actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining input from text files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining input from commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re ready to squawk with `awk`, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing awk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`awk` is a pattern-scanning and text-processing utility that you can use to
    automate the process of creating reports and databases. With its built-in math
    functions, you can also use it to perform spreadsheet operations on text files
    of columnar, numerical data. The term `awk` comes from the names of its creators,
    Aho, Weinberger and Kernighan. The original version is now referred to as “old
    `awk`". Newer implementations, such as `nawk` and `gawk`, have more features and
    are somewhat easier to use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The version of `awk` you have depends upon which operating system you’re running.
    Most Linux operating systems run `gawk`, which is the GNU implementation of `awk`.
    There’s most always an `awk` symbolic link that points to the `gawk` executable,
    as you see here on my Fedora workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A notable exception is with Alpine Linux, which by default uses the lightweight
    `awk` implementation that’s built into the `busybox` executable. However, both
    `gawk` and `mawk`, another `awk` implementation, are available for installation
    from the Alpine repositories. (I couldn’t find a definitive answer for why `mawk`
    is called `mawk`. But, its author is Michael Brennan, so I’m guessing that it’s
    supposed to stand for “Michael’s `awk`".)
  prefs: []
  type: TYPE_NORMAL
- en: Unix and Unix-like operating systems, such as macOS, OpenIndiana, and the various
    BSD distros, use `nawk`, which is short for “new `awk`". You’ll sometimes see
    this referred to as the “one true `awk`", partly because Brian Kernighan, one
    of the authors of the original `awk`, is one of its maintainers. However, `gawk`
    is available for installation for both FreeBSD and OpenIndiana, and `mawk` is
    available for FreeBSD.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what are the differences between these different `awk` implementations?
    Well, here’s a quick run-down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`busybox`: The `awk` implementation that’s built into `busybox` is super lightweight,
    and is ideal for low-resource embedded systems. This is why it’s the default choice
    for Alpine Linux, which is also popular for embedded systems. Be aware though
    that it might not always have the features that you need for complex `awk` commands
    or scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nawk`: As I’ve already mentioned, `nawk` is the default choice for most Unix
    and Unix-like systems such as FreeBSD, OpenIndiana, and macOS. But, the executable
    file you’ll find on these systems is normally just `awk`, instead of `nawk`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mawk`: This is supposed to be a faster version of `awk`, which was created
    by Mike Brennan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gawk`: This implementation has features that the other implementations don’t
    have. One major enhancement is the inclusion of **internationalization and localization**
    capabilities, which facilitates creating software for different languages and
    locales. It also includes TCP/IP networking capabilities and enhanced features
    for dealing with regular expressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless I state otherwise, I’ll be showing you coding techniques that work the
    same on both `nawk` and `gawk`. So, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Patterns and Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An `awk` **pattern** is simply the text or the regular expression upon which
    an **action** will operate. The source can be either a plain text file or the
    output of another program. To begin, let’s dump the entire contents of the `/etc/passwd`
    file to the screen, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command, the `{print $0}` part is the action, which must be surrounded
    by a pair of single quotes. The `$` designates which field to print. In this case,
    the `$0` causes every field to print. Specifying a pattern would cause only the
    lines with that pattern to print. By not specifying a pattern this time, I caused
    every line to print. Now, let’s say that I only want to show the line that contains
    a specific username. I’ll just add the pattern, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The pattern needs to be enclosed within a pair of forward slashes, which in
    turn need to be within the pair of single quotes that also surround the action.
  prefs: []
  type: TYPE_NORMAL
- en: '`awk` operates on groups of information known as `records`. By default, each
    line in a text file is one record. For now, that’s all we’re going to deal with.
    However, you can also have files with multi-line records, which require special
    techniques to process. I’ll show you that in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `{print $0}` is the default action, I could just omit that part and get
    the same result, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s just print out the first field of this line. Do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$1` designates that I want to print field number 1\. But wait though,
    this still isn’t right, because the command has actually printed fields 1 through
    5\. That’s because the default field delimiter for `awk` is a blank space. Field
    5, which contains my full name, has a blank space between the “Donald” and the
    “A.” So, as far as `awk` is concerned, this is the beginning of the second field.
    To fix that, I’ll use the `-F:` option to make `awk` recognize the colon as the
    field delimiter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, I have the output that I want.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to display more than one field, use a comma-separated list of field
    identifiers in the action, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So here, I’m displaying fields 1 and 7\. (Note that the comma between the field
    numbers is what places a blank space between the fields in the output. Omitting
    the comma would cause the output to not have that blank space.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pipe the output of another program into `awk`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Yeah, I know. It’s usually bad form to pipe `cat` output into another utility,
    when you could just directly use the other utility. But for now, this serves to
    demonstrate the concept.
  prefs: []
  type: TYPE_NORMAL
- en: All of the demos that I’ve shown you thus far could also have been done with
    `cat`, `grep`, `cut`, or combinations thereof. So, you could be forgiven for wondering
    what the point is in using `awk`. Well, hang on, because you’ll soon see that
    `awk` can do some awesome things that the other utilities can’t do, or can’t do
    as well. We’ll begin by taking a closer look at how `awk` can process input from
    plain text files.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining Input from Text Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might have already guessed, the default manner in which `awk` operates
    is to read a file line-by-line, searching for the specified pattern in each line.
    When it finds a line that contains the specified pattern, it will perform the
    specified action on that line. Let’s begin by building upon the `passwd` file
    example that I showed you in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Looking for Human Users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `/etc/passwd` file contains a list of all users on the system. What I’ve
    always found curious is that system user accounts and normal human user accounts
    are all mixed together in the same file. But, let’s say that as part of your administrator
    duties, you need to maintain a list of normal human users on each machine. One
    way to do that is to use `awk` to search through the `passwd` file for the **User
    ID Numbers** (**UIDs**) that correspond to human users. To find out what the UID
    numbers for normal users are, you can look in the `/etc/login.defs` file that’s
    on most Linux systems. This file can be somewhat different on different Linux
    systems, so I’ll just show you how it is on my Fedora machine. On lines 142 through
    145, you see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, to view all human user accounts on my system, I would search for all `passwd`
    file lines where field 3 (the UID field) contains a value that is greater than
    or equal to 1000 and less than or equal to 60000, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also redirect the output into a text file, by placing the output redirector
    within the action construct, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In both examples, note how I’m using `&&` as the `and` operator in the pattern
    portion of the command.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to use this command for your own use, be sure to verify what range
    of UID numbers that your operating system is using. Most Linux distros use the
    range of 1000 through 60000, as defined in the `/etc/login.defs` file. Non-Linux
    operating systems, such as OpenIndiana and FreeBSD, don’t use a `login.defs` file,
    and I’ve not been able to find any definitive answer about what UID ranges they
    use. The best I can tell you about them is to look in the `/etc/passwd` file to
    see what UID is assigned to the first human user account, and to consult your
    organization’s policy manual to see the exact range of UID numbers that your organization
    wants to use for human users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there’s no need to type this whole long command every time you want
    to use it. Instead, just put it into a normal shell script, which I’ll call `user_list.sh`.
    It will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s good, but what if you need a comma-separated value (`.csv`) file that
    you can easily import into a spreadsheet? Well, I’ve got you covered. Just add
    a `BEGIN` section, where you would define the new field delimiter for the output,
    as well as the field delimiter for the input, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This might seem a bit strange, because when you define an input field delimiter
    in the `awk` action, you used the `-F` option. But, when you define an input field
    delimiter in the `BEGIN` section, you use the `FS` option. Likewise, you use `OFS`
    in the `BEGIN` section to define the output field delimiter. (In `awk`-speak,
    field delimiters are actually called **Field Separators**, which explains why
    these `BEGIN` options are called `FS` and `OFS`.)
  prefs: []
  type: TYPE_NORMAL
- en: The `BEGIN` section of an `awk` command or script is where you add any type
    of initialization code that you want to run before `awk` starts processing the
    input file. You can use it to define field separators, add a header to the output,
    or initialize global variables that you’ll use later.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s good, but I’d also like to see the users’ UIDs. So, I’ll just add field
    3 to the mix, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that I have my `awk` command the way I want it, I’ll place it into the
    `user_list2.sh` shell script that will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You could write a program that does this same thing in some other programming
    language, such as Python, C, or Java. But, the program code would be quite complex
    and more difficult to get right. With `awk`, all it takes is just a simple single-line
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see how `awk` can help a busy webserver administrator.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing Webserver Access Logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Webserver access logs contain a lot of information that can help a website owner,
    a webserver administrator, or a network security administrator. There are a lot
    of fancy log-parsing tools that can build fancy reports that tell you everything
    that’s going on, if that’s what you need. But, there may be times when you’ll
    want to quickly extract some specific data without taking the time to run some
    fancy tool. There are a few different ways to do that, and `awk` is one of the
    best.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin the scenario, you’ll need a virtual machine with an active webserver
    installed. To keep things simple, I’ll just install the Apache server and the
    PHP module on my Fedora Server virtual machine, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, enable and start the Apache service, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the server from different machines, you’ll need to open Port 80 on
    the firewall, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `/var/www/html/` directory, create the `test.php` file, with
    the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Reminder**: To make this work, be sure to set your virtual machine up with
    Bridged Mode networking, so that other machines on your network can reach it.
    Also, be sure that the virtual machines that you use to access the webserver are
    also set up in Bridged Mode, so that each machine will have its own IP address
    in the access log file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from as many other machines as possible, access both the Fedora Webserver
    Test Page and the `test.php` page. Then, try to access a non-existent page. Your
    URLs should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'On the webserver virtual machine, open the `var/log/httpd/access_log` file
    in `less`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the structure of the file, and how it uses blank spaces as field delimiters
    for some fields and double quotes as field delimiters for other fields. For example,
    here’s one entry from my own access file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you see here that some fields are surrounded by double quotes, and others
    aren’t. For now, let’s look at the IP addresses that have accessed this machine,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you see, I just piped the `awk` output into `sort -V`, which I then piped
    into `uniq`. Using the `-V` option for `sort` causes the IP addresses to be sorted
    in correct numerical order. You can’t use the `-n` switch for this, because by
    default, `sort` treats the dots in the IP addresses as decimal points. The `-V`
    option overrides that behavior by doing what is called a **natural sort**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is good, except that I still don’t know how many times the webserver was
    accessed from each IP address. I’ll use `uniq` with the `-c` option to see that,
    which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s good, but I really want to create a `.csv` file, as I did for my list
    of users. I can’t do that by defining the `OFS` parameter in the `BEGIN` section
    this time, because the count field isn’t created until I pipe the output into
    `uniq -c`. So, I’ll cheat a bit by installing the `miller` package, which is in
    the repositories for most Linux distros, as well as for FreeBSD. On a Mac, you
    should be able to install it with `homebrew`. Anyway, to create the `.csv` file,
    I’ll just pipe the output from this `awk` command into the `mlr` utility, which
    is part of the `miller` package. Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `--p2c` option for `mlr` is what converts the output to `.csv` format. After
    that is `cat`, which is the `mlr` verb. You see that this `cat` just dumps the
    output to either the screen or to a file, the same as its `bash` cousin does.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m showing you how to create `.csv` files, because for historical reasons,
    `.csv` is the most popular format for plain-text data files, and your employer
    or clients might expect you to use them. However, as we’ll see in a bit, this
    isn’t always the best format. In certain circumstances, you might find that your
    best bet is to forget about `.csv` files, and instead save your data to **Tab
    Separated Value** (`.tsv`) files, which might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can also import them into your favorite spreadsheet program, and in certain
    circumstances, they’re much easier to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need a `.json` file instead of a `.csv` file, `mlr` can also do that
    for you. You’ll just replace the `--p2c` option with the `--ojson` option, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There’s a lot more that you can do with `mlr` than I can show you here. To learn
    more about it, consult either the `mlr` man page or the Miller Documentation web
    page. (You’ll find a link to the Miller page in the *Further Reading* section.)
    As good as `mlr` is though, it does have one flaw. That is, it can’t handle fields
    that contain blank spaces or commas. So, you won’t be able to use it for every
    field in the Apache access log.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s say that we want to see which operating systems and browsers are
    accessing this server. The **User Agent** string that contains that information
    is in field 6, which is surrounded by a pair of double quotes. So, we’ll have
    to use the double quote as the field delimiter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can see here that I had to escape the double quote with a backslash, so
    that the shell won’t misinterpret it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look for a specific User Agent. Let’s say that we want to know
    how many users are using a Mac. Just add the pattern, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The entries for the Intel Mac are from my 2010-model Mac Pro, so they make sense.
    But, what’s with that PPC business in lines 3 and 4 of the output? Well, that’s
    also easily explained. Just for fun, I fired up my 21-year old eMac that’s equipped
    with an old-school Motorola PowerPC G4 processor, and used it to access the test
    webserver. (I’m guessing that you’ll never see any of those on your own network.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also obtain this information with nothing but pure `awk`, without having
    to pipe the output into other utilities. Do that by building an **associative
    array**, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `BEGIN` section with an `OFS` definition, and you can create a `.csv`
    file. Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the normal shell scripting arrays that you’ve seen previously, `awk`
    associative arrays use text strings, instead of numbers, as their indexes. Also,
    arrays in `awk` are defined on-the-fly, and don’t have to be declared before you
    can use them. So here you see the `count` array, with whatever the respective
    values of field 1 are for the index values. The `++` operator, which assumes an
    initial value of 0, adds together the number of times each index string is found
    in the file. The first portion of this command, which ends at the semi-colon,
    processes the file line-by-line as `awk` normally does. The `END` keyword designates
    code that will run after the line-by-line processing has completed. In this case,
    you see a `for` loop that prints out a summary of unique IP addresses, along with
    how many times each one was found. Unfortunately, there’s no easy way to sort
    the output with pure `awk`, but you can still pipe the output into `sort`, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To make this work, I’m using sort with the `-t,` option to define the comma
    as the field delimiter. (Yeah, I know. It would be nice if all Linux and Unix
    utilities used the same option switch to define field delimiters, but that’s just
    not how the world works.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Another difference with using pure `awk` is that the number of occurrences
    for each IP address is in the second column, rather than in the first column as
    you saw before. That’s okay here, but it might not work so well for other fields.
    For example, let’s change the command to look at the User Agents in field 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Yeah, it works, but having the number of occurrences in the second column for
    this makes the output somewhat less readable.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned before, the `.csv` format isn’t always your best choice for a
    plain-text data file. In fact, it’s impossible to turn the output from field 6
    into a proper `.csv` file that any spreadsheet program will properly display.
    That’s because this field contains blank spaces and commas that make a spreadsheet
    program think that there are more fields in the `.csv` file than there really
    are.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the easiest solution is to surround the text in field 6 with a pair of
    double quotes and save the output to a `.tsv` file. Then, when you open the file
    in your spreadsheet, define the `"` as the field delimiter. Anyway, here’s the
    command to create the `.tsv` file, without using an associative array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `awk` strips out the double quotes that surround field 6 in the
    original log file. So, to make this work properly, I have to put them back into
    the final output file. In the action part, you see that I’m printing a double
    quote both before and after `$6`. By omitting the commas that you might normally
    place between the various `print` elements, I’ll ensure that there are no blank
    spaces between the quotes and the text. Then, I’m just piping the output into
    `sort`, `uniq`, and `sort` again as I’ve shown you before. Here’s how the file
    looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer to use an associative array, you can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how I had to surround the `printf` parameters with a pair of double quotes.
    The first `%s` parameter is for the count field, and the second `%s` parameter
    is for the user agent field. To add the double quotes in the proper places, I
    added a `\"` to both before and after the second `%s`. Using either the associative
    array method or the non-associative array method gives me the same results. Now,
    when I open the file in a spreadsheet program, I’ll just define the double quote
    as the field delimiter. Here’s how that looks on LibreOffice Calc:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_14_1](img/B21693_14_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Setting the field delimiter in LibreOffice Calc'
  prefs: []
  type: TYPE_NORMAL
- en: I know that I haven’t fully explained `print` versus `printf` yet, but I will
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `user_agent.tsv` file should now display properly, with the count in the
    first column and the User Agent string in the second column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s count the number of times that each URL on the webserver was hit.
    I like having the count as the first field of output, so I’ll again pipe the `awk`
    output into `uniq` and `sort`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the blank space as the field delimiter means that the URL field is field
    7\. At the end, I’m piping the output into `sort` again so that the list will
    print out according to the number of hits for each URL. But actually, I’d like
    that to show the most popular URLs at the top of the list. So, I’ll just add the
    `-r` option to sort in reverse, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: One thing we see is that someone tried to perform a directory traversal attack
    against me, as evidenced by the lines that begin with `/test.php?page` or `/test.php?module`.
    I’ll show you more about that later in *Chapter 18, Shell Scripting for Security
    Professionals*.
  prefs: []
  type: TYPE_NORMAL
- en: 'That last field we’ll look at is field 9, which is the **HTTP status code**.
    Again, we’ll use the blank space as the field delimiter, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the breakdown of what these codes mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '200: The `200` code means that users were able to access web pages normally,
    with no problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '304: The `304` code just means that when a user reloaded a page, nothing on
    the page had changed, so that it didn’t need to be reloaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '403: The `403` code means that someone tried to access a page for which the
    user wasn’t authorized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '404: The `404` means that a user tried to access a page that doesn’t exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Okay, all this is good. So now, let’s put all this into the `access_log_parse.sh`
    script, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: I’ve decided that I want to create a separate `.tsv` file for each function,
    and that I want to have a timestamp in each filename. The `%F` option for `date`
    prints the date in `YEAR-MONTH-DATE` format, which is fine. I could have used
    the `%T` option to print the time, but that would have placed colons in the filenames,
    which would require me to escape the colons every time I want to access one of
    these files from the command line. So, I instead used the `%I-%M-%p` combination,
    in order to replace the colons with dashes. (To see more formatting options, consult
    the `date` man page.) The rest of the script consists of the commands that you’ve
    already seen, so I won’t repeat any of those explanations.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can fancy up any of these scripts to meet your own desires and
    needs. Just use the techniques that I’ve shown you in previous chapters to add
    markup language tags to the output, and convert the output files to `.html` or
    `.pdf` format. For the multi-function script that I’ve just now shown you, you
    could add either `if..then` or `case` constructs that would allow you to choose
    the specific function that you want to run. And, don’t feel bad if you need to
    refer back to the previous chapters to see how any of this is done. Trust me,
    I won’t hold it against you.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we’ve been parsing through the entire file to find what we want to
    see. Sometimes though, you might just want to view information from either a specific
    line or range of lines. For example, let’s say that you just want to see line
    10\. Do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NR` variable represents the **Number of Record**. Since each record in
    the `access_log` file consists of only a single line, this is the same as defining
    the line number that you want to see. To see a range of lines, do something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, I’m looking at field 1 of lines 10 through 15\. Of course, you could do
    the same thing by combining the `tail`, `head`, and `cut` utilities, but this
    is way easier.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ve looked at `FS`, `OFS`, and `NR`. What I haven’t told
    you yet is that these three constructs are variables that are built into `awk`.
    There are many more built-in variables, but I’d rather not overwhelm you by explaining
    all of them now. If you’re interested in reading about all of them, just open
    the `awk` man page and scroll down to the **Built-in Variables** section.
  prefs: []
  type: TYPE_NORMAL
- en: The log parsing techniques that I’ve presented here can be used for any type
    of log file. To design your `awk` commands, look through the log files that you
    want to process and take note of how the fields are laid out in each line, and
    what information they contain.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let’s look at a few other log-parsing techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Using Regular Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can enhance your `awk` experience with regular expressions, just as you
    can with other text-manipulation utilities.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to, refer back to *Chapter 2, Text Stream Filters – Part 2* and
    *Chapter 9, Filtering Text with grep, sed, and Regular Expressions* to review
    the concepts of regular expressions and POSIX character classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our first example, let’s say that you need to search through the `/etc/passwd`
    file for all users whose usernames begin with a lower-case *v*. Just use a simple
    regular expression, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This works because the username field is the first field of every line. So,
    you don’t need to do anything any fancier than just this. But, let’s suppose you
    need to search for something in another field that begins with a certain character.
    For example let’s say that you need to search through the Apache access log file
    for all HTTP status codes that are in the 400 range. Just do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$9` in the pattern means that you’re looking for a certain pattern in
    field 9\. The `~` means that you want something in that field to match whatever
    is within the following forward slashes. In this case, it’s looking for anything
    in field 9 that begins with the number 4\. In the output, you see that I’ve found
    both the 403 and the 404 status codes. And, if you need to, you can save the output
    to a `.csv` file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer, you can save it to a `.tsv` file by omitting the `mlr --p2c
    cat` portion, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To see everything *except* for a certain pattern, use the `!~` construct, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to see everything except for the 400 codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s say that we want to see all instances where someone used either
    the Safari or the Lynx web browsers. You could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'However, that doesn’t work, because it will include entries like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'For some strange reason, Apache can’t exactly identify the Microsoft Edge browser,
    so it reports it as several different possibilities, including Safari. To narrow
    that down, I’ll exclude any users who are using Windows. (Safari used to be available
    for Windows, but the Windows version was discontinued in 2012.) Here’s how that
    looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: And here, you see something that’s rather strange. It’s that when you use an
    `or` or an `and` operator within a regular expression, you use either a single
    `|` or a single `&`. When you use an `or` or an `and` operator outside of a regular
    expression, you use either `||` or `&&`. I know, it’s confusing, but that’s just
    the way it is. Anyway, if you look through the output now, you’ll see that there
    are no lines from the Windows users.
  prefs: []
  type: TYPE_NORMAL
- en: I know, this is just scratching the surface for what you can do with `awk` and
    regular expressions. If you ask real nicely, I might show you a few more examples
    in the next section, which will be about how to use `awk` to process information
    from other commands.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining Input from Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start with something simple, by obtaining some basic process information.
    On the Fedora Server virtual machine that’s running Apache, search for all `ps
    aux` output lines that contain the `httpd` pattern, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s say that we want to see all processes that are owned by the root
    user. That’s also easy. Just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There’s nothing really new here, because these `awk` commands are the same as
    you saw in the previous section. Indeed, pretty much all of the techniques that
    you can do with parsing log files also work here. So, let’s not repeat any more
    of that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step for parsing information from the `ps` utility is to see what
    the various fields are. The `aux` combination of options is what I find most useful
    for myself, simply because it displays the specific information that I most need
    to see. To see the `ps` header that shows the field names, I’ll pipe the `ps aux`
    output into `head -1`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the breakdown of what all these fields represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '`USER`: The user that owns each particular process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PID`: The **Process ID** number of each process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%CPU`: The percentage of CPU resources that each process consumes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RSS`: The **Resident Set Size** is the amount of actual physical, non-swapped
    memory that each process uses. (I know that this is out of order, but you’ll soon
    see the reason.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%MEM`: The ratio of the process’s RSS to the amount of physical memory that’s
    installed in the machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VSZ`: The **Virtual Set Size** is the amount of virtual memory that each process
    is using. (This is expressed in numbers of 1024-byte units.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TTY`: This is the terminal which is controlling each process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STAT`: This column holds the status code of each process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`START`: The starting time or date of each process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIME`: This is the cumulative CPU time for each process, in “`[DD-]HH:MM:SS`"
    format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMMAND`: The commands that started each process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bear in mind that there are many options switches for `ps`, which all show different
    types of process data. There are also many ways to combine the switches in order
    to get all of the information you need, displayed in your preferred format. For
    now though, I’m just going to stick with `ps aux`, mainly because it’s the most
    useful option combination for me. For more details, see the `ps` man page.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `ps` commands always display this header along with the information
    that you want to see. So, you’ll see this header if you pipe `ps` into an `awk`
    command that doesn’t filter it out. For example, let’s look at the processes that
    are not owned by the root user, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s fine most of the time. But, having that header there might mess you
    up if you need to save the information to a formatted text file. To fix this,
    let’s use the **Number of Record** (`NR)` variable that I showed you in the previous
    section. Here’s how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `NR > 1` clause means that we only want to see records that come after record
    1\. In other words, we don’t want to see the first line of output, which in this
    case would be the `ps` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know what each field is, we can create some useful one-liners to
    extract information. First, let’s see how many processes are in either the **Running**
    state or the **Zombie** state. (A Zombie process is a dead process that hasn’t
    yet been properly destroyed by its parent process. You can view the `ps` man page
    to learn more about them.) We know that the `STAT` column is field 8, so the command
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: It looks a bit jumbled up because the `COMMAND` field for the second process
    contains a very long string, but that’s okay. You can still see that field 8 in
    every line begins with the letter `R`. (You’ll rarely see any Zombie processes
    on your systems, so don’t worry about not seeing any of them here. And no, Zombie
    processes don’t go around looking for brains to steal.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The `w` command shows you a list of all users who are logged into the system,
    and what they’re doing. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You see that I’m logged in via `tty1`, which is the local terminal. I’m also
    logged in remotely via a `pts` terminal, along with Vicky and Frank. (Remember
    that `tty` terminals indicate that someone is logged in locally, while `pts` terminals
    indicate that someone is logged in remotely.) Now, let’s use `ps` to see more
    information about the processes that the remote users are running, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'A few moments ago, I showed you how to strip the header line out of the output
    if your `awk` command doesn’t already strip it out. This time, the `awk` command
    does strip it out, but I’ve decided that I want to see it. To fix that, I’ll do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Note here that I’m using two different methods of finding a pattern. The `$7
    ~ "pts"` portion finds all lines that contain the `pts` text string in field 7\.
    So, we see that `pts/0`, `pts/1`, and `pts/2` all match this search criterion.
    The `$1 == "USER"` portion is looking for an exact, whole-word match. To demonstrate,
    look at this `user.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `~` to search for all lines with `USER` in field 1 gives us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Replacing the `~` with `==` gives us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: So you see that there is a big difference. Also, note that since I’m searching
    for a literal text string, I can surround the search term (`USER`) within either
    a pair of double quotes or a pair of forward slashes when using the ~. However,
    when using the `==`, you’ll need to use the double quotes, because using the double
    slashes shows you nothing.
  prefs: []
  type: TYPE_NORMAL
- en: And, with that bit of a digression out of the way, let’s get back to our regularly
    scheduled program.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve now decided that I want to see all processes with a virtual memory size
    (`VSZ`) of more than 500,000 bytes. `VSZ` information is in field 5, so my `awk`
    command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'But, that’s more information than I really need. I just want to look at the
    relevant fields, and I’ve decided to place each field on its own line, along with
    a label. Here’s how I’ll do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As noted before, `NR > 1` prevents `ps` from printing the default header. In
    the action, the `print` command places a pair of tabs (`\t\t`) between `USER`,
    `PID`, `VSZ`, and their respective values. The `COMMAND` label is longer, so it
    only requires one tab (`\t`) between it and its values. This ensures that all
    values in the second column line up nice and neat. The newlines (`\n`) after the
    `USER`, `PID`, and `VSZ` values cause the next field to print on a new line. After
    the `COMMAND` value, I placed two newlines (`\n\n`) so that there would be a blank
    line between each record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s turn this command into a function that we can add to the `sysinfo.lib`
    function library that I showed you in *Chapter 10--Understanding Functions*. Our
    new `VSZ_info()` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the `system_info.sh` script that I also showed you in *Chapter 10*,
    you’ll need to add `$(VSZ_info)` to the end of the list of functions that the
    script calls. Now when you run the script, you’ll see the `VSZ` information at
    the end of the output file. (Both files are too long to reproduce here, but you
    can download them from GitHub.)
  prefs: []
  type: TYPE_NORMAL
- en: Okay, that about wraps it up for the basics of using `awk` in shell scripts.
    Let’s summarize and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I introduced you to the sacred mysteries of using `awk`. We
    started by looking at the numerous implementations of `awk`, and at how a basic
    `awk` command is constructed. Next, we saw how to use `awk` to process information
    either from a text file or from another program. Then, we saw how to run `awk`
    commands from within a normal shell script. Finally, we turned an `awk` command
    into a function, and added it to our function library file.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at how to create `awk` program scripts. I’ll
    see you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two parts of an `awk` command? (Choose two.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: action
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: expression
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: pattern
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: command
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: E. order
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `{print $0}` do in an `awk` command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It prints the name of the script that you’re running, because `$0` is the bash
    positional parameter that hold the name of the script.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It prints the value that was assigned to the `0` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It prints all fields of a record.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s an invalid command that doesn’t do anything.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You want to perform an exact, whole-word match for all lines that contain a
    certain text string. Which of the following `awk` operators would you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`==`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`=`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`eq`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`~`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is the best place to define values for `FS` and `OFS`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the END section of an `awk` command.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You can’t. They already have pre-defined values.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `BEGIN` section of an `awk` command.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the action of an `awk` command.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you use regular expressions with `awk`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Surround the regular expression with a pair of forward slashes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Surround the regular expression with a pair of single quotes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Surround the regular expression with a pair of double quotes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t surround the regular expression with anything.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GNU awk Users’ Guide: [https://www.gnu.org/software/gawk/manual/gawk.html](https://www.gnu.org/software/gawk/manual/gawk.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Awk by Example: [https://developer.ibm.com/tutorials/l-awk1/](https://developer.ibm.com/tutorials/l-awk1/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'awklang.org--The site for things related to the awk language: [http://www.awklang.org/](http://www.awklang.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'awk: One True awk: [https://github.com/onetrueawk/awk](https://github.com/onetrueawk/awk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Awk Scripts YouTube channel: [https://www.youtube.com/@awkscripts](mailto:https://www.youtube.com/@awkscripts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Miller Documentation: [https://miller.readthedocs.io/en/latest/](https://miller.readthedocs.io/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The GAWK Manual-Useful “One-liners”: [http://web.mit.edu/gnu/doc/html/gawk_7.html](http://web.mit.edu/gnu/doc/html/gawk_7.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Use awk in Bash Scripting: [https://www.cyberciti.biz/faq/bash-scripting-using-awk/](https://www.cyberciti.biz/faq/bash-scripting-using-awk/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advanced Bash Shell Scripting Guide-Shell Wrappers: [https://www.linuxtopia.org/online_books/advanced_bash_scripting_guide/wrapper.html](https://www.linuxtopia.org/online_books/advanced_bash_scripting_guide/wrapper.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Awk: The Power and Promise of a 40-year-old Language: [https://www.fosslife.org/awk-power-and-promise-40-year-old-language](https://www.fosslife.org/awk-power-and-promise-40-year-old-language)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a and c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Linux experts, and the author himself.
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10596186092701843.png)'
  prefs: []
  type: TYPE_IMG
- en: Leave a Review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoy it!
    Your feedback is invaluable and helps us improve and grow. Once you've completed
    reading it, please take a moment to leave an Amazon review; it will only take
    a minute, but it makes a big difference for readers like you.
  prefs: []
  type: TYPE_NORMAL
- en: Scan the QR code below to receive a free ebook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/review.png)'
  prefs: []
  type: TYPE_IMG
