- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Sharing and Transferring Files
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享和传输文件
- en: In the previous chapter, we looked at what’s involved in the process of setting
    up a few network services, such as DHCP and DNS. Those are two important components
    of a network, but there are quite a few different types of applications and resources
    you can make available on your network to further enhance it. A file server is
    one such example, which can give your users a central place to store critical
    files and can even enhance collaboration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们看到了设置一些网络服务（如DHCP和DNS）涉及的过程。这些是网络的两个重要组成部分，但你可以在你的网络上提供许多不同类型的应用程序和资源，以进一步增强它。文件服务器就是其中的一个例子，它可以为用户提供一个集中存储关键文件的地方，甚至可以增强协作。
- en: 'Perhaps you’ve used a file server before, or even set one up on a different
    platform. With Ubuntu Server, there are multiple methods to not only store files,
    but also to transfer files from one node to another over a network link. In this
    chapter, we’ll look into setting up a central file server using both Samba and
    NFS, as well as how to transfer files between nodes with utilities such as `scp`
    and `rsync`. We’ll also go over some situations in which one solution may work
    better for you than another. As we go through these concepts, we will cover the
    following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你之前使用过文件服务器，甚至在不同平台上设置过文件服务器。在Ubuntu服务器上，不仅有多种存储文件的方法，还可以通过网络链路将文件从一个节点传输到另一个节点。在本章中，我们将探讨如何使用Samba和NFS设置中央文件服务器，以及如何使用`scp`和`rsync`等工具在节点之间传输文件。我们还将讨论一些情况，在这些情况下，一种解决方案可能比另一种更适合你。在讨论这些概念时，我们将涵盖以下主题：
- en: File server considerations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件服务器考虑因素
- en: Sharing files with Windows users via Samba
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Samba与Windows用户共享文件
- en: Setting up NFS shares
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置NFS共享
- en: Transferring files with `rsync`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`rsync`传输文件
- en: Transferring files with `scp`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`scp`传输文件
- en: Before we can get started with configuring our server to enable it to share
    files with other users, we should first understand what our available options
    are to enable us to choose the best technology for our use case.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始配置服务器以使其能够与其他用户共享文件之前，我们首先应该了解一下我们可以选择的可用选项，以便为我们的用例选择最佳技术。
- en: File server considerations
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件服务器考虑因素
- en: When it comes to setting up a file server, the process is a matter of setting
    up some sort of daemon to accept connections and share specific directories, and
    ensure the appropriate users are able to access those directories. You’ll also
    implement permissions to determine who can access specific directories, and what
    type of access they will have (read/write, read-only, and so on). When deciding
    *how* to share the files, it’s generally a choice between two common technologies
    that can facilitate the actual sharing, **Samba** and **NFS**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置文件服务器方面，过程是设置某种守护程序以接受连接并共享特定目录，并确保适当的用户能够访问这些目录。您还将实施权限以确定谁可以访问特定目录，以及他们将拥有的访问类型（读/写、只读等）。在决定如何共享文件时，通常是在两种常见技术之间进行选择，即**Samba**和**NFS**。
- en: All in all, there’s nothing stopping you from hosting both Samba and NFS shares
    on a single server. The two technologies can actually co-exist on the same device.
    However, each of the two popular solutions is more appropriate for particular
    use cases. Before we get started with setting up our file server, we should first
    understand the differences between Samba and NFS, so we can make an informed decision
    as to which one is more appropriate for our environment. As a general rule of
    thumb, Samba is great for mixed environments (where you have Windows as well as
    Linux clients), and NFS is more appropriate for use in Linux or Unix environments,
    but there’s a bit more to it than that.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，没有什么可以阻止您在单个服务器上托管Samba和NFS共享。这两种技术实际上可以在同一设备上共存。然而，这两种流行的解决方案各自更适合特定的用例。在开始设置文件服务器之前，我们应该先了解Samba和NFS之间的区别，以便能够就我们的环境选择更合适的一个。作为一个经验法则，Samba非常适合混合环境（其中既有Windows客户端也有Linux客户端），而NFS更适合在Linux或Unix环境中使用，但实际情况比这复杂得多。
- en: Samba is a great solution for many environments, because it allows you to share
    files with Windows, Linux, and macOS machines. Basically, pretty much everyone
    will be able to access your shares, provided you give them permission to do so.
    The reason this works is because Samba is a re-implementation of the **Server
    Message Block** (**SMB**) protocol, which is primarily used by Windows systems.
    However, you don’t need to use the Windows platform in order to be able to access
    Samba shares, since many platforms offer support for this protocol.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Samba 是许多环境中的一个好方案，因为它允许你与 Windows、Linux 和 macOS 机器共享文件。基本上，只要你赋予权限，几乎所有人都能访问你的共享。之所以能够这样，是因为
    Samba 是 **服务器消息块**（**SMB**）协议的重新实现，而该协议主要由 Windows 系统使用。然而，你不需要使用 Windows 平台也能访问
    Samba 共享，因为许多平台都支持这一协议。
- en: You may be wondering why I am going to cover two different solutions in this
    chapter. After all, if Samba shares can be accessed by pretty much everything
    and everyone, why bother with anything else? Even with Samba’s many strengths,
    there are weaknesses as well. First of all, permissions are handled very differently,
    so you’ll need to configure your shares in specific ways in order to prevent access
    to users that shouldn’t be able to see confidential data. With NFS, full support
    for standard UNIX permissions is provided, so you’ll only need to configure your
    permissions once. If permissions and confidentiality are important to you, you
    may want to look closer at NFS.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，为什么我在这一章会讲解两种不同的解决方案。毕竟，如果 Samba 共享几乎能被所有设备和用户访问，为什么还要考虑其他的呢？尽管 Samba
    有许多优点，但也有一些缺点。首先，权限的处理方式差异很大，因此你需要以特定的方式配置共享，以防止那些不应访问机密数据的用户进入。而 NFS 完全支持标准 UNIX
    权限，因此你只需配置一次权限。如果权限和机密性对你来说很重要，可能需要更仔细地考虑 NFS。
- en: It’s also not accurate to say that Windows systems cannot access NFS shares,
    because some versions actually can. By default, no version of Windows supports
    NFS outright, but some editions offer a plugin you can install that enables this
    support. If you install **Services for NFS**, your installation of Windows will
    be able to access NFS shares from that point forward.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 说 Windows 系统无法访问 NFS 共享并不准确，因为某些版本实际上是可以的。默认情况下，Windows 的任何版本都不直接支持 NFS，但一些版本提供了一个插件，可以让你安装它以启用此支持。如果你安装了
    **NFS 服务**，从那时起，你的 Windows 安装将能够访问 NFS 共享。
- en: Regarding an all-Linux environment or a situation where you only have Linux
    machines that need to access your shares, NFS is a great choice because it integrates
    much more tightly with the rest of the distribution. Permissions can be more easily
    enforced and, depending on your hardware, performance may be higher. The specifics
    of your environment will make your decision for you. Perhaps you’ll choose Samba
    for your mixed environment, or NFS for your all-Linux environment. Maybe you’ll
    even set up both NFS and Samba, having shares available for each platform. My
    recommendation is to learn and practice both, since you’ll use both solutions
    at one point or another during your career anyway.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关于全 Linux 环境或只有 Linux 机器需要访问共享的情况，NFS 是一个不错的选择，因为它与操作系统的集成更加紧密。权限可以更容易地进行控制，并且根据硬件的不同，性能可能更高。具体的环境会帮助你做出决定。也许你会为混合环境选择
    Samba，或为全 Linux 环境选择 NFS。也可能你会同时设置 NFS 和 Samba，为每个平台提供共享。我建议你学习并实践这两种方案，因为无论如何，你在职业生涯的某个时刻都将使用到这两种解决方案。
- en: Before you continue to the sections on setting up Samba and NFS, I recommend
    you first decide where in your filesystem you’d like to act as a parent directory
    for your file shares. This isn’t actually required, but I think it makes for better
    organization. There is no one right place to store your shares, but personally
    I like to create a `/share` directory at the `root` filesystem and create sub-directories
    for my network shares within it. For example, I can create `/share/documents`,
    `/share/public`, and so on for Samba shares. With regard to NFS, I usually create
    shared directories within `/exports`. You can choose how to set up your directory
    structure. As you read the remainder of this chapter, make sure to change my example
    paths to match yours if you use a different style.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续设置 Samba 和 NFS 的部分之前，我建议您首先确定您的文件系统中哪个位置作为文件共享的父目录。这并非必需，但我认为这样更有利于组织。并没有一个固定的地方来存储您的共享文件，但我个人喜欢在
    `root` 文件系统下创建一个 `/share` 目录，并在其中创建子目录用于我的网络共享。例如，我可以创建 `/share/documents`、`/share/public`
    等用于 Samba 共享的子目录。关于 NFS，我通常在 `/exports` 下创建共享目录。您可以选择如何设置您的目录结构。在阅读本章的其余部分时，请确保根据您的需要更改示例路径。
- en: Sharing files with Windows users via Samba
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Samba 向 Windows 用户共享文件
- en: 'In this section, I’ll walk you through setting up your very own **Samba** file
    server. I’ll also go over a sample configuration to get you started so that you
    can add your own shares. First, we’ll need to make sure that the `samba` package
    is installed on our server:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我将向您介绍如何设置您自己的 **Samba** 文件服务器。我还将讲解一个示例配置，以帮助您入门，以便您可以添加自己的共享。首先，我们需要确保在我们的服务器上安装了
    `samba` 软件包：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you install the `samba` package, you’ll have a new daemon installed on
    your server, `smbd`. The `smbd` daemon will be automatically started and enabled
    for you. You’ll also be provided with a default configuration file for Samba,
    located at `/etc/samba/smb.conf`. For now, I recommend stopping `samba` since
    we have yet to configure it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装 `samba` 软件包时，您的服务器上将安装一个新的守护程序 `smbd`。`smbd` 守护程序将自动启动和启用。同时，您还将获得一个位于
    `/etc/samba/smb.conf` 的默认 Samba 配置文件。目前，我建议停止 `samba`，因为我们还没有配置它：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since we’re going to configure Samba from scratch, we should start with an
    empty configuration file. Let’s back up the original file, rather than overwrite
    it. The default file includes some useful notes and samples, so we should keep
    it around for future reference:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将从头开始配置 Samba，我们应该从一个空白的配置文件开始。让我们备份原始文件，而不是直接覆盖它。默认文件包含一些有用的注释和示例，所以我们应该保留它以备将来参考：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can begin a fresh configuration. Although it’s not required, I like
    to split my Samba configuration up between two files, `/etc/samba/smb.conf` and
    `/etc/samba/smbshared.conf`. You don’t have to do this, but I think it makes the
    configuration cleaner and easier to read. First, here is a sample `/etc/samba/smb.conf`
    file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始一个全新的配置。虽然这不是必需的，但我喜欢将我的 Samba 配置分成两个文件，`/etc/samba/smb.conf` 和 `/etc/samba/smbshared.conf`。你不一定要这样做，但我认为这样可以使配置更清晰、更易于阅读。首先，这是一个
    `/etc/samba/smb.conf` 文件的示例：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, this is a really short file. Basically, we’re including only
    the lines we absolutely need to in order to set up a file server with Samba. Next,
    I’ll explain each line and what it does.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，这是一个非常简短的文件。基本上，我们只包括了设置 Samba 文件服务器所需的行。接下来，我将解释每一行及其作用。
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the `[global]` stanza, we’re declaring the global section of our configuration,
    which will consist of settings that will impact Samba as a whole. There will also
    be additional stanzas for individual shares, which we’ll get to later.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `[global]` 部分，我们声明了配置的全局部分，其中包含将影响整个 Samba 的设置。还会有额外的部分用于单独的共享，我们稍后会讨论到。
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `server string` is somewhat of a description field for the `File Server`.
    If you’ve browsed networks from Windows computers before, you may have seen this
    field. Whatever you type here will display underneath the server’s name in Windows
    Explorer. This isn’t required, but it’s nice to have.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`server string` 在某种程度上是 `File Server` 的描述字段。如果您以前从 Windows 计算机浏览网络，可能已经看到这个字段。无论您在此处键入什么内容，都将显示在
    Windows Explorer 中服务器名称下方。这不是必需的，但是有这个字段还是挺不错的。'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we’re setting the `workgroup`, which is the exact same thing as a `workgroup`
    on Windows PCs. In short, the workgroup is a namespace that describes a group
    of machines. When browsing network shares on Windows systems, you’ll see a list
    of workgroups, and then one or more computers within that workgroup. In short,
    this is a way to logically group your nodes. You can set this to whatever you
    like. If you already have a workgroup in your organization, you should set it
    here to match the workgroup names of your other machines. The default workgroup
    name is simply `WORKGROUP` on Windows PCs, if you haven’t customized the workgroup
    name at all.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了 `workgroup`，它与 Windows PC 上的 `workgroup` 完全相同。简而言之，工作组是一个命名空间，用于描述一组计算机。在
    Windows 系统中浏览网络共享时，你会看到一组工作组列表，然后在该工作组中看到一台或多台计算机。简而言之，这是用来逻辑地将你的节点进行分组的方法。你可以将它设置为任何你喜欢的名称。如果你已经在组织中有一个工作组，你应该在这里设置它，以匹配其他计算机的工作组名称。如果你没有自定义工作组名称，Windows
    PC 上的默认工作组名称就是 `WORKGROUP`。
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This setting sets up Samba to utilize usernames and passwords for authentication
    to the server. Here, we’re setting the `security` mode to `user`, which means
    we’re using local users to authenticate, rather than other options such as `ads`
    (Active Directory) or `domain` (domain controller), which are both outside the
    scope of this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置配置 Samba 使用用户名和密码进行服务器身份验证。在这里，我们将 `security` 模式设置为 `user`，这意味着我们使用本地用户进行身份验证，而不是使用
    `ads`（Active Directory）或 `domain`（域控制器）等其他选项，这些选项都不在本书的范围内。
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This option configures Samba to treat unauthenticated users as guest users.
    Basically, unauthenticated users will still be able to access shares, but they
    will have guest permissions instead of full permissions. If that’s not something
    you want, then you can omit this line from your file. Note that if you do omit
    this, you’ll need to make sure that both your server and client PCs have the same
    user account names on either side. Ideally, we want to use directory-based authentication,
    but that’s beyond the scope of this book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项配置 Samba 将未认证的用户视为访客用户。基本上，未认证的用户仍然可以访问共享，但他们将拥有访客权限，而不是完全权限。如果你不希望这样，你可以从文件中省略这一行。请注意，如果你省略了这一行，你需要确保服务器和客户端计算机两边的用户帐户名称是相同的。理想情况下，我们希望使用基于目录的身份验证，但那超出了本书的范围。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `name resolve order` setting configures how Samba resolves hostnames. In
    this case, we’re using the broadcast name first, followed by `wins`. Since `wins`
    has been pretty much abandoned (and replaced by DNS), we include it here solely
    for compatibility with legacy networks.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`name resolve order` 设置配置 Samba 如何解析主机名。在这个设置中，我们首先使用广播名称，然后是 `wins`。由于 `wins`
    已经基本上被弃用（并被 DNS 取代），我们在这里包含它只是为了兼容遗留网络。'
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Remember how I mentioned that I usually split my Samba configurations into
    two different files? On this line, I’m calling that second `/etc/samba/smbshared.conf`
    file. The contents of the `smbshared.conf` file will be inserted right here, as
    if we only had one file. We haven’t created the `smbshared.conf` file yet. Let’s
    take care of that next. Here’s a sample `smbshared.conf` file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我提到过我通常会将我的 Samba 配置分成两个文件吗？在这一行，我正在调用第二个 `/etc/samba/smbshared.conf` 文件。`smbshared.conf`
    文件的内容将在这里插入，就像我们只有一个文件一样。我们还没有创建 `smbshared.conf` 文件。接下来让我们来创建它。这是一个示例 `smbshared.conf`
    文件：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, I’m separating share declarations in their own file. We can
    see several interesting things within `smbshared.conf`. First, we have two stanzas,
    `[Documents]` and `[Public]`. Each stanza is a share name, which will allow Windows
    users to access the share under `//servername/share-name`. In this case, this
    file will give us two shares: `//servername/Documents` and `//servername/Public`.
    The `Public` share is writable for everyone, though the `Documents` share is restricted
    to read-only. The `Documents` share has the following options:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我将共享声明分离到它们自己的文件中。我们可以在 `smbshared.conf` 中看到一些有趣的内容。首先，我们有两个段落，`[Documents]`
    和 `[Public]`。每个段落都是一个共享名称，它将允许 Windows 用户通过 `//servername/share-name` 访问共享。在这种情况下，这个文件将为我们提供两个共享：`//servername/Documents`
    和 `//servername/Public`。`Public` 共享对所有人可写，而 `Documents` 共享则限制为只读。`Documents` 共享具有以下选项：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is the path to the share, which must exist on the server’s filesystem.
    In this case, when a user reads files from `//servername/Documents` on a Windows
    system, they will be reading data from `/share/documents` on the Ubuntu server
    that’s housing the share.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是共享的路径，它必须存在于服务器的文件系统中。在这种情况下，当用户在 Windows 系统上从 `//servername/Documents` 读取文件时，他们实际上是在从托管共享的
    Ubuntu 服务器上的 `/share/documents` 读取数据。
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These two lines are basically bypassing user ownership. When a user reads this
    share, they are treated as `myuser` instead of their actual user account. Normally,
    you would want to set up LDAP or Active Directory to manage your user accounts
    and handle their mapping to Ubuntu Server, but a full discussion of directory-based
    user access isn’t covered in this book, so I provided the `force` options as an
    easy starting point. The user account you set here must exist on the server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行基本上是绕过了用户所有权。当用户访问此共享时，他们会被当作 `myuser` 而不是他们实际的用户帐户。通常，你会希望设置 LDAP 或 Active
    Directory 来管理你的用户帐户，并处理它们与 Ubuntu 服务器的映射，但本书并未详细讨论基于目录的用户访问，因此我提供了 `force` 选项作为一个简单的起点。你在这里设置的用户帐户必须存在于服务器上。
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With these two lines, we’re configuring what users are able to do once they
    connect to this share. In this case, `public = yes` means that the share is publicly
    available, though `writable = no` prevents anyone from making changes to the contents
    of this share. This is useful if you want to share files with others, but you
    want to restrict access and stop anyone from being able to modify the content.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两行配置，我们设置了连接到此共享后的用户可以做什么。在这种情况下，`public = yes` 意味着共享是公开可用的，尽管 `writable
    = no` 防止任何人对该共享的内容进行更改。如果你想与他人共享文件，但又想限制访问并阻止任何人修改内容，这是很有用的。
- en: 'The `Public` share has some additional settings that weren’t found in the `Documents`
    share:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Public` 共享具有一些在 `Documents` 共享中没有的额外设置：'
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With these options, I’m setting up how the permissions of files and directories
    will be handled when new content is added to the share. Directories will be given
    `777` permissions and files will be given permissions of `664`. Yes, these permissions
    are very open; note that the share is named `Public`, which implies full access
    anyway, and its intended purpose is to house data that isn’t confidential or restricted:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些选项，我正在设置如何处理当新内容添加到共享时，文件和目录的权限。目录将被赋予 `777` 权限，而文件将被赋予 `664` 权限。是的，这些权限非常开放；请注意，共享名为
    `Public`，意味着无论如何都应有完全访问权限，它的预期用途是存放那些不涉及机密或限制的数据：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Just as I did with the previous share, I’m setting up the share to be publicly
    available, but this time I’m also configuring it to allow users to make changes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我在之前的共享中做的那样，我设置了共享为公开可用，但这次我还配置它允许用户进行更改。
- en: 'To take advantage of this configuration, we need to start the Samba daemon.
    Before we do though, we want to double-check that the directories we entered into
    our `smbshared.conf` file exist, so if you’re using my example, you’ll need to
    create `/share/documents` and `/share/public`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用此配置，我们需要启动 Samba 守护进程。在此之前，我们要再次检查我们在 `smbshared.conf` 文件中输入的目录是否存在，所以如果你使用我的示例，你需要创建
    `/share/documents` 和 `/share/public`：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also, the user account that was referenced in the force user and the group
    referenced in the force group must both exist and have ownership over the shared
    directories:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，强制用户中提到的用户帐户和强制组中提到的组必须都存在并且对共享目录拥有所有权：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At this point, it’s a good idea to use the `testparm` command, which will test
    the syntax of our Samba configuration files for us. It won’t necessarily catch
    every error we could have made, but it is a good command to run to quickly check
    the sanity. This command will first check the syntax, and then it will print the
    entire configuration to the terminal for you to have a chance to review it. If
    you see no errors here, then you can proceed to start the service:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，使用 `testparm` 命令是个好主意，它将测试我们的 Samba 配置文件的语法。它不一定能发现我们可能犯的每一个错误，但它是一个快速检查配置是否正常的好命令。此命令首先会检查语法，然后会将整个配置打印到终端，供你查看。如果你在这里没有看到错误，那么可以继续启动服务：
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, check the status to ensure that the daemon is running:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，检查状态以确保守护进程正在运行：
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will produce output similar to the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似以下内容的输出：
- en: '![](img/B18425_12_01.png)Figure 12.1: Checking the status of the smbd daemon'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/B18425_12_01.png)图 12.1：检查 smbd 守护进程的状态'
- en: That really should be all there is to it; you should now have `Documents` and
    `Public` shares on your file server that Windows users should be able to access.
    In fact, your Linux machines should be able to access these shares as well. On
    Windows, **Windows Explorer** has the ability to browse file shares on your network.
    If in doubt, try pressing the *Windows* key and the *r* key at the same time to
    open the **Run** dialog box, and then type the **Universal Naming Convention**
    (**UNC**) path to the share (`\\servername\Documents` or `\\servername\Public`).
    You should be able to see any files stored in either of those directories. In
    the case of the `Public` share, you should be able to create new files there as
    well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux systems, if you have a desktop environment installed, most of them
    feature a file manager that supports browsing network shares. Since there are
    a handful of different desktop environments available, the method varies from
    one distribution or configuration to another. Typically, most Linux file managers
    will have a network link within the file manager, which will allow you to easily
    browse your local shares. In the case of Ubuntu itself, you may need to install
    `smbclient` and `cifs-utils` via `apt`, so if you get an error you can try installing
    those packages. In the following screenshot, an Ubuntu 22.04 desktop client is
    browsing shares on a local Samba server:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B18425_12_02.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: Browsing a Samba share from a Linux client'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'If your file manager doesn’t show you the available shares on your server,
    you can also access a Samba share by adding an entry for it in the `/etc/fstab`
    file, such as the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, assuming the local directory exists (`/mnt/documents` in the example
    `fstab` line), you should be able to mount the share with the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the `fstab` entry, I included the `noauto` option so that your system won’t
    mount the Samba share at boot time (you’ll need to do so manually with the `mount`
    command). If you do want the Samba share automatically mounted at boot time, change
    `noauto` to `auto`. However, you may receive errors during boot if for some reason
    the server hosting your Samba shares isn’t accessible, which is why I prefer the
    `noauto` option.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’d prefer to mount the Samba share without adding an `fstab` entry, the
    following example command should do the trick; just change the share name and
    mount point to match your local configuration:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From here, feel free to experiment. You can add additional shares as appropriate,
    and customize your Samba implementation as you see fit. In the next section, we’ll
    explore NFS.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Setting up NFS shares
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alternative to Samba is **NFS**. It’s a great method of sharing files from
    a Linux or Unix server to another Linux or Unix server. As I mentioned earlier
    in the chapter, Windows systems can access NFS shares as well, but that requires
    an add-on to be enabled. Therefore, NFS is preferred in a Linux or Unix environment,
    since it fully supports Linux and Unix-style permissions. As you can see from
    our dive into Samba earlier, we essentially forced all shares to be treated as
    being accessed by a particular user, which was messy, but was the easiest example
    of setting up a Samba server without also walking you through setting up a complicated
    Windows Active Directory deployment. Samba can certainly support per-user access
    restrictions and benefits greatly from a centralized directory server, though
    that would basically be a book of its own! NFS integrates better in a non-mixed
    environment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we set up a parent directory in our filesystem to house our Samba
    shares, and we should do the same thing with NFS. While it wasn’t mandatory to
    have a special parent directory with Samba (I had you do that in order to be neat,
    but you weren’t required to), NFS really does want its own directory to house
    all of its shares. It’s not strictly required with NFS either, but there’s an
    added benefit in doing so, which I’ll go over before the end of this section.
    In my case, I’ll use `/exports` as an example, so you should make sure that that
    directory, or whatever you’ve chosen for NFS, exists:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, let’s install the required NFS packages on our server. The following
    command will install NFS and its dependencies:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once you install the `nfs-kernel-server` package, the `nfs-kernel-server` daemon
    will start up automatically. It will also create a default `/etc/exports` file
    (which is the main file that NFS reads its share information from), but it doesn’t
    contain any useful settings, just some commented lines. Let’s back up the `/etc/exports`
    file, since we’ll be creating our own:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To set up NFS, let’s first create some directories that we will share with
    other users. Each share in NFS is known as an **export**. I’ll use the following
    directories as examples, but you can export any directory you like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `/etc/exports` file (which we’re creating fresh), I’ll insert the following
    four lines:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first line is our **export root**, which I’ll go over a bit later. The next
    three lines are individual shares or exports. The `/backup`, `/documents`, and
    `/public` directories are being shared from the `/exports` parent directory. In
    this case, after the directory is called out in a line, we’re also setting which
    network is able to access them (`192.168.1.0`/`255.255.255.0` in our case). This
    means that if you’re connecting from a different network, your access will be
    denied. Each connecting machine must be a member of the `192.168.1.0/24` network
    in order to proceed (so make sure you change this to match your IP scheme). Finally,
    we include some options for each export, for example, `rw,no_subtree_check`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是我们的**导出根目录**，稍后我会详细介绍。接下来的三行是单独的共享或导出。`/backup`、`/documents`和`/public`目录是从`/exports`父目录共享的。在这种情况下，目录在一行中被调用后，我们还会设置哪些网络能够访问它们（在我们的例子中是`192.168.1.0`/`255.255.255.0`）。这意味着如果你从不同的网络连接，访问将被拒绝。每台连接的机器必须是`192.168.1.0/24`网络的成员才能继续操作（所以确保你修改这个以匹配你的IP方案）。最后，我们为每个导出项包含一些选项，例如`rw,no_subtree_check`。
- en: As far as what these options do, the first (`rw`) is rather self-explanatory.
    Here, we can set whether or not other nodes will be able to make changes to data
    within the export. In the examples I gave, the `/documents` export is read-only
    (`ro`), while the others allow read and write.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 至于这些选项的作用，第一个（`rw`）是相当直观的。在这里，我们可以设置其他节点是否可以对导出中的数据进行更改。在我给出的例子中，`/documents`导出是只读的（`ro`），而其他的则允许读写。
- en: The next option in each example is `no_subtree_check`. This option is known
    to increase reliability and is mainly implied by default. However, not including
    it may make NFS complain when it restarts, but nothing that will actually stop
    it from working. Particularly, this option disables what is known as **subtree
    checking**, which has had some stability issues in the past. Normally, when a
    directory is exported, NFS might scan parent directories as well, which is sometimes
    problematic, and can cause issues when it comes to open file handles.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例中的下一个选项是`no_subtree_check`。这个选项已知可以提高可靠性，并且默认情况下通常会隐式启用。然而，如果不包括它，NFS在重启时可能会发出警告，但不会真正阻止其正常工作。具体来说，这个选项禁用了所谓的**子树检查**，以前这个功能曾出现过一些稳定性问题。通常，当一个目录被导出时，NFS可能还会扫描父目录，这有时会导致问题，尤其是在处理打开的文件句柄时。
- en: 'There are several other options that can be included in an `export`, and you
    can read more about them by checking the man page for `export`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他选项可以包含在`export`中，你可以通过查看`export`的手册页面了解更多内容：
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: One option you’ll see quite often in the wild is `no_root_squash`. Normally,
    the `root` user on one system is mapped to nobody on the other for security reasons.
    In most cases, one system having `root` access to another is a bad idea. The `no_root_squash`
    option disables this, and it allows the `root` user on one end to be treated as
    the `root` user on the other. I can’t think of a reason, personally, where this
    would be useful (or even recommended), but I have seen this option quite often
    in the wild, so I figured I would bring it up. Again, check the man pages for
    `export` for more information on additional options you can pass to your exports.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际使用中，你会经常看到一个选项是`no_root_squash`。通常，系统中的`root`用户会被映射为另一个系统中的`nobody`用户，出于安全原因。在大多数情况下，一个系统对另一个系统拥有`root`权限是一个不好的主意。`no_root_squash`选项禁用这一点，它允许一端的`root`用户在另一端被当作`root`用户处理。就我个人而言，我想不出这种设置有什么用处（甚至不推荐使用），但我在实际中确实经常看到这个选项，所以我觉得有必要提一下。再次提醒，查看`export`的手册页面以获取更多关于你可以传递给导出的附加选项的详细信息。
- en: Next, we have one more file to edit before we can actually seal the deal on
    our NFS setup. The `/etc /idmapd.conf` file is necessary for mapping permissions
    on one node to another. In *Chapter 2*, *Managing Users and ermissions*, we talked
    about the fact that each user has an ID (UID) assigned to them. The problem, though,
    is that from one system to another, a user will not typically have the same UID.
    For example, user `jdoe` may be UID `1001` on server A, but `1007` on server B.
    When it comes to NFS, this greatly confuses the situation, because UIDs are used
    in order to reference permissions. Mapping IDs with `idmapd` allows this to stay
    consistent and handles translating each user properly, though it must be configured
    correctly and consistently on each node. Basically, as long as you use the same
    domain name on each server and client and configure the `/etc/idmapd.conf` file
    properly on each, you should be fine.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure this, open `/etc/idmapd.conf` in your text editor. Look for an
    option that is similar to the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First, remove the `#` symbol from that line to uncomment it. Then, change the
    domain to match the one used within the rest of your network. You can leave this
    as it is as long as it’s the same on each node, but if you recall from *Chapter
    11*, *Setting Up Network Services*, we used a sample domain of `local.lan` in
    our DHCP configuration, so it’s best to make sure you use the same domain name
    everywhere—even the domain provided by DHCP. Basically, just be as consistent
    as you can and you’ll have a much easier time overall. You’ll also want to edit
    the `/etc/idmapd.conf` file on each node that will access your file server, to
    ensure they are configured the same as well.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'With our `/etc/exports` and `/etc/idmapd.conf` files in place, and assuming
    you’ve already created the exported directories on your filesystem, we should
    be all set to restart NFS to activate our configuration:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After restarting NFS, you should check the daemon’s output via `systemctl`
    to ensure that there are no errors:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As long as there are no errors, our NFS server should be working. Now, we just
    need to learn how to mount these shares on another system. Unlike Samba, using
    a Linux file manager and browsing the network will not show NFS exports by default;
    we’ll need to mount them manually. Client machines, assuming they are Debian-based
    (Ubuntu fits this description), will need the `nfs-common` package installed in
    order to access these exports.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'It may already be installed, but if it’s not, we can install it with `apt`
    like any other package:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With the client installed, we can now use the `mount` command to mount NFS
    exports on a client. For example, with regards to our `documents` export, we can
    use the following variation of the `mount` command to do the trick:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Replace `myserver` with either your server’s hostname or its IP address, `documents`
    with the name of the actual share on the server, and `/mnt/documents` with the
    path on your local server where you want to mount the share. From this point forward,
    you should be able to access the contents of the `documents` export on your file
    server. Notice, however, that the exported directory on the server was `/exports/documents`,
    but we only asked for `/documents` instead of the full path with the example `mount`
    command. The reason this works is because we identified an export root of `/exports`.
    To save you from flipping back, here’s the first line from the `/etc/exports`
    file, where we identified our export root:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With the export root, we basically set the base directory for our NFS exports.
    We set it as read-only (`ro`), because we don’t want anyone making any changes
    to the `/exports` directory itself. Other directories within `/exports` have their
    own permissions and will thus override the `ro` setting on a per-export basis,
    so there’s no real reason to set our export root as anything other than read-only.
    With our export root set, we don’t have to call out the entire path of the export
    when we mount it; we only need the directory name. This is why we can mount an
    NFS export from `myserver:/documents` instead of having to type the entire path.
    While this does save us a bit of typing, it’s also useful because from the user’s
    perspective, they aren’t required to know anything about the underlying filesystem
    on the server. There’s simply no value in the user having to memorize the fact
    that the server is sharing a document’s directory from `/exports`; all they’re
    interested in is getting to their data. Another benefit is if we ever need to
    move our export `root` to a different directory (during a maintenance period),
    our users won’t have to change their configuration to reference the new place;
    they’ll only need to unmount and remount the exports.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'So, at this point, you’ll have three directories being exported from your file
    server, and you can always add others as you go. However, whenever you add a new
    export, it won’t be automatically added and read by NFS. You can restart NFS to
    activate new exports, but that’s not really a good idea while users may be connected
    to them, since that will disrupt their access. Thankfully, the following command
    will cause NFS to reread the `/etc/exports` file without disrupting existing connections.
    This will allow you to activate new exports immediately without having to wait
    for users to finish what they’re working on:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With this section out of the way, you should be able to export a directory from
    your Ubuntu Server, and then mount that export on another Linux machine. Feel
    free to practice creating and mounting exports until you get the hang of it. In
    addition, you should familiarize yourself with a few additional options and settings
    that are allowable in the `/etc/exports` file, after consulting the man page on
    exports.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The `/etc/exports` file, as you’ve seen in this section, is typically all you’ll
    need to set up a basic file server via NFS. However, you should also be aware
    that there’s another configuration file, `/etc/nfs.conf`, and that file is new
    in Ubuntu 22.04\. The purpose of this file is to tune the finer details of the
    NFS server. Although it’s out of scope to go over the `/etc/nfs.conf` file, it’s
    worth having a look at this file in order to get a feel for which types of options
    are available. For more information, see the further reading section at the end
    of this chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve had more NFS practice than you can tolerate, we’ll move on to a
    few ways in which you can copy files from one node to another without needing
    to set up an intermediary service or daemon.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Transferring files with rsync
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of all the countless tools and utilities available in the Linux and Unix world,
    few are as beloved as `rsync`. This is a utility that you can use to copy data
    from one place to another very easily, and there are many options available to
    allow you to be very specific about how you want the data to be transferred. Examples
    of its many use cases include copying files while preserving permissions, copying
    files while backing up replaced files, and even setting up incremental backups.
    If you don’t already know how to use `rsync`, you’ll probably want to get lots
    of practice with it, as it’s something you’ll soon see will be indispensable during
    your career as a Linux administrator, and it is also something that the Linux
    community generally assumes you already know. Thankfully, `rsync` is not hard
    to learn. Most administrators can learn the basic usage in about an hour or less,
    but the countless options available will lead you to learn new tricks even years
    down the road.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Another aspect that makes `rsync` flexible is the many ways you can manipulate
    the source and target directories. I mentioned earlier that `rsync` is a tool
    you can use to copy data from one place to another. The beauty of this is that
    the source and target can literally be anywhere you’d like, assuming you have
    appropriate access. For example, the most common usage of `rsync` is to copy data
    from a directory on one server to a directory on another server over the network.
    However, you don’t even have to use the network; you can even copy data from one
    directory to another on the same server. While this may not seem like a useful
    thing to do at first, consider that the target directory may be a mount point
    that leads to a backup disk, or an NFS share that actually exists on another server.
    This also works in reverse: you can copy data from a network location to a local
    directory if you desire.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: To get started with practicing with `rsync`, I recommend that you find some
    sample files to work with. Perhaps you have a collection of documents you can
    use, MP3 files, videos, text files, or basically any kind of data you have lying
    around. It’s important to make a copy of this data. If we make a mistake we could
    overwrite things, so it’s best to work with a copy of the data, or data you don’t
    care about, while you’re practicing. If you don’t have any files to work with,
    you can create some text files. The idea is to practice copying files from one
    place to another; it really doesn’t matter what you copy or where you send it
    to. I’ll walk you through some `rsync` examples that will progressively increase
    in complexity. The first few examples will show you how to back up a `home` directory,
    but later examples will be potentially destructive so you will probably want to
    work with sample files until you get the hang of it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our first example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With that command, we’re using `rsync` (as `root`) to copy the contents of the
    `home` directory for the `myuser` directory to a backup directory, `/backup` (make
    sure the target directory exists). In the example, I used the `-r` option, which
    means `rsync` will grab directories recursively as well. You should now see a
    copy of the `/home/myuser` directory inside your `/backup` directory.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we have a bit of a problem. If you look at the permissions in the
    `/backup/myuser` directory, you can see that everything in the target is now owned
    by `root`. This isn’t a good thing; when you back up a user’s `home` directory,
    you’ll want to retain their permissions. In addition, you should retain as much
    metadata as you can, including things like timestamps. Let’s try another variation
    of `rsync`. Don’t worry about the fact that `/backup` already has a copy of the
    `myuser` home directory from our previous backup. Let’s perform the backup again,
    but this time, we’ll use the `-a` option:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This time, we replaced the `-r` option with `-a` (archive), which retains as
    much metadata as possible (in most cases, it should make everything an exact copy).
    What you should notice now is that the permissions within the backup match the
    permissions within the user’s `home` directory we copied from. The timestamps
    of the files will now match as well. This works because whenever `rsync` runs,
    it will copy what’s different from the last time it ran. The files from our first
    backup were already there, but the permissions were wrong. When we ran the second
    command, `rsync` only needed to copy what was different, so it applied the correct
    permissions to the files. If any new files were added to the source directory
    since we last ran the command, the new or updated files would be copied over as
    well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'The `archive` mode (the `-a` option that we used with the previous command)
    is actually very popular; you’ll probably see it a lot during your travels. The
    `-a` option is actually a wrapper option that includes the following options all
    at the same time:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you’re curious about what each of these options do, consult the man page
    for `rsync` for more detailed information. In summary, the `-r` option copies
    data recursively (which we already know), the `-l` option copies symbolic links,
    `-p` preserves permissions, `-g` preserves group ownership, `-o` preserves the
    owner, and `-D` preserves device files. If you put those options together, we
    get `-rlptgoD`. Therefore, `-a` is actually equal to `-rlptgoD`. I find `-a` easier
    to remember.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The `archive` mode is great and all, but wouldn’t it be nice to be able to
    watch what `rsync` is up to when it runs? Add the `-v` option and try the command
    again:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This time, `rsync` will display on your terminal what it’s doing as it runs
    (`-v` activates **verbose** mode). This is actually one of my favorite variations
    of the `rsync` command, as I like to copy everything and retain all the metadata,
    as well as watch what `rsync` is doing as it works.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'What if I told you that `rsync` supports SSH by default? It’s true! Using `rsync`,
    you can easily copy data from one node to another, even over SSH. The same options
    apply, so you don’t actually have to do anything different other than point `rsync`
    to the other server, rather than to another directory on your local server:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With this example, I’m copying the `home` directory for `myuser` to the `/backup`
    directory on server `192.168.1.5`. I’m connecting to the other server as the `admin`
    user. Make sure you change the user account and IP address accordingly, and also
    make sure the user account you use has access to the `/backup` directory. When
    you run this command, you should get prompted for the SSH password as you would
    when using plain SSH to connect to the server. After the connection is established,
    the files will be copied to the target server and directory.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’ll get into some even cooler examples (some of which are potentially
    destructive), and we probably won’t want to work with an actual `home` directory
    for these, unless it’s a test account and you don’t care about its contents. As
    I’ve mentioned before, you should have some test files to play with. When practicing,
    simply replace my directories with yours. Here’s another variation worth trying:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now I’m introducing you to the `--delete` option. This option allows you to
    synchronize two directories. Let me explain why this is important. With every
    `rsync` example up until now, we’ve been copying files from point A to point B,
    but we weren’t deleting anything. For example, let’s say you’ve already used `rsync`
    to copy contents from point A to point B. Then, you delete some files from point
    A. When you use `rsync` to copy files from point A to point B again, the files
    you deleted in point A won’t be deleted in point B. They’ll still be there. This
    is because by default, `rsync` copies data between two locations, but it doesn’t
    remove anything. With the `--delete` option, you’re effectively synchronizing
    the two points, thus you’re telling `rsync` to make them the same by allowing
    it to delete files in the target that are no longer in the source.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll add the `-b` (backup) option:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This one is particularly useful. Normally, when a file is updated on `/src`
    and then copied over to `/target`, the copy on `/target` is overwritten with the
    new version. But what if you don’t want any files to be replaced? The `-b` option
    renames files on the target that are being overwritten, so you’ll still have the
    original file. If you add the `--backup-dir` option, things get really interesting:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, we’re copying files from `/src` to `/target` as we were before, but we’re
    now sending replaced files to the `/backup/incremental` directory. This means
    that when a file is going to be replaced on the target, the original file will
    be copied to `/backup/incremental`. This works because we used the `-b` option
    (backup) but we also used the `--backup-dir` option, which means that the replaced
    files won’t be renamed; they’ll simply be moved to the designated directory. This
    allows us to effectively perform incremental backups.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on our previous example, we can use the Bash shell itself to make
    incremental backups work even better. Consider these commands:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With this example, we grab the current date and store it in a variable (`CURDATE`).
    In the `rsync` portion of the command, we use that variable for the `--backup-dir`
    option. This will copy the replaced files to a `backup` directory named after
    the `date` the command was run. Basically, if today’s date was `08-17-2022`, the
    resulting command would be the same as if we had run the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Hopefully, you can see how flexible `rsync` is and how it can be used to not
    only copy files between directories and/or nodes, but also to serve as a backup
    solution as well (assuming you have a remote destination to copy files to). The
    best part is that this is only the beginning. If you consult the man page for
    `rsync`, you’ll see that there are a lot of options you can use to customize it
    even further. Give it some practice, and you should get the hang of it in no time.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Transferring files with SCP
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A useful alternative to `rsync` is the **Secure Copy** (**SCP**) utility, which
    comes bundled with the OpenSSH client. It allows you to quickly copy files from
    one node to another. While `rsync` also allows you to copy files to other network
    nodes via SSH, SCP is more practical for one-off tasks; `rsync` is geared toward
    more complex jobs. If your goal is to send a single file or a small number of
    files to another machine, SCP is a great tool you can use to get the job done.
    If nothing else, it’s yet another item for your administration toolbox. To utilize
    SCP, we’ll use the `scp` command. Since you most likely already have the OpenSSH
    client installed, you should already have the `scp` command available. If you
    execute `which scp`, you should receive the following output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If you don’t see any output, make sure that the `openssh-client` package is
    installed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Using SCP is very similar in nature to `rsync`. The command requires a source,
    a target, and a filename. To transfer a single file from your local machine to
    another, the resulting command would look similar to the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With this example, we’re copying the `myfile.txt` file (which is located in
    our current working directory) to a server located at `192.168.1.50`. If the target
    server is recognized by DNS, we could’ve used the DNS name instead of the IP address.
    The command will connect to the server as user `jdoe` and place the file into
    that user’s `home` directory. Actually, we can shorten that command a bit:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that I removed the target path, which was `/home/jdoe`. I’m able to omit
    the path to the target, since the `home` directory is assumed if you don’t give
    the `scp` command a target path. Therefore, the `myfile.txt` file will end up
    in `/home/jdoe` whether or not I included the path to the `home` directory explicitly.
    If I wanted to copy the file somewhere else, I would definitely need to call out
    the location. Make sure you always include at least the colon when copying a file,
    since if you don’t include it, you’ll end up copying the file to your current
    working directory instead of the target.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'The `scp` command also works in reverse:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: With this example, we’re assuming that `myfile.txt` is located in the `home`
    directory for the user `jdoe`. This command will copy that file to the current
    working directory of our local machine, since I designated the local path as a
    *single period* (which corresponds to our current working directory). Using `scp`
    in reverse isn’t always practical, since you have to already know where the desired
    file is stored on the target before transferring it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'With our previous `scp` examples, we’ve only been copying a single file. If
    we want to transfer or download an entire directory and its contents, we will
    need to use the `-r` option, which allows us to do a recursive copy:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'With this example, we’re copying the local folder `/home/jdoe/downloads/linux_iso`
    to remote machine `192.168.1.50`. Since we used the `-r` option, `scp` will transfer
    the `linux_iso` folder and all of its contents. At the remote end, we’re again
    connecting via the user `jdoe`. Notice that the target path is simply `downloads`.
    Since `scp` defaults to the user’s `home` directory, this will copy the `linux_iso`
    directory from the source machine to the target machine under the `/home/jdoe/downloads`
    directory. The following command would’ve had the exact same result:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `home` directory is not the only assumption the `scp` command makes. It
    also assumes that SSH is listening on port `22` on the remote machine. Since it’s
    possible to change the SSH port on a server to something else, port `22` may or
    may not be what’s in use. If you need to designate a different port for `scp`
    to use, use the `-P` option:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: With that example, we’re connecting to the remote machine via port `2222`. If
    you’ve configured SSH to listen on a different port, change the number accordingly.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Although port `22` is always the default for OpenSSH, it’s common for some administrators
    to change it to something else. While changing the SSH port doesn’t add a great
    deal of benefit in regard to security (an intensive port scan will still find
    your SSH daemon), it’s a relatively easy change to make, and making it even just
    a little bit harder to find is beneficial. We’ll discuss this further in *Chapter
    21*, *Securing Your Server*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Like most commands in the Linux world, the `scp` command supports verbose mode.
    If you want to see how the `scp` command progresses as it copies multiple files,
    add the `-v` option:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Well, there you have it. The `scp` command isn’t overly complex or advanced,
    but it’s really great for situations in which you want to perform a one-time copy
    of a file from one node to another. Since it copies files over SSH, you benefit
    from its security, and it also integrates well with your existing SSH configuration.
    An example of this integration is the fact that `scp` recognizes your `~/.ssh/config`
    file (if you have one), so you can shorten the command even further. Go ahead
    and practice with it a bit, and in the next section, we’ll go over yet another
    trick that OpenSSH has up its sleeve.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored multiple ways of accessing remote resources. Just
    about every network has a central location for storing files, and we explored
    two ways of accomplishing this with NFS and Samba. Both NFS and Samba have their
    place in the data center and are very useful ways in which we can make resources
    on a server available to our users who need to access them. We also talked about
    `rsync` and `scp`, two great utilities for transferring data without needing to
    set up a permanent share.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Next up is *Chapter 13*, *Managing Databases*. Now that we have all kinds of
    useful services running on our Ubuntu Server network, it’s only fitting that we
    take a look at serving databases as well. Specifically, we’ll look at MariaDB.
    See you there!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Relevant videos
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tutorial for `scp`: [https://linux.video/scp](https://linux.video/scp)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Backing up a Linux server with `rsync`: [https://linux.video/rsync-backup](https://linux.video/rsync-backup)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transferring files with `rsync`: [https://linux.video/rsync-transfer](https://linux.video/rsync-transfer)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ubuntu `rsync` documentation: [https://learnlinux.link/u-rsync](https://learnlinux.link/u-rsync)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ubuntu Samba documentation: [https://learnlinux.link/u-smb](https://learnlinux.link/u-smb)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service – NFS (contains additional information on NFS changes in 22.04): [https://learnlinux.link/u-nfs-1](https://learnlinux.link/u-nfs-1)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ubuntu NFS documentation: [https://learnlinux.link/u-nfs-2](https://learnlinux.link/u-nfs-2)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Active Directory Integration: [https://learnlinux.link/u-ad](https://learnlinux.link/u-ad)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
