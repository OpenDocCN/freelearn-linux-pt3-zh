- en: '*Chapter 6*: Configuring SELinux through Infrastructure-as-Code Orchestration'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the advent of large distributed application platforms, cloud services,
    and the high adoption of virtualized infrastructure, system administrators are
    actively managing their systems through **Infrastructure-as-Code** frameworks:
    orchestration and configuration tooling that uses source code-like information
    to manage the systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, administrators will learn how to distribute and load custom
    SELinux policy modules, set file context definitions and apply those to the systems,
    set the permissive state of the system or SELinux domains, configure the SELinux
    settings on the systems, and how to customize SELinux actions if they are not
    supported by the tooling. We will apply this with four popular automation frameworks:
    Ansible, Chef, Puppet, and SaltStack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the target settings and policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible for SELinux system administration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing SaltStack to configure SELinux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating system management with Puppet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wielding Chef for system automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found in our Git repository at [https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition](https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2T4Fksv](https://bit.ly/2T4Fksv)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the target settings and policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we embark on the journey of using these four automation frameworks, we
    need to clarify what we want to accomplish. After all, to truly compare automation
    frameworks, we need to test each framework with the same tests each time.
  prefs: []
  type: TYPE_NORMAL
- en: The idempotency of actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever we create a remote management environment with a central repository,
    we need to consider the impact of running remote management activities on the
    system. A very common best practice, strongly adopted by all these frameworks,
    is idempotency.
  prefs: []
  type: TYPE_NORMAL
- en: 'An **idempotent** task is a task that will not modify a system if the system''s
    state is already how it should be. Or, differently put, repeatedly executing a
    task does not affect the system or the processes that run on it if nothing needs
    to be changed. As an example, consider loading an SELinux module: if the module
    is already loaded, then the module should not be reloaded. If it isn''t loaded
    yet, then we will load the proper module.'
  prefs: []
  type: TYPE_NORMAL
- en: While most actions supported by the automation frameworks are idempotent, we
    will need to create custom actions ourselves if the framework does not support
    what we want. For instance, if the framework does not support loading SELinux
    modules, then we need to write our own code to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Most orchestration frameworks will envelope non-idempotent tasks in a definition
    that is more idempotent. For instance, if a change in a configuration file requires
    a system reboot, then the enveloped definition would be something like *reboot
    after file change*. The engine can check the state of the file (when it changed)
    and the system (when it rebooted) and deduce whether a reboot is needed or not,
    even though a system reboot as a task is a non-idempotent task.
  prefs: []
  type: TYPE_NORMAL
- en: Policy and state management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first set of scenarios that we want to support through the automation frameworks
    is to ensure that SELinux is active (enforcing) and that the right SELinux policy
    is loaded, a task usually performed by the machine's package management system.
    While allowing the package management system to handle this is convenient, it
    only offers the ability to use distribution-specific default policies. Sysadmins
    of systems with different security requirements will be restrained when using
    default policies and will need to create custom policies and policy handling routines.
    So, we will examine how to distribute and load custom policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom policy we will use in the examples is a CIL policy, which is very
    new and often not directly supported by the automation frameworks. However, it
    gives us a nice reoccurring situation to create custom rules within the automation
    framework. We store the policy itself in a file called `test.cil` that has the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This simple policy will enable logging any transition from the `staff_sudo_t`
    domain to the `sysadm_t` domain and is easy to test out with `sudo`. In our example,
    it serves no other purpose than to quickly allow us to verify that the policy
    has been correctly loaded.
  prefs: []
  type: TYPE_NORMAL
- en: State-wise, we will ensure that the system is in enforcing mode, but have the
    `zoneminder_t` SELinux domain marked as permissive.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux configuration settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second group of actions we want to take up is to configure the system with
    the various SELinux settings we've discussed in different chapters before. Most
    of these we've seen through the `semanage` commands, and we will learn how the
    various automation frameworks support these entries, and to what extent.
  prefs: []
  type: TYPE_NORMAL
- en: We will not go through every setting, but rather focus on the supported configuration
    sets within each automation framework. If a framework does not support a particular
    configuration (such as the `semanage ibpkey` one, which is fairly new), we will
    need to create custom actions for this. In that case, we will show how to approach
    this once, as it is a recurring and similar approach for the others as well.
  prefs: []
  type: TYPE_NORMAL
- en: Setting file contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third and final group of actions we want to see is how the automation frameworks
    support applying file contexts to resources. This can be applying an `semanage
    fcontext` configuration, after which a restore operation is done (such as with
    `restorecon`), but also validating whether the framework supports applying contexts
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: Directly applying the context allows administrators to use the frameworks directly
    without having to twiddle with creating and reapplying file context definitions
    (which can have some performance overhead). However, this should only be considered
    if the automation framework is the sole method through which system changes can
    be made. In any other case, having missing file context definitions might lead
    to administrators resetting contexts to an incorrect state.
  prefs: []
  type: TYPE_NORMAL
- en: Recovering from mistakes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we're diving into the various frameworks that allow managing
    SELinux across a multitude of systems. It is not the intention of this chapter
    to explain the frameworks themselves in detail, nor the secure configuration of
    the frameworks themselves. We don't recommend immediately applying this to production
    systems without testing first, and make sure to have backups!
  prefs: []
  type: TYPE_NORMAL
- en: That being said, many settings applied in this chapter are easily corrected
    if things fail. We refer to [*Chapter 2*](B16276_02_Final_VK.xhtml#_idTextAnchor045),
    *Understanding SELinux Decisions and Logging*, to selectively put SELinux in permissive
    mode if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, each framework can easily be suspended, allowing administrators
    to correct issues without being affected by the framework overwriting the changes
    immediately after.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every framework we discuss further has its own approach to infrastructure automation
    and configuration. It is not the intention of this book to dwell on the details
    of each framework, but rather to focus on its core support and how it deals with
    SELinux. We will also abstract away how to handle different Linux distributions
    and have all examples based on CentOS.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, these frameworks are continuously improving and evolving. When
    we consider these frameworks in this chapter, we only explore how they are commonly
    used, and not how they can specialize in specific deployments. For instance, if
    a framework uses an agent-based architecture by default but also supports SSH-based
    connections, we will only consider the agent-based one in this book, as that is
    the default setup for these frameworks and we want to focus on the SELinux configuration
    support features.
  prefs: []
  type: TYPE_NORMAL
- en: But don't let this stop you from experimenting with the frameworks further and
    adapting them to your own liking! That said, let's dive into our first engine,
    Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible for SELinux system administration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first orchestration and automation tooling we'll consider is Ansible, a
    very popular open source solution for the remote management of systems. Ansible
    has commercial backing through Red Hat but does not limit its support to Red Hat
    or even Linux systems. Other environments such as Windows environments or even
    network setups have significant Ansible-based support.
  prefs: []
  type: TYPE_NORMAL
- en: How Ansible works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Ansible** generally uses a central server that hosts the configuration and
    interprets the settings. The Ansible runtime then connects to the remote systems
    over SSH, sending the necessary data to a temporary location, and then executes
    the steps locally.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of SSH as its main connection approach has significant advantages:
    administrators know how this protocol works and how to configure and control it.
    Furthermore, Ansible does not require any additional deployments on the target
    machines, except for Python and libselinux''s Python bindings (which are often
    installed on SELinux-enabled machines by default).'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible knows how to address the various resources through its modules. **Ansible
    modules** contain the logic that Ansible uses to execute tasks correctly. The
    module code is distributed to the target machines and is executed on the remote
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: The definitions that administrators configure systems with are stored in Ansible
    playbooks. **Playbooks** define how a system should be configured, and Ansible
    will read and interpret playbooks to see what it must execute on each system.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate the management of Ansible playbooks in larger environments, Ansible
    uses **Ansible roles** to bundle coherent definitions. Administrators can then,
    in their playbooks, assign roles to systems to automatically uplift the state
    of those systems accordingly. For instance, a role can be created to create a
    properly configured web server, a database, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create a role called `packt_selinux` and apply it to
    a remote system. Within that role, we will show how to configure and execute the
    various SELinux tasks using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install and set up Ansible, most Linux distributions offer out-of-the-box
    support for the framework. On CentOS, the following steps can be taken. Users
    of other distributions can easily deduce the steps for their platform:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to enable **Extra Packages for Enterprise Linux** (**EPEL**), after
    which you can install Ansible easily. Execute this on the master node (from which
    you want to manage the other systems):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once installed, create an SSH key pair to use between the master system and
    the target systems that we will be managing with Ansible. Use the `ssh-keygen`
    command to create a key pair on the master system, and then copy the public key
    (`~/.ssh/id_rsa.pub`) to the remote systems, saving it as `~/.ssh/authorized_keys`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test to see whether the remote connection works properly, for instance, by
    executing the `id` command remotely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the test is successful, we can configure Ansible to see this remote system
    as one of the nodes it will be managing. To accomplish this, edit `/etc/ansible/hosts`
    and add the hostname to the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see whether Ansible can correctly manage the remote system, we can ask it
    to gather all the facts about the remote system. Facts in Ansible represent the
    discovered settings of the remote system and can be used to fine-tune playbooks
    and roles later. For instance, the Ansible facts discovered of the distribution
    can be used to select which package name an installation uses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output of the last task is a large set of discovered facts, showing us that
    the connection succeeded and that Ansible is ready to manage the remote system.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and testing the Ansible role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To allow reusable configurations across multiple systems, Ansible recommends
    the use of its Ansible roles. We will create a role called `packt_selinux`, have
    it create a custom directory, and then assign this role to the remote system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `ansible-galaxy` to create an empty yet ready-to-use role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the `main.yml` file and have it create a custom directory. The content
    of the file should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In later steps, this file will be extended with more and more blocks. Each block
    will start with a name that identifies the block, and then the state definition.
    In the current block, we used Ansible's `file` module to assert that a file or
    directory is available with the parameters given.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Assign the role to the remote system and apply the playbook. We accomplish
    this by first creating an `/etc/ansible/site.yml` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run this playbook to apply the setting defined in our role to the remote systems:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ansible will display its progress, as well as for which tasks it has executed
    a change. In our case, a change would mean that the directory has been created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have tested our role and assigned the role to the remote system,
    all we need to do is update the role gradually until it contains all the logic
    we need. No other configuration is needed, and after each change, we can rerun
    the `ansible-playbook` command from the main server.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning SELinux contexts to filesystem resources with Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the current role, we create a custom directory inside `/usr/share/selinux`.
    This parent directory has the `usr_t` SELinux type set, so the newly created subdirectory
    has it as well. The SELinux user of this directory, however, will be different,
    as Ansible has created the directory after remotely logging in to the system.
    In a default CentOS configuration, this means that the target directory's context
    will have `unconfined_u` as its SELinux user component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the definition in `main.yml` and explicitly set the SELinux user
    and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After applying the change (using `ansible-playbook`), the updated definition
    results in a correctly set SELinux user and SELinux type for this directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we added two parameters to the file definition: `setype` and
    `seuser`. The Ansible file module supports the following SELinux-related parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`seuser` is the SELinux user of the resource. Set this to `system_u` for system
    resources, as used in the example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serole` is the SELinux role of the resource. This is generally not used, as
    role inheritance on the system will generally result in the resource being labeled
    with the `object_r` role, which is correct most of the time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setype` is the SELinux type of the resource and is the most commonly used
    SELinux parameter in file modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selevel` is the SELinux sensitivity level for the resource. By default, it
    is set to `s0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we've learned from the example already, you do not need to declare the type
    if the inherited context is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Loading custom SELinux policies with Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible's current release has no support for loading custom SELinux modules.
    While custom modules are found on Ansible galaxy (the ecosystem where contributors
    can add more modules), let's see how we would handle distributing a custom policy
    to the systems under Ansible control and loading the module, but only if it is
    not loaded yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we could start creating custom modules ourselves, let''s use a combination
    of tasks in the existing role to accomplish this. We will try to accomplish the
    following tasks in sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: Upload a custom policy called `test.cil` to the remote system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether this custom policy is already loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the custom policy, but only if the previous check failed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These three tasks are handled through three modules: the `copy` module, the
    `shell` module, and the `command` module. We will use each of these modules in
    separate steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the custom policy mentioned earlier in this chapter by placing the `test.cil`
    file in the `files/` folder of the `packt_selinux` role.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new code block in the `main.yml` file of the role, with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will ensure that the `test.cil` file, currently on the master machine,
    is distributed to the target nodes in the directory we've previously created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we check whether the policy is already loaded. For this, we use the `shell`
    module and use the fail or success state later. Hence, we store the return in
    the `test_is_loaded` variable, and explicitly tell Ansible to ignore a failure
    as we use this as a check rather than a state definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `command` module loads the policy file, and only if the previous task failed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This approach shows how we can use our knowledge of SELinux to define and set
    states. This method can be used for other SELinux settings as well, for instance,
    by validating the output of listings (for example, with `semanage`) before defining
    or adjusting settings.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible's out-of-the-box SELinux support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ansible has quite a few modules available to provide native support for several
    SELinux-related settings, which we briefly cover here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `selinux` module can be used to set or change the SELinux state (enforcing
    or permissive) as well as to select the appropriate SELinux policy type (such
    as targeted):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the `seboolean` module, the SELinux booleans can be adjusted at will:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `sefcontext` module allows us to change SELinux file context definitions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With `selinux_permissive`, we can selectively mark certain SELinux policy domains
    as permissive:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `selogin` module can be used to map a login to an SELinux user, as with
    `semanage login`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`seport` can be used to create an SELinux port mapping:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Other SELinux settings might be supported through custom modules, but with the
    method presented earlier, administrators can already start configuring SELinux
    across all systems in their environment.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing SaltStack to configure SELinux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second orchestration and automation framework we'll consider is SaltStack,
    which has commercial backing by the SaltStack company. SaltStack uses a declarative
    language similar to Ansible and is also written in Python. In this chapter, we
    will use the open source SaltStack framework, but an enterprise version of SaltStack
    is available as well, which adds more features on top of the open source one.
  prefs: []
  type: TYPE_NORMAL
- en: How SaltStack works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SaltStack**, often also described as just Salt, is an automation framework
    that uses an agent/server model for its integrations. Unlike Ansible, SaltStack
    generally requires agent installations on the target nodes (called **minions**)
    and activation of the minion daemons to enable communications to the master. This
    communication is encrypted, and the minion authentication uses public-key validation,
    which needs to be approved on the master to ensure no rogue minions participate
    in a SaltStack environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While agent-less installations are possible with SaltStack as well, we will
    focus on agent-based deployments. In such a configuration, the minions regularly
    check with the master to see whether any updates need to be applied. But administrators
    do not need to wait until the minion pulls the latest updates: you can also trigger
    updates from the master, effectively pushing changes to the nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: The target state that a minion should be in is written down in a `.sls` suffix.
    These Salt State files can refer to other state files, to allow a modular design
    and reusability across multiple machines.
  prefs: []
  type: TYPE_NORMAL
- en: If we need more elaborate coding, SaltStack supports the creation and distribution
    of modules, called **Salt execution modules**. However, unlike Ansible's Galaxy,
    no community repositories currently exist to find more execution modules.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring SaltStack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The installation of SaltStack is similar across the different Linux distributions.
    Let''s see how the installation is done on a CentOS machine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to enable the SaltStack repository that contains its software.
    The project maintains the repository definitions through RPM files that can be
    installed immediately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have enabled the repository on all systems, install `salt-master` on
    the master, and `salt-minion` on the remote systems:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we start the daemons on the systems, we first update the minion configuration
    to point to the master. By default, the minions will attempt to connect to a host
    with the hostname `salt`, but this can be easily changed by editing `/etc/salt/minion`
    and setting the right hostname:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the minion configured, we can now launch the SaltStack master (`salt-master`)
    and minion (`salt-minion`) daemons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The minion will connect to the master and present its public key. To list the
    agents currently connected, use `salt-key -L`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have accepted the key, the master will know and control the minion.
    Let''s see whether we can properly interact with the remote system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will list all system services on the minion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `salt` command is the main command used to query and interact with the remote
    minions from the master. If the last command is successfully returning all system
    services, then SaltStack is correctly configured and ready to manage the remote
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and testing our SELinux state with SaltStack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create our SELinux state called `packt_selinux`, and have it applied
    to the remote minion:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to create the top file. This file is the master file for SaltStack,
    from which the entire environment is configured:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create the state definition for `packt_selinux`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Place the SELinux `test.cil` module, as defined earlier on in this chapter,
    inside `/srv/salt/packt_selinux` as we refer to it in the state definition. Once
    placed, we can apply this state to the environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `state.apply` subcommand of the `salt` command is used to apply the state
    across the environment. Each time we modify our state definition, this command
    can be used to force an update to the minions. Without this, the minions will
    (by default) update their state every 60 minutes. These scheduled state updates
    are called mine updates and are configured on the agents inside `/etc/salt/minion`.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning SELinux contexts to filesystem resources with SaltStack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing, support for addressing SELinux types in resources has
    not yet reached the stable versions of SaltStack. SaltStack, however, supports
    running commands but only if a certain test has succeeded (or failed).
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `init.sls` file and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `cmd.run` approach allows us to easily create custom SELinux support using
    the commands we've seen earlier on in this book. The `unless` check contains the
    test to see whether we need to execute the command or not, allowing us to create
    idempotent state definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Loading custom SELinux policies with SaltStack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s load our custom SELinux module on the remote systems. SaltStack has
    support for loading SELinux modules through the `selinux.module` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As in the previous section, we need to add an `unless` statement, as otherwise,
    SaltStack will attempt to load the SELinux module repeatedly every time the state
    is applied.
  prefs: []
  type: TYPE_NORMAL
- en: Using SaltStack's out-of-the-box SELinux support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SaltStack''s native SELinux support is gradually expanding but still has much
    room for improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `selinux.boolean`, the SELinux boolean values can be set on the target
    machines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The file contexts, as managed with `semanage fcontext`, can be defined using
    the `selinux.fcontext_policy_present` state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To remove the definition, use the `selinux.fcontext_policy_absent` definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With `selinux.mode`, we can put the system in enforcing or permissive mode:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Port mappings are handled using the `selinux.port_policy_present` state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `cmd.run` approach mentioned earlier, we can apply SELinux configuration
    updates to systems in a repeatable fashion for unsupported settings.
  prefs: []
  type: TYPE_NORMAL
- en: Automating system management with Puppet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet is the third automation framework that we will check out. It is the oldest
    one in our list, with its first release in 2005, and is commonly seen as the baseline
    against which other automation frameworks are compared. It has commercial backing
    through the Puppet company, also often referred to as Puppet Labs.
  prefs: []
  type: TYPE_NORMAL
- en: How Puppet works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like SaltStack, **Puppet** uses an agent/server-based model with public-key
    authentication of the agents to ensure no rogue agents are active within the environment.
  prefs: []
  type: TYPE_NORMAL
- en: The **Puppet master** has access to the **Puppet manifests**, which is the declaration
    of the state that Puppet wants to achieve. These manifests use a specific language
    inspired by Ruby and can refer to classes provided by modules to ensure reusability
    across the environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Puppet modules**, hence, are the workhorse within Puppet, and Puppet has
    a significant community called Puppet Forge that allows you to download and install
    modules created by the community to more easily manage your environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Puppet agents will regularly connect to the master, informing the master of
    the current details of the remote machine. These current details are called **facts**
    and can be used by Puppet to dynamically handle changes in the environment. The
    master then compiles the target state in what it calls a **catalog** and sends
    that catalog over to the agent. The agent then applies this catalog and reports
    the results back.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Puppet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Puppet company offers integrated packages for several Linux distributions.
    The following instructions focus on RPM-compatible distributions, but other platforms
    have very similar instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Puppet company provides repository definitions through RPM files. After
    the repositories are established, you can install `puppetserver` and `pdk` (on
    the master) and `puppet-agent` (on the remote systems) so that the software is
    readily available to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the master to have its certificate properly named. Edit the `puppet.conf`
    file inside `/etc/puppetlabs/puppet` and, within the `[master]` section, update
    or add the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the Puppet server so that the clients can start connecting to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the remote systems, edit the same configuration file, and update or add
    the following settings in the `[main]` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, start the Puppet agent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the master node, we can now query the pending certificate requests. It should
    display the requests from the agents we recently started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can accept this request (sign the certificate) as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To validate whether the connection works, log in on the remote machine and
    trigger the agent to apply the (currently empty) catalog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unlike SaltStack, where we can push a change to the agents, Puppet relies on
    the agents to frequently poll the server. In the configuration we made earlier,
    we configured the agent to check every hour. With the `puppet agent --test` command,
    we can signal the agent to run the state check immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and testing the SELinux class with Puppet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create our `packt_selinux` class, through which we will configure our
    remote machine''s SELinux settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `/etc/puppetlabs/code/modules` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result is an empty module with lots of default files and directories. We
    will be mostly working with the module's manifest file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside the `packt_selinux/manifests` directory, create a new file named `init.pp`
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, inside the `/etc/puppetlabs/code/environments/production/manifests` location,
    create a file called `site.pp` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `site.pp` file provides the top-level hierarchy for Puppet to associate
    its environment with the appropriate definitions. In this example, the node with
    the hostname `rem1.internal.genfic.local` is configured through a reference to
    `packt_selinux`, the module we created previously.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inside the `packt_selinux` module, we've created the `packt_selinux` class,
    which currently is composed of a single directive to create `/usr/share/selinux/custom`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With these definitions in place, have the remote agent update its state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In product environments, it is common to have this command either scheduled
    regularly or to run the Puppet agent continuously as a daemon.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the class properly assigned to the node, we can expand our configuration
    with more SELinux details.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning SELinux contexts to filesystem resources with Puppet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s augment our current class definition with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For this block to work properly, we need to place the `test.cil` SELinux module
    in the `files/` folder inside the `packt_selinux` module location. This block
    will have Puppet upload the file to the directory, with the dependency set that
    the directory must exist. The `require` statement refers to the previously defined
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also see that Puppet has out-of-the-box support for SELinux type definitions.
    The file class has several SELinux-supported parameters that can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`seluser` defines the SELinux user for the resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selrole` defines the SELinux role for the resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seltype` defines the SELinux type for the resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selrange` defines the SELinux sensitivity range for the resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selinux_ignore_defaults` tells Puppet to ignore the default SELinux context
    (as queried from the SELinux policy).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our previous example is thus actually superfluous because Puppet will actively
    query the SELinux policy to discover what the right resource context is and apply
    this. With `selinux_ignore_defaults` set to `true`, Puppet will not query and
    adjust the context accordingly, which can be useful when testing out new setups
    that do not have proper context definitions set.
  prefs: []
  type: TYPE_NORMAL
- en: Loading custom SELinux policies with Puppet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Puppet does have support for loading and managing SELinux modules. However,
    its support is currently restricted to the more traditional SELinux policy modules,
    and not the CIL powered ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create another block in our module definition that loads the `test.cil`
    file, but only if no test SELinux module is already loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This approach allows us to create custom SELinux configuration adjustments if
    the native Puppet support does not suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Using Puppet's out-of-the-box SELinux support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Puppet has a few SELinux-related classes supported out of the box but has more
    support through Puppet Forge, an ecosystem of community-contributed modules. One
    of the modules that we can recommend is the `puppet-selinux` module, which Puppet
    (the company) maintains on Puppet Forge (and thus has a higher chance of remaining
    supported in later versions of Puppet).
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing new modules is quite easy, using the `puppet module` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then refer to the `selinux` class (provided through this module) within
    our manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `selinux` class can be directly used to set the enforcing (or permissive)
    state of the system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The (native) `selboolean` class can be used to set SELinux booleans:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SELinux file contexts can be defined using the `selinux::fcontext` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Equivalence definitions for the file context are handled by `selinux::fcontext::equivalence`,
    like so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Custom port mappings are handled by `selinux::port`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Individual SELinux domains can be made permissive using `selinux::permissive`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If standard SELinux modules are present, the use of `selmodule` allows loading
    it up. In this case, it will search for the SELinux module named after the block,
    inside the directory referred to by `selmoduledir`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While other SELinux-supporting modules might be available on Puppet Forge, be
    sure to validate whether these modules are mature and sufficiently stable. If
    their support is uncertain, you might want to pursue the `exec` route, as used
    earlier on, in *Loading custom SELinux policies with Puppet*.
  prefs: []
  type: TYPE_NORMAL
- en: Wielding Chef for system automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last automation framework we will explore is Chef. Chef is a slightly more
    hands-on and development-oriented automation framework than the previous ones,
    but powerful nonetheless. It has commercial backing by the similarly named company
    Chef.
  prefs: []
  type: TYPE_NORMAL
- en: How Chef works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chef has a slightly more extensive approach to automation and requires slightly
    more work to get up and running. Once set up, however, it offers a very flexible
    and programmable environment wherein infrastructure automation can be worked out.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of systems in the Chef architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Chef server** acts as the central hub on which the automation code is
    maintained, and which interacts with the remote systems to apply the changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Chef workstation** is an endpoint on which administrators and engineers
    develop Chef recipes (code) and cookbooks and interact with the Chef server. There
    can be multiple Chef workstations per Chef environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Chef client** is an agent running on the remote systems (nodes) managed
    by the Chef environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers create automation code in **recipes**, which are like tasks. Multiple
    recipes are bundled in a **cookbook** and uploaded to the Chef server before the
    recipes can be applied to one or more nodes. Cookbooks can be compared with modules
    in the previous automation frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The Chef clients and server use public key-based authentication and encryption
    for their interactions. It is the client that takes the initiative, connecting
    to the server to download the latest cookbooks and other resources, after which
    it calculates and applies the latest changes, sending feedback on these changes
    back to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Chef
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A full Chef installation requires a few components to be installed. The Chef
    workstation and the Chef server need to be installed by the administrator, whereas
    the Chef agents will be installed by Chef later.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Chef workstation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install and use Chef, first download the Chef workstation. All Chef software
    can be downloaded from [https://downloads.chef.io](https://downloads.chef.io).
    For CentOS, the Chef workstation is available as an RPM, which can be installed
    using `yum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, unlike common packaged software, the Chef workstation dependencies
    are not explicitly listed as RPM dependencies, causing the software to be installed
    without its necessary libraries. At the end of the installation, the RPM file
    will execute a post-installation script that checks the dependencies and reports
    on the missing libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependencies, currently, require the following CentOS packages to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'After the installation, run `chef -v` (as a regular, non-root user) to verify
    whether all dependencies are met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The command should output the versions of the included Chef components.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring the Chef server core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second installation is the Chef server core. This software is again made
    available as RPM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Chef server core using `yum`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the installation finishes, we need to configure it for our environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a directory named `/var/opt/chef`. We will use this directory to store
    the cryptographic keys to authenticate against the Chef server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, configure the Chef server using `chef-server-ctl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will set up the Chef server on the current system. This setup can take
    a while to complete, but once finished, we can continue with creating a user account
    inside of Chef.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s create an account called `chefadmin` for the user `lisa` on this system
    and give it a custom password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an organization unit inside the Chef configuration, which we associate
    with the newly created user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this done, the server administration itself is all done, and we can start
    creating our development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the development environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned earlier on, Chef is somewhat more development-oriented than the
    previous automation frameworks. The user that will interact with Chef (using the
    Chef workstation) needs to establish a development environment first:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We previously created an account called `chefadmin` for the user `lisa`. Now,
    log in as the user `lisa` and create a development environment in the user''s
    home directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a Git-enabled environment as the Chef utilities require it. If you
    have no active Git configuration yet, you might need to add your email and name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the Chef knife configuration as `.chef/knife.rb` within this environment
    (so `~/chef/.chef/knife.rb` in our example):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Download the certificates that the Chef server uses (these certificates are
    self-signed certificates) and then check the SSL connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the checks are successful, we can commit the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are now ready to start our recipe and cookbook development.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the SELinux cookbook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The cookbook we are going to develop will contain the various SELinux configuration
    entries, which are then assigned to the remote node:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a cookbook called `packt_selinux`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `recipes/default.rb` file contains the actual logic we want to apply to
    the remote systems. Let''s create a definition for the `/usr/share/selinux/custom`
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now upload the cookbook to the Chef server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can query the available cookbooks on the Chef server with the `list` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the cookbook available, let''s bootstrap the target node. Bootstrapping
    only needs to occur once, but must be triggered from a Chef authenticated user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This ensures the Chef server knows the remote system. We can query the nodes
    using `knife node list` and get more details about a node with the `show` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign the `packt_selinux` recipe to the node using the `run_list add` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For our purposes, we will trigger the `chef-client` command on the remote system
    to download and apply the latest changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If this command returns successfully, then Chef is ready to manage the remote
    system using the cookbook we've developed.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning SELinux contexts to filesystem resources with Chef
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Chef has limited native support for SELinux contexts. When instructed to create
    or modify files on nodes, it will relabel those files according to the present
    file context definitions on the nodes. We can, however, subscribe to events defined
    in the recipe, and trigger appropriate actions when they occur. For instance,
    to explicitly set the context of a directory, we can create something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding this to the `recipes/default.rb` file, we first need to upload
    the updated cookbook to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Afterward, we can rerun `chef-client` on the remote node to apply this updated
    recipe. If the directory was previously already created, the recipe will not change
    anything as the subscription will not be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Loading custom SELinux policies with Chef
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s update our recipe to include the logic to load a custom policy. We will
    use two blocks in our recipe, one to upload the `test.cil` file to the node, and
    another one to load it, but only if it was not loaded previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Put the `test.cil` file in a folder called `files` inside the `packt_selinux`
    cookbook directory, before uploading the updated cookbook and reapplying the changes
    using `chef-client`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Chef's out-of-the-box SELinux support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Chef itself has limited out-of-the-box SELinux support, cookbooks are
    available online on Chef Supermarket (where the Chef community manages and distributes
    their custom cookbooks). Chef (the company) maintains the `selinux` cookbook itself,
    which allows managing the SELinux state of a system, whereas the `selinux_policy`
    cookbook addresses a few other SELinux settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s download and install the `selinux` and `selinux_policy` cookbooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, adjust the `metadata.rb` file of our own cookbook to include the dependency
    to this newly added cookbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use some of the predefined recipes to handle SELinux configuration
    settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `selinux_state`, we can place the system in an enforcing or permissive
    state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `selinux_policy_boolean` recipe can configure an SELinux boolean value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With `selinux_policy_port`, a custom SELinux port mapping can be defined:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A file context definition can be set using `selinux_policy_fcontext`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An SELinux domain can be put in permissive mode using the `selinux_policy_permissive`
    recipe:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Don't forget to upload the changed cookbook before calling `chef-client` on
    the remote systems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automation frameworks such as Ansible, SaltStack, Puppet, and Chef can be easily
    used to manage SELinux settings on a multitude of systems. While not all frameworks
    can deal with SELinux settings natively, this is easily mitigated by either using
    community-provided modules or by creating custom rules that check and update the
    settings accordingly. In this chapter, we've seen how to accomplish this by installing
    a custom, CIL-based SELinux policy.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that these frameworks all have their specific approaches. Ansible,
    for instance, does not use any software installations on remote systems and communicates
    with the target systems using SSH. The other frameworks all use an agent/server
    model but have their own views on configuring settings (the syntax between Puppet
    and SaltStack is noticeably different) or design (Chef uses a workstation where
    developers have their development environment). All these frameworks are easily
    put in place and configured and can handle most SELinux settings without any problems.
    All tools have a way of modularizing the definitions so they can be applied easily
    against a larger number of systems.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to apply SELinux settings consistently, let's see what
    other SELinux controls exist, but now through userspace application-specific support.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the four tools have native support for setting SELinux contexts on
    resources?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do these orchestration tools allow reusable customization beyond native
    support?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some obvious differences between the listed orchestration tools?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
