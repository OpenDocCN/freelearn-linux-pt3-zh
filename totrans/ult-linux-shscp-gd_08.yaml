- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic Shell Script Construction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yeah, I know. You’re dying to start creating some shell scripts, but haven’t
    been able to do that yet. So, in this chapter, we’ll look at the basics of shell
    script construction. We’ll then wrap things up by looking at some shell scripts
    that are both practical and useful.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the techniques that I’m presenting in this chapter work for any shell,
    but I’ll also present some that might only work on `bash`. So, just to keep things
    simple though, I’ll be sticking with `bash` for now. In *Chapter 22, Using the
    zsh Shell*, I’ll show you techniques that are specific to `zsh`. In *Chapter 19,
    Shell Script Portability*, I’ll show you techniques that will work on a wide variety
    of shells.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that you’ll see in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding basic shell script construction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding subshells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding scripting variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding array variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding variable expansion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding command substitution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding decisions and loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding positional parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding exit codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about echo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at some real-world examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All right, if you’re ready, let’s jump in.
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use any Linux distro that has `bash` installed. If you’re a Mac user, you’ll
    want to use one of your Linux virtual machines, because some of the scripts use
    commands that won’t work on macOS. Feel free to follow along on your local machine
    as you go through this chapter, but also be aware that I will provide some actual
    hands-on labs.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve also included one hands-on exercise that uses a FreeBSD virtual machine.
    Create the FreeBSD virtual machine and install both `sudo` and `bash`, as I showed
    you in the book’s *Preface*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, as I explained in the *Preface*, you can download the scripts from the
    Github repository by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Understanding Basic Shell Script Construction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you’ll need to do when creating a shell script is to define
    which shell you want to use to interpret the script.
  prefs: []
  type: TYPE_NORMAL
- en: You might have a particular reason for choosing one shell over another. That’s
    something we’ll talk about in *Chapter 19, Shell Script Portability*, and *Chapter
    22, Using the Z Shell*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll define the shell to use as the interpreter in the **shebang line**,
    which is the first line of the script. It will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally of course, a line that begins with the `#` sign would indicate a comment
    that would be ignored by the shell. The shebang line--and please don’t ask me
    why it’s called that--is an exception to that rule. In addition to defining a
    specific shell that you want to use, such as `/bin/bash` or `/bin/zsh`, you can
    also define the generic `/bin/sh` shell to make your scripts more portable, so
    that they’ll run on a wider variety of shells and operating systems. Here’s how
    that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This generic `sh` shell is supposed to make it so that you can run your scripts
    on different systems that might or might not have `bash` installed. But, it’s
    also problematic because the various shells that `sh` represents aren’t fully
    compatible with each other. Here’s the breakdown of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: On FreeBSD and possibly other **Berkeley Software Distribution** (**BSD**)-type
    systems, the `sh` executable is the old-school Bourne shell, which is the ancestor
    of the Bourne Again Shell (`bash`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Red Hat-type systems, `sh` is a symbolic link that points to the `bash` executable.
    Be aware that `bash` can use certain programming features that the other shells
    in this list can’t use. (I’ll explain more about this in *Chapter 19, Shell Script
    Portability*.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Debian/Ubuntu-type systems, `sh` is a symbolic link that points to the `dash`
    executable. `dash` stands for **Debian Almquist Shell**, which is a faster, more
    lightweight implementation of `bash`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Alpine Linux, `sh` is a symbolic link that points to `ash`, which is a lightweight
    shell that’s part of the `busybox` executable. (On Alpine, `bash` is not installed
    by default.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On OpenIndiana, which is a **Free Open Source Software** fork of Oracle’s Solaris
    operating system, `sh` is a symbolic link that points to the `ksh93` shell. This
    shell, which is also known as the Korn shell, is somewhat, but not completely,
    compatible with `bash`. (It was created by a guy named David Korn, and has nothing
    to do with any vegetable.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On macOS, `sh` is a symbolic link that points to `bash`. (Curiously, `zsh` is
    the default login shell on macOS, but `bash` is still installed by default and
    is available for use.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be aware that using `#!/bin/sh` in your scripts can be problematic. That’s because
    the various shells on the various operating systems that `#!/bin/sh` represents
    aren’t fully compatible with each other. So, let’s say that you’re creating a
    script on a Red Hat machine, on which `sh` points to `bash`. There’s a real possibility
    that the script won’t run on either a Debian or a FreeBSD machine, on which `sh`
    points to `dash` and Bourne shell, respectively. For that reason, we’ll concentrate
    on `bash` for now, and will just use `#!/bin/bash` as our shebang line. And, as
    I mentioned before, we’ll talk more about this topic in *Chapter 19, Shell Script
    Portability*.
  prefs: []
  type: TYPE_NORMAL
- en: A shell script can be as simple or as complex as your needs dictate. It can
    be just one or more normal Linux/Unix commands put together in a list, to be performed
    sequentially. Or, you can have scripts that can approach the complexity of programs
    written in a higher-level programming language, such as C.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by taking a look at a very simple, one-command script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple one-line script that I used to use to back up my `images`
    directory on one computer to a backup directory on a Debian computer. It uses
    `rsync`, with its appropriate options, to synchronize the two directories via
    a Secure Shell (`ssh`) session. (Although I normally don’t like to allow the root
    user to do `ssh` logins, in this case it’s necessary. Obviously, I would only
    do this on a local network, and would never do it across the Internet.) Appropriately,
    I named the script `rsync_with_debian`. Before I could run the script, I had to
    add the executable permission, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: On the second line of this `rsync_with_debian` script, right after the shebang
    line, you see the exact same command that I would have typed on the command-line
    if I didn’t have the script. So, you see, I’ve greatly simplified things by creating
    a script.
  prefs: []
  type: TYPE_NORMAL
- en: To make this script available to all users on the system, place it in the `/usr/local/bin/`
    directory, which should be in everyone’s `PATH` setting.
  prefs: []
  type: TYPE_NORMAL
- en: Before going further, let’s reinforce what you’ve just learned with a hands-on
    lab.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on Lab – Counting Logged-in Users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This lab will help you create a shell script that shows how many users are logged
    in, and then modify it so that only unique users are listed. (This script uses
    some of the text stream filters that you learned about in the previous two chapters.)
  prefs: []
  type: TYPE_NORMAL
- en: 'On one of your Linux virtual machines, create three additional user accounts.
    On your Fedora virtual machine, do it like this, except choose your own user names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On a Debian virtual machine, do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At the local terminal of the virtual machine, obtain its IP address, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open four terminal windows on your host machine. Using the IP address of your
    own virtual machine, log into your own account from one window, and then log into
    each of the other accounts from the other windows. The commands will look something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the terminal window where you’re logged in, view all of the users who
    are currently logged in, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should see five users, because your own account will show up once for the
    local terminal log-in, and once for the remote `ssh` log-in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `logged-in.sh` script, and make it look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I’m using the concept of **command substitution** to assign the output of the
    `who | wc -l` command to the value of the `users` scripting variable. (I’ll tell
    you more about command substitution later, so don’t stress out about it just yet.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the script executable, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the script, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The problem here is that there are really only four users, because your own
    username is counted twice. So, let’s fix that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `logged-in.sh` script so that it now looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The variable `uniqusers` is created by all of the commands that are piped to
    each other inside the `()`. The `cut` operation is delimited by a blank space
    (`-d" "`) and the first field (`-f1`) is what you will cut from the output of
    `who`. That output is piped to `sort` and then to `uniq`, which will only send
    the names of unique users to the `wc -l` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script again, and the output should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make one last modification to the script to list the names of the unique users
    who are logged in. The completed script will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the script again, and you should get output that looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Congratulations! You’ve just created your first shell script. Now, let’s do
    some testing.
  prefs: []
  type: TYPE_NORMAL
- en: Performing Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There will be times when your scripts will need to test for a certain condition
    before making a decision on which action to take. You might need to check for
    the existence of a certain file or directory, whether certain permissions are
    set on a file or directory, or for a myriad of other things. There are three ways
    to perform a test, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the keyword `test` followed by a test condition, with another command joined
    to it with either a `&&` or a `||` construct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enclose the test condition within a set of square brackets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an if. . .then construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by looking at the `test` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Using the test Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our first example, let’s test to see whether a certain directory exists,
    and then create it if it doesn’t. Here’s how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s put that into the `test_graphics.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run this script to see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you may have guessed, the `-d` operator stands for *directory*. The `||`
    construct causes the `mkdir` command to run if the graphics directory doesn’t
    exist. And of course, if the directory already exists, it won’t get created again.
    This is a good safety measure that can prevent you from accidentally overwriting
    any existing files or directories. (I’ll show you a chart with more `test` operators
    in just a moment.)
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the second way to perform a test.
  prefs: []
  type: TYPE_NORMAL
- en: Enclosing a test Condition Within Square Brackets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second way to perform a test is to enclose the test condition within a
    pair of square brackets, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'First, note how you must have a blank space after the first bracket and before
    the second one. This tests for the existence of the `graphics` directory, just
    as the `test -d` construct did. Now, let’s put that into the `test_graphics_2.sh`
    script, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this script will give you the exact same output as the first script.
    Now, let’s put a twist on things. Modify the `test_graphics_2.sh` script so that
    it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `!` is a negation operator, which makes the affected operator do the opposite
    of what it’s supposed to do. In this case, the `!` causes the `-d` operator to
    check for the *absence* of the `graphics` directory. To make this work properly,
    I also had to change the `||` operator to the `&&` operator. (Also, note that
    there must be a blank space between the `!` and the `-d`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also test for numerical values, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You see that I’m calling up the value of the variable `var`, and testing to
    see if it is equal (`-eq`) to 0\. Instead of using a negation (`!`) here to see
    if the variable is *not* equal to 0, use the `-ne` operator. Let’s see how that
    looks in the `test_var.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The third way to perform a test is to use an `if. . .then` construct, which
    we’ll briefly talk about next.
  prefs: []
  type: TYPE_NORMAL
- en: Using an if. . .then Construct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using an `if. . .then` construct is handy when you have more complex test conditions.
    Here’s the most basic example, in the form of the `test_graphics_3.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This construct begins with the `if` statement, and ends with the `fi` statement.
    (That’s `if` spelled backwards.) Place a semi-colon after the test condition,
    followed by the keyword `then`. After that, specify the action that you want to
    perform, which in this case is `mkdir graphics`. Although indenting the action
    block isn’t necessary in shell scripting, as it is in other languages, it does
    help make the script more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there’s a lot more to `if. . .then` constructs than just this. Not
    to worry though, because I’ll show you more about them in the *Understanding Decisions
    and Loops* section. Before we get there though, I want to show you some more concepts
    that you can use to fancy up your `if. . .then` constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the various other types of tests that you can do.
  prefs: []
  type: TYPE_NORMAL
- en: Using Other Types of Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a lot more kinds of tests that you can do, including text string
    comparisons, numerical comparisons, whether files or directories exist and what
    permissions are set on them. Here’s a chart of the more popular tests, along with
    their operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Test** |'
  prefs: []
  type: TYPE_TB
- en: '| `-b filename` | True if a block device file with the specified filename exists.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-c filename` | True if a character device file with the specified filename
    exists. |'
  prefs: []
  type: TYPE_TB
- en: '| `-d directory_name` | True if a directory with the specified directory name
    exists. |'
  prefs: []
  type: TYPE_TB
- en: '| `-e filename` | True if any type of file with the specified filename exists.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-f filename` | True if a regular file with the specified filename exists.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-g filename` | True if a file or directory has the SGID permission set.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-G filename` | True if a file exists and is owned by the Effective Group
    ID |'
  prefs: []
  type: TYPE_TB
- en: '| `-h filename` | True if the file exists and it’s a symbolic link |'
  prefs: []
  type: TYPE_TB
- en: '| `-k filename` | True if the file or directory exists and has the sticky bit
    set |'
  prefs: []
  type: TYPE_TB
- en: '| `-L filename` | True if the file exists and it’s a symbolic link. (This is
    the same as `-h`.) |'
  prefs: []
  type: TYPE_TB
- en: '| `-p filename` | True if the file exists and it’s a named pipe |'
  prefs: []
  type: TYPE_TB
- en: '| `-O filename` | True if the file exists and it’s owned by the Effective UID
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-r filename` | True if the file exists and it’s readable |'
  prefs: []
  type: TYPE_TB
- en: '| `-S filename` | True if the file exists and it’s a socket |'
  prefs: []
  type: TYPE_TB
- en: '| `-s filename` | True if the file exists and it’s non-zero bytes in size |'
  prefs: []
  type: TYPE_TB
- en: '| `-u filename` | True if the file exists and it has the SUID bit set |'
  prefs: []
  type: TYPE_TB
- en: '| `-w filename` | True if the file exists and it’s writable |'
  prefs: []
  type: TYPE_TB
- en: '| `-x filename` | True if the file exists and it’s executable |'
  prefs: []
  type: TYPE_TB
- en: '| `file1 -nt file2` | True if file1 is newer than file2 |'
  prefs: []
  type: TYPE_TB
- en: '| `file1 -ot file2` | True if file1 is older than file2 |'
  prefs: []
  type: TYPE_TB
- en: '| `-z string` | True if the length of the text string is 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `-n string` | True if the length of the text string is not 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `string1 == string2` | True if the two text strings are identical |'
  prefs: []
  type: TYPE_TB
- en: '| `string1 != string2` | True if the two text strings are not identical |'
  prefs: []
  type: TYPE_TB
- en: '| `string1 < string2` | True if `string1` comes before `string2` in alphabetical
    order |'
  prefs: []
  type: TYPE_TB
- en: '| `string1 > string2` | True if `string1` comes after `string2` in alphabetical
    order |'
  prefs: []
  type: TYPE_TB
- en: '| `integer1 -eq integer2` | True if the two integers are equal |'
  prefs: []
  type: TYPE_TB
- en: '| `integer1 -ne integer2` | True if the two integers are not equal |'
  prefs: []
  type: TYPE_TB
- en: '| `integer1 -lt integer2` | True if `integer1` is less than `integer2` |'
  prefs: []
  type: TYPE_TB
- en: '| `integer1 -gt integer2` | True if `integer1` is greater than `integer2` |'
  prefs: []
  type: TYPE_TB
- en: '| `integer1 -le integer2` | True if `integer1` is less than or equal to `integer2`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `integer1 -ge integer2` | True if `integer1` is greater than or equal to
    `integer2` |'
  prefs: []
  type: TYPE_TB
- en: '| `-o optionname` | True if a shell option is enabled |'
  prefs: []
  type: TYPE_TB
- en: I know, that’s a lot of stuff, isn’t it? But, that’s okay. If you don’t want
    to memorize all of this, just keep this chart handy for ready reference.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let’s talk about subshells.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Subshells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you perform a test using the `[ $var -ne 0 ]` construct, the test will
    invoke a **subshell**. To prevent a test from invoking a subshell, use this construct,
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This can make your script run somewhat more efficiently, which might or might
    not be a huge deal for your particular script.
  prefs: []
  type: TYPE_NORMAL
- en: This `[[. . .]]` type of construct is also necessary when you perform tests
    that require matching a pattern to a regular expression. (Matching regular expressions
    won’t work within a `[. . .]` construct.)
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this `[[. . .]]` construct is that you can’t use it on certain
    non-`bash` shells, such as `dash`, `ash`, or `Bourne`. (You’ll see that in *Chapter
    19, Shell Script Portability*.)
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you don’t know what regular expressions are just yet, and that’s
    okay. I’ll show you all about them in *Chapter 9, Filtering Text with grep, sed,
    and Regular Expressions*.
  prefs: []
  type: TYPE_NORMAL
- en: At any rate, you can always try your scripts with subshells and without subshells,
    to see which works better for you.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now looked at all three methods to perform testing. So, how about a bit
    of practice with a hands-on lab?
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on Lab – Testing Conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this step, download the `tests-test.sh` script from the Github repository.
    (It’s a rather long script that I can’t reproduce here, due to book formatting
    considerations.) Open the script in your text editor, and examine how it’s constructed.
    The first thing you’ll see is that it’s checking for the existence of the `myfile.txt`
    file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, you’ll see the command to create the file if it doesn’t exist,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you’ll see the command to set `400` as the permissions setting, which
    means that the user has permission to read the file, and that nobody has permission
    to write to it. Then, we want to verify that all write permissions have been removed.
    Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After several more permissions settings manipulations and tests for them, you’ll
    see this stanza that tests for the existence of a directory, and creates it if
    it doesn’t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The final thing you’ll see is the stanza that tests for the `noclobber` option,
    sets it, and then tests for it again.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve finished reviewing the script, run it to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: For bonus points, retype the script into your own script file. Why? Well, a
    dirty little secret is that if you type code in yourself, it will help you better
    understand the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next step, create the `tests-test_2.sh` script with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Make the script file executable and then run it to view the results. Change
    the values of the `string1`, `string2`, `num1`, and `num2` variables and then
    run the script again and view the results.
  prefs: []
  type: TYPE_NORMAL
- en: End of lab.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a closer look at variables.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Scripting Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve already told you a bit about scripting variables, and you’ve already seen
    them in use. But, there’s a bit more to the story.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Deleting Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you’ve already seen, it’s sometimes either necessary or more convenient
    to define variables in your scripts. You can also define, view, and unset variables
    from the command-line. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, I’ve defined the variable `car`, and set its value to `Ford`. The first
    `echo` command shows the assigned value. The second `echo` command verifies that
    I’ve successfully cleared the variable with `unset`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Variables and Shell Levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you place a shebang line, such as `#!/bin/bash` or `#!/bin/sh`, at the
    start of your script, a new non-interactive child shell will be invoked every
    time you run the script. When the script finishes, the child shell terminates.
    The child shell inherits any variables that are exported from the parent shell.
    But, the parent shell won’t inherit any variables from the child shell. To demonstrate,
    let’s set the `car` variable to `Volkswagen` in the parent shell, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `car_demo.sh` script, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the file executable and then run the script. The output should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the `Volkswagen` value of car was inherited from the parent shell.
    That’s because I used the `export` command to make sure that this value would
    be available to the child shell that the script invokes. Let’s try this again,
    except this time, I won’t export the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: To make this work, I first had to unset the `car` variable. In addition to clearing
    out the value of `car`, it also cleared out the export. When I ran the script
    this time, it couldn’t find the value of `car` that I set in the parent shell.
  prefs: []
  type: TYPE_NORMAL
- en: So, why is this important? It’s just that you may, at times, find yourself writing
    scripts that will call another script, which will effectively open another child
    shell. If you want variables to be available to a child shell, you have to export
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Case Sensitivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variable names are case sensitive. So, a variable named `car` is completely
    different from variables named `Car` or `CAR`.
  prefs: []
  type: TYPE_NORMAL
- en: Environmental variables have names with all upper-case letters, and it’s best
    practice for programming variable names to be in either all lower-case letters
    or mixed-case letters. Amazingly, Linux and Unix shells don’t enforce that rule
    for programming variables. But, it is best practice, because it helps prevent
    you from accidentally overwriting the value of an important environmental variable.
  prefs: []
  type: TYPE_NORMAL
- en: Sad to say, there are shell scripting tutorials on the web in which the authors
    have you create programming variable names with all upper-case letters. In fact,
    I just came across one such tutorial. For the most part, the author has you create
    variables with names that don’t conflict with any environmental variables. In
    one spot though, the author has you create the `USER` variable and assign a value
    to it. Of course, `USER` is already the name of an environmental variable, so
    assigning a new value to it will overwrite what its value should be. The lesson
    here is that there are a lot of good tutorials on the web, but there are also
    a lot that give out wrong information.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Read-Only Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ve just seen that when you declare a variable in the normal way, you can
    either unset it or give it a new value. You can also make a variable read-only,
    which prevents the variable from being either redefined or unset. Here’s how that
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: With the read-only property set, the only way that I can either change or get
    rid of `car` is to close the terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: Well, this is the only way that you can get rid of a read-only variable if you
    don’t have root user privileges. If you do have root user privileges, you can
    use the **GNU bash Debugger** (`gbd`) to get rid of it. But, that’s beyond the
    scope of this chapter. (We’ll look at `gbd` in *Chapter 21, Debugging Shell Scripts*.)
  prefs: []
  type: TYPE_NORMAL
- en: Okay, this is all great if all you need is to define some individual variables.
    But, what if you need a whole list of variables? Well, this is where arrays come
    in handy. Let’s look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Array Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An array allows you to collect a list into one variable. The easy way to create
    an array variable is to assign a value to one of its indices, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, `name` is the name of the array, and `index` is the position of the item
    in the array. (Note that index must be a number.) `value` is the value that’s
    set for that individual item in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The numbering system for arrays begins with 0\. So, `name[0]` would be the
    first item in the array. To create an indexed array, use `declare` with the `-a`
    option, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s create the list that will be inserted into the array, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view the value of any individual item in the array, but there’s a special
    way to do it. Here’s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note how I had to surround the `myarray[x]` construct with a pair of curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the whole list of array items, use either a `*` or an `@` in place
    of the index number, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To just count the number of array items, insert a `#` in front of the array
    name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Okay, that covers the basics of arrays. Let’s do something a bit more practical
    with a hands-on lab.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on Lab – Using Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see how arrays are built, create the `ip.sh` script with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make the file executable and run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `/opt/scripts/` directory to store data files that your scripts
    will need to access, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `/opt/scripts/` directory, create the `banned.txt` file. (Note that
    in this directory, you’ll need to use `sudo` when opening your text editor.) Add
    to it the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your own home directory, create the `attackers.sh` script, which will build
    an array of banned IP addresses from a list in a text file. Add the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the executable permission and run the script, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Modify the script so that the elements 0, 5, and 8 are printed to screen, and
    rerun the script. (You’ve already seen how to do it.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End of Lab
  prefs: []
  type: TYPE_NORMAL
- en: 'A few words of explanation about this `attackers.sh` script are in order. First,
    in the second line, I’m using command substitution with the `cat` command to assign
    the contents of the `banned.txt` script to the `badips` variable. (I know, I keep
    showing you examples of command substitution, but I haven’t fully explained it
    yet. Don’t worry though, I’ll do that in a bit.) However, this still isn’t an
    array. I’ve created that separately in the `declare -a` line. In the `attackers=`
    line, I called back the value of the `badips` variable, which I then used to build
    the `attackers` array. Alternatively, I could have skipped using the intermediate
    variable and built the array directly from the `cat` command substitution, as
    I did in this `attackers_2.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Either way works, but this way is a bit more streamlined.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-life scenario, you could add code that will automatically invoke a
    firewall rule that will block all of the addresses in the `banned.txt` file. But,
    that requires using techniques that I haven’t yet shown you. So, we’ll just have
    to get that later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s expand some variables.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Variable Expansion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Variable expansion**, which is also called **parameter expansion**, allows
    the shell to test or modify values of a variable to be used in a script, using
    special modifiers enclosed in curly braces and preceded by a `$` (`${variable}`).
    If this variable is not set in `bash` it will be expanded to a null string. The
    best way to begin is to show you a few simple examples.'
  prefs: []
  type: TYPE_NORMAL
- en: Substituting a Value for an Unset Variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, I’ll define the `cat` variable with the name of my 16-year old gray
    kitty. Then, I’ll perform a test to see if `cat` really has a set value, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, I’ll unset the value of `cat`, and perform the test again. Watch what
    happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what happened? Well, the `-` between `cat` and `"This cat variable is not
    set."` tests to see whether or not the `cat` variable has an assigned value. If
    the variable has no assigned value, then the text string that comes after the
    `-` is substituted for the variable’s value. However, the substituted value is
    not actually *assigned* to the variable, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, assign a null value to `cat`, and try this again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we just get a blank line as output, because the `cat` variable is
    set. It’s just that it’s set to a null value. Let’s try this again, using `:-`
    instead of `-` , like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This works because placing a `:` in front of the `-` causes variables that have
    been set with a null value to be treated as unset variables.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, that does it for unset variables. Sometimes though, we might need to work
    with variables that do have set values, as you’ll see next.
  prefs: []
  type: TYPE_NORMAL
- en: Substituting a Value for a Set Variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can go the opposite way by substituting a value for a variable that *does*
    have an assigned value, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `+` construct causes the following text string to be substituted
    for the variable’s assigned value. Note that since there are no special characters
    in this text string that need to be escaped, the quotes are optional. However,
    best practice dictates using quotes anyway, just to be safe. Also note that this
    substitution did not change the actual assigned value of the `car` variable, as
    you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As you just saw with the `–` operator, the `+` operator treats variables with
    a null value as being set. If you want to treat variables with null values as
    unset, then use the `:+` operator. If you create a variable and leave it with
    a null value, it will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You see that with a null value, there’s no output from the `echo` command.
    Now, since I just happen to be using a Dell computer, let’s set the value of `computer`
    to `Dell`, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As I’ve already indicated, the operators that we’ve just looked at will substitute
    a value for a variable, depending upon whether the value has an assigned value.
    But, they won’t actually change the value of the variable. But, we might at times
    need to change a variable’s value, as we’ll see next.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a Value to a Variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This next trick actually will assign a value to an unset variable, using the
    `=` and `:=` operators. Let’s begin by assigning a value to the `town` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see if we can assign a different value to town:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'As you’ve seen before, using this operator without a preceding `:` causes a
    variable with a null value to be treated as a set variable. Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'To show how using the `:=` operator works, let’s create the `armadillo` variable
    with a null value, and then assign to it a default value, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Artie is the tentative name that I’ve given to the armadillo who’s recently
    begun visiting my back yard at night. But, I don’t yet know if the armadillo is
    a boy or a girl, so I don’t yet know if Artie is an appropriate name. If I find
    out that it’s a girl, I might want to change the name to Annie. So, let’s try
    the preceding exercise again, but with `armadillo` set to `Annie`. Then, we’ll
    see if we can use our variable expansion to change it to `Artie`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You see that since the `armadillo` variable already had the `Annie` assigned
    as its value, the `echo ${armadillo:=Artie}` command had no effect, other than
    to show the value that I had already assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what if you don’t want to substitute a variable’s value, but just want
    to see an error message? Let’s look at that.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying an Error Message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You won’t always want to perform either a value substitution or a value assignment
    for an unset variable. Sometimes, you might just want to see an error (`stderror`)
    message if the variable is unset. Do that with the `:?` construct, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try that again with a dog named Rastus, which was the name of an English
    Shepard that my Grandma had when I was a kid. It will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: I know, you’re thinking that this looks just like the first example, where I
    substituted a message for the value of the unset `cat` variable with a `-`. Well,
    you’re kind of right. It’s just that the `-` substitutes a value that shows up
    as `stdout`, while the `:?` substitutes a message that shows up as `stderr`. Another
    difference is that if you use `:?` in a shell script with an unset variable, it
    will cause the script to exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try that by creating the `ex.sh` script with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, I’ve been showing you how to use `echo` to both perform the variable
    expansion and show the results. This particular construct allows you to just test
    the variable without echoing the results, by using a `:` instead of `echo`. Now
    when I run this script, you’ll see that it exits before the final `echo` command
    can execute, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait a minute! Did I just call myself a big dummy? Oh, well. Anyway, let’s
    change the script so that `var` has an assigned value, as you see in this `ex_2.sh`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The script now runs to completion, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'So to reiterate, using the `:` in place of the `echo` prevents the `${var:?"var
    is unset, you big dummy"}` construct from printing out the value of the variable.
    We can change that behavior by changing the `:` back to an `echo`, as you see
    here in `ex_3.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see the results of that change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This time, the value of `var` does print out.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve just seen with the `-` and the `+` operators, preceding the `?` with
    a `:` causes the operator to treat a variable that was created with a null value
    as unset. Leaving out the `:` causes the operator to treat variables that were
    created with a null value as set.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s change gears by looking at variable offsets.
  prefs: []
  type: TYPE_NORMAL
- en: Using Variable Offsets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last type of variable expansion that I’ll show you involves the substitution
    of just a subset of a text string. This involves using a **variable offset**,
    and is a bit more difficult to understand unless you can see an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you set a variable it will have a set size, or number of characters. The
    `${variable:offset}` construct uses the offset, or number of characters from the
    specified location. So, if the offset is `4` it will omit the first four characters,
    and will only echo all of the characters after the fourth character. The addition
    of a length parameter with the `${variable:offset:length}` construct allows you
    to also determine how many characters that you want to use. To begin, let’s create
    the `text` variable with a value of `MailServer`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s say that we only want to see the text that comes after the fourth
    letter. Use an offset, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool, it works. Now, let’s say that we want to see just the first four letters.
    Use an offset and length, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This means that we’re starting after position `0`, and are viewing only the
    first four letters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also extract text from somewhere in the middle of the text string,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Here, I’m starting after the fourth character, and am extracting the next five
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For something a bit more practical, let’s set the `location` variable with
    the name of a US city and state, along with its associated zip code. (That’s *postal
    code* for anyone who isn’t here in the US.) Then, let’s say that we want to extract
    the zip code portion of the text string, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of setting the offset by counting from the beginning of the text string,
    I could also have used a negative number to just extract the last part of the
    text string. Since the zip code is five digits long, I could use a `-5`, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: To ensure that this always works properly, be sure to always leave a blank space
    between the `:` and the `-`. Also, since city names will always vary in length,
    this would be a better option if you need to extract zip codes from a whole list
    of locations.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for offsets. So now, let’s match some patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Matching Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next variable expansion trick involves matching patterns. Let’s start by
    creating the `pathname` variable, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s say that I want to strip the lowest level directory from this path.
    I’ll do that with a `%` and an `*`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The `%` tells the shell to omit the final part of the string that matches the
    pattern. In this case, the `*` at the end isn’t necessary, because `yum` just
    happens to be at the end of the `pathname`. So, you’ll get the same result without
    it. But, if you want to omit the lowest two levels of `pathname`, you will need
    to use the `*` so that the pattern will match properly. Here’s what I’m talking
    about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: You see that without the `*`, the pattern matching didn’t work. With the ***,
    the matching worked just fine. So, even when the `*` isn’t absolutely necessary,
    it’s best to include it, just to be sure.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, you might at times just want to extract the names of the
    lower level directories. To do that, just replace the `%` with a `#`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s wrap this section up with one final trick. This time, I’ll match a pattern
    and then substitute something else. First, I’ll create the string variable, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s good, except that I’ve decided that I don’t want blank spaces between
    the words. So, I’ll substitute an `_` character, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'That didn’t work out so well, because it only replaced the first blank space.
    To perform a global replacement, I’ll need to add an extra forward slash after
    `string`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: This looks much better. But, what’s really going on here? Well, we’re using
    a `/pattern_to_be_replaced/` construct to perform the substitution. Whatever you
    place between the two forward slashes is what you want to replace. You can specify
    an individual character, a character class, or some other pattern that you want
    to replace. At the end, between the last forward slash and the closing curly brace,
    place the character that you want to substitute.
  prefs: []
  type: TYPE_NORMAL
- en: There’s still a bit more to the variable expansion business, but I’ve shown
    you the most practical examples. If you want to see more, you’ll find a reference
    in the *Further Reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, now that we’ve substituted some patterns, let’s move on to substituting
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Command Substitution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Counting Logged-in Users* and *Using Arrays* Hands-on Labs, I’ve shown
    you some examples of **command substitution** in action, but I haven’t yet fully
    explained it. It’s about time that I do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Command substitution is an extremely handy tool that you will use extensively.
    I mean, really. You can do some very cool stuff with it. It involves taking the
    output from a shell command and either using it in another command, or assigning
    it as the value of some variable. You’ll place the command from which you’ll be
    taking output within a `$( )` construct. Here’s a very simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: You see how the output of the `uname -r` command, which shows the version of
    the current running Linux kernel, is substituted for the command substitution
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create the `command_subsitution_1.sh` script, and make it look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the breakdown. In the second line, I’m testing for the absence of the
    `Daily_Reports directory`. If it’s not there, then I’ll create it. In the fourth
    line, I’m using command substitution to create the `datestamp` variable with the
    current date as its assigned value. The current date is returned by the `date
    +%F` command, and will be in the year-month-day format (2023-10-03). In the final
    line, I’m echoing a message that contains today’s date into a file that contains
    today’s date in its filename. Here’s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Is that slick, or is that slick? Trust me, you’ll be doing this sort of thing
    a lot if you need to create scripts that will automatically generate reports.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: There are many different formatting options that you can use with the `date`
    command. To see them all, just view the `date` man page.
  prefs: []
  type: TYPE_NORMAL
- en: But, we’re missing an important element here. What if today’s report has already
    been created? Do you want to overwrite it?
  prefs: []
  type: TYPE_NORMAL
- en: 'No, in this case, I don’t. So, let’s create the `command_substitution_2.sh`
    script to test for the absence of today’s report before creating another one.
    It involves adding just a teeny bit of extra code, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: That last command that looks like three lines is really just one line that wraps
    around on the printed page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, prepare to be amazed at what happens when I run this new, modified script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Just for fun, let’s look at some other cool examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a script, which we’ll call `am_i_root_1.sh`, which will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The `whoami` command returns the name of the user who’s running the command.
    Here’s what that looks like when I run it first without `sudo`, and then with
    `sudo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, running `whoami` with `sudo` shows that I’m the root user. The
    first command uses the `!=` operator to test if the user is *not* the root user.
    The second command uses the `==` operator to test if the user *is* the root user.
    Now, let’s run the script to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'It works, which means that we have achieved coolness. But, we can be even more
    cool by streamlining things a bit. Modify the script so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Instead of two commands in this script, I now have only one. But either way,
    the output is identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of placing your command within a `$( )` construct, you can also surround
    it with a pair of backticks, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: That works, but it’s a deprecated method that I don’t recommend. The biggest
    problem with it is that if your command contains any special characters that the
    shell might interpret incorrectly, you’ll have to be sure to escape them with
    a backslash. With the newer `$( )` construct, you don’t have to worry so much
    about that. I’m only mentioning this method because you might still see other
    people’s scripts that use it.
  prefs: []
  type: TYPE_NORMAL
- en: That does it for the command substitution business. Now, we need to make some
    decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Decisions and Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, I’ve been showing you a lot of programming techniques and constructs
    that are specific to shell scripting. In this section, I’ll show you some constructs
    that are common to most all programming languages. I’ll begin by showing you another
    way to make decisions.
  prefs: []
  type: TYPE_NORMAL
- en: The if. .then Construct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although the `&&` and `||` decision constructs work for simple scripts, you
    might want to use `if . . then` constructs for anything more complex, such as
    when you would need to test for multiple conditions at once. For the first example,
    create the `am_i_root_2.sh` script, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Note that each decision stanza begins with `if` and ends with `fi`. (Yes, that’s
    `if` spelled backwards.) Also note that with `bash` shell scripting, indentation
    isn’t required, as it is in certain other programming languages. But, it does
    make the code much more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using the `whoami` command this time, I’m using the `id` command,
    which offers more options than `whoami`. (See the man pages for both commands
    for details.) As far as the rest of it goes, rather than trying to explain it
    all in detail, I’ll just let you study this script to see how everything works.
    That will be easier for me, and less boring for you. And besides, I have faith
    in you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see what happens when I run this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'When you’re testing for more than one condition for the same decision, it would
    be more proper to use one `if .. then .. elif` construct, rather than two `if
    .. then` constructs. This can add a bit more clarity to your code, so that anyone
    who reads it can make a bit more sense of it. Let’s create the `am_i_root_3.sh`
    script to showcase this technique. Make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The `elif` keyword in this script is short for `else if`. Other than that, everything
    is pretty much the same as it was before in the previous script. When you run
    it, you’ll get the same output as you got for the previous script. Also, note
    that you can test for multiple conditions with more than one `elif` stanza.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you could also use an `if .. then .. else` construct. Create
    the `am_i_root_4.sh` script, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `else` can be handy, because it defines a default action to take if the
    conditions in any of the `if` or `elif` stanzas aren’t fulfilled. For example,
    take a look at this script that detects which operating system your machine is
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: You see that this script can detect Linux, macOS, or FreeBSD. If the machine
    isn’t running any of those three operating systems, the `else` statement at the
    end displays the default message. Another thing to note is that you’ll need to
    place a semi-colon and a `then` keyword at the end of each `if` or `elif` statement,
    but you don’t need to place them after an `else` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how that looks when I run the script on an OpenIndiana machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if I wanted to, I could insert another `elif` stanza to test for
    SunOS.
  prefs: []
  type: TYPE_NORMAL
- en: That about covers it for `if. .then`. Let’s now do something while waiting for
    something else.
  prefs: []
  type: TYPE_NORMAL
- en: The do. . while construct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This construct will continuously execute a set of commands while a certain
    condition is true. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This `while_demo.sh` script starts by assigning a value of `10` to the `x`
    variable. As long as the value of `x` remains greater than `0`, it will subtract
    `1` from this value and assign the new value to `x`, using the `expr $x-1` command.
    It then echos the new value. The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in this `while_demo.sh` script, you can use a bit of shorthand for
    decrementing the value of `x` by 1 for each loop. Just replace the `x=$(expr $x
    - 1)` line with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This is the same type of construct that you might be used to seeing in C or
    C++ language programs. However, this construct is not portable, which means that
    it works fine on `bash`, but not on other shells. So, if you need to make your
    script so that it will run on Bourne shell, `dash`, or `ash`, you’ll need to avoid
    this construct and instead stick with the `x=$(expr $x - 1)` construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also use a `while` loop to read a text file, line-by-line. Here’s
    the very simple `read_file.sh` script that reads the `/etc/passwd` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: As you see, I start by creating the `file` variable with `/etc/passwd` as its
    assigned value. The `while` line defines the variable line, and the `read -r`
    command assigns values to the line variable. On each pass of the while loop, the
    `read -r` command reads one line of the file, assigns the contents of the line
    to the `line` variable, and then echos the contents of the line to `stdout`. When
    all lines of the file have been read, the loop terminates. At the end, you see
    that I’m using a `stdin` redirector to make the `while` loop read the file. Normally,
    `read` breaks long lines into shorter lines and terminates each part of the long
    line with a backslash. The `-r` option disables that behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be times when you’ll want to create an infinite loop that never stops
    until you tell it to. (There might also be times when you’ll create an infinite
    loop by accident, but that’s a whole different story. For now, let’s assume that
    you want to do it on purpose.) To demonstrate, create the `infinite_loop.sh` script,
    and make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s a rather useless script, which does nothing but echo some messages. The
    `sleep 1` command causes a one-second delay between each iteration of the loop.
    Here’s what happens when I run this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: There are still a few other tricks that we can do with `while..do`, but this
    will do it for now. Let’s now look at `for..in`.
  prefs: []
  type: TYPE_NORMAL
- en: The for..in Construct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for . . in` construct will process a list, and perform a command for each
    item in the list. In this `car_demo_2.sh` script, the `for` line creates the `cars`
    variable. Here’s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time that the loop iterates, the `in` keyword takes a name of a classic
    car from the list, and assigns it to `cars` as its value. The loop ends when it
    reaches the end of the list. Here’s what happens when I run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s easy enough, so let’s try another one. This time, create the `list_demo.sh`
    script, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'This loop just does an `ls`-style listing of the files in your current directory.
    I’m using the `*` wildcard to tell `for` to read in all of the filenames, regardless
    of how many files there are. In the `echo` line, I have to surround `$filename`
    with a pair of double quotes in case any filenames contain blank spaces. Here’s
    what happens when I run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The reason this works is that if you do `echo *` from the command-line, you’ll
    see a jumbled-up listing of files in the directory. The `for..in` loop causes
    `echo` to list each filename on its own line.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we’ve just looked at `for..in`. Let’s now look at `for`.
  prefs: []
  type: TYPE_NORMAL
- en: The for Construct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is similar to the `for . . in` construct, except for where it gets its
    list. With `for`, the user will enter the list as arguments when calling the script.
    Let’s create the `car_demo_3.sh` script to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cars` variable gets created in the `for` line, but there’s no list of
    cars. So, where does the list come from? It comes from arguments that the user
    enters on the command-line when he or she invokes the script. Instead of using
    classic car names this time, let’s use a list of modern car names, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s look at the `break` command.
  prefs: []
  type: TYPE_NORMAL
- en: Using break
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `break` command to further control how you want `for..in` and `while..do`
    loops to operate. To see how this works, create the `break_demo.sh` script and
    make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The `while` line tells the script to run as long as the value of `j` is less
    than `5`. The `j=$((j + 1))` construct on the sixth line is a mathematical operator,
    with increments the value of `j` by `1` on each iteration of the loop. The `if..then`
    construct that starts on the seventh line defines what should happen when the
    value of `j` is equal to `2`. The `break` command then terminates the loop. Here’s
    how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'As I’ve indicated for the `while_demo.sh` script, you can replace the `j=$((j
    + 1))` construct with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: However, `((j++))` is `bash`-specific, and might not work on other non-`bash`
    shells.
  prefs: []
  type: TYPE_NORMAL
- en: You can also express this as `j=$(expr j + 1)`, which is also portable, and
    is the form that I showed you in the `while_demo.sh` script.
  prefs: []
  type: TYPE_NORMAL
- en: (I’ll show you more about performing math in shell scripts in *Chapter 11, Performing
    Mathematical Operations*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for fun, delete the `break` command from the script and run it again.
    You should now see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: This time, the loop keeps running past the number `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken a break, let’s continue.
  prefs: []
  type: TYPE_NORMAL
- en: Using continue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `continue` command also modifies how `for..in` and `while..do` loops operate.
    This time, create the `for_continue.sh` script, and make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'On each iteration of the `for` loop, a different classic car name gets assigned
    as the value of `cars`. The `if..then` stanza determines if the value of `cars`
    is either `Buick` or `Mercury`. The `continue` command within the `if..then` stanza
    causes the loop to skip over those two car names, so that the `echo` command won’t
    list them. You also see another use for the `||` construct here. When used within
    a test operation, the `||` acts as an `or` operator. Here’s what the output looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s try this with a `while..do` loop. Create the `while_continue.sh`
    script, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we just want to skip over numbers 3 and 6\. Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Okay, enough of that. Let’s look at the `until` construct.
  prefs: []
  type: TYPE_NORMAL
- en: The until Construct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `until` loop will continue until a certain condition is met. You can use
    it for a variety of things, such as playing a guessing game. See how it works
    by creating the `secret_word.sh` script, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'So, I’ve set the `secretword` to `Donnie`. (Hey, that’s me!) I then set `word`
    to a null value. The `until` loop will run until I enter the correct value for
    `secretword`. (In this case, `read` pauses the script until you enter your guess.)
    It works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Cool, right? I mean, this is yet another trick that you can perform at your
    next party.
  prefs: []
  type: TYPE_NORMAL
- en: All right, let’s move on to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: The case Construct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `case` construct provides a way to avoid using an `if..then..else` construct.
    It allows users to enter a text string, then evaluate that string and provide
    the option that the string indicates. Here’s the basic structure of case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The `case` statement is matched against a number of values until a match is
    found. When a match is found, the commands are executed until the double semicolons
    (`;;`) are reached. Then, the commands after the `esac` line are executed.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no match, then the commands between the `*)` and the double semicolons
    are executed. The `*)` acts the same way as the `else` in an `if ...then` construct,
    in that they both provide a default action in case none of the tested conditions
    are met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for fun, try this out by creating the `term_color.sh` script, which will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'This script allows you to change the background color of your terminal. (And
    yes, I know that I’ve set the `g` option to `white`. That’s because when you run
    this script and choose the `g` option, the background will look more gray than
    white.) Running the script looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Run the script in your own terminal, choose the `g` option, and you should see
    the background of the command prompt turn gray. (Or, if your terminal is already
    set up with a white background, choose the `b` option, instead.) To see the background
    for the whole terminal turn gray, just type `clear`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For even more fun, edit the script to add another option. First, make the `echo`
    line at the top look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the `y` option after the `g` option. This new option will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'To see something that’s hideously ugly, run the script again and choose the
    `y` option. (Don’t worry though, because the setting isn’t permanent.) Here’s
    how using the various options will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21693_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Running the term_color.sh script'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, you’ve already seen how to use `for` to enter arguments when you invoke
    your scripts. Now, let’s look at another way.
  prefs: []
  type: TYPE_NORMAL
- en: Using Positional Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you run a shell script, you can also enter command-line parameters that
    will be used within the script. The first parameter that you enter will be designated
    as `$1`, the second will be designated as `$2`, and so on. (`$9` is as high as
    you can go.) The `$0` parameter is reserved for the name of the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, create the `position_demo.sh` script, which will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'To invoke the script, enter three names after the name of the script, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: In the output, the `$1`, `$2`, and `$3` variables will be expanded to the names
    that I entered on the command-line. The `$0` variable will be expanded to the
    full path and name of the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three special positional parameters that you can use to enhance your
    scripts. Here’s the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$#`: This shows the number of parameters that you’ve entered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$@`: This lists all of the parameters that you’ve entered, with each one on
    a separate line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$*`: This lists all of the parameters that you’ve entered on a single line,
    with a blank space between each one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One cool thing that you can do with the `$#` parameter is error-checking. To
    see what I mean, run the `position_demo.sh` script again, but only enter one name
    as an argument. You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, it gave me no warning about the fact that I didn’t list the correct
    number of names. Let’s modify things a bit to take care of that. Create the `position_demo_2.sh`
    script, and make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this script with all three names, and you’ll get the same output that you
    got with the first script. Then, run it again with only one name, and you should
    see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: That looks much better.
  prefs: []
  type: TYPE_NORMAL
- en: 'To introduce our next trick, take a look at the output of the `date` command,
    without specifying any formatting options, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'You see seven fields in the output, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: Day of week
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AM or PM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timezone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, create the `position_demo_3.sh` script, which will treat each field of
    the date output as a positional parameter. Make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'On the second line, you see another use for the `set` command that you haven’t
    yet seen. The first time you saw `set`, it was with the `-o` option to set shell
    options. This time, I’m using it without any options and with `$(date)` as an
    argument. Here’s what the `bash` man page says about using `set` in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: Without options, display the name and value of each shell variable in a format
    that can be reused as input for setting or resetting the currently-set variables.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this case, `set` is taking the output of `$(date)` and formatting it in a
    way that allows the individual fields to be used as positional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the third line, you see where the real magic happens. The `$*` positional
    parameter lists all fields of `$(date)` on a single line. The rest of the `echo`
    commands just output a text string, followed by the value of the specified field
    or fields. Here’s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: It works as it should, and looks pretty cool. Add this to the list of tricks
    to try at your next party.
  prefs: []
  type: TYPE_NORMAL
- en: I think that that about covers it for positional parameters. Let’s now look
    at exit codes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Exit Codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve already seen some examples of using the `exit` command, which can either
    terminate a script normally or cause it to terminate early upon an error condition.
    What I haven’t explained yet, is about **exit codes**. There are two general classes
    of exit codes, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Standard shell exit codes**: Each shell has its own defined set of exit codes.
    (To keep things simple, I’ll just talk about `bash` exit codes in this chapter.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-defined exit codes**: You can also define your own exit codes for different
    purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s talk about standard exit codes first.
  prefs: []
  type: TYPE_NORMAL
- en: Standard Shell Exit Codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a program or script runs successfully, it returns an exit code of `0`.
    Otherwise, the exit code will be a non-`0` number from `1` to `255`. To demonstrate,
    use `find` to search through the `/etc/` directory for the `passwd` file, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'You see that `find` found the file, but we also have a lot of `Permission denied`
    errors due to the fact that there are directories that I can’t enter with my normal
    user privileges. Now, verify the exit code, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The `?` is a special variable that returns the exit code for the previous command
    that was just run. In this case, the exit code is `1`, which tells me that there
    was some kind of error condition. The specific error was that `find` couldn’t
    enter certain directories to perform its search. So, let’s try this again with
    `sudo`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: This time I get exit code `0`, which means that there were no error conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, you’ll see either `0` or `1` as the exit code. The complete
    list of codes that you might see include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1` General errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` Misuse of shell builtins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`126` Cannot invoke requested command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`127` Command not found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`128` Invalid argument to `exit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`128+n` Fatal error signal `n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`130` Script terminated by *Ctrl-c*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s possible to demonstrate some of the other codes. Start by creating the
    `exit.sh` script, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Right away, you can see the error. The `exit` command requires a numerical
    argument, and won’t work with an alphabetical argument. But, we’re going to pretend
    that we don’t see the error, and try to run it anyway. Here’s what you’ll get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: The `2` exit code indicates that I misused a **shell builtin**.
  prefs: []
  type: TYPE_NORMAL
- en: A **shell builtin** is just a command that doesn’t have its own executable program
    file, because it’s built into the `bash` executable program file. One would think
    that I would get a `128` code, since I provided an invalid argument to `exit`,
    but that’s not how it works. (In fact, I’m really not sure what I would have to
    do to get a `128` code. But, that’s okay.) To see the complete list of shell builtins,
    just view the `builtins` man page.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `126` code normally means that you don’t have permission to run a command.
    For example, let’s say that I forgot to set the executable permission on a script,
    as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Watch what happens when I try to run this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'You can generate a `127` code by trying to execute a command that doesn’t exist,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, my name is not a command.
  prefs: []
  type: TYPE_NORMAL
- en: The `128+n` code means that some sort of fatal error condition occurred. The
    `n` signifies another digit that’s added to `128`. For example, if you start a
    command and *Ctrl-c* out of it before it completes, you’ll get a code of `128+2`,
    which equals `130`. (The `2` in this case indicates the specific fatal condition.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use standard exit codes within a shell script to make it handle different
    conditions. To see that, create the `netchk.sh` script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: This script expects you to invoke it with a hostname, domain name, or an IP
    address as an argument. In the first `if..then` construct at the top, you see
    that if you don’t enter an argument, the script will default to using `google.com`
    as the argument. \
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, it will use the argument that you specified. It will then try to
    ping the specified site. If the ping is successful, the exit code will be `0`.
    Otherwise, it will be something other than `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second `if..then` construct, you see that if the exit code is not `0`,
    it will echo a `Network Failure` message and send an entry to the system log file,
    which on the Fedora machine is `/var/log/messages`. Otherwise, it will echo a
    `Success` message. Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: There’s not much else to say about the standard exit codes. So, let’s say a
    few words about user-defined exit codes.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined Exit Codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can specify your own exit codes simply by specifying a numerical argument
    for `exit`. This is handy for whenever you might need to pass some specific exit
    code to an external program. The Nagios network monitoring tool is a great example.
  prefs: []
  type: TYPE_NORMAL
- en: Nagios is a tool that can monitor pretty much every type of device on your network.
    It can monitor various types of servers, workstations, routers, switches, and
    even printers. What makes it so cool is that it’s modular, which means that it
    works with plug-ins. If you need to monitor a particular device and find that
    there’s no plug-in that will do the job, you can just write your own. You can
    write plug-ins in a variety of programming languages, which includes shell scripting.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install a Nagios monitoring agent on a server or workstation that you
    want to monitor, and create a shell script that generates exit codes that Nagios
    expects to see. To understand how it works, check out this code snippet from a
    larger script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: This script is looking at the `/etc/passwd` file to see if there is more than
    one user with a UID of `0`. That’s important, because UID 0 is what gives a user
    account root user powers. So, on any Linux system, you never want to see more
    than one user account with UID 0\. In the `if..then` construct, you see that if
    the script finds more than one UID 0 account, it will generate an exit code of
    `2`. Otherwise, it will generate an exit code of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: This exit code and its corresponding `echo` command get passed to the Nagios
    monitoring agent. The monitoring agent will then pass the output from the `echo`
    command to the Nagios server, which will display the message on the Nagios dashboard.
    (You’ll see the entire script in just a few moments, when you get to the *Looking
    at Some Real-World Examples* section.)
  prefs: []
  type: TYPE_NORMAL
- en: That’s about it for exit codes. Let’s now take a closer look at `echo`.
  prefs: []
  type: TYPE_NORMAL
- en: More Information About echo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve already seen the most simple way to use `echo`, which is to either display
    a message on the screen or send text into a text file. What you haven’t seen yet
    is `echo`'s various formatting options.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use it with the `-n` switch, you’ll prevent it from creating a new line
    at the end of the text output, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Use it with the `-e` switch, and you’ll be able to use some backslash options.
    For example, to insert a vertical tab into a line of text, use the `-e` switch
    with the `\v` option, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'To insert a horizontal tab, use the `\t` option, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to insert a backslash into the text, just use two consecutive backslashes,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'You’re not limited to just echoing text messages. You can also use a wildcard
    character to show a list of files that you have in the current directory, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also echo a message along with the file list, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: With a bit of imagination, you’ll be able to use these `echo` formatting options
    to enhance the appearance of your screen output and text documents.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, as cool as these formatting options for `echo` are, they don’t work well
    on certain non-`bash` shells, such as `dash`. In *Chapter 19—Shell Script Portability*,
    I’ll show you how to fix that by using `printf` instead of `echo`.
  prefs: []
  type: TYPE_NORMAL
- en: That’s about it for `echo`. Let’s move on to the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at Some Real-World Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I’ll show you some practical, real-life things that you can
    do with some of the techniques that we’ve covered so far. Actually, rather than
    just showing you, I’ll let you get your hands dirty with some cool hands-on labs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hands-on Lab: Using if..then'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is absolutely a real-life example. Several years ago, I created this script
    as a plug-in for the Nagios network monitoring system. The scenario was that we
    wanted to make sure that malicious hackers haven’t added a rogue `UID 0` account
    to the `/etc/passwd` file on Linux and FreeBSD machines. That’s because any account
    with a UID setting of `0` in the `passwd` file has full root privileges, and we
    don’t want any unauthorized accounts to have root privileges.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that on Linux machines there’s only supposed to be one user account
    with `UID 0`, and on FreeBSD there are two accounts with `UID 0`. (One `UID 0`
    account is named `toor`, which has `bash` set as the default shell. The other
    `UID 0` account is `root`, which has `csh` set as the default shell.) So, we needed
    a script that will work on both operating systems. (Note that you’ll be altering
    the `passwd` file for this lab, so you’ll want to do this on a virtual machine,
    and not on a real production machine.)
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `exit 1` and `exit 2` status codes that you’ll see are what Nagios
    expects to see to indicate either `OKAY` or `CRITICAL`. Also note that you can
    add more `elif` stanzas if you want to check other UNIX or UNIX-like operating
    systems. (In fact, you’ll see that I’ve just now added code to check macOS and
    OpenIndiana.) With the introduction out of the way, let’s get to the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the script is too long to reproduce in the book. So, go to the
    Github repository and download the `UID-0_check.sh` script. Transfer it to a Linux
    virtual machine. Open the script in your text editor, and examine the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the script to see the results. You should see this message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**WARNING: Again I say, do this on a virtual machine, not on your production
    workstation.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On a Linux virtual machine, create another user account, using the appropriate
    user-creation command for your Linux distro. Open the `/etc/passwd` file in your
    text editor, and change the UID number for the new user to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This UID field is the third field in each line of the passwd file. For example,
    you see here that Vicky’s UID is 1001:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing her UID to `0` will make the line look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and run the script again. You should now see a message that looks
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete the new user account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a FreeBSD virtual machine and install `sudo` and `bash` as I showed you
    in the *Preface* chapter. Transfer the `UID-0_check.sh` script to it, and repeat
    Steps 3 through 5\. This time, you should see that `2 accounts` are `OKAY`, and
    that `3 accounts` are `CRITICAL`. This will give you a chance to see how the `elif
    [ $os == FreeBSD ]; then` stanza at the bottom of the script can correctly detect
    which operating system you’re running, so that it can run the correct code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End of lab
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on Lab – Parsing an Apache Access Log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lab, I’ll show you how much power a one-command shell script can have.
    Building up that one command can be a bit tricky though, so I’ll show you how
    to build it one step at a time, ensuring that each step works properly before
    continuing to the next step. If you’re ready, let’s dig in.
  prefs: []
  type: TYPE_NORMAL
- en: Set up a Fedora Server virtual machine with Bridged networking. (You’ll need
    Bridged networking so that you can access the machine from other machines on your
    network.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install and activate the Apache webserver, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open Port 80 on the virtual machine’s firewall, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From as many other machines on your network as possible, open a web browser
    and navigate to the virtual machine’s IP address. The URL that you enter should
    look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that you can access this from either physical machines or other virtual
    machines that are on the same network. Also, note that there’s no need to set
    up your own web page, because the default *Fedora Webserver Test Page* will work
    fine for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'View the Apache access log, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note how each line begins with the IP address of each machine that accessed
    this website. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'You see that the source IP address is in the first field, and that the fields
    are separated by blank spaces. So, one way that we can see just the list of source
    IP addresses is to use `cut`, and to specify a blank space as the delimiter to
    view just the first field. The command and its output would look something like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With only one exception, you see the list of IPv4 addresses of the machines
    that accessed this server. The one exception is the IPv6 address at the top of
    the list, which is the `localhost` address of the Fedora Server machine. (You
    likely won’t see this IPv6 address, unless you access the page from within the
    virtual machine itself.)
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good. You’ve successfully isolated the first field. Let’s now add
    the second part, which will sort the output so that the `uniq` filter will work
    properly in the next step. Here’s what that looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By using `sort` without the `-n` option, the list doesn’t get sorted in proper
    numerical order. But for this step, that doesn’t matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to eliminate duplicate IP addresses from the output, and to
    also count how many there are of each in the source file. Here’s how that looks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll now do a reverse numerical sort on the number of times that each IP address
    occurs, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that you know that the command works properly, create the `ipaddress_count.sh`
    script, and make it look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Be aware that you’ll need to use `sudo` to run this script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s fancy things up a bit. Add some code to save the results to
    a text file with a timestamp in its filename. It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Of course, there are other available programs that do a more comprehensive job
    of parsing your webserver log files. But, this script is handy for a quick analysis
    of who is accessing your server.
  prefs: []
  type: TYPE_NORMAL
- en: End of lab
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the final lab.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on Lab – Beta Testing a Hard Drive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final example involves an experience that I had quite a few years ago. That’s
    when the good folk at Western Digital invited me to participate in a beta test
    of a new model hard drive. All I really had to do was to keep the drive running
    for the whole four-month test period, and then collect log data from the drive’s
    BIOS at the end of the test period. But, I went a bit beyond that by writing a
    shell script that automatically collected drive performance data on a daily basis.
    As before, do this on your Fedora Server virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To collect drive performance data, you’ll need to install a couple of packages,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the `sysstat` service and ensure that it’s active, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll use the `sar` component of the `sysstat` package to collect your data.
    But, it will be a few minutes before any `sar` data become available. While you’re
    waiting, generate some hard drive activity by doing a system update, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: View the `sar` man page and take note of the different types of data that can
    be collected with the various `sar` option switches. You’ll be seeing several
    of those options in the shell script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is another one of those scripts that’s too large to reproduce in the book.
    So, download the `hard_drive.sh` script from the Github repository. Open it in
    your text editor and study it. I’ve covered all of the concepts that I’ve used
    in this script, so you should be able to figure out what it’s doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last command in the script is a `smartctl` command, which requires `sudo`
    privileges. So, you’ll need to use `sudo` to run the script, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Be patient, because this takes a few minutes to run. Also, be aware that the
    virtual drive of your virtual machine isn’t `smartmontools`-aware, which means
    that you’ll see some warning messages in your report.
  prefs: []
  type: TYPE_NORMAL
- en: When the script has finished running, look at the generated report in the `Drive_Reports`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feel free to run this script on your Linux host machine. It should run on most
    any Linux distro, as long as you have the `sysstat` and `smartmontools` packages
    installed, and the `sysstat` service is running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End of Lab
  prefs: []
  type: TYPE_NORMAL
- en: All right, that wraps it up for this chapter. Let’s summarize and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered an incredible amount of ground in this chapter, and I hope that I
    haven’t overwhelmed you. What I wanted to do was to provide you with a comprehensive
    overview of the concepts and techniques that you would use to build a usable shell
    script. We started with some techniques that are unique to shell scripting, and
    followed up with techniques that are common to most all programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: And really, that’s one of the coolest things about learning shell scripting.
    It’s much easier to learn than higher-level languages such as C, Java, or Rust,
    but it’s still extremely useful. And, as you learn shell scripting, you also learn
    about the constructs and concepts that also apply to the higher-level languages.
    So, if you ever plan to learn another programming language, learning shell scripting
    first can help you prepare for it.
  prefs: []
  type: TYPE_NORMAL
- en: But, even with all that we’ve covered, we’re not done yet. In the next chapter,
    I’ll present a few more ways to filter and manipulate text. I’ll see you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following snippets represents the *most preferred* way to perform
    command substitution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`` `command` ``'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`%(command)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`"command"`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$(command)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to create an array of names. How would you do that?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`set array=names`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`array=names`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`array names`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`declare names`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`declare -a names`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: How would you view the exit code of a command that you just ran?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`echo $#`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`echo $?`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`echo $$`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`echo $!`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You want to create a loop that will read a list of names, and then echo the
    names into another text file. But, you want to skip two of the names. Which of
    the following commands would make your script do that?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`break`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`skip`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`continue`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`stop`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You want to compare two numerical values to see if they’re equal. which of the
    following operators would you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`=`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-eq`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`==`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-ne`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is the Bash Shebang and How to Use It: [https://www.rosehosting.com/blog/what-is-the-bash-shebang/](https://www.rosehosting.com/blog/what-is-the-bash-shebang/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An Introduction to Parameter Expansion in bash: [https://opensource.com/article/17/6/bash-parameter-expansion](https://opensource.com/article/17/6/bash-parameter-expansion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Shell Parameter Expansion (Bash Reference Manual): [https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html](https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Introduction to if: [https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bash while Loop: [https://linuxize.com/post/bash-while-loop/](https://linuxize.com/post/bash-while-loop/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Find Most Used Disk Space Directories and Files in Linux: [https://www.tecmint.com/find-top-large-directories-and-files-sizes-in-linux/](https://www.tecmint.com/find-top-large-directories-and-files-sizes-in-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Standard Exit Status Codes in Linux: [https://www.baeldung.com/linux/status-codes](https://www.baeldung.com/linux/status-codes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Use the sar Command on Linux: [https://www.howtogeek.com/793513/how-to-use-the-sar-command-on-linux/](https://www.howtogeek.com/793513/how-to-use-the-sar-command-on-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: e
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Linux experts, and the author himself.
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10596186092701843.png)'
  prefs: []
  type: TYPE_IMG
