- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Sharing and Transferring Files
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享和传输文件
- en: In the previous chapter, we looked at what’s involved in the process of setting
    up a few network services, such as DHCP and DNS. Those are two important components
    of a network, but there are quite a few different types of applications and resources
    you can make available on your network to further enhance it. A file server is
    one such example, which can give your users a central place to store critical
    files and can even enhance collaboration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们看到了设置一些网络服务（如DHCP和DNS）涉及的过程。这些是网络的两个重要组成部分，但你可以在你的网络上提供许多不同类型的应用程序和资源，以进一步增强它。文件服务器就是其中的一个例子，它可以为用户提供一个集中存储关键文件的地方，甚至可以增强协作。
- en: 'Perhaps you’ve used a file server before, or even set one up on a different
    platform. With Ubuntu Server, there are multiple methods to not only store files,
    but also to transfer files from one node to another over a network link. In this
    chapter, we’ll look into setting up a central file server using both Samba and
    NFS, as well as how to transfer files between nodes with utilities such as `scp`
    and `rsync`. We’ll also go over some situations in which one solution may work
    better for you than another. As we go through these concepts, we will cover the
    following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你之前使用过文件服务器，甚至在不同平台上设置过文件服务器。在Ubuntu服务器上，不仅有多种存储文件的方法，还可以通过网络链路将文件从一个节点传输到另一个节点。在本章中，我们将探讨如何使用Samba和NFS设置中央文件服务器，以及如何使用`scp`和`rsync`等工具在节点之间传输文件。我们还将讨论一些情况，在这些情况下，一种解决方案可能比另一种更适合你。在讨论这些概念时，我们将涵盖以下主题：
- en: File server considerations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件服务器考虑因素
- en: Sharing files with Windows users via Samba
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Samba与Windows用户共享文件
- en: Setting up NFS shares
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置NFS共享
- en: Transferring files with `rsync`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`rsync`传输文件
- en: Transferring files with `scp`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`scp`传输文件
- en: Before we can get started with configuring our server to enable it to share
    files with other users, we should first understand what our available options
    are to enable us to choose the best technology for our use case.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始配置服务器以使其能够与其他用户共享文件之前，我们首先应该了解一下我们可以选择的可用选项，以便为我们的用例选择最佳技术。
- en: File server considerations
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件服务器考虑因素
- en: When it comes to setting up a file server, the process is a matter of setting
    up some sort of daemon to accept connections and share specific directories, and
    ensure the appropriate users are able to access those directories. You’ll also
    implement permissions to determine who can access specific directories, and what
    type of access they will have (read/write, read-only, and so on). When deciding
    *how* to share the files, it’s generally a choice between two common technologies
    that can facilitate the actual sharing, **Samba** and **NFS**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置文件服务器方面，过程是设置某种守护程序以接受连接并共享特定目录，并确保适当的用户能够访问这些目录。您还将实施权限以确定谁可以访问特定目录，以及他们将拥有的访问类型（读/写、只读等）。在决定如何共享文件时，通常是在两种常见技术之间进行选择，即**Samba**和**NFS**。
- en: All in all, there’s nothing stopping you from hosting both Samba and NFS shares
    on a single server. The two technologies can actually co-exist on the same device.
    However, each of the two popular solutions is more appropriate for particular
    use cases. Before we get started with setting up our file server, we should first
    understand the differences between Samba and NFS, so we can make an informed decision
    as to which one is more appropriate for our environment. As a general rule of
    thumb, Samba is great for mixed environments (where you have Windows as well as
    Linux clients), and NFS is more appropriate for use in Linux or Unix environments,
    but there’s a bit more to it than that.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，没有什么可以阻止您在单个服务器上托管Samba和NFS共享。这两种技术实际上可以在同一设备上共存。然而，这两种流行的解决方案各自更适合特定的用例。在开始设置文件服务器之前，我们应该先了解Samba和NFS之间的区别，以便能够就我们的环境选择更合适的一个。作为一个经验法则，Samba非常适合混合环境（其中既有Windows客户端也有Linux客户端），而NFS更适合在Linux或Unix环境中使用，但实际情况比这复杂得多。
- en: Samba is a great solution for many environments, because it allows you to share
    files with Windows, Linux, and macOS machines. Basically, pretty much everyone
    will be able to access your shares, provided you give them permission to do so.
    The reason this works is because Samba is a re-implementation of the **Server
    Message Block** (**SMB**) protocol, which is primarily used by Windows systems.
    However, you don’t need to use the Windows platform in order to be able to access
    Samba shares, since many platforms offer support for this protocol.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Samba 是许多环境中的一个好方案，因为它允许你与 Windows、Linux 和 macOS 机器共享文件。基本上，只要你赋予权限，几乎所有人都能访问你的共享。之所以能够这样，是因为
    Samba 是 **服务器消息块**（**SMB**）协议的重新实现，而该协议主要由 Windows 系统使用。然而，你不需要使用 Windows 平台也能访问
    Samba 共享，因为许多平台都支持这一协议。
- en: You may be wondering why I am going to cover two different solutions in this
    chapter. After all, if Samba shares can be accessed by pretty much everything
    and everyone, why bother with anything else? Even with Samba’s many strengths,
    there are weaknesses as well. First of all, permissions are handled very differently,
    so you’ll need to configure your shares in specific ways in order to prevent access
    to users that shouldn’t be able to see confidential data. With NFS, full support
    for standard UNIX permissions is provided, so you’ll only need to configure your
    permissions once. If permissions and confidentiality are important to you, you
    may want to look closer at NFS.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，为什么我在这一章会讲解两种不同的解决方案。毕竟，如果 Samba 共享几乎能被所有设备和用户访问，为什么还要考虑其他的呢？尽管 Samba
    有许多优点，但也有一些缺点。首先，权限的处理方式差异很大，因此你需要以特定的方式配置共享，以防止那些不应访问机密数据的用户进入。而 NFS 完全支持标准 UNIX
    权限，因此你只需配置一次权限。如果权限和机密性对你来说很重要，可能需要更仔细地考虑 NFS。
- en: It’s also not accurate to say that Windows systems cannot access NFS shares,
    because some versions actually can. By default, no version of Windows supports
    NFS outright, but some editions offer a plugin you can install that enables this
    support. If you install **Services for NFS**, your installation of Windows will
    be able to access NFS shares from that point forward.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 说 Windows 系统无法访问 NFS 共享并不准确，因为某些版本实际上是可以的。默认情况下，Windows 的任何版本都不直接支持 NFS，但一些版本提供了一个插件，可以让你安装它以启用此支持。如果你安装了
    **NFS 服务**，从那时起，你的 Windows 安装将能够访问 NFS 共享。
- en: Regarding an all-Linux environment or a situation where you only have Linux
    machines that need to access your shares, NFS is a great choice because it integrates
    much more tightly with the rest of the distribution. Permissions can be more easily
    enforced and, depending on your hardware, performance may be higher. The specifics
    of your environment will make your decision for you. Perhaps you’ll choose Samba
    for your mixed environment, or NFS for your all-Linux environment. Maybe you’ll
    even set up both NFS and Samba, having shares available for each platform. My
    recommendation is to learn and practice both, since you’ll use both solutions
    at one point or another during your career anyway.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关于全 Linux 环境或只有 Linux 机器需要访问共享的情况，NFS 是一个不错的选择，因为它与操作系统的集成更加紧密。权限可以更容易地进行控制，并且根据硬件的不同，性能可能更高。具体的环境会帮助你做出决定。也许你会为混合环境选择
    Samba，或为全 Linux 环境选择 NFS。也可能你会同时设置 NFS 和 Samba，为每个平台提供共享。我建议你学习并实践这两种方案，因为无论如何，你在职业生涯的某个时刻都将使用到这两种解决方案。
- en: Before you continue to the sections on setting up Samba and NFS, I recommend
    you first decide where in your filesystem you’d like to act as a parent directory
    for your file shares. This isn’t actually required, but I think it makes for better
    organization. There is no one right place to store your shares, but personally
    I like to create a `/share` directory at the `root` filesystem and create sub-directories
    for my network shares within it. For example, I can create `/share/documents`,
    `/share/public`, and so on for Samba shares. With regard to NFS, I usually create
    shared directories within `/exports`. You can choose how to set up your directory
    structure. As you read the remainder of this chapter, make sure to change my example
    paths to match yours if you use a different style.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续设置 Samba 和 NFS 的部分之前，我建议您首先确定您的文件系统中哪个位置作为文件共享的父目录。这并非必需，但我认为这样更有利于组织。并没有一个固定的地方来存储您的共享文件，但我个人喜欢在
    `root` 文件系统下创建一个 `/share` 目录，并在其中创建子目录用于我的网络共享。例如，我可以创建 `/share/documents`、`/share/public`
    等用于 Samba 共享的子目录。关于 NFS，我通常在 `/exports` 下创建共享目录。您可以选择如何设置您的目录结构。在阅读本章的其余部分时，请确保根据您的需要更改示例路径。
- en: Sharing files with Windows users via Samba
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Samba 向 Windows 用户共享文件
- en: 'In this section, I’ll walk you through setting up your very own **Samba** file
    server. I’ll also go over a sample configuration to get you started so that you
    can add your own shares. First, we’ll need to make sure that the `samba` package
    is installed on our server:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我将向您介绍如何设置您自己的 **Samba** 文件服务器。我还将讲解一个示例配置，以帮助您入门，以便您可以添加自己的共享。首先，我们需要确保在我们的服务器上安装了
    `samba` 软件包：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you install the `samba` package, you’ll have a new daemon installed on
    your server, `smbd`. The `smbd` daemon will be automatically started and enabled
    for you. You’ll also be provided with a default configuration file for Samba,
    located at `/etc/samba/smb.conf`. For now, I recommend stopping `samba` since
    we have yet to configure it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装 `samba` 软件包时，您的服务器上将安装一个新的守护程序 `smbd`。`smbd` 守护程序将自动启动和启用。同时，您还将获得一个位于
    `/etc/samba/smb.conf` 的默认 Samba 配置文件。目前，我建议停止 `samba`，因为我们还没有配置它：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since we’re going to configure Samba from scratch, we should start with an
    empty configuration file. Let’s back up the original file, rather than overwrite
    it. The default file includes some useful notes and samples, so we should keep
    it around for future reference:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将从头开始配置 Samba，我们应该从一个空白的配置文件开始。让我们备份原始文件，而不是直接覆盖它。默认文件包含一些有用的注释和示例，所以我们应该保留它以备将来参考：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can begin a fresh configuration. Although it’s not required, I like
    to split my Samba configuration up between two files, `/etc/samba/smb.conf` and
    `/etc/samba/smbshared.conf`. You don’t have to do this, but I think it makes the
    configuration cleaner and easier to read. First, here is a sample `/etc/samba/smb.conf`
    file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始一个全新的配置。虽然这不是必需的，但我喜欢将我的 Samba 配置分成两个文件，`/etc/samba/smb.conf` 和 `/etc/samba/smbshared.conf`。你不一定要这样做，但我认为这样可以使配置更清晰、更易于阅读。首先，这是一个
    `/etc/samba/smb.conf` 文件的示例：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, this is a really short file. Basically, we’re including only
    the lines we absolutely need to in order to set up a file server with Samba. Next,
    I’ll explain each line and what it does.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，这是一个非常简短的文件。基本上，我们只包括了设置 Samba 文件服务器所需的行。接下来，我将解释每一行及其作用。
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the `[global]` stanza, we’re declaring the global section of our configuration,
    which will consist of settings that will impact Samba as a whole. There will also
    be additional stanzas for individual shares, which we’ll get to later.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `[global]` 部分，我们声明了配置的全局部分，其中包含将影响整个 Samba 的设置。还会有额外的部分用于单独的共享，我们稍后会讨论到。
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `server string` is somewhat of a description field for the `File Server`.
    If you’ve browsed networks from Windows computers before, you may have seen this
    field. Whatever you type here will display underneath the server’s name in Windows
    Explorer. This isn’t required, but it’s nice to have.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`server string` 在某种程度上是 `File Server` 的描述字段。如果您以前从 Windows 计算机浏览网络，可能已经看到这个字段。无论您在此处键入什么内容，都将显示在
    Windows Explorer 中服务器名称下方。这不是必需的，但是有这个字段还是挺不错的。'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we’re setting the `workgroup`, which is the exact same thing as a `workgroup`
    on Windows PCs. In short, the workgroup is a namespace that describes a group
    of machines. When browsing network shares on Windows systems, you’ll see a list
    of workgroups, and then one or more computers within that workgroup. In short,
    this is a way to logically group your nodes. You can set this to whatever you
    like. If you already have a workgroup in your organization, you should set it
    here to match the workgroup names of your other machines. The default workgroup
    name is simply `WORKGROUP` on Windows PCs, if you haven’t customized the workgroup
    name at all.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了 `workgroup`，它与 Windows PC 上的 `workgroup` 完全相同。简而言之，工作组是一个命名空间，用于描述一组计算机。在
    Windows 系统中浏览网络共享时，你会看到一组工作组列表，然后在该工作组中看到一台或多台计算机。简而言之，这是用来逻辑地将你的节点进行分组的方法。你可以将它设置为任何你喜欢的名称。如果你已经在组织中有一个工作组，你应该在这里设置它，以匹配其他计算机的工作组名称。如果你没有自定义工作组名称，Windows
    PC 上的默认工作组名称就是 `WORKGROUP`。
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This setting sets up Samba to utilize usernames and passwords for authentication
    to the server. Here, we’re setting the `security` mode to `user`, which means
    we’re using local users to authenticate, rather than other options such as `ads`
    (Active Directory) or `domain` (domain controller), which are both outside the
    scope of this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置配置 Samba 使用用户名和密码进行服务器身份验证。在这里，我们将 `security` 模式设置为 `user`，这意味着我们使用本地用户进行身份验证，而不是使用
    `ads`（Active Directory）或 `domain`（域控制器）等其他选项，这些选项都不在本书的范围内。
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This option configures Samba to treat unauthenticated users as guest users.
    Basically, unauthenticated users will still be able to access shares, but they
    will have guest permissions instead of full permissions. If that’s not something
    you want, then you can omit this line from your file. Note that if you do omit
    this, you’ll need to make sure that both your server and client PCs have the same
    user account names on either side. Ideally, we want to use directory-based authentication,
    but that’s beyond the scope of this book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项配置 Samba 将未认证的用户视为访客用户。基本上，未认证的用户仍然可以访问共享，但他们将拥有访客权限，而不是完全权限。如果你不希望这样，你可以从文件中省略这一行。请注意，如果你省略了这一行，你需要确保服务器和客户端计算机两边的用户帐户名称是相同的。理想情况下，我们希望使用基于目录的身份验证，但那超出了本书的范围。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `name resolve order` setting configures how Samba resolves hostnames. In
    this case, we’re using the broadcast name first, followed by `wins`. Since `wins`
    has been pretty much abandoned (and replaced by DNS), we include it here solely
    for compatibility with legacy networks.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`name resolve order` 设置配置 Samba 如何解析主机名。在这个设置中，我们首先使用广播名称，然后是 `wins`。由于 `wins`
    已经基本上被弃用（并被 DNS 取代），我们在这里包含它只是为了兼容遗留网络。'
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Remember how I mentioned that I usually split my Samba configurations into
    two different files? On this line, I’m calling that second `/etc/samba/smbshared.conf`
    file. The contents of the `smbshared.conf` file will be inserted right here, as
    if we only had one file. We haven’t created the `smbshared.conf` file yet. Let’s
    take care of that next. Here’s a sample `smbshared.conf` file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我提到过我通常会将我的 Samba 配置分成两个文件吗？在这一行，我正在调用第二个 `/etc/samba/smbshared.conf` 文件。`smbshared.conf`
    文件的内容将在这里插入，就像我们只有一个文件一样。我们还没有创建 `smbshared.conf` 文件。接下来让我们来创建它。这是一个示例 `smbshared.conf`
    文件：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, I’m separating share declarations in their own file. We can
    see several interesting things within `smbshared.conf`. First, we have two stanzas,
    `[Documents]` and `[Public]`. Each stanza is a share name, which will allow Windows
    users to access the share under `//servername/share-name`. In this case, this
    file will give us two shares: `//servername/Documents` and `//servername/Public`.
    The `Public` share is writable for everyone, though the `Documents` share is restricted
    to read-only. The `Documents` share has the following options:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我将共享声明分离到它们自己的文件中。我们可以在 `smbshared.conf` 中看到一些有趣的内容。首先，我们有两个段落，`[Documents]`
    和 `[Public]`。每个段落都是一个共享名称，它将允许 Windows 用户通过 `//servername/share-name` 访问共享。在这种情况下，这个文件将为我们提供两个共享：`//servername/Documents`
    和 `//servername/Public`。`Public` 共享对所有人可写，而 `Documents` 共享则限制为只读。`Documents` 共享具有以下选项：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is the path to the share, which must exist on the server’s filesystem.
    In this case, when a user reads files from `//servername/Documents` on a Windows
    system, they will be reading data from `/share/documents` on the Ubuntu server
    that’s housing the share.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是共享的路径，它必须存在于服务器的文件系统中。在这种情况下，当用户在 Windows 系统上从 `//servername/Documents` 读取文件时，他们实际上是在从托管共享的
    Ubuntu 服务器上的 `/share/documents` 读取数据。
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These two lines are basically bypassing user ownership. When a user reads this
    share, they are treated as `myuser` instead of their actual user account. Normally,
    you would want to set up LDAP or Active Directory to manage your user accounts
    and handle their mapping to Ubuntu Server, but a full discussion of directory-based
    user access isn’t covered in this book, so I provided the `force` options as an
    easy starting point. The user account you set here must exist on the server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行基本上是绕过了用户所有权。当用户访问此共享时，他们会被当作 `myuser` 而不是他们实际的用户帐户。通常，你会希望设置 LDAP 或 Active
    Directory 来管理你的用户帐户，并处理它们与 Ubuntu 服务器的映射，但本书并未详细讨论基于目录的用户访问，因此我提供了 `force` 选项作为一个简单的起点。你在这里设置的用户帐户必须存在于服务器上。
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With these two lines, we’re configuring what users are able to do once they
    connect to this share. In this case, `public = yes` means that the share is publicly
    available, though `writable = no` prevents anyone from making changes to the contents
    of this share. This is useful if you want to share files with others, but you
    want to restrict access and stop anyone from being able to modify the content.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两行配置，我们设置了连接到此共享后的用户可以做什么。在这种情况下，`public = yes` 意味着共享是公开可用的，尽管 `writable
    = no` 防止任何人对该共享的内容进行更改。如果你想与他人共享文件，但又想限制访问并阻止任何人修改内容，这是很有用的。
- en: 'The `Public` share has some additional settings that weren’t found in the `Documents`
    share:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Public` 共享具有一些在 `Documents` 共享中没有的额外设置：'
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With these options, I’m setting up how the permissions of files and directories
    will be handled when new content is added to the share. Directories will be given
    `777` permissions and files will be given permissions of `664`. Yes, these permissions
    are very open; note that the share is named `Public`, which implies full access
    anyway, and its intended purpose is to house data that isn’t confidential or restricted:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些选项，我正在设置如何处理当新内容添加到共享时，文件和目录的权限。目录将被赋予 `777` 权限，而文件将被赋予 `664` 权限。是的，这些权限非常开放；请注意，共享名为
    `Public`，意味着无论如何都应有完全访问权限，它的预期用途是存放那些不涉及机密或限制的数据：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Just as I did with the previous share, I’m setting up the share to be publicly
    available, but this time I’m also configuring it to allow users to make changes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我在之前的共享中做的那样，我设置了共享为公开可用，但这次我还配置它允许用户进行更改。
- en: 'To take advantage of this configuration, we need to start the Samba daemon.
    Before we do though, we want to double-check that the directories we entered into
    our `smbshared.conf` file exist, so if you’re using my example, you’ll need to
    create `/share/documents` and `/share/public`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用此配置，我们需要启动 Samba 守护进程。在此之前，我们要再次检查我们在 `smbshared.conf` 文件中输入的目录是否存在，所以如果你使用我的示例，你需要创建
    `/share/documents` 和 `/share/public`：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also, the user account that was referenced in the force user and the group
    referenced in the force group must both exist and have ownership over the shared
    directories:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，强制用户中提到的用户帐户和强制组中提到的组必须都存在并且对共享目录拥有所有权：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At this point, it’s a good idea to use the `testparm` command, which will test
    the syntax of our Samba configuration files for us. It won’t necessarily catch
    every error we could have made, but it is a good command to run to quickly check
    the sanity. This command will first check the syntax, and then it will print the
    entire configuration to the terminal for you to have a chance to review it. If
    you see no errors here, then you can proceed to start the service:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，使用 `testparm` 命令是个好主意，它将测试我们的 Samba 配置文件的语法。它不一定能发现我们可能犯的每一个错误，但它是一个快速检查配置是否正常的好命令。此命令首先会检查语法，然后会将整个配置打印到终端，供你查看。如果你在这里没有看到错误，那么可以继续启动服务：
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, check the status to ensure that the daemon is running:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，检查状态以确保守护进程正在运行：
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will produce output similar to the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似以下内容的输出：
- en: '![](img/B18425_12_01.png)Figure 12.1: Checking the status of the smbd daemon'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/B18425_12_01.png)图 12.1：检查 smbd 守护进程的状态'
- en: That really should be all there is to it; you should now have `Documents` and
    `Public` shares on your file server that Windows users should be able to access.
    In fact, your Linux machines should be able to access these shares as well. On
    Windows, **Windows Explorer** has the ability to browse file shares on your network.
    If in doubt, try pressing the *Windows* key and the *r* key at the same time to
    open the **Run** dialog box, and then type the **Universal Naming Convention**
    (**UNC**) path to the share (`\\servername\Documents` or `\\servername\Public`).
    You should be able to see any files stored in either of those directories. In
    the case of the `Public` share, you should be able to create new files there as
    well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该就是全部了；你现在应该有 `Documents` 和 `Public` 共享在你的文件服务器上，Windows 用户应该能够访问这些共享。实际上，你的
    Linux 机器也应该能够访问这些共享。在 Windows 上，**Windows 资源管理器**能够浏览你网络上的文件共享。如果有疑问，尝试同时按下 *Windows*
    键和 *r* 键，打开 **运行** 对话框，然后输入共享的 **通用命名约定**（**UNC**）路径（例如 `\\servername\Documents`
    或 `\\servername\Public`）。你应该能够看到存储在这两个目录中的任何文件。对于 `Public` 共享，你也应该能够在那里创建新文件。
- en: 'On Linux systems, if you have a desktop environment installed, most of them
    feature a file manager that supports browsing network shares. Since there are
    a handful of different desktop environments available, the method varies from
    one distribution or configuration to another. Typically, most Linux file managers
    will have a network link within the file manager, which will allow you to easily
    browse your local shares. In the case of Ubuntu itself, you may need to install
    `smbclient` and `cifs-utils` via `apt`, so if you get an error you can try installing
    those packages. In the following screenshot, an Ubuntu 22.04 desktop client is
    browsing shares on a local Samba server:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统中，如果安装了桌面环境，大多数桌面环境都带有支持浏览网络共享的文件管理器。由于有多种不同的桌面环境可供选择，方法因发行版或配置的不同而有所不同。通常，大多数
    Linux 文件管理器都会在文件管理器中有一个网络链接，允许你轻松浏览本地共享。以 Ubuntu 为例，你可能需要通过 `apt` 安装 `smbclient`
    和 `cifs-utils`，如果遇到错误，可以尝试安装这些软件包。在以下截图中，一台 Ubuntu 22.04 桌面客户端正在浏览本地 Samba 服务器上的共享：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B18425_12_02.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![一张计算机的截图，自动生成的描述，信心中等](img/B18425_12_02.png)'
- en: 'Figure 12.2: Browsing a Samba share from a Linux client'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：从 Linux 客户端浏览 Samba 共享
- en: 'If your file manager doesn’t show you the available shares on your server,
    you can also access a Samba share by adding an entry for it in the `/etc/fstab`
    file, such as the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的文件管理器没有显示服务器上可用的共享，你也可以通过在 `/etc/fstab` 文件中为其添加条目来访问 Samba 共享，例如以下内容：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, assuming the local directory exists (`/mnt/documents` in the example
    `fstab` line), you should be able to mount the share with the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，假设本地目录存在（示例中的`fstab`行是`/mnt/documents`），你应该能够使用以下命令挂载该共享：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the `fstab` entry, I included the `noauto` option so that your system won’t
    mount the Samba share at boot time (you’ll need to do so manually with the `mount`
    command). If you do want the Samba share automatically mounted at boot time, change
    `noauto` to `auto`. However, you may receive errors during boot if for some reason
    the server hosting your Samba shares isn’t accessible, which is why I prefer the
    `noauto` option.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `fstab` 条目中，我包含了 `noauto` 选项，这样系统在启动时不会自动挂载 Samba 共享（你需要手动使用 `mount` 命令来挂载）。如果你希望在启动时自动挂载
    Samba 共享，可以将 `noauto` 改为 `auto`。但是，如果由于某种原因，托管 Samba 共享的服务器无法访问，你可能会在启动时遇到错误，这就是为什么我更倾向于使用
    `noauto` 选项。
- en: 'If you’d prefer to mount the Samba share without adding an `fstab` entry, the
    following example command should do the trick; just change the share name and
    mount point to match your local configuration:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在不添加 `fstab` 条目的情况下挂载 Samba 共享，以下示例命令应该能够实现；只需更改共享名称和挂载点，以匹配你的本地配置：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From here, feel free to experiment. You can add additional shares as appropriate,
    and customize your Samba implementation as you see fit. In the next section, we’ll
    explore NFS.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，随意进行实验。你可以根据需要添加额外的共享，并根据自己的需求自定义 Samba 实现。在下一节中，我们将探讨 NFS。
- en: Setting up NFS shares
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 NFS 共享
- en: An alternative to Samba is **NFS**. It’s a great method of sharing files from
    a Linux or Unix server to another Linux or Unix server. As I mentioned earlier
    in the chapter, Windows systems can access NFS shares as well, but that requires
    an add-on to be enabled. Therefore, NFS is preferred in a Linux or Unix environment,
    since it fully supports Linux and Unix-style permissions. As you can see from
    our dive into Samba earlier, we essentially forced all shares to be treated as
    being accessed by a particular user, which was messy, but was the easiest example
    of setting up a Samba server without also walking you through setting up a complicated
    Windows Active Directory deployment. Samba can certainly support per-user access
    restrictions and benefits greatly from a centralized directory server, though
    that would basically be a book of its own! NFS integrates better in a non-mixed
    environment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Samba的替代方案是**NFS**。它是一种非常好的方法，用于从Linux或Unix服务器向另一台Linux或Unix服务器共享文件。正如我在本章前面提到的，Windows系统也可以访问NFS共享，但这需要启用一个附加组件。因此，在Linux或Unix环境中，NFS是首选，因为它完全支持Linux和Unix风格的权限。正如我们之前深入了解Samba时看到的，我们基本上强制要求所有共享目录都以特定用户身份进行访问，虽然这种做法有些混乱，但它是最简单的Samba服务器设置示例，而不需要我们进一步讲解复杂的Windows
    Active Directory部署。Samba当然可以支持基于用户的访问限制，并且在集中的目录服务器上会有很大的优势，尽管那几乎会成为一本书！NFS在非混合环境中更具集成性。
- en: 'Earlier, we set up a parent directory in our filesystem to house our Samba
    shares, and we should do the same thing with NFS. While it wasn’t mandatory to
    have a special parent directory with Samba (I had you do that in order to be neat,
    but you weren’t required to), NFS really does want its own directory to house
    all of its shares. It’s not strictly required with NFS either, but there’s an
    added benefit in doing so, which I’ll go over before the end of this section.
    In my case, I’ll use `/exports` as an example, so you should make sure that that
    directory, or whatever you’ve chosen for NFS, exists:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们在文件系统中设置了一个父目录来存放我们的Samba共享，NFS也应该做同样的事情。虽然对于Samba来说，拥有一个专门的父目录并不是强制要求（我让你这么做是为了保持整洁，但你并不一定需要这么做），但NFS确实希望有一个自己的目录来存放所有共享。虽然NFS也不是严格要求这样做，但这样做有额外的好处，我将在本节结束前进行说明。在我的例子中，我将使用`/exports`作为示例，因此你应该确保该目录或你为NFS选择的目录已经存在：
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, let’s install the required NFS packages on our server. The following
    command will install NFS and its dependencies:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在服务器上安装所需的NFS软件包。以下命令将安装NFS及其依赖项：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once you install the `nfs-kernel-server` package, the `nfs-kernel-server` daemon
    will start up automatically. It will also create a default `/etc/exports` file
    (which is the main file that NFS reads its share information from), but it doesn’t
    contain any useful settings, just some commented lines. Let’s back up the `/etc/exports`
    file, since we’ll be creating our own:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了`nfs-kernel-server`软件包，`nfs-kernel-server`守护进程将自动启动。它还会创建一个默认的`/etc/exports`文件（这是NFS读取共享信息的主要文件），但该文件并不包含任何有用的设置，仅包含一些注释行。让我们备份`/etc/exports`文件，因为我们将创建我们自己的文件：
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To set up NFS, let’s first create some directories that we will share with
    other users. Each share in NFS is known as an **export**. I’ll use the following
    directories as examples, but you can export any directory you like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置NFS，首先让我们创建一些将与其他用户共享的目录。在NFS中，每个共享目录被称为**export**。我将使用以下目录作为示例，但你可以导出任何你喜欢的目录：
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `/etc/exports` file (which we’re creating fresh), I’ll insert the following
    four lines:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/etc/exports`文件中（我们正在重新创建这个文件），我将插入以下四行：
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first line is our **export root**, which I’ll go over a bit later. The next
    three lines are individual shares or exports. The `/backup`, `/documents`, and
    `/public` directories are being shared from the `/exports` parent directory. In
    this case, after the directory is called out in a line, we’re also setting which
    network is able to access them (`192.168.1.0`/`255.255.255.0` in our case). This
    means that if you’re connecting from a different network, your access will be
    denied. Each connecting machine must be a member of the `192.168.1.0/24` network
    in order to proceed (so make sure you change this to match your IP scheme). Finally,
    we include some options for each export, for example, `rw,no_subtree_check`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是我们的**导出根目录**，稍后我会详细介绍。接下来的三行是单独的共享或导出。`/backup`、`/documents`和`/public`目录是从`/exports`父目录共享的。在这种情况下，目录在一行中被调用后，我们还会设置哪些网络能够访问它们（在我们的例子中是`192.168.1.0`/`255.255.255.0`）。这意味着如果你从不同的网络连接，访问将被拒绝。每台连接的机器必须是`192.168.1.0/24`网络的成员才能继续操作（所以确保你修改这个以匹配你的IP方案）。最后，我们为每个导出项包含一些选项，例如`rw,no_subtree_check`。
- en: As far as what these options do, the first (`rw`) is rather self-explanatory.
    Here, we can set whether or not other nodes will be able to make changes to data
    within the export. In the examples I gave, the `/documents` export is read-only
    (`ro`), while the others allow read and write.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 至于这些选项的作用，第一个（`rw`）是相当直观的。在这里，我们可以设置其他节点是否可以对导出中的数据进行更改。在我给出的例子中，`/documents`导出是只读的（`ro`），而其他的则允许读写。
- en: The next option in each example is `no_subtree_check`. This option is known
    to increase reliability and is mainly implied by default. However, not including
    it may make NFS complain when it restarts, but nothing that will actually stop
    it from working. Particularly, this option disables what is known as **subtree
    checking**, which has had some stability issues in the past. Normally, when a
    directory is exported, NFS might scan parent directories as well, which is sometimes
    problematic, and can cause issues when it comes to open file handles.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例中的下一个选项是`no_subtree_check`。这个选项已知可以提高可靠性，并且默认情况下通常会隐式启用。然而，如果不包括它，NFS在重启时可能会发出警告，但不会真正阻止其正常工作。具体来说，这个选项禁用了所谓的**子树检查**，以前这个功能曾出现过一些稳定性问题。通常，当一个目录被导出时，NFS可能还会扫描父目录，这有时会导致问题，尤其是在处理打开的文件句柄时。
- en: 'There are several other options that can be included in an `export`, and you
    can read more about them by checking the man page for `export`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他选项可以包含在`export`中，你可以通过查看`export`的手册页面了解更多内容：
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: One option you’ll see quite often in the wild is `no_root_squash`. Normally,
    the `root` user on one system is mapped to nobody on the other for security reasons.
    In most cases, one system having `root` access to another is a bad idea. The `no_root_squash`
    option disables this, and it allows the `root` user on one end to be treated as
    the `root` user on the other. I can’t think of a reason, personally, where this
    would be useful (or even recommended), but I have seen this option quite often
    in the wild, so I figured I would bring it up. Again, check the man pages for
    `export` for more information on additional options you can pass to your exports.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际使用中，你会经常看到一个选项是`no_root_squash`。通常，系统中的`root`用户会被映射为另一个系统中的`nobody`用户，出于安全原因。在大多数情况下，一个系统对另一个系统拥有`root`权限是一个不好的主意。`no_root_squash`选项禁用这一点，它允许一端的`root`用户在另一端被当作`root`用户处理。就我个人而言，我想不出这种设置有什么用处（甚至不推荐使用），但我在实际中确实经常看到这个选项，所以我觉得有必要提一下。再次提醒，查看`export`的手册页面以获取更多关于你可以传递给导出的附加选项的详细信息。
- en: Next, we have one more file to edit before we can actually seal the deal on
    our NFS setup. The `/etc /idmapd.conf` file is necessary for mapping permissions
    on one node to another. In *Chapter 2*, *Managing Users and ermissions*, we talked
    about the fact that each user has an ID (UID) assigned to them. The problem, though,
    is that from one system to another, a user will not typically have the same UID.
    For example, user `jdoe` may be UID `1001` on server A, but `1007` on server B.
    When it comes to NFS, this greatly confuses the situation, because UIDs are used
    in order to reference permissions. Mapping IDs with `idmapd` allows this to stay
    consistent and handles translating each user properly, though it must be configured
    correctly and consistently on each node. Basically, as long as you use the same
    domain name on each server and client and configure the `/etc/idmapd.conf` file
    properly on each, you should be fine.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们完成NFS设置之前，还有一个文件需要编辑。`/etc/idmapd.conf`文件用于映射一个节点上的权限到另一个节点。在*第二章*，*管理用户和权限*中，我们讨论了每个用户都有一个分配给他们的ID（UID）。然而，问题在于，从一个系统到另一个系统，用户的UID通常是不同的。例如，用户`jdoe`在服务器A上的UID可能是`1001`，但在服务器B上是`1007`。对于NFS来说，这就非常混淆了，因为UID用于引用权限。通过`idmapd`映射ID可以保持一致，并确保正确地转换每个用户，尽管它必须在每个节点上正确且一致地配置。基本上，只要你在每个服务器和客户端上使用相同的域名，并且在每个节点上正确配置`/etc/idmapd.conf`文件，你就应该没问题。
- en: 'To configure this, open `/etc/idmapd.conf` in your text editor. Look for an
    option that is similar to the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置此项，打开`/etc/idmapd.conf`文件，并用文本编辑器查找类似于以下内容的选项：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First, remove the `#` symbol from that line to uncomment it. Then, change the
    domain to match the one used within the rest of your network. You can leave this
    as it is as long as it’s the same on each node, but if you recall from *Chapter
    11*, *Setting Up Network Services*, we used a sample domain of `local.lan` in
    our DHCP configuration, so it’s best to make sure you use the same domain name
    everywhere—even the domain provided by DHCP. Basically, just be as consistent
    as you can and you’ll have a much easier time overall. You’ll also want to edit
    the `/etc/idmapd.conf` file on each node that will access your file server, to
    ensure they are configured the same as well.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，删除该行前的`#`符号，以取消注释。然后，将域名更改为与你网络中其他部分使用的域名匹配。只要它在每个节点上相同，你可以保持默认值不变，但如果你记得在*第十一章*，*设置网络服务*中，我们在DHCP配置中使用了`local.lan`作为示例域名，所以最好确保在每个地方使用相同的域名——甚至包括DHCP提供的域名。基本上，只要尽量保持一致，你整体会更轻松。你还需要在每个将访问文件服务器的节点上编辑`/etc/idmapd.conf`文件，以确保它们也配置得相同。
- en: 'With our `/etc/exports` and `/etc/idmapd.conf` files in place, and assuming
    you’ve already created the exported directories on your filesystem, we should
    be all set to restart NFS to activate our configuration:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们配置了`/etc/exports`和`/etc/idmapd.conf`文件，并假设你已经在文件系统上创建了导出的目录后，我们应该准备好重启NFS以激活我们的配置：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After restarting NFS, you should check the daemon’s output via `systemctl`
    to ensure that there are no errors:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重启NFS后，你应该通过`systemctl`检查守护进程的输出，以确保没有错误：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As long as there are no errors, our NFS server should be working. Now, we just
    need to learn how to mount these shares on another system. Unlike Samba, using
    a Linux file manager and browsing the network will not show NFS exports by default;
    we’ll need to mount them manually. Client machines, assuming they are Debian-based
    (Ubuntu fits this description), will need the `nfs-common` package installed in
    order to access these exports.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 只要没有错误，我们的NFS服务器应该就可以正常工作了。现在，我们只需要学习如何在另一台系统上挂载这些共享。与Samba不同，使用Linux文件管理器并浏览网络默认不会显示NFS导出；我们需要手动挂载它们。客户端机器，假设它们是基于Debian的（例如Ubuntu），需要安装`nfs-common`软件包才能访问这些导出。
- en: 'It may already be installed, but if it’s not, we can install it with `apt`
    like any other package:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能已经安装好了，但如果没有，我们可以像安装其他软件包一样使用`apt`进行安装：
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With the client installed, we can now use the `mount` command to mount NFS
    exports on a client. For example, with regards to our `documents` export, we can
    use the following variation of the `mount` command to do the trick:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端安装完成后，我们现在可以使用`mount`命令在客户端挂载NFS导出。例如，针对我们的`documents`导出，我们可以使用以下变体的`mount`命令来完成这项工作：
- en: '[PRE34]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Replace `myserver` with either your server’s hostname or its IP address, `documents`
    with the name of the actual share on the server, and `/mnt/documents` with the
    path on your local server where you want to mount the share. From this point forward,
    you should be able to access the contents of the `documents` export on your file
    server. Notice, however, that the exported directory on the server was `/exports/documents`,
    but we only asked for `/documents` instead of the full path with the example `mount`
    command. The reason this works is because we identified an export root of `/exports`.
    To save you from flipping back, here’s the first line from the `/etc/exports`
    file, where we identified our export root:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将`myserver`替换为你的服务器主机名或 IP 地址，将`documents`替换为服务器上实际共享的名称，将`/mnt/documents`替换为你在本地服务器上希望挂载共享的路径。从此以后，你应该能够访问文件服务器上`documents`导出的内容。然而请注意，服务器上的导出目录是`/exports/documents`，但我们在示例`mount`命令中只要求`/documents`，而没有提供完整路径。之所以这样有效，是因为我们指定了`/exports`作为导出根目录。为了避免你来回翻看，这里是`/etc/exports`文件中的第一行，我们在其中指定了导出根目录：
- en: '[PRE35]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With the export root, we basically set the base directory for our NFS exports.
    We set it as read-only (`ro`), because we don’t want anyone making any changes
    to the `/exports` directory itself. Other directories within `/exports` have their
    own permissions and will thus override the `ro` setting on a per-export basis,
    so there’s no real reason to set our export root as anything other than read-only.
    With our export root set, we don’t have to call out the entire path of the export
    when we mount it; we only need the directory name. This is why we can mount an
    NFS export from `myserver:/documents` instead of having to type the entire path.
    While this does save us a bit of typing, it’s also useful because from the user’s
    perspective, they aren’t required to know anything about the underlying filesystem
    on the server. There’s simply no value in the user having to memorize the fact
    that the server is sharing a document’s directory from `/exports`; all they’re
    interested in is getting to their data. Another benefit is if we ever need to
    move our export `root` to a different directory (during a maintenance period),
    our users won’t have to change their configuration to reference the new place;
    they’ll only need to unmount and remount the exports.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导出根目录，我们基本上设置了 NFS 导出的基准目录。我们将其设置为只读（`ro`），因为我们不希望任何人对`/exports`目录本身进行更改。`/exports`中的其他目录有自己的权限，因此会在每个导出的基础上覆盖`ro`设置，因此没有必要将我们的导出根目录设置为其他任何东西，除了只读。设置了导出根目录后，我们在挂载时无需调用导出的完整路径，只需要目录名。这就是为什么我们可以从`myserver:/documents`挂载
    NFS 导出，而不必输入完整路径。虽然这样可以节省一些输入，但它也有用，因为从用户的角度来看，他们不需要了解服务器上的底层文件系统。用户完全不需要记住服务器从`/exports`共享了一个文档目录的事实；他们只关心如何访问他们的数据。另一个好处是，如果我们需要将导出根目录移到其他目录（例如在维护期间），用户不需要修改他们的配置来引用新的位置；他们只需要卸载并重新挂载导出即可。
- en: 'So, at this point, you’ll have three directories being exported from your file
    server, and you can always add others as you go. However, whenever you add a new
    export, it won’t be automatically added and read by NFS. You can restart NFS to
    activate new exports, but that’s not really a good idea while users may be connected
    to them, since that will disrupt their access. Thankfully, the following command
    will cause NFS to reread the `/etc/exports` file without disrupting existing connections.
    This will allow you to activate new exports immediately without having to wait
    for users to finish what they’re working on:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，到这个时候，你的文件服务器将导出三个目录，并且你可以根据需要随时添加其他目录。然而，每当你添加一个新的导出时，它不会被 NFS 自动添加并读取。你可以重启
    NFS 来激活新的导出，但在用户可能已经连接到它们的情况下，这样做其实并不是一个好主意，因为这会打断他们的访问。幸运的是，下面的命令可以让 NFS 重新读取`/etc/exports`文件，而不会干扰现有的连接。这样，你可以立即激活新的导出，而不必等待用户完成他们正在进行的工作：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With this section out of the way, you should be able to export a directory from
    your Ubuntu Server, and then mount that export on another Linux machine. Feel
    free to practice creating and mounting exports until you get the hang of it. In
    addition, you should familiarize yourself with a few additional options and settings
    that are allowable in the `/etc/exports` file, after consulting the man page on
    exports.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完这一部分后，你应该能够从你的 Ubuntu 服务器导出一个目录，然后将该导出挂载到另一台 Linux 机器上。随时练习创建和挂载导出，直到你掌握为止。此外，在查阅
    `exports` 的 man 页面后，你还应该熟悉 `/etc/exports` 文件中允许的一些附加选项和设置。
- en: The `/etc/exports` file, as you’ve seen in this section, is typically all you’ll
    need to set up a basic file server via NFS. However, you should also be aware
    that there’s another configuration file, `/etc/nfs.conf`, and that file is new
    in Ubuntu 22.04\. The purpose of this file is to tune the finer details of the
    NFS server. Although it’s out of scope to go over the `/etc/nfs.conf` file, it’s
    worth having a look at this file in order to get a feel for which types of options
    are available. For more information, see the further reading section at the end
    of this chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这一部分中看到的，`/etc/exports` 文件通常是设置基本 NFS 文件服务器所需的全部。然而，你还应该知道，Ubuntu 22.04
    中新增了一个配置文件 `/etc/nfs.conf`。这个文件的目的是调整 NFS 服务器的细节配置。虽然本章范围不包括 `/etc/nfs.conf` 文件的讲解，但查看这个文件仍然值得，这样你可以了解有哪些可用的选项。有关更多信息，请参见本章末尾的进一步阅读部分。
- en: When you’ve had more NFS practice than you can tolerate, we’ll move on to a
    few ways in which you can copy files from one node to another without needing
    to set up an intermediary service or daemon.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你已经不能再忍受更多的 NFS 实践时，我们将转向几种方法，让你能够在不需要设置中间服务或守护进程的情况下，从一个节点复制文件到另一个节点。
- en: Transferring files with rsync
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 rsync 传输文件
- en: Of all the countless tools and utilities available in the Linux and Unix world,
    few are as beloved as `rsync`. This is a utility that you can use to copy data
    from one place to another very easily, and there are many options available to
    allow you to be very specific about how you want the data to be transferred. Examples
    of its many use cases include copying files while preserving permissions, copying
    files while backing up replaced files, and even setting up incremental backups.
    If you don’t already know how to use `rsync`, you’ll probably want to get lots
    of practice with it, as it’s something you’ll soon see will be indispensable during
    your career as a Linux administrator, and it is also something that the Linux
    community generally assumes you already know. Thankfully, `rsync` is not hard
    to learn. Most administrators can learn the basic usage in about an hour or less,
    but the countless options available will lead you to learn new tricks even years
    down the road.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和 Unix 世界中，成千上万的工具和实用程序中，**`rsync`** 是最受欢迎的工具之一。这是一个你可以用来轻松将数据从一个地方复制到另一个地方的工具，并且提供了许多选项，可以让你非常精确地控制数据的传输方式。它的许多使用案例包括在保留权限的同时复制文件、在备份替换文件时复制文件，甚至设置增量备份。如果你还不知道如何使用
    **`rsync`**，你可能会想要多加练习，因为它将成为你作为 Linux 管理员的职业生涯中不可或缺的工具，而且 Linux 社区普遍假设你已经知道如何使用它。幸运的是，**`rsync`**
    并不难学。大多数管理员可以在一个小时或更短的时间内学会基本用法，而无数可用选项会让你即使多年后仍能学到新的技巧。
- en: 'Another aspect that makes `rsync` flexible is the many ways you can manipulate
    the source and target directories. I mentioned earlier that `rsync` is a tool
    you can use to copy data from one place to another. The beauty of this is that
    the source and target can literally be anywhere you’d like, assuming you have
    appropriate access. For example, the most common usage of `rsync` is to copy data
    from a directory on one server to a directory on another server over the network.
    However, you don’t even have to use the network; you can even copy data from one
    directory to another on the same server. While this may not seem like a useful
    thing to do at first, consider that the target directory may be a mount point
    that leads to a backup disk, or an NFS share that actually exists on another server.
    This also works in reverse: you can copy data from a network location to a local
    directory if you desire.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使`rsync`灵活的方面是，你可以以多种方式操作源目录和目标目录。我之前提到过，`rsync`是一个可以用来将数据从一个地方复制到另一个地方的工具。这么做的好处在于，源和目标目录实际上可以是你想要的任何地方，只要你有适当的访问权限。例如，`rsync`最常见的用途是将数据从一个服务器的目录复制到另一个服务器的目录，跨越网络进行传输。然而，你甚至不需要使用网络；你也可以将数据从同一台服务器的一个目录复制到另一个目录。虽然刚开始看起来这似乎不是一个非常有用的操作，但想一想，目标目录可能是一个挂载点，指向备份磁盘，或者是一个NFS共享，实际上存在于另一台服务器上。这也可以反向操作：如果需要，你也可以将数据从网络位置复制到本地目录。
- en: To get started with practicing with `rsync`, I recommend that you find some
    sample files to work with. Perhaps you have a collection of documents you can
    use, MP3 files, videos, text files, or basically any kind of data you have lying
    around. It’s important to make a copy of this data. If we make a mistake we could
    overwrite things, so it’s best to work with a copy of the data, or data you don’t
    care about, while you’re practicing. If you don’t have any files to work with,
    you can create some text files. The idea is to practice copying files from one
    place to another; it really doesn’t matter what you copy or where you send it
    to. I’ll walk you through some `rsync` examples that will progressively increase
    in complexity. The first few examples will show you how to back up a `home` directory,
    but later examples will be potentially destructive so you will probably want to
    work with sample files until you get the hang of it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始练习`rsync`，我建议你找到一些示例文件进行操作。也许你有一些可以使用的文档、MP3 文件、视频、文本文件，或者基本上任何你手头有的数据。重要的是要先制作这些数据的副本。如果我们犯了错误，可能会覆盖掉一些内容，所以在练习时最好使用数据的副本，或者是你不太在意的数据。如果你没有任何文件可以使用，你可以创建一些文本文件。这个练习的目的是从一个地方复制文件到另一个地方；其实你复制什么或者将它发送到哪里并不重要。我会带你逐步进行一些`rsync`的示例，难度会逐渐增加。前几个示例会向你展示如何备份`home`目录，但后面的示例可能会有潜在的破坏性，因此你可能希望使用示例文件，直到你掌握技巧。
- en: 'Here’s our first example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个示例：
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With that command, we’re using `rsync` (as `root`) to copy the contents of the
    `home` directory for the `myuser` directory to a backup directory, `/backup` (make
    sure the target directory exists). In the example, I used the `-r` option, which
    means `rsync` will grab directories recursively as well. You should now see a
    copy of the `/home/myuser` directory inside your `/backup` directory.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个命令，我们使用`rsync`（作为`root`）将`myuser`目录的`home`目录内容复制到备份目录`/backup`（确保目标目录存在）。在示例中，我使用了`-r`选项，意味着`rsync`也会递归地抓取目录。你现在应该能在`/backup`目录中看到`/home/myuser`目录的副本。
- en: 'However, we have a bit of a problem. If you look at the permissions in the
    `/backup/myuser` directory, you can see that everything in the target is now owned
    by `root`. This isn’t a good thing; when you back up a user’s `home` directory,
    you’ll want to retain their permissions. In addition, you should retain as much
    metadata as you can, including things like timestamps. Let’s try another variation
    of `rsync`. Don’t worry about the fact that `/backup` already has a copy of the
    `myuser` home directory from our previous backup. Let’s perform the backup again,
    but this time, we’ll use the `-a` option:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们遇到了一点问题。如果你查看`/backup/myuser`目录的权限，你会看到目标目录中的所有内容现在都归`root`所有。这并不是一个好现象；当你备份一个用户的`home`目录时，你应该保留他们的权限。此外，你还应该尽可能保留所有的元数据，包括时间戳等信息。我们再试试`rsync`的另一种变体。不要担心`/backup`已经包含我们之前备份的`myuser`
    home目录。我们再次执行备份，但这次我们将使用`-a`选项：
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This time, we replaced the `-r` option with `-a` (archive), which retains as
    much metadata as possible (in most cases, it should make everything an exact copy).
    What you should notice now is that the permissions within the backup match the
    permissions within the user’s `home` directory we copied from. The timestamps
    of the files will now match as well. This works because whenever `rsync` runs,
    it will copy what’s different from the last time it ran. The files from our first
    backup were already there, but the permissions were wrong. When we ran the second
    command, `rsync` only needed to copy what was different, so it applied the correct
    permissions to the files. If any new files were added to the source directory
    since we last ran the command, the new or updated files would be copied over as
    well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将 `-r` 选项替换为 `-a`（归档模式），它尽可能保留所有元数据（在大多数情况下，它应该能确保一切都是精确的复制）。你现在应该注意到的是，备份中的权限与我们复制的用户
    `home` 目录中的权限匹配。文件的时间戳也将一致。这是因为每次运行 `rsync` 时，它都会复制与上次运行时不同的内容。我们第一次备份的文件已经存在，但权限不正确。当我们运行第二个命令时，`rsync`
    只需要复制不同的内容，因此它为文件应用了正确的权限。如果自上次运行命令以来源目录中有新文件被添加，那么新文件或更新的文件也会被复制过去。
- en: 'The `archive` mode (the `-a` option that we used with the previous command)
    is actually very popular; you’ll probably see it a lot during your travels. The
    `-a` option is actually a wrapper option that includes the following options all
    at the same time:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`archive` 模式（我们在前一个命令中使用的 `-a` 选项）实际上非常流行；你可能在旅途中经常看到它。`-a` 选项实际上是一个包装选项，它同时包括以下所有选项：'
- en: '[PRE39]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you’re curious about what each of these options do, consult the man page
    for `rsync` for more detailed information. In summary, the `-r` option copies
    data recursively (which we already know), the `-l` option copies symbolic links,
    `-p` preserves permissions, `-g` preserves group ownership, `-o` preserves the
    owner, and `-D` preserves device files. If you put those options together, we
    get `-rlptgoD`. Therefore, `-a` is actually equal to `-rlptgoD`. I find `-a` easier
    to remember.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些选项的具体作用感到好奇，可以查看 `rsync` 的手册页，获取更详细的信息。总结来说，`-r` 选项表示递归地复制数据（这一点我们已经知道），`-l`
    选项复制符号链接，`-p` 保留权限，`-g` 保留组所有权，`-o` 保留所有者，`-D` 保留设备文件。如果把这些选项组合起来，我们就得到了 `-rlptgoD`。因此，`-a`
    实际上等同于 `-rlptgoD`。我觉得 `-a` 更容易记住。
- en: 'The `archive` mode is great and all, but wouldn’t it be nice to be able to
    watch what `rsync` is up to when it runs? Add the `-v` option and try the command
    again:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`archive` 模式很好用，但如果能看到 `rsync` 在运行时的状态是不是更好呢？添加 `-v` 选项并再次尝试该命令：'
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This time, `rsync` will display on your terminal what it’s doing as it runs
    (`-v` activates **verbose** mode). This is actually one of my favorite variations
    of the `rsync` command, as I like to copy everything and retain all the metadata,
    as well as watch what `rsync` is doing as it works.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，`rsync` 会在终端显示它运行时的操作 (`-v` 激活了 **详细模式**) 。这是我最喜欢的 `rsync` 命令变体之一，因为我喜欢复制所有内容并保留所有元数据，同时也能看到
    `rsync` 在工作时的状态。
- en: 'What if I told you that `rsync` supports SSH by default? It’s true! Using `rsync`,
    you can easily copy data from one node to another, even over SSH. The same options
    apply, so you don’t actually have to do anything different other than point `rsync`
    to the other server, rather than to another directory on your local server:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你 `rsync` 默认支持 SSH，你信吗？这是真的！通过使用 `rsync`，你可以轻松地从一个节点将数据复制到另一个节点，甚至通过 SSH。所有选项都适用，因此你不需要做任何不同的操作，只需将
    `rsync` 指向另一台服务器，而不是本地服务器上的其他目录：
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With this example, I’m copying the `home` directory for `myuser` to the `/backup`
    directory on server `192.168.1.5`. I’m connecting to the other server as the `admin`
    user. Make sure you change the user account and IP address accordingly, and also
    make sure the user account you use has access to the `/backup` directory. When
    you run this command, you should get prompted for the SSH password as you would
    when using plain SSH to connect to the server. After the connection is established,
    the files will be copied to the target server and directory.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将 `myuser` 用户的 `home` 目录复制到服务器 `192.168.1.5` 上的 `/backup` 目录。我以 `admin`
    用户身份连接到另一台服务器。确保你根据需要更改用户账户和 IP 地址，同时确保你使用的账户有访问 `/backup` 目录的权限。当你运行此命令时，系统应该会提示你输入
    SSH 密码，就像你通过普通 SSH 连接到服务器时一样。连接建立后，文件将被复制到目标服务器和目录。
- en: 'Now, we’ll get into some even cooler examples (some of which are potentially
    destructive), and we probably won’t want to work with an actual `home` directory
    for these, unless it’s a test account and you don’t care about its contents. As
    I’ve mentioned before, you should have some test files to play with. When practicing,
    simply replace my directories with yours. Here’s another variation worth trying:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进入一些更酷的示例（其中一些可能具有破坏性），我们可能不想使用实际的`home`目录来做这些，除非是一个测试账户，并且你不在乎其内容。正如我之前提到的，你应该有一些测试文件来进行练习。在练习时，只需将我的目录替换为你的目录。这里有另一个值得尝试的变体：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now I’m introducing you to the `--delete` option. This option allows you to
    synchronize two directories. Let me explain why this is important. With every
    `rsync` example up until now, we’ve been copying files from point A to point B,
    but we weren’t deleting anything. For example, let’s say you’ve already used `rsync`
    to copy contents from point A to point B. Then, you delete some files from point
    A. When you use `rsync` to copy files from point A to point B again, the files
    you deleted in point A won’t be deleted in point B. They’ll still be there. This
    is because by default, `rsync` copies data between two locations, but it doesn’t
    remove anything. With the `--delete` option, you’re effectively synchronizing
    the two points, thus you’re telling `rsync` to make them the same by allowing
    it to delete files in the target that are no longer in the source.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我向你介绍`--delete`选项。这个选项允许你同步两个目录。让我解释一下为什么这个选项很重要。直到现在，我们的每个`rsync`例子都在将文件从A点复制到B点，但我们没有删除任何文件。例如，假设你已经使用`rsync`将A点的内容复制到了B点。然后，你从A点删除了一些文件。当你再次使用`rsync`将文件从A点复制到B点时，你在A点删除的文件不会在B点被删除，它们仍然会存在。这是因为默认情况下，`rsync`只是将数据从一个位置复制到另一个位置，但并不删除任何东西。使用`--delete`选项后，你实际上是在同步这两个位置，因此你告诉`rsync`通过删除目标位置中已不再存在于源位置的文件来使它们一致。
- en: 'Next, we’ll add the `-b` (backup) option:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加`-b`（备份）选项：
- en: '[PRE43]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This one is particularly useful. Normally, when a file is updated on `/src`
    and then copied over to `/target`, the copy on `/target` is overwritten with the
    new version. But what if you don’t want any files to be replaced? The `-b` option
    renames files on the target that are being overwritten, so you’ll still have the
    original file. If you add the `--backup-dir` option, things get really interesting:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项特别有用。通常，当`/src`上的文件被更新并复制到`/target`时，`/target`上的文件将被新版本覆盖。但如果你不想替换任何文件呢？`-b`选项会重命名在目标位置被覆盖的文件，因此你仍然可以保留原始文件。如果你添加了`--backup-dir`选项，事情会变得更有趣：
- en: '[PRE44]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, we’re copying files from `/src` to `/target` as we were before, but we’re
    now sending replaced files to the `/backup/incremental` directory. This means
    that when a file is going to be replaced on the target, the original file will
    be copied to `/backup/incremental`. This works because we used the `-b` option
    (backup) but we also used the `--backup-dir` option, which means that the replaced
    files won’t be renamed; they’ll simply be moved to the designated directory. This
    allows us to effectively perform incremental backups.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们像之前一样将文件从`/src`复制到`/target`，但是我们现在将替换的文件发送到`/backup/incremental`目录。这意味着，当一个文件要被替换时，原始文件将被复制到`/backup/incremental`。之所以能这样工作，是因为我们使用了`-b`选项（备份），但我们也使用了`--backup-dir`选项，这意味着被替换的文件不会被重命名；它们将简单地被移动到指定目录中。这使我们能够有效地进行增量备份。
- en: 'Building on our previous example, we can use the Bash shell itself to make
    incremental backups work even better. Consider these commands:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子基础上，我们可以使用Bash shell本身使增量备份工作得更好。考虑这些命令：
- en: '[PRE45]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With this example, we grab the current date and store it in a variable (`CURDATE`).
    In the `rsync` portion of the command, we use that variable for the `--backup-dir`
    option. This will copy the replaced files to a `backup` directory named after
    the `date` the command was run. Basically, if today’s date was `08-17-2022`, the
    resulting command would be the same as if we had run the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们获取当前日期并将其存储在一个变量中（`CURDATE`）。在命令的`rsync`部分，我们使用该变量作为`--backup-dir`选项的值。这会将替换的文件复制到一个以命令运行时的`date`命名的`backup`目录中。基本上，如果今天的日期是`08-17-2022`，那么执行的命令将与我们运行以下命令的结果相同：
- en: '[PRE46]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Hopefully, you can see how flexible `rsync` is and how it can be used to not
    only copy files between directories and/or nodes, but also to serve as a backup
    solution as well (assuming you have a remote destination to copy files to). The
    best part is that this is only the beginning. If you consult the man page for
    `rsync`, you’ll see that there are a lot of options you can use to customize it
    even further. Give it some practice, and you should get the hang of it in no time.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能看到 `rsync` 的灵活性，以及它如何不仅用于在目录和/或节点之间复制文件，还能作为备份解决方案（前提是你有一个远程目标来复制文件）。最棒的是，这只是个开始。如果你查阅
    `rsync` 的手册页，你会发现还有许多选项可以进一步定制它。多加练习，你应该很快就能掌握它。
- en: Transferring files with SCP
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SCP 传输文件
- en: 'A useful alternative to `rsync` is the **Secure Copy** (**SCP**) utility, which
    comes bundled with the OpenSSH client. It allows you to quickly copy files from
    one node to another. While `rsync` also allows you to copy files to other network
    nodes via SSH, SCP is more practical for one-off tasks; `rsync` is geared toward
    more complex jobs. If your goal is to send a single file or a small number of
    files to another machine, SCP is a great tool you can use to get the job done.
    If nothing else, it’s yet another item for your administration toolbox. To utilize
    SCP, we’ll use the `scp` command. Since you most likely already have the OpenSSH
    client installed, you should already have the `scp` command available. If you
    execute `which scp`, you should receive the following output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的替代方案是 **Secure Copy**（**SCP**）工具，它与 OpenSSH 客户端一起打包提供。它允许你快速地将文件从一个节点复制到另一个节点。虽然
    `rsync` 也允许你通过 SSH 将文件复制到其他网络节点，但 SCP 更适合用于一次性任务；`rsync` 更适合更复杂的工作。如果你的目标是将单个文件或少量文件发送到另一台机器，SCP
    是一个很好的工具，可以帮助你完成这项任务。如果没有别的，它也是你管理工具箱中的另一个好帮手。要使用 SCP，我们将使用 `scp` 命令。由于你很可能已经安装了
    OpenSSH 客户端，因此应该已经可以使用 `scp` 命令了。如果你执行 `which scp`，你应该看到如下输出：
- en: '[PRE47]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If you don’t see any output, make sure that the `openssh-client` package is
    installed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到任何输出，确保已安装 `openssh-client` 包。
- en: 'Using SCP is very similar in nature to `rsync`. The command requires a source,
    a target, and a filename. To transfer a single file from your local machine to
    another, the resulting command would look similar to the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SCP 与 `rsync` 非常相似。该命令需要一个源、一个目标和一个文件名。要将一个文件从本地机器传输到另一台机器，生成的命令可能如下所示：
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With this example, we’re copying the `myfile.txt` file (which is located in
    our current working directory) to a server located at `192.168.1.50`. If the target
    server is recognized by DNS, we could’ve used the DNS name instead of the IP address.
    The command will connect to the server as user `jdoe` and place the file into
    that user’s `home` directory. Actually, we can shorten that command a bit:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将 `myfile.txt` 文件（位于当前工作目录中）复制到位于 `192.168.1.50` 的服务器。如果目标服务器被 DNS
    识别，我们本可以使用 DNS 名称而不是 IP 地址。此命令将作为用户 `jdoe` 连接到服务器，并将文件放入该用户的 `home` 目录。实际上，我们可以稍微简化一下这个命令：
- en: '[PRE49]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that I removed the target path, which was `/home/jdoe`. I’m able to omit
    the path to the target, since the `home` directory is assumed if you don’t give
    the `scp` command a target path. Therefore, the `myfile.txt` file will end up
    in `/home/jdoe` whether or not I included the path to the `home` directory explicitly.
    If I wanted to copy the file somewhere else, I would definitely need to call out
    the location. Make sure you always include at least the colon when copying a file,
    since if you don’t include it, you’ll end up copying the file to your current
    working directory instead of the target.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我省略了目标路径 `/home/jdoe`。由于如果你没有为 `scp` 命令提供目标路径，默认会将文件放入 `home` 目录，因此我可以省略目标路径。所以，无论我是否明确包含
    `home` 目录的路径，`myfile.txt` 文件最终都会出现在 `/home/jdoe`。如果我想将文件复制到其他地方，我就必须指定目标位置。确保在复制文件时至少包含冒号，因为如果不包括它，你将把文件复制到当前工作目录，而不是目标目录。
- en: 'The `scp` command also works in reverse:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`scp` 命令也可以反向工作：'
- en: '[PRE50]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: With this example, we’re assuming that `myfile.txt` is located in the `home`
    directory for the user `jdoe`. This command will copy that file to the current
    working directory of our local machine, since I designated the local path as a
    *single period* (which corresponds to our current working directory). Using `scp`
    in reverse isn’t always practical, since you have to already know where the desired
    file is stored on the target before transferring it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们假设`myfile.txt`位于用户`jdoe`的`home`目录中。此命令将把该文件复制到我们本地机器的当前工作目录，因为我将本地路径指定为*一个点*（它对应于我们的当前工作目录）。在反向使用`scp`时并不总是实用的，因为你必须提前知道目标机器上文件的存储位置才能进行传输。
- en: 'With our previous `scp` examples, we’ve only been copying a single file. If
    we want to transfer or download an entire directory and its contents, we will
    need to use the `-r` option, which allows us to do a recursive copy:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的`scp`示例中，我们只复制了一个文件。如果我们想传输或下载整个目录及其内容，我们需要使用`-r`选项，这样可以执行递归复制：
- en: '[PRE51]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'With this example, we’re copying the local folder `/home/jdoe/downloads/linux_iso`
    to remote machine `192.168.1.50`. Since we used the `-r` option, `scp` will transfer
    the `linux_iso` folder and all of its contents. At the remote end, we’re again
    connecting via the user `jdoe`. Notice that the target path is simply `downloads`.
    Since `scp` defaults to the user’s `home` directory, this will copy the `linux_iso`
    directory from the source machine to the target machine under the `/home/jdoe/downloads`
    directory. The following command would’ve had the exact same result:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在将本地文件夹`/home/jdoe/downloads/linux_iso`复制到远程机器`192.168.1.50`。由于我们使用了`-r`选项，`scp`将传输`linux_iso`文件夹及其所有内容。在远程端，我们再次通过用户`jdoe`连接。请注意，目标路径仅为`downloads`。由于`scp`默认使用用户的`home`目录，这将把`linux_iso`目录从源机器复制到目标机器的`/home/jdoe/downloads`目录下。以下命令将产生完全相同的结果：
- en: '[PRE52]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `home` directory is not the only assumption the `scp` command makes. It
    also assumes that SSH is listening on port `22` on the remote machine. Since it’s
    possible to change the SSH port on a server to something else, port `22` may or
    may not be what’s in use. If you need to designate a different port for `scp`
    to use, use the `-P` option:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`home`目录并不是`scp`命令假设的唯一路径。它还假设SSH在远程机器的端口`22`上监听。由于可以将服务器的SSH端口更改为其他端口，端口`22`可能并不是实际使用的端口。如果你需要为`scp`指定一个不同的端口，请使用`-P`选项：'
- en: '[PRE53]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: With that example, we’re connecting to the remote machine via port `2222`. If
    you’ve configured SSH to listen on a different port, change the number accordingly.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们通过端口`2222`连接到远程机器。如果你已经配置了SSH监听不同的端口，请相应地更改端口号。
- en: Although port `22` is always the default for OpenSSH, it’s common for some administrators
    to change it to something else. While changing the SSH port doesn’t add a great
    deal of benefit in regard to security (an intensive port scan will still find
    your SSH daemon), it’s a relatively easy change to make, and making it even just
    a little bit harder to find is beneficial. We’ll discuss this further in *Chapter
    21*, *Securing Your Server*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管端口`22`始终是OpenSSH的默认端口，但一些管理员常常会将其更改为其他端口。虽然更改SSH端口在安全性方面并不会带来很大的好处（一个强力端口扫描仍然可以找到你的SSH守护进程），但这是一个相对容易的修改，而且将其设置为稍微难以发现一点是有益的。我们将在*第21章*中进一步讨论这个问题，*保护你的服务器*。
- en: 'Like most commands in the Linux world, the `scp` command supports verbose mode.
    If you want to see how the `scp` command progresses as it copies multiple files,
    add the `-v` option:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与Linux世界中的大多数命令一样，`scp`命令支持详细模式。如果你想查看`scp`命令在复制多个文件时的进度，可以添加`-v`选项：
- en: '[PRE54]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Well, there you have it. The `scp` command isn’t overly complex or advanced,
    but it’s really great for situations in which you want to perform a one-time copy
    of a file from one node to another. Since it copies files over SSH, you benefit
    from its security, and it also integrates well with your existing SSH configuration.
    An example of this integration is the fact that `scp` recognizes your `~/.ssh/config`
    file (if you have one), so you can shorten the command even further. Go ahead
    and practice with it a bit, and in the next section, we’ll go over yet another
    trick that OpenSSH has up its sleeve.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，就是这样。`scp`命令并不是特别复杂或高级，但它非常适合那些你想要一次性从一个节点将文件复制到另一个节点的情况。由于它通过SSH复制文件，你可以从中受益于其安全性，并且它也很好地与现有的SSH配置集成。这种集成的一个例子是，`scp`会识别你的`~/.ssh/config`文件（如果你有的话），所以你可以进一步简化命令。试着多练习一下，在下一个部分中，我们将介绍OpenSSH的另一个技巧。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we explored multiple ways of accessing remote resources. Just
    about every network has a central location for storing files, and we explored
    two ways of accomplishing this with NFS and Samba. Both NFS and Samba have their
    place in the data center and are very useful ways in which we can make resources
    on a server available to our users who need to access them. We also talked about
    `rsync` and `scp`, two great utilities for transferring data without needing to
    set up a permanent share.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们探讨了多种访问远程资源的方式。几乎每个网络都有一个用于存储文件的中心位置，我们探索了使用 NFS 和 Samba 完成这一目标的两种方式。NFS
    和 Samba 在数据中心中各有其用途，并且是我们可以将服务器上的资源提供给需要访问的用户的非常有用的方式。我们还讨论了`rsync`和`scp`，这两个无需设置永久共享即可传输数据的优秀实用工具。
- en: Next up is *Chapter 13*, *Managing Databases*. Now that we have all kinds of
    useful services running on our Ubuntu Server network, it’s only fitting that we
    take a look at serving databases as well. Specifically, we’ll look at MariaDB.
    See you there!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 *第 13 章*，*管理数据库*。现在我们的 Ubuntu 服务器网络上运行了各种有用的服务，看看如何服务数据库才是正经事。具体来说，我们将研究
    MariaDB。到时见！
- en: Relevant videos
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关视频
- en: 'Tutorial for `scp`: [https://linux.video/scp](https://linux.video/scp)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教程`scp`：[https://linux.video/scp](https://linux.video/scp)
- en: 'Backing up a Linux server with `rsync`: [https://linux.video/rsync-backup](https://linux.video/rsync-backup)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`rsync`备份 Linux 服务器：[https://linux.video/rsync-backup](https://linux.video/rsync-backup)
- en: 'Transferring files with `rsync`: [https://linux.video/rsync-transfer](https://linux.video/rsync-transfer)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`rsync`传输文件：[https://linux.video/rsync-transfer](https://linux.video/rsync-transfer)
- en: Further reading
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Ubuntu `rsync` documentation: [https://learnlinux.link/u-rsync](https://learnlinux.link/u-rsync)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu `rsync` 文档：[https://learnlinux.link/u-rsync](https://learnlinux.link/u-rsync)
- en: 'Ubuntu Samba documentation: [https://learnlinux.link/u-smb](https://learnlinux.link/u-smb)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Samba 文档：[https://learnlinux.link/u-smb](https://learnlinux.link/u-smb)
- en: 'Service – NFS (contains additional information on NFS changes in 22.04): [https://learnlinux.link/u-nfs-1](https://learnlinux.link/u-nfs-1)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务 – NFS（包含 22.04 版本中 NFS 更改的额外信息）：[https://learnlinux.link/u-nfs-1](https://learnlinux.link/u-nfs-1)
- en: 'Ubuntu NFS documentation: [https://learnlinux.link/u-nfs-2](https://learnlinux.link/u-nfs-2)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu NFS 文档：[https://learnlinux.link/u-nfs-2](https://learnlinux.link/u-nfs-2)
- en: 'Active Directory Integration: [https://learnlinux.link/u-ad](https://learnlinux.link/u-ad)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Active Directory 集成：[https://learnlinux.link/u-ad](https://learnlinux.link/u-ad)
- en: Join our community on Discord
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code50046724-1955875156.png)'
