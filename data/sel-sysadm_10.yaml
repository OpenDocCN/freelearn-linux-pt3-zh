- en: '*Chapter 8*: SEPostgreSQL – Extending PostgreSQL with SELinux'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：SEPostgreSQL——通过SELinux扩展PostgreSQL'
- en: 'In the previous chapter, we covered a few example SELinux-aware applications:
    applications that know and interact with the SELinux subsystem to further enhance
    security within the application context. Some of these use existing policy constructs,
    such as Apache''s `mod_selinux`, whereas others enhance the policy with custom
    classes to further fine-tune their behavior (as with D-Bus and the `acquire_svc`
    permission).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了几个示例SELinux感知应用程序：这些应用程序能够识别并与SELinux子系统交互，以进一步增强应用程序上下文中的安全性。部分应用程序使用现有的策略构件，例如Apache的`mod_selinux`，而其他应用程序则通过自定义类来增强策略，从而更精细地调整其行为（如D-Bus和`acquire_svc`权限）。
- en: With **Security-Enhanced PostgreSQL** (**SEPostgreSQL**), we get a more elaborate
    example of an SELinux-aware application, which uses multiple additional classes
    within SELinux, as well as labeling its internal database objects to further enforce
    security rules. In this chapter, we will learn how to apply labels within PostgreSQL,
    debug its enforcement rules, associate the right labels with the PostgreSQL resources,
    and show how this label-based security method can be used to augment specific
    security practices within a relational database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**安全增强型 PostgreSQL**（**SEPostgreSQL**），我们可以得到一个更复杂的SELinux感知应用程序示例，该程序使用多个额外的SELinux类，并对其内部数据库对象进行标签化，以进一步强化安全规则。在本章中，我们将学习如何在PostgreSQL中应用标签，调试其执行规则，将正确的标签与PostgreSQL资源关联，并展示这种基于标签的安全方法如何增强关系数据库中的特定安全实践。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introducing PostgreSQL and `sepgsql`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 PostgreSQL 和 `sepgsql`
- en: Understanding SELinux's database-specific object classes and permissions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解SELinux的数据库特定对象类和权限
- en: Using MCS and MLS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MCS 和 MLS
- en: Integrating SEPostgreSQL into a network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将SEPostgreSQL集成到网络中
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3dDcg4Z](https://bit.ly/3dDcg4Z)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下视频，了解代码的实际应用：[https://bit.ly/3dDcg4Z](https://bit.ly/3dDcg4Z)
- en: Introducing PostgreSQL and sepgsql
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 PostgreSQL 和 sepgsql
- en: PostgreSQL is a popular, featureful, and mature relational database management
    system. Like Apache, it also enables a modular extension of its functionalities
    through loadable modules. The module we will investigate is called `sepgsql`,
    PostgreSQL enhances itself with SELinux support for additional access controls,
    offering fine-grained data flow controls based on SELinux policy rules.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL是一个流行的、功能丰富且成熟的关系数据库管理系统。与Apache类似，它也通过可加载模块支持功能的模块化扩展。我们将研究的模块称为`sepgsql`，它为PostgreSQL提供了SELinux支持，以实现额外的访问控制，提供基于SELinux策略规则的细粒度数据流控制。
- en: Please be aware though that `sepgsql` does not implement a full mandatory access
    control system within PostgreSQL, as not all PostgreSQL statements will result
    in a policy check. While it augments the security posture of the PostgreSQL database,
    the module has a few limitations listed in its online documentation, available
    at [https://www.postgresql.org/docs/10/sepgsql.html](https://www.postgresql.org/docs/10/sepgsql.html)
    (adjust the version number in the URL as needed; the referenced document at this
    URL is for PostgreSQL 10, which is the version currently used within CentOS 8
    and used throughout this chapter).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`sepgsql`并没有在PostgreSQL中实现完整的强制访问控制系统，因为并非所有的PostgreSQL语句都会导致策略检查。虽然它增强了PostgreSQL数据库的安全性，但该模块也有一些限制，详见其在线文档，网址为[https://www.postgresql.org/docs/10/sepgsql.html](https://www.postgresql.org/docs/10/sepgsql.html)（如有需要，请根据版本号调整URL；此URL中的参考文档适用于PostgreSQL
    10，这是CentOS 8中使用的版本，也是本章所使用的版本）。
- en: Reconfiguring PostgreSQL with sepgsql
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用sepgsql重新配置PostgreSQL
- en: Before we can install `sepgsql`, we need to have a working PostgreSQL system
    at our disposal. Most Linux distributions have readily available tutorials on
    how to deploy PostgreSQL, which often involves creating the databases associated
    with it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们安装`sepgsql`之前，必须确保有一个可用的PostgreSQL系统。大多数Linux发行版都有现成的教程，指导如何部署PostgreSQL，这通常涉及创建与之关联的数据库。
- en: In this chapter, we will assume that the database itself is available inside
    `/var/lib/pgsql/data`, the default location for a CentOS-based PostgreSQL installation.
    The PostgreSQL configuration files are also located inside this location.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们假设数据库本身位于`/var/lib/pgsql/data`，这是基于CentOS的PostgreSQL安装的默认位置。PostgreSQL的配置文件也位于此位置。
- en: 'To install `sepgsql`, the following steps should be executed:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `sepgsql`，应执行以下步骤：
- en: 'Let''s first see whether the database is functioning properly by logging in
    as the (default) `postgres` superuser, and listing the currently available databases:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先通过以（默认）`postgres` 超级用户身份登录，并列出当前可用的数据库，来查看数据库是否正常工作：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Assuming PostgreSQL is working properly, let's configure it to use the `sepgsql`
    module. This module is part of the contributed modules within PostgreSQL, and
    is maintained by the PostgreSQL community. In CentOS, the `sepgsql` module is
    part of the `postgresql-contrib` package, which can be easily added to the system
    using `yum install postgresql-contrib` if it is not present yet.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设 PostgreSQL 正常工作，接下来我们将配置它使用 `sepgsql` 模块。该模块是 PostgreSQL 中的一个贡献模块，由 PostgreSQL
    社区维护。在 CentOS 中，`sepgsql` 模块属于 `postgresql-contrib` 包，如果系统中尚未安装，可以通过 `yum install
    postgresql-contrib` 命令轻松安装。
- en: 'Edit the `postgresql.conf` file inside `/var/lib/pgsql/data` and search for
    the `shared_preload_libraries` statement. By default, it will be commented out,
    so uncomment it and add `sepgsql` inside:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `/var/lib/pgsql/data` 目录下的 `postgresql.conf` 文件，并查找 `shared_preload_libraries`
    语句。默认情况下，它会被注释掉，因此需要取消注释，并在其中添加 `sepgsql`：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As mentioned, changing this parameter requires restarting the database. We
    will do that later, but first, we will shut down the database as our next steps
    will require an offline database:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，修改此参数需要重新启动数据库。我们稍后会进行，但首先，我们将关闭数据库，因为接下来的操作需要在离线模式下进行：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we need to reconfigure all databases and enable the `sepgsql`-related
    functions. We will cover these functions in the *Using sepgsql specific functions*
    section. To enable the functions, we have to become the `postgres` superuser again,
    and for each database available, we load a specific SQL file:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要重新配置所有数据库并启用与 `sepgsql` 相关的函数。我们将在 *使用 sepgsql 特定函数* 部分讲解这些函数。为了启用这些函数，我们需要再次成为
    `postgres` 超级用户，并且对每个可用的数据库加载特定的 SQL 文件：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s validate whether `sepgsql` is working by starting the PostgreSQL database,
    logging in to PostgreSQL, and asking for our current context:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过启动 PostgreSQL 数据库、登录到 PostgreSQL 并请求当前上下文来验证 `sepgsql` 是否正常工作：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's further configure the database with a test account that we can use to
    validate the `sepgsql` controls.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步配置数据库，创建一个测试账户，用于验证 `sepgsql` 控制：
- en: Creating a test account
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试账户
- en: To validate whether the `sepgsql` controls are working, we should have a test
    account outside of the `postgres` superuser, and a local user that we can map
    to different SELinux contexts. As the SELinux context will heavily decide which
    privileges are associated with a session, we want to be able to show the impact
    of one context compared to the others.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证 `sepgsql` 控制是否生效，我们应该创建一个非 `postgres` 超级用户的测试账户，并且创建一个本地用户，以便将其映射到不同的 SELinux
    上下文中。由于 SELinux 上下文会决定会话所关联的权限，我们希望能够展示不同上下文之间的影响。
- en: 'First, inside PostgreSQL (with the `postgres` superuser), create a test account
    called `testuser`, and allow the account to authenticate with a given password:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 PostgreSQL 中（使用 `postgres` 超级用户），创建一个名为 `testuser` 的测试账户，并允许该账户使用指定密码进行身份验证：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also need to configure the database to allow password-based authentication
    (as the default PostgreSQL setup will use system trust or another means of authentication).
    To accomplish that, edit the `pg_hba.conf` file inside `/var/lib/pgsql/data` with
    the following settings:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要配置数据库以允许基于密码的身份验证（因为默认的 PostgreSQL 配置会使用系统信任或其他身份验证方式）。为此，在 `/var/lib/pgsql/data`
    目录中编辑 `pg_hba.conf` 文件，并进行如下设置：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `pg_hba.conf` file manages the host-based authentication rules for PostgreSQL.
    We update it to allow password-based authentication for the `testuser` account
    (which uses `md5` as an identifier) while allowing the `postgres` superuser to
    continue to authenticate using peer trust.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`pg_hba.conf` 文件管理 PostgreSQL 的基于主机的身份验证规则。我们更新该文件，允许 `testuser` 账户（使用 `md5`
    作为标识符）进行基于密码的身份验证，同时允许 `postgres` 超级用户继续使用对等信任进行身份验证。'
- en: With these changes in place, PostgreSQL allows password-based authentication
    of the `testuser` account both when the user initiates the communication over
    a local, socket-based interaction, as well as when a network-based communication
    is used.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改生效后，PostgreSQL 允许 `testuser` 账户进行基于密码的身份验证，无论是当用户通过本地基于套接字的方式发起通信，还是通过网络通信方式进行连接。
- en: 'We also need to tell the SELinux policy that regular users will be allowed
    to connect to the PostgreSQL service:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要告诉SELinux策略，允许普通用户连接到PostgreSQL服务：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While this would be sufficient for accessing the PostgreSQL service, it is not
    adequate to allow the regular user domain (`user_t`) to interact with `sepgsql`.
    To accomplish that, we need to adjust the SELinux policy so that the `user_t`
    domain is also associated with the `sepgsql_client_type` attribute, and that the
    `user_r` role can have the `sepgsql`-related types active.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这足以访问PostgreSQL服务，但不足以允许常规用户域（`user_t`）与`sepgsql`交互。为了实现这一点，我们需要调整SELinux策略，使得`user_t`域也与`sepgsql_client_type`属性相关联，并且`user_r`角色可以激活与`sepgsql`相关的类型。
- en: 'We do this through a small CIL policy, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个小的CIL策略来实现此操作，如下所示：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is also possible to accomplish this with a reference policy style module,
    as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过参考策略风格模块来完成此操作，如下所示：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Assuming we stick with the CIL-based policy, let''s load the file (that is,
    `local_sepgsql.cil`) as an SELinux policy module:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们继续使用基于CIL的策略，让我们将文件（即`local_sepgsql.cil`）加载为SELinux策略模块：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Don't forget to restart the PostgreSQL service after changing the `pg_hba.conf`
    file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改`pg_hba.conf`文件后，别忘了重启PostgreSQL服务。
- en: Tuning sepgsql inside PostgreSQL
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在PostgreSQL内部调整sepgsql
- en: 'The `sepgsql` module introduces two configuration parameters that can be used
    to tweak `sepgsql` inside PostgreSQL:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepgsql`模块引入了两个配置参数，可以用于调整PostgreSQL内部的`sepgsql`：'
- en: The `sepgsql.permissive` parameter tells PostgreSQL not to enforce the SELinux
    policy rules inside PostgreSQL. This is similar to the permissive state of SELinux
    on the system, but covers the `sepgsql`-related functionality inside PostgreSQL
    alone.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sepgsql.permissive`参数告诉PostgreSQL在PostgreSQL内部不强制执行SELinux策略规则。这类似于SELinux在系统上的宽容状态，但仅涵盖PostgreSQL内部的`sepgsql`相关功能。'
- en: The `sepgsql.debug_audit` parameter tells PostgreSQL to always log the SELinux-related
    decisions, even when they are to allow a statement to be processed. This is similar
    to the `auditallow` statements for SELinux on the system.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sepgsql.debug_audit`参数告诉PostgreSQL始终记录与SELinux相关的决策，即使它们是允许处理某个语句。这类似于系统上SELinux的`auditallow`语句。'
- en: 'It is very important however to understand that `sepgsql` is a user-space object
    manager, as explained in [*Chapter 7*](B16276_07_Final_VK.xhtml#_idTextAnchor216),
    *Configuring Application-Specific SELinux Controls*: the SELinux subsystem in
    the Linux kernel is not used for enforcing the access controls, only `sepgsql`
    is. The only purpose that the SELinux subsystem has is to allow PostgreSQL to
    query the active SELinux policy or obtain current SELinux context information.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，非常重要的一点是要理解，正如在[*第7章*](B16276_07_Final_VK.xhtml#_idTextAnchor216)中解释的那样，`sepgsql`是一个用户空间对象管理器，*配置应用程序特定的SELinux控制*：Linux内核中的SELinux子系统并不用于强制执行访问控制，只有`sepgsql`才负责。SELinux子系统的唯一作用是允许PostgreSQL查询当前的SELinux策略或获取当前的SELinux上下文信息。
- en: Hence, the previous configuration parameters work mostly independently of the
    configuration of the system. While SELinux must be active on the system, it does
    not need to be in enforcing mode to have `sepgsql` enforce the rules inside PostgreSQL,
    nor does a permissive SELinux system make the enforcement of `sepgsql` permissive
    as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，之前的配置参数大多独立于系统的配置工作。虽然SELinux必须在系统上激活，但它不需要处于强制模式才能使`sepgsql`在PostgreSQL内部强制执行规则，系统处于宽容模式也不会使`sepgsql`的强制执行变为宽容模式。
- en: The `sepgsql.debug_audit` parameter does have some relationship with the system
    policy. We can add `auditallow` statements to the SELinux policy to force the
    logging of events even when they are allowed. What the `sepgsql.debug_audit` parameter
    does is force all events to be logged, something useful for troubleshooting `sepgsql`,
    as we will see next.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepgsql.debug_audit`参数与系统策略有一定关系。我们可以在SELinux策略中添加`auditallow`语句，以强制记录即使是被允许的事件。`sepgsql.debug_audit`参数的作用是强制记录所有事件，这对排查`sepgsql`问题非常有用，接下来我们将看到这一点。'
- en: Troubleshooting sepgsql
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排查sepgsql问题
- en: 'Let''s enable the debug statements for an individual session and reinvoke the
    `sepgsql_getcon` function again:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为单个会话启用调试语句，并再次调用`sepgsql_getcon`函数：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you want to enable the configuration for the entire system, you can place
    the configuration inside the `postgresql.conf` file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为整个系统启用此配置，可以将配置放入`postgresql.conf`文件中：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Inside the PostgreSQL logs, we will notice the following information:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostgreSQL日志中，我们将注意到以下信息：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first two lines log the statements that we have executed within the session,
    whereas the third line is the SELinux log event related to the execution of `sepgsql_getcon`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行记录了我们在会话中执行的语句，而第三行是与执行 `sepgsql_getcon` 相关的 SELinux 日志事件。
- en: The event tells us that the `unconfined_t` domain (source context) has attempted
    (and succeeded) to execute the database procedure (as indicated by the `db_procedure`
    class) labeled with the `sepgsql_proc_exec_t` type. The in-database function is
    the `sepgsql_getcon` function within the `pg_catalog` schema.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该事件告诉我们，`unconfined_t` 域（源上下文）尝试（并成功）执行数据库过程（如 `db_procedure` 类所示），该过程标记为 `sepgsql_proc_exec_t`
    类型。数据库中的功能是 `pg_catalog` 模式中的 `sepgsql_getcon` 函数。
- en: 'If a denial occurs, this will result in a similar event in the logs, but will
    also be made visible to the end user that triggered the denial, as PostgreSQL
    will show an error message like so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生拒绝，这将导致日志中出现类似的事件，并且拒绝触发的最终用户将看到错误信息，PostgreSQL 会显示类似以下的错误消息：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Unlike the audit logging executed by, for instance, D-Bus (which results in
    `USER_AVC` events in the regular audit log), `sepgsql` will follow the log configuration
    of the PostgreSQL database itself, so keep a close eye out on this log file (or
    other log targets configured in PostgreSQL) when trying to troubleshoot `sepgsql`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与例如 D-Bus 执行的审计日志（会在常规审计日志中产生 `USER_AVC` 事件）不同，`sepgsql` 将遵循 PostgreSQL 数据库本身的日志配置，因此在尝试故障排除
    `sepgsql` 时，请密切关注该日志文件（或 PostgreSQL 中配置的其他日志目标）。
- en: In this simple example, you might already have noticed that the event references
    a database-specific class (`db_procedure`). In the next section, we will look
    into the various classes, permissions, and types associated with `sepgsql` and
    thus supported by the SELinux policy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的示例中，你可能已经注意到事件引用了一个数据库特定的类（`db_procedure`）。在接下来的部分，我们将深入探讨与 `sepgsql`
    相关的各种类、权限和类型，并因此支持 SELinux 策略。
- en: Understanding SELinux's database-specific object classes and permissions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 SELinux 的数据库特定对象类和权限
- en: 'The `sepgsql` module uses several database-specific SELinux classes to fine-tune
    the policies and access controls. The supported classes can be listed through
    `/sys/fs/selinux/class` or the `seinfo` command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepgsql` 模块使用多个数据库特定的 SELinux 类来精细调控策略和访问控制。可以通过 `/sys/fs/selinux/class` 或
    `seinfo` 命令列出支持的类：'
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'These classes have an obvious relational database meaning: `db_database` is
    for database-related permissions, `db_table` for table permissions, `db_procedure`
    for database procedures, and so on. While not all classes are still supported
    by `sepgsql` (the `db_database` class has no immediate support anymore), most
    do have their usual mapping within the PostgreSQL database.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类具有明显的关系数据库含义：`db_database` 用于与数据库相关的权限，`db_table` 用于表权限，`db_procedure` 用于数据库过程，依此类推。虽然并非所有类都仍然被
    `sepgsql` 支持（`db_database` 类不再直接支持），但大多数类仍然在 PostgreSQL 数据库中具有其常规映射。
- en: Let's see what permissions are supported by `sepgsql` and how this can be used
    to fine-tune access controls within the database.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `sepgsql` 支持哪些权限，以及如何利用这些权限在数据库中精细调控访问控制。
- en: Understanding sepgsql permissions
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 sepgsql 权限
- en: The access controls that `sepgsql` enforces are on top of the discretionary
    access controls already supported by PostgreSQL. Rather than using the privileges
    of the role or user currently acting within the database, the `sepgsql` module
    will use the context associated with the session.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepgsql` 强制执行的访问控制是在 PostgreSQL 已经支持的自主访问控制基础上实现的。与其使用当前在数据库中操作的角色或用户的权限，`sepgsql`
    模块将使用与会话关联的上下文。'
- en: 'As we can use different SELinux contexts for sessions that are authenticated
    using the same database role, we can create distinct access controls within the
    database without associating this with the user account itself. We can, for instance,
    differentiate based on the initialization of the database session: a remote session
    might have a separate context compared to a locally launched session, or the authorizations
    might be unique across different Linux users even when they share the same account
    within the database.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以为使用相同数据库角色认证的会话使用不同的 SELinux 上下文，我们可以在数据库中创建不同的访问控制，而无需将其与用户帐户本身关联。例如，我们可以根据数据库会话的初始化方式进行区分：远程会话可能与本地启动的会话具有不同的上下文，或者即使在数据库中共享相同帐户，不同的
    Linux 用户也可能具有独特的授权。
- en: Important note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: As remote connections require the peer context to be accessible, `sepgsql` requires
    either the use of labeled IPSec, or we need to introduce fallback labeling using
    NetLabel and CIPSO, as seen in [*Chapter 5*](B16276_05_Final_VK.xhtml#_idTextAnchor138),
    *Controlling Network Communications*. We will establish such a mapping in the
    *Integrating SEPostgreSQL in the network* section, after explaining the various
    permission mappings.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于远程连接需要对等方上下文是可访问的，`sepgsql`要求使用带标签的IPSec，或者我们需要通过NetLabel和CIPSO引入回退标签，正如在[*第5章*](B16276_05_Final_VK.xhtml#_idTextAnchor138)中看到的，*控制网络通信*。我们将在解释各种权限映射后，在*将SEPostgreSQL集成到网络中*部分中建立这样的映射。
- en: 'Once logged in, a query on a table will trigger a few checks against the SELinux
    policy:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦登录，对表的查询将触发针对SELinux策略的几项检查：
- en: Any `SELECT`, `INSERT`, `UPDATE`, or `DELETE` statement on a table results in
    a permission check against the `select`, `insert`, `update`, or `delete` permissions
    within the `db_table` class.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对表执行任何`SELECT`、`INSERT`、`UPDATE`或`DELETE`语句都会导致对`db_table`类中的`select`、`insert`、`update`或`delete`权限进行权限检查。
- en: When the `WHERE` clause lists one or more different tables, then the `select`
    privilege for those different tables is checked as well.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`WHERE`子句列出一个或多个不同的表时，还会检查这些不同表的`select`权限。
- en: Furthermore, column-level permissions are checked for each referenced column,
    and this is checked against the permissions within the `db_column` class. Again,
    permission checks against the `select` permission validate the read access, whereas
    the `update` or `insert` permissions reflect the controls to check when the values
    are changed.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还会检查每个引用列的列级权限，并且这会与`db_column`类中的权限进行比较。再次强调，对`select`权限的检查验证了读取访问权限，而`update`或`insert`权限反映了在值发生变化时需要检查的控制。
- en: A more elaborate overview of the supported permissions is available in the PostgreSQL
    `sepgsql` documentation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有关支持的权限的更详细概述，可以参考PostgreSQL的`sepgsql`文档。
- en: Using the default supported types
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用默认支持的类型
- en: The default SELinux policy has several types readily available for use within
    a `sepgsql` setup. Most of the SEPostgreSQL configurations will not deviate from
    these default types, and instead rely on the category- and sensitivity-oriented
    controls that we touched upon in [*Chapter 3*](B16276_03_Final_VK.xhtml#_idTextAnchor071),
    *Managing User Logins*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的SELinux策略有多种类型可以在`sepgsql`设置中直接使用。大多数SEPostgreSQL配置不会偏离这些默认类型，而是依赖于我们在[*第3章*](B16276_03_Final_VK.xhtml#_idTextAnchor071)中提到的基于类别和敏感度的控制，*管理用户登录*。
- en: 'To see what these default types are, what they are used for, and how to assign
    these labels within PostgreSQL, let''s start with creating a new database called
    `db_test`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些默认类型是什么，它们的用途以及如何在PostgreSQL中分配这些标签，我们先从创建一个名为`db_test`的新数据库开始：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we connect to this newly created database and create a simple table,
    called `tb_users`, which has the following columns:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们连接到这个新创建的数据库，并创建一个简单的表，命名为`tb_users`，它有以下列：
- en: The user's ID, named `uid`
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的ID，命名为`uid`
- en: The user's name, named `name`
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的姓名，命名为`name`
- en: The user's email address, named `mail`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的电子邮件地址，命名为`mail`
- en: The user's mailing address, named `address`
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的邮寄地址，命名为`address`
- en: The user's password salt and hash, named `salt` and `phash`
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的密码盐和哈希，分别命名为`salt`和`phash`
- en: Important note
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: The example used is merely an example, meant to show how to approach SELinux
    labels and `sepgsql`. Proper database design and best practices for addressing
    password hashes and other sensitive data are well beyond the scope of this book!
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所使用的示例仅仅是一个示范，旨在展示如何处理SELinux标签和`sepgsql`。适当的数据库设计以及处理密码哈希和其他敏感数据的最佳实践远远超出了本书的范围！
- en: 'As you can imagine, we will be securing some of these columns further: while
    the password hash should obviously be considered very sensitive, we should also
    make sure to properly protect the mail and address fields as this is **Personally
    Identifiable Information** (**PII**), which in many areas of the world is governed
    by specific privacy laws:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想，我们将进一步保护这些列：虽然密码哈希显然应该被视为非常敏感的信息，但我们还应该确保妥善保护邮件和地址字段，因为这些是**个人身份信息**（**PII**），在世界许多地方受特定隐私法律的管辖：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'What is now the label associated with this table? For that, we need to query
    the PostgreSQL internal tables/views, more specifically the `pg_seclabels` one:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个表关联的标签是什么？为此，我们需要查询PostgreSQL的内部表/视图，特别是`pg_seclabels`：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the table has received the `sepgsql_table_t` type and default
    sensitivity (`s0`).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，表已获得 `sepgsql_table_t` 类型和默认敏感度（`s0`）。
- en: '`sepgsql_table_t` is the default type for tables. We usually find this type
    used for general table support and columns. Alongside the `sepgsql_table_t` type,
    the policy has a few other table- and column-oriented types that administrators
    can use to differentiate the controls that `sepgsql` enforces:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepgsql_table_t` 是表的默认类型。我们通常会看到该类型用于一般的表支持和列。除了 `sepgsql_table_t` 类型外，策略还有一些其他表和列相关的类型，管理员可以用来区分
    `sepgsql` 强制执行的控制：'
- en: The `sepgsql_fixed_table_t` type can be used for tables or columns that can
    only be appended to (inserted into) but not updated. This could be for log-related
    tables or audit events where we want to use the `sepgsql` controls to further
    enforce this (beyond the in-database controls that could be used for this as well).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sepgsql_fixed_table_t` 类型可用于只能追加（插入）但不能更新的表或列。这可以用于与日志相关的表或审计事件，我们希望通过 `sepgsql`
    控制进一步加强这一点（超出可以用于此的数据库内控件）。'
- en: The `sepgsql_ro_table_t` type can be used for tables or columns that should
    only be read from (read-only).
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sepgsql_ro_table_t` 类型可用于只能读取（只读）的表或列。'
- en: The `sepgsql_secret_table_t` type can be used for tables or columns that cannot
    be accessed by regular users or sessions, and only by administrative ones. This
    is generally used for tables or columns that are only used through protected and/or
    privileged procedures.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sepgsql_secret_table_t` 类型可用于常规用户或会话无法访问的表或列，只能由管理员访问。这通常用于只能通过受保护和/或特权程序访问的表或列。'
- en: The `unpriv_sepgsql_table_t` type is like the `sepgsql_table_t` type, but specific
    to tables or columns managed by admins or unconfined users that cannot be accessed
    by confined users.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unpriv_sepgsql_table_t` 类型类似于 `sepgsql_table_t` 类型，但特定于由管理员或未受限用户管理的表或列，这些表或列无法被受限用户访问。'
- en: The `user_sepgsql_table_t` type on the other hand is specifically constructed
    for tables or columns managed by confined users. This allows administrators to
    differentiate between user-specific tables and general tables.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，`user_sepgsql_table_t` 类型专门为受限用户管理的表或列而构建。这使得管理员能够区分用户特定的表和一般表。
- en: 'Let''s grant the `testuser` account (full) access to this table and database,
    and add some data to the table:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们授予 `testuser` 账户对该表和数据库的（完全）访问权限，并向表中添加一些数据：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we query the data through our test user, we can see all data added to the
    table:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过测试用户查询数据，我们可以看到所有已添加到表中的数据：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s change the type of the `phash` column to `sepgsql_secret_table_t`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `phash` 列的类型更改为 `sepgsql_secret_table_t`：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This alone however will not prevent the `testuser` user from accessing the
    data. It will depend on how the `testuser` logs in to the database—from which
    context the session will be initiated. If we launch the session from an unconfined
    domain, then the session will still allow access to the data. Let''s instead log
    in from a regular user session (`user_t`), and try to access the data again:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅此一点并不能防止 `testuser` 用户访问数据。这取决于 `testuser` 如何登录到数据库——会话是从哪个上下文启动的。如果我们从未受限域启动会话，那么该会话仍然允许访问数据。我们不如从常规用户会话（`user_t`）登录，并再次尝试访问数据：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Even though the user has all the privileges within the database, we notice
    that the policy has prevented access. We can, however, query the columns not marked
    as `sepgsql_secret_table_t`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 即使用户在数据库中拥有所有权限，我们仍然注意到策略阻止了访问。然而，我们可以查询那些未标记为 `sepgsql_secret_table_t` 的列：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As the `phash` column is now marked as `sepgsql_secret_table_t`, we would still
    want the regular database user to be able to query if a hash matches the hash
    in the database, or set a new hash. This allows the database user to manage the
    accounts without easily leaking the password hashes. We do this through functions,
    which we will describe next.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `phash` 列现在被标记为 `sepgsql_secret_table_t`，我们仍然希望常规数据库用户能够查询哈希值是否与数据库中的哈希值匹配，或者设置新的哈希值。这使得数据库用户可以在不轻易泄漏密码哈希的情况下管理账户。我们通过函数实现这一点，接下来我们将描述这些函数。
- en: Creating trusted procedures
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建受信任的过程
- en: PostgreSQL supports functions and procedures to facilitate isolating or combining
    actions within the database or on the data in a more structured and managed way.
    Procedures are allowed to do transactional updates in the database, but do not
    return a value by themselves. Functions return a value, but are not allowed to
    do transactional updates. In our example, we will create two functions, one to
    compare a hash with the stored hash (but without showing the stored hash to the
    database user) and another to update the stored hash.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 支持函数和过程，以更结构化和可管理的方式促进数据库内或数据上的操作的隔离或组合。过程允许在数据库中进行事务更新，但自身不返回值。函数返回值，但不允许进行事务更新。在我们的示例中，我们将创建两个函数，一个用于将哈希与存储的哈希进行比较（但不将存储的哈希显示给数据库用户），另一个用于更新存储的哈希。
- en: Informational note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 信息提示
- en: While we should be using procedures for the second function, not all PostgreSQL
    versions in use today support them. Support for procedures has only been included
    from PostgreSQL version 11 onward, whereas our examples use PostgreSQL 10.6, as
    that is the current version supported by CentOS 8.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们应该为第二个函数使用过程，但并非所有今天使用的 PostgreSQL 版本都支持它们。支持过程的功能仅从 PostgreSQL 版本 11 开始引入，而我们的示例使用
    PostgreSQL 10.6，因为那是 CentOS 8 支持的当前版本。
- en: 'Let''s first create the two functions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来创建这两个函数：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We introduce a regular expression in the function to sanitize the input as we
    will be marking these functions as trusted later, and we do not want the functions
    to be a jumping ground for activities such as SQL injection.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数中引入了正则表达式来清理输入，因为我们稍后会将这些函数标记为受信任的，我们不希望这些函数成为SQL注入等攻击的跳板。
- en: 'Once the functions are defined, authorized users can use them to access the
    more protected data. Of course, we need to properly label these functions. In
    the default SELinux policy, the following types are available to deal with procedures
    and functions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了这些函数，授权用户可以使用它们来访问更多受保护的数据。当然，我们需要正确标记这些函数。在默认的 SELinux 策略中，以下类型可用于处理过程和函数：
- en: '`sepgsql_proc_exec_t` is the type to assign to regular functions or procedures.
    Once executed, the procedure will run within the current context of the user,
    so no transition will occur.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sepgsql_proc_exec_t` 是分配给常规函数或过程的类型。执行后，过程将在用户的当前上下文中运行，因此不会发生转换。'
- en: '`sepgsql_trusted_proc_exec_t` is the type to assign to trusted procedures or
    functions. Once executed, these functions will run in the `sepgsql_trusted_proc_t`
    domain, which has access to more privileged types such as `sepgsql_secret_table_t`.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sepgsql_trusted_proc_exec_t` 是分配给受信任的过程或函数的类型。执行后，这些函数将在 `sepgsql_trusted_proc_t`
    域内运行，该域具有访问更多特权类型的权限，例如 `sepgsql_secret_table_t`。'
- en: '`sepgsql_ranged_proc_exec_t` is the type to assign to a trusted procedure or
    function, but with an additional privilege: ranged procedures are allowed to change
    the current sensitivity. Ranged procedure privileges are useful to assign to a
    function or procedure that can access columns labeled with a category that the
    current context would not be able to access otherwise. Once executed, these functions
    and procedures will run in the `sepgsql_ranged_proc_t` domain.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sepgsql_ranged_proc_exec_t` 是分配给受信任的过程或函数的类型，但它有一个额外的权限：允许范围过程改变当前的敏感性。范围过程权限对于可以访问当前上下文无法访问的类别标签列的函数或过程很有用。执行后，这些函数和过程将在
    `sepgsql_ranged_proc_t` 域内运行。'
- en: User-managed procedures can be labeled with `unpriv_sepgsql_proc_exec_t` (for
    unconfined users) and `user_sepgsql_proc_t` (for confined users). These procedures
    and functions will continue to run in the user domain itself.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户管理的过程可以标记为 `unpriv_sepgsql_proc_exec_t`（对于未受限用户）和 `user_sepgsql_proc_t`（对于受限用户）。这些过程和函数将继续在用户域内运行。
- en: 'To get the currently assigned label for the function, use the `LIKE` statement
    as the functions are defined (in the `objname` column) with variables in their
    name. As such, they are not always that obvious to immediately select:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前分配给函数的标签，可以使用 `LIKE` 语句，因为函数在定义时（在 `objname` 列中）包含了变量，因此它们并不总是那么显而易见，无法立即选择：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s mark these functions as trusted:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些函数标记为受信任的：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With these labels in place, the database user can execute the appropriate checks
    and changes even though the user has no access to the `phash` column itself:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些标签，数据库用户即使无法访问 `phash` 列本身，也可以执行适当的检查和更改：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Of course, preventing unauthorized users from accessing sensitive data is not
    something that PostgreSQL cannot do without `sepgsql`. PostgreSQL can have procedures
    and functions marked as running with the privileges of the owner of the function
    or procedure, rather than the executing session. What `sepgsql` provides is another
    means to accomplish this, or offer data protection through other security models.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，防止未授权用户访问敏感数据并不是PostgreSQL在没有`sepgsql`的情况下无法做到的事。PostgreSQL可以将过程和函数标记为以函数或过程所有者的权限而非执行会话的权限运行。`sepgsql`提供的是另一种实现此功能的方式，或者通过其他安全模型提供数据保护。
- en: For instance, in our example, the in-database permissions of the `testuser`
    account are still applicable, we are not granting the `testuser` account other
    privileges or escalating its privileges to a higher set – instead, we are using
    the SELinux labels and context information to additionally filter privileges.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的示例中，`testuser`账户的数据库内权限仍然适用，我们并没有为`testuser`账户授予其他权限或将其权限提升到更高的级别——相反，我们是使用SELinux标签和上下文信息来进一步过滤权限。
- en: Using sepgsql-specific functions
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用sepgsql特定的函数
- en: 'The `sepgsql` PostgreSQL module adds a handful of functions that we can use
    to interact with the labeling within the database:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepgsql` PostgreSQL模块添加了一些可以用来与数据库内标签进行交互的函数：'
- en: With `sepgsql_getcon()`, we can obtain the current context for the session.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sepgsql_getcon()`，我们可以获取当前会话的上下文。
- en: With `sepgsql_setcon()`, we can change the context of the current session, provided
    that the current context has the permissions to do so, of course.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sepgsql_setcon()`，我们可以更改当前会话的上下文，前提是当前上下文具有执行此操作的权限。
- en: With `sepgsql_restorecon()`, all objects within the current database are relabeled
    back to the default setup. The function supports a single argument, which can
    be `NULL`, or be a reference to a file that defines the new defaults.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sepgsql_restorecon()`，当前数据库中的所有对象会重新标记回默认设置。该函数支持一个参数，可以是`NULL`，也可以是定义新默认值的文件引用。
- en: With `sepgsql_mcstrans_in()` and `sepgsql_mcstrans_out()`, we can interact with
    the `mcstrans` daemon (if it is running), translating from a human-readable sensitivity
    range to raw (`_in()`) or vice versa (`_out()`).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sepgsql_mcstrans_in()`和`sepgsql_mcstrans_out()`，我们可以与`mcstrans`守护进程（如果它正在运行）进行交互，将人类可读的敏感度范围转换为原始（`_in()`）或反之（`_out()`）。
- en: These functions are useful when maintaining labels or defining functions that
    have logic included that depends on the context information.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在维护标签或定义依赖于上下文信息的逻辑函数时非常有用。
- en: Using MCS and MLS
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MCS和MLS
- en: The most common use case for enabling the `sepgsql` module is to use **Multi-Category
    Support** (**MCS**) and **Multi-Level Security** (**MLS**) support within SELinux
    to fine-tune access to resources.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 启用`sepgsql`模块的最常见用例是使用**多类别支持**（**MCS**）和**多级安全性**（**MLS**）支持，结合SELinux来细化资源访问控制。
- en: Limiting access to columns based on categories
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于类别限制对列的访问
- en: Suppose we use the range of category numbers from `c900` to `c909` to address
    specific PII datasets, and grant users access to these categories either by granting
    them direct access, or by using specific SELinux contexts to consult this data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用从`c900`到`c909`的类别编号范围来处理特定的PII数据集，并通过直接授予访问权限或使用特定的SELinux上下文来授权用户访问这些类别。
- en: 'Within the database, we could mark the PII-sensitive data with a category number
    within that range:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中，我们可以使用该范围内的类别编号来标记敏感的PII数据：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With the labels applied, a user that does not have access to this category
    will not be able to access the data:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 应用标签后，没有访问该类别权限的用户将无法访问数据：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With the category range for the user set correctly, access to the data is granted:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当为用户正确设置类别范围时，访问数据将被授权：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It is important to understand though that most domains will be allowed to switch
    their category set, as long as it remains within the allowed range:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但是需要理解的是，大多数域都允许切换其类别集，只要它仍然在允许的范围内：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This means that, even when a user session for this user launches with a more
    limited category set (for instance, using the `runcon` command), the user will
    still be able to call `runcon` again to extend the category range, or use the
    `sepgsql_setcon()` function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，即使该用户的会话启动时使用了更有限的类别集（例如，使用`runcon`命令），用户仍然可以再次调用`runcon`以扩展类别范围，或者使用`sepgsql_setcon()`函数：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To remediate this, we need to have the target domain be MCS-constrained.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要使目标域受到MCS约束。
- en: Constraining the user domain for sensitivity range manipulation
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制用户域以操作敏感度范围
- en: 'The SELinux policy always allows reducing the category range, so a range that
    initially includes the `c900` category can always switch to a category range that
    excludes this category. The rules within SELinux that grant domains the privilege
    to reduce their category range use dominance rules, which are basically algorithms
    running mathematical set expressions on the source and target set: if the target
    set is fully enclosed within the source set, then SELinux will allow the range
    transition to occur.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 策略始终允许减少类别范围，因此，最初包含 `c900` 类别的范围可以始终切换到一个排除该类别的范围。在 SELinux 中，授予域减少类别范围特权的规则使用了支配规则，这些规则本质上是运行数学集合表达式的算法：如果目标集合完全包含在源集合中，SELinux
    将允许类别范围的转换。
- en: The policy however also allows for extending the category range (if the range
    remains within the allowed range as defined by the SELinux configuration for the
    user), unless the domain itself is marked as **MCS-constrained**. The default
    MCS-constrained domains are generally those domains used for sandbox usage or
    virtualization, as we will see in [*Chapter 9*](B16276_09_Final_VK.xhtml#_idTextAnchor257),
    *Secure Virtualization*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该策略也允许扩展类别范围（如果该范围仍然在 SELinux 配置中为用户定义的允许范围内），除非该域本身被标记为 **MCS 限制**。默认的 MCS
    限制域通常是那些用于沙箱使用或虚拟化的域，正如我们将在 [*第 9 章*](B16276_09_Final_VK.xhtml#_idTextAnchor257)
    *安全虚拟化* 中看到的那样。
- en: 'However, we can easily add more domains. For instance, to mark the user domain
    as MCS-constrained, load the following CIL policy:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以轻松添加更多的域。例如，要将用户域标记为 MCS 限制，只需加载以下 CIL 策略：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will prevent the `user_t` domain from growing its category range again.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将防止 `user_t` 域再次扩展其类别范围。
- en: Integrating SEPostgreSQL into the network
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 SEPostgreSQL 集成到网络中
- en: When we use the `sepgsql` module in PostgreSQL, all database sessions need to
    have a security context associated with them. While for local communications (which
    use Unix domain sockets) this context is readily available, networked sessions
    (which are the most common) do not automatically have a context set.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 PostgreSQL 中使用 `sepgsql` 模块时，所有数据库会话都需要与之关联一个安全上下文。对于本地通信（使用 Unix 域套接字）来说，这个上下文是容易获取的，但网络会话（最常见的类型）并不会自动设置上下文。
- en: 'If the system does not participate in a labeled networking setup, as we saw
    in [*Chapter 5*](B16276_05_Final_VK.xhtml#_idTextAnchor138), *Controlling Network
    Communications*, interaction with the database will fail:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统没有参与标记的网络设置，正如我们在 [*第 5 章*](B16276_05_Final_VK.xhtml#_idTextAnchor138) *控制网络通信*
    中看到的那样，与数据库的交互将失败：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To resolve this, the recommended approach is to start using labeled IPSec. However,
    we can also use NetLabel to introduce fallback labeling where needed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，推荐的方法是开始使用标记的 IPSec。不过，我们也可以使用 NetLabel 在需要时引入回退标记。
- en: Creating a fallback label for remote sessions
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为远程会话创建回退标签
- en: With Linux's NetLabel and CIPSO support (as seen in [*Chapter 5*](B16276_05_Final_VK.xhtml#_idTextAnchor138),
    *Controlling Network Communications*) we can introduce both fallback labeling
    (associating a label based on the source address), as well as use full labeling
    for localhost communication.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Linux 的 NetLabel 和 CIPSO 支持（如在 [*第 5 章*](B16276_05_Final_VK.xhtml#_idTextAnchor138)
    *控制网络通信* 中看到的那样），我们可以同时引入回退标签（基于源地址关联标签），并且为本地通信使用完整的标签。
- en: With full, local label support, NetLabel can pass the source context to the
    target if all this communication solely traverses over the loopback device (as
    such communication does not leave the system, allowing NetLabel to trace and support
    the flow from end to end and provide context information to the receiving service).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完整的本地标签支持，NetLabel 可以将源上下文传递给目标，如果所有的通信仅在回环设备上进行（因为此类通信不会离开系统，允许 NetLabel
    跟踪并支持端到端的流动，并向接收服务提供上下文信息）。
- en: 'Let''s create the CIPSO definition for local labeling:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为本地标签创建 CIPSO 定义：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We now create a default context for communication coming from the network (over
    the `eth0` interface and the `192.168.100.1/24` network). It is this context that
    we will see when connecting to the PostgreSQL server over the network:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在为来自网络的通信（通过 `eth0` 接口和 `192.168.100.1/24` 网络）创建一个默认上下文。正是这个上下文我们会在通过网络连接到
    PostgreSQL 服务器时看到：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can now remove the default mapping rules, and add mapping rules for the
    different communication types:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以删除默认映射规则，并为不同的通信类型添加映射规则：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The mappings we created will allow unlabeled communication for everything (but
    keep in mind that we have a specific label defined for communication coming from
    `192.168.100.0/24`) and loopback-based full labeling on the localhost.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的映射将允许一切通信不带标签（但请记住，我们已为来自`192.168.100.0/24`的通信定义了特定标签），并在本地主机上进行基于回环的完整标签设置。
- en: Tuning the SELinux policy
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整SELinux策略
- en: 'Next to the labeling configuration, we might also need to further fine-tune
    the SELinux policy for PostgreSQL. A couple of SELinux booleans are worth mentioning
    here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标签配置外，我们可能还需要进一步微调PostgreSQL的SELinux策略。这里有几个SELinux布尔值值得一提：
- en: The `postgresql_selinux_transmit_client_label` SELinux boolean (disabled by
    default) allows the `postgresql_t` domain to set its own session contexts. The
    PostgreSQL server might want to set its own session context when the server itself
    has database connections to other, remote databases (for instance, using PostgreSQL's
    **Foreign Data Wrapper** (**FDW**) support). When enabled, the client context
    will be passed on to the remote databases as well.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgresql_selinux_transmit_client_label` SELinux布尔值（默认禁用）允许`postgresql_t`域设置其自己的会话上下文。当PostgreSQL服务器与其他远程数据库建立连接时，可能需要设置自己的会话上下文（例如，使用PostgreSQL的**外部数据包装器**（**FDW**）支持）。启用后，客户端上下文也会传递给远程数据库。'
- en: The `postgresql_selinux_unconfined_dbadm` SELinux boolean (enabled by default)
    grants administrative database privileges in `sepgsql` to any unconfined user
    domain.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgresql_selinux_unconfined_dbadm` SELinux布尔值（默认启用）授予任何未限制的用户域在`sepgsql`中的数据库管理员权限。'
- en: The `postgresql_selinux_users_ddl` SELinux boolean (enabled by default) allows
    unprivileged users to run `user_sepgsql_table_t` being used.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgresql_selinux_users_ddl` SELinux布尔值（默认启用）允许非特权用户使用`user_sepgsql_table_t`。'
- en: The `selinuxuser_postgresql_connect_enabled` SELinux boolean (disabled by default)
    allows user domains to connect to the PostgreSQL daemon over the Unix domain sockets.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selinuxuser_postgresql_connect_enabled` SELinux布尔值（默认禁用）允许用户域通过Unix域套接字连接到PostgreSQL守护进程。'
- en: Don't forget to persist the boolean changes (using `setsebool -P`) as otherwise,
    a system reboot will revert the settings back to their default values.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了使布尔值更改持久化（使用`setsebool -P`），否则系统重启后设置将恢复为默认值。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The PostgreSQL database can be extended with SELinux support using the `sepgsql`
    module. The module adds label support to the various objects within a database,
    and checks access permissions between the session context and the target label.
    To obtain the session context, `sepgsql` relies either on purely socket-based
    communication, or labeled networking.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL数据库可以通过`sepgsql`模块扩展SELinux支持。该模块为数据库中的各种对象添加了标签支持，并检查会话上下文与目标标签之间的访问权限。为了获取会话上下文，`sepgsql`依赖于基于套接字的通信或带标签的网络通信。
- en: In this chapter, we learned how to enable the `sepgsql` module and how to troubleshoot
    possible policy issues. We then used the various default types within an example
    database and used these types to show how the access controls in `sepgsql` work.
    We then used SELinux's MCS support to further handle category-based access controls.
    Finally, we integrated PostgreSQL in a network using fallback labeling support.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何启用`sepgsql`模块以及如何排除可能的策略问题。然后，我们在示例数据库中使用了各种默认类型，并用这些类型展示了`sepgsql`中的访问控制如何工作。接着，我们利用SELinux的MCS支持进一步处理基于类别的访问控制。最后，我们在使用回退标签支持的网络中集成了PostgreSQL。
- en: In the next chapter, we will examine secure virtualization within Linux and
    see how SELinux contributes to the isolation of virtual guests.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Linux中的安全虚拟化，并看看SELinux如何帮助隔离虚拟客体。
- en: Questions
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is SEPostgreSQL part of the default PostgreSQL technology?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SEPostgreSQL是默认PostgreSQL技术的一部分吗？
- en: What else needs to be additionally enabled before `sepgsql` can be used properly?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sepgsql`能够正常使用之前，还需要启用哪些其他设置？
- en: How do you set or query the labels on database objects?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何设置或查询数据库对象上的标签？
- en: Why are the `sepgsql` decision events not available in the system audit log?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么`sepgsql`决策事件没有出现在系统审计日志中？
