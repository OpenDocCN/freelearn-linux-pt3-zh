- en: '*Chapter 12*: Using Arguments and Functions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：使用参数和函数'
- en: Whenever we are trying to program any kind of application or a script in any
    programming language, we should always try to make our code modular and easily
    maintainable. The thing that is going to help us a lot in this aspect of creating
    scripts is a concept known as a **function**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们尝试用任何编程语言编写任何类型的应用程序或脚本时，我们应该始终尽量使我们的代码模块化，并且容易维护。在创建脚本的这一方面，帮助我们很多的概念是**函数**。
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Using custom functions in shell script code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在shell脚本中使用自定义函数
- en: Passing arguments to a function
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将参数传递给函数
- en: Local and global variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部和全局变量
- en: Working with returns from a function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理函数的返回值
- en: Loading an external function to a shell script
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将外部函数加载到shell脚本中
- en: Implementing commonly used procedures via functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过函数实现常用过程
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For these recipes, we''re going to use a Linux machine. We can use any `cli1`
    VM as it''s the most convenient to use, seeing that it''s a **command-line interface**
    (**CLI**)-only machine. So, all in all, we need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些食谱，我们将使用一台Linux机器。我们可以使用任何`cli1`虚拟机，因为它是最方便使用的，因为它仅是**命令行界面**（**CLI**）机器。所以，总的来说，我们需要以下内容：
- en: A VM with Linux installed—any distribution (in our case, it's going to be **Ubuntu
    20.02**).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了Linux的虚拟机——任何发行版（在我们的案例中，将使用**Ubuntu 20.02**）。
- en: A bit of time to digest the complexities of using the VI(m) editor. Nano is
    less complex, therefore it's going to be easier to learn about that one.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花点时间消化使用VI(m)编辑器的复杂性。Nano更简单，因此它会更容易学习。
- en: So, start your VM, and let's get cracking!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，启动你的虚拟机，开始吧！
- en: Using custom functions in shell script code
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在shell脚本中使用自定义函数
- en: Up to this point, all we did was create very simple scripts that had a few commands
    at most. This is going to be most of your scripts since a lot of work that is
    solved by scripting is the simple elimination of repetitive tasks. In this chapter,
    we are going to work with functions as a way of creating modules of code in your
    script. Their main purpose is going to be to avoid repetitive blocks of code in
    your scripts, further simplifying the scripts themselves.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的只是创建非常简单的脚本，最多只有几个命令。这将是你大多数脚本的样子，因为通过脚本解决的许多问题都是简单地消除重复的任务。在本章中，我们将通过函数来创建脚本中的代码模块。它们的主要目的是避免脚本中重复的代码块，进一步简化脚本本身。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: When it comes to functions, Bash is a little bit strange. Things you may know
    about functions from other languages will look similar in `bash` but at the same
    time, completely different. We are going to start with how a function is defined.
    To make matters confusing from the very start, `bash` uses two very similar notations,
    one that looks more like something you would find in other languages, and another
    that is more in line with the rest of the `bash` syntax.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 说到函数，Bash有点奇怪。你可能从其他语言中了解的函数，在`bash`中看起来相似，但又完全不同。我们将从如何定义函数开始。为了让事情从一开始就变得复杂，`bash`使用了两种非常相似的表示方法，一种看起来更像是你在其他语言中会看到的，另一种则更符合`bash`的语法规则。
- en: Before we even mention them, have in mind that there is no difference in functionality
    or anything else in the way functions are defined—we can use either of them with
    the exact same results.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们提到它们之前，请记住，函数的定义在功能或其他方面没有任何区别——我们可以使用它们中的任何一个，结果是完全相同的。
- en: The syntax of the first definition looks like something you would see in any
    programming language. There are no keywords—we simply specify the name of the
    function followed by two normal brackets, and then define a command block that
    makes up the function in curly brackets.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个定义的语法看起来像是你在任何编程语言中都会看到的。没有关键字——我们只是指定函数的名称，后跟两个普通括号，然后在大括号中定义构成函数的命令块。
- en: 'There is a big difference between `bash` and almost every programming language
    out there, though. Usually, brackets in any language serve to pass arguments or
    parameters to the function. In `bash`, they are always empty—their only purpose
    is to define a function. Parameters are passed in a completely different way:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`bash`和几乎所有其他编程语言之间有一个很大的区别。通常，在任何语言中，括号用于将参数传递给函数。而在`bash`中，它们始终是空的——它们唯一的作用是定义一个函数。参数是通过完全不同的方式传递的：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another way to define a function is more in line with the way `bash` usually
    works. There is a reserved word, `function`; so, in order to define a function,
    we simply do this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 定义函数的另一种方式更符合`bash`的常规方式。这里有一个保留字`function`；因此，为了定义一个函数，我们只需这样做：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This version is more likely to remind you that arguments are provided in a different
    way, but that is probably the only difference between the two.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本更可能提醒你，参数是以不同的方式提供的，但这可能是两者之间唯一的区别。
- en: A function must be defined before we can use it. This is completely logical
    since the shell runs every line one by one and, to understand a command, has to
    have it defined as either an internal command, an external command, or a function.
    Unlike some other languages, arguments and return values are not defined in advance—or,
    to be more precise, are not defined at all.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数必须在使用之前定义。这是完全合乎逻辑的，因为Shell是逐行执行每条命令的，要理解一条命令，必须先定义它是内部命令、外部命令还是函数。与其他一些编程语言不同，参数和返回值不会预先定义——或者更准确地说，根本不定义。
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: As always, we are going to start with a `hello world` script, but with a little
    twist. We are going to use our `echo` command inside a function, and the main
    part of the script is going to run this function. We are also going to create
    an alternative version of our function just to show that both ways to define a
    function work the same.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将从一个`hello world`脚本开始，但会做一些小小的改变。我们将在一个函数内使用`echo`命令，并且脚本的主要部分将运行这个函数。我们还将创建一个函数的替代版本，旨在展示两种定义函数的方式是等效的。
- en: 'There are a couple of things to notice in this script—when we define a function,
    there is no *right* way to do it; both ways work, but they work differently. We
    prefer using the format that explicitly mentions the `function` keyword since
    it immediately draws attention to this being a definition of a function, but this
    is just our preference—you can use whichever format you like:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中有几点需要注意——当我们定义函数时，并没有*唯一正确*的方式；两种方式都可以使用，但它们的工作方式不同。我们倾向于使用明确包含`function`关键字的格式，因为这样可以立即引起注意，表明这是一种函数定义，但这只是我们的个人偏好——你可以使用任何你喜欢的格式：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we run the script, we can see that both our functions behave exactly the
    same:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行脚本时，我们可以看到两个函数的表现完全相同：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we are going to create an example that makes much more sense. There are
    going to be a lot of scripts that will require you to output things to the screen
    or into a file. Some parts of the output are going to be repeated over and over—a
    task that is exactly designed for a function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个更有意义的示例。许多脚本都需要你将内容输出到屏幕或文件中。输出的某些部分会反复出现——这是函数特别适合的任务：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What our function did is create a header for our output. When we learn to pass
    arguments to functions, we are going to use this trick a lot, especially when
    we need to output formatted text into logs or when we have a large block of text
    with a few variables that we need to fill in.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数所做的工作是为输出创建一个头部。当我们学习如何向函数传递参数时，我们将经常使用这个技巧，特别是当我们需要将格式化的文本输出到日志中，或者当我们有一大块文本，并且需要填入几个变量时。
- en: How it works…
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Functions are parts of the code that `bash` reproduces whenever we reference
    our function inside a script. Their purpose is primarily geared toward creating
    scripts that are easier to read and debug. There is another reason to use functions:
    avoiding errors in code. If we need to reuse parts of the code in different parts
    of the script, we can always copy and paste it, but that creates a large possibility
    that we will introduce bugs into the script.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是`bash`中重复执行的代码块，每当我们在脚本中引用它们时，它们就会被重新执行。它们的主要目的是使脚本更易读、更易调试。使用函数的另一个原因是：避免代码错误。如果我们需要在脚本的不同部分重用某些代码，我们可以直接复制和粘贴，但这可能会引入错误，导致脚本出现bug。
- en: See also
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '[https://www.shell-tips.com/bash/functions/](https://www.shell-tips.com/bash/functions/)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.shell-tips.com/bash/functions/](https://www.shell-tips.com/bash/functions/)'
- en: '[https://tldp.org/LDP/abs/html/complexfunct.html](https://tldp.org/LDP/abs/html/complexfunct.html)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://tldp.org/LDP/abs/html/complexfunct.html](https://tldp.org/LDP/abs/html/complexfunct.html)'
- en: Passing arguments to a function
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向函数传递参数
- en: We started demonstrating what a function looks like by showing you a simple
    script, the simplest we could create. We still haven't defined how to *talk* to
    your function, and we still don't know how to give a function some parameters
    or arguments and get something in return. In this recipe, we are going to fix
    that.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过展示一个简单的脚本来开始演示函数的样子，这是我们能创建的最简单的脚本。我们仍然没有定义如何*与*函数进行交互，也不知道如何给函数传递参数或参数并获得返回结果。在这个配方中，我们将解决这个问题。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Since we mentioned arguments, we need to talk a little about them. `bash` treats
    arguments in functions the same as it does in the script itself—arguments become
    local variables inside the function block. To return a value, we also do almost
    exactly the same as when we need to deal with the whole script—we simply return
    a value from our function block and then read it inside the main script body.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们提到了参数，我们需要稍微谈一下它们。`bash`在函数中的参数处理与在脚本本身中处理参数相同——参数在函数块内部变成局部变量。为了返回一个值，我们几乎是采用与处理整个脚本时相同的方式——我们仅仅从函数块中返回一个值，然后在主脚本体内读取它。
- en: Remember when we said you can reference arguments that were given to your script
    when it was initially called, and that we used variables called `$1`, `$2`, `$3`,
    and so on to get the first, second, third, and other parameters that were in the
    command line? The exact same thing applies to functions. In this case, we use
    the same variable names as when referencing arguments given to our function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们说过你可以引用最初调用脚本时传递给脚本的参数吗？我们使用了名为`$1`、`$2`、`$3`等的变量来获取命令行中的第一个、第二个、第三个等参数吗？在函数中也是如此。此时，我们使用与引用传递给函数的参数时相同的变量名。
- en: How to do it…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In order to send two parameters to a simple function that will display them,
    we would use something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向一个简单的函数发送两个参数并显示它们，我们可以使用类似下面的方式：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What happens when we try to run this script is that our arguments get passed
    in a way that we expect, one after the other, and then our function outputs them:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试运行这个脚本时，参数会按我们预期的顺序逐个传递，然后我们的函数会输出它们：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You may wonder how our scripts are going to handle arguments that are given
    to the script, compared to arguments we pass to the function. The short answer
    is that variables named `$1` and so on have a value that is local to the function
    and is defined by arguments we passed to the function. Outside of the function
    code block, these variables have the value of the arguments passed to the script.
    The long version of the answer is going to be in the next recipe and is called
    local and global variables. Using arguments is nothing but a special case of declaring
    a local variable; arguments that we pass simply become a local variable in the
    function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道我们的脚本如何处理传递给脚本的参数，与我们传递给函数的参数相比有何不同。简短的回答是，名为`$1`等的变量具有函数局部的值，并且由我们传递给函数的参数定义。在函数代码块外部，这些变量的值则是传递给脚本的参数。详细的答案将在下一个配方中说明，这涉及局部变量和全局变量的概念。使用参数其实就是声明局部变量的一种特殊情况；我们传递的参数会在函数内变成局部变量：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The reason we are changing the order of the arguments is to show the order
    in which arguments are passed to the function and to make sure that we are not
    using the arguments we passed to the script in the function since they have the
    same name. What this script will do is get two arguments from the command line,
    reverse them, and then give them in reversed order as arguments to our function.
    The function is simply going to output them:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改参数顺序的原因是为了展示参数传递给函数的顺序，并确保我们不会在函数中使用传递给脚本的参数，因为它们的名字相同。这个脚本将从命令行获取两个参数，交换它们的顺序，然后将它们作为参数传递给我们的函数。函数将简单地输出它们：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What happened here is also what we expected. Now, we are going to check one
    more thing that can be confusing to some people. Is the function even aware that
    some arguments are passed to the script or are the arguments strictly local? In
    order to check that, we are going to ignore whatever was in the script command
    line, and we are going to pass a pair of hardcoded strings to the function. If
    `bash` is behaving like we think it is, our script will output the hardcoded values.
    If the variables named `$1` and `$2` are set to values from the command line and
    they persist in the function, we should see that value in our `echo` statement.
    What we are going to do is create a `functionarg3.sh` file containing the following
    code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情也正如我们所预期的那样。接下来，我们将检查一个可能让一些人感到困惑的事情。函数是否知道一些参数被传递给了脚本，还是这些参数严格是局部的？为了检查这一点，我们将忽略脚本命令行中的内容，并向函数传递一对硬编码的字符串。如果`bash`像我们预期的那样工作，我们的脚本将输出这些硬编码的值。如果命名为`$1`和`$2`的变量被设置为命令行中的值，并且这些值在函数内仍然存在，我们应该能在`echo`语句中看到这些值。我们将创建一个`functionarg3.sh`文件，包含以下代码：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we are going to run it and check what happened:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将运行它并检查发生了什么：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see that our assumption was correct and that the arguments given to the
    function always take precedence.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的假设是正确的，传递给函数的参数总是优先于其他内容。
- en: The next thing that we are going to do is show you how to handle simple operations
    using functions. Operations that can be done on variables is something we covered
    elsewhere in this book, but here, we are going to use an example we haven't used
    yet. We are simply going to add two arguments from the command line together.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的是展示如何使用函数处理简单的操作。关于可以对变量执行的操作，我们在本书的其他部分已有涉及，但在这里，我们将使用一个之前没有用过的例子。我们将简单地将命令行中的两个参数相加。
- en: 'In order to do that, we are passing arguments from the command line into our
    function and then using `echo` to output the result of the calculation. Part of
    the function used to get the result is also very interesting since it reminds
    us that we have to explicitly use a function to add two numbers in order to do
    that. If we try to add variables together, we are going to end up creating a string—something
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将从命令行将参数传递给函数，然后使用`echo`输出计算结果。用于获取结果的函数部分也非常有趣，因为它提醒我们，必须显式使用一个函数来加两个数字。否则，如果我们尝试将变量相加，最终会得到一个字符串——像这样：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is the final version incorporated into our script:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终版本，已被纳入我们的脚本中：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that in this example, we are using a new variable inside a function to
    add the numbers and then outputting the value of this variable as the result.
    This is a better way to do this than directly doing the operation in the output
    itself—code that uses these temporary variables is always easier to read and understand
    than trying to find and understand variables embedded into output strings.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个例子中，我们在函数内部使用一个新变量来加数字，然后将该变量的值作为结果输出。这比直接在输出中进行操作要好得多——使用这些临时变量的代码总是比试图查找和理解嵌入到输出字符串中的变量更容易阅读和理解。
- en: How it works…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The next thing we want to show is a nifty little feature that is not so common
    in most programming languages. Since `bash` treats arguments in the function the
    same way as it treats arguments to the script and uses the same logic to turn
    these arguments into variables inside the function, we can actually send multiple
    arguments to the function without defining their number in advance. Of course,
    our function needs to be able to understand something such as this.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们想展示的是一个很有趣的小功能，这个功能在大多数编程语言中并不常见。由于`bash`在函数中处理参数的方式与处理脚本中的参数相同，并且使用相同的逻辑将这些参数转化为函数内部的变量，因此我们实际上可以在不预先定义参数数量的情况下向函数传递多个参数。当然，我们的函数需要能够理解类似这样的东西。
- en: See also
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[https://linuxize.com/post/bash-functions/](https://linuxize.com/post/bash-functions/)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://linuxize.com/post/bash-functions/](https://linuxize.com/post/bash-functions/)'
- en: '[https://linuxhint.com/create-bash-functions-arguments/](https://linuxhint.com/create-bash-functions-arguments/)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://linuxhint.com/create-bash-functions-arguments/](https://linuxhint.com/create-bash-functions-arguments/)'
- en: Local and global variables
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地变量和全局变量
- en: When it comes to declaring any variable in a script—or for that matter, anywhere
    at all—one crucial attribute for that variable is its scope. By scope, we mean
    *where the variable has the value we declared*. Scope is very important since
    not understanding how it works means that we can get unexpected results in some
    cases.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当在脚本中声明任何变量时——或者更广泛地说，任何地方——对于该变量，一个至关重要的属性就是它的作用域。作用域指的是*变量值被声明的地方*。作用域非常重要，因为如果我们不理解它是如何工作的，就可能在某些情况下得到意外的结果。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: Defining a global scope to our variables is something `bash` does by default,
    without any interaction with us. All variables that are defined are global variables;
    their value is the same in the entire script. If we change the variable value
    by reassigning it (remember that operations on the value do not change the value
    itself), this value changes globally, and the old value is lost.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 定义变量的全局作用域是`bash`的默认行为，不需要我们与之交互。所有定义的变量都是全局变量；它们的值在整个脚本中都是相同的。如果我们通过重新赋值来改变变量的值（记住，对值的操作不会改变值本身），那么这个值会全局变化，旧值将被丢失。
- en: There is another thing we can do when declaring variables, and that is to declare
    them locally. In simple terms, this means that we are explicitly telling `bash`
    that we will use this variable in some limited part of the code and that it needs
    to keep the value just there, not globally in the entire script.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明变量时，我们还可以做另一件事，那就是将其声明为局部变量。简单来说，这意味着我们明确告诉`bash`，我们将在代码的某个有限部分使用这个变量，并且它需要只在这里保存值，而不是在整个脚本中作为全局变量存在。
- en: What are the reasons to declare a local variable? There are a couple of them,
    the most important one being to make sure that we don't change the value of any
    global variable. If a variable is declared locally with the same name as a global
    one, `bash` will create another instance of the variable with the same name and
    will keep track of both values, the global and the local one.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要声明一个局部变量？有几个原因，其中最重要的是确保我们不会更改任何全局变量的值。如果一个变量与全局变量同名并在局部作用域中声明，`bash`将创建该变量的另一个实例，并会分别跟踪全局值和局部值。
- en: Global and local variables and how they work are something that is best explained
    by using an example.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量和局部变量以及它们是如何工作的，最好的解释方法就是使用一个示例。
- en: How to do it…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'The script that we are going to use to show you how this works is something
    that you will find in almost every example on the internet and in any book covering
    the subject. The idea is to create a global variable and then create a local variable
    in the function that is going to have the same name as the global one. The value
    that the global variable has should be different than the local value, and once
    we display that value, we should see that the value changes depending on if we
    are referencing a global or local variable:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的脚本展示如何工作的例子，几乎可以在互联网上的每一个示例中找到，或者在任何涉及该主题的书籍中都会出现。这个示例的思路是创建一个全局变量，然后在函数中创建一个与全局变量同名的局部变量。全局变量的值应该与局部变量的值不同，当我们显示这个值时，应该能够看到根据我们引用的是全局变量还是局部变量，值会有所不同：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we execute this script, we are going to see exactly how variables interact:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行这个脚本，我们将看到变量是如何交互的：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is completely expected—if there are a global variable and a local variable
    with the same name, the local variable will have its own values in the block it
    is defined in; otherwise, a global value will be used.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全预期的——如果存在同名的全局变量和局部变量，局部变量将只在其定义的块中有自己的值；否则，将使用全局值。
- en: We said scripts such as this are common as an example, but what happens if we
    define just the local value? `bash` is different from most other languages since,
    by default, it will not show an error if we mistakenly try to reference a variable
    that is undefined. When debugging scripts, this can be a big problem since an
    undefined variable and a defined variable with no value will, at first, look exactly
    the same when we try to reference them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过像这样的脚本是常见的示例，但如果我们只定义局部变量会发生什么呢？`bash`与大多数其他语言不同，因为默认情况下，如果我们错误地引用了未定义的变量，它不会显示错误信息。在调试脚本时，这可能是一个大问题，因为未定义的变量和没有值的已定义变量在我们尝试引用它们时，乍一看它们是完全一样的。
- en: 'To show this, we are going to make a small modification to our script and just
    remove the first variable definition. This will make our global value undefined—only
    the local value will have an actual value:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这一点，我们将对脚本做一个小修改，只需删除第一个变量定义。这将导致我们的全局值变为未定义——只有局部值才有实际的值：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In any strict programming language, something such as this would create an
    error. In `bash`, things are different:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何严格的编程语言中，类似的做法都会产生错误。但在`bash`中，情况有所不同：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can see that instead of errors, the script just ignores the variable value
    and replaces it with nothing. As we mentioned, even though we are expecting this
    behavior, keep in mind that this can lead to unexpected consequences. Another
    important thing in this script is the local value. We can see that the local variable
    *exists* only in the block of code in which it is defined; defining it will not
    create a global variable, and the value will be lost as soon as the function or
    block of code is executed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，脚本并没有报错，而是忽略了变量的值，并用“空值”替换它。正如我们所提到的，虽然我们预期会出现这种行为，但要注意，这可能会导致一些意想不到的后果。另一个在脚本中重要的点是局部值。我们可以看到，局部变量*只存在*于其定义的代码块中；定义它并不会创建一个全局变量，而且一旦函数或代码块执行完毕，局部值将会丢失。
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Using global variables in scripts can be useful for one more thing—forwarding
    values between functions. This feature of variables is something that can be useful,
    but at the same time, it is something that is dependent on your personal style
    of programming. Using global variables this way is easy—what you do is just declare
    a variable at the start of the script and then change its value whenever you need
    to. Usually, you assign a value before executing a particular function and then
    read the same variable after the function is done. This way, your function only
    needs to change the variable to give you the value that you expect.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中使用全局变量还有一个好处——在函数之间传递值。变量的这一特性是非常有用的，但同时也取决于你个人的编程风格。以这种方式使用全局变量很简单——你只需要在脚本开始时声明一个变量，然后在需要时更改其值。通常，你会在执行特定函数之前赋值，然后在函数执行完毕后读取同一个变量。这样，你的函数只需改变变量，就能给你期望的值。
- en: However, there is a big problem in this otherwise perfectly logical way of using
    global variables. Since you have no way of knowing if the function behaved correctly
    and got to the point where it had to change the value of the variable, you do
    not have any idea if the value itself is what you are expecting. If a function
    fails for any reason, your variable will have the same value you sent to the function,
    leaving you with something that could be wrong.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种看似合理的使用全局变量方式中，存在一个大问题。由于你无法确定函数是否按预期执行，并且是否已经到达需要改变变量值的阶段，你根本无法知道值本身是否符合预期。如果函数因为某些原因失败，变量将保持你传给它的值，导致可能出现错误的情况。
- en: What we are trying to say is that using global variables in this way is to be
    avoided, even though you can do it—the right way to work with functions and passing
    values is by using arguments and returning values by a mechanism we will look
    at in the next recipe.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想说的是，以这种方式使用全局变量应该避免，尽管你可以这样做——正确的方式是通过使用参数并通过一个我们将在下一个示例中讨论的机制来返回值，来处理函数和传递值。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[https://www.thegeekstuff.com/2010/05/bash-variables/](https://www.thegeekstuff.com/2010/05/bash-variables/)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.thegeekstuff.com/2010/05/bash-variables/](https://www.thegeekstuff.com/2010/05/bash-variables/)'
- en: '[https://tldp.org/LDP/abs/html/localvar.html](https://tldp.org/LDP/abs/html/localvar.html)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://tldp.org/LDP/abs/html/localvar.html](https://tldp.org/LDP/abs/html/localvar.html)'
- en: Working with returns from a function
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理函数返回值
- en: We mentioned that it is possible to use global variables to pass values to the
    functions inside a script and to get results back. This is the worst possible
    way to do it. If we need to pass some value to a function, using arguments is
    the way it should be done. The problem that we still have is how to get the results
    back when the function finishes. We are going to solve that in this recipe.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过，可以使用全局变量将值传递给脚本中的函数，并返回结果。这是最糟糕的做法。如果我们需要将某个值传递给函数，使用参数才是正确的方式。我们仍然面临的问题是，如何在函数执行完后获取结果。我们将在本章中解决这个问题。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If nothing else, `bash` is logical and consistent in the syntax it uses. The
    reason we are mentioning this is that when functions return a value, they use
    the exact same mechanism that scripts use when returning a variable—the `return`
    command. Using this command, it is possible for a function to return a value when
    called, but the value can be in the range of numbers between `0` and `255`. There
    is also a possibility to set a global variable just to return a function value—for
    example, if we need to return a string—but try to avoid that since it creates
    code that is difficult to debug. When you are browsing the internet for function
    `return` statements, you may also run into a third solution that uses something
    called *reference passing* or `nameref`. This is a more complex solution that
    you should be aware of, but we are deliberately avoiding it in this recipe since
    it works only on the most recent versions of `bash` (from `4.3` up), and that
    breaks the compatibility and usability of our scripts.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有别的，`bash`在其使用的语法上是逻辑一致的。之所以提到这一点，是因为当函数返回一个值时，它们使用的机制和脚本返回变量时使用的机制完全相同——即`return`命令。通过使用这个命令，函数在被调用时可以返回一个值，但这个值的范围只能在`0`到`255`之间。也有可能设置一个全局变量来返回函数值——例如，如果我们需要返回一个字符串——但尽量避免这样做，因为这会产生难以调试的代码。当你在互联网上浏览函数`return`语句时，你也可能会遇到一种第三种解决方案，这种方案使用了一种叫做*引用传递*或`nameref`的技术。这是一个更复杂的解决方案，你需要了解它，但我们故意在这个例子中避免它，因为它只在`bash`的最新版本（`4.3`及以上）中有效，这会破坏我们脚本的兼容性和可用性。
- en: How to do it…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We''ll show you both ways to return a function, starting with the one we consider
    wrong. The reason that we are even showing you a wrong solution is that you will
    often run into this in different scripts downloaded from the internet, and if
    you are unaware of this method, you will probably be a little bit puzzled at first
    because the variable is usually first defined in the function itself and does
    not exist before the function is first called:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向你展示两种返回函数值的方法，从我们认为错误的方法开始。之所以展示一个错误的解决方案，是因为你在不同的脚本中（尤其是从互联网上下载的脚本）经常会遇到这种情况，如果你不了解这种方法，可能一开始会有点困惑，因为变量通常是在函数内部首次定义的，在函数第一次调用之前并不存在：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What we did is just pass two strings to a function that returned them concatenated.
    Of course, this is silly—we could do that by simply using the expression we used
    in the function. This example is so basic that it doesn't even use any operators.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的就是将两个字符串传递给一个函数，函数返回它们连接后的结果。当然，这样做很傻——我们完全可以仅仅通过函数中使用的表达式来完成这个任务。这个例子如此基础，甚至没有使用任何运算符。
- en: What's important is the way we returned our value. By just assigning a new value
    and therefore creating a global variable named `RESULT`, we got our string, and
    we were able to use `echo` to write it to the screen. Why is this a problem?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回值的方式很重要。通过仅仅赋予一个新值，并因此创建了一个名为`RESULT`的全局变量，我们得到了我们的字符串，并能够使用`echo`将其写入屏幕。为什么这会是个问题？
- en: We have already explained this. What we are doing here is dangerous since we
    have no way of knowing if the function has done what it had to do. The only thing
    we have is the variable called `RESULT` that probably contains the value we expect.
    In this trivial example, we could check the outcome, but that would defeat the
    purpose of having a dedicated function. In order to reduce the uncertainty a little
    bit, there is a small trick that we can do.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解释过这个问题了。我们在这里所做的事情是危险的，因为我们无法知道函数是否完成了它必须做的事情。我们唯一拥有的就是一个名为`RESULT`的变量，它可能包含我们期望的值。在这个简单的例子中，我们可以检查结果，但那样会违背有一个专用函数的目的。为了稍微减少不确定性，我们可以做一个小技巧。
- en: 'Consider this change to the script:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑对脚本做出这样的修改：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What we did is create a conditional output. The format of the condition itself
    should be familiar to you by now—we are using logical functions to either print
    out the result of the function or to print out that the function did not work
    correctly. As a reminder to when we introduced logical operators, what our script
    does in the last line is check for the value of a variable called `$?`. If the
    variable value equals `0`, we print out the result of the function. If the value
    is not zero, we output the error message since we know that our function had an
    error somewhere inside its command block.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是创建一个条件输出。条件本身的格式你现在应该已经熟悉——我们使用逻辑函数来打印函数的结果，或者打印出函数没有正确执行的消息。提醒一下，当我们介绍逻辑运算符时，我们脚本在最后一行做的事情是检查一个名为`$?`的变量的值。如果变量值等于`0`，我们打印函数的结果。如果值不是零，我们输出错误信息，因为我们知道函数的命令块内部某处出了问题。
- en: The reason we can do this is simple—we already said that functions have the
    same way of communicating to the script as the script itself does to the rest
    of the operating system. This includes passing arguments and being able to use
    a `return` statement to return values, but also it means that `bash` sets a variable
    named `?` when the function is finished. When we use it to understand what happened
    to the script (which we already explained), if we check this variable and it has
    a value of `0`, this means that the function finished correctly, or at least that
    the last command in it finished correctly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以能做到这一点很简单——我们已经提到过，函数与脚本之间的通信方式与脚本与操作系统其他部分的通信方式相同。这包括传递参数以及能够使用`return`语句返回值，还意味着`bash`在函数结束时会设置一个名为`?`的变量。当我们用它来理解脚本发生了什么（我们已经解释过），如果我们检查这个变量并且它的值为`0`，这意味着函数正确执行完毕，或者至少最后一条命令正确执行完毕。
- en: 'This is a simple solution to a problem that we shouldn''t create in the first
    place; whenever possible, we should use `return` to get our values. Here''s an
    example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的解决方案，针对我们本不应该一开始就创建的问题；只要可能，我们应该使用`return`来获取我们的值。以下是一个示例：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a much better way if we are sure that our numbers fit into the range
    from `0` to `255`. We are outputting the result of the function, and this is as
    easy as referencing the right variable. We could also check if the value of the
    variable after the execution of the function is `0`, meaning that the function
    behaved correctly, and then output the result.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确保数字在`0`到`255`的范围内，这是一种更好的方式。我们输出函数的结果，操作就像引用正确的变量一样简单。我们还可以检查函数执行后的变量值是否为`0`，这意味着函数正常工作，然后再输出结果。
- en: Another thing you should know is that a function can use the `exit` command.
    By using it, you are telling `bash` to immediately stop what the function is doing
    and exit the function command block. The value that is going to be returned in
    this instance is going to be the error level of the last command that was executed
    before the `exit` command was invoked.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你应该知道的事情是，函数可以使用`exit`命令。通过使用它，你是在告诉`bash`立即停止函数正在执行的操作并退出函数命令块。在这种情况下，将返回的值是执行`exit`命令之前最后一条命令的错误级别。
- en: 'Here''s an example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What is going to get printed is just the first line of output; since we used
    the `exit` statement, the second part of the output will never run:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将要打印的是输出的第一行；由于我们使用了`exit`语句，第二部分输出将永远不会执行：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The main reason why all of this even exists is to enable you to more tightly
    control how functions and, more generally, the order of command execution works
    in your script. `bash` is very basic in the way it approaches this topic, and
    that at the same time makes it versatile. In order to use functions, you only
    need to know how arguments work in scripting—all the variable names and logic
    behind it are the same when applied to functions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切存在的主要原因是为了让你更紧密地控制函数以及更一般来说，脚本中命令执行的顺序。`bash`在处理这个话题时非常基础，这也正是它的多功能性所在。为了使用函数，你只需要了解脚本中参数的工作方式——所有的变量名和背后的逻辑在应用于函数时是相同的。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[https://www.assertnotmagic.com/2020/06/19/bash-return-multiple/](https://www.assertnotmagic.com/2020/06/19/bash-return-multiple/)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.assertnotmagic.com/2020/06/19/bash-return-multiple/](https://www.assertnotmagic.com/2020/06/19/bash-return-multiple/)'
- en: '[https://www.linuxjournal.com/content/return-values-bash-functions](https://www.linuxjournal.com/content/return-values-bash-functions)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.linuxjournal.com/content/return-values-bash-functions](https://www.linuxjournal.com/content/return-values-bash-functions)'
- en: Loading an external function to a shell script
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将外部函数加载到 shell 脚本中
- en: A problem that will often pop up when you need to create more complex shell
    scripts is going to be how to include other code into your script. Once you start
    scripting, you will often create a couple of common functions that you always
    use—things such as opening connections to servers, getting some operations done,
    and other things like that.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要创建更复杂的 shell 脚本时，常见的问题之一就是如何将其他代码包含到脚本中。一旦你开始编写脚本，你通常会创建一些常用的函数——比如打开与服务器的连接，执行一些操作，或者其他类似的操作。
- en: Sometimes, your scripts will have to use a lot of preset variables that are
    defined by the user before they even run the script in order to avoid having to
    type them in each time a script is called.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，为了避免每次脚本被调用时都需要输入变量，你的脚本必须使用许多由用户预先定义的变量，这些变量需要在脚本运行前就设置好。
- en: Of course, the solution to both of these problems can be to simply copy and
    paste the relevant code into your script and to make the user edit the script
    before running it. The reason we should never do this is that each time we copy
    and paste something, we are creating a new version of our code. If we notice an
    error in the code, we need to fix it in all the scripts that reuse it. Luckily,
    there is a better way to solve this problem, and that is to split the script into
    different files and then include them when we need them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，解决这两个问题的方法可以是将相关代码直接复制并粘贴到脚本中，并让用户在运行脚本之前编辑它。我们不应该这样做的原因是，每次复制和粘贴内容时，我们都会创建代码的新版本。如果我们在代码中发现错误，就需要在所有重复使用这段代码的脚本中进行修复。幸运的是，解决这个问题有一个更好的方法，那就是将脚本拆分成不同的文件，然后在需要时引用它们。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is going to be useful in two scenarios that are not necessarily
    mutually exclusive. We already mentioned both of them briefly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案将在两种不一定互斥的场景中非常有用。我们已经简要提到过这两种场景。
- en: The first one is when using external functions. Normally, when creating a script,
    everything is going to be in one file. All the functions, definitions, variables,
    and commands are going to be in one place. This is usually completely fine if
    we are creating something that is specially written to accomplish a particular
    task.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方案是使用外部函数。通常，在创建脚本时，所有内容都会放在一个文件中。所有函数、定义、变量和命令都会集中在一个地方。如果我们只是在创建专门完成特定任务的脚本，这种做法通常完全没问题。
- en: More often than not, we will need to solve something that we already worked
    on before in some other solution. In this case, we usually already have some functions
    ready that can be considered part of the solution.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的是，我们需要解决一些之前在其他解决方案中已经处理过的问题。在这种情况下，我们通常已经有一些可以被认为是解决方案一部分的现成函数。
- en: In complex scripting solutions, you might even use some common things such as
    menus, interfaces, headers, footers, logs, and other things that are exactly the
    same across every script that you make.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的脚本解决方案中，你可能会使用一些通用的功能，比如菜单、界面、页眉、页脚、日志等，这些内容在你创建的每个脚本中都是完全相同的。
- en: Another very common problem is settings that require some setup by the user.
    Large scripts can have server names, ports, filenames, users, and many different
    things that are required for the script to function. You can always put this information
    as arguments into the command line, but that will look bad and will make your
    script prone to errors since the user will have to type a lot of things by hand
    each time scripts are executed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常常见的问题是需要用户进行设置的配置。大型脚本可能会包含服务器名称、端口、文件名、用户以及脚本运行所需的其他许多信息。你可以将这些信息作为命令行参数传递，但这种做法看起来不太好，而且会使脚本容易出错，因为用户每次运行脚本时都必须手动输入大量内容。
- en: A common practice in these circumstances is to put everything in one file as
    variables, and then have the user edit this file as part of the installation process
    for the script. Of course, you can put everything together with the script itself,
    but that will almost certainly mean some user will change something they shouldn't
    have.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一种常见做法是将所有内容作为变量放在一个文件中，然后让用户在脚本的安装过程中编辑此文件。当然，你也可以将所有内容与脚本本身放在一起，但这几乎肯定会导致某些用户更改他们不应该更改的内容。
- en: As always, there is a solution for that.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，解决方案是存在的。
- en: How to do it…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: '`bash` has built-in functionality that enables including different files into
    a script. The idea is pretty simple—there is a *master script file* that gets
    executed as the script itself. In that file are commands that tell `bash` to include
    different files and scripts.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`bash`具有内置的功能，可以将不同的文件包含到脚本中。这个思想很简单——有一个*主脚本文件*，它作为脚本本身执行。在该文件中，有一些命令告诉`bash`包含不同的文件和脚本。'
- en: 'As with everything else, even though this is a pretty easy thing to do, there
    are some things you need to know. The command we are going to use first is `source`.
    Before we explain everything, we are going to create two scripts. The first one
    is going to be the script that the user is going to run, and it is going to look
    like this. Name the file `main.sh`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他事情一样，尽管这是一件非常简单的事情，但你需要了解一些事情。我们首先要使用的命令是`source`。在我们解释所有内容之前，我们将创建两个脚本。第一个是用户将要运行的脚本，它看起来是这样的。将文件命名为`main.sh`：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We are going to run it just to see how the script behaves:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行它，只是为了看看脚本的行为：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The results are what we expected—our current directory is the same as the one
    we ran the script in, and `$SHLVL` is `2` since we ran our script in a separate
    shell (`lvl2`) from the command line (`lvl1`). Our variable is defined as `main`
    and it hasn't changed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 结果正如我们预期的那样——我们当前的目录与我们运行脚本时所在的目录相同，并且`$SHLVL`为`2`，因为我们在与命令行(`lvl1`)不同的独立 shell
    (`lvl2`) 中运行了脚本。我们的变量定义为`main`，并且它没有发生变化。
- en: 'Now, we are going to create our second script and name it `auxscript.sh`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建第二个脚本并命名为`auxscript.sh`：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The biggest thing here is that we are not using the usual `#!/bin/bash` notation
    at the start of the script. This is intentional, as this file is meant to be included
    in other scripts, not run by itself.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最大的问题是我们没有在脚本开始时使用通常的`#!/bin/bash`标记。这是故意的，因为这个文件是为了被包含在其他脚本中，而不是独立运行的。
- en: After that, we are doing more or less the same things as in the main script,
    outputting some text and values, and working with variables.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们做的事情大致与主脚本中一样，输出一些文本和数值，并且操作变量。
- en: The reason we are changing the variable is to show what actually happens inside
    this included part of the file and how it interacts with the main script body.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改变量的原因是为了展示在文件的包含部分实际发生了什么，以及它是如何与主脚本主体交互的。
- en: 'Now, we are going to change the `main.sh` script and add just one line:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更改`main.sh`脚本并只添加一行：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The main thing now is to run the `main.sh` script again:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最主要的事情是再次运行`main.sh`脚本：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Some interesting things happened here. What we can see is that our environment
    variables haven't changed but the test variable did.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了一些有趣的事情。我们可以看到，环境变量没有发生变化，但测试变量却发生了变化。
- en: We are going to explain that, but we are going to do one more thing before that—we
    are going to use another command instead of `source`. A lot of people new to scripting
    tend to confuse the `source` command that we just showed you with executing a
    script. After all, we are including a script inside a script, so those things
    do look similar. We are going to try to do it in our example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解释这一点，但在此之前，我们要做一件事——我们将使用另一个命令，而不是`source`。很多刚接触脚本的人往往会将我们刚刚展示的`source`命令与执行脚本混淆。毕竟，我们是在脚本中包含一个脚本，所以这些东西看起来很相似。我们将尝试在我们的例子中实现这一点。
- en: 'We are going to change a single line inside the main script, but our `aux`
    script is going to stay the same. There are multiple ways in which we can do it,
    but we intentionally chose to run `bash` and run our second script explicitly.
    The reason is simple—other methods require our script to have the executive bit
    set (something we haven''t done) or depend on less readable versions of the same
    thing as just running a command called `exec`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在主脚本中更改一行，但我们的`aux`脚本保持不变。我们可以用多种方式做到这一点，但我们故意选择了运行`bash`并显式地运行第二个脚本。原因很简单——其他方法要求我们的脚本设置执行位（这是我们没有做的），或者依赖于类似于直接运行`exec`命令的较不易理解的版本：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The only thing we have changed is that we are not including the script—we are
    executing it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一改变的就是，我们没有包含脚本——我们在执行它：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can see, however, that this small change created a huge difference in the
    way our script works.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以看到，这个小小的变化在脚本的工作方式上产生了巨大的不同。
- en: How it works…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The last example we did requires quite a lot of explaining, and we need to start
    with how `bash` works.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的最后一个例子需要很多解释，我们需要从`bash`的工作方式开始。
- en: Using the `source` command tells `bash` to go find a file and use its contents
    at the place where we sourced the file. What `bash` does is straightforward—it
    just replaces this line with the entire file we pointed to. All the lines are
    inserted and then executed as if we copy-pasted the entire file into our original
    script.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`source`命令告诉`bash`去查找一个文件并在我们引用该文件的地方使用它的内容。`bash`做的事情很简单——它只是用我们指向的整个文件替换这一行。所有的行都会被插入，然后像我们将整个文件复制粘贴到原始脚本中一样执行。
- en: This is the reason why in our first example nothing changed. Our script started
    running from the main file, continued running commands from the auxiliary file,
    and then returned to the main file to finish the commands that followed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在我们的第一个示例中什么都没有改变的原因。我们的脚本从主文件开始运行，继续从辅助文件运行命令，然后返回主文件执行接下来的命令。
- en: When we changed our `source` for `bash`, we created a completely different scenario.
    By using the `bash` command inside the script, we are telling the shell to start
    another instance and execute the script we are referring to. This means that the
    entire environment is created, and unless we explicitly specify that we need some
    variables in the new environment, they are not going to get exported.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`source`替换为`bash`时，创建了一个完全不同的场景。通过在脚本中使用`bash`命令，我们告诉shell启动另一个实例并执行我们引用的脚本。这意味着会创建整个环境，除非我们明确指定在新环境中需要一些变量，否则这些变量不会被导出。
- en: This is also the reason that our `$SHLVL` variable incremented—since we called
    another shell inside, the shell level had to go up.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是我们的`$SHLVL`变量增加的原因——因为我们在脚本中调用了另一个shell，shell级别必须提高。
- en: Our test variable vanished because we didn't export it, so it had no value before
    being set, and since our environment was created just to run these couple of lines,
    the same variable simply disappeared when the script we called ended.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试变量消失了，因为我们没有导出它，因此它在被设置之前没有值，而且由于我们的环境仅仅是为了运行这几行代码而创建的，因此当我们调用的脚本结束时，同样的变量也消失了。
- en: Remember that executing a script and sourcing it are completely different things,
    and when in doubt, think about what you are trying to do. If you want to execute
    something inside a script such as a regular command, use `bash` or `exec`. If
    you would otherwise copy-paste code from another script, use `source`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，执行脚本和引用脚本是完全不同的事情，当你不确定时，思考你到底想做什么。如果你想像常规命令一样执行脚本中的某个内容，使用`bash`或`exec`。如果你需要从另一个脚本复制粘贴代码，使用`source`。
- en: Before we finish with this recipe, we also need to mention functions. Including
    functions is exactly the same as including any other part of any other script,
    with one important difference. In order for your code to work, you *must* include
    functions at the start of the script or immediately before you try to use said
    functions. If you don't do that, the resulting error is going to be the same as
    if you hadn't defined your function at all.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本教程之前，我们还需要提到函数。包含函数的方式与包含任何其他脚本部分完全相同，有一个重要的区别。为了让代码正常工作，你*必须*在脚本的开头或在尝试使用这些函数之前包含函数。如果没有这样做，结果会是和根本没有定义函数一样，导致错误。
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '[https://bash.cyberciti.biz/guide/Source_command](https://bash.cyberciti.biz/guide/Source_command)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bash.cyberciti.biz/guide/Source_command](https://bash.cyberciti.biz/guide/Source_command)'
- en: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_01.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_01.html)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_01.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_01.html)'
- en: Implementing commonly used procedures via functions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过函数实现常用程序
- en: By this point, we have created a lot of different and very simple scripts that
    more or less used `echo` and a few commands just to show how a particular thing
    in `bash` works. In this recipe, we are going to give you a couple of ideas on
    how to use what we have learned so far.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了很多不同且非常简单的脚本，这些脚本或多或少使用了`echo`和一些命令，仅仅是为了展示`bash`中某个特定功能的工作原理。在本篇教程中，我们将给你一些关于如何使用我们迄今为止学到的内容的想法。
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to create a small script that is going to show you how to easily
    automate the most mundane tasks on any system. The idea here is not to show you
    every task possible, but instead to show you how to tackle the most common problems.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个小脚本，展示如何轻松自动化任何系统中的日常任务。这里的重点不是展示每个可能的任务，而是教你如何解决最常见的问题。
- en: How to do it…
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: Before we even start with the script, we need to go back to the recipes where
    we were explaining how to start writing scripts. What we are talking about are
    the prerequisites and presumptions we are going to make when we create and run
    this script.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写脚本之前，我们需要回到之前的教程，回顾如何开始编写脚本。我们讨论的是当我们创建和运行这个脚本时，我们所做的前提条件和假设。
- en: Every script will have its own prerequisites. These are usually a list of things
    that your script needs to run—either it requires different packages or it needs
    some other condition that has to be met in order for the script to work, such
    as a working database or a working web server.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每个脚本都会有其特定的前提条件。这些通常是脚本运行所需的东西清单——可能是需要不同的包，或者是需要满足某些条件才能使脚本正常工作，例如一个正常工作的数据库或正常工作的Web服务器。
- en: For this one, we are presuming that you have installed a package called `curl`
    and that you are connected to the internet.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，我们假设你已经安装了一个叫做`curl`的包，并且你已经连接到了互联网。
- en: Now, for the presumptions that we are depending on, this script has some commands
    that affect users and groups on the system. This means that in order for that
    part of the script to work, we absolutely need the script to be run either by
    the `root` user or another user who has administrative privileges.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于我们所依赖的假设，这个脚本包含了一些会影响系统用户和组的命令。这意味着，为了使脚本的这一部分正常工作，我们绝对需要脚本由`root`用户或拥有管理员权限的其他用户来运行。
- en: The script also presumes a lot about users and checks only if we have enough
    parameters, not the quality of arguments that were provided. This means that a
    user can give the script a number instead of a string, and the script will happily
    use this as a valid parameter. We will explain how to deal with that when we start
    dissecting the script.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本还假设了很多关于用户的信息，并且只检查我们是否有足够的参数，而不是检查提供的参数质量。这意味着用户可以给脚本提供一个数字而不是字符串，脚本会把它当作有效的参数。我们将在开始解析脚本时解释如何处理这个问题。
- en: As a person responsible for writing scripts, part of your job is to be aware
    of these preconditions and to make sure to address them. There are two ways you
    can do that—the first is by stating what your script expects in some form of document
    that will follow your script.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 作为负责编写脚本的人，你的工作之一是要清楚这些前提条件，并确保处理好这些条件。有两种方法可以做到这一点——第一种是以某种形式在文档中说明你的脚本期望的条件，这个文档会跟随脚本一起发布。
- en: The other thing you can do (and we highly recommend this) is to check for every
    possible condition that you can think of, and if something is wrong, either print
    an error message and stop your script or, if you know what the problem is, try
    to rectify it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以做的另一件事（我们强烈推荐这样做）是检查你能想到的每一种可能的条件，如果出现问题，要么打印错误信息并停止脚本，要么，如果你知道问题所在，尝试修复它。
- en: Examples of things you can solve inside the script are administrator privileges—your
    script can test if it can run, and ask the user to elevate privileges if the permissions
    are too low. You can also test if a particular package is present on the system
    if you see that some command that is not standard fails.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在脚本中解决的一些问题示例是管理员权限——你的脚本可以测试是否能够运行，如果权限不足，它会要求用户提升权限。你还可以测试系统中是否存在特定的包，如果你看到某个非标准命令失败，可以进行检查。
- en: In the end, how you solve problems in your script is going to be up to you and
    your skill level, but before you do anything, remember that when it comes to scripting,
    you need to test everything.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，如何解决脚本中的问题将取决于你和你的技能水平，但在你做任何事之前，记住，编写脚本时你需要测试一切。
- en: 'Now, here''s the actual script:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是实际的脚本：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: This script requires some explaining, and we intentionally did not comment on
    any of it for two reasons. One was that comments would make the script so long
    it would require too many print pages, and the other one was to be able to go
    through it block by block in this explanation without breaking your flow with
    short comments. Having said that, always comment on your scripts!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本需要一些解释，我们故意没有对其进行注释，原因有两个。一个是注释会使得脚本变得过长，导致需要打印太多页，另一个是为了能够在这次解释中逐块讲解，而不会因为短小的注释打断你的思路。话虽如此，记住，脚本中一定要加上注释！
- en: So, our script starts with a function. Considering this function has only one
    line, you may be surprised that we decided to break it into function, but we had
    a point to make.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的脚本从一个函数开始。考虑到这个函数只有一行，你可能会惊讶于我们决定把它拆成一个函数，但我们是有目的的。
- en: Some commands, such as `rsync` or `tar`, for example, have a complicated list
    of switches that are often used. When creating a script, it is sometimes easier
    to put some of those commands into a function to be able to call the function
    without having to remember all the switches every time. This also goes for commands
    that need a lot of parameters that are predetermined when the script is configured.
    Put all of them into a function and then call the function with only the bare
    minimum of arguments.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一些命令，如`rsync`或`tar`，例如，有一长串常用的开关。在创建脚本时，有时将其中一些命令放入函数中，这样就可以在不记住每个开关的情况下调用该函数。对于需要许多预设参数的命令，这种方法也适用。将所有这些参数放入一个函数中，然后只用最基本的参数调用该函数。
- en: Another thing we put into a function is *usage*, a block of text that helps
    the user to run the script, giving them enough information so they don't need
    any other type of help.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将*usage*（用法）放入函数中，它是一个帮助用户运行脚本的文本块，提供足够的信息，让他们无需其他帮助。
- en: If you can, please write more verbose help pages for your script. You can even
    create a `read the help page for more information`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，请为您的脚本编写更详细的帮助页面。你甚至可以创建一个`阅读帮助页面以获取更多信息`。
- en: In this function, we are using the `$0` positional argument in order to output
    the name of the script. Use this way of giving the user help when you are giving
    examples on script usage. Avoid hardcoding the script name because you don't know
    if the user changed the filename of the script, and hardcoded names can then completely
    puzzle them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用了`$0`位置参数来输出脚本的名称。当你在提供脚本使用示例时，使用这种方式来为用户提供帮助。避免硬编码脚本名称，因为你不知道用户是否更改了脚本的文件名，而硬编码的名称可能会让他们完全困惑。
- en: Also, if you are using any special character in your text, use quotation marks;
    otherwise, you may run into errors or, worse, completely unexplainable errors.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你在文本中使用任何特殊字符，请使用引号；否则，可能会遇到错误，或者更糟糕的是，出现完全无法解释的错误。
- en: The next part of our script deals with each individual command. When creating
    a command-line utility such as this, decide in advance whether you are going to
    create a tool that will use *commands* such as this one, *switches* such as -`h`
    or `—something`, or some sort of simple textual interface. There are pros and
    cons for all of these, but in essence, the format that we chose is mostly used
    for scripts that can do multiple tasks one at a time. Switches enable you to introduce
    many parameters to a task, and **user interfaces** (**UIs**) are targeted toward
    inexperienced users. Also, remember that your script may be used from inside other
    scripts, so avoid interfaces that will block that.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的下一部分处理每个单独的命令。在创建像这样的命令行工具时，事先决定你是要创建一个使用*命令*（如这个命令）、*开关*（如-`h`或`—something`）还是某种简单文本界面的工具。这些方法各有优缺点，但从本质上讲，我们选择的格式通常用于可以一次执行多个任务的脚本。开关允许你为任务引入多个参数，而**用户界面**（**UIs**）则面向没有经验的用户。此外，请记住，您的脚本可能会在其他脚本中使用，因此要避免使用会阻碍这一过程的界面。
- en: In the `case` statement, we are checking for a couple of things. First, we are
    testing if the first argument is a valid command. After that, we are checking
    if there are enough arguments for a given command to make sure that we can run
    it without errors. Even with this, we are not doing nearly enough testing for
    the validity of arguments. When reading this, try to add a few more sanity checks
    such as *are the parameters actually valid*, *did the user input a valid parameter
    containing spaces that got divided into multiple strings*, and so on.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`case`语句中，我们检查了几个事项。首先，我们测试第一个参数是否是有效命令。然后，我们检查给定命令是否有足够的参数，以确保可以无误运行。即便如此，我们仍然没有进行足够的参数有效性测试。在阅读时，尝试添加一些其他的合理性检查，比如*参数是否有效*、*用户是否输入了包含空格的有效参数并将其分成了多个字符串*，等等。
- en: 'We are not going into too much detail for individual commands; we are only
    going to mention the one that, in all fairness, looks completely out of place.
    We are, of course, talking about the `weather` command that gives you a weather
    report for your city:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细讨论单个命令；我们只会提到那个看起来完全不合适的命令。我们当然在说的是`weather`命令，它为你提供所在城市的天气报告：
- en: '![Figure 12.1 – wttr.in is one of many interesting services available online'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – wttr.in是许多有趣的在线服务之一'
- en: '](img/Figure_12.1_B16269.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.1_B16269.jpg)'
- en: Figure 12.1 – wttr.in is one of many interesting services available online
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – wttr.in是许多有趣的在线服务之一
- en: Internet is full of useful services, and [wttr.in](http://wttr.in) is definitely
    one of those. If you go to [wttr.in](http://wttr.in) or run `curl wttr.in`, you
    are going to get a weather report for the city that the system thinks you are
    living in. There is some deep magic involved here—the system is going to try to
    guess where you are based on your **Internet Protocol** (**IP**) address, and
    even while having to do that, it is going to give you a pretty accurate forecast
    almost immediately.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网充满了有用的服务，而[wttr.in](http://wttr.in)绝对是其中之一。如果你访问[wttr.in](http://wttr.in)或者运行`curl
    wttr.in`，系统会给你一个关于你所在城市的天气报告。这里面有一些深奥的技术——系统会根据你的**互联网协议**（**IP**）地址来尝试猜测你的位置，甚至在进行这个猜测的过程中，几乎会立即提供一个相当准确的天气预报。
- en: We chose to show you this example on purpose—if you add a city name to the [wttr.in](http://wttr.in)
    link, the system is going to show you the weather in that city, while even trying
    to guess the exact city name. There are a couple of really useful online services
    such as this accessible from the command line, and using some of them means you
    can extend your script in the most unusual ways.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意选择这个例子来展示——如果你在[wttr.in](http://wttr.in)链接后添加一个城市名，系统会显示该城市的天气，甚至会尝试猜测准确的城市名称。像这样的在线服务有不少，可以通过命令行访问，使用其中一些可以让你以最不寻常的方式扩展你的脚本。
- en: At the end of the recipe, note that we are checking for different errors in
    how the script is invoked in three different ways. Always try to anticipate errors
    such as this.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程的最后，注意我们正在检查脚本以三种不同方式调用时可能出现的不同错误。始终尝试预测这类错误。
- en: See also
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The following web page is a must-see if you do anything in the command line:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在命令行中做任何操作，下面的网页是必看的：
- en: '[https://stackify.com/top-command-line-tools/](https://stackify.com/top-command-line-tools/)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://stackify.com/top-command-line-tools/](https://stackify.com/top-command-line-tools/)'
