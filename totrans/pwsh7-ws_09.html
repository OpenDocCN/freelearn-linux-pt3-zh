<html><head></head><body>
		<div id="_idContainer181">
			<h1 id="_idParaDest-180" class="chapter-number"><a id="_idTextAnchor184"/>9</h1>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor185"/>Don’t Repeat Yourself – Functions and Scriptblocks</h1>
			<p>In this chapter, we’re going to look at one of the basic principles of software development and learn how to apply it to save ourselves effort and make our code easier to maintain: <strong class="bold">Don’t Repeat Yourself</strong>, also <a id="_idIndexMarker628"/>known as the <strong class="bold">DRY</strong> principle. In <em class="italic">The Pragmatic Programmer</em>, by Andy Hunt and Dave Thomas, the principle is stated as “<em class="italic">Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.</em>” Some programmers will take this principle to its logical conclusion and have no repeating code anywhere. We’re writing scripts, and so we will apply the principle just as much as is convenient. We will talk about the concept of functions within code. By the end of the chapter, we will have seen how to write functions in our scripts to replace repeating code and learned how doing this makes our scripts easier to adapt and repair. We will also learn about another type of expression that is related to <a id="_idIndexMarker629"/>functions: <strong class="bold">scriptblocks</strong>. Along the way, we will also inevitably have to discuss the concept <a id="_idIndexMarker630"/><span class="No-Break">of </span><span class="No-Break"><strong class="bold">scope</strong></span><span class="No-Break">.</span></p>
			<p>In this chapter, we are going to cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Why do we care about <span class="No-Break">repeating code?</span></li>
				<li>How to turn repeating code into <span class="No-Break">a function</span></li>
				<li>The concept <span class="No-Break">of scope</span></li>
				<li><span class="No-Break">Exploring scriptblocks</span></li>
				<li>Let’s do <span class="No-Break">something useful</span></li>
			</ul>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor186"/>Why do we care about repeating code?</h1>
			<p>The obvious<a id="_idIndexMarker631"/> reason is that it is boring to figure out how to do something in PowerShell and then keep repeating the same lines over and over. For example, back in <a href="B17600_04.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>,<em class="italic"> PowerShell Variables and Data Structures</em>, we discussed objects by referring to <strong class="source-inline">TypeName Imaginary.Bike</strong>. The <strong class="source-inline">Imaginary.Bike</strong> object had three properties: <strong class="source-inline">handlebar</strong>, <strong class="source-inline">wheel</strong>, and <strong class="source-inline">color</strong>. Let’s say we want to write a short script that validates that an imaginary bike has all its properties. It might look something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
$mybike = @{handlebar = "ApeHanger"; color = "Red"; wheel = 15}
if (!($mybike.handlebar)) {
    write-output "this bike has no handlebars"
}
if (!($mybike.wheel)) {
    write-output "this bike has no wheels"
}
if (!($mybike.color)) {
    write-output "this bike has no handlebars"
}
if (!($mybike.gears)) {
    write-output "this bike has no gears"
}</pre>			<p>In the first line, I’m<a id="_idIndexMarker632"/> just defining my imaginary bike. The validation script starts after that. I’ve thrown in a non-existent property, <strong class="source-inline">gears</strong>, just to make sure that the code works. We can see that the script has a lot of <strong class="source-inline">if</strong> statements that do almost exactly the same thing as each other: they check whether an attribute is present and output a message if it is missing. We’re not too bothered about the repetition because we’re only checking four properties. But what if we needed to check 40 or 400?  This is where the DRY principle comes in. We could write a script to do the same thing <span class="No-Break">like this:</span></p>
			<pre class="source-code">
$properties = @('handlebar', 'wheel', 'color', 'gears')
foreach ($property in $properties) {
    if (!($mybike.($property))) {
        write-output "this bike has no $property"
    }
}</pre>			<p>Each property we add from now on just needs a single word added to the <strong class="source-inline">$properties</strong> array, rather than three new lines of code. <span class="No-Break">Great, huh?</span></p>
			<p>We’re not just saving ourselves the effort of typing stuff out twice here, though. We’re also saving ourselves the effort of finding our typing mistakes in possibly hundreds of lines of code. If that <strong class="source-inline">foreach</strong> loop works for one property, it will work for all of them, unless we mistyped the property name when we added it to the <strong class="source-inline">$properties</strong> array. We know exactly where to look if something isn’t working, and so does anyone who needs to troubleshoot our script <span class="No-Break">after us.</span></p>
			<p>The DRY principle doesn’t just refer to excessive code duplication; it can be applied far more widely in software. To quote <em class="italic">The Pragmatic Programmer</em> again, “<em class="italic">Many people took it [DRY] to refer to code only: they thought that DRY means “don’t copy-and-paste lines of source.” […] DRY is about the duplication of knowledge, of intent. It’s about expressing the same thing in two different places, possibly in two totally </em><span class="No-Break"><em class="italic">different ways.</em></span><span class="No-Break">”</span></p>
			<p>Imagine if we had written not just one script but a whole bunch of scripts that worked with imaginary <a id="_idIndexMarker633"/>bikes. Perhaps we run an imaginary bike shop and want a stock control application. We might find we need to refer to imaginary bike properties frequently in those scripts. It may be that we would end up with lists of properties in lots of places. It’s not hard to imagine that those lists might differ. Some might be incomplete. Some might be out of date. If we were to apply DRY to this, then there would be just one list of properties for all the scripts, a single source of truth when it comes to the properties that an imaginary bike might have, and whenever a script needed to refer to the list of properties, this is where they would <span class="No-Break">find them.</span></p>
			<p>To summarize, then, we care about repeating code for <span class="No-Break">three reasons:</span></p>
			<ul>
				<li>We don’t want to write more code than <span class="No-Break">is necessary.</span></li>
				<li>We want it to be easier to <span class="No-Break">find mistakes.</span></li>
				<li>We want a single source of truth for <span class="No-Break">our code.</span></li>
			</ul>
			<p>Do we want to reduce code duplication all the time, in every case? Probably not. Going back to the section on automation in <a href="B17600_08.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Writing Our First Script – Turning Simple Cmdlets into Reusable Code</em>, sometimes the effort required to reduce duplication to the minimum just isn’t worth it. Perhaps we’re only going to use a piece of code twice; in this case, copying and pasting it is perfectly fine, rather than working out how to do it just once. There are also two other software development principles <a id="_idIndexMarker634"/>worth knowing about: <strong class="bold">Avoid Hasty Abstraction</strong> (<strong class="bold">AHA</strong>) and <strong class="bold">You Aren’t Gonna Need It</strong> (<strong class="bold">YAGNI</strong>). AHA warns<a id="_idIndexMarker635"/> us to “<em class="italic">prefer duplication over the wrong abstraction</em>” and comes from Sandi Metz, the author of <em class="italic">Practical Object-Oriented Design in Ruby</em>. She encourages us to be flexible in our coding and only create abstractions (such as the second validation script previously) if they are genuinely necessary, and only once we understand exactly how the abstraction needs to work. The YAGNI principle comes from the<a id="_idIndexMarker636"/> practice of <strong class="bold">Extreme Programming</strong> (<strong class="bold">XP</strong>) and states that we should not add functionality until it’s needed. As an example, if our imaginary bike had only a single property, then writing the script in the first example, with a single <strong class="source-inline">if</strong> statement, is preferable to writing the script in the second example with an abstraction that isn’t going to be used (<em class="italic">You Aren’t Gonna Need It</em>). We should do the simplest thing that could possibly work. One of the main takeaways from <a id="_idIndexMarker637"/>this is that software developers love <span class="No-Break">an acronym.</span></p>
			<p>Now we know why we should reduce code duplication, let’s look at one of the main ways to do it in PowerShell: by <span class="No-Break">using functions.</span></p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor187"/>How to turn repeating code into a function</h1>
			<p>A function is a <strong class="bold">named</strong> section <a id="_idIndexMarker638"/>of code, a piece of <a id="_idIndexMarker639"/>code within a script or program that is given a label, and may be used by referring to the label. This is a very common programming paradigm and appears in most imperative programming languages. Some languages, such as PowerShell and Python, call these pieces of code functions. Some call them subroutines, subprograms, methods, or procedures. The paradigm is called procedural programming and lies between the scripting that most people practice with PowerShell and full object-oriented programming in languages such as C++ and Java. Functional programming is a different paradigm, with a <span class="No-Break">declarative style.</span></p>
			<p class="callout-heading">Imperative, Declarative, Procedural, and Functional</p>
			<p class="callout">I’m throwing around a lot of new words here, so it’s worth quickly explaining what <span class="No-Break">they mean.</span></p>
			<p class="callout"><strong class="bold">Imperative</strong> languages <a id="_idIndexMarker640"/>are <em class="italic">recipe</em> languages such as Python and PowerShell. Each step in the script or program tells the computer to do something, and often, how to do that thing. This is usually the first style of programming that people learn; often, it is the only style <span class="No-Break">they learn.</span></p>
			<p class="callout"><strong class="bold">Declarative</strong> languages tell<a id="_idIndexMarker641"/> the computer what the end result should look like, and leave it up to the computer how to get there. We are all familiar with a declarative language: HTML. An HTML document may tell a computer that a string is a <strong class="source-inline">&lt;Heading&gt;</strong>, but it is up to the browser that is interpreting the HTML to decide what a <strong class="source-inline">&lt;Heading&gt;</strong> <span class="No-Break">looks like.</span></p>
			<p class="callout"><strong class="bold">Procedural</strong> programming is<a id="_idIndexMarker642"/> the style of programming we’re going to be examining in this chapter: writing procedures, which are called functions in PowerShell, and calling them from within our script. The overall programming style is <span class="No-Break">still imperative.</span></p>
			<p class="callout"><strong class="bold">Functional</strong> programming is a<a id="_idIndexMarker643"/> declarative style of programming, where we create functions on objects and then call the functions. Pure functional programming is often described as declarative programming. Functional programming in PowerShell is not impossible, but it is pretty advanced, so we’re not going to cover it in this book. If you are really interested in having a look at it, then visit Chris Kuech’s GitHub page at <a href="https://github.com/chriskuech/functional">https://github.com/chriskuech/functional</a> and have a play with<a id="_idIndexMarker644"/> his <strong class="bold">functional</strong> module <span class="No-Break">for PowerShell.</span></p>
			<p>Let’s have a<a id="_idIndexMarker645"/> look at a function. In the PowerShell <a id="_idIndexMarker646"/>console, <span class="No-Break">try this:</span></p>
			<pre class="console">
function get-square($a) {$a * $a}</pre>			<p>Now, type <strong class="source-inline">get-square</strong>, followed by a number, <span class="No-Break">like this:</span></p>
			<pre class="console">
get-square 23</pre>			<p>As if by magic, the square of our number is returned. While the console is open, we can use <strong class="source-inline">get-square</strong> as often as <span class="No-Break">we like.</span></p>
			<p>What have we done there? Well, we’ve taken some code, <strong class="source-inline">{$a * $a}</strong>, and given it a label (or name), <strong class="source-inline">get-square</strong>, by using the <strong class="source-inline">function</strong> keyword. We’ve also told it to expect a variable, <strong class="source-inline">$a</strong>, by placing the variable in brackets directly after the name. Whenever we use the name of the function, the code runs on the object we’re passing – in this case, the <span class="No-Break">integer </span><span class="No-Break"><strong class="source-inline">23</strong></span><span class="No-Break">.</span></p>
			<p>It’s pretty rare we would define and use a function in the console like that. Instead, I usually incorporate functions into my scripts. Let’s do that now. Open a new PowerShell file in VS Code so we can carry on playing. Let’s do something a little more adventurous. Let’s create a <a id="_idIndexMarker647"/>function that gets the square root of a number<a id="_idIndexMarker648"/> by approximation. <span class="No-Break">Type this:</span></p>
			<pre class="source-code">
function Get-RoughRoot {
    param (
        $number
    )
    $start = 1
    while (($start * $start) -le $number)  {
        $result = $start
        $start += 1
            }
       return $result
}
Get-RoughRoot 785692</pre>			<p>All this code does is start at <strong class="source-inline">1</strong>, and keep multiplying numbers by themselves until it gets to a number that is larger than the number we originally pass to the function – in this case, <strong class="source-inline">785692</strong>. It’s pretty rough and ready. If we run this code, we find that the approximate square root of 785,692 is 886, pretty close to the actual square root of 886.392 but not exact. It demonstrates one of the strengths of machines: fast repetition. It’s gone through that <strong class="source-inline">while</strong> loop <span class="No-Break">887 times.</span></p>
			<p>Notice the <strong class="source-inline">param()</strong> block that we’ve opened on the second line. It’s the same as the <strong class="source-inline">param()</strong> blocks we’ve been using already. In fact, we can turn this function into an <strong class="bold">advanced function</strong> by<a id="_idIndexMarker649"/> including the <strong class="source-inline">cmdletbinding()</strong> attribute, and then we could use all the common parameters with <strong class="source-inline">Get-RoughRoot</strong>.  We can do all the same things with the <strong class="source-inline">param()</strong> block in a function as we can do with the <strong class="source-inline">param()</strong> block in <span class="No-Break">a script.</span></p>
			<p class="callout-heading">Activity 1</p>
			<p class="callout">If we type <strong class="source-inline">65378 | Get-RoughRoot</strong> at the end of our script and run it, what’s going to happen? Why is that, and how could we make that <span class="No-Break">line work?</span></p>
			<p>Once we’ve created our function within a script, we can call it as many times as we like, just by referring to the name of the function and providing values for the parameters. Yes, there is a<a id="_idIndexMarker650"/> really easy way to get an accurate square <a id="_idIndexMarker651"/>root with PowerShell, and it’s much shorter, but where’s the fun <span class="No-Break">in that?</span></p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor188"/>What makes a function?</h2>
			<p>To create<a id="_idIndexMarker652"/> functions, we need <span class="No-Break">the following:</span></p>
			<ul>
				<li>The keyword, <strong class="source-inline">function</strong>, at <span class="No-Break">the start.</span></li>
				<li>A descriptive and meaningful name. It’s best to follow the PowerShell naming conventions and use an approved verb in a verb-noun pair, especially if the function is going to be shared <span class="No-Break">with others.</span></li>
				<li>A set of PowerShell cmdlets in <span class="No-Break">braces, </span><span class="No-Break"><strong class="source-inline">{}</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>We can include a set of parameters, either within a <strong class="source-inline">param()</strong> block after we’ve opened the braces, or we can include them in brackets appended to the name. It’s preferable to use the <strong class="source-inline">param()</strong> block, especially if we’ve got multiple parameters or if we want to add statements to the parameters – for instance, to control how they accept pipeline input, or what types <span class="No-Break">they accept.</span></p>
			<p>When we’re including functions in scripts, it is important to remember that the script is read by the computer from top to bottom, rather than ingested whole before executing. It is important, therefore, that we have defined our functions before we call them in the script. It’s usual to define all the functions in a script at the top, after <span class="No-Break">the parameters.</span></p>
			<p>Each function consists of four statement blocks: <strong class="source-inline">begin</strong>, <strong class="source-inline">process</strong>, <strong class="source-inline">end</strong>, and <strong class="source-inline">clean</strong>. We don’t need to include these statements for our function to work, but we need to be aware of how PowerShell will read our code if we don’t <span class="No-Break">include them.</span></p>
			<p>The <strong class="source-inline">begin</strong> statement block is for statements that set up the function and will only run once when the function is called before the function does anything with its input. Similarly, the <strong class="source-inline">end</strong> block will only run once when the function is called. The <strong class="source-inline">process</strong> block will run for each object in the pipeline that is fed to the function, which is why we need to include it when<a id="_idIndexMarker653"/> accepting multiple objects from the pipeline, because if no statement blocks are specified, then PowerShell assigns all statements to the <span class="No-Break"><strong class="source-inline">end</strong></span><span class="No-Break"> block.</span></p>
			<p>The <strong class="source-inline">clean</strong> statement block was introduced in PowerShell 7.3. It is similar to the <strong class="source-inline">end</strong> statement block, but it will always run, even if the function terminates due to an error or if the function is deliberately halted by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>, whereas the <strong class="source-inline">end</strong> block will not. The other difference is that the <strong class="source-inline">end</strong> block can output objects to the pipeline, and <span class="No-Break"><strong class="source-inline">clean</strong></span><span class="No-Break"> cannot.</span></p>
			<p>Let’s see how this looks in actual code. In the following figure, we’ve added <strong class="source-inline">begin</strong>, <strong class="source-inline">end</strong>, <strong class="source-inline">process</strong>, and <strong class="source-inline">clean</strong> statement blocks to our <span class="No-Break"><strong class="source-inline">Get-RoughRoot</strong></span><span class="No-Break"> function:</span></p>
			<div>
				<div id="_idContainer171" class="IMG---Figure">
					<img src="image/B17600_09_001.jpg" alt="Figure 9.1 – Begin, process, end, and clean statement blocks"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Begin, process, end, and clean statement blocks</p>
			<p>The <strong class="source-inline">begin</strong> statement <a id="_idIndexMarker654"/>on<a id="_idIndexMarker655"/> line <strong class="source-inline">12</strong> contains<a id="_idIndexMarker656"/> a <strong class="source-inline">Write-Output</strong> cmdlet to<a id="_idIndexMarker657"/> display the<a id="_idIndexMarker658"/> value that is currently held in the <strong class="source-inline">-number</strong> parameter. We can see from the output at the bottom that there is no value held in this parameter when the <strong class="source-inline">begin</strong> block runs. The <strong class="source-inline">process</strong> block on line <strong class="source-inline">15</strong> then runs and feeds the current value of <strong class="source-inline">-number</strong> to the pipeline, and repeats for as many values of <strong class="source-inline">-number</strong> as there are in the pipeline. The <strong class="source-inline">end</strong> block on line <strong class="source-inline">24</strong> then runs once, and can only see the final value passed by the <strong class="source-inline">-number</strong> parameter. Finally, the <strong class="source-inline">clean</strong> block executes on line <strong class="source-inline">28</strong>. We can see that it produces no output at all, although it does complete successfully. If you don’t believe me, try it – write a line of code that can’t run, such as <strong class="source-inline">write-rubbish "here is some rubbish"</strong>. There will be a whole load of red text as PowerShell fails to <span class="No-Break">execute it.</span></p>
			<p>There is also an important keyword to be aware of: <strong class="source-inline">return</strong>. The <strong class="source-inline">return</strong> keyword ends the current iteration of the block that is running. Let’s see what happens when we use it. Here is the code for the <strong class="source-inline">Get-RoughRoot</strong> function, with an <strong class="source-inline">if</strong> statement in the <strong class="source-inline">process</strong> block<a id="_idIndexMarker659"/> that returns the <strong class="source-inline">pop</strong> string if the original number is less <span class="No-Break">than 10:</span></p>
			<pre class="source-code">
function Get-RoughRoot {
    param (
        [Parameter(ValueFromPipeline)]
        $number
    )
    begin {
    write-output "for the begin statement, the number is $number"
    }
    process {
        $start = 1
        while (($start * $start) -le $number)  {
            $result = $start
            $start += 1
                }
        if ($number -lt 10) {
            return "pop"
        }
        write-output "The rough root of $number is $result"
        }
    end {
        write-output "for the end statement, the number is $number"
    }
}</pre>			<p>Let’s now pass a number less than 10 in our pipeline, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
785692, 4, 3492858  | Get-RoughRoot</pre>			<p>We will get the output in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer172" class="IMG---Figure">
					<img src="image/B17600_09_002.jpg" alt="Figure 9.2 – Using the return keyword"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Using the return keyword</p>
			<p>We can see that the rough<a id="_idIndexMarker660"/> roots of the two large numbers are returned, but the process block has terminated early when fed a number less <span class="No-Break">than 10.</span></p>
			<p>The <strong class="source-inline">return</strong> keyword has returned the value it has been assigned (<strong class="source-inline">pop</strong>), but that is purely optional – we don’t need to assign a value to <strong class="source-inline">return</strong>. It’s worth noting that this is slightly confusing for those of us who are familiar with other languages. For example, in Python, the <strong class="source-inline">return</strong> statement is used to supply the result of the function. In both Python and PowerShell, <strong class="source-inline">return</strong> statements work in very similar ways but the intention behind them is <a id="_idIndexMarker661"/>different; PowerShell will return the output of the function without the <strong class="source-inline">return</strong> keyword, whereas Python will not. For both Python and PowerShell, <strong class="source-inline">return</strong> will stop the function at the point it <span class="No-Break">is used.</span></p>
			<h3>Basic and advanced functions</h3>
			<p>Most of the functions <a id="_idIndexMarker662"/>I write within scripts are basic functions, but we can make a function behave like a cmdlet by using the <strong class="source-inline">CmdletBinding</strong> attribute. This gives us access to a range of behaviors that we see in cmdlets, such as the <strong class="source-inline">-whatif</strong> and <strong class="source-inline">-confirm</strong> parameters. It also gives us access to advanced <a id="_idIndexMarker663"/>methods such as <strong class="source-inline">WriteCommandDetail</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">WriteError</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor189"/>Function parameters</h2>
			<p>As we’ve mentioned, parameters<a id="_idIndexMarker664"/> for functions work the same way as parameters in scripts, but it’s worth recapping <span class="No-Break">them here.</span></p>
			<h3>Types of parameters</h3>
			<p>There are<a id="_idIndexMarker665"/> four types of parameters we can use with functions (<span class="No-Break">and scripts!):</span></p>
			<ul>
				<li><span class="No-Break">Named parameters</span></li>
				<li><span class="No-Break">Switch parameters</span></li>
				<li><span class="No-Break">Positional parameters</span></li>
				<li><span class="No-Break">Dynamic parameters.</span></li>
			</ul>
			<p>Let’s take a <span class="No-Break">closer look.</span></p>
			<h4>Named parameters</h4>
			<p>Named <a id="_idIndexMarker666"/>parameters are the parameters we’ve <a id="_idIndexMarker667"/>been working with, where we supply a variable that is used as the parameter’s name, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Param(
$number
)</pre>			<p>The name of that parameter, whether it is in a function or a script, is <strong class="source-inline">-number</strong>. We can use the <strong class="source-inline">$number</strong> variable anywhere within our function, and it will have the value supplied in the parameter. As we saw in <a href="B17600_08.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Writing Our First Script – Turning Simple Cmdlets into Reusable Code</em>, we can set a default value for a parameter <span class="No-Break">like this:</span></p>
			<pre class="source-code">
$number = 100</pre>			<p>We can also specify the type of the parameter by supplying a type value in square brackets <a id="_idIndexMarker668"/>before <a id="_idIndexMarker669"/>the <span class="No-Break">variable: </span><span class="No-Break"><strong class="source-inline">[int]$number</strong></span><span class="No-Break">.</span></p>
			<h4>Switch parameters</h4>
			<p>Switch parameters <a id="_idIndexMarker670"/>don’t require a value, they are<a id="_idIndexMarker671"/> simply on or off. If we supply the parameter to the function, then they are on; if they’re not supplied, then they are off. We specify the type of the parameter as <strong class="source-inline">[switch]</strong>, like this: <strong class="source-inline">[switch]$heads</strong>. We can test for the presence of the switch in our function with an <strong class="source-inline">if</strong> statement, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Function get-flip {
    param([switch]$heads)
    if ($heads.ispresent) {"Heads!"}
    else {"Tails!"}
}</pre>			<p>We don’t need the <strong class="source-inline">.ispresent</strong> property, we could just type <strong class="source-inline">if ($heads)</strong>, but I think that’s less clear. We could also use the <strong class="source-inline">if ($heads -eq $true)</strong> construction, which we may see in older articles on the web, but that is not Microsoft’s <span class="No-Break">preferred method.</span></p>
			<h4>Positional parameters</h4>
			<p>These parameters <a id="_idIndexMarker672"/>make use of the <strong class="source-inline">$Args</strong> automatic<a id="_idIndexMarker673"/> variable instead of using a <strong class="source-inline">param()</strong> block. This parameter exists for every basic function and allows us to create unnamed parameters, <span class="No-Break">like this:</span></p>
			<pre class="console">
Function get-product {
$product = $Args[0] * $Args[1]
Write-output "The product of $($Args[0]) and $($Args[1]) is $product"
}</pre>			<p>This means we can supply parameters <span class="No-Break">like this:</span></p>
			<pre class="console">
Get-product 2 4</pre>			<p>We can see the result in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer173" class="IMG---Figure">
					<img src="image/B17600_09_003.jpg" alt="Figure 9.3 – Using positional parameters"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Using positional parameters</p>
			<p>We can see the function has correctly assigned the values we supplied. The <strong class="source-inline">$Args</strong> parameter is <span class="No-Break">an array.</span></p>
			<p>Note that if we use a <strong class="source-inline">param()</strong> block, then that will override this functionality; it won’t work, as we will need to specify positional parameters. By default, parameters are positional, in<a id="_idIndexMarker674"/> the order that the parameters are <a id="_idIndexMarker675"/>written down, so this <span class="No-Break">will work:</span></p>
			<pre class="console">
Function get-product {
Param($a,$b)
$product = $a * $b
$product
}
Get-product 2 4</pre>			<p>The value <strong class="source-inline">2</strong> will be assigned to <strong class="source-inline">$a</strong>, and the value <strong class="source-inline">4</strong> will be assigned to <strong class="source-inline">$b</strong>. If it is important that a parameter be at a specific position, however, we should use the <strong class="source-inline">position</strong> attribute, discussed in the <span class="No-Break">next section.</span></p>
			<p>The <strong class="source-inline">$Args</strong> automatic variable can also be used to splat parameters into a function – review <a href="B17600_04.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">PowerShell Variables and Data Structures</em>, for more about splatting. Let’s see how that works in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer174" class="IMG---Figure">
					<img src="image/B17600_09_004.jpg" alt="Figure 9.4 – Splatting the $Args variable"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Splatting the $Args variable</p>
			<p>In the first line, we are creating a simple function called <strong class="source-inline">Get-Fifteen20</strong>. It runs <strong class="source-inline">Get-Random</strong>. We tell it to accept arguments from the command line into an array called <strong class="source-inline">@Args</strong> (note the array symbol, <strong class="source-inline">@</strong>). After that, we tell it to output the value of the <strong class="source-inline">$Args</strong> automatic variable. From the output, we can see we first get a random number between 15 and 20 (<strong class="source-inline">19</strong>), then we get the contents of the <strong class="source-inline">$Args</strong> variable. We can see it is an array of four objects: <strong class="source-inline">-minimum</strong>, <strong class="source-inline">15</strong>, <strong class="source-inline">-maximum</strong>, and <strong class="source-inline">20</strong>. These are supplied in sequence to the <strong class="source-inline">Get-Random</strong> cmdlet in the function, giving us an effective PowerShell statement <a id="_idIndexMarker676"/>of <strong class="source-inline">Get-Random -minimum 15 -maximum 20</strong>, which <a id="_idIndexMarker677"/>works <span class="No-Break">just fine.</span></p>
			<p class="callout-heading">Activity 2</p>
			<p class="callout">Why doesn’t <strong class="source-inline">Get-Fifteen20 15 </strong><span class="No-Break"><strong class="source-inline">20</strong></span><span class="No-Break"> work?</span></p>
			<h4>Dynamic parameters</h4>
			<p>Dynamic <a id="_idIndexMarker678"/>parameters are only available if a <a id="_idIndexMarker679"/>specified condition is true. They are not defined in the <strong class="source-inline">param()</strong> block, but in a separate <strong class="source-inline">DynamicParam{}</strong> block – note this uses braces, not brackets. Dynamic parameters are quite an advanced topic and should only be used if absolutely necessary, so we’re not going to spend much time on them here. A good example of how they work can be found in the <strong class="source-inline">Get-ChildItem</strong> cmdlet. <strong class="source-inline">Get-ChildItem</strong> can be used with any PSProvider – we covered PSProviders in <a href="B17600_06.xhtml#_idTextAnchor117"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">PowerShell and Files – Reading, Writing, and Manipulating Data</em>. Depending on which PSProvider we are using, different parameters of <strong class="source-inline">Get-ChildItem</strong> are available. For instance, if we are in the <strong class="source-inline">FileSystem</strong> provider, we have access to parameters such as <strong class="source-inline">-File</strong> and <strong class="source-inline">-Hidden</strong>. If we are using the <strong class="source-inline">Certificate</strong> provider, then we can’t use those parameters but we have parameters such as <strong class="source-inline">-DnsName</strong> and <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">SslServerAuthentication</strong></span><span class="No-Break"> instead.</span></p>
			<p>Now we’ve <a id="_idIndexMarker680"/>covered the types of <a id="_idIndexMarker681"/>parameters, let’s take a look at some of the attributes we can apply to <span class="No-Break">our parameters.</span></p>
			<h3>Parameter attributes</h3>
			<p>Attributes are <a id="_idIndexMarker682"/>optional arguments that we can use to control how parameters behave – whether they are mandatory or accept pipeline input, for example. To use attributes, we must start each parameter with the <strong class="source-inline">Parameter()</strong> attribute, which looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Param(
[Parameter(Argument = Value)]
$ParameterName
)</pre>			<p>The <strong class="source-inline">Parameter()</strong> attribute takes multiple arguments, but we must separate them with a comma (<strong class="source-inline">,</strong>). Let’s go through the more <span class="No-Break">common parameters.</span></p>
			<h4>CmdletBinding</h4>
			<p>The <strong class="source-inline">CmdletBinding</strong> attribute <a id="_idIndexMarker683"/>makes the <a id="_idIndexMarker684"/>function behave like a cmdlet. If we use this attribute within a function, we get access to the common parameters such as <strong class="source-inline">-whatif</strong> and <strong class="source-inline">-confirm</strong>. This removes access to the <strong class="source-inline">$Args</strong> automatic variable for <span class="No-Break">that function.</span></p>
			<h4>Mandatory</h4>
			<p>As we <a id="_idIndexMarker685"/>saw in <a href="B17600_08.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Writing Our First Script – Turning Simple Cmdlets into Reusable Code</em>, we<a id="_idIndexMarker686"/> can use the <strong class="source-inline">Mandatory</strong> argument to ensure a value is provided for a parameter, and the <strong class="source-inline">HelpMessage</strong> argument to provide help for that <span class="No-Break">mandatory parameter:</span></p>
			<pre class="source-code">
Param(
[Parameter(Mandatory, HelpMessage="Type one or more integers, separated by commas." )]
[int[]]
$number
)</pre>			<p>This means that at least one integer must be supplied with the <strong class="source-inline">-number</strong> parameter, and a help <a id="_idIndexMarker687"/>message can <span class="No-Break">be </span><span class="No-Break"><a id="_idIndexMarker688"/></span><span class="No-Break">accessed.</span></p>
			<h4>Position</h4>
			<p>The <strong class="source-inline">Position</strong> argument <a id="_idIndexMarker689"/>allows a parameter<a id="_idIndexMarker690"/> to be passed without explicitly naming it and can specify at which position it must <span class="No-Break">be supplied:</span></p>
			<pre class="source-code">
Param(
[Parameter(Mandatory, Position=0 )]
[int[]]
$number
)</pre>			<p>The preceding code tells us that the first value passed without a preceding parameter name will be applied to the <strong class="source-inline">-number</strong> parameter. Two things to note are that named parameters are not counted, and that numbering starts at <strong class="source-inline">0</strong>, so the second position is <strong class="source-inline">Position=1</strong>. Note that if we’re using a <strong class="source-inline">param()</strong> block, the <strong class="source-inline">$Args</strong> functionality we’ve just covered won’t work, and we’ll not be able to splat parameters into a cmdlet within <span class="No-Break">our function.</span></p>
			<p>If we don’t use a <strong class="source-inline">Position</strong> argument, then all the parameters will be assigned positions in the order they are declared in the <strong class="source-inline">param()</strong> block, but we shouldn’t rely on this working exactly as we expect. If we want a parameter to be positional, then we should <span class="No-Break">declare it.</span></p>
			<h4>ParameterSetName</h4>
			<p>We can<a id="_idIndexMarker691"/> use the <strong class="source-inline">ParameterSetName</strong> argument to define parameters that are only present for particular<a id="_idIndexMarker692"/> parameter sets. If <strong class="source-inline">ParameterSetName</strong> is not supplied, a parameter belongs to all parameter sets. I adhere to the philosophy that a function should do one thing, and so I’ve never really found the need for parameter sets. Some people, however, like to write Swiss Army knife functions that do lots of things, and so parameter sets are useful <span class="No-Break">for them.</span></p>
			<h4>ValueFromPipeline</h4>
			<p>We’ve used<a id="_idIndexMarker693"/> this <a id="_idIndexMarker694"/>already in this chapter – it’s necessary to allow a function parameter to accept an object from the pipeline. The parameter accepts the <span class="No-Break">whole object.</span></p>
			<h4>ValueFromPipelineByPropertyName</h4>
			<p>If we only want<a id="_idIndexMarker695"/> the parameter to accept a property of an<a id="_idIndexMarker696"/> object (for instance, a name), then we can use this argument. If the object in the pipeline has a name property, <strong class="source-inline">$object.name</strong>, then that will be used for this parameter. The object property must match the parameter name; otherwise, it won’t get passed. For instance, if we pass a string through the pipeline to a function with a <strong class="source-inline">-length</strong> parameter that accepts pipeline values by property name, then the parameter will be populated with the length of the string, not the actual string. If the parameter is called <strong class="source-inline">-stringlength</strong>, then it will be empty because the string doesn’t have a <span class="No-Break"><strong class="source-inline">stringlength</strong></span><span class="No-Break"> property.</span></p>
			<h4>ValueFromRemainingArguments</h4>
			<p>We can use this<a id="_idIndexMarker697"/> parameter <a id="_idIndexMarker698"/>to hold an indeterminate number of arguments that might be passed to a function, as an array. We can then access those arguments by using the index of their position in the array. This is useful in advanced functions, where we don’t have access to the <strong class="source-inline">$Args</strong> automatic variable, and we<a id="_idIndexMarker699"/> want <a id="_idIndexMarker700"/>to capture an unknown number <span class="No-Break">of arguments.</span></p>
			<h4>HelpMessage</h4>
			<p>As we’ve <a id="_idIndexMarker701"/>seen already, this attribute<a id="_idIndexMarker702"/> can be used to provide a helpful message for <span class="No-Break">mandatory parameters.</span></p>
			<h4>Alias</h4>
			<p>I’m including this <a id="_idIndexMarker703"/>here for the sake of <a id="_idIndexMarker704"/>completeness, but I think I’ve made my views on aliases quite plain. They can occasionally be useful, but they also lead to confusion and make code less readable. It is possible, however, to use the <strong class="source-inline">Alias</strong> attribute to provide an alias for <span class="No-Break">a parameter.</span></p>
			<h4>SupportsWildcards</h4>
			<p>We can use this<a id="_idIndexMarker705"/> parameter<a id="_idIndexMarker706"/> if we want a parameter to accept wildcards. Note that this doesn’t mean the function supports wildcards – we still need to write code in our function that can handle <span class="No-Break">wildcard input.</span></p>
			<h4>Argument completion attributes</h4>
			<p>There are two argument <a id="_idIndexMarker707"/>completion <a id="_idIndexMarker708"/>attributes that allow a user to complete the values of a parameter using the <em class="italic">Tab</em> key. These are similar to the <strong class="source-inline">ValidateSet</strong> attribute. We’re not going to cover them in this book, but it’s useful to know that it is something we can do if we <span class="No-Break">want to.</span></p>
			<h4>Validation attributes</h4>
			<p>There are<a id="_idIndexMarker709"/> currently 14 attributes that we <a id="_idIndexMarker710"/>can use to validate parameters and the values supplied for them. We can validate that a value is null, that a value follows a specific pattern such as a credit card number or IP address, and that a value is of a certain length or falls in a certain range. We discovered the <strong class="source-inline">ValidateSet</strong> attribute in <a href="B17600_08.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Writing Our First Script – Turning Simple Cmdlets into Reusable Code</em>. It works <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Param(
[Parameter (Mandatory)]
[ValidateSet("Pontypool", "Newport", "Swansea","Llanelli", "Cardiff")]
[string]$team
)</pre>			<p>This will only accept the string if it appears in the array listed in <strong class="source-inline">ValidateSet</strong>. Note that validation attributes sit outside the <span class="No-Break"><strong class="source-inline">Parameter()</strong></span><span class="No-Break"> attribute.</span></p>
			<p>While there are <a id="_idIndexMarker711"/>plenty more aspects of<a id="_idIndexMarker712"/> parameters we could cover, that’s enough for now. Let’s look at a specialized type of <span class="No-Break">function: filters.</span></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor190"/>Filters</h2>
			<p>A filter is a specialized<a id="_idIndexMarker713"/> function that automatically runs on all<a id="_idIndexMarker714"/> objects in the pipeline. A filter is similar to a function with just a <strong class="source-inline">process{}</strong> statement block. We can use them <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="image/B17600_09_005.jpg" alt="Figure 9.5 – Using a filter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Using a filter</p>
			<p>Instead of using the <strong class="source-inline">function</strong> keyword, we’ve used <strong class="source-inline">filter</strong>. We’ve called our filter <strong class="source-inline">square</strong> and defined it as multiplying the pipeline object by itself. Now we can feed a value to the filter via the pipeline, and get an output. Notice that we can’t use it like a function; <strong class="source-inline">square 36</strong> won’t work as there’s nothing in the pipeline for the filter to <span class="No-Break">work on.</span></p>
			<p>Before we can really<a id="_idIndexMarker715"/> get on with using functions, though, we need to talk about an<a id="_idIndexMarker716"/> important <span class="No-Break">concept: scope.</span></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor191"/>The concept of scope</h1>
			<p>PowerShell uses the <a id="_idIndexMarker717"/>concept of scope to protect variables, functions, PSDrives, and aliases from inadvertent change by limiting how they may be accessed and modified. <span class="No-Break">Let’s demonstrate:</span></p>
			<ol>
				<li>Create a variable and set <span class="No-Break">its value:</span><pre class="source-code">
<strong class="bold">$ScopeTest = 10</strong></pre></li>				<li>Create <span class="No-Break">a function:</span><pre class="source-code">
<strong class="bold">Function Set-ScopeTest {$ScopeTest = 15; Write-Output "the value of ScopeTest is $ScopeTest"}</strong></pre></li>				<li>Test the value of <strong class="source-inline">$ScopeTest</strong> by calling <span class="No-Break">the variable:</span><pre class="source-code">
<strong class="bold">$ScopeTest</strong></pre></li>				<li>Run <span class="No-Break">our function:</span><pre class="source-code">
<strong class="bold">Set-ScopeTest</strong></pre></li>				<li>We can see from the output that the value of <strong class="source-inline">$ScopeTest</strong> inside the function is <strong class="source-inline">15</strong>. Let’s check whether the value has <span class="No-Break">changed permanently:</span><pre class="source-code">
<strong class="bold">$ScopeTest</strong></pre><p class="list-inset">No, it hasn’t. That’s because the function is operating on its local scope; it can read the value of the variable, and it can change it while it’s running, but it can’t change it permanently because the variable exists outside the function. This is known as the scope of <span class="No-Break">the function.</span></p></li>			</ol>
			<p>PowerShell has the following types <span class="No-Break">of scopes:</span></p>
			<ul>
				<li><strong class="bold">Global</strong>: This is the <a id="_idIndexMarker718"/>scope created when a PowerShell session is started. It includes all the automatic variables and functions, plus any that we define at the prompt, such as the <strong class="source-inline">$scopeTest</strong> variable we just used. Anything that is defined in the global scope is available everywhere inside the <span class="No-Break">current session.</span></li>
				<li><strong class="bold">Local</strong>: This is the scope where we are currently working. When we are using the command prompt, our local scope is the global scope. Inside the <strong class="source-inline">Set-ScopeTest</strong> function, there is a different scope to the global scope. When we changed the <strong class="source-inline">$SetScope</strong> variable inside our function, it only changed in the local scope of the function, not the global scope. The local scope is relative to other scopes, not a predefined scope, so it may refer to the global scope, a script scope, or a child of the global or script scopes. We can create many nested local scopes. When we run a script or a function, we are creating a new <span class="No-Break">local scope.</span></li>
				<li><strong class="bold">Script</strong>: This is the scope that is created when we run a script. Only the statements in the script run in the script scope, and those statements see the script scope as the local scope. Each script that is running has its own script scope; they don’t <a id="_idIndexMarker719"/><span class="No-Break">share objects.</span></li>
			</ul>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor192"/>Parent and child scopes</h2>
			<p>There is a <a id="_idIndexMarker720"/>hierarchy of scopes. A scope that is <a id="_idIndexMarker721"/>contained in another scope is called a child scope, and the containing scope is called the parent scope. The global scope is always the root scope, the parent of all scopes, and other scopes are child scopes of the global scope. So, when we ran <strong class="source-inline">Set-ScopeTest</strong> previously, we created a local scope for the function that is a child of the global scope. The local scope can read the variables of the parent scope, but by default, does not change them in the parent scope; it can only change them in its local scope. Let’s add a few lines to our <strong class="source-inline">Set-ScopeTest</strong> function to <span class="No-Break">illustrate this:</span></p>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/B17600_09_006.jpg" alt="Figure 9.6 – Illustrating parent and child scopes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Illustrating parent and child scopes</p>
			<p>The first line we’ve added gets the value of the <strong class="source-inline">$ScopeTest</strong> variable that the function inherits from its parent scope (in this case, <strong class="source-inline">10</strong>) and writes it to the screen. We then change the value of <strong class="source-inline">$ScopeTest</strong> within the function, as before, and output the new value. Next, we’ve got a couple of lines using <strong class="source-inline">Get-Variable</strong> that retrieve the value of the <strong class="source-inline">$ScopeTest</strong> variable in the global and local scopes. We can see that even within the function, the global value of <strong class="source-inline">$ScopeTest</strong> remains <strong class="source-inline">10</strong> – it is only the local instance of <strong class="source-inline">$ScopeTest</strong> that <a id="_idIndexMarker722"/>is <a id="_idIndexMarker723"/>changed by the function. What happens if we want to modify the value of a variable in the parent scope with our function, though? Let’s take a look at how we can <span class="No-Break">do that.</span></p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor193"/>Scope modifiers</h2>
			<p>Scopes are used <a id="_idIndexMarker724"/>for a reason – to protect ourselves from inadvertent changes – and we should only step outside the automatic scopes with caution, but sometimes we need to do it. PowerShell includes a number of scope modifiers that allow us to change the default scope. They include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">Global</strong>: This specifies objects in the <span class="No-Break">global scope.</span></li>
				<li><strong class="source-inline">Local</strong>: This specifies an object in the <span class="No-Break">current scope.</span></li>
				<li><strong class="source-inline">Script</strong>: This specifies an object in the parent script scope, or in the global scope if there is no parent script; we’d use this with functions embedded <span class="No-Break">in scripts.</span></li>
				<li><strong class="source-inline">Private</strong>: When this is used while creating variables, this prevents child scopes from using <span class="No-Break">the object.</span></li>
				<li><strong class="source-inline">&lt;Variable-namespace&gt;</strong> These refer to PSDrive namespaces, such as <strong class="source-inline">env:</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">variable:</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>There are also a couple of others that we won’t cover here: <strong class="source-inline">workflow:</strong>, which is deprecated, and <strong class="source-inline">using:</strong>, which is used with cmdlets such as <strong class="source-inline">Invoke-Command</strong> and <strong class="source-inline">Start-Job</strong>. Scripts operate by default in the <strong class="source-inline">script:</strong> scope. Functions operate in the <strong class="source-inline">local:</strong> scope by default, even when they are defined in <span class="No-Break">a script.</span></p>
			<p>We use the scope modifier between the <strong class="source-inline">$</strong> symbol and the variable name, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
$global:ScopeTest = 10</pre>			<p>This will create <a id="_idIndexMarker725"/>a variable in the global scope called <strong class="source-inline">ScopeTest</strong> and set its value to <strong class="source-inline">10</strong> (remember, the variable name doesn’t have a <strong class="source-inline">$</strong> symbol – we use the <strong class="source-inline">$</strong> symbol to refer to the contents of <span class="No-Break">the variable).</span></p>
			<p>Similarly, we can define the scope of a function <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Function Global:Set-ScopeTest {$ScopeTest = 15}</pre>			<p>Note that setting the scope of the function to global doesn’t change where the function acts, it changes where it is available. So, a function with a global scope doesn’t automatically act on global variables, as we can <span class="No-Break">see here:</span></p>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/B17600_09_007.jpg" alt="Figure 9.7 – Global functions and global variables"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Global functions and global variables</p>
			<p>We can see the original value of <strong class="source-inline">$ScopeTest</strong> is <strong class="source-inline">10</strong>. We then define a global function called <strong class="source-inline">Set-ScopeTest</strong> that sets the value to <strong class="source-inline">15</strong>. Calling the function doesn’t change the global value of <strong class="source-inline">$ScopeTest</strong>. To do that, we need to tell the function to work on the global variable, not the local version running inside the function. We do that in the second command, with the following code: <strong class="source-inline">$Global:ScopeTest = </strong><span class="No-Break"><strong class="source-inline">15</strong></span><span class="No-Break">.</span></p>
			<p>As we work through the rest of the book, we’ll see the concept of scope, and no doubt be occasionally frustrated by it. Remember that it is there to protect us and provide a set of handy guardrails to prevent us from experiencing hilarious consequences. We should only step outside the default scope after some thought and consideration. We can often avoid this through passing variables as parameters, or explicitly writing output from inside our <a id="_idIndexMarker726"/>function and storing it as <span class="No-Break">a variable.</span></p>
			<p>Now we understand functions, let’s look at their very close <span class="No-Break">relatives: scriptblocks.</span></p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor194"/>Exploring scriptblocks</h1>
			<p>A scriptblock is a <a id="_idIndexMarker727"/>collection of statements inside braces (<strong class="source-inline">{}</strong>) that can be used as a single unit. We’ve already used them numerous times: in <strong class="source-inline">Where-Object</strong> cmdlets, <strong class="source-inline">if</strong> and <strong class="source-inline">else</strong> statements, <strong class="source-inline">foreach</strong> loops, and earlier in this chapter, when we were writing functions. In this section, we are going to look at some of the properties of scriptblocks and how we can use them in <span class="No-Break">our code.</span></p>
			<p>Consider everything we’ve just done on functions. A function consists of the <strong class="source-inline">function</strong> keyword, a name, and a scriptblock: a set of statements inside braces. We don’t need the keyword to use the scriptblock – the keyword supplies a label that we use to call the scriptblock when we <span class="No-Break">need it.</span></p>
			<p>Scriptblocks return the output of all the statements they contain; this may be a single object or an array of objects. We can use the <strong class="source-inline">return</strong> keyword, and it works the same as it does for a function: it will exit the scriptblock at <span class="No-Break">that point.</span></p>
			<p>We can create parameters for scriptblocks using a <strong class="source-inline">param()</strong> block, and it will accept all the parameter types and attributes that we use with a function. What we can’t do is pass parameters<a id="_idIndexMarker728"/> outside the braces, as we can with functions, because there is no name value to attach <span class="No-Break">them to.</span></p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor195"/>How to run a scriptblock</h2>
			<p>There are many <a id="_idIndexMarker729"/>ways to call scriptblocks – lots of cmdlets and statements such as <strong class="source-inline">foreach</strong> accept them. Sometimes, however, we want to just run the scriptblock. <strong class="source-inline">Invoke-Command</strong> is one way to do it, <span class="No-Break">like this:</span></p>
			<pre class="console">
$a = 10
Invoke-Command -ScriptBlock {$a * $a}</pre>			<p>This gives us the output <strong class="source-inline">100</strong>. Let’s look at some of the other ways we might <span class="No-Break">do it.</span></p>
			<p>Unlike functions, scriptblocks may be stored in variables, <span class="No-Break">like this:</span></p>
			<pre class="console">
$square = {$a * $a}</pre>			<p>Now, we can use the <strong class="source-inline">$square</strong> variable in the <span class="No-Break">following ways:</span></p>
			<ul>
				<li>We can pass it as a parameter to <strong class="source-inline">Invoke-Command</strong>, either with the <strong class="source-inline">-ScriptBlock</strong>  parameter name <span class="No-Break">or not:</span><pre class="source-code">
Invoke-Command $square</pre></li>				<li>Using <strong class="source-inline">Get-Member</strong>, we can see that <strong class="source-inline">$square</strong> has a <strong class="source-inline">TypeName</strong> of <strong class="source-inline">System.Management.Automation.ScriptBlock</strong>. This type has a method called <strong class="source-inline">invoke()</strong>, which we can use <span class="No-Break">like this:</span><pre class="source-code">
$square.invoke()</pre></li>				<li>Let’s say we’ve put a parameter in our scriptblock, <span class="No-Break">like this:</span><pre class="source-code">
$square = {param($a) $a * $a}</pre><p class="list-inset">Then, we can pass the parameter in <span class="No-Break">the brackets:</span></p><pre class="source-code">$square.invoke(20)</pre><p class="list-inset">What we can’t do is just call the variable to run <span class="No-Break">the scriptblock:</span></p></li>			</ul>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/B17600_09_008.jpg" alt="Figure 9.8 – How not to run a scriptblock"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – How not to run a scriptblock</p>
			<p class="list-inset">As you can see, if we call the variable, we get the contents of the scriptblock, not the output. Instead, we use the call operator (<strong class="source-inline">&amp;</strong>) <span class="No-Break">like this:</span></p>
			<pre class="source-code">
&amp;$square 20</pre>			<p class="list-inset">We can leave a space between <strong class="source-inline">&amp;</strong> and <strong class="source-inline">$square</strong> as well, <strong class="source-inline">&amp; $square</strong>, and we will often see it written <span class="No-Break">like that.</span></p>
			<ul>
				<li>There is one other way: dot sourcing. Instead of the call operator, we can use a period (<strong class="source-inline">.</strong>) <span class="No-Break">like this:</span><pre class="source-code">
. $square</pre></li>			</ul>
			<p>We need to be very <a id="_idIndexMarker730"/>careful when we call scriptblocks like this. Using <strong class="source-inline">Invoke-Command</strong>, <strong class="source-inline">invoke()</strong> and the call operator all run the scriptblock in a child scope, as we would expect. Dot sourcing will run it in the parent scope, as we can see in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="image/B17600_09_009.jpg" alt="Figure 9.9 – The call operator and dot sourcing"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – The call operator and dot sourcing</p>
			<p>In the first line, we’ve defined a variable, <strong class="source-inline">$SbScope</strong>, as the <strong class="source-inline">Global scope!</strong> string. We then define a variable, <strong class="source-inline">$ChangeSbScope</strong>, as a scriptblock that sets <strong class="source-inline">$SbScope</strong> to <strong class="source-inline">Local scope!</strong> and returns it. When we call <strong class="source-inline">$ChangeSbScope</strong> with the call operator, it runs in the local scope and leaves the global value <strong class="source-inline">of $SbScope</strong> unchanged: <strong class="source-inline">Global scope!</strong>. However, when we dot source <strong class="source-inline">$ChangeSbScope</strong>, we can see that it changes the value of <strong class="source-inline">$SbScope</strong> in the global scope. Be careful. Don’t dot source unless you’re<a id="_idIndexMarker731"/> absolutely sure that’s what you have <span class="No-Break">to do.</span></p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor196"/>Lambdas</h2>
			<p>Most programming<a id="_idIndexMarker732"/> languages have the concept of a <strong class="bold">lambda</strong> – an anonymous<a id="_idIndexMarker733"/> function, a function without a name. In PowerShell, we have the scriptblock, which is a broader concept that includes lambdas. So in Python, we might have a lambda statement such as the following, which adds a value <span class="No-Break">to itself:</span></p>
			<pre class="source-code">
Add = lambda a: a + a
Add(20)</pre>			<p>And we get the output <strong class="source-inline">40</strong>. In PowerShell, the equivalent lambda, using a scriptblock, would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
$add = {param($a) $a + $a}
&amp;$add(20)</pre>			<p>And again, we get <strong class="source-inline">40</strong>. Lambdas in Python are limited to expressions and can’t include statements, whereas in PowerShell, we are not <span class="No-Break">so restricted.</span></p>
			<p>When do we want to use scriptblocks instead of functions? Generally, we use scriptblocks for short, simple blocks of code that may only occur a couple of times in a script. I often use them in the console as well. If I’m writing a script that is going to be used by other people, then anything more than a line or two of code would go in a function to improve readability and make sure other people know exactly what I was trying <span class="No-Break">to do.</span></p>
			<p>The final case for scriptblocks is for people who come to PowerShell knowing another language, such as Python. Using scriptblocks as a substitute for lambdas allows them to continue <a id="_idIndexMarker734"/>writing <a id="_idIndexMarker735"/>code in a style they are <span class="No-Break">used to.</span></p>
			<p>That’s enough to learn about functions and scriptblocks. Let’s look at a <span class="No-Break">practical application.</span></p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor197"/>Let’s do something useful</h1>
			<p>When I am writing PowerShell scripts for customers, I like to make sure that the script records information about what it is doing and any changes it has made in a log file so that I can quickly pinpoint what is going on. I don’t write the functionality each time I write a script, however; I just include some saved PowerShell snippets in the script that give me a log file function. Let’s think about how we might do <span class="No-Break">that now.</span></p>
			<p>First, we need to think about where we create the log file. I use <strong class="source-inline">C:\temp</strong>, as that directory is usually where we put things that we don’t want to keep forever, and it usually has fairly relaxed permissions. We might want to think about a different directory on Linux or macOS, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">/var/log/</strong></span><span class="No-Break">.</span></p>
			<p>We also want to create a file that is as easy to read as possible; I write to a text file but I use the suffix <strong class="source-inline">.log</strong> so that I know what sort of text file it is. The file we create needs to be date-stamped so that we know which file relates to which instance the script was run. This means we need to create it outside the function, at the script level; otherwise, we’ll create a new file every time the function <span class="No-Break">is called.</span></p>
			<p>Each file entry needs to be time-stamped so we know in what order the events in the log occurred, and it also needs to record a string that we can pass from outside <span class="No-Break">the function.</span></p>
			<p>It looks like we need two parameters: <strong class="source-inline">$LogFile</strong> and <strong class="source-inline">$LogString</strong>. Let’s start <span class="No-Break">writing this:</span></p>
			<ol>
				<li>Create a new PowerShell file in VS Code; I’m calling <span class="No-Break">mine </span><span class="No-Break"><strong class="source-inline">Write-Log.ps1</strong></span><span class="No-Break">.</span></li>
				<li>First, let’s <span class="No-Break">create </span><span class="No-Break"><strong class="source-inline">$LogFilename</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">$LogFile = "c:\temp\MyLogFile" + $(Get-Date -UFormat "%Y-%m-%d_%H-%M-%S") + ".log"</strong></pre><p class="list-inset">Don’t worry too much about the <strong class="source-inline">-UFormat</strong> parameter of <strong class="source-inline">Get-Date</strong>; it’s to produce an easily readable text string that will work with Windows <span class="No-Break">file-naming rules.</span></p></li>				<li>Now, we need a descriptive name, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">Write-Log</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">Function Write-Log {</strong>
<strong class="bold">}</strong></pre></li>				<li>We also need a <strong class="source-inline">param()</strong> block for our <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">LogString</strong></span><span class="No-Break"> parameter:</span><pre class="source-code">
<strong class="bold">Function Write-Log {</strong>
<strong class="bold">Param(</strong>
<strong class="bold">$logString</strong>
<strong class="bold">)</strong>
<strong class="bold">}</strong></pre></li>				<li>Now, let’s get onto the functionality. We need a variable that holds a string for the current date and time. Here’s another way to <span class="No-Break">do it:</span><pre class="source-code">
<strong class="bold">$stamp = (Get-Date).ToString("yyyy/m/dd HH:mm:ss")</strong></pre></li>				<li>Now, we need to create a log message by concatenating the <strong class="source-inline">$stamp</strong> variable and the <strong class="source-inline">$LogString</strong> variable that we get from <span class="No-Break">the parameter:</span><pre class="source-code">
<strong class="bold">$LogMessage = "$stamp $Logstring"</strong></pre></li>				<li>Finally, we need to write it to the <span class="No-Break">log file:</span><pre class="source-code">
<strong class="bold">Add-Content $Logfile –Value $LogMessage</strong></pre></li>				<li>And that’s it. Let’s add a line in the script after the function to check that <span class="No-Break">it works:</span><pre class="source-code">
<strong class="bold">Write-Log "is this thing on?"</strong></pre><p class="list-inset">And let’s run it <span class="No-Break">to see.</span></p></li>			</ol>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/B17600_09_010.jpg" alt="Figure 9.10 – Yes it is"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Yes it is</p>
			<p>Here’s my <span class="No-Break">complete code:</span></p>
			<pre class="source-code">
$LogFile = "c:\temp\MyLogFile" + $(Get-Date -UFormat "%Y-%m-%d_%H-%M-%S") + ".log"
Function Write-Log {
    Param (
        [string]$LogString
    )
    $stamp = (Get-Date).ToString("yyyy/m/dd HH:mm:ss")
    $LogMessage = "$stamp $Logstring"
    Add-Content $Logfile –Value $LogMessage
}
Write-Log "Is this thing on?"</pre>			<p>The function I use for work does a number of other things as well, and we’ll be looking at some of them in the next chapter – <a href="B17600_10.xhtml#_idTextAnchor201"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Error Handling – Oh No! It’s </em><span class="No-Break"><em class="italic">Gone Wrong!</em></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Activity 3</p>
			<p class="callout">This function writes a file to a location on the client. If we regularly run scripts that make use of it, we’re going to end up with a lot of files cluttering things up. How might we go about writing a function that clears up old log files when we run <span class="No-Break">the script?</span></p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor198"/>Summary</h1>
			<p>We’ve done some interesting stuff in this chapter. We considered some fundamental principles of software engineering, particularly DRY, and saw how we might apply them within PowerShell scripts. We looked in detail at how functions are constructed and how they work. We briefly discussed the difference between basic and <span class="No-Break">advanced functions.</span></p>
			<p>We then discussed the four types of parameters we can use with functions: named, switch, positional, and dynamic parameters. We also learned about the <strong class="source-inline">$Args</strong> automatic variable and saw how we can use that to splat parameters into cmdlets in our <span class="No-Break">basic function.</span></p>
			<p>Next, we looked at the many types of attributes we can apply to our parameters to control how the script behaves. We concentrated on the more common attributes but acknowledged the existence of completion attributes and <span class="No-Break">validation attributes.</span></p>
			<p>Finally, we looked at a special type of function – the filter – and saw how we could use it to process <span class="No-Break">pipeline objects.</span></p>
			<p>We then spent some time looking at the concept of scope and saw how this is used to protect our environment and keep scripts and functions working in constrained areas of memory. We learned about parent and child scopes and the concept of scope hierarchy. Finally, we looked at how we could force functions and scripts to work outside their <span class="No-Break">default scopes.</span></p>
			<p>We then moved on to scriptblocks and saw how they are related to functions. We talked about different ways of calling them, including dot sourcing – a method we should use with caution. We then learned how scriptblocks relate to a common programming concept: the anonymous function <span class="No-Break">or lambda.</span></p>
			<p>We covered a fair bit of theory, so we finished the chapter looking at how we could construct a function to do something useful that we can apply in many scripts – writing to a log file. I hope you found this useful; I know I use it <span class="No-Break">a lot.</span></p>
			<p>In the next chapter, we’re going to be looking at how to handle errors, both in our script and ones we encounter when our script meets the <span class="No-Break">outside world.</span></p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor199"/>Further reading</h1>
			<ul>
				<li>For information on the software engineering concepts we covered at the start of the chapter: <em class="italic">The Pragmatic Programmer</em>, 20<span class="superscript">th</span> Anniversary Edition, David Thomas and Andrew Hunt, 2019, Addison Wesley. There’s lots of other really useful stuff in there <span class="No-Break">as well.</span></li>
				<li>There are lots of help <em class="italic">About</em> files included in PowerShell on the topics we’ve covered in this chapter. It’s worth knowing and reading <span class="No-Break">these ones:</span><ul><li>About <span class="No-Break">Functions: </span><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions?view=powershell-7.3&#13;"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/</span>
<span class="No-Break">module/microsoft.powershell.core/about/about_functions?view=powershell-7.3</span></a></li><li>About Advanced <span class="No-Break">Functions: </span><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced?view=powershell-7.3"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced?view=powershell-7.3</span></a></li><li>About Advanced Function <span class="No-Break">Methods: </span><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_methods?view=powershell-7.3"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_methods?view=powershell-7.3</span></a></li><li>About Advanced Function <span class="No-Break">Parameters: </span><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters?view=powershell-7.3"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters?view=powershell-7.3</span></a></li><li>About Advanced Function Argument <span class="No-Break">Completion: </span><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_argument_completion?view=powershell-7.3"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_argument_completion?view=powershell-7.3</span></a></li><li>About <span class="No-Break">CmdletBinding: </span><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute?view=powershell-7.3"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute?view=powershell-7.3</span></a></li><li>About Function <span class="No-Break">Output: </span><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_outputtypeattribute?view=powershell-7.3"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_outputtypeattribute?view=powershell-7.3</span></a></li><li>About <span class="No-Break">ScriptBlocks: </span><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_script_blocks?view=powershell-7.3"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_script_blocks?view=powershell-7.3</span></a></li></ul></li>
			</ul>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor200"/>Exercises</h1>
			<ol>
				<li>What does AHA <span class="No-Break">stand for?</span></li>
				<li>Why should we be very careful when using <span class="No-Break">dot sourcing?</span></li>
				<li>We’ve created a variable called <strong class="source-inline">$ScriptBlock</strong> and populated it with a scriptblock. Let’s say we call it <span class="No-Break">like this:</span><pre class="source-code">
$ScriptBlock</pre><p class="list-inset">We don’t get the output we expect. <span class="No-Break">Why not?</span></p></li>				<li>What parameter argument might we use to check that our input is a valid <span class="No-Break">IP address?</span></li>
				<li>We’ve created a filter, <strong class="source-inline">get-square</strong>, and we’re trying to use it <span class="No-Break">like this:</span><pre class="source-code">
Get-square 365</pre><p class="list-inset">Why isn’t there <span class="No-Break">any output?</span></p></li>				<li>What are we <span class="No-Break">doing here?</span><pre class="source-code">
$private:number</pre></li>				<li>What’s the main difference between a function and <span class="No-Break">a scriptblock?</span></li>
				<li>What are we doing <span class="No-Break">wrong here?</span><pre class="source-code">
Function get-square($a) {$a*$a}
15 | get-square</pre></li>				<li>We’ve spent a lot of time in this chapter getting an inaccurate square root. How would we write a function to get an accurate <span class="No-Break">square root?</span><pre class="source-code">
Function get-root($a) {
&lt;what goes here?&gt;
}</pre></li>			</ol>
		</div>
	</body></html>