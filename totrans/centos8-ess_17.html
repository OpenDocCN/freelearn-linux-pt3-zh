<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer176" class="_idGenObjectStyleOverride-1">&#13;
			<p id="_idParaDest-185" class="Chapter-Title"><span class="ChapterMarker">19. </span><a id="_idTextAnchor248"/>An Overview of Virtualization Techniques</p>&#13;
			<p class="My-Basic-Paragraph"><a id="_idIndexMarker430"/>Virtualization is generically defined as the ability to run multiple operating systems simultaneously on a single computer system. While not necessarily a new concept, Virtualization has come to prominence in recent years because it provides a way to fully utilize the CPU and resource capacity of a server system while providing stability (in that if one virtualized guest system crashes, the host and any other guest systems continue to run). </p>&#13;
			<p class="My-Basic-Paragraph">Virtualization is also useful in terms of trying out different operating systems without having to configure dual boot environments. For example, you can run Windows in a virtual machine without having to re-partition the disk, shut down CentOS 8 and then boot from Windows. You simply start up a virtualized version of Windows as a guest operating system. Similarly, virtualization allows you to run other Linux distributions from within a CentOS 8 system, providing concurrent access to both operating systems.</p>&#13;
			<p class="My-Basic-Paragraph">When deciding on the best approach to implementing virtualization it is important to have a clear understanding of the different virtualization solutions that are currently available. The purpose of this chapter, therefore, is to describe in general terms the virtualization techniques in common use today. </p>&#13;
			<p id="_idParaDest-186" class="Heading-1-1"><span class="Heading11Marker">19.1 </span><a id="_idTextAnchor249"/>Guest Operating System Virtualization </p>&#13;
			<p class="My-Basic-Paragraph"><a id="_idIndexMarker431"/><a id="_idIndexMarker432"/>Guest OS virtualization, also referred to as application-based virtualization, is perhaps the easiest concept to understand. In this scenario the physical host computer system runs a standard unmodified operating system such as Windows, Linux, UNIX or macOS. Running on this operating system is a virtualization application which executes in much the same way as any other application such as a word processor or spreadsheet would run on the system. It is within this virtualization application that one or more virtual machines are created to run the guest operating systems on the host computer. </p>&#13;
			<p class="My-Basic-Paragraph">The virtualization application is responsible for starting, stopping and managing each virtual machine and essentially controlling access to physical hardware resources on behalf of the individual virtual machines. The virtualization application also engages in a process known as binary rewriting which involves scanning the instruction stream of the executing guest system and replacing any privileged instructions with safe emulations. This has the effect of making the guest system think it is running directly on the system hardware, rather than in a virtual machine within an application. </p>&#13;
			<p class="My-Basic-Paragraph">The following figure provides an illustration of guest OS based virtualization: </p>&#13;
			<p class="My-Basic-Paragraph ParaOverride-1"><img class="_idGenObjectAttribute-1" src="Images/guest_os_virtualization.png" alt="" width="422" height="388"/></p>&#13;
			<p class="Figure-Caption"><span class="FigureCaptionMarker">Figure 19-1</span></p>&#13;
			<p class="My-Basic-Paragraph">As outlined in the above diagram, the guest operating systems operate in virtual machines within the virtualization application which, in turn, runs on top of the host operating system in the same way as any other application. Clearly, the multiple layers of abstraction between the guest operating systems and the underlying host hardware are not conducive to high levels of virtual machine performance. This technique does, however, have the advantage that no changes are necessary to either host or guest operating systems and no special CPU hardware virtualization support is required. </p>&#13;
			<p id="_idParaDest-187" class="Heading-1-1"><span class="Heading11Marker">19.2 </span><a id="_idTextAnchor250"/><a id="_idIndexMarker433"/><a id="_idIndexMarker434"/><a id="_idIndexMarker435"/><a id="_idIndexMarker436"/>Hypervisor <a id="_idIndexMarker437"/><a id="_idIndexMarker438"/><a id="_idIndexMarker439"/><a id="_idIndexMarker440"/>Virtualization </p>&#13;
			<p class="My-Basic-Paragraph">In hypervisor virtualization, the task of a hypervisor is to handle resource and memory allocation for the virtual machines in addition to providing interfaces for higher level administration and monitoring tools. Hypervisor based solutions are categorized as being either Type-1 or Type-2. </p>&#13;
			<p class="My-Basic-Paragraph">Type-2 hypervisors (sometimes referred to as <span class="My-Italic _idGenCharOverride-1">hosted hypervisors</span>) are installed as software applications that run on top of the host operating system, providing virtualization capabilities by coordinating access to resources such as the CPU, memory and network for guest virtual machines. <a href="../Text/Virtualization_Overview.xhtml#_idTextAnchor251">Figure 19-2</a> illustrates the typical architecture of a system using Type-2 hypervisor virtualization:</p>&#13;
			<p class="My-Basic-Paragraph ParaOverride-1"> <img class="_idGenObjectAttribute-2" src="Images/type-2_hypervisor_virtualization.png" alt="" width="422" height="400"/></p>&#13;
			<p class="Figure-Caption"><span class="FigureCaptionMarker">Figure 19-2</span><a id="_idTextAnchor251"/></p>&#13;
			<p class="My-Basic-Paragraph">To understand how Type-1 hypervisors work, it helps to understand a little about Intel x86 processor architecture. The x86 family of CPUs provides a range of protection levels known as <span class="My-Italic _idGenCharOverride-1">rings</span> in which code can execute. Ring 0 has the highest level privilege and it is in this ring that the operating system kernel normally runs. Code executing in ring 0 is said to be running in system space, kernel mode or supervisor mode. All other code such as applications running on the operating system operate in less privileged rings, typically ring 3.</p>&#13;
			<p class="My-Basic-Paragraph">In contrast to Type-2 hypervisors, Type-1 hypervisors (also referred to as<span class="My-Italic _idGenCharOverride-1"> metal</span> or <a id="_idIndexMarker441"/><a id="_idIndexMarker442"/><a id="_idIndexMarker443"/><a id="_idIndexMarker444"/><a id="_idIndexMarker445"/><span class="My-Italic _idGenCharOverride-1">native hypervisors</span>) run directly on the hardware of the host system in ring 0. Clearly, with the hypervisor occupying ring 0 of the CPU, the kernels for any guest operating systems running on the system must run in less privileged CPU rings. Unfortunately, most operating system kernels are written explicitly to run in ring 0 for the simple reason that they need to perform tasks that are only available in that ring, such as the ability to execute privileged CPU instructions and directly manipulate memory. A number of different solutions to this problem have been devised in recent years, each of which is described below: </p>&#13;
			<p id="_idParaDest-188" class="Heading-1-1-1"><span class="Heading111Marker">19.2.1 </span><a id="_idTextAnchor252"/><a id="_idIndexMarker446"/><a id="_idIndexMarker447"/><a id="_idIndexMarker448"/><a id="_idIndexMarker449"/>Paravirtualization </p>&#13;
			<p class="My-Basic-Paragraph">Under paravirtualization, the kernel of the guest operating system is modified specifically to run on the hypervisor. This typically involves replacing any privileged operations that will only run in ring 0 of the CPU with calls to the hypervisor (known as <span class="My-Italic _idGenCharOverride-1">hypercalls</span>). The hypervisor, in turn, performs the task on behalf of the guest kernel. This typically limits support to open source operating systems such as Linux which may be freely altered and proprietary operating systems where the owners have agreed to make the necessary code modifications to target a specific hypervisor. These issues notwithstanding, the ability of the guest kernel to communicate directly with the hypervisor results in greater performance levels compared to other virtualization approaches. </p>&#13;
			<p id="_idParaDest-189" class="Heading-1-1-1"><span class="Heading111Marker">19.2.2 </span><a id="_idTextAnchor253"/><a id="_idIndexMarker450"/><a id="_idIndexMarker451"/>Full Virtualization</p>&#13;
			<p class="My-Basic-Paragraph">Full virtualization provides support for unmodified guest operating systems. The term unmodified refers to operating system kernels which have not been altered to run on a hypervisor and therefore still execute privileged operations as though running in ring 0 of the CPU. In this scenario, the hypervisor provides CPU emulation to handle and modify privileged and protected CPU operations made by unmodified guest operating system kernels. Unfortunately this emulation process requires both time and system resources to operate resulting in inferior performance levels when compared to those provided by paravirtualization. </p>&#13;
			<p id="_idParaDest-190" class="Heading-1-1-1"><span class="Heading111Marker">19.2.3 </span><a id="_idTextAnchor254"/><a id="_idIndexMarker452"/><a id="_idIndexMarker453"/><a id="_idIndexMarker454"/><a id="_idIndexMarker455"/><a id="_idIndexMarker456"/><a id="_idIndexMarker457"/>Hardware Virtualization </p>&#13;
			<p class="My-Basic-Paragraph">Hardware virtualization leverages virtualization features built into the latest generations of CPUs from both Intel and AMD. These technologies, known as Intel VT and AMD-V respectively, provide extensions necessary to run unmodified guest virtual machines without the overheads inherent in full virtualization CPU emulation. In very simplistic terms these new processors provide an additional privilege mode (referred to as ring -1) above ring 0 in which the hypervisor can operate, thereby leaving ring 0 available for unmodified guest operating systems. </p>&#13;
			<p class="My-Basic-Paragraph">The following figure illustrates the Type-1 hypervisor approach to virtualization: </p>&#13;
			<p class="My-Basic-Paragraph ParaOverride-1"><img class="_idGenObjectAttribute-3" src="Images/type-1_hypervisor_virtualization.png" alt="" width="422" height="342"/></p>&#13;
			<p class="Figure-Caption"><span class="FigureCaptionMarker">Figure 19-3</span></p>&#13;
			<p class="My-Basic-Paragraph">As outlined in the above illustration, in addition to the virtual machines, an administrative operating system and/or management console also runs on top of the hypervisor allowing the virtual machines to be managed by a system administrator.</p>&#13;
			<p id="_idParaDest-191" class="Heading-1-1"><span class="Heading11Marker">19.3 </span><a id="_idTextAnchor255"/>Virtual Machine Networking</p>&#13;
			<p class="My-Basic-Paragraph">Virtual machines will invariably need to be connected to a network to be of any practical use. One option is for the guest to be connected to a virtual network running within the operating system of the host computer. In this configuration any virtual machines on the virtual network can see each other but access to the external network is provided by <a id="_idIndexMarker458"/>Network Address Translation (<a id="_idIndexMarker459"/>NAT). When using the virtual network and NAT, each virtual machine is represented on the external network (the network to which the host is connected) using the IP address of the host system. This is the default behavior for KVM virtualization on CentOS 8 and generally requires no additional configuration. Typically, a single virtual network is created by default, represented by the name <span class="My-Italic _idGenCharOverride-1">default</span> and the device <span class="My-Italic _idGenCharOverride-1">virbr0</span>.</p>&#13;
			<p class="My-Basic-Paragraph">In order for guests to appear as individual and independent systems on the external network (i.e. with their own IP addresses), they must be configured to share a physical network interface on the host. The quickest way to achieve this is to configure the virtual machine to use the “direct connection” network configuration option (also referred to as the MacVTap) which will provide the guest system with an IP address on the same network as the host. Unfortunately, while this gives the virtual machine access to other systems on the network, it is not possible to establish a connection between the guest and the host when using the MacVTap driver. </p>&#13;
			<p class="My-Basic-Paragraph">A better option is to configure a <span class="My-Italic _idGenCharOverride-1">network bridge</span> interface on the host system to which the guests can connect. This provides the guest with an IP address on the external network while also allowing the guest and host to communicate, a topic which is covered in the chapter entitled <a href="../Text/KVM_Network_Bridge.xhtml#_idTextAnchor285"><span class="My-Italic _idGenCharOverride-1">“Creating a CentOS 8 KVM Networked Bridge Interface”</span></a>. </p>&#13;
			<p id="_idParaDest-192" class="Heading-1-1"><span class="Heading11Marker">19.4 </span><a id="_idTextAnchor256"/>Summary</p>&#13;
			<p class="My-Basic-Paragraph">Virtualization is defined as the ability to run multiple guest operating systems within a single host operating system. A number of approaches to virtualization have been developed including guest operating system and hypervisor virtualization. Hypervisor virtualization falls into two categories known as Type-1 and Type-2. Type-2 virtualization solutions are categorized as para-virtualization, full virtualization and hardware virtualization, the latter making use of special virtualization features of some Intel and AMD processor models.</p>&#13;
			<p class="My-Basic-Paragraph">Virtual machine guest operating systems have a number of options in terms of networking including NAT, direct connection (MacVTap) and network bridge configurations.</p>&#13;
		</div>&#13;
</div>



  </body></html>