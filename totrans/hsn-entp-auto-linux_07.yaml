- en: Using Ansible to Build Virtual Machine Templates for Deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 构建用于部署的虚拟机模板
- en: So far in this book, we have covered in detail the groundwork for the remainder—that
    is to say, we have set the rationale for what we intend to do next and provided
    a *crash course* in our automation tool of choice, Ansible. From the preceding
    chapter, we know that, in an enterprise-scale environment, there are two fundamental
    methods for deploying Linux, and which of these to use is determined by the technologies
    in use in your environment and your intended goals.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已详细介绍了其余部分的基础工作——也就是说，我们已经为接下来的操作奠定了理论基础，并且提供了关于我们选择的自动化工具 Ansible
    的*速成课程*。从前一章中我们知道，在企业规模的环境中，部署 Linux 有两种基本方法，选择哪种方法取决于你环境中使用的技术以及你的目标。
- en: In this chapter, we will cover in detail how to build virtual machine images
    that will serve on most virtualization and cloud platforms. The differences between
    these two platforms are subtle but distinct as we shall find out, and by the end
    of this chapter, you will know how to handle both environments with ease. We will
    start with a discussion on the initial build requirements, and then move on to
    configure and prepare the images for use in your chosen environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细介绍如何构建适用于大多数虚拟化和云平台的虚拟机镜像。这两个平台之间的差异微妙但明显，我们将在本章结束时了解到这一点，并且你将学会轻松处理这两种环境。我们将从讨论初始构建需求开始，然后继续配置并准备镜像以便在你选择的环境中使用。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Performing the initial build
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行初始构建
- en: Using Ansible to build and standardize the template
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 构建和标准化模板
- en: Cleaning up the build with Ansible
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 清理构建
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have access to a virtualization-capable environment
    running Ubuntu 18.04 LTS. Some examples are also performed on CentOS 7\. In either
    of these cases, the examples can be run on either a physical machine (or laptop)
    running one of the aforementioned operating systems, with a process that has virtualization
    extensions enabled or a virtual machine with nested virtualization enabled.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你可以访问运行 Ubuntu 18.04 LTS 的虚拟化环境。一些示例也会在 CentOS 7 上执行。在这两种情况下，示例可以在运行上述操作系统的物理机器（或笔记本电脑）上执行，只要该进程启用了虚拟化扩展，或者在启用了嵌套虚拟化的虚拟机上执行。
- en: Ansible 2.8 is also used later in this chapter and it is assumed you have this
    installed on the Linux host you are using.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后续也会使用 Ansible 2.8，并假设你已经在所使用的 Linux 主机上安装了该版本。
- en: All example code discussed in this chapter is available from GitHub at: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter05](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter05).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中讨论的所有示例代码可以从 GitHub 获取：[https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter05](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter05)。
- en: Performing the initial build
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行初始构建
- en: As discussed in [Chapter 4](2b6b6bcd-287a-4ce9-a2fa-1ecccf3a174b.xhtml), *Deployment
    Methodologies*, whether you are using a traditional virtualization platform such
    as oVirt or VMware or a cloud-based one such as OpenStack or Amazon's EC2, your
    starting point for any Linux deployments (and hence further automation) will be
    a templated image.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第4章](2b6b6bcd-287a-4ce9-a2fa-1ecccf3a174b.xhtml)《部署方法》中讨论的那样，*部署方法*，无论你使用传统的虚拟化平台（如
    oVirt 或 VMware）还是基于云的平台（如 OpenStack 或亚马逊的 EC2），你在任何 Linux 部署（以及随后的自动化）中的起点都会是一个模板镜像。
- en: In terms of the SOE we defined in [Chapter 1](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml),
    *Building a Standard Operating Environment on Linux*, the templated image is the
    very real initial manifestation of this. It is usually a small virtual machine
    image, with just enough software installed and configuration completed that it
    is useful in almost all scenarios it might be deployed in for the enterprise.
    As long as the image boots up cleanly with a unique hostname, SSH host keys, and
    such, then it can be customized almost immediately using further automation as
    we shall discover from [Chapter 7](200bea26-7066-4feb-a571-481a5f047ae4.xhtml),
    *Configuration Management with Ansible*, later in this book. Let's dive into the
    build process by taking a ready-made template image (provided by a third party)
    as our starting point.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们在[第1章](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml)中定义的SOE而言，*在Linux上构建标准操作环境*，模板化镜像就是这一环境的实际初步表现。它通常是一个小型虚拟机镜像，安装了足够的软件并完成了配置，能够在企业的几乎所有部署场景中发挥作用。只要镜像能干净地启动，并且具有唯一的主机名、SSH主机密钥等，那么它几乎可以立即通过进一步的自动化进行定制，正如我们将在本书的[第7章](200bea26-7066-4feb-a571-481a5f047ae4.xhtml)中通过*使用Ansible进行配置管理*了解到的那样。让我们通过采用一个现成的模板镜像（由第三方提供）作为起点来深入了解构建过程。
- en: Using ready-made template images
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现成的模板镜像
- en: For most platforms, there are a large number of readily available images for
    you to download, and again, we discussed a few of these in the previous chapter.
    For many enterprises, these images will be sufficient. However, what if you absolutely
    need full control over your image definition? Perhaps you are adopting a new standard
    (at the time of writing, Red Hat Enterprise Linux 8 has just been released, and
    CentOS 8 will surely follow in due course), and you want to implement it early
    to gain experience and test workloads. What if you operate in a secure environment
    (perhaps payment card industry-compliant), and you absolutely have to have 100%
    confidence in how the image was built and there can be no risk of compromise?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数平台，有大量现成的镜像可以下载，正如我们在上一章中讨论的那样。对于许多企业来说，这些镜像已经足够。但如果你绝对需要完全控制镜像定义呢？也许你正在采用一个新的标准（在写作时，Red
    Hat Enterprise Linux 8刚刚发布，而CentOS 8也将在适当时候发布），并且你希望尽早实现它以获得经验并测试工作负载。如果你在一个安全的环境中工作（可能符合支付卡行业标准），并且你必须对镜像的构建过程100%有信心，不能有任何被妥协的风险，又该如何处理？
- en: This, of course, is not to say that any publicly available images are compromised
    or even likely to be, but historically there have been a handful of *man-in-the-middle*
    or *supply chain* attacks where attackers have compromised services not directly,
    but rather indirectly by attacking common components that are used as building
    blocks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是说任何公开可用的图像都有被妥协的风险，甚至不太可能发生这种情况，但历史上确实出现过少数的*中间人*或*供应链*攻击，攻击者通过攻击常用的组件间接妥协了服务，而非直接攻击服务本身。
- en: Most publicly available images come from trustworthy sources that have put in
    place a variety of checks and controls to ensure their integrity. Provided you
    make use of these checks, and perform due diligence on any images you download,
    most enterprises will find little need to create their own images from scratch,
    as automation tools such as Ansible will take care of all post-deployment configuration.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数公开可用的镜像都来自可信的来源，这些来源已经实施了各种检查和控制，以确保其完整性。只要你利用这些检查，并对下载的任何镜像进行尽职调查，大多数企业会发现几乎没有必要从零开始创建自己的镜像，因为像Ansible这样的自动化工具会处理所有部署后的配置。
- en: 'Let''s take a practical example: suppose that, for a new set of deployments,
    we have decided to create an SOE based upon the Fedora 30 server image, and we
    will be running this on an OpenStack infrastructure:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个实际的例子来说明：假设在一组新的部署中，我们决定基于Fedora 30服务器镜像创建一个标准操作环境（SOE），并将在OpenStack基础设施上运行：
- en: We would download the cloud image from the official Fedora project web site—details
    can be found here, though note that the version number will change over time as
    new releases of Fedora arrive, at [https://alt.fedoraproject.org/cloud/](https://alt.fedoraproject.org/cloud/).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从Fedora项目官方网站下载云镜像—具体详情可以在这里找到，注意版本号会随着Fedora新版本的发布而变化，网址为：[https://alt.fedoraproject.org/cloud/](https://alt.fedoraproject.org/cloud/)。
- en: 'Upon establishing the correct Fedora cloud image for our environment, we can
    download our required image with a command such as this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的环境确定了正确的Fedora云镜像之后，我们可以通过如下命令下载所需的镜像：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Simple enough—now, let's verify it. Verification instructions are normally provided
    with all major Linux releases, whether for ISOs or complete images, and those
    for our Fedora image download can be found at [https://alt.fedoraproject.org/en/verify.html](https://alt.fedoraproject.org/en/verify.html).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很简单——现在，让我们进行验证。验证说明通常会随所有主要 Linux 发行版提供，无论是 ISOs 还是完整的镜像文件，我们的 Fedora 镜像下载的验证说明可以在 [https://alt.fedoraproject.org/en/verify.html](https://alt.fedoraproject.org/en/verify.html)找到。
- en: 'Let''s run through the process and validate our image. First of all, we will
    import the official Fedora GPG key to validate the checksum file to make sure
    it hasn''t been tampered with:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步执行过程并验证我们的镜像。首先，我们将导入官方的 Fedora GPG 密钥来验证校验和文件，以确保它没有被篡改：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we will download the checksum file for the cloud base images and verify
    it:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将下载云基础镜像的校验和文件并进行验证：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Although you may get a warning about the key not being certified by a trusted
    signature (this is a facet of the way GPG key trust is established), the important
    thing is that the signature of the file is validated as good—see the following
    screenshot for an example of the output:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然你可能会收到关于密钥未通过可信签名认证的警告（这是 GPG 密钥信任建立方式的一个方面），但重要的是文件的签名已被验证为有效——请参阅下面的截图，了解输出的示例：
- en: '![](img/68e73909-46e1-444f-9321-e319b0c49493.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68e73909-46e1-444f-9321-e319b0c49493.png)'
- en: 'As long as the signature verifies successfully, the last step is to validate
    the actual image against the checksums themselves, with the following command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要签名验证成功，最后一步就是使用以下命令将实际镜像与校验和进行验证：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will get errors for any files that are in the `*-CHECKSUM` file that you
    haven''t downloaded, but as you can see in the following screenshot, our downloaded
    image matches the checksum in the file and so we can proceed to use it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何你没有下载的 `*-CHECKSUM` 文件中的文件，你会收到错误。但正如下面截图所示，我们下载的镜像与文件中的校验和匹配，因此可以继续使用它：
- en: '![](img/80e48215-c119-48d2-9e3c-27370deea527.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80e48215-c119-48d2-9e3c-27370deea527.png)'
- en: With these steps completed, we can proceed to use the downloaded image in our
    OpenStack platform. You may, of course, want to customize this image after deployment,
    and we will look at ways to do this later in this book. Just because you have
    chosen an *off-the-shelf* image does not mean it has to remain that way. Note
    that these steps will vary slightly for each Linux distribution, but the high-level
    procedure should be the same. The important thing is to validate all downloaded
    images.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们可以继续在我们的 OpenStack 平台上使用下载的镜像。当然，部署后你可能想要定制这个镜像，后续我们会探讨如何进行定制。选择了一个*现成的*镜像并不意味着它必须保持原样。请注意，这些步骤在不同的
    Linux 发行版中会有一些细微的差异，但整体流程应该是相同的。重要的是要验证所有下载的镜像。
- en: There is also an issue of trust surrounding the use of publicly available operating
    system images. How do you know that the author removed all redundant services
    and sysprepped the image correctly? How do you know that there are no back doors
    or other vulnerabilities? Although there are many excellent publicly available
    images out there, you should always perform due diligence on any that you download
    and ensure they are fit for your environment.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公共操作系统镜像时，也有一个关于信任的问题。你怎么知道作者已经移除了所有冗余服务并正确地进行了 sysprep 操作？你怎么知道其中没有后门或其他漏洞？尽管有很多优秀的公共可用镜像，但你在下载任何镜像时应始终进行尽职调查，确保它们适合你的环境。
- en: What if you absolutely have to generate your own image, however? We will explore
    this in the next part of this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果你必须生成自己的镜像呢？我们将在本章的下一部分进行探讨。
- en: Creating your own virtual machine images
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你自己的虚拟机镜像
- en: The preceding process described will be fine for many enterprises, but sooner
    or later, the requirement will come about to create your own completely customized
    virtual machine image. Fortunately, modern Linux distributions make it easy to
    achieve this, and you don't need to even be on the same platform as you are building.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前述过程适用于许多企业，但迟早会有需求，要求创建自己完全定制的虚拟机镜像。幸运的是，现代 Linux 发行版使得这一过程变得简单，你甚至不需要在与构建镜像相同的平台上操作。
- en: 'Let''s take a look at building a CentOS 7.6 virtual machine image using an
    Ubuntu 18.04 Server host:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何使用 Ubuntu 18.04 Server 主机构建 CentOS 7.6 虚拟机镜像：
- en: The first step before we begin is to ensure that the build host is capable of
    running virtual machines—this is normally a set of CPU extensions that are included
    with most modern x86 systems. It is also possible to build virtual machine images
    using nested virtualization, that is, to create a virtual machine within another
    virtual machine. However, to do this, you will have to enable virtualization support
    in your build VM. The process for this varies from one hypervisor to another,
    and so we will not go into detail on this here.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始之前，第一步是确保构建主机能够运行虚拟机——这通常是一组包含在大多数现代 x86 系统中的 CPU 扩展。也可以通过嵌套虚拟化来构建虚拟机镜像，即在另一个虚拟机内创建虚拟机。然而，要做到这一点，你必须在构建虚拟机中启用虚拟化支持。这个过程因虚拟化平台不同而异，因此我们在这里不进行详细介绍。
- en: If you are using a VMware hypervisor to perform nested virtualization, you will
    need to enable **code profiling** support for the CPU as well as enabling **hypervisor
    applications**—some of the steps in this process will fail otherwise.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 VMware 虚拟化平台来执行嵌套虚拟化，你还需要启用 **代码分析** 支持以及启用 **虚拟化应用程序**——否则，这一过程中的某些步骤将无法成功。
- en: 'Once you have your build host up and running, you will need to install the
    Linux **Kernel-based Virtual Machine** (**KVM**) toolset—the commands to do this
    will vary depending upon your build host version of Linux, but on our Ubuntu host,
    we need to run the following commands:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你的构建主机启动并运行，你需要安装 Linux **基于内核的虚拟机**（**KVM**）工具集——执行这些命令的方式会根据你的构建主机的 Linux
    版本有所不同，但在我们的 Ubuntu 主机上，我们需要运行以下命令：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note the need to add your user account to two KVM-related groups—you will also
    need to log out and back in again for these group changes to take effect.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，需要将你的用户帐户添加到两个与 KVM 相关的用户组——你还需要注销并重新登录，以使这些用户组变更生效。
- en: 'Once this is complete, you will also need to download a local copy of the ISO
    image for your chosen Linux image. I use the following command to download an
    ISO image as it is sufficient for the CentOS 7.6 SOE image I am going to create:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，你还需要下载你选择的 Linux 镜像的本地 ISO 副本。我使用以下命令下载 ISO 镜像，这对于我要创建的 CentOS 7.6 SOE
    镜像来说已足够：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With all of these pieces in place, you will now create an empty virtual machine
    disk image. The best format to choose for this is the **Quick Copy On Write** (**QCOW2**)
    format, which is compatible with OpenStack and most public cloud platforms. Hence,
    we will make this image as generic as possible to enable the widest array of support
    possible.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些所有步骤准备好后，你现在将创建一个空的虚拟机磁盘镜像。最适合选择的格式是 **快速写时复制**（**QCOW2**）格式，这与 OpenStack
    和大多数公共云平台兼容。因此，我们将尽量使这个镜像尽可能通用，以便支持尽可能广泛的环境。
- en: 'To create a blank 20 GB QCOW2 image in the current directory, we would run
    the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要在当前目录中创建一个空白的 20 GB QCOW2 镜像，我们可以运行以下命令：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that other image formats are available. If, for example, you were building
    exclusively for VMware, it would make sense to use the VMDK format instead:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，其他镜像格式也是可用的。例如，如果你只为 VMware 构建镜像，那么使用 VMDK 格式会更合适：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that both these commands create sparse images—that is, they are only as
    big as the data and metadata they contain. They can be turned later into pre-allocated
    images by your chosen hypervisor platform if you wish:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个命令创建的是稀疏镜像——也就是说，它们的大小仅与其包含的数据和元数据大小相等。如果你愿意，它们以后可以通过你选择的虚拟化平台转换为预分配的镜像：
- en: '![](img/6a50e71b-ae66-42ef-b2ec-7ea8e0f67efd.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a50e71b-ae66-42ef-b2ec-7ea8e0f67efd.png)'
- en: 'With the empty disk images created, it''s time to install the VM image:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建好空的磁盘镜像后，是时候安装虚拟机镜像了：
- en: We will use the `virt-install` command to achieve this, which basically runs
    up a temporary VM for OS installation. Don't worry about parameters such as CPU
    and memory—as long as these are sufficient for the OS installation to be run,
    they will be fine—they do not have any bearing on the deployed virtual machine.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`virt-install`命令来实现这一点，该命令基本上会启动一个临时虚拟机来进行操作系统安装。不要担心像 CPU 和内存等参数——只要它们足够支持操作系统的安装，它们就没问题——这些不会影响已部署的虚拟机。
- en: Note the use of VNC in the `--graphics vnc,listen=0.0.0.0` option—we will use
    this to remotely control the virtual machine and complete the installation. You
    can choose another graphics option, such as SPICE, if you prefer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`--graphics vnc,listen=0.0.0.0`选项中使用了 VNC——我们将使用它来远程控制虚拟机并完成安装。如果你喜欢，也可以选择其他图形选项，如
    SPICE。
- en: 'The following command is an example of how to use `virt-install` to create
    a CentOS 7 image from the ISO we downloaded earlier, using the preceding 20 GB
    QCOW2 disk image we created:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令是如何使用`virt-install`从我们之前下载的ISO创建CentOS 7镜像的示例，使用我们之前创建的20 GB QCOW2磁盘镜像：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Most of these parameters are self-explanatory, but pay particular attention
    to your environment. For example, if you have edited or removed the `default`
    network, the preceding command will fail. Similarly, ensure the correct paths
    for all files referenced.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数大多数都是自解释的，但请特别注意你的环境。例如，如果你编辑或删除了`default`网络，前面的命令将会失败。类似地，确保所有引用文件的路径是正确的。
- en: To see the list of supported `--os-variant` parameters, run the `osinfo-query
    os` command.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看支持的`--os-variant`参数列表，请运行`osinfo-query os`命令。
- en: Naturally, you would vary these parameters according to the operating system
    you are installing, your disk image name, and so on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，你需要根据所安装的操作系统、磁盘镜像名称等来调整这些参数。
- en: 'For now, let''s run this command—when successful, it should inform you that
    you can connect to the virtual machine console to continue:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们运行这个命令——如果成功，它会提示你可以连接到虚拟机控制台以继续操作：
- en: '![](img/eb890b7d-29e5-4b31-9335-642fcde2a1df.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb890b7d-29e5-4b31-9335-642fcde2a1df.png)'
- en: 'We will now connect to it from another shell using the `virt-viewer` utility:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将使用`virt-viewer`工具从另一个终端连接到它：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'From here, you will install the operating system in the normal way. As we have
    discussed in [Chapter 4](2b6b6bcd-287a-4ce9-a2fa-1ecccf3a174b.xhtml), *Deployment
    Methodologies*, try to go for the most minimal install that you can. Don''t worry
    too much about hostname and such, as these should get set later as part of the
    deployment process; specify the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，你将以正常方式安装操作系统。正如我们在[第4章](2b6b6bcd-287a-4ce9-a2fa-1ecccf3a174b.xhtml)《部署方法论》中讨论过的，*尽量选择最小化安装*。不要太担心主机名等问题，因为这些应该在后续的部署过程中设置；请指定以下内容：
- en: Choose KEYBOARD and LANGUAGE SUPPORT most relevant to your locale.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择与本地环境最相关的**键盘和语言支持**。
- en: Choose the appropriate DATE & TIME settings for your country.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择适合你所在国家的**日期与时间**设置。
- en: Ensure SOFTWARE SELECTION is Minimal Install (this is the default).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保**软件选择**为“最小化安装”（这是默认选项）。
- en: Set INSTALLATION DESTINATION—there will only be one virtual hard drive attached
    to this VM using the preceding `virt-install` command, so this is simply a matter
    of selecting it.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置**安装目标**——使用前面的`virt-install`命令，只有一个虚拟硬盘附加到该虚拟机，因此只需选择它即可。
- en: Enable or disable KDUMP as appropriate.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要启用或禁用KDUMP。
- en: Ensure networking is enabled under NETWORK & HOST NAME.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**网络与主机名称**中启用网络。
- en: 'The resulting CentOS 7 installation settings screen should look something like
    the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是一个CentOS 7安装设置界面，类似于下面的截图：
- en: '![](img/7ff215f0-0956-47b4-a09b-f255467de7e3.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ff215f0-0956-47b4-a09b-f255467de7e3.png)'
- en: Allow the installation to complete as normal, and then log into the VM you have
    just created. Once logged into the running VM, you should perform any and all
    customization that you want to appear in the final version of the VM template.
    In the next section of this chapter, we will go into the use of Ansible for configuring
    deployed virtual machines, and using it to build templates is no different—hence,
    to prevent overlap with later chapters, we will not go into details of Ansible
    configuration work here.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 允许安装按正常流程完成，然后登录到你刚创建的虚拟机。一旦登录到运行中的虚拟机，你应该进行所有希望出现在最终虚拟机模板中的定制设置。在本章的下一节中，我们将介绍如何使用Ansible配置已部署的虚拟机，并且使用Ansible构建模板没有什么不同——因此，为了避免与后续章节的内容重叠，我们这里不会详细讲解Ansible配置工作。
- en: 'When your VM goes to reboot after the initial installation, you may find that
    it shuts down. If it does, you will need to undefine it using the `virsh` utility,
    and then run it again using a slight variant on our previous `virt-install` command,
    telling `virt-install` to boot this time from the hard drive image rather than
    the CD:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的虚拟机在初始安装后重新启动时，你可能会发现它关闭了。如果发生这种情况，你需要使用`virsh`工具将其取消定义，然后使用我们之前的`virt-install`命令的轻微变种重新运行它，并告诉`virt-install`这次从硬盘镜像启动，而不是从光盘启动：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It is worth noting at this stage that most cloud platforms, whether OpenStack,
    **Amazon Web Services** (**AWS**) or otherwise, all make use of the `cloud-init`
    utility to perform the initial configuration of the virtual machine image once
    it is deployed and running. Hence, as a bare minimum, we will install this in
    our VM image before we shut it down. The following are the listed commands required
    to install this manually and, in the next section, we will turn this into an Ansible
    role for installation:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段需要注意的是，大多数云平台，无论是 OpenStack、**Amazon Web Services**（**AWS**）还是其他平台，都使用
    `cloud-init` 工具来执行虚拟机镜像部署并运行后的初始配置。因此，作为最低要求，我们将在关闭虚拟机之前将其安装到我们的虚拟机镜像中。以下是手动安装该工具所需的命令，接下来我们将把它转化为
    Ansible 角色进行安装：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When you have completed these commands successfully, you will probably need
    to customize `/etc/cloud/cloud.cfg` to configure `cloud-init` for the environment
    you will use it in, although the default configuration serves as a good start
    for many environments.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你成功执行这些命令后，你可能需要自定义 `/etc/cloud/cloud.cfg` 以配置 `cloud-init`，适配你将使用的环境，尽管默认配置已经适用于许多环境，并且可以作为良好的起点。
- en: Configuring `cloud-init` is left as an exercise for you, given the wide variety
    of cloud platforms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 `cloud-init` 作为练习留给你，因为云平台种类繁多。
- en: Finally, when you have performed any other customization you need, you can now
    shut the virtual machine down. Make sure to shut it down cleanly rather than simply
    powering it off, as this is going to become a template to be deployed at scale.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你完成任何其他自定义配置后，你可以关闭虚拟机。确保干净地关闭虚拟机，而不是直接断电，因为这将成为一个模板，用于大规模部署。
- en: Once the virtual machine has been shut down, the next step is to run **system
    preparation** (**sysprep**) on the image, and then to compact the sparse image
    file to make it as small as possible for distribution and archival.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦虚拟机关闭，接下来的步骤是对镜像执行 **系统准备**（**sysprep**），然后压缩稀疏镜像文件，使其尽可能小，以便分发和存档。
- en: 'The process of sysprepping is to prepare an image for deployment at scale.
    Hence, all uniquely identifiable parameters will be wiped to produce a clean image
    for deployment at scale, such as the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Sysprep 过程是为大规模部署准备镜像。因此，所有唯一可识别的参数将被清除，以生成一个干净的镜像用于大规模部署，具体包括以下内容：
- en: SSH host keys
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSH 主机密钥
- en: History files
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史文件
- en: Local session configuration
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地会话配置
- en: Log files
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志文件
- en: MAC address references in network configuration
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络配置中的 MAC 地址引用
- en: 'The preceding list is not exhaustive though—there are numerous items to clean
    up for an image to be considered truly clean and ready for deployment, and it
    would warrant an entire chapter by itself to explain them all. Fortunately for
    us, there are two commands in the suite of KVM tools that perform exactly these
    tasks for us:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表并不是详尽无遗的——实际上还有很多需要清理的项目，才能确保镜像真正干净并准备好部署，解释这些内容将需要一个完整的章节。幸运的是，我们可以使用
    KVM 工具集中的两个命令来执行这些任务：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Although the output from the first command is too lengthy to fit in a single
    screenshot, it shows the wide variety of tasks that are considered necessary as
    part of sysprep, and if you find yourself running through this process either
    manually or with Ansible, the `virt-sysprep` utility should give you a good guideline
    as to the tasks you should perform:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管第一个命令的输出太长，无法放在一张截图中，但它展示了作为 sysprep 过程的一部分，所需执行的各种任务。如果你发现自己手动或使用 Ansible
    执行该过程，`virt-sysprep` 工具将为你提供有关应执行任务的良好指导：
- en: '![](img/82944a6d-dce7-43a5-b01e-f29bd8eefc68.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82944a6d-dce7-43a5-b01e-f29bd8eefc68.png)'
- en: 'Finally, we re-sparsify the disk image, effectively compacting it for efficient
    storage. Note that if you get any free space warnings when running this tool (it
    requires a great deal of space in `/tmp` by default—the exact amount will be determined
    by the size of your virtual disk image), you should generally not ignore them,
    as there is a chance the utility will fill up your partition, hence stopping your
    build host from working correctly:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们再次将磁盘镜像稀疏化，实际上是压缩它，以便高效存储。请注意，如果在运行此工具时收到任何免费空间警告（默认情况下它需要在 `/tmp` 中大量空间——具体大小由虚拟磁盘镜像的大小决定），你通常不应忽略这些警告，因为工具可能会填满你的分区，从而导致构建主机无法正常工作：
- en: '![](img/8f5bb278-21b5-4515-961a-50d27b21df6d.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f5bb278-21b5-4515-961a-50d27b21df6d.png)'
- en: The steps performed in this part of this chapter should work for just about
    any Linux distribution, being built on just about any Linux host. As ever, refer
    to the documentation for your preferred distribution for guidance on package names.
    Nonetheless, by following this process, you have now successfully built yourself
    a completely bespoke cloud image, which you should be able to upload to many of
    the popular cloud and hypervisor platforms.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本章这一部分执行的步骤应该适用于几乎任何Linux发行版，并且可以在几乎任何Linux主机上构建。像往常一样，参考你首选的发行版文档，获取有关软件包名称的指导。然而，通过遵循这个过程，你现在已经成功构建了一个完全定制的云镜像，应该能够将其上传到许多流行的云平台和虚拟化平台。
- en: From here, we will take a more detailed look at customizing the template with
    Ansible, rather than entering commands manually as we did in this section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们将更加详细地了解如何使用Ansible自定义模板，而不是像本节中那样手动输入命令。
- en: Using Ansible to build and standardize the template
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible构建和标准化模板
- en: You should, by now, have a base Linux image for deployment in your enterprise.
    If you chose to download a ready-made template (or indeed, to make use of one
    provided by a public cloud provider), then your image will be very much a blank
    template, ready for customization. If you chose to build your own, then you may
    have already chosen to perform a small amount of customization such as the installation
    of `cloud-init` that we performed earlier. You will note, however, that we did
    this by hand, which is hardly along the line of the scalable, repeatable, auditable
    processes that we have lauded throughout the early parts of this book. As we proceed
    through this section of this chapter, we will take a look at how to customize
    a base template, regardless of its origin, using Ansible.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经有了一个用于部署到企业中的基础Linux镜像。如果你选择下载一个现成的模板（或者实际上，使用公共云提供商提供的模板），那么你的镜像将非常类似于一个空白模板，准备好进行定制。如果你选择自己构建，那么你可能已经选择执行了一些小的定制，如我们之前安装的`cloud-init`。然而，你会注意到，我们是手动进行的，这与我们在本书早期部分所推崇的可扩展、可重复和可审计的过程有些不一致。随着我们继续本章的这一部分，我们将了解如何使用Ansible定制基础模板，无论它的来源如何。
- en: 'There is no one-size-fits-all Linux image that will suit everyone, and as a
    result, this chapter is not definitive. We will, however, look at some of the
    more common tasks that might be associated with customizing as an image for deployment,
    such as the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种适用于所有人的Linux镜像，因此，本章并不是一个终极指南。然而，我们将查看一些与定制部署镜像相关的常见任务，如下所示：
- en: Transferring files into the image
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件传输到镜像中
- en: Installing packages
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装软件包
- en: Editing configuration files
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑配置文件
- en: Validating the image
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证镜像
- en: Through a combination of these examples, most readers should be able to customize
    their own images to their requirements with ease. Let's start exploring this in
    greater depth with a look at how to transfer files into the virtual machine image
    we created previously using Ansible.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些示例的结合，大多数读者应该能够轻松地根据自己的要求定制自己的镜像。让我们开始更深入地探索，看看如何使用Ansible将文件传输到我们之前创建的虚拟机镜像中。
- en: Transferring files into the image
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文件传输到镜像中
- en: 'It is commonplace, in the experience of the author, to need to *inject* files
    into an operating system image to ensure it meets a given set of requirements.
    These files might be a simple text file, such as an enterprise-standard *message
    of the day*, a configuration file for an existing package, or perhaps even a binary
    file that is not available in a package. Ansible can handle all of these with
    ease, so let''s look at some specific examples. As it is generally good practice
    to write your Ansible code in roles to support reuse and readability, we will
    define a role for our example here. In this example, I am making the following
    assumptions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在作者的经验中，*注入*文件到操作系统镜像中以确保其符合给定的要求是非常常见的做法。这些文件可能是一个简单的文本文件，例如企业标准的*每日信息*、现有软件包的配置文件，或者甚至是一个在软件包中没有的二进制文件。Ansible可以轻松处理所有这些问题，因此让我们来看看一些具体的例子。由于将Ansible代码写成角色以支持重用性和可读性通常是一个好习惯，我们将在这里为我们的示例定义一个角色。在这个示例中，我做出以下假设：
- en: We have downloaded/built our Linux template as outlined in the previous section
    of this chapter.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经按照本章前面的部分下载/构建了我们的Linux模板。
- en: We are running this bare template in a virtual machine.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在虚拟机中运行这个裸模板。
- en: The IP address of this virtual machine is `192.168.81.141`.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个虚拟机的IP地址是`192.168.81.141`。
- en: 'The virtual machine has a user account already set up with the following credentials:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机已经配置了一个用户账户，凭证如下：
- en: Username: `imagebuild`.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名：`imagebuild`。
- en: Password: `password`.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码：`password`。
- en: This account is sudo-enabled.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此账户启用了sudo权限。
- en: 'Naturally, we would not distribute a cloud image with a sudo-enabled account
    that uses a weak password like this, so we are assuming we will use this account
    during the build phase only and then will remove it during the cleanup phase.
    Ansible needs to be able to connect to a remote host to perform its magic, but
    the account it uses can be transient in nature and removed after use:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们不会分发一个包含启用了sudo权限且使用这种弱密码的账户的云镜像，因此我们假设在构建阶段只会使用此账户，之后将在清理阶段将其移除。Ansible需要能够连接到远程主机以执行其任务，但它使用的账户可以是暂时性的，任务完成后可以删除。
- en: 'Under our example, we would create an inventory file that looks like this—yours
    will undoubtedly be different and customizing it for your image and environment
    is left as an exercise for you:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据我们的示例，我们将创建一个清单文件，其内容如下——你创建的文件可能会有所不同，如何根据你的镜像和环境定制它将留给你作为练习：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a very simple example; in many ways, it is the bare minimum needed for
    this process when we do not have SSH key authentication configured. Often SSH
    keys are the best way to handle SSH authentication as they offer several benefits,
    not least that tasks can run without a password prompt.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的示例；从某种意义上说，当我们没有配置SSH密钥认证时，这是执行此过程所需的最基本步骤。通常，SSH密钥是处理SSH认证的最佳方式，因为它们有多种优点，最重要的是任务可以在没有密码提示的情况下运行。
- en: Although this inventory file is intended to be transient in nature, it is still
    best practice to use `ansible-vault` to store passwords and this is recommended
    here. For the sake of simplicity in this chapter and to reduce the number of steps
    that you need to complete, we will leave the passwords unencrypted (in cleartext).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个清单文件的本意是暂时性的，但使用`ansible-vault`来存储密码仍然是最佳实践，本文建议使用此方法。为了简化本章内容并减少所需的步骤，我们将密码保持未加密（明文）。
- en: 'Next, we''ll create the basic directory structure for our role:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为角色创建基本的目录结构：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s create a few sample files to copy across. First of all, create
    a customized message to append to the message of the day in `roles/filecopyexample/files/motd`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一些示例文件以便复制。首先，在`roles/filecopyexample/files/motd`中创建一个定制的消息，附加到每日消息中：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s also create a new configuration file for the `chrony` service to synchronize
    time to our corporate time servers in `roles/filecopyexample/files/chrony.conf`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将为`chrony`服务创建一个新的配置文件，以将时间同步到我们公司内部的时间服务器，文件路径为`roles/filecopyexample/files/chrony.conf`：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We intend to copy these two files across to the remote server. However, Ansible
    is not limited to copying files from the Ansible host—it can also download files
    from a remote server directly to the target host:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算将这两个文件复制到远程服务器。然而，Ansible不仅限于从Ansible主机复制文件——它还可以直接从远程服务器下载文件到目标主机：
- en: Let's suppose your build is going to need `docker-compose`—we could download
    this from an internal server, or even directly from the internet if your image
    machine has access to the internet. Suppose we want to install `docker-compose` 1.18.0
    into our images, we can instruct Ansible to download this directly from [https://github.com/docker/compose/releases/download/1.18.0/docker-compose-Linux-x86_64](https://github.com/docker/compose/releases/download/1.18.0/docker-compose-Linux-x86_64).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你的构建需要`docker-compose`——我们可以从内部服务器下载它，或者如果你的镜像机器可以访问互联网，也可以直接从网上下载。假设我们想将`docker-compose`
    1.18.0安装到镜像中，我们可以指示Ansible直接从[https://github.com/docker/compose/releases/download/1.18.0/docker-compose-Linux-x86_64](https://github.com/docker/compose/releases/download/1.18.0/docker-compose-Linux-x86_64)下载它。
- en: 'Now, let''s build our role to copy across our two files and download `docker-compose` into
    our image—this must be written in `roles/filecopyexample/tasks/main.yml`. The
    first part of this role is shown in the following code, and serves to copy across
    the two configuration files we discussed earlier:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个角色，将这两个文件复制到目标主机，并将`docker-compose`下载到镜像中——这必须写在`roles/filecopyexample/tasks/main.yml`中。角色的第一部分如下所示，它负责复制我们之前讨论的两个配置文件：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The role then continues, with the task of installing `docker-compose` on the
    VM image:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，角色将继续执行在虚拟机镜像上安装`docker-compose`的任务：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Hence, our role is now complete, though be sure to customize it correctly for
    your environment. For example, it is likely a newer version of `docker-compose`
    might be available and this will mean a change to the `url` parameter of the preceding `get_url`
    module.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的角色现在已经完成，但请确保根据你的环境正确自定义它。例如，可能会有更新版本的`docker-compose`，这意味着要更改前面`get_url`模块中的`url`参数。
- en: The path of the `chrony` configuration file may vary depending on your operating
    system—check this before running the preceding playbook. The path shown in the
    example is suitable for a CentOS 7 system like the one we built earlier.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`chrony`配置文件的路径可能会根据你的操作系统而有所不同——在运行前面的播放剧本之前，请检查此路径。示例中显示的路径适用于像我们之前构建的CentOS
    7系统。'
- en: 'Finally, we will create a file in the top-level directory (where the `roles/` directory
    was created) called `site.yml` to call and run this role. This should contain
    the following:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在顶层目录中创建一个名为`site.yml`的文件（该目录是之前创建`roles/`目录的地方），用来调用并运行这个角色。这个文件应包含以下内容：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, let''s run our example with the `ansible-playbook -i hosts site.yml` command and
    see what happens:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用`ansible-playbook -i hosts site.yml`命令运行我们的示例，看看会发生什么：
- en: '![](img/95176795-3eef-4217-91fa-9184a6a6388f.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95176795-3eef-4217-91fa-9184a6a6388f.png)'
- en: As we can see, the `changed` statuses tell us that all three of our files were
    transferred or downloaded successfully, and by way of example, we can see that
    it is now possible to run `docker-compose`, which was installed during the playbook
    run (though this would require Docker to run correctly, which we have not installed
    as part of this example).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`changed`状态告诉我们，所有三个文件都已经成功传输或下载，作为示例，我们可以看到现在可以运行`docker-compose`，这个工具是在播放剧本执行期间安装的（虽然这需要Docker正确运行，而我们没有在这个示例中安装Docker）。
- en: Obviously this example has made a fundamental assumption—that the `chrony` package
    was installed on our example image during the build phase. Although it makes sense
    to start with a minimal operating system image for the reasons we have discussed
    previously, there is almost certainly going to be a requirement to install a few
    supplemental packages on the basic build, and we will explore this in the next
    section.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这个例子做了一个基本假设——在我们示例镜像的构建阶段，已经安装了`chrony`包。尽管从我们之前讨论的原因来看，从一个最小化的操作系统镜像开始是有道理的，但几乎肯定会有需要在基础构建上安装一些额外软件包的要求，我们将在下一节探讨这一点。
- en: Installing packages
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装软件包
- en: We have looked at how to install a standalone binary such as `docker-compose` in
    the previous section—but what if we need to actually install some additional operating
    system packages that were not installed in our base image? For example, `cloud-init` is
    incredibly useful in most cloud environments but was not included in our minimal
    CentOS 7 install that we performed earlier.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中讨论了如何安装像`docker-compose`这样的独立二进制文件——但如果我们需要安装一些在基础镜像中没有安装的操作系统软件包怎么办？例如，`cloud-init`在大多数云环境中非常有用，但在我们之前进行的最小化CentOS
    7安装中并没有包含。
- en: 'Here, again, Ansible can help—this time, we will define a role to install the
    packages we require. We''ll reuse the inventory file from the previous section
    and create a new role called `packageinstall` in the same manner that we did before:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Ansible再次可以派上用场——这一次，我们将定义一个角色来安装所需的软件包。我们将重用上一节中的清单文件，并以我们之前的方式创建一个名为`packageinstall`的新角色：
- en: Now, the preceding example on copying files would work on all Linux distributions—the
    only thing you need to be mindful of is where destination files might life. For
    example, our CentOS 7 VM image will have the `chrony` configuration file installed
    in `/etc/chrony.conf`, whilst an Ubuntu 18.04 LTS server would have it in `/etc/chrony/chrony.conf`.
    Apart from this small change to the `dest:` parameter of the `copy` module, the
    code would remain the same.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，前面的复制文件示例将适用于所有Linux发行版——你需要注意的唯一事情是目标文件可能的位置。例如，我们的CentOS 7虚拟机镜像将把`chrony`配置文件安装在`/etc/chrony.conf`，而Ubuntu
    18.04 LTS服务器则会把它安装在`/etc/chrony/chrony.conf`。除了`copy`模块中`dest:`参数的这个小改动，代码保持不变。
- en: Unfortunately, it gets a little more complex with package installation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，软件包安装会变得更加复杂。
- en: 'Let''s suppose we want to install `cloud-init` and `docker` on our CentOS 7
    example image—the role required to do this might look like this:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们想在CentOS 7示例镜像上安装`cloud-init`和`docker`——实现这一目标的角色可能如下所示：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We must install the EPEL repository first, and then we can install the required
    packages. When we run it, the output should look something like this:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须首先安装 EPEL 仓库，然后才能安装所需的包。当我们运行时，输出应该类似于以下内容：
- en: '![](img/118e82be-2c14-41ed-85f8-006698478d55.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/118e82be-2c14-41ed-85f8-006698478d55.png)'
- en: 'If you are using a different Linux distribution, then you need to vary the
    package manager accordingly. For example, on distributions that use the `apt`
    package manager such as Debian or Ubuntu, the equivalent Ansible role would look
    like the following block of code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是其他 Linux 发行版，那么需要相应地更改包管理器。例如，在使用`apt`包管理器的 Debian 或 Ubuntu 等发行版中，相应的
    Ansible 角色将类似于以下代码块：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note the change in module from `yum` to `apt`, and the different package name
    used for the Docker container service. Other than that, the playbook is almost
    identical.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意模块从`yum`变更为`apt`，以及用于 Docker 容器服务的不同包名。除此之外，剧本几乎是相同的。
- en: We can improve on this further—this different results in the need to maintain
    two different roles for two different operating system bases—but what if we could
    intelligently combine them into one? Fortunately, the facts that Ansible gathers
    when it first runs can be used to identify the operating system and, as such,
    run the correct code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步改进这一点——这会导致需要为两种不同的操作系统维护两个不同的角色——但如果我们能够智能地将它们合并为一个呢？幸运的是，Ansible 在首次运行时收集的信息可以用来识别操作系统，因此可以运行正确的代码。
- en: 'We will repurpose our earlier example code to combine both of these installations
    into one Ansible role:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用之前的示例代码，将这两项安装合并为一个 Ansible 角色：
- en: 'The first part of the code is almost identical to the preceding example, except
    that we have now specified the `when` clause to ensure it is only run on Debian-
    or Ubuntu-based Linux distributions:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的第一部分与前面的示例几乎相同，唯一的不同是我们现在指定了`when`子句，确保它仅在 Debian 或 Ubuntu 基础的 Linux 发行版上运行：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We then add two further tasks that perform the required steps to install Docker
    on CentOS or Red Hat Enterprise Linux:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加了两个额外的任务，执行在 CentOS 或 Red Hat Enterprise Linux 上安装 Docker 所需的步骤：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice again the `when` clauses under each task—these specific examples are
    used to determine whether the tasks should be run depending on the facts that
    Ansible obtained during the initial part of the run. Hence, if we now run this
    role on an Ubuntu system, we see the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意每个任务下的`when`子句——这些特定的示例用于根据 Ansible 在初次运行时收集的事实来判断任务是否应该执行。因此，如果我们现在在 Ubuntu
    系统上运行此角色，我们会看到以下内容：
- en: '![](img/310c40fb-430c-4466-b821-3344f81faa97.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/310c40fb-430c-4466-b821-3344f81faa97.png)'
- en: 'As you can see, the first task related to `apt` was run, but the two following
    ones based on `yum` were skipped because the conditions of the `when` clause were
    not met. Now, if we run it on a CentOS 7 target instead, we see this:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，首先与`apt`相关的任务已运行，但随后基于`yum`的两个任务被跳过了，因为`when`子句的条件没有满足。现在，如果我们将其应用于 CentOS
    7 目标，则会看到如下内容：
- en: '![](img/03714111-8f66-426d-9fe6-a83fe2a30983.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03714111-8f66-426d-9fe6-a83fe2a30983.png)'
- en: 'The inverse is now true: the `apt` task was skipped, but the two `yum` related
    tasks were run. In this way, it is possible to maintain a single role for installing
    a common set of package requirements, even when dealing with several different
    base operating systems. Combining `when` clauses with Ansible facts is a very
    powerful way to ensure the correct behavior of a single code base across a variety
    of systems, and hence if your SOE does extend to both Debian and Red Hat-based
    systems, you can still maintain code with ease and simplicity.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在情况正好相反：`apt`任务被跳过，但与`yum`相关的两个任务被执行。通过这种方式，即使在处理几个不同的基础操作系统时，也可以维护一个安装通用软件包需求的单一角色。将`when`子句与
    Ansible 收集的事实结合起来，是确保单一代码库在多种系统上正确运行的强大方式，因此，如果你的 SOE 涵盖了 Debian 和基于 Red Hat 的系统，你仍然可以轻松简便地维护代码。
- en: Once supplemental packages have been installed, they often must be configured
    for them to be useful. In the next section, we will explore the use of Ansible
    in editing configuration files.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦补充包安装完成，通常需要进行配置才能使其发挥作用。在接下来的部分，我们将探讨在编辑配置文件时如何使用 Ansible。
- en: Editing configuration files
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑配置文件
- en: So far, all of the configuration work we have performed has been very black
    and white—we are either installing something (be that a file or a package), or
    we could equally and just as easily delete it (more on this in the section on
    cleaning up). However, what if something more subtle is required? Earlier in this
    chapter, in the section entitled *Transferring files into the image*, we replaced
    the entire `chrony.conf` file with our own version. This, however, might be a
    bit too much brute force—for example, we might only need to change one line in
    a file, and replacing the entire file to change one line is a bit heavy-handed,
    especially when you consider that the configuration file might get updated in
    a future package version.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的所有配置工作都是非常简单明了的——我们要么在安装某些东西（无论是文件还是软件包），要么同样轻松地删除它（关于这一点将在清理部分进一步讲解）。但是，如果需要更为微妙的操作呢？在本章之前的*将文件传输到镜像中*部分，我们替换了整个`chrony.conf`文件，使用了我们自己的版本。然而，这种做法可能有点过于暴力——例如，我们可能只需要更改文件中的一行，而为了修改一行就替换整个文件，这种方式有些过重，特别是考虑到配置文件可能会在未来的软件包版本中更新。
- en: 'Let''s take another common operating system image configuration requirement:
    SSH daemon security. By default, CentOS 7 installations like the one we created
    earlier allow remote logins from the root account. This is not desirable for security
    reasons, so the question is, how do we update the SSH daemon configuration without
    having to replace the entire file? Luckily, Ansible has modules for just such
    a task.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看另一个常见的操作系统镜像配置需求：SSH 守护进程的安全性。默认情况下，如我们之前创建的 CentOS 7 安装，允许使用 root 账户进行远程登录。出于安全原因，这并不可取。那么问题是，我们如何在不替换整个文件的情况下更新
    SSH 守护进程配置呢？幸运的是，Ansible 就有用于这种任务的模块。
- en: 'To perform this task, the `lineinfile` module will come in handy. Consider
    the following role, which we''ll call `securesshd`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此任务，`lineinfile`模块将派上用场。考虑以下角色，我们称之为`securesshd`：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we are using the `lineinfile` module to process the `/etc/ssh/sshd_config` file.
    We are telling it to look for lines beginning with `PermitRootLogin` (this prevents
    us from accidentally editing commented-out lines), and then to replace this line
    with `PermitRootLogin no`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`lineinfile`模块处理`/etc/ssh/sshd_config`文件。我们指示它查找以`PermitRootLogin`开头的行（这可以防止我们不小心编辑被注释掉的行），然后将该行替换为`PermitRootLogin
    no`。
- en: 'Let''s try that against a CentOS 7 test system:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个 CentOS 7 测试系统上尝试一下：
- en: '![](img/af064e87-0bc9-496d-847b-5ab293aaf16b.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af064e87-0bc9-496d-847b-5ab293aaf16b.png)'
- en: This works just as desired. Regular expressions require a great deal of care
    though. For example, the SSH daemon will process configuration lines that contain
    whitespace at the beginning of the line. However, our simple regular expression
    in the preceding code does not take account of whitespace, and so could easily
    miss an otherwise valid SSH configuration directive. To craft regular expressions
    that take account of all possible situations and permutations of a file is an
    art in itself and so caution is most definitely advised in their creation and
    use.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这正如预期的那样工作。然而，正则表达式需要非常小心。例如，SSH 守护进程会处理包含行首空格的配置行。然而，我们在前面代码中的简单正则表达式没有考虑空格，因此可能会错过其他有效的
    SSH 配置指令。制定能够考虑所有可能情况和文件排列的正则表达式本身就是一门艺术，因此在创建和使用时必须非常小心。
- en: Note that, on a live system, you would also need to restart the SSH service
    to make this change effective; however, as this is an image that we will clean
    up and then shut down for future deployment, there is no need to do this here.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在实际系统中，你还需要重启 SSH 服务才能使更改生效；但是，由于这是一个我们将清理并关闭以进行未来部署的镜像，所以在这里不需要这样做。
- en: A halfway house between uploading an entire file and editing an existing one
    is the use of templates. Ansible Jinja2 templating is incredibly powerful and
    very useful where files might have to have contents that vary with some variable
    parameter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上传整个文件和编辑现有文件之间的一个中间方法是使用模板。Ansible Jinja2 模板非常强大，对于需要根据某些变量参数来变化内容的文件非常有用。
- en: Consider again our `chrony` configuration example from earlier—here, we transferred
    a static file with a hardcoded NTP server address. This is fine if your enterprise
    relies on a static NTP server (or a set of them), but some will rely on different
    NTP servers depending on where the image is to be deployed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑我们之前提到的`chrony`配置示例——在这里，我们传输了一个包含硬编码 NTP 服务器地址的静态文件。如果你的企业依赖于一个静态 NTP 服务器（或一组服务器），这是可以的，但有些企业则可能会根据镜像要部署的位置而依赖不同的
    NTP 服务器。
- en: 'Let''s demonstrate this with a new role called `templatentp`. For this, we
    will define a templates directory in `roles/templatentp/templates` and place into
    it a file called `chrony.conf.j2` with the following contents:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个名为`templatentp`的新角色来演示这一点。为此，我们将在`roles/templatentp/templates`中定义一个模板目录，并将一个名为`chrony.conf.j2`的文件放入其中，内容如下：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that the file is almost identical to the previous example, except that
    we now have an Ansible variable name in place of the static hostname on the first
    line of the file.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个文件与前面的例子几乎完全相同，唯一的不同是我们在文件的第一行用一个 Ansible 变量名替代了静态的主机名。
- en: 'Let''s create the `main.yml` file for the role as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个角色创建`main.yml`文件，如下所示：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice how similar it is to the `copy` example. Our `site.yml` is also only
    slightly different—in it, we will define the variable with the NTP server hostname.
    There are many places in Ansible where this variable could be defined, and it
    is left to the user to figure out the best place for them to define it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意它与`copy`例子有多么相似。我们的`site.yml`文件也只有一点点不同——在其中，我们将定义带有 NTP 服务器主机名的变量。Ansible
    中有很多地方可以定义这个变量，用户需要自己决定最适合的定义位置：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we can run the playbook and see the results:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以运行剧本并查看结果：
- en: '![](img/7de0ec1f-25fc-4092-b80c-ebeb2e8d8f65.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7de0ec1f-25fc-4092-b80c-ebeb2e8d8f65.png)'
- en: In this way, Ansible provides you with powerful tools to not only copy or download
    entire configurations into place, but also to manipulate existing ones to suit
    your environment. Let's suppose that our image is now complete. We could take
    this on faith, but good practice suggests we should always test the result of
    any build process, especially an automated one. Thankfully, Ansible can help us
    to validate the image we have created according to our requirements, and we will
    explore this in the next section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，Ansible 提供了强大的工具，不仅可以将整个配置复制或下载到目标环境中，还可以操作现有配置以适应你的环境。假设我们的镜像现在已经完成。我们可以凭信心认为它是好的，但良好的实践建议我们应始终测试任何构建过程的结果，尤其是自动化构建。幸运的是，Ansible
    可以帮助我们根据要求验证我们创建的镜像，我们将在下一节中探讨这一点。
- en: Validating the image build
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证镜像构建
- en: As well as installing and configuring your image, you might also wish to verify
    that certain components that are critical, and that you assume to be present,
    are actually present. This is especially true when you download an image that
    was created by someone else.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安装和配置你的镜像外，你可能还希望验证某些关键组件是否存在，并假设它们是存在的。特别是当你下载一个由别人创建的镜像时，这一点尤为重要。
- en: There are many ways to perform this task in Ansible—let's take a simple example.
    Suppose you have an archival script that makes use of the `bzip2` compression
    utility to compress files. This is just a small tool but if you rely on it for
    certain purposes, your scripts would break if it was not present. It is also a
    pertinent example, as the minimal install of CentOS 7 (as we performed earlier)
    does not actually include it!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ansible 中执行此任务有多种方法——让我们以一个简单的例子为例。假设你有一个归档脚本，它使用了`bzip2`压缩工具来压缩文件。这个工具本身很小，但如果你依赖它完成某些任务，在没有它的情况下，脚本就会崩溃。它也是一个恰当的例子，因为我们之前执行的
    CentOS 7 最小安装实际上并没有包含它！
- en: How can Ansible solve this problem? There are two approaches we can take. First
    of all, we know from our earlier background work on Ansible that most modules
    are idempotent—that is, they are designed to achieve a desired state on the target
    host and not repeat actions that have already been performed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 如何解决这个问题？我们可以采取两种方法。首先，根据我们之前对 Ansible 的了解，大多数模块是幂等的——也就是说，它们旨在使目标主机达到期望的状态，并且不会重复已执行的操作。
- en: 'Hence, we could have very easily included a role such as this in our configuration
    playbook:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以非常容易地在我们的配置剧本中包含这样一个角色：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When this role is run and `bzip2` is not installed, it will perform the installation
    and return the result `changed`. When it detects that `bzip2` is installed, it
    will return `ok` and perform no further actions. However, what if we truly want
    to check for something rather than just perform an action, perhaps as a post-build
    step? Later in this book, we'll look at more detailed ways of auditing systems,
    but for now, let's further this example with Ansible.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行这个角色时，如果`bzip2`没有安装，它将执行安装并返回结果`changed`。当它检测到`bzip2`已安装时，它将返回`ok`并且不执行任何进一步操作。但是，如果我们确实想检查某些东西，而不仅仅是执行某个动作，可能作为构建后的步骤呢？在本书后面，我们将探讨更详细的系统审计方法，但现在，我们先通过
    Ansible 进一步了解这个例子。
- en: If you were using shell commands, you would check for the presence of `bzip2` in
    one of two ways, that is, query the RPM database to see whether the `bzip2` package
    is installed or check for the presence of `/bin/bzip2` on the filesystem.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 shell 命令，你会通过两种方式之一来检查是否存在`bzip2`，即查询 RPM 数据库以查看`bzip2`包是否已安装，或者检查文件系统中是否存在`/bin/bzip2`。
- en: 'Let''s look at the latter example in Ansible. The Ansible `stat` module can
    be used to verify the existence of a file. Consider the following code, which
    we''ll create in a role called `checkbzip2` in the usual manner:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看一下 Ansible 中的后者示例。Ansible的`stat`模块可以用来验证文件是否存在。请看以下代码，我们将在通常的方式下创建一个名为`checkbzip2`的角色：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we are using the `stat` module to tell us about the `/bin/bzip2` file (if
    it exists). We `register` the result of the module run in a variable called `bzip2result`,
    and then we define a custom failure condition on the task that will cause it to fail
    (and hence fail the entire the playbook run) if the file does not exist. Note
    that when a failure condition is encountered, Ansible halts the entire playbook
    run, forcing you to address the issue before continuing. Obviously, this may or
    may not be the behavior you desire, but it is easy to vary the failure condition
    accordingly.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`stat`模块来检查`/bin/bzip2`文件是否存在。我们将模块执行的结果注册到名为`bzip2result`的变量中，然后我们为任务定义一个自定义的失败条件，若文件不存在，则导致任务失败（进而使整个
    playbook 执行失败）。请注意，当遇到失败条件时，Ansible 会暂停整个 playbook 的执行，迫使你在继续之前解决问题。显然，这可能不是你希望的行为，但你可以轻松根据需要调整失败条件。
- en: 'Let''s take a look at this in action:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看实际操作中的效果：
- en: '![](img/3d627adc-f501-46ab-a37b-6474a298e5a7.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d627adc-f501-46ab-a37b-6474a298e5a7.png)'
- en: As you can see, the debug statement was never run because of the failure encountered.
    Hence, we can be absolutely sure when running this role that our image is going
    to have `bzip2` installed—if it doesn't, our playbook will fail.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调试语句未被执行，因为遇到了错误。因此，我们可以完全确信，当运行此角色时，我们的镜像中将会安装`bzip2`——如果没有安装，playbook将会失败。
- en: 'Once `bzip2` is installed, the run looks quite different:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`bzip2`安装完成，运行结果会变得大不相同：
- en: '![](img/85c4f010-3e8f-4b78-9f21-b39d247d77f2.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85c4f010-3e8f-4b78-9f21-b39d247d77f2.png)'
- en: 'This is quite definitive in its behavior, which is exactly what we would want.
    Ansible is not just limited to checking for files though—we could also check that
    our `sshd_config` file has the `PermitRootLogin no` line we looked at earlier:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是非常明确的，正是我们所希望的。然而，Ansible 并不仅限于检查文件——我们还可以检查我们的`sshd_config`文件中是否有之前提到的`PermitRootLogin
    no`行：
- en: 'We could do this with a role as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过角色来实现这一点，代码如下：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, running this when the setting is not in place again yields a failure:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当设置未生效时，再次运行会导致失败：
- en: '![](img/05d02a35-5796-4186-9d62-3dbdcce8cb43.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05d02a35-5796-4186-9d62-3dbdcce8cb43.png)'
- en: 'Yet if we put this setting in place, we see the following:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果我们设置了这个条件，我们会看到以下结果：
- en: '![](img/a643a45e-26cb-4d34-8b7c-a0ea4317a81b.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a643a45e-26cb-4d34-8b7c-a0ea4317a81b.png)'
- en: Again, it's very definitive. Note the `changed` status in the preceding output—this
    is so because we used the `command` module, which successfully ran `command`—hence,
    it always returns `changed`. We could alter this behavior with a `changed_when` clause
    to this task if we wanted.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，它的行为非常明确。请注意前面输出中的`changed`状态——这是因为我们使用了`command`模块，它成功执行了`command`——因此，它总是返回`changed`。如果需要，我们可以通过在此任务中添加`changed_when`条件来改变这一行为。
- en: In this manner, Ansible playbooks can be put together that not only customize
    your build but also validate the end result. This is especially useful for testing
    purposes, and where security is a consideration.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，可以编写 Ansible playbook，不仅可以自定义构建过程，还可以验证最终结果。这在测试过程中尤其有用，尤其是在需要考虑安全性的场景中。
- en: Before completing this chapter, let's take a look, in the next section, at how
    we pull together all of the disparate roles and pieces of code we have discussed
    so far to form a cohesive automated solution.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章之前，让我们在接下来的章节中看看，我们如何将迄今为止讨论的所有角色和代码片段组合起来，形成一个连贯的自动化解决方案。
- en: Putting it all together
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合起来
- en: 'Throughout this section of this chapter, you will note that we have used roles
    for all of our examples. Naturally, when it comes to building out your final image,
    you don''t want to end up running lots of playbooks individually as we have done
    here. Luckily, if we were to combine everything, all we would need to do is put
    all of the roles together in the `roles/` subdirectory, and then reference them
    all in the `site.yml` playbook. The `roles` directory should look something like
    this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分中，你会注意到我们在所有示例中都使用了角色（roles）。自然地，当你最终构建你的镜像时，你不希望像我们在这里所做的那样单独运行多个playbook。幸运的是，如果我们将所有内容合并起来，我们所需要做的就是将所有的角色放在`roles/`子目录中，然后在`site.yml`
    playbook中引用它们。`roles`目录应该类似于以下内容：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, our `site.yml` file will look like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的`site.yml`文件应该是这样的：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Running this code is left as an exercise for the reader, as we have already
    run all of the component parts earlier in this chapter. However, if all goes well
    then, when all roles have completed, there should be no `failed` statuses—just
    a mixture of `changed` and `ok`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码的部分留给读者自行完成，因为我们已经在本章的早些部分运行了所有组件。然而，如果一切顺利，那么当所有角色执行完毕后，应该没有`failed`状态——只有`changed`和`ok`的混合状态。
- en: If you have run through the process of post-build customization, as detailed
    in this chapter, the resulting image will likely need cleaning up a second time.
    We could resort to the `virt-sysprep` command again, however, Ansible can help
    us here too. In the next section, we will explore the use of Ansible for cleaning
    up images for large scale deployment.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经按照本章的详细说明完成了后期构建自定义，那么生成的镜像可能需要第二次清理。我们可以再次使用`virt-sysprep`命令，但Ansible也可以在这里帮助我们。在下一节中，我们将探讨如何使用Ansible来清理镜像以便进行大规模部署。
- en: Cleaning up the build with Ansible
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible清理构建过程
- en: By now, you should have a pretty good idea of how to build or validate a base
    image, and then customize it with Ansible. Before we close this chapter, it is
    worth revisiting the task of cleaning up your image for deployment. Whether you
    have built an image from scratch or downloaded a ready-made one, if you have booted
    it up and run commands on it, either manually or using Ansible, you are likely
    to have a whole load of items that you really don't want present every time you
    deploy the image. For example, do you really want all of the system log files
    from every configuration task you performed and the initial boot to be present
    on every single virtual machine deployed? If you had to run any commands by hand
    (even if it was to set up authentication to allow Ansible to run), do you want
    those commands in the `.bash_history` file of the account you ran them in on every
    deployment?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对如何构建或验证基础镜像，并使用Ansible进行自定义有了相当清晰的理解。在我们结束本章之前，值得回顾一下清理镜像以便部署的任务。无论你是从头构建镜像还是下载了现成的镜像，如果你已经启动并在其上运行了命令，无论是手动还是使用Ansible，你可能会有很多你不希望在每次部署镜像时都出现的东西。例如，你真的希望每次部署的虚拟机上都有你执行的每个配置任务和初始启动的系统日志文件吗？如果你必须手动运行任何命令（即使是为了设置身份验证以允许Ansible运行），你是否希望这些命令出现在你运行它们的账户的`.bash_history`文件中，并在每次部署时都被记录？
- en: The answer to these is, of course, no. Then there are those files that could
    actually cause problems if cloned—for example, duplicate SSH host keys or MAC
    address-specific configurations such as `udev` configuration data. All of this
    should be cleaned out before you consider the image ready for distribution.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案，当然是“否”。然后还有一些文件，如果被克隆可能会引起问题——例如，重复的SSH主机密钥或MAC地址特定的配置，如`udev`配置数据。在你认为镜像准备好分发之前，所有这些内容应该清理干净。
- en: Ansible can help with this task too, although it is recommended that you use
    the `virt-sysprep` tool that we demonstrated earlier in this chapter, as this
    takes care of all of these steps for you. There might be a reason why you don't
    want to use this tool—perhaps you don't have access to it in your environment,
    or there isn't a build for your preferred distribution of Linux. In this instance,
    you can use Ansible to perform the final cleanup. The great thing about Ansible
    is that you can use the built-in modules, as we have demonstrated so far in this
    chapter, but you can equally use raw shell commands—this can be especially useful
    when you need to perform wildcard operations across a filesystem.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 也可以帮助完成此任务，尽管我们建议使用本章前面展示的`virt-sysprep`工具，因为它可以为您处理所有这些步骤。您可能有不想使用此工具的原因——例如，您的环境中没有访问权限，或者您的
    Linux 发行版没有此工具的版本。在这种情况下，您可以使用 Ansible 执行最终的清理。Ansible 的优点是，您可以使用本章中展示的内置模块，但同样也可以使用原始的
    shell 命令——这在需要跨文件系统执行通配符操作时尤其有用。
- en: 'The following is an example of a role that relies on raw shell commands to
    clean up an image in preparation for deployment. It is not as complete as the
    job performed by `virt-sysprep`, but does serve as a good example of how this
    could be performed using Ansible. Note that this example is specific to CentOS
    7—if using a different operating system, then it will be necessary to change paths,
    package database cleanup commands, and so on. Hence, this playbook is presented
    to the reader very much as a practical example of how the cleanup could be performed
    in Ansible, though it is intended that the reader takes this further depending
    on their own requirements. First of all, we clean out the package database, as
    this data need not be replicated across deployments:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个角色的示例，该角色依赖原始的 shell 命令来清理镜像，为部署做准备。它没有`virt-sysprep`所执行的任务那么完整，但作为如何使用
    Ansible 执行此操作的良好示例。请注意，此示例特定于 CentOS 7——如果使用不同的操作系统，则需要更改路径、软件包数据库清理命令等。因此，本剧本提供给读者的更多是一个实用示例，展示了如何在
    Ansible 中执行清理操作，但读者可以根据自己的需求进一步完善。首先，我们清理软件包数据库，因为这些数据不需要在各个部署之间复制：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We then continue by clearing out the logs—this is achieved by stopping the
    logging daemon, forcing a rotation of the logs, and then recursively deleting
    the directory containing them:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们继续清理日志——通过停止日志守护进程，强制日志轮换，然后递归删除包含日志的目录来实现：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We then clear our hardware and MAC address-specific configurations that would
    be invalid on a deployed VM image:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们清理硬件和 MAC 地址特定的配置，这些配置在部署后的虚拟机镜像中无效：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Following this, we clear out `/tmp` and remove any history files from user
    home directories. The following example is not complete, but does show some pertinent
    examples:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们清理`/tmp`目录，并移除用户主目录中的历史文件。以下示例不完整，但展示了一些相关的例子：
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we perform our final task—in this case, the removal of the SSH host
    keys. Note that following this, we also shut down the VM—this is performed as
    part of this command to prevent accidental creation of any additional history
    or logging data. Note also the `ignore_errors` clause, which prevents the playbook
    from failing when the shutdown occurs and the SSH connection is terminated:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们执行最终任务——在这种情况下，删除 SSH 主机密钥。请注意，在此之后，我们还关闭虚拟机——这是作为此命令的一部分执行的，以防止意外创建任何额外的历史或日志数据。还要注意`ignore_errors`子句，它可以防止在关闭虚拟机并断开
    SSH 连接时剧本失败：
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Running this code on a CentOS 7 VM will result is a fairly well-cleaned image,
    but there are specifics not covered here. For example, we have cleared out all
    bash history, but if any alternate shells were used, their data would not be cleaned.
    Similarly, we have cleaned out VIM application data from root's home directory,
    but not any other applications that may or may not have been used during the image
    creation. Hence, it is up to you to extend this role as you require in your environment.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 7 虚拟机上运行此代码将生成一个相对干净的镜像，但这里没有涉及一些细节。例如，我们已经清理了所有 bash 历史记录，但如果使用了其他
    shell，其数据将不会被清理。类似地，我们清理了 root 用户主目录中的 VIM 应用数据，但没有清理可能在镜像创建过程中使用过的其他应用数据。因此，您需要根据您的环境需求扩展此角色。
- en: By this stage, you will have run through the entire process, end-to-end, of
    creating, customizing, and cleaning up a Linux operating system for our proposed
    SOE. Effective use of Ansible means that the entire process can be automated,
    and hence enables us to make a strong start toward automation in the enterprise.
    All that remains is to deploy the template we have created into your environment,
    and from here, you can clone it and build on it to your heart's content.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段，你已经完整地了解了创建、定制和清理 Linux 操作系统的整个过程，用于我们的 SOE 提议。有效使用 Ansible 意味着整个过程可以自动化，因此使我们能够在企业中迈出自动化的坚实步伐。接下来，只需将我们创建的模板部署到你的环境中，从这里开始，你可以根据需要克隆并进一步构建它。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have seen several hands-on examples of how to obtain or build Linux virtual
    machine images for use in a wide variety of scenarios and environments. We have
    seen how Ansible lends itself to automating this process, and hence how it complements
    the image build process to support the good practices we have previously discussed
    for automation in the enterprise and, in particular, the creation and management
    of an SOE.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到几个实际示例，展示了如何获取或构建 Linux 虚拟机镜像，以便在各种场景和环境中使用。我们还看到 Ansible 如何帮助自动化这一过程，进而如何与镜像构建过程相结合，支持我们之前讨论过的企业自动化最佳实践，特别是
    SOE（标准化操作环境）的创建与管理。
- en: In this chapter, you learned how to build Linux images for templating purposes
    and indeed obtain and verify ready-made ones. You then learned through practical
    examples how to customize these template images with Ansible, covering key concepts
    such as package installation and configuration file management. Finally, you learned
    how to ensure that image builds are clean and tidy and do not contain data that
    would either be wasteful or harmful to replicate across and infrastructure.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何构建用于模板的 Linux 镜像，并且了解了如何获取并验证现成的镜像。接着，你通过实际示例学习了如何使用 Ansible 自定义这些模板镜像，涉及的关键概念包括软件包安装和配置文件管理。最后，你学习了如何确保镜像构建干净整洁，不包含任何会浪费或有害的重复数据。
- en: In the next chapter of this book, we will look at how to create standardized
    images for use on bare metal servers and in some traditional virtualization environments.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章，我们将探讨如何为裸金属服务器和某些传统虚拟化环境创建标准化镜像。
- en: Questions
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the purpose of system preparation (sysprep)?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统准备（sysprep）的目的是什么？
- en: When would you need to make use of Ansible facts in your roles?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你什么时候需要在角色中使用 Ansible facts？
- en: How would you deploy a new configuration file to a virtual machine image using
    Ansible?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何通过 Ansible 将新配置文件部署到虚拟机镜像中？
- en: Which Ansible module is used to download a file from the internet directly into
    a virtual machine image?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用哪个 Ansible 模块可以将文件直接从互联网下载到虚拟机镜像中？
- en: How would you write a single Ansible role that will install packages on both
    Ubuntu and CentOS?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何编写一个 Ansible 角色，能够在 Ubuntu 和 CentOS 上安装软件包？
- en: Why would you wish to validate an ISO image you have downloaded?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你需要验证已下载的 ISO 镜像？
- en: How does the use of Ansible roles at this stage benefit the environment once
    it is deployed?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一阶段使用 Ansible 角色会如何有利于环境的部署？
- en: Further reading
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: For an in-depth understanding of Ansible, please refer to *Mastering Ansible*,
    *Third Edition* by *James Freeman* and *Jesse Keating*, available at [https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如需深入了解 Ansible，请参考 *Mastering Ansible*，*第三版*，由 *James Freeman* 和 *Jesse Keating*
    编写，书籍可通过 [https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition)
    获取。
- en: For more details on the use of KVM for virtualization on Linux, please refer
    to *Mastering KVM Virtualization* by *Prasad Mukhedkar*, *Anil Vettathu*, *Humble
    Devassy Chirammal*, available at [https://www.packtpub.com/gb/networking-and-servers/mastering-kvm-virtualization](https://www.packtpub.com/gb/networking-and-servers/mastering-kvm-virtualization)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于在 Linux 上使用 KVM 进行虚拟化的更多细节，请参考 *Mastering KVM Virtualization*，由 *Prasad Mukhedkar*、*Anil
    Vettathu* 和 *Humble Devassy Chirammal* 编写，书籍可通过 [https://www.packtpub.com/gb/networking-and-servers/mastering-kvm-virtualization](https://www.packtpub.com/gb/networking-and-servers/mastering-kvm-virtualization)
    获取。
