- en: '*Chapter 9*: An Introduction to Shell Scripting'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*: Shell脚本简介'
- en: We have come to the part that defines one of the things that Unix (or Linux)
    is known for – its scripting. When it comes to the so-called *Unix philosophy*,
    being able not only to use tools that the command line offers to you but also
    being able to create your own is an amazing ability, using shell tools that do
    one thing really well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经来到了定义Unix（或Linux）知名特性之一的部分——它的脚本编写。当谈到所谓的*Unix哲学*时，不仅能使用命令行提供的工具，而且还能创建自己的工具，这是一个令人惊叹的能力，利用那些做一件事做得非常好的Shell工具。
- en: Scripting is exactly that – the ability to create simple (and complex) tools
    that, at their core, are a set of commands performing a certain task. We need
    to clear one thing up before everything else – there is a distinction that some
    people make between programming and scripting. Strictly speaking, all scripting
    is programming, but not all programming is scripting. We are talking about disciplines
    that follow the exact same premises, logic, and ways of thinking, but at the same
    time, there are major differences between the two. When we talk about scripting,
    we are in reality creating files that are going to get *interpreted* when running,
    and that means that the shell (or some other *interpreter*) is going to read the
    file line by line and then run the commands. There is another option, and that
    is to create text files that are *compiled* before being run. Usually, this is
    faster than interpreting them, but at the same time, it both requires a few extra
    steps and is not as flexible as scripting.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本编写正是如此——能够创建简单（或复杂）的工具，本质上是执行特定任务的一组命令。在一切开始之前，我们需要澄清一件事——有些人将编程与脚本区分开。严格来说，所有脚本编写都是编程，但并非所有编程都是脚本编写。我们谈论的是遵循相同前提、逻辑和思维方式的学科，但同时，两者之间也有着重大区别。说到脚本编写，实际上我们是在创建文件，这些文件在运行时会被*解释*，这意味着Shell（或其他*解释器*）会逐行读取文件并执行命令。还有另一种方式，那就是创建文本文件，在运行前进行*编译*。通常，这种方式比解释执行更快，但同时需要一些额外的步骤，并且不如脚本灵活。
- en: We are not going to waste our time on anything connected to compiled applications;
    in this book, we'll be strictly dealing with scripts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会浪费时间讨论与编译应用程序相关的内容；本书将严格处理脚本。
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下内容：
- en: Writing your first Bash shell script
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写你的第一个Bash Shell脚本
- en: Serializing basic commands – from simple to complex
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化基本命令 – 从简单到复杂
- en: Manipulating shell script input, output, and errors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作Shell脚本的输入、输出和错误
- en: Shell script hygiene
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell脚本的基本规范
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this recipe, we''re going to use a Linux machine. We are using the same
    setup as in other chapters:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的内容将在Linux机器上进行演示。我们使用与其他章节相同的设置：
- en: A virtual machine with Linux installed, any distribution (in our case, it's
    going to be *Ubuntu 20.04*)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了Linux的虚拟机，任意发行版（在我们的案例中，将使用*Ubuntu 20.04*）
- en: Bash – the default shell for every major distribution out there
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash – 每个主流发行版的默认Shell
- en: Scripts in this chapter, and in all the other chapters covering scripting, will
    probably run in any distribution using Bash. The power of scripting is exactly
    in this compatibility; if a machine runs Linux, it will run almost any script,
    and the only problems are going to come from what the script itself expects on
    the server.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章及所有涉及脚本的章节中的脚本，应该能在任何使用Bash的发行版上运行。脚本的强大之处就在于这种兼容性；如果机器运行Linux，几乎可以运行任何脚本，唯一的问题来自脚本本身对服务器的要求。
- en: Writing your first Bash shell script
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的第一个Bash Shell脚本
- en: Before we do a simple `Hello World!` shell script, let's quickly talk about
    the shell itself and what does it do on a normal Linux machine. The simplest way
    of describing it is that the shell is the connection between the user (us) and
    the kernel (the part of the operating system in charge of everything). We have
    already talked about that before, but we need to make some points here to make
    it easier to explain some concepts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写一个简单的`Hello World!` Shell脚本之前，先快速了解一下Shell本身以及它在普通Linux机器上的作用。最简单的描述方式是，Shell是用户（我们）与内核（操作系统中负责一切的部分）之间的连接。我们之前已经讨论过这个问题，但在这里我们需要澄清一些要点，以便更容易解释某些概念。
- en: 'The shell is an application that usually displays a prompt and finds and runs
    whatever command we give it. This is called the **interactive shell** and is the
    most-used way of working in Linux. This is what all the **Command-Line Interface**
    (**CLI**) business is about – having an interface that enables us to execute whatever
    we need:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 是一个应用程序，通常显示一个提示符，并查找并运行我们给它的任何命令。这称为**交互式 shell**，是在Linux中使用最广泛的工作方式。这就是所有**命令行界面**（**CLI**）的内容
    - 拥有一个界面，使我们能够执行我们需要的命令：
- en: '![Figure 9.1 – A typical root shell'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.1 – 一个典型的 root shell'
- en: '](img/Figure_9.1_B16269.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B16269.jpg)'
- en: Figure 9.1 – A typical root shell
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 一个典型的 root shell
- en: There is, however, another mode of operation for a shell called **non-interactive
    mode**. This covers all the instances of the shell when it is not acting based
    on our commands from the command line but instead by reading a file (our script)
    line by line and executing the commands. Obviously, we cannot interact with the
    commands directly, so the mode is aptly called non-interactive.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，shell 的另一种操作模式称为**非交互模式**。这涵盖了 shell 在不根据我们从命令行输入的命令行为基础，而是逐行读取文件（我们的脚本）并执行命令时的所有实例。显然，我们无法直接与命令进行交互，因此该模式恰当地称为非交互式。
- en: Bear in mind that we can interact with the script during execution if we wish
    (and plan) to; the name refers only to the lack of direct interaction with the
    shell or having no CLI available. At the same time, this interaction limit means
    that we get to see our script run as fast as possible, at any time that we need
    it. Pair that with a myriad of tools at our disposal in a normal Linux system,
    and we have an extremely powerful feature available to finish our tasks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在执行脚本时，如果需要（并且计划），我们可以与其交互；名称仅指与Shell的直接交互或无CLI可用。同时，这种交互限制意味着我们可以在任何需要的时候，尽快地看到我们的脚本运行。结合Linux系统中我们随时可以使用的各种工具，我们拥有一个极其强大的功能，可以帮助我们完成任务。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Let''s quickly run a few commands and find out about our current shell:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速运行几个命令，了解一下我们当前的 shell：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What happened here? The first command we used was `ps`, and it gave us information
    about which shell is currently running or, to be precise, which shell is responsible
    for the current execution of commands that we issue. Using `$$` as the process
    number, we are asking the `ps` command to give us the number of the process assigned
    to our current shell. We performed a small trick here – `$$` is a Bash internal
    variable that gives us the running PID of a process.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？我们使用的第一个命令是 `ps`，它为我们提供了当前正在运行的 shell 的信息，或者更精确地说，负责我们发出的命令当前执行的 shell。使用
    `$$` 作为进程号，我们要求 `ps` 命令提供我们当前 shell 分配的进程号。我们在这里进行了一个小技巧 - `$$` 是 Bash 的内部变量，它给我们提供了一个进程的运行
    PID。
- en: The other command that we used is `echo`, and we used its `$SHELL` variable
    that automatically resolves to whatever the user's current shell is.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的另一个命令是 `echo`，并使用了其 `$SHELL` 变量，该变量会自动解析为用户当前的 shell。
- en: However, there is a big difference between these two commands. Depending on
    the circumstances, they can give us completely different results, since they are
    referring to completely different things. Let's explain – each user has their
    *assigned* shell, which is going to be executed when the user logs in. The result
    of the `echo` command is going to give you that, and the shell itself is defined
    in the `/etc/passwd` file, in the line that describes a particular user. So basically,
    the output of the command is going to provide the name of your default shell.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这两个命令之间存在很大的区别。根据具体情况，它们可以给我们完全不同的结果，因为它们指的是完全不同的事物。让我们来解释一下 - 每个用户都有他们*分配的*
    shell，在用户登录时将被执行。`echo` 命令的结果将会给你这个信息，而 shell 本身则定义在 `/etc/passwd` 文件中，描述特定用户的那一行。因此，该命令的输出基本上会提供你的默认
    shell 名称。
- en: At the same time, every user can run any shell available on the system as a
    command, and automatically get this shell as their *current* shell. By that, we
    mean that this shell is going to process whatever the user is typing into the
    command line. This is important, since your script can be run from the command
    line using a different shell than the one you are supposed to be using, based
    on information in the `/etc/passwd` file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，每个用户可以作为命令运行系统上任何可用的 shell，并且自动将该 shell 作为他们的*当前* shell。这意味着这个 shell 将处理用户在命令行中输入的任何内容。这很重要，因为你的脚本可以使用与你应该使用的不同
    shell 来自命令行运行，基于 `/etc/passwd` 文件中的信息。
- en: Your shell doesn't have to be `bash`. You can also choose any shell that is
    available on your system, or you can even install shells that are not currently
    available on the system you are using but are available as packages.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 shell 不一定非得是 `bash`。你也可以选择系统中可用的任何 shell，或者甚至可以安装当前系统中不可用但作为软件包提供的 shell。
- en: With that in mind, when it comes to scripting, `bash` is the shell of choice,
    even for users running other shells, since `bash` will run on most, if not all,
    Linux machines.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有鉴于此，谈到脚本编写时，即便你使用的是其他 shell，`bash` 仍然是首选的 shell，因为 `bash` 能在大多数甚至所有 Linux 机器上运行。
- en: Now, let's talk a little bit about the editors used for scripting.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来聊一聊用于脚本编写的编辑器。
- en: For chapters dealing with scripting in this book, we are going to use `vim`
    or `vi`; however, the script examples are going to be displayed as text without
    any color. We already covered a lot of editors in a separate chapter. Since the
    topic of text editors tends to be pretty divisive, and we are a bit pragmatic
    on this, our suggestion is to use whatever works for you.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中涉及脚本编写的章节，我们将使用 `vim` 或 `vi`；然而，脚本示例将以文本形式显示，而不带有任何颜色。我们已经在另一个章节中讲解了很多编辑器。由于文本编辑器的话题往往引发较大争议，而我们对此较为务实，我们的建议是使用对你有用的编辑器。
- en: Vim, JOE, nano, vi, Emacs, gedit, Sublime Text, Atom, Notepadqq, Visual Studio
    Code, and so on are what's available, but it's up to you to choose. For simple
    scripts, any editor will work, and more often than not, you will choose something
    that already exists on the system you are working on, just because you need to
    make a small change in a script.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Vim、JOE、nano、vi、Emacs、gedit、Sublime Text、Atom、Notepadqq、Visual Studio Code 等都是可用的编辑器，但选择哪个完全取决于你。对于简单的脚本，任何编辑器都能工作，通常你会选择系统上已有的编辑器，只因为你需要对脚本做一个小改动。
- en: 'When developing scripts on your own machine, you are probably going to go with
    something more complicated, simply because it makes working much easier. Vim is
    a good example, since it provides syntax highlighting and formatting for `bash`.
    Advanced editors are going to provide you with more functions, but our opinion
    is that you shouldn''t rely on too many bells and whistles, since this will make
    you dependent on a certain application that may or may not be available to you
    at all times:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在自己的机器上开发脚本时，可能会选择更复杂的工具，因为它能让工作变得更轻松。Vim 就是一个很好的例子，因为它为 `bash` 提供了语法高亮和格式化功能。高级编辑器会为你提供更多功能，但我们的观点是你不应该过度依赖那些花里胡哨的功能，因为这会让你依赖某个应用，而这个应用可能并不总是能使用：
- en: '![Figure 9.2 – A script opened in Vim – note the color highlights and indentation'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.2 – 在 Vim 中打开的脚本 – 注意颜色高亮和缩进'
- en: '](img/Figure_9.2_B16269.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.2_B16269.jpg)'
- en: Figure 9.2 – A script opened in Vim – note the color highlights and indentation
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 在 Vim 中打开的脚本 – 注意颜色高亮和缩进
- en: In the end, you will end up using two editors, one for developing your scripts
    and one on servers you are deploying your scripts to. Remember that you will inevitably
    have to do some debugging on the systems you are deploying your scripts to, so
    be prepared that some of your normal tools will be missing. Don't become dependent
    on them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你将会使用两个编辑器，一个用于开发你的脚本，另一个用于你部署脚本的服务器。记住，你在部署脚本的系统上不可避免地需要进行调试，因此要做好准备，某些你平常使用的工具可能无法使用。不要过于依赖它们。
- en: How to do it…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Let''s create our first script and see what it is about the shell that we are
    so concerned with:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建第一个脚本，看看到底是什么让我们如此关注 shell：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, what does the script actually do? It simply writes `Hello World!` to
    the standard output and exits. Although we have three lines in the script itself,
    only one of them does something, while the other two have different purposes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，脚本到底做了什么？它仅仅是将 `Hello World!` 输出到标准输出并退出。虽然脚本本身有三行，但其中只有一行是实际执行操作的，另外两行则有不同的用途。
- en: What we are going to do is first unpack the meaning behind the first two lines
    and then pay attention to the `echo` command.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是首先解析前两行的含义，然后关注 `echo` 命令。
- en: Note that we are not counting empty lines in the script, although your editor
    might. In scripting, empty lines are meaningless to the interpreter, so we are
    using them to make the script more human-readable and ignoring them when talking
    about the script – Bash does the same thing when executing the script.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在脚本中不计算空行，尽管编辑器可能会计算。对于脚本，空行对解释器来说没有意义，因此我们使用空行使脚本更具可读性，但在讨论脚本时会忽略它们——Bash
    在执行脚本时也是这样做的。
- en: As a rule, if we use the `#` character anywhere in the script, an interpreter
    is going to treat everything that comes after that character *in the same* line
    as a comment. Our first two lines are comments, but the first line in the script
    is special – it defines the shell that is going to run commands in the scripts
    while also being a comment. This sequence is called a *shebang*. We need to explain
    that.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个规则，如果我们在脚本中使用`#`字符，解释器将把该字符之后的内容视为注释（*在同一行*）。我们的前两行是注释，但脚本的第一行是特殊的——它定义了执行脚本命令的
    shell，同时也是一行注释。这个序列被称为*shebang*。我们需要对此进行解释。
- en: Under Linux, scripting is not confined to using `bash` only or even using any
    other Bash-compatible shell. In your script, you can actually use whatever scripting
    language you want. Other than being Bash, it can be Python or Perl – you can use
    whatever language is available on the system and that you know how to write scripts
    in.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 下，脚本编写并不局限于使用`bash`或任何其他 Bash 兼容的 shell。在你的脚本中，实际上可以使用任何你想要的脚本语言。除了
    Bash，它还可以是 Python 或 Perl——你可以使用系统上可用的任何语言，只要你知道如何编写该语言的脚本。
- en: Normally a script is run by an interpreter. The interpreter is basically an
    application that is able to understand what's inside the file and then is able
    to run the commands that are inside the file, one by one. All the interpreters
    that we mentioned (Python, Bash, and Perl) use simple plaintext files as inputs,
    so there needs to be a way of telling what kind of script is in a particular file
    to let the system know how to run it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，脚本是由解释器执行的。解释器基本上是一个能够理解文件内容的应用程序，然后逐行执行文件中的命令。我们提到的所有解释器（Python、Bash 和 Perl）都使用简单的文本文件作为输入，因此需要一种方法来告诉系统该文件中是什么类型的脚本，从而让系统知道如何执行它。
- en: 'This can be done in two different ways – one way is to actually call the script
    directly using the right interpreter, such as the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过两种不同的方式来实现——一种方式是通过使用正确的解释器直接调用脚本，例如以下方式：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This simply makes sure we are using the right interpreter for the script; it
    doesn't make our script any more readable to the system or another user.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是确保我们为脚本使用了正确的解释器；它不会让系统或其他用户更容易理解我们的脚本。
- en: 'Now, consider another way of doing this. Let''s make the script executable,
    and then run it directly:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑另一种做法。让我们使脚本可执行，然后直接运行它：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The difference between these two is subtle but important, although the end result
    is going to be the same, since we are running the same script.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者之间的区别微妙但重要，尽管最终结果是相同的，因为我们运行的是相同的脚本。
- en: In the first example, we are explicitly telling the system to use a particular
    interpreter and run our script. In the second example, we are telling the system
    to run the script using whatever interpreter it needs, and this is when the first
    line of the script plays its crucial role. What the current shell is going to
    do is take the first line (the shebang) and try and find the interpreter that
    this line points to. If it finds it, the system is going to use this interpreter
    to run whatever is in the rest of the file. The end result is simple – if we follow
    the convention and put our interpreter as the first-line comment, the system is
    going to be able to run our script even if we don't mention it explicitly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们明确告诉系统使用特定的解释器来运行脚本。在第二个示例中，我们告诉系统使用它需要的解释器来运行脚本，这时脚本的第一行发挥了至关重要的作用。当前的
    shell 会拿到第一行（shebang），并尝试找到该行指向的解释器。如果找到了，系统将使用这个解释器来运行文件中的其余内容。最终结果很简单——如果我们遵循约定并将解释器放在第一行的注释中，系统就能运行我们的脚本，即使我们没有明确提到它。
- en: If the first line is something other than the name of the interpreter, our script
    will work only if we call it by explicitly using the name of the interpreter –
    if we try to run it directly, the system is going to throw an error.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一行是解释器的名称以外的内容，我们的脚本只有在明确使用解释器名称调用时才能运行——如果我们直接运行它，系统将抛出错误。
- en: How it works…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Linux does not use extensions as a way of identifying files, so a script can
    have any name that is possible on the filesystem; the extension does not have
    to be `.sh`. All this means is that in order to have our script work universally,
    we need to think about the right formatting for the first line.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 不使用扩展名来标识文件，因此脚本可以有任何符合文件系统规定的名称；扩展名不一定是`.sh`。这意味着，为了让我们的脚本能够普遍运行，我们需要考虑第一行的正确格式。
- en: The next line in the script is our comment, which identifies the name of the
    script and the version. Of course, any script will function without comments such
    as these or, in general, without any comments at all, but comments are extremely
    important in scripting. We will pay much more attention to the comments later
    in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的下一行是我们的注释，它标识了脚本的名称和版本。当然，任何脚本都可以没有这样的注释，或者一般来说，没有任何注释，但在脚本编写中，注释非常重要。我们稍后在本章中会更加关注注释。
- en: The third line is the one actually doing the work, and it simply displays the
    string to the standard output that is assigned to the script. Standard input,
    output, and error handling are things that we will also deal with a little bit
    later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行实际上是在工作的那一行，它简单地将分配给脚本的字符串显示到标准输出。标准输入、输出和错误处理是我们稍后也会稍微涉及的内容。
- en: This is our first script. We explained a lot in this part of the chapter, and
    we focused on everything other than the actual command that performs the script
    task, but we had to deal with a lot of other things.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个脚本。在这一章的这部分中，我们解释了很多内容，重点是除了执行脚本任务的实际命令之外的一切，但我们必须处理很多其他事情。
- en: There's more…
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'We are going to be dealing with scripts a lot more in this chapter and the
    next few, but we have links to get you started:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将会大量处理脚本，但我们有链接可以让您开始：
- en: 'The Bash manual – containing everything about the Bash shell: [https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash 手册 - 包含有关 Bash Shell 的所有信息：[https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html)
- en: 'Bash scripting cheat sheets: [https://devhints.io/bash](https://devhints.io/bash)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash 脚本速查表：[https://devhints.io/bash](https://devhints.io/bash)
- en: 'How to get a shell script to actually work: [https://linuxcommand.org/lc3_wss0010.php](https://linuxcommand.org/lc3_wss0010.php)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使一个 shell 脚本真正起作用：[https://linuxcommand.org/lc3_wss0010.php](https://linuxcommand.org/lc3_wss0010.php)
- en: Serializing basic commands – from simple to complex
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化基本命令 - 从简单到复杂
- en: Scripts are nothing more than a list of commands that are executed in a particular
    order. In its most basic structure, the order is completely linear without any
    decision making, loops, or conditional branching.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本只不过是按特定顺序执行的命令列表。在其最基本的结构中，顺序完全是线性的，没有任何决策、循环或条件分支。
- en: Commands are executed from first to last, from top to bottom, and from the start
    of the line to its end. Even if it sounds simple and not very useful, this way
    of creating scripts can have its uses, since it enables us to quickly run a predefined
    set of commands instead of repeating them from the command line. In other words,
    there are problems that require more than a single one-line command but are not
    complicated enough to require complex logic. This is not to devalue complex Bash
    scripting logic, as there's a lot of automation in IT that can be implemented
    by using Bash scripting.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 命令按照从上到下，从行首到行尾的顺序执行。即使听起来很简单并且不是很有用，但通过这种方式创建脚本也可以有其用处，因为它使我们能够快速运行一组预定义的命令，而不是从命令行重复输入它们。换句话说，有些问题需要超过一行命令，但不复杂到需要复杂的逻辑。这并不是贬低复杂的
    Bash 脚本逻辑，因为 IT 中有许多自动化任务可以通过使用 Bash 脚本来实现。
- en: 'Let''s now imagine a simple task like that, something that we will be using
    as a recurring example. We are going to create a simple backup script. Our task
    is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在想象一个简单的任务，比如我们将用作经常性示例的任务。我们将创建一个简单的备份脚本。我们的任务如下：
- en: Create a directory under `/opt/backup` that has today's date in its name.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/opt/backup`下创建一个以今天日期命名的目录。
- en: Copy all the files from the `/root` folder to this directory.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有文件从`/root`文件夹复制到此目录。
- en: Send an empty email to the `root` user that will simply say that a backup was
    done.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`root`用户发送一封空邮件，只说备份已完成。
- en: Add a line to a file named `donebackups.lst` in the `/root` folder that will
    have today's date in it.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`/root`文件夹中名为`donebackups.lst`的文件添加一行，其中包含今天的日期。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before we start – a disclaimer. This is a simple script that does not make too
    much sense for a number of reasons. The most important is that it is oblivious
    to the context it is running in. We quickly need to talk about this and the other
    problems first, and then we'll compose a script that solves this task.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前——免责声明。这是一个简单的脚本，由于多种原因，它的意义并不大。最重要的一点是，它忽略了运行环境的上下文。我们需要先快速讨论这些问题，然后我们会编写一个能解决这个任务的脚本。
- en: What do we mean by *context*? No matter which way we choose to run them, scripts
    are run by a user, in so-called user space, and they have some things that define
    their environment that we usually call context.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的*上下文*是什么意思？无论我们选择以何种方式运行脚本，脚本都是由用户在所谓的用户空间中运行的，它们有一些定义其环境的因素，我们通常称之为上下文。
- en: 'Context is the entire environment that is running the script and offers the
    following questions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文是运行脚本的整个环境，并且提出了以下问题：
- en: Which user is running the script?
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个用户在运行脚本？
- en: What permissions does this script have?
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个脚本有什么权限？
- en: Is the script run from the command line as a tool or as a background task?
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本是作为工具从命令行运行，还是作为后台任务运行？
- en: What directory is the script running from?
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本是从哪个目录运行的？
- en: Other than these, there are usually several other things that can be relevant
    for the running script, and we will talk about those as we progress through this
    book.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，通常还有一些其他可能对运行脚本相关的因素，我们将在本书的后续部分讨论这些问题。
- en: Right now, we need to make clear that context is extremely important and that
    our scripts should never in any way or form take for granted any element of it.
    If we want our scripts to run correctly, we should presume nothing, and instead,
    we should check everything that we expect to be in a certain state.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要明确的是，上下文极其重要，我们的脚本绝不应当以任何形式或方式理所当然地假设任何元素。如果我们希望脚本正确运行，我们应该不做任何假设，而应该检查所有我们期望处于某种状态的内容。
- en: A script that is able to check and decide what the possible problems are in
    the environment that started it requires two things that we haven't yet talked
    about – controlling the flow of the script and interacting with the system. Right
    now, it is obvious that we still don't know how to do that.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个能够检查并判断运行它的环境中可能出现的问题的脚本，要求具备我们尚未讨论的两个方面——控制脚本流程和与系统交互。现在，很明显我们仍然不知道如何做到这一点。
- en: Not being able to test things in a script means that, after all, we are going
    to presume a lot when creating this particular script. Be warned – this is usually
    the first thing that will lead us into problems.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 无法在脚本中测试某些内容意味着，在创建这个特定脚本时，我们将假设很多事情。要小心——这通常是导致问题的第一个原因。
- en: Not thinking things through before we even type a single letter is usually the
    source of all problems; scripts are rarely so simple that they can be created
    without planning in advance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们输入第一个字母之前没有仔细思考，通常是所有问题的根源；脚本很少是如此简单，能够在没有提前规划的情况下创建。
- en: The main reason we are talking about this now is to try and put you in the right
    mindset when creating your scripts.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在讨论这些问题的主要原因是希望在创建脚本时让你保持正确的思维方式。
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'So, how do you create a script? Before you even begin, you should do the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何创建脚本呢？在开始之前，你应该做以下几件事：
- en: Define your tasks.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义你的任务。
- en: Research commands that you are going to use.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究你将要使用的命令。
- en: Check permissions and things required for the individual commands to succeed.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查权限以及成功执行各个命令所需的条件。
- en: Try individual commands before using them in the script.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将命令用于脚本之前，先单独尝试这些命令。
- en: 'Think about things that you are presuming:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你假设的一些事情：
- en: If you are reading from or writing to any files, do you expect the files to
    be there, or do you need to create them?
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在读写某些文件，你是否期望这些文件已经存在，还是你需要创建它们？
- en: If you are referencing some file or directory, does it even exist, and do you
    have the right permissions?
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在引用某个文件或目录，它是否存在，并且你是否拥有正确的权限？
- en: Are you using some command that needs to be installed or configured beforehand?
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否使用了一些需要提前安装或配置的命令？
- en: Are you referencing files by an absolute or relative path?
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是通过绝对路径还是相对路径引用文件？
- en: This is only the tip of the iceberg that is usually called **sanity checks**,
    and the term *sanity*, in this case, refers to the state your script operates
    in. **Sane state** is what we say when we mean that everything is okay. Any deviation
    from this, or any error or problem that makes your script behave in an unexpected
    way, is a problem. This is why we need to think in advance. And that's also the
    reason why sanity-checked code can take much more effort than regular code that
    just does the basics.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是通常被称为**健全性检查**的冰山一角，在这种情况下，*健全性*指的是脚本运行时的状态。**健全状态**是指一切正常。当脚本偏离这一状态，或者出现错误或问题导致脚本行为异常时，那就是问题所在。这就是为什么我们需要提前思考的原因。也正因如此，进行健全性检查的代码可能比仅仅执行基础功能的常规代码更费力。
- en: But believe us – these kinds of checks will help keep not only the sanity of
    the environment but also your own sanity intact when dealing with complex tasks.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但是相信我们——这种类型的检查不仅有助于保持环境的正常运行，还能帮助你在处理复杂任务时保持理智。
- en: Right now, we are bravely ignoring all this and dealing with the basics. For
    our backup script, we are going to presume that both the `/root` and `/opt` directories
    exist and are accessible to whatever user is running the script. In our particular
    case, this means that our script is going to work ONLY if run by a superuser,
    since this user is required to be able to access files under `/root`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们勇敢地忽略了所有这些，专注于基础知识。对于我们的备份脚本，我们假设`/root`和`/opt`目录存在，并且对运行脚本的任何用户都是可访问的。在我们这个特定的案例中，这意味着只有超级用户运行脚本时，脚本才会有效，因为该用户需要能够访问`/root`下的文件。
- en: Also, we are going to presume that an email system of some kind exists and is
    running on the local computer. We will also presume that the log file mentioned
    in the last step is writeable to our script.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们假设某种类型的电子邮件系统存在，并且在本地计算机上运行。我们还假设在最后一步提到的日志文件可以被我们的脚本写入。
- en: Important Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: When running a script, you are making a lot of presumptions like these, and
    if any of them is not correct, your script is going to fail in some way. Your
    main job as a script creator is to prevent this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行脚本时，你会做出很多这样的假设，如果任何一个假设不正确，脚本就会以某种方式失败。作为脚本创建者，你的主要任务就是防止这种情况发生。
- en: What commands are we going to use?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用什么命令？
- en: Our first task is going to be to create a directory using today's date in its
    name. Here, we are going to presume that this directory does not exist, and we
    are going to create it no matter what. This is a significant deviation from the
    logic that we are going to use later – a command like this would usually check
    at least if the directory existed, and if the command itself succeeded. A script
    should fail in some graceful way if any of these are not `true`, or it should
    create directories that it needs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项任务是创建一个名称中包含今天日期的目录。在这里，我们假设这个目录不存在，并且无论如何都要创建它。这与我们稍后使用的逻辑有显著偏差——像这样的命令通常会检查目录是否存在，且命令本身是否成功。如果任何条件不`true`，脚本应该优雅地失败，或者创建它所需要的目录。
- en: Before you say, *But wait – I can already do that; I know how to do testing
    in a single command line,* let's go back and talk again about how a script is
    run.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在你说，*等等——我已经会这样做了；我知道如何在一个命令行中进行测试*之前，让我们回过头来再谈一谈脚本是如何运行的。
- en: At this moment, we are trying to create something that has no logic to control
    the flow of the script so that commands are run one line at a time. We could try
    to cheat and do some checks in each individual line, but since we are not controlling
    the flow of the entire script, this can be even more dangerous than doing no checks
    at all.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，我们尝试创建一些没有控制脚本流程的逻辑，这样命令就能逐行运行。我们本可以尝试在每行中进行一些检查，但由于我们没有控制整个脚本的流程，这可能比根本不做检查还要危险。
- en: An interpreter is going to run all the commands no matter what, and even if
    we are checking for problems and spot them, we will end up running all the commands
    in the script. The right thing to do if something is not right is to control how
    the *script* behaves, not how a *single command* behaves. No matter how simple
    or complex a scripting task is, you should always think about the aforementioned
    context and what your script is doing to it. If something fails, your script needs
    to decide – is the failure something that can be dealt with, or do you need to
    abort the execution of the entire script?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器会运行所有命令，无论如何，即使我们检查是否存在问题并发现了它们，我们最终还是会执行脚本中的所有命令。如果出现问题，正确的做法是控制*脚本*的行为，而不是控制*单个命令*的行为。不管脚本任务是多么简单或复杂，你都应该始终考虑上述背景以及你的脚本对它的影响。如果出现故障，脚本需要决定——这个故障是可以处理的吗？还是需要中止整个脚本的执行？
- en: If you are aborting execution in the middle of the script, is there something
    you need to do before your script ends? Usually, when something that forces you
    to abort a task happens, you will have some way of notifying the system and the
    user that there was a problem. Sometimes, that will not be enough – your script
    will have to clean up after itself.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在脚本中途中止执行，是否有需要在脚本结束之前做的事情？通常，当某些事情迫使你中止任务时，你会有某种方式通知系统和用户发生了问题。有时候，这可能还不够——你的脚本需要自行清理。
- en: It could be a matter of deleting some files, but it could be that you need to
    revert a change or even hundreds of changes that you made to the system. Every
    failure should be evaluated not only on its severity but also on how it affects
    the system and the state that your script created on that system.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能仅仅是删除一些文件的问题，也可能是需要恢复你对系统所做的某个更改，甚至是恢复数百个更改。每次失败都应该评估它的严重性，以及它如何影响系统和脚本在该系统上创建的状态。
- en: How it works…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: After creating what is probably the world's largest disclaimer on why our script
    is so basic, let's get down to work.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了可能是世界上最大的免责声明，解释我们为什么脚本如此简单之后，咱们开始动手工作吧。
- en: Task by task, how are we going to solve this?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一步步来，我们该如何解决这个问题呢？
- en: Creating a directory is simple; we are going to avoid using Bash shell expansion,
    and we will use the `date` system command. We are cheating a little bit here,
    since we are referencing the system environment, but the task is simply impossible
    to accomplish without it, and we are not relying on something that is inherent
    to Bash itself. Note here that this also demonstrates that there are usually multiple
    ways to do any one thing in scripting. The only difference is your creativity.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建目录很简单；我们将避免使用 Bash shell 扩展，而是使用`date`系统命令。这里我们有点作弊，因为我们引用了系统环境，但这个任务没有它就根本无法完成，我们也没有依赖
    Bash 本身的内置功能。请注意，这也展示了在脚本中通常有多种方法可以完成同一件事，唯一的区别是你的创造力。
- en: 'The first command will be something like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令大概是这样的：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Please note that we are running this as the `root` user. Let''s quickly check
    what happened:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在以`root`用户身份运行这个操作。我们来快速检查一下发生了什么：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see that our directory has been created. Now, let''s deal with the copy
    operation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的目录已经创建好了。现在，让我们处理复制操作：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We were able to create a test file and copy it to our directory. Pay attention
    to the way we are referencing the directory that we are copying to – since we
    don't know *when* this script is going to run, there is no way for us to know
    what the current directory we need to copy to is.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功创建了一个测试文件并将其复制到我们的目录。请注意，我们引用目标目录的方式——由于我们不知道*什么时候*脚本会运行，我们无法知道当前需要复制到哪个目录。
- en: To avoid the hassle of having to read and parse directories, we are simply recreating
    the directory name the same way we did when we created the directory itself. There
    is a possible bug here – if, by some freak chance, your script is run exactly
    at midnight, it is possible that the part where the directory is created is run
    before midnight and the part we are using to copy the files is run after midnight.
    This can create an error, since the names will not match. The chance of this happening
    is slim, and we are not going to plan for it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免需要读取和解析目录的麻烦，我们简单地重新创建目录名称，就像我们创建目录时一样。这里可能会有一个错误——如果在某种奇怪的情况下，脚本恰好在午夜时运行，那么创建目录的部分可能会在午夜之前执行，而我们用来复制文件的部分则可能会在午夜之后执行。这会导致错误，因为名称将不匹配。发生这种情况的几率很小，我们也不会为此做计划。
- en: In a large script, things like this can and will create big problems if not
    addressed correctly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大型脚本中，如果不正确处理这类问题，将会导致严重的问题。
- en: 'Now, let''s do mail functionality:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理邮件功能：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The error here is important. We did it to show the importance of testing commands.
    In this case, we tried sending mail, and it made us realize that the command we
    are expecting to use is not installed by default.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的错误很重要。我们这样做是为了展示测试命令的重要性。在这种情况下，我们尝试发送邮件，这让我们意识到我们期望使用的命令并不是默认安装的。
- en: In order to run this script, we actually need to have the `mail` command installed.
    It is going to be there on servers that have mail service configured but is going
    to be absent on normal workstations. Since our backup script should work on any
    server, we need to solve that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，实际上我们需要安装`mail`命令。在配置了邮件服务的服务器上，这个命令会存在，但在普通工作站上则不会。由于我们的备份脚本应该在任何服务器上工作，我们需要解决这个问题。
- en: Blindly installing a package using a package manager is usually safe; the system
    will either install the package or update it if it was already installed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 盲目地使用包管理器安装软件包通常是安全的；系统将安装该软件包或者如果已安装则更新它。
- en: 'Now, we are going to try that command again, and once again, it is going to
    fail:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次尝试该命令，但这次又将失败：
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We didn't actually fail, but when we invoked the first command, it required
    us to input some data. It was asking us for the `Cc` address, and we had to press
    *Ctrl* + *D* to finish the body of the email.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上没有失败，但当我们调用第一个命令时，它要求我们输入一些数据。它要求我们输入`Cc`地址，并且我们必须按下*Ctrl* + *D*来完成邮件正文。
- en: This is another reason to test commands before using them in a script.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是在脚本中使用命令之前进行测试的另一个理由。
- en: After realizing that we need to do something to make this command run unattended
    and reading the manual, we can see it is a matter of simply providing no inputs
    by redirecting `/dev/null` into the command.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在意识到我们需要做一些事情使这个命令无需人工干预运行并阅读手册后，我们发现只需将`/dev/null`重定向到命令中即可。
- en: 'Now, for the last command that we need to do, we implement the actual reporting
    of the backup:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于我们需要执行的最后一个命令，我们实施备份的实际报告：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember, we need to append to a file. Additionally, what we want to do is reference
    the file directly using an absolute path; after all, we have no idea where we
    will be when running this script.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们需要向文件追加内容。另外，我们希望直接使用绝对路径引用文件；毕竟，在运行此脚本时，我们不知道会在哪里。
- en: 'Okay, we have tried and tested all the commands. How does our script actually
    look? It''s not complicated:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经尝试和测试了所有的命令。我们的脚本实际上是什么样子？并不复杂：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let's run it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行它。
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are a few things that need our attention. First, note that we have some
    output from the script that we didn't expect. This is normal and is a direct result
    of what we saw when we tested our command – some commands threw errors. The reason
    we are seeing this error is going to be explained in the next part of this chapter.
    Another thing that we need to note is that other than the errors, we have no other
    output. The only way we have to tell whether our script was successful or not
    will be by having the script itself report it – we need to check the mail and
    the file mentioned in the script to check whether everything is correct. That
    points us to another thing we are going to need – the logging. We are going to
    deal with logs and debugging in later chapters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件事情需要我们的注意。首先，请注意，我们有一些脚本输出是我们没有预料到的。这是正常的，直接是我们在测试命令时看到的结果 — 一些命令抛出了错误。我们看到这个错误的原因将在本章的下一部分进行解释。我们需要注意的另一件事是，除了错误之外，我们没有其他输出。我们唯一能判断我们的脚本是否成功的方法将是让脚本本身报告
    — 我们需要检查脚本中提到的邮件和文件以确认一切是否正确。这提示我们还需要另一件事情 — 日志记录。我们将在后续章节中处理日志和调试问题。
- en: Now, let's elaborate a little on how your script communicates with the environment.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们稍微详细介绍一下您的脚本如何与环境通信。
- en: There's more…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Different operators for chaining in Bash: [https://www.thegeekdiary.com/6-bash-shell-command-line-chaining-operators-in-linux/](https://www.thegeekdiary.com/6-bash-shell-command-line-chaining-operators-in-linux/%0D)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash 中不同的命令链操作符：[https://www.thegeekdiary.com/6-bash-shell-command-line-chaining-operators-in-linux/](https://www.thegeekdiary.com/6-bash-shell-command-line-chaining-operators-in-linux/%0D)
- en: 'Formatting dates in Bash: [https://www.cyberciti.biz/faq/linux-unix-formatting-dates-for-display/](https://www.cyberciti.biz/faq/linux-unix-formatting-dates-for-display/)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在 Bash 中格式化日期: [https://www.cyberciti.biz/faq/linux-unix-formatting-dates-for-display/](https://www.cyberciti.biz/faq/linux-unix-formatting-dates-for-display/)'
- en: Manipulating shell script input, output, and errors
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作 shell 脚本的输入、输出和错误
- en: There are only a few things that are as pragmatic as the idea behind the concept
    of standard input and standard output on Linux.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比 Linux 中标准输入和标准输出的概念更具实用性了。
- en: Since the start of Unix, the idea of interoperability between different applications
    and tools installed on a system was one of the primary prerequisites that every
    script, tool, and application had to follow.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Unix 起，系统上安装的不同应用程序和工具之间的互操作性一直是每个脚本、工具和应用程序必须遵循的主要前提之一。
- en: Simply put, if you wrote any tool on a system, you could count on three separate
    channels of communication to your surroundings. Based on the concept of ANSI C
    input/output streams called **standard output** and **standard input**, everything
    that runs in a shell can communicate in three ways – it can receive inputs from
    standard input, it can output results and information to standard output, and
    it can report errors to a separate output that is marked just for this task as
    **error output**.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，如果你在系统上编写任何工具，你可以依赖三个独立的通信渠道与外部环境进行交互。基于 ANSI C 输入/输出流的概念，称为**标准输出**和**标准输入**，在
    shell 中运行的所有程序可以通过三种方式进行通信——它可以从标准输入接收输入，它可以将结果和信息输出到标准输出，并且它可以将错误报告到专门为此任务标记的另一个输出，称为**错误输出**。
- en: Pair this idea with the concept that every tool should output text-only information
    with minimal formatting, and should be ready to accept text input if it is required,
    and you have a framework that is simple but amazingly robust and portable.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个概念与每个工具应该输出仅包含文本信息并具有最小格式化的思想结合起来，并且应该准备好在需要时接受文本输入，你就得到了一个简单但极其强大且可移植的框架。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: When we create scripts, we are going to use these concepts a lot, in a myriad
    of different ways. Before we can do that, we need to make sure that we understand
    what inputs and outputs actually exist and are available to us, and what is the
    usual way of using them when scripting. After that, we will deal with some recommendations
    and how to conform to certain well-established best practices when it comes to
    user interaction.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建脚本时，我们将经常使用这些概念，以各种不同的方式。在这之前，我们需要确保理解实际存在且可用的输入和输出，以及在编写脚本时它们的常见使用方式。之后，我们将处理一些建议以及如何遵循在用户交互方面已确立的最佳实践。
- en: Even before that, we need to define some things. Standard input, output, and
    error are just special cases of something called **file descriptors**. To simplify
    things a bit, we will not be spending too much time on what a file descriptor
    actually is; for the sake of this chapter, let's just say that it is a way of
    referencing an open file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至在此之前，我们需要定义一些概念。标准输入、输出和错误只是被称为**文件描述符**的某些特例。为了简化一些内容，我们不会花太多时间讨论文件描述符到底是什么；就本章而言，我们可以将其视为引用已打开文件的一种方式。
- en: Since in Linux everything is considered to be a file, we are basically just
    assigning a number to something we can write to, read from, or both read and write
    to, depending on the context. Obviously, our options on reading and writing depend
    on what the actual device referenced is.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在 Linux 中一切都被视为文件，因此我们实际上只是为可以写入、读取或在某些情况下既能读又能写的内容分配一个数字，具体取决于上下文。显然，读取和写入的选项取决于实际设备的引用是什么。
- en: By default, your script will *open* communication with three *files* that it
    can use. Standard input is going to be connected to a keyboard; your script is
    going to accept information from the keyboard unless you change it to something
    else, such as some other file or output of another script or application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你的脚本会*打开*与三个*文件*的通信。这些文件将用于处理标准输入，标准输入将与键盘连接；你的脚本将从键盘接收信息，除非你将其更改为其他东西，例如另一个文件或其他脚本或应用程序的输出。
- en: Standard output is, by default, set to the *console* or the screen you are running
    your script from. In some circumstances, we will also call a screen connected
    physically to your server a **console**, but that is not part of what we are dealing
    with right now. The reason we are mentioning this is to avoid unnecessary confusion.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输出默认设置为*控制台*或你运行脚本的屏幕。在某些情况下，我们还会将物理连接到服务器的屏幕称为**控制台**，但这不是我们现在要处理的内容。我们提到这一点是为了避免不必要的混淆。
- en: We cannot read from a screen or write to a keyboard, and this is why we are
    usually referring to them as *consoles*, which is a common name that more or less
    describes both the keyboard and the screen. There is a lot more to learn here,
    but for now, we are going to leave it at this.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法从屏幕读取或向键盘写入，这就是为什么我们通常称它们为*控制台*，这是一种常见的名称，或多或少地描述了键盘和屏幕。这里还有很多内容可以学习，但现在我们就先停在这里。
- en: How to do it…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: To better explain these two things, you can do something simple – run a command
    called `cat` without any arguments. When executed like this, any command including
    `cat` will accept standard input and then output the result to the standard output.
    In this particular case, `cat` is going to do it one line at a time, since it
    waits for a line separator before it outputs information.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释这两件事，你可以做一个简单的操作——运行一个没有任何参数的`cat`命令。当像这样执行时，任何命令，包括`cat`，都会接受标准输入并将结果输出到标准输出。在这个特定的例子中，`cat`会一行一行地处理，因为它在输出信息之前会等待一个行分隔符。
- en: In reality, this means that `cat` is going to echo whatever you type in, line
    by line, until you use *Ctrl* + *D* to signal a special character called **End
    of Transmission** (**EOT**), which tells the system that you decided to end typing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着`cat`会逐行回显你输入的内容，直到你使用*Ctrl* + *D*发送一个特殊字符，称为**传输结束**（**EOT**），这告诉系统你决定结束输入。
- en: 'This will end the execution of the application. In the screenshot, it looks
    like we typed each line twice; in fact, one is our input, and the other one is
    the output from the command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将结束应用程序的执行。在截图中，看起来我们输入了每一行两次；实际上，一行是我们的输入，另一行是命令的输出：
- en: '![Figure 9.3 – cat – the simplest command to demonstrate standard input and
    output'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3 – cat – 演示标准输入和输出的最简单命令'
- en: '](img/Figure_9.3_B16269.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.3_B16269.jpg)'
- en: Figure 9.3 – cat – the simplest command to demonstrate standard input and output
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – cat – 演示标准输入和输出的最简单命令
- en: There is also standard error, which also defaults to the screen but is a separate
    stream of data; if we output something to standard error, it will be displayed
    in a way that looks exactly the same as standard output, but that can be redirected
    if we need to.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 还有标准错误，它也默认为屏幕，但它是一个独立的数据流；如果我们将某些内容输出到标准错误，它会以与标准输出完全相同的方式显示，但如果需要的话，可以进行重定向。
- en: The reason why there are two separate streams handling output is simple – we
    usually want to have some data as the result of our script, but we do not want
    errors to be part of it. In this case, we can redirect data into some file and
    redirect errors to the screen, or even to another file, and then deal with them
    later.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以有两个单独的流来处理输出，很简单——我们通常希望将某些数据作为脚本的结果，但我们不希望错误也成为其中的一部分。在这种情况下，我们可以将数据重定向到某个文件，将错误重定向到屏幕，或者甚至重定向到另一个文件，然后再处理它们。
- en: 'Now, remember when we mentioned that standard input, output, and error are
    special instances of a file descriptor? Bash can actually have nine file descriptors
    open at the same time, so there are many more things we can do when writing out
    something in our scripts. This is, however, rarely done, since almost everything
    can be accomplished by using only the default ones. For now, just remember the
    following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，记得我们之前提到标准输入、输出和错误是文件描述符的特殊实例吗？Bash实际上可以同时打开九个文件描述符，所以在编写脚本时我们可以做更多的事情。然而，这种做法很少使用，因为几乎所有的操作都可以通过使用默认的文件描述符完成。现在，记住以下几点：
- en: Standard input is file descriptor number `0`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准输入是文件描述符号`0`。
- en: Standard output is file descriptor number `1`.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准输出是文件描述符号`1`。
- en: Standard error is file descriptor number `2`.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准错误是文件描述符号`2`。
- en: Why do these numbers matter? By using some special characters in the command
    line and in our scripts, we can do a lot if we know only these three numbers.
    First, how do we stop a script displaying something on the screen, and how do
    we output it to a file instead? By simple use of the `>` character.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这些数字很重要？通过在命令行和脚本中使用一些特殊字符，如果我们只知道这三个数字，我们可以做很多事情。首先，如何停止脚本在屏幕上显示某些内容，如何将它输出到文件中？只需简单地使用
    `>` 字符。
- en: Sometimes, you will see a command line containing `1>` instead of just `>`.
    This is exactly the same as using a single `>` character, but it is sometimes
    written like this to make sure you understand that you are redirecting standard
    output.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会看到命令行中包含 `1>` 而不是单纯的 `>`。这与使用单个 `>` 字符完全相同，但有时写成这样是为了确保你明白你正在重定向标准输出。
- en: You are probably familiar with this form of redirection, since this is one of
    the first things you learn when dealing with the command line. An important thing
    to note is that we can redirect to a file in two different ways, depending on
    what do we want to do with the file if it already exists.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对这种重定向形式很熟悉，因为这是你在处理命令行时学到的第一件事之一。需要注意的一点是，我们可以通过两种不同的方式将输出重定向到文件中，这取决于如果文件已经存在，我们希望对其做什么。
- en: By using `> filename`, we are going to redirect whatever the script outputted
    to the standard output to the file named `filename`. If the file does not exist,
    it will be created, and if the file exists, it will be *overwritten*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `> filename`，我们将把脚本输出的内容重定向到名为 `filename` 的文件中。如果该文件不存在，它将被创建，如果文件已经存在，它将被*覆盖*。
- en: By using just one more bracket, the `>> filename` redirection will be different
    in the way it treats files that already exist. If we redirect using this symbol,
    we are going to *append* data into an already existing file; data is going to
    go to the end of the file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一个额外的括号，`>> filename` 重定向在处理已存在文件时的方式会有所不同。如果我们使用这个符号进行重定向，我们将会*追加*数据到一个已存在的文件中；数据将被添加到文件的末尾。
- en: Having mentioned `1>`, we need to deal with the way more popular `2>` symbol
    that represents standard error. When something wrong happens in our script, it
    is going to output it as an error. Usually, you will notice it if you just redirect
    the script output to a file; if you fail to mention `2>`, you will see that only
    errors are going to appear on the screen, while everything else is going to end
    up in the file.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 提到 `1>` 后，我们需要处理更常见的 `2>` 符号，它表示标准错误。当脚本中出现错误时，它会将错误输出。通常，如果你只把脚本输出重定向到文件，你会注意到，如果没有提到
    `2>`，只有错误会出现在屏幕上，而其他所有内容都会写入文件。
- en: If we actually want to output the result of errors in a particular file, we
    can do that by using `2> errorfilename`, and the script will write its errors
    into a file called `errorfilename`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确实希望将错误的结果输出到特定的文件中，可以通过使用 `2> errorfilename` 来实现，脚本将把错误写入名为 `errorfilename`
    的文件中。
- en: There is also the possibility that we want to output everything into a single
    file, and there are two ways to do this. One is to do both redirections in one
    command line separately, using the same filename for both redirects. This has
    its own advantage of being easy to read when we are trying to understand where
    the outputs are going.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种可能性是我们希望将所有内容输出到同一个文件中，且有两种方式可以实现。一种是分别在一条命令行中执行两个重定向，使用相同的文件名进行重定向。这样做的好处是当我们尝试理解输出的去向时，它比较容易阅读。
- en: 'The main disadvantage is that this redirection is probably the most used one
    when it comes to dealing with scripts, especially when we run them unattended,
    and this makes it *harder* to read in most environments. Of course, there is a
    simple solution to this – instead of using two separate redirects, we can use
    a single one by using the `&> filename`. In the Bash environment, this means that
    we want to redirect both standard error and output to the same file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的缺点是，这种重定向可能是处理脚本时最常用的，尤其是在我们让脚本在无人值守的情况下运行时，这使得它在大多数环境中*更难*阅读。当然，有一个简单的解决办法——我们可以通过使用
    `&> filename` 来使用单一重定向代替两个分开的重定向。在 Bash 环境中，这意味着我们希望将标准错误和输出都重定向到同一个文件：
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Please note that this trick works only if redirecting both the output and errors
    to one file; if the output files are different, we need to specify them explicitly
    one by one.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个技巧仅在将输出和错误都重定向到同一个文件时有效；如果输出文件不同，我们需要明确地分别指定它们。
- en: When we started discussing outputs, we said that there can be more than just
    the three predefined ones, and the way to handle them is logical. If we decide
    to redirect something outputted to file descriptor number `5`, the way to handle
    it in the command line would be to just redirect `5> filename`. This is something
    you will not see every day, but it can be extremely useful if you need to create
    more than one log file or need to create different outputs to different destinations
    from the same script. This approach is seldom used, since it is much easier to
    handle redirection directly from the script, and by using variables in the script,
    anyone debugging your scripts is going to have a much easier job.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始讨论输出时，我们提到过输出不仅仅限于三个预定义的类型，处理它们的方式是合乎逻辑的。如果我们决定将某些输出重定向到文件描述符 `5`，在命令行中的处理方式将是直接重定向
    `5> 文件名`。这不是每天都会见到的情况，但如果你需要创建多个日志文件或从同一个脚本输出不同的内容到不同的目标，這將是非常有用的。这种方法很少使用，因为直接从脚本中处理重定向要简单得多，而且通过在脚本中使用变量，任何调试你脚本的人都将更加容易。
- en: Up to this point, we were dealing with redirection from *outside* of our scripts.
    It is time to move on to how to use this in our everyday work.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们处理的是来自*外部*的重定向。现在是时候转向如何在日常工作中使用它了。
- en: 'The main thing that we are going to do using redirection is to log things.
    There are a couple of approaches here. One is to simply use the `echo` command
    in the script and then do the redirection for the whole script – for example,
    we can create a simple script that just prints four lines of text:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用重定向的主要目的是记录信息。有几种方法可以实现这一点。一种是简单地在脚本中使用 `echo` 命令，然后对整个脚本进行重定向——例如，我们可以创建一个简单的脚本，只打印四行文本：
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s name it `simpleecho.sh` and run it using Bash:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其命名为 `simpleecho.sh` 并通过 Bash 运行它：
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we are going to redirect it to a file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将它重定向到一个文件：
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Okay, we can see that our file now contains output for the `echo` commands.
    For the sake of showing how errors work, we are going to insert an intentional
    error into our script:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们可以看到文件现在包含了 `echo` 命令的输出。为了演示错误是如何工作的，我们将在脚本中插入一个故意的错误：
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we are going to do the same procedure again, first starting the script
    and then redirecting it to see what happened:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次执行相同的操作，首先启动脚本，然后进行重定向，看看发生了什么：
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The main thing to take away here is that error output is always separate from
    standard output, so we are not going to see errors in our file unless we specifically
    redirect them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要记住的主要一点是，错误输出始终与标准输出分开，因此除非我们特意重定向它们，否则不会在文件中看到错误。
- en: Everything up to this point was simple, since our script was using just standard
    output. Often, communicating with users is not so simple because we want to have
    our script to be able to provide some information on screen and to a special log
    file. Things are similar when working with unattended scripts; having the ability
    to redirect script output to a certain file is nice, but more often, we are going
    to make our script use a particular log file by itself, without the need for the
    user or the administrator to do any redirection when executing the script.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，事情都很简单，因为我们的脚本只使用了标准输出。通常，与用户的沟通并不像这那么简单，因为我们希望脚本既能在屏幕上提供一些信息，又能输出到一个特定的日志文件。当处理无人值守脚本时，情况类似；能够将脚本输出重定向到特定文件是很方便的，但更常见的做法是让脚本自动使用一个特定的日志文件，无需用户或管理员在执行脚本时进行任何重定向。
- en: The process required to do this is remarkably simple – we can use the redirection
    at the command level to redirect our output to a file. There is only one thing
    you have to remember here. Redirection into a file is limited to a single command;
    if you redirect anything, the file is going to be closed as soon as the command
    finishes. This is important primarily because you will always need to append to
    a file; if you forget to do so, that file is going to get rewritten with new data,
    making it useless as a log. Since a log is usually used to track multiple executions
    of a script or service, you will almost universally append to files.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的过程非常简单——我们可以在命令级别使用重定向，将输出重定向到文件。这里唯一需要记住的一点是，重定向到文件仅限于单个命令；如果你重定向任何内容，文件将在命令完成后立即关闭。这一点非常重要，主要因为你通常需要将内容附加到文件中；如果你忘记这样做，文件将会被新数据覆盖，作为日志文件就失去了作用。由于日志通常用于跟踪脚本或服务的多次执行，你几乎总是会将数据附加到文件中。
- en: How it works…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s now expand our initial script, adding a little bit of logging. What
    we are going to do is write separate logs that will contain information about
    the actions that the script took while running. We are going to write this information
    to a log file located in the directory that the script was invoked from. This
    means that our script will at any one time be able to use three separate channels
    for output; in addition to standard output and standard error, we are also using
    our log file. The big difference between log files and standard output is that
    our log is hardcoded, and there is no way of redirecting it to another file. Of
    course, a solution for this problem exists, but we are not going to spend too
    much time on it; we already said it is possible to use one of the other file descriptors
    and map output to it, forwarding the output to whatever stream we need later.
    This is seldom used, since it requires additional attention when running a script:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们扩展我们的初始脚本，增加一点日志记录。我们要做的是编写单独的日志，其中包含脚本运行时执行的操作信息。我们将此信息写入脚本调用目录中的日志文件。这意味着我们的脚本随时可以使用三个单独的输出通道；除了标准输出和标准错误之外，我们还使用我们的日志文件。日志文件与标准输出之间的主要区别在于我们的日志是硬编码的，没有办法将其重定向到另一个文件。当然，存在此问题的解决方案，但我们不会花太多时间在上面；我们已经说过可以使用其他文件描述符之一，并将输出映射到它，稍后将输出转发到任何所需的流。这很少使用，因为在运行脚本时需要额外注意：
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This approach gives us additional flexibility, since we do not have to forward
    standard output in order to have logs; our script already does that. This means
    that we can start the script either from the command line or as an unattended
    task and get the same results in the logs. Of course, we can always use redirection
    and make sure that every output is written and saved.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法为我们提供了额外的灵活性，因为我们无需转发标准输出即可获得日志；我们的脚本已经做到了这一点。这意味着我们可以从命令行或作为无人看管的任务启动脚本，并在日志中获得相同的结果。当然，我们始终可以使用重定向来确保每个输出都被写入和保存。
- en: There's more…
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Standard input and output (in C): https://www.technologyuk.net/computing/software-development/computer-programming/c-programming/basic-io.shtml'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 中的标准输入和输出：[https://www.technologyuk.net/computing/software-development/computer-programming/c-programming/basic-io.shtml](https://www.technologyuk.net/computing/software-development/computer-programming/c-programming/basic-io.shtml)
- en: 'Standard input and output (in Bash, with examples): [https://tldp.org/LDP/abs/html/io-redirection.html](https://tldp.org/LDP/abs/html/io-redirection.html%0D)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash 中的标准输入和输出（带示例）：[https://tldp.org/LDP/abs/html/io-redirection.html](https://tldp.org/LDP/abs/html/io-redirection.html%0D)
- en: Shell script hygiene
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell 脚本卫生
- en: Commenting is not just something you can do; it's an art by itself. In this
    part of the chapter, we are going to deal with comments in order to make your
    life easier when writing scripts, but the advice and best practices that are given
    here are easily used in any programming language that we can think of. Really
    understanding how to comment in a useful way is something that you're going to
    need to learn, since it will help anybody going to use your scripts after you
    are done writing them.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 评论不仅仅是你可以做的事情；它本身就是一种艺术。在本章的这一部分，我们将处理评论，以便在编写脚本时使您的生活更轻松，但是在此处提供的建议和最佳实践在我们能想到的任何编程语言中都可以轻松使用。真正理解如何以有用的方式进行评论是您需要学习的事情，因为它将帮助任何在您完成编写后要使用您的脚本的人。
- en: So, what are comments? Possibly the easiest way to describe them is to say that
    they are documentation on what the script is intended to do, how the script works,
    and who has created the script, and they provide more information on technical
    details of the script, such as when it was created.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，评论是什么？可能描述它们的最简单方式是说它们是关于脚本预期执行的文档、脚本如何工作以及谁创建了脚本的文档，并且它们提供了有关脚本的技术细节的更多信息，例如创建时间。
- en: Commenting is something that you should automatically want to do. Nobody is
    perfect and nobody has a perfect memory. Comments are there to help you remember
    what you did inside some script and to provide anybody else with guidance on how
    the script works and what the different things are that they need to know if they
    need to change anything in the script.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 评论是您应该自动想要做的事情。没有人是完美的，也没有人有完美的记忆。评论的作用是帮助您记住在某些脚本内部所做的事情，并向任何其他人提供关于脚本如何工作以及如果他们需要更改脚本中的任何内容时需要知道的不同事项的指导。
- en: One more important point is that commenting is not the same as providing documentation.
    Sometimes, people are going to say that they don't need documentation because
    they already have comments in their code, but this is completely wrong. Unless
    you're talking about a script that has only 10 lines of code or so, comments are
    going to help you to understand what the script is doing without looking up the
    whole documentation, which saves you a lot of time.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的点是，注释并不等同于提供文档。有时候，人们可能会说他们不需要文档，因为他们在代码中已经有了注释，但这是完全错误的。除非你在讨论只有大约10行代码的脚本，否则注释会帮助你理解脚本的功能，而不必查阅整个文档，这可以节省大量时间。
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: So, let's now talk about different types of comments. When writing code, there
    is always a part that involves commenting on individual procedures or parts of
    the script, expected input and output, data types, and data in general.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈不同类型的注释。在编写代码时，总会涉及对各个过程或脚本部分的注释、预期的输入和输出、数据类型以及数据的注释。
- en: In Bash, comments are universally started by the `#` sign. Bash does not recognize
    multiline comments, unlike some other programming languages. What this means is
    that we need to pay attention so that every line that contains a comment starts
    with `#`. The only exception of sorts is the first line in the script, which contains
    the interpreter that is going to run the script, but the interpreter continues
    working after that line, so we can say that every line that starts with `#` is
    actually a comment. The shell is going to ignore everything inside the comment
    or, to be more precise, it is going to completely ignore the lines that contain
    the comment. So, understand that the comments are written for you and for other
    people that are going to be dealing with your scripts. Try to make them easy to
    understand, precise, and avoid repeating what can actually be deduced from the
    command itself. For example, if you have a command that is echoing something,
    try not saying, *Okay, this command is going to echo…* whatever text you're trying
    to output to a user, but try to explain why. This is especially useful when commenting
    on cryptic output that contains a lot of variables.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash中，注释通常以`#`符号开头。Bash不识别多行注释，不像一些其他编程语言那样。这意味着我们需要注意，每一行包含注释的行都以`#`开头。某种程度上的例外是脚本中的第一行，它包含将运行脚本的解释器，但解释器在那行之后继续工作，所以我们可以说每一行以`#`开头的行实际上都是注释。Shell会忽略注释内的所有内容，或者更准确地说，它会完全忽略包含注释的行。因此，请理解注释是为您和其他将要处理您的脚本的人编写的。尽量使它们易于理解、准确，并避免重复可以从命令本身推导出的内容。例如，如果您有一个命令在回显某些内容，请尽量不要说，“好的，这个命令将回显…”你要输出给用户的任何文本，而是尽量解释为什么。在注释带有许多变量的晦涩输出时，这尤其有用。
- en: You can and should write comments in front of every block of code in your script,
    but you should also comment at the start and the end of the script.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以并且应该在脚本中每个代码块的前面写注释，但也应该在脚本的开头和结尾写注释。
- en: How to do it…
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: Let's start with the beginning of the script. What should be the first comment?
    The first line should, of course, be the name of the interpreter, and after that,
    we usually give information about the script itself. Generally, the script should
    start with a comment that gives information on who wrote it, when, and if it is
    part of the project that is responsible for the script itself.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从脚本的开始说起。第一个注释应该是什么？首先应该是解释器的名称，然后通常会提供有关脚本本身的信息。通常，脚本应该以一个注释开始，提供有关谁编写了它、何时编写的以及它是否属于负责脚本本身的项目的信息。
- en: This part should also state technical things such as licensing distribution,
    limitation on warranties, and who is and is not allowed to use the script.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分还应该说明技术细节，如许可分发、对保证的限制以及谁有权使用脚本，谁没有。
- en: Having done the header, we should also deal with the arguments and information
    on how a script should be run and what to expect in terms of input. If there is
    something special about the input, such as expected types, the number of arguments,
    or some prerequisites that need to exist or run before the script is running,
    they should be stated somewhere at the beginning of the script.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了头部之后，我们还应该处理脚本的参数和运行方式，以及在输入方面的预期结果。如果输入有特殊要求，比如预期类型、参数数量或者在运行脚本之前需要存在或运行的先决条件，这些都应该在脚本的开头某处声明。
- en: Now, we come to the functions. We are going to deal with the concept of functions
    later, but we do need to talk about how to comment on them, since this also applies
    to any other block of code. This is because functions are, by themselves, modular
    and written as a separate block of code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来讲解函数。我们稍后会讨论函数的概念，但我们需要先讨论如何对函数进行注释，因为这也适用于任何其他的代码块。原因在于，函数本身是模块化的，并且以独立代码块的形式书写。
- en: Sharing something separated inside a function gives us the opportunity to comment.
    We should use this part of the comments to describe what the function or the module
    does, what variables we are going to change and need, the arguments that your
    function is going to take, what the function is going to do, and what the output
    to the function is going to be. If we are dealing with some sort of nonstandard
    output – for example, if we are dealing with logging to a separate file – we should
    state that in the function header. We should also note all the return codes that
    the function outputs if it changes the exit status of the script.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部共享某些内容时，给我们提供了注释的机会。我们应该利用这部分注释来描述函数或模块的作用，哪些变量会被修改或需要，函数将接收哪些参数，函数将执行什么操作，以及函数的输出是什么。如果我们处理的是某种非标准输出
    —— 比如说，记录日志到单独的文件 —— 我们应该在函数头部说明。我们还应该注明函数输出的所有返回代码，尤其是在它改变脚本的退出状态时。
- en: There are useful ways of using comments to create reminders for yourself and
    for others to inform what still needs to be done in a script, which are called
    **to do comments**. They are usually written in capital letters – **TODO**.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些有用的方式可以通过注释来创建提醒，提醒自己或他人脚本中仍需要完成的任务，这些被称为**待办注释**。它们通常以大写字母写成 —— **TODO**。
- en: We should also note that there is something called a `heredoc` notation that
    is sometimes used when we need to create large blocks of comments. This notation
    uses shell redirection in a very specific way so that it can provide the header
    and the footer for the comment block without using common signs. We're going to
    provide you with an example of this notation, since you will run into it when
    you analyze other people's scripts, but we're not going to use it in our scripts.
    The main reason for that is that it tends to make scripts less readable.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应注意，存在一种叫做`heredoc`表示法的方式，它有时用于我们需要创建大块注释时。这种表示法通过特定的Shell重定向方式来提供注释块的头部和尾部，而不使用常见的符号。我们将为你提供一个该表示法的示例，因为你在分析其他人脚本时会遇到它，但我们在自己的脚本中不会使用它。主要原因是它往往使脚本的可读性下降。
- en: 'For example, this is a perfectly valid way of creating a comment:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一种完全有效的注释创建方式：
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, what do we actually comment?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们到底注释什么呢？
- en: 'Let''s start with some general things:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些一般性的事情开始：
- en: State clearly who wrote the script and when was it created.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确标明脚本的编写者以及创建时间。
- en: Version your script – if there are any changes, update the version so that you
    can track which script you are using on different computers.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给脚本版本化 —— 如果有任何更改，更新版本号，以便你可以跟踪不同计算机上使用的脚本。
- en: Explain any complicated part of the code – things such as regular expressions,
    calling outside sources, and general references to anything outside of your script
    should be commented.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释代码中任何复杂的部分 —— 诸如正则表达式、调用外部资源、以及任何引用脚本之外的内容都应该加上注释。
- en: Comment on individual blocks of code.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对单独的代码块进行注释。
- en: Clearly note all the old parts of code that you commented out and left in your
    script.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰标注你注释掉并保留在脚本中的旧代码部分。
- en: We'll talk a bit about all these points.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会稍微讲一下所有这些要点。
- en: Clearly marking the script author and creation date is crucial. Your scripts
    are probably going to end up being maintained by people other than you. The worst
    thing that can happen to you when you open a script with a couple of hundred lines
    of code is not knowing who to talk to when something goes wrong. Some people think
    that they are going to avoid being constantly pestered by other admins by not
    signing the script, but this is simply wrong. You wrote that script; be proud
    of it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰地标明脚本的作者和创建日期至关重要。你的脚本可能会被其他人维护。打开一个有几百行代码的脚本时，最糟糕的情况就是不知道出问题时该找谁。有些人认为不签署脚本可以避免被其他管理员不断打扰，但这种想法是错误的。你写了这个脚本，为它感到自豪吧。
- en: After you mention the author, always note when the script was created. This
    helps people prioritize possible changes, especially to some outside resources
    that you may be using in the script itself. Also, write when the last change was
    made, since it is relevant information for everybody maintaining the script, including
    you.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在提及作者后，请始终注意脚本的创建时间。这有助于人们优先考虑可能的更改，尤其是一些脚本中可能使用的外部资源。此外，请写出最后一次更改的时间，因为这对于所有维护脚本的人（包括您在内）都是相关信息。
- en: After mentioning changes, learn to version. Versioning is a way of keeping track
    of different changes that you make in a script and making sure you know which
    version you are using at any given moment. Versioning itself is a simple concept
    of using a scheme that enables you to track how your script progresses and what
    has changed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在提及更改后，学习版本控制。版本控制是一种跟踪脚本中不同更改的方式，并确保您知道在任何给定时刻使用的版本。版本控制本身是一个简单的概念，使用一种方案来跟踪您的脚本的进展及所做的更改。
- en: There are a couple of ways this can be done, since there is no official standard
    on how to write down versions, although a lot of people tend to use semantic versioning
    (`https://semver.org/`). Usually, versions more or less strictly follow either
    changes in the source code or the time when a particular version was created.
    Both schemes have their merits, but when writing scripts, we think that tracking
    changes is a much better idea, since we can deduce very little from versions using
    dates as a reference.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过几种方式来完成，因为目前没有官方标准来写下版本，尽管很多人倾向于使用语义化版本控制（`https://semver.org/`）。通常，版本号或多或少严格地遵循源代码的变化或特定版本创建时的时间。这两种方案都有其优点，但在撰写脚本时，我们认为跟踪更改是一个更好的主意，因为我们几乎无法从日期版本中推断出什么。
- en: Before we commit to any versioning scheme, we will quickly go over some examples.
    The way we handle versions in different software is directly related to the type
    of software we are dealing with and the number of changes between versions.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们承诺任何版本方案之前，我们将快速浏览一些示例。我们处理不同软件版本的方式直接与我们所处理的软件类型及版本之间的更改数量有关。
- en: General-purpose applications usually stick to a *normal* versioning scheme that
    has a structure using two numbers representing major and minor versions of the
    application. For example, we can have App v1.0, then App v1.1, then App v2.0,
    and so on. The first number represents major changes made to the applications;
    the second number usually represents minor changes or bug fixes. This is practically
    the norm for large applications on the market today.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通用应用程序通常坚持使用一个*正常*的版本方案，其结构使用两个数字表示应用程序的主要和次要版本。例如，我们可以有 App v1.0，然后是 App v1.1，然后是
    App v2.0，依此类推。第一个数字表示对应用程序进行的主要更改；第二个数字通常表示次要更改或错误修复。这实际上是今天市场上大型应用程序的通行做法。
- en: In our scripts, we are going to use the same scheme, but we are going to implement
    semantic versioning, so a version will be `1.0.0` or `3.2.4`. The third number
    represents small changes and makes sense when the number of changes is small,
    but changes are significant. Note that some applications take this approach to
    the extreme, so you will inevitably run into things such as Version `2.1.2.1-33.PL2`.
    When dealing with scripts, this will just complicate your work, so don't do it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本中，我们将使用相同的方案，但我们将实施语义化版本控制，因此版本将是`1.0.0`或`3.2.4`。第三个数字表示小的变更，并在变更数较少但变更显著时才有意义。请注意，有些应用程序将此方法推向极端，因此您将不可避免地遇到诸如版本`2.1.2.1-33.PL2`之类的情况。在处理脚本时，这只会使您的工作变得更加复杂，所以请不要这样做。
- en: Another way of dealing with versions is by referencing time, as most operating
    systems do now. So, for example, there is Ubuntu 20.04 and 20.10, representing
    releases that came out in April and October of 2020 respectively. The reason for
    this is the enormous number of changes. Releasing a new version of an entire operating
    system each time something changes is simply impossible; you would need to release
    a new version practically every few hours.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 处理版本的另一种方式是参考时间，就像现在大多数操作系统所做的那样。例如，有 Ubuntu 20.04 和 20.10，分别代表2020年4月和10月发布的版本。这样做的原因是变更的数量巨大。每次发生变更时发布整个操作系统的新版本几乎是不可能的；你需要几乎每隔几小时发布一个新版本。
- en: There is also a sequential numbering scheme that is usually paired with one
    of the two approaches we mentioned. Microsoft uses this versioning style, having
    major releases with names such as *Windows 10*, update releases named something
    such as 20.04 or 21H1 that represent the time of the release, and then using build
    versions to denote minor changes in the operating systems.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种顺序编号方案，通常与我们提到的两种方法之一配合使用。微软使用这种版本控制风格，主要版本发布如*Windows 10*，更新版本发布如20.04或21H1，代表发布的时间，然后使用构建版本来表示操作系统的小改动。
- en: All of these schemes have their good and bad sides, but whatever you choose,
    we have only one recommendation – stick to it. Don't mix different versioning
    schemes, since it will confuse people.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些版本控制方案都有其优缺点，但无论你选择哪种，我们只有一个建议——坚持使用它。不要混合不同的版本控制方案，因为这会让人感到困惑。
- en: While talking about versioning, we should also talk about change tracking. When
    creating *a new version* of a script, most of the time, you will make many changes
    to the script itself. It can be that you will fix bugs, or make your code quicker
    or more reliable. Some of these changes will have to be documented in some way
    other than by increasing the version number. This is important in order to remember
    what you did to the script. There are a couple of ways to do that. One is to keep
    track of all the changes in a separate file (usually, we use a `ChangeLog` file
    for that purpose). This makes your comments and the script itself much more legible,
    but now you have another file whose updates you need to care about. It also makes
    it easier for everyone else to read the code, as it gets developed and changed
    with each new version. Another way is to keep a list of all the changes in the
    script itself. A benefit of that is that you can quickly check what has changed,
    but your script now has extra text that you need to skip through. There is also
    a version that keeps the changes in line with the place where they were created,
    usually before the line of code that contains the changes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 说到版本控制，我们还应该谈谈变更追踪。当创建*新版本*的脚本时，大多数情况下你会对脚本本身进行很多更改。这些更改可能是修复 bug，或者使代码更快、更可靠。某些更改需要以其他方式记录，而不是单纯增加版本号。这样做很重要，因为它能帮助你记住对脚本做了什么。可以通过几种方式来实现。一种方法是将所有更改记录在一个单独的文件中（通常我们会使用`ChangeLog`文件来记录）。这样，你的注释和脚本本身会更加清晰易读，但你也需要关注这个新文件的更新。这样做还可以让其他人更容易阅读代码，因为每次新版本的发布都会更新它。另一种方法是直接在脚本中列出所有的更改。这种方法的好处是你可以快速查看哪些地方发生了变化，但这样脚本就会多出一些额外的文本，需要你跳过。还有一种版本是在修改所在的代码行之前记录更改，这样更改和代码本身紧密关联。
- en: 'Let''s see how all this looks in practice:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些在实践中是如何运作的：
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We are going to stop here, since we will cover this and a lot more in further
    chapters, learning as we go along.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里暂停，因为接下来章节会详细介绍这些内容，并且在学习过程中逐步深入。
- en: There's more…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'Commenting in Bash – examples: https://git.savannah.gnu.org/cgit/bash.git/tree/examples'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Bash 中注释 – 示例： https://git.savannah.gnu.org/cgit/bash.git/tree/examples
- en: 'Identifying files in Linux: [https://man7.org/linux/man-pages/man4/magic.4.html](https://man7.org/linux/man-pages/man4/magic.4.html)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 中识别文件： [https://man7.org/linux/man-pages/man4/magic.4.html](https://man7.org/linux/man-pages/man4/magic.4.html)
