<html><head></head><body>
		<div id="_idContainer080">
			<h1 id="_idParaDest-254"><em class="italic"><a id="_idTextAnchor266"/>Chapter 18</em>: Understanding systemd-logind</h1>
			<p>Yes, it's true – there's even a new way of managing user logins and user sessions in systemd. In this chapter, we'll delve into the mysteries of <strong class="source-inline">systemd-logind</strong>, and show you some fairly nifty user management tricks. Knowing these tricks can definitely help you out in a business environment. Specific topics in this chapter include:</p>
			<ul>
				<li>Understanding the need for a new login service</li>
				<li>Understanding <strong class="source-inline">systemd-logind.service</strong></li>
				<li>Understanding <strong class="source-inline">logind.conf</strong></li>
				<li>Understanding <strong class="source-inline">loginctl</strong></li>
				<li>Understanding <strong class="source-inline">polkit</strong></li>
			</ul>
			<p>All right, let's get started.</p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor267"/>Technical requirements</h1>
			<p>We won't need anything fancy for this chapter. Just use your normal <strong class="bold">Alma</strong> and <strong class="bold">Ubuntu Server</strong> virtual machines, and it will all be good. Well, let me rephrase that. You'll want to use Ubuntu Server for the <strong class="source-inline">logind.conf</strong> demos, because restarting the <strong class="source-inline">systemd-logind</strong> service is problematic on graphical mode machines (I'll explain more about that in a bit). At the end of the chapter, there will be a couple of demos for which it will be handy to have a desktop interface, so you'll want an Alma machine with the <strong class="bold">Gnome 3 </strong>desktop for them.</p>
			<p>All right, let's begin by looking at the <strong class="source-inline">systemd-logind.service</strong> file.</p>
			<p>Check out the following link to see the Code in Action video: <a href="https://bit.ly/3EiIHSD">https://bit.ly/3EiIHSD</a></p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor268"/>Understanding the need for a new login service</h1>
			<p>I know, you're <a id="_idIndexMarker721"/>wondering, <em class="italic">Why do we even need a new login service?</em> One reason is because of the tight integration between <strong class="source-inline">systemd</strong> and <strong class="source-inline">cgroups</strong>. The <strong class="source-inline">systemd-logind</strong> service does several things for us, but its main job is to create cgroup slices and scopes for everyone who logs into a system. As we go through this chapter, we'll look at a few other things that <strong class="source-inline">systemd-logind</strong> also does for us. (To read a short description about all of the things that <strong class="source-inline">systemd-logind</strong> does, see the <strong class="source-inline">systemd-logind</strong> man page.)</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor269"/>Understanding systemd-logind.service</h1>
			<p>There's a<a id="_idIndexMarker722"/> considerable difference in how this unit file is set up on RHEL-type systems and Ubuntu. Let's first look at the RHEL-type setup on the Alma machine.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor270"/>The Alma Linux systemd-logind.service file</h2>
			<p>On <a id="_idIndexMarker723"/>the Alma machine, the <strong class="source-inline">[Unit]</strong> section <a id="_idIndexMarker724"/>of the <strong class="source-inline">/lib/systemd/system/systemd-logind.service</strong> file looks like this:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=Login Service</p>
			<p class="source-code">Documentation=man:systemd-logind.service(8) man:logind.conf(5)</p>
			<p class="source-code">Documentation=https://www.freedesktop.org/wiki/Software/systemd/logind</p>
			<p class="source-code">Documentation=https://www.freedesktop.org/wiki/Software/systemd/multiseat</p>
			<p class="source-code">Wants=user.slice</p>
			<p class="source-code">After=nss-user-lookup.target user.slice</p>
			<p class="source-code"># Ask for the dbus socket.</p>
			<p class="source-code">Wants=dbus.socket</p>
			<p class="source-code">After=dbus.socket</p>
			<p>Here's the breakdown:</p>
			<ul>
				<li><strong class="source-inline">Wants=user.slice</strong>: This makes total sense. Due to systemd's tight integration with cgroups, a user slice must be created for every user who logs in.</li>
				<li><strong class="source-inline">After=nss-user-lookup.target</strong>: The <strong class="bold">Name Service Switch</strong> (<strong class="bold">NSS</strong>) determines<a id="_idIndexMarker725"/> where the system is to look for various types of information, including user authentication information. This is configured in the <strong class="source-inline">/etc/nsswitch.conf</strong> file, which we'll discuss next.</li>
				<li><strong class="source-inline">Wants=dbus.socket</strong> and <strong class="source-inline">After=dbus.socket</strong>: There's no <strong class="source-inline">[Install]</strong> section of this service file, so this service won't automatically start when we reach either the multi-user or graphical target. Instead, a <strong class="source-inline">dbus</strong> message <a id="_idIndexMarker726"/>will get generated<a id="_idIndexMarker727"/> when the first user logs in for the first time, which will automatically start the service.</li>
			</ul>
			<p>Okay, let's look at the relevant lines of the <strong class="source-inline">/etc/nsswitch.conf</strong> file. Open it and look for these four lines:</p>
			<p class="source-code">passwd:      sss files systemd</p>
			<p class="source-code">shadow:     files sss</p>
			<p class="source-code">group:       sss files systemd</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p class="source-code">gshadow:    files</p>
			<p>In the <strong class="source-inline">passwd:</strong>, <strong class="source-inline">shadow:</strong>, and <strong class="source-inline">group:</strong> lines of the file, the <strong class="source-inline">sss</strong> means that user and group<a id="_idIndexMarker728"/> information <a id="_idIndexMarker729"/>will <a id="_idIndexMarker730"/>be pulled from the <strong class="bold">System Security Services Daemon</strong> (<strong class="bold">SSSD</strong>). The <strong class="source-inline">sssd</strong> allows <a id="_idIndexMarker731"/>you to use <strong class="bold">LDAP</strong>, <strong class="bold">FreeIPA</strong>, or even <strong class="bold">Microsoft</strong> <strong class="bold">Active Directory</strong> as a means <a id="_idIndexMarker732"/>of user authentication. If you're not using any of these three authentication methods, then authentication information will be pulled from files, which are the <strong class="source-inline">/etc/passwd</strong>, <strong class="source-inline">/etc/group</strong>, <strong class="source-inline">/etc/shadow</strong>, and <strong class="source-inline">/etc/gshadow</strong> files. If the system can't find information about the user who's logging in in either <strong class="source-inline">sss</strong> or <strong class="source-inline">files</strong>, then it will go to <strong class="source-inline">systemd</strong>. The <strong class="source-inline">systemd</strong> setting allows the system to authenticate a dynamic user that might be configured in a service unit file, and that wouldn't have an entry in either the <strong class="source-inline">/etc/passwd</strong> or <strong class="source-inline">/etc/shadow</strong> files.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><em class="italic">Dynamic users</em>, to which I alluded in the preceding paragraph, aren't for normal human users who would log into a computer. They're <em class="italic">system accounts</em> that are used for running services with reduced privileges. A dynamic user gets created on-the-fly whenever a service that uses one starts, and gets destroyed whenever the service stops. You'll never see an entry for a dynamic user in the <strong class="source-inline">/etc/passwd</strong>, <strong class="source-inline">/etc/group</strong>, <strong class="source-inline">/etc/gshadow</strong>, or <strong class="source-inline">/etc/shadow</strong> files.</p>
			<p>Now, let's<a id="_idIndexMarker733"/> get<a id="_idIndexMarker734"/> back to the <strong class="source-inline">systemd-logind.service</strong> file, and look at the <strong class="source-inline">[Service]</strong> section. I can't show it all to you at once, so here's the top part:</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">ExecStart=/usr/lib/systemd/systemd-logind</p>
			<p class="source-code">Restart=always</p>
			<p class="source-code">RestartSec=0</p>
			<p class="source-code">BusName=org.freedesktop.login1</p>
			<p class="source-code">WatchdogSec=3min</p>
			<p class="source-code">CapabilityBoundingSet=CAP_SYS_ADMIN CAP_MAC_ADMIN CAP_AUDIT_CONTROL CAP_CHOWN CAP_KILL CAP_DAC_READ_SEARCH CAP_DAC_OVERRIDE CAP_FOWNER CAP_SYS_TTY_CONFIG</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p>It's mainly the standard stuff that we've gone over before, so you should have a good handle on it already. The main thing I want you to notice is the <strong class="source-inline">CapabilityBoundingSet=</strong> line, which grants a lot of root-level capabilities to this service. The second part of the <strong class="source-inline">[Service]</strong> section consists of a lot of security and resource control directives:</p>
			<p class="source-code">. . .</p>
			<p class="source-code">MemoryDenyWriteExecute=yes</p>
			<p class="source-code">RestrictRealtime=yes</p>
			<p class="source-code">RestrictNamespaces=yes</p>
			<p class="source-code">RestrictAddressFamilies=AF_UNIX AF_NETLINK</p>
			<p class="source-code">RestrictSUIDSGID=yes</p>
			<p class="source-code">SystemCallFilter=@system-service</p>
			<p class="source-code">SystemCallErrorNumber=EPERM</p>
			<p class="source-code">SystemCallArchitectures=native</p>
			<p class="source-code">LockPersonality=yes</p>
			<p class="source-code">FileDescriptorStoreMax=512</p>
			<p class="source-code"># Increase the default a bit in order to allow many simultaneous logins since we keep one fd open per session.</p>
			<p class="source-code">LimitNOFILE=16384</p>
			<p>As always, I'll<a id="_idIndexMarker735"/> leave it to you to look these<a id="_idIndexMarker736"/> directives up in the <strong class="source-inline">systemd.directives</strong> man page.</p>
			<p>All right, that's it for the <strong class="source-inline">systemd-logind.service</strong> file on the Alma machine. Let's look at the one on the Ubuntu machine.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor271"/>The Ubuntu Server systemd-logind.service file</h2>
			<p>The <strong class="source-inline">systemd-logind.service</strong> file <a id="_idIndexMarker737"/>on<a id="_idIndexMarker738"/> the Ubuntu machine is considerably different from the one on the Alma machine. Let's look at the <strong class="source-inline">[Unit]</strong> section first:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=Login Service</p>
			<p class="source-code">Documentation=man:systemd-logind.service(8) man:logind.conf(5)</p>
			<p class="source-code">Documentation=https://www.freedesktop.org/wiki/Software/systemd/logind</p>
			<p class="source-code">Documentation=https://www.freedesktop.org/wiki/Software/systemd/multiseat</p>
			<p class="source-code">Wants=user.slice modprobe@drm.service</p>
			<p class="source-code">After=nss-user-lookup.target user.slice modprobe@drm.service</p>
			<p class="source-code">ConditionPathExists=/lib/systemd/system/dbus.service</p>
			<p class="source-code"># Ask for the dbus socket.</p>
			<p class="source-code">Wants=dbus.socket</p>
			<p class="source-code">After=dbus.socket</p>
			<p class="source-code">. . .</p>
			<p>The first <a id="_idIndexMarker739"/>difference<a id="_idIndexMarker740"/> we see is that the <strong class="source-inline">Wants=</strong> line calls in the <strong class="source-inline">modprobe@.service</strong> to load the <strong class="bold">Direct Rendering Manager</strong> (<strong class="bold">DRM</strong>) (<strong class="source-inline">drm</strong>) kernel <a id="_idIndexMarker741"/>module. I'm not sure why that is, because this seems like something that should get loaded when you boot the machine. In fact, this seems to be the case on the Alma machine, as we see here:</p>
			<p class="source-code">[donnie@localhost ~]$ lsmod | grep drm</p>
			<p class="source-code">drm_kms_helper        233472  1 vmwgfx</p>
			<p class="source-code">syscopyarea            16384  1 drm_kms_helper</p>
			<p class="source-code">sysfillrect            16384  1 drm_kms_helper</p>
			<p class="source-code">sysimgblt              16384  1 drm_kms_helper</p>
			<p class="source-code">fb_sys_fops            16384  1 drm_kms_helper</p>
			<p class="source-code">drm                   569344  4 vmwgfx,drm_kms_helper,ttm</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>For some reason that I don't know, the Ubuntu developers decided to load the <strong class="source-inline">drm</strong> module when the <strong class="source-inline">systemd-logind</strong> service starts, instead of at boot-up.</p>
			<p>The <strong class="source-inline">[Service]</strong> section on the Ubuntu machine is much larger, because it contains more security directives than what you saw on the Alma machine. Why? Well remember, the Alma machine is<a id="_idIndexMarker742"/> running <strong class="bold">SELinux</strong>, which gives comprehensive system protection right out of the box. Ubuntu Server is running <strong class="bold">AppArmor</strong>, which <a id="_idIndexMarker743"/>isn't nearly as good, at least not in its out-of-the-box configuration. So, the extra security directives in the <strong class="source-inline">systemd-logind.service</strong> file give us some good <em class="italic">Mandatory Access Control</em> protection that AppArmor doesn't give us. Here's a snippet of the <strong class="source-inline">[Service]</strong> section, which<a id="_idIndexMarker744"/> shows<a id="_idIndexMarker745"/> some of the extra directives for Ubuntu:</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">BusName=org.freedesktop.login1</p>
			<p class="source-code">CapabilityBoundingSet=CAP_SYS_ADMIN CAP_MAC_ADMIN CAP_AUDIT_CONTROL CAP_CHOWN CAP_DAC_READ_SEARCH CAP_DAC_OVERRIDE CAP_FOWNER CAP_SYS_TTY_CONFIG CAP_LINUX_IMMUTABLE</p>
			<p class="source-code">DeviceAllow=block-* r</p>
			<p class="source-code">DeviceAllow=char-/dev/console rw</p>
			<p class="source-code">DeviceAllow=char-drm rw</p>
			<p class="source-code">DeviceAllow=char-input rw</p>
			<p class="source-code">…</p>
			<p class="source-code">…</p>
			<p class="source-code"># Increase the default a bit in order to allow many simultaneous logins since</p>
			<p class="source-code"># we keep one fd open per session.</p>
			<p class="source-code">LimitNOFILE=524288</p>
			<p>As always, I'll let you read about these security directives in the man pages.</p>
			<p>Next, let's <a id="_idIndexMarker746"/>look<a id="_idIndexMarker747"/> at the configuration file for <strong class="source-inline">systemd-logind.service</strong>.</p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor272"/>Understanding logind.conf</h1>
			<p>The <strong class="source-inline">/etc/systemd/logind.conf</strong> file<a id="_idIndexMarker748"/> is the configuration file for the <strong class="source-inline">systemd-logind</strong> service. Now, before we get too far, I want to recommend that you use a text-mode virtual machine for this section. The demos will have you make several changes to the <strong class="source-inline">logind.conf</strong> file, and you'll need to restart the <strong class="source-inline">systemd-logind</strong> service after each one. If you do that on a graphical mode machine, you'll get logged out of the desktop, and will have to log back in. The desktop doesn't always come back up correctly, and you'll end up having to restart the machine. With a text-mode machine, that isn't a problem. So, since the Ubuntu Server machine is already in text mode, we'll use it for the demos.</p>
			<p>The good news is that the <strong class="source-inline">logind.conf</strong> file is identical on both the Ubuntu machine and the Alma machine. Here's what it<a id="_idTextAnchor273"/> looks like:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B17491_Figure_18.1.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 18.1 – The logind.conf file</p>
			<p>As is the case with<a id="_idIndexMarker749"/> all of the configuration files in <strong class="source-inline">/etc/systemd/</strong>, all directives are commented out. The values shown are the default ones that are compiled into the <strong class="source-inline">systemd-logind</strong> executable. You can probably figure out what many of these directives do just by looking at their names, and you can consult the <strong class="source-inline">logind.conf</strong> man page to read about the ones that aren't so obvious. So, rather than cover each directive in detail, I just want to go over a few of the more interesting ones. Let's start with the <em class="italic">virtual terminals</em> setting.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor274"/>Virtual terminals</h2>
			<p>At the top, we <a id="_idIndexMarker750"/>see the <strong class="source-inline">#NAutoVTs=6</strong> line. This sets the number of <a id="_idIndexMarker751"/>available <em class="italic">virtual terminals</em>. Virtual terminals don't do much for you on a desktop machine, because you can just open multiple terminal emulators from the <strong class="bold">Start</strong> menu. But, they're extremely handy on a text-mode machine. In fact, I use them all the time here on one of my text-mode, Linux-powered GPU mining rigs. While the mining software is running in the default virtual terminal, I can do a <em class="italic">Ctrl + Alt + Function</em> key sequence to bring up another terminal so that I can do something else there. So, to bring up virtual terminal 2, I would do <em class="italic">Ctrl + Alt + F2</em> and log into a new session. I can bring up a total of six virtual terminals by using function keys <em class="italic">F1</em> through <em class="italic">F6</em>. (Doing <em class="italic">Ctrl + Alt + F1</em> gets you back to the default terminal.) That's cool because while the mining software runs in the <strong class="bold">F1</strong> terminal, I can have a text-mode cryptocoin wallet running in the <strong class="bold">F2</strong> terminal, edit a file in the <strong class="bold">F3</strong> terminal, and <strong class="source-inline">ssh</strong> into my other GPU mining rig from the <strong class="bold">F4</strong> terminal.  On a graphical mode desktop machine, one virtual terminal is reserved for the desktop. (It's usually the <strong class="bold">F1</strong> terminal, but that could vary with different distros.) You can try this on your virtual machine, but there's a bit of a trick to it. If your host machine is running <strong class="bold">Windows</strong>, just do the <em class="italic">Ctrl-Alt-Function</em> key sequence from your normal keyboard, as you'd do on a bare-metal Linux machine. But, if your host machine is running Linux, you'll need to open the <strong class="bold">VirtualBox</strong> <strong class="bold">Input/Keyboard</strong> menu and bring up the <strong class="bold">Soft Keyboard</strong>: </p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B17491_Figure_18.2.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 18.2 – The VirtualBox Soft Keyboard</p>
			<p>Then, do <a id="_idIndexMarker752"/>your <em class="italic">Ctrl-Alt-Function</em> key <a id="_idIndexMarker753"/>sequence by clicking on the soft keyboard. If you try to do it the normal way with your normal keyboard, the key sequence will be intercepted by the host machine. </p>
			<p>You'll likely never edit this line, because six virtual terminals are enough for most people. But if you ever do need more, you can add them here. For example, let's say that you need to have eight virtual terminals instead of just six. Just change the <strong class="source-inline">#NAutoVTs=6</strong> line to <strong class="source-inline">#NAutoVTs=8</strong>. Then, restart the <strong class="source-inline">systemd-logind</strong> service:</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/systemd$ sudo systemctl restart systemd-logind</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/systemd$</p>
			<p>You can see the extra two virtual terminals by doing <em class="italic">Ctrl + Alt + F7</em> and <em class="italic">Ctrl + Alt + F8</em>.</p>
			<p>Next, let's <a id="_idIndexMarker754"/>see<a id="_idIndexMarker755"/> how users can keep processes going after they log out.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor275"/>Keeping user processes going after logout</h2>
			<p>These next <a id="_idIndexMarker756"/>three lines work together:</p>
			<p class="source-code">#KillUserProcesses=no</p>
			<p class="source-code">#KillOnlyUsers=</p>
			<p class="source-code">#KillExcludeUsers=root</p>
			<p>If you're an old-timer like me, you'll likely remember how this worked in the old SysV days. You'd log into a Linux server, start a process from the command line, and then log out while the process was still going. The problem was that the process would stop as soon as you logged out. If you logged in remotely and started a process, it would stop if you accidentally closed the remote terminal of your local machine or if the local machine were to reboot. In order to keep the process on the remote machine going if any of those things happened, you'd need to start the process with either <strong class="source-inline">screen</strong> or <strong class="source-inline">nohup</strong>. Now though, you don't have to worry about that as long as these three lines stay as you see them here. To demonstrate, create an account on the text-mode Ubuntu machine for Frank, if you haven't done so already:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ sudo adduser frank</p>
			<p>Then, have him remotely log in. Have him create the <strong class="source-inline">loop.sh</strong> shell script in his own home directory, like this:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">i=0</p>
			<p class="source-code">for i in {0..100000}</p>
			<p class="source-code">do</p>
			<p class="source-code">        echo $i &gt;&gt; number.txt</p>
			<p class="source-code">        sleep 5</p>
			<p class="source-code">done</p>
			<p class="source-code">exit</p>
			<p>It's a silly little loop that does nothing but create an entry in a text file every five seconds. That's okay though, because it serves our purpose. (Also, note that I didn't upload this script to <strong class="bold">GitHub</strong>, because it would take longer for you to download it than it would to just type<a id="_idIndexMarker757"/> it yourself.) Next, have Frank set the executable permission on the <strong class="source-inline">loop.sh</strong> file:</p>
			<p class="source-code">frank@ubuntu20-04:~$ chmod u+x loop.sh</p>
			<p class="source-code">frank@ubuntu20-04:~$ ls -l</p>
			<p class="source-code">total 4</p>
			<p class="source-code">-rwxr--r-- 1 frank 83 Sep  9 16:29 loop.sh</p>
			<p class="source-code">frank@ubuntu20-04:~$</p>
			<p>Now, have Frank start the script as a background process:</p>
			<p class="source-code">frank@ubuntu20-04:~$ ./loop.sh &amp;</p>
			<p class="source-code">[1] 2446</p>
			<p class="source-code">frank@ubuntu20-04:~$</p>
			<p>Verify that the script is running by doing <strong class="source-inline">tail -f number.txt</strong>:</p>
			<p class="source-code">frank@ubuntu20-04:~$ tail -f number.txt</p>
			<p class="source-code">10</p>
			<p class="source-code">11</p>
			<p class="source-code">12</p>
			<p class="source-code">13</p>
			<p class="source-code">14</p>
			<p class="source-code">15</p>
			<p class="source-code">16</p>
			<p class="source-code">17</p>
			<p class="source-code">18</p>
			<p>Do a <em class="italic">Ctrl + C</em> to stop the <strong class="source-inline">tail -f</strong> process. Then, have Frank log out by typing <strong class="source-inline">exit</strong>.</p>
			<p>Next, have Frank log in again, and again have him do <strong class="source-inline">tail -f number.txt</strong>. You should see that the number list keeps incrementing, which means that the process kept going after Frank logged out. To stop the process, use <strong class="source-inline">ps aux</strong> to get the <strong class="source-inline">PID</strong> number, and then use that PID number in a <strong class="source-inline">kill</strong> command:</p>
			<p class="source-code">frank@ubuntu20-04:~$ ps aux | grep loop.sh</p>
			<p class="source-code">frank       2446  0.1  1.5  32012 31120 ?        S    16:35   0:00 /bin/bash ./loop.sh</p>
			<p class="source-code">frank       2598  0.0  0.0   3304   736 pts/2    S+   16:46   0:00 grep --color=auto loop.sh</p>
			<p class="source-code">frank@ubuntu20-04:~$ kill 2446</p>
			<p class="source-code">frank@ubuntu20-04:~$</p>
			<p>Then, have <a id="_idIndexMarker758"/>Frank log out by typing <strong class="source-inline">exit</strong>.</p>
			<p>Now, let's say that we don't want Frank to keep his processes going after he logs out. In your own terminal, open the <strong class="source-inline">/etc/systemd/logind.conf</strong> file in your text editor. Change the <strong class="source-inline">#KillOnlyUsers=</strong> line so that it looks like this:</p>
			<p class="source-code">KillOnlyUsers=frank</p>
			<p>Save the file and restart the <strong class="source-inline">systemd-logind</strong> service:</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/systemd$ sudo systemctl restart systemd-logind</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/systemd$</p>
			<p>Note that there's no <strong class="source-inline">reload</strong> option for this service.</p>
			<p>Go back to Frank's terminal, and have him log back in. Have him start the <strong class="source-inline">loop.sh</strong> script in the background, as you did before. When you do a <strong class="source-inline">tail -f number.txt</strong> command this time, you should see that the number list no longer increments.</p>
			<p>Okay, we're through with Frank for now, so go ahead and have him log out.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A few days ago, the day that I started writing this chapter, Frank the cat decided to help out. He pressed some keys on my keyboard and deleted a whole paragraph, replacing it with a string of dashes. (Thank goodness for the <strong class="bold">Undo</strong> feature.)</p>
			<p>Next, let's<a id="_idIndexMarker759"/> look at a few <em class="italic">power management directives</em>.</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor276"/>Power management directives</h2>
			<p>Further <a id="_idIndexMarker760"/>down<a id="_idIndexMarker761"/> in the <strong class="source-inline">/etc/systemd/logind.conf</strong> file, you'll see the <strong class="source-inline">HandlePowerKey=</strong>, <strong class="source-inline">HandleSuspendKey=</strong>, <strong class="source-inline">HandleHibernateKey=</strong>, <strong class="source-inline">HandleLidSwitch=</strong>, <strong class="source-inline">HandleLidSwitchExternalPower=</strong>, and the <strong class="source-inline">HandleLidSwitchDocked=</strong> power management directives. You can probably figure out what these directives do just by looking at their names, and you can see the default settings in the <strong class="source-inline">logind.conf</strong> file. To see the other settings that you can use for these directives, just consult the <strong class="source-inline">logind.conf</strong> man page. It's a good write-up, so I won't repeat any of that here. But, I will offer one example.</p>
			<p>Let's say you have a laptop, and you need it to keep running when you shut the lid. Just look for this line:</p>
			<p class="source-code">#HandleLidSwitch=suspend</p>
			<p>Change it to look like this:</p>
			<p class="source-code">HandleLidSwitch=ignore</p>
			<p>I'm going to assume that you're running your laptop in graphical mode. (Doesn't everyone?) Since restarting <strong class="source-inline">systemd-logind.service</strong> doesn't work well on graphical mode machines, your best bet would be to just reboot the machine so that the new setting can take effect. Now, instead of suspending the laptop when you close the lid, it will continue running as merrily as it did with the lid open. (You can try this on your virtual machine if you really want to. But, since your virtual machine doesn't have a lid, you won't see anything happen.).</p>
			<p>For our last example, let's do some <em class="italic">Idle Action</em>.</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor277"/>The IdleAction directives</h2>
			<p><strong class="source-inline">IdleAction</strong>, eh? Boy, if <a id="_idIndexMarker762"/>that isn't an oxymoron, I don't <a id="_idIndexMarker763"/>know what is. But seriously, you can configure these next two directives to control what happens when you leave the computer sitting idle for a specified period of time:</p>
			<p class="source-code">#IdleAction=ignore</p>
			<p class="source-code">#IdleActionSec=30min</p>
			<p>By default, the machine will just keep running until you shut it down. Just for fun, change these two lines so that they look like this:</p>
			<p class="source-code">IdleAction=poweroff</p>
			<p class="source-code">IdleActionSec=3min</p>
			<p>Restart <strong class="source-inline">systemd-logind.service</strong>, and then just wait, without touching the virtual machine. After three minutes, you should see the machine automatically shut down. Of course, you don't want to leave the virtual machine with this configuration, so boot it up again and change these settings back to their default values. Then, restart <strong class="source-inline">systemd-logind.service</strong>.</p>
			<p>There are still a few <a id="_idIndexMarker764"/>directives that I didn't cover, but you can read about them in the <strong class="source-inline">logind.conf</strong> man<a id="_idIndexMarker765"/> page. Let's move on to the <strong class="source-inline">loginctl</strong> management utility.</p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor278"/>Understanding loginctl</h1>
			<p>Another bit of<a id="_idIndexMarker766"/> good news is that <strong class="source-inline">loginctl</strong> works identically on both Ubuntu and Alma. You can use it to keep an eye on what other users are doing, change certain settings for a user's login environment, or even as a security tool to get rid of malicious users. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">For this section, we'll continue with the Ubuntu Server machine. Create user accounts for Pogo, Vicky, and Frank, if you haven't already done so. Log yourself in from the local terminal, and again from a remote terminal. Do <em class="italic">Ctrl-Alt-F2</em> on the virtual machine to get to the second virtual terminal, and have Vicky log in there. Then, have Pogo and Frank log in from their own remote terminals.</p>
			<p>Before we get into the real meat of the matter, we need to define a couple of terms:</p>
			<ul>
				<li><strong class="bold">session</strong>: A <em class="italic">session</em> gets created whenever a user logs into the system. Each session is assigned a decimal number as its ID.</li>
				<li><strong class="bold">seat</strong>: A <em class="italic">seat</em> consists of all of the hardware that is assigned to a specific workstation. Each seat has an assigned text-string name that consists of from 1 to 255 characters. A user who logs into a computer at the local console will always be assigned a seat. Users who log in remotely will <em class="italic">not</em> be assigned a seat. In a default setup, <strong class="source-inline">seat0</strong> is the only seat that you will ever see. Creating new seats involves configuring <strong class="source-inline">udev</strong> rules, which is beyond the scope of this book.</li>
			</ul>
			<p>Doing either <strong class="source-inline">loginctl</strong> without any options or <strong class="source-inline">loginctl list-sessions</strong> shows you who is<a id="_idIndexMarker767"/> logged in and where they've logged in from:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ loginctl</p>
			<p class="source-code">SESSION  UID USER   SEAT  TTY  </p>
			<p class="source-code">     10         1001 frank                 pts/1</p>
			<p class="source-code">     14         1003 vicky    seat0    tty2 </p>
			<p class="source-code">     16         1004 pogo                 pts/2</p>
			<p class="source-code">      3          1000 donnie  seat0    tty1 </p>
			<p class="source-code">      6          1000 donnie              pts/0</p>
			<p class="source-code">5 sessions listed.</p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>You see that Vicky and I are the only ones with assigned seats, while Frank and Pogo have to remain standing. (Yeah I know, bad joke.) But seriously, Vicky and I were assigned to <strong class="source-inline">seat0</strong> because we're both logged in at the local terminal. I logged in from <strong class="source-inline">tty1</strong>, which is the default virtual terminal. Then, I did <em class="italic">Ctrl-Alt-F2</em> to get to the second virtual terminal (<strong class="source-inline">tty2</strong>), and had Vicky log in there. It's probably not real likely that you'll have two people log into two different virtual terminals of the same local machine, but it could happen. I did it now to show you that more than one user can be assigned to the same seat. You also see that I have two sessions going for myself, because I'm logged in from both the local terminal and from a remote <strong class="source-inline">ssh</strong> session on the <strong class="source-inline">pts/0</strong> terminal. Frank and Pogo are only logged in remotely, which is why they don't have seats. Also, note that every session has its own assigned ID number in the first column.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">I've just shown you how the <strong class="source-inline">list-sessions</strong> option works on Ubuntu. On a RHEL 8-type distro such as Alma, the <strong class="source-inline">SEAT</strong> and <strong class="source-inline">TTY</strong> columns will both be empty for any users who have logged in remotely. (I have no idea why.) However, you will see the <strong class="source-inline">pts</strong> information for a user when you use either a <strong class="source-inline">user-status</strong> or a <strong class="source-inline">session-status</strong> option, which I'll explain next.</p>
			<p>Use the <strong class="source-inline">user-status</strong> option <a id="_idIndexMarker768"/>to see detailed information about a user. If you don't specify a username, you'll see information about your own user account. Right now, let's see what kind of mischief our intrepid opossum, Pogo, is up to:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ loginctl user-status pogo</p>
			<p class="source-code">pogo (1004)</p>
			<p class="source-code">           Since: Sat 2021-09-11 16:50:45 EDT; 24min ago</p>
			<p class="source-code">           State: active</p>
			<p class="source-code">        Sessions: *16</p>
			<p class="source-code">          Linger: no</p>
			<p class="source-code">            Unit: user-1004.slice</p>
			<p class="source-code">                  ├─session-16.scope</p>
			<p class="source-code">                  │ ├─2211 sshd: pogo [priv]</p>
			<p class="source-code">                  │ ├─2302 sshd: pogo@pts/2</p>
			<p class="source-code">                  │ └─2303 -bash</p>
			<p class="source-code">                  └─user@1004.service</p>
			<p class="source-code">. . .</p>
			<p class="source-code">Sep 11 16:50:45 ubuntu20-04 systemd[2226]: Startup finished in 125ms.</p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>To see slightly less information, we'll look at Pogo's <strong class="source-inline">session-status</strong>. We see that he's in session<a id="_idIndexMarker769"/> number <strong class="source-inline">16</strong>, so the command and output will look like this:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ loginctl session-status 16</p>
			<p class="source-code">16 - pogo (1004)</p>
			<p class="source-code">           Since: Sat 2021-09-11 16:50:45 EDT; 39min ago</p>
			<p class="source-code">          Leader: 2211 (sshd)</p>
			<p class="source-code">             TTY: pts/2</p>
			<p class="source-code">          Remote: 192.168.0.51</p>
			<p class="source-code">         Service: sshd; type tty; class user</p>
			<p class="source-code">           State: active</p>
			<p class="source-code">            Unit: session-16.scope</p>
			<p class="source-code">                  ├─2211 sshd: pogo [priv]</p>
			<p class="source-code">                  ├─2302 sshd: pogo@pts/2</p>
			<p class="source-code">                  └─2303 -bash</p>
			<p class="source-code">Sep 11 16:50:45 ubuntu20-04 systemd[1]: Started Session 16 of user pogo.</p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>We've seen examples of how to get information about users and sessions. Let's look at how to get information about seats. A <strong class="source-inline">list-seat</strong> command shows you all of the available seats:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ loginctl list-seats</p>
			<p class="source-code">SEAT </p>
			<p class="source-code">seat0</p>
			<p class="source-code">1 seats listed.</p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>Unless you've configured one or more <strong class="source-inline">udev</strong> rules, <strong class="source-inline">seat0</strong> is the only one you'll ever see. Now, use<a id="_idIndexMarker770"/> the <strong class="source-inline">seat-status</strong> option to see the hardware that this seat includes:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ loginctl seat-status seat0</p>
			<p class="source-code">seat0</p>
			<p class="source-code">        Sessions: *14 3</p>
			<p class="source-code">         Devices:</p>
			<p class="source-code">                  ├─/sys/devices/LNXSYSTM:00/LNXPWRBN:00/input/input0</p>
			<p class="source-code">                  │ input:input0 "Power Button"</p>
			<p class="source-code">                  ├─/sys/devices/LNXSYSTM:00/LNXSLPBN:00/input/input1</p>
			<p class="source-code">                  │ input:input1 "Sleep Button"</p>
			<p class="source-code">                  ├─/sys/devices/LNXSYSTM:00/LNXSYBUS:00/PNP0A03:00/LNXVIDEO:00/input/input4</p>
			<p class="source-code">                  │ input:input4 "Video Bus"</p>
			<p class="source-code">                  ├─/sys/devices/pci0000:00/0000:00:01.1/ata2/host1/target1:0:0/1:0:0:0/block/sr0</p>
			<p class="source-code">                  │ block:sr0</p>
			<p class="source-code">. . .</p>
			<p>There are several more options for getting information about users, sessions, and seats, but you get the idea. Besides, you can get more information from the <strong class="source-inline">loginctl</strong> man page.</p>
			<p>Next, let's say that for whatever reason, you want to kick Frank out of his session. Just use the <strong class="source-inline">terminate-session</strong> option, followed by Frank's session ID number, like this:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ sudo loginctl terminate-session 10</p>
			<p class="source-code">[sudo] password for donnie: </p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>Here, you see <a id="_idIndexMarker771"/>that Frank's session really has been terminated:</p>
			<p class="source-code">frank@ubuntu20-04:~$ Connection to 192.168.0.49 closed by remote host.</p>
			<p class="source-code">Connection to 192.168.0.49 closed.</p>
			<p class="source-code">donnie@siftworkstation: ~</p>
			<p class="source-code">$ </p>
			<p>If a user is logged into multiple sessions and you want to shut down all of their sessions, use the <strong class="source-inline">terminate-user</strong> option, like this:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ sudo loginctl terminate-user pogo</p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>There are a few other management commands that you might find useful. They're easy to understand, and<a id="_idIndexMarker772"/> there's a good write-up about them in the <strong class="source-inline">loginctl</strong> man page.</p>
			<p>Next, let's cover a cool tool that can replace <strong class="source-inline">sudo</strong> in <em class="italic">some</em> instances.</p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor279"/>Understanding polkit</h1>
			<p><strong class="bold">PolicyKit</strong> and <strong class="bold">polkit</strong> aren't <a id="_idIndexMarker773"/>part of the systemd ecosystem, but <strong class="source-inline">systemd-logind</strong> does provide access to <strong class="source-inline">polkit</strong> functionality. PolicyKit was a <strong class="bold">Red Hat</strong> innovation that came on the scene quite a few years ago, and it could be used on various Unix-like operating systems. In 2012, a new version was released with the brand new name, <em class="italic">polkit</em>. The developers changed the name as a reminder that this is a whole new code base that isn't compatible with the older version.</p>
			<p>The <strong class="source-inline">polkit</strong> service is similar to <strong class="source-inline">sudo</strong> in that it allows a normally non-privileged user to perform certain privileged tasks. There is, however, a big difference between the two.</p>
			<p>The <strong class="source-inline">sudo</strong> utility is quite easy to configure, and you can easily grant pretty much any admin privilege or privileges to any user. When you install the operating system, you'll have full <strong class="source-inline">sudo</strong> privileges for yourself, and nobody else will have any. On the other hand, <strong class="source-inline">polkit</strong> comes pre-configured with a set of administrative tasks for which it can grant root privileges. You can add more tasks, and there might be times when you'll want to. Keep in mind though, that writing rules and actions for <strong class="source-inline">polkit</strong> is more complex than writing rules for <strong class="source-inline">sudo</strong>. So, you'll want to study the examples that are already on the system and read the documentation before you try to write your own. Before we look at these rules and actions, let's see how <strong class="source-inline">polkit</strong> grants root privileges. </p>
			<p>We'll start with the <a id="_idIndexMarker774"/>Alma Linux machine. We need root privileges to peek into some of the <strong class="source-inline">polkit</strong> directories, so let's just go to the <strong class="source-inline">root</strong> shell:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo su -</p>
			<p class="source-code">[sudo] password for donnie: </p>
			<p class="source-code">[root@localhost ~]#</p>
			<p>Now, look in the <strong class="source-inline">/etc/polkit-1/rules.d/</strong> directory:</p>
			<p class="source-code">[root@localhost ~]# cd /etc/polkit-1/rules.d/</p>
			<p class="source-code">[root@localhost rules.d]# ls</p>
			<p class="source-code">49-polkit-pkla-compat.rules  50-default.rules</p>
			<p class="source-code">[root@localhost rules.d]#</p>
			<p>The file we want is the <strong class="source-inline">50-default.rules</strong> file, which looks like this:</p>
			<p class="source-code">[root@localhost rules.d]# cat 50-default.rules </p>
			<p class="source-code">/* -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*- */</p>
			<p class="source-code">// DO NOT EDIT THIS FILE, it will be overwritten on update</p>
			<p class="source-code">//</p>
			<p class="source-code">// Default rules for polkit</p>
			<p class="source-code">//</p>
			<p class="source-code">// See the polkit(8) man page for more information</p>
			<p class="source-code">// about configuring polkit.</p>
			<p class="source-code">polkit.addAdminRule(function(action, subject) {</p>
			<p class="source-code">    return ["unix-group:wheel"];</p>
			<p class="source-code">});</p>
			<p class="source-code">[root@localhost rules.d]#</p>
			<p>Take note of the final stanza:</p>
			<p class="source-code">polkit.addAdminRule(function(action, subject) {</p>
			<p class="source-code">return ["unix-group:wheel"];</p>
			<p>This means<a id="_idIndexMarker775"/> that if <strong class="source-inline">polkit</strong> detects someone trying to perform an administrative task without using <strong class="source-inline">sudo</strong>, it will look in the wheel group to see if anyone is there. If there is someone in the wheel group, then it will prompt the user to enter the password of that person. If the wheel group has no members, that means that the root user has an assigned password. If that's the case, <strong class="source-inline">polkit</strong> will prompt for the root user password.</p>
			<p>On the Ubuntu machine, the files we need to see are in the <strong class="source-inline">/etc/polkit-1/localauthority.conf.d/</strong> directory, and we don't need root privileges to enter it:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ cd /etc/polkit-1/localauthority.conf.d/</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/polkit-1/localauthority.conf.d$ ls -l</p>
			<p class="source-code">total 8</p>
			<p class="source-code">-rw-r--r-- 1 root 267 Aug 16  2019 50-localauthority.conf</p>
			<p class="source-code">-rw-r--r-- 1 root root  65 Aug 16  2019 51-ubuntu-admin.conf</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/polkit-1/localauthority.conf.d$</p>
			<p>The <strong class="source-inline">50-localauthority.conf</strong> file looks like this:</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/polkit-1/localauthority.conf.d$ cat 50-localauthority.conf </p>
			<p class="source-code"># Configuration file for the PolicyKit Local Authority.</p>
			<p class="source-code">#</p>
			<p class="source-code"># DO NOT EDIT THIS FILE, it will be overwritten on update.</p>
			<p class="source-code">#</p>
			<p class="source-code"># See the pklocalauthority(8) man page for more information</p>
			<p class="source-code"># about configuring the Local Authority.</p>
			<p class="source-code">#</p>
			<p class="source-code">[Configuration]</p>
			<p class="source-code">AdminIdentities=unix-user:0</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/polkit-1/localauthority.conf.d$</p>
			<p>There's only one<a id="_idIndexMarker776"/> important line here, which looks for the root user. (That's the <strong class="source-inline">unix-user</strong> with UID <strong class="source-inline">0</strong>.) The other file looks for members of the <strong class="source-inline">sudo</strong> or <strong class="source-inline">admin</strong> groups:</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/polkit-1/localauthority.conf.d$ cat 51-ubuntu-admin.conf </p>
			<p class="source-code">[Configuration]</p>
			<p class="source-code">AdminIdentities=unix-group:sudo;unix-group:admin</p>
			<p class="source-code">donnie@ubuntu20-04:/etc/polkit-1/localauthority.conf.d$</p>
			<p>The biggest difference between the Red Hat and Ubuntu worlds so far is that on Red Hat-type systems, members of the wheel group have full sudo privileges. On Ubuntu systems, members of either the sudo group or the admin group have full sudo privileges. Now, let's see how this works.</p>
			<p>On the Ubuntu machine, try to reload the <strong class="source-inline">ssh</strong> service without using sudo:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ systemctl reload ssh</p>
			<p class="source-code">==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ===</p>
			<p class="source-code">Authentication is required to reload 'ssh.service'.</p>
			<p class="source-code">Authenticating as: Donald A. Tevault (donnie)</p>
			<p class="source-code">Password: </p>
			<p class="source-code">==== AUTHENTICATION COMPLETE ===</p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>As you see, polkit asks for my password because I'm the only member of the sudo group. Now, let's try using polkit to look at the firewall configuration:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ iptables -L</p>
			<p class="source-code">Fatal: can't open lock file /run/xtables.lock: Permission denied</p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>It failed, because<a id="_idIndexMarker777"/> polkit isn't configured to work with the <strong class="source-inline">iptables</strong> command.</p>
			<p>Next, let's see what happens if Pogo tries to use polkit. For it to work though, his password will need to be different from your own password. If it's the same, change it to something else:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ sudo passwd pogo</p>
			<p class="source-code">New password: Retype new password: </p>
			<p class="source-code">passwd: password updated successfully</p>
			<p class="source-code">donnie@ubuntu20-04:~$</p>
			<p>Now, let's have Pogo try to reload <strong class="source-inline">ssh</strong>:</p>
			<p class="source-code">pogo@ubuntu20-04:~$ systemctl reload ssh</p>
			<p class="source-code">==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ===</p>
			<p class="source-code">Authentication is required to reload 'ssh.service'.</p>
			<p class="source-code">Authenticating as: Donald A. Tevault (donnie)</p>
			<p class="source-code">Password: </p>
			<p class="source-code">polkit-agent-helper-1: pam_authenticate failed: Authentication failure</p>
			<p class="source-code">==== AUTHENTICATION FAILED ===</p>
			<p class="source-code">Failed to reload ssh.service: Access denied</p>
			<p class="source-code">See system logs and 'systemctl status ssh.service' for details.</p>
			<p class="source-code">pogo@ubuntu20-04:~$</p>
			<p>As before, polkit asks for my password, because I'm a member of the sudo group and Pogo isn't. Pogo <a id="_idIndexMarker778"/>doesn't know my password, so he can't perform this command.</p>
			<p>While we're still on the Ubuntu machine, let's see what some of these rules look like. We'll <strong class="source-inline">cd</strong> into the <strong class="source-inline">/usr/share/polkit-1/rules.d/</strong> directory and peek inside the <strong class="source-inline">systemd-networkd.rules</strong> file:</p>
			<p class="source-code">// Allow systemd-networkd to set timezone, get product UUID,</p>
			<p class="source-code">// and transient hostname</p>
			<p class="source-code">polkit.addRule(function(action, subject) {</p>
			<p class="source-code">    if ((action.id == "org.freedesktop.hostname1.set-hostname" ||</p>
			<p class="source-code">         action.id == "org.freedesktop.hostname1.get-product-uuid" ||</p>
			<p class="source-code">         action.id == "org.freedesktop.timedate1.set-timezone") &amp;&amp;</p>
			<p class="source-code">        subject.user == "systemd-network") {</p>
			<p class="source-code">        return polkit.Result.YES;</p>
			<p class="source-code">    }</p>
			<p class="source-code">});</p>
			<p>Here, we're assigning root privileges to the <strong class="source-inline">systemd-networkd</strong> system user account so that it can perform these three tasks without prompting for a password. (The <strong class="source-inline">return polkit.Result.YES;</strong> line is what prevents it from asking for a password.)</p>
			<p>For something a bit more complex, let's <strong class="source-inline">cd</strong> into the <strong class="source-inline">/usr/share/polkit-1/actions/</strong> directory and peek inside one of its files. We'll choose the <strong class="source-inline">com.ubuntu.languageselector.policy</strong> file, since it's the shortest. The only part that we need <a id="_idIndexMarker779"/>to look at is the <strong class="source-inline">action id=</strong> section, which looks like this:</p>
			<p class="source-code">. . .</p>
			<p class="source-code"> &lt;action id="com.ubuntu.languageselector.setsystemdefaultlanguage"&gt;</p>
			<p class="source-code">    &lt;description gettext-domain="language-selector"&gt;Set system default language&lt;/description&gt;</p>
			<p class="source-code">    &lt;message gettext-domain="language-selector"&gt;System policy prevented setting default language&lt;/message&gt;</p>
			<p class="source-code">    &lt;defaults&gt;</p>
			<p class="source-code">      &lt;allow_any&gt;auth_admin&lt;/allow_any&gt;</p>
			<p class="source-code">      &lt;allow_inactive&gt;no&lt;/allow_inactive&gt;</p>
			<p class="source-code">      &lt;allow_active&gt;auth_admin_keep&lt;/allow_active&gt;</p>
			<p class="source-code">    &lt;/defaults&gt;</p>
			<p class="source-code">  &lt;/action&gt;</p>
			<p class="source-code">. . .</p>
			<p>The <strong class="source-inline">&lt;default&gt;</strong> stanza at the bottom is where we define who can perform this action. Here's the breakdown:</p>
			<ul>
				<li><strong class="source-inline">&lt;allow_any&gt;</strong>: This tag sets authorizations for any client machine. The <strong class="source-inline">auth_admin</strong> setting requires the user to enter the administrative password before the action can be performed.</li>
				<li><strong class="source-inline">&lt;allow_inactive&gt;</strong>: This tag sets authorizations for clients in inactive sessions on the local console. It's set to <strong class="source-inline">no</strong> here, which prevents these clients from having any authorization.</li>
				<li><strong class="source-inline">&lt;allow_active&gt;</strong>: This is for clients in an active session on the local console. The <strong class="source-inline">auth_admin_keep</strong> value requires that the user enter the admin password. It also allows the user to maintain authorization for a short period of time.</li>
			</ul>
			<p>The other action files are set up in a similar manner, and I'll leave it to you to peruse through them. For more details on the rules and actions, see the <strong class="source-inline">polkit</strong> man page.</p>
			<p>The polkit <a id="_idIndexMarker780"/>service is activated by a <strong class="source-inline">dbus</strong> message whenever someone tries to perform an administrative action that's configured in <strong class="source-inline">polkit</strong>, as we see by the <strong class="source-inline">Type=dbus</strong> line in its unit file:</p>
			<p class="source-code">donnie@ubuntu20-04:~$ cd /lib/systemd/system</p>
			<p class="source-code">donnie@ubuntu20-04:/lib/systemd/system$ cat polkit.service </p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=Authorization Manager</p>
			<p class="source-code">Documentation=man:polkit(8)</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">Type=dbus</p>
			<p class="source-code">BusName=org.freedesktop.PolicyKit1</p>
			<p class="source-code">ExecStart=/usr/lib/policykit-1/polkitd --no-debug</p>
			<p class="source-code">donnie@ubuntu20-04:/lib/systemd/system$</p>
			<p>Okay, that does it for the Ubuntu machine. Things are pretty much the same on the Alma machine, except that you need root privileges to <strong class="source-inline">cd</strong> into the <strong class="source-inline">rules.d/</strong> directory, as we see here:</p>
			<p class="source-code">[donnie@localhost system]$ cd /usr/share/polkit-1/</p>
			<p class="source-code">[donnie@localhost polkit-1]$ ls -l</p>
			<p class="source-code">total 8</p>
			<p class="source-code">drwxr-xr-x. 2 root    4096 Jul 23 15:51 actions</p>
			<p class="source-code">drwx------. 2 polkitd root  287 Jul 12 17:51 rules.d</p>
			<p class="source-code">[donnie@localhost polkit-1]$</p>
			<p>Now, let's<a id="_idIndexMarker781"/> shift over to the local graphical terminal of the Alma virtual machine. If you're still in the root shell, type <strong class="source-inline">exit</strong> to get back to your own shell. Now, try to reload <strong class="source-inline">sshd</strong>, and you'll see a dialog box pop up to ask for the admin password:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B17491_Figure_18.3.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 18.3 – The graphical polkit password dialog box</p>
			<p>Okay, I think that<a id="_idIndexMarker782"/> that's about it for polkit. Let's summarize what we've learned and wrap things up.</p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor280"/>Summary</h1>
			<p>As always, we've seen some cool stuff in this chapter. We began with a discussion about the <strong class="source-inline">systemd-logind.service</strong> file, and saw how it's set up differently on the Ubuntu and Alma machines. We then looked at the <strong class="source-inline">logind.conf</strong> file, and played with some of its configuration options. After that, we played with <strong class="source-inline">loginctl</strong> and wrapped up with a discussion of polkit.</p>
			<p>And that, guys and gals, wraps things up not only for this chapter, but also for the whole book. I hope that you've enjoyed our journey through the idyllic <em class="italic">land of systemd</em> as much as I have. Take care, and I hope to see you again soon.</p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor281"/>Questions</h1>
			<ol>
				<li>How does the <strong class="source-inline">systemd-logind</strong> service get activated?<p>A. As part of the multi-user target</p><p>B. As part of the graphical target</p><p>C. When it receives a <strong class="source-inline">dbus</strong> message</p><p>D. As part of the <strong class="source-inline">sysinit</strong> target</p></li>
				<li>What happens when two different users remotely log into a Linux server?<p>A. They both get assigned to <strong class="source-inline">seat0</strong>.</p><p>B. One gets assigned to <strong class="source-inline">seat0</strong> and the other gets assigned to <strong class="source-inline">seat1</strong>.</p><p>C. They both get assigned to <strong class="source-inline">seat1</strong>.</p><p>D. Neither of them gets an assigned seat.</p></li>
				<li>In which of the following files does <strong class="source-inline">systemd-logind</strong> look to find out how to do user authentication?<p>A. <strong class="source-inline">/etc/nsswitch.conf</strong></p><p>B. <strong class="source-inline">/etc/default/nsswitch.conf</strong></p><p>C. <strong class="source-inline">/etc/sysconfig/nsswitch.conf</strong></p><p>D. <strong class="source-inline">/etc/authenticate.conf</strong></p></li>
				<li>Which of the following statements is true about polkit?<p>A. In its default configuration, it works with only a pre-defined set of administrative commands.</p><p>B. In its default configuration, it works with all administrative commands, just as sudo does.</p><p>C. It only works with the root user password.</p><p>D. It can only be used on text-mode machines.</p></li>
			</ol>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor282"/>Answers</h1>
			<ol>
				<li value="1">C</li>
				<li>D</li>
				<li>A</li>
				<li>A</li>
			</ol>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor283"/>Further reading</h1>
			<ul>
				<li>The SSSD home page: <a href="https://sssd.io/ ">https://sssd.io/</a></li>
				<li>An explanation of seats and sessions: <a href="https://www.man7.org/linux/man-pages/man3/sd-login.3.html ">https://www.man7.org/linux/man-pages/man3/sd-login.3.html</a></li>
				<li>The polkit reference manual: <a href="https://www.freedesktop.org/software/polkit/docs/latest/polkit.8.html">https://www.freedesktop.org/software/polkit/docs/latest/polkit.8.html</a></li>
			</ul>
		</div>
	</body></html>