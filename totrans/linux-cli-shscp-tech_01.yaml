- en: '*Chapter 1*: Basics of Shell and Text Terminal'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*：Shell和文本终端基础'
- en: An ancient Chinese proverb states that *A journey of a thousand miles begins
    with a single step*. This chapter is going to be that single, first step on our
    journey to mastering the Linux **command-line interface** (**CLI**) and **shell
    scripting**. Specifically, we're going to learn how to use Terminal, the shell,
    some basic commands, and one very handy utility to work on many things at once,
    called **screen**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一句古老的中国谚语说：“*千里之行，始于足下*”。本章将是我们迈向精通Linux **命令行界面**（**CLI**）和**Shell脚本**的第一步。具体来说，我们将学习如何使用终端、Shell，一些基本命令以及一个非常实用的工具——`screen`，来一次处理多个任务。
- en: As you progress further through the book, you'll notice that we will be using
    these concepts a lot, as they're the basis for what we're going to do in the later
    chapters. When dealing with systems administration, we can usually do a lot more
    in some kind of CLI than in any kind of **graphical user interface** (**GUI**).
    This stems from the idea of the programmability of a *CLI* versus the *static*
    nature of most GUIs in IT. Furthermore, a utility such as screen will make our
    life in the CLI a lot easier, as we're going to be able to deal with multiple
    virtual screens at the same time, thus enhancing our productivity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你深入阅读本书，你会注意到我们将频繁使用这些概念，因为它们是后续章节的基础。在进行系统管理时，我们通常在某种命令行界面（CLI）中能做的更多，而不仅仅是在任何一种**图形用户界面**（**GUI**）中。这源自于*CLI*的可编程性与大多数IT图形界面*静态*性质之间的对比。此外，像`screen`这样的工具将使我们的CLI操作更加轻松，因为我们可以同时处理多个虚拟屏幕，从而提高工作效率。
- en: 'So, in short, we''re going to deal with the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将处理以下几个主题：
- en: Accessing the shell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问Shell
- en: Setting up the user shell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置用户Shell
- en: Setting up the Bash shell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Bash Shell
- en: Using the most common shell commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最常见的Shell命令
- en: Using `screen`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`screen`
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For these recipes, we''re going to use two Linux machines – in our case, it''s
    going to be two VMware virtual machines with *Ubuntu* (*20.04 Focal Fossa*). Let''s
    call them `cli1` and `gui1`, and as the book progresses, we''re going to add some
    more, as our topics grow in complexity. So, all in all, we need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些主题，我们将使用两台Linux机器——在我们的案例中，它们是两台运行*Ubuntu*（*20.04 Focal Fossa*）的VMware虚拟机。我们称它们为`cli1`和`gui1`，随着书籍的推进，我们将增加更多机器，随着主题的复杂性增加，所以，总的来说，我们需要以下内容：
- en: VMware Player, Workstation, Fusion, or ESXi
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VMware Player、Workstation、Fusion 或 ESXi
- en: Ubuntu 20.04 Focal Fossa installation ISO file
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu 20.04 Focal Fossa安装ISO文件
- en: A bit of time to install these two virtual machines without the GUI (the `cli1`
    machine) and with the GUI (`gui1`)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装这两台没有图形界面的虚拟机（`cli1`机器）和带图形界面的虚拟机（`gui1`机器）需要一些时间。
- en: After the installation process is finished, we're going to start with shell
    basics – our very next topic.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程完成后，我们将开始学习Shell基础——这是我们下一个要讨论的主题。
- en: Accessing the shell
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问Shell
- en: First, let's briefly discuss various **shell** access methods. It can be as
    simple as just installing a virtual machine with Linux that's running text mode
    only, but it could also be a virtual machine with the GUI. That would require
    us doing something to have access to text mode; so, let's learn about these different
    ways of getting access to the shell.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们简要讨论各种**Shell**访问方法。它可以简单到只安装一个运行文本模式的Linux虚拟机，但也可以是一个带有图形界面的虚拟机。那样我们就需要做一些工作来访问文本模式；所以，让我们学习这些不同的Shell访问方式。
- en: It's also important to understand *why* accessing the shell is so important.
    The reasoning behind this is simple, which is that we can do a lot more in the
    shell than in the GUI. In the second part of this book, we're going to dig deeper
    into the concept of shell scripting, and then it's going to become obvious how
    that applies to our statement about being able to do a lot more in the shell.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 理解*为什么*访问Shell如此重要也很关键。其背后的理由很简单，因为我们在Shell中能做的事情远比在GUI中做的多。在本书的第二部分，我们将深入探讨Shell脚本的概念，那时你会发现，为什么我们在Shell中能够做更多的事情，这一点会更加显而易见。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For starters, we need to deploy our two virtual machines. We can actually install
    both of these machines as text-mode machines with the OpenSSH server (the installation
    process asks about OpenSSH at one point). Then, we could add the GUI to the `gui1`
    machine so that we can work with that, too. We do that by typing a couple of commands
    into the `gui1` machine after logging in as `student` (which is the username we
    came up with for this example):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要部署我们的两个虚拟机。我们实际上可以将这两台机器安装为文本模式机器，并启用 OpenSSH 服务器（安装过程中的某个步骤会询问 OpenSSH）。然后，我们可以为
    `gui1` 机器添加图形界面，以便我们也可以使用它。我们通过在以 `student` 用户登录后，在 `gui1` 机器上输入几个命令来完成此操作（`student`
    是我们为本示例设置的用户名）：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`sudo` is going to ask us for the `student` user password (it can be any user
    that you created during the installation process; `student` is just something
    that we used in our example). When the **tasksel TUI** interface starts, we will
    select the **Ubuntu desktop** package set, as shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo` 将要求我们输入 `student` 用户的密码（这可以是你在安装过程中创建的任何用户；`student` 只是我们在示例中使用的用户名）。当
    **tasksel TUI** 界面启动时，我们将选择 **Ubuntu 桌面** 软件包集，如下图所示：'
- en: '![Figure 1.1 – Ubuntu desktop package'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – Ubuntu 桌面软件包'
- en: '](img/Figure_1.1_B16269.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.1_B16269.jpg)'
- en: Figure 1.1 – Ubuntu desktop package
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – Ubuntu 桌面软件包
- en: As you can see from *Figure 1.1*, you need to select **Ubuntu desktop** by using
    the arrow keys and spacebar to select from the menu, then use *Tab* or the arrow
    keys to select **Ok** and press *Enter*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 *图 1.1* 所示，你需要使用箭头键选择 **Ubuntu 桌面**，并按空格键从菜单中进行选择，然后使用 *Tab* 或箭头键选择 **Ok**
    并按 *Enter*。
- en: Let's now discuss how to access the shell.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论如何访问 shell。
- en: How to do it…
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'If we deployed our Ubuntu machine with default options, we''re going to be
    faced with text mode by default. To access the shell and have the capability to
    do something with our Linux virtual machine, we need to type in our *username*
    and *password*. It needs to be the username or password that we typed in during
    the installation process. In our virtual machine, the user named `student` was
    created, with the preassigned `student` password. When we successfully log in,
    we''re faced with the regular text mode and associated shell, as in the following
    screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用默认选项部署了 Ubuntu 机器，默认情况下我们将看到文本模式。为了访问 shell 并能够对 Linux 虚拟机进行操作，我们需要输入我们在安装过程中设置的
    *用户名* 和 *密码*。必须是我们在安装过程中输入的用户名或密码。在我们的虚拟机中，创建了名为 `student` 的用户，密码为预设的 `student`
    密码。当我们成功登录后，将看到常规的文本模式和关联的 shell，如下图所示：
- en: '![Figure 1.2 – Accessing the CLI from text mode after logging in'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – 登录后从文本模式访问 CLI'
- en: '](img/Figure_1.2_B16269.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.2_B16269.jpg)'
- en: Figure 1.2 – Accessing the CLI from text mode after logging in
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 登录后从文本模式访问 CLI
- en: 'If, however, we did a GUI installation, there are three different ways of accessing
    the shell:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们进行了图形界面安装，访问 shell 有三种不同的方法：
- en: 'We could start a text Terminal in **GNOME** (**GNOME Terminal**) and use the
    shell from there. On the plus side, it gives us a GUI-like look and feel that
    might be a bit more user-friendly to a lot of people. On the downside, we''re
    rarely going to find a GUI on Linux servers in production environments, so it
    might be a case of *learning bad habits*. To start GNOME Terminal, we can either
    use the built-in GNOME search function (by pressing the *WIN* key) or just right-click
    on the desktop and open **Terminal**. The result will look like this:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在 **GNOME**（**GNOME 终端**）中启动文本终端并使用其中的 shell。优点是它为我们提供了类似图形用户界面的外观和感觉，对许多人来说可能更友好。缺点是，我们很少在生产环境中的
    Linux 服务器上找到图形界面，因此这可能会导致 *养成不良习惯*。要启动 GNOME 终端，我们可以使用内置的 GNOME 搜索功能（按 *WIN* 键）或直接右键点击桌面并打开
    **终端**。结果如下所示：
- en: '![Figure 1.3 – Finding Terminal in the GNOME GUI by using'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – 在 GNOME 图形界面中查找终端'
- en: the WIN key to search for the Terminal keyword
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WIN 键搜索“Terminal”关键词
- en: '](img/Figure_1.3_B16269.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.3_B16269.jpg)'
- en: Figure 1.3 – Finding Terminal in the GNOME GUI by using the WIN key to search
    for the Terminal keyword
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 在 GNOME 图形用户界面中使用 WIN 键搜索“Terminal”关键词来查找终端
- en: We could just switch to a text-based text console, as Linux doesn't stop us
    from using text consoles when we deploy the GUI. For that, we need to press a
    dedicated key combination that is going to get us to one of those text consoles.
    For example, we can press the *Ctrl* + *Alt* + *F3* key combination. That is going
    to take us to text mode, specifically, to the text console number.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以直接切换到基于文本的控制台，因为 Linux 在部署 GUI 时并不阻止我们使用文本控制台。为此，我们需要按下一个专门的键盘组合，才能进入其中一个文本控制台。例如，我们可以按下
    *Ctrl* + *Alt* + *F3* 键组合。这样，我们将进入文本模式，具体来说，进入文本控制台编号。
- en: 'There, we can log in and start typing our commands. The result will look like
    this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，我们可以登录并开始输入我们的命令。结果将如下所示：
- en: '![Figure 1.4 – Switching to the text Terminal from the GUI'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 从 GUI 切换到文本终端'
- en: '](img/Figure_1.4_B16269.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.4_B16269.jpg)'
- en: Figure 1.4 – Switching to the text Terminal from the GUI
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 从 GUI 切换到文本终端
- en: We're in the shell again. We can now start using any commands we want to.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们又回到 shell 了。现在我们可以开始使用任何我们想要的命令。
- en: 'We could use the `systemctl` command to switch to text mode as a default mode
    for the current session (until the next reboot). We could even use it to make
    the text mode permanent, regardless of the fact that we have full GUI installation.
    To achieve that, in our GUI, we need to log in and then type the following sequence
    of commands into GNOME Terminal:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `systemctl` 命令将当前会话的默认模式切换为文本模式（直到下次重启）。我们甚至可以使用它将文本模式设置为永久模式，尽管我们已经安装了完整的
    GUI。为了实现这一点，在我们的 GUI 中，我们需要登录，然后在 GNOME 终端中输入以下一系列命令：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can use the first command if we want to set our Linux virtual machine to
    boot to text mode *by default*. We can use the second command to re-configure
    our Linux machine to switch to text mode *immediately*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将 Linux 虚拟机设置为 *默认* 启动到文本模式，可以使用第一条命令。如果我们想立即将 Linux 机器重新配置为切换到文本模式，可以使用第二条命令。
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: There are a couple of sets of commands that we used in the previous recipe,
    so let's explain what these commands do so that we can have a clear picture of
    what we were doing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们使用了几组命令，接下来让我们解释这些命令的作用，以便我们能够清楚地了解我们所做的事情。
- en: 'The first set of commands is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组命令如下：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These three commands are going to do the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这三条命令将执行以下操作：
- en: '`sudo -i` is going to ask us for the current user''s password. If that user
    has been added to the `sudoers` system (`/etc/sudoers`), that means that we can
    use the current user''s password to log in as root and use administrative privileges.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo -i` 将要求我们输入当前用户的密码。如果该用户已经被添加到 `sudoers` 系统中（`/etc/sudoers`），这意味着我们可以使用当前用户的密码以
    root 身份登录并使用管理员权限。'
- en: '`apt-get -y install tasksel` will install the `tasksel` application. The main
    purpose of this application is to simplify package deployment. Specifically, we
    are going to use it in the next step to deploy an *Ubuntu desktop* set of packages
    (multiple hundreds of packages). Imagine typing all the `apt-get` commands for
    that deployment procedure manually!'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apt-get -y install tasksel` 将安装 `tasksel` 应用程序。该应用程序的主要目的是简化包的部署。具体来说，我们将在下一步中使用它来部署一组
    *Ubuntu 桌面* 包（多个成百上千个包）。想象一下，如果手动输入所有的 `apt-get` 命令来完成这一部署过程会是什么样子！'
- en: The `tasksel` command is going to start the tasksel application, which will
    be used to deploy the necessary packages.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasksel` 命令将启动 tasksel 应用程序，该程序将用于部署所需的包。'
- en: 'The second set of commands do the following things:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组命令执行以下操作：
- en: '`systemctl set-default multi-user.target` will set text mode as the default
    boot target. The translation of this is that our Linux machine will boot in text
    mode by default only when it becomes valid after the next reboot.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemctl set-default multi-user.target` 将设置文本模式为默认启动目标。其含义是，我们的 Linux 机器将在下次重启后默认以文本模式启动。'
- en: '`systemctl isolate multi-user.target` will switch us to text mode immediately.
    It''s completely different from the `set-default` procedure, as it has nothing
    to do with the state of our Linux machine post-reboot.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemctl isolate multi-user.target` 将立即将我们切换到文本模式。与 `set-default` 程序完全不同，因为它与重启后的
    Linux 机器状态无关。'
- en: See also
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'If you need more information about `apt-get`, `tasksel`, or `systemctl`, we
    suggest that you visit these links:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于 `apt-get`、`tasksel` 或 `systemctl` 的信息，我们建议你访问以下链接：
- en: '`apt-get`: [https://help.ubuntu.com/community/AptGet/Howto](https://help.ubuntu.com/community/AptGet/Howto)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apt-get`: [https://help.ubuntu.com/community/AptGet/Howto](https://help.ubuntu.com/community/AptGet/Howto)'
- en: '`tasksel`: [https://help.ubuntu.com/community/Tasksel](https://help.ubuntu.com/community/Tasksel)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasksel`: [https://help.ubuntu.com/community/Tasksel](https://help.ubuntu.com/community/Tasksel)'
- en: '`systemctl`: [https://www.liquidweb.com/kb/what-is-systemctl-an-in-depth-overview/](https://www.liquidweb.com/kb/what-is-systemctl-an-in-depth-overview/)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemctl`: [https://www.liquidweb.com/kb/what-is-systemctl-an-in-depth-overview/](https://www.liquidweb.com/kb/what-is-systemctl-an-in-depth-overview/)'
- en: Setting up the user shell
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置用户的shell
- en: Now that we have learned about how to access the shell, let's configure it for
    our comfortable use. We're going to see a couple of examples so that we can understand
    how customizable the Linux shell is. Specifically, we're going to customize the
    look and feel of our prompt.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何访问shell，让我们将其配置为便于使用。我们将看到几个例子，以便理解Linux shell的自定义性。具体来说，我们将自定义提示符的外观和感觉。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We just need to keep our virtual machines up and running.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要保持虚拟机的运行。
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We''re going to edit a file called `/home/student/.bashrc`. Before we do that,
    let''s create a backup copy of the `.bashrc` file, just in case we make some mistakes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编辑一个名为`/home/student/.bashrc`的文件。在此之前，让我们创建`.bashrc`文件的备份副本，以防我们犯错：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Before we edit this file, make sure that you take note of how the prompt looks
    at this point. If you''re logged in as `student` to the `cli1` machine, your prompt
    should look like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑这个文件之前，确保你记下当前提示符的样子。如果你以`student`身份登录到`cli1`机器，提示符应该是这样的：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s edit the `.bashrc` file by using `nano`. Type in the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`nano`编辑`.bashrc`文件。输入以下命令：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we type in this command, we''re going to open `.bashrc` in the nano editor.
    Let''s scroll all the way to the end of this file, which should look like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入这个命令时，我们将会在nano编辑器中打开`.bashrc`。让我们滚动到文件的末尾，应该像这样：
- en: '![Figure 1.5 – .bashrc default content'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5 – .bashrc默认内容'
- en: '](img/Figure_1.5_B16269.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.5_B16269.jpg)'
- en: Figure 1.5 – .bashrc default content
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – .bashrc默认内容
- en: 'Let''s go all the way below the last `fi` and add the following statement:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要继续到最后一个`fi`的位置，并添加以下语句：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, use *Ctrl* + *X* to save the file. Then, when we''re back in the shell,
    let''s type in the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用*Ctrl* + *X*保存文件。然后，当我们回到shell时，输入以下命令：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we did everything correctly, our prompt should look like this now:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们一切都做对了，我们的提示符现在应该是这样的：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This can be further customized by using PS1 parameters. Let''s locate the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用PS1参数进一步自定义。让我们定位以下内容：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''ll change it to the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其更改为以下内容：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `\u@\H` part represents the `username@host` part of the prompt. The `\A`
    part is for 24-hour time. So, when we do the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`\u@\H`部分表示提示符中的`username@host`部分。`\A`部分表示24小时制的时间。所以，当我们执行以下操作时：'
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Again, we should get the following state of our prompt:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们应该看到提示符的以下状态：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`19:30` represents time. We could also customize things such as the type of
    font (underlined, normal, dim, bold) and color (black, red, green, and so on).
    Let''s do that now. For example, let''s edit `.bashrc` again and set `PS1` like
    this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`19:30`表示时间。我们还可以自定义其他内容，比如字体类型（下划线、正常、暗淡、粗体）和颜色（黑色、红色、绿色等）。现在就让我们来做这个。比如，我们再次编辑`.bashrc`文件，将`PS1`设置如下：'
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our prompt should now look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的提示符应该是这样的：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this particular example, `\e[` tells the `PS1` variable that we want to change
    the color of our prompt. `0;31m` means red (`30` is black, `34` is blue, and so
    on). The `[]` enclosed part is our regular prompt, as previously discussed. The
    last bit, `\e[0m`, tells the `PS1` variable that we're done with color modification
    for our `PS1` output.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个具体的例子中，`\e[`告诉`PS1`变量我们想要更改提示符的颜色。`0;31m`表示红色（`30`是黑色，`34`是蓝色，以此类推）。`[]`括起来的部分是我们之前讨论的常规提示符。最后的部分，`\e[0m`，告诉`PS1`变量我们已完成对`PS1`输出的颜色修改。
- en: As we can see, touching just one shell variable (`PS1`) can drastically change
    the way we consume text mode in our Linux virtual machine.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，修改一个shell变量（`PS1`）就能大幅改变我们在Linux虚拟机中的文本模式体验。
- en: How it works…
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: As a shell variable, `PS1` can be used to customize the look and feel of our
    shell. Think of it in the way that most users customize their GUI using different
    wallpapers, text sizes, colors, and so on, and it's a natural thing that we do
    because we like what we like. `PS1` is often called a **primary prompt display
    variable**, as described in the previous section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个Shell变量，`PS1`可以用来定制Shell的外观和感觉。可以把它理解为大多数用户自定义GUI时，使用不同的壁纸、文本大小、颜色等方式，它是我们喜欢的东西，因此这是一个很自然的做法。`PS1`通常被称为**主提示显示变量**，如前面章节所述。
- en: The `source` command that we used *executes* `.bashrc`, in the sense that it
    will apply the settings from `.bashrc`. That's why we didn't need to log off and
    log in again, as it would be a waste of time, and the `source` command can help
    us with that.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的`source`命令*执行*了`.bashrc`，意味着它将应用来自`.bashrc`的设置。因此，我们无需注销再重新登录，因为那样浪费时间，`source`命令可以帮助我们解决这个问题。
- en: Let's now add some more settings to our `.bashrc` file, as there are many more
    things that we can customize.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`.bashrc`文件中添加更多设置，因为还有很多内容可以自定义。
- en: Setting up the Bash shell
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Bash shell。
- en: We played with the `PS1` variable and configured it so that it's more to our
    liking. Let's now use more `.bashrc` settings to configure our Bash shell even
    further.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调整了`PS1`变量并将其配置为更符合我们的喜好。现在，让我们使用更多的`.bashrc`设置，进一步配置我们的Bash shell。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始。
- en: We need to leave our virtual machines running. If they are not powered on, we
    need to power them back on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要保持虚拟机处于运行状态。如果它们没有开机，我们需要重新开机。
- en: How to do it…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'Let''s discuss how to change the following shell parameters:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论如何更改以下Shell参数：
- en: Add some custom aliases.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些自定义别名。
- en: 'If we open the `.bashrc` file again, we can do some additional magic with it.
    First, let''s add a couple of aliases. Close to the end of the `.bashrc` file,
    there''s a section with a couple of aliases (`ll`, `la`, and `l`). Let''s add
    the following lines to that part of the `.bashrc` file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次打开`.bashrc`文件，可以对它进行一些额外的设置。首先，添加几个别名。在`.bashrc`文件的末尾附近，有一部分包含了一些别名（`ll`、`la`和`l`）。我们可以在该部分添加以下行：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This code will introduce five new aliases:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将引入五个新别名：
- en: To see a list of processes
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看进程列表
- en: To filter processes according to the keyword to be typed in after `pfilter`
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照`pfilter`后面要输入的关键字过滤进程。
- en: To start the service; service name to be typed after `start`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动服务；服务名称应在`start`后面输入。
- en: To stop the service; service name to be typed after `stop`
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止服务；服务名称应在`stop`后面输入。
- en: To enable the service; service name to be typed after `ena`
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用服务；服务名称应在`ena`后面输入。
- en: As we can see, using aliases can make our typing shorter and the administration
    process simpler.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用别名可以让我们的输入更简短，且使管理过程更简单。
- en: Adjust the size of the Bash history.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整Bash历史记录的大小。
- en: 'At the top of the `.bashrc` file, there''s a section similar to this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.bashrc`文件的顶部，有一个类似这样的部分：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we want the Bash shell to remember more than the last 1,000 typed commands
    in the current session (`HISTSIZE`), and to save more than 1,000 commands in the
    history file (called `.bash_history`), we can change the values of these variables,
    let's say to `2000` and `2000`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望Bash shell记住当前会话中输入的超过1,000条命令（`HISTSIZE`），并且将超过1,000条命令保存在历史文件（`.bash_history`）中，我们可以更改这些变量的值，例如设置为`2000`和`2000`。
- en: Adjust the `PATH` variable.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`PATH`变量。
- en: Let's say that we want to add a custom path to our existing `PATH` variable.
    For example, we installed our custom application in the `/opt/bin` directory,
    and we don't want to call that application by using the full path every single
    time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想向现有的`PATH`变量中添加一个自定义路径。例如，我们将自定义应用程序安装在`/opt/bin`目录中，而且我们不想每次都通过完整路径来调用该应用程序。
- en: 'We need to edit the `.profile` file for this, as the `PATH` variable for our
    current user is set there. So, open the `.profile` file in the editor and add
    the following line to the end of this file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编辑`.profile`文件，因为当前用户的`PATH`变量是在那里设置的。因此，打开`.profile`文件并将以下行添加到文件的末尾：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Set our default editor.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们的默认编辑器。
- en: 'Let''s add the following two lines to the `.bashrc` file, at the end of the
    file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下两行添加到`.bashrc`文件中，位于文件末尾：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This would set nano as our preferred default editor.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把nano设置为我们首选的默认编辑器。
- en: How it works…
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The Bash shell has a set of reserved variables that we can use solely for Bash
    purposes. Some of these reserved variables include the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Bash shell具有一组保留变量，我们只能用于Bash目的。其中一些保留变量包括以下内容：
- en: '`PS1`, `PS2`, `PS3`, and `PS4`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PS1`、`PS2`、`PS3` 和 `PS4`'
- en: '`HISTFILESIZE` and `HISTSIZE`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HISTFILESIZE` 和 `HISTSIZE`'
- en: '`VISUAL` and `EDITOR`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VISUAL` 和 `EDITOR`'
- en: '`OLDPWD`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OLDPWD`'
- en: '`PWD`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PWD`'
- en: These are reserved for specific Bash functions, so we shouldn't create custom
    variables with these names. You can learn more about these reserved variables
    from the link provided in the *There's more…* section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称是为特定Bash函数保留的，因此我们不应该用这些名称创建自定义变量。您可以从*还有更多…*部分提供的链接了解更多关于这些保留变量的信息。
- en: As far as PS variables are concerned, we can consider them to be our entry into
    customization of the Bash shell. That especially goes for the PS1 variable, as
    it's the variable that's most commonly used. We can use all of these variables
    to set Bash to suit our own needs as we don't have to use predefined global configuration
    only. As time goes by, more and more Linux system administrators create their
    own, customized configurations for Bash as it increases the convenience of using
    the Bash shell and their own productivity.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 就PS变量而言，我们可以认为它们是我们自定义Bash shell的入口。特别是对于PS1变量来说，因为它是最常用的变量。我们可以使用所有这些变量来设置Bash，以适应我们自己的需求，因为我们不必只使用预定义的全局配置。随着时间的推移，越来越多的Linux系统管理员为Bash创建自己的定制配置，因为这增加了使用Bash
    shell的便利性和他们自己的生产力。
- en: There's more…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'If we need to learn more about Bash reserved variables and PS variables, we
    can check the following links:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要了解更多关于Bash保留变量和PS变量的信息，我们可以查看以下链接：
- en: '`https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html`'
- en: '`https://access.redhat.com/solutions/505983`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://access.redhat.com/solutions/505983`'
- en: Using the most common shell commands
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用最常见的shell命令
- en: Let's now switch our attention to learning a basic set of **Linux shell commands**.
    We're going to discuss commands to manipulate files and folders, processes, archives,
    and links. We'll do that via a scenario that is going to involve many steps.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向学习一组基本的**Linux shell命令**。我们将讨论用于操作文件和文件夹、进程、归档和链接的命令。我们将通过一个涉及多个步骤的场景来实现这一点。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We still need the same virtual machines as with our previous recipes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要与之前的配方相同的虚拟机。
- en: How to do it…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In order for us to be able to use shell commands, we have to start the shell.
    If we''re using the CLI, we just need to log in and we''re going to enter the
    shell session. If we''re using a GUI approach, we have to find a GUI Terminal
    in our application menu. After that, we can start typing commands:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用shell命令，我们必须启动shell。如果我们使用CLI，我们只需登录并进入shell会话。如果我们使用GUI方法，我们必须在应用程序菜单中找到一个GUI终端。之后，我们可以开始输入命令：
- en: For starters, let's use a basic set of commands to work with files and directories.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用一组基本的命令来处理文件和目录。
- en: 'Let''s list the content of the current directory:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出当前目录的内容：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output will look similar to this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于这样：
- en: '![Figure 1.6 – Standard output for the ls -al command with all the pertinent
    information'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6 – `ls -al` 命令的标准输出，包含所有相关信息'
- en: '](img/Figure_1.6_B16269.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.6_B16269.jpg)'
- en: Figure 1.6 – Standard output for the ls -al command with all the pertinent information
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – `ls -al` 命令的标准输出，包含所有相关信息
- en: 'Now, let''s create a directory called `directory1` and a stack of five files
    called `test1` to `test5`. That''s what the `touch` command does – it creates
    empty files. Then, let''s copy these files to that directory:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`directory1`的目录和一个名为`test1`到`test5`的五个文件的堆栈。`touch`命令会创建空文件。接着，让我们把这些文件复制到该目录：
- en: '[PRE20]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After that, let''s create a directory called `directory2` and move files 1-5
    to `directory2`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，让我们创建一个名为`directory2`的目录，并将文件1到5移动到`directory2`：
- en: '[PRE21]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s check the amount of used disk space in `directory1` and `directory2`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查`directory1`和`directory2`中已使用的磁盘空间量：
- en: '[PRE22]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s check the capacity of our current disk (the `-h` switch provides us
    with a nice, human-readable output):'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查当前磁盘的容量（`-h`开关为我们提供了一个友好的、易读的输出）：
- en: '[PRE23]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The next stack of commands is related to links known as **hard links** and **soft
    links**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一组命令与硬链接和软链接相关。
- en: 'For creating hard and soft links, let''s log in to our `cli1` virtual machine
    and log in as `root`. The overall concept of hard and soft links will be explained
    a bit later in this chapter. So, create a temporary directory and use some files.
    We''ll just use an existing file as it''s more than enough for this scenario (the
    `.bashrc` file):'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建硬链接和软链接，让我们登录到`cli1`虚拟机，并以`root`身份登录。硬链接和软链接的整体概念将在本章稍后解释。因此，创建一个临时目录并使用一些文件。我们将使用一个现有的文件，因为它足以满足这个场景（`.bashrc`文件）：
- en: '[PRE24]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s now check the beginning and end of one of these files. For example,
    let''s use `/tmp/.bashrc`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们检查其中一个文件的开始和结尾。例如，我们使用`/tmp/.bashrc`：
- en: '[PRE25]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s now check the tail end of the same file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查同一个文件的尾部：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The next step is going to involve checking running processes and the system
    state.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步将涉及检查运行的进程和系统状态。
- en: Let's now use commands to check the load our system currently has, find some
    processes, and kill some of them for fun.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用命令检查系统当前的负载，找到一些进程，并杀掉其中的一些进程来娱乐一下。
- en: 'First, let''s check the load (uptime command) and find the top 20 most time-consuming
    processes (the `ps` command):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查负载（使用`uptime`命令），并找到消耗时间最多的前20个进程（`ps`命令）：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, let''s find a specific process by name and kill it:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们根据进程名称找到特定的进程并杀掉它：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We're done with this part of the recipe. Let's now discuss the next part of
    this recipe, which is about administering users and groups.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了这部分的内容。接下来，让我们讨论本配方的下一部分，关于用户和组的管理。
- en: 'Using shell commands for user and group administration, let''s first go through
    the list of commands that we''re going to use in this recipe:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令行管理用户和组，首先让我们浏览一下本配方中要使用的命令列表：
- en: '`useradd`: Command that''s used to *create* a local user account'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useradd`：用于*创建*本地用户账户的命令。'
- en: '`usermod`: Command that''s used to *modify* a local user account'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usermod`：用于*修改*本地用户账户的命令。'
- en: '`userdel`: Command that''s used to *delete* a local user account'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userdel`：用于*删除*本地用户账户的命令。'
- en: '`groupadd`: Command that''s used to *create* a local group'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupadd`：用于*创建*本地组的命令。'
- en: '`groupmod`: Command that''s used to *modify* a local group'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupmod`：用于*修改*本地组的命令。'
- en: '`groupdel`: Command that''s used to *delete* a local group'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupdel`：用于*删除*本地组的命令。'
- en: '`passwd`: Command that''s most often used to assign passwords to user accounts,
    but it can be used for some other scenarios (for example, locking user accounts)'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`passwd`：最常用于为用户账户分配密码的命令，但也可以用于其他场景（例如，锁定用户账户）。'
- en: '`chage`: Command that''s used to manage user password expiry.'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chage`：用于管理用户密码过期的命令。'
- en: 'So, let''s create our first users and groups by using the `useradd` and `groupadd`
    commands with a scenario. Let''s say that our task is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们通过使用`useradd`和`groupadd`命令来创建我们的第一个用户和组，配合一个场景。假设我们的任务如下：
- en: Create four users called `jack`, `joe`, `jill`, and `sarah`.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建四个用户，分别为`jack`、`joe`、`jill`和`sarah`。
- en: Create two user groups called `profs` and `pupils`.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两个用户组，分别为`profs`和`pupils`。
- en: Re-configure the `jack` and `jill` user accounts to be members of the `profs`
    group.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新配置`jack`和`jill`用户账户，使其成为`profs`组的成员。
- en: Re-configure the `joe` and `sarah` user accounts to be members of the `pupils`
    group.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新配置`joe`和`sarah`用户账户，使其成为`pupils`组的成员。
- en: Assign a standard password to all the accounts (we're going to use `P@ckT2021`
    for this purpose).
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有账户分配一个标准密码（我们将使用`P@ckT2021`作为这个目的）。
- en: Configure user accounts so that they have to change their password on the next
    login.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置用户账户，使其在下次登录时必须更改密码。
- en: Set a specific expiry data for the `profs` users group – the minimum number
    of days before password change set to `15`, the maximum number of days before
    forced password change set to `30`, the warning for password change needs to start
    a week before it expires, and set the expiry date for accounts to 2022/01/01 (January
    1st, 2022).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`profs`用户组设置特定的过期日期——密码更改前的最小天数设置为`15`，强制密码更改前的最大天数设置为`30`，密码更改的警告在密码到期前一周开始，并将账户的过期日期设置为2022/01/01（2022年1月1日）。
- en: Set a specific expiry data for the `pupils` users group – the minimum number
    of days before password change set to `7`, the maximum number of days before forced
    password change set to `30`, the warning for password change needs to start 10
    days before it expires, and set the expiry date for accounts to 2021/09/01 (September
    1st, 2021).
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`pupils`用户组设置具体的过期日期——密码更改的最小天数设为`7`天，强制密码更改的最大天数设为`30`天，密码更改的提醒需要在密码过期前10天开始，并且设置账户的过期日期为2021/09/01（2021年9月1日）。
- en: Modify the `profs` group to be called `professors` and the `pupils` group to
    be called `students`.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`profs`组修改为`professors`，并将`pupils`组修改为`students`。
- en: 'The first task is to create the user accounts:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个任务是创建用户账户：
- en: '[PRE29]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will create entries for these four users in the `/etc/passwd` file (where
    most of the users' information is stored – username, user ID, group ID, default
    home directory, and default shell) and the `/etc/shadow` file (where users' passwords
    and aging information are stored).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`/etc/passwd`文件中为这四个用户创建条目（该文件存储了大多数用户的信息——用户名、用户ID、组ID、默认主目录和默认shell），并在`/etc/shadow`文件中创建条目（该文件存储了用户的密码和密码过期信息）。
- en: 'Then, we need to create the groups:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建这些组：
- en: '[PRE30]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will create entries for these groups in the `/etc/group` file, where the
    system keeps all the system groups.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为这些组在`/etc/group`文件中创建条目，该文件是系统存储所有系统组的地方。
- en: The next step is to manage users' group membership, for both the `professors`
    and `students` user groups.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是管理`professors`和`students`用户组的成员资格。
- en: Before we do that, we need to be aware of one fact. There are two distinctive
    local group types, a **primary group** and a **supplementary group**. A primary
    group is important in terms of being the key parameter used when creating new
    files and directories, as the users primary group will be used by default for
    that (there are exceptions, as we'll mention in *the Setting up the Bash shell
    recipe* in this chapter, about umask, permissions, and ACLs). A supplementary
    group is important when dealing with sharing files and folders and related scenarios
    and exceptions. This is what's usually used for some additional settings for more
    advanced scenarios. These scenarios are going to be explained partially in the
    aforementioned *Setting up the Bash shell recipe* in this chapter, as well as
    in recipes about NFS and Samba in [*Chapter 9*](B16269_09_Final_PD_ePub.xhtml#_idTextAnchor206)*,
    An Introduction to Shell Scripting.*
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，需要了解一个事实。存在两种不同的本地用户组类型，**主组**和**附加组**。主组在创建新文件和目录时非常重要，因为创建文件时会默认使用用户的主组（当然也有例外，我们将在本章的*设置Bash
    shell*部分提到关于umask、权限和ACL的内容）。附加组在共享文件和文件夹及相关场景中很重要，通常用于一些附加设置，以应对更复杂的场景。这些场景将在本章提到的*设置Bash
    shell*部分中解释，也会在[《第9章》](B16269_09_Final_PD_ePub.xhtml#_idTextAnchor206)*和《Shell脚本简介》*的配方中进一步讲解。
- en: Primary and supplementary groups are stored in the `/etc/group` file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 主组和附加组存储在`/etc/group`文件中。
- en: 'Now that we''ve gotten that out of the way, let''s modify our users'' settings
    so that they belong to *supplementary* groups as assigned by the scenario:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这部分内容，接下来让我们修改用户的设置，使他们属于*附加*组，这些组是根据场景指定的：
- en: '[PRE31]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s now check how that changes the `/etc/group` file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查一下这如何改变`/etc/group`文件：
- en: '![Figure 1.7 – Entries in the /etc/group file'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.7 – /etc/group文件中的条目'
- en: '](img/Figure_1.7_B16269.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.7_B16269.jpg)'
- en: Figure 1.7 – Entries in the /etc/group file
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – /etc/group文件中的条目
- en: The first four entries in the `/etc/group` file were actually created when we
    used the `useradd` command to create these user accounts. The next two entries
    (except for the last part, after the `:` sign) were created by the `groupadd`
    commands. Entries after the `:` sign were created after the `usermod` commands.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/group`文件中的前四个条目实际上是在我们使用`useradd`命令创建这些用户账户时创建的。接下来的两个条目（冒号后面的部分除外）是由`groupadd`命令创建的。冒号后面的条目是通过`usermod`命令创建的。'
- en: 'Let''s now set their initial password and set a forced password change on the
    next login. We can do this in a couple of different ways, but let''s learn the
    more *programmatic* approach to doing this, by echoing a string and using it as
    the plain-text password for a user account:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们设置他们的初始密码，并在下次登录时强制更改密码。我们可以通过几种不同的方式来实现这一点，但让我们学习更*程序化*的做法，通过回显字符串并将其作为用户账户的明文密码：
- en: '[PRE32]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The echo part, without the rest of the command, would just mean typing `P@ckT2021`
    in to a Terminal, like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅是回显部分，没有其他命令的情况下，意味着在终端中输入`P@ckT2021`，像这样：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In CentOS and similar distributions, we could use the `passwd` command with
    the `--stdin` parameter, which would mean that we want to add a password for the
    user account via standard input (keyboard, variables, and so on). In Ubuntu, this
    is not available. So, we can echo the `username:P@ckT2021` string to the shell
    and pipe that to the `chpasswd` command, which achieves just that purpose; instead
    of outputting the string to our Terminal, the `chpasswd` command uses it as standard
    input into itself.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS和类似的发行版中，我们可以使用带有`--stdin`参数的`passwd`命令，这意味着我们希望通过标准输入（键盘、变量等）为用户帐户添加密码。在Ubuntu中，这个功能不可用。因此，我们可以将`username:P@ckT2021`字符串回显到shell并通过管道传输给`chpasswd`命令，这样就能达到同样的目的；`chpasswd`命令不会将该字符串输出到终端，而是将其作为标准输入处理。
- en: 'Let''s set the expiry date for professors and students. For this purpose, we
    need to learn how to use the `chage` command and some of its parameters (`-m`,
    `-M`, `-W`, and `-E`). In short, they mean the following:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为教授和学生设置到期日期。为此，我们需要学习如何使用`chage`命令及其一些参数（`-m`、`-M`、`-W`和`-E`）。简而言之，它们的含义如下：
- en: If we use the `-m` parameter, that means that we want to assign the minimum
    number of days before the password change is *allowed*.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用`-m`参数，这意味着我们想要设置密码更改前允许的最小天数。
- en: If we use the `-M` parameter, that means that we want to assign the maximum
    number of days before the password change is *forced*.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用`-M`参数，这意味着我们想要设置密码更改前强制执行的最大天数。
- en: If we use the `-W` parameter, that means that we want to set the number of warning
    days before password expiration, which in turn means that the shell is going to
    start throwing us messages about needing to change our password before it expires.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用`-W`参数，这意味着我们希望设置密码过期前的警告天数，这意味着shell会开始向我们抛出关于需要在密码过期前更改密码的消息。
- en: If we use the `-E` parameter, that means that we want to set account expiration
    to a certain date (YYYY-MM-DD format).
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用`-E`参数，这意味着我们想要将帐户过期设置为某个特定日期（YYYY-MM-DD格式）。
- en: 'Let''s now translate that into commands:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将其转换为命令：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, let''s modify the groups to their final settings:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将组修改为最终设置：
- en: '[PRE35]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These commands will only change group names, not their other data (such as
    group ID), which is going to be reflected in our users'' information, as well:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令只会更改组名，而不会更改其他数据（如组ID），这些更改也会反映在我们的用户信息中：
- en: '![Figure 1.8 – Checking created users'' settings'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.8 – 检查已创建用户的设置'
- en: '](img/Figure_1.8_B16269.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.8_B16269.jpg)'
- en: Figure 1.8 – Checking created users' settings
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 检查已创建用户的设置
- en: As we can see, `jack` and `jill` are members of a group that's now called `professors`,
    while `joe` and `sarah` are now members of a group called `students`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`jack`和`jill`是现在叫做`professors`的组的成员，而`joe`和`sarah`是现在叫做`students`的组的成员。
- en: 'We deliberately left the `userdel` and `groupdel` commands for last, as these
    come with some caveats and shouldn''t be used lightly. Let''s create a user called
    `temp` and a group called `temporary`, and then let''s delete them:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意把`userdel`和`groupdel`命令放到最后，因为这些命令有一些注意事项，不应轻易使用。让我们创建一个名为`temp`的用户和一个名为`temporary`的组，然后删除它们：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will work just fine. The thing is, because we used the `userdel` command
    without any parameters, it will leave the user's home directory intact. Since
    users' home directories are usually stored in the `/home` directory, by default
    that means that the `/home/temp` directory is still going to be there. When deleting
    users, we sometimes want to delete a user but not their files. If you specifically
    want to delete a user account and all the data from that user account, then use
    the `userdel -r username` command. But think twice before doing it!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以正常工作。问题是，由于我们在没有任何参数的情况下使用了`userdel`命令，它将保留用户的主目录不变。由于用户的主目录通常存储在`/home`目录中，默认情况下，这意味着`/home/temp`目录仍然会存在。在删除用户时，我们有时希望删除用户但保留其文件。如果你特别希望删除用户帐户及其所有数据，请使用`userdel
    -r username`命令。但在执行之前请三思而后行！
- en: How it works...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Let's now discuss the more complex part of the previous recipe, which is **symbolic
    links** and **hard links**.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一下之前配方中较复杂的部分，即**符号链接**和**硬链接**。
- en: Using the `ln` command without extra parameters tries to create a hard link.
    Using `ln` with the `-s` parameter tries to create a soft link. We can clearly
    see that there are some errors in that part of our recipe. Let's discuss them
    now by going back from the top.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ln`命令而不带额外参数时，会尝试创建硬链接。使用`ln`并加上`-s`参数时，会尝试创建软链接。我们可以明显看到食谱中有一些错误。现在，让我们从头开始讨论这些问题。
- en: 'When we''ve finished typing in the first six commands from the recipe (ending
    with `ls -al`), which we''re using to list the folder contents, the end result
    should look similar to this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入完食谱中的前六个命令（以`ls -al`结束），这些命令用于列出文件夹内容时，最终结果应该类似于以下内容：
- en: '![Figure 1.9 – Original file, hard link and soft link'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.9 – 原始文件、硬链接和软链接'
- en: '](img/Figure_1.9_B16269.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.9_B16269.jpg)'
- en: Figure 1.9 – Original file, hard link and soft link
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – 原始文件、硬链接和软链接
- en: 'There are some conclusions that can be reached just by interpreting this previous
    screenshot:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的截图中，我们可以得出一些结论：
- en: The `content` file and the `hardlink` file have the same size (1,349 bytes,
    in our case).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content`文件和`hardlink`文件的大小相同（在我们的例子中是1,349字节）。'
- en: The `content` file and the `softlink` file don't have the same file size (1,349
    bytes versus 11 bytes here).
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content`文件和`softlink`文件的文件大小不同（分别为1,349字节与11字节）。'
- en: Soft links are marked differently by default (usually, a different color in
    the Terminal).
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软链接通常会以不同的方式标记（通常在终端中显示为不同的颜色）。
- en: 'Now, for the purposes of building up this explanation, let''s delete the original
    `content` file:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了进一步说明这个问题，我们来删除原始的`content`文件：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The end result will look like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果将如下所示：
- en: '![Figure 1.10 – Removing the original file leaves interesting consequences'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.10 – 删除原始文件后产生的有趣后果'
- en: '](img/Figure_1.10_B16269.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.10_B16269.jpg)'
- en: Figure 1.10 – Removing the original file leaves interesting consequences
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 – 删除原始文件后产生的有趣后果
- en: We can see that the original file is gone, while the hard link is still here
    and has the same size. On the other hand, the soft link changed color (from green
    to red), indicating that there's some kind of problem. Interesting, isn't it?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，原始文件已被删除，而硬链接仍然存在并保持相同的大小。另一方面，软链接的颜色发生了变化（从绿色变为红色），这表明出现了某种问题。很有趣，不是吗？
- en: 'If we open the `hardlink.cfg` file in the **vi editor**, the content is definitely
    there:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在**vi编辑器**中打开`hardlink.cfg`文件，内容是确实存在的：
- en: '![Figure 1.11 – The hardlink.cfg file still has the original content'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.11 – hardlink.cfg 文件仍然包含原始内容'
- en: '](img/Figure_1.11_B16269.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.11_B16269.jpg)'
- en: Figure 1.11 – The hardlink.cfg file still has the original content
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 – hardlink.cfg 文件仍然包含原始内容
- en: The reason why this happens comes from the way in which filesystems work. When
    we delete a file, we don't delete the content of the file, we just delete an entry
    in the filesystem table (filename) that points to the content of the file. The
    reason for this is simple in that it's about speed and convenience. If the operating
    system actually removed the file content, it would need to free its blocks and
    write zeros to them. That would take a lot of time. Furthermore, it would complicate
    file recovery.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以会发生这种情况，源于文件系统的工作方式。当我们删除一个文件时，我们并不会删除文件的内容，而只是删除文件系统表中的一个条目（文件名），该条目指向文件内容。这是因为删除文件内容涉及到速度和便捷性。如果操作系统实际删除文件内容，它将需要释放块并将零写入这些块，这会非常耗时。而且，这会使得文件恢复变得复杂。
- en: This is where hard links and soft links come into play. The main difference
    between them is something that we can easily deduce from the scenario. It's the
    fact that hard links point to the actual file content, while soft links point
    to the original filename. That also explains the size difference. Hard links must
    be the same size as the original file (as the original file and hard link point
    to the content of the same content, therefore the same size). The reason why `softlink.cfg`
    only consumes 11 bytes on the filesystem is simple; it's that the `content.cfg`
    string needs 11 bytes to be saved to the filesystem table.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是硬链接和软链接发挥作用的地方。它们之间的主要区别可以通过这个场景轻松推断出来。硬链接指向实际的文件内容，而软链接指向原始的文件名。这也解释了文件大小的不同。硬链接必须与原始文件大小相同（因为原始文件和硬链接都指向相同的内容，因此大小相同）。而`softlink.cfg`仅占用11字节的空间，原因很简单；`content.cfg`字符串在文件系统表中保存时需要11字节。
- en: 'This is also the reason why there are two other major differences between hard
    links and soft links:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是硬链接和软链接之间存在的另外两个主要区别的原因：
- en: Hard links cannot point to a directory and they have to point to a file.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬链接不能指向目录，必须指向文件。
- en: Hard links cannot go across partitions. We can't reference/see data from the
    first mounted partition if we look from the perspective of the second partition.
    The second partition has its own filesystem table (which contains entries pointing
    to the actual content on that partition) that's completely independent of the
    filesystem table of the first partition.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬链接不能跨越分区。如果我们从第二个分区的角度来看，我们无法引用/查看第一个挂载分区的数据。第二个分区有自己独立的文件系统表（其中包含指向该分区上实际内容的条目），与第一个分区的文件系统表完全独立。
- en: 'The cool thing, going back to our recipe, is that we can easily recover the
    original file. If we go back to the `/root/links` directory, we can just copy
    the `hardlink.cfg` file to `content.cfg` and our original file and the corresponding
    symbolic link are back:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的教程，值得注意的是，我们可以轻松恢复原始文件。如果我们回到 `/root/links` 目录，我们只需要将 `hardlink.cfg` 文件复制为
    `content.cfg`，那么我们的原始文件和相应的符号链接就恢复了：
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The end result will be just like earlier, when we created the `content.cfg`
    file and the hard link and soft link pointing to it:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果就像之前一样，当我们创建 `content.cfg` 文件以及指向它的硬链接和软链接时：
- en: '![Figure 1.12 – Our original file and soft link are back'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.12 – 我们的原始文件和软链接已恢复'
- en: '](img/Figure_1.12_B16269.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.12_B16269.jpg)'
- en: Figure 1.12 – Our original file and soft link are back
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 我们的原始文件和软链接已恢复
- en: We will use these commands throughout this book, so we need to make sure that
    we master using them before we move on to the next chapters. But for the time
    being, we'll add just one more command to the stack. It's the subject of our next
    recipe, known as **screen**.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们将使用这些命令，因此我们需要确保在进入下一章之前掌握它们。但目前为止，我们只会将其中一个命令添加到命令栈中。它就是我们下一个教程的主题，叫做
    **screen**。
- en: Using screen
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 screen
- en: '**screen** is one of those text utilities that was incredibly popular in the
    1990s and 2000s, with its popularity shrinking after that. System administrators
    often have to open multiple consoles on the same machine or use any of those multiple
    consoles to connect to external machines. Let''s see how screen fits into this
    scenario.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**screen** 是一种曾在 1990 年代和 2000 年代非常流行的文本工具，虽然其流行度在之后有所下降。系统管理员通常需要在同一台机器上打开多个控制台，或者使用这些控制台连接到外部机器。让我们来看一下
    screen 如何适应这种场景。'
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before starting with this recipe, we need to make sure that we have screen
    on our Linux machine. So, we need to use the following command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用这个教程之前，我们需要确保我们的 Linux 机器上安装了 screen。为了做到这一点，我们需要使用以下命令：
- en: '[PRE39]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After that, we're ready to follow our recipe.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们就可以准备按照我们的教程继续操作了。
- en: How to do it…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We need to start a regular text Terminal (this can be done in the GUI as well,
    but it can be considered as a bit of a less-effective way to use screen real estate).
    Then, we just need to type in the following command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要启动一个常规的文本终端（这也可以通过图形界面完成，但从屏幕空间的利用效率来看，这可能被认为是一种不太有效的方式）。然后，我们只需要输入以下命令：
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When we start screen, it is going to throw us a long piece of text about licensing
    and other less-than-interesting subjects, with a couple of important pieces of
    information at the bottom of the screen. It will look similar to this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动 screen 时，它会展示一长段关于许可和其他不太有趣的内容的文本，屏幕底部会有几个重要的信息。它看起来会类似于这样：
- en: '![Figure 1.13 – Basic screen information'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.13 – 基本的 screen 信息'
- en: '](img/Figure_1.13_B16269.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.13_B16269.jpg)'
- en: Figure 1.13 – Basic screen information
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 – 基本的 screen 信息
- en: The only part of this output that's really interesting to us is **Capabilities**.
    It tells us that with screen, we can do some cool stuff, such as copy, detach,
    and work with fonts. But even without most of these advanced features, screen
    enables us to open multiple virtual text Terminals, within the limits of one text
    Terminal. Then, it enables us to detach (something like putting the screen process
    in the background), log off, come back later, log in, and re-attach our session
    to screen. That enables some cool things, such as leaving a permanent set of virtual
    text consoles open for the most common, mostly used use cases.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最感兴趣的这个输出部分是**功能**。它告诉我们，通过使用 screen，我们可以做一些很酷的事情，比如复制、分离以及处理字体。但即使没有大多数这些高级功能，screen
    也能让我们在一个文本终端的限制内打开多个虚拟文本终端。然后，它让我们可以分离（就像把 screen 进程放到后台一样）、注销、稍后重新登录，重新连接会话到
    screen。这样可以实现一些很酷的功能，比如为最常用的、最常见的使用场景保留一组永久的虚拟文本控制台。
- en: After we press the *Enter* key on the screen shown in the previous screenshot,
    we're going to be thrown into the text mode again. This is screen's first virtual
    text console. If we want to use additional virtual text consoles, we can create
    them by using the *Ctrl* + *A* + *C* key combination. Every one of these virtual
    text consoles is numbered from 0 onward. If we create five virtual text consoles
    in screen (numbered 0-4) and we're in screen 4 and want to jump to screen 0, we
    can easily do that in two ways. The first one involves *absolute* addressing,
    in other words, we can tell screen that we want to go specifically to screen 0
    (by using *Ctrl* + *A* + *0*). The second way to go from screen 4 to 0 is to use
    a *circular* approach. When we use the *Ctrl* + *A* + spacebar key combination,
    we're circling through screens in a subsequent fashion – 0, then 1, then 2, and
    so on. If we're on screen 4 and we want to go to 0, because we don't have a screen
    5, we can just circle from 4 to 0 by using *Ctrl* + *A* + spacebar.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们按下屏幕中前面截图显示的*Enter*键后，我们将再次进入文本模式。这是 screen 的第一个虚拟文本控制台。如果我们想使用更多的虚拟文本控制台，可以通过按下
    *Ctrl* + *A* + *C* 组合键来创建它们。每一个虚拟文本控制台从 0 开始编号。如果我们在 screen 中创建了五个虚拟文本控制台（编号从
    0 到 4），并且我们在 screen 4 上，想跳到 screen 0，我们可以通过两种方式轻松做到这一点。第一种方法是使用*绝对*地址，也就是说，我们可以告诉
    screen 我们想特别跳到 screen 0（使用 *Ctrl* + *A* + *0*）。第二种方法是使用*循环*的方式。当我们使用 *Ctrl* +
    *A* + 空格键组合时，我们会按顺序循环通过各个屏幕——0，然后是 1，然后是 2，以此类推。如果我们在 screen 4 上，想跳到 0，因为没有 screen
    5，我们只需通过 *Ctrl* + *A* + 空格键就能从 4 循环到 0。
- en: 'If we need to log off, we can detach our screen. The key combination for that
    is *Ctrl* + *A* + *D* (detach screen). If sometime later we want to go back to
    our screens, we need to type in the following command:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要注销，可以分离我们的 screen。其组合键是 *Ctrl* + *A* + *D*（分离 screen）。如果稍后我们想返回我们的屏幕，我们需要输入以下命令：
- en: '[PRE41]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can also copy-paste in screen by using the *Ctrl* + *A* + *]* key combination,
    then scroll and find the bit of text that we want to start copying, use the spacebar
    to start copying and to end the copying process, and then the *Ctrl* + *A* + *]*
    combination if we want to paste text somewhere. It takes a bit of practice, but
    it's also very usable. *Just imagine doing stuff like that in 1996!*
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在 screen 中使用 *Ctrl* + *A* + *]* 键组合来进行复制粘贴，然后滚动并找到我们想要开始复制的文本部分，使用空格键开始复制，并结束复制过程，然后如果我们想把文本粘贴到某个地方，再次使用
    *Ctrl* + *A* + *]* 组合键。它需要一点练习，但也非常好用。*试想一下在 1996 年做这些事情！*
- en: Important Note
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When working with screen, we suggest that you first press *Ctrl* + *A*, let
    those keys go, and then press whichever key you need to go wherever you want to
    go on the screen.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 screen 时，我们建议你首先按下*Ctrl* + *A*，松开这两个键，然后按下你需要的任何键，去到你想要在屏幕上去的地方。
- en: How it works…
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: screen works by creating multiple detachable virtual text consoles. These consoles
    remain active until there's a process that kills screen, or until the system reboots.
    Keeping in mind that most production environments based on Linux servers don't
    have a GUI, having the capability to connect to a server once and then open multiple
    screens comes in handy.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: screen 通过创建多个可分离的虚拟文本控制台来工作。这些控制台会保持活跃，直到有进程终止了 screen，或者直到系统重启。考虑到大多数基于 Linux
    服务器的生产环境没有 GUI，能够一次连接到服务器并打开多个 screen 是非常方便的。
- en: There's more…
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'screen requires a bit of trial and error and getting used to. We recommend
    that you check the following link to learn more:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: screen 需要一些试验和错误，需要一段时间适应。我们建议你查看以下链接以了解更多内容：
- en: '`https://www.howtogeek.com/662422/how-to-use-linuxs-screen-command/`'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://www.howtogeek.com/662422/how-to-use-linuxs-screen-command/`'
