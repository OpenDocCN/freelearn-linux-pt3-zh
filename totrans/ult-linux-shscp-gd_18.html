<html><head></head><body>
  <div id="_idContainer249" class="Basic-Text-Frame">
    <h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">18</span></h1>
    <h1 id="_idParaDest-367" class="chapterTitle"><span class="koboSpan" id="kobo.2.1">Shell Scripting for Security Professionals</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.3.1">In this chapter, we’ll do things a bit differently. </span><span class="koboSpan" id="kobo.3.2">Instead of showing you new scripting concepts, I’ll show you how to use the concepts that you’ve already learned to perform chores that a security professional might need to do.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.4.1">Of course, you could do many of these chores with a more complex program, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5.1">nmap</span></code><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">But, there may be times when these tools won’t be available to you. </span><span class="koboSpan" id="kobo.6.3">In this chapter, I’ll show you some simple scripts that can do some of these jobs.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.7.1">Topics in this chapter include:</span></p>
    <ul>
      <li class="bulletList"><span class="koboSpan" id="kobo.8.1">Simple scripts for auditing</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.9.1">Creating simple firewall scripts</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.10.1">Searching for existing security-related scripts</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.11.1">Okay, I know that you’re anxious to get started. </span><span class="koboSpan" id="kobo.11.2">So, let’s go.</span></li>
    </ul>
    <h1 id="_idParaDest-368" class="heading 1"><span class="koboSpan" id="kobo.12.1">Technical Requirements</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.13.1">For the Linux demos in this chapter, I’ll use a Fedora Server virtual machine. </span><span class="koboSpan" id="kobo.13.2">That’s because these demos will use features and utilities that are unique to Red Hat-type distros, such as Fedora. </span><span class="koboSpan" id="kobo.13.3">However, you can easily adapt them to other Linux distros, such as Ubuntu or Debian, if you desire.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.14.1">I’ll also be showing you some things on OpenIndiana and FreeBSD. </span><span class="koboSpan" id="kobo.14.2">On your FreeBSD virtual machine, I’m assuming that you’ve already installed </span><code class="inlineCode"><span class="koboSpan" id="kobo.15.1">bash</span></code><span class="koboSpan" id="kobo.16.1">, and set up a normal user account with full </span><code class="inlineCode"><span class="koboSpan" id="kobo.17.1">sudo</span></code><span class="koboSpan" id="kobo.18.1"> privileges, as I’ve shown you in </span><em class="chapterRef"><span class="koboSpan" id="kobo.19.1">Chapter 12, Automating Scripts with here Documents and expect</span></em><span class="koboSpan" id="kobo.20.1">.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.21.1">Also, as always, you can grab the scripts from Github by running:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.22.1">git clone https://github.com/PacktPublishing/The-Ultimate-Linux-Shell-Scripting-Guide.git
</span></code></pre>
    <h1 id="_idParaDest-369" class="heading 1"><span class="koboSpan" id="kobo.23.1">Simple Scripts for Auditing</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.24.1">If you’re used to</span><a id="_idIndexMarker1053"/><span class="koboSpan" id="kobo.25.1"> using </span><code class="inlineCode"><span class="koboSpan" id="kobo.26.1">nmap</span></code><span class="koboSpan" id="kobo.27.1">, you already know how awesome it is. </span><span class="koboSpan" id="kobo.27.2">You can use it for many types of auditing and network security chores, such as scanning ports or identifying operating systems on remote machines. </span><span class="koboSpan" id="kobo.27.3">But, if you ever find yourself in a situation where </span><code class="inlineCode"><span class="koboSpan" id="kobo.28.1">nmap</span></code><span class="koboSpan" id="kobo.29.1"> isn’t available to you, know that you can do some of your </span><code class="inlineCode"><span class="koboSpan" id="kobo.30.1">nmap</span></code><span class="koboSpan" id="kobo.31.1"> chores with some simple shell scripts. </span><span class="koboSpan" id="kobo.31.2">Let’s begin with something simple.</span></p>
    <h2 id="_idParaDest-370" class="heading 2"><span class="koboSpan" id="kobo.32.1">Identifying an Operating System</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.33.1">You can </span><a id="_idIndexMarker1054"/><span class="koboSpan" id="kobo.34.1">get a rough idea of what operating system is running on another machine by pinging it, and looking at the </span><strong class="keyWord"><span class="koboSpan" id="kobo.35.1">Time-to-Live</span></strong><span class="koboSpan" id="kobo.36.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.37.1">TTL</span></strong><span class="koboSpan" id="kobo.38.1">) figure in the response. </span><span class="koboSpan" id="kobo.38.2">Here’s how it works:</span></p>
    <ul>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.39.1">64</span></code><span class="koboSpan" id="kobo.40.1">: If the TTL of a ping response is 64, then the operating system of the target machine is Linux, some sort of BSD, or macOS.</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.41.1">128</span></code><span class="koboSpan" id="kobo.42.1">: A 128 TTL indicates that the target machine is running Windows.</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.43.1">255</span></code><span class="koboSpan" id="kobo.44.1">: This indicates that the target machine is running either Solaris or a Solaris clone, such as OpenIndiana.</span></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.45.1">Here’s the output of a normal ping command. </span><span class="koboSpan" id="kobo.45.2">(Note that I’m using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.46.1">-c1</span></code><span class="koboSpan" id="kobo.47.1"> option, which means</span><a id="_idIndexMarker1055"/><span class="koboSpan" id="kobo.48.1"> that I’m only sending one ping packet.) This shows the TTL field:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.49.1">donnie@fedora:~$ ping -c1 192.168.0.18
PING 192.168.0.18 (192.168.0.18) 56(84) bytes of data.
</span><span class="koboSpan" id="kobo.49.2">64 bytes from 192.168.0.18: icmp_seq=1 ttl=128 time=5.09 ms
--- 192.168.0.18 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 5.086/5.086/5.086/0.000 ms
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.50.1">In the second line of output, you see </span><code class="inlineCode"><span class="koboSpan" id="kobo.51.1">ttl=128</span></code><span class="koboSpan" id="kobo.52.1">, which indicates that I’ve just pinged a Windows machine. </span><span class="koboSpan" id="kobo.52.2">Now, here’s the </span><code class="inlineCode"><span class="koboSpan" id="kobo.53.1">os-detect.sh</span></code><span class="koboSpan" id="kobo.54.1"> script, which automatically interprets the TTL field:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.55.1">#!/bin/bash
ttl=$(ping -c1 $1 | head -2 | tail -1 | cut -d= -f3 | cut -d" " -f1)
echo "The TTL value is $ttl."
</span><span class="koboSpan" id="kobo.55.2">if [[ $ttl == 64 ]]; then
         echo "A TTL of $ttl indicates either a Linux, BSD, or macOS operating system."
</span><span class="koboSpan" id="kobo.55.3">elif [[ $ttl == 128 ]]; then
        echo "A TTL of $ttl indicates a Windows operating system."
</span><span class="koboSpan" id="kobo.55.4">elif [[ $ttl == 255 ]] ; then
        echo "A TTL of $ttl indicates a Solaris/OpenIndiana operating system."
</span><span class="koboSpan" id="kobo.55.5">else
        echo "There was no recognized TTL value."
</span><span class="koboSpan" id="kobo.55.6">fi
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.56.1">In the second line, I’m using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.57.1">$1</span></code><span class="koboSpan" id="kobo.58.1"> positional parameter to represent the IP address of the target machine. </span><span class="koboSpan" id="kobo.58.2">I’m also piping the </span><code class="inlineCode"><span class="koboSpan" id="kobo.59.1">ping</span></code><span class="koboSpan" id="kobo.60.1"> output into </span><code class="inlineCode"><span class="koboSpan" id="kobo.61.1">head</span></code><span class="koboSpan" id="kobo.62.1"> and then </span><code class="inlineCode"><span class="koboSpan" id="kobo.63.1">tail</span></code><span class="koboSpan" id="kobo.64.1"> in order to isolate the second line of output, which contains the TTL field. </span><span class="koboSpan" id="kobo.64.2">I then pipe this second line into </span><code class="inlineCode"><span class="koboSpan" id="kobo.65.1">cut</span></code><span class="koboSpan" id="kobo.66.1">, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.67.1">=</span></code><span class="koboSpan" id="kobo.68.1"> as the field delimiter to isolate the third field, which in this example with Windows is </span><code class="inlineCode"><span class="koboSpan" id="kobo.69.1">128 time</span></code><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">Finally, I pipe the value of this third field into </span><code class="inlineCode"><span class="koboSpan" id="kobo.71.1">cut</span></code><span class="koboSpan" id="kobo.72.1">, in order to isolate just the TTL number. </span><span class="koboSpan" id="kobo.72.2">This TTL number will be the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.73.1">ttl</span></code><span class="koboSpan" id="kobo.74.1"> variable.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.75.1">Finally, we have the </span><code class="inlineCode"><span class="koboSpan" id="kobo.76.1">if. </span><span class="koboSpan" id="kobo.76.2">.elif. </span><span class="koboSpan" id="kobo.76.3">.else</span></code><span class="koboSpan" id="kobo.77.1"> construct to identify the target machine’s operating system. </span><span class="koboSpan" id="kobo.77.2">Now, here’s the script in operation:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.78.1">donnie@fedora:~$ ./os-detect.sh 192.168.0.18
The TTL value is 128.
</span><span class="koboSpan" id="kobo.78.2">A TTL of 128 indicates a Windows operating system.
</span><span class="koboSpan" id="kobo.78.3">donnie@fedora:~$ ./os-detect.sh 192.168.0.20
The TTL value is 64.
</span><span class="koboSpan" id="kobo.78.4">A TTL of 64 indicates either a Linux, BSD, or macOS operating system.
</span><span class="koboSpan" id="kobo.78.5">donnie@fedora:~$ ./os-detect.sh 192.168.0.19
The TTL value is 255.
</span><span class="koboSpan" id="kobo.78.6">A TTL of 255 indicates a Solaris/OpenIndiana operating system.
</span><span class="koboSpan" id="kobo.78.7">donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.79.1">For the record, the</span><a id="_idIndexMarker1056"/><span class="koboSpan" id="kobo.80.1"> first machine is running Windows 10, the second one is running FreeBSD, and the third one is running OpenIndiana. </span><span class="koboSpan" id="kobo.80.2">So, that’s easy, right? </span><span class="koboSpan" id="kobo.80.3">Hang on though, because I do need to point out a couple of caveats.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.81.1">First, is the obvious fact that this script can’t provide much detail about the operating systems on the target machines. </span><span class="koboSpan" id="kobo.81.2">In fact, it can’t even differentiate between Linux, BSD, or macOS operating systems. </span><span class="koboSpan" id="kobo.81.3">The second caveat is that you can only use this script to scan machines that are on your local network, because sending ping packets across a network boundary changes the TTL value. </span><span class="koboSpan" id="kobo.81.4">Thirdly, you can run this script from either a Linux or a BSD machine, but you can’t run it from a Solaris/OpenIndiana machine. </span><span class="koboSpan" id="kobo.81.5">That’s because Solaris and OpenIndiana use a different implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.82.1">ping</span></code><span class="koboSpan" id="kobo.83.1"> utility that doesn’t show anything other than the fact that the target machine is up. </span><span class="koboSpan" id="kobo.83.2">And lastly, if the target machines have firewalls that are configured to block ping packets, then this script won’t work at all.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.84.1">So, even though this script could be a handy tool for a quick analysis of machines on your local network, you’ll need to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.85.1">nmap</span></code><span class="koboSpan" id="kobo.86.1"> or some other equivalent tool to get more detailed information, to scan machines on another network, or to scan machines with firewalls that block ping packets. </span><span class="koboSpan" id="kobo.86.2">For example, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.87.1">nmap</span></code><span class="koboSpan" id="kobo.88.1"> with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.89.1">-A</span></code><span class="koboSpan" id="kobo.90.1"> option allows </span><code class="inlineCode"><span class="koboSpan" id="kobo.91.1">nmap</span></code><span class="koboSpan" id="kobo.92.1"> to somewhat accurately detect the operating system of the target </span><a id="_idIndexMarker1057"/><span class="koboSpan" id="kobo.93.1">machine. </span><span class="koboSpan" id="kobo.93.2">Here’s how it looks when I scan a FreeBSD 14 machine:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.94.1">donnie@fedora:~$ sudo nmap -A 192.168.0.20
. </span><span class="koboSpan" id="kobo.94.2">. </span><span class="koboSpan" id="kobo.94.3">.
</span><span class="koboSpan" id="kobo.94.4">. </span><span class="koboSpan" id="kobo.94.5">. </span><span class="koboSpan" id="kobo.94.6">.
</span><span class="koboSpan" id="kobo.94.7">Device type: general purpose
Running: FreeBSD 12.X|13.X
OS CPE: cpe:/o:freebsd:freebsd:12 cpe:/o:freebsd:freebsd:13
OS details: FreeBSD 12.0-RELEASE - 13.0-CURRENT
Network Distance: 1 hop
Service Info: OS: FreeBSD; CPE: cpe:/o:freebsd:freebsd
Okay, that's cool. </span><span class="koboSpan" id="kobo.94.8">Let's now scan some ports.
</span><span class="koboSpan" id="kobo.94.9">. </span><span class="koboSpan" id="kobo.94.10">. </span><span class="koboSpan" id="kobo.94.11">.
</span><span class="koboSpan" id="kobo.94.12">. </span><span class="koboSpan" id="kobo.94.13">. </span><span class="koboSpan" id="kobo.94.14">.
</span><span class="koboSpan" id="kobo.94.15">donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.95.1">Okay, you see what I meant when I said that </span><code class="inlineCode"><span class="koboSpan" id="kobo.96.1">nmap</span></code><span class="koboSpan" id="kobo.97.1">'s operating system detection is </span><em class="italic"><span class="koboSpan" id="kobo.98.1">somewhat</span></em><span class="koboSpan" id="kobo.99.1"> accurate. </span><span class="koboSpan" id="kobo.99.2">The scan results show that I’m scanning a FreeBSD 12 or FreeBSD 13 machine, even though it’s really a FreeBSD 14 machine. </span><span class="koboSpan" id="kobo.99.3">But, FreeBSD 14 is still quite new, so it’s probable that the fingerprint for it hasn’t yet been added to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.100.1">nmap</span></code><span class="koboSpan" id="kobo.101.1"> database. </span><span class="koboSpan" id="kobo.101.2">On the positive side, at least this accurately tells us that it’s some sort of FreeBSD machine, instead of just telling us that it could be FreeBSD, Linux, or macOS.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.102.1">On the other hand, you might find times when our simple script works better. </span><span class="koboSpan" id="kobo.102.2">For example, look at what happens when I do an </span><code class="inlineCode"><span class="koboSpan" id="kobo.103.1">nmap -A</span></code><span class="koboSpan" id="kobo.104.1"> scan on an OpenIndiana machine:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.105.1">donnie@fedora:~$ sudo nmap -A 192.168.0.19
. </span><span class="koboSpan" id="kobo.105.2">. </span><span class="koboSpan" id="kobo.105.3">.
</span><span class="koboSpan" id="kobo.105.4">. </span><span class="koboSpan" id="kobo.105.5">. </span><span class="koboSpan" id="kobo.105.6">.
</span><span class="koboSpan" id="kobo.105.7">No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).
</span><span class="koboSpan" id="kobo.105.8">. </span><span class="koboSpan" id="kobo.105.9">. </span><span class="koboSpan" id="kobo.105.10">.
</span><span class="koboSpan" id="kobo.105.11">. </span><span class="koboSpan" id="kobo.105.12">. </span><span class="koboSpan" id="kobo.105.13">.
</span><span class="koboSpan" id="kobo.105.14">donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.106.1">As you saw earlier, our </span><a id="_idIndexMarker1058"/><span class="koboSpan" id="kobo.107.1">script correctly identified this machine as either a Solaris or OpenIndiana machine. </span><span class="koboSpan" id="kobo.107.2">But, </span><code class="inlineCode"><span class="koboSpan" id="kobo.108.1">nmap</span></code><span class="koboSpan" id="kobo.109.1"> can’t identify it at all.</span></p>
    <h2 id="_idParaDest-371" class="heading 2"><span class="koboSpan" id="kobo.110.1">A Simple Port-scanning Script</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.111.1">This is a </span><a id="_idIndexMarker1059"/><span class="koboSpan" id="kobo.112.1">cool little script that you can use to scan either local or remote machines for open network ports. </span><span class="koboSpan" id="kobo.112.2">If you’re new </span><a id="_idIndexMarker1060"/><span class="koboSpan" id="kobo.113.1">to network scanning, a network port can be in any one of three states. </span><span class="koboSpan" id="kobo.113.2">Here are the relevant definitions of those states:</span></p>
    <ul>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.114.1">open</span></code><span class="koboSpan" id="kobo.115.1">: An open port is one that has an associated network service running, and that is not blocked by a firewall. </span><span class="koboSpan" id="kobo.115.2">For example, you would expect to find Port 22 open on a server that has its Secure Shell service running, and Port 443 open on a webserver that’s using an encrypted connection. </span><span class="koboSpan" id="kobo.115.3">By observing which ports on a remote machine are open, you can tell which network services are running on that machine.</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.116.1">closed</span></code><span class="koboSpan" id="kobo.117.1">: A closed port is one that does not have an associated service running, and that is not blocked by a firewall.</span></li>
      <li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.118.1">filtered</span></code><span class="koboSpan" id="kobo.119.1">: A filtered port has been blocked by a firewall.</span></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.120.1">This script works by using the network capability that’s built into the GNU implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.121.1">bash</span></code><span class="koboSpan" id="kobo.122.1"> that comes on Linux and newer versions of macOS. </span><span class="koboSpan" id="kobo.122.2">It works by using either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.123.1">/dev/tcp</span></code><span class="koboSpan" id="kobo.124.1"> or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.125.1">/dev/udp</span></code><span class="koboSpan" id="kobo.126.1"> device on your Linux system. </span><span class="koboSpan" id="kobo.126.2">What’s crazy though, is that you won’t find either of these device files in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.127.1">/dev/</span></code><span class="koboSpan" id="kobo.128.1"> directory. </span><span class="koboSpan" id="kobo.128.2">That’s because they’re hard-coded into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.129.1">bash</span></code><span class="koboSpan" id="kobo.130.1"> executable. </span><span class="koboSpan" id="kobo.130.2">You can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.131.1">strings</span></code><span class="koboSpan" id="kobo.132.1"> utility to verify that, as you see here:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.133.1">donnie@fedora:~$ strings /bin/bash | grep tcp
/dev/tcp/*/*
donnie@fedora:~$ strings /bin/bash | grep udp
/dev/udp/*/*
donnie@fedora:~$
</span></code></pre>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.134.1">In case you’re wondering, </span><code class="inlineCode"><span class="koboSpan" id="kobo.135.1">strings</span></code><span class="koboSpan" id="kobo.136.1"> allows you to view text strings that are embedded into binary executable files. </span><span class="koboSpan" id="kobo.136.2">Also, be aware that this networking capability is only built into the GNU implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.137.1">bash</span></code><span class="koboSpan" id="kobo.138.1">, which means that you can run these commands on either Linux or a newer version of macOS, but not on other Unix/Unix-like distros such as FreeBSD or OpenIndiana.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.139.1">The</span><a id="_idIndexMarker1061"/><span class="koboSpan" id="kobo.140.1"> simplest way to illustrate this is </span><a id="_idIndexMarker1062"/><span class="koboSpan" id="kobo.141.1">to manually query a port that will provide feedback. </span><span class="koboSpan" id="kobo.141.2">Here, I’m querying Port 13 on a remote network time server:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.142.1">donnie@fedora:~$ cat &lt; /dev/tcp/time.nist.gov/13
60372 24-03-03 21:04:44 58 0 0 544.5 UTC(NIST) *
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.143.1">You’ll also get feedback from Port 22, the SSH port, as you see here:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.144.1">donnie@fedora:~$ cat &lt; /dev/tcp/192.168.0.20/22
SSH-2.0-OpenSSH_9.3 FreeBSD-20230719
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.145.1">This one takes a bit longer to complete, because it takes a while for the authentication timer on the target machine to time out.</span></p>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.146.1">In both of these examples, note how I’m using the input redirector (</span><code class="inlineCode"><span class="koboSpan" id="kobo.147.1">&lt;</span></code><span class="koboSpan" id="kobo.148.1">) to obtain input from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.149.1">/dev/tcp</span></code><span class="koboSpan" id="kobo.150.1"> device. </span><span class="koboSpan" id="kobo.150.2">Then, after the </span><code class="inlineCode"><span class="koboSpan" id="kobo.151.1">/dev/tcp/</span></code><span class="koboSpan" id="kobo.152.1"> part, I place the IP address of the target machine, and finally the port that I want to scan.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.153.1">Most ports won’t provide you with any kind of feedback. </span><span class="koboSpan" id="kobo.153.2">But, you can still tell if a port is open by how quickly the command executes. </span><span class="koboSpan" id="kobo.153.3">For example, if you query Port 53 on a DNS server, you should see that the command completes execution immediately, as you see here with the Google DNS server:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.154.1">donnie@fedora:~$ cat &lt; /dev/tcp/8.8.8.8/53
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.155.1">So, I know </span><a id="_idIndexMarker1063"/><span class="koboSpan" id="kobo.156.1">that Port 53 is open. </span><span class="koboSpan" id="kobo.156.2">But, if I query a port that isn’t open, such as Port 54 in this case, it will be a very long time </span><a id="_idIndexMarker1064"/><span class="koboSpan" id="kobo.157.1">before the command-prompt returns with an error message, as you see here:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.158.1">donnie@fedora:~$ cat &lt; /dev/tcp/8.8.8.8/54
bash: connect: Connection timed out
bash: /dev/tcp/8.8.8.8/54: Connection timed out
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.159.1">Now, let’s leverage this knowledge by creating the </span><code class="inlineCode"><span class="koboSpan" id="kobo.160.1">bash-portscan1.sh</span></code><span class="koboSpan" id="kobo.161.1"> script, like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.162.1">#!/bin/bash
host=$1
startport=$2
stopport=$3
ping=$(ping -c 1 $host | grep bytes | wc -l)
if [ "$ping" -gt 1 ]; then
  echo "$host is up";
else
  echo "$host is down. </span><span class="koboSpan" id="kobo.162.2">Quitting";
  exit
fi
for ((counter=$startport; counter&lt;=$stopport; counter++)); do
          (echo &gt;/dev/tcp/$host/$counter) &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo "Port $counter open"
done
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.163.1">It’s rather long, so I’ll break it down into sections. </span><span class="koboSpan" id="kobo.163.2">Here’s the top part:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.164.1">#!/bin/bash
host=$1
startport=$2
stopport=$3
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.165.1">To run this script, you’ll need to specify either the hostname or the IP address of the target machine, along with the range of ports that you want to scan. </span><span class="koboSpan" id="kobo.165.2">Easy enough so far, right? </span><span class="koboSpan" id="kobo.165.3">Next, we want to verify that the target machine is actually up, and create a </span><a id="_idIndexMarker1065"/><span class="koboSpan" id="kobo.166.1">variable assignment that we can use in the next step. </span><span class="koboSpan" id="kobo.166.2">Here’s how that looks:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.167.1">ping=$(ping -c 1 $host | grep bytes | wc -l)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.168.1">The value </span><a id="_idIndexMarker1066"/><span class="koboSpan" id="kobo.169.1">of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.170.1">ping</span></code><span class="koboSpan" id="kobo.171.1"> variable will be greater than 1, most likely 2, if the target machine is up and accessible. </span><span class="koboSpan" id="kobo.171.2">If the target machine isn’t accessible, the value will just be 1. </span><span class="koboSpan" id="kobo.171.3">To see how this works, run this from the command-line, leaving off the </span><code class="inlineCode"><span class="koboSpan" id="kobo.172.1">wc -l</span></code><span class="koboSpan" id="kobo.173.1"> part, like so:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.174.1">donnie@fedora:~$ ping -c1 192.168.0.20 | grep bytes
PING 192.168.0.20 (192.168.0.20) 56(84) bytes of data.
</span><span class="koboSpan" id="kobo.174.2">64 bytes from 192.168.0.20: icmp_seq=1 ttl=64 time=0.506 ms
donnie@fedora:~$ ping -c1 192.168.0.200 | grep bytes
PING 192.168.0.200 (192.168.0.200) 56(84) bytes of data.
</span><span class="koboSpan" id="kobo.174.3">donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.175.1">I first pinged a machine that’s up, and got two lines of output. </span><span class="koboSpan" id="kobo.175.2">I then pinged a fictitious machine, and only received one line of output. </span><span class="koboSpan" id="kobo.175.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.176.1">wc -l</span></code><span class="koboSpan" id="kobo.177.1"> command will count those lines and assign the appropriate value to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.178.1">ping</span></code><span class="koboSpan" id="kobo.179.1"> variable.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.180.1">Next, we have the </span><code class="inlineCode"><span class="koboSpan" id="kobo.181.1">if. </span><span class="koboSpan" id="kobo.181.2">.else</span></code><span class="koboSpan" id="kobo.182.1"> block that causes the script to exit if the target machine isn’t up. </span><span class="koboSpan" id="kobo.182.2">Here’s how that looks:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.183.1">if [ "$ping" -gt 1 ]; then
  echo "$host is up";
else
  echo "$host is down. </span><span class="koboSpan" id="kobo.183.2">Quitting";
  exit
fi
</span></code></pre>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.184.1">Note how I had to surround </span><code class="inlineCode"><span class="koboSpan" id="kobo.185.1">$ping</span></code><span class="koboSpan" id="kobo.186.1"> with a pair of double quotes. </span><span class="koboSpan" id="kobo.186.2">That’s because the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.187.1">ping</span></code><span class="koboSpan" id="kobo.188.1"> will contain blank spaces, non-alphanumeric characters, and might consist of more than one line. </span><span class="koboSpan" id="kobo.188.2">Without the double quotes, </span><code class="inlineCode"><span class="koboSpan" id="kobo.189.1">bash</span></code><span class="koboSpan" id="kobo.190.1"> won’t interpret the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.191.1">ping</span></code><span class="koboSpan" id="kobo.192.1"> correctly.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.193.1">Finally, we</span><a id="_idIndexMarker1067"/><span class="koboSpan" id="kobo.194.1"> have the </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">for</span></code><span class="koboSpan" id="kobo.196.1"> loop that does </span><a id="_idIndexMarker1068"/><span class="koboSpan" id="kobo.197.1">the actual port scan. </span><span class="koboSpan" id="kobo.197.2">Here’s how it looks:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.198.1">for ((counter=$startport; counter&lt;=$stopport; counter++)); do
          (echo &gt;/dev/tcp/$host/$counter) &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo "Port $counter open"
done
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.199.1">This starts by assigning the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.200.1">startport</span></code><span class="koboSpan" id="kobo.201.1"> variable to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.202.1">counter</span></code><span class="koboSpan" id="kobo.203.1"> variable. </span><span class="koboSpan" id="kobo.203.2">The loop will continue as long as the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.204.1">counter</span></code><span class="koboSpan" id="kobo.205.1"> is less than or equal to the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.206.1">stopport</span></code><span class="koboSpan" id="kobo.207.1">.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.208.1">Now, here’s how it looks when I run the script:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.209.1">donnie@fedora:~$ ./bash-portscan1.sh 192.168.0.20 20 22
192.168.0.20 is up
Port 22 open
donnie@fedora:~$ ./bash-portscan1.sh 8.8.8.8 53 53
8.8.8.8 is up
Port 53 open
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.210.1">In the first instance, I scanned a range of ports, beginning with Port 20 and ending with Port 22. </span><span class="koboSpan" id="kobo.210.2">Then, I scanned only Port 53 on the Google DNS server. </span></p>
    <p class="normal"><span class="koboSpan" id="kobo.211.1">So you see, this works fine with either local or remote targets.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.212.1">So far, we’ve only scanned TCP ports. </span><span class="koboSpan" id="kobo.212.2">But, you can also scan UDP ports by making one simple modification, as I’ve done in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.213.1">bash-portscan2.sh</span></code><span class="koboSpan" id="kobo.214.1"> script. </span><span class="koboSpan" id="kobo.214.2">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.215.1">for</span></code><span class="koboSpan" id="kobo.216.1"> loop, just change </span><code class="inlineCode"><span class="koboSpan" id="kobo.217.1">tcp</span></code><span class="koboSpan" id="kobo.218.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.219.1">udp</span></code><span class="koboSpan" id="kobo.220.1">, so that it will look like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.221.1">for ((counter=$startport; counter&lt;=$stopport; counter++)); do
          (echo &gt;/dev/udp/$host/$counter) &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo "Port $counter open"
done
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.222.1">Of course, you </span><a id="_idIndexMarker1069"/><span class="koboSpan" id="kobo.223.1">can fancy things up a bit more if you like. </span><span class="koboSpan" id="kobo.223.2">For example, you could combine the TCP and the UDP scan functions together into one script, and have some sort of </span><a id="_idIndexMarker1070"/><span class="koboSpan" id="kobo.224.1">menu that allows you to choose the one you want to do. </span><span class="koboSpan" id="kobo.224.2">Heck, for that matter, you could even add a </span><code class="inlineCode"><span class="koboSpan" id="kobo.225.1">yad</span></code><span class="koboSpan" id="kobo.226.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.227.1">dialog</span></code><span class="koboSpan" id="kobo.228.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.229.1">xdialog</span></code><span class="koboSpan" id="kobo.230.1"> interface. </span><span class="koboSpan" id="kobo.230.2">(I’ve shown you the techniques for all this in </span><em class="chapterRef"><span class="koboSpan" id="kobo.231.1">Chapter 16, Creating User Interfaces with yad, dialog, and xdialog</span></em><span class="koboSpan" id="kobo.232.1">.)</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.233.1">Now, you can get more detailed information about your target by using </span><code class="inlineCode"><span class="koboSpan" id="kobo.234.1">nmap</span></code><span class="koboSpan" id="kobo.235.1"> to perform the scan, which would look something like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.236.1">donnie@fedora:~$ sudo nmap -sS 192.168.0.20
Starting Nmap 7.93 ( https://nmap.org ) at 2024-03-03 17:12 EST
Nmap scan report for 192.168.0.20
Host is up (0.00044s latency).
</span><span class="koboSpan" id="kobo.236.2">Not shown: 999 closed tcp ports (reset)
PORT   STATE SERVICE
22/tcp open  ssh
MAC Address: 08:00:27:45:A4:75 (Oracle VirtualBox virtual NIC)
Nmap done: 1 IP address (1 host up) scanned in 6.01 seconds
donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.237.1">This </span><code class="inlineCode"><span class="koboSpan" id="kobo.238.1">-sS</span></code><span class="koboSpan" id="kobo.239.1"> type of scan, which is known as a SYN packet scan, requires </span><code class="inlineCode"><span class="koboSpan" id="kobo.240.1">sudo</span></code><span class="koboSpan" id="kobo.241.1"> privileges. </span><span class="koboSpan" id="kobo.241.2">However, you can also do a </span><code class="inlineCode"><span class="koboSpan" id="kobo.242.1">-sT</span></code><span class="koboSpan" id="kobo.243.1"> type of scan, which doesn’t require </span><code class="inlineCode"><span class="koboSpan" id="kobo.244.1">sudo</span></code><span class="koboSpan" id="kobo.245.1"> privileges. </span><span class="koboSpan" id="kobo.245.2">Scanning open ports with our homemade script runs almost instantaneously. </span><span class="koboSpan" id="kobo.245.3">But scanning closed or filtered ports can be, but not always, faster with </span><code class="inlineCode"><span class="koboSpan" id="kobo.246.1">nmap</span></code><span class="koboSpan" id="kobo.247.1">. </span><span class="koboSpan" id="kobo.247.2">Still though, there is one possible advantage for using our script. </span><span class="koboSpan" id="kobo.247.3">It’s just that certain types of </span><code class="inlineCode"><span class="koboSpan" id="kobo.248.1">nmap</span></code><span class="koboSpan" id="kobo.249.1"> scans can be blocked by adding a few rules to the target machine’s firewall. </span><span class="koboSpan" id="kobo.249.2">So, if you try to run an </span><code class="inlineCode"><span class="koboSpan" id="kobo.250.1">nmap</span></code><span class="koboSpan" id="kobo.251.1"> scan against a machine and get no results, you might try using the script, instead. </span><span class="koboSpan" id="kobo.251.2">On the other hand, scanning open ports with the script can be a bit less stealthy, because it will leave tell-tale messages in the target machine’s system log files. </span><span class="koboSpan" id="kobo.251.3">For example, here’s the set of messages that resulted from using the script to scan Port 22 on an AlmaLinux 9 machine:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.252.1">Mar  6 13:25:20 localhost sshd[1601]: error: kex_exchange_identification: client sent invalid protocol identifier ""
Mar  6 13:25:20 localhost sshd[1601]: error: send_error: write: Broken pipe
Mar  6 13:25:20 localhost sshd[1601]: banner exchange: Connection from 192.168.0.16 port 38680: invalid format
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.253.1">Using the </span><a id="_idIndexMarker1071"/><span class="koboSpan" id="kobo.254.1">script to scan other open ports will create similar messages, while scanning closed ports won’t create any messages</span><a id="_idIndexMarker1072"/><span class="koboSpan" id="kobo.255.1"> at all. </span><span class="koboSpan" id="kobo.255.2">If you use the script to scan an open webserver port, such as Port 80 or Port 443, you’ll instead see messages like this one in the webserver’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.256.1">access_log</span></code><span class="koboSpan" id="kobo.257.1"> file:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.258.1">192.168.0.16 - - [06/Mar/2024:13:38:49 -0500] "\n" 400 226 "-" "-"
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.259.1">But, </span><code class="inlineCode"><span class="koboSpan" id="kobo.260.1">nmap</span></code><span class="koboSpan" id="kobo.261.1"> won’t create any messages like these unless the target machine’s firewall is configured to log packets that come from </span><code class="inlineCode"><span class="koboSpan" id="kobo.262.1">nmap</span></code><span class="koboSpan" id="kobo.263.1"> scans. </span><span class="koboSpan" id="kobo.263.2">So, there are advantages and disadvantages for both approaches.</span></p>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.264.1">On Red Hat-type machines, such as AlmaLinux, Rocky Linux, and RHEL, these messages will show up in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.265.1">/var/log/secure</span></code><span class="koboSpan" id="kobo.266.1"> file. </span><span class="koboSpan" id="kobo.266.2">On other distros, these messages might show up in either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.267.1">/var/log/messages</span></code><span class="koboSpan" id="kobo.268.1"> file or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.269.1">/var/log/syslog</span></code><span class="koboSpan" id="kobo.270.1"> file. </span><span class="koboSpan" id="kobo.270.2">Some Linux distros, such as Debian, no longer create any of these files by default. </span><span class="koboSpan" id="kobo.270.3">For them, you’ll need to either use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.271.1">sudo journalctl</span></code><span class="koboSpan" id="kobo.272.1"> command to view the messages, or install the </span><code class="inlineCode"><span class="koboSpan" id="kobo.273.1">rsyslog</span></code><span class="koboSpan" id="kobo.274.1"> package from the normal distro repository so that you can have the normal text-mode log files..</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.275.1">Now, let’s do something a bit more complex.</span></p>
    <h2 id="_idParaDest-372" class="heading 2"><span class="koboSpan" id="kobo.276.1">Auditing the root User Account</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.277.1">Since I’m a </span><a id="_idIndexMarker1073"/><span class="koboSpan" id="kobo.278.1">security geek, I always advocate setting up Linux and Unix systems with the root user account disabled. </span><span class="koboSpan" id="kobo.278.2">That’s easy to do on many modern Linux systems, because you can configure </span><a id="_idIndexMarker1074"/><span class="koboSpan" id="kobo.279.1">things properly in the system installer. </span><span class="koboSpan" id="kobo.279.2">In fact, the Ubuntu installer won’t even let you enable the root user account, and will just automatically add the account that you created for yourself to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.280.1">sudo</span></code><span class="koboSpan" id="kobo.281.1"> group. </span><span class="koboSpan" id="kobo.281.2">(You can enable the root user account after you’ve installed the operating system, even though that’s not recommended practice.) For other Linux distros, such as Debian, Fedora, or members of the RHEL family, enabling the root user account during installation is optional. </span><span class="koboSpan" id="kobo.281.3">On most Unix-like systems such as FreeBSD and OpenIndiana, the installer will assign a password to the root user account. </span><span class="koboSpan" id="kobo.281.4">On FreeBSD, after installation has been completed, you’ll have to manually install </span><code class="inlineCode"><span class="koboSpan" id="kobo.282.1">sudo</span></code><span class="koboSpan" id="kobo.283.1">, set up a normal user account to use it, and then disable the root user account. </span><span class="koboSpan" id="kobo.283.2">On OpenIndiana, the normal user you create when you install the operating system will already be configured to have full </span><code class="inlineCode"><span class="koboSpan" id="kobo.284.1">sudo</span></code><span class="koboSpan" id="kobo.285.1"> privileges, and the root account will also be enabled.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.286.1">So now, you want an easy way to audit your systems to see if the root user on them is enabled. </span><span class="koboSpan" id="kobo.286.2">Let’s begin by setting up a script that works equally well on either Linux or OpenIndiana systems.</span></p>
    <h3 id="_idParaDest-373" class="heading 3"><span class="koboSpan" id="kobo.287.1">Creating the root Account Auditing Script for Linux and OpenIndiana</span></h3>
    <p class="normal"><span class="koboSpan" id="kobo.288.1">We’ll</span><a id="_idIndexMarker1075"/><span class="koboSpan" id="kobo.289.1"> begin with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">rootlock_1.sh</span></code><span class="koboSpan" id="kobo.291.1"> script, which you can download from the Github repository. </span><span class="koboSpan" id="kobo.291.2">This is another one of those scripts that’s too long to show here in its entirety. </span><span class="koboSpan" id="kobo.291.3">That’s okay though, because it’s easier to explain if I break it down into sections.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.292.1">The first thing I want to do is to initialize a couple of variables, like so:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.293.1">#!/bin/bash
os=$(uname)
quantity=$(cut -f3 -d: /etc/passwd | grep -w 0 | wc -l)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.294.1">OpenIndiana and most Linux systems come with </span><code class="inlineCode"><span class="koboSpan" id="kobo.295.1">bash</span></code><span class="koboSpan" id="kobo.296.1"> installed by default, and both use the same shadow file system. </span><span class="koboSpan" id="kobo.296.2">So, the same exact script works for either one. </span><span class="koboSpan" id="kobo.296.3">Eventually though, I might want to modify it so that it will run on some of the BSD-type</span><a id="_idIndexMarker1076"/><span class="koboSpan" id="kobo.297.1"> operating systems, which are set up differently. </span><span class="koboSpan" id="kobo.297.2">To prepare for that, I’ll use the output of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.298.1">uname</span></code><span class="koboSpan" id="kobo.299.1"> command as the value for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">os</span></code><span class="koboSpan" id="kobo.301.1"> variable, so that I can ensure that the correct code will always run on each operating system. </span><span class="koboSpan" id="kobo.301.2">I also want to know how many user accounts there are that have an assigned UID value of 0, so I’ll create the </span><code class="inlineCode"><span class="koboSpan" id="kobo.302.1">quantity</span></code><span class="koboSpan" id="kobo.303.1"> variable to keep track of that. </span><span class="koboSpan" id="kobo.303.2">To obtain that value, I need to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.304.1">cut -f3 -d:</span></code><span class="koboSpan" id="kobo.305.1"> command to look at the third field of each </span><code class="inlineCode"><span class="koboSpan" id="kobo.306.1">passwd</span></code><span class="koboSpan" id="kobo.307.1"> file entry, and then pipe that into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.308.1">grep -w 0</span></code><span class="koboSpan" id="kobo.309.1"> command to only find the lines that contain nothing but a 0 in that field. </span><span class="koboSpan" id="kobo.309.2">Finally, I use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.310.1">wc -l</span></code><span class="koboSpan" id="kobo.311.1"> command to count the number of lines that match this criterion.</span></p>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.312.1">Remember that the UID value of 0 is what gives user accounts full root user privileges. </span><span class="koboSpan" id="kobo.312.2">On most operating systems, you should never see more than one UID 0 user account. </span><span class="koboSpan" id="kobo.312.3">On some BSD-type systems, you’ll see either two or three UID 0 accounts. </span><span class="koboSpan" id="kobo.312.4">One will be the root account, which might have either </span><code class="inlineCode"><span class="koboSpan" id="kobo.313.1">csh</span></code><span class="koboSpan" id="kobo.314.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.315.1">sh</span></code><span class="koboSpan" id="kobo.316.1"> assigned as the default shell. </span><span class="koboSpan" id="kobo.316.2">A second one will be the toor account, which will have </span><code class="inlineCode"><span class="koboSpan" id="kobo.317.1">sh</span></code><span class="koboSpan" id="kobo.318.1"> assigned as the default shell. </span><span class="koboSpan" id="kobo.318.2">DragonflyBSD has a third UID 0 account which is called, installer. </span><span class="koboSpan" id="kobo.318.3">So, if you want to write one script that will cover all of these different operating systems, you’ll need to write code that will account for each one having a different number of UID 0 accounts. </span><span class="koboSpan" id="kobo.318.4">(We’ll look at all that later in this section.)</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.319.1">Next, I’ve created the </span><code class="inlineCode"><span class="koboSpan" id="kobo.320.1">linux_sunos</span></code><span class="koboSpan" id="kobo.321.1"> function, which contains the bulk of the working code. </span><span class="koboSpan" id="kobo.321.2">Here’s how it looks:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.322.1">linux_sunos() {
        if [ $quantity -gt 1 ] ; then
                echo "CRITICAL.  </span><span class="koboSpan" id="kobo.322.2">There are $quantity accounts with UID 0."
        </span><span class="koboSpan" id="kobo.322.3">else
                echo "OKAY.  </span><span class="koboSpan" id="kobo.322.4">There is only one account with UID 0."
        </span><span class="koboSpan" id="kobo.322.5">fi 
        echo
        echo
        rootlock=$(awk 'BEGIN {FS=":"}; /root/ {print $2}' /etc/shadow | cut -c1)
        if [ "$rootlock" == $ ] ; then
                echo "CRITICAL!!  </span><span class="koboSpan" id="kobo.322.6">The root account is not locked out."
        </span><span class="koboSpan" id="kobo.322.7">else
                echo "The root account is locked out, as it should be."
        </span><span class="koboSpan" id="kobo.322.8">fi 
}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.323.1">The top </span><a id="_idIndexMarker1077"/><span class="koboSpan" id="kobo.324.1">part is easy. </span><span class="koboSpan" id="kobo.324.2">It’s just an </span><code class="inlineCode"><span class="koboSpan" id="kobo.325.1">if. </span><span class="koboSpan" id="kobo.325.2">.then. </span><span class="koboSpan" id="kobo.325.3">.else</span></code><span class="koboSpan" id="kobo.326.1"> construct that alerts you if there are more than one UID 0 accounts in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">/etc/passwd</span></code><span class="koboSpan" id="kobo.328.1"> file.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.329.1">Next, I use an </span><code class="inlineCode"><span class="koboSpan" id="kobo.330.1">awk</span></code><span class="koboSpan" id="kobo.331.1"> command, with its output piped into </span><code class="inlineCode"><span class="koboSpan" id="kobo.332.1">cut -c1</span></code><span class="koboSpan" id="kobo.333.1">, to find the root user account line in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.334.1">/etc/shadow</span></code><span class="koboSpan" id="kobo.335.1"> file, and to isolate the value of the first character of the second field of that line. </span><span class="koboSpan" id="kobo.335.2">That value will be assigned to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.336.1">rootlock</span></code><span class="koboSpan" id="kobo.337.1"> variable. </span><span class="koboSpan" id="kobo.337.2">So, what is so significant about that character? </span><span class="koboSpan" id="kobo.337.3">Well, here’s the deal.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.338.1">On Linux, Unix, and Unix-like systems, a list of user accounts is kept in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.339.1">/etc/passwd</span></code><span class="koboSpan" id="kobo.340.1"> file. </span><span class="koboSpan" id="kobo.340.2">This file must always be world-readable, so that users can access their user account information when they log in. </span><span class="koboSpan" id="kobo.340.3">Many years ago, when I was young and still had a full head of hair, user passwords were also kept in this </span><code class="inlineCode"><span class="koboSpan" id="kobo.341.1">passwd</span></code><span class="koboSpan" id="kobo.342.1"> file. </span><span class="koboSpan" id="kobo.342.2">Eventually, someone figured out that keeping passwords in a world-readable file is a security problem, and invented</span><a id="_idIndexMarker1078"/><span class="koboSpan" id="kobo.343.1"> the </span><strong class="keyWord"><span class="koboSpan" id="kobo.344.1">shadow file system</span></strong><span class="koboSpan" id="kobo.345.1">. </span><span class="koboSpan" id="kobo.345.2">Now, the hashed values of all users’ passwords are in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.346.1">/etc/shadow</span></code><span class="koboSpan" id="kobo.347.1"> file on Linux and Solaris/OpenIndiana systems, which requires root privileges to read. </span><span class="koboSpan" id="kobo.347.2">(It’s a bit different on BSD-type systems, as I’ll show you in just a bit.) For example, here’s the entry for my own user account on my Fedora Server virtual machine:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.348.1">donnie:$y$j9T$PfB847h88/LNURBaDxBbWdYI$bRXbrMUrTM7JwWifuDfjt6oFl0FFdYEzcwJHF5r/kG5::0:99999:7:::
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.349.1">(Note that this is one long line that wraps around on the printed page. </span><span class="koboSpan" id="kobo.349.2">Also note that I changed a couple of characters, to prevent revealing the real hash value.)</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.350.1">What I </span><a id="_idIndexMarker1079"/><span class="koboSpan" id="kobo.351.1">want you to note is the prefix of this hashed value, which is </span><code class="inlineCode"><span class="koboSpan" id="kobo.352.1">$y$</span></code><span class="koboSpan" id="kobo.353.1">. </span><span class="koboSpan" id="kobo.353.2">The leading </span><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">$</span></code><span class="koboSpan" id="kobo.355.1"> indicates that this account is enabled, and the whole </span><code class="inlineCode"><span class="koboSpan" id="kobo.356.1">$y$</span></code><span class="koboSpan" id="kobo.357.1"> thing indicates that the password was </span><a id="_idIndexMarker1080"/><span class="koboSpan" id="kobo.358.1">hashed by the </span><strong class="keyWord"><span class="koboSpan" id="kobo.359.1">yescrypt</span></strong><span class="koboSpan" id="kobo.360.1"> hashing algorithm.</span></p>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.361.1">Since Fedora is a cutting-edge, somewhat experimental Linux distro, you can expect it to use new technologies that aren’t yet widely used by the rest of the Linux ecosystem. </span><span class="koboSpan" id="kobo.361.2">Such is the case here with Fedora’s use of yescrypt. </span><span class="koboSpan" id="kobo.361.3">On most modern Linux distros, you’ll see a </span><code class="inlineCode"><span class="koboSpan" id="kobo.362.1">$6$</span></code><span class="koboSpan" id="kobo.363.1"> prefix on the password hash, which indicates that they’re using the SHA512 hashing algorithm. </span><span class="koboSpan" id="kobo.363.2">Although SHA512 hashes are very difficult to crack, yescrypt hashes are supposed to be even more difficult, which enhances password security.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.364.1">For our present purposes, it doesn’t matter which hashing algorithm is in use. </span><span class="koboSpan" id="kobo.364.2">All we care about is that leading </span><code class="inlineCode"><span class="koboSpan" id="kobo.365.1">$</span></code><span class="koboSpan" id="kobo.366.1">, because that’s what tells us that the account is enabled. </span><span class="koboSpan" id="kobo.366.2">If anything other than a </span><code class="inlineCode"><span class="koboSpan" id="kobo.367.1">$</span></code><span class="koboSpan" id="kobo.368.1"> is in that first position, then the account is disabled. </span><span class="koboSpan" id="kobo.368.2">For best security, you want to see something like any of these three lines in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.369.1">/etc/shadow</span></code><span class="koboSpan" id="kobo.370.1"> file:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.371.1">root:!::0:99999:7:::
root:*::0:99999:7:::
root:*LK*::0:99999:7:::
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.372.1">Now, here’s the sort of thing that you don’t want to see:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.373.1">root:$y$j9T$TZqIDctm8w7ESbopARa5f1$RKjMWhZ9zS4KZ5dPvSODo2nAIH4s8GwZTA4TJNnoh3B:19 844:0:99999:7:::
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.374.1">On this virtual machine, the root account is enabled, as indicated by the leading </span><code class="inlineCode"><span class="koboSpan" id="kobo.375.1">$</span></code><span class="koboSpan" id="kobo.376.1">. </span><span class="koboSpan" id="kobo.376.2">And, this takes us back to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.377.1">linux_sunos</span></code><span class="koboSpan" id="kobo.378.1"> function in our script. </span><span class="koboSpan" id="kobo.378.2">Let’s take another look at the line that creates the </span><code class="inlineCode"><span class="koboSpan" id="kobo.379.1">rootlock</span></code><span class="koboSpan" id="kobo.380.1"> variable:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.381.1">rootlock=$(awk 'BEGIN {FS=":"}; /root/ {print $2}' /etc/shadow | cut -c1)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.382.1">As I pointed </span><a id="_idIndexMarker1081"/><span class="koboSpan" id="kobo.383.1">out before, this </span><code class="inlineCode"><span class="koboSpan" id="kobo.384.1">awk</span></code><span class="koboSpan" id="kobo.385.1"> command isolates the second field of the root user’s entry, which is the password field. </span><span class="koboSpan" id="kobo.385.2">Piping the </span><code class="inlineCode"><span class="koboSpan" id="kobo.386.1">awk</span></code><span class="koboSpan" id="kobo.387.1"> output into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.388.1">cut -c1</span></code><span class="koboSpan" id="kobo.389.1"> command isolates the first character of that field. </span><span class="koboSpan" id="kobo.389.2">The value of that character is then assigned as the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.390.1">rootlock</span></code><span class="koboSpan" id="kobo.391.1"> variable.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.392.1">Next up is the code that determines whether or not the root user account is locked:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.393.1">if [ "$rootlock" == '$' ] ; then
                echo "CRITICAL!!  </span><span class="koboSpan" id="kobo.393.2">The root account is not locked out."
        </span><span class="koboSpan" id="kobo.393.3">else
                echo "The root account is locked out, as it should be."
        </span><span class="koboSpan" id="kobo.393.4">fi
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.394.1">This says that if the first character of the second field of the root user’s entry is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.395.1">$</span></code><span class="koboSpan" id="kobo.396.1">, then the account is not locked. </span><span class="koboSpan" id="kobo.396.2">If that first character is anything other than a </span><code class="inlineCode"><span class="koboSpan" id="kobo.397.1">$</span></code><span class="koboSpan" id="kobo.398.1">, then the account is locked, and all is good.</span></p>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.399.1">Note that in this </span><code class="inlineCode"><span class="koboSpan" id="kobo.400.1">if. </span><span class="koboSpan" id="kobo.400.2">.then. </span><span class="koboSpan" id="kobo.400.3">.else</span></code><span class="koboSpan" id="kobo.401.1"> construct I had to surround </span><code class="inlineCode"><span class="koboSpan" id="kobo.402.1">$rootlock</span></code><span class="koboSpan" id="kobo.403.1"> with a pair of double quotes. </span><span class="koboSpan" id="kobo.403.2">That’s because on some Linux distros, such as Ubuntu, you might see an </span><code class="inlineCode"><span class="koboSpan" id="kobo.404.1">*</span></code><span class="koboSpan" id="kobo.405.1"> in the password field of the root user’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.406.1">shadow</span></code><span class="koboSpan" id="kobo.407.1"> file entry. </span><span class="koboSpan" id="kobo.407.2">Without the double quotes, the shell will interpret the </span><code class="inlineCode"><span class="koboSpan" id="kobo.408.1">*</span></code><span class="koboSpan" id="kobo.409.1"> as a wildcard, and will cause </span><code class="inlineCode"><span class="koboSpan" id="kobo.410.1">$rootlock</span></code><span class="koboSpan" id="kobo.411.1"> to return the list of files in the current working directory. </span><span class="koboSpan" id="kobo.411.2">Using the double quotes allows the </span><code class="inlineCode"><span class="koboSpan" id="kobo.412.1">$</span></code><span class="koboSpan" id="kobo.413.1"> to do its job, while forcing the shell to interpret the </span><code class="inlineCode"><span class="koboSpan" id="kobo.414.1">*</span></code><span class="koboSpan" id="kobo.415.1"> in a literal manner.</span></p>
      <p class="normal"><span class="koboSpan" id="kobo.416.1">For good measure, I also surrounded the </span><code class="inlineCode"><span class="koboSpan" id="kobo.417.1">$</span></code><span class="koboSpan" id="kobo.418.1"> with a pair of single quotes, to ensure that that the shell would interpret it correctly. </span><span class="koboSpan" id="kobo.418.2">(It actually worked fine when I tested it without the single quotes, but it’s better to be safe.)</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.419.1">Now, at the </span><a id="_idIndexMarker1082"/><span class="koboSpan" id="kobo.420.1">very end of the script, after the function, you see this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.421.1">if [ $os == Linux ] || [ $os == SunOS ] ; then
        linux_sunos
else
        echo "I don't know this operating system."
</span><span class="koboSpan" id="kobo.421.2">fi
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.422.1">The value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.423.1">os</span></code><span class="koboSpan" id="kobo.424.1"> variable should be </span><code class="inlineCode"><span class="koboSpan" id="kobo.425.1">Linux</span></code><span class="koboSpan" id="kobo.426.1"> on a Linux system, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.427.1">SunOS</span></code><span class="koboSpan" id="kobo.428.1"> on an OpenIndiana system. </span><span class="koboSpan" id="kobo.428.2">Either way, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.429.1">linux_sunos</span></code><span class="koboSpan" id="kobo.430.1"> function will run. </span><span class="koboSpan" id="kobo.430.2">If the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.431.1">os</span></code><span class="koboSpan" id="kobo.432.1"> is anything else, the user will see an error message.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.433.1">Finally, let’s test this script to see what happens. </span><span class="koboSpan" id="kobo.433.2">Here’s what it looks like on the Fedora workstation that I’m using to write this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.434.1">donnie@fedora:~$ sudo ./rootlock_1.sh
[sudo] password for donnie:
OKAY.  </span><span class="koboSpan" id="kobo.434.2">There is only one account with UID 0.
</span><span class="koboSpan" id="kobo.434.3">The root account is locked out, as it should be.
</span><span class="koboSpan" id="kobo.434.4">donnie@fedora:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.435.1">Very cool, it all looks good.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.436.1">To see how it looks when the root account is enabled, I pulled up my Fedora Server virtual machine, which has never had the root account enabled. </span><span class="koboSpan" id="kobo.436.2">I enabled the root account like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.437.1">donnie@fedora-server:~$ sudo passwd root
Changing password for user root.
</span><span class="koboSpan" id="kobo.437.2">New password:
Retype new password:
passwd: all authentication tokens updated successfully.
</span><span class="koboSpan" id="kobo.437.3">donnie@fedora-server:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.438.1">Easy, right? </span><span class="koboSpan" id="kobo.438.2">All I had to do was to assign a password to the root user account. </span><span class="koboSpan" id="kobo.438.3">Now, let’s run the script:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.439.1">donnie@fedora-server:~$ sudo ./rootlock_1.sh
OKAY.  </span><span class="koboSpan" id="kobo.439.2">There is only one account with UID 0.
</span><span class="koboSpan" id="kobo.439.3">CRITICAL!!  </span><span class="koboSpan" id="kobo.439.4">The root account is not locked out.
</span><span class="koboSpan" id="kobo.439.5">donnie@fedora-server:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.440.1">Now, let’s </span><a id="_idIndexMarker1083"/><span class="koboSpan" id="kobo.441.1">add the option to disable the root account, as you see in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.442.1">rootlock_2.sh</span></code><span class="koboSpan" id="kobo.443.1"> script. </span><span class="koboSpan" id="kobo.443.2">We’ll do that by embedding another </span><code class="inlineCode"><span class="koboSpan" id="kobo.444.1">if. </span><span class="koboSpan" id="kobo.444.2">.then. </span><span class="koboSpan" id="kobo.444.3">.else</span></code><span class="koboSpan" id="kobo.445.1"> construct within the one that’s already there. </span><span class="koboSpan" id="kobo.445.2">Here’s how it looks:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.446.1">if [ $rootlock == $ ] ; then
                echo "CRITICAL!!  </span><span class="koboSpan" id="kobo.446.2">The root account is not locked out."
                </span><span class="koboSpan" id="kobo.446.3">echo "Do you want to disable the root account? </span><span class="koboSpan" id="kobo.446.4">(y/n)"
                read answer
                if [ $answer == y ] ; then
                        passwd -l root
                else
                        exit
                fi
        else
                echo "The root account is locked out, as it should be."
        </span><span class="koboSpan" id="kobo.446.5">fi
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.447.1">Here’s how running the modified script looks:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.448.1">donnie@fedora-server:~$ sudo ./rootlock_2.sh
OKAY.  </span><span class="koboSpan" id="kobo.448.2">There is only one account with UID 0.
</span><span class="koboSpan" id="kobo.448.3">CRITICAL!!  </span><span class="koboSpan" id="kobo.448.4">The root account is not locked out.
</span><span class="koboSpan" id="kobo.448.5">Do you want to disable the root account? </span><span class="koboSpan" id="kobo.448.6">(y/n)
y
Locking password for user root.
</span><span class="koboSpan" id="kobo.448.7">passwd: Success
donnie@fedora-server:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.449.1">To disable an account, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.450.1">passwd -l</span></code><span class="koboSpan" id="kobo.451.1"> command places a pair of exclamation points in front of the password hash, like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.452.1">root:!!$y$j9T$ckYOQzoMU0mr9gQkjqz/K0$QDNV0unG1XAfBwViY.7a6JR8VaMpIGObGzXIN0vxGQA:19847:0:99999:7:::
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.453.1">The </span><a id="_idIndexMarker1084"/><span class="koboSpan" id="kobo.454.1">password hash is still there, but the operating system can no longer read it. </span><span class="koboSpan" id="kobo.454.2">This will allow you to unlock the account by running:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.455.1">donnie@fedora-server:~$ sudo passwd -u root
[sudo] password for donnie:
Unlocking password for user root.
</span><span class="koboSpan" id="kobo.455.2">passwd: Success
donnie@fedora-server:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.456.1">To both delete the password and disable the account, place a </span><code class="inlineCode"><span class="koboSpan" id="kobo.457.1">passwd -d root</span></code><span class="koboSpan" id="kobo.458.1"> command on the line before the </span><code class="inlineCode"><span class="koboSpan" id="kobo.459.1">passwd -l root</span></code><span class="koboSpan" id="kobo.460.1"> command, so that the construct will now look like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.461.1">if [ $rootlock == $ ] ; then
                echo "CRITICAL!!  </span><span class="koboSpan" id="kobo.461.2">The root account is not locked out."
                </span><span class="koboSpan" id="kobo.461.3">echo "Do you want to disable the root account? </span><span class="koboSpan" id="kobo.461.4">(y/n)"
                read answer
                if [ $answer == y ] ; then
                        passwd -d root
                        passwd -l root
                else
                        exit
                fi
        else
                echo "The root account is locked out, as it should be."
        </span><span class="koboSpan" id="kobo.461.5">fi
</span></code></pre>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.462.1">Note that you can’t use both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.463.1">-l</span></code><span class="koboSpan" id="kobo.464.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.465.1">-d</span></code><span class="koboSpan" id="kobo.466.1"> options for </span><code class="inlineCode"><span class="koboSpan" id="kobo.467.1">passwd</span></code><span class="koboSpan" id="kobo.468.1"> in a single command. </span><span class="koboSpan" id="kobo.468.2">To use both options, you’ll need to run two separate commands. </span><span class="koboSpan" id="kobo.468.3">Also note that if you just use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.469.1">-d</span></code><span class="koboSpan" id="kobo.470.1"> option, you’ll delete the password hash but the account is still considered as enabled. </span><span class="koboSpan" id="kobo.470.2">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.471.1">passwd -l</span></code><span class="koboSpan" id="kobo.472.1"> after running </span><code class="inlineCode"><span class="koboSpan" id="kobo.473.1">passwd -d</span></code><span class="koboSpan" id="kobo.474.1"> will both delete the password hash and disable the account.</span></p>
      <p class="normal"><span class="koboSpan" id="kobo.475.1">And, although you probably already know this, I’ll tell you anyway. </span><span class="koboSpan" id="kobo.475.2">Before you disable the root user account, be darned sure that you’re logged in as a normal user with full </span><code class="inlineCode"><span class="koboSpan" id="kobo.476.1">sudo</span></code><span class="koboSpan" id="kobo.477.1"> privileges, instead of as the root user. </span><span class="koboSpan" id="kobo.477.2">That way, there will be no chance of accidentally disabling the root account on a machine for which nobody else has any admin privileges.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.478.1">The only</span><a id="_idIndexMarker1085"/><span class="koboSpan" id="kobo.479.1"> way to re-enable root’s account now is to create a new password, as you’ve already seen.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.480.1">That covers it for Linux and OpenIndiana. </span><span class="koboSpan" id="kobo.480.2">Let’s see if we can make this work on FreeBSD.</span></p>
    <h3 id="_idParaDest-374" class="heading 3"><span class="koboSpan" id="kobo.481.1">Modifying the root Account Auditing Script for Use on FreeBSD</span></h3>
    <p class="normal"><span class="koboSpan" id="kobo.482.1">On </span><a id="_idIndexMarker1086"/><span class="koboSpan" id="kobo.483.1">BSD-type operating systems, such as FreeBSD, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.484.1">/etc/master.passwd</span></code><span class="koboSpan" id="kobo.485.1"> file is used instead of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.486.1">/etc/shadow</span></code><span class="koboSpan" id="kobo.487.1"> file. </span><span class="koboSpan" id="kobo.487.2">In addition to the UID 0 root user account in the</span><code class="inlineCode"><span class="koboSpan" id="kobo.488.1"> /etc/passwd</span></code><span class="koboSpan" id="kobo.489.1"> file, there’s the toor user account, which is also a UID 0 account. </span><span class="koboSpan" id="kobo.489.2">So, we’ll need to add a </span><code class="inlineCode"><span class="koboSpan" id="kobo.490.1">freebsd</span></code><span class="koboSpan" id="kobo.491.1"> function to work with these differences.</span></p>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.492.1">Up through FreeBSD 13, the root user account has </span><code class="inlineCode"><span class="koboSpan" id="kobo.493.1">csh</span></code><span class="koboSpan" id="kobo.494.1"> assigned as its default shell, and the toor account has </span><code class="inlineCode"><span class="koboSpan" id="kobo.495.1">sh</span></code><span class="koboSpan" id="kobo.496.1"> assigned as the default shell. </span><span class="koboSpan" id="kobo.496.2">Now, on FreeBSD 14, both of these UID 0 accounts have </span><code class="inlineCode"><span class="koboSpan" id="kobo.497.1">sh</span></code><span class="koboSpan" id="kobo.498.1"> as the default shell.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.499.1">The simplest way to do this is to add a new function, which I’ll call </span><code class="inlineCode"><span class="koboSpan" id="kobo.500.1">freebsd</span></code><span class="koboSpan" id="kobo.501.1">. </span><span class="koboSpan" id="kobo.501.2">(Really, what else would I call it?) You’ll find this new function in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">rootlock_3.sh</span></code><span class="koboSpan" id="kobo.503.1"> script that’s in the Github repository. </span><span class="koboSpan" id="kobo.503.2">Let’s break this new function into sections to see what we have. </span><span class="koboSpan" id="kobo.503.3">Here’s the top part:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.504.1">freebsd() {
        if [ $quantity -gt 2 ]
        then
                echo "CRITICAL.  </span><span class="koboSpan" id="kobo.504.2">There are $quantity accounts in the passwd file with UID 0."
        </span><span class="koboSpan" id="kobo.504.3">else
                echo "OKAY.  </span><span class="koboSpan" id="kobo.504.4">There are only two accounts in the passwd file with UID 0."
                </span><span class="koboSpan" id="kobo.504.5">echo
                echo
        fi
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.505.1">This is the</span><a id="_idIndexMarker1087"/><span class="koboSpan" id="kobo.506.1"> same as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.507.1">linux_sunos</span></code><span class="koboSpan" id="kobo.508.1"> function that we just looked at, except that it now checks for more than two UID 0 accounts in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.509.1">passwd</span></code><span class="koboSpan" id="kobo.510.1"> file. </span><span class="koboSpan" id="kobo.510.2">Here’s the next part:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.511.1">rootlock=$(awk 'BEGIN {FS=":"}; $1 ~ /root/ {print $2}' /etc/master.passwd | cut -c1)
        if [ "$rootlock" == '$' ] ; then
                echo "CRITICAL!!  </span><span class="koboSpan" id="kobo.511.2">The root account is not locked out."
                </span><span class="koboSpan" id="kobo.511.3">echo "Do you want to disable the root account? </span><span class="koboSpan" id="kobo.511.4">(y/n)"
                read answer
                if [ $answer == y ] ; then
                        pw mod user root -w no
                fi
        else
                echo "The root account is locked out, as it should be."
        </span><span class="koboSpan" id="kobo.511.5">fi
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.512.1">I had to modify the </span><code class="inlineCode"><span class="koboSpan" id="kobo.513.1">awk</span></code><span class="koboSpan" id="kobo.514.1"> command so that it will only find “root” in the first field of a line, as you see here with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.515.1">$1 ~ /root/</span></code><span class="koboSpan" id="kobo.516.1"> part:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.517.1">rootlock=$(awk 'BEGIN {FS=":"}; $1 ~ /root/ {print $2}' /etc/master.passwd | cut -c1)
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.518.1">That’s because, unlike the Linux and OpenIndiana </span><code class="inlineCode"><span class="koboSpan" id="kobo.519.1">shadow</span></code><span class="koboSpan" id="kobo.520.1"> files, the FreeBSD </span><code class="inlineCode"><span class="koboSpan" id="kobo.521.1">master.passwd</span></code><span class="koboSpan" id="kobo.522.1"> file lists users’ default home directories. </span><span class="koboSpan" id="kobo.522.2">As you see here, the default home directories for the first three users are set to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.523.1">/root/</span></code><span class="koboSpan" id="kobo.524.1"> directory:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.525.1">root:*:0:0::0:0:Charlie &amp;:/root:/bin/csh
toor:*:0:0::0:0:Bourne-again Superuser:/root:
daemon:*:1:1::0:0:Owner of many system processes:/root:/usr/sbin/nologin
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.526.1">Having </span><code class="inlineCode"><span class="koboSpan" id="kobo.527.1">/root/</span></code><span class="koboSpan" id="kobo.528.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.529.1">$1 ~ /root/</span></code><span class="koboSpan" id="kobo.530.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">awk</span></code><span class="koboSpan" id="kobo.532.1"> command causes the script to read all </span><a id="_idIndexMarker1088"/><span class="koboSpan" id="kobo.533.1">three of these lines, instead of just the first one that’s for the root user. </span><span class="koboSpan" id="kobo.533.2">This prevents the script from properly detecting if the root user account is enabled. </span><span class="koboSpan" id="kobo.533.3">That’s because if the script sees a </span><code class="inlineCode"><span class="koboSpan" id="kobo.534.1">$</span></code><span class="koboSpan" id="kobo.535.1"> in field 2 of the root line, and then sees an </span><code class="inlineCode"><span class="koboSpan" id="kobo.536.1">*</span></code><span class="koboSpan" id="kobo.537.1"> in field 2 of the toor and daemon lines, it will assign the </span><code class="inlineCode"><span class="koboSpan" id="kobo.538.1">*</span></code><span class="koboSpan" id="kobo.539.1"> as the final value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.540.1">rootlock</span></code><span class="koboSpan" id="kobo.541.1">. </span><span class="koboSpan" id="kobo.541.2">Because of that, the script will always show that the root account is locked, even when it isn’t.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.542.1">I also had to change the commands that lock the root and toor accounts, because the FreeBSD version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.543.1">passwd</span></code><span class="koboSpan" id="kobo.544.1"> doesn’t have the proper option switches to do that. </span><span class="koboSpan" id="kobo.544.2">So, I replaced the two </span><code class="inlineCode"><span class="koboSpan" id="kobo.545.1">passwd</span></code><span class="koboSpan" id="kobo.546.1"> commands with:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.547.1">pw mod user root -w no
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.548.1">This handy command both removes the password and locks the account at the same time.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.549.1">Since FreeBSD also has the toor account with UID 0, I’ve added another section to check for that:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.550.1">toorlock=$(awk 'BEGIN {FS=":"}; /toor/ {print $2}' /etc/master.passwd | cut -c1)
        if [ "$toorlock" == '$' ] ; then
                echo "CRITICAL!!  </span><span class="koboSpan" id="kobo.550.2">The toor account is not locked out."
                </span><span class="koboSpan" id="kobo.550.3">echo "Do you want to disable the toor account? </span><span class="koboSpan" id="kobo.550.4">(y/n)"
                read answer
                if [ $answer == y ] ; then
                        pw mod user toor -w no
                fi
        else
                echo "The toor account is locked out, as it should be."
        </span><span class="koboSpan" id="kobo.550.5">fi
}
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.551.1">Only one line in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.552.1">master.passwd</span></code><span class="koboSpan" id="kobo.553.1"> file contains the word “toor”, so I didn’t need to tell </span><code class="inlineCode"><span class="koboSpan" id="kobo.554.1">awk</span></code><span class="koboSpan" id="kobo.555.1"> to look for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.556.1">/toor/</span></code><span class="koboSpan" id="kobo.557.1"> pattern in only the first field. </span><span class="koboSpan" id="kobo.557.2">Other than that, it’s the same </span><a id="_idIndexMarker1089"/><span class="koboSpan" id="kobo.558.1">as what I’ve just shown you for the root user. </span><span class="koboSpan" id="kobo.558.2">(Of course, since this is the end of the function, I’ve included the closing curly brace at the end.)</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.559.1">Finally, I’ve modified the final part of the script so that it will automatically choose which function to run:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.560.1">if [ $os == Linux ] || [ $os == SunOS ] ; then
        linux_sunos
elif [ $os == FreeBSD ] ; then
        freebsd
else
        echo "I don't know this operating system."
</span><span class="koboSpan" id="kobo.560.2">fi
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.561.1">You’ve seen this sort of thing before in previous chapters, so you likely already know what’s going on with this.</span></p>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.562.1">Once again, I’m reading your mind. </span><span class="koboSpan" id="kobo.562.2">You’re thinking about how cool this script is, and how much you’d like to use it on an entire fleet of mixed Linux, Unix, and Unix-like servers. </span><span class="koboSpan" id="kobo.562.3">The problem though, is that this script is written for </span><code class="inlineCode"><span class="koboSpan" id="kobo.563.1">bash</span></code><span class="koboSpan" id="kobo.564.1"> and uses some of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.565.1">bash</span></code><span class="koboSpan" id="kobo.566.1"> advanced features that don’t work on many of the legacy </span><code class="inlineCode"><span class="koboSpan" id="kobo.567.1">sh</span></code><span class="koboSpan" id="kobo.568.1"> shells. </span><span class="koboSpan" id="kobo.568.2">That’s great if you can install </span><code class="inlineCode"><span class="koboSpan" id="kobo.569.1">bash</span></code><span class="koboSpan" id="kobo.570.1"> on all of your Unix and Unix-like servers, but that might not be an option. </span><span class="koboSpan" id="kobo.570.2">Also, if you’re working with Internet of Things devices that run lightweight versions of Linux, you might not be able to install </span><code class="inlineCode"><span class="koboSpan" id="kobo.571.1">bash</span></code><span class="koboSpan" id="kobo.572.1"> on them either. </span><span class="koboSpan" id="kobo.572.2">So, what do you do? </span><span class="koboSpan" id="kobo.572.3">Well, hang on, because I’ll explain all of that in </span><em class="chapterRef"><span class="koboSpan" id="kobo.573.1">Chapter 19, Shell Script Portability</span></em><span class="koboSpan" id="kobo.574.1">.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.575.1">I think that this about covers it for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.576.1">rootlock</span></code><span class="koboSpan" id="kobo.577.1"> scripts. </span><span class="koboSpan" id="kobo.577.2">Let’s look at one more auditing script before wrapping up this section.</span></p>
    <h2 id="_idParaDest-375" class="heading 2"><span class="koboSpan" id="kobo.578.1">Creating a User Activity Monitoring Script</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.579.1">In this scenario, you</span><a id="_idIndexMarker1090"/><span class="koboSpan" id="kobo.580.1"> want to see a record of when other users have logged into the system, and</span><a id="_idIndexMarker1091"/><span class="koboSpan" id="kobo.581.1"> what they’re doing with their </span><code class="inlineCode"><span class="koboSpan" id="kobo.582.1">sudo</span></code><span class="koboSpan" id="kobo.583.1"> privileges. </span><span class="koboSpan" id="kobo.583.2">To do that, let’s create the </span><code class="inlineCode"><span class="koboSpan" id="kobo.584.1">user_activity_1.sh script</span></code><span class="koboSpan" id="kobo.585.1">. </span><span class="koboSpan" id="kobo.585.2">Here’s the top section:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.586.1">#!/bin/bash
if [[ $1 == "" ]] ; then
        echo "You must specify a user name."
        </span><span class="koboSpan" id="kobo.586.2">echo "Usage: sudo ./user_activity_1.sh username "
        exit
fi
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.587.1">This tells you that you have to supply a user name when invoking this script. </span><span class="koboSpan" id="kobo.587.2">If you don’t specify a user name, you’ll see this message, and the script will exit. </span><span class="koboSpan" id="kobo.587.3">Here’s the next part:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.588.1">if [[ -f /var/log/secure ]] ; then
        logfile=/var/log/secure
elif [[ -f /var/log/auth.log ]] ; then
        logfile=/var/log/auth.log
elif [[ -n $(awk /suse/ /etc/os-release) ]] ; then
        logfile=/var/log/messages
else
        echo "I don't know this operating system."
        </span><span class="koboSpan" id="kobo.588.2">exit
fi
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.589.1">Most Linux and some Unix/Unix-like distros store user authentication messages in either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.590.1">/var/log/secure</span></code><span class="koboSpan" id="kobo.591.1"> file or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.592.1">/var/log/auth.log</span></code><span class="koboSpan" id="kobo.593.1"> file. </span><span class="koboSpan" id="kobo.593.2">SUSE and openSUSE are notable exceptions to this rule, because they store this information in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.594.1">/var/log/messages</span></code><span class="koboSpan" id="kobo.595.1"> file.</span></p>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.596.1">I’m assuming here that you’re working with a distro that has either </span><code class="inlineCode"><span class="koboSpan" id="kobo.597.1">rsyslog</span></code><span class="koboSpan" id="kobo.598.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.599.1">syslog</span></code><span class="koboSpan" id="kobo.600.1"> installed. </span><span class="koboSpan" id="kobo.600.2">This script won’t work if all you have is </span><code class="inlineCode"><span class="koboSpan" id="kobo.601.1">journald</span></code><span class="koboSpan" id="kobo.602.1">.</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.603.1">Finally, here’s the part that does the actual work.</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.604.1">username=$1
echo "=== User Account Activity ===" &gt; user_activity_for_"$username"_$(date +"%F_%H-%M").txt
# Check user activity in system logs
echo "=== Recent Logins ===" &gt;&gt; user_activity_for_"$username"_$(date +"%F_%H-%M").txt
last | grep $username &gt;&gt; user_activity_for_"$username"_$(date +"%F_%I-%M").txt
# Check sudo command usage
echo "=== Sudo Command Usage ===" &gt;&gt; user_activity_for_"$username"_$(date +"%F_%H-%M").txt
grep sudo "$logfile" | grep $username &gt;&gt; user_activity_for_"$username"_$(date +"%F_%H-%M").txt
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.605.1">Okay, it’s </span><a id="_idIndexMarker1092"/><span class="koboSpan" id="kobo.606.1">easy. </span><span class="koboSpan" id="kobo.606.2">It’s just creating a report file with </span><a id="_idIndexMarker1093"/><span class="koboSpan" id="kobo.607.1">the user’s name and a timestamp in the filename. </span><span class="koboSpan" id="kobo.607.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.608.1">last</span></code><span class="koboSpan" id="kobo.609.1"> command creates the record of the user’s logins, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.610.1">grep</span></code><span class="koboSpan" id="kobo.611.1"> command searches through the designated file for all lines that contain the </span><em class="italic"><span class="koboSpan" id="kobo.612.1">sudo</span></em><span class="koboSpan" id="kobo.613.1"> text string. </span><span class="koboSpan" id="kobo.613.2">Then, it pipes that output into </span><code class="inlineCode"><span class="koboSpan" id="kobo.614.1">grep</span></code><span class="koboSpan" id="kobo.615.1"> to search for all lines that contain the designated user name.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.616.1">Now, let’s run the script to see what that Donnie character has been doing:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.617.1">donnie@fedora-server:~$ sudo ./user_activity_1.sh donnie
[sudo] password for donnie:
donnie@fedora-server:~$ ls -l user_activity_*
-rwxr--r--. </span><span class="koboSpan" id="kobo.617.2">1 donnie donnie    921 May 14 18:11 user_activity_1.sh
-rw-r--r--. </span><span class="koboSpan" id="kobo.617.3">1 root   root   276170 May 14 18:11 user_activity_for_donnie_2024-05-14_18-11.txt
donnie@fedora-server:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.618.1">Very cool. </span><span class="koboSpan" id="kobo.618.2">You see that the script has created a report file with my username and the current date and time in the filename. </span><span class="koboSpan" id="kobo.618.3">Here’s a snippet of what you’ll see in that report file:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.619.1">=== User Account Activity ===
=== Recent Logins ===
donnie   pts/1        192.168.0.16     Tue May 14 15:30 - 16:41  (01:11)
donnie   pts/0        192.168.0.16     Tue May 14 15:22   still logged in
donnie   tty1                          Mon May 13 17:33 - 17:44  (00:11)
donnie   pts/0        192.168.0.16     Mon May 13 14:43 - 17:44  (03:01)
=== Sudo Command Usage ===
Dec  8 14:17:32 localhost sudo[993]:  donnie : TTY=tty1 ; PWD=/home/donnie ; USER=root ; COMMAND=/usr/bin/dnf install openscap-scanner scap-security-guide
Dec  8 14:17:32 localhost sudo[993]: pam_unix(sudo:session): session opened for user root(uid=0) by donnie(uid=1000)
Jan 30 13:02:43 localhost sudo[955]:  donnie : TTY=tty1 ; PWD=/home/donnie ; USER=root ; COMMAND=/usr/bin/dnf -y upgrade
</span></code></pre>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.620.1">I’ve tested this script on Fedora Server, Ubuntu Server, openSUSE, FreeBSD, and OpenBSD. </span><span class="koboSpan" id="kobo.620.2">(Note that I installed </span><code class="inlineCode"><span class="koboSpan" id="kobo.621.1">bash</span></code><span class="koboSpan" id="kobo.622.1"> on both of the BSD distros.)</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.623.1">Okay, I think </span><a id="_idIndexMarker1094"/><span class="koboSpan" id="kobo.624.1">that </span><a id="_idIndexMarker1095"/><span class="koboSpan" id="kobo.625.1">that’s about it for the auditing scripts. </span><span class="koboSpan" id="kobo.625.2">Let’s see what we can do with a firewall script.</span></p>
    <h1 id="_idParaDest-376" class="heading 1"><span class="koboSpan" id="kobo.626.1">Creating Simple Firewall Scripts</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.627.1">In this scenario, you </span><a id="_idIndexMarker1096"/><span class="koboSpan" id="kobo.628.1">need to create a text file with a list of IP addresses that you want to block. </span><span class="koboSpan" id="kobo.628.2">You then need to create a shell script that will read that list of IP addresses, and then create firewall rules that will block them. </span><span class="koboSpan" id="kobo.628.3">There are two ways that you can do this. </span><span class="koboSpan" id="kobo.628.4">First, there’s the hard way. </span><span class="koboSpan" id="kobo.628.5">And then, there’s the easy way.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.629.1">The hard way consists of reading the list of addresses into a variable array, and then creating a </span><code class="inlineCode"><span class="koboSpan" id="kobo.630.1">for</span></code><span class="koboSpan" id="kobo.631.1"> loop that will create a blocking rule for each IP address that’s in the array. </span><span class="koboSpan" id="kobo.631.2">Okay, it’s not that hard, but it is a bit harder than we would like. </span><span class="koboSpan" id="kobo.631.3">(I’ll show you the easy way after I show you the hard way. </span><span class="koboSpan" id="kobo.631.4">That way, you’ll be more appreciative of the easy way.)</span></p>
    <h2 id="_idParaDest-377" class="heading 2"><span class="koboSpan" id="kobo.632.1">Creating an IP Address Blocking Script for Red Hat Distros</span></h2>
    <p class="normal"><span class="koboSpan" id="kobo.633.1">Red Hat-type distros, such</span><a id="_idIndexMarker1097"/><span class="koboSpan" id="kobo.634.1"> as Fedora, AlmaLinux, Rocky Linux, Oracle Linux, and of </span><a id="_idIndexMarker1098"/><span class="koboSpan" id="kobo.635.1">course Red Hat Enterprise Linux, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.636.1">firewalld</span></code><span class="koboSpan" id="kobo.637.1"> as their firewall management utility, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.638.1">nftables</span></code><span class="koboSpan" id="kobo.639.1"> as the</span><a id="_idIndexMarker1099"/><span class="koboSpan" id="kobo.640.1"> actual firewall engine. </span><span class="koboSpan" id="kobo.640.2">To my knowledge, the only non-Red Hat Linux distros that come with this setup installed by default are SUSE and openSUSE.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.641.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.642.1">firewall-cmd</span></code><span class="koboSpan" id="kobo.643.1"> utility is the main way to manage </span><code class="inlineCode"><span class="koboSpan" id="kobo.644.1">firewalld</span></code><span class="koboSpan" id="kobo.645.1"> rules, policies and configuration. </span><span class="koboSpan" id="kobo.645.2">To see how this works, let’s do a couple of hands-on labs.</span></p>
    <h3 id="_idParaDest-378" class="heading 3"><span class="koboSpan" id="kobo.646.1">Hands-on Lab: Create the Script with an Array and a for loop</span></h3>
    <p class="normal"><span class="koboSpan" id="kobo.647.1">In this lab, you’ll create a</span><a id="_idIndexMarker1100"/><span class="koboSpan" id="kobo.648.1"> script that builds a variable array by reading the list of IP addresses from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.649.1">ip-address_blacklist.txt</span></code><span class="koboSpan" id="kobo.650.1"> file. </span><span class="koboSpan" id="kobo.650.2">You’ll then use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.651.1">for</span></code><span class="koboSpan" id="kobo.652.1"> loop to create a firewall rule for each IP address in the list.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.653.1">1. </span><span class="koboSpan" id="kobo.653.2">On the Fedora Server virtual machine, create the </span><code class="inlineCode"><span class="koboSpan" id="kobo.654.1">ip-address_blacklist.txt</span></code><span class="koboSpan" id="kobo.655.1"> file, with one IP address on each line. </span><span class="koboSpan" id="kobo.655.2">Make it look something like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.656.1">donnie@fedora-server:~$ cat ip-address_blacklist.txt
192.168.0.14
192.168.0.84
192.168.0.7
192.168.0.12
192.168.0.39
donnie@fedora-server:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.657.1">2. </span><span class="koboSpan" id="kobo.657.2">Now, create the </span><code class="inlineCode"><span class="koboSpan" id="kobo.658.1">firewall-blacklist_array.sh</span></code><span class="koboSpan" id="kobo.659.1"> script, which uses a variable array and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.660.1">for</span></code><span class="koboSpan" id="kobo.661.1"> loop. </span><span class="koboSpan" id="kobo.661.2">Make it look like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.662.1">#!/bin/bash
declare -a badips
badips=( $(cat ip-address_blacklist.txt) )
for ip in ${badips[*]}
do
        firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source address="$ip" drop"
done
firewall-cmd --reload
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.663.1">The</span><a id="_idIndexMarker1101"/><span class="koboSpan" id="kobo.664.1"> first thing we’re doing here is to declare and build the </span><code class="inlineCode"><span class="koboSpan" id="kobo.665.1">badips</span></code><span class="koboSpan" id="kobo.666.1"> array, as I showed you in </span><em class="chapterRef"><span class="koboSpan" id="kobo.667.1">Chapter 8, Basic Shell Script Construction</span></em><span class="koboSpan" id="kobo.668.1">. </span><span class="koboSpan" id="kobo.668.2">This array obtains its values from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.669.1">ip-address_blacklist.txt</span></code><span class="koboSpan" id="kobo.670.1"> file that we’ve just created. </span><span class="koboSpan" id="kobo.670.2">Within the </span><code class="inlineCode"><span class="koboSpan" id="kobo.671.1">for</span></code><span class="koboSpan" id="kobo.672.1"> loop, you see the </span><code class="inlineCode"><span class="koboSpan" id="kobo.673.1">firewall-cmd</span></code><span class="koboSpan" id="kobo.674.1"> command that creates a firewall rule for each IP address that we loaded into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.675.1">badips</span></code><span class="koboSpan" id="kobo.676.1"> array. </span><span class="koboSpan" id="kobo.676.2">Whenever you use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.677.1">--permanent</span></code><span class="koboSpan" id="kobo.678.1"> option the </span><code class="inlineCode"><span class="koboSpan" id="kobo.679.1">firewall-cmd</span></code><span class="koboSpan" id="kobo.680.1"> command will write the new rules to the proper configuration file. </span><span class="koboSpan" id="kobo.680.2">But, it won’t load the new rules into the running firewall. </span><span class="koboSpan" id="kobo.680.3">The final </span><code class="inlineCode"><span class="koboSpan" id="kobo.681.1">firewall-cmd --reload</span></code><span class="koboSpan" id="kobo.682.1"> command loads the new rules so that they will take effect.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.683.1">3. </span><span class="koboSpan" id="kobo.683.2">Run this script on your Fedora virtual machine. </span><span class="koboSpan" id="kobo.683.3">You should receive one success message for each IP address, and a final success message after the reload command. </span><span class="koboSpan" id="kobo.683.4">Here’s how it looks:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.684.1">donnie@fedora-server:~$ sudo ./firewall-blacklist_array.sh
success
success
success
success
success
success
donnie@fedora-server:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.685.1">4. </span><span class="koboSpan" id="kobo.685.2">To verify that the rules have taken effect, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.686.1">nft list ruleset</span></code><span class="koboSpan" id="kobo.687.1"> command, and then scroll back to where you’ll see the new rules. </span><span class="koboSpan" id="kobo.687.2">Here’s how that looks:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.688.1">donnie@fedora-server:~$ sudo nft list ruleset
. </span><span class="koboSpan" id="kobo.688.2">. </span><span class="koboSpan" id="kobo.688.3">.
</span><span class="koboSpan" id="kobo.688.4">. </span><span class="koboSpan" id="kobo.688.5">. </span><span class="koboSpan" id="kobo.688.6">.
</span><span class="koboSpan" id="kobo.688.7">chain filter_IN_FedoraServer_deny {
		ip saddr 192.168.0.14 drop
		ip saddr 192.168.0.84 drop
		ip saddr 192.168.0.7 drop
		ip saddr 192.168.0.12 drop
		ip saddr 192.168.0.39 drop
	}
. </span><span class="koboSpan" id="kobo.688.8">. </span><span class="koboSpan" id="kobo.688.9">.
</span><span class="koboSpan" id="kobo.688.10">. </span><span class="koboSpan" id="kobo.688.11">. </span><span class="koboSpan" id="kobo.688.12">.
</span><span class="koboSpan" id="kobo.688.13">donnie@fedora-server:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.689.1">5. </span><span class="koboSpan" id="kobo.689.2">To see</span><a id="_idIndexMarker1102"/><span class="koboSpan" id="kobo.690.1"> if the rules have been added permanently, look at the proper configuration file in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.691.1">/etc/firewalld/zones/</span></code><span class="koboSpan" id="kobo.692.1"> directory, like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.693.1">donnie@fedora-server:~$ sudo cat /etc/firewalld/zones/FedoraServer.xml
. </span><span class="koboSpan" id="kobo.693.2">. </span><span class="koboSpan" id="kobo.693.3">.
</span><span class="koboSpan" id="kobo.693.4">. </span><span class="koboSpan" id="kobo.693.5">. </span><span class="koboSpan" id="kobo.693.6">.
</span><span class="koboSpan" id="kobo.693.7">&lt;rule family="ipv4"&gt;
    &lt;source address="192.168.0.14"/&gt;
    &lt;drop/&gt;
  &lt;/rule&gt;
  &lt;rule family="ipv4"&gt;
    &lt;source address="192.168.0.84"/&gt;
    &lt;drop/&gt;
  &lt;/rule&gt;
 . </span><span class="koboSpan" id="kobo.693.8">. </span><span class="koboSpan" id="kobo.693.9">.
</span><span class="koboSpan" id="kobo.693.10">. </span><span class="koboSpan" id="kobo.693.11">. </span><span class="koboSpan" id="kobo.693.12">.
</span><span class="koboSpan" id="kobo.693.13">donnie@fedora-server:~$
</span></code></pre>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.694.1">Note that the name of this configuration file will be different on other distros, such as AlmaLinux, Rocky Linux, Red Hat Enterprise Linux, or SUSE/openSUSE.</span></p>
      <p class="normal"><span class="koboSpan" id="kobo.695.1">Also, be aware that different Linux distros come with different firewall management utilities. </span><span class="koboSpan" id="kobo.695.2">For example, Ubuntu comes with the </span><strong class="keyWord"><span class="koboSpan" id="kobo.696.1">Uncomplicated Firewall</span></strong><span class="koboSpan" id="kobo.697.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.698.1">ufw</span></code><span class="koboSpan" id="kobo.699.1">) firewall manager, and other distros might just have you use plain </span><code class="inlineCode"><span class="koboSpan" id="kobo.700.1">nftables</span></code><span class="koboSpan" id="kobo.701.1"> without a management utility. </span><span class="koboSpan" id="kobo.701.2">Once you know the proper firewall management commands for your particular distro, it’s a simple matter to modify this script to work with it. </span><span class="koboSpan" id="kobo.701.3">(If you need to learn more about Linux firewalls, you might like to check out one of my other books, </span><em class="italic"><span class="koboSpan" id="kobo.702.1">Mastering Linux Security and Hardening</span></em><span class="koboSpan" id="kobo.703.1">, which is available from both Amazon and directly from Packt Publishing.)</span></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.704.1">End of lab.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.705.1">Okay, that wasn’t</span><a id="_idIndexMarker1103"/><span class="koboSpan" id="kobo.706.1"> too difficult, was it? </span><span class="koboSpan" id="kobo.706.2">Hang on, though. </span><span class="koboSpan" id="kobo.706.3">Let’s make this even easier with </span><code class="inlineCode"><span class="koboSpan" id="kobo.707.1">xargs</span></code><span class="koboSpan" id="kobo.708.1">.</span></p>
    <h3 id="_idParaDest-379" class="heading 3"><span class="koboSpan" id="kobo.709.1">Hands-on Lab: Creating the Script with xargs</span></h3>
    <p class="normal"><span class="koboSpan" id="kobo.710.1">Back in </span><em class="chapterRef"><span class="koboSpan" id="kobo.711.1">Chapter 7, Text Stream Filters–Part 2</span></em><span class="koboSpan" id="kobo.712.1">, I introduced you to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.713.1">xargs</span></code><span class="koboSpan" id="kobo.714.1"> utility. </span><span class="koboSpan" id="kobo.714.2">I showed </span><a id="_idIndexMarker1104"/><span class="koboSpan" id="kobo.715.1">you a few examples of how to use it in the context of text stream filters, and I also promised that I would show you more examples of how to use it later. </span><span class="koboSpan" id="kobo.715.2">You can vastly simplify this type of script by using </span><code class="inlineCode"><span class="koboSpan" id="kobo.716.1">xargs</span></code><span class="koboSpan" id="kobo.717.1"> instead of variable arrays and </span><code class="inlineCode"><span class="koboSpan" id="kobo.718.1">for</span></code><span class="koboSpan" id="kobo.719.1"> loops. </span><span class="koboSpan" id="kobo.719.2">As before, I’ll show you how it’s done with the Red Hat family.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.720.1">1. </span><span class="koboSpan" id="kobo.720.2">Create the </span><code class="inlineCode"><span class="koboSpan" id="kobo.721.1">firewall-blacklist_xargs.sh</span></code><span class="koboSpan" id="kobo.722.1"> script, like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.723.1">#!/bin/bash
xargs -i firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source 
address={} drop" &lt; ip-address_blacklist.txt
firewall-cmd --reload
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.724.1">(Note that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.725.1">xargs</span></code><span class="koboSpan" id="kobo.726.1"> line is a long line that wraps around on the printed page.)</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.727.1">As before, the first command is just a normal </span><code class="inlineCode"><span class="koboSpan" id="kobo.728.1">firewall-cmd</span></code><span class="koboSpan" id="kobo.729.1"> command that creates the blocking rules. </span><span class="koboSpan" id="kobo.729.2">In this case, we’re preceding the command with </span><code class="inlineCode"><span class="koboSpan" id="kobo.730.1">xargs -i</span></code><span class="koboSpan" id="kobo.731.1"> so that it will read the list of IP addresses from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.732.1">ip-address_blacklist.txt</span></code><span class="koboSpan" id="kobo.733.1"> file, one at a time. </span><span class="koboSpan" id="kobo.733.2">In a normal </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">firewall-cmd</span></code><span class="koboSpan" id="kobo.735.1"> command, you would place either an IP address or a range of IP addresses after the </span><code class="inlineCode"><span class="koboSpan" id="kobo.736.1">source address=</span></code><span class="koboSpan" id="kobo.737.1"> part. </span><span class="koboSpan" id="kobo.737.2">This time though, we’ve</span><a id="_idIndexMarker1105"/><span class="koboSpan" id="kobo.738.1"> placed a pair of curly braces there. </span><span class="koboSpan" id="kobo.738.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.739.1">xargs</span></code><span class="koboSpan" id="kobo.740.1"> utility will cause the </span><code class="inlineCode"><span class="koboSpan" id="kobo.741.1">firewall-cmd</span></code><span class="koboSpan" id="kobo.742.1"> command to run once for each IP address that it finds in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.743.1">ip-address_blacklist.txt</span></code><span class="koboSpan" id="kobo.744.1"> file. </span><span class="koboSpan" id="kobo.744.2">Each time that the command runs, the next IP address in the list will be placed within the pair of curly braces. </span><span class="koboSpan" id="kobo.744.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.745.1">--permanent</span></code><span class="koboSpan" id="kobo.746.1"> option in this </span><code class="inlineCode"><span class="koboSpan" id="kobo.747.1">firewall-cmd</span></code><span class="koboSpan" id="kobo.748.1"> command is what saves the new rules to the proper rules file. </span><span class="koboSpan" id="kobo.748.2">Using this </span><code class="inlineCode"><span class="koboSpan" id="kobo.749.1">--permanent</span></code><span class="koboSpan" id="kobo.750.1"> option requires you to run the </span><code class="inlineCode"><span class="koboSpan" id="kobo.751.1">firewall-cmd --reload</span></code><span class="koboSpan" id="kobo.752.1"> command in order to make the new rules take effect.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.753.1">2. </span><span class="koboSpan" id="kobo.753.2">Edit the </span><code class="inlineCode"><span class="koboSpan" id="kobo.754.1">ip-address_blacklist.txt</span></code><span class="koboSpan" id="kobo.755.1"> file to add a few more IP addresses. </span><span class="koboSpan" id="kobo.755.2">Then, run the script. </span><span class="koboSpan" id="kobo.755.3">The output should now look something like this:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.756.1">donnie@fedora-server:~$ sudo ./firewall-blacklist_xargs.sh
Warning: ALREADY_ENABLED: rule family=ipv4 source address=192.168.0.14 drop
success
Warning: ALREADY_ENABLED: rule family=ipv4 source address=192.168.0.84 drop
success
Warning: ALREADY_ENABLED: rule family=ipv4 source address=192.168.0.7 drop
success
Warning: ALREADY_ENABLED: rule family=ipv4 source address=192.168.0.12 drop
success
Warning: ALREADY_ENABLED: rule family=ipv4 source address=192.168.0.39 drop
success
success
success
success
donnie@fedora-server:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.757.1">3. </span><span class="koboSpan" id="kobo.757.2">Verify that the new rules have taken effect:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.758.1">donnie@fedora-server:~$ sudo nft list ruleset
. </span><span class="koboSpan" id="kobo.758.2">. </span><span class="koboSpan" id="kobo.758.3">.
</span><span class="koboSpan" id="kobo.758.4">. </span><span class="koboSpan" id="kobo.758.5">. </span><span class="koboSpan" id="kobo.758.6">.
</span><span class="koboSpan" id="kobo.758.7">chain filter_IN_FedoraServer_deny {
		ip saddr 192.168.0.14 drop
		ip saddr 192.168.0.84 drop
		ip saddr 192.168.0.7 drop
		ip saddr 192.168.0.12 drop
		ip saddr 192.168.0.39 drop
		ip saddr 212.12.3.12 drop
		ip saddr 172.10.0.0/16 drop
	}
. </span><span class="koboSpan" id="kobo.758.8">. </span><span class="koboSpan" id="kobo.758.9">.
</span><span class="koboSpan" id="kobo.758.10">. </span><span class="koboSpan" id="kobo.758.11">. </span><span class="koboSpan" id="kobo.758.12">.
</span><span class="koboSpan" id="kobo.758.13">donnie@fedora-server:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.759.1">Note how with the last rule, I opted to block an entire IP address subnet. </span><span class="koboSpan" id="kobo.759.2">This capability</span><a id="_idIndexMarker1106"/><span class="koboSpan" id="kobo.760.1"> could come in handy if you ever need to block an entire country from accessing your server, for example.</span></p>
    <div class="note">
      <p class="normal"><span class="koboSpan" id="kobo.761.1">If you ever do need to block an entire country, you can find lists of IP address ranges for various countries here:</span></p>
      <p class="normal"><a href="https://lite.ip2location.com/ip-address-ranges-by-country"><span class="url"><span class="koboSpan" id="kobo.762.1">https://lite.ip2location.com/ip-address-ranges-by-country</span></span></a></p>
    </div>
    <p class="normal"><span class="koboSpan" id="kobo.763.1">4. </span><span class="koboSpan" id="kobo.763.2">Open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.764.1">/etc/firewalld/zones/FedoraServer.xml</span></code><span class="koboSpan" id="kobo.765.1"> file in your text editor, and remove the rules that you’ve just created.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.766.1">5. </span><span class="koboSpan" id="kobo.766.2">Finally, clear the rules out of the running firewall by doing:</span></p>
    <pre class="programlisting gen"><code class="hljs-con"><span class="koboSpan" id="kobo.767.1">donnie@fedora-server:~$ sudo firewall-cmd --reload
success
donnie@fedora-server:~$
</span></code></pre>
    <p class="normal"><span class="koboSpan" id="kobo.768.1">End of lab.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.769.1">Now, is that slick, or is that slick? </span><span class="koboSpan" id="kobo.769.2">I mean, by using </span><code class="inlineCode"><span class="koboSpan" id="kobo.770.1">xargs</span></code><span class="koboSpan" id="kobo.771.1"> instead of variable arrays and </span><code class="inlineCode"><span class="koboSpan" id="kobo.772.1">for</span></code><span class="koboSpan" id="kobo.773.1"> loops, you’ve vastly simplified this script. </span><span class="koboSpan" id="kobo.773.2">Also, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.774.1">xargs</span></code><span class="koboSpan" id="kobo.775.1"> makes your scripts </span><a id="_idIndexMarker1107"/><span class="koboSpan" id="kobo.776.1">more portable. </span><span class="koboSpan" id="kobo.776.2">That’s because you can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.777.1">xargs</span></code><span class="koboSpan" id="kobo.778.1"> on pretty much any type of Linux, Unix, or Unix-like shell. </span><span class="koboSpan" id="kobo.778.2">On the other hand, you can use variable arrays with </span><code class="inlineCode"><span class="koboSpan" id="kobo.779.1">bash</span></code><span class="koboSpan" id="kobo.780.1">, but not with certain variations of </span><code class="inlineCode"><span class="koboSpan" id="kobo.781.1">sh</span></code><span class="koboSpan" id="kobo.782.1">. </span><span class="koboSpan" id="kobo.782.2">(I’ll talk more about portability in </span><em class="chapterRef"><span class="koboSpan" id="kobo.783.1">Chapter 19, Shell Script Portability</span></em><span class="koboSpan" id="kobo.784.1">.) So really, having </span><code class="inlineCode"><span class="koboSpan" id="kobo.785.1">xargs</span></code><span class="koboSpan" id="kobo.786.1"> in our toolbox is what I call a win-win!</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.787.1">Next, let’s see if we can save ourselves a bit of work.</span></p>
    <h1 id="_idParaDest-380" class="heading 1"><span class="koboSpan" id="kobo.788.1">Searching for Existing Security-related Scripts</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.789.1">A basic tenet of </span><a id="_idIndexMarker1108"/><span class="koboSpan" id="kobo.790.1">computer programming is to reuse code as much as possible. </span><span class="koboSpan" id="kobo.790.2">Otherwise, every programmer in the world would waste huge amounts of time trying to always reinvent the proverbial wheel. </span><span class="koboSpan" id="kobo.790.3">So, if you find yourself in need of a script and don’t know how to write it yourself, you can search for one either by using your favorite search engine or by searching on Github.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.791.1">The only catch with using search engines is that you might have to try several different search terms to find what you need. </span><span class="koboSpan" id="kobo.791.2">For example, I tried the following search terms on DuckDuckGo:</span></p>
    <ul>
      <li class="bulletList"><span class="koboSpan" id="kobo.792.1">bash scripts for security audit</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.793.1">bash scripting for pentesters</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.794.1">bash scripts for security administrators</span></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.795.1">bash scripting for cybersecurity</span></li>
    </ul>
    <p class="normal"><span class="koboSpan" id="kobo.796.1">As a matter of full disclosure, I have to say that most of these search results were for courses and books for which you’ll have to pay. </span><span class="koboSpan" id="kobo.796.2">If that’s what you need or want, then great. </span><span class="koboSpan" id="kobo.796.3">But, mixed in with all that you might find some gems that will either help you with your immediate problem or that will give you some good ideas for your own scripts.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.797.1">For more concise and useful search results, you might consider searching for scripts on</span><a id="_idIndexMarker1109"/><span class="koboSpan" id="kobo.798.1"> Github. </span><span class="koboSpan" id="kobo.798.2">Here, for example, I searched for the term, </span><em class="italic"><span class="koboSpan" id="kobo.799.1">bash security scripts</span></em><span class="koboSpan" id="kobo.800.1">:</span></p>
    <figure class="mediaobject"><span class="koboSpan" id="kobo.801.1"><img src="../Images/B21693_18_01.png" alt="B21693_18_1"/></span></figure>
    <p class="packt_figref"><span class="koboSpan" id="kobo.802.1">Figure 18.1: Searching for bash security scripts on Github</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.803.1">You’ll find lots of repositories from many different authors like this. </span><span class="koboSpan" id="kobo.803.2">Most, if not all, of these scripts are released under a free-as-in-freedom software license, so you can download them and use them as you wish. </span><span class="koboSpan" id="kobo.803.3">Of course, you’ll want to review and test the scripts before you put them into production use. </span><span class="koboSpan" id="kobo.803.4">Some of them will work on your systems without modification, and some won’t. </span><span class="koboSpan" id="kobo.803.5">So, just because you’re able to find scripts that someone else has already written doesn’t mean that you can just skate by without any knowledge of shell scripting.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.804.1">All right, I think that about covers it. </span><span class="koboSpan" id="kobo.804.2">Let’s summarize and then move on to the next chapter.</span></p>
    <h1 id="_idParaDest-381" class="heading 1"><span class="koboSpan" id="kobo.805.1">Summary</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.806.1">In this chapter, I didn’t introduce a lot of new scripting concepts as I normally do. </span><span class="koboSpan" id="kobo.806.2">Instead, I showed you how to use the concepts that you already know to create scripts that might be useful to a security-conscious administrator. </span><span class="koboSpan" id="kobo.806.3">You’ve seen how to create shell scripts that can do simple port scans or operating system identification. </span><span class="koboSpan" id="kobo.806.4">Then, you saw how to create auditing scripts that can show if the root user account is enabled, when a normal user is logging into the system, and what a normal user is doing with his or her </span><code class="inlineCode"><span class="koboSpan" id="kobo.807.1">sudo</span></code><span class="koboSpan" id="kobo.808.1"> privileges. </span><span class="koboSpan" id="kobo.808.2">After that, I showed you a script that can read a list of IP addresses, and automatically create firewall rules to block those addresses. </span><span class="koboSpan" id="kobo.808.3">Finally, I showed you some tips about how to find and use scripts that other people have already created.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.809.1">In the next chapter, we’ll talk a bit about shell script portability. </span><span class="koboSpan" id="kobo.809.2">I’ll see you there.</span></p>
    <h1 id="_idParaDest-382" class="heading 1"><span class="koboSpan" id="kobo.810.1">Questions</span></h1>
    <ol>
      <li class="numberedList" value="1"><span class="koboSpan" id="kobo.811.1">When you do a port scan of a remote machine and find ports that are in a closed state, what does that mean?</span><ol>
          <li class="alphabeticList level 2" value="1"><span class="koboSpan" id="kobo.812.1">That the ports are blocked by a firewall.</span></li>
          <li class="alphabeticList level 2"><span class="koboSpan" id="kobo.813.1">That the ports are not blocked by a firewall, and that the associated services for those ports are not running.</span></li>
          <li class="alphabeticList level 2"><span class="koboSpan" id="kobo.814.1">That the ports are not blocked by a firewall, and that the associated services for those ports are running.</span></li>
          <li class="alphabeticList level 2"><span class="koboSpan" id="kobo.815.1">That the remote machine can’t be reached by your port scanner.</span></li>
        </ol>
      </li>
      <li class="numberedList"><span class="koboSpan" id="kobo.816.1">You’re looking for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.817.1">/etc/shadow</span></code><span class="koboSpan" id="kobo.818.1"> file on a FreeBSD system, but can’t find it. </span><span class="koboSpan" id="kobo.818.2">What could be the problem?</span><ol>
          <li class="alphabeticList level 2" value="1"><span class="koboSpan" id="kobo.819.1">FreeBSD keeps its account passwords in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.820.1">/etc/passwd</span></code><span class="koboSpan" id="kobo.821.1"> file.</span></li>
          <li class="alphabeticList level 2"><span class="koboSpan" id="kobo.822.1">FreeBSD keeps its account passwords in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.823.1">/var/lib/</span></code><span class="koboSpan" id="kobo.824.1"> directory.</span></li>
          <li class="alphabeticList level 2"><span class="koboSpan" id="kobo.825.1">FreeBSD uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.826.1">/etc/master.passwd</span></code><span class="koboSpan" id="kobo.827.1"> file instead of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.828.1">/etc/shadow</span></code><span class="koboSpan" id="kobo.829.1"> file.</span></li>
          <li class="alphabeticList level 2"><span class="koboSpan" id="kobo.830.1">FreeBSD doesn’t require passwords.</span></li>
        </ol>
      </li>
      <li class="numberedList"><span class="koboSpan" id="kobo.831.1">Which of the following statements is true?</span><ol>
          <li class="alphabeticList level 2" value="1"><span class="koboSpan" id="kobo.832.1">There is no advantage to using </span><code class="inlineCode"><span class="koboSpan" id="kobo.833.1">xargs</span></code><span class="koboSpan" id="kobo.834.1"> in your scripts.</span></li>
          <li class="alphabeticList level 2"><span class="koboSpan" id="kobo.835.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.836.1">xargs</span></code><span class="koboSpan" id="kobo.837.1"> can make your scripts easier to create, easier to read, and can enhance script portability.</span></li>
          <li class="alphabeticList level 2"><span class="koboSpan" id="kobo.838.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.839.1">xarg</span></code><span class="koboSpan" id="kobo.840.1">s makes your scripts more complex and harder to understand.</span></li>
        </ol>
      </li>
    </ol>
    <h1 id="_idParaDest-383" class="heading 1"><span class="koboSpan" id="kobo.841.1">Further Reading</span></h1>
    <ul>
      <li class="bulletList"><span class="koboSpan" id="kobo.842.1">Introduction to Bash for Cybersecurity: </span><a href="mailto:https://medium.com/@aardvarkinfinity/introduction-to-bash-for-cybersecurity-56792984bcc0"><span class="url"><span class="koboSpan" id="kobo.843.1">https://medium.com/@aardvarkinfinity/introduction-to-bash-for-cybersecurity-56792984bcc0</span></span></a></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.844.1">Shell Scripting and Security: </span><a href="https://www.linuxjournal.com/content/shell-scripting-and-security"><span class="url"><span class="koboSpan" id="kobo.845.1">https://www.linuxjournal.com/content/shell-scripting-and-security</span></span></a></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.846.1">HackSploit Blog-Bash Scripting: </span><a href="https://hackersploit.org/bash-scripting/"><span class="url"><span class="koboSpan" id="kobo.847.1">https://hackersploit.org/bash-scripting/</span></span></a></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.848.1">Is Bash the Secret Weapon of Cybersecurity Experts?: </span><a href="https://cyberinsight.co/is-bash-used-in-cyber-security/"><span class="url"><span class="koboSpan" id="kobo.849.1">https://cyberinsight.co/is-bash-used-in-cyber-security/</span></span></a></li>
      <li class="bulletList"><span class="koboSpan" id="kobo.850.1">Secure Scripting: A Step-by-Step Guide to Password Automation in Linux with Bash: </span><a href="mailto:https://medium.com/@GeorgeBaidooJr/secure-scripting-a-step-by-step-guide-to-password-automation-in-linux-with-bash-12aa6b980acf"><span class="url"><span class="koboSpan" id="kobo.851.1">https://medium.com/@GeorgeBaidooJr/secure-scripting-a-step-by-step-guide-to-password-automation-in-linux-with-bash-12aa6b980acf</span></span></a></li>
    </ul>
    <h1 id="_idParaDest-384" class="heading 1"><span class="koboSpan" id="kobo.852.1">Answers</span></h1>
    <ol>
      <li class="numberedList" value="1"><span class="koboSpan" id="kobo.853.1">b</span></li>
      <li class="numberedList"><span class="koboSpan" id="kobo.854.1">c</span></li>
      <li class="numberedList"><span class="koboSpan" id="kobo.855.1">b</span></li>
    </ol>
    <h1 id="_idParaDest-385" class="heading 1"><span class="koboSpan" id="kobo.856.1">Join our community on Discord!</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.857.1">Read this book alongside other users, Linux experts, and the author himself. </span></p>
    <p class="normal"><span class="koboSpan" id="kobo.858.1">Ask questions, provide solutions to other readers, chat with the author via Ask Me Anything sessions, and much more. </span><span class="koboSpan" id="kobo.858.2">Scan the QR code or visit the link to join the community.</span></p>
    <p class="normal"><a href="https://packt.link/SecNet"><span class="url"><span class="koboSpan" id="kobo.859.1">https://packt.link/SecNet</span></span></a></p>
    <p class="normal"><span class="koboSpan" id="kobo.860.1"><img src="../Images/QR_Code10596186092701843.png" alt=""/></span></p>
<h1 id="_idParaDest-4" class="heading 1"><span class="koboSpan" id="kobo.861.1">Leave a Review!</span></h1>
    <p class="normal"><span class="koboSpan" id="kobo.862.1">Thank you for purchasing this book from Packt Publishing—we hope you enjoy it! </span><span class="koboSpan" id="kobo.862.2">Your feedback is invaluable and helps us improve and grow. </span><span class="koboSpan" id="kobo.862.3">Once you've completed reading it, please take a moment to leave an Amazon review; it will only take a minute, but it makes a big difference for readers like you.</span></p>
    <p class="normal"><span class="koboSpan" id="kobo.863.1">Scan the QR code below to receive a free ebook of your choice.</span></p>
    <p class="normal"><a href="https://packt.link/NzOWQ"><span class="url"><span class="koboSpan" id="kobo.864.1">https://packt.link/NzOWQ</span></span></a></p>
    <p class="normal"><span class="koboSpan" id="kobo.865.1"><img src="../Images/review.png" alt=""/></span></p>
  </div>
</body></html>