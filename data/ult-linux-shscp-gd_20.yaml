- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: Shell Script Security
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell 脚本安全性
- en: Thus far, we haven’t talked a whole lot about shell scripting security. Frankly,
    it’s because it’s one of those things that you might never have to worry about.
    I mean, a lot of times you’ll just be writing scripts for your own use, that you’ll
    just be running from your home directory on your own local machine. Even if you’re
    an administrator who needs to create scripts that perform some sort of administrative
    task, you might only need to either run them on from your own home directory or
    share them with other *trusted* administrators who just run them from their own
    home directories. In these cases, shell scripting security isn’t necessarily a
    huge deal.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论很多关于 Shell 脚本安全性的话题。坦白说，这是因为它可能是你从来不需要担心的事情。我的意思是，很多时候你编写的脚本只是供自己使用，你可能只是从自己本地机器的主目录运行它们。即使你是一个需要创建执行某些管理任务的脚本的管理员，你也可能只需要在自己的主目录中运行它们，或者与其他*受信任*的管理员共享他们并从各自的主目录中运行它们。在这些情况下，Shell
    脚本安全性不一定是一个大问题。
- en: However, you may at times need to share your script with other users or administrators
    that you don’t fully trust. In these cases, shell scripting security is *extremely
    important*, and should be a major part of your scripting focus. For example, you
    might have some sort of administrative script that you need to place into a directory
    that administrators with only limited permissions can access. In those cases,
    you also need to ensure that nobody can modify it, and that only certain designated
    administrators can execute it. You’ll also want to design the script in a way
    that will prevent bad actors from using it to perform command injection attacks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能需要与其他用户或管理员共享你的脚本，而你并不完全信任他们。在这种情况下，Shell 脚本安全性是*极其重要*的，并且应该成为你脚本编写的主要关注点。例如，你可能有一些管理脚本，需要将其放入一个只有有限权限的管理员才能访问的目录。在这些情况下，你还需要确保没有人可以修改它，并且只有某些指定的管理员可以执行它。你还需要设计脚本，以防止恶意用户利用它进行命令注入攻击。
- en: 'Topics in this chapter include:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题包括：
- en: Controlling Access to Your Scripts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制对脚本的访问
- en: Understanding SUID and SGID Considerations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 SUID 和 SGID 的注意事项
- en: Avoiding Sensitive Data Leakage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免敏感数据泄露
- en: Understanding Command Injection with `eval`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `eval` 的命令注入
- en: Understanding Path Security
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解路径安全
- en: If you’re ready, let’s get going.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你准备好了，我们就开始吧。
- en: Technical Requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: I’ll mainly be working with Fedora Server and Ubuntu Server virtual machines.
    But, the techniques that I’ll show you should work on just about any Linux distro.
    I’ll also be showing you some things on a FreeBSD 14 virtual machine, and an OpenIndiana
    virtual machine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我将主要使用 Fedora Server 和 Ubuntu Server 虚拟机进行工作。不过，我展示的技巧应该适用于几乎任何 Linux 发行版。我还会在
    FreeBSD 14 虚拟机和 OpenIndiana 虚拟机上展示一些内容。
- en: 'As always, you can grab the scripts by doing:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，你可以通过以下方式获取脚本：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Controlling Access to Your Scripts
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制对脚本的访问
- en: A lot of the scripts that you create might be just for yourself or your co-workers.
    Or, they might be for general distribution to the public. In all of these cases,
    you might not need to worry about having any kind of access control on your scripts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的大多数脚本可能仅供自己或同事使用。或者，它们可能是公开分发的。在所有这些情况下，你可能不需要担心对脚本设置任何访问控制。
- en: 'But, there might also be times when you need to create scripts that only certain
    people can access. The methods that you can use for this include:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有时你可能需要创建只能由特定人员访问的脚本。你可以使用的这些方法包括：
- en: Assigning `sudo` privileges
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配`sudo`权限
- en: Assigning an Access Control List
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配访问控制列表
- en: Obfuscating plain-text scripts
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混淆明文脚本
- en: We’ll begin by looking using `sudo`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用`sudo`进行查看。
- en: Assigning sudo Privileges
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配 sudo 权限
- en: '`sudo` is a handy security feature that is installed by default on macOS, OpenIndiana
    and most Linux distros. It’s also available for installation on most BSD-type
    distros and any Linux distros on which it isn’t installed by default. The most
    common way to use `sudo` is to allow non-privileged users to run programs with
    root user privileges. (You can also use `sudo` to allow users to run programs
    with the privileges of other non-root users, such as a database user. I’m not
    going to go into all that now though, because I’m trying to keep things simple.)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo`是一个便捷的安全功能，默认安装在macOS、OpenIndiana和大多数Linux发行版中。它也可以安装在大多数BSD类型的发行版上，或任何未默认安装它的Linux发行版中。使用`sudo`的最常见方式是允许非特权用户以root用户权限运行程序。（你也可以使用`sudo`让用户以其他非root用户的权限运行程序，比如数据库用户。不过我现在不打算讲这些内容，因为我想保持简单。）'
- en: Now, here’s what makes `sudo` so cool. Let’s say that you want a particular
    user to run one particular program with root user privileges. With `sudo`, you
    don’t have to give that user the root user password. Instead, just configure the
    user’s `sudo` privileges for the program, and then let the user enter his or her
    own password whenever he or she needs to run the program. Let’s look at how that
    works.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看是什么让`sudo`如此酷。假设你想让某个特定的用户以root用户权限运行一个特定的程序。使用`sudo`，你无需给该用户root用户的密码。相反，你只需为该程序配置该用户的`sudo`权限，然后让该用户在运行程序时输入自己的密码。我们来看一下是如何实现的。
- en: Hands-on Lab ­– Configuring sudo
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实践实验 – 配置sudo
- en: In this lab, you’ll create a simple script, and configure `sudo` so that only
    designated users can run it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，你将创建一个简单的脚本，并配置`sudo`，使得只有指定的用户能够运行它。
- en: 'Create the `sudo_demo1.sh` script, like this:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`sudo_demo1.sh`脚本，如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Copy the script to the `/usr/local/sbin/` directory:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本复制到`/usr/local/sbin/`目录：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you see, copying this script to `/user/local/sbin/` caused the ownership
    of the file to automatically change to the root user.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，将该脚本复制到`/user/local/sbin/`后，文件的所有权会自动更改为root用户。
- en: 'Set permissions on the `sudo_demo1.sh` file so that only the root user can
    access it:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`sudo_demo1.sh`文件的权限，使得只有root用户能够访问它：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note how in the `chmod 700` command, the 7 assigns read, write, and execute
    privileges to the root user. The two 0s remove all privileges from the *group*
    and from *others*. But, how do we obtain the value of 7 in the *user* position?
    Here’s the breakdown on how it works:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`chmod 700`命令中，7为root用户分配了读取、写入和执行权限。两个0则从*组*和*其他*用户那里移除了所有权限。但，如何在*用户*位置获得7的值呢？下面是它的详细解释：
- en: The *read* permission has a value of 4.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*读取*权限的值为4。'
- en: The *write* permission has a value of 2.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*写入*权限的值为2。'
- en: The *execute* permission has a value of 1.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*执行*权限的值为1。'
- en: In this case, we want the user to have full read, write, and execute permissions.
    Adding the values of all three of those permissions gives us a value of 7\.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望用户具有完全的读取、写入和执行权限。将这三种权限的值相加得到的值为7\。
- en: (I know that this is a rather cursory explanation, but for now, please bear
    with me.)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: （我知道这是一个相当简略的解释，但现在请你耐心点。）
- en: Create a non-privileged user account for Horatio.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Horatio创建一个非特权用户帐户。
- en: 'On Debian/Ubuntu, do:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian/Ubuntu中，执行：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On Fedora and other Red Hat-type distros:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fedora和其他Red Hat类型的发行版中：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Begin configuring `sudo` by entering:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始配置`sudo`，请输入以下命令：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command will open the `/etc/sudoers` file in either `nano`, `vi`, or `vim`,
    depending upon which operating system you’re working with. Beyond that, the directions
    are the same.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将在`nano`、`vi`或`vim`中打开`/etc/sudoers`文件，具体取决于你所使用的操作系统。除此之外，操作步骤是一样的。
- en: 'Scroll down until you see this line:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动，直到看到以下这一行：
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Directly below that line, place this line:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在那一行的正下方，加入以下这一行：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Save the file as you would with a normal text editor.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用普通文本编辑器保存文件。
- en: 'I know that the `ALL=(ALL:ALL)` thing looks confusing, but it’s really quite
    simple. Here’s the TL;DR of what it means:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道`ALL=(ALL:ALL)`这一行看起来很困惑，但实际上它非常简单。下面是它的简要解释：
- en: ON_HOSTS=(AS_USER:AS_GROUP_MEMBER) ALLOWED_COMMANDS
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ON_HOSTS=(AS_USER:AS_GROUP_MEMBER) ALLOWED_COMMANDS
- en: 'Now, here’s the more specific breakdown:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以下是更具体的说明：
- en: The first `ALL` means that the specified user can run this command on all machines
    on the local network. Optionally, you can replace this `ALL` with the hostname
    of a particular machine or groups of machines on which you want this user to be
    able to run this command.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`ALL`表示指定用户可以在本地网络上的所有机器上运行此命令。你也可以选择将这个`ALL`替换为特定机器或机器组的主机名，来限制此用户仅能在这些机器上运行该命令。
- en: The second `ALL` means that the specified user can run this command as all users,
    including the root user.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`ALL`表示指定用户可以作为所有用户运行此命令，包括root用户。
- en: The third `ALL` means that Horatio can run this command as a member of all groups,
    including the root user’s group. (Note that this is optional. You can also just
    omit the group, and set this to `ALL=(ALL)`.)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个`ALL`表示Horatio可以作为所有组的成员运行此命令，包括root用户的组。（请注意，这是可选的。你也可以省略该组，并将其设置为`ALL=(ALL)`。）
- en: In the `root` line, the final `ALL` means that the root user can run all privileged
    commands. In the `horatio` line, the final `ALL` is replaced by the specific command
    that we want to allow Horatio to run.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`root`行中，最后的`ALL`表示root用户可以运行所有特权命令。在`horatio`行中，最后的`ALL`被替换为我们希望Horatio运行的特定命令。
- en: Open another terminal window on your host machine, and log into the virtual
    machine with Horatio’s account.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主机机器上打开另一个终端窗口，并使用Horatio的账户登录到虚拟机。
- en: 'Have Horatio test this by first trying to run the script without `sudo`, and
    then with `sudo`, like this:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让Horatio通过首先尝试在没有`sudo`的情况下运行脚本，然后再使用`sudo`，像这样测试：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You see that Horatio can run the script with his `sudo` privileges.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到Horatio可以使用他的`sudo`权限运行该脚本。
- en: 'Have Horatio attempt to view the script’s source code, like so:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让Horatio尝试查看脚本的源代码，像这样：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Horatio can’t view or edit the source code, because he doesn’t have the proper
    `sudo` privileges for that. He has `sudo` privileges to do one thing, and one
    thing only, as the root user, which is just to execute the `sudo_demo1.sh` script.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Horatio无法查看或编辑源代码，因为他没有适当的`sudo`权限来执行此操作。他仅拥有作为root用户的`sudo`权限，这个权限仅限于执行`sudo_demo1.sh`脚本。
- en: That does it for our introduction to the mysteries of `sudo`. Let’s move on
    to our next method of controlling access to scripts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们介绍`sudo`的内容。接下来，让我们继续介绍另一种控制脚本访问的方法。
- en: Using an Access Control List
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问控制列表（ACL）
- en: If you’ve ever been a Windows administrator, you likely know that the NTFS filesystem
    on Windows allows you to grant really fine-grained permissions settings on files
    and directories. Sadly, the filesystems on Linux, Unix, and Unix-like systems
    don’t have such fine-grained access control built into them. But, we can make
    up for that deficiency somewhat by using an **Access Control List**, or **ACL**.
    Let’s look at how to do that in this hands-on lab.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾是Windows管理员，你可能知道Windows上的NTFS文件系统允许你对文件和目录设置非常细粒度的权限。遗憾的是，Linux、Unix和类Unix系统上的文件系统并没有内建如此细粒度的访问控制。但我们可以通过使用**访问控制列表**（**ACL**）在一定程度上弥补这一缺陷。让我们看看如何在这个实践实验中做到这一点。
- en: Hands-on Lab – Setting an ACL for Horatio on Linux
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实践实验——在Linux上为Horatio设置ACL
- en: In this lab, we’ll create another script for which only Horatio will have permission
    to run. To keep things simple, just use the same virtual machine that you used
    for the previous lab, so that you won’t have to create another user account.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将创建另一个脚本，只有Horatio有权限运行。为了简化操作，直接使用你之前用于实验的虚拟机，这样你就无需再创建另一个用户账户。
- en: 'You’ll find everything you need for setting up ACLs already installed on your
    Fedora virtual machine. If you’re using a Debian/Ubuntu type of machine, you might
    have to install the `acl` package by doing:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会发现你在Fedora虚拟机上设置ACL所需的一切已经安装好。如果你使用的是Debian/Ubuntu类型的机器，你可能需要通过以下方式安装`acl`软件包：
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Log into your own normal user account, and create the `acl_demo.sh` script,
    like this:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到你自己的普通用户账户，并创建`acl_demo.sh`脚本，像这样：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Copy the script to the `/usr/local/sbin/` directory, and note how the ownership
    automatically changes to the root user:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本复制到`/usr/local/sbin/`目录，并注意所有权如何自动更改为root用户：
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In order for an ACL to work, you’ll need to remove all permissions from group
    and others, like this:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使ACL生效，你需要从组和其他用户中移除所有权限，像这样：
- en: '[PRE14]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is because the whole point of using an ACL is to prevent everyone who hasn’t
    been set up with an ACL from accessing the file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为使用ACL的关键在于防止那些没有被设置ACL的用户访问文件。
- en: 'Use `getfacl` to verify that no ACL has been set:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`getfacl`验证是否设置了ACL：
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In another terminal window, log into Horatio’s account, and try to run the
    `acl_demo.sh` script, like so:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，登录Horatio的帐户，并尝试运行`acl_demo.sh`脚本，如下所示：
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You see that Horatio has been denied.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到Horatio已被拒绝访问。
- en: 'Go back to your own terminal window. Create an ACL so that Horatio will have
    read and execute permissions on the `acl_demo.sh` script, like so:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到你自己的终端窗口。创建一个ACL，使Horatio在`acl_demo.sh`脚本上拥有读取和执行权限，如下所示：
- en: '[PRE17]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here’s the breakdown of the command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是命令的详细解释：
- en: '`-m`: This means to modify the existing ACL. It will also create an ACL if
    one hasn’t been created yet.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-m`：这意味着修改现有的ACL。如果尚未创建ACL，它还会创建一个。'
- en: '`u:horatio`: This means that we’re creating an ACL for user `horatio`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u:horatio`：这表示我们正在为用户`horatio`创建一个ACL。'
- en: '`rx`: This means that we’re granting the read and execute permissions for this
    file to the specified user.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rx`：这意味着我们为指定用户授予该文件的读取和执行权限。'
- en: Note the `+` at the end of the permissions settings for this file. This indicates
    that an ACL has been created.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意文件权限设置末尾的`+`。这表示已经创建了一个ACL。
- en: 'Use `getfacl` to verify that the ACL was created properly:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`getfacl`验证ACL是否已正确创建：
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `user:horatio:r-x` line indicates that the ACL has been created for Horatio.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`user:horatio:r-x`行表示已为Horatio创建了ACL。'
- en: 'Go back to Horatio’s terminal window, and have him try to run the script:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到Horatio的终端窗口，让他尝试运行脚本：
- en: '[PRE19]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This time, Horatio has achieved coolness.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，Horatio达到了酷炫的境界。
- en: 'There is one downside to using an ACL instead of `sudo`. That is, `sudo` automatically
    assumes that a user needs to read a shell script in order to execute it. So, `sudo`
    allows a user to execute the script without explicitly setting the read permission
    for that user. This means that the user won’t be able to use any utility such
    as `cat` or `less` to view the contents of the script file. When using an ACL,
    the read permission and the execute permission both have to be explicitly set
    on the script to allow someone to run it. So, when using an ACL, you won’t be
    able to prevent the user from viewing the contents of the file. You can prove
    that by having Horatio view the file, like so:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用ACL而不是`sudo`有一个缺点。即，`sudo`会自动假设用户需要读取一个Shell脚本才能执行它。因此，`sudo`允许用户在没有明确设置读取权限的情况下执行脚本。这意味着用户无法使用任何实用工具（如`cat`或`less`）查看脚本文件的内容。而使用ACL时，必须显式地为脚本设置读取权限和执行权限，才能让某人执行它。所以，使用ACL时，你不能防止用户查看文件内容。你可以通过让Horatio查看文件来证明这一点，如下所示：
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The bottom line here is that if you want to prevent users from viewing the contents
    of your scripts, set them up with the appropriate `sudo` privileges instead of
    using an ACL. On the other hand, if you don’t mind that users can view the script’s
    source code, then using an ACL is definitely an option.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的结论是，如果你想防止用户查看脚本内容，可以设置适当的`sudo`权限，而不是使用ACL。另一方面，如果你不介意用户查看脚本的源代码，那么使用ACL肯定是一个可行的选项。
- en: Space doesn’t allow for me to present more than just a cursory coverage of permissions
    settings, `sudo`, and ACLs in this chapter. If you need more information about
    them, I have entire chapters devoted to each of these topics in my *Mastering
    Linux Security and Hardening* book.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本章篇幅有限，无法详细介绍权限设置、`sudo`和ACL的内容。如果你需要更多信息，我在我的《精通Linux安全与加固》书中有专门的章节介绍每个主题。
- en: That’s does it for `sudo` and ACLs on Linux. Let’s now see how to do it on FreeBSD
    14.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`sudo`和Linux上的ACL的全部内容。现在让我们看看如何在FreeBSD 14上实现。
- en: Hands-on Lab – Setting an ACL for Horatio on FreeBSD 14
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实操实验 – 在FreeBSD 14上为Horatio设置ACL
- en: You’ll find everything you need for creating ACLs already installed on FreeBSD
    14\. Let’s begin.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在FreeBSD 14上，你会发现所有用于创建ACL的工具已经安装好了。我们开始吧。
- en: 'Create Horatio’s user account by doing:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下操作创建Horatio的用户帐户：
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The FreeBSD `adduser` command is interactive, similar to the `adduser` command
    on Debian and Ubuntu. After you invoke it, you’ll just need to enter Horatio’s
    information, as prompted. Here’s what it looks like:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD的`adduser`命令是交互式的，类似于Debian和Ubuntu上的`adduser`命令。调用它之后，你只需按照提示输入Horatio的信息。以下是操作界面的样子：
- en: '![B21693_20_1](img/B21693_20_01.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_20_1](img/B21693_20_01.png)'
- en: 'Figure 20.1: Adding a user account to FreeBSD'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.1：向FreeBSD添加用户帐户
- en: In case you’re wondering about the **Full Name** field, it’s just that Horatio
    really is a black cat who’s been visiting me lately.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对**全名**字段感到好奇，那只是因为Horatio真的是一只最近经常光顾我的黑猫。
- en: 'Use the same `acl_demo.sh` script that you used for the Linux lab. Copy it
    to the `/usr/local/sbin/` directory, and verify that ownership has changed to
    the root user:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你在 Linux 实验中使用的相同的`acl_demo.sh`脚本。将它复制到`/usr/local/sbin/`目录，并验证其所有权已更改为 root
    用户：
- en: '[PRE22]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Apply the 700 permissions setting to `acl_demo.sh`. This will mean that the
    root user will have read, write, and execute permissions, and that *group* and
    *others* have no permissions.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `acl_demo.sh` 应用 700 权限设置。这将意味着 root 用户将具有读、写和执行权限，而 *组* 和 *其他用户* 没有权限。
- en: '[PRE23]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In another terminal window, log into Horatio’s user account on the FreeBSD machine.
    Then, have him attempt to run the `acl_demo.sh` script.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，登录到 FreeBSD 机器上 Horatio 的用户账户。然后，让他尝试运行 `acl_demo.sh` 脚本。
- en: '[PRE24]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Go back to your own terminal window, and set the ACL for Horatio, like so:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到你自己的终端窗口，并像这样为 Horatio 设置 ACL：
- en: '[PRE25]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that the command is slightly different this time, because Linux uses the
    **Network Filesystem version 4** (**NFSv4**) style of ACLs, and FreeBSD uses the
    POSIX style of ACLs. It’s not a big difference, though. It’s just that with FreeBSD,
    you have to add `allow` to the `setfacl` command.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，这次命令略有不同，因为 Linux 使用 **网络文件系统版本 4** (**NFSv4**) 样式的 ACL，而 FreeBSD 使用 POSIX
    样式的 ACL。不过，这并不是一个大差异。只是 FreeBSD 需要在 `setfacl` 命令中添加 `allow`。
- en: 'Verify that the ACL has been properly set:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 ACL 是否已正确设置：
- en: '[PRE26]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You see that indeed, Horatio does have read and execute permissions for this
    script.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，Horatio 确实对这个脚本拥有读和执行权限。
- en: 'Go back to Horatio’s terminal, and have him try to run the `acl_demo.sh` command:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 Horatio 的终端，让他尝试运行 `acl_demo.sh` 命令：
- en: '[PRE27]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It works, which means that Horatio has now achieved coolness on FreeBSD.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效，这意味着 Horatio 现在在 FreeBSD 上实现了酷炫。
- en: Next, let’s give this a try on OpenIndiana.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在 OpenIndiana 上试试看。
- en: Hands-on Lab – Setting an ACL for Horatio on OpenIndiana
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实验操作 – 在 OpenIndiana 上为 Horatio 设置 ACL
- en: Doing this on OpenIndiana will be considerably different, because it doesn’t
    use `setfacl` or `getfacl` to manage ACLs. Instead, it uses `chmod` for managing
    both normal permissions settings and ACLs. You’ll once again use the same `acl_demo.sh`
    script that you used for the previous labs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenIndiana 上执行此操作会大不相同，因为它不使用 `setfacl` 或 `getfacl` 来管理 ACL。相反，它使用 `chmod`
    来管理正常的权限设置和 ACL。你将再次使用你在之前实验中使用的相同的 `acl_demo.sh` 脚本。
- en: 'Create Horatio’s user account, like this:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Horatio 的用户账户，如下所示：
- en: '[PRE28]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `-m` option tells `useradd` to create the new user’s home directory. On
    the OpenIndiana version of `useradd`, this is normally the only option switch
    that you’ll need.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`-m` 选项告诉 `useradd` 创建新用户的主目录。在 OpenIndiana 版本的 `useradd` 中，通常这是你唯一需要的选项开关。'
- en: There’s no `/usr/local/` directory on OpenIndiana, so just copy the `acl_demo.sh`
    script to the `/usr/sbin/` directory, instead. Then, verify that the ownership
    has changed to the root user.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenIndiana 上没有 `/usr/local/` 目录，因此只需将 `acl_demo.sh` 脚本复制到 `/usr/sbin/` 目录。然后，验证所有权已更改为
    root 用户。
- en: '[PRE29]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Change the permissions setting of the `acl_demo.sh` file to 700, as you did
    in the previous labs:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `acl_demo.sh` 文件的权限设置更改为 700，如你在之前的实验中所做的：
- en: '[PRE30]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In another terminal window, log into Horatio’s account. Have him try to run
    the `acl_demo.sh` script:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，登录到 Horatio 的账户。让他尝试运行 `acl_demo.sh` 脚本：
- en: '[PRE31]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, apply an ACL for Horatio, granting him both read and execute privileges
    for the `acl_demo.sh` script:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为 Horatio 应用一个 ACL，授予他对 `acl_demo.sh` 脚本的读和执行权限：
- en: '[PRE32]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note how instead of using `setfacl -m u:horatio`, OpenIndiana uses `chmod A+user:horatio`.
    The `A+` in this case just means that we’re adding an ACL.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不同于使用 `setfacl -m u:horatio`，OpenIndiana 使用 `chmod A+user:horatio`。这里的 `A+`
    仅表示我们正在添加一个 ACL。
- en: 'Go back to Horatio’s terminal, and have him try to run the script:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 Horatio 的终端，让他尝试运行脚本：
- en: '[PRE33]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Yes, indeed. Even on OpenIndiana, Horatio has achieved coolness.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，确实如此。即使在 OpenIndiana 上，Horatio 也实现了酷炫。
- en: If you need to learn about OpenIndiana administration, you’ll find that the
    official documentation at the OpenIndiana website is rather lacking. Fortunately,
    OpenIndiana is a fork of Oracle’s Solaris operating system, which means that you
    can use the official Solaris documentation, instead. (I’ve placed a link to the
    relevant page in the *Further Reading* section.)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要了解 OpenIndiana 的管理，你会发现 OpenIndiana 网站上的官方文档相当缺乏。幸运的是，OpenIndiana 是 Oracle
    的 Solaris 操作系统的一个分支，这意味着你可以使用官方的 Solaris 文档。 (我已经在 *进一步阅读* 部分提供了相关页面的链接。)
- en: I think that that about covers it for ACLs. Let’s move on to another way to
    control access to your scripts.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这大致涵盖了ACLs。让我们继续探讨另一种控制对脚本访问权限的方法。
- en: Obfuscating Plain-Text Scripts
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混淆明文脚本
- en: 'You can also hide the contents of your shell scripts and prevent anyone from
    tampering with them by using the `shc` utility to convert your scripts into obfuscated
    executable binary files. And, you can do some things with `shc` that you can’t
    do with either `sudo` or ACLs. Specifically, `shc` allows you to:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`shc`实用程序隐藏shell脚本的内容，防止任何人篡改它们，将您的脚本转换为混淆的可执行二进制文件。而且，您可以通过`shc`做一些使用`sudo`或ACLs无法做到的事情。具体来说，`shc`允许您：
- en: Create an executable file that can run on only one machine.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个只能在一台机器上运行的可执行文件。
- en: Set expiration dates for the executable files.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为可执行文件设置过期日期。
- en: Create executable files that can’t be traced with debugging utilities such as
    `strace` or `truss`. (I’ll explain those in just a bit.)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建无法使用诸如`strace`或`truss`等调试工具追踪的可执行文件。（稍后我会解释这些工具。）
- en: Let’s begin by installing `shc`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始安装`shc`。
- en: Installing shc
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装shc
- en: 'It’s easy to install on Linux, FreeBSD, and macOS. Here’s how it’s done:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux、FreeBSD和macOS上安装很简单。操作如下：
- en: 'On Fedora:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fedora上：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'On Debian/Ubuntu:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian/Ubuntu上：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that on Linux, you also need to install the `gcc` package so that you will
    have a C compiler that will work with `shc`. On FreeBSD, the C compiler gets installed
    as part of the operating system.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Linux上，您还需要安装`gcc`包，以便具有可以与`shc`一起工作的C编译器。在FreeBSD上，C编译器作为操作系统的一部分安装。
- en: 'On FreeBSD:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在FreeBSD上：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'On macOS with Homebrew installed:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了Homebrew的macOS上：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Sadly, `shc` isn’t available for OpenIndiana.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，`shc`在OpenIndiana上不可用。
- en: Hands-on Lab – Using shc
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实验室实践 – 使用shc
- en: For this lab, you’ll create the `supersecret.sh` script on your Fedora virtual
    machine. Also, go ahead and boot up your Debian/Ubuntu virtual machine, so that
    you can test your compiled scripts on it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实验中，您将在您的Fedora虚拟机上创建`supersecret.sh`脚本。另外，请启动您的Debian/Ubuntu虚拟机，以便可以在其上测试编译后的脚本。
- en: 'Using `shc` is simple. To demo, let’s create the `supersecret.sh` script, like
    this:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shc`很简单。为了演示，让我们创建`supersecret.sh`脚本，就像这样：
- en: '[PRE38]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is just a simple *here document* that prints out a message, which looks
    like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的*here document*，打印出一个消息，看起来像这样：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The next step is to convert the shell script into an obfuscated binary file,
    like so:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个步骤是将shell脚本转换为混淆的二进制文件，如下所示：
- en: '[PRE40]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As you see, I’m using the `-f` option to point to the shell script that I want
    to obfuscate, and the `-o` option to save the obfuscated binary file with the
    specified filename. This operation also creates a C language source file, as you
    see here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我使用`-f`选项指向我要混淆的shell脚本，并使用`-o`选项将混淆后的二进制文件保存为指定的文件名。此操作还会创建一个C语言源文件，如您所见：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`shc` works by first creating this C source code file, and then by calling
    a C compiler to compile the C source code into the binary file. You can prove
    that this works by trying to open the binary file with `cat`, like so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`shc`的工作方式首先是创建这个C源代码文件，然后调用C编译器将C源代码编译成二进制文件。您可以尝试使用`cat`打开二进制文件来证明这一点，如下所示：'
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you can read that, then you’re better than I am.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能读懂这些内容，那么您比我更强。
- en: 'Try running this new `supersecret` binary, and you’ll see that it works just
    like the script:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试运行这个新的`supersecret`二进制文件，您会发现它的工作方式与脚本一样：
- en: '[PRE43]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Okay, let’s be real. You’re not going to obfuscate a simple script that does
    nothing but print out a message. I mean, anyone who can execute this binary file
    can still see the message. So, let’s just say that your script contains a lot
    of additional code or data that you want to hide from everyone, including even
    the authorized users of the script. You also want to ensure that nobody can modify
    your scripts. In cases like that, `shc` is definitely a useful tool.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们真实一点。您不会对一个只打印消息的简单脚本进行混淆。我的意思是，任何能执行这个二进制文件的人仍然可以看到消息。因此，让我们只是说您的脚本包含了很多额外的代码或数据，您希望将其隐藏，甚至包括脚本的授权用户在内。在这种情况下，`shc`绝对是一个有用的工具。
- en: 'By default, `shc` creates binary files that will only run on the machine on
    which they were created. For example, let’s see what happens when I transfer the
    `supersecret` binary that I created on this Fedora machine to an Ubuntu machine:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`shc`创建的二进制文件只能在创建它们的机器上运行。例如，让我们看看我将在这台Fedora机器上创建的`supersecret`二进制文件转移到Ubuntu机器上会发生什么：
- en: '[PRE44]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That’s definitely a handy security feature, because it allows you to control
    where your program can be run. So, if a malicious hacker were to somehow find
    your program and download it, he or she wouldn’t be able to run it. The only catch
    is that we see the default `Please contact your provider. . .` message that’s
    built into `shc`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是一个方便的安全特性，因为它允许你控制程序可以运行的地方。所以，如果恶意黑客不小心找到并下载了你的程序，他们将无法运行它。唯一的缺点是，我们会看到
    `shc` 内置的默认消息 `Please contact your provider. . .`。
- en: 'The default `Please contact your provider. . .` message doesn’t mean anything
    to us, because it provides us with a bogus contact address. On the Fedora machine,
    fix that by adding the `-m` option and a custom message, like this:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认的 `Please contact your provider. . .` 消息对我们来说没有意义，因为它提供了一个虚假的联系地址。在 Fedora
    机器上，通过添加 `-m` 选项和自定义消息来解决这个问题，像这样：
- en: '[PRE45]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Transfer the new `supersecret` binary file to the Debian/Ubuntu machine, and
    try to run it. You should now see your custom message, like this:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的 `supersecret` 二进制文件传输到 Debian/Ubuntu 机器上，然后尝试运行它。你现在应该能看到你自定义的消息，像这样：
- en: '[PRE46]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Of course, you could also add your own contact address, if you really wanted
    to.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你真的想要的话，你也可以添加你自己的联系地址。
- en: 'Sometimes though, you might want to create binary files that will run on any
    machine that’s running the same operating system as the machine on which you created
    them. To do that, just relax the security a bit with the `-r` option, like so:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不过，有时你可能希望创建能够在任何与创建它们的机器相同操作系统上运行的二进制文件。为了做到这一点，只需使用 `-r` 选项稍微放宽一些安全性，像这样：
- en: '[PRE47]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When I transfer this new binary file to my Ubuntu machine, it will run just
    fine, as you see here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将这个新的二进制文件传输到我的 Ubuntu 机器上时，它将正常运行，正如你在这里看到的：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Also, understand that `shc` creates binary files that can run on only one type
    of operating system. To see how that works, let’s transfer the binary that I created
    on my Fedora machine to a FreeBSD machine. Here’s what happens when I try to run
    it:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，理解 `shc` 会创建只能在某种操作系统上运行的二进制文件。为了查看其工作原理，让我们将我在 Fedora 机器上创建的二进制文件传输到 FreeBSD
    机器上。下面是当我尝试运行它时发生的情况：
- en: '[PRE49]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: But, if you transfer the original script to the FreeBSD machine and then run
    `shc` on it, you’ll get a binary that will run on FreeBSD.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你将原始脚本传输到 FreeBSD 机器上，然后在其上运行 `shc`，你会得到一个能在 FreeBSD 上运行的二进制文件。
- en: The good news here is that `shc` works exactly the same on FreeBSD as it does
    on Linux. So, you won’t even have to modify your `shc` commands.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，`shc` 在 FreeBSD 上的工作方式与在 Linux 上完全相同。所以，你甚至不需要修改你的 `shc` 命令。
- en: 'The next `shc` option I’ll cover is the `-e` option, which allows you to set
    an expiration date on your program. Just specify the expiration date in the day-month-year
    (dd/mm/yyyy) format, like so:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的 `shc` 选项是 `-e` 选项，它允许你为程序设置过期日期。只需按日-月-年（dd/mm/yyyy）格式指定过期日期，像这样：
- en: '[PRE50]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: I’m doing this on 1 July 2024, so I’ll have to come back tomorrow to see if
    this actually works. So bye for now, I’ll see you tomorrow.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在是在2024年7月1日做这个，所以我得等到明天才能看到这个是否真的有效。那么现在先说再见，明天见。
- en: 'Okay, it’s now 2 July 2024, and I’m back. Let’s see if this `supersecret` binary
    file still works:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在是2024年7月2日，我回来了。让我们看看这个 `supersecret` 二进制文件是否还有效：
- en: '[PRE51]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Cool, the expiration date option works just fine.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，过期日期选项工作得非常好。
- en: '**Remember**: Even when you obfuscate your scripts with `shc`, you’ll still
    need to use either `sudo` or an ACL to control who can execute them on a particular
    machine.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**记住**：即使你通过 `shc` 混淆了脚本，仍然需要使用 `sudo` 或 ACL 来控制谁可以在特定机器上执行它们。'
- en: Now, let’s see about making our executables untraceable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何让我们的可执行文件无法被追踪。
- en: Hands-on Lab – Creating Untraceable Executables
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实验室练习 – 创建无法追踪的可执行文件
- en: As you’ll see in the next chapter, we have several tracing tools available to
    help programmers debug programs. These tools include `strace` for Linux systems,
    `truss` for FreeBSD, and either `dtrace` or `dtruss` for macOS. For Linux, there’s
    also `ltrace`, which can trace calls to programming libraries.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在下一章看到的，我们有多种跟踪工具可以帮助程序员调试程序。这些工具包括适用于 Linux 系统的 `strace`，适用于 FreeBSD 的
    `truss`，以及适用于 macOS 的 `dtrace` 或 `dtruss`。对于 Linux，还有 `ltrace`，它可以跟踪对编程库的调用。
- en: The `strace`, `dtrace`, `truss`, and `dtruss` utilities can trace the **system
    calls** that a program makes. The easiest way to explain system calls is that
    they’re the mechanism that programs use to communicate with the operating system
    kernel.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace`、`dtrace`、`truss` 和 `dtruss` 工具可以追踪程序所执行的 **系统调用**。解释系统调用最简单的方式是，它们是程序用来与操作系统内核进行通信的机制。'
- en: The problem for us is that either a malicious actor or an unauthorized non-malicious
    actor could also use the information that these utilities provide to reverse engineer
    one of your compiled scripts. This could allow these unauthorized parties to see
    secrets that you don’t want them to see.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说的问题是，恶意或非恶意的未授权人员也可以利用这些工具提供的信息来反向工程你编译的脚本。这可能让这些未授权方看到你不希望他们看到的秘密。
- en: 'What information would we not want unauthorized people to see? Here are two
    examples:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望未授权的人看到哪些信息？以下是两个例子：
- en: '**The names and locations of sensitive files that your program accesses**:
    These files could reveal secrets to unauthorized actors.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的程序访问的敏感文件的名称和位置**：这些文件可能会泄露给未授权的人员重要信息。'
- en: '**Embedded passwords**: Even if you encrypt passwords, using `strace`, `truss`,
    `dtrace`, or `dtruss` on your compiled binary file will reveal the plain-text
    passwords. (You’ll soon see that in the *Avoiding Sensitive Data Leakage* section.)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌入的密码**：即使你加密了密码，使用`strace`、`truss`、`dtrace`或`dtruss`在你编译的二进制文件上，也能泄露明文密码。（你很快会在*避免敏感数据泄漏*部分看到这一点。）'
- en: Needless to say, either of these cases can represent a serious security problem.
    So to be sure, just get into the habit of making your `shc` binaries untraceable,
    as I’m about to show you in this section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 不用说，这两种情况都可能代表一个严重的安全问题。所以，为了确保安全，养成将你的`shc`二进制文件设为不可追踪的习惯，就像我接下来要展示的那样。
- en: 'Here’s how it works:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的工作原理：
- en: 'On the Fedora machine, install `strace` and `ltrace`, like this:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Fedora机器上，安装`strace`和`ltrace`，像这样：
- en: '[PRE52]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: On the Fedora machine, create a new `supersecret` binary without either the
    expiration date or the custom message.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Fedora机器上，创建一个新的`supersecret`二进制文件，去除过期日期和自定义消息。
- en: '[PRE53]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a file that contains `strace` data about the `supersecret` binary, like
    this:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`strace`数据的文件，关于`supersecret`二进制文件，像这样：
- en: '[PRE54]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that the `strace` output gets sent to `stderr`, which is why you have to
    use the `2>` redirector.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`strace`的输出被发送到`stderr`，这就是为什么你需要使用`2>`重定向符号。
- en: 'Open the `supersecret1_trace.txt` file in less. What you’ll see is a jumbled
    up mess that looks something like this:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`less`打开`supersecret1_trace.txt`文件。你会看到一堆乱七八糟的内容，看起来像这样：
- en: '[PRE55]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: For the most part, you would need to be a C language kernel programmer to understand
    what’s going on with this. However, as we’ll soon see, you might be able to glean
    some really important information if you know how to look for it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分情况下，你需要是C语言内核程序员，才能理解发生了什么。但是，正如我们即将看到的，如果你知道如何查找这些信息，你可能会发现一些非常重要的内容。
- en: 'Count how many lines are in the `supersecret1_trace.txt` file, like this:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算`supersecret1_trace.txt`文件中的行数，像这样：
- en: '[PRE56]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: So, there are 297 lines of output in the `supersecret1_trace.txt` file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`supersecret1_trace.txt`文件中有297行输出。
- en: Note that for all of these examples, you might get a different number of output
    lines on your own machines.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于所有这些例子，你在自己的机器上可能会得到不同数量的输出行。
- en: 'Perform an `ltrace` operation on the `supersecret` binary, saving the output
    to the `supersecret1_ltrace.txt` file. Then, count the number of lines in the
    `supersecret1_ltrace.txt` file, like so:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`supersecret`二进制文件执行`ltrace`操作，并将输出保存到`supersecret1_ltrace.txt`文件中。然后，像这样计算`supersecret1_ltrace.txt`文件中的行数：
- en: '[PRE57]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You see that there are 7270 lines in the `supersecret1_ltrace` file.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到`supersecret1_ltrace`文件中有7270行。
- en: Create a new `supersecret` binary. This time though, use the `-U` option to
    make this binary untraceable.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`supersecret`二进制文件。不过这次，使用`-U`选项将该二进制文件设置为不可追踪。
- en: '[PRE58]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You won’t have to delete the original binary before you do this, because this
    new command will overwrite the original binary.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此操作之前，你不必删除原始二进制文件，因为此新命令会覆盖原始的二进制文件。
- en: Run `strace` on the `supersecret` binary again, saving the output to the `supersecret2_tract.txt`
    file.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在`supersecret`二进制文件上运行`strace`，将输出保存到`supersecret2_tract.txt`文件中。
- en: '[PRE59]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This time, `strace` was prevented from doing its job.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，`strace`被阻止执行其功能。
- en: Even with the `-U` option, you’ll still get some output sent to the output file.
    However, it will be much less than you got without the `-U`. Verify that by counting
    the lines in the `supersecret2_trace.txt` file.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使使用了`-U`选项，你仍然会看到一些输出发送到输出文件。不过，这些输出会比没有使用`-U`时少得多。通过计算`supersecret2_trace.txt`文件中的行数来验证这一点。
- en: '[PRE60]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This time, there are only 34 lines of output, which is way less than the 297
    lines that we had without the `-U` switch. So, this is further proof that the
    `-U` option prevents an `strace` operation from being successful.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，输出只有 34 行，比我们在没有 `-U` 开关时的 297 行要少得多。所以，这进一步证明了 `-U` 选项可以防止 `strace` 操作成功。
- en: 'Now, do an `ltrace` on the `supersecret` binary, and save the output to the
    `supersecret2_ltrace.txt` file:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，对 `supersecret` 二进制文件进行 `ltrace`，并将输出保存到 `supersecret2_ltrace.txt` 文件中：
- en: '[PRE61]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Count the lines in the `supersecret2_ltrace.txt` file:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 统计 `supersecret2_ltrace.txt` 文件中的行数：
- en: '[PRE62]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Wow! There are only four lines in the output file this time. That’s a far cry
    from the 7270 lines that we had without the `-U` option.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这次输出文件只有四行。这与我们在没有 `-U` 选项时的 7270 行相差甚远。
- en: 'On FreeBSD, the `shc` commands to create the obfuscated binary files are identical
    to what you’ve seen on Linux. But, to perform system call tracing on FreeBSD binaries,
    use `truss` instead of `strace`, like so:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FreeBSD 上，创建混淆二进制文件的 `shc` 命令和你在 Linux 上看到的一样。但是，要对 FreeBSD 二进制文件进行系统调用追踪，使用
    `truss` 而不是 `strace`，像这样：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As far as I’ve been able to tell, there’s no FreeBSD equivalent to the Linux
    `ltrace` command.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 就我所知，FreeBSD 上并没有与 Linux `ltrace` 命令等效的命令。
- en: On macOS, you have the `dtrace` and `dtruss` commands. But to use them, you’ll
    have to boot your machine into **Recovery** mode and disable the **System Integrity
    Protection** (**SIP**). I don’t recommend doing that unless you absolutely, positively
    have to.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，你可以使用 `dtrace` 和 `dtruss` 命令。但是，要使用它们，你必须将机器启动到**恢复**模式并禁用**系统完整性保护**（**SIP**）。除非你绝对、一定需要这么做，否则我不建议这样操作。
- en: You’ll also see that `dtrace` is available on OpenIndiana. But, since `shc`
    isn’t available on OpenIndiana, I won’t bother to cover it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会发现 `dtrace` 在 OpenIndiana 上是可用的。但是，由于 OpenIndiana 上没有 `shc`，我就不再讨论它了。
- en: Next, let’s see if we can decrypt this script.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看能不能解密这个脚本。
- en: Decrypting shc Binaries
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解密 shc 二进制文件
- en: Many years ago, when I showed `shc` to the students in my first shell scripting
    class, it was somewhat easy to crack the `shc` algorithm in order to convert a
    binary file back to the original shell script. So at that time, `shc` wasn’t a
    very secure option. Now, due to `shc` developers taking advantage of improvements
    in modern operating system kernels, it’s a lot harder to crack `shc`. But, there
    are a couple of utilities that are *supposed* to crack `shc`, or at least that’s
    what their developers say.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 很多年前，当我在第一次教授 shell 脚本课程时，我向学生们展示了 `shc`，那时要破解 `shc` 算法并将二进制文件转换回原始 shell 脚本是相对容易的。所以当时，`shc`
    不是一个非常安全的选项。现在，由于 `shc` 开发者利用了现代操作系统内核的改进，破解 `shc` 要困难得多了。但是，还是有一些工具*应该*能破解 `shc`，或者至少它们的开发者是这么说的。
- en: This might be a bit of a spoiler, but I’ll share it anyway.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有些剧透，但我还是决定分享。
- en: As you’ll soon see, the binaries that `shc` creates are currently safe from
    this type of cracking attack. But, there’s always the possibility that someone
    could come up with better cracking tools in the future. So, think of this section
    as a framework for performing your own tests on any cracking tools that might
    come out in the future.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你很快会看到的，`shc` 创建的二进制文件目前对这种类型的破解攻击是安全的。不过，总有可能有人会在未来开发出更强的破解工具。所以，把这一部分看作是一个框架，用来对未来可能出现的破解工具进行测试。
- en: Let’s take a quick look at these utilities, shall we?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一下这些工具，好吗？
- en: 'Hands-on Lab: Testing UnSHc'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验室实操：测试 UnSHc
- en: This lab will familiarize you with the UnSHc utility. I’m using a Fedora Server
    virtual machine, but you can use either another Linux virtual machine or a FreeBSD
    virtual machine if you desire.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验室将帮助你熟悉 UnSHc 工具。我正在使用 Fedora Server 虚拟机，但你也可以使用其他 Linux 虚拟机或 FreeBSD 虚拟机，随你选择。
- en: 'Download UnSHc from Github by doing:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令从 Github 下载 UnSHc：
- en: '[PRE64]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Once it’s downloaded, which only takes a few seconds, `cd` into the `UnSHc/latest/`
    directory, and copy the `unshc.sh` script to the `/usr/local/bin/` directory:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，只需要几秒钟，`cd` 进入 `UnSHc/latest/` 目录，然后将 `unshc.sh` 脚本复制到 `/usr/local/bin/`
    目录：
- en: '[PRE65]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the `UnSHc/sample/` directory, you’ll see an example shell script, along
    with the corresponding C source code file and compiled binary file.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `UnSHc/sample/` 目录中，你会看到一个示例的 shell 脚本，并且有相应的 C 源代码文件和编译后的二进制文件。
- en: Note that this C source code file and binary file were both generated by a very
    old version of `shc`. (The reason why I mention this will become apparent in just
    a moment.)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个 C 源代码文件和二进制文件是由非常旧版本的 `shc` 生成的。（我提到这一点的原因马上就会明了。）
- en: 'Copy the binary file, which is `test.sh.x`, to your home directory:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将二进制文件 `test.sh.x` 复制到你的主目录：
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Attempt to decrypt the `test.sh.x` file, like so:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试解密 `test.sh.x` 文件，如下所示：
- en: '[PRE67]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The output should look something like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于这样：
- en: '![B21693_20_2](img/B21693_20_02.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_20_2](img/B21693_20_02.png)'
- en: 'Figure 20.2: Using UnSHc'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.2：使用 UnSHc
- en: 'Verify that the `test.sh.x` binary file actually did get decrypted, like this:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 `test.sh.x` 二进制文件是否已成功解密，如下所示：
- en: '[PRE68]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Okay, so that works just fine.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这样就能正常工作了。
- en: 'Next, try to decrypt a binary file that you created with the current version
    of `shc`. (You can use the binary file that you created in the *Using shc* lab,
    or you can create a new one.) Do it like this:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，尝试解密一个你用当前版本的 `shc` 创建的二进制文件。（你可以使用在 *使用 shc* 实验中创建的二进制文件，或者你也可以创建一个新的。）如下所示：
- en: '[PRE69]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As you see this time, the operation failed. So, the binary didn’t get decrypted,
    and the original shell script was not reconstructed.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你看到的，这次操作失败了。所以，二进制文件没有被解密，原始的 shell 脚本也没有被重建。
- en: 'To see why the operation failed this time, go into the `UnSHc/` directory and
    open the `README.md` file. Close to the top of the file, you’ll see this paragraph:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看为什么这次操作失败，进入 `UnSHc/` 目录并打开 `README.md` 文件。在文件的顶部附近，你会看到这一段：
- en: '**Due to the many problems since `shc` 4.0.3, there seems to be a need for
    clarification. In `shc` 4.0.3 many structural changes have been incorporated,
    so that `shc` now makes use of various security mechanisms provided by the linux-kernel
    itself. Therefore, it is now almost impossible to extract the original shell script
    at all with current UnSHc version, if the new `shc` version was used. This requires
    a more in-depth approach, which means that a modified `bash` or a modified linux-kernel
    is needed to bypass the security measures.**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**由于自 `shc` 4.0.3 以来出现了许多问题，似乎需要进行澄清。在 `shc` 4.0.3 中，已经加入了许多结构性更改，使得 `shc`
    现在利用了 Linux 内核本身提供的各种安全机制。因此，如果使用的是新版本的 `shc`，当前的 UnSHc 版本几乎不可能提取出原始的 shell 脚本。这需要一种更深入的方法，这意味着需要修改版的
    `bash` 或修改过的 Linux 内核才能绕过这些安全措施。**'
- en: So you see that the current version of `shc` is much more secure than the older
    versions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以看到，当前版本的 `shc` 比旧版本要安全得多。
- en: I also tested UnSHc on a FreeBSD machine, and got the same results. That tells
    me that the security enhancements that prevent you from successfully using UnSHc
    are also in the current FreeBSD kernel.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我还在一台 FreeBSD 机器上测试了 UnSHc，结果一样。这告诉我，阻止你成功使用 UnSHc 的安全增强功能也在当前的 FreeBSD 内核中。
- en: 'Also, I tested another `shc` cracker that’s called `deshc-deb`. If you’d like
    to play with it, you can download it by doing:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我还测试了另一个名为 `deshc-deb` 的 `shc` 破解工具。如果你想试试，可以通过以下方式下载：
- en: '[PRE70]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '(Spoiler alert: `deshc-deb` doesn’t work either.)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: （剧透警告：`deshc-deb` 也不起作用。）
- en: Okay, I know, that was a lot of work to show you that something doesn’t work.
    But, I figured that you might want to see for yourself, instead of just accepting
    my say-so for it. Seriously though, the bottom line is that `shc` is a good, secure
    way to obfuscate your scripts, in case you really need to do that. And, due to
    improvements in the Linux and FreeBSD kernels, the current decrypting utilities
    no longer work. However, you still need to take precautions to avoid sensitive
    data leakage, as you’ll see a bit later in the *Avoiding Sensitive Data Leakage*
    section. Next though, let’s look at a pair of permissions setting that could get
    you into trouble.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我知道，这个展示过程中做了很多工作来告诉你某些东西不起作用。但是，我觉得你可能想亲自看看，而不是仅仅接受我的说法。说真的，结论是，`shc` 是一种非常好的、安全的方式来混淆你的脚本，如果你真的需要这么做的话。而且，由于
    Linux 和 FreeBSD 内核的改进，目前的解密工具已经不再有效。不过，你仍然需要采取预防措施，以避免敏感数据泄露，稍后你会在*避免敏感数据泄露*部分看到相关内容。接下来，让我们看一下可能会让你陷入困境的一对权限设置。
- en: Understanding SUID and SGID Considerations
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 SUID 和 SGID 的考虑因素
- en: '**SUID** and **SGID**, which stand for **Set User Identity** and **Set Group
    Identity**, are permissions settings that you can place on executable files. These
    two permissions settings are not only handy, but are also mandatory on certain
    executable files that deal with certain functions of Linux, Unix, and Unix-like
    operating systems. However, if you set SUID or SGID on programs that you create
    yourself, you could be opening your system up to all kinds of security problems.
    Before I explain why that is, I need to explain what SUID and SGID actually do
    and why they’re needed.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**SUID**和**SGID**，分别代表**设置用户身份**和**设置组身份**，是你可以为可执行文件设置的权限。这两种权限设置不仅非常实用，而且对于处理Linux、Unix及类Unix操作系统某些功能的特定可执行文件来说，是必需的。然而，如果你为自己创建的程序设置了SUID或SGID，可能会给你的系统带来各种安全问题。在我解释为什么会这样之前，我需要解释一下SUID和SGID实际是如何工作的，以及为什么它们是必要的。'
- en: 'First, let’s go into the `/bin/` directory, and look at the permissions settings
    for the `rm` executable, like so:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们进入`/bin/`目录，查看`rm`可执行文件的权限设置，如下所示：
- en: '[PRE71]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here’s the breakdown of what you’re seeing:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是你所看到的内容的详细解释：
- en: The `root root` portion of this output indicates that this file belongs to the
    root user, and is associated with the root user’s group.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出中的`root root`部分表示该文件属于根用户，并且与根用户的组相关联。
- en: The permissions settings are at the beginning of the line, and are divided into
    three sections. The `rwx` settings are for the *user* of the file, which in this
    case is the root user. (In the Linux/Unix world, we refer to the *owner* of the
    file as the file’s *user*.) The `rwx` here means that the root user has read,
    write, and executable permissions for this file.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权限设置位于行的开头，分为三个部分。`rwx`设置适用于文件的*用户*，在这种情况下是根用户。（在Linux/Unix世界中，我们将文件的*所有者*称为文件的*用户*。）这里的`rwx`表示根用户对该文件具有读取、写入和执行权限。
- en: The next group of settings, which is `r-x`, is for the *group*, which in this
    case is for the root group. This means that members of this group, which in this
    case consists of only the root user, have read and executable permissions for
    this file.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一组设置是`r-x`，适用于*组*，在这种情况下是根组。这意味着该组的成员，在这个例子中仅限于根用户，具有对该文件的读取和执行权限。
- en: Finally, we have the third group of settings, which again is `r-x`. This group
    of settings is for *others*. This means that anyone who isn’t the root user or
    a member of the root group can invoke the `rm` command, even though the `rm` executable
    belongs to the root user. The catch with this is that a normal, unprivileged user
    can only use `rm` to remove files and directories with permissions settings that
    allow the normal user to do so. (Normally, this would mean that the normal user
    can only remove his or her own files and directories.) Removing any other files
    and directories with `rm` requires root privileges.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有第三组设置，仍然是`r-x`。这组设置适用于*其他人*。这意味着不是根用户或根组成员的任何人都可以调用`rm`命令，即使`rm`可执行文件属于根用户。需要注意的是，普通的、没有特权的用户只能使用`rm`删除具有允许普通用户执行删除操作的权限设置的文件和目录。（通常，这意味着普通用户只能删除他或她自己的文件和目录。）删除任何其他文件和目录需要根权限。
- en: 'Now, there are times when a normal user who doesn’t have either root or `sudo`
    privileges needs to do something that requires root privileges. The most common
    task of this sort is when a normal user needs to change his or her own password.
    Changing a password requires modifying the `/etc/shadow` file on Linux and OpenIndiana
    systems, and the `/etc/master.passwd` file on FreeBSD and most other BSD-type
    systems. But, look at the permissions settings of the `shadow` file on my Fedora
    workstation:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，普通用户没有根用户或`sudo`权限，但需要做一些需要根权限的事情。最常见的任务是当普通用户需要更改自己的密码时。更改密码需要修改Linux和OpenIndiana系统上的`/etc/shadow`文件，以及FreeBSD和大多数其他BSD类型系统上的`/etc/master.passwd`文件。但是，看看我在Fedora工作站上`shadow`文件的权限设置：
- en: '[PRE72]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Okay, this looks very strange, because there are no permissions of any kind
    on this file for anybody. In reality, the root user does have read and write permissions
    on this file. It’s just that Red Hat-type operating systems, such as Fedora, use
    another mechanism to grant those permissions to the root user. (I don’t want to
    go into what that mechanism is, because it’s beyond the scope of our present topic.)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这看起来很奇怪，因为这个文件对任何人都没有任何权限。实际上，root用户确实具有对该文件的读写权限。只是像Fedora这样的Red Hat类型操作系统，使用另一种机制将这些权限授予root用户。（我不想深入探讨这个机制是什么，因为它超出了我们当前话题的范围。）
- en: 'More typical is what you see on this Debian machine:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 更典型的是你在这台Debian机器上看到的情况：
- en: '[PRE73]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here, we see that only the root user has read and write permissions, and that
    the shadow group only has read permissions. Either way though, a normal user who
    needs to change his or her own password needs to modify this file, without invoking
    root or `sudo` privileges. How can that be accomplished? Well, with SUID, of course.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到只有root用户具有读写权限，而shadow组仅具有读权限。无论如何，普通用户如果需要更改自己的密码，必须修改这个文件，而不需要调用root或`sudo`权限。怎么实现这一点呢？当然是通过SUID。
- en: 'Adding the SUID permission to an executable file allows any normal user to
    execute that file with the same privileges as that file’s user. For example, look
    at the permissions settings on the `passwd` executable:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将SUID权限添加到可执行文件上，允许任何普通用户以该文件所有者的权限执行该文件。例如，查看`passwd`可执行文件的权限设置：
- en: '[PRE74]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This time, we see `rws` as the permissions setting for the *user*, which again
    in this case is the root user. The lower-case `s` here means that the executable
    permission is set for the root user, and that the SUID permission is also set.
    In the third permissions group, you see `r-x`, which means that normal, unprivileged
    users can run this program. The SUID permission is what allows the normal user
    to change his or her own password, which requires modifying either the `/etc/shadow`
    file or the `/etc/master.passwd` file. So now, let’s see if this works for Frank,
    who has no root or `sudo` privileges:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们看到`rws`作为*用户*的权限设置，在这种情况下，用户是root用户。小写字母`s`表示已为root用户设置了可执行权限，并且SUID权限也已设置。在第三组权限中，你会看到`r-x`，这意味着普通的无权限用户也可以运行此程序。SUID权限正是允许普通用户更改自己的密码，这需要修改`/etc/shadow`文件或`/etc/master.passwd`文件。所以现在，让我们看看没有root或`sudo`权限的Frank能否成功：
- en: '[PRE75]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Indeed it does, thanks to the SUID setting on the `passwd` executable.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 的确如此，这要归功于`passwd`可执行文件上的SUID设置。
- en: I should point out that the SUID setting on the `passwd` executable only works
    if a user is setting his or her own password. To set anyone else’s password, a
    user would still need to have the proper `sudo` privileges. (And no, I don’t know
    how the operating system developers can make SUID work selectively like that.)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要指出的是，`passwd`可执行文件上的SUID设置仅在用户设置自己的密码时有效。如果用户想要设置其他人的密码，仍然需要拥有适当的`sudo`权限。（至于操作系统开发人员是如何使SUID像这样有选择地工作，我也不清楚。）
- en: 'The SGID setting on executable files works the same way, except for groups.
    For example, look at the settings for the `write` executable:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件上的SGID设置以相同的方式工作，只不过是针对组。例如，查看`write`可执行文件的设置：
- en: '[PRE76]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In this case, you see the `s` setting in the *group* permissions, which means
    that any user who executes this program has the same privileges as the associated
    group. In this case, we’re talking about the tty group, which is a system group
    that allows its members to send output to the terminal. The SGID permission here
    allows a normal user to use `write` to send messages to another user who’s logged
    into another terminal, like so:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你会看到*组*权限中的`s`设置，这意味着任何执行此程序的用户都拥有与关联组相同的权限。在这种情况下，我们讨论的是tty组，它是一个系统组，允许其成员将输出发送到终端。这里的SGID权限允许普通用户使用`write`将消息发送给登录到另一个终端的用户，像这样：
- en: '[PRE77]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'After entering the `write frank` command, I hit **Enter**. I then entered the
    message and hit *Ctrl*-*d* to actually send the message. Thanks to the SGID setting
    on `write`, I was able to make that message show up on Frank’s terminal, as you
    see here:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`write frank`命令后，我按下了**Enter**。然后我输入了消息，并按下*Ctrl*-*d*实际发送消息。由于`write`上的SGID设置，我能够让这条消息显示在Frank的终端上，正如你在这里看到的：
- en: '[PRE78]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: So, what does all this have to do with shell scripting? Well, it’s just that
    even though SUID and SGID are mandatory on certain executable files that are part
    of the operating system, they can be a security hazard if you set them on executable
    files that you create. By doing so, you can inadvertently allow normal users to
    do things that they shouldn’t be allowed to do, and you can also allow intruders
    to invoke malicious code that could affect the entire system.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，所有这些与 shell 脚本有什么关系呢？嗯，问题在于，尽管 SUID 和 SGID 在操作系统的某些可执行文件上是强制要求的，但如果你在自己创建的可执行文件上设置它们，它们可能会成为安全隐患。这样做，你可能会无意中让普通用户做他们本不应该做的事情，也可能让入侵者调用恶意代码，影响整个系统。
- en: So, the general rule is to never, but *never*, set either SUID or SGID on programs
    of your own creation, unless you really know what you’re doing and can avoid the
    security problems.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，一般规则是，绝对不要在你自己创建的程序上设置 SUID 或 SGID，除非你真的知道自己在做什么，并且能够避免安全问题。
- en: 'By the way, here’s how to set the SUID permission on files:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，下面是如何设置文件的 SUID 权限：
- en: '[PRE79]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Setting SGID looks like this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 SGID 看起来是这样的：
- en: '[PRE80]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: But, for shell scripters, there’s a bit of good news. That is, if you set either
    SUID or SGID on a shell script, it will have no effect at all. This is because
    the kernels of Linux, Unix, and Unix-like operating systems contain code that
    cause the operating system to ignore SUID and SGID settings on any executable
    script file that contains a shebang line. So, contrary to what you might see in
    other shell scripting tutorials, setting either of these dangerous permissions
    on your scripts isn’t a problem, because they will have absolutely zero effect.
    However, they *might* have an effect on any binary files that you create with
    `shc`, so watch out for them.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于 shell 脚本编写者来说，有个好消息。也就是说，如果你在 shell 脚本上设置了 SUID 或 SGID，它们将完全没有任何效果。这是因为
    Linux、Unix 和类 Unix 操作系统的内核包含代码，使得操作系统忽略包含 shebang 行的任何可执行脚本文件上的 SUID 和 SGID 设置。因此，与其他
    shell 脚本教程中可能看到的内容相反，在你的脚本上设置这两种危险权限不是问题，因为它们将完全没有任何效果。然而，它们*可能*对你使用 `shc` 创建的任何二进制文件产生影响，所以要注意。
- en: Unfortunately, I haven’t been able to extensively test the effects of SUID and
    SGID permissions on the binary files that you create with `shc`. So, just be aware
    that you don’t want to see either of these permissions settings on those binary
    files.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我还没有能够广泛测试 SUID 和 SGID 权限对你使用 `shc` 创建的二进制文件的影响。所以，只要知道你不想在这些二进制文件上看到这两种权限设置。
- en: I should also mention that it is possible to mount filesystem partitions with
    the `nosuid` option, which would cause the SUID and SGID permissions to be completely
    ignored on any files that are within that partition. In fact, many modern Linux
    and Unix distros already mount certain important partitions, such as the `/tmp/`
    filesystem, with the `nosuid` option by default. Unfortunately, showing you how
    to set this option on your own partitions is beyond the scope of this book. In
    fact, I really can’t, because the procedure differs for the various Linux and
    Unix distros, as well as for the various filesystem formats that they use. If
    you need to know how to set the `nosuid` option, your best bet is to consult the
    documentation for your particular distro.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该提到，可以使用 `nosuid` 选项挂载文件系统分区，这样会导致该分区内的任何文件上的 SUID 和 SGID 权限完全被忽略。事实上，许多现代
    Linux 和 Unix 发行版已经默认使用 `nosuid` 选项挂载某些重要的分区，比如 `/tmp/` 文件系统。不幸的是，如何在你自己的分区上设置这个选项超出了本书的范围。实际上，我真的无法提供，因为不同的
    Linux 和 Unix 发行版以及它们使用的不同文件系统格式都有不同的设置方式。如果你需要知道如何设置 `nosuid` 选项，最好的办法是查阅你特定发行版的文档。
- en: Okay, let’s talk about data leakage.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们谈谈数据泄露。
- en: Avoiding Sensitive Data Leakage
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免敏感数据泄露
- en: As a systems administrator, there’s a very good chance that you’ll eventually
    have to deal with some sort of sensitive data, such as passwords, financial information,
    or customer information. You’ll always want to ensure that your scripts don’t
    inadvertently cause any sensitive data to leak out to any unauthorized people.
    Let’s look at some ways that that could happen, and how to prevent it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统管理员，你很可能最终需要处理某些敏感数据，如密码、财务信息或客户信息。你总是需要确保你的脚本不会无意中导致敏感数据泄露给未经授权的人。让我们看看可能发生这种情况的几种方式，以及如何防止它。
- en: Securing Temporary Files
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保临时文件安全
- en: 'At some point, you might need to create scripts that store some sort of ephemeral
    data in a temporary file. Reasons that you might need to do this include:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 到某个时候，你可能需要创建存储某种临时数据的脚本。你可能需要这样做的原因包括：
- en: Processing a large amount of data without using excessive system memory.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大量数据而不使用过多的系统内存。
- en: Storing the intermediate results of some sort of complex operation.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储某种复杂操作的中间结果。
- en: Storing temporary data for logging debugging information.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储用于记录调试信息的临时数据。
- en: Allowing different processes or scripts to communicate with each other.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许不同的进程或脚本相互通信。
- en: Since the `/tmp/` directory is the most common place to store temporary files,
    let’s begin this topic with and explanation of it.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `/tmp/` 目录是存储临时文件的最常见地方，让我们从解释它开始这个话题。
- en: Understanding the /tmp/ Directory
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 `/tmp/` 目录
- en: 'As I just said, the most common place to store temporary files is in the `/tmp/`
    directory. The good part about this directory is that it is world-readable and
    world-writable, as you see here:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我刚才所说，存储临时文件最常见的地方就是 `/tmp/` 目录。这个目录的优点是它是全世界可读和可写的，就像你在这里看到的：
- en: '[PRE81]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This is good, because it provides a common, well-known place that different
    scripts and processes can access. Indeed, this directory isn’t just used by your
    shell scripts. It’s also used by various operating system processes. Here on the
    Fedora virtual machine, you see that it’s storing temporary data from various
    `systemd` processes:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为它提供了一个公共的、广为人知的地方，供不同的脚本和进程访问。实际上，这个目录不仅仅是你的 shell 脚本使用的，它也被各种操作系统进程使用。在
    Fedora 虚拟机上，你可以看到它存储了来自各种`systemd`进程的临时数据：
- en: '[PRE82]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'As you see here, every file or directory that gets created in `/tmp/` is set
    with restrictive permissions, so that only the *user* of those files or directories
    can access them. Also, take another look at the permissions settings for the `/tmp/`
    directory itself:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，每个在 `/tmp/` 中创建的文件或目录都设置了限制性权限，以便只有这些文件或目录的 *用户* 能够访问它们。另外，再看一下 `/tmp/`
    目录本身的权限设置：
- en: '[PRE83]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: At the end of the permissions string, you see a `t` in place of an `x`. This
    means that the executable permission is set for *others*, so in that sense it
    does the same job as the `x`. So, anybody can enter that directory. But, the `t`,
    which is known as the **sticky bit**, also makes it so that different users can’t
    delete each other’s files or directories, unless they have root privileges. (This
    would be true even if the files and directories were set with world-writable permissions.)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在权限字符串的末尾，你会看到一个 `t` 代替了 `x`。这意味着可执行权限被设置为 *其他人*，从这个意义上讲，它和 `x` 做的工作是一样的。所以，任何人都可以进入这个目录。但
    `t`，也就是 **粘滞位**，还确保不同用户无法删除彼此的文件或目录，除非他们具有 root 权限。（即使这些文件和目录设置了全世界可写的权限，这一点依然成立。）
- en: I know that this is a rather cursory explanation of the sticky bit, but a fuller
    explanation is beyond the scope of this book. You’ll find a lot more about it
    in my *Mastering Linux Security and Hardening* Book.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这只是一个关于粘滞位的简要解释，但更详细的解释超出了本书的范围。在我的《*Linux安全与硬化精通*》一书中，你会找到更多相关内容。
- en: Okay, now that you understand the `/tmp/` directory, let’s look at how you can
    create scripts that will create temporary files. Understand though, that there
    are two ways to do it. First there’s the wrong way, and then there’s the right
    way.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在你了解了 `/tmp/` 目录，让我们看看如何创建可以创建临时文件的脚本。但要理解的是，这有两种做法。首先是错误的做法，然后是正确的做法。
- en: The Wrong Way to Create Temporary Files
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建临时文件的错误方式
- en: 'So now, let’s say that you really need to write a script that creates temporary
    files. How would you do it, and how would it be a security concern? Well, before
    I show you the right way to create temporary files, let me show you the wrong
    way, in this `tmp_file1.sh` script:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在，假设你真的需要写一个创建临时文件的脚本。你会怎么做呢？它会带来什么安全问题？在我展示如何正确创建临时文件之前，让我先展示在这个 `tmp_file1.sh`
    脚本中错误的做法：
- en: '[PRE84]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Run this script, and you’ll see this in the `/tmp/` directory:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个脚本，你将在 `/tmp/` 目录中看到这个：
- en: '[PRE85]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You see that the read permission is set for the *user*, *group*, and *others*.
    The write permission is only set for the *user*. So, I’m the only person who can
    write to this file, but every unprivileged user who’s logged into the server can
    read it. That’s not what you want if you’re really dealing with sensitive data.
    The other problem is that this script is using a predictable naming convention
    for the temporary file, which makes it easy for attackers to perform **sym link
    attacks**.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，读取权限被设置为*用户*、*组*和*其他人*都有。写入权限只为*用户*设置。所以，我是唯一能写入这个文件的人，但每个登录到服务器的无特权用户都能读取它。如果你真正在处理敏感数据，那可不是你想要的。另一个问题是，这个脚本使用了一个可预测的临时文件命名约定，这使得攻击者容易进行**符号链接攻击**。
- en: 'Trying to explain how **sym link attacks** work is way beyond the scope of
    this book. For now, let’s just say that they can cause bad things to happen, such
    as:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试解释**符号链接攻击**是超出了本书的范围。现在，我们只需要说它们可能导致不好的事情发生，比如：
- en: Leakage of sensitive data.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 敏感数据泄露。
- en: Injection of false data.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注入虚假数据。
- en: Denial of service attacks.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝服务攻击。
- en: If you want to learn more about sym link attacks, check out the references in
    the *Further Reading* section.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于符号链接攻击的信息，可以查看*进一步阅读*部分中的参考资料。
- en: Also, bear in mind that security threats don’t always come from unauthorized
    intruders. Authorized system users who can easily access the `/tmp/` directory
    can also be threats.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请记住，安全威胁并不总是来自未经授权的入侵者。可以轻松访问`/tmp/`目录的授权系统用户也可能构成威胁。
- en: Now that you’ve seen the wrong way to do business, let’s look at the right way.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经看到了错误的做法，那我们来看看正确的方法。
- en: The Right Way to Create Temporary Files
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确创建临时文件的方法
- en: 'The absolute best way to create temporary files is to use the `mktemp` utility.
    Here’s how it works from the command-line:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 创建临时文件的最佳方法是使用`mktemp`工具。下面是如何在命令行中使用它：
- en: '[PRE86]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This is cool, because it solves both of the problems that we had in the previous
    demo. First, it automatically sets restrictive permissions on the files that it
    creates, so that nobody but the person who created them can access them. Secondly,
    it creates files with random filenames, which makes the files safe from sym link
    attacks. Let’s see how this works in the `tmp_file2.sh` script:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，因为它解决了我们在前面演示中的两个问题。首先，它自动设置了创建的文件的限制权限，这样除了创建者之外，其他人无法访问这些文件。其次，它创建了随机文件名的文件，这使得这些文件免受符号链接攻击。让我们看看在`tmp_file2.sh`脚本中这是如何工作的：
- en: '[PRE87]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In the `temp_file=$(mktemp)` line, I’m using command substitution to assign
    the output of the `mktemp` command to the `temp_file` variable. Since `mktemp`
    creates files with random filenames, the name of the temporary file will be different
    every time you run the script. The `echo` line is just sending some output into
    the temporary file. Anyway, let’s see what we have when we run this script:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在`temp_file=$(mktemp)`这一行，我使用了命令替换，将`mktemp`命令的输出赋值给`temp_file`变量。由于`mktemp`创建的是随机文件名的文件，因此每次运行脚本时，临时文件的名称都会不同。`echo`这一行只是将一些输出写入临时文件。无论如何，让我们看看运行这个脚本时会有什么结果：
- en: '[PRE88]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'As we’ve already noted above, the file is set with restrictive permissions,
    so that only I can access it:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们上面已经提到的，文件设置了限制权限，只有我能访问它：
- en: '[PRE89]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Okay, this is all cool, and it looks good. But, we still don’t have a way to
    automatically delete our temporary files when we no longer need them. I mean,
    even though they’re all set with restrictive permissions, you still don’t want
    them hanging around when they’re no longer needed. Now, you might be tempted to
    just put an `rm` command at the end of the script, as you see here in the `tmp_file3.sh`
    script:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，以上这些都挺好看，但我们仍然没有一个方法在不再需要临时文件时自动删除它们。我的意思是，尽管这些文件都设置了限制权限，但当它们不再需要时，你还是不希望它们被留在那里。现在，你可能会想直接在脚本的末尾加一个`rm`命令，就像你在`tmp_file3.sh`脚本中看到的那样：
- en: '[PRE90]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Sure, that works in a simple script like this one. But, if you’re creating
    a complex script that could possibly exit without running to completion, the `rm`
    command might not get invoked. So, your best bet is to use a **trap** that will
    delete the temporary file, even if the script exits prematurely. Here’s how that
    works, in the the `tmp_file4.sh` script:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这在像这样的简单脚本中有效。但如果你创建的是一个可能在执行过程中提前退出的复杂脚本，`rm`命令可能不会被执行。因此，最好的做法是使用**trap**命令，即使脚本提前退出，也能删除临时文件。下面是`tmp_file4.sh`脚本中如何工作的：
- en: '[PRE91]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'When you execute a script, it always opens in a new child shell. When the script
    has either run to completion or has exited prematurely, the child shell closes.
    The second line in this script, the `trap` line, specifies a command to run when
    that child shell closes. In this case, we want the `rm -f` command to run. (The
    `-f` switch forces the `rm` command to delete files without prompting the user.)
    After the `echo` line, which sends some text into the temporary file, I’ve added
    two lines that will prove that the temporary file really does get created. Anyway,
    here’s what happens when I run the script:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行脚本时，它总是会在一个新的子 Shell 中打开。当脚本运行完毕或提前退出时，子 Shell 会关闭。脚本中的第二行，`trap` 行，指定了当该子
    Shell 关闭时要运行的命令。在这种情况下，我们希望运行`rm -f`命令。（`-f`选项强制`rm`命令删除文件而不提示用户。）在`echo`行之后，向临时文件发送一些文本，我添加了两行代码来证明临时文件确实被创建了。无论如何，以下是我运行脚本时发生的情况：
- en: '[PRE92]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: So, when I ran the script, it showed me the file and then showed me its contents,
    as I had hoped it would. But when I ran the `ls -l /tmp/tmp*` command afterwards,
    it showed that no `tmp` file exists. This proves that the `trap` command in the
    script really did delete the temporary file.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当我运行脚本时，它按我预期的那样显示了文件，并且显示了它的内容。但当我之后运行`ls -l /tmp/tmp*`命令时，它显示没有`tmp`文件。这证明了脚本中的`trap`命令确实删除了临时文件。
- en: 'As good as all this looks, there’s still one more modification that I’d like
    to show you in the `tmp_file5.sh` script, as you see here:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些看起来都很好，但我还是想向你展示在`tmp_file5.sh`脚本中做的最后一个修改，如下所示：
- en: '[PRE93]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The only thing I did here was to add `|| exit 1` to the `temp_file` line. This
    makes it so that if for some weird reason the `mktemp` command can’t create the
    temporary file, the script will exit gracefully with exit code 1\. In reality,
    it might not be needed here, because it’s almost a sure bet that `mktemp` will
    be able to create the temporary file. But, it’s considered good programming practice
    to provide a graceful exit mechanism, and it certainly doesn’t hurt anything to
    have it.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里所做的唯一修改是将`|| exit 1`添加到`temp_file`那一行。这样，如果由于某些奇怪的原因，`mktemp`命令无法创建临时文件，脚本将优雅地退出，并返回退出码1。实际上，这里可能不需要这么做，因为几乎可以确定`mktemp`能够创建临时文件。但是，提供一个优雅的退出机制被认为是良好的编程实践，拥有它肯定不会有坏处。
- en: Note that you can also create temporary directories in the `/tmp/` directory
    by using `mktemp` with the `-d` option switch.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您还可以通过使用`mktemp`并加上`-d`选项切换，在`/tmp/`目录中创建临时目录。
- en: Okay, you now know how to work with temporary files in a secure manner. Now,
    let’s move on to something else that can be a bit of a bugaboo. That is, how to
    securely use passwords in scripts.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你现在知道如何以安全的方式处理临时文件了。接下来，让我们处理另一个可能会成为麻烦的事情，那就是如何在脚本中安全地使用密码。
- en: Using Passwords in Shell Scripts
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Shell 脚本中使用密码
- en: 'The information in this section can help you out with two different scenarios:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的信息可以帮助你应对两种不同的情况：
- en: You need to create a script that a certain administrator or group of administrators
    will use, and place it where they can all access it. These administrators all
    have limited privileges, and what they need to do requires the password to some
    remote server. But, you don’t want them to know that password, because you don’t
    want to allow them to actually log into that server. All you want them to do is
    just one specific job, such as copying files to that server.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要创建一个脚本，供某个管理员或管理员组使用，并将其放置在他们都可以访问的地方。这些管理员都只有有限的权限，他们需要做的事情需要某个远程服务器的密码。但是，你不希望他们知道这个密码，因为你不想让他们实际登录到那个服务器。你只希望他们做一项特定的工作，例如将文件复制到该服务器。
- en: You need to create a script for your own use that requires a password to a remote
    server. You want to set the script up to automatically run at a regularly scheduled
    time, as either a `cron` job or as a `systemd` timer job. If the script has to
    prompt you for a password, the job will be interrupted and won’t run to completion.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要为自己的使用创建一个需要远程服务器密码的脚本。你希望设置脚本，使其在定期安排的时间自动运行，无论是作为`cron`作业还是`systemd`定时器作业。如果脚本需要提示你输入密码，作业将会被中断，无法完成。
- en: In both cases, you’ll need to embed a password into your script. But, there’s
    a danger that your password might leak out to unauthorized parties. Naturally,
    you’ll want to prevent that. So, let’s see how.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你都需要将密码嵌入到脚本中。但这有可能使你的密码泄露给未经授权的人员。自然，你希望防止这种情况发生。那么，接下来我们来看看如何避免。
- en: Hands-on Lab – Encrypting Passwords
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实践实验 – 加密密码
- en: For this scenario, I’ll show you a solution that I borrowed from the *How-to
    Geek* website. It’s a good solution as far as it goes, but it’s only a partial
    solution, as you’ll soon see. First though, let’s encrypt a password and create
    a script that uses it. Then, I’ll show you the complete solution.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个场景，我将展示一个我从*How-to Geek*网站借来的解决方案。就它所涵盖的范围而言，这是一个不错的解决方案，但它只是一个部分解决方案，正如你很快会看到的。首先，我们加密一个密码并创建一个使用它的脚本。然后，我会展示完整的解决方案。
- en: I’ve placed the link to the original *How-to Geek* article in the *Further Reading*
    section. Also, to avoid re-inventing the proverbial wheel, I won’t repeat the
    extensive explanations that the author of this article has already provided.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在*进一步阅读*部分中提供了原始*How-to Geek*文章的链接。此外，为了避免重新发明轮子，我不会重复这篇文章的作者已经提供的详细解释。
- en: To begin, you’ll need a system with both the `openssl` and the `sshpass` packages
    installed. The `openssl` package is normally installed on pretty much every Linux,
    Unix, or Unix-like operating system, so you won’t have to worry about that. You’ll
    only need to worry about installing `sshpass`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要一个系统，其中已安装`openssl`和`sshpass`包。`openssl`包通常会安装在几乎所有Linux、Unix或类Unix操作系统上，所以你不必担心这一点。你只需关注如何安装`sshpass`。
- en: You’ll use `openssl` to encrypt your password, and `sshpass` to automatically
    pass your password to the `ssh` client.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`openssl`来加密密码，并使用`sshpass`自动将密码传递给`ssh`客户端。
- en: The `sshpass` package is in the normal repositories for Fedora, Debian/Ubuntu,
    and FreeBSD. The package name is the same in all cases, so just use your normal
    package manager to install it.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`sshpass`包在Fedora、Debian/Ubuntu和FreeBSD的常规软件库中都有。无论在哪个系统上，包名都是一样的，因此只需使用你常用的包管理器进行安装。'
- en: Just for fun, I’ll be using the FreeBSD virtual machine for this lab, but you
    can use either of your Linux virtual machines if you desire. (The procedure will
    be the same, regardless.)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，我将使用FreeBSD虚拟机来进行这个实验，但如果你愿意，也可以使用你的任一Linux虚拟机。（无论如何，步骤是相同的。）
- en: 'Create the `.secret_vault.txt` file that contains the encrypted password for
    the remote server that you want to access, like this:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`.secret_vault.txt`文件，包含你要访问的远程服务器的加密密码，如下所示：
- en: '[PRE94]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In this command, `Chicken&&Lips` is the password for the remote server that
    you want to access, and `Turkey&&Lips` is the password that you’ll need to decrypt
    the password. (Why you need this decryption password will become clear in a few
    moments.) `Chicken&&Lips` is the password that you’ll encrypt.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，`Chicken&&Lips`是你要访问的远程服务器的密码，`Turkey&&Lips`是你用来解密密码的密码。（你需要这个解密密码的原因稍后会解释。）`Chicken&&Lips`是你将要加密的密码。
- en: 'Use the `chmod 600 .secret_vault.txt` command to set the read and write permissions
    for yourself, and to remove all permissions from everyone else:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`chmod 600 .secret_vault.txt`命令为自己设置读写权限，并移除其他所有用户的权限：
- en: '[PRE95]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Look in the `.secret_vault.txt` file, and you’ll see the `sha512` hash value
    of your remote server password:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看`.secret_vault.txt`文件，你将看到远程服务器密码的`sha512`哈希值：
- en: '[PRE96]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Create the `go-remote.sh` script, using your own information for the `Remote_User`,
    `Remote_Password`, and `Remote_Server`:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`go-remote.sh`脚本，使用你自己的信息来填写`Remote_User`、`Remote_Password`和`Remote_Server`：
- en: '[PRE97]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: As you’ll see explained in the original *How-to Geek* article, the password
    for decrypting the `Remote_Password` has to be in the script, in plain-text. The
    author of the article doesn’t consider this a problem, because the `.secret_vault.txt`
    file is a so-called hidden file that’s in your own home directory, and because
    the permissions on it are set so that only the file owner can access it. However,
    that explanation only makes sense if the plain-text script is in a location that
    nobody else can access. (I’ll explain more about that in just a bit.)
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在原始*How-to Geek*文章中看到的那样，解密`Remote_Password`的密码必须以明文形式出现在脚本中。文章的作者并不认为这是个问题，因为`.secret_vault.txt`文件是一个所谓的隐藏文件，位于你自己的主目录中，并且文件的权限设置为只有文件所有者才能访问它。然而，这个解释只有在明文脚本位于任何人无法访问的位置时才有意义。（我稍后会详细解释这个问题。）
- en: Instead of hard-coding the information for the remote user, remote server, and
    remote server password into the body of the script, I’m assigning the values for
    this information to the `Remote_User`, `Remote_Password`, and `Remote_Server`
    variables. To obtain the decrypted password that I need to assign to the `Remote_Password`
    variable, I’m using the `stdin` (`<`) redirector to read the password hash from
    the `.secret_vault.txt` file into the `openssl` command.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有将远程用户、远程服务器和远程服务器密码硬编码到脚本中，而是将这些信息的值分配给`Remote_User`、`Remote_Password`和`Remote_Server`变量。为了获取我需要分配给`Remote_Password`变量的解密密码，我使用`stdin`（`<`）重定向器将密码哈希从`.secret_vault.txt`文件读取到`openssl`命令中。
- en: The `sshpass -p` command passes Horatio’s password, from the `Remote_Password`
    variable, to the `ssh` client. Since we don’t need for Horatio to open a remote
    terminal, we’ll disable that with the `-T` option for `ssh`. The `_remote_commands`
    *here document* contains a single command that will be executed on the remote
    server. That is, it will create a `script.log` file that contains a timestamp
    in Horatio’s home directory.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`sshpass -p`命令将Horatio的密码（来自`Remote_Password`变量）传递给`ssh`客户端。由于我们不需要Horatio打开远程终端，我们将通过`-T`选项禁用该功能。`_remote_commands`*here
    document*包含一个将在远程服务器上执行的命令。也就是说，它将创建一个包含时间戳的`script.log`文件，在Horatio的家目录中。'
- en: 'In order for this script to work, you’ll need to have Horatio’s public SSH
    key for the remote server in your `.ssh/known_hosts` file. So, before you try
    to run the script, have Horatio log into the remote server in the normal manner,
    and then have him log back out, like so:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让这个脚本工作，你需要在你的`.ssh/known_hosts`文件中拥有Horatio的远程服务器公钥。所以，在你尝试运行脚本之前，让Horatio以正常方式登录远程服务器，然后让他像这样退出：
- en: '[PRE98]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Execute the `go-remote.sh` script. You should see the login information from
    the remote server come up momentarily, and then be returned to the command prompt
    of your local machine.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`go-remote.sh`脚本。你应该能看到来自远程服务器的登录信息，并且很快会返回到本地机器的命令提示符。
- en: 'Log into Horatio’s account on the remote server. You should see the `script.log`
    file that contains a timestamp. It should look something like this:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到Horatio的远程服务器账户。你应该能看到一个包含时间戳的`script.log`文件。它看起来应该是这样的：
- en: '[PRE99]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: If you see the `script.log` file in Horatio’s home directory, you have achieved
    coolness. But, is this really a complete solution? Well, no. Let’s look at some
    potential problems that the author of this *How-to Geek* article doesn’t address.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Horatio的家目录中看到了`script.log`文件，那么你已经实现了酷炫的效果。但这真的算是一个完整的解决方案吗？嗯，不完全是。让我们来看看这篇*How-to
    Geek*文章的作者没有提到的一些潜在问题。
- en: Understanding the Problems with this Solution
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解这个解决方案的问题
- en: Again I ask, is the solution that I’ve just presented a good one? Well, that
    depends upon a few factors. I mean, if you have the script and the hashed password
    in your own home directory where only you can access it, it might be okay. But,
    here’s an important consideration. Some operating systems, such as FreeBSD and
    older implementations of Linux, have users’ home directories open to other users
    by default. Anyone who can get into your home directory can read the encryption
    password in your plain-text script, and see the name of the file that contains
    the encrypted password. In fact, let’s take a look at that.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我再次问，刚才我展示的解决方案是一个好的方案吗？嗯，这取决于一些因素。我的意思是，如果你将脚本和加密密码放在你自己家目录中，并且只有你可以访问它，那么可能没问题。但是，这里有一个重要的考虑因素。一些操作系统，比如FreeBSD和旧版的Linux实现，默认情况下会将用户的家目录开放给其他用户。任何能够进入你家目录的人都可以读取你脚本中的明文加密密码，并看到包含加密密码的文件名。事实上，让我们来看看这个问题。
- en: Home Directory Permissions on FreeBSD
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: FreeBSD上的家目录权限
- en: 'Here’s how it looks on FreeBSD:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这是FreeBSD上的样子：
- en: '[PRE100]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'As you see, by default, FreeBSD sets the read and execute permissions for *others*
    on users’ home directories. In this case, it means that Horatio can see what’s
    in my directory, and I can see what’s in his directory, without having to use
    any kind of administrative privileges. Fortunately, I can easily fix that for
    myself, like this:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，默认情况下，FreeBSD会为用户的家目录设置*其他*用户的读取和执行权限。在这种情况下，这意味着Horatio可以查看我目录中的内容，我也可以查看他的目录内容，而不需要使用任何管理员权限。幸运的是，我可以很容易地为自己修复这个问题，像这样：
- en: '[PRE101]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The `chmod 700` command preserves the read, write, and execute permissions
    that I have for myself, and removes all permissions for everyone else. To ensure
    that any future users have this restrictive permissions settings on their FreeBSD
    home directories, create the `/etc/adduser.conf` file with that setting, like
    this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`chmod 700`命令保留了我对家目录的读取、写入和执行权限，同时移除了其他所有人的权限。为了确保任何未来的用户在FreeBSD上也能拥有这种限制性的权限设置，请按照以下方式创建`/etc/adduser.conf`文件：'
- en: '[PRE102]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This is an interactive utility that prompts you for a lot of information. Accept
    the defaults for everything except for the `Home directory permissions (Leave
    empty for default):` line. For it, enter `700` as the value. Test your setup by
    creating another user account. You should see that the new user will have restrictive
    permissions set on his or her home directory, as you see here for the account
    that I just created for Vicky:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个交互式工具，它会提示你输入很多信息。除`Home directory permissions (Leave empty for default):`这一行外，其他选项都可以使用默认值。对于这一行，请输入`700`作为值。通过创建另一个用户账户来测试你的设置。你应该看到新用户的家目录会设置限制权限，就像我为Vicky刚创建的账户一样：
- en: '[PRE103]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Also, keep in mind that when you install FreeBSD, the user account that the
    installer creates for you will have the more open permissions settings for your
    home directory. So, after you complete the installation, be sure to set your home
    directory permissions to the more restrictive value. Then, run the `sudo adduser
    -C` command to create the `/etc/adduser.conf` file, as I’ve just shown you.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，记住，当你安装FreeBSD时，安装程序为你创建的用户账户会为家目录设置较为开放的权限。因此，在安装完成后，一定要将家目录权限设置为更为限制的值。然后，运行`sudo
    adduser -C`命令来创建`/etc/adduser.conf`文件，就像我刚刚给你演示的那样。
- en: Home Directories on Linux
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Linux上的家目录
- en: 'Home directory permissions on Linux aren’t as much of a problem, because many
    modern Linux distros create home directories with restrictive permissions by default.
    For example, here’s how they look on any Red Hat-type system, such as Fedora,
    and on Debian 12:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，家目录权限通常不是问题，因为许多现代Linux发行版默认创建具有限制权限的家目录。例如，以下是Red Hat类型系统（如Fedora）和Debian
    12上的家目录权限显示：
- en: '[PRE104]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'And, here’s how they look on Ubuntu 22.04 and newer:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，这就是它在Ubuntu 22.04及更新版本中的样子：
- en: '[PRE105]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The only difference with Ubuntu is that it has read and execute permissions
    for the user’s private group, where the Red Hat distros and Debian don’t. That’s
    okay because either way, nobody can access the home directories except for their
    respective owners.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的不同点是，Ubuntu为用户的私有组设置了读取和执行权限，而Red Hat系列和Debian则没有。这没关系，因为无论如何，除了各自的所有者，其他人都无法访问家目录。
- en: Home Directories on Other Linux or Unix Distros
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 其他Linux或Unix发行版上的家目录
- en: Other Linux or Unix distros might have other ways of doing business with their
    users’ home directories. If you work with any of them, be sure to check the home
    directory permissions settings, and make any necessary changes.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 其他Linux或Unix发行版可能会有不同的方式来管理用户的家目录。如果你使用其中任何一个，请务必检查家目录权限设置，并根据需要进行修改。
- en: Okay, that does it for home directory permissions. But, what if you need to
    place a script somewhere else where other administrators can access it? Let’s
    see what we can do about that.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，家目录权限的部分就讲到这里。但如果你需要将脚本放到其他位置，以便其他管理员访问该脚本呢？让我们看看如何解决这个问题。
- en: 'Hands-on Lab: Making an Untraceable Binary'
  id: totrans-426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实操实验：创建不可追踪的二进制文件
- en: If other administrators need to access a script that requires an embedded password,
    you might have to place both it and the encrypted password file into some other
    directory, such as `/usr/local/bin/` or `/usr/local/sbin/`. In those cases, you’ll
    want to ensure that nobody can read or modify the script, and that nobody can
    trace it. That’s because anyone who can read your script, the `go-remote.sh` script
    in this case, can see the password that you need to decrypt the remote server
    password, as well as the name of the file that contains the remote server password.
    And of course, anyone who can edit this file can add extra commands to do possibly
    nasty things on the remote server.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他管理员需要访问需要嵌入密码的脚本，你可能需要将它和加密的密码文件放到其他目录，比如`/usr/local/bin/`或`/usr/local/sbin/`。在这种情况下，你需要确保没有人可以读取或修改该脚本，并且没有人可以追踪到它。这是因为任何能读取你的脚本（此处是`go-remote.sh`脚本）的人，都能看到你用来解密远程服务器密码的密码，以及包含该远程服务器密码的文件名。当然，任何能够编辑该文件的人，也可以添加额外的命令，可能在远程服务器上执行恶意操作。
- en: Fortunately, you can easily solve this problem by using `shc` to turn your scripts
    into executable binary files, as I showed you a few pages back in the *Controlling
    Access to Your Scripts* section. But, when you do this, you absolutely *must*
    use `shc` with the `-U` option to make the binary untraceable.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以通过使用 `shc` 将脚本转换成可执行的二进制文件来轻松解决这个问题，就像我在 *控制脚本访问权限* 部分所展示的那样。但在执行此操作时，你一定*必须*使用
    `shc` 的 `-U` 选项，以确保二进制文件不可追踪。
- en: If you don’t make your binary files untraceable, anyone who can access the files
    can use debugging utilities such as `strace`, `truss`, `dtrace`, or `dtruss` to
    obtain the plain-text password, even if it has been encrypted with the strongest
    algorithm known to mankind.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不使你的二进制文件不可追踪，那么任何可以访问这些文件的人都可以使用调试工具，如 `strace`、`truss`、`dtrace` 或 `dtruss`
    来获取明文密码，即使它已经被最强的加密算法加密。
- en: 'To demonstrate, go back to the same virtual machine that you used to create
    the `go-remote.sh` script. Turn the script into an executable binary, using `shc`
    without the `-U` option:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示，回到你用来创建 `go-remote.sh` 脚本的虚拟机。使用没有 `-U` 选项的 `shc` 将脚本转换成可执行的二进制文件：
- en: '[PRE106]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Using `truss` on FreeBSD or `strace` on Linux, create the `trace1.txt` trace
    file of the `go-remote` executable.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 FreeBSD 上使用 `truss` 或在 Linux 上使用 `strace`，创建 `go-remote` 可执行文件的 `trace1.txt`
    跟踪文件。
- en: 'On FreeBSD:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FreeBSD 上：
- en: '[PRE107]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'On Linux:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上：
- en: '[PRE108]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Open the `trace1.txt` file, and scroll down until you see Horatio’s password
    for the remote server. In my own file, it was on line 191, and it looks like this:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `trace1.txt` 文件，向下滚动，直到看到 Horatio 的远程服务器密码。在我自己的文件中，它在第 191 行，内容如下：
- en: '[PRE109]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Yes indeed, `Chicken&&Lips` really is Horatio’s password for the remote server.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，`Chicken&&Lips` 确实是 Horatio 用来登录远程服务器的密码。
- en: 'Re-create the `go-remote` binary, using the `-U` option to make it untraceable:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新创建 `go-remote` 二进制文件，使用 `-U` 选项使其不可追踪：
- en: '[PRE110]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Repeat *Step 2*, except this time save the output to the `trace2.txt` file:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *第 2 步*，不过这次将输出保存到 `trace2.txt` 文件：
- en: 'Open the `trace2.txt` file and search for Horatio’s password. (Spoiler alert:
    This time, you won’t find it.)'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `trace2.txt` 文件并搜索 Horatio 的密码。（剧透警告：这次你不会找到它。）
- en: Now, after all this, I need to let you in on a little secret. That is, that
    neither Horatio’s username nor the address of the remote server shows up in the
    `truss` or `strace` output. So, anyone who were to trace your binaries will have
    the password, but no username or server address. But, don’t think that you’re
    all good because of this. Remember, you need to think like a malicious hacker.
    Any malicious hacker worth his or her salt would already have used other means
    to map the servers on your network, and would have found a way to enumerate a
    list of possible usernames. So, even though this procedure only gives hackers
    one piece of the puzzle, it’s still an important piece that can be combined with
    the other pieces.
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，经过这一切，我需要告诉你一个小秘密。也就是，Horatio 的用户名和远程服务器的地址在 `truss` 或 `strace` 的输出中都不会出现。所以，任何追踪你的二进制文件的人都能获得密码，但不会有用户名或服务器地址。但是，别以为这样就万事大吉了。记住，你需要像恶意黑客一样思考。任何值得一提的恶意黑客早就会使用其他手段来映射你网络中的服务器，并找到列举可能用户名的方法。所以，尽管这个过程只给了黑客一个谜题的部分答案，但它仍然是一个重要的部分，可以与其他部分结合起来。
- en: All right, I think we’re about through with this topic. Let’s now take a quick
    look at secure coding practices.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想我们差不多完成这个话题了。现在让我们快速看一下安全编码实践。
- en: Understanding Command Injection with eval
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解使用 eval 的命令注入
- en: Another major problem with shell script security involves scripts that accept
    input from untrusted users or untrusted sources. If the script is coded incorrectly,
    an attacker could use it to inject malicious commands as the script’s input. Before
    we look at examples of that, let’s look the `eval` command, which facilitates
    passing data or commands into a script.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关于 shell 脚本安全的主要问题是接受来自不信任用户或不信任来源的输入的脚本。如果脚本编码不正确，攻击者可能会利用它注入恶意命令作为脚本的输入。在我们查看这些示例之前，让我们先看一下
    `eval` 命令，它便于将数据或命令传递给脚本。
- en: Using eval on the Command-line
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在命令行上使用 eval
- en: The `eval` command is a shell builtin that’s available on most shells. It’s
    very handy when used properly, but dangerous when used improperly. Before we get
    into that, let’s look at how `eval` works on the command-line.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval` 命令是大多数 shell 中的内建命令。当正确使用时，它非常方便，但不当使用时却非常危险。在我们深入了解之前，让我们看看 `eval`
    在命令行上的使用方法。'
- en: Okay, `eval` is one of those commands that can be really complex to fully understand.
    So, to keep things simple, I’ll be presenting some rather simplistic `eval` demos
    in this section. Even though they’ll demonstrate things that you’ll never do in
    real life, they’ll serve the purpose of demonstrating the concepts.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，`eval`是一个非常复杂的命令，完全理解它可能会很困难。所以，为了简化，我将在本节中展示一些非常简单的`eval`示例。虽然它们展示的内容在实际生活中可能不会做，但它们足以展示基本概念。
- en: For anyone who would like to see more in-depth coverage of `eval`, I’ll drop
    some links into the *Further Reading* section.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何想要更深入了解`eval`的人，我将在*进一步阅读*部分中放入一些链接。
- en: 'The best way to think of `eval` is that you can use it to dynamically process
    commands that the shell would normally treat as meaningless text strings. For
    example, let’s say that we want to find the date from three weeks ago. We would
    use `date` with the `--date=` option, like this:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`eval`的最佳方式是，它可以用来动态处理那些通常会被 shell 视为无意义文本字符串的命令。例如，假设我们想要找到三周前的日期。我们可以使用带有`--date=`选项的`date`命令，如下所示：
- en: '[PRE111]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'As you see, I just used the `"3 weeks ago"` text string as the argument for
    the `--date` option, which works just fine. Now, let’s assign this date command
    to the `threeweeksago` variable and `echo` back the results, like this:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我只是使用了“`3周前`”这个文本字符串作为`--date`选项的参数，它运行得很好。现在，让我们将这个日期命令分配给`threeweeksago`变量，并用`echo`输出结果，像这样：
- en: '[PRE112]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'As you see, the `echo` command just returned the text string that I assigned
    to the variable. For some real magic, watch what happens when I replace `echo`
    with `eval`:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`echo`命令只是返回了我分配给变量的文本字符串。为了展示真正的魔法，看看当我将`echo`替换为`eval`时会发生什么：
- en: '[PRE113]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Now, let’s wait a few minutes and run this again.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们等几分钟，然后再运行一次。
- en: '[PRE114]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Look carefully, and you’ll see that the second `eval` command has updated the
    time value. This sort of thing can be handy in scripting, because it allows you
    to assign a command to a variable, and then use that variable throughout the rest
    of the script. This allows you to execute the command in various parts of the
    script, without having to type out the entire command multiple times. But, as
    I’ve already mentioned, there’s both a safe way and a dangerous way to use `eval`.
    Let’s first look at the safe way.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看，你会看到第二个`eval`命令更新了时间值。这样的做法在脚本中非常有用，因为它允许你将命令分配给一个变量，然后在脚本的其他部分中使用这个变量。这样，你就能在脚本的不同部分执行该命令，而不必多次输入整个命令。但正如我之前提到的，`eval`的使用既有安全的方法，也有危险的方法。让我们先看一下安全的用法。
- en: Using eval Safely
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全使用eval
- en: 'Let’s take a look at the `eval-test1.sh` script to see a simple example of
    safe `eval` usage:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`eval-test1.sh`脚本，查看一个安全使用`eval`的简单示例：
- en: '[PRE115]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Running the script looks like this:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本的样子如下：
- en: '[PRE116]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The reason this is safe is because we’re feeding `eval` a text string that comes
    from within the script itself. As long as you have the permissions on this script
    locked down so that nobody can modify it, it’s perfectly sane and safe. Using
    `eval` in this way makes it impossible for attackers to insert their own malicious
    commands.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以这样是安全的，是因为我们提供给`eval`的是来自脚本本身的文本字符串。只要你确保这个脚本的权限被锁定，没人能修改它，那么它完全是安全的。以这种方式使用`eval`，可以防止攻击者插入他们自己的恶意命令。
- en: 'Of course, this script is rather pointless, because it doesn’t do anything
    at all useful. So, let’s look at a more practical example in the `eval-test2.sh`
    script:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个脚本其实没什么实际意义，因为它完全没有做任何有用的事情。所以，让我们来看一个更实际的例子，位于`eval-test2.sh`脚本中：
- en: '[PRE117]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Here, I’m using `eval` within a command substitution construct to create the
    value for the `datestamp` variable. I’ll use then use this `datestamp` variable
    to insert a datestamp into both the text file, and the name of the text file.
    Here’s how it looks when I run the script:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用`eval`在命令替换结构中创建`datestamp`变量的值。然后，我会使用这个`datestamp`变量，将时间戳插入到文本文件和文本文件名中。下面是运行脚本时的效果：
- en: '[PRE118]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: As you see, it works just fine. And, if I were to run this command a few moments
    later, I would see a new file with a new timestamp. And of course, if I were to
    decide to change the `--date` value to something else, such as `"1 month ago"`,
    I would only have to make the change in the `desiredDate=` line, instead of having
    to change it multiple times throughout the script.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它运行得很好。而且，如果我稍后再次运行这个命令，我会看到一个带有新时间戳的新文件。当然，如果我决定将`--date`值更改为其他内容，比如“`1个月前`”，我只需在`desiredDate=`这一行进行更改，而不必在脚本的多个地方进行修改。
- en: So, now that I’ve shown you the safe way to use `eval`, let’s look at the dangerous
    way.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我已经展示了使用 `eval` 的安全方法，我们来看一下危险的用法。
- en: Using eval Dangerously
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `eval` 的危险性
- en: 'The `eval-test3.sh` script shows a very simple example of what you *never*
    want to do:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval-test3.sh` 脚本展示了一个你*绝对*不想做的非常简单的例子：'
- en: '[PRE119]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Yeah, I know what you’re thinking. Nobody would ever create such a simplistic
    script that uses `eval` in this manner. That’s okay though, because it serves
    the purpose of demonstrating the concept. Let’s try it out to see what happens.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道你在想什么。没人会创建一个如此简单的脚本，以这种方式使用 `eval`。不过没关系，因为它的目的是展示这个概念。让我们试试，看看会发生什么。
- en: '[PRE120]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: As you see, the `date` command gets passed into `eval` as positional parameter
    `$1`. This seems safe enough, but is it really? The key here is that anyone who
    runs this script can insert any command that he or she wants to run. For example,
    let’s say that this script is in the `/usr/local/bin/` directory. The permissions
    are set so that nobody can modify it, but also so that every non-privileged user
    can execute it. So, what could a malicious hacker accomplish with this? Let’s
    see.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`date` 命令被传递给 `eval` 作为位置参数 `$1`。这看起来足够安全，但真的安全吗？关键在于，任何运行这个脚本的人都可以插入任何他们想要执行的命令。例如，假设这个脚本位于
    `/usr/local/bin/` 目录中。权限设置为无人能够修改它，但同时每个非特权用户都可以执行它。那么，恶意黑客能通过此做些什么呢？我们来看看。
- en: '[PRE121]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This particular example might not seem like a big deal, because the `passwd`
    file is world-readable anyway. But then, it could be a big deal under certain
    circumstances. For example, let’s say that you’re running a web server, and you
    have a shell script set up as a CGI script.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子看起来似乎没什么大不了的，因为 `passwd` 文件本来就是全世界可读的。但在某些情况下，这可能会变得非常严重。举个例子，假设你正在运行一个
    Web 服务器，并且有一个 shell 脚本作为 CGI 脚本设置好。
- en: '**CGI** stands for **Common Gateway Interface**. You can create CGI scripts
    from various programming languages, including shell scripting. These CGI scripts
    can perform various functions on web servers, such as counting users, or even
    serving out content.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '**CGI** 代表 **公共网关接口**。你可以使用各种编程语言来创建 CGI 脚本，包括 shell 脚本。这些 CGI 脚本可以在 Web 服务器上执行各种功能，比如计数用户，甚至提供内容。'
- en: A full explanation of setting up web servers and how to hack them is way beyond
    the scope of this book. For now, let’s just say that there are some clever hackers
    out there who can find and exploit poorly designed CGI scripts on web servers.
    That’s especially true if the web server security isn’t set up properly.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置 Web 服务器以及如何攻击它的详细解释超出了本书的范围。现在我们就说，外面有一些聪明的黑客能找到并利用设计不当的 CGI 脚本，尤其是在 Web
    服务器安全措施没有正确配置的情况下。
- en: A malicious hacker who hasn’t been able to log into the web server wouldn’t
    be able to view the `passwd` file. But, if he or she were to find that this poorly-designed
    script is performing some sort of CGI function, he or she might be able to view
    the `passwd` file to enumerate the server’s users. (But then, maybe not. Proper
    web server security measures might prevent this from happening, even if the script
    is insecure.)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 一个恶意黑客如果无法登录 Web 服务器，将无法查看 `passwd` 文件。但如果他或她发现这个设计不当的脚本正在执行某种 CGI 功能，那么他或她可能能够查看
    `passwd` 文件，从而枚举服务器上的用户。（不过，也许不会。适当的 Web 服务器安全措施可能会防止这种情况发生，即使脚本本身存在安全漏洞。）
- en: 'For another example that might be more probable, let’s say that you’ve placed
    the `eval-test3.sh` script in the `/usr/local/sbin/` directory, and have it set
    up so that only the root user has executable permissions, like this:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能性较高的例子是，假设你把 `eval-test3.sh` 脚本放在 `/usr/local/sbin/` 目录中，并将它设置为只有 root
    用户有执行权限，如下所示：
- en: '[PRE122]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'You then invoke the `sudo visudo` command to set up Charlie so that he has
    root privileges to run the `eval-test3.sh` script, but nothing else. Here’s the
    line that does that:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你运行 `sudo visudo` 命令来设置 Charlie，使他仅具有运行 `eval-test3.sh` 脚本的 root 权限，而不能做其他操作。这里是实现这一点的那一行：
- en: '[PRE123]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Let’s see how that works.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这是如何工作的。
- en: '[PRE124]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Charlie didn’t do any harm this time, but what about next time? Let’s see:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这次 Charlie 没有造成任何危害，但下次呢？让我们看看：
- en: '[PRE125]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This time, Charlie did some real damage. He shut down the web server, causing
    a Denial-of-Service attack. Ordinarily, Charlie wouldn’t have the power to do
    this. But, because he has `sudo` privileges to run the `eval-test3.sh` script,
    and that script contains the `eval $1` line, Charlie can now run any command he
    wants to run, including system administrative commands.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，Charlie做了一些真正的破坏。他关闭了Web服务器，造成了拒绝服务攻击（Denial-of-Service）。通常情况下，Charlie是没有这个权限的。但是，因为他有`sudo`权限来运行`eval-test3.sh`脚本，而该脚本包含了`eval
    $1`这一行，Charlie现在可以运行任何他想要的命令，包括系统管理员命令。
- en: 'As I said at the beginning of this section, I’ve tried to keep the explanation
    of `eval` simple. To see more complex and somewhat more realistic `eval` scenarios,
    I would like to draw your attention to two really good articles that I’ve found.
    The first one is on Medium.com, and is the absolute best write-up I’ve found that
    covers a real-world way to exploit poorly-written scripts with `eval`:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本节开头所说的，我尽量让`eval`的解释保持简单。如果你想了解更复杂且更具现实意义的`eval`场景，我想推荐两篇我发现的非常好的文章。第一篇文章在Medium.com上，是我找到的最好的写作之一，详细讲述了如何利用写得不好的脚本中的`eval`进行实际攻击：
- en: 'The perils of Bash eval:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: Bash eval的危险：
- en: '[https://medium.com/dot-debug/the-perils-of-bash-eval-cc5f9e309cae](https://medium.com/dot-debug/the-perils-of-bash-eval-cc5f9e309cae)'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://medium.com/dot-debug/the-perils-of-bash-eval-cc5f9e309cae](https://medium.com/dot-debug/the-perils-of-bash-eval-cc5f9e309cae)'
- en: 'The second one, at the Earthly.dev site, shows how to perform a **reverse shell
    attack** with an `eval` script. (If you don’t know what a reverse shell attack
    is, you’ll find the explanation in the article.) Anyway, you can find it here:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 第二篇文章位于Earthly.dev网站，展示了如何通过一个`eval`脚本进行**反向Shell攻击**。（如果你不知道什么是反向Shell攻击，你可以在文章中找到解释。）总之，你可以在这里找到这篇文章：
- en: 'Bash eval: Understanding and (Safely) Using the Power of Dynamic Code Evaluation:
    [https://earthly.dev/blog/safely-using-bash-eval/](https://earthly.dev/blog/safely-using-bash-eval/)'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: Bash eval：理解和（安全地）使用动态代码评估的威力：[https://earthly.dev/blog/safely-using-bash-eval/](https://earthly.dev/blog/safely-using-bash-eval/)
- en: 'Also, there has been at least one instance of a real-life shell script vulnerability
    that involved an incorrect usage of `eval`. This involved the installation script
    for Gradle, which is an automated build tool for software development. You can
    read about it here:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，至少有一次与真实世界 shell 脚本漏洞相关的事件，涉及了`eval`的错误使用。这是与Gradle的安装脚本有关，Gradle是一个用于软件开发的自动化构建工具。你可以在这里阅读相关内容：
- en: 'CVE-2021-32751:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 'CVE-2021-32751:'
- en: '[https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-32751](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-32751)'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-32751](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-32751)'
- en: Now that you understand the dangers of `eval`, let’s consider whether or not
    we even have to use it.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了`eval`的危险，我们来考虑一下是否真的需要使用它。
- en: Using Alternatives to eval
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`eval`的替代方案
- en: Many times, you’ll be able to use a safe alternative to `eval`. Let’s look at
    a few examples.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，你可以使用`eval`的安全替代方案。让我们看几个例子。
- en: Using Command Substitution
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用命令替换
- en: In the `eval-test1.sh` script that I showed you at the beginning of this section,
    you could have replaced `eval` with a command substitution construct.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在我在本节开头展示的`eval-test1.sh`脚本中，你本可以用命令替换构造来替代`eval`。
- en: 'Here’s how it looks in the `eval-test1-alternative.sh` script:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在`eval-test1-alternative.sh`脚本中的实现：
- en: '[PRE126]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Run the script, and you’ll see that it behaves exactly the same as the `eval`
    version:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，你会发现它的行为与`eval`版本完全相同：
- en: '[PRE127]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Granted, it doesn’t really matter in this case, because the script doesn’t accept
    external input. So, it’s perfectly safe to use `eval` with it. But, if you create
    a script that does accept external input and you have the choice between using
    `eval` and using command substitution, your best bet is to go with command substitution.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在这种情况下，它并不重要，因为该脚本不接受外部输入。因此，使用`eval`是完全安全的。但是，如果你创建了一个接受外部输入的脚本，并且你有选择在`eval`和命令替换之间做决定，最好的选择是使用命令替换。
- en: '**Remember**: Always go with the safest option for your scripts.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**记住**：始终为你的脚本选择最安全的选项。'
- en: Evaluating if eval is Necessary
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估是否有必要使用`eval`
- en: 'In some cases, using `eval` doesn’t even do anything that we can’t do without
    it. For example, look at the `eval-test4.sh` script:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，使用`eval`甚至不会做任何我们不可以在没有它的情况下做的事情。例如，看看`eval-test4.sh`脚本：
- en: '[PRE128]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'When you run this script, you’ll pass in a number as positional parameter `$1`.
    The arithmetic operator in the `eval` line will increment the number by 1, and
    display the result. Here’s how that looks:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个脚本时，你将传递一个数字作为位置参数`$1`。`eval`行中的算术运算符会将这个数字加1，并显示结果。它的运行效果如下所示：
- en: '[PRE129]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now, let’s remove the `eval` command, so that the script looks like this:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们移除`eval`命令，使得脚本变成这样：
- en: '[PRE130]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Running the script without `eval` gives us this:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用`eval`运行脚本时，结果是这样的：
- en: '[PRE131]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The output is identical to what it was when we used `eval`, which tells me that
    `eval` isn’t even needed here. So, the only thing that `eval` does here is to
    add an attack vector that we definitely don’t need.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与我们使用`eval`时完全相同，这告诉我`eval`在这里根本不需要。因此，`eval`在这里唯一的作用就是增加一个我们绝对不需要的攻击向量。
- en: '**Remember**: Don’t use `eval` when it isn’t necessary.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '**记住**：当没有必要时，不要使用`eval`。'
- en: 'A similar scenario involves assigning a command to a variable, as we see here
    in the `eval-test5.sh` script:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的场景涉及将命令赋值给一个变量，正如我们在`eval-test5.sh`脚本中看到的那样：
- en: '[PRE132]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Running this script will indeed show us the status of the web server service:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本将显示我们网站服务器服务的状态：
- en: '[PRE133]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'As before, we can accomplish the same thing without using `eval` at all, as
    you see here in the `eval-test6.sh` script:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以在完全不使用`eval`的情况下完成相同的操作，正如你在`eval-test6.sh`脚本中看到的那样：
- en: '[PRE134]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Run this script, and the results will be identical to what they were when you
    used `eval`. So again, `eval` isn’t needed.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个脚本，结果将与使用`eval`时的结果相同。因此，`eval`并不需要。
- en: 'Another example of this is the `value5.sh` script that I showed you in *Chapter
    10—Understanding Functions*. To refresh your memory, here’s what it looks like:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是我在*第10章—理解函数*中展示过的`value5.sh`脚本。为了帮助你回忆，下面是它的内容：
- en: '[PRE135]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: I’ve already explained this in *Chapter 10*, so for now I’ll just say that I’m
    using `eval` here as a mechanism to help pass values in and out of the `valuepass`
    function. But, if you refer back to *Chapter 10*, you’ll see that this is only
    one of several methods that I showed you for passing values in and out of a function.
    Using `eval` here is perfectly safe, since this script is only passing values
    internally. But, if you ever need to create a function that accepts external values
    from either the script’s user or an external text file, you’ll want to use one
    of the alternative methods.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在*第10章*中解释过这个问题，所以现在我只想说，我在这里使用`eval`是作为一种机制，帮助在`valuepass`函数内部传递值。但如果你回顾*第10章*，你会看到这只是我向你展示的几种传递值进出函数的方法之一。在这里使用`eval`是完全安全的，因为这个脚本只是进行内部值的传递。但是，如果你需要创建一个接受来自脚本用户或外部文本文件的外部值的函数，那么你就需要使用其中一种替代方法。
- en: I think that covers it for `eval`. Let’s look at one last possible coding problem,
    and then move on to the next chapter.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这就涵盖了`eval`的内容。让我们看看最后一个可能的编码问题，然后继续进入下一章节。
- en: Understanding Path Security
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解路径安全性
- en: 'The possibility—however remote it may be—exists that someone could plant a
    trojaned version of some system utility on your system, and then manipulate a
    user’s `PATH` setting so that the trojaned utility would be invoked, instead of
    the real one. The trojaned utility could do a variety of nasty things, such as
    exfiltrating sensitive data or performing a ransomware attack by encrypting important
    files. Before I show you a script, let’s see how this looks on the command-line.
    Let’s begin by showing you where the executable file for the normal `ls` command
    is located:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这种可能性非常渺小，也存在某人可能在你的系统上植入恶意版本的某个系统工具，并通过修改用户的`PATH`设置来调用该恶意工具，而不是调用真实的工具。这个恶意工具可能会做各种有害的事情，例如窃取敏感数据，或通过加密重要文件来进行勒索软件攻击。在我展示脚本之前，让我们先看看这在命令行上的表现。让我们先来看正常的`ls`命令的可执行文件所在的位置：
- en: '[PRE136]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'We see that it’s located in the `/usr/bin/` directory, as it should be. Now,
    let’s create a bogus `ls`, in the form of a script, and place it into the `/tmp/`
    directory. Here’s the `ls` script:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到它位于`/usr/bin/`目录中，这是应该的。现在，让我们创建一个假的`ls`脚本，并将其放入`/tmp/`目录中。下面是这个`ls`脚本：
- en: '[PRE137]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Of course, the `echo` command is harmless, but a real malicious hacker would
    replace that with something that isn’t harmless. After running the malicious command,
    the script will then invoke the normal `ls` command.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`echo`命令是无害的，但一个真正的恶意黑客会用一些不无害的命令来替换它。运行恶意命令后，脚本会调用正常的`ls`命令。
- en: Next, let’s manipulate the user’s `PATH` setting so that this script will get
    invoked instead of the real `ls`.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们修改用户的`PATH`设置，使得这个脚本会被调用，而不是实际的`ls`。
- en: '[PRE138]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Finally, we’ll invoke `ls`:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将调用`ls`：
- en: '[PRE139]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: This time, the bogus `ls` was invoked, because the `/tmp/` directory is the
    first directory in the user’s `PATH` setting.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，伪造的`ls`被调用了，因为`/tmp/`目录是用户`PATH`设置中的第一个目录。
- en: By default, the shell scripts that you create will use your normal `PATH` settings
    to find the utilities and programs that the script invokes. For example, when
    you want to invoke the `ls` command in a script, just add a line that says `ls`
    instead of `/usr/bin/ls`. By doing that though, any attacker who can manipulate
    a user’s `PATH` setting could cause the script to run a bogus, trojaned program.
    There are three things you can do to prevent that.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你创建的 shell 脚本会使用你正常的`PATH`设置来查找脚本中调用的工具和程序。例如，当你在脚本中想调用`ls`命令时，只需添加一行`ls`，而不是`/usr/bin/ls`。然而，采取这种方式后，任何能够操控用户`PATH`设置的攻击者都可能让脚本运行一个伪造的木马程序。你可以采取三种措施来防止这种情况发生。
- en: '**Method 1**: Make the script unreadable and untraceable, as I showed you in
    the first portion of this chapter. That way, attackers won’t be able to see which
    utilities that the script is invoking, which means that they won’t know which
    utilities to replace with a trojaned version.'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法 1**：让脚本不可读且无法追踪，正如我在本章第一部分所展示的那样。这样，攻击者就无法看到脚本正在调用哪些工具，这意味着他们不知道应该替换哪些工具来植入木马。'
- en: '**Method 2**: Explicitly set a new `PATH` at the top of the script. Here’s
    how that would look, in the `path-test1.sh` script:'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法 2**：在脚本顶部显式设置新的`PATH`。以下是在`path-test1.sh`脚本中的实现方式：'
- en: '[PRE140]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '**Method 3**: Use the entire path to every command that you place in the script.
    So, for example, when you want to invoke `awk`, have the line say `/bin/awk` instead
    of just `awk`.'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法 3**：在脚本中为每个命令使用完整路径。例如，当你想调用`awk`时，应该让这一行写成`/bin/awk`，而不是仅仅写`awk`。'
- en: One problem with the third method is that it could make your scripts less portable.
    That’s because some operating systems, such as FreeBSD, might have the executable
    files for certain utilities stored in directories that are different from what
    you’re used to. For example, FreeBSD has the executable files for many of its
    utilities in the `/usr/local/bin/` directory, instead of in the `/usr/bin/` as
    we’re used to seeing on Linux operating systems. So, if you want to ensure that
    your scripts will run on as many operating systems as possible, your best bet
    is to forget about Method 3\. Using Method 2 will be much easier and just as effective.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法的一个问题是，它可能会使你的脚本不那么可移植。这是因为某些操作系统（例如 FreeBSD）可能将某些工具的可执行文件存储在不同的目录中，而不是你习惯的目录。例如，FreeBSD
    将许多工具的可执行文件存储在`/usr/local/bin/`目录中，而不是我们在 Linux 操作系统中习惯看到的`/usr/bin/`目录。所以，如果你希望确保脚本能在尽可能多的操作系统上运行，你最好的做法是放弃方法
    3。使用方法 2 会更简单且同样有效。
- en: And now, you’re wondering how an attacker could possibly manipulate someone’s
    `PATH` setting like this. Well, I can think of two possible scenarios.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能在想攻击者是如何操控某人的`PATH`设置的。我可以想到两种可能的场景。
- en: 'Attack Scenario 1: Compromising the User’s Account'
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 攻击场景 1：妥协用户账户
- en: One way that an attacker can manipulate a user’s `PATH` setting is to first
    gain access to the user’s account. If the attacker has already accomplished that,
    then it’s game over anyway and path security would be the least of the user’s
    problems. So, your best bet would be to ensure that users’ accounts are configured
    securely, to prevent anyone from breaking in.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可能通过以下方式之一来操控用户的`PATH`设置：首先获得用户账户的访问权限。如果攻击者已经完成了这一点，那么无论如何，游戏就结束了，路径安全就不是用户最关心的问题。因此，你最好的做法是确保用户账户的配置是安全的，防止任何人入侵。
- en: 'Attack Scenario 2: Social Engineering'
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 攻击场景 2：社会工程学
- en: An attacker could also possibly use social engineering to trick a user into
    running a program that would alter the user’s shell configuration files.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者还可能使用社会工程学手段，欺骗用户运行一个程序，该程序会修改用户的 shell 配置文件。
- en: In the world of cybersecurity, **social engineering** can take many forms. For
    example, it can come by way of a scam email with a link to a malicious file, or
    it could come by way of a face-to-face encounter. In any case, the goal is to
    convince the victim to perform some sort of action that could cause a breach of
    security.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络安全的世界里，**社会工程学**可以有多种形式。例如，它可以通过一封带有恶意文件链接的诈骗邮件来实现，或者通过面对面的接触来进行。在任何情况下，目标都是说服受害者执行某种可能导致安全漏洞的操作。
- en: For this scenario, I’m using the Fedora Server virtual machine.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个场景，我使用的是 Fedora Server 虚拟机。
- en: 'First, let’s look at the `harmless-program.sh` script:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看一下`harmless-program.sh`脚本：
- en: '[PRE141]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Run the script, and note that it places an extra `PATH` directive at the end
    of the `.bashrc` file. This extra directive overrides the `PATH` directive that’s
    at the top of the file. This new setting won’t take effect right away, but it
    will the next time that the user either logs into the system or opens another
    terminal window.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本，并注意到它在`.bashrc`文件的末尾添加了一个额外的`PATH`指令。这个额外的指令覆盖了文件顶部的`PATH`指令。这个新设置不会立即生效，但在用户下一次登录系统或打开新终端窗口时将生效。
- en: 'Log out and then log back in again. Prepare to be amazed at what happens when
    you try to do a directory listing:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登出后，再重新登录。准备好当你尝试做目录列表时看到的惊人情况：
- en: '[PRE142]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Of course, in real life the script would have done something a bit more nasty.
    Also, distributing this sort of malicious program as a script would be a bit obvious.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在现实生活中，脚本可能会做一些更为恶意的事情。而且，将这种恶意程序作为脚本分发会显得有些明显。
- en: So, let’s use `shc` to convert this to an untraceable executable binary. Also,
    use the `-r` option so that the binary will execute on other Linux machines.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，让我们使用`shc`将其转换为一个不可追踪的可执行二进制文件。同时，使用`-r`选项，这样该二进制文件将在其他 Linux 机器上执行。
- en: '[PRE143]'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Before you try to execute the binary, open the `.bashrc` file in your text editor,
    and delete the two lines that were added by the script.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在尝试执行二进制文件之前，在文本编辑器中打开`.bashrc`文件，删除由脚本添加的那两行。
- en: Log out and then log back in.
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登出后，再重新登录。
- en: Execute the new `harmless-program` binary.
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行新的`harmless-program`二进制文件。
- en: Log out and then log back in. Then, execute the `ls` command. You should see
    the same results that you saw in Step 3.
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登出后，再重新登录。然后，执行`ls`命令。你应该会看到与步骤 3 中相同的结果。
- en: Finally, open the `.bashrc` file in your text editor and delete the two lines
    that were added by the `harmless-program` program.
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在文本编辑器中打开`.bashrc`文件，删除由`harmless-program`程序添加的那两行。
- en: If you do a web search for articles related to shell scripting security, you’ll
    find several that talk about path security attacks. Curiously though, I’ve never
    seen a single one that explains how someone might execute such an attack.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在网上搜索与 Shell 脚本安全相关的文章，你会发现有几篇讨论了路径安全攻击。然而，奇怪的是，我从未见过一篇文章解释有人如何执行这种攻击。
- en: Also, this scenario provides a prime example of why all personnel who use a
    computer should learn to recognize and avoid social engineering attacks.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个场景提供了一个很好的例子，说明为什么所有使用计算机的人员都应该学会识别和避免社会工程攻击。
- en: Okay, I think that this about covers things for this topic. So, let’s wrap up
    and move on.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想这部分的内容已经覆盖得差不多了。接下来，我们就总结一下并继续前进。
- en: Summary
  id: totrans-574
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered topics that are important to a security-conscious
    Linux or Unix administrator. We began with a discussion of how to control access
    to your important scripts, and showed various methods of doing so. Next, we looked
    at considerations about the SUID and SGID permissions settings, and then we looked
    at a few different ways to prevent your scripts from leaking sensitive data. We
    then looked at how using the `eval` command in scripts can be quite dangerous,
    and wrapped up with a discussion of path security.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了对于关注安全的 Linux 或 Unix 管理员来说非常重要的主题。我们首先讨论了如何控制对重要脚本的访问，并展示了多种方法来实现这一点。接下来，我们关注了
    SUID 和 SGID 权限设置的相关注意事项，然后探讨了几种防止脚本泄露敏感数据的方法。接着，我们讨论了在脚本中使用`eval`命令是多么危险，最后以路径安全的讨论作为总结。
- en: In the next chapter, we’ll talk about debugging buggy scripts. I’ll see you
    there.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何调试有漏洞的脚本。到时见。
- en: Questions
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following is true about the `eval` command?
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于`eval`命令，以下哪项是正确的？
- en: It’s always safe to use `eval` in your scripts.
  id: totrans-579
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本中使用`eval`总是很安全的。
- en: It’s always dangerous to use `eval` in your scripts.
  id: totrans-580
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本中使用`eval`总是很危险的。
- en: It’s only safe to use `eval` in your scripts if it only takes input from and
    external source.
  id: totrans-581
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当`eval`仅从外部源获取输入时，才可以安全地在脚本中使用它。
- en: It’s only safe to use `eval` in your scripts if it only takes input from within
    your script.
  id: totrans-582
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当`eval`仅从脚本内部获取输入时，才可以安全地在脚本中使用它。
- en: Which two of the following statements are true about the `/tmp/` directory?
    (Choose two.)
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于`/tmp/`目录，以下哪两项陈述是正确的？（选择两项。）
- en: It’s completely secure, because only administrative users can enter it.
  id: totrans-584
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是完全安全的，因为只有管理员用户可以进入。
- en: Anybody can create files in it.
  id: totrans-585
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何人都可以在其中创建文件。
- en: Anybody can read files that `mktemp` creates in the `/tmp/` directory.
  id: totrans-586
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何人都可以读取`mktemp`在`/tmp/`目录中创建的文件。
- en: Any files that `mktemp` creates in the `/tmp/` directory can only be read by
    the user who created them.
  id: totrans-587
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mktemp`在`/tmp/`目录中创建的任何文件只能由创建它们的用户读取。'
- en: How would you prevent an attacker from obtaining information from a binary that
    you’ve created with `shc`?
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何防止攻击者从你用`shc`创建的二进制文件中获取信息？
- en: It’s never possible to obtain information from an `shc` binary.
  id: totrans-589
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`shc`二进制文件中获取信息永远是不可能的。
- en: Use `shc` with the `-U` option.
  id: totrans-590
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shc`并带上`-U`选项。
- en: Use `shc` with the `-u` option.
  id: totrans-591
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shc`并带上`-u`选项。
- en: There’s nothing you can do to prevent this.
  id: totrans-592
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你无法做任何事情来防止这种情况发生。
- en: Before you set an Access Control List on a file, what must you do to that file?
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为文件设置访问控制列表（ACL）之前，你需要做什么？
- en: Remove all permissions from *group* and *others*.
  id: totrans-594
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除*组*和*其他*的所有权限。
- en: There’s nothing that you need to do.
  id: totrans-595
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你无需做任何事情。
- en: Ensure that *user*, *group*, and *others* all have read, write, and execute
    permissions.
  id: totrans-596
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保*用户*、*组*和*其他*都具有读、写和执行权限。
- en: Change ownership of the file to the root user.
  id: totrans-597
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件的所有权更改为root用户。
- en: What’s the best way to ensure that any temporary files that your script creates
    in the `/tmp/` directory always get deleted?
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保脚本在`/tmp/`目录中创建的任何临时文件始终被删除的最佳方法是什么？
- en: After you run the script, go into the `/tmp/` directory and delete the temporary
    files yourself.
  id: totrans-599
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本后，进入`/tmp/`目录并手动删除临时文件。
- en: Automatically delete the files with an `rm` command at the end of the script.
  id: totrans-600
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本结束时使用`rm`命令自动删除文件。
- en: Automatically delete the files with a `trap` command at the beginning of the
    script.
  id: totrans-601
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本开始时使用`trap`命令自动删除文件。
- en: No action is needed, because your script will always automatically delete its
    temporary files.
  id: totrans-602
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不需要任何操作，因为脚本会始终自动删除其临时文件。
- en: Further Reading
  id: totrans-603
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Setting and Displaying ACLs on ZFS File in Compact Format—Oracle Solaris ZFS
    Administration Guide: [https://docs.oracle.com/cd/E23823_01/html/819-5461/gbchf.html#scrolltoc](https://docs.oracle.com/cd/E23823_01/html/819-5461/gbchf.html#scrolltoc)'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ZFS文件上设置和显示ACL（以紧凑格式）—Oracle Solaris ZFS管理指南：[https://docs.oracle.com/cd/E23823_01/html/819-5461/gbchf.html#scrolltoc](https://docs.oracle.com/cd/E23823_01/html/819-5461/gbchf.html#scrolltoc)
- en: 'Shell Scripts and Security: [https://stackoverflow.com/questions/8935162/shell-scripts-and-security](https://stackoverflow.com/questions/8935162/shell-scripts-and-security)'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell脚本与安全性：[https://stackoverflow.com/questions/8935162/shell-scripts-and-security](https://stackoverflow.com/questions/8935162/shell-scripts-and-security)
- en: 'Shell Script Security: [https://developer.apple.com/library/archive/documentation/OpenSource/Conceptual/ShellScripting/ShellScriptSecurity/ShellScriptSecurity.html](https://developer.apple.com/library/archive/documentation/OpenSource/Conceptual/ShellScripting/ShellScriptSecurity/ShellScriptSecurity.html)'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell脚本安全性：[https://developer.apple.com/library/archive/documentation/OpenSource/Conceptual/ShellScripting/ShellScriptSecurity/ShellScriptSecurity.html](https://developer.apple.com/library/archive/documentation/OpenSource/Conceptual/ShellScripting/ShellScriptSecurity/ShellScriptSecurity.html)
- en: 'How to Securely Work with Temporary Files in Linux Shell Scripting: [https://youtu.be/zxswimoojh4?si=ERfbJ04U2LJzQE60](https://youtu.be/zxswimoojh4?si=ERfbJ04U2LJzQE60)'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Linux Shell脚本中安全地处理临时文件：[https://youtu.be/zxswimoojh4?si=ERfbJ04U2LJzQE60](https://youtu.be/zxswimoojh4?si=ERfbJ04U2LJzQE60)
- en: 'Why is SUID disabled for shell scripts but not for binaries?: [https://security.stackexchange.com/questions/194166/why-is-suid-disabled-for-shell-scripts-but-not-for-binaries](https://security.stackexchange.com/questions/194166/why-is-suid-disabled-for-shell-scripts-but-not-for-binaries
    )'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么SUID对shell脚本禁用但对二进制文件不禁用？：[https://security.stackexchange.com/questions/194166/why-is-suid-disabled-for-shell-scripts-but-not-for-binaries](https://security.stackexchange.com/questions/194166/why-is-suid-disabled-for-shell-scripts-but-not-for-binaries)
- en: 'Dangers of SUID shell scripts: [https://www.drdobbs.com/dangers-of-suid-shell-scripts/199101190](https://www.drdobbs.com/dangers-of-suid-shell-scripts/199101190)'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SUID shell脚本的危险：[https://www.drdobbs.com/dangers-of-suid-shell-scripts/199101190](https://www.drdobbs.com/dangers-of-suid-shell-scripts/199101190)
- en: 'Using the trap builtin to catch interrupts for graceful event handling in the
    shell: [https://www.shellscript.sh/trap.html](https://www.shellscript.sh/trap.html)'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 trap 内置命令捕获中断以实现 shell 中的优雅事件处理: [https://www.shellscript.sh/trap.html](https://www.shellscript.sh/trap.html)'
- en: 'Reverse Engineering Tools in Linux—strings, nm, ltrace, strace, LD_PRELOAD:
    [https://www.thegeekstuff.com/2012/03/reverse-engineering-tools/](https://www.thegeekstuff.com/2012/03/reverse-engineering-tools/)'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux 中的逆向工程工具—strings, nm, ltrace, strace, LD_PRELOAD: [https://www.thegeekstuff.com/2012/03/reverse-engineering-tools/](https://www.thegeekstuff.com/2012/03/reverse-engineering-tools/)'
- en: 'Reverse Engineering with strace: [https://function61.com/blog/2017/reverse-engineering-with-strace/](https://function61.com/blog/2017/reverse-engineering-with-strace/)'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 strace 进行逆向工程: [https://function61.com/blog/2017/reverse-engineering-with-strace/](https://function61.com/blog/2017/reverse-engineering-with-strace/)'
- en: 'How to Use Encrypted Passwords in Bash Scripts: [https://www.howtogeek.com/734838/how-to-use-encrypted-passwords-in-bash-scripts/](https://www.howtogeek.com/734838/how-to-use-encrypted-passwords-in-bash-scripts/)'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如何在 Bash 脚本中使用加密密码: [https://www.howtogeek.com/734838/how-to-use-encrypted-passwords-in-bash-scripts/](https://www.howtogeek.com/734838/how-to-use-encrypted-passwords-in-bash-scripts/)'
- en: 'Beginners Guide for eval Command on Linux: [https://linuxtldr.com/eval-command/](https://linuxtldr.com/eval-command/)'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux 中 eval 命令的初学者指南: [https://linuxtldr.com/eval-command/](https://linuxtldr.com/eval-command/)'
- en: 'How to Use eval in Linux Bash Scripts: [https://www.howtogeek.com/818088/bash-eval/](https://www.howtogeek.com/818088/bash-eval/)'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如何在 Linux Bash 脚本中使用 eval: [https://www.howtogeek.com/818088/bash-eval/](https://www.howtogeek.com/818088/bash-eval/)'
- en: 'Eval Command and Security Issues: [http://mywiki.wooledge.org/BashFAQ/048](http://mywiki.wooledge.org/BashFAQ/048)'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Eval 命令和安全问题: [http://mywiki.wooledge.org/BashFAQ/048](http://mywiki.wooledge.org/BashFAQ/048)'
- en: 'Code Injection: [https://owasp.org/www-community/attacks/Code_Injection](https://owasp.org/www-community/attacks/Code_Injection)'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '代码注入: [https://owasp.org/www-community/attacks/Code_Injection](https://owasp.org/www-community/attacks/Code_Injection)'
- en: 'Securing Shell Scripts: [https://www.admin-magazine.com/Archive/2021/64/Best-practices-for-secure-script-programming](https://www.admin-magazine.com/Archive/2021/64/Best-practices-for-secure-script-programming)'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '脚本安全: [https://www.admin-magazine.com/Archive/2021/64/Best-practices-for-secure-script-programming](https://www.admin-magazine.com/Archive/2021/64/Best-practices-for-secure-script-programming)'
- en: Answers
  id: totrans-619
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: d
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: b and d
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b 和 d
- en: b
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: a
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a
- en: c
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: Join our community on Discord!
  id: totrans-625
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Linux 专家以及作者本人一起阅读这本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 提问，向其他读者提供解决方案，参加与作者的问答互动，更多精彩内容。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-629
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
