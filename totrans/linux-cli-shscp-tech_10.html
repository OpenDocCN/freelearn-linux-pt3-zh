<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer232">
			<p> </p>
			<h1 id="_idParaDest-219"><em class="italic"><a id="_idTextAnchor225"/>Chapter 10</em>: Using Loops</h1>
			<p>In the previous chapter, we started dealing with scripting, and we did a lot of learning about how scripts work and how they are structured. However, we missed a huge topic in scripting – influencing the order in which commands are executed when a script is run. There are a couple of things that we need to cover here, since there are multiple ways we can influence what is going to be the next command executed in a script. </p>
			<p>We are going to start with a concept we call <strong class="bold">iterators</strong> or, more commonly, <strong class="bold">loops</strong>. There are a lot of things in everyday <a id="_idIndexMarker727"/>tasks that need to be done repeatedly, usually changing just one small thing in every iteration. This is where looping comes in. </p>
			<p>We will cover the following recipes in this chapter: </p>
			<ul>
				<li>The <strong class="source-inline">for</strong> loop</li>
				<li><strong class="source-inline">break</strong> and <strong class="source-inline">continue</strong></li>
				<li>The <strong class="source-inline">while</strong> loop</li>
				<li>The <strong class="source-inline">test-if</strong> loop</li>
				<li>The <strong class="source-inline">case</strong> loop</li>
				<li>Logical looping with <strong class="source-inline">and</strong>, <strong class="source-inline">or</strong>, and <strong class="source-inline">not</strong></li>
			</ul>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor226"/>The for loop</h1>
			<p>When we talk about loops, we usually make a distinction based on the place in the execution where the <a id="_idIndexMarker728"/>variable we <a id="_idIndexMarker729"/>are using changes its value. <strong class="source-inline">for</strong> loops, in that respect, belong to the group where a variable is set before each iteration and keeps its value until the next iteration is run. The most common task that we are going to perform by using a <strong class="source-inline">for</strong> loop is going to be using the loop to iterate through sets of things, usually either numbers or names.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor227"/>Getting ready</h2>
			<p>Before we begin introducing different ways of using a <strong class="source-inline">for</strong> loop, we need to address its abstract form: </p>
			<p class="source-code">for item in [LIST]</p>
			<p class="source-code">Do</p>
			<p class="source-code">  [COMMANDS]</p>
			<p class="source-code">done</p>
			<p>What do we have here? The first thing to note is that we have some reserved keywords that make Bash understand that we want to use a <strong class="source-inline">for</strong> loop. In this particular example, <strong class="source-inline">item</strong> is actually the name of the variable that will hold one value from the list in each loop iteration. The word <strong class="source-inline">in</strong> is a<a id="_idIndexMarker730"/> keyword that further helps us understand that we are going to use a set of values that we currently call a list, although it can be different things. </p>
			<p>After the list, there is a block that defines what commands we intend to run each time a loop is performed. Currently, we are going to work with this block as a single entity, containing commands that will be executed one after another without interruptions. Later in this chapter, we are going to introduce some conditional branching that will enable us to cover more possible workflow solutions, but for now, a block is uninterruptable. </p>
			<p>What will<a id="_idIndexMarker731"/> probably surprise you is that a <strong class="source-inline">for</strong> loop is often used directly from the command line, even more often than in scripts. The reason is simple – there are a lot of tasks we can accomplish by using a simple <strong class="source-inline">for</strong> loop, and complicating them by creating scripts is to be avoided. A <strong class="source-inline">for</strong> loop<a id="_idIndexMarker732"/> in this form looks a little different than in the one we showed as our first example, the main difference being the semicolon that separates the keywords when we are using a single line to write out the loop. </p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor228"/>How to do it…</h2>
			<p>Let's start with a simple example. We are going to run through a list of servers and echo one in each iteration of the loop. Note that the shell takes our command from the prompt and repeats it before executing it: </p>
			<p class="source-code">root@cli1:~# for name in srv1 srv2 srv3 ;do echo $name; \</p>
			<p class="source-code">done; </p>
			<p class="source-code">Srv1</p>
			<p class="source-code">Srv2</p>
			<p class="source-code">srv3</p>
			<p>Using <strong class="source-inline">echo</strong> as a placeholder<a id="_idIndexMarker733"/> for commands when testing a loop is common. We are going to use this<a id="_idIndexMarker734"/> style of debugging a lot in our examples. <strong class="source-inline">echo</strong> as a<a id="_idIndexMarker735"/> command is probably the most useful one in this context since it changes nothing and, at the same time, enables us to see what the actual output is going to be. </p>
			<p>When creating a list of objects, we don't have to use any special characters to separate individual entries; bash is going to <a id="_idIndexMarker736"/>treat space as a delimiter, and as long as we separate our values by a space, <strong class="source-inline">bash</strong> is going to understand our intentions. A little later, we are going to show you how to change the character that separates a value in the list, but a space will work in almost all the circumstances. </p>
			<p>The list we are using in the iterations can be explicitly defined, but more often than not, we are going to need to create it when we run our loop, in the command line or the script.</p>
			<p>A typical example of this is running a loop on a set of files in a directory. The way to do this is to use shell expansion. This means letting the shell run a command and then using its output as the list for the <strong class="source-inline">for</strong> loop. We can do this either by specifying a command in backticks (<strong class="source-inline">`</strong>) or using <strong class="source-inline">bash</strong> notation of <strong class="source-inline">$</strong>(command). Both ways have the same result – a command is run and then piped to a list. </p>
			<p>Our example is going to be a loop that iterates through the current directory and runs the <strong class="source-inline">file</strong> command on <a id="_idIndexMarker737"/>each individual file, giving us information on what this particular file actually is. We are still on the command line:</p>
			<p class="source-code">root@cli1:~# for name in `ls`; do file $name; done;</p>
			<p class="source-code">donebackups.lst: ASCII text</p>
			<p class="source-code">snap: directory</p>
			<p class="source-code">testfile: empty</p>
			<p>Now, let's deal with something more interesting. Often, we need to use numbers in our loops, either to count something or to create other objects. Almost all programming languages have some sort of loop that enables this. Bash is a sort of an exception to this rule, since it can do it in a couple of different ways. One is to use the <strong class="source-inline">echo</strong> command and a little bit of shell expansion to accomplish this task.</p>
			<p>If you are unfamiliar with <a id="_idIndexMarker738"/>this, giving <strong class="source-inline">echo</strong> an argument that consists of a number formatted in <a id="_idIndexMarker739"/>curly brackets will make it output all the numbers in the interval that you specified: </p>
			<p class="source-code">demo@cli1:~/scripting$ echo {0..9}</p>
			<p class="source-code">0 1 2 3 4 5 6 7 8 9</p>
			<p>To use this in a loop, we simply do the same trick as we did in the previous example: </p>
			<p class="source-code">root@cli1:~# for number in `echo {0..9}`; do echo $number; \</p>
			<p class="source-code">done; </p>
			<p class="source-code">for number in `echo {0..9}`; do echo $number; done; </p>
			<p class="source-code">0</p>
			<p class="source-code">1</p>
			<p class="source-code">2</p>
			<p class="source-code">3</p>
			<p class="source-code">4</p>
			<p class="source-code">5</p>
			<p class="source-code">6</p>
			<p class="source-code">7</p>
			<p class="source-code">8</p>
			<p class="source-code">9</p>
			<p>We are not limited to using a fixed step in the interval; if we simply mention an interval followed by a number, this number will be considered as a step value. A step value is basically a number that your variable is going to be incremented with in each loop iteration. </p>
			<p>We are going to try a simple loop using multipliers of <strong class="source-inline">20</strong>:</p>
			<p class="source-code">root@cli1:~# for number in `echo {0..100..20}`; do echo \</p>
			<p class="source-code">$number; done; </p>
			<p class="source-code">for number in `echo {0..100..20}`; do echo $number; done; </p>
			<p class="source-code">0</p>
			<p class="source-code">20</p>
			<p class="source-code">40</p>
			<p class="source-code">60</p>
			<p class="source-code">80</p>
			<p class="source-code">100</p>
			<p>We can combine shell <a id="_idIndexMarker740"/>expansion the same way that we normally do in the command line<a id="_idIndexMarker741"/> and create different values for our loop. For example, in order to create server names for three groups of servers, each containing six servers, we can use a simple one-line loop:</p>
			<p class="source-code">root@cli1:~# for name  in srv{l,w,m}-{1..6}; do echo $name; \</p>
			<p class="source-code">done;</p>
			<p class="source-code">srvl-1</p>
			<p class="source-code">srvl-2</p>
			<p class="source-code">srvl-3</p>
			<p class="source-code">srvl-4</p>
			<p class="source-code">srvl-5</p>
			<p class="source-code">srvl-6</p>
			<p class="source-code">srvw-1</p>
			<p class="source-code">srvw-2</p>
			<p class="source-code">srvw-3</p>
			<p class="source-code">srvw-4</p>
			<p class="source-code">srvw-5</p>
			<p class="source-code">srvw-6</p>
			<p class="source-code">srvm-1</p>
			<p class="source-code">srvm-2</p>
			<p class="source-code">srvm-3</p>
			<p class="source-code">srvm-4</p>
			<p class="source-code">srvm-5</p>
			<p class="source-code">srvm-6</p>
			<p>Of course, loops can be<a id="_idIndexMarker742"/> embedded within each other by simply placing the inner loop <a id="_idIndexMarker743"/>into the <strong class="source-inline">do-done</strong> block of the outer loop. In this particular example, we are using shell expansion to loop through a list of values in both loops:</p>
			<p class="source-code">root@cli1:~# for name  in {user1,user2,user3,user4}; do \</p>
			<p class="source-code">for server in {srv1,srv2,srv3,srv4}; do echo "Trying to ssh \</p>
			<p class="source-code">$name@$server"; done;done; </p>
			<p class="source-code">Trying to ssh user1@srv1</p>
			<p class="source-code">Trying to ssh user1@srv2</p>
			<p class="source-code">Trying to ssh user1@srv3</p>
			<p class="source-code">Trying to ssh user1@srv4</p>
			<p class="source-code">Trying to ssh user2@srv1</p>
			<p class="source-code">Trying to ssh user2@srv2</p>
			<p class="source-code">Trying to ssh user2@srv3</p>
			<p class="source-code">Trying to ssh user2@srv4</p>
			<p class="source-code">Trying to ssh user3@srv1</p>
			<p class="source-code">Trying to ssh user3@srv2</p>
			<p class="source-code">Trying to ssh user3@srv3</p>
			<p class="source-code">Trying to ssh user3@srv4</p>
			<p class="source-code">Trying to ssh user4@srv1</p>
			<p class="source-code">Trying to ssh user4@srv2</p>
			<p class="source-code">Trying to ssh user4@srv3</p>
			<p class="source-code">Trying to ssh user4@srv4</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor229"/>How it works…</h2>
			<p>Now is the time to <a id="_idIndexMarker744"/>slowly switch from the command line to how we can use these<a id="_idIndexMarker745"/> loops in scripts. The biggest difference here is that <strong class="source-inline">for</strong> loops are way easier to read when formatted in a script. </p>
			<p>For our first example, we are going to mention another way of creating a set of numbers in a loop, a so-called <em class="italic">C-style loop</em>. As the name suggests, this loop takes its syntax from the C language. Each<a id="_idIndexMarker746"/> loop has three separate values. Of these, the first two are compulsory; the third is not. The<a id="_idIndexMarker747"/> first value is called either the <em class="italic">initialization value</em> or the <em class="italic">start value</em>. It gives<a id="_idIndexMarker748"/> us the value of the variable in the first loop iteration. One thing to note here is that we need to assign the initial value explicitly, which significantly differs from the usual style used in the <em class="italic">normal</em> <strong class="source-inline">for</strong> loop. </p>
			<p>The second value in this loop variation<a id="_idIndexMarker749"/> is the <em class="italic">test condition</em>, occasionally known as the <em class="italic">boundary condition</em>. This represents the last valid value that our loop iterator will have before<a id="_idIndexMarker750"/> we finish the loop or, to put it more simply, the largest number if we count incrementally. </p>
			<p>The third value can be omitted; it will default to <strong class="source-inline">1</strong>. If we use it, this is going to be the default step or increment that our loop is going to use. </p>
			<p>Theoretically, this C-style <strong class="source-inline">for</strong> loop will look like this: </p>
			<p class="source-code">for ((INITIALIZATION; TEST; STEP))</p>
			<p class="source-code">Do</p>
			<p class="source-code">  [COMMANDS]</p>
			<p class="source-code">done</p>
			<p>In reality, it has a more complex syntax, but it will look very familiar to all of you with experience in programming in C, as the name suggests:</p>
			<p class="source-code">for ((i = 0 ; i &lt;= 100 ; i=i+20)); do</p>
			<p class="source-code">  echo "Counter: $i"</p>
			<p class="source-code">done</p>
			<p>Before we go <a id="_idIndexMarker751"/>on, let's look at an example of a loop that we have already used but formatted as <a id="_idIndexMarker752"/>it would be in a script: </p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># for loop test script 1 </p>
			<p class="source-code">for name  in {user1,user2,user3,user4}; do</p>
			<p class="source-code">        for server in {srv1,srv2,srv3,srv4}; do</p>
			<p class="source-code">                echo "Trying to ssh $name@$server"</p>
			<p class="source-code">        Done</p>
			<p class="source-code">done</p>
			<p>As we can see, the only real difference here is the formatting and the omission of semicolons that directly stems from not having to parse the entire script in one line.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor230"/>See also</h2>
			<p>In order to <a id="_idIndexMarker753"/>understand looping, you will probably need quite a few examples. Start with these links: </p>
			<ul>
				<li><a href="https://linuxhint.com/30_bash_loop_examples">https://linuxhint.com/30_bash_loop_examples</a>/</li>
				<li><a href="https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-7.html">https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-7.html</a></li>
			</ul>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor231"/>break and continue</h1>
			<p>Up until now, we haven't really done any conditional branching in our scripts. Everything we did was linear, even loops. Our script was able to execute commands line by line, starting from the first one, and if we had a loop, it was running until our conditions that we stated at the<a id="_idIndexMarker754"/> loop start were met. This means that our loops have a fixed, predetermined number of iterations. Sometimes, or to be more precise often, we need to do something that breaks this idea.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor232"/>Getting ready</h2>
			<p>Imagine this example – you have a loop that has to iterate a number of times <em class="italic">unless</em> a condition is met. We said that our loops have the number of iterations fixed at the start of the loop, so we obviously need a way to end the loop prematurely. </p>
			<p>This is why we have a <a id="_idIndexMarker755"/>command called <strong class="source-inline">break</strong>. As the name suggests, this command breaks the loop by escaping from the command block it is included in and finishing the loop, regardless of the conditions that were used in the definition of the loop. The main reason why this is important is to establish control over the loop and handle any possible state that requires you to not finish the job you started in your loop. One more thing to note is that the <strong class="source-inline">break</strong> command is not limited only to <strong class="source-inline">for</strong> loops; it can be used in any other block of code, a thing that will become more useful later when we learn other ways to structure our scripts into blocks. </p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor233"/>How to do it…</h2>
			<p>It is always easy to start with an example, but in this particular case, we are going to start with an overall view of how this command works. We are going to use abstract commands instead of actual ones to help you understand the structure of this loop. After this, we are going to create some real-world examples: </p>
			<p class="source-code">for I in 1 2 3 4 5</p>
			<p class="source-code">do</p>
			<p class="source-code">#main part of the loop, will execute each time loop is started</p>
			<p class="source-code">  command1      </p>
			<p class="source-code">  command2</p>
			<p class="source-code">#condition to meet if we need to break the loop</p>
			<p class="source-code">  if (break-condition)</p>
			<p class="source-code">  then</p>
			<p class="source-code">#Leave the loop</p>
			<p class="source-code">      break          </p>
			<p class="source-code">  fi</p>
			<p class="source-code">#This command will execute if the condition is not met</p>
			<p class="source-code">  statements3              </p>
			<p class="source-code">done</p>
			<p class="source-code">command4</p>
			<p>What is going on here? The <strong class="source-inline">for</strong> loop by itself is a normal loop that gets executed using <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, <strong class="source-inline">3</strong>, <strong class="source-inline">4</strong>, and <strong class="source-inline">5</strong> as values. <strong class="source-inline">command1</strong> and <strong class="source-inline">command2</strong> are going to get executed the way we expect them to be at least once, since they are the first thing after the start of the loop. </p>
			<p>The <strong class="source-inline">if</strong> statement<a id="_idIndexMarker756"/> is <a id="_idIndexMarker757"/>where things get interesting. We will talk a lot more about <strong class="source-inline">if</strong> statements, but we need to mention them here in their most basic form. Here, we have something called a break condition. This can be anything that can be resolved to a logical value. That means the result of our condition has to be either <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. If the result is false, our condition is not met, and the loop continues by executing <strong class="source-inline">command3</strong>,  looping back to the beginning of the loop, and assigning the next value to our variable. </p>
			<p>We are more interested in what happens if the break condition evaluates to true. This means that we have met our condition and need to run the block of code that follows. A simple <strong class="source-inline">break</strong> statement is here, and it has no arguments. What will happen next is that the script will immediately exit the loop and go to execute <strong class="source-inline">command4</strong> and whatever is after it. The important thing is that <strong class="source-inline">command3</strong> will not be run in this case, and the loop will not repeat, regardless of the value of the loop variable. </p>
			<p>There is another statement called <strong class="source-inline">continue</strong> that can also be useful, although it is not used as much <a id="_idIndexMarker758"/>as <strong class="source-inline">break</strong>. <strong class="source-inline">Continue</strong> also breaks the loop in a way, but not permanently. Once you use <strong class="source-inline">continue</strong> in<a id="_idIndexMarker759"/> the loop, the program flow is going to immediately go to the start of the loop block without executing the remaining statements. </p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor234"/>How it works…</h2>
			<p>Having talked about the abstract structure, it is time to create an example. </p>
			<p>Imagine we are counting using a <strong class="source-inline">for</strong> loop, but we want to break out of it as soon as we hit the number <strong class="source-inline">4</strong> as the value of our variable. Of course, we could do this by simply specifying number <strong class="source-inline">5</strong> as the upper value that we are counting, but we need to show how the loop works, so we are<a id="_idIndexMarker760"/> going to break out of it using the <strong class="source-inline">break</strong> statement:  </p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># testing the break command</p>
			<p class="source-code">for number  in 1 2 3 4 5</p>
			<p class="source-code">do </p>
			<p class="source-code">echo running command1, number is $number</p>
			<p class="source-code">echo running command2, number is $number</p>
			<p class="source-code">if [ $number -eq 4 ]</p>
			<p class="source-code">        Then</p>
			<p class="source-code">                echo breaking out of loop, number is $number</p>
			<p class="source-code">                Break</p>
			<p class="source-code">fi</p>
			<p class="source-code">echo running command3, number is $number</p>
			<p class="source-code">done</p>
			<p>It's time to break down our script, but we are going to run it before we do that: </p>
			<p class="source-code">demo@cli1:~/scripting$ bash forbreak.sh </p>
			<p class="source-code">running command1, number is 1</p>
			<p class="source-code">running command2, number is 1</p>
			<p class="source-code">running command3, number is 1</p>
			<p class="source-code">running command1, number is 2</p>
			<p class="source-code">running command2, number is 2</p>
			<p class="source-code">running command3, number is 2</p>
			<p class="source-code">running command1, number is 3</p>
			<p class="source-code">running command2, number is 3</p>
			<p class="source-code">running command3, number is 3</p>
			<p class="source-code">running command1, number is 4</p>
			<p class="source-code">running command2, number is 4</p>
			<p class="source-code">breaking out of loop, number is 4</p>
			<p>Our sample script looks a lot like our <em class="italic">abstract</em> example, but we used actual the <strong class="source-inline">echo</strong> command to emulate something that should happen. The most important part that we need to talk about is the <strong class="source-inline">if</strong> command; everything else is as we said in the first part of this recipe. </p>
			<p>We mentioned that <a id="_idIndexMarker761"/>we need to have a condition for our <strong class="source-inline">break</strong> statement to make any sense. In this particular case, we are using <strong class="source-inline">if</strong> with a <strong class="source-inline">test</strong> condition; basically, we are telling <strong class="source-inline">bash</strong> to compare two values and let us know whether they are the same or not. In <strong class="source-inline">bash</strong>, there are two ways to do this – one is to use the <strong class="source-inline">=</strong> operator we are used to, and another is to use the <strong class="source-inline">-eq</strong> or <strong class="source-inline">equals</strong> operator. The difference between these two is that <strong class="source-inline">=</strong> compares <strong class="source-inline">strings</strong>, while <strong class="source-inline">-eq</strong> compares integers. We will go into much more detail in later recipes, since they are important in scripting. </p>
			<p>Now, let's see how <a id="_idIndexMarker762"/>the <strong class="source-inline">continue</strong> command works. We are going to slightly modify our script so that it skips over the third command once it hits <strong class="source-inline">3</strong> as the value of the variable:</p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># testing the continue command</p>
			<p class="source-code">for number  in 1 2 3 4 5</p>
			<p class="source-code">do</p>
			<p class="source-code">echo running command1, number is $number</p>
			<p class="source-code">echo running command2, number is $number</p>
			<p class="source-code">if [ $number -eq 3 ]</p>
			<p class="source-code">        Then</p>
			<p class="source-code">                echo skipping over a statement, number is \</p>
			<p class="source-code">$number</p>
			<p class="source-code">                Continue</p>
			<p class="source-code">fi</p>
			<p class="source-code">echo running command3, number is $number</p>
			<p class="source-code">done</p>
			<p>What we did is a simple change in the <strong class="source-inline">if</strong> statement; we changed the condition so that it checks whether the variable value is equal to <strong class="source-inline">3</strong>, and then we created a command block that skips over the rest of the<a id="_idIndexMarker763"/> loop when our condition is satisfied. Running it is simple:</p>
			<p class="source-code">demo@cli1:~/scripting$ bash forcontinue.sh</p>
			<p class="source-code">running command1, number is 1</p>
			<p class="source-code">running command2, number is 1</p>
			<p class="source-code">running command3, number is 1</p>
			<p class="source-code">running command1, number is 2</p>
			<p class="source-code">running command2, number is 2</p>
			<p class="source-code">running command3, number is 2</p>
			<p class="source-code">running command1, number is 3</p>
			<p class="source-code">running command2, number is 3</p>
			<p class="source-code">skipping over a statement, number is 3</p>
			<p class="source-code">running command1, number is 4</p>
			<p class="source-code">running command2, number is 4</p>
			<p class="source-code">running command3, number is 4</p>
			<p class="source-code">running command1, number is 5</p>
			<p class="source-code">running command2, number is 5</p>
			<p class="source-code">running command3, number is 5</p>
			<p>The only real point here is noting that we finished all our iterations; the only thing we skipped was one instance of running the third command in the script. Also, note that the <strong class="source-inline">continue</strong> command <a id="_idIndexMarker764"/>in the loop is going to skip over everything up to the end of the current loop and go back to the beginning, while a <strong class="source-inline">break</strong> statement is going to skip the entire loop and not repeat it. </p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor235"/>See also</h2>
			<p>Interrupting command flow <a id="_idIndexMarker765"/>can be a problem at first. More information is available at these links: </p>
			<ul>
				<li><a href="https://tldp.org/LDP/abs/html/loopcontrol.html">https://tldp.org/LDP/abs/html/loopcontrol.html</a></li>
				<li><a href="https://linuxize.com/post/bash-break-continue/">https://linuxize.com/post/bash-break-continue/</a></li>
			</ul>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor236"/>The while loop</h1>
			<p>Up until now, we have dealt with loops that have a fixed number of iterations. The reason is simple – if you are using a <strong class="source-inline">for</strong> loop, you need to specify <em class="italic">for</em> what values your loop is going to run, or what values your variable is going to have while in the loop. </p>
			<p>The problem <a id="_idIndexMarker766"/>with this approach to looping is that sometimes you don't know in advance how many iterations you are<a id="_idIndexMarker767"/> going to need to do something. This is where the <strong class="source-inline">while</strong> loop comes into play. </p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor237"/>Getting ready</h2>
			<p>The most important thing you need to know about the <strong class="source-inline">while</strong> loop is that it does its testing at the start of the loop. This means that we need to structure our script to run <em class="italic">while</em> something is true. This also means that we can make a loop that will never get executed; if we create a <strong class="source-inline">while</strong> loop that has a condition that is not met, <strong class="source-inline">bash</strong> is not going to run it at all. This has a number of great advantages, since it gives us the flexibility to use our loop as many times as we need without thinking about boundaries, and we can still use <strong class="source-inline">break</strong> when we need to get out of the loop before our condition is met. </p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor238"/>How to do it…</h2>
			<p>A <strong class="source-inline">while</strong> loop looks even simpler than a standard <strong class="source-inline">for</strong> loop; we have a condition that must be met, and a command block that is going to get executed. If the condition is not met, commands will not run and <strong class="source-inline">bash</strong> is going to skip over the block and continue running whatever is after the end of the <strong class="source-inline">done</strong> statement that terminates the block: </p>
			<p class="source-code">while [ condition ]; do commands; done</p>
			<p>Condition, in this case, is the same logical condition that we mentioned earlier. There is also another way of using the <strong class="source-inline">while</strong> loop by having something called <strong class="source-inline">control-command</strong>, a command<a id="_idIndexMarker768"/> that runs and directly provides information for the loop to start. We are going to use this one a lot, since it enables us to, for example, read a file line by line, without<a id="_idIndexMarker769"/> specifying how many lines it has beforehand: </p>
			<p class="source-code">while control-command; do COMMANDS; done</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor239"/>How it works…</h2>
			<p>As usual, we are going to give a few examples. First, we are going to repeat the task we already accomplished using the <strong class="source-inline">for</strong> loops. The idea is to loop until our value reaches <strong class="source-inline">4</strong> and then finish the loop. Note that the value can be a string, not necessarily a number:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">x=0</p>
			<p class="source-code">while [ $x -le 4 ]</p>
			<p class="source-code">do</p>
			<p class="source-code">  echo number is $number</p>
			<p class="source-code">  x=$(( $x + 1 ))</p>
			<p class="source-code">done</p>
			<p>There are a few little things we need to emphasize. The first one is the condition we used. In our <strong class="source-inline">for</strong> loop, we compared whether the value is <strong class="source-inline">4</strong> and then used <strong class="source-inline">break</strong> to get out of our loop. In this case, we cannot do that; if we check whether the value of our <strong class="source-inline">x</strong> variable is <strong class="source-inline">4</strong>, the loop will never run, since the initial value is <strong class="source-inline">1</strong>. </p>
			<p>In a <strong class="source-inline">while</strong> loop, we need to check for the opposite – we want our loop to run until the value becomes <strong class="source-inline">4</strong>, so the condition has to be true in all cases <em class="italic">except</em> when our variable is exactly <strong class="source-inline">4</strong>. </p>
			<p>Thankfully, the very same <strong class="source-inline">while</strong> keyword helps in creating the condition. </p>
			<p>We mentioned that instead of a condition, we can have a command. A typical example that you are going to use often is reading a file. We can do this using a <strong class="source-inline">for</strong> loop, but it would be needlessly complicated. <strong class="source-inline">for</strong> loops need to know the number of iterations before we even start a loop. In order to solve this problem using a <strong class="source-inline">for</strong> loop, we would need to count the lines in a file before we can start looping, and this would be both complicated and slow, since <a id="_idIndexMarker770"/>it requires us to open the file twice – first to count the lines and <a id="_idIndexMarker771"/>then to read them in the loop. </p>
			<p>A much simpler way is to use a <strong class="source-inline">while</strong> loop. We simply run the loop while our command gives us some output – in this case, while it reads from a file. As soon as the command fails, the loop is over:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">FILE=testfile.txt</p>
			<p class="source-code"># read testfile and display it one line at a time</p>
			<p class="source-code">while read line</p>
			<p class="source-code">do</p>
			<p class="source-code">     # just write out the line prefixed by &gt;</p>
			<p class="source-code">     echo "&gt; $line"</p>
			<p class="source-code">done &lt; $FILE</p>
			<p>You will notice that there are a few things we haven't yet seen in the scripts. The first one is the use of the variables. We sort of already did that when we were dealing with the <strong class="source-inline">for</strong> statements, but here you can see both how a variable is declared and how it is used. We'll talk a lot more about this later. Another thing is how we actually read the file. The <strong class="source-inline">read</strong> command has no arguments; it is intended to be used with standard input. Since we know how to redirect inputs and outputs, we are going to just redirect whatever is in the file as the input of the <strong class="source-inline">read</strong> command. This is why we used redirection in the last line of the script. It may look awkward, but it is the way to do it. </p>
			<p>Sometimes, we have a reason to use a loop that never finishes, a so-called infinite loop. It looks counterintuitive, but this kind of loop is extremely common in scripts when we need to run the script over and over again and have no idea how many iterations we need. Sometimes, we may even want our script to run continuously and then use the <strong class="source-inline">break</strong> statement to stop it if<a id="_idIndexMarker772"/> something happens. An infinite <strong class="source-inline">while</strong> loop is <a id="_idIndexMarker773"/>simple; just<a id="_idIndexMarker774"/> use <strong class="source-inline">:</strong> as the condition:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">while :</p>
			<p class="source-code">do</p>
			<p class="source-code">     echo "infinite loops [ hit CTRL+C to stop]"</p>
			<p class="source-code">done</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor240"/>See also</h2>
			<ul>
				<li><a href="https://linuxize.com/post/bash-while-loop/">https://linuxize.com/post/bash-while-loop/</a></li>
				<li><a href="https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html">https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html</a></li>
				<li><a href="https://www.redhat.com/sysadmin/bash-scripting-while-loops">https://www.redhat.com/sysadmin/bash-scripting-while-loops</a></li>
			</ul>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor241"/>The test-if loop</h1>
			<p>When strictly talking about loops, we usually divide them into <strong class="source-inline">for</strong> and <strong class="source-inline">while</strong> loops. There are some other structures that we sometimes call loops, even though they are more structured like a block<a id="_idIndexMarker775"/> of commands. Other names for these could be <strong class="source-inline">decision</strong> loops or <strong class="source-inline">decision</strong> blocks, but<a id="_idIndexMarker776"/> for legacy reasons, they are usually referred to as <strong class="source-inline">test-if</strong> loops, <strong class="source-inline">case</strong> loops, or <strong class="source-inline">logical</strong> loops. </p>
			<p>The primary idea behind this is that any decision-making part of the code actually branches the code into different paths containing blocks of commands. Since branching and decision-making is probably the most important thing you will do in your scripts, we are going to show you some of the most commonly used structures that will find their way, more or less, into any script you make. </p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor242"/>Getting ready</h2>
			<p>For this recipe, the most important thing is to understand that for any conditional branching, or for that matter, any conditions that you put in your code, you will use logical expressions. Logical expressions are, simply put, statements that can be either true or false. </p>
			<p>Take, for example, statements such as the following: </p>
			<ul>
				<li>The <strong class="source-inline">something.txt</strong> file exists.</li>
				<li>The number <strong class="source-inline">2</strong> is greater than the number <strong class="source-inline">0</strong>.</li>
				<li>The <strong class="source-inline">somedir</strong> directory exists and is readable by the user Joe.</li>
				<li>The <strong class="source-inline">unreadable.txt</strong> file is not readable by any user.</li>
			</ul>
			<p>Every statement<a id="_idIndexMarker777"/> here is something that can be either true or false. The most<a id="_idIndexMarker778"/> important thing here is that there are no other logical states that we can define about any of the statements. Another thing is that every statement here refers to a particular object, a file, a directory, or a number, and gives us some attribute or state of that object. </p>
			<p>Having this in mind, we are going to introduce shell testing as a concept and then use it to help us work on our scripts. </p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor243"/>How to do it…</h2>
			<p>We already introduced the concept of the <strong class="source-inline">if</strong> statement using <strong class="source-inline">condition</strong> to branch to one of the <em class="italic">evaluated</em> blocks of code. This condition has to be met, which means it needs to be resolved into a <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> statement. The <strong class="source-inline">if</strong> command is then going to decide which part of the code is going to run. </p>
			<p>This evaluation is also called <em class="italic">testing</em>, and there are two ways of doing it in shell. The <strong class="source-inline">bash</strong> shell has a command called <strong class="source-inline">test</strong> that is sometimes used in scripts. This command takes an <em class="italic">expression</em> and evaluates it to see whether the result is true or false. The result of the command is not printed in the output, but instead, the command assigns its <em class="italic">exit status</em> to the appropriate value. </p>
			<p>Exit status is a value that each command will set after finishing, and we can check it from inside the command line, or from our script. This status is usually used to either see whether there were any errors executing a particular command or to pass some information, such as a logical value of a tested expression. </p>
			<p>In order to test exit status, we can use a simple <strong class="source-inline">echo</strong> command. Let's do a few examples using a simple expression and the <strong class="source-inline">test</strong> command. </p>
			<p>The first example uses the <strong class="source-inline">echo</strong> command to write out what the exit status was of the <strong class="source-inline">test</strong> command. In all the examples, <strong class="source-inline">0</strong> means <strong class="source-inline">true</strong> and <strong class="source-inline">1</strong> means <strong class="source-inline">false</strong>:</p>
			<p class="source-code">demo@cli1:~/$ test "1"="0" ; echo $?</p>
			<p class="source-code">0</p>
			<p>So, how come we got a result that says that <strong class="source-inline">1=0</strong> is true? We made a syntax error (on purpose) to show you probably the most common mistake in scripting. All commands will usually use a very strict syntax, and <em class="italic">test</em> is not an exception. The problem with this particular command is that it will not show an error; instead, it is going to just treat our expression like it is <em class="italic">one single argument</em> and then decide it is <strong class="source-inline">true</strong>. </p>
			<p>We can check this by using a completely nonsensical argument, such as a single word: </p>
			<p class="source-code">demo@cli1:~/$ test whatever ; echo $?</p>
			<p class="source-code">0</p>
			<p>As you can see, the<a id="_idIndexMarker779"/> result is logically true, even if it does not make any real<a id="_idIndexMarker780"/> sense. In reality, <strong class="source-inline">test</strong> requires spaces to understand which part of the expression is the operator and what are the operands. The right way to write our previous example is as follows: </p>
			<p class="source-code">demo@cli1:~/$ test "1" = "0" ; echo $?</p>
			<p class="source-code">1</p>
			<p>This is the result we expected. To check, we are going to try evaluating another expression: </p>
			<p class="source-code">demo@cli1:~/$ test "0" = "0" ; echo $?</p>
			<p class="source-code">0</p>
			<p>So, this one is true. This is completely what we expected. The reason we are using quotation marks here is that we are not actually evaluating numbers; we are comparing <em class="italic">strings</em>. What if we remove the quotation marks? </p>
			<p class="source-code">demo@cli1:~/$ test 0 = 0 ; echo $?</p>
			<p class="source-code">0</p>
			<p>This also works okay; just to check, we are going to retry with something that should be false:</p>
			<p class="source-code">demo@cli1:~/$ test 0 = 1 ; echo $?</p>
			<p class="source-code">1</p>
			<p>The result is also completely what we expected to see. Let's now try something else. We said there is a difference between comparing numbers and strings. A number has the same value regardless of the number of zeroes preceding it: </p>
			<p class="source-code">demo@cli1:~/$ test 01 = 1 ; echo $?</p>
			<p class="source-code">1</p>
			<p>Our command now states<a id="_idIndexMarker781"/> that these two are not equal. Why? Because the <em class="italic">strings</em> are not<a id="_idIndexMarker782"/> equal. <strong class="source-inline">Bash</strong> uses different operators to compare strings and numbers, and since we used the <strong class="source-inline">1</strong> for the strings, these values are not the same. The same goes for using them in quotation marks, just to show how quotes are handled:</p>
			<p class="source-code">demo@cli1:~/$ test "01" = "1" ; echo $?</p>
			<p class="source-code">1 </p>
			<p>The operator that we should have used for integer comparison is <strong class="source-inline">-eq</strong>; it will understand that we are comparing numbers and compare them accordingly: </p>
			<p class="source-code">demo@cli1:~/$ test "01" -eq "1" ; echo $?</p>
			<p class="source-code">0</p>
			<p>Regardless of whether we are using quotes or not, the result should be the same: </p>
			<p class="source-code">demo@cli1:~/$ test 01 -eq 1 ; echo $?</p>
			<p class="source-code">0</p>
			<p>For the last example, we are going to see what happens when we confuse the operators the other way around and try to compare strings using the integer comparison: </p>
			<p class="source-code">demo@cli1:~/scripting$ test 0a -eq  0a ; echo $?</p>
			<p class="source-code">bash: test: 0a: integer expression expected</p>
			<p class="source-code">2</p>
			<p>What does this result mean? First, our test tried to evaluate the condition and realized there is an error in comparison, since it cannot compare a string and an integer or, to be more precise, that an integer cannot contain letters. We got the error in our output, so the command exited with the <strong class="source-inline">2</strong> status, which signifies an error. The result logically makes no sense, so the result is neither <strong class="source-inline">0</strong> nor <strong class="source-inline">1</strong>. </p>
			<p>The next thing we need to do is implement what we learned in actual scripting, but before that, we need to address one more thing. There are two ways to create our tests. One is by explicitly using the <strong class="source-inline">test</strong> command. Another is by using square brackets (<strong class="source-inline">[ ]</strong>). While we are <a id="_idIndexMarker783"/>going to use <strong class="source-inline">test</strong> a lot when we need to run something in the<a id="_idIndexMarker784"/> command line depending on some condition, when using the <strong class="source-inline">if</strong> statement, we are going to use square brackets most of the time, since they are easier to write and look better when glancing over the script. Just to make sure, here is one of the expressions we used, written in a different way. Please pay attention to the spaces inside the brackets; there needs to be a single space between the brackets and the expression we are using: </p>
			<p class="source-code">demo@cli1:~/$ [ 01 -eq 1 ] ; echo $?</p>
			<p class="source-code">0</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor244"/>How it works…</h2>
			<p>We are going to write a small script that is going to test whether a file exists in the directory the script was run from. For that, we need to talk a little about some other operators that we can use. </p>
			<p>If you take a look at the <strong class="source-inline">man</strong> page for the <strong class="source-inline">test</strong> command or at a <strong class="source-inline">bash</strong> manual, you will see that there are many different tests we can do, depending on what we want to check; the most common ones we are going to use are probably the following (taken directly from the man pages for <strong class="source-inline">test(1)</strong>):</p>
			<ul>
				<li>The <strong class="source-inline">-d</strong> file: The file exists and is a directory.</li>
				<li>The <strong class="source-inline">-e</strong> file: The file exists. </li>
				<li>The <strong class="source-inline">-f</strong> file: The file exists and is a regular file.</li>
				<li>The <strong class="source-inline">-r</strong> file: The file exists and read permission is granted.</li>
				<li>The <strong class="source-inline">-s</strong> file: The file exists and has a size greater than zero.</li>
				<li>The <strong class="source-inline">-w</strong> file: The file exists and write permission is granted.</li>
				<li>The <strong class="source-inline">-x</strong> file: The file exists and execute (or search) permission is granted.</li>
			</ul>
			<p>Let's create a script using this: </p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># testing if a file exists</p>
			<p class="source-code">if [ -f testfile.txt ]</p>
			<p class="source-code">      then</p>
			<p class="source-code">           echo testfile.txt exists in the current directory</p>
			<p class="source-code">      else </p>
			<p class="source-code">           echo File does not exist in the current directory! </p>
			<p class="source-code">fi</p>
			<p>Probably the<a id="_idIndexMarker785"/> most important thing to learn here is the structure and the use<a id="_idIndexMarker786"/> of the <strong class="source-inline">else</strong> statement. There are two blocks or <em class="italic">parts</em> of code we define in an <strong class="source-inline">if</strong> statement – one is called <strong class="source-inline">then</strong> and the other <strong class="source-inline">else</strong>. They do as their names suggest; if the condition we used in the statement evaluates as true, then the <strong class="source-inline">then</strong> code block is going to get executed. If the condition is not met, then the <strong class="source-inline">else</strong> block will be run. These blocks are mutually exclusive; only one of them is going to get run. </p>
			<p>Now, we are going to deal with a topic that will sometimes confuse you. We already mentioned that a script has a context it is running in. Among other things, there are two things you need to know every time your script is running – where it was run from and which user ran the script. </p>
			<p>These two pieces of information are crucial, since they define how we are going to reference the files we need and what permissions we will have from inside of the script. </p>
			<p>Our next task is going to be to create a script that will show us how to deal with all of this. What we are going to do is test whether the script can read and write the <strong class="source-inline">root</strong> directory and whether the directory even exists. The reference we are going to make to this directory is going<a id="_idIndexMarker787"/> to be relative, so we are going to presume that our script is<a id="_idIndexMarker788"/> being run from the <strong class="source-inline">/</strong> directory, which is usually false. Then, we are going to try and run the script in different directories and under different users, comparing the results:</p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># testing permissions and paths </p>
			<p class="source-code">if [ -d root ]</p>
			<p class="source-code">     then</p>
			<p class="source-code">           echo root directory exists!</p>
			<p class="source-code">     else </p>
			<p class="source-code">           echo root directory does NOT exist! </p>
			<p class="source-code">fi</p>
			<p class="source-code">if [ -r root ]</p>
			<p class="source-code">        then</p>
			<p class="source-code">                echo Script can read from the directory!</p>
			<p class="source-code">        else</p>
			<p class="source-code">                echo Script can NOT read from the directory!    </p>
			<p class="source-code">fi</p>
			<p class="source-code">if [ -w root ]</p>
			<p class="source-code">        then</p>
			<p class="source-code">                echo Script can write to the directory!</p>
			<p class="source-code">        else</p>
			<p class="source-code">                echo Script can not write to the directory!    </p>
			<p class="source-code">fi</p>
			<p>As you can see, we are basically testing for three different conditions. First, we are trying to see whether the directory exists at all and, after that, whether the script has read and write permissions.</p>
			<p>First, we are going to<a id="_idIndexMarker789"/> try and run this as the current user in the directory that the script<a id="_idIndexMarker790"/> is created in. Then, we are going to go to the <strong class="source-inline">/</strong> directory and run it from there:</p>
			<p class="source-code">demo@cli1:~/scripting$ bash testif2.sh </p>
			<p class="source-code">root directory does NOT exists!</p>
			<p class="source-code">Script can NOT read from the directory!</p>
			<p class="source-code">Script can not write to the directory!</p>
			<p class="source-code">demo@cli1:~/scripting$ cd /</p>
			<p class="source-code">demo@cli1:/$ bash home/demo/scripting/testif2.sh </p>
			<p class="source-code">root directory exists!</p>
			<p class="source-code">Script can NOT read from the directory!</p>
			<p class="source-code">Script can not write to the directory!</p>
			<p>What does all this tell us? Our first run was unable to find the directory since we were using a relative path in the script. This makes the directory that the script is run from important. </p>
			<p>Another thing we learned is how our checks work. We can independently check whether a file or directory exists, and different permissions that the current user has on a particular file. We are going to show that by running the script under a <strong class="source-inline">root</strong> user using the <strong class="source-inline">sudo</strong> command: </p>
			<p class="source-code">demo@cli1:~/scripting$ cd /</p>
			<p class="source-code">demo@cli1:/$ sudo bash home/demo/scripting/testif2.sh </p>
			<p class="source-code">[sudo] password for demo: </p>
			<p class="source-code">root directory exists!</p>
			<p class="source-code">Script can read from the directory!</p>
			<p class="source-code">Script can write to the directory!</p>
			<p>As soon as we change the context, we can see that the same script is not only able to see that the directory is there but also has full rights to use it. </p>
			<p>Now, we are going to completely change our script to demonstrate how we can embed our checks into one another. Our script will once again test whether the <strong class="source-inline">root</strong> directory is in the current directory, but this time, the script is going to check whether it has read and write rights only if the <a id="_idIndexMarker791"/>directory exists. After all, it makes no sense to see whether you <a id="_idIndexMarker792"/>can read a directory that isn't there: </p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># testing permissions and paths </p>
			<p class="source-code">if [ -d root ]</p>
			<p class="source-code">        then</p>
			<p class="source-code">                echo root directory exists!</p>
			<p class="source-code">                if [ -r root ]</p>
			<p class="source-code">                      then</p>
			<p class="source-code">                        echo Script can read from the \</p>
			<p class="source-code">directory!</p>
			<p class="source-code">                      else</p>
			<p class="source-code">                        echo Script can NOT read from the \</p>
			<p class="source-code">directory!</p>
			<p class="source-code">                fi</p>
			<p class="source-code">                if [ -w root ]</p>
			<p class="source-code">                      then</p>
			<p class="source-code">                        echo Script can write to the directory!</p>
			<p class="source-code">                      else</p>
			<p class="source-code">                        echo Script can not write to the \</p>
			<p class="source-code">directory!</p>
			<p class="source-code">                fi</p>
			<p class="source-code">        else</p>
			<p class="source-code">                echo root directory does NOT exists!</p>
			<p class="source-code">fi</p>
			<p>Now, we are <a id="_idIndexMarker793"/>going to run it in two directories to see if our script works; the <a id="_idIndexMarker794"/>main difference should be the output. Also, when you have a nested structure such as this one, always try to keep your indentation consistent. This means that you always should try to keep commands in the same block indented in such a way that it is immediately obvious where each command belongs: </p>
			<p class="source-code">demo@cli1:~/scripting$ bash testif3.sh</p>
			<p class="source-code">root directory does NOT exists!</p>
			<p class="source-code">demo@cli1:~/scripting$ cd /</p>
			<p class="source-code">demo@cli1:/$ bash home/demo/scripting/testif3.sh </p>
			<p class="source-code">root directory exists!</p>
			<p class="source-code">Script can NOT read from the directory!</p>
			<p class="source-code">Script can not write to the directory!</p>
			<p>We have now seen what can be done with different tests and conditions in <strong class="source-inline">bash</strong>. The next topic is similar<a id="_idIndexMarker795"/> to this one – the <strong class="source-inline">case</strong> statement or <strong class="source-inline">case</strong> loop. </p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor245"/>See also</h2>
			<ul>
				<li><a href="https://www.thegeekdiary.com/bash-if-loop-examples-if-then-fi-if-then-elif-fi-if-then-else-fi/">https://www.thegeekdiary.com/bash-if-loop-examples-if-then-fi-if-then-elif-fi-if-then-else-fi/</a></li>
				<li><a href="https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html">https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html</a></li>
				<li><a href="https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php">https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php</a></li>
			</ul>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor246"/>The case loop</h1>
			<p>Up until now, we have dealt<a id="_idIndexMarker796"/> with basic commands that allow us to do things we need when<a id="_idIndexMarker797"/> trying to write a script, such as looping, branching, breaking, and continuing program flow. A <strong class="source-inline">case</strong> loop, the topic of this recipe, is not strictly necessary, since the logic behind it can be created using a multi-nested group of individual <strong class="source-inline">if</strong> commands. The reason we are even mentioning this is simply because <strong class="source-inline">case</strong> is something that we are going to use a lot in our scripts, and the alternative of using <strong class="source-inline">if</strong> statements is both difficult to write and read, and complicated to debug. </p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor247"/>Getting ready</h2>
			<p>One could simply say that a <strong class="source-inline">case</strong> loop or <strong class="source-inline">case</strong> statement is just another way of writing multiple <strong class="source-inline">if then else</strong> tests. <strong class="source-inline">Case</strong> is not something that can be used in place of a normal <strong class="source-inline">if</strong> statement, but there is a common situation in which a <strong class="source-inline">case</strong> statement makes our lives a lot less complicated and our scripts much easier to debug and understand. But before we go into that, we need to understand a little bit about variables and branching. Once we start using <strong class="source-inline">if</strong> statements, we are quickly going to realize that they can be used, more or less, in two distinct ways. The first is the one everyone thinks about when thinking about an <strong class="source-inline">if</strong> statement – we have a variable and we compare it to another variable or a value. This is common and often done in a script. Something a little less common is when we have to compare a variable to a list of values. This happens most often when we need to sort things into groups or run a block of code depending on the user input. </p>
			<p>User input is probably the most popular reason a <strong class="source-inline">case</strong> statement is used. In scripts, this is often used once we start using arguments. Our scripts will have to reconfigure things based on what arguments the user chose when running the script. We will take a look at that a little bit later when we start dealing with passing arguments to a script, which will exclusively use <strong class="source-inline">case</strong> statements to run appropriate commands. </p>
			<p>User menus are another thing that is solved by using <strong class="source-inline">case</strong> statements; to generalize, each time a user has a multiple-choice answer to a question, this is going to get handled by a <strong class="source-inline">case</strong> statement. </p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor248"/>How to do it…</h2>
			<p>The best way to explain a <strong class="source-inline">case</strong> statement is by creating an example. Let's say that a user starts a script, and they have four choices of what they want the script to do. Right now, we are not prepared to deal with how they will input their choice, so let's just presume that there is a variable called <strong class="source-inline">$1</strong> that contains one of these values – <strong class="source-inline">copy</strong>, <strong class="source-inline">delete</strong>, <strong class="source-inline">move</strong>, and <strong class="source-inline">help</strong>. Our script will have to run the appropriate part of the code based on user input. In fact, this<a id="_idIndexMarker798"/> is the way arguments are handled, but we will talk about that<a id="_idIndexMarker799"/> later. </p>
			<p>Our first version is going to use the <strong class="source-inline">if – then – elif</strong> loop: </p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># $1 contains either copy, delete, move or help</p>
			<p class="source-code">if [ $1 = "copy" ]</p>
			<p class="source-code">        then</p>
			<p class="source-code">                echo you chose to copy!</p>
			<p class="source-code">        elif  [ $1 = "delete" ]</p>
			<p class="source-code">                then</p>
			<p class="source-code">                        echo you chose to delete!</p>
			<p class="source-code">        elif  [ $1 = "move" ]</p>
			<p class="source-code">                then</p>
			<p class="source-code">                        echo you chose to move!  </p>
			<p class="source-code">        elif  [ $1 = "help" ]</p>
			<p class="source-code">                then</p>
			<p class="source-code">                        echo you chose help!  </p>
			<p class="source-code">else    </p>
			<p class="source-code">                echo please make a choice!</p>
			<p class="source-code">fi</p>
			<p>This works, but it has two problems. One is that it throws errors if there are no arguments given, since this means we are comparing a value to a variable without a value. The other problem is that this is complicated to read, even if we pay extra attention to using the right indentation. We are going to redo this using a <strong class="source-inline">case</strong> statement: </p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># $1 contains either copy, delete, move or help</p>
			<p class="source-code">case $1 in </p>
			<p class="source-code">      copy)      echo you chose to copy! ;;</p>
			<p class="source-code">      delete) echo you chose to delete! ;;</p>
			<p class="source-code">      move)   echo you chose to move! ;; </p>
			<p class="source-code">      help)   echo you chose help!  ;;</p>
			<p class="source-code">      *)    echo please make a choice!</p>
			<p class="source-code">esac</p>
			<p>The first thing you will <a id="_idIndexMarker800"/>notice is how simple and clean this looks. As well as being easier <a id="_idIndexMarker801"/>to write, the code is much easier to read and debug if we need to. There are just two simple things to pay attention to – the end of the statement block is defined as <strong class="source-inline">esac</strong>, which is <strong class="source-inline">case</strong> spelled backward, similar to how the <strong class="source-inline">if</strong> statement is terminated by <strong class="source-inline">fi</strong>. Another thing is that you have to use <strong class="source-inline">;;</strong> to terminate a line, since that's what's used to delimit choices in the <strong class="source-inline">case</strong> loop. </p>
			<p>When matching values, you can also use limited regular expressions; this is the reason that the <strong class="source-inline">*</strong> <strong class="source-inline">glob</strong> is used to symbolize <em class="italic">zero or more characters</em>. </p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor249"/>How it works…</h2>
			<p>Now that we know a lot more about scripting, we are going to do a simple script that searches for a string in a directory and lets us know what happened. We don't care about where the text is; we just want to know whether there is text that we used somewhere in the directory we ran our script in. </p>
			<p>The things we need to know before we even start are as follows: </p>
			<ul>
				<li><strong class="source-inline">$1</strong> is going to hold a string value that is going to be the text we are searching for.</li>
				<li><strong class="source-inline">$?</strong> holds the <strong class="source-inline">exit</strong> value of a command that was just completed in the script.</li>
				<li><strong class="source-inline">grep</strong> as a command returns either <strong class="source-inline">0</strong> if it found something, <strong class="source-inline">1</strong> if it didn't, or <strong class="source-inline">2</strong> if there was an error.</li>
				<li>There is a special device called <strong class="source-inline">/dev/null</strong> that can be used if we need to silence some output.</li>
			</ul>
			<p>Thanks to<a id="_idIndexMarker802"/> the <strong class="source-inline">case</strong> statement, this is <a id="_idIndexMarker803"/>a trivial task: </p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># $1 contains string we are searching for</p>
			<p class="source-code">grep $1 * &amp;&gt; /dev/null</p>
			<p class="source-code">case $? In</p>
			<p class="source-code">      0)    echo Something was found! ;;</p>
			<p class="source-code">      1)       echo Nothing was found! ;;</p>
			<p class="source-code">      2)        echo grep reported an error! ;;</p>
			<p class="source-code">esac</p>
			<p>For the last script, we are going to use <strong class="source-inline">case</strong> to combine another script from this chapter that was testing a directory and put it into a larger script. We are going to create a script that will be given a command and a filename as arguments. The command is going to be either <strong class="source-inline">check</strong>, <strong class="source-inline">copy</strong>, <strong class="source-inline">delete</strong>, or <strong class="source-inline">help</strong>. If we specify either <strong class="source-inline">copy</strong> or <strong class="source-inline">delete</strong>, the script will check whether it has the permissions to do the task and then the <strong class="source-inline">echo</strong> command that it would normally call. </p>
			<p>If we specify <strong class="source-inline">check</strong>, the script is going to check for permissions on a given file:</p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># $1 contains either check, copy, delete or help</p>
			<p class="source-code">#script expects two arguments: a command and a file name</p>
			<p class="source-code">case $1 in </p>
			<p class="source-code">      copy) </p>
			<p class="source-code">       echo you chose to copy! </p>
			<p class="source-code">       if [ -r $2 ]</p>
			<p class="source-code">      then</p>
			<p class="source-code">      echo Script can read the file use cp $2 ~ to copy to \</p>
			<p class="source-code">your home Directory!</p>
			<p class="source-code">      else</p>
			<p class="source-code">      echo Script can NOT read the file!    </p>
			<p class="source-code">      fi</p>
			<p class="source-code">          ;;</p>
			<p class="source-code">      delete) </p>
			<p class="source-code">       echo you chose to delete! </p>
			<p class="source-code">           if [ -w $2 ]</p>
			<p class="source-code">             then</p>
			<p class="source-code">             echo Script can write the file, use rm $2 to \</p>
			<p class="source-code">remove it!</p>
			<p class="source-code">             else</p>
			<p class="source-code">             echo Script can NOT read the file!    </p>
			<p class="source-code">           fi</p>
			<p class="source-code">           ;;</p>
			<p class="source-code">      check)</p>
			<p class="source-code">       if [ -f $2 ]</p>
			<p class="source-code">              then</p>
			<p class="source-code">                 echo File $2 exists!</p>
			<p class="source-code">                  if [ -r $2 ]</p>
			<p class="source-code">                        then</p>
			<p class="source-code">                                echo Script can read $2!</p>
			<p class="source-code">                           else</p>
			<p class="source-code">                                echo Script can NOT read $2!</p>
			<p class="source-code">                      fi</p>
			<p class="source-code">                      if [ -w $2 ]</p>
			<p class="source-code">                          then</p>
			<p class="source-code">                                 echo Script can write to $2!</p>
			<p class="source-code">                          else</p>
			<p class="source-code">                                 echo Script can not write to $2!</p>
			<p class="source-code">                      fi</p>
			<p class="source-code">            else</p>
			<p class="source-code">                      echo File $2 does NOT exist!</p>
			<p class="source-code">           fi  ;;</p>
			<p class="source-code">      help)         </p>
			<p class="source-code">      echo you chose help, please choose from check, copy or \</p>
			<p class="source-code">delete!  ;;</p>
			<p class="source-code">      *)   echo please make a choice, available are copy \</p>
			<p class="source-code">check delete and help!</p>
			<p class="source-code">esac</p>
			<p>What we<a id="_idIndexMarker804"/> have done here is combine everything that we have done so far into a script <a id="_idIndexMarker805"/>that actually does something. The only thing we haven't mentioned before is <strong class="source-inline">$2</strong> as the second argument in the script. In this case, we use it to get the filename we need to run the commands. This is how it all looks when run from the command line: </p>
			<p class="source-code">demo@cli1:~/scripting$ bash testcas4.sh check testfile.txt</p>
			<p class="source-code">File testfile.txt exists!</p>
			<p class="source-code">Script can read testfile.txt!</p>
			<p class="source-code">Script can write to testfile.txt!</p>
			<p class="source-code">demo@cli1:~/scripting$ bash testcas4.sh check testfile.tx</p>
			<p class="source-code">File testfile.tx does NOT exist!</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor250"/>See also</h2>
			<p>When it comes to using <strong class="source-inline">case</strong> in your scripts, you will soon realize that a lot of examples are copied and pasted<a id="_idIndexMarker806"/> between sites. The following links are two good sources: </p>
			<ul>
				<li>https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html</li>
				<li>https://www.shellhacks.com/case-statement-bash-example/</li>
			</ul>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor251"/>Logical looping with and, or, and not </h1>
			<p>There is no way to escape logic when it comes to computers. We already dealt with some things you can do with evaluating conditions, but there is a lot more that can be done in <strong class="source-inline">bash</strong>. </p>
			<p>In this recipe, we are going to deal with different logical operators that help us with scripting in general. First, we are going to deal with what can be done on the command line, and then we are going to <a id="_idIndexMarker807"/>use that in scripts. </p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor252"/>Getting ready</h2>
			<p>First, let's quickly talk about logic operators. So far, we mentioned expressions that have a value of true and false. We also mentioned a lot of different expressions that are built into <strong class="source-inline">bash</strong>, since they provide functionality crucial for everyday work on the command line. Now is the time to talk about<a id="_idIndexMarker808"/> logical operators that help us combine expressions and create complex solutions. We are going to start with the usual operators: </p>
			<ul>
				<li><strong class="source-inline">&amp;&amp;</strong> (the logical <strong class="source-inline">AND</strong>)</li>
				<li><strong class="source-inline">||</strong> (the logical <strong class="source-inline">OR</strong>)</li>
			</ul>
			<p>The interesting thing about these is that they can be used directly on the command line. The command line in <strong class="source-inline">bash</strong> basically has four ways of executing commands. One is to run them one by one on each line. This is the usual way we work in interactive mode. </p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor253"/>How to do it…</h2>
			<p>Sometimes, we need (or want) to run multiple commands on one line. This is mostly done by using <strong class="source-inline">;</strong> to separate commands, such as the following: </p>
			<p class="source-code">demo@cli1:~/scripting$ pwd ; ls</p>
			<p class="source-code">/home/demo/scripting</p>
			<p class="source-code">backupexample.sh  errorfile  forbreak.sh  forcontinue.sh  forloop1.sh  helloworld.sh  helloworldv1.sh  outputfile  readfile.sh  testcas1.sh</p>
			<p>As we can see, it is exactly the same as if we ran each command by itself, but shell just executes them in a row. We already used this when we tested different expressions using the <strong class="source-inline">test</strong> command. We needed to check what the exit status was of that command, so we always used <strong class="source-inline">echo</strong> directly after running the test. </p>
			<p>Sometimes, however, we can use a little logic to create shortcuts. This is where logical operators come into play. The remaining two ways to run multiple commands use them to not only run the command but also to run them conditionally. </p>
			<p>Imagine we want to perform a command after we make some kind of test – for example, we want to open a file but only if the file actually exists. We could write an <strong class="source-inline">if</strong> statement here, but it would make absolutely <a id="_idIndexMarker809"/>no sense to complicate things like that. This is where we can use the <a id="_idIndexMarker810"/>logical <strong class="source-inline">AND</strong>:</p>
			<p class="source-code">demo@cli1:~/scripting$ [ -f outputfile ] &amp;&amp; cat outputfile </p>
			<p class="source-code">Hello World!</p>
			<p class="source-code">demo@cli1:~/scripting$ [ -f idonotexist ] &amp;&amp; cat outputfile</p>
			<p class="source-code">demo@cli1:~/scripting$</p>
			<p>In general, using <strong class="source-inline">&amp;&amp;</strong> between commands tells <strong class="source-inline">bash</strong> to run the command on the right only if the command on the left succeeded. In our example, this means that we have a file named <strong class="source-inline">output</strong> in our directory. On the left, we are doing a quick test if this file exists. Once this is successful, we run <strong class="source-inline">cat</strong> to output the file contents. </p>
			<p>In the second example, we intentionally used the wrong filename, and the <strong class="source-inline">cat</strong> command hasn't been run, since the file is not there. </p>
			<p>Another logical operand<a id="_idIndexMarker811"/> we can use is the logical <strong class="source-inline">OR</strong>. The operator to use is <strong class="source-inline">||</strong> in the<a id="_idIndexMarker812"/> same way as before. This operator instructs <strong class="source-inline">bash</strong> to run the command on the right only if the command on the left failed: </p>
			<p class="source-code">demo@cli1:~/scripting$ [ -f idonotexist ] || cat outputfile </p>
			<p class="source-code">Hello World!</p>
			<p class="source-code">demo@cli1:~/scripting$ [ -f outputfile ] || cat outputfile</p>
			<p class="source-code">demo@cli1:~/scripting$</p>
			<p>This is the exact opposite of the previous example. Our <strong class="source-inline">cat</strong> command ran only when the test failed. A structure such as this is sometimes used in scripts to create fail-safes or to quickly run things such as updates. </p>
			<p>What is nice is that this enables us to immediately do something, depending on the test: </p>
			<p class="source-code">demo@cli1:~/$[ -f outputfile ] &amp;&amp; echo exists || echo not \</p>
			<p class="source-code">exists</p>
			<p class="source-code">Exists</p>
			<p class="source-code">demo@cli1:~/$[ -f idonotexist ] &amp;&amp; echo exists || echo exists \</p>
			<p class="source-code">not</p>
			<p class="source-code">exists not</p>
			<p>These operators also exist in test expressions, allowing us to create different conditions that would otherwise require multiple <strong class="source-inline">if</strong> statements. </p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor254"/>How it works…</h2>
			<p>Testing a condition is<a id="_idIndexMarker813"/> hopefully now completely familiar to you. We are going to try and combine a few of them to explain what different operators can do. For example, if we want to quickly check whether a file exists and is readable, we can do it by either testing whether it is readable or explicitly combining those two things into one statement: </p>
			<p class="source-code">demo@cli1:~/$ [ -f outputfile ] &amp;&amp;  [ -r outputfile ] ; echo \</p>
			<p class="source-code">$?</p>
			<p class="source-code">0</p>
			<p>These tests are going to be most useful when dealing with strings and numbers. For instance, we can try and find whether a number is within an interval in a script, as follows: </p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># testing if a number is in an interval</p>
			<p class="source-code">if [ $1 -gt 1 ]</p>
			<p class="source-code">      then</p>
			<p class="source-code">          if [ $1 -lt 10 ] </p>
			<p class="source-code">                 then </p>
			<p class="source-code">                  echo Number is between 1 and 10</p>
			<p class="source-code">          else </p>
			<p class="source-code">                echo Number is not between 1 and 10</p>
			<p class="source-code">                fi</p>
			<p class="source-code">     else </p>
			<p class="source-code">            echo number is not between 1 and 10! </p>
			<p class="source-code">fi</p>
			<p>We are going to run this <a id="_idIndexMarker814"/>script, but before we even do that, we can see that it looks complicated, more than it should be. It is not just the fact that we have to use two <strong class="source-inline">if</strong> statements to make sure that we handle both parts of the outside interval; this script demands a lot of explanations, even though it is only a couple of lines long. Does it work? Yes, as we can see here:</p>
			<p class="source-code">demo@cli1:~/scripting$ bash testmultiple.sh 42</p>
			<p class="source-code">Number is not between 1 and 10</p>
			<p class="source-code">demo@cli1:~/scripting$ bash testmultiple.sh 2</p>
			<p class="source-code">Number is between 1 and 10</p>
			<p class="source-code">demo@cli1:~/scripting$ bash testmultiple.sh -1</p>
			<p class="source-code">number is not between 1 and 10!</p>
			<p>Now, we are going to use logical operators to optimize our script:</p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># testing if a number is in an interval</p>
			<p class="source-code">if [[ $1 -gt 1  &amp;&amp;  $1 -lt 10 ]]</p>
			<p class="source-code">        then</p>
			<p class="source-code">                        echo Number is between 1 and 10</p>
			<p class="source-code">        else</p>
			<p class="source-code">                        echo Number is not between 1 and 10</p>
			<p class="source-code">fi</p>
			<p>We are using double <a id="_idIndexMarker815"/>brackets here because we have to. There are multiple ways to achieve the same goal, and there are some older versions of the syntax, but it is best practice to use double brackets when dealing with multiple expressions.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor255"/>See also</h2>
			<p>Dealing with<a id="_idIndexMarker816"/> logical operators is, in part, complicated because there are so many of them. You can find much more information here: </p>
			<ul>
				<li><a href="https://linuxhint.com/bash_operator_examples/#o23">https://linuxhint.com/bash_operator_examples/#o23</a></li>
				<li><a href="https://opensource.com/article/19/10/programming-bash-logical-operators-shell-expansions">https://opensource.com/article/19/10/programming-bash-logical-operators-shell-expansions</a></li>
			</ul>
		</div>
	</div></body></html>