<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div id="_idContainer043" class="calibre2">
			<h1 id="_idParaDest-350" class="calibre5"><em class="italic"><a id="_idTextAnchor354" class="pcalibre calibre6 pcalibre1"/>Chapter 14</em>: Dealing with New Applications</h1>
			<p class="calibre3">New applications are often not yet supported through an application-specific SELinux policy, as most application projects do not develop the SELinux policies themselves, but rely on the community in general (or Linux distributions more specifically) to create and maintain them. Some Linux distributions have implemented fallbacks to allow these applications to run, even though they might not be isolated properly. Administrators might not like the sound of having untrusted new applications running without any SELinux enforcements active though. </p>
			<p class="calibre3">Hence, this chapter covers how administrators can run new applications in a number of isolated environments, ranging from the (often default) unprotected domains, to sandbox systems, and eventually by reusing existing SELinux domains without having to develop completely new ones.</p>
			<p class="calibre3">In this chapter, we're going to cover the following main topics:</p>
			<ul class="calibre8">
				<li class="calibre9">Running applications without restrictions</li>
				<li class="calibre9">Using sandboxed applications</li>
				<li class="calibre9">Assigning common policies to new applications</li>
				<li class="calibre9">Extending generated policies</li>
			</ul>
			<h1 id="_idParaDest-351" class="calibre5"><a id="_idTextAnchor355" class="pcalibre calibre6 pcalibre1"/>Technical requirements</h1>
			<p class="calibre3">Check out the following video to see the Code in Action: <a href="https://bit.ly/3dGG5Bu" class="pcalibre calibre6 pcalibre1">https://bit.ly/3dGG5Bu</a></p>
			<h1 id="_idParaDest-352" class="calibre5"><a id="_idTextAnchor356" class="pcalibre calibre6 pcalibre1"/>Running applications without restrictions</h1>
			<p class="calibre3">The default behavior in many Linux<a id="_idIndexMarker901" class="pcalibre calibre6 pcalibre1"/> distributions is to run new applications through unconfined domains. These are specially crafted domains that, while still being controlled by SELinux, are designed to have very, very broad permissions granted. You can compare such unconfined domains with a firewall that allows any possible flow: while the firewall is running, it is hardly doing any enforcement.</p>
			<p class="calibre3">There is, however, another approach possible as well, namely, running an application as a permissive domain. Unlike unconfined domains, permissive domains are not enforced through SELinux: everything the <a id="_idIndexMarker902" class="pcalibre calibre6 pcalibre1"/>domain does is allowed, even though SELinux might log every violation. We briefly touched upon permissive domains in <a href="B16276_03_Final_VK.xhtml#_idTextAnchor071" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding SELinux Decisions and Logging</em>.</p>
			<p class="calibre3">Let's first look at unconfined domains and how administrators can modify system configuration to apply unconfined domains to other applications, or remove applications from being unconfined.</p>
			<h2 id="_idParaDest-353" class="calibre10"><a id="_idTextAnchor357" class="pcalibre calibre6 pcalibre1"/>Understanding how unconfined domains work</h2>
			<p class="calibre3">An <strong class="bold">unconfined domain</strong> is an SELinux<a id="_idIndexMarker903" class="pcalibre calibre6 pcalibre1"/> domain that has broad permissions, restricting only a very small amount of actions that a domain can do. Unconfined domains are not really a concept that SELinux, as technology, supports. Instead, it is used by SELinux policy developers who created a set of permissions they consider as being unconfined.</p>
			<p class="calibre3">End users on many Linux distributions will have noticed that their own context is <strong class="source-inline">unconfined_t</strong>. While this is indeed a reference to being an unconfined domain, there are more domains that are unconfined than <strong class="source-inline">unconfined_t</strong>.</p>
			<p class="calibre3">SELinux policy developers have<a id="_idIndexMarker904" class="pcalibre calibre6 pcalibre1"/> aggregated most of the permissions related to unconfined domains either in the domains themselves (as is the case for the reference policy) or in SELinux attributes, such as <strong class="source-inline">unconfined_domain_type</strong> and <strong class="source-inline">unconfined_user_type</strong> (as is the case for CentOS and related Linux distributions). In the case of attributes, these attributes are then assigned to one or more domains to effectively make them unconfined in nature:</p>
			<p class="source-code">$ seinfo -a | grep unconfined</p>
			<p class="source-code">$ seinfo -a unconfined_domain_type -x</p>
			<p class="calibre3">Once a process is running as an unconfined domain, that does not imply that every action of that domain remains unconfined. When an unconfined domain executes a process that has a proper SELinux policy assigned, it is possible for this execution to still invoke a domain transition, effectively running the executed command in a (possibly confined) SELinux domain.</p>
			<p class="calibre3">As the decision whether a domain transition is allowed or not falls within the SELinux policy, it is recommended that administrators query which domain transitions are allowed and which ones aren't. We saw how to <a id="_idIndexMarker905" class="pcalibre calibre6 pcalibre1"/>analyze domain transitions in <a href="B16276_13_Final_VK.xhtml#_idTextAnchor330" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 13</em></a>, <em class="italic">Analyzing Policy Behavior</em>. Given that we are mostly interested in single-step analysis, we can use the <strong class="source-inline">sesearch</strong> utility to have a quick overview of supported domain transitions:</p>
			<p class="source-code">$ sesearch -A -s unconfined_service_t -c process -p transition</p>
			<p class="source-code">allow unconfined_service_t chronyc_t:process transition;</p>
			<p class="source-code">allow unconfined_service_t rpm_script_t:process transition;</p>
			<p class="source-code">allow unconfined_service_t unconfined_service_t:process { transition ...};</p>
			<p class="source-code">allow unconfined_service_t virt_domain:process { transition ...};</p>
			<p class="calibre3">We can see the (many) permissions related to an unconfined domain by either checking them for a single domain, or for the attribute that represents unconfined domains directly:</p>
			<p class="source-code">$ sesearch -A -s unconfined_domain_type -ds</p>
			<p class="calibre3">Using unconfined domains is preferred over making domains permissive, so let's see how we can mark a new application to run as an unconfined domain.</p>
			<h2 id="_idParaDest-354" class="calibre10"><a id="_idTextAnchor358" class="pcalibre calibre6 pcalibre1"/>Making new applications run as an unconfined domain</h2>
			<p class="calibre3">When applications are executed, there are<a id="_idIndexMarker906" class="pcalibre calibre6 pcalibre1"/> a number of checks that need to pass before this results in a domain transition:</p>
			<ul class="calibre8">
				<li class="calibre9">The source SELinux domain must be able to execute the application (implying <strong class="source-inline">execute</strong> rights on the SELinux type associated with the application's binary or script).</li>
				<li class="calibre9">The source SELinux domain must be able to transition to the target domain.</li>
				<li class="calibre9">The target domain must have its application binary or script labeled with an SELinux type that is marked as an entrypoint for that domain.</li>
				<li class="calibre9">The target domain must be allowed for the SELinux role that the source domain is running with (or a role transition has to be allowed, but that is a corner case).</li>
			</ul>
			<p class="calibre3">All these checks are related to the SELinux policy and the labels. It comes as no surprise then that, in order for us to enable applications to run in an unconfined domain, we need to associate the right labels.</p>
			<p class="calibre3">Let's consider two<a id="_idIndexMarker907" class="pcalibre calibre6 pcalibre1"/> examples in the following sections, one being a user-triggered application, while the other is a daemonized service.</p>
			<h3 class="calibre12">Running applications in an explicit unconfined domain</h3>
			<p class="calibre3">For applications that <a id="_idIndexMarker908" class="pcalibre calibre6 pcalibre1"/>users execute, let's take the example of Jailkit, which we introduced in <a href="B16276_07_Final_VK.xhtml#_idTextAnchor216" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 7</em></a>, <em class="italic">Configuring Application-Specific SELinux Controls</em>. By default, this application is not associated with any domain, so it<a id="_idIndexMarker909" class="pcalibre calibre6 pcalibre1"/> runs within the same domain as the parent process. If we are logged in to the system through the <strong class="source-inline">unconfined_u</strong> user (in the <strong class="source-inline">unconfined_t</strong> SELinux domain), then we have nothing to do. But suppose that our staff user is confined, yet we want to have the command run in the <strong class="source-inline">unconfined_t</strong> domain.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This is used as an example that shows how to have applications run in a target domain – in our case, an unconfined domain. Allowing confined users to run unconfined applications always has a risk associated with it, because they might use this to break out of their confinement. Make sure that this is only done for applications or users where you have confidence that they will not breach security.</p>
			<p class="calibre3">To allow the application to run in the <strong class="source-inline">unconfined_t</strong> domain, we will use <strong class="source-inline">sudo</strong> and its SELinux support. While we could also extend the SELinux policy to allow it transparently, this is not recommended. Updating the SELinux policy to allow confined users to run unconfined commands implies that several principles listed in the policy are overturned. You would need to allow the confined user to switch to the <strong class="source-inline">unconfined_r</strong> role (which is often not allowed for security reasons) transparently, for instance. It would require significant analysis to make sure that it cannot be used to break out of the confined role.</p>
			<p class="calibre3">Using <strong class="source-inline">sudo</strong> allows us to limit the <a id="_idIndexMarker910" class="pcalibre calibre6 pcalibre1"/>methods through which such more privileged commands are executed. SELinux-wise, the appropriate controls are put on the <strong class="source-inline">staff_sudo_t</strong> domain, for instance, which is only assigned when executing the <strong class="source-inline">sudo</strong> command, rather than the <strong class="source-inline">staff_t</strong> domain, which is where most of the user's interactions are executed.</p>
			<p class="calibre3">Let's allow the <strong class="source-inline">lisa</strong> user to run the <strong class="source-inline">jk_init</strong> command as an unconfined process:</p>
			<ol class="calibre18">
				<li class="calibre9">First, check whether the <a id="_idIndexMarker911" class="pcalibre calibre6 pcalibre1"/>SELinux user for which we want to execute the command is allowed to do anything with the <strong class="source-inline">unconfined_r</strong> SELinux role (and if not, add the role to the SELinux user configuration):<p class="source-code"><strong class="bold"># semanage user -l</strong></p><p class="calibre3">Allowing a role does not imply that the user domain automatically switches role when needed though, but rather that it is an allowed role for the user.</p></li>
				<li class="calibre9">Next, update the <strong class="source-inline">/etc/sudoers</strong> file to include a transition when executing the following command:<p class="source-code"><strong class="bold"># visudo</strong></p><p class="source-code"><strong class="bold">lisa  ALL=(root) ROLE=unconfined_r TYPE=unconfined_r </strong><strong class="bold">NOPASSWD: /usr/sbin/jk_init</strong></p><p class="calibre3">In this case, we not only use a <strong class="source-inline">ROLE</strong> and <strong class="source-inline">TYPE</strong> transition, but we also allow the command to be executed as the <strong class="source-inline">root</strong> user, as that is a requirement for the <strong class="source-inline">jk_init</strong> command. Of course, this can be adjusted as needed.</p></li>
				<li class="calibre9">Our user can now run the command, prefixed by <strong class="source-inline">sudo</strong>, to have it execute in the right domain and using the right role:<p class="source-code"><strong class="bold">$ sudo /usr/sbin/jk_init -v -j /srv/chroot \</strong></p><p class="source-code"><strong class="bold">  extshellplusnet</strong></p></li>
			</ol>
			<p class="calibre3">Using <strong class="source-inline">sudo</strong> for end user applications is common when the privileges of the user also have to switch (from the user<a id="_idIndexMarker912" class="pcalibre calibre6 pcalibre1"/> privilege to the root privilege). It is<a id="_idIndexMarker913" class="pcalibre calibre6 pcalibre1"/> less common to use it when staying within the Linux user context though.</p>
			<h3 class="calibre12">Running daemons in an explicit unconfined domain</h3>
			<p class="calibre3">The second use case, and perhaps a<a id="_idIndexMarker914" class="pcalibre calibre6 pcalibre1"/> more common one than for end user applications, is to run daemonized services in an unconfined domain. Most <a id="_idIndexMarker915" class="pcalibre calibre6 pcalibre1"/>Linux distributions that use unconfined domains (such as CentOS) will by default have newly installed software run as an unconfined domain as well. For instance, any service that is enabled and activated through systemd (which runs as the <strong class="source-inline">init_t</strong> SELinux domain) and that does not have an explicit labeling set (meaning the executable commands are labeled as <strong class="source-inline">bin_t</strong>) will run in the <strong class="source-inline">unconfined_service_t</strong> domain.</p>
			<p class="calibre3">But what if we have a confined application that we want to run in an unconfined domain? Let's take PostgreSQL as an example. Suppose this is an isolated database that has certain extensions active that are incompatible with the existing PostgreSQL SELinux domain (<strong class="source-inline">postgresql_t</strong>). Administrators might not have the time to extend the current SELinux policy using methods such as <strong class="source-inline">audit2allow</strong>, as seen in <a href="B16276_12_Final_VK.xhtml#_idTextAnchor312" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 12</em></a>, <em class="italic">Tuning SELinux Policies</em>.</p>
			<p class="calibre3">Luckily, we can easily move PostgreSQL to work and run in an unconfined domain. There are two ways to approach this:</p>
			<ul class="calibre8">
				<li class="calibre9">We can remove the existing labels on its executable files (<strong class="source-inline">postgresql_exec_t</strong>) and set it to <strong class="source-inline">bin_t</strong> instead. This will then trigger the default transition when starting the PostgreSQL binary to the <strong class="source-inline">unconfined_service_t</strong> domain.</li>
				<li class="calibre9">We can update the SELinux policy for <strong class="source-inline">postgresql_t</strong> to become an unconfined domain itself.</li>
			</ul>
			<p class="calibre3">Switching the labels is easy, but is the least recommended method. It is, however, a quick and dirty way to see whether running the service in the <strong class="source-inline">unconfined_service_t</strong> domain is sufficient to resolve the issue immediately:</p>
			<p class="source-code"># chcon -t bin_t /usr/bin/postgres</p>
			<p class="calibre3">If agreeable, make sure that the label change remains, even after a relabel operation occurs:</p>
			<p class="source-code"># semanage fcontext -a -t bin_t /usr/bin/postgres</p>
			<p class="calibre3">Updating the SELinux policy for the PostgreSQL daemon is recommended though, as it retains the existing support within the policy (including the file transitions and other integrations that the <strong class="source-inline">postgresql_t</strong> domain has with other domains and resources). It also allows administrators to update the policy as needed later on, when there is more time available.</p>
			<p class="calibre3">To make the <strong class="source-inline">postgresql_t</strong> domain<a id="_idIndexMarker916" class="pcalibre calibre6 pcalibre1"/> unconfined, we need to assign the <strong class="source-inline">unconfined_domain_type</strong> attribute to the <strong class="source-inline">postgresql_t</strong> domain. This can<a id="_idIndexMarker917" class="pcalibre calibre6 pcalibre1"/> be accomplished by loading in the following CIL-based SELinux policy:</p>
			<p class="source-code">(typeattributeset cil_gen_require postgresql_t)</p>
			<p class="source-code">(typeattributeset cil_gen_require unconfined_domain_type)</p>
			<p class="source-code">(typeattributeset unconfined_domain_type (postgresql_t))</p>
			<p class="calibre3">Save this in a file and load it using <strong class="source-inline">semodule -i</strong>, and from that point onward the <strong class="source-inline">postgresql_t</strong> domain will be augmented with the privileges associated with the <strong class="source-inline">unconfined_domain_type</strong> attribute.</p>
			<h2 id="_idParaDest-355" class="calibre10"><a id="_idTextAnchor359" class="pcalibre calibre6 pcalibre1"/>Extending unconfined domains</h2>
			<p class="calibre3">As unconfined domains<a id="_idIndexMarker918" class="pcalibre calibre6 pcalibre1"/> are still enforced, it might be possible that SELinux is still preventing some actions from occurring. We can adjust the SELinux policy to extend unconfined domains with more privileges though. While the default <strong class="source-inline">unconfined_service_t</strong> domain has almost all possible permissions set, more specifically, identified domains might not be as expansive.</p>
			<p class="calibre3">The trick to adding more privileges to the domains is to assign the appropriate attribute to them. The method is the same as seen in <em class="italic">Running daemons in an explicit unconfined domain</em>, adding more attributes as needed. The list of attributes that we can add is very significant (as you can see from <strong class="source-inline">seinfo -a</strong>), but the most important ones, especially for the CentOS-based SELinux policy, are the following:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="source-inline">files_unconfined_type</strong> allows the domain to manage any possible file- or filesystem-based resource.</li>
				<li class="calibre9"><strong class="source-inline">devices_unconfined_type</strong> allows the domain to interact and manage any device resource.</li>
				<li class="calibre9"><strong class="source-inline">filesystem_unconfined_type</strong> allows the domain to interact and manage all filesystems.</li>
				<li class="calibre9"><strong class="source-inline">selinux_unconfined_type</strong> allows the domain to interact with and manage the SELinux subsystem and configuration.</li>
				<li class="calibre9"><strong class="source-inline">storage_unconfined_type</strong> allows the domain to interact with storage systems and removable devices.</li>
				<li class="calibre9"><strong class="source-inline">dbusd_unconfined</strong> allows the domain to interact with all possible D-Bus services.</li>
				<li class="calibre9"><strong class="source-inline">xserver_unconfined_type</strong> allows the domain to interact with and manage all X server resources.</li>
			</ul>
			<p class="calibre3">Furthermore, there are several <strong class="source-inline">can_*</strong> attributes that<a id="_idIndexMarker919" class="pcalibre calibre6 pcalibre1"/> fine-tune very specific, security-sensitive actions. The names of these attributes nicely explain what they allow. For instance, <strong class="source-inline">can_write_shadow_passwords</strong> allows the domain to write to <strong class="source-inline">/etc/shadow</strong>, whereas <strong class="source-inline">can_change_object_identity</strong> means that the domain can change the SELinux user of an object.</p>
			<p class="calibre3">Not all attributes have their privileges reflected in regular <strong class="source-inline">allow</strong> rules or transitions that can be queried using <strong class="source-inline">sesearch</strong>. For instance, <strong class="source-inline">can_change_object_identity</strong> is used in SELinux constraints instead:</p>
			<p class="source-code"># seinfo --constrain | grep can_change_object_identity</p>
			<p class="calibre3">Querying the constraints is an often forgotten method to see what or why a certain privilege is or isn't assigned to a domain.</p>
			<p class="calibre3">Suppose now that an application still fails to run correctly within an unconfined domain, then we can use permissive domains to allow this application to run unprotected, while having the rest of the system remain in enforcing mode.</p>
			<h2 id="_idParaDest-356" class="calibre10"><a id="_idTextAnchor360" class="pcalibre calibre6 pcalibre1"/>Marking domains as permissive</h2>
			<p class="calibre3">As we saw in <a href="B16276_02_Final_VK.xhtml#_idTextAnchor045" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding SELinux Decisions and Logging</em>, we can mark a domain <a id="_idIndexMarker920" class="pcalibre calibre6 pcalibre1"/>as permissive using <strong class="source-inline">semanage permissive</strong>:</p>
			<p class="source-code"># semanage permissive -a postgresql_t</p>
			<p class="calibre3">The same command can be used to query (<strong class="source-inline">-l</strong>) or remove (<strong class="source-inline">-d</strong>) permissive states. However, administrators should take special care before marking domains as permissive:</p>
			<ul class="calibre8">
				<li class="calibre9">First of all, if you mark a domain as permissive, then all processes running with that SELinux domain will run without any active SELinux enforcements. As an administrator, you really want to limit the number of processes that are running through permissive domains, so do not mark broadly used SELinux domains as permissive.<p class="calibre3">A daemon that runs in an unconfined domain, yet still has problems, should not result in the unconfined domain being marked as permissive. Instead, have the daemon run as a different domain, and mark that domain as permissive.</p></li>
				<li class="calibre9">Secondly, permissive domains will still trigger SELinux behavior by the SELinux subsystem. Transition rules, including process transitions and file transitions, are still executed. This is of course by design, as permissive domains are meant to be short-lived, allowing administrators and developers to capture information and adapt the policy as needed before they can remove the permissive flag again.<p class="calibre3">This also implies that, if the domain does not have proper transition rules set, it might result in files being created on the system that have the wrong SELinux types set. Because of this, using permissive domains should not be considered for applications or daemons that have a wide impact on the system, but rather for more isolated situations where you, as an administrator, feel confident that you can easily fine-tune the policy if needed.</p></li>
			</ul>
			<p class="calibre3">Consider the situation where we deploy pgpool-II, a load balancer for PostgreSQL databases, and find that the application does not run properly in an unconfined domain, even though it already runs in the <strong class="source-inline">unconfined_service_t</strong> SELinux domain. While we can put this domain in permissive mode, this would also apply to various other services running inside the <strong class="source-inline">unconfined_service_t</strong> domain.</p>
			<p class="calibre3">What we can do is relabel its<a id="_idIndexMarker921" class="pcalibre calibre6 pcalibre1"/> resources (executables mostly) so that the application is run through a different SELinux domain, and then mark that domain as permissive. We can either reuse an existing, unused domain or generate one, as we will see in the <em class="italic">Generating policies with sepolicy generate</em> section.</p>
			<p class="calibre3">When we want to run an application in a (strictly) confined manner though, we need to take a completely different route and seek out how to put such applications in sandbox-like domains.</p>
			<h1 id="_idParaDest-357" class="calibre5"><a id="_idTextAnchor361" class="pcalibre calibre6 pcalibre1"/>Using sandboxed applications</h1>
			<p class="calibre3">New applications that should<a id="_idIndexMarker922" class="pcalibre calibre6 pcalibre1"/> only have very limited privileges, and that are untrusted by nature, should be confined completely. While we could look at custom SELinux policies for these applications, this is hardly possible for each and every application out there.</p>
			<p class="calibre3">Instead, we can consider sandboxing the applications, isolating their access from the system. With the help of some other Linux primitives such as namespace support, a utility has been created called the SELinux sandbox, which launches applications in a tightly confined domain. This is mostly meant for end user applications.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The SELinux sandbox, its SELinux policy, and the command associated with it, is specific to Linux distributions that use or follow Red Hat packages, such as CentOS. It might not be available for your Linux distribution.</p>
			<p class="calibre3">For service-oriented domains, using the container runtime and protection measures are more suited. For more information about using container protections, see <a href="B16276_11_Final_VK.xhtml#_idTextAnchor293" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 11</em></a>, <em class="italic">Enhancing the Security of Containerized Workloads</em>.</p>
			<h2 id="_idParaDest-358" class="calibre10"><a id="_idTextAnchor362" class="pcalibre calibre6 pcalibre1"/>Understanding the SELinux sandbox</h2>
			<p class="calibre3">The <strong class="bold">SELinux sandbox</strong> is a combination <a id="_idIndexMarker923" class="pcalibre calibre6 pcalibre1"/>of a number of technologies <a id="_idIndexMarker924" class="pcalibre calibre6 pcalibre1"/>and protection measures. While the SELinux policy plays an important part, other isolation measures are taken as well to really create a sandbox experience for applications and users.</p>
			<p class="calibre3">The purpose of the sandbox is to create a low-privilege environment that blocks anything that could jeopardize the security of the system or the user's data. This also means that network interaction is blocked by default (no data exfiltration), and many system resources are hidden away from the sandboxed process.</p>
			<p class="calibre3">Many of the access controls themselves are handled by the SELinux policy. The sandbox SELinux domains, <strong class="source-inline">sandbox_t</strong>, and derivatives such as <strong class="source-inline">sandbox_xserver_t</strong>, do not have many privileges for other resources. The sandbox utility will also apply sVirt-like categories to differentiate one sandboxed process from another.</p>
			<p class="calibre3">The isolation, however, is done using different means. <strong class="bold">Namespaces</strong> are used to give the sandboxed process a different view of the<a id="_idIndexMarker925" class="pcalibre calibre6 pcalibre1"/> filesystem (similar to polyinstantiation), whereas runtime capabilities are<a id="_idIndexMarker926" class="pcalibre calibre6 pcalibre1"/> dropped before executing the process. The <strong class="source-inline">seunshare</strong> application is responsible for doing these isolation tasks.</p>
			<p class="calibre3">Let's see how the SELinux sandbox works in practice.</p>
			<h2 id="_idParaDest-359" class="calibre10"><a id="_idTextAnchor363" class="pcalibre calibre6 pcalibre1"/>Using the sandbox command</h2>
			<p class="calibre3">The SELinux sandbox <a id="_idIndexMarker927" class="pcalibre calibre6 pcalibre1"/>uses the <strong class="source-inline">sandbox</strong> command. Now, before we<a id="_idIndexMarker928" class="pcalibre calibre6 pcalibre1"/> can use it, we need to make sure that our SELinux user has multiple categories set as, otherwise, the SELinux sandbox cannot randomly allocate two categories for isolation:</p>
			<p class="source-code"># semanage login -l</p>
			<p class="source-code"># semanage login -m -r "s0-s0:c0.c100" lisa</p>
			<p class="calibre3">Once assigned, we can prepare for running an untrusted application in a sandbox. For instance, we can download one of the International Obfuscated C Code Contest applications from <a href="https://www.ioccc.org" class="pcalibre calibre6 pcalibre1">https://www.ioccc.org</a>, compile it, and then<a id="_idIndexMarker929" class="pcalibre calibre6 pcalibre1"/> only run it in a sandbox mode just in case the code behaves maliciously:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">Assuming we use the 2019 entry from <strong class="source-inline">adamovsky</strong>, we should have the <strong class="source-inline">prog</strong> binary and the <strong class="source-inline">advent.unl</strong> file ready to use. Create a location in which to store these files, and copy them over:<p class="source-code"><strong class="bold">$ mkdir sandbox</strong></p><p class="source-code"><strong class="bold">$ cp 2019/adamovsky/* sandbox</strong></p></li>
				<li class="calibre9">Next, run the <strong class="source-inline">prog</strong> command from within the sandbox:<p class="source-code"><strong class="bold">$ sandbox -H sandbox/ prog advent.unl</strong></p><p class="source-code"><strong class="bold">Welcome to Adventure!! Would you like instructions?</strong></p><p class="source-code"><strong class="bold">**</strong></p></li>
				<li class="calibre9">While the application runs, we can check its current context with <strong class="source-inline">ps</strong>:<p class="source-code"><strong class="bold"># ps -efZ | grep prog</strong></p><p class="calibre3">Alongside the <strong class="source-inline">prog</strong> command itself, which will be running in the <strong class="source-inline">sandbox_t</strong> SELinux domain and with a certain category pair set, you will notice that a <strong class="source-inline">seunshare</strong> command will run alongside it. This command provides the isolation for the process, not only by triggering the SELinux context change, but also removing unnecessary mount and filesystem views from the process's viewpoint.</p></li>
				<li class="calibre9">If we exit the application, we can see that the sandbox location has been labeled with an sVirt-like MCS pair:<p class="source-code"><strong class="bold">$ ls -Z sandbox/</strong></p><p class="source-code"><strong class="bold">staff_u:object_r:sandbox_file_t:s0:c29,c94 advent.unl</strong></p><p class="source-code"><strong class="bold">staff_u:object_r:sandbox_file_t:s0:c29,c94 prog</strong></p></li>
			</ol>
			<p class="calibre3">The method we used here<a id="_idIndexMarker930" class="pcalibre calibre6 pcalibre1"/> was to explicitly tell the sandbox to create an isolated home directory based upon the <strong class="source-inline">sandbox/</strong> folder and run the <strong class="source-inline">prog</strong> binary from within this<a id="_idIndexMarker931" class="pcalibre calibre6 pcalibre1"/> location (and with <strong class="source-inline">advent.unl</strong> as an argument to the <strong class="source-inline">prog</strong> command). However, this is not the sole approach.</p>
			<p class="calibre3">If no explicit home directory is provided, then the sandbox will create a temporary one (and clean it up afterward). However, in that case, we cannot execute commands that are not already installed on the system, unless we allow the sandbox domain to execute <strong class="source-inline">user_home_t</strong>-labeled resources:</p>
			<p class="source-code">(typeattributeset cil_gen_require sandbox_t)</p>
			<p class="source-code">(allow sandbox_t user_home_t (file (execute map)))</p>
			<p class="calibre3">With this policy loaded, we can use the sandbox with the least number of options. For instance, with the Burton contest submission (also from IOCCC's 2019 contest), we have the following:</p>
			<p class="source-code">$ cat prog.c | sandbox ./prog</p>
			<p class="source-code">      1      1   127</p>
			<p class="calibre3">The use of a more known location, however, allows more flexibility, as well as allowing the sandbox to keep data across multiple sessions (as the directory pointed toward will not be cleaned up).</p>
			<p class="calibre3">The SELinux sandbox also supports running graphical applications in the sandbox. To accomplish this, add the <strong class="source-inline">-X</strong> option to the <strong class="source-inline">sandbox</strong> command. The resulting process will run in the <strong class="source-inline">sandbox_xserver_t</strong> domain rather than the <strong class="source-inline">sandbox_t</strong> domain, as more privileges are needed to allow graphical applications to run. Keep in mind though that the sandbox domain <a id="_idIndexMarker932" class="pcalibre calibre6 pcalibre1"/>has very few privileges; connecting to<a id="_idIndexMarker933" class="pcalibre calibre6 pcalibre1"/> networked resources is not allowed, so it is not possible to use the sandbox (without additional modifications and SELinux policy adjustments) to run a sandboxed browser to interact with unsafe websites.</p>
			<h1 id="_idParaDest-360" class="calibre5"><a id="_idTextAnchor364" class="pcalibre calibre6 pcalibre1"/>Assigning common policies to new applications</h1>
			<p class="calibre3">In between the strong<a id="_idIndexMarker934" class="pcalibre calibre6 pcalibre1"/> isolation of an SELinux sandbox and the broad permissions of unconfined domains (or even permissive domains) sits the sufficiently<a id="_idIndexMarker935" class="pcalibre calibre6 pcalibre1"/> privileged application domain. For most administrators, having a proper SELinux domain for applications is the best way forward, as it allows all the common behaviors and restricts unwanted ones.</p>
			<p class="calibre3">When we start looking at application domains, however, we notice that there is differentiation in complexity, and as an administrator, we need to understand what the complexity is about before we can make the right choice.</p>
			<h2 id="_idParaDest-361" class="calibre10"><a id="_idTextAnchor365" class="pcalibre calibre6 pcalibre1"/>Understanding domain complexity</h2>
			<p class="calibre3">SELinux is able to provide full system confinement: each and every application runs in its own restricted environment that it cannot break out of. But that requires fine-grained policies that are developed <a id="_idIndexMarker936" class="pcalibre calibre6 pcalibre1"/>as quickly as the new releases of all the applications they confine.</p>
			<p class="calibre3">Developing fine-grained policies at this speed is not possible, so a balance has to be struck between the maintainability of a policy and the security of the domain. This balance is the policy design complexity or domain complexity, which can be roughly categorized as follows:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="bold">Fine-grained policies</strong> have separate, individual domains<a id="_idIndexMarker937" class="pcalibre calibre6 pcalibre1"/> for each sub component of an application or service. Such policies have the advantage that they really attempt to restrict applications as much as possible. Through<a id="_idIndexMarker938" class="pcalibre calibre6 pcalibre1"/> fine-grained policies, roles developed with users and administrators in mind become fine-grained as well, for instance, by differentiating sub-roles in the application.<p class="calibre3">The disadvantage of such policies is that they are hard to maintain, requiring frequent updates as the application itself evolves. The policies also need to take into account the impact of the various configuration options that the application supports.</p><p class="calibre3">Such fine-grained policies are not frequently found. An example is the policy set provided for the Postfix mail infrastructure. Each sub-service of the Postfix infrastructure has its own SELinux domain.</p></li>
				<li class="calibre9"><strong class="bold">Application-level policies</strong> use a single<a id="_idIndexMarker939" class="pcalibre calibre6 pcalibre1"/> domain for an <a id="_idIndexMarker940" class="pcalibre calibre6 pcalibre1"/>application, regardless of its sub-components. This balances the requirement for application confinement versus the maintainability of the application and its SELinux policy.<p class="calibre3">Such application-level policies are the most common in SELinux policies. They do still suffer from regular maintenance as applications expand their functionality, but the complexity of this is limited and SELinux policy developers should not have too many problems maintaining these policies.</p></li>
				<li class="calibre9"><strong class="bold">Category-wide policies</strong> use a single domain definition for a set of applications that implement the <a id="_idIndexMarker941" class="pcalibre calibre6 pcalibre1"/>same functionality. This is popular for services that act very similarly and whose user-role definitions <a id="_idIndexMarker942" class="pcalibre calibre6 pcalibre1"/>can be described without really considering the application-specific nature.<p class="calibre3">A good example of a category-wide policy is the policy for web servers. While this policy was initially written for the Apache HTTP daemon, the policy has become reusable for a number of web servers, such as the Cherokee, Hiawatha, Nginx, and Lighttpd projects.</p><p class="calibre3">While such policies are easier to maintain, the downside of category-wide policies is that they often have more broad privileges than really needed. As more applications are joined in the category-wide policy, additional rules and privileges are added to support those specific functions.</p></li>
				<li class="calibre9"><strong class="bold">Coarse-grained policies</strong> are used for <a id="_idIndexMarker943" class="pcalibre calibre6 pcalibre1"/>applications or <a id="_idIndexMarker944" class="pcalibre calibre6 pcalibre1"/>services whose behavior is hard to define. End user domains are examples of coarse-grained policies, as are unconfined domains.</li>
			</ul>
			<p class="calibre3">When we are dealing with a new application, and we want to quickly assign a decent-enough policy, the most common method is to see whether a category-wide policy exists that we can reuse for the application.</p>
			<h2 id="_idParaDest-362" class="calibre10"><a id="_idTextAnchor366" class="pcalibre calibre6 pcalibre1"/>Running applications in a specific policy</h2>
			<p class="calibre3">Let's consider the<a id="_idIndexMarker945" class="pcalibre calibre6 pcalibre1"/> situation for the pgpool-II application. When we install it without any additional changes, it will run with the <strong class="source-inline">unconfined_service_t</strong> domain, as mentioned in the <em class="italic">Marking domains as permissive</em> section. But perhaps we can find a suitable policy to run the pgpool-II application with, through which it is more confined.</p>
			<p class="calibre3">As the pgpool-II solution is a load balance-like application for PostgreSQL databases, it is likely we can run it in the PostgreSQL domain. If there are no PostgreSQL databases running on the same system, then lending this domain for the pgpool-II application might not do much harm. Let's see how well this goes:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">The PostgreSQL policy uses the <strong class="source-inline">postgresql_exec_t</strong> SELinux type for its executables, so let's assign that one to the <strong class="source-inline">pgpool</strong> binary:<p class="source-code"><strong class="bold"># chcon -t postgresql_exec_t /usr/bin/pgpool</strong></p></li>
				<li class="calibre9">If we try to start the <strong class="source-inline">pgpool</strong> system service, we might get one or more failures:<p class="source-code"><strong class="bold"># systemctl start pgpool</strong></p><p class="source-code"><strong class="bold"># systemctl status pgpool</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">WARNING: Failed to open status file at: "/var/log/pgpool/</strong><strong class="bold">pgpool_status"</strong></p><p class="source-code"><strong class="bold">FATAL: could not read pid file</strong></p></li>
				<li class="calibre9">One of the failures mentioned is that the daemon cannot access its logs (in <strong class="source-inline">/var/log/pgpool</strong>) while another<a id="_idIndexMarker946" class="pcalibre calibre6 pcalibre1"/> complains about the process ID file (in <strong class="source-inline">/var/run/pgpool</strong>) being unreachable. As these were previously created by an unconfined domain, it is indeed likely that their context is wrong as well. Let's apply the PostgreSQL-specific types to these locations:<p class="source-code"><strong class="bold"># chcon -R -t postgresql_log_t /var/log/pgpool</strong></p><p class="source-code"><strong class="bold"># chcon -R -t postgresql_var_run_t /var/run/pgpool</strong></p></li>
				<li class="calibre9">After restarting <strong class="source-inline">pgpool</strong>, we notice it has a new failure:<p class="source-code"><strong class="bold"># systemctl start pgpool</strong></p><p class="source-code"><strong class="bold"># systemctl status pgpool</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">LOG: Setting up socket for ::1.9999</strong></p><p class="source-code"><strong class="bold">FATAL: failed to create INET domain socket</strong></p><p class="source-code"><strong class="bold">DETAIL: bind on socket failed with error "Permission </strong><strong class="bold">denied"</strong></p><p class="calibre3">This time, we get a permission failure, which most of the time implies that the SELinux policy is refusing a certain action:</p><p class="source-code"><strong class="bold"># ausearch -i -m avc -ts recent</strong></p><p class="source-code"><strong class="bold">... avc: denied { name_bind } for pid=20065 comm=pgpool </strong><strong class="bold">src=9999 scontext=system_u:system_r:postgresql_t:s0 tcontext=system_u:object_r:jboss_management_port_t:s0 tclass=tcp_socket</strong></p><p class="calibre3">The denial seems to reflect the information displayed earlier: <strong class="source-inline">pgpool</strong> wants to listen on port <strong class="source-inline">9999</strong>, but SELinux is refusing this.</p></li>
				<li class="calibre9">Let's create a small policy enhancement to allow <strong class="source-inline">postgresql_t</strong> to bind to this port:<p class="source-code">(typeattributeset cil_gen_require jboss_management_port_t)</p><p class="source-code">(typeattributeset cil_gen_require postgresql_t)</p><p class="source-code">(allow postgresql_t jboss_management_port_t (tcp_socket (name_bind)))</p></li>
				<li class="calibre9">Load this policy and restart <strong class="source-inline">pgpool</strong>. With this in place, <strong class="source-inline">pgpool</strong> starts up fine.<p class="calibre3">Of course, having the daemon<a id="_idIndexMarker947" class="pcalibre calibre6 pcalibre1"/> launch without problems does not mean that it will work without problems, so it is recommended to continue testing, using the service as intended.</p></li>
			</ol>
			<p class="calibre3">Finding out which policy can be reused for a process requires a bit of practice and searching. For instance, you can query the policy for which domains are able to bind to the port that the daemon needs. Or you can search for a domain that has a behavior very similar to the application involved. In our example, we only had to allow the domain to bind to port <strong class="source-inline">9999</strong>. We could also use this information point to seek a different policy—one that is allowed to bind to this port (such as the <strong class="source-inline">httpd_t</strong> domain) and see whether that one fits better.</p>
			<p class="calibre3">While this approach is trial and error, it could allow running the service in a more confined domain than the unconfined domain would. A much better approach, however, is to generate a new, custom policy and work from there.</p>
			<h1 id="_idParaDest-363" class="calibre5"><a id="_idTextAnchor367" class="pcalibre calibre6 pcalibre1"/>Extending generated policies</h1>
			<p class="calibre3">When we assign a different <a id="_idIndexMarker948" class="pcalibre calibre6 pcalibre1"/>policy to a new application, we are reusing and possibly extending existing policies. We can go a step further and generate new policies, after which we can further extend those policies, effectively moving into the realm of developing new policies ourselves.</p>
			<p class="calibre3">In <a href="B16276_15_Final_VK.xhtml#_idTextAnchor373" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 15</em></a>, <em class="italic">Using the Reference Policy</em>, and <a href="B16276_16_Final_VK.xhtml#_idTextAnchor391" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 16</em></a>, <em class="italic">Developing Policies with SELinux CIL</em>, we will expand further into the policy development aspects for more fine-grained control. By using policy generation tools, however, we can quickly create a first-draft policy and adapt as needed.</p>
			<p class="calibre3">An important caveat is that policy generation tools often limit themselves to a single-policy format, either being reference policy style or CIL style. Administrators and organizations should try to focus on a single style and stick with that so that the learning curve for new developers and administrators isn't too high.</p>
			<h2 id="_idParaDest-364" class="calibre10"><a id="_idTextAnchor368" class="pcalibre calibre6 pcalibre1"/>Understanding the limitations of generated policies</h2>
			<p class="calibre3">Policy generators, such as the <strong class="source-inline">udica</strong> tool we<a id="_idIndexMarker949" class="pcalibre calibre6 pcalibre1"/> saw in <a href="B16276_11_Final_VK.xhtml#_idTextAnchor293" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 11</em></a>, <em class="italic">Enhancing the Security of Containerized Workloads</em>, often have a very specific purpose. For instance, the <strong class="source-inline">udica</strong> tool focuses on generating new container SELinux domains and is only useful for those containers. Generators will always have a specific target in mind for what their policies should look like.</p>
			<p class="calibre3">The generated policies are often application-level policies. Creating fine-grained policies with generators is hard, and defining category-wide policies requires multiple steps and occurrences, whereas generators often use single-step generations.</p>
			<p class="calibre3">Furthermore, most generated policies only generally support role-based access controls within SELinux: either a user is allowed the target SELinux domain and interacting with it, or the user isn't allowed. Differentiating roles (such as application administrator versus application user) are not often included in generated policies.</p>
			<p class="calibre3">Administrators should be aware that generators also have to make assumptions about how applications work. While this allows generators to be used for the majority of simple services and applications, they are definitely not ready yet to substitute a knowledgeable team of SELinux policy developers.</p>
			<h2 id="_idParaDest-365" class="calibre10"><a id="_idTextAnchor369" class="pcalibre calibre6 pcalibre1"/>Introducing sepolicy generate</h2>
			<p class="calibre3">The <strong class="source-inline">sepolicy</strong> command is <a id="_idIndexMarker950" class="pcalibre calibre6 pcalibre1"/>able to generate initial SELinux policy modules, which administrators and developers can then fine-tune further. This generator will use some resources on the system (such as the package database of the distribution) to better understand which resources to include, and generates a number of SELinux policy files.</p>
			<p class="calibre3">As there are different types of <a id="_idIndexMarker951" class="pcalibre calibre6 pcalibre1"/>applications around, the <strong class="source-inline">sepolicy generate</strong> command also requires the user to inform it about the application type. The following types are currently supported:</p>
			<ul class="calibre8">
				<li class="calibre9">User applications are identified with the <strong class="source-inline">--application</strong> option. Such applications are meant for end users to launch and interact with.</li>
				<li class="calibre9">System service applications are identified with the <strong class="source-inline">--init</strong> option. Applications that run in daemon mode or with their own user are most often system service applications.</li>
				<li class="calibre9">D-Bus system service applications are identified with the <strong class="source-inline">--dbus</strong> option. This type of service is invoked by D-Bus.</li>
				<li class="calibre9"><strong class="bold">Common Gateway Interface</strong> (<strong class="bold">CGI</strong>) scripts or applications are supported through the <strong class="source-inline">--cgi</strong> option. Using CGI-specific <a id="_idIndexMarker952" class="pcalibre calibre6 pcalibre1"/>domains allows having CGI applications run in their own domain, rather than extending the privileges of the web server domain itself.</li>
				<li class="calibre9"><strong class="bold">Internet services daemon</strong> (<strong class="bold">inetd</strong>) applications are <a id="_idIndexMarker953" class="pcalibre calibre6 pcalibre1"/>supported through the <strong class="source-inline">--inetd</strong> option.</li>
				<li class="calibre9">Sandbox applications are like user applications but much more confined, and are supported through the <strong class="source-inline">--sandbox</strong> option.</li>
			</ul>
			<p class="calibre3">Next to application-level policy generation, <strong class="source-inline">sepolicy generate</strong> also supports generating user domains and roles:</p>
			<ul class="calibre8">
				<li class="calibre9">Standard users with support for the graphical desktop can be generated using the <strong class="source-inline">--desktop_user</strong> option. This is a common, non-administration-oriented user role.</li>
				<li class="calibre9">A more lightweight, minimal user role that still supports the graphical desktop can be generated using the <strong class="source-inline">--x_user</strong> option. This domain focuses on minimal permissions and thus requires further extensions before they can be better put to use.</li>
				<li class="calibre9">If no graphical user<a id="_idIndexMarker954" class="pcalibre calibre6 pcalibre1"/> interface needs to be supported, then you can use the <strong class="source-inline">--term_user</strong> option. This generates a confined user domain without desktop support.</li>
				<li class="calibre9">Administration-oriented user domains can be generated using the <strong class="source-inline">--admin_user</strong> option. This is meant for broad administrative privileges.</li>
				<li class="calibre9">More confined <a id="_idIndexMarker955" class="pcalibre calibre6 pcalibre1"/>administration domains can be generated using the <strong class="source-inline">--confined_admin</strong> option. This allows you to generate user domains that have administrative roles for a limited number of application domains, not to the system as a whole.</li>
			</ul>
			<p class="calibre3">The generator also supports customizing existing domains further (using <strong class="source-inline">--customize</strong>) or generating specific types (using <strong class="source-inline">--newtype</strong>).</p>
			<p class="calibre3">Let's use <strong class="source-inline">sepolicy generate</strong> to generate a policy for the pgpool-II application.</p>
			<h2 id="_idParaDest-366" class="calibre10"><a id="_idTextAnchor370" class="pcalibre calibre6 pcalibre1"/>Generating policies with sepolicy generate</h2>
			<p class="calibre3">The <strong class="source-inline">sepolicy generate</strong> command will create <a id="_idIndexMarker956" class="pcalibre calibre6 pcalibre1"/>a skeleton SELinux policy, using the reference policy code style. This policy <a id="_idIndexMarker957" class="pcalibre calibre6 pcalibre1"/>can then be gradually extended with the privileges the application needs.</p>
			<p class="calibre3">Let's create and adapt the policy for <strong class="source-inline">pgool</strong>:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">First, we tell <strong class="source-inline">sepolicy</strong> to generate a new policy, named <strong class="source-inline">pgpool</strong>, which is intended for the <strong class="source-inline">/usr/bin/pgpool</strong> binary:<p class="source-code"><strong class="bold"># sepolicy generate -n pgpool --init /usr/bin/pgpool</strong></p></li>
				<li class="calibre9">Next, build the generated SELinux policy:<p class="source-code"><strong class="bold"># make -f /usr/share/selinux/devel/Makefile pgpool.pp</strong></p></li>
				<li class="calibre9">Load the policy in memory:<p class="source-code"><strong class="bold"># semodule -i pgpool.pp</strong></p></li>
				<li class="calibre9">Relabel the filesystem, or at least the locations mentioned in the generated <strong class="source-inline">pgpool.fc</strong> file:<p class="source-code"><strong class="bold"># restorecon -RvF /usr/bin/pgpool /var/log/pgpool \</strong></p><p class="source-code"><strong class="bold">  /var/run/pgpool</strong></p></li>
				<li class="calibre9">Start the <strong class="source-inline">pgpool</strong> service:<p class="source-code"><strong class="bold"># systemctl start pgpool</strong></p><p class="calibre3">After starting, be amazed that <strong class="source-inline">pgpool</strong> is running flawlessly.</p></li>
			</ol>
			<p class="calibre3">Now, you might have the impression that this was too easy. Yes, it was. The default SELinux policy that <strong class="source-inline">sepolicy generate</strong> provides is permissive, as you can see from within the <strong class="source-inline">pgpool.te</strong> file:</p>
			<p class="source-code">permissive pgpool_t;</p>
			<p class="calibre3">If we remove this statement, rebuild, and <a id="_idIndexMarker958" class="pcalibre calibre6 pcalibre1"/>reload the <a id="_idIndexMarker959" class="pcalibre calibre6 pcalibre1"/>policy, then we will notice the failures coming up again, such as the process not being allowed to bind to the selected ports. We can now use <strong class="source-inline">audit2allow</strong>, for instance, to help us extend the policy as needed:</p>
			<p class="source-code"># cat /var/log/audit/audit.log | audit2allow -R</p>
			<p class="calibre3">Gradually extend, rebuild, and reload the policy until the application works without problems.</p>
			<h1 id="_idParaDest-367" class="calibre5"><a id="_idTextAnchor371" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
			<p class="calibre3">Linux administrators can use SELinux controls to prevent or confine access to applications, but this is not always the requirement at hand. Being able to run the application with the <em class="italic">right</em> set of permissions is, and what the right set is depends on the user's intentions and the environment.</p>
			<p class="calibre3">Within this chapter, we've learned how to apply the appropriate confinement to application domains, ranging from very isolated container environments over regular application domains, category-wide permission sets, and up to unconfined domains and even permissive domains. We learned that this is done by first finding the appropriate domain, understanding which labels the domain uses, and then assigning the right labels to the files so that the application is executed in the right domain.</p>
			<p class="calibre3">We also learned how to generate new policies (using <strong class="source-inline">sepolicy generate</strong>) ourselves without immediately having to dive into a full SELinux policy development approach, which is what we will consider in the final two chapters.</p>
			<h1 id="_idParaDest-368" class="calibre5"><a id="_idTextAnchor372" class="pcalibre calibre6 pcalibre1"/>Questions</h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">What is the difference between an unconfined domain and a permissive domain?</li>
				<li class="calibre9">How can we run applications in a very restricted domain?</li>
				<li class="calibre9">How can we easily switch the domain in which a service will run?</li>
				<li class="calibre9">Why do policies generated by <strong class="source-inline">sepolicy</strong> seemingly run without problems?</li>
			</ol>
		</div>
	</div></body></html>