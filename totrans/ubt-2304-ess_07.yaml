- en: 8\. Using the Bash Shell on Ubuntu 23.04
  prefs: []
  type: TYPE_NORMAL
- en: An essential part of learning to work with Ubuntu and Linux distributions generally
    involves gaining proficiency in working in the shell environment. While graphical
    desktop environments such as GNOME, included with Linux, provide a user-friendly
    interface to the operating system, the shell environment provides far greater
    capabilities, flexibility, and automation than can ever be achieved using graphical
    desktop tools. The shell environment also provides a means for interacting with
    the operating system when a desktop environment is unavailable, a common occurrence
    when working with a server-based operating system such as Ubuntu or a damaged
    system that will not fully boot.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, this chapter aims to provide an overview of the default shell environment
    on Ubuntu (specifically the Bash shell).
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 What is a Shell?
  prefs: []
  type: TYPE_NORMAL
- en: The shell is an interactive command interpreter environment within which commands
    may be typed at a prompt or entered into a file as a script and executed. The
    origins of the shell can be traced back to the early days of the UNIX operating
    system. In fact, in the early days of Linux, before the introduction of graphical
    desktops, the shell was the only way for a user to interact with the operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: A variety of shell environments have been developed over the years. The first
    widely used shell was the Bourne shell, written by Stephen Bourne at Bell Labs.
  prefs: []
  type: TYPE_NORMAL
- en: Yet another early creation was the C shell which shared some syntax similarities
    with the C Programming Language and introduced usability enhancements such as
    command-line editing and history.
  prefs: []
  type: TYPE_NORMAL
- en: The Korn shell (developed by David Korn at Bell Labs) is based on features provided
    by both the Bourne and C shells.
  prefs: []
  type: TYPE_NORMAL
- en: The default shell on Ubuntu is the Bash shell (shorthand for Bourne Again SHell).
    This shell, which began life as an open-source version of the Bourne shell, was
    developed for the GNU Project by Brian Fox and is based on features provided by
    both the Bourne shell and the C shell.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Gaining Access to the Shell
  prefs: []
  type: TYPE_NORMAL
- en: From within the GNOME desktop environment, the shell prompt may be accessed
    from a Terminal window by selecting the Activities option in the top bar, entering
    Terminal into the search bar, and clicking the Terminal icon.
  prefs: []
  type: TYPE_NORMAL
- en: When remotely logging into an Ubuntu server, for example, using SSH, the user
    is presented with a shell prompt. The chapter entitled [“Configuring SSH Key-based
    Authentication on Ubuntu 23.04”](SSH_Authentication.xhtml#_idTextAnchor281) will
    cover details on accessing a remote server using SSH. When booting a server-based
    system in which a desktop environment has not been installed, the shell is entered
    immediately after the user completes the login procedure at the physical console
    terminal or remote login session.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Entering Commands at the Prompt
  prefs: []
  type: TYPE_NORMAL
- en: 'Commands are entered at the shell command prompt simply by typing the command
    and pressing the Enter key. While some commands perform tasks silently, most will
    display some form of output before returning to the prompt. For example, the ls
    command can be used to display the files and directories in the current working
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: $ ls
  prefs: []
  type: TYPE_NORMAL
- en: Desktop Documents Downloads Music Pictures Public Templates Videos
  prefs: []
  type: TYPE_NORMAL
- en: 'The available commands are either built into the shell itself or reside on
    the physical file system. The location on the file system of a command may be
    identified using the which command. For example, to find out where the ls executable
    resides on the file system:'
  prefs: []
  type: TYPE_NORMAL
- en: $ which ls
  prefs: []
  type: TYPE_NORMAL
- en: alias ls=’ls --color=auto’
  prefs: []
  type: TYPE_NORMAL
- en: /usr/bin/ls
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, the ls command resides in the /usr/bin directory. Note also that an
    alias is configured, a topic that will be covered later in this chapter. Using
    the which command to locate the path to commands built into the shell will result
    in a message indicating the executable cannot be found. For example, attempting
    to find the location of the history command (which is built into the shell rather
    than existing as an executable on the file system) will result in output similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: $ which history
  prefs: []
  type: TYPE_NORMAL
- en: '/usr/bin/which: no history in (/home/demo/.local/bin:/home/demo/bin:/usr/share/Modules/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin)'
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Getting Information about a Command
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the commands available to the Linux shell can seem cryptic. To find
    out detailed information about what a command does and how to use it, use the
    man command specifying the name of the command as an argument. For example, to
    learn more about the pwd command:'
  prefs: []
  type: TYPE_NORMAL
- en: $ man pwd
  prefs: []
  type: TYPE_NORMAL
- en: 'A detailed description of the pwd command will be displayed when the above
    command is executed. Many commands will also provide additional information when
    run with the --help command-line option:'
  prefs: []
  type: TYPE_NORMAL
- en: $ wc --help
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Bash Command-line Editing
  prefs: []
  type: TYPE_NORMAL
- en: 'Early shell environments did not provide any form of line editing capabilities.
    This meant that if you spotted an error at the beginning of a long command-line,
    you were typing, you had to delete all the following characters, correct the error
    and then re-enter the remainder of the command. Fortunately, Bash provides a wide
    range of command-line editing options, as outlined in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Key Sequence | Action |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-b or Left Arrow | Move the cursor back one position |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-f or Right Arrow | Move the cursor forward one position |'
  prefs: []
  type: TYPE_TB
- en: '| Delete | Delete the character currently beneath the cursor |'
  prefs: []
  type: TYPE_TB
- en: '| Backspace | Delete the character to the left of the cursor |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-_ | Undo previous change (can be repeated to undo all previous changes)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-a | Move the cursor to the start of the line |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-e | Move the cursor to the end of the line |'
  prefs: []
  type: TYPE_TB
- en: '| Meta-f or Esc then f | Move cursor forward one word |'
  prefs: []
  type: TYPE_TB
- en: '| Meta-b or Esc then b | Move the cursor back one word |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-l | Clear the screen of everything except the current command |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-k | Delete to the end of the line from the current cursor position |'
  prefs: []
  type: TYPE_TB
- en: '| Meta-d or Esc then d | Delete to end of the current word |'
  prefs: []
  type: TYPE_TB
- en: '| Meta-DEL or Esc then DEL | Delete beginning to the current word |'
  prefs: []
  type: TYPE_TB
- en: '| Ctrl-w | Delete from the current cursor position to the previous white space
    |'
  prefs: []
  type: TYPE_TB
- en: Table 8-1
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 Working with the Shell History
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to command-line editing features, the Bash shell provides command-line
    history support. A list of previously executed commands may be viewed using the
    history command:'
  prefs: []
  type: TYPE_NORMAL
- en: $ history
  prefs: []
  type: TYPE_NORMAL
- en: 1 ps
  prefs: []
  type: TYPE_NORMAL
- en: 2 ls
  prefs: []
  type: TYPE_NORMAL
- en: 3 ls –l /
  prefs: []
  type: TYPE_NORMAL
- en: 4 ls
  prefs: []
  type: TYPE_NORMAL
- en: 5 man pwd
  prefs: []
  type: TYPE_NORMAL
- en: 6 man apropos
  prefs: []
  type: TYPE_NORMAL
- en: In addition, Ctrl-p (or up arrow) and Ctrl-n (or down arrow) may be used to
    scroll back and forth through previously entered commands. Finally, when the desired
    command from the history is displayed, press the Enter key to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to enter the ‘!’ character, followed by the first few characters
    of the command to be repeated, followed by the Enter key.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 Filename Shorthand
  prefs: []
  type: TYPE_NORMAL
- en: 'Many shell commands take one or more filenames as arguments. For example, to
    display the content of a text file named list.txt, the cat command would be used
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: $ cat list.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the content of multiple text files could be displayed by specifying
    all the file names as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: $ cat list.txt list2.txt list3.txt list4.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of typing in each name, pattern matching can be used to specify all
    files with names matching certain criteria. For example, the ‘*’ wildcard character
    can be used to simplify the above example:'
  prefs: []
  type: TYPE_NORMAL
- en: $ cat *.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'The above command will display the content of all files ending with a .txt
    extension. This could be further restricted to any file names beginning with list
    and ending in .txt:'
  prefs: []
  type: TYPE_NORMAL
- en: $ cat list*.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'Single character matches may be specified using the ‘?’ character:'
  prefs: []
  type: TYPE_NORMAL
- en: $ cat list?.txt
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 Filename and Path Completion
  prefs: []
  type: TYPE_NORMAL
- en: Rather than typing in a complete file name or path or using pattern matching
    to reduce the amount of typing, the shell provides the filename completion feature.
    To use filename completion, enter the first few characters of the file or path
    name and then press the Esc key twice. The shell will then complete the filename
    for you with the first file or path name in the directory that matches the characters
    you entered. To obtain a list of possible matches, press Esc = after entering
    the first few characters.
  prefs: []
  type: TYPE_NORMAL
- en: 8.9 Input and Output Redirection
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, many shell commands output information when executed.
    By default, this output goes to a device file named stdout which is essentially
    the terminal window or console in which the shell is running. Conversely, the
    shell takes input from a device file named stdin, which by default is the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output from a command can be redirected from stdout to a physical file on the
    file system using the ‘>’ character. For example, to redirect the output from
    an ls command to a file named files.txt, the following command would be required:'
  prefs: []
  type: TYPE_NORMAL
- en: $ ls *.txt > files.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon completion, files.txt will contain the list of files in the current directory.
    Similarly, the contents of a file may be fed into a command in place of stdin.
    For example, to redirect the contents of a file as input to a command:'
  prefs: []
  type: TYPE_NORMAL
- en: $ wc –l < files.txt
  prefs: []
  type: TYPE_NORMAL
- en: The above command will display the number of lines in the files.txt file.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that the ‘>’ redirection operator creates a new file
    or truncates an existing file when used. To append to an existing file, use the
    ‘>>’ operator:'
  prefs: []
  type: TYPE_NORMAL
- en: $ ls *.dat >> files.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to standard output, the shell also provides standard error output
    using stderr. While output from a command is directed to stdout, any error messages
    generated by the command are directed to stderr. This means that if stdout is
    directed to a file, error messages will still appear in the terminal. This is
    generally the desired behavior, though stderr may also be redirected if desired
    using the ‘2>’ operator:'
  prefs: []
  type: TYPE_NORMAL
- en: $ ls dkjfnvkjdnf 2> errormsg
  prefs: []
  type: TYPE_NORMAL
- en: On completion of the command, an error reporting that the file named dkjfnvkjdnf
    could not be found will be contained in the errormsg file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both stderr and stdout may be redirected to the same file using the &> operator:'
  prefs: []
  type: TYPE_NORMAL
- en: $ ls /etc dkjfnvkjdnf &> alloutput
  prefs: []
  type: TYPE_NORMAL
- en: On completion of execution, the alloutput file will contain both a listing of
    the contents of the /etc directory and the error message associated with the attempt
    to list a non-existent file.
  prefs: []
  type: TYPE_NORMAL
- en: 8.10 Working with Pipes in the Bash Shell
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to I/O redirection, the shell also allows output from one command
    to be piped directly as input to another command. A pipe operation is achieved
    by placing the ‘|’ character between two or more commands on a command line. For
    example, to count the number of processes running on a system, the output from
    the ps command can be piped through to the wc command:'
  prefs: []
  type: TYPE_NORMAL
- en: $ ps –ef | wc –l
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no limit to the number of pipe operations that can be performed on
    a command line. For example, to find the number of lines in a file that contain
    the name Smith:'
  prefs: []
  type: TYPE_NORMAL
- en: $ cat namesfile | grep Smith | wc –l
  prefs: []
  type: TYPE_NORMAL
- en: 8.11 Configuring Aliases
  prefs: []
  type: TYPE_NORMAL
- en: 'As you gain proficiency with the shell environment, you will likely frequently
    issue commands with the same arguments. For example, you may often use the ls
    command with the l and t options:'
  prefs: []
  type: TYPE_NORMAL
- en: $ ls –lt
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce the amount of typing involved in issuing a command, it is possible
    to create an alias that maps to the command and arguments. For example, to create
    an alias such that entering the letter l will cause the ls –lt command to be executed,
    the following statement would be used:'
  prefs: []
  type: TYPE_NORMAL
- en: $ alias l="ls –lt"
  prefs: []
  type: TYPE_NORMAL
- en: Entering l at the command prompt will now execute the original statement.
  prefs: []
  type: TYPE_NORMAL
- en: 8.12 Environment Variables
  prefs: []
  type: TYPE_NORMAL
- en: 'Shell environment variables provide temporary storage of data and configuration
    settings. The shell itself sets up several environment variables that the user
    may change to modify the behavior of the shell. A listing of currently defined
    variables may be obtained using the env command:'
  prefs: []
  type: TYPE_NORMAL
- en: $ env
  prefs: []
  type: TYPE_NORMAL
- en: SSH_CONNECTION=192.168.0.19 61231 192.168.0.28 22
  prefs: []
  type: TYPE_NORMAL
- en: MODULES_RUN_QUARANTINE=LD_LIBRARY_PATH
  prefs: []
  type: TYPE_NORMAL
- en: LANG=en_US.UTF-8
  prefs: []
  type: TYPE_NORMAL
- en: HISTCONTROL=ignoredups
  prefs: []
  type: TYPE_NORMAL
- en: HOSTNAME=demo-pc.ebookfrenzy.com
  prefs: []
  type: TYPE_NORMAL
- en: XDG_SESSION_ID=15
  prefs: []
  type: TYPE_NORMAL
- en: MODULES_CMD=/usr/share/Modules/libexec/modulecmd.tcl
  prefs: []
  type: TYPE_NORMAL
- en: USER=demo
  prefs: []
  type: TYPE_NORMAL
- en: ENV=/usr/share/Modules/init/profile.sh
  prefs: []
  type: TYPE_NORMAL
- en: SELINUX_ROLE_REQUESTED=
  prefs: []
  type: TYPE_NORMAL
- en: PWD=/home/demo
  prefs: []
  type: TYPE_NORMAL
- en: HOME=/home/demo
  prefs: []
  type: TYPE_NORMAL
- en: SSH_CLIENT=192.168.0.19 61231 22
  prefs: []
  type: TYPE_NORMAL
- en: SELINUX_LEVEL_REQUESTED=
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most useful environment variable is PATH. This defines the directories
    in which the shell will search for commands entered at the command prompt and
    the order in which it will do so. The PATH environment variable for a user account
    on a newly installed Ubuntu system will likely be configured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: $ echo $PATH
  prefs: []
  type: TYPE_NORMAL
- en: /home/demo/.local/bin:/home/demo/bin:/usr/share/Modules/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful variable is HOME, which specifies the current user’s home directory.
    If, for example, you wanted the shell to also look for commands in the scripts
    directory located in your home directory, you would modify the PATH variable as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: $ export PATH=$PATH:$HOME/scripts
  prefs: []
  type: TYPE_NORMAL
- en: 'The current value of an existing environment variable may be displayed using
    the echo command:'
  prefs: []
  type: TYPE_NORMAL
- en: $ echo $PATH
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create your own environment variables using the export command. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: $ export DATAPATH=/data/files
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful trick to assign the output from a command to an environment variable
    involves using back quotes (`) around the command. For example, to assign the
    current date and time to an environment variable called NOW:'
  prefs: []
  type: TYPE_NORMAL
- en: $ export NOW=`date`
  prefs: []
  type: TYPE_NORMAL
- en: $ echo $NOW
  prefs: []
  type: TYPE_NORMAL
- en: Wed Mar 29 12:39:20 PM EDT 2023
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are environment variables or alias settings that need to be configured
    each time you enter the shell environment, they may be added to a file in your
    home directory named .bashrc. For example, the following .bashrc file is configured
    to set up the DATAPATH environment variable and an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: .bashrc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Source global definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: if [ -f /etc/bashrc ]; then
  prefs: []
  type: TYPE_NORMAL
- en: . /etc/bashrc
  prefs: []
  type: TYPE_NORMAL
- en: fi
  prefs: []
  type: TYPE_NORMAL
- en: User specific environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PATH="$HOME/.local/bin:$HOME/bin:$PATH"
  prefs: []
  type: TYPE_NORMAL
- en: export PATH
  prefs: []
  type: TYPE_NORMAL
- en: 'Uncomment the following line if you don’t like systemctl’s auto-paging feature:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: export SYSTEMD_PAGER=
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User specific aliases and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: export DATAPATH=/data/files
  prefs: []
  type: TYPE_NORMAL
- en: alias l="ls -lt"
  prefs: []
  type: TYPE_NORMAL
- en: 8.13 Writing Shell Scripts
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have focused exclusively on the interactive nature of the Bash shell.
    By interactive, we mean manually entering commands individually and executing
    them at the prompt. In fact, this is only a small part of what the shell is capable
    of. Arguably one of the most powerful aspects of the shell involves the ability
    to create shell scripts. Shell scripts are text files containing statement sequences
    that can be executed within the shell environment to perform tasks. In addition
    to the ability to execute commands, the shell provides many programming constructs,
    such as for and do loops and if statements, that you might reasonably expect to
    find in a scripting language.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, a detailed overview of shell scripting is beyond the scope of
    this chapter. However, many books and web resources dedicated to shell scripting
    do the subject much more justice than we could ever hope to achieve here. In this
    section, therefore, we will only be providing a very small taste of shell scripting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in creating a shell script is to create a file (for this example,
    we will name it simple.sh) and add the following as the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '#!/bin/sh'
  prefs: []
  type: TYPE_NORMAL
- en: 'The #! is called the “shebang” and is a special sequence of characters indicating
    that the path to the interpreter needed to execute the script is the next item
    on the line (in this case, the sh executable located in /bin). This could equally
    be, for example, /bin/csh or /bin/ksh if either were the interpreter you wanted
    to use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to write a simple script:'
  prefs: []
  type: TYPE_NORMAL
- en: '#!/bin/sh'
  prefs: []
  type: TYPE_NORMAL
- en: for i in *
  prefs: []
  type: TYPE_NORMAL
- en: do
  prefs: []
  type: TYPE_NORMAL
- en: echo $i
  prefs: []
  type: TYPE_NORMAL
- en: done
  prefs: []
  type: TYPE_NORMAL
- en: 'All this script does is iterate through all the files in the current directory
    and display the name of each file. This script may be executed by passing the
    name of the script through as an argument to sh:'
  prefs: []
  type: TYPE_NORMAL
- en: $ sh simple.sh
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the file executable (thereby negating the need to pass it through to
    the sh command), the chmod command can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: $ chmod +x simple.sh
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the execute bit has been set on the file’s permissions, it may be executed
    directly. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: $ ./simple.sh
  prefs: []
  type: TYPE_NORMAL
- en: 8.14 Summary
  prefs: []
  type: TYPE_NORMAL
- en: We briefly toured the Bash shell environment in this chapter of Ubuntu Essentials.
    In the world of graphical desktop environments, it is easy to forget that an operating
    system’s true power and flexibility can often only be utilized by dropping down
    below the user-friendly desktop interface and using a shell environment. Moreover,
    familiarity with the shell is necessary to administer and maintain server-based
    systems that do not have the desktop installed or when attempting to repair a
    system damaged to the point that the desktop or Cockpit interface will no longer
    launch.
  prefs: []
  type: TYPE_NORMAL
- en: The shell’s capabilities go far beyond the areas covered in this chapter. If
    you are new to the shell, we strongly encourage you to seek additional resources.
    Once familiar with the concepts, you will quickly find that it is quicker to perform
    many tasks using the shell in a terminal window than to wade through menus and
    dialogs on the desktop.
  prefs: []
  type: TYPE_NORMAL
