["```\n    # cat /proc/sys/net/ipv4/icmp_echo_ignore_all\n    0\n    ```", "```\n    # echo \"1\" > /proc/sys/net/ipv4/icmp_echo_ignore_all\n    ```", "```\n    # cat /proc/sys/net/ipv4/icmp_echo_ignore_all\n    1\n    ```", "```\n    sysctl command with the –w option to enable ping:\n\n    ```", "```\n\n    Confirm that `ping` support is already enabled:\n    ```", "```\n        # sysctl command with the -p option to apply the setting:\n\n        ```", "```\n\n        Confirm the `ping` behavior change:\n        ```", "```\n# sysctl –a\n```", "```\n# ps aux\n```", "```\n# top\n```", "```\n# free\n```", "```\n$ gnome-system-monitor\n```", "```\n# dnf install sysstat\n```", "```\n    # ps ax --format pid,%cpu,cmd --sort -%cpu\n    ```", "```\n    # ps auxf | grep \"[h]ttpd\"\n    # ps ax --format pid,%cpu,cmd --sort -%cpu | grep \"[h]ttpd\"\n    ```", "```\n    # top -p 851,876,881,910\n    ```", "```\n    # pidstat -p 851,876,881,910 1 1\n    ```", "```\n    # ps axo pid,pri,rtprio,ni,cls,comm | grep -e \"PID\" -e \"[h]ttpd\"\n    ```", "```\n    # chrt -p [PID]\n    ```", "```\n    # systemctl stop httpd\n    # chrt -f 38 /usr/sbin/httpd\n    ```", "```\n    # vim /etc/systemd/system/httpd.service.d/10-scheduler.conf\n    [Service]\n    CPUSchedulingPolicy=rr\n    CPUSchedulingPriority=10\n    ```", "```\n# systemctl daemon-reload\n```", "```\n    # systemctl restart httpd\n    ```", "```\n# ps -o pid,vsz,rss,comm -C httpd\n```", "```\n    # systemctl set-property sshd.service MemoryLimit=1G\n    ```", "```\n# free –m\n```", "```\n# vmstat --unit M 1\n```", "```\n# sysctl vm.overcommit_memory\n# sysctl vm.overcommit_ratio\n```", "```\n# lsblk -fp\n```", "```\n$ df –h\n```", "```\n# iostat\n```", "```\n# iostat -dyz  1 3\n```", "```\n    # wipefs /dev/sdc\n    ```", "```\n    # parted /dev/sdc print\n    ```", "```\n    # parted /dev/sdc\n    ```", "```\n    # udevadm settle\n    ```", "```\n    # mkswap /dev/sdc1\n    ```", "```\n    # free -m\n    ```", "```\n    # swapon /dev/sdc1\n    ```", "```\n    # lsblk -fp\n    ```", "```\nUUID=6f53144d-fe12-4fc3-bb69-6469012592dc  swap  swap  defaults 0 0\n```", "```\n# systemctl enable --now sysstat\n```", "```\n    # sar –u 1 3\n    ```", "```\n    # sar –q –f /var/log/sa17\n    ```", "```\n# log files to analyze, either by period or by a known event. A copy of the file can be used to generate the performance graphs. Follow these steps:\n\n1.  Use the **sar** command to redirect the contents of the log files to a text file:\n\n    ```", "```\n\n     2.  Use the **java** command to open the **ksar** tool:\n\n    ```", "```\n\n![Figure 11.42 – The ksar tool’s main window](img/B19121_11_42.jpg)\n\nFigure 11.42 – The ksar tool’s main window\nLoad the `data` file created from the `log` files to generate the system performance graphs.\n\n1.  From the **Data** menu, click on **Load from a** **text file…**:\n\n![Figure 11.43 – The Load from a text file… option](img/B19121_11_43.jpg)\n\nFigure 11.43 – The Load from a text file… option\nThe file selection window will open.\n\n1.  Navigate to the directory where the generated file resides:\n\n![Figure 11.44 – Selecting the sar file](img/B19121_11_44.jpg)\n\nFigure 11.44 – Selecting the sar file\nSelect the `sar` file and click **Open**.\nThe file will take some time to load, depending on its size and the amount of data to analyze.\n\n1.  After loading finishes, the window will display the data column for filtering by resource:\n\n![Figure 11.45 – Data analyzed window](img/B19121_11_45.jpg)\n\nFigure 11.45 – Data analyzed window\nNavigate to **NIC** to review the network behavior.\n\n1.  Click **Interfaces traffic** and then **eth0**:\n\n![Figure 11.46 – NIC performance graph](img/B19121_11_46.jpg)\n\nFigure 11.46 – NIC performance graph\nNote\nOn your system, the device may be different. Please confirm the device information that we will analyze.\nThis way, the behavior could be better visualized.\nLet’s export these graphs.\n\n1.  Click on the **Export** menu and then **Export** **to PDF…**:\n\n![Figure 11.47 – The Export menu](img/B19121_11_47.jpg)\n\nFigure 11.47 – The Export menu\nThe window for selecting the data to export will open.\n\n1.  Select the data to export and click the **OK** button:\n\n![Figure 11.48 – Selecting data to export](img/B19121_11_48.jpg)\n\nFigure 11.48 – Selecting data to export\nName the file, as is best practice, with the system’s name, and save it in the directory of your choice.\nNote\nYou can get the export report from our GitHub repository at [https://github.com/PacktPublishing/Fedora-Linux-System-Administration/blob/main/chapter11/workstation.packt.lab.pdf](https://github.com/PacktPublishing/Fedora-Linux-System-Administration/blob/main/chapter11/workstation.packt.lab.pdf).\nThis concludes the best practices for improving system performance. In the next chapter, we will talk about the security provided by Fedora Linux.\nSummary\nIn this chapter, we provided an overview of best practices in system tuning. Beyond configurations, we looked at the tools that are available in Fedora Linux to analyze system behavior.\nSystem tuning, in most cases, is performed after a failure incident. It is at this point that it gets confused with troubleshooting. System tuning is about more than resolving a failure – it is about collecting metrics and performing analysis using the right tools.\nFirst, we learned how to change the kernel tunables using the `sysctl` command to understand their origin and the scope of these changes in their original configuration.\nThen, we learned how to use the system tools and utilities, including the `ps`, `top`, and `free` commands. We also covered the suite of utilities provided by installing the `sysstat` package, including the `mpstat`, `iostat`, `pidstat`, and `sar` commands.\nAfter that, we briefly reviewed the *units of measurement*, which cause failures when sizing resources, particularly in storage.\nFinally, we touched on network tuning and discussed the limitations of the operating system. While doing so, we learned how to use `ksar`, a tool that helps us graph the metrics collected by `sysstat` when it’s running as a service.\nIn the next chapter, we will take a walk through the hardened security layer offered by Fedora Linux: SELinux. In most cases, this is not activated due to ignorance of how it works. We will clarify how it operates so that we can implement it in our systems.\n\n```"]