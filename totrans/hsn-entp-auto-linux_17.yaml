- en: Using CIS Benchmarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When implementing Linux in the Enterprise, security is paramount. There is no
    one step that can be taken to achieve the nirvana of a truly *secure* environment—rather,
    the approach is an amalgamation of disparate steps that come together to build
    an environment that is as safe and secure as it can be. Indeed, this statement
    brings us to another important point—security is a moving target. As just one
    example, SSLv2 was considered to be secure and was used to secure websites across
    the internet for many years. Then came the DROWN attack in 2016, which rendered
    it insecure. Thus, a server secured for internet traffic (perhaps a frontend web
    server) in 2015 would have, at the time, been considered secure. However, in 2017,
    it would have been considered highly vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: Linux itself has always been considered a secure operating system, though its
    high and increasing levels of adoption has seen attacks on the rise. Throughout
    this book, we have advocated, at a high level, good security practices in the
    design of your Linux estate, for example, not installing unnecessary services
    on your base operating system image. Nonetheless, there is much more we can do
    to make our Linux environment more secure and, in this chapter, we will explore
    the ways in which standards have been developed to ensure the security of Linux
    environments. Specifically, we will consider the use of the CIS Benchmarks, along
    with some practical examples of how to apply them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, the following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CIS Benchmarks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying security policy wisely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripted deployment of server hardening
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter includes examples based on the following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: CentOS 7.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To run through these examples, you will need access to two servers or virtual
    machines running the operating system listed previously, along with Ansible. Note
    that the examples given in this chapter may be destructive in nature (for example,
    they delete files and make changes to server configuration) and, if run as shown,
    are only intended to be run in an isolated test environment.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are satisfied that you have a safe environment to operate in, let's
    get started with routine system maintenance with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: All example code discussed in this chapter is available from GitHub at the following
    URL: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter13](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CIS Benchmarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we delve into what a CIS Benchmark actually consists of, let's take a
    look at why they exist and, conceptually, what they are.
  prefs: []
  type: TYPE_NORMAL
- en: What is a CIS Benchmark?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing servers, regardless of their operating system, is a big task. It requires
    being constantly up to date with new attack vectors and vulnerabilities as they
    are discovered (see the mention of the DROWN attack and SSLv2 in the introduction
    to this chapter). Some things are well-known and considered *normal*. For example,
    on Linux, it is generally frowned upon to ever log in as root—instead, it is almost
    universally recognized that each individual user should have their own user account
    and should perform all commands requiring elevated permissions using the `sudo`
    command. Thus, some Linux distributions such as Ubuntu come with remote root access
    disabled by default. Others, such as CentOS, do not. Even between these two key
    distributions commonly found in the enterprise, you know that, for one, you need
    to actively turn off remote root SSH access and, for the other, you just need
    to check that it is turned off.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, defining a security policy goes far deeper than whether root access
    is allowed over SSH. Over the years, individuals build up a wealth of knowledge
    about what works and, perhaps by learning the hard way, what doesn't. However,
    the security of your environment should not be defined by how experienced your
    system administrators are. Rather, there should be some defined standard for how
    to best secure a server to prevent most of the common attacks, and also to ensure
    that a suitable level of information is logged in the case that an audit is ever
    required to find the root cause of an event.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the concept of the CIS Benchmark comes in. Many people are familiar
    with the concept of a benchmark as a performance test (that is, speed). However,
    whether your server is secure or not is something that can be tested by looking
    for certain criteria, and thus the CIS Benchmark exists. Quoting directly from
    the **Community for Internet Security** (**CIS** for short) website:'
  prefs: []
  type: TYPE_NORMAL
- en: '"CIS Benchmarks are developed through a unique consensus-based process comprised
    of cybersecurity professionals and subject matter experts around the world."'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, these benchmarks can be considered an amalgamation of best practices from
    industry professionals. Further, they are regularly updated and so can be used
    by engineers and administrators to keep abreast of best practices when it comes
    to securing a server.
  prefs: []
  type: TYPE_NORMAL
- en: It should, of course, be noted that there are other security standards out there
    that go to even greater depths than the CIS Benchmark, for example, FedRAMP and
    NSA security requirements. It would be impossible to go into detail of all the
    different profiles available within this book, and so we will focus on the CIS
    Benchmark, which is freely available (in exchange for some personal information)
    and is also well regarded.
  prefs: []
  type: TYPE_NORMAL
- en: That this book focuses on the CIS Benchmarks should not be taken as an implicit
    statement that you should implement these on your server estate in order for it
    to be secure. It is the duty of each and every reader to ensure they understand
    their own security requirements and to implement the correct ones accordingly.
    In this chapter, we work through the use of CIS Benchmarks as a worked example
    of server hardening to a given standard.
  prefs: []
  type: TYPE_NORMAL
- en: Also of note is that the CIS Benchmarks are divided by technology. For example,
    there is a CIS Benchmark for both Red Hat Enterprise Linux 7 and Ubuntu Server,
    which you can apply to your Enterprise Linux estate. However, these focus on securing
    the base operating system, and if you install an application layer on top of it,
    then you must apply the appropriate security policy for that as well.
  prefs: []
  type: TYPE_NORMAL
- en: There are CIS Benchmarks for more than 140 technologies, including common Linux
    services such as nginx, Apache, and PostgreSQL. Thus, if you are building an internet-facing
    web server, it would make sense to apply both the operating system benchmark and
    then the appropriate one for the chosen web server.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a bespoke application layer, or indeed are simply using a technology
    not listed on the CIS website, do not despair—secure the underlying operating
    system using the appropriate benchmark and then apply security practices in the
    best way you can. Often, there is good advice on the internet, but figuring this
    out is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: A full list of the technologies for which there are CIS Benchmarks can be found
    here: [https://www.cisecurity.org/cis-benchmarks/](https://www.cisecurity.org/cis-benchmarks/).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have obtained the security benchmark for your chosen operating system,
    it is time to consider the application of it. Before we get this far, though,
    in the next section of this chapter, we will explore in greater detail the contents
    of a CIS Benchmark for the Linux operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring CIS Benchmarks in detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a practical example to explore CIS Benchmarks in greater detail by
    looking at the one for RHEL 7\. At the time of writing, this is on release version
    2.2.0 and consists of 386 pages! Thus, immediately we can see that implementing
    this benchmark is unlikely to be a trivial activity.
  prefs: []
  type: TYPE_NORMAL
- en: As you explore the document, you will find that the section of most interest
    to us—the *Recommendations* section—is divided into subsections. Each of these
    focuses on a specific area of security within the operating system. At the time
    of writing, *section 1* is all about the initial setup of the operating system;
    parameters and configuration likely to be applied at build time. S*ection 2* is
    all about securing common services that might be installed by default on a RHEL
    7 server. *Section 3* deals with network configuration, while s*ection 4* goes
    into detail on your logging and audit logging setup to ensure you are capturing
    the requisite amount of data during daily use. This is to ensure you can audit
    your servers and find out what happened if you are unfortunate enough to suffer
    a breach or an outage. *Section 5* considers access to your server and authentication
    (this is where you will find SSH server security mentioned—in fact, you will see
    that our example of disabling remote root logins is benchmark 5.2.8 in version
    2.2.0 of the document). Finally, *section 6* is entitled *System Maintenance* and
    is intended to be run not once, but regularly, to ensure the integrity of the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we have discussed previously in this book that it is possible for
    anyone with root privileges to change core system configuration, and thus it is
    recommended that all of the benchmarks be run (or at least checked) on a regular
    basis to ensure compliance with the original policy.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore this across the next two chapters of this book; however, for
    now, let's return to furthering our understanding of the CIS Benchmark itself.
    As you look into each recommendation, you will notice that each has a level associated
    with it and is either *Scored* or *Not Scored* (this is stated in the title of
    each benchmark).
  prefs: []
  type: TYPE_NORMAL
- en: Each of these benchmarks are intended to contribute to a final report or scoring
    of a system as part of a compliance check—and recommendations that are scored
    quite literally contribute to the final score. Thus, if your system meets the
    check, then the final score is increased—however, if it is not met, the final
    score is decreased. Those marked as *Not Scored* have no bearing on the final
    score at all. In other words, you are not marked down for failing to implement
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This, of course, does not mean they are any less important to consider. By
    way of example, let''s consider benchmark 3.7 of the version 2.2.0 RHEL 7 benchmark,
    which is entitled *Ensure wireless interfaces are disabled*. The rationale between
    each benchmark is given in the details of the benchmark, and this one states the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"If wireless is not to be used, wireless devices can be disabled to reduce
    the potential attack surface."'
  prefs: []
  type: TYPE_NORMAL
- en: This is a logical approach—we know that if your device has a wireless interface,
    it should be disabled unless it is in use. In addition, wireless security protocols
    have been historically broken, just as SSLv2 was, and thus, in the long term,
    wireless network communication might not be considered to be truly secure. Nonetheless,
    on a corporate laptop running RHEL 7, you cannot guarantee that it will be connected
    to a wired network connection. Wireless networking might be the only option and,
    in this instance, you would need to leave it turned on.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the CIS Benchmark cannot make this decision for you—only you can
    know whether your system needs to have its wireless network adapters enabled (if
    present), and so it is reasonable that this is a non-scorable item.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, our old friend benchmark 5.2.8 (disabling remote root SSH access)
    is scored as there should be no rational reason for enabling this in an enterprise
    environment. Thus, we would expect our system to be scored down if this benchmark
    could not be met.
  prefs: []
  type: TYPE_NORMAL
- en: Each benchmark has details on how to test for the presence of the condition
    or configuration mentioned, along with the details on how to apply the desired
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these details, you will also note that each benchmark has a level
    associated with it that can be either 1 or 2\. In each case, for RHEL 7, you will
    see that these levels are applied to two different scenarios—the use of RHEL 7
    as a server and as a workstation. Again, this makes sense when we delve into the
    meaning of these levels.
  prefs: []
  type: TYPE_NORMAL
- en: Level 1 is intended to be a sensible security baseline for you to apply to your
    environment to reduce the attack surface. It is not intended to have an extensive
    impact on the day-to-day business usage of your Linux environment, and so level
    1 benchmarks are the less intrusive ones to implement.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, level 2 benchmarks are offered to provide a much more rigorous
    level of security, and are highly likely to have an impact on the day-to-day usage
    of your environment.
  prefs: []
  type: TYPE_NORMAL
- en: If we look again at benchmark 3.7, we will see that it is categorized as level
    1 for servers and level 2 for workstations. This makes sense—a server is unlikely
    to have a wireless network adapter, and even less likely to be using it, even
    if present, thus disabling it has little or no impact on the day-to-day usage
    of the server. However, a RHEL 7 laptop would become a lot less portable if benchmark
    3.7 was implemented on it, and so the level 2 categorization warns us of this.
    Imagine having a laptop and not being able to use it on a wireless network—this
    is a concept that, to many, is unfeasible in this day and age!
  prefs: []
  type: TYPE_NORMAL
- en: Benchmark 5.2.8 is considered level 1 for both server and workstation because
    it is already considered good practice not to use the root account for day-to-day
    operations—thus, disabling access to it over SSH should not have any impact on
    a day-to-day basis.
  prefs: []
  type: TYPE_NORMAL
- en: In an ideal world, you should read and understand all benchmarks before you
    apply them in case they have an impact on your way of doing things—for example,
    I still come across systems that make use of the root account over SSH for scripted
    operations, and while my first task is normally to rectify this, if I were to
    blindly apply the CIS Benchmark to these systems, I would break an otherwise working
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: However, accepting that anyone who manages an Enterprise Linux environment is
    incredibly busy, you could be forgiven for thinking that you could just apply
    the scored level 1 benchmarks to your systems. Indeed, this would give you a reasonable
    security baseline while incurring a relatively low risk—yet there is no substitute
    for being thorough. In the next section of this chapter, we will look in greater
    detail at how to wisely select benchmarks without causing issues in your environment!
  prefs: []
  type: TYPE_NORMAL
- en: Applying security policy wisely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we had begun to explore in the previous section, each CIS Benchmark has
    a level and scoring associated with it. The level is of particular concern to
    us as, while we wish to secure our systems as effectively as possible, we would
    not wish to break any running systems. For this reason, it is highly advisable
    to apply the benchmarks in an isolated test environment and test your applications
    before deploying them to a production environment. Indeed, if the application
    of a benchmark breaks a given system, the following process should be executed
    in the enterprise to resolve it:'
  prefs: []
  type: TYPE_NORMAL
- en: Establish which benchmark caused the issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine which internal systems were affected by the benchmark.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide whether the internal systems can be changed to work with the benchmarks
    (for example, use an unprivileged account over SSH rather than root).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the changes to the internal systems and apply the benchmark universally
    or (only if there is a good reason to) make an exception for that benchmark and
    record it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CIS Benchmarks could even break your Ansible automation—the simplest example
    being that you are using the root account to perform your automation tasks over,
    and you disable this as part of your CIS Benchmark deployment. In this instance,
    you would find Ansible locked out of all of your systems and, in the worst case,
    you would have to manually modify each server to reinstate Ansible access.
  prefs: []
  type: TYPE_NORMAL
- en: Although we can't go through the benchmarks one by one in this chapter, in the
    following subsections, we will explore some of the relevant examples to look out
    for. It is hoped this will give you enough information to review the benchmark
    for your chosen version of Linux, and then make informed decisions on what security
    policies are in the best interests of your environment.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue with our example of using the RHEL 7 benchmark version 2.2.0\.
    However, most of what we describe here will be applicable to other Linux platforms
    too. Configuration file paths and even log file paths might vary, but these will
    be detailed in the relevant CIS Benchmark for your operating system, so be sure
    to download the benchmark that is most relevant to you.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have considered the overall principles of security policy application,
    we will dive into some specific examples, starting with the SELinux policy in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the SELinux security policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Section 1.6.1 of the RHEL 7 benchmark concerns the implementation of SELinux
    and consists of checks to ensure SELinux is in enforcing mode rather than disabled
    at some level. You will note that these checks are all level 2 benchmarks, meaning
    they could break existing systems.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling and applying SELinux is a very good idea on operating systems that
    support it, yet even at the time of writing there are many Linux applications
    that do not work with it and whose installation instructions state that SELinux
    must be disabled for the application to function. This, of course, is not ideal
    and instead you should create an SELinux policy that allows your application stack
    to work without the need to disable it.
  prefs: []
  type: TYPE_NORMAL
- en: Not all enterprises will have the skill set of time to allow this to be completed,
    though, and so some careful consideration needs to be given to this set of benchmarks—in
    short, it should be applied if at all possible, but exceptions may be required.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with Ubuntu, the same logic should be applied to AppArmor,
    which is enabled by default on Ubuntu Server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section of this chapter, we will take a look at how the CIS Benchmarks
    affect the way filesystems are mounted on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting of filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All filesystems in Linux must be mounted before they can be used—this is quite
    simply the mapping of block devices such as a partition on a disk to a path. To
    most users, this is transparent and happens at boot time, but to those responsible
    for configuring systems, it needs some attention. For example, the `/tmp` filesystem
    is usually writable to all users, and so it is desirable to not let people execute
    files from this directory as they could put any arbitrary binary in there to be
    run by themselves or someone else. Thus, this filesystem is often mounted with
    the `noexec` flag to achieve exactly this.
  prefs: []
  type: TYPE_NORMAL
- en: Changing mount options for partitions (and indeed partition structure) can be
    problematic on machines that have already been deployed. In addition, many cloud
    platforms feature a flat filesystem structure and, as such, the preceding example
    of `/tmp` may not be achievable as it cannot be mounted separately from the `root`
    partition. As a result, I recommend that you factor this part of the CIS Benchmark
    into your server (or image) build process and create exclusions for public cloud
    platforms where required.
  prefs: []
  type: TYPE_NORMAL
- en: The benchmarks in *section 1.1 *of the CIS Benchmark (entitled *Filesystem Configuration*)
    concern exactly these kinds of details and, again, these will need to be tailored
    to your environment. For example, benchmark 1.1.1.8 recommends disabling the ability
    to mount FAT filesystems, and *section 1.1.5* recommends disabling binary execution
    on `/tmp`, as discussed previously. These are both scored benchmarks and, at the
    time of writing, there should be little need to use or mount FAT volumes or execute
    files from `/tmp`. However, in some legacy environments, this could still be required
    and so this should be applied with some care.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there are many recommendations around having separate filesystems
    for important paths such as `/tmp` and `/var`, and also special mount options.
    All of these will work in a large number of cases but, again, it would be too
    bold to state that this will work for everyone, especially in preexisting environments,
    and so these should be applied but with an understanding of the environmental
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Having looked at the implications of the CIS Benchmarks on how filesystems are
    mounted, we will proceed to look at the recommendations around intrusion detection
    using file checksumming.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Advanced Intrusion Detection Environment (AIDE)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Benchmark 1.3.1 concerns the installation of **Advanced Intrusion Detection
    Environment** (**AIDE**)—a modern replacement for the venerable **Tripwire** utility
    that can scan the filesystem and checksum all the files, thus providing a reliable
    way of detecting modifications to the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: On the face of it, installing and using AIDE is a very good idea—however, if
    you have an environment with 100 machines in it and you update all of them, you
    will get 100 reports, each containing details of a large number of file changes.
    There are other solutions to this problem, including the open source OSSEC project
    ([https://www.ossec.net/](https://www.ossec.net/)), but this is not checked for
    as part of the CIS Benchmark and so it is left for you to decide what the right
    solution is for your enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: This, of course, is not to say that AIDE should not be used—far from it. Rather,
    it is to say that, if you choose to use AIDE, make sure you have processes in
    place to process and understand the reports, and to ensure that you can distinguish
    false positives (for example, a change in the checksum of a binary due to a package
    update) from genuinely malicious and unexpected modifications (for example, `/bin/ls`
    changes even though no package update has been performed).
  prefs: []
  type: TYPE_NORMAL
- en: Having looked at whether AIDE is a viable tool to install on your Linux infrastructure,
    we will proceed to look at how the CIS Benchmarks impact the default configuration
    of services at boot time.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CIS Service benchmarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Section 2.2 of the benchmark details a number of scored level 1 benchmarks around
    services that are to be disabled. Again, the rationale behind this is that the
    attack surface should be minimized, and so, for example, `httpd` should not be
    running unless a server is intended to be a web server.
  prefs: []
  type: TYPE_NORMAL
- en: While logical in itself, a review of this section turns up a large number of
    services that could be vital for your environment, including `squid`, `httpd`,
    and `snmpd`. For all of these benchmarks, they should only be applied if it makes
    sense to do so. You would not turn off Apache on a web server, and neither would
    you disable `squid` on a proxy server.
  prefs: []
  type: TYPE_NORMAL
- en: However, good guidance is given with regard to these benchmarks about when they
    should be applied and, in the case of `snmpd`, there is even guidance on securing
    the service if your environment relies on this for monitoring purposes.
  prefs: []
  type: TYPE_NORMAL
- en: X Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Benchmark 2.2.2 goes as far as ensuring that the X Windows server is actually
    uninstalled from your systems. Most servers are headless and it would be possible
    to do this—however, you would not do this for a workstation or for a system that
    performs remote desktop functions.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to apply this benchmark to your servers, but only when you know it is
    safe to apply it.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing hosts by network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Benchmarks 3.4.2 and 3.4.3 ensure that `/etc/hosts.allow` and `/etc/hosts.deny`
    are configured—this means that, for all services that process these two files,
    only connections from networks that are allowed are actually processed.
  prefs: []
  type: TYPE_NORMAL
- en: This is generally a good idea—however, many organizations have good firewalls
    and some actually have policies of not allowing local firewalls on their servers
    because it complicates the process of debugging. If a connection is denied, the
    more firewalls you have, the more you have to check to find out where it was denied.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it is recommended you apply these two benchmarks in accordance with your
    corporate security policy.
  prefs: []
  type: TYPE_NORMAL
- en: Local firewalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The same applies for the benchmarks in *section 3.6* that concern the installation
    and configuration of iptables. Although this local firewall increases your level
    of server security, it is in contrast to many corporate security policies of having
    fewer, more centralized, firewalls rather than many localized ones. Apply these
    benchmarks in accordance with corporate policy.
  prefs: []
  type: TYPE_NORMAL
- en: Overall guidance on scoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will note that many of the benchmarks I have advised you to exercise caution
    over applying are actually scored. This brings us to a wider point regarding scoring—the
    aim of applying CIS Benchmarks is not to achieve a 100% score. Rather, it is to
    achieve the highest possible score that is right for your environment and enables
    your enterprise to function correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Scoring should instead be used to establish your own baseline—once you have
    worked through all benchmarks in the manner discussed in this chapter, you will
    know which are right for your enterprise and, hence, what your target score is.
  prefs: []
  type: TYPE_NORMAL
- en: Through a process of auditing the results of repeated applications of the benchmark,
    repeated scoring exercises can be performed to track overall environment compliance
    and drift over time. For example, if repeated audits show an ever-decreasing score,
    then you know you have a problem with regards to compliance, for the root cause
    must be established—whether that is users making unauthorized changes to systems,
    or even rolling out new servers that have not been correctly secured.
  prefs: []
  type: TYPE_NORMAL
- en: Either way, your CIS Benchmark score will become a useful tool in monitoring
    the compliance of your Linux estate with your security policy. In the next section
    of this chapter, we will explore scripted approaches to CIS Benchmark application
    and compliance.
  prefs: []
  type: TYPE_NORMAL
- en: Scripted deployment of server hardening
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have spent some time exploring the CIS Benchmarks and how they are intended
    to be worked with. Now, let us turn our attention to more practical matters—how
    to audit them and how to implement them. In this book, we have focused on Ansible
    as our chosen tool for automating such tasks, and indeed Ansible is an excellent
    solution for this purpose. With that said, of course, you will have noticed that
    the examples in the CIS Benchmark document itself are often shell commands or,
    in some cases, are simply statements regarding configuration lines that should
    exist (or not exist) in a given file.
  prefs: []
  type: TYPE_NORMAL
- en: In order to clearly explain the auditing and implementation of the CIS Benchmark
    on a Linux system, I have split the examples into two. In this part of this chapter,
    we will develop traditional shell scripts for checking for CIS Benchmark compliance,
    and then for implementing the recommendations if required. This will look very
    similar to the CIS Benchmark document itself and thus will help with generating
    an understanding of how to implement them. Then, in the next chapter, we will
    develop these shell script-based examples into Ansible roles so that we can use
    our favorite automation tool to manage our CIS Benchmark compliance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's work through some examples to demonstrate how to develop such scripts,
    starting with our root login over SSH example.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring SSH root login is disabled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CIS recommendation 5.2.8 in version 2.2.0 of the RHEL 7 benchmark is that we
    should disable remote root logins. We have visited this example already in other
    guises, and here we will look specifically at the recommendations in the CIS Benchmark
    document to help us understand how this should be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'The document states that, to audit for this requirement (and thus score this
    item), the following test result should be observed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the command is intended for a human being to interpret the output
    of it—this command will return the `PermitRootLogin` line from this file, regardless
    of whether it is enabled or disabled. The text shows the desired output, but assumes
    that the person running the test will read the output and check whether it is
    enabled or not—workable on a small scale, but not viable for automation purposes.
    The remediation suggested is to edit `/etc/ssh/sshd_config` to set the following
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good—the CIS Benchmark document is quite descriptive, and even gives
    us a head start with our coding. However, as stated previously, these snippets
    don't really help us to either check or implement this recommendation in an automated
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to audit for this condition using a shell script. In this instance,
    we would want to run the `grep` command mentioned in the benchmark document, but
    use a more precise pattern to ensure we only match the `PermitRootLogin` line
    when it is set to `no`. We would then check for the desired output and `echo`
    a suitable message to the console, depending on the result of the check. This
    script might look like this (noting that there are multiple ways to achieve the
    same end result in shell scripting!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The script is fairly straightforward for anyone familiar with shell scripts,
    but in brief, here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We put some useful documentation in the comments at the top of the file so that
    we know which recommendation we are testing for. Note that recommendation numbers
    might change between document versions and so it is important to record both.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We `echo` a line of informative text about the test we are running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the suggested audit command from the CIS Benchmark is run, only this time
    we are checking for the presence of the `PermitRootLogin no` line. The output
    is captured in an `OUTPUT` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the contents of `OUTPUT` are blank, then we know the line we are checking
    for does not exist in the file and the test is assumed to have failed. We can
    safely assume this because root logins are enabled by default in the OpenSSH server,
    and so if this line is absent from the configuration file, then provided there
    were no issues with our `grep` pattern, root logins are enabled. We `echo` this
    to the Terminal so that the user knows to take action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The only condition under which the `OUTPUT` variable should contain text is
    when the `grep` command finds the desired pattern. If this condition is achieved,
    then we echo a different message for the user so that they know that this test
    has passed and no further action is required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see this script in action, along with an attempt to fix the problem
    by hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a53551f-7c99-4e7d-9fdd-0969f7a0caa2.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see a prime example of the manual process, which many system administrators
    and engineers will be familiar with when managing their estates. We ran the check
    script defined previously and it yielded the response `FAILED!`. Thus, our first
    step was to take a look at the config file to see why the test failed. There were
    one of two possibilities that would have caused this result—either the line containing
    `PermitRootLogin` was not present at all, or it was commented out. In this case,
    the former proved to be true.
  prefs: []
  type: TYPE_NORMAL
- en: If the line had been present, but commented out, we could have used `sed` (or
    another inline editing tool) to uncomment the line and set the parameter to `no`.
    However, as the line was not present, we needed to append the line to the file,
    which we have done in the previous screenshot using the `tee -a` command. Note
    that this was needed in conjunction with `sudo` because only `root` can write
    to this file. We then run the test a second time and it passes. Of course, you
    will note that it would have been entirely possible to simply open this file with
    `vim` (or your favorite editor) and correct the issue manually; however, the previous
    example could lend itself to a scripted solution.
  prefs: []
  type: TYPE_NORMAL
- en: As shown from the preceding example, this is an incredibly slow and manual process.
    This would be bad enough to perform on a single server (for example, the template
    image), but imagine scaling this up across an entire estate of Linux servers,
    and then to all the recommendations in the CIS Benchmark document. The task would
    be a full-time (and very tedious) job for someone.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s better to automate the process and you will note that, in the CIS Benchmark
    document, there is not only a test case for auditing the recommendation on a server,
    but also a recommended alteration. In most cases, this is simply a statement of
    the line(s) that should be present in the given configuration file(s). In this
    case, we want to assert the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to try and remedy this issue by developing our shell script further,
    we would need to perform the following steps when the test results are in a `FAILED!`
    state (on an `OK` result, no further action is necessary):'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have failed to match the desired pattern in the file, we know that the
    line is either present, but has the wrong setting, or is not present at all (either
    absent or commented out). We can ignore the difference between the last two possibilities
    as it will do no harm to leave the commented out line in place and add the correct
    line in. Thus, our first task is to test for the presence of the `PermitRootLogin`
    line, regardless of its setting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous screenshot, we are looking for any line in the configuration
    file that begins with `PermitRootLogin`. If we get nothing back (our positive
    test case), then we know we must add the line to the file by adding the following
    directly under the `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. However, if our `grep` command did return some output, we
    know the line is present and the value is incorrect, and so we can use a tool
    such as `sed` to modify the line in place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have modified the file (regardless of the route taken), we know we
    must restart `sshd` for the changes to be picked up. Thus, under the closing `fi`
    statement of the inner `if` construct, we add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this with an SSH configuration where this setting is not present,
    we see the following behavior—note that a second run of the script shows that
    the modifications were successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/151d712f-2ab1-46e3-86d0-cc03e393c074.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, if we run it and the line is present and not correct according to
    the CIS Benchmark, we see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d988510e-b2a2-4b9a-ba37-3a5e11fe7783.png)'
  prefs: []
  type: TYPE_IMG
- en: This is excellent—we have just used shell scripts to automate one of the recommendations
    in the CIS Benchmark document. However, you will note that the shell script we
    developed contains a lot of repetition and would not be easy to pick up by someone
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Further, this recommendation is one of the more simple ones—there is only one
    line to modify in one file in this case. What if the recommendation is more in
    depth? Let's take a look at that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring packet redirect sending is disabled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recommendation 3.1.2 of the version 2.2.0 RHEL benchmark is somewhat more detailed—this
    is a scored level 1 benchmark that ensures that your servers do not send routing
    information to other hosts. Unless they have been configured as a router, there
    should be no good reason for them to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the documentation itself, we can see that the recommended audit commands
    (and results) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The commands to be run begin with the `$` character, while the desired results
    are shown on the following line. We can already see that developing this into
    a shell script is going to take some work—we need to validate the output of the
    two `sysctl` commands, and then also check the configuration files to ensure that
    the parameters will persist across reboots and kernel parameter reloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check for the current kernel parameter setting quite easily using some
    shell code such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You will note that the code structure is almost identical to that which we used
    to check the `PermitRootLogin` parameter for SSH—hence, although the code to automate
    our auditing process is getting easier, it is also getting highly repetitious
    and inefficient. A similar block of code would then be used to check the value
    of the `net.ipv4.conf.default.send_redirects` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check the persistent configuration of these parameters, again,
    by building the audit commands from the CIS Benchmark document into a conditional
    structure similar to what we did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we would replicate this block for the `net.ipv4.conf.default.send_redirects`
    parameter. Thus, once again, we have successfully built up a script to audit this
    benchmark—running it on our system looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f2098e0-5ec0-4253-837d-66769c2d0ffd.png)'
  prefs: []
  type: TYPE_IMG
- en: That's 35 lines of shell script (albeit with a few comments at the top of the
    file), much of it repetitious, and all just to know that we have completely failed
    to meet this requirement! Once again, if we are to expand this example to resolve
    the issues, we need to expand our script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the active kernel parameters is quite easy—we just need to add a series
    of commands such as the following into the `FAILED!` branch of our first two `if`
    constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We could add something similar for `net.ipv4.conf.default.send_redirects` in
    the appropriate place.
  prefs: []
  type: TYPE_NORMAL
- en: For our persistent parameters, however, things are a bit more tricky—we need
    to deal with the two possible configuration file scenarios as with the `PermitRootLogin`
    example, but now we have a configuration that is built up of a series of files
    and we must choose which file to modify if the parameter isn't present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, once again, we must build up a block of code to handle these two differing
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s a pretty ugly and difficult-to-read piece of code. What it does is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It runs a second `grep` against the known configuration files to see whether
    the parameter is in there, regardless of its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the parameter is not set, then we choose to append it to `/etc/sysctl.conf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the parameter is set, we instead use `sed` to modify the parameter, forcing
    it to our desired value of `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now when we run this script as before, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/615e1ba1-da69-44f4-8663-071f9342850e.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, this works nicely; however, we are now up to 57 lines of shell
    code and much of it starting to get quite unreadable. All of this is for setting
    just two kernel parameters, and although we have now built up a fairly solid code
    base for taking the CIS Benchmarks (along with their recommended audit and remediation
    steps), it is not scaling at all well.
  prefs: []
  type: TYPE_NORMAL
- en: Further, these scripts are all being run locally in the preceding example—what
    if we wanted to run them from a central place? In the next section, we will take
    a look at exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: Running CIS Benchmark scripts from a remote location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The challenge with shell scripting is that, while it is easy to run on the machine
    where the scripts exist, it is a little more difficult to do on a remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: The scripts we developed previously are designed to be run from an unprivileged
    account—thus, we have used `sudo` on the steps that specifically require root
    access to be run. This is fine when you have passwordless sudo access set up,
    but when a password is required for elevated access using `sudo`, this further
    complicates the task of running the scripts remotely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the entire script could be run as root and, depending on your use
    case and security requirements, this may or may not be desirable. Let''s take
    a look at the task of running our send redirect example on a remote system called
    `centos-testhost`. To achieve this, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: SSH into the remote system and authenticate—this could be with a password or
    SSH keys that were set up previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the shell required to run the script we have developed—in our examples,
    this is `/bin/bash`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add the `-s` flag to the `bash` command—this causes the shell to read its
    command from the standard input (that is, the commands can be piped to it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we pipe our script across to `bash`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is one further caveat to this approach—in our script, we have boldly assumed
    that the commands we rely on (such as `sysctl`) exist within one of the directories
    defined in the PATH variable. It could be argued that this is flawed—however,
    it can also make script development easier, especially when building up scripts
    that might be used in a cross-platform environment.
  prefs: []
  type: TYPE_NORMAL
- en: For example, although we have been exclusively working with the RHEL 7 CIS Benchmark
    in this chapter, it is fair to assume that Ubuntu Server would also want to have
    SSH root logins disabled, and not send packet redirect information unless it is
    explicitly configured as a router. Hence, we might reasonably expect the scripts
    we have developed so far to work on both systems and save us some development
    effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, on RHEL 7 (and CentOS 7), the `sysctl` command is found in `/usr/sbin/sysctl`,
    whereas on Ubuntu it is in `/sbin/sysctl`. This difference in itself could be
    handled by defining the path to `sysctl` in a variable at the top of the script,
    and then calling it via this—however, even so, it would mean modifying many scripts
    related to CIS hardening, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In short, this is better than our original approach, but still highly manual
    and messy. Returning to the task of running our existing script remotely, putting
    all our requirements together, we might run it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command assumes we are running the script as the current user
    on the local system—we could explicitly set the user by adding it before the hostname:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this against our remote system (including a second run to ensure the
    modifications took place effectively) will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/987f3c66-8e88-4810-ae4e-d6cbd4dbe130.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that this has been effective against our remote system and that no
    modification to our original script was required. All of this, while very effective,
    is somewhat inefficient and cumbersome, especially when compared to our experience
    with Ansible. In fact, it is fair to say that these examples demonstrate the value
    that Ansible brings to automating fundamental system administration tasks. To
    develop this, in the next chapter, we will look at how to build upon our foundation
    in CIS Benchmarks by developing Ansible playbooks to carry out the tasks required.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's highly connected world, system security is paramount, and while Linux
    has long been regarded as a secure operating system, there is much that can be
    done to enhance its security. CIS Benchmarks provided one such standardized approach
    by bringing together a consensus on security best practices from across the technology
    industry. CIS Benchmarks, however, are extensive and, if applied by hand, would
    take many hours for an engineer to implement on a single system. Thus, automating
    their deployment is of vital importance.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you have learned about CIS Benchmarks, what they are for, and
    the benefits they bring. You then learned about the balance between security and
    application support, and how to make informed decisions when applying a server
    hardening policy. You also learned how to make use of shell scripts to apply some
    example security policies on a Linux server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will develop this concept further by demonstrating effective
    methods for automating the deployment of CIS Benchmark recommendations using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why are CIS Benchmarks relevant to securing Linux servers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you secure Ubuntu Server with the appropriate benchmark and then install
    nginx on that server, does that also need hardening?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a level 1 and a level 2 benchmark?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are some benchmarks scored and others not?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you check using a shell script that a given audit requirement has been
    met?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: State three possible issues relating to automated modification of configuration
    files using a shell script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do shell scripts not scale well for the automated rollout of CIS Benchmarks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you run a CIS Benchmark shell script on a remote server using SSH?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you want to make use of a variable to specify the path to a binary
    used to implement a CIS recommendation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why might you use sudo for individual commands within a script rather than needing
    the whole script to run as root?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To review common questions about the CIS Benchmarks, please refer to [https://www.cisecurity.org/cis-benchmarks/cis-benchmarks-faq/](https://www.cisecurity.org/cis-benchmarks/cis-benchmarks-faq/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full list of CIS Benchmarks is available at [https://www.cisecurity.org/cis-benchmarks/](https://www.cisecurity.org/cis-benchmarks/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a greater understanding of Linux shell scripting, please refer to *Mastering
    Linux Shell Scripting, Second Edition, Andrew Mallett* and *Mokhtar Ebrahim* ([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-linux-shell-scripting-second-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-linux-shell-scripting-second-edition)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand more about SELinux and how to create your own policies, please
    refer to *SELinux System Administration, Second Edition, Sven Vermeulen* ([https://www.packtpub.com/gb/networking-and-servers/selinux-system-administration-second-edition](https://www.packtpub.com/gb/networking-and-servers/selinux-system-administration-second-edition)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
