<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer050">
<h1 class="chapterNumber">2</h1>
<h1 class="chapterTitle" id="_idParaDest-30">Managing Users and Permissions</h1>
<p class="normal">In the previous chapter, we set up our very own Ubuntu Server installation, and we can now learn how to maintain it, starting with a look at managing who is able to use our server.</p>
<p class="normal">As administrators of Ubuntu servers, users can be your greatest asset and also your biggest headache. During your career, you’ll add countless new users, manage their passwords, remove their accounts when they leave the company, and grant or remove access to resources across the network. Even on servers on which you’re the only user, you’ll still find yourself managing user accounts, since even system processes run as users. To be successful at managing Linux servers, you’ll also need to know how to manage permissions, create password policies, and limit who can execute administrative commands on the machine. In this chapter, we’ll work through these concepts so that you have a clear idea of how to manage users and their resources.</p>
<p class="normal">In particular, we will cover:</p>
<ul>
<li class="bulletList">Understanding the purpose of users and groups</li>
<li class="bulletList">Understanding when to use <code class="inlineCode">root</code></li>
<li class="bulletList">Creating and removing users</li>
<li class="bulletList">Understanding the <code class="inlineCode">/etc/passwd</code> and <code class="inlineCode">/etc/shadow</code> files</li>
<li class="bulletList">Distributing default configuration files with <code class="inlineCode">/etc/skel</code></li>
<li class="bulletList">Switching between users</li>
<li class="bulletList">Managing groups</li>
<li class="bulletList">Managing passwords and password policies</li>
<li class="bulletList">Configuring administrator access with <code class="inlineCode">sudo</code></li>
<li class="bulletList">Setting permissions on files and directories</li>
</ul>
<p class="normal">In the first section, we will have a quick discussion about the nature of managing users.</p>
<h1 class="heading-1" id="_idParaDest-31">Understanding the purpose of users and groups</h1>
<p class="normal">When it<a id="_idIndexMarker075"/> comes to <a id="_idIndexMarker076"/>a server, users are very important—without users to serve, then there’s no real need for a server in the first place. The subject of user management itself within the world of IT is in and of itself quite vast. Entire books have been written on individual methods of authentication, and entire technologies (such as <strong class="keyWord">Lightweight Directory Access Protocol</strong>, or <strong class="keyWord">LDAP</strong>) exist <a id="_idIndexMarker077"/>around it. In this chapter, we’ll look at managing users that exist locally on our server, and the groups that help define what they are able to do.</p>
<p class="normal">Since Ubuntu Server is a distribution of Linux, it adopts the Unix style of managing user accounts, groups, and permissions. Although our focus is on Ubuntu, many of the same commands around user management that you’ll learn in this chapter will apply to other platforms as well. There are commands that allow you to add, remove, and change users, as well as commands that allow you to alter permissions.</p>
<p class="normal">Users in the context of a server refer to who (or what) is able to use the server. For example, you may have an accountant named Susan, or an IT administrator named Haneef, who both need to access the server. Perhaps Susan only needs access to a file share directory for accounting-related files, and Haneef might have more access to the server as a system administrator. The user accounts we create on our server will represent the actual people that will use it.</p>
<p class="normal">Groups allow us to segregate access to specific files and directories. As we’ll learn later, files and directories have user and group assignments. When combined with permissions, we’ll be able to manage what our users are able to do with our server.</p>
<p class="normal">Users aren’t always people, though. We also have system users on our server that applications and running processes might use for background or automated tasks. An example of this might be a backup job, and you may have a backup user that runs a task in the background to facilitate some sort of file copy task that copies important files to another place. You don’t have to worry about system-related users for now, just know that they exist. You’ll see more examples of this as we go through the book.</p>
<p class="normal">More advanced organizations may have a central login server, such as <strong class="keyWord">Active Directory</strong> (<strong class="keyWord">AD</strong>) or standard <a id="_idIndexMarker078"/>LDAP. There are others aside from those, as well. In this book, we won’t cover those technologies, but just keep in mind that central authentication servers are a possibility for your organization, should you choose to explore them.</p>
<p class="normal">The most <a id="_idIndexMarker079"/>powerful <a id="_idIndexMarker080"/>user of all, though, is <code class="inlineCode">root</code>. This special user gives us the most control, but as you’ll see in the next section, that comes with risks.</p>
<h1 class="heading-1" id="_idParaDest-32">Understanding when to use root</h1>
<p class="normal">In the last chapter, we<a id="_idIndexMarker081"/> set up our very own Ubuntu Server installation. During the installation process, we were instructed to create a user account to act as a system administrator. So, at this point, we should have at least two users on our server. We have the aforementioned administrative user, as well as <code class="inlineCode">root</code>. We can certainly create additional user accounts with varying levels of access (and we will do so in this chapter), but before we get to that, some discussion is in order regarding the administrator account you created, as well as the <code class="inlineCode">root</code> user that was created for you.</p>
<p class="normal">The <code class="inlineCode">root</code> user account exists on all Linux distributions and is the most powerful user account on the planet. The <code class="inlineCode">root</code> user account can be used to do anything within your server, and I do mean <em class="italic">anything</em>. Want to create files and directories virtually anywhere on the filesystem? Want to install software? These processes are easily performed with <code class="inlineCode">root</code>. The <code class="inlineCode">root</code> account can even be used to destroy your entire installation with one typo or ill-conceived command: if you instruct <code class="inlineCode">root</code> to delete all the files on your entire hard disk, it won’t hesitate to do so. It’s always assumed on a Linux system that if you are using <code class="inlineCode">root</code>, you are doing so because you know what you are doing. So, there’s often not so much as a confirmation prompt while executing any command as <code class="inlineCode">root</code>. It will simply do as instructed, for better or worse.</p>
<p class="normal">It’s for this reason that every Linux distribution I’ve ever used has stated, or at least highly recommended, that you create a standard user during the installation process. It’s generally recommended in the Linux community for an administrator to have their own account and then switch to <code class="inlineCode">root</code> whenever a task comes up that requires <code class="inlineCode">root</code> privileges to complete. This approach is less likely to destroy your server with an accidental typo or bad command. Some administrators will strictly use <code class="inlineCode">root</code> at all times without any issue, but again, it’s recommended to use <code class="inlineCode">root</code> only when you have to.</p>
<p class="normal">Most distributions ask you to create a <code class="inlineCode">root</code> password during installation in order to protect that account. Even Debian (on which Ubuntu is based) has you set a <code class="inlineCode">root</code> password during installation. Ubuntu just decides to do things a little bit differently. The reason for this is that, unlike many other distributions, Ubuntu defaults to locking out the <code class="inlineCode">root</code> account altogether. There’s nothing stopping you from enabling <code class="inlineCode">root</code>, or switching to the <code class="inlineCode">root</code> user after you log in. Being disabled by default just means the <code class="inlineCode">root</code> account isn’t as easily accessible as it normally would be. I’ll cover how to enable this account later in this chapter, should you feel the need to do so.</p>
<p class="normal">An exception to this rule is that some VPS providers, such as Linode, will enable the <code class="inlineCode">root</code> account even on their Ubuntu servers. Sometimes, the <code class="inlineCode">root</code> password will be randomly generated and emailed to you. However, you should still create a user for yourself with administrative access regardless.</p>
<p class="normal">Instead<a id="_idIndexMarker082"/> of using <code class="inlineCode">root</code> outright, Ubuntu (as well as its server version) recommends the use of <code class="inlineCode">sudo</code>. Specifically, <code class="inlineCode">sudo</code> enables you to run individual commands with elevated privileges instead of being logged in as <code class="inlineCode">root</code> all the time.</p>
<h2 class="heading-2" id="_idParaDest-33">Using sudo to run privileged commands</h2>
<p class="normal">I’ll go over<a id="_idIndexMarker083"/> how <a id="_idIndexMarker084"/>to manage <code class="inlineCode">sudo</code> later on in this chapter, but for now, just keep in mind that the purpose of <code class="inlineCode">sudo</code> is to enable you to use your user account to do things that normally only <code class="inlineCode">root</code> would be able to do. For example, as a normal user, you cannot issue a command such as the following to install a software package (don’t worry about the <code class="inlineCode">apt</code> command for now, as we’ll cover that in <em class="chapterRef">Chapter 3</em>, <em class="italic">Managing Software Packages</em>):</p>
<pre class="programlisting con"><code class="hljs-con">apt install tmux
</code></pre>
<p class="normal">Instead, you’ll receive an error:</p>
<pre class="programlisting con"><code class="hljs-con">E: Could not open lock file /var/lib/dpkg/lock-frontend - open (13: Permission denied)
E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), are you root?
</code></pre>
<p class="normal">But if you prefix the command with <code class="inlineCode">sudo</code> (assuming your user account has access to it), the command will work just fine:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install tmux
</code></pre>
<p class="normal">When you use <code class="inlineCode">sudo</code>, you’ll be asked for your user’s password for confirmation, and then the command will execute. Subsequent commands prefixed with <code class="inlineCode">sudo</code> may not prompt for your password, as it will cache your password for a short period of time until it times out or the terminal is closed. Understanding this should clarify the usefulness of the user account you created during installation. I referred to this user as an administrative account earlier, but it’s really just a user account that is able to utilize <code class="inlineCode">sudo</code>. Ubuntu Server automatically gives the first user account you create during installation access to <code class="inlineCode">sudo</code>.</p>
<p class="normal">The intent is<a id="_idIndexMarker085"/> that <a id="_idIndexMarker086"/>you’ll use that account to administer the system, rather than <code class="inlineCode">root</code>. When you create additional user accounts, they will not have access to <code class="inlineCode">sudo</code> by default, unless you explicitly grant it to them.</p>
<h1 class="heading-1" id="_idParaDest-34">Creating and removing users</h1>
<p class="normal">Creating<a id="_idIndexMarker087"/> users in <a id="_idIndexMarker088"/>Ubuntu can be done with one of two commands: <code class="inlineCode">adduser</code> and <code class="inlineCode">useradd</code>. This can be a little confusing at first, because both of these commands do the same thing (in different ways) and are named very similarly. I’ll go over the <code class="inlineCode">useradd</code> command first and then I’ll explain how <code class="inlineCode">adduser</code> differs. You may even prefer the latter, but we’ll get to that in a moment.</p>
<h2 class="heading-2" id="_idParaDest-35">Using useradd</h2>
<p class="normal">First, here’s<a id="_idIndexMarker089"/> an example of the <code class="inlineCode">useradd</code> command in action:</p>
<pre class="programlisting con"><code class="hljs-con">sudo useradd -d /home/jdoe -m jdoe
</code></pre>
<p class="normal">With this command, I created a user named <code class="inlineCode">jdoe</code>. With the <code class="inlineCode">-d</code> option, I’m clarifying that I would like a home directory created for this user, and following that, I called out <code class="inlineCode">/home/jdoe</code> as the user’s home directory. The <code class="inlineCode">-m</code> flag tells the system that I would like the home directory to be created during the process; otherwise, I would’ve had to create the directory myself. Finally, I called out the username for my new user (in this case, <code class="inlineCode">jdoe</code>).</p>
<p class="normal">As we go along in this book, there will be commands that require <code class="inlineCode">root</code> privileges in order to execute. The preceding command was an example of this. For commands that require such permissions, I’ll prefix the commands with <code class="inlineCode">sudo</code>. When you see these, it just means that <code class="inlineCode">root</code> privileges are required to run the command. For these, you can also log in as <code class="inlineCode">root</code> (if <code class="inlineCode">root</code> is enabled) or switch to <code class="inlineCode">root</code> to execute these commands as well. However, as I mentioned before, using <code class="inlineCode">sudo</code> instead of using the <code class="inlineCode">root</code> account is strongly encouraged.</p>
<p class="normal">Now, list the storage of <code class="inlineCode">/home</code> using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">ls -l /home
</code></pre>
<p class="normal">You should <a id="_idIndexMarker090"/>see a folder listed there for our new user:</p>
<figure class="mediaobject"><img alt="" height="188" src="../Images/B18425_02_01.png" width="668"/></figure>
<p class="packt_figref">Figure 2.1: Listing the contents of /home after our first user was created</p>
<p class="normal">What about creating our user’s password? We may have been asked for our current user’s password due to using <code class="inlineCode">sudo</code>, but we weren’t asked for a password for the new user. To create a password for the user, we can use the <code class="inlineCode">passwd</code> command. The <code class="inlineCode">passwd</code> command defaults to allowing you to change the password for the user you’re currently logged in as, but it also allows you to set a password for any other user if you run it as <code class="inlineCode">root</code> or with <code class="inlineCode">sudo</code>. If you enter <code class="inlineCode">passwd</code> by itself, the command will first ask you for your current password, then your new password, and then it will ask you to confirm your new password again. If you prefix the command with <code class="inlineCode">sudo</code> and then specify a different user account, you can set the password for any user you wish. An example of the output of this process is as follows:</p>
<figure class="mediaobject"><img alt="" height="195" src="../Images/B18425_02_02.png" width="688"/></figure>
<p class="packt_figref">Figure 2.2: Changing the password of a user</p>
<p class="normal">As you can see in the previous screenshot, you won’t see any asterisks or any kind of output when you type a password using the <code class="inlineCode">passwd</code> command. This is normal. Although you won’t see any visual indication of input, your input is being recognized.</p>
<p class="normal">Now we have a new user and we were able to set a password for that user. The <code class="inlineCode">jdoe</code> user will now<a id="_idIndexMarker091"/> be able to access the system with the password we’ve chosen. This user won’t have access to <code class="inlineCode">sudo</code> by default, but we’ll cover how to change this later on in the chapter.</p>
<h2 class="heading-2" id="_idParaDest-36">Using adduser</h2>
<p class="normal">Earlier, I<a id="_idIndexMarker092"/> mentioned the <code class="inlineCode">adduser</code> command as another way of creating a user. The difference (and convenience) of this command should become apparent immediately once you’ve used it. Go ahead and give it a try; execute <code class="inlineCode">adduser</code> along with a username for a user you wish to create. An example run of this process is as follows:</p>
<figure class="mediaobject"><img alt="" height="523" src="../Images/B18425_02_03.png" width="700"/></figure>
<p class="packt_figref">Figure 2.3: Creating a user with the adduser command</p>
<p class="normal">In the preceding <a id="_idIndexMarker093"/>process, I executed <code class="inlineCode">sudo adduser dscully</code> (commands that modify users require <code class="inlineCode">sudo</code> or <code class="inlineCode">root</code>) and then I was asked a series of questions regarding how I wanted the user to be created. I was asked for the password (twice), <code class="inlineCode">Full Name</code>, <code class="inlineCode">Room Number</code>, <code class="inlineCode">Work Phone</code>, and <code class="inlineCode">Home Phone</code>. In the <code class="inlineCode">Other</code> field, I entered the comment <code class="inlineCode">Trust no one</code>, which is a great mindset to adopt while managing users. The latter prompts prior to the final confirmation were all optional: I didn’t have to enter <code class="inlineCode">Full Name</code>, <code class="inlineCode">Room Number</code>, and so on. I could’ve pressed <em class="keystroke">Enter</em> to skip those prompts if I wanted to. The only things that are really required are the username and the password.</p>
<p class="normal">From the output, we can see that the <code class="inlineCode">adduser</code> command performed quite a bit of work for us. The command defaulted to using <code class="inlineCode">/home/dscully</code> as the home directory for the user, the account was<a id="_idIndexMarker094"/> given the next available <strong class="keyWord">User ID</strong> (<strong class="keyWord">UID</strong>) and <strong class="keyWord">Group ID</strong> (<strong class="keyWord">GID</strong>) of <code class="inlineCode">1002</code>, and it <a id="_idIndexMarker095"/>also copied files from <code class="inlineCode">/etc/skel</code> into our new user’s <code class="inlineCode">home</code> directory. In fact, both the <code class="inlineCode">adduser</code> and <code class="inlineCode">useradd</code> commands copy files from <code class="inlineCode">/etc/skel</code>, but <code class="inlineCode">adduser</code> is more verbose regarding the actions it performs.</p>
<p class="normal">Don’t worry if you don’t understand what <code class="inlineCode">UID</code>, <code class="inlineCode">GID</code>, and <code class="inlineCode">/etc/skel</code> are yet. We’ll work through those concepts soon.</p>
<p class="normal">In a nutshell, the <code class="inlineCode">adduser</code> command is much more convenient in the sense that it prompts you for various options while it creates the user without requiring that you memorize command-line options. It also gives you detailed information about what it has done. At this point, you may be wondering why someone would want to use <code class="inlineCode">useradd</code> at all, considering how much more convenient <code class="inlineCode">adduser</code> seems to be. Unfortunately, <code class="inlineCode">adduser</code> is not available on all distributions of Linux. It’s best to familiarize yourself with <code class="inlineCode">useradd</code> in case you find yourself on a Linux system that’s not Ubuntu.</p>
<p class="normal">It may be interesting for you to see what exactly the <code class="inlineCode">adduser</code> command is. It’s not even a binary program—it’s <a id="_idIndexMarker096"/>a <strong class="keyWord">shell script</strong>. A shell script is simply a text file that can be executed as a program. You don’t have to worry too much about scripting now, as we will cover it in <em class="chapterRef">Chapter 6</em>, <em class="italic">Boosting Your Command-line Efficiency</em>. In the case of <code class="inlineCode">adduser</code>, it’s a script <a id="_idIndexMarker097"/>written<a id="_idIndexMarker098"/> in <strong class="keyWord">Perl</strong>, which is a programming language that is sometimes used for administrative tasks. Since it’s not binary, you can even open it in a text editor in order to view all the code that it executes behind the scenes. However, make sure you don’t open the file in a text editor with <code class="inlineCode">root</code> privileges, to ensure that you don’t accidentally save changes to the file and break the script. The following command will open <code class="inlineCode">adduser</code> in a text editor on an Ubuntu Server system:</p>
<pre class="programlisting con"><code class="hljs-con">nano /usr/sbin/adduser
</code></pre>
<p class="normal">Use your up/down arrows as well as the <em class="keystroke">Page Up</em> and <em class="keystroke">Page Down</em> keys to scroll through the file. When you’re finished, press <em class="keystroke">Ctrl</em> + <em class="keystroke">x</em> on your keyboard to exit the text editor. If the editor prompts you to save changes, don’t do so. Anyway, those of you with keen eyes will likely notice that the <code class="inlineCode">adduser</code> script is calling <code class="inlineCode">useradd</code> to perform its actual work. So either way, you’re either directly or indirectly using <code class="inlineCode">useradd</code>.</p>
<p class="normal">Now that we know how to create users, it will be useful to understand how to remove them as well.</p>
<h2 class="heading-2" id="_idParaDest-37">Removing users</h2>
<p class="normal">Removing or disabling <a id="_idIndexMarker099"/>an account is very important when a user no longer needs to access a system, as unmanaged accounts often become a security risk. To remove a user account, we’ll use the <code class="inlineCode">userdel</code> command.</p>
<p class="normal">Before removing an account, though, there is one very important question you should ask yourself. Will you (or another person) need access to the user’s files? Most companies have retention policies in place that detail what should happen to a user’s data when they leave the organization. Sometimes, these files are copied into an archive for long-term storage. Often, a manager, coworker, or new hire will need access to the former user’s files, perhaps to continue working on a project where they left off. It’s important to understand this policy ahead of managing users. If you don’t have a policy in place that outlines retention requirements for files when users resign, you should probably work with your management team and create one.</p>
<p class="normal">By default, the <code class="inlineCode">userdel</code> command does not remove the contents of the user’s <code class="inlineCode">home</code> directory. Here, we use the following command to remove <code class="inlineCode">dscully</code> from the system:</p>
<pre class="programlisting con"><code class="hljs-con">sudo userdel dscully
</code></pre>
<p class="normal">We can see that the files for the <code class="inlineCode">dscully</code> user still exist by entering the following command:</p>
<pre class="programlisting con"><code class="hljs-con">ls -l /home
</code></pre>
<p class="normal">The preceding commands will result in the following outputs:</p>
<figure class="mediaobject"><img alt="" height="241" src="../Images/B18425_02_04.png" width="611"/></figure>
<p class="packt_figref">Figure 2.4: The home directory for the user dscully still exists, even though we removed the user</p>
<p class="normal">With the <code class="inlineCode">/home</code> directory for <code class="inlineCode">dscully</code> still existing, we’re able to move the contents of this directory anywhere we would like to. If we had a directory called <code class="inlineCode">/store/file_archive</code>, for example, we could easily move the files there:</p>
<pre class="programlisting con"><code class="hljs-con">sudo mv /home/dscully /store/file_archive
</code></pre>
<p class="normal">Of course, it’s up to you to create the directory where your long-term storage will ultimately be, but you get the idea.</p>
<p class="normal">If you weren’t already aware, you can create a new directory with the <code class="inlineCode">mkdir</code> command. You can create a directory within any other directory that your logged-in user has access to. The following command will create the <code class="inlineCode">file_archive</code> directory I mentioned in the preceding example:</p>
<pre class="programlisting con"><code class="hljs-con">sudo mkdir -p /store/file_archive
</code></pre>
<p class="normal">The <code class="inlineCode">-p</code> flag simply <a id="_idIndexMarker100"/>creates the parent directory if it didn’t already exist.</p>
<p class="normal">If you do actually want to remove a user’s home directory at the same time that you remove an account, just add the <code class="inlineCode">-r</code> option. This will eliminate the user and their data in one shot:</p>
<pre class="programlisting con"><code class="hljs-con">sudo userdel -r dscully
</code></pre>
<p class="normal">To remove the <code class="inlineCode">/home</code> directory for the user after the account was already removed (if you didn’t use the <code class="inlineCode">-r</code> parameter the first time), use the <code class="inlineCode">rm -r</code> command to get rid of it, as you would any other directory:</p>
<pre class="programlisting con"><code class="hljs-con">sudo rm -r /home/dscully
</code></pre>
<p class="normal">It probably goes without saying, but the <code class="inlineCode">rm</code> command can be extremely dangerous. If you’re logged in as <code class="inlineCode">root</code> or using <code class="inlineCode">sudo</code> while using <code class="inlineCode">rm</code>, you can easily destroy your entire installed system if you’re not careful. <em class="italic">DO NOT run this command</em>, but as a hypothetical example, the following command (while seemingly innocent at first glance) will likely completely destroy your entire filesystem:</p>
<pre class="programlisting con"><code class="hljs-con">sudo rm -r / home/dscully
</code></pre>
<p class="normal">Notice the typo: I accidentally typed a space after the first forward slash. I literally accidentally told my system to remove the contents of the entire filesystem. If that command were executed, the server probably wouldn’t even boot the next time we attempted to start it. All user and program data would be wiped out. If there was ever any single reason for us to be protective over the <code class="inlineCode">root</code> account, the <code class="inlineCode">rm</code> command is most certainly it!</p>
<p class="normal">At this point, we<a id="_idIndexMarker101"/> understand how to add and remove users. In the next section, we’ll look deeper into passwords.</p>
<h1 class="heading-1" id="_idParaDest-38">Understanding the /etc/passwd and /etc/shadow files</h1>
<p class="normal">Now that we know how to create (and delete) user accounts on our server, we are well on our way to being able to manage our users. But where exactly is this information stored? We know that users store their personal files in <code class="inlineCode">/home</code>, but is there some kind of database somewhere that keeps track of which user accounts are on our system? Actually, user account information is stored in two special text files:</p>
<ul>
<li class="bulletList"><code class="inlineCode">/etc/passwd</code></li>
<li class="bulletList"><code class="inlineCode">/etc/shadow</code></li>
</ul>
<p class="normal">You can display the contents of each of those two files with the following commands. Note that any user can look at the contents of <code class="inlineCode">/etc/passwd</code>, while only <code class="inlineCode">root</code> has access to <code class="inlineCode">/etc/shadow</code>:</p>
<pre class="programlisting con"><code class="hljs-con">cat /etc/passwd 
sudo cat /etc/shadow
</code></pre>
<p class="normal">Go ahead and take a look at these two files (just don’t make any changes), and I will help you understand them.</p>
<h2 class="heading-2" id="_idParaDest-39">Understanding the /etc/passwd file</h2>
<p class="normal">First, let’s go <a id="_idIndexMarker102"/>over the <code class="inlineCode">/etc/passwd</code> file. What follows is some example output from this file on my test server. For brevity, I have limited the output to the last eight lines:</p>
<figure class="mediaobject"><img alt="" height="219" src="../Images/B18425_02_05.png" width="669"/></figure>
<p class="packt_figref">Figure 2.5: Example /etc/passwd file</p>
<p class="normal">Each line within this file corresponds to a user account on the system. Entries are split into columns, separated by a colon (<code class="inlineCode">:</code>). The username is in the first column, so you can see that I’ve created users <code class="inlineCode">jay</code> and <code class="inlineCode">jdoe</code>. The next column on each is simply an <code class="inlineCode">x</code>. I’ll go over what that means a bit later. For now, let’s skip to the third and fourth columns, which reference the UID and GID respectively. </p>
<p class="normal">On a Linux system, user accounts and groups are actually referenced by their IDs. While it’s easier for you and I to manage users by their names, usernames and group names are nothing more than a label placed on the UID and GID in order to help us identify them more easily.</p>
<p class="normal">For example, it may <a id="_idIndexMarker103"/>be frustrating to try to remember that <code class="inlineCode">jdoe</code> is UID <code class="inlineCode">1001</code> on our server each time we want to manage this account. Managing it by referring to the account as <code class="inlineCode">jdoe</code> is easier for humans, since we don’t remember numbers as well as we do names. But to Linux, each time we reference user <code class="inlineCode">jdoe</code>, we’re actually just referencing UID <code class="inlineCode">1001</code>. When a user is created, the system (by default) automatically assigns the next available UID to the account. If you manage multiple Ubuntu servers, note that the UIDs will not match from one system to another, so keep in mind that UIDs don’t synchronize between installations.</p>
<p class="normal">In my case (as shown in <em class="italic">Figure 2.5</em>), the UID of each user is the same as their GID. This is just a coincidence on my system and it isn’t always that way in practice. While I’ll discuss creating groups later in this chapter, understand that creating groups works in a similar way to creating users, in the sense that the group is assigned the next available GID in much the same way as new user accounts are assigned the next available UID. When you create a user, the user’s primary group is the same as their username (unless you request otherwise). For example, when I created <code class="inlineCode">jdoe</code>, the system also automatically created a <code class="inlineCode">jdoe</code> group as well.</p>
<p class="normal">This is what you’re actually seeing here—the UID for the user, as well as the GID for the user’s primary group. Again, we’ll get to groups in more detail later.</p>
<p class="normal">You probably also noticed that the <code class="inlineCode">/etc/passwd</code> file on your system contains entries for many more users than the ones we’ve created ourselves. This is perfectly normal, as Linux uses user accounts for various processes and services that run in the background. You’ll likely never interact with the default accounts at all, though you may someday create your own system user for a process to run as. For example, perhaps you’ll create a data processor account for an automated data-processing script to run under.</p>
<p class="normal">Anyway, back to our <code class="inlineCode">/etc/passwd</code> file. The fifth column is designated for user info, most commonly the user’s first and last names. In my example, the fifth field is blank for <code class="inlineCode">jdoe</code>, as I created <code class="inlineCode">jdoe</code> with the <code class="inlineCode">useradd</code> command, which didn’t prompt me for the first and last names. This field is also nicknamed the <code class="inlineCode">GECOS</code> field, and you may see it referred to as such when you read the documentation.</p>
<p class="normal">In the sixth column, the home directory for each user is shown. In the case of <code class="inlineCode">jdoe</code>, it’s set as <code class="inlineCode">/home/jdoe</code>. Finally, we designate the user’s shell as <code class="inlineCode">/bin/bash</code>. This field refers to the default shell the user will use, which defaults to <code class="inlineCode">/bin/bash</code> when an account is created with the <code class="inlineCode">adduser</code> command, and <code class="inlineCode">/bin/sh</code> when created with the <code class="inlineCode">useradd</code> command. (If you have no preference, <code class="inlineCode">/bin/bash</code> is the best choice for most.) If we want the user to <a id="_idIndexMarker104"/>use a different shell, we can clarify that here (though shells other than <code class="inlineCode">/bin/bash</code> aren’t covered in this book). If we wanted, we could change the user’s shell to something invalid to prevent them from logging in at all. This is useful for when a security issue requires us to disable an account quickly.</p>
<h2 class="heading-2" id="_idParaDest-40">Understanding the /etc/shadow file</h2>
<p class="normal">With that out of <a id="_idIndexMarker105"/>the way, let’s take a look at the <code class="inlineCode">/etc/shadow</code> file. We can use <code class="inlineCode">cat</code> to display the contents like any other text file, but unlike <code class="inlineCode">/etc/passwd</code>, we need <code class="inlineCode">root</code> privileges in order to view it. So, go ahead and display the contents of this file, and I’ll walk you through it:</p>
<pre class="programlisting con"><code class="hljs-con">sudo cat /etc/shadow
</code></pre>
<p class="normal">This will display the following output:</p>
<figure class="mediaobject"><img alt="" height="138" src="../Images/B18425_02_06.png" width="880"/></figure>
<p class="packt_figref">Figure 2.6: Example /etc/shadow file</p>
<p class="normal">The preceding screenshot, <em class="italic">Figure 2.6</em>, shows the last four lines of this file on my server. First, we have the username in the first column—no surprises there. Note that the output is not showing the UID for each user in this file. The system knows which username matches which UID based on the <code class="inlineCode">/etc/passwd</code> file, so there’s no need to repeat that here. In the second column, we have what appears to be gobbledygook. Actually, that’s the most important part of this entire file. That’s the actual hash for the user’s password.</p>
<p class="normal">A password hash is a conversion of the actual password to a different string that represents the original password. This is a one-way conversion, so you cannot find the actual password by <a id="_idIndexMarker106"/>reverse-engineering the hash. In the <code class="inlineCode">/etc/passwd</code> file, the hash of the password is stored rather than the actual password, for security purposes.</p>
<p class="normal">If you recall, in the <code class="inlineCode">/etc/passwd</code> file, each user listing had an <code class="inlineCode">x</code> for the second column, and I mentioned I would explain that later. What the <code class="inlineCode">x</code> refers to is the fact that the user’s password is encrypted and simply not stored in <code class="inlineCode">/etc/passwd</code> and is instead stored in <code class="inlineCode">/etc/shadow</code>. After all, the <code class="inlineCode">/etc/passwd</code> file is viewable by everyone, so it would compromise security quite a bit if anyone could just open up the file and see what everyone’s passwords were.</p>
<p class="normal">In the days of old, you could actually store a user’s password in <code class="inlineCode">/etc/passwd</code>, but it’s never done that way anymore. Whenever you create a user account on a modern Linux system, the user’s password is encrypted (an <code class="inlineCode">x</code> is placed in the second column of <code class="inlineCode">/etc/passwd</code> for the user), and the actual password hash is stored in the second column of <code class="inlineCode">/etc/shadow</code> to keep it away from prying eyes. Hopefully, now the relationship between these two files has become apparent.</p>
<p class="normal">Remember earlier I mentioned that the <code class="inlineCode">root</code> user account is locked out by default? Well, let’s actually see that in action. Execute the following command to see the <code class="inlineCode">root</code> user account entry in <code class="inlineCode">/etc/shadow</code>:</p>
<pre class="programlisting con"><code class="hljs-con">sudo cat /etc/shadow | grep root
</code></pre>
<p class="normal">On my system, I get the following output:</p>
<figure class="mediaobject"><img alt="" height="147" src="../Images/B18425_02_07.png" width="728"/></figure>
<p class="packt_figref">Figure 2.7: Example /etc/shadow file</p>
<p class="normal">You should notice <a id="_idIndexMarker107"/>right away that the <code class="inlineCode">root</code> user account doesn’t have a password hash at all. Instead, there’s an asterisk where the password hash would’ve been. In practice, placing an asterisk or exclamation point here is one way to lock an account. Even easier, you can use the <code class="inlineCode">passwd -l</code> command against an account to lock it without having to edit a file. But either way, we can still switch to the <code class="inlineCode">root</code> account anytime (which I’ll show you how to do later on in this chapter). Entering an asterisk or exclamation mark in the second field creates the restriction that we can’t directly log in as that user from the shell or over the network. We have to log in to the system as a normal user account first, and then we can still switch to that user if we want to.</p>
<p class="normal">With the discussion of password hashes out of the way, there are a few more fields within <code class="inlineCode">/etc/shadow</code> entries that we should probably understand. Here’s a contrived example line:</p>
<pre class="programlisting con"><code class="hljs-con">mulder:$6$TPxx8Z.:16809:0:99999:7:::
</code></pre>
<p class="normal">Continuing on with the third column, we can see the number of days since the <strong class="keyWord">Unix epoch</strong> that the password was last changed. For those that don’t know, the Unix epoch is January 1, 1970. Therefore, we can read that column as the password having last been changed 16,809 days after the Unix epoch.</p>
<p class="normal">Personally, I like to use the following command to show more easily when the password was last changed:</p>
<pre class="programlisting con"><code class="hljs-con">sudo passwd -S &lt;username&gt;
</code></pre>
<p class="normal">This will result in an output that looks something like the following:</p>
<figure class="mediaobject"><img alt="" height="160" src="../Images/B18425_02_08.png" width="703"/></figure>
<p class="packt_figref">Figure 2.8: Checking the date of the last password change for a user</p>
<p class="normal">By executing this <a id="_idIndexMarker108"/>command, you can view information about any account on your system. The first column is obviously the username. The second has to do with the status of the password, which in this case is <code class="inlineCode">L</code>, which refers to the fact that the user has a password that is locked. It would show <code class="inlineCode">P</code> if the password was set and usable, or <code class="inlineCode">NP</code> if the user didn’t have a password at all.</p>
<p class="normal">The third column of this command’s output gives you the actual date of the last password change for the user. The fourth column tells us how many days are required to pass before the user will be able to change their password again. In this example, <code class="inlineCode">jdoe</code> can change the password any time because the minimum number of days is set to <code class="inlineCode">0</code>. We’ll talk about how to set the minimum number of days later on in this chapter, but I’ll give you a brief explanation of what this refers to. At first, it may seem silly to require a user to wait a certain number of days to be able to change their password. However, never underestimate the ability of your users to be oppositional. It’s quite common for a user, when required to change their password, to change their password to satisfy history requirements, only to then just change it back to what it was originally. By setting a minimum number of days, you’re forcing a waiting period in between password changes, making it less convenient for your users to cycle back through to their original password.</p>
<p class="normal">The fifth column, as you can probably guess, is the maximum number of days that can pass between password changes. If you require your users to change their passwords every certain number of days, you’ll see that in this column. By default, this is set to <code class="inlineCode">99999</code> days. That number of days is way beyond the human lifespan, so it may as well be infinite.</p>
<p class="normal">Continuing with the sixth column, we have the number of days that will elapse before the expiration date on which the user is warned that they will soon be required to change their password. In the seventh column, we set how many days can pass after the password expires, in which case the account will be disabled. With our example user, this is not set. Finally, with the eighth column (which is not visible), we can see the number of days since the Unix epoch that will elapse before the account is disabled (in our case, there’s nothing here, so there is no disabled day set).</p>
<p class="normal">We’ll go over <a id="_idIndexMarker109"/>setting these fields later, but for now, hopefully you understand the contents of the <code class="inlineCode">/etc/shadow</code> file better.</p>
<p class="normal">If at any time you’d like additional clarification, feel free to check out the Ubuntu man pages. A man page (short for manual page) can give you quite a bit more information about commands as well as files. For example, the following command shows you the man page for the <code class="inlineCode">ls</code> command:</p>
<pre class="programlisting con"><code class="hljs-con">man ls
</code></pre>
<p class="normal">More specific to this section, you can retrieve man pages for the <code class="inlineCode">/etc/shadow</code> files as well:</p>
<pre class="programlisting con"><code class="hljs-con">man passwd
man shadow
</code></pre>
<p class="normal">Press <em class="keystroke">q</em> on your keyboard to exit out of a man page. Feel free to check out the man pages for any command in this book to learn more as you go along.</p>
<p class="normal">Now that we fully understand how to manage our users, we can also look at how to provide them with default files in their home directory.</p>
<h1 class="heading-1" id="_idParaDest-41">Distributing default configuration files with /etc/skel</h1>
<p class="normal">In a typical <a id="_idIndexMarker110"/>organization, there are<a id="_idIndexMarker111"/> usually some defaults that are recommended for users in terms of files and configuration. </p>
<p class="normal">For example, in a company that performs software development, there are likely recommended settings for text editors and version control systems. Files that are contained within <code class="inlineCode">/etc/skel</code> are copied into the home directory for all new users when you create them (assuming you’ve chosen to create a home directory while setting up the user).</p>
<p class="normal">In fact, you can see this for yourself right now. Execute the following command:</p>
<pre class="programlisting con"><code class="hljs-con">ls -la /etc/skel
</code></pre>
<p class="normal">Now, you should be able to view the contents of the <code class="inlineCode">/etc/skel</code> directory:</p>
<figure class="mediaobject"><img alt="" height="285" src="../Images/B18425_02_09.png" width="691"/></figure>
<p class="packt_figref">Figure 2.9: Default /etc/skel files</p>
<p class="normal">You probably already know how to list files within a directory, but I added the <code class="inlineCode">-a</code> option because I wanted to view hidden files as well. The files included in <code class="inlineCode">/etc/skel</code> by default are hidden (their filenames begin with a period). I threw in the <code class="inlineCode">-l</code> parameter solely because it shows a long list, which I think is easier to read.</p>
<p class="normal">Each time you create a new user and request a home directory to be created as well, these three files, shown in <em class="italic">Figure 2.9</em>, will be copied into their home directory, along with any other files you create here. You can verify this by listing the storage of the home directories for the users you’ve created so far. The <code class="inlineCode">.bashrc</code> file in one user’s home directory should be the same as any other, unless they’ve made changes to it.</p>
<p class="normal">Armed with this knowledge, it should be extremely easy to create default files for new users that you create. For example, you could create a file named <code class="inlineCode">welcome</code> with your favorite text editor and place it in <code class="inlineCode">/etc/skel</code>. Perhaps you may create this file to contain helpful phone numbers and information for new hires in your company. The file would then be automatically copied to the new user’s home directory when you create the account. The user, after logging in, would see this file in their home directory and see the information. More practically, if your company has specific editor settings that are favored for writing code, you can include those files in <code class="inlineCode">/etc/skel</code> as well to help ensure your users are compliant. In fact, you can include default configuration files for any application your company uses.</p>
<p class="normal">Go ahead and give it a try. Feel free to create some random text files and then create a new user afterward, and you’ll see that these files will propagate into the home directories of<a id="_idIndexMarker112"/> the <a id="_idIndexMarker113"/>new user accounts that you add to your system.</p>
<p class="normal">Now that we have multiple users and have also seen how to manage their default files, we can take a look at how to switch from one user to another.</p>
<h1 class="heading-1" id="_idParaDest-42">Switching users</h1>
<p class="normal">Now that we<a id="_idIndexMarker114"/> have several users on our system, we need to know how to switch between them. Of course, you can always just log in to the server as one of the users, but you can actually switch to any user account at any time, provided you either know that user’s password or have <code class="inlineCode">sudo</code> access.</p>
<p class="normal">The command you will use to switch from one user to another is the <code class="inlineCode">su</code> command. If you enter <code class="inlineCode">su</code> with no options, it will assume that you want to switch to <code class="inlineCode">root</code> and will ask you for the <code class="inlineCode">root</code> password. As I mentioned earlier, Ubuntu locks the <code class="inlineCode">root</code> account by default, so at this point you may not have a <code class="inlineCode">root</code> password.</p>
<p class="normal">Even though Ubuntu doesn’t create a password for <code class="inlineCode">root</code> by default, some <strong class="keyWord">Virtual Private Server</strong> (<strong class="keyWord">VPS</strong>) providers<a id="_idIndexMarker115"/> unlock the <code class="inlineCode">root</code> password and actually have you log in as the <code class="inlineCode">root</code> user. Having an unlocked <code class="inlineCode">root</code> account is not a standard Ubuntu practice, and is a customization specific to some cloud providers.</p>
<p class="normal">Unlocking the <code class="inlineCode">root</code> account is actually really simple; all you have to do is create a <code class="inlineCode">root</code> password. To do that, you can execute the following command as any user with <code class="inlineCode">sudo</code> access:</p>
<pre class="programlisting con"><code class="hljs-con">sudo passwd
</code></pre>
<p class="normal">The command will ask you to create and confirm your <code class="inlineCode">root</code> password. From this point on, you will be able to use the <code class="inlineCode">root</code> account as any other account. You can log in as <code class="inlineCode">root</code> or switch to <code class="inlineCode">root</code>—it’s fully available now. However, you really don’t have to unlock the <code class="inlineCode">root</code> account in order to use it. You certainly can, but there are ways to switch to <code class="inlineCode">root</code> without unlocking it, and it’s typically better to leave the <code class="inlineCode">root</code> account locked unless you have a very specific reason to unlock it. The following command will allow you to switch to <code class="inlineCode">root</code> from a user account that has <code class="inlineCode">sudo</code> access:</p>
<pre class="programlisting con"><code class="hljs-con">sudo su - 
</code></pre>
<p class="normal">Now you’ll be<a id="_idIndexMarker116"/> logged in as <code class="inlineCode">root</code> and will be able to execute any command you want with no restrictions whatsoever. To return to your previously logged-in account, simply type <code class="inlineCode">exit</code>. You can tell which user you’re logged in as by the value at the beginning of your <code class="inlineCode">bash</code> prompt.</p>
<p class="normal">What if you want to switch to an account other than <code class="inlineCode">root</code>? Of course, you can simply log out and then log in as that user. But you really don’t have to do that. The following command will do the job, providing you know the password for the account:</p>
<pre class="programlisting con"><code class="hljs-con">su - &lt;username&gt;
</code></pre>
<p class="normal">The shell will ask for that user’s password and then you’ll be logged in as that user. Again, type <code class="inlineCode">exit</code> when you’re done using the account, which will return you to the one you were using before you switched.</p>
<p class="normal">That command is all well and good if you know the user’s password, but you often won’t. Typically, in an enterprise, you’ll create an account, force the user to change their password at first login, and then you will no longer know that user’s password. </p>
<p class="normal">Since you have <code class="inlineCode">root</code> and <code class="inlineCode">sudo</code> access, you could always change their password and then log in as them. But they’ll know something is amiss if their password suddenly stops working—you’re not eavesdropping, are you? Armed with <code class="inlineCode">sudo</code> access, you can use <code class="inlineCode">sudo</code> to change to any user you want to, even if you don’t know their password. Just prefix our previous command with <code class="inlineCode">sudo</code> and you’ll only need to enter the password for your user account, instead of theirs:</p>
<pre class="programlisting con"><code class="hljs-con">sudo su - &lt;username&gt;
</code></pre>
<p class="normal">Switching to another user account is often very helpful for support (especially while troubleshooting permissions). As an example, say that a user comes to you complaining that they cannot access the contents of a specific directory, or they are unable to run a command. In that case, you can log in to the server, switch to their user account, and try to reproduce their problem. That way, you can not only see their problem yourself, but you can also test out whether or not your fix has solved their issue before you report back to them.</p>
<p class="normal">Now we have<a id="_idIndexMarker117"/> a full understanding of user accounts, and even how to switch between them. In the next section, we’ll look into groups, which allow us to categorize our users.</p>
<h1 class="heading-1" id="_idParaDest-43">Managing groups</h1>
<p class="normal">Now that we <a id="_idIndexMarker118"/>understand how to create, manage, and switch between user accounts, we’ll need to understand how to manage <strong class="keyWord">groups</strong> as well. The concept of groups in Linux is not very different from other platforms and pretty much serves the exact same purpose. With groups, you can more efficiently control a user’s access to resources on your server. By assigning a group to a resource (a file, a directory, and so on), you can allow and disallow access to users by simply adding them or removing them from the group.</p>
<p class="normal">The way this works in Linux is that every file or directory has both a user and a group that takes ownership of it. This is contrary to platforms such as Windows, which can have multiple groups assigned to a single resource. With Linux, it’s just one-to-one ownership: just one user and just one group assigned to each file or directory. If you list the contents of a directory on a Linux system, you can see this for yourself:</p>
<pre class="programlisting con"><code class="hljs-con">ls -l 
</code></pre>
<p class="normal">The following is a sample line of output from a directory on one of my servers:</p>
<pre class="programlisting con"><code class="hljs-con">-rw-r--r-- 1 root bind  490 2022-04-15 22:05 named.conf 
</code></pre>
<p class="normal">In this case, we can see that <code class="inlineCode">root</code> owns the file and that the group <code class="inlineCode">bind</code> is also assigned to it. Ignore the other fields for now; I’ll explain them later when we get to the section of this chapter dedicated to permissions. For now, just keep in mind that one user and one group are assigned to each file or directory.</p>
<p class="normal">While each file or directory can only have one group assignment, any user account can be a member of any number of groups. Entering the <code class="inlineCode">groups</code> command by itself with no options will tell you what groups your logged-in user is currently a member of. If you add a username to the <code class="inlineCode">groups</code> command, you’ll see which groups that user is a member of. Go ahead and give the <code class="inlineCode">groups</code> command a try with and without providing a username to get the idea.</p>
<p class="normal">On the Ubuntu Server platform, you’ll likely see that each of your user accounts is a member of a group that’s named the same as your username. As I mentioned earlier, when you create a user account, you’re also creating a group with the same name as the user. On some Linux distributions, though, a user’s primary group will default to a group called <code class="inlineCode">users</code> instead. If you were to execute the <code class="inlineCode">groups</code> command as a user on the Ubuntu desktop platform, you would likely see additional groups. This is due to the fact that distributions of Linux that cater to being a server platform are often more stripped down and users on desktop platforms need access to more objects such as printers, audio cards, and so <a id="_idIndexMarker119"/>on. Some packages that can be installed also add additional system users to the server.</p>
<p class="normal">If you were curious as to which groups exist on your server, all you would need to do is <code class="inlineCode">cat</code> the contents of the <code class="inlineCode">/etc/group</code> file. Similar to the <code class="inlineCode">/etc/passwd</code> file we covered earlier, the <code class="inlineCode">/etc/group</code> file contains information regarding the groups that have been created on your system. Go ahead and take a look at this file on your system:</p>
<pre class="programlisting con"><code class="hljs-con">cat /etc/group 
</code></pre>
<p class="normal">The following is sample output from this file on one of my servers:</p>
<figure class="mediaobject"><img alt="" height="275" src="../Images/B18425_02_10.png" width="742"/></figure>
<p class="packt_figref">Figure 2.10: Sample output from the /etc/group file</p>
<p class="normal">Like before, the columns in this file are separated by colons, though each line is only four columns long. In the first column, we have the name of the group. No surprise there. In the second, we are able to store a password for the group, but this is not used often as it’s actually a security risk to do so. In the third column, we have the GID, which is similar in concept to the UID from when we were discussing users. Finally, in the last column, we (would) see a comma-separated list of each user that is a member of each of the groups.</p>
<p class="normal">Several entries don’t<a id="_idIndexMarker120"/> show any group memberships at all. Each user is indeed a member of their own group, so this is implied even though it doesn’t explicitly call that out in this file. If you take a look at the <code class="inlineCode">/etc/passwd</code> entries for your users, you will see that their primary group (shown as the third column in the form of a GID) references a group contained in the <code class="inlineCode">/etc/group</code> file.</p>
<p class="normal">Creating new groups on your system is easy to do and is a great idea for categorizing your users and what they are able to do. Perhaps you create an <code class="inlineCode">accounting</code> group for your accountants, an <code class="inlineCode">admins</code> group for those in your IT department, and a <code class="inlineCode">sales</code> group for your salespeople. The <code class="inlineCode">groupadd</code> command allows you to create new groups. </p>
<p class="normal">If you wanted to, you could just edit the <code class="inlineCode">/etc/group</code> file and add a new line with your group information manually, although, in my opinion, using <code class="inlineCode">groupadd</code> saves you some work and ensures that group entries are created properly. Editing group and user files directly is typically frowned upon (and a typo can cause serious problems). Anyway, what follows is an example of creating a new group with the <code class="inlineCode">groupadd</code> command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo groupadd admins
</code></pre>
<p class="normal">If you take a look at the <code class="inlineCode">/etc/group</code> file again after adding a new group, you’ll see that a new line was created in the file and a <code class="inlineCode">GID</code> was chosen for you (the first one that hadn’t been used yet). Removing a group is just as easy. Just issue the <code class="inlineCode">groupdel</code> command followed by the name of the group you wish to remove:</p>
<pre class="programlisting con"><code class="hljs-con">sudo groupdel admins
</code></pre>
<p class="normal">Next, we’ll take a look at the <code class="inlineCode">usermod</code> command, which will allow you to actually associate users with groups. The <code class="inlineCode">usermod</code> command is more or less a Swiss Army knife; there are several things you can do with that command (adding a user to a group is just one of its abilities). If we wanted to add a user to our <code class="inlineCode">admins</code> group, we would issue the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo usermod -aG admins myuser
</code></pre>
<p class="normal">In that example, we’re supplying the <code class="inlineCode">-a</code> option, which means append, and immediately following that, we’re using <code class="inlineCode">-G</code>, which means we would like to modify secondary group membership. I put the two options together with a single dash (<code class="inlineCode">-aG</code>), but you could also issue them <a id="_idIndexMarker121"/>separately (<code class="inlineCode">-a -G</code>). The example I gave only adds the user to additional groups; it doesn’t replace their primary group.</p>
<p class="normal">Be careful not to miss the <code class="inlineCode">-a</code> option here, as by doing so, you will instead replace all current group memberships with the new one, which is usually not what you want. The <code class="inlineCode">-a</code> option means append, or to add the existing list of group memberships for that user.</p>
<p class="normal">If you wanted to change a user’s primary group, you would use the <code class="inlineCode">-g</code> option instead (lowercase <em class="italic">g</em> instead of an uppercase <em class="italic">G</em> as we used earlier):</p>
<pre class="programlisting con"><code class="hljs-con">sudo usermod -g &lt;group-name&gt; &lt;username&gt;
</code></pre>
<p class="normal">Feel free to check out the man pages for the <code class="inlineCode">usermod</code> command, to see all the nifty things it allows you to manage relating to your users. You can peruse the man page for the <code class="inlineCode">usermod</code> command with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">man usermod
</code></pre>
<p class="normal">One additional example is changing a user’s <code class="inlineCode">/home</code> directory. Suppose that one of your users has undergone a name change, so you’d like to change their username, as well as moving their previous <code class="inlineCode">home</code> directory (and their files) to a new one. The following commands will take care of that:</p>
<pre class="programlisting con"><code class="hljs-con">sudo usermod -d /home/jsmith jdoe -m 
sudo usermod -l jsmith jdoe 
</code></pre>
<p class="normal">In that example, we’re moving the home directory for <code class="inlineCode">jdoe</code> to <code class="inlineCode">/home/jsmith</code>, and then in the second example, we’re changing the username from <code class="inlineCode">jdoe</code> to <code class="inlineCode">jsmith</code>.</p>
<p class="normal">If you wish to remove a user from a group, you can use the <code class="inlineCode">gpasswd</code> command to do so. <code class="inlineCode">gpasswd -d</code> will do the trick:</p>
<pre class="programlisting con"><code class="hljs-con">sudo gpasswd -d &lt;username&gt; &lt;grouptoremove&gt; 
</code></pre>
<p class="normal">In fact, <code class="inlineCode">gpasswd</code> can also be used in place of <code class="inlineCode">usermod</code> to add a user to a group:</p>
<pre class="programlisting con"><code class="hljs-con">sudo gpasswd -a &lt;username&gt; &lt;group&gt; 
</code></pre>
<p class="normal">So, now you know how to manage groups. With the efficient management of groups, you’ll be able to manage the resources on your server better. Of course, groups are relatively useless<a id="_idIndexMarker122"/> without some explanation of how to manage permissions (otherwise, nothing would actually allow a member of a group access to a resource). Later on in this chapter, we’ll cover permissions so that you have a complete understanding of how to manage user access.</p>
<h1 class="heading-1" id="_idParaDest-44">Managing passwords and password policies</h1>
<p class="normal">In this<a id="_idIndexMarker123"/> chapter, we’ve <a id="_idIndexMarker124"/>already covered a bit of password management, since I’ve given you a few examples of the <code class="inlineCode">passwd</code> command. If you recall, the <code class="inlineCode">passwd</code> command allows us to change the password of the currently logged-in user. In addition, using <code class="inlineCode">passwd</code> as <code class="inlineCode">root</code> (and supplying a username) allows us to change the password for any user account on our system. But that’s not all this command can do.</p>
<h2 class="heading-2" id="_idParaDest-45">Locking and unlocking user accounts</h2>
<p class="normal">One thing I’ve <a id="_idIndexMarker125"/>neglected <a id="_idIndexMarker126"/>to mention regarding the <code class="inlineCode">passwd</code> command is the fact that you can use it to lock and unlock a user’s account. There are many reasons why you may want to do this. For instance, if a user is going on vacation or extended leave, perhaps you’d want to lock their account so that it cannot be used while they are away. After all, the fewer active accounts, the smaller your attack surface. To lock an account, use the <code class="inlineCode">-l</code> option:</p>
<pre class="programlisting con"><code class="hljs-con">sudo passwd -l &lt;username&gt;
</code></pre>
<p class="normal">And to unlock it, use the <code class="inlineCode">-u</code> option:</p>
<pre class="programlisting con"><code class="hljs-con">sudo passwd -u &lt;username&gt;
</code></pre>
<p class="normal">However, locking an account will not prevent the user from logging in if they have access to the server via SSH while utilizing public key authentication. In that case, you’d want to remove their ability to use SSH as well. One common way of doing this is to limit SSH access to users who are members of a specific group. When you lock an account, simply remove them from the group. Don’t worry so much about the SSH portion of this discussion if this is new to you. We will discuss securing your SSH server in <em class="chapterRef">Chapter 21</em>, <em class="italic">Securing Your Server</em>. For now, just keep in mind that you can use <code class="inlineCode">passwd</code> to lock or unlock accounts, and if you utilize SSH, you’ll want to lock your users out of that to prevent them from logging in.</p>
<p class="normal">However, there’s <a id="_idIndexMarker127"/>more to password management <a id="_idIndexMarker128"/>than the <code class="inlineCode">passwd</code> command, as we can also implement our own policies, such as viewing or adjusting password expiration details.</p>
<h2 class="heading-2" id="_idParaDest-46">Setting password expiration information</h2>
<p class="normal">Earlier, I mentioned<a id="_idIndexMarker129"/> that you can set an expiration date on a user’s password (during our discussion on the <code class="inlineCode">/etc/shadow</code> file). In this section, we’ll go through how to actually do that. Specifically, the <code class="inlineCode">chage</code> command gives us this ability. We can use <code class="inlineCode">chage</code> to alter the expiration period of a user’s password, but it’s also a more convenient way of viewing current expiration information than viewing the <code class="inlineCode">/etc/shadow</code> file. With the <code class="inlineCode">-l</code> option of <code class="inlineCode">chage</code>, along with providing a username, we can see the relevant info:</p>
<pre class="programlisting con"><code class="hljs-con">sudo chage -l &lt;username&gt;
</code></pre>
<p class="normal">Using <code class="inlineCode">sudo</code> or <code class="inlineCode">root</code> is not required to run <code class="inlineCode">chage</code>. You’re able to view expiration information for your own username without needing to escalate permissions. However, if you want to view information via <code class="inlineCode">chage</code> for any user account other than your own, you will need to use <code class="inlineCode">sudo</code>.</p>
<p class="normal">In the example that follows, we can see the output of this command from a sample user account:</p>
<figure class="mediaobject"><img alt="" height="250" src="../Images/B18425_02_11.png" width="743"/></figure>
<p class="packt_figref">Figure 2.11: Output from the chage command</p>
<p class="normal">In the output, we can see values for the date of expiration, the maximum number of days between password changes, and so on. Basically, it’s the same information stored in <code class="inlineCode">/etc/shadow</code> but it’s much easier to read.</p>
<p class="normal">If you would like <a id="_idIndexMarker130"/>to change this information, <code class="inlineCode">chage</code> will again be the tool of choice. The first example I’ll provide is a very common one. When creating user accounts, you’ll certainly want them to change their password when they first log in.</p>
<p class="normal">Unfortunately, not everyone will be keen on doing so. The <code class="inlineCode">chage</code> command allows you to force a password change for a user when they first log in. Basically, you can set their number of days to expiry to <code class="inlineCode">0</code> as follows:</p>
<pre class="programlisting con"><code class="hljs-con">sudo chage -d 0 &lt;username&gt;
</code></pre>
<p class="normal">You can see the results of this command immediately if you run <code class="inlineCode">chage -l</code> again against the user account you just modified:</p>
<pre class="programlisting con"><code class="hljs-con">sudo chage -l &lt;username&gt;
</code></pre>
<p class="normal">The output will display information regarding the password change:</p>
<figure class="mediaobject"><img alt="" height="243" src="../Images/B18425_02_12.png" width="824"/></figure>
<p class="packt_figref">Figure 2.12: The chage command listing a user that has a required password change period set</p>
<p class="normal">To set a user account to require a password change after a certain period of days, the following will do the trick:</p>
<pre class="programlisting con"><code class="hljs-con">sudo chage -M 90 &lt;username&gt; 
</code></pre>
<p class="normal">In that example, I’m setting the user account to expire and require a password change in 90 days. When the impending date reaches 7 days before the password is to be changed, the user <a id="_idIndexMarker131"/>will see a warning message when they log in.</p>
<p class="normal">As I mentioned earlier, users will often do whatever they can to cheat password requirements and may try to change their password back to what it was originally after satisfying the initially required password change. You can set the minimum number of days with the <code class="inlineCode">-m</code> flag, as you can see in the next example where we set it to 5 days:</p>
<pre class="programlisting con"><code class="hljs-con">sudo chage -m 5 dscully
</code></pre>
<p class="normal">The trick with setting a minimum password age is to set it so that it will be inconvenient for the user to change their password to the original one, but you still want a user to be able to change their password when they feel the need to (so don’t set it too long, either). If a user wants to change their password before the minimum number of days elapses (for example, if your user feels that their account may have been compromised), they can always have you change it for them. However, if you make your password requirements too much of an inconvenience for your users, it can also work against you.</p>
<h2 class="heading-2" id="_idParaDest-47">Setting a password policy</h2>
<p class="normal">Next, we<a id="_idIndexMarker132"/> should discuss setting a password policy. After all, forcing your users to change their passwords does little good if they change it to something simple, such as <code class="inlineCode">abc123</code>. A password policy allows you to force requirements on your users for things such as length, complexity, and so on.</p>
<p class="normal">To facilitate this, we<a id="_idIndexMarker133"/> have <strong class="keyWord">Pluggable Authentication Module</strong> (<strong class="keyWord">PAM</strong>) at our disposal. PAM gives us additional functionality and control over the process of authentication, and also provides additional plugins we can use to extend authentication and add additional features. Although a full walkthrough of PAM isn’t covered in this book, I recommend keeping it fresh in your mind in case you want to add additional features later.</p>
<p class="normal">Specific to the subject of setting up a password policy, we can install a PAM module to enable this, which involves installing a new package:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install libpam-cracklib
</code></pre>
<p class="normal">Next, let’s take a look at the following file, which is provided with Ubuntu. Feel free to open it with a text editor, such as <code class="inlineCode">nano</code>, as we’ll need to edit it:</p>
<pre class="programlisting con"><code class="hljs-con">sudo nano /etc/pam.d/common-password
</code></pre>
<p class="normal">An extremely important tip while modifying configuration files related to authentication (such as password requirements, <code class="inlineCode">sudo</code> access, SSH, and so on) is to always keep a <code class="inlineCode">root</code> shell open at all times while you make changes, and in another shell, test those changes. Do not log out of your initial <code class="inlineCode">root</code> window until you are 100% certain that your changes have been thoroughly tested. While testing a policy, make sure that not only can your users log in, but your admins too. Otherwise, you may remove your ability to log in to a server and make changes.</p>
<p class="normal">To enable a history requirement for your passwords (meaning the system remembers the last several passwords a user has used, preventing them from reusing them), we can add the following line to the file:</p>
<pre class="programlisting code"><code class="hljs-code">password   required   pam_pwhistory.so remember=99 use_authok
</code></pre>
<p class="normal">In the example <code class="inlineCode">config</code> line, I’m using <code class="inlineCode">remember=99</code>, which (as you can probably guess) will cause our system to remember the last 99 passwords for each user and prevent them from using those passwords again. If you’ve configured a minimum password age earlier, for example, 5 days, it would take the user 495 days to cycle back to their original password if you take into account that the user changes their password once every 5 days, 99 times. That pretty much makes it impossible for the user to utilize their old passwords.</p>
<p class="normal">Another field worth mentioning within the <code class="inlineCode">/etc/pam.d/common-password</code> file is the section that reads <code class="inlineCode">difok=3</code>. This configuration mandates that at least three characters have to be different before the password is considered acceptable. Otherwise, the password would be deemed too similar to the old one and refused. You can change this value to whatever you like; the default is normally <code class="inlineCode">5</code> but Ubuntu defaults it to <code class="inlineCode">3</code> in their implementation of this config file. In addition, you’ll also see <code class="inlineCode">obscure</code> mentioned in the file as well, which prevents simple passwords from being used (such as common dictionary words and so on).</p>
<p class="normal">Setting a password policy is a great practice to increase the security of your server. However, it’s also important to not get carried away. In order to strike a balance between security and user frustration, the challenge is always to create enough restrictions to increase your security, while trying to minimize the frustration of your users. Of course, the mere mention of the word “password” to a typical user is enough to frustrate them, so you can’t please everyone. But in terms of overall system security, I’m sure your users will appreciate the fact that they can be reasonably sure that you as an administrator have taken the necessary precautions to keep their (and your company’s) data<a id="_idIndexMarker134"/> safe. When it comes down to it, use your best judgment.</p>
<p class="normal">Since we’re on the subject of security, we should also take a look at configuring <code class="inlineCode">sudo</code> itself, which we’ll take care of in the next section.</p>
<h1 class="heading-1" id="_idParaDest-48">Configuring administrator access with sudo</h1>
<p class="normal">By now, we’ve<a id="_idIndexMarker135"/> already used <code class="inlineCode">sudo</code> quite a few<a id="_idIndexMarker136"/> times in this book. At this point, you should already be aware of the fact that <code class="inlineCode">sudo</code> allows you to execute commands as if you were logged in as another user, with <code class="inlineCode">root</code> being the default. However, we haven’t had any formal discussion about it yet, nor have we discussed how to actually modify which of your user accounts are able to utilize <code class="inlineCode">sudo</code>.</p>
<p class="normal">On all Linux systems, you should protect your <code class="inlineCode">root</code> account with a strong password and limit it to being used by as few people as possible. On Ubuntu, the <code class="inlineCode">root</code> account is locked anyway, so unless you unlocked it by setting a password (or you’re using a version of Ubuntu supplied by a VPS provider), it cannot be used to log in to the system. Using <code class="inlineCode">sudo</code> is an alternative to logging in as <code class="inlineCode">root</code> to execute commands directly, so you can give your administrators access to perform tasks that require <code class="inlineCode">root</code> privileges with <code class="inlineCode">sudo</code> without actually giving them your <code class="inlineCode">root</code> password or unlocking the <code class="inlineCode">root</code> account. In fact, <code class="inlineCode">sudo</code> allows you to be a bit more granular. Using <code class="inlineCode">root</code> directly is basically all or nothing—if someone knows the <code class="inlineCode">root</code> password and the <code class="inlineCode">root</code> account is enabled, that person is not limited and can do whatever they want. With <code class="inlineCode">sudo</code>, that can also be true, but you can actually restrict some users to use only particular commands and therefore limit the scope of what they are able to do on the system. For example, you could give an admin access to install software updates but not allow them to reboot the server.</p>
<p class="normal">By default, members of the <code class="inlineCode">sudo</code> group are able to use <code class="inlineCode">sudo</code> without any restrictions. Basically, members of this group can do anything <code class="inlineCode">root</code> can do (which is everything). During installation, the user account you created was made a member of <code class="inlineCode">sudo</code>. To give additional users access to <code class="inlineCode">sudo</code>, all you would need to do is add them to the <code class="inlineCode">sudo</code> group:</p>
<pre class="programlisting con"><code class="hljs-con">sudo usermod -aG sudo &lt;username&gt;
</code></pre>
<p class="normal">Not all distributions <a id="_idIndexMarker137"/>utilize the <code class="inlineCode">sudo</code> group by default, or <a id="_idIndexMarker138"/>even automatically install <code class="inlineCode">sudo</code>. Other distributions require you to install <code class="inlineCode">sudo</code> manually and may use another group (such as <code class="inlineCode">wheel</code>) to govern access to <code class="inlineCode">sudo</code>.</p>
<p class="normal">But again, that gives those users access to everything, and that may or may not be what you want. To actually configure <code class="inlineCode">sudo</code>, we use the <code class="inlineCode">visudo</code> command. This command assists you with editing <code class="inlineCode">/etc/sudoers</code>, which is the configuration file that governs <code class="inlineCode">sudo</code> access. Although you can edit <code class="inlineCode">/etc/sudoers</code> yourself with a text editor, configuring <code class="inlineCode">sudo</code> in that way is strongly discouraged. The <code class="inlineCode">visudo</code> command checks to make sure your changes follow the correct syntax and helps prevent you from accidentally destroying the file. This is a very good approach, because if you did make any errors in the <code class="inlineCode">/etc/sudoers</code> file, you may wind up in a situation where no one is able to gain administrative control over the server. And while there are ways to recover from such a mistake, it’s certainly not a very pleasant situation to find yourself in! So, the takeaway here is never to edit the <code class="inlineCode">/etc/sudoers</code> file directly; always use <code class="inlineCode">visudo</code> to do so.</p>
<p class="normal">Here’s an example of the type of warning the <code class="inlineCode">visudo</code> command shows when you make a mistake:</p>
<figure class="mediaobject"><img alt="" height="183" src="../Images/B18425_02_13.png" width="649"/></figure>
<p class="packt_figref">Figure 2.13: The visudo command showing an error</p>
<p class="normal">If you do see this error, press <em class="keystroke">e</em> to return to edit the file, and then correct the mistake.</p>
<p class="normal">The way this works is when you run <code class="inlineCode">visudo</code> from your shell, you are brought into a text editor with the <code class="inlineCode">/etc/sudoers</code> file opened up. You can then make changes to the file and save it like you would any other text file. By default, Ubuntu opens up the <code class="inlineCode">nano</code> text editor when you use <code class="inlineCode">visudo</code>. With <code class="inlineCode">nano</code>, you can save changes using <em class="keystroke">Ctrl</em> + <em class="keystroke">w</em>, and you can exit the text editor with <em class="keystroke">Ctrl</em> + <em class="keystroke">x</em>.</p>
<p class="normal">So <code class="inlineCode">visudo</code> allows you to make changes to who is able to access <code class="inlineCode">sudo</code>. But how do you actually make these changes? Go ahead and scroll through the <code class="inlineCode">/etc/sudoers</code> file that <code class="inlineCode">visudo</code> opens and<a id="_idIndexMarker139"/> you should see a line similar to the<a id="_idIndexMarker140"/> following:</p>
<pre class="programlisting code"><code class="hljs-code">%sudo   ALL=(ALL:ALL) ALL 
</code></pre>
<p class="normal">This is the line of configuration that enables <code class="inlineCode">sudo</code> access to anyone who is a member of the <code class="inlineCode">sudo</code> group. You can change the group name to any that you’d like, for example, perhaps you’d like to create a group called <code class="inlineCode">admins</code> instead. If you do change this, make sure that you actually create that group and add yourself and your staff to be members of it before you edit the <code class="inlineCode">/etc/sudoers</code> file or log off; it would be rather embarrassing if you found yourself locked out of administrator access to the server.</p>
<p class="normal">Of course, you don’t have to enable access by group. You can actually call out a username instead. With the <code class="inlineCode">/etc/sudoers</code> file, groups are preceded by <code class="inlineCode">%</code>, while users are not. As an example of this, we also have the following line in the file:</p>
<pre class="programlisting code"><code class="hljs-code">root    ALL=(ALL:ALL) ALL 
</code></pre>
<p class="normal">Here, we’re calling out a username (in this case, <code class="inlineCode">root</code>), but the rest of the line is the same as the one I pointed out before. While you can certainly copy this line and paste it one or more times (substituting <code class="inlineCode">root</code> for a different username) to grant access to others, using the group approach is really the best way. It’s easier to add and remove users from a group (such as the <code class="inlineCode">sudo</code> group) than it is to use <code class="inlineCode">visudo</code> each time.</p>
<p class="normal">So, at this point, you’re probably wondering what the options on <code class="inlineCode">/etc/sudoers</code> configuration lines actually mean. So far, both examples used <code class="inlineCode">ALL=(ALL:ALL) All</code>. In order to fully understand <code class="inlineCode">sudo</code>, understanding the other fields is extremely important, so let’s go through them (using the <code class="inlineCode">root</code> line again as an example).</p>
<p class="normal">The first <code class="inlineCode">ALL</code> means that <code class="inlineCode">root</code> is able to use <code class="inlineCode">sudo</code> from any terminal. The second <code class="inlineCode">ALL</code> means that <code class="inlineCode">root</code> can use <code class="inlineCode">sudo</code> to impersonate any other user. The third <code class="inlineCode">ALL</code> means that <code class="inlineCode">root</code> can impersonate any other group. Finally, the last <code class="inlineCode">ALL</code> refers to what commands this user is able to use; in this case, any command they wish.</p>
<p class="normal">To help drive this home, I’ll give some additional examples. Here’s a hypothetical example:</p>
<pre class="programlisting con"><code class="hljs-con">charlie    ALL=(ALL:ALL) /sbin/reboot,/sbin/shutdown 
</code></pre>
<p class="normal">Here, we’re allowing user <code class="inlineCode">charlie</code> to execute the <code class="inlineCode">reboot</code> and <code class="inlineCode">shutdown</code> commands. If user <code class="inlineCode">charlie</code> tries to<a id="_idIndexMarker141"/> do something else (such as <a id="_idIndexMarker142"/>install a package), they will receive an error message:</p>
<pre class="programlisting con"><code class="hljs-con">Sorry, user charlie is not allowed to execute '/usr/bin/apt install tmux' as root on ubuntu. 
</code></pre>
<p class="normal">However, if <code class="inlineCode">charlie</code> wants to use the <code class="inlineCode">reboot</code> or <code class="inlineCode">shutdown</code> commands on the server, they will be able to do so because we explicitly called out those commands while setting up this user’s <code class="inlineCode">sudo</code> access. We can limit this further by changing the first <code class="inlineCode">ALL</code> to a machine name, in this case, <code class="inlineCode">ubuntu</code>, to reference the host name of the server I’m using for my examples. I’ve also changed the command that <code class="inlineCode">charlie</code> is allowed to run:</p>
<pre class="programlisting con"><code class="hljs-con">charlie    ubuntu=(ALL:ALL) /usr/bin/apt 
</code></pre>
<p class="normal">It’s always a good idea to use full paths to commands when editing <code class="inlineCode">sudo</code> permissions, rather than the shortened versions. For example, we used <code class="inlineCode">/usr/bin/apt</code> here, instead of just <code class="inlineCode">apt</code>. This is important, as the user could create a script named <code class="inlineCode">apt</code> to do mischievous things that we normally wouldn’t allow them to do. By using the full path, we’re limiting the user to the binary stored at that path.</p>
<p class="normal">Now, <code class="inlineCode">charlie</code> is only able to use <code class="inlineCode">apt</code>. They can use <code class="inlineCode">apt update</code>, <code class="inlineCode">apt dist-upgrade</code>, and any other sub-command of <code class="inlineCode">apt</code>. But if they try to reboot the server, remove protected files, add users, or anything else we haven’t explicitly set, they will be prevented from doing so.</p>
<p class="normal">We have another problem, though. We’re allowing <code class="inlineCode">charlie</code> to impersonate other users. This may not be completely terrible given the context of installing packages (impersonating another user would be useless unless that user also has access to install packages), but it’s bad form to allow this unless we really need to. In this case, we could just remove the <code class="inlineCode">(ALL:ALL)</code> from the line altogether to prevent <code class="inlineCode">charlie</code> from using the <code class="inlineCode">-u</code> option of <code class="inlineCode">sudo</code> to run commands as other users:</p>
<pre class="programlisting con"><code class="hljs-con">charlie    ubuntu= /usr/bin/apt
</code></pre>
<p class="normal">On the other hand, if we actually do want <code class="inlineCode">charlie</code> to be able to impersonate other users (but only<a id="_idIndexMarker143"/> specific users), we can call out the <a id="_idIndexMarker144"/>username and group that <code class="inlineCode">charlie</code> is allowed to act on behalf of by setting those values:</p>
<pre class="programlisting con"><code class="hljs-con">charlie    ubuntu=(dscully:admins) ALL
</code></pre>
<p class="normal">In that example, <code class="inlineCode">charlie</code> is able to run commands on behalf of the user <code class="inlineCode">dscully</code> and the group <code class="inlineCode">admins</code>.</p>
<p class="normal">Of course, there is much more to <code class="inlineCode">sudo</code> than what I’ve mentioned in this section. Entire books could be written about <code class="inlineCode">sudo</code> (and have been), but 99% of what you will need for your daily management of this tool involves how to add access to users while being specific about what each user is able to do. As a best practice, use groups when you can (for example, you could have an <code class="inlineCode">apt</code> group, a <code class="inlineCode">reboot</code> group, and so on) and be as specific as you can regarding who is able to do what. This way, you’re not only able to keep the <code class="inlineCode">root</code> account private (or even better, disabled), but you also have more accountability on your servers.</p>
<p class="normal">Now that we’ve explored granting access to <code class="inlineCode">sudo</code>, we will next take a look at permissions, which give us even more control over what our users are able to access.</p>
<h1 class="heading-1" id="_idParaDest-49">Setting permissions on files and directories</h1>
<p class="normal">In this section, all <a id="_idIndexMarker145"/>the user management<a id="_idIndexMarker146"/> we’ve done in this chapter so far all comes together. We’ve learned how to add accounts, manage accounts, and secure them, but we haven’t actually done any work regarding managing the resources as far as who is able to access them. In this section, I’ll give you a brief overview of how permissions work in Ubuntu Server and then I’ll provide some examples for customizing them.</p>
<h2 class="heading-2" id="_idParaDest-50">Viewing permissions</h2>
<p class="normal">I’m sure by now<a id="_idIndexMarker147"/> that you understand how to list the contents of a directory with the <code class="inlineCode">ls</code> command. When it comes to viewing permissions, the <code class="inlineCode">-l</code> flag is especially handy, as the output that the long listing provides allows us to view the permissions of an object:</p>
<pre class="programlisting con"><code class="hljs-con">ls -l
</code></pre>
<p class="normal">The following are some example, hypothetical file listings:</p>
<pre class="programlisting con"><code class="hljs-con">-rw-rw-rw- 1 doctor   5        Jan 11   12:52 welcome 
-rw-r--r-- 1 root     root   665      Feb 19   profile 
-rwxr-xr-x 1 dalek   dalek   35125    Nov  7   exterminate 
</code></pre>
<p class="normal">In each line, we see several fields of information. The first column is our permission string for the object (for example, <code class="inlineCode">-rw-r—r--</code>), which we’ll cover in more detail shortly. We also see the link count for the object (second column). Links are beyond the scope of this chapter but will be discussed in <em class="chapterRef">Chapter 5</em>, <em class="italic">Managing Files and Directories</em>. Continuing on, the user that owns the file is displayed in the third column, the group that owns the file is in the fourth column, the size in bytes is in the fifth, the last date the file was modified is in the sixth, and finally there is the name of the file.</p>
<p class="normal">Keep in mind that depending on how your shell is configured, your output may look different and the fields may be in different places. For the sake of our discussion on permissions, what we’re really concerned with is the permissions string, as well as the owning user and group. In this case, we can see that the first file (named <code class="inlineCode">welcome</code>) is owned by a user named <code class="inlineCode">doctor</code>. The second file is named <code class="inlineCode">profile</code> and is owned by <code class="inlineCode">root</code>. Finally, we have a file named <code class="inlineCode">exterminate</code> owned by a user named <code class="inlineCode">dalek</code>.</p>
<p class="normal">With these files, we have the permission strings of <code class="inlineCode">-rw-rw-rw-</code>, <code class="inlineCode">-rw-r--r--</code>, and <code class="inlineCode">-rwxr-xr-x</code> respectively. If you haven’t worked with permissions before, these may seem strange, but it’s actually quite easy when you break them down. Each permission string can be broken down into four groups, as I’ll show you in the following table:</p>
<table class="table-container" id="table001">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Object type</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">User</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Group</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">World</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">-</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">rw-</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">rw-</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">rw-</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">-</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">rw-</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">r--</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">r--</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">-</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">rwx</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">rwx</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">r-x</code></p>
</td>
</tr>
</tbody>
</table>
<p class="normal">I’ve broken down <a id="_idIndexMarker148"/>each of the three example permission strings into four groups. Basically, I split them each at the first character and then again every third. The first section of a permission string is just one character. In each of these examples, it’s just a single hyphen. This refers to what type the object is. Is it a directory? A file? A link? In our case, each of these permission strings is a file, because the first positions of the permission strings are all hyphens. If the object were a directory, the first character would’ve been a <code class="inlineCode">d</code> instead of a <code class="inlineCode">-</code>. If the object were a link, this field would’ve been <code class="inlineCode">l</code> (lowercase <em class="italic">L</em>) instead.</p>
<p class="normal">In the next section, in the second column of each object, we have three characters, <code class="inlineCode">rw-</code>, <code class="inlineCode">rw-</code>, and <code class="inlineCode">rwx</code> respectively. This refers to the permissions that apply to the user that owns the file. For example, here is the first permission string again:</p>
<pre class="programlisting con"><code class="hljs-con">-rw-rw-rw- 1 doctor doctor    5 Jan 11 12:52 welcome
</code></pre>
<p class="normal">The third section of the preceding code output shows us that <code class="inlineCode">doctor</code> is the user that owns the file. Therefore, referring back to the table, the second column of the permission string (<code class="inlineCode">rw-</code>) applies specifically to the user <code class="inlineCode">doctor</code>. Moving on, the third column of permissions is also three characters; in this case, <code class="inlineCode">rw-</code> again. This section of the permissions string refers to the group that owns the file. In this case, the group is also named <code class="inlineCode">doctor</code>, as you can see in column four of the preceding code output. Finally, the last section of the permission string, visualized in the table (<code class="inlineCode">rw-</code> yet again, in this case), refers to <code class="inlineCode">world</code>, also known as <em class="italic">other</em>. This basically refers to anyone else other than the owning user and owning group. Therefore, literally everyone else gets at least <code class="inlineCode">rw-</code> permissions on the object.</p>
<p class="normal">Individually, <code class="inlineCode">r</code> stands for <em class="italic">read</em> and <code class="inlineCode">w</code> stands for <em class="italic">write</em>. Therefore, we can read the second column (<code class="inlineCode">rw-</code>), indicating that the user (<code class="inlineCode">doctor</code>) has access to read and write to this file. The third column (<code class="inlineCode">rw-</code> again) tells us the <code class="inlineCode">doctor</code> group also has read and write access to this file. The fourth column of the permission string is the same, so anyone else would also have read and write permissions to the file as well.</p>
<p class="normal">The third permission string I gave as an example looks a bit different. Here it is again:</p>
<pre class="programlisting con"><code class="hljs-con">-rwxr-xr-x 1 dalek dalek      35125 Nov  7  exterminate
</code></pre>
<p class="normal">Here, we see the <code class="inlineCode">x</code> attribute set. The <code class="inlineCode">x</code> attribute refers to the ability to execute the file as a script. So, with that in mind, we know that this file is likely a script and is executable by users, groups, and others. Given the filename of <code class="inlineCode">exterminate</code>, this is rather suspicious, and if it were a real file, we’d probably want to look into it.</p>
<p class="normal">If a permission is not set, it will simply be a single hyphen where there would normally be <code class="inlineCode">r</code>, <code class="inlineCode">w</code>, or <code class="inlineCode">x</code>. This is <a id="_idIndexMarker149"/>the same as indicating that a permission is disabled. Here are some examples:</p>
<ul>
<li class="bulletList"><code class="inlineCode">rwx</code>: Object has read, write, and execute permissions set for this field</li>
<li class="bulletList"><code class="inlineCode">r-x</code>: Object has read enabled, write disabled, and execute enabled for this field</li>
<li class="bulletList"><code class="inlineCode">r--</code>: Object has read enabled, write disabled, and execute disabled for this field</li>
<li class="bulletList"><code class="inlineCode">---</code>: Object has no permissions enabled for this field</li>
</ul>
<p class="normal">Bringing this discussion all the way home, here are a few more permission strings:</p>
<pre class="programlisting con"><code class="hljs-con">-rw-r--r-- 1   sue   accounting      35125  Nov  7  budget.txt 
drwxr-x--- 1   bob   sales           35125  Nov  7  annual_projects 
</code></pre>
<p class="normal">For the first of these examples, we see that <code class="inlineCode">sue</code> is the owning user of <code class="inlineCode">budget.txt</code> and that this file is assigned an accounting group. This object is readable and writable by <code class="inlineCode">sue</code> and readable by everyone else (<code class="inlineCode">group</code> and <code class="inlineCode">world</code>). This is probably bad, considering this is a budget file and is probably confidential. We’ll change it later.</p>
<p class="normal">The <code class="inlineCode">annual_projects</code> object is a directory, which we can tell from the <code class="inlineCode">d</code> in the first column. This directory is owned by the <code class="inlineCode">bob</code> user and the <code class="inlineCode">sales</code> group. However, since this is a directory, each of the permission bits has different meanings. In the following two tables, I’ll outline the meanings of these bits for files and again for directories:</p>
<ul>
<li class="bulletList">Files:</li>
</ul>
<table class="table-container" id="table002">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Bit</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Meaning</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">r</code></p>
</td>
<td class="table-cell">
<p class="normal">The file can be read</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">w</code></p>
</td>
<td class="table-cell">
<p class="normal">The file can be written to</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">x</code></p>
</td>
<td class="table-cell">
<p class="normal">The file can be executed as a program</p>
</td>
</tr>
</tbody>
</table>
<ul>
<li class="bulletList">Directories:</li>
</ul>
<table class="table-container" id="table003">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Bit</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Meaning</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">r</code></p>
</td>
<td class="table-cell">
<p class="normal">The contents of the directory can be viewed</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">w</code></p>
</td>
<td class="table-cell">
<p class="normal">The contents of the directory can be altered</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">x</code></p>
</td>
<td class="table-cell">
<p class="normal">The user or group can use <code class="inlineCode">cd</code> to go inside the directory</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">As you can see, permissions are read differently depending on their context: whether they apply to a file or a directory. In the example of the <code class="inlineCode">annual_projects</code> directory, <code class="inlineCode">bob</code> has <code class="inlineCode">rwx</code> permissions to the directory. This means that the user <code class="inlineCode">bob</code> can do everything (view the contents, add or remove contents, and use <code class="inlineCode">cd</code> to move the current directory of his shell into the directory). Regarding a group, members of the <code class="inlineCode">sales</code> group are able to view the contents of this directory and <code class="inlineCode">cd</code> into it. However, no one in the <code class="inlineCode">sales</code> group can add or remove<a id="_idIndexMarker150"/> items to or from the directory. On this object, <em class="italic">other</em> has no permissions set at all. This means that no one else can do anything at all with this object, not even view its contents.</p>
<h2 class="heading-2" id="_idParaDest-51">Changing permissions</h2>
<p class="normal">So, now we<a id="_idIndexMarker151"/> understand how to read permissions on files and directories. That’s great, but how do we alter them? As I mentioned earlier, the <code class="inlineCode">budget.txt</code> file is readable by everyone (<em class="italic">other</em>). This is not good because the file is confidential. To change permissions on an object, we will use the <code class="inlineCode">chmod</code> command. This command allows us to alter the permissions of files and directories in a few different ways.</p>
<p class="normal">First, we can simply remove read access from the <code class="inlineCode">sue</code> user’s budget file by removing the read bit from the other field. We can do that with the following example:</p>
<pre class="programlisting con"><code class="hljs-con">chmod o-r budget.txt
</code></pre>
<p class="normal">If we are currently not in the directory where the file resides, we need to give a full path:</p>
<pre class="programlisting con"><code class="hljs-con">chmod o-r /home/sue/budget.txt
</code></pre>
<p class="normal">If you’re using the <code class="inlineCode">chmod</code> command against files other than those you own yourself, you’ll need to use <code class="inlineCode">sudo</code>.</p>
<p class="normal">But either way, you probably get the idea. With this example, we’re removing the <code class="inlineCode">r</code> bit from <em class="italic">other</em> (<code class="inlineCode">o-r</code>). If we wanted to add this bit instead, we would simply use <code class="inlineCode">+</code> instead of <code class="inlineCode">-</code>. Here are some additional examples of <code class="inlineCode">chmod</code> in action:</p>
<ul>
<li class="bulletList"><code class="inlineCode">chmod u+rw &lt;filename&gt;</code>: The object gets <code class="inlineCode">rw</code> added to the <code class="inlineCode">user</code> column</li>
<li class="bulletList"><code class="inlineCode">chmod g+r &lt;filename&gt;</code>: The owning group is given read access</li>
<li class="bulletList"><code class="inlineCode">chmod o-rw &lt;filename&gt;</code>: <em class="italic">Other</em> is stripped of the <code class="inlineCode">rw</code> bits</li>
</ul>
<p class="normal">In addition, you can also use octal point values to manage and modify permissions. This is actually the most common method of altering permissions. I like to think of this as a scoring system. That’s not what it is, but it makes it a lot easier to understand to think of each type of access as having its own value. Basically, each of the permission bits (<code class="inlineCode">r</code>, <code class="inlineCode">w</code>, and <code class="inlineCode">x</code>) has its <a id="_idIndexMarker152"/>own octal equivalent, as follows:</p>
<ul>
<li class="bulletList">Read: <code class="inlineCode">4</code></li>
<li class="bulletList">Write: <code class="inlineCode">2</code></li>
<li class="bulletList">Execute: <code class="inlineCode">1</code></li>
</ul>
<p class="normal">With this style, there are only a few possibilities for numbers you can achieve when combining these octal values (each can only be used once). Therefore, we can get <code class="inlineCode">0</code>, <code class="inlineCode">1</code>, <code class="inlineCode">2</code>, <code class="inlineCode">3</code>, <code class="inlineCode">4</code>, <code class="inlineCode">5</code>, <code class="inlineCode">6</code>, and <code class="inlineCode">7</code> by adding (or not adding) these numbers in different combinations. Some of them you’ll almost never see, such as an object having write access but not read. For the most part, you’ll see <code class="inlineCode">0</code>, <code class="inlineCode">4</code>, <code class="inlineCode">5</code>, <code class="inlineCode">6</code>, and <code class="inlineCode">7</code> used with <code class="inlineCode">chmod</code> most often. For example, if we add <code class="inlineCode">Read</code> and <code class="inlineCode">Write</code>, we get <code class="inlineCode">6</code>. If we add <code class="inlineCode">Read</code> and <code class="inlineCode">Execute</code>, we get <code class="inlineCode">5</code>. If we add all three, we get <code class="inlineCode">7</code>. If we add no permissions, we get <code class="inlineCode">0</code>. We repeat this for each column (<code class="inlineCode">User</code>, <code class="inlineCode">Group</code>, and <code class="inlineCode">Other</code>) to come up with a string of three numbers. Here are some examples:</p>
<ul>
<li class="bulletList"><code class="inlineCode">600</code>: <code class="inlineCode">User</code> has read and write (4+2). No other permissions are set.
    <p class="normal">This is the same as <code class="inlineCode">-rw-------</code>.</p></li>
</ul>
<ul>
<li class="bulletList"><code class="inlineCode">740</code>: <code class="inlineCode">User</code> has read, write, and execute. <code class="inlineCode">Group</code> has read. <code class="inlineCode">Other</code> has nothing.
    <p class="normal">This is the same as <code class="inlineCode">-rwxr-----</code>.</p></li>
</ul>
<ul>
<li class="bulletList"><code class="inlineCode">770</code>: Both <code class="inlineCode">User</code> and <code class="inlineCode">Group</code> have full access (read, write, and execute). <code class="inlineCode">Other</code> has nothing.
    <p class="normal">This is the same as <code class="inlineCode">-rwxrwx---</code>.</p></li>
</ul>
<ul>
<li class="bulletList"><code class="inlineCode">777</code>: Everyone has everything.
    <p class="normal">This is the same as <code class="inlineCode">-rwxrwxrwx</code>.</p></li>
</ul>
<p class="normal">Going back to <code class="inlineCode">chmod</code>, we can use this numbering system in practice:</p>
<ul>
<li class="bulletList"><code class="inlineCode">chmod 600 filename.txt</code></li>
<li class="bulletList"><code class="inlineCode">chmod 740 filename.txt</code></li>
<li class="bulletList"><code class="inlineCode">chmod 770 filename.txt</code></li>
</ul>
<p class="normal">Hopefully you get the idea. If you wanted to change the permissions of a directory, the <code class="inlineCode">-R</code> option may be helpful to you. This makes the changes recursive, meaning that you’ll not only make the changes to the directory but also to all files and directories underneath it in one shot:</p>
<pre class="programlisting con"><code class="hljs-con">chmod 770 -R mydir
</code></pre>
<p class="normal">While using <code class="inlineCode">-R</code> with <code class="inlineCode">chmod</code> can save you some time, it can also cause trouble if you have a mix of directories <a id="_idIndexMarker153"/>and files underneath the directory you’re changing permissions on. The previous example gives permissions <code class="inlineCode">770</code> to <code class="inlineCode">mydir</code> and all of its contents. If there are files inside, they are now given executable permissions to the user and group, since <code class="inlineCode">7</code> includes the execute bit (value of <code class="inlineCode">1</code>). This may not be what you want. We can use the <code class="inlineCode">find</code> command to differentiate these. While <code class="inlineCode">find</code> is out of the scope of this chapter, it should be relatively simple to see what the following commands are doing and how they may be useful:</p>
<pre class="programlisting con"><code class="hljs-con">find /path/to/dir/ -type f -exec chmod 644 {} \; 
find /path/to/dir/ -type d -exec chmod 755 {} \; 
</code></pre>
<p class="normal">Basically, in the first example, the <code class="inlineCode">find</code> command is locating all files (<code class="inlineCode">-type f</code>) in <code class="inlineCode">/path/to/dir/</code> and everything it finds, it executes <code class="inlineCode">chmod 644</code> against. The second example is locating all directories in this same path and changing them all to permission <code class="inlineCode">755</code>. The <code class="inlineCode">find</code> command isn’t covered in detail here because it easily deserves a chapter of its own, but I’m including it here because hopefully these examples are useful and will be handy for you to include in your own list of useful commands.</p>
<h2 class="heading-2" id="_idParaDest-52">Changing the ownership of objects</h2>
<p class="normal">Finally, we’ll <a id="_idIndexMarker154"/>need to know how to change the<a id="_idIndexMarker155"/> ownership of files and directories. It’s often the case that a particular user needs to gain access to an object, or perhaps we need to change the owning group as well. We can change user and group ownership of a file or directory with the <code class="inlineCode">chown</code> command. As an example, if we wanted to change the owner of a file to <code class="inlineCode">sue</code>, we could do the following:</p>
<pre class="programlisting con"><code class="hljs-con">sudo chown sue myfile.txt
</code></pre>
<p class="normal">In the case of a directory, we can also use the <code class="inlineCode">-R</code> flag to change the ownership of the directory itself, as well as all the files and directories it may contain:</p>
<pre class="programlisting con"><code class="hljs-con">sudo chown -R sue mydir 
</code></pre>
<p class="normal">If we would like to change the group assignment to the object, we would follow the following syntax:</p>
<pre class="programlisting con"><code class="hljs-con">sudo chown sue:sales myfile.txt 
</code></pre>
<p class="normal">Notice the colon separating the user and the group. With that command, we established that we would like the <code class="inlineCode">sue</code> user and the <code class="inlineCode">sales</code> group to own this resource. Again, we could use <code class="inlineCode">-R</code> if the object were a directory and we wanted to make the changes recursive.</p>
<p class="normal">Another command worth knowing is the <code class="inlineCode">chgrp</code> command, which allows you to directly change the group ownership of a file. To use it, you can execute the <code class="inlineCode">chgrp</code> command along with the group you’d like to own the file, followed by the filename. For example, our previous <code class="inlineCode">chown</code> command can be simplified to the following, since we were only modifying the group assignment of that file:</p>
<pre class="programlisting con"><code class="hljs-con">sudo chgrp sales myfile.txt
</code></pre>
<p class="normal">Just like the <code class="inlineCode">chown</code> command, we can use the <code class="inlineCode">-R</code> option with <code class="inlineCode">chgrp</code> to make our changes recursively, in the case of a directory.</p>
<p class="normal">Well, there you have it. You should now be able to manage permissions of the files and directories on your server. If you haven’t worked through permissions on a Linux system before, it may take a few tries before you get the hang of it. The best thing for you to do is to practice. Create some files and directories (as well as users) and manage their permissions. Try to remove a user’s access to a resource and then try to access that resource as that user anyway and see what errors you get. Fix those errors and work through more examples. With<a id="_idIndexMarker156"/> practice, you should be <a id="_idIndexMarker157"/>able to get a handle on this very quickly.</p>
<h1 class="heading-1" id="_idParaDest-53">Summary</h1>
<p class="normal">In Linux administration and related fields, managing users and permissions is something you’ll find yourself doing quite a bit. New users will join your organization, while others will leave, so this is something that will become ingrained in your mental toolset. Even if you’re the only person using your servers, you’ll find yourself managing permissions for applications as well, given the fact that processes cannot function if they don’t have access to their required resources.</p>
<p class="normal">In this chapter, we took a lengthy dive into managing users, groups, and permissions. We worked through creating and removing users, assigning permissions, and managing administrative access with <code class="inlineCode">sudo</code>. Practice these concepts on your server. When you get the hang of it, I’ll see you in our next chapter, where we’ll discuss all things related to package management. It’s going to be epic.</p>
<h1 class="heading-1" id="_idParaDest-54">Relevant videos</h1>
<ul>
<li class="bulletList">Linux Crash Course – Managing Users (LearnLinuxTV): <a href="https://linux.video/lcc-users"><span class="url">https://linux.video/lcc-users</span></a></li>
<li class="bulletList">Linux Crash Course – Understanding File &amp; Directory Permissions (LearnLinuxTV): <a href="https://linux.video/lcc-perm"><span class="url">https://linux.video/lcc-perm</span></a></li>
<li class="bulletList">Linux Crash Course – usermod (LearnLinuxTV): <a href="https://linux.video/lcc-usermod"><span class="url">https://linux.video/lcc-usermod</span></a></li>
<li class="bulletList">Linux Crash Course – sudo (LearnLinuxTV): <a href="https://linux.video/lcc-sudo"><span class="url">https://linux.video/lcc-sudo</span></a></li>
<li class="bulletList">Linux Crash Course – User Account &amp; Password Expiration (LearnLinuxTV): <a href="https://linux.video/lcc-userexp"><span class="url">https://linux.video/lcc-userexp</span></a></li>
<li class="bulletList">Linux Crash Course – Managing Groups (LearnLinuxTV): <a href="https://linux.video/lcc-groups"><span class="url">https://linux.video/lcc-groups</span></a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-55">Further reading</h1>
<ul>
<li class="bulletList">File permissions (Ubuntu community wiki): <a href="https://learnlinux.link/ubuntu-perms"><span class="url">https://learnlinux.link/ubuntu-perms</span></a></li>
<li class="bulletList">User management (Ubuntu documentation): <a href="https://learnlinux.link/sec-users"><span class="url">https://learnlinux.link/sec-users</span></a></li>
</ul>
<h1 class="heading-1">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers: </p>
<p class="normal"><a href="https://packt.link/LWaZ0"><span class="url">https://packt.link/LWaZ0</span></a></p>
<p class="normal"><img alt="" height="177" src="../Images/QR_Code50046724-1955875156.png" width="177"/></p>
</div>
</div></body></html>