- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell Control Flow – Conditionals and Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, everything we have done has been one thing after another, to paraphrase
    Arnold Toynbee. That’s fine, but it doesn’t reflect how we want things to happen
    in the real world. Most of the time, we want our code to do different things depending
    on the circumstances, and sometimes we want it to do something a number of times.
    This is where control flow is necessary. In this chapter, we are going to look
    at how to make PowerShell do different things in a script, depending on what it
    finds – these are called **conditionals**. Then we are going to look at how to
    make PowerShell repeat a process, both for a predetermined number of times and
    for an indefinite number. Because an indefinite number may be effectively infinite,
    we are going to look at how to break out of and continue looping behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Doing this effectively requires writing multiple lines of code, so first, we
    are going to talk about **Integrated Development Environments** (**IDEs**) and
    then install the one that is recommended for PowerShell 7, Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to IDEs and VS Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional control – `if`, `else`, `elseif`, and `switch`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops – `foreach`, `do while`, `do until`, `while`, and `for`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking and continuing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s play a game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to IDEs and VS Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The console is great for running a line or two of code or for quickly checking
    whether an idea will work, but it cannot save our code, and we can’t edit it.
    We need an editor. The simplest editor is whichever text editor we have installed
    on our machine, for instance, Notepad on Windows or Vi on Linux. These will do
    the bare minimum in that we can write our code, save it, and come back and edit
    it. They won’t do any more than that, though, and there are much better options
    available.
  prefs: []
  type: TYPE_NORMAL
- en: An IDE will highlight commands and keywords and do some syntax checking, and
    the good ones will also come with a built-in console to allow us to test our code
    by running short sections of it, sometimes just a line or the whole thing at once.
    They also usually have some sort of debugging facility, allowing us to stop our
    code at certain points and check the contents of variables. Most languages come
    with some form of IDE, for instance, Python has **IDLE**, the **Integrated Development
    and Learning Environment**, but I don’t know many people who use it for their
    work, and Windows PowerShell has the **Integrated Scripting Environment**, or
    **ISE**, which is excellent, but has not been made available for PowerShell 7\.
    Instead, the recommended IDE for PowerShell 7 is **Visual Studio Code** (**VS
    Code**), an open source JavaScript-based environment from Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: VS Code is highly extensible (translation – lots of people have written add-ons
    for it) and can be used with a wide range of languages. All we need to do is download
    our choice of language modules. There are also add-ons that check syntax, allow
    us to use code snippets, connect us to code repositories, such as Git, integrate
    testing, and generally do anything we could do with a far more expensive IDE,
    such as Eclipse. Rather than talk about it, let’s get it installed.
  prefs: []
  type: TYPE_NORMAL
- en: Installing VS Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: VS Code can be installed on Windows, Linux, macOS, and Raspberry Pi – that’s
    right, there’s a Raspbian install. It’s pretty simple. Go to the VS Code download
    page at [https://code.visualstudio.com/download](https://code.visualstudio.com/download),
    and click on the relevant package for the machine and operating system we are
    working on; so for a Raspberry Pi, we would select the `.deb` ARM download. Once
    it’s downloaded, change to the folder or directory where we’ve saved the package.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'VS Code is a graphical tool, so we need to use a desktop environment with Linux.
    For Ubuntu and other Debian-based versions, we just need to run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For Raspbian, it’s easier still:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These commands will do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things are a little more complicated for Red Hat distros. The easiest way is
    probably with snapd, in which case the following will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are more detailed instructions on installing VS Code for Linux at [https://code.visualstudio.com/docs/setup/linux](https://code.visualstudio.com/docs/setup/linux).
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install VS Code on macOS, download the relevant Mac installer `.zip` file
    and extract the contents. Drag the `Visual Studio Code.app` to the `Applications`
    folder, which will make VS Code available in **Launchpad**.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Windows, we have a choice of user or system installations. If we follow
    the user install option, the application gets installed by default in `C:\Users\<username>\AppData\Local\Programs\Microsoft
    VS Code` and is only available for the user who installed it. If we use the system
    installer, then it gets installed in `C:\Program Files\Microsoft VS Code` and
    requires administrator privileges to install. Automatic updates are easier if
    we install the user installation package, so let’s go ahead and download that
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: Once it’s downloaded, browse to the `Download` location and double-click the
    `.``exe` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the **End-User License Agreement** (**EULA**) and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the installation location if you want, and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide whether you want a *Start* menu folder, and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the `PATH` environment variable and registering code as an editor for supported
    file types. Click **Next**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Select Additional Tasks for the VS Code installation](img/B17600_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Select Additional Tasks for the VS Code installation
  prefs: []
  type: TYPE_NORMAL
- en: Review the installation options and click **Install**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Finish** and admire your new VS Code installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A really quick way for Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we’ve got the `PowerShellGet` module installed, then we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Press `Y` to agree `Yes`, and that’s it. This method is great for when we know
    what we’re doing with VS Code, but if this is our first time with it, let’s do
    things manually so we can see exactly what’s going on.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring VS Code for PowerShell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’ve got VS Code installed, we need to tell it to recognize the PowerShell
    language. On installation VS Code has no idea about PowerShell. We need to install
    an extension. Open VS Code, if it isn’t already open, by typing `Code` in the
    search bar and selecting the application in the results. In the main window, click
    on the *Extensions* icon on the far-left edge of the window – it looks like a
    pile of boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Finding the PowerShell extension for VS Code](img/B17600_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Finding the PowerShell extension for VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'Type `powershell` in the extensions search bar. We want the PowerShell extension
    by Microsoft; it’s the first result, as shown in the following screenshot. Click
    on it, and then click the blue **Install** button in the main pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Installing the PowerShell extension for VS Code](img/B17600_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Installing the PowerShell extension for VS Code
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started. Press *Ctrl* + *N* to open a new file. We’ll be asked to
    select a language. We don’t have to do this, but doing so means we have assistance
    ready from the start; we can type without specifying a language, but the syntax
    checking and highlighting won’t be available until we save our file as a PowerShell
    script by using the `.ps1` file extension. Go ahead and click to select **PowerShell**
    from the dropdown. We can change the language at any time by clicking on the language
    name in the bottom-right corner; if we haven’t selected a language then it says
    **Plain Text**.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we should see after selecting PowerShell is that the PowerShell
    integrated terminal has started at the bottom of the screen. We can run PowerShell
    cmdlets in there, and when we run our code from the top window, the results will
    appear in the terminal. Try this – in the top window, type `write-outp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see VS Code give you a helpful autocomplete option like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Autocomplete in VS Code](img/B17600_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Autocomplete in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only does it autocomplete for you, but it also gives hints about how the
    cmdlet is used; if you hover over the suggestion, you will see a `.ps1`; I’ve
    used `HelloWorld.ps1`. Now click the play icon (arrow) at the top right of the
    window to run the code. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Running PowerShell in VS Code](img/B17600_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Running PowerShell in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: If you get an output that looks like the preceding screenshot, congratulations.
    You’ve run your first script!
  prefs: []
  type: TYPE_NORMAL
- en: Top tip for switching terminal environments
  prefs: []
  type: TYPE_NORMAL
- en: If you’re running on Windows, you’ve probably got at least two different versions
    of PowerShell installed – PowerShell 7 and Windows PowerShell. How do you swap
    between them? Click on the curly braces (`PATH` environment variable. You can
    use the `$PSVersionTable` variable to check which version you’re running.
  prefs: []
  type: TYPE_NORMAL
- en: 'VS Code is incredibly powerful and has hundreds of features and extensions,
    meaning we can spend a good chunk of our day using it, but this has a few drawbacks
    to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: Because it is open source and frequently updated, blog articles and tutorials
    on the internet (or, heaven forfend, a book on PowerShell programming) can become
    rapidly out of date. We need to carefully research how to use a feature or understand
    why something doesn’t work and be wary of any source more than a year or two old.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because it is open source and extensible, there can be quite a steep learning
    curve. As we go through the book, we’ll cover quite a few of the common use cases
    and features, but we’ll barely scratch the surface of the things we can do with
    this software. The official Microsoft documentation is up to date, if not particularly
    user-friendly. We should supplement our reading with trustworthy articles and
    useful websites, such as Stack Overflow and Spiceworks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because it is open source and extensible, anyone can write extensions for it.
    This means that sometimes extensions will be brilliant, and sometimes they will
    be less useful. It can also be the case that an extension that was marvelous two
    years ago has now fallen into disrepair because the author wrote it as a fun project
    and is now concentrating on other things.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These drawbacks aside, VS Code is incredibly useful. When we come across something
    that makes us wince in frustration, we should pause, be kind, and work around
    it. Better still, fix it; that is part of the joy of open source software.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have VS Code installed and ready to use, let’s move on to the actual
    topic of the chapter; PowerShell control flow. We are going to start with conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional control – if, else, elseif, and switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conditional control flow is based on a simple statement. If this thing is true,
    then do that thing. The first part is a Boolean expression. The second part is
    an action based on the resolution of the Boolean. A Boolean expression will resolve
    to one of two values: true or false. We discussed Boolean operators in [*Chapter
    3*](B17600_03.xhtml#_idTextAnchor049), *The PowerShell Pipeline – How to String
    Cmdlets Together*, in the *Understanding Where-Object advanced syntax* section.
    Consider the following two statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first one resolves to the Boolean-type object true. The second one resolves
    to false. Try it if you don’t believe me. It’s not often that we need to check
    whether 1 is the same as 2, but we frequently need to compare variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Just checking](img/B17600_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Just checking
  prefs: []
  type: TYPE_NORMAL
- en: That covers the first part of our logic; next, we need to be able to perform
    an action based on the result of our test. Let’s get VS Code ready for some fun.
    Let’s close VS Code for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to your PowerShell prompt (not the one in VS Code) and type the following
    to create a working directory, move to it, and start VS Code inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The period after `Code` is important. Don’t miss it, or you will be working
    in the wrong location. VS Code will start and ask whether you want to trust the
    authors of the files in this folder. We probably do, as we are going to be the
    authors. We’re going to need a new file to work in, so press *Ctrl* + *N* to create
    a new file and select `Conditionals.ps1`. We have our blank canvas. Let’s go to
    work.
  prefs: []
  type: TYPE_NORMAL
- en: The if statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first conditional we’ll look at is the simplest – the `if` statement. We
    can use this to perform an action based on whether an expression is true or false.
    Type this in the script pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The brackets contain an expression that needs to be evaluated. The curly braces
    contain a scriptblock that will run if the expression resolves to true. Now, highlight
    your lines and press *F8*. Your code will run, and you should see the output in
    the terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The if statement](img/B17600_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The if statement
  prefs: []
  type: TYPE_NORMAL
- en: Be careful to use single quotes; review [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071),
    *PowerShell Variables and Data Structures*, to understand why. If you use double
    quotes in the action, then you will see the output `5 is bigger than 4`, because
    you’ve expanded the `$``x` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Top tip
  prefs: []
  type: TYPE_NORMAL
- en: After you type `if`, pause for a second to let VS Code catch up. It will offer
    you a choice of cmdlets and keywords. Click on `if` in the list, and it will construct
    the statement for you, as shown in lines 7 to 9 in *Figure 5**.7*. All you need
    to do is fill in the condition and the action.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the green text on lines 3 and 8\. Those are comments. We use them to
    make our code more readable and to clarify what we are doing. A single-line comment
    is started with `#`; everything after the `#` will be ignored by PowerShell. A
    multi-line comment starts with `<#` and ends with `#>`. These comments were autogenerated
    by VS Code; we can leave them in or delete them. It makes no difference to how
    the code runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test whether a statement is false as well. Type this below line 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re using`!` as a `-not` operator there. We could write line 11 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'But you won’t see the `-not` operator written out like that very often – most
    people use `!`. If you highlight that code and press *F8* then you get the output
    `$x is bigger than` `4`, again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Reversing a condition with the -not operator](img/B17600_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Reversing a condition with the -not operator
  prefs: []
  type: TYPE_NORMAL
- en: If `$x` is smaller than 4, we will get no output, and the script will move on
    to the next line after the `if` statement – we don’t need to do anything else.
    What happens if we want the script to do one thing if a statement is true and
    something else if a statement is false?
  prefs: []
  type: TYPE_NORMAL
- en: The else statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use the `else` statement to specify a second action if the test condition
    for the `if` statement isn’t true. Type this starting on line 15 – use the autocomplete
    for the `else` statement and notice we are using `-lt` in the condition, not `-gt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now select lines 15-22 and hit *F8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Using the else statement](img/B17600_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Using the else statement
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the remark on line 20 from autocompleting the `else` statement: `Action
    when all if and elseif conditions are false`. The `else` statement is a catch-all
    if no conditions are true. But how do we test for multiple conditions? We could
    write multiple `if` statements, one after another, but each statement would execute
    regardless of the statement before. We could nest `if` statements inside each
    other, but that would be a lot of work.'
  prefs: []
  type: TYPE_NORMAL
- en: The elseif statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use `elseif` to specify multiple conditions to test for multiple conditions
    within a single `if` statement. Type this on line 24\. Use autocomplete to help
    get everything right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Highlight the code you’ve just entered and hit *F8*. You should see the output
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Using the elseif statement](img/B17600_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Using the elseif statement
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have as many `elseif` statements as you need, but once one is true,
    the parent `if` statement will exit. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We get the output `$x is less than 6`. The `else` statement never gets to run.
  prefs: []
  type: TYPE_NORMAL
- en: The ternary operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PowerShell 7 has a new operator that allows us to construct simple `if`/`else`
    statement pairs in a single line. On line 15 of our code, we have the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rewrite this with the ternary operator like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is great and will save a lot of typing, but it’s also less readable. The
    question mark character (`?)` can also be used as an alias for the `Where-Object`
    cmdlet, but it’s not being used that way here. Remember that our code will be
    read many more times than it is written.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if multiple statements are true? Let’s look at a way we can handle
    that.
  prefs: []
  type: TYPE_NORMAL
- en: The switch statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We could test for multiple conditions with multiple `if` statements, but that
    might get complicated, so there is a special statement to test for multiple true
    conditions – `switch`. The `switch` statement tests each condition and executes
    the associated scriptblock for that condition. Every condition that is true will
    execute. Let’s see how it works. On a new line, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you select the code and press *F8* you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Using the switch statement](img/B17600_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Using the switch statement
  prefs: []
  type: TYPE_NORMAL
- en: 'There are lots of things we can do with the `switch` statement. Consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are running through a string. We’ve used the `-Wildcard` and `-CaseSensitive`
    parameters to check for matching portions of the string and make sure that the
    cases match as well. We’re evaluating a property of the string, not just the content,
    and finally, we are setting a default output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Switch options](img/B17600_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Switch options
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the lines of code in the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: In line 75, we’re setting parameters for the `switch` statement – notice they
    have to come before the expression to be evaluated that is enclosed in brackets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line 76, we’re asking whether the string contains the integer `7`. In lines
    77 and 78, we’re demonstrating the use of the `-``CaseSensitive` parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line 80, we’re evaluating a property of the string, its length. Notice that
    this has to go in a scriptblock, so it needs curly braces, not brackets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, on line 81, we are setting a default output – this will only be produced
    if no other conditions in the `switch` statement get matched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity 1
  prefs: []
  type: TYPE_NORMAL
- en: Why doesn’t the output produce the line `contains 7`?
  prefs: []
  type: TYPE_NORMAL
- en: We can also use a `-Regex` parameter to evaluate against a regular expression.
    This can’t be used with the `-Wildcard` or `-Exact` parameter. The `-Exact` parameter
    is the opposite of `-Wildcard` and is the default.
  prefs: []
  type: TYPE_NORMAL
- en: Loops – foreach, do while, do until, while, for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automation theory tells us that machines are better than people at performing
    repetitive tasks; they will perform the task any number of times in exactly the
    same way each time. When we are writing code, we call this iteration or looping.
    We’re going to look at four examples of looping in PowerShell that are relatively
    common. We’ll start with the `foreach` loop, before looking at `do while` and
    its counterpart, `do until`. We’ll then look at the more generalized `while` statement
    and finish with a look at the `for` statement and see how it differs from `foreach`.
    Let’s get started by creating a new file, setting it as a PowerShell file, and
    saving it as `loops.ps1`.
  prefs: []
  type: TYPE_NORMAL
- en: The foreach loop statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the most common loop statement. We’ve seen `foreach` before, when we
    looked at the `Foreach-Object` cmdlet in [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049),
    *The PowerShell Pipeline – How to String Cmdlets Together*. They’re similar in
    function, but not the same, and have very different syntax. `foreach` loops have
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If `foreach` is at the start of a statement, then PowerShell will treat it
    as the `foreach` loop statement, not an alias for `ForEach-Object`. We can see
    this happening in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – The foreach statement and foreach as an alias for ForEach-Object](img/B17600_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – The foreach statement and foreach as an alias for ForEach-Object
  prefs: []
  type: TYPE_NORMAL
- en: In line 1, `foreach` is at the start of the line, or statement, and in line
    2 it comes after a pipeline character. `PSScriptAnalyzer`, part of the PowerShell
    extension for VS Code, has recognized `foreach` as an alias of `ForEach-Object`
    in line 2 and given it a wavy yellow underline to denote poor practice, but not
    in line 1\. If we hover the mouse over `foreach` in line 2, we can see that it
    is moaning because we have used an alias, and it’s right. What else is going on
    in that image?
  prefs: []
  type: TYPE_NORMAL
- en: In line 1, we’ve got a `foreach` statement – it consists of the `foreach` keyword,
    a grouped expression in brackets, and a scriptblock in curly braces. The grouped
    expression takes the format `($element` `in [expression])` and produces a collection
    of objects. Once the collection is complete, the scriptblock operates on each
    object in turn. In this case, we are collecting all the objects in the current
    directory that end in `.ps1`. We then perform an operation on them – we get their
    length (`$f.length`) and add it to the `$l` variable using the compound operator,
    `+=`. It doesn’t matter what variable we use to denote the elements in the collection
    so long as it isn’t an automatic variable or a variable we are using elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: In the second line, we are using the `ForEach-Object` cmdlet to do exactly the
    same thing. What’s the difference?
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `foreach` keyword to create a loop, the expression is run to
    produce an array, which is held in memory. Each element is then run into the scriptblock
    one at a time. If your expression creates a very large array then you may experience
    memory issues.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `ForEach-Object` cmdlet as part of a pipeline, each element
    in the array created by `Get-ChildItem *.ps1` passes through the entire pipeline
    one at a time; this means it uses a lot less memory, as the whole array doesn’t
    exist in memory, just single elements. The downside is it may well take longer
    to process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try a `foreach` loop for ourselves. Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That’s not quite the same as the line in *Figure 5**.13*. We’re using a semicolon
    (`;`) as a statement separator; this allows us to put multiple statements on one
    line instead of splitting it over multiple lines. This is easier to type but not
    easier to read. Let’s go through the command;
  prefs: []
  type: TYPE_NORMAL
- en: Our first statement is `$l = 0 ;`. This creates the `$l` variable and sets it
    to `0`. This means each time we run the whole line, it will reset `$l` to `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second statement is `Foreach ($i in Get-ChildItem *.ps1) {$l += $i.length}
    ;`. This is where we create our array and loop through each element of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our final statement is just `$l` – this returns the value of `$l` at the end
    of the loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see how this looks in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – The foreach loop and statement separator](img/B17600_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – The foreach loop and statement separator
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be using `foreach` loops quite a lot, as they are the most common type
    of loop. Let’s move on to the next types, `do while` and `do until`.
  prefs: []
  type: TYPE_NORMAL
- en: The do while and do until loop statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `do while` and `do until` loops share the same syntax, which puts the scriptblock
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Because the condition is last, they will always execute the scriptblock at least
    once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try this. Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at what we’ve just done:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, we’re creating a `$number` variable and setting it to `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second line, we are starting a `do while` loop with the `do` keyword,
    opening a scriptblock with a curly brace, `{`, and incrementing by 1 the `$number`
    variable using the `++` increment operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the third line, we’re performing another operation, writing output to the
    screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the final line, we are closing the scriptblock with a curly brace, `}`, then
    using the `while` keyword to supply the condition, in brackets. In this case,
    it is while `$number` is not equal to `5`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is your last line of output? For me, it is `The number is 5`. This is
    because the scriptblock is run before the condition is evaluated. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the following screenshot, the scriptblock has been executed
    even though the condition is false.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – The computer is lying to you](img/B17600_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – The computer is lying to you
  prefs: []
  type: TYPE_NORMAL
- en: 'The `do until` loop works the same way, but until the condition is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see how those loops look next to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – do while and do until](img/B17600_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – do while and do until
  prefs: []
  type: TYPE_NORMAL
- en: Generally, we use `do until` loops when the test condition is expected to be
    positive and `do while` loops when the test condition is expected to be negative.
    It is not `while` or `until` that determines true or false, but the condition
    associated with it. You can just as easily have “not equals” (negative) with `until`
    and “equals” (positive) with `while`. Remember, though, that the scriptblock will
    execute the first time the condition is not met. What can we do about that?
  prefs: []
  type: TYPE_NORMAL
- en: The while loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `while` loop turns the `do while` loop back to front and puts the condition
    before the scriptblock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This means if the condition is not true, then the scriptblock never executes.
    There is no `until` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it. Type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Activity 2
  prefs: []
  type: TYPE_NORMAL
- en: This produces the same output as our `do while` example. Why? How would you
    prove that the scriptblock doesn’t execute when the condition is true?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at our final loop next, the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Despite its name, the `for` loop is more like a `while` loop than a `foreach`
    loop. It’s a counting loop that depends on a condition being true, like `while`,
    but it is much more flexible. The syntax is more complicated as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The iterator is the variable we’re going to iterate, similar to the `$number`
    variable we used previously when we looked at the `while` loop. The condition
    is the same as the `while` loop condition, and the iteration is the action we
    perform on the iterator each time we go round the loop. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s not hugely exciting; it just looks like a complicated way to do exactly
    the same as the `while` loop previously. However, the `for` loop allows us to
    index the element of the loop and move around based on that index. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the output shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Ordering fruit around with a for loop](img/B17600_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Ordering fruit around with a for loop
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another thing we can do with a `for` loop that makes it special. We
    can change the contents of our array. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, that didn’t work. We might have hoped that by changing `$fruit` it would
    affect the original array, but it doesn’t, because the `foreach` loop operates
    on copies of the elements in the array. We can use the `for` loop to do it though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And we should see the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Using a for loop to make fruit tasty](img/B17600_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – Using a for loop to make fruit tasty
  prefs: []
  type: TYPE_NORMAL
- en: We’re doing something new in line 50, there. We’re using `$()`, the sub-expression
    symbol, to make sure PowerShell correctly interprets what we mean. While we can
    expand simple variables inside double quotes, more complex expressions need a
    little more. Without wrapping `$fruits[$i]` in a pair of brackets preceded by
    a dollar sign, PowerShell won’t correctly unpack it.
  prefs: []
  type: TYPE_NORMAL
- en: We’re nearly done with loops. We’ve looked at the `foreach` loop, which performs
    an operation for each element in an array. We’ve looked at `do while` and `while`,
    which repeat an operation while a condition is true. Then we looked at `do until`,
    which performs an operation until a condition becomes true. Finally, we looked
    at the more complicated `for` loop, which repeats an operation a predetermined
    number of times. What we need next is a way of controlling our loops. What happens
    if the condition in a `while` loop never becomes false? Let’s look at loop control
    with `break` and `continue`.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking and continuing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `break` and `continue` statements are related and allow us to control how
    our loops behave. We can also use them in `switch` statements. It’s important
    not to use them outside of loops or `switch` statements as they can lead to unpredictable
    behavior. A `break` statement can be used to stop a loop iterating altogether,
    while `continue` can be used to stop an iteration and move on to the next one.
    Let’s look at `break` first.
  prefs: []
  type: TYPE_NORMAL
- en: The break statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s play with the trusty `while` loop. Type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, you’ll see that the last number printed is `2`. The conditional `if`
    statement says to stop looping if `$number` is `3`. The `break` statement only
    acts on the loop it is nested inside.
  prefs: []
  type: TYPE_NORMAL
- en: The continue statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `continue` statement stops the current iteration of the loop, not the whole
    loop, and moves on to the next iteration. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the loop prints out the numbers `1` to `5`, but omits `3`. It breaks
    out of the current iteration before it reaches the `Write-Host` statement, and
    starts the next one. You should see the result in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Using continue](img/B17600_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – Using continue
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `break` and `continue` in `switch` statements, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to the `switch` block we used earlier in the chapter, in the
    *The switch statement* section. The difference is we are now passing an array
    of strings, not a single one. The `continue` statement in line 7 means that the
    `long string` and `No powershell here` outputs are never executed; instead, the
    `switch` statement moves on to the next element in the array, `python`. Now replace
    `continue` with `break`. We can see that the entire `switch` statement stops –
    `python` is never processed.
  prefs: []
  type: TYPE_NORMAL
- en: That’s enough for now on loops. We’ll be using them a lot in the rest of the
    book. Let’s have some fun now, instead.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s play a game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re all familiar with number-guessing games. Let’s use what we’ve learned
    in this chapter to write a game in PowerShell. This is a common challenge set
    in many programming tutorials, so we’re not going to be any different. In the
    UK, it is sometimes called the Brucie Game because of its similarity to the popular
    UK TV gameshow Bruce Forsyth’s Play Your Cards Right. The Brucie bonus here is
    that we get to learn something.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program generates a random integer between 1 and 100\. We then need to
    get user input in the form of another integer. We compare the guess with the hidden
    number and decide whether it’s right. If it is, we go to the end of the program.
    If it isn’t, then we need to decide whether it is too high or too low and output
    an appropriate message before going back and asking for another guess. We can
    represent this as a flow chart, which will be helpful when it comes to writing
    our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Flow chart for the Brucie game](img/B17600_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – Flow chart for the Brucie game
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is open a new file; mine is called `Brucie.ps1`.
    Let’s go to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first box calls for a random integer between 1 and 100\. That’s easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to tell the player what to do, and get an input from them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have our two numbers in variables called `$Hidden` and `$guess`. We
    need to compare them. The best way to do this is to use an `if`-`else` statement.
    If the number is wrong, we do one thing, else we print `You Win!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'What action do we need to perform? We need to see whether it is higher or lower.
    We’ll need another `if`-`else` there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: And that is that. Wait, no it isn’t. We need to give them multiple guesses.
    We need a loop. We could use all sorts of loops here, but probably the easiest
    is a `while` loop. Have a think about how you might do it before moving on and
    seeing how I did it.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t peek. Think.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK. Here’s my solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the whole thing working:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – The Brucie game](img/B17600_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – The Brucie game
  prefs: []
  type: TYPE_NORMAL
- en: On line 4, I’ve initialized `$guess` as `0` so that the loop has something to
    work with.
  prefs: []
  type: TYPE_NORMAL
- en: On line 5, I’ve changed my first `if` statement to a `while` statement. I’ve
    also closed the loop with a curly brace and made `Write-Host "You Win"` the final
    statement of the program.
  prefs: []
  type: TYPE_NORMAL
- en: On line 6, I’ve brought my input-gathering statement inside the loop. Try leaving
    it outside. That gets old quickly because we’re never changing the value of `$guess`
    from 0.
  prefs: []
  type: TYPE_NORMAL
- en: The only other change I made was on line 9, where I replaced `else` with an
    `elseif` statement, otherwise the loop prints `Lower!` even when we’re right.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it. Make sure you save a working copy of the game so we can work
    with it later. We’ve covered a lot of ground in this chapter; let’s summarize.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started the chapter by looking at IDEs and installing the recommended environment
    for PowerShell 7, VS Code. VS Code is a large and ever-changing application. We
    need to spend time familiarizing ourselves with it and keep regularly updated
    as the features and capabilities change frequently. We have seen that it is easy
    to use and very powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then looked at the two main ways of controlling flow within a program: conditionals
    and loops. We spent a lot of time on the `if`, `else`, and `elseif` conditional
    statements and then looked at the related `switch` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: After that, we looked at loops. We started with a loop that will iterate through
    all the elements in an array – the `foreach` loop – and explored how it differs
    from the `ForEach-Object` cmdlet. We looked at `do while` and `do until`, which
    will repeat a loop while a condition is true or false, and then we looked at the
    `while` loop, which swaps the position of the condition and the scriptblock. The
    last loop we looked at in this section was a counting loop – `for`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we finished this chapter by writing a short number-guessing game in
    PowerShell, the Brucie game. I hope you enjoyed doing this, as this sort of exercise
    will really cement how to write code in PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to be looking at how PowerShell can be used
    to interact with files. We’re going to be reading content, writing content, and
    generally playing around.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What output will `$x = 4 ; IF ($x -gt 4) {Write-Host '$x is larger than` `4'}`
    produce?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a statement that will produce an output for the line `$x = 4 ; IF ($x
    -gt 4) {Write-Host '$x is larger than 4'}` when `$x` is not larger than 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a statement that will produce output from `$x = 4 ; IF ($x -gt 4) {Write-Host
    '$x is larger than 4'}` when `$x` is exactly 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a statement that will produce an output for the line `$x = 4 ; IF ($x
    -gt 4) {Write-Host '$x is larger than 4'}` when `$x` is not larger than 4, as
    in question 2, but this time use the `ternary` operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is going wrong here?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rewrite `$number = 0 ; Do {$number ++ ; Write-Host "Number is $number"} While
    ($number -eq 5)` so that it works, but without using a d`o` `until` loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make this statement work: `For ($i = 0 ; $i -lt 5 ) {``Write-Host $i}`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should only use `break` and `continue` statements in loops and one other
    place. Where?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you make it so the Brucie game limits the number of guesses a user
    could make?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This was a big chapter, so there is plenty of further reading here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Developing PowerShell with VS Code: [https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode](https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About `if`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_if](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_if)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About `switch`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_switch](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_switch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About `foreach`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_foreach](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_foreach)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About `do`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_do](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_do)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About `while`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_while](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_while)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About `for`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_for](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_for)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About `break`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_break](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_break)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About `continue`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_continue](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_continue)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
