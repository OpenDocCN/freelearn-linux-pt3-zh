- en: '*Chapter 4*: Using File Contexts and Process Domains'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：使用文件上下文和进程域'
- en: SELinux-enabled systems are strongly dependent on the notion of contexts (on
    resources) and domains (on processes). The access controls that SELinux enforces
    use these contexts to identify the resources, and define the enforcement rules
    within the policy. Because of its inherent reliance on these contexts, this chapter
    will go into detail on file contexts, context definitions, and process domains.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 SELinux 的系统强烈依赖于上下文（资源上的）和域（进程上的）的概念。SELinux 强制实施的访问控制使用这些上下文来识别资源，并在策略中定义强制规则。由于其固有的对这些上下文的依赖，本章将详细讨论文件上下文、上下文定义和进程域。
- en: We will work with the file contexts and learn where they are stored so that
    you can easily adjust your system to work optimally with SELinux. We assign contexts
    to resources both temporarily (for testing purposes) and permanently, and learn
    how these contexts are used to automatically deduce the process domain. Once we
    know how to obtain process domain information, we will query the SELinux policy
    to learn about the current access controls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理文件上下文并了解它们存储的位置，这样你就可以轻松调整系统，以便与 SELinux 最佳配合使用。我们为资源分配上下文，既可以是临时的（用于测试），也可以是永久的，并学习如何利用这些上下文来自动推断进程域。一旦我们知道如何获取进程域信息，我们将查询
    SELinux 策略，以了解当前的访问控制。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Introduction to SELinux file contexts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux 文件上下文简介
- en: Keeping or ignoring contexts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留或忽略上下文
- en: SELinux file context expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux 文件上下文表达式
- en: Modifying file contexts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改文件上下文
- en: The context of a process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程的上下文
- en: Limiting the scope of transitions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制转换的范围
- en: Types, permissions, and constraints
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型、权限和约束
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3m3JzkP](https://bit.ly/3m3JzkP)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请观看以下视频，查看代码的实际应用：[https://bit.ly/3m3JzkP](https://bit.ly/3m3JzkP)
- en: Introduction to SELinux file contexts
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SELinux 文件上下文简介
- en: SELinux file contexts are the most important configuration that a system administrator
    will have to work with when working with SELinux on the system. Contexts for files
    are generally identified through a label that is assigned to the file. Mislabeled
    files are a constant source of headaches for sysadmins, and most common SELinux
    issues are resolved by correcting the SELinux context.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 文件上下文是系统管理员在系统中使用 SELinux 时需要处理的最重要的配置。文件的上下文通常通过分配给文件的标签来识别。标签错误的文件是系统管理员的常见头痛来源，大多数常见的
    SELinux 问题都通过纠正 SELinux 上下文来解决。
- en: 'Knowing where and how SELinux contexts are used is key to understanding and
    resolving SELinux related issues. The following diagram shows how contexts are
    applied on regular Linux resources, and how the LSM subsystem uses these contexts
    for decision making:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 SELinux 上下文的使用方式和位置是理解和解决 SELinux 相关问题的关键。下图展示了上下文如何应用于常规 Linux 资源，以及 LSM
    子系统如何使用这些上下文来做出决策：
- en: '![Figure 4.1 – Distinction between contexts and regular Linux info ](img/B16276_04_001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 上下文与常规 Linux 信息的区别](img/B16276_04_001.jpg)'
- en: Figure 4.1 – Distinction between contexts and regular Linux info
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 上下文与常规 Linux 信息的区别
- en: 'Let''s consider a web-based deployment as an example: DokuWiki. This is a popular
    PHP wiki that uses files rather than a database as its backend system, and is
    easy to install and manage. As a web hosting platform, we will use nginx.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以基于 Web 的部署为例：DokuWiki。DokuWiki 是一个流行的 PHP 维基，它使用文件而不是数据库作为后端系统，且易于安装和管理。作为
    Web 托管平台，我们将使用 nginx。
- en: Getting context information
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取上下文信息
- en: 'Let''s assume that the DokuWiki application will be hosted at `/srv/web/localhost/htdocs/dokuwiki`
    and that it will store its wiki pages (user content) in the `data/` subdirectory.
    We start by downloading the latest DokuWiki tarball from the project site, [http://download.dokuwiki.org](http://download.dokuwiki.org),
    and extract it to this location:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 DokuWiki 应用将托管在 `/srv/web/localhost/htdocs/dokuwiki` 位置，并且它会将其维基页面（用户内容）存储在
    `data/` 子目录中。我们从项目站点下载最新的 DokuWiki tarball，[http://download.dokuwiki.org](http://download.dokuwiki.org)，并将其解压到此位置：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While distributions might have prepackaged DokuWiki installations available,
    we will use the manual installation approach to show the various file context-related
    actions in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些发行版可能提供预打包的 DokuWiki 安装，但我们将使用手动安装的方法来展示本章中的各种文件上下文相关操作。
- en: The contexts of files can easily be acquired using the `-Z` option of the `ls`
    command. Most utilities that can provide feedback on contexts will try to do so
    using the `-Z` option, as we saw with the `id` utility in [*Chapter 1*](B16276_01_Final_VK.xhtml#_idTextAnchor018),
    *Fundamental SELinux Concepts*, and [*Chapter 3*](B16276_03_Final_VK.xhtml#_idTextAnchor071),
    *Managing User Logins*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`ls`命令的`-Z`选项轻松获取文件的上下文。大多数能够提供上下文反馈的工具都会尝试使用`-Z`选项，正如我们在[*第1章*](B16276_01_Final_VK.xhtml#_idTextAnchor018)《基础SELinux概念》和[*第3章*](B16276_03_Final_VK.xhtml#_idTextAnchor071)《管理用户登录》中所看到的`id`工具所示。
- en: 'Let''s look at the current context of the `dokuwiki` directory itself:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`dokuwiki`目录本身的当前上下文：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The context displayed here is `var_t`. In the *Keeping or ignoring contexts*
    section, we will change this to the correct context (as `var_t` is too generic
    and not meant for hosting web content).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的上下文是`var_t`。在*保留或忽略上下文*部分中，我们将把这个上下文改为正确的上下文（因为`var_t`过于通用，不适合托管网页内容）。
- en: File and directory contexts are stored in the filesystem as extended attributes
    when the filesystem supports this. An **extended attribute** (often abbreviated
    to **xattr**) is a key/value combination associated with a resource's inode (an
    information block that represents a file, directory, or symbolic link on a filesystem).
    Each resource can have multiple extended attributes, but only one value per unique
    key. When we talk about assigning a **label** to a file or directory (or relabeling
    a file), then we imply setting or updating this extended attribute, as it is the
    label that SELinux will use to obtain the SELinux context for the file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和目录上下文在文件系统中作为扩展属性存储，当文件系统支持此功能时。**扩展属性**（通常缩写为**xattr**）是与资源的inode（代表文件、目录或符号链接的文件系统信息块）相关联的键/值组合。每个资源可以有多个扩展属性，但每个唯一的键只有一个值。当我们谈论为文件或目录分配**标签**（或重新标记文件）时，我们指的是设置或更新这个扩展属性，因为它是SELinux用于获取文件SELinux上下文的标签。
- en: Important note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Filesystems that do not support extended attributes can still be used on SELinux-enabled
    systems. However, the entire filesystem (including all its files and directories)
    will then be shown with a single context, and differentiation across resources
    on the filesystem is not possible. We explain how to define file contexts on these
    filesystems in the *Using mount options to set SELinux contexts* subsection in
    this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持扩展属性的文件系统仍然可以在启用了SELinux的系统上使用。然而，整个文件系统（包括所有文件和目录）将显示为单一上下文，无法在文件系统上区分资源。我们将在本章的*使用挂载选项设置SELinux上下文*小节中解释如何在这些文件系统上定义文件上下文。
- en: 'By convention, extended attributes on Linux use the following syntax:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据约定，Linux上的扩展属性使用以下语法：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The namespace of an extended attribute allows for additional access controls
    or features. Of the currently supported extended attribute namespaces (`security`,
    `system`, `trusted`, and `user`), the `security` namespace enforces specific restrictions
    on manipulating the attribute: if no security module is loaded (for instance,
    SELinux is not enabled), then only processes with the `CAP_SYS_ADMIN` capability
    (basically root or similarly privileged processes) can modify this parameter.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展属性的命名空间允许进行额外的访问控制或特性。在当前支持的扩展属性命名空间（`security`、`system`、`trusted`和`user`）中，`security`命名空间对操作该属性施加了特定的限制：如果没有加载安全模块（例如，未启用SELinux），则只有具有`CAP_SYS_ADMIN`能力的进程（基本上是root或类似权限的进程）才能修改此参数。
- en: 'We can query the existing extended attributes using the `getfattr` application,
    as shown in the following example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`getfattr`应用程序查询现有的扩展属性，如下例所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, the `security.selinux` extended attribute hosts the SELinux context.
    This ensures that non-administrative users cannot alter the SELinux context of
    a file when SELinux is disabled and that the SELinux policy controls who can manipulate
    contexts when SELinux is enabled.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`security.selinux`扩展属性存储着SELinux上下文。这确保了当SELinux被禁用时，非管理员用户无法更改文件的SELinux上下文，并且当SELinux启用时，SELinux策略控制谁可以操作上下文。
- en: 'The `stat` application can also be used to show SELinux contexts:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`stat`应用程序也可以用来显示SELinux上下文：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Getting context information from a file or directory should be as common to
    an administrator as getting regular access control information (the read (`r`),
    write (`w`), and execute (`x`) flags).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件或目录获取上下文信息应该和获取常规访问控制信息（读取（`r`）、写入（`w`）和执行（`x`）标志）一样常见。
- en: Interpreting SELinux context types
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释SELinux上下文类型
- en: After using SELinux for a while, the motive behind using file labels to assign
    an SELinux context to the file becomes somewhat clearer. SELinux contexts are
    named after their purpose, allowing administrators to more easily see whether
    a context is correctly assigned.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SELinux 一段时间后，使用文件标签为文件分配 SELinux 上下文的动机变得更加清晰。SELinux 上下文根据其目的命名，使管理员更容易看出上下文是否被正确分配。
- en: Consider the context of a user file in its home directory (`user_home_t`), a
    directory in `/tmp` for a Java application (`java_tmp_t`), or a socket of `rpcbind`
    (`rpcbind_var_run_t`). All these files or directories have considerably different
    purposes on the filesystem, and this reflects itself in the assigned contexts.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个用户文件在其主目录中的上下文（`user_home_t`）、一个位于 `/tmp` 目录中的 Java 应用程序目录（`java_tmp_t`），或
    `rpcbind` 的一个套接字（`rpcbind_var_run_t`）。这些文件或目录在文件系统中具有截然不同的用途，这一点体现在它们所分配的上下文中。
- en: Policy writers will always try to name the context consistently, making it easier
    for us to understand the purpose of the file, but also to make the policy almost
    self-explanatory so that administrators can understand the purpose of the policy
    without additional documentation needs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 策略编写者总是尽力一致地命名上下文，使我们更容易理解文件的目的，同时也使得策略几乎是自解释的，管理员可以在不需要额外文档的情况下理解策略的目的。
- en: For the regular filesystem, for instance, files are labeled with a context resembling
    their main location as they have similar security properties. For example, we
    find binaries in the `/bin` folder (and `/usr/bin`) to be associated with the
    `bin_t` type, boot files in `/boot` associated with `boot_t`, and generic system
    resources in `/usr` associated with `usr_t`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规文件系统，例如，文件根据其主要位置进行标签，以便它们具有相似的安全属性。例如，我们发现 `/bin` 文件夹（以及 `/usr/bin`）中的二进制文件与
    `bin_t` 类型相关联，`/boot` 中的启动文件与 `boot_t` 相关联，`/usr` 中的通用系统资源与 `usr_t` 相关联。
- en: 'We can also find more application-specific contexts. For instance, for the
    PostgreSQL database server, we have the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以找到更多应用特定的上下文。例如，对于 PostgreSQL 数据库服务器，我们有以下上下文：
- en: The `postgresql_t` context is meant for the application itself (process type
    or domain).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgresql_t` 上下文是为应用程序本身（进程类型或域）设计的。'
- en: The `postgresql_port_t` context is meant for the TCP port on which the PostgreSQL
    daemon listens.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgresql_port_t` 上下文是为 PostgreSQL 守护进程监听的 TCP 端口设计的。'
- en: The `postgresql_server_packet_t` and `postgresql_client_packet_t` contexts are
    types associated with network packets received (in case of the `postgresql_server_packet_t`
    type) or sent to the PostgreSQL port.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgresql_server_packet_t` 和 `postgresql_client_packet_t` 上下文是与接收的网络数据包（对于
    `postgresql_server_packet_t` 类型）或发送到 PostgreSQL 端口的数据包相关的类型。'
- en: The `postgresql_exec_t` type is assigned to the `postgres` binary.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgresql_exec_t` 类型被分配给 `postgres` 二进制文件。'
- en: The various `postgresql_*_t` types for specific filesystem locations related
    to the daemon, such as `postgresql_var_run_t` (to apply to resources in `/var/run`),
    `postgresql_etc_t` (to apply to resources in `/etc`), `postgresql_log_t` (to apply
    to resources in `/var/log`), and `postgresql_tmp_t` (to apply to resources in
    `/tmp`).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种 `postgresql_*_t` 类型用于与守护进程相关的特定文件系统位置，例如 `postgresql_var_run_t`（适用于 `/var/run`
    中的资源）、`postgresql_etc_t`（适用于 `/etc` 中的资源）、`postgresql_log_t`（适用于 `/var/log` 中的资源）和
    `postgresql_tmp_t`（适用于 `/tmp` 中的资源）。
- en: The `mysqld_db_t` type for the database files themselves.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库文件本身的 `mysqld_db_t` 类型。
- en: Based on the context of a file or resource, administrators can easily detect
    anomalies in the system setup. An example of an anomaly is when we move a file
    from the user's home directory to a web server location. When this occurs, the
    file retains the `user_home_t` context as extended attributes are moved with it.
    As the web server process isn't allowed to access `user_home_t` by default, it
    will not be able to serve this file to its users.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件或资源的上下文，管理员可以轻松地检测系统设置中的异常。异常的一个例子是当我们将文件从用户的主目录移动到 Web 服务器位置时。当这种情况发生时，文件保留了
    `user_home_t` 上下文，因为扩展属性随着文件一起移动。由于 Web 服务器进程默认不允许访问 `user_home_t`，它将无法向用户提供该文件。
- en: Let's see how to properly set contexts during such copy or move operations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在这种复制或移动操作中正确设置上下文。
- en: Keeping or ignoring contexts
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持或忽略上下文
- en: Now that we are aware that file contexts are stored as extended attributes,
    how do we ensure that files receive the correct label when they are written or
    modified? To set an SELinux context on a filesystem resource, a few guidelines
    exist, ranging from inheritance rules to explicit commands.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道文件上下文是作为扩展属性存储的，如何确保文件在写入或修改时获得正确的标签呢？为了在文件系统资源上设置SELinux上下文，存在一些准则，从继承规则到显式命令。
- en: Inheriting the default contexts
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承默认上下文
- en: By default, the SELinux security subsystem uses context inheritance to identify
    which context should be assigned to a file (or directory, socket, and so on) when
    it is created. A file created in a directory with a `var_t` context will be assigned
    the `var_t` context as well. This means that the file inherits the context from
    the parent directory and not from the context of the executing process.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SELinux安全子系统使用上下文继承来确定在创建文件（或目录、套接字等）时应该分配哪个上下文。在具有`var_t`上下文的目录中创建的文件，也将被分配`var_t`上下文。这意味着文件从父目录继承上下文，而不是从执行进程的上下文继承。
- en: 'There are a few exceptions to this though:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一些例外：
- en: SELinux-aware applications can force the context of a file to be different (assuming
    the SELinux policy allows it, of course). As this is within the software code
    itself, this behavior cannot be generally configured.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持SELinux的应用程序可以强制文件的上下文不同（当然，前提是SELinux策略允许这样做）。由于这是在软件代码内部，这种行为无法进行通用配置。
- en: An application called `restorecond` can be used that enforces contexts on various
    paths/files based on SELinux's context rules. We will cover these rules and the
    `restorecond` application in the *SELinux file context expressions* and *Modifying
    file contexts* sections, respectively.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`restorecond`的应用程序可以根据SELinux的上下文规则，在不同的路径/文件上强制执行上下文。我们将在*SELinux文件上下文表达式*和*修改文件上下文*部分分别介绍这些规则和`restorecond`应用程序。
- en: The SELinux policy allows for transition rules that consider the context of
    the process creating new files or directories, as well as the name of the file
    the process is creating.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux策略允许考虑创建新文件或目录的进程的上下文以及进程正在创建的文件名的过渡规则。
- en: It is these transition rules we will cover next.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将介绍这些过渡规则。
- en: Querying transition rules
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询过渡规则
- en: 'Type transition rules are policy rules that force the use of a different type
    upon certain conditions. For file contexts, such a type transition rule can be
    as follows: if a process running in the `httpd_t` domain creates a file in a directory
    labeled with the `var_log_t` SELinux type, then the type identifier of the file
    becomes `httpd_log_t`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 类型过渡规则是策略规则，在某些条件下强制使用不同的类型。对于文件上下文，类似的类型过渡规则可以是这样的：如果在`httpd_t`域中运行的进程在标记为`var_log_t`的目录中创建一个文件，那么该文件的类型标识符将变为`httpd_log_t`。
- en: Basically, this rule assigns the `httpd_log_t` web server log context to any
    file placed in a log directory by web servers, rather than the default `var_log_t`,
    which would be the case when standard inheritance was used.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这条规则将`httpd_log_t`网页服务器日志上下文分配给任何被网页服务器放入日志目录中的文件，而不是使用标准继承时会出现的默认`var_log_t`上下文。
- en: 'We can query these type transition rules using `sesearch`. The `sesearch` application
    is one of the most important tools available to query the current SELinux policy.
    For the previous example, we need the (source) domain and the (target) context
    of the directory: `httpd_t` and `var_log_t`. In the following example, we use
    `sesearch` to find the type transition declaration related to the `httpd_t` domain
    toward the `var_log_t` context:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`sesearch`查询这些类型过渡规则。`sesearch`应用程序是查询当前SELinux策略的最重要工具之一。对于前面的例子，我们需要目录的（源）域和（目标）上下文：`httpd_t`和`var_log_t`。在以下示例中，我们使用`sesearch`来查找与`httpd_t`域过渡到`var_log_t`上下文的类型过渡声明：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `type_transition` line is an SELinux policy rule, which maps perfectly
    to the description. Let''s look at another set of type transition rules for the
    `tmp_t` type (assigned to the directory used for temporary files, such as `/tmp`
    and `/var/tmp`):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`type_transition`行是一个SELinux策略规则，完美地映射到描述中。我们来看一下针对`tmp_t`类型（分配给用于临时文件的目录，如`/tmp`和`/var/tmp`）的另一组类型过渡规则：'
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The policy tells us that, if a file, directory, symbolic link, or socket is
    created in a directory labeled `tmp_t`, then this newly created resource gets
    the `httpd_tmp_t` context assigned (and thus not the default, inherited `tmp_t`
    one). Alongside these rules, it also contains two named file transitions, which
    are more flexible transition rules.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 策略告诉我们，如果在标记为`tmp_t`的目录中创建文件、目录、符号链接或套接字，则该新创建的资源将分配`httpd_tmp_t`上下文（因此不是默认的继承`tmp_t`上下文）。除了这些规则外，它还包含了两个命名的文件转换规则，这些规则是更灵活的转换规则。
- en: With `HTTP_23` or `HTTP_48` is created in a directory labeled `tmp_t`, then
    it does not get the `httpd_tmp_t` context assigned (as would be implied by the
    regular type transition rules), but the `krb5_host_rcache_t` type (used for Kerberos
    implementations) instead.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在标记为`tmp_t`的目录中创建`HTTP_23`或`HTTP_48`，则不会分配`httpd_tmp_t`上下文（根据常规类型转换规则本应分配），而是分配`krb5_host_rcache_t`类型（用于Kerberos实现）。
- en: Type transitions not only give us insight into what labels (and thus also SELinux
    contexts) are going to be assigned, but also give us some clues as to which types
    are related to a particular domain. In the web server example, we found out by
    querying the policy that its log files are most likely labeled `httpd_log_t`,
    and its temporary files `httpd_tmp_t`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换不仅使我们了解哪些标签（因此也包括SELinux上下文）将被分配，还为我们提供了哪些类型与特定域相关的线索。在web服务器的示例中，我们通过查询策略发现，其日志文件很可能被标记为`httpd_log_t`，而临时文件则标记为`httpd_tmp_t`。
- en: Copying and moving files
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制和移动文件
- en: 'File contexts can also be transferred together with the file itself during
    copy or move operations. By default, Linux will do the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 文件上下文也可以在复制或移动操作过程中与文件一起传输。默认情况下，Linux会执行以下操作：
- en: Retain the file context in case of a move (`mv`) operation on the same filesystem
    (as this operation does not touch extended attributes, but merely adjusts the
    metadata of the file).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一文件系统上的移动（`mv`）操作中保留文件上下文（因为此操作不会触及扩展属性，仅调整文件的元数据）。
- en: Ignore the current file context in case of a move operation across a filesystem
    boundary, as this creates a new file, including content and extended attributes.
    Instead, it uses the inheritance (or file transition rules) to define the target
    context.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在跨文件系统边界的移动操作中忽略当前文件上下文，因为这会创建一个新文件，包括内容和扩展属性。相反，使用继承（或文件转换规则）来定义目标上下文。
- en: Ignore the file context in case of a copy (`cp`) operation, instead using the
    inheritance (or file transition rules) to define the target context.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行复制（`cp`）操作时忽略文件上下文，而是使用继承（或文件转换规则）来定义目标上下文。
- en: Luckily, this is just default behavior (based on the extended attribute support
    of these utilities) that can be manipulated freely.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这只是默认行为（基于这些实用程序的扩展属性支持），可以自由操作。
- en: 'We can use the `-Z` option to tell `mv` that the context of the file should
    be set to the default type associated with the target location. For instance,
    in the next example, two files are moved from a user''s home directory to the
    `/srv` directory. The first example will retain its file context (`user_home_t`
    or `admin_home_t`), while the second one will receive the type associated with
    user files placed in `/srv` (`var_t`):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-Z`选项告诉`mv`命令将文件的上下文设置为与目标位置相关联的默认类型。例如，在下一个示例中，两个文件从用户的主目录移动到`/srv`目录。第一个示例将保留其文件上下文（`user_home_t`或`admin_home_t`），而第二个示例将获得与放置在`/srv`中的用户文件相关的类型（`var_t`）：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, we can tell the `cp` command through the `--preserve=context` option
    to preserve the SELinux context while copying files. Using the same example, we
    now get the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以通过`--preserve=context`选项告诉`cp`命令在复制文件时保留SELinux上下文。使用相同的示例，现在我们得到以下结果：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Most of the utilities provided through the `coreutils` package support the
    `-Z` option: `mkdir` (to create a directory), `mknod` (to create a device file),
    `mkfifo` (to create a named pipe), and so on.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`coreutils`包提供的大多数实用程序支持`-Z`选项：`mkdir`（创建目录）、`mknod`（创建设备文件）、`mkfifo`（创建命名管道）等。'
- en: Important note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: If the `mv` command returns `failed to set the security context` when using
    the `-Z` option, then it is very likely that the location either does not have
    a valid context associated with it, or that the filesystem does not support SELinux
    labels. The former is for instances applicable when moving files to `/tmp` as
    the CentOS SELinux policy does not have any default context set for files and
    directories inside `/tmp`. Newly created resources always need to have their own
    affiliated labels applied (such as `user_tmp_t`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在使用`-Z`选项时，`mv`命令返回`failed to set the security context`，那么很可能该位置要么没有与之关联的有效上下文，要么文件系统不支持SELinux标签。前者适用于将文件移动到`/tmp`的情况，因为CentOS
    SELinux策略未为`/tmp`中的文件和目录设置默认上下文。新创建的资源总是需要应用其关联的标签（例如`user_tmp_t`）。
- en: 'Even more so, many of these utilities allow the user to explicitly provide
    a context through the `--context` option. For instance, to create a directory,
    `/srv/foo`, with the context `user_home_t`, using `mkdir` by default would not
    work, as the target context would be set to `var_t`. With the `--context` option,
    we can tell the utility to set a specific context:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，许多这些工具允许用户通过`--context`选项显式地提供上下文。例如，要创建一个上下文为`user_home_t`的目录`/srv/foo`，使用`mkdir`默认情况下是无法实现的，因为目标上下文会被设置为`var_t`。通过`--context`选项，我们可以告诉工具设置特定的上下文：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For other utilities, it is best to consult the manual page and see how the utility
    deals with extended attributes. For instance, the `rsync` command can preserve
    the extended attributes by using the `-X` or `--xattrs` option.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他工具，最好查阅手册页面，了解该工具如何处理扩展属性。例如，`rsync`命令可以通过使用`-X`或`--xattrs`选项来保留扩展属性。
- en: Temporarily changing file contexts
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时更改文件上下文
- en: 'We can use the `chcon` tool to update the context of the file (or files) directly.
    In our previous example, we noticed the `var_t` label on the DokuWiki files. This
    is a generic type for variable data and is not the right context for web content.
    We can use `chcon` to put the `httpd_sys_content_t` label on these files, which
    would allow web servers to have read access on these resources:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`chcon`工具直接更新文件（或文件们）的上下文。在我们之前的示例中，我们注意到DokuWiki文件上的`var_t`标签。这个标签是针对变量数据的通用类型，而不是用于网页内容的正确上下文。我们可以使用`chcon`将`httpd_sys_content_t`标签应用到这些文件上，这样就允许网页服务器对这些资源具有读取权限：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another feature that `chcon` offers is to tell it to label a file or location
    with the same context as a different file. In the next example, we use `chcon`
    to label `/srv/web` and its resources with the same context as used for the `/var/www`
    directory:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`chcon`提供的另一个功能是告诉它用与另一个文件相同的上下文来标记文件或位置。在下一个示例中，我们使用`chcon`将`/srv/web`及其资源标记为与`/var/www`目录相同的上下文：'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we change the context of a file through `chcon` and set it to a context
    different from the one in the context list, then the context might be reverted
    later: package managers might reset the file contexts back to their intended value,
    or the system administrator might trigger a fill filesystem relabeling operation.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过`chcon`更改文件的上下文并将其设置为与上下文列表中不同的上下文，那么该上下文可能会被恢复：包管理器可能会将文件上下文重置回其预定值，或者系统管理员可能会触发一次完整的文件系统标签重命名操作。
- en: 'Until now, we''ve only focused on the type part of a context. Contexts, however,
    also include a role part and an SELinux user part. If UBAC is not enabled, then
    the SELinux user has no influence on any decisions, and resetting it has little
    value. If UBAC is enabled, though, it might be necessary to reset the SELinux
    user values on files. Utilities such as `chcon` can set the SELinux user as well:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只关注了上下文中的类型部分。然而，上下文还包括角色部分和SELinux用户部分。如果未启用UBAC，则SELinux用户对任何决策没有影响，重置它几乎没有价值。然而，如果启用了UBAC，则可能需要重置文件上的SELinux用户值。像`chcon`这样的工具也可以设置SELinux用户：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The role for a file is usually `object_r` as roles currently only make sense
    for users (processes).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的角色通常是`object_r`，因为角色当前只对用户（进程）有意义。
- en: To be able to change contexts, we do need the proper SELinux privileges, named
    `relabelfrom` and `relabelto`. These rights are granted on domains to indicate
    whether the domain can change a label from one type to another. If we find denials
    in the audit log related to these permissions, then this means that the policy
    prohibits the domain from changing the contexts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够更改上下文，我们确实需要适当的SELinux权限，称为`relabelfrom`和`relabelto`。这些权限授予域，以指示该域是否可以将标签从一种类型更改为另一种类型。如果我们在审核日志中找到与这些权限相关的拒绝信息，那么这意味着策略禁止该域更改上下文。
- en: Placing categories on files and directories
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将类别放置在文件和目录上
- en: 'We focused primarily on changing types and briefly touched SELinux users, but
    another important part is to support categories and sensitivity levels. With `chcon`,
    we can add sensitivity levels and categories as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要关注类型的更改，并简要讨论了 SELinux 用户，但另一个重要部分是支持类别和敏感度级别。使用`chcon`，我们可以如下添加敏感度级别和类别：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Another tool that can be used to assign categories is the `chcat` tool. With
    `chcat`, we can assign additional categories rather than having to reiterate them,
    as would be the case with `chcon`, and even enjoy the human-readable category
    levels provided by the `setrans.conf` file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以用来分配类别的工具是`chcat`工具。通过`chcat`，我们可以分配额外的类别，而无需像`chcon`那样反复设置它们，甚至可以享受由`setrans.conf`文件提供的可读性强的类别级别：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To remove a category, just use the minus sign:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除类别，只需使用减号：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To remove all categories, use the `-d` option:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除所有类别，请使用`-d`选项：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Users and administrators should keep in mind that applications generally do
    not set categories themselves, so they need to be added ad hoc.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和管理员应当记住，应用程序通常不会自行设置类别，因此需要根据需要手动添加。
- en: Using multilevel security on files
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在文件上使用多级安全性
- en: 'When the system uses an MLS policy, the `chcon` tool needs to be used. The
    syntax is the same as with categories. For instance, to set the sensitivity `s1`
    and category set `c2` and `c4` to `c10` on all files of a user''s home directory,
    you''d do the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统使用 MLS 策略时，需要使用`chcon`工具。语法与类别相同。例如，要在用户主目录的所有文件上设置敏感度` s1`和类别集` c2`和` c4`到`
    c10`，你可以执行以下操作：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember that both the context of the user executing `chcon` and the context
    of the user who will use the data must be able to deal with the mentioned sensitivity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，执行`chcon`的用户的上下文和将使用数据的用户的上下文必须能够处理提到的敏感度。
- en: Backing up and restoring extended attributes
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份和恢复扩展属性
- en: 'As with the regular file operation tools (such as `mv` and `cp`), backup software,
    too, needs to consider SELinux contexts. Two important requirements exist for
    a backup tool when working with SELinux-enabled systems:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规的文件操作工具（如`mv`和`cp`）一样，备份软件在处理 SELinux 启用的系统时，也需要考虑 SELinux 上下文。备份工具在与 SELinux
    启用的系统一起使用时有两个重要的要求：
- en: The backup tool must run in an SELinux context capable of reading all files
    in scope of the backup, and, of course, of restoring those files as well. If no
    specific SELinux policy for the backup tool exists, then it might need to run
    in an unconfined or highly privileged domain to succeed.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份工具必须在能够读取备份范围内所有文件的 SELinux 上下文中运行，当然，还需要能够恢复这些文件。如果备份工具没有特定的 SELinux 策略，那么它可能需要在未受限制或具有高度权限的域中运行才能成功。
- en: The backup tool must be able to back up and restore extended attributes.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份工具必须能够备份和恢复扩展属性。
- en: 'A popular tool for taking backups (or archives) is the `tar` application, which
    supports SELinux contexts as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的备份（或归档）工具是`tar`应用程序，它支持以下 SELinux 上下文：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When creating a tar archive, add `--selinux` to include SELinux contexts (both
    during the creation of the archive and when extracting files from the archive).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 tar 归档时，添加`--selinux`以包括 SELinux 上下文（在创建归档和提取文件时都会包括）。
- en: Using mount options to set SELinux contexts
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用挂载选项设置 SELinux 上下文
- en: Not all filesystems support extended attributes. When we use a filesystem without
    extended attribute support, then the SELinux context of a file is either based
    on the filesystem type itself (each filesystem has its own associated context)
    or is passed on to the system using a `mount` option.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有文件系统都支持扩展属性。当我们使用不支持扩展属性的文件系统时，文件的 SELinux 上下文要么基于文件系统类型本身（每个文件系统都有自己关联的上下文），要么通过`mount`选项传递给系统。
- en: 'The most commonly used `mount` option in these situations is the `context=`
    option. When set, it will use the mentioned context as the context for all the
    resources in the filesystem. For instance, to mount an external USB drive that
    hosts a FAT filesystem while ensuring that end users can write to it, we could
    mount it with the `user_home_t` context:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，最常用的`mount`选项是`context=`选项。当设置时，它将使用指定的上下文作为文件系统中所有资源的上下文。例如，要挂载一个包含
    FAT 文件系统的外部 USB 驱动器，并确保最终用户可以写入该驱动器，我们可以使用`user_home_t`上下文挂载它：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the filesystem supports extended attributes but doesn''t have all files
    labeled yet, then we can use the `defcontext=` option to tell Linux that, if no
    SELinux context is available, then the default context provided should be used:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件系统支持扩展属性，但尚未对所有文件进行标记，则可以使用 `defcontext=` 选项告诉 Linux，如果没有 SELinux 上下文可用，则应使用提供的默认上下文：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Another mount option is `fscontext=`. This assigns a context on the filesystem
    type rather than the context of the files on the filesystem. For instance, a CD/DVD
    filesystem can be ISO 9660, Joliet, or UDF. SELinux uses this type definition
    on a filesystem to map permissions such as mount operations and file creation.
    With the `fscontext=` option, the filesystem type can be set differently from
    what the default filesystem type would be.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个挂载选项是 `fscontext=`。它为文件系统类型分配上下文，而不是为文件系统中的文件分配上下文。例如，CD/DVD 文件系统可以是 ISO
    9660、Joliet 或 UDF。SELinux 使用此类型定义来映射权限，例如挂载操作和文件创建。通过 `fscontext=` 选项，可以将文件系统类型设置为不同于默认文件系统类型。
- en: 'The last option that can be used when mounting filesystems is the `rootcontext=`
    option. This will force the root inode of the filesystem to have the given context
    even before the filesystem is visible to the user space. Permission checks on
    the location during the mount operation itself can cause havoc when the location
    does not have the expected context (especially when filesystems are mounted outside
    their expected location). The `rootcontext=` option provides a reusable configuration
    option to set the expected context:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当挂载文件系统时，可以使用的最后一个选项是 `rootcontext=` 选项。即使文件系统尚未对用户空间可见，此选项也会强制将文件系统的根 inode
    设置为给定的上下文。挂载操作期间对该位置的权限检查可能会在该位置没有预期上下文时造成混乱（尤其是当文件系统被挂载到预期位置之外时）。`rootcontext=`
    选项提供了一个可重用的配置选项来设置预期的上下文：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That''s it – these are all the context-related mount options. A final note
    though: the `context=` option is mutually exclusive to the `defcontext=` and `fscontext=`
    options. So, while the `defcontext=` and `fscontext=` options can be used together,
    they cannot be used with the `context=` option. Assuming the target filesystem
    allows for extended attributes, then we can use the file context expressions,
    which we will cover in the next section.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——这些就是所有与上下文相关的挂载选项。不过有一点需要注意：`context=` 选项与 `defcontext=` 和 `fscontext=`
    选项是互斥的。因此，虽然 `defcontext=` 和 `fscontext=` 选项可以一起使用，但不能与 `context=` 选项一起使用。假设目标文件系统支持扩展属性，则可以使用文件上下文表达式，我们将在下一节中讨论这个内容。
- en: SELinux file context expressions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SELinux 文件上下文表达式
- en: When we think that the context of a file is wrong, we need to correct the context.
    SELinux offers several methods to do so, and some distributions even add in more.
    We can use tools such as `chcon`, `restorecon` (together with `semanage`), `setfiles`,
    `rlpkg` (Gentoo), and `fixfiles`. Of course, we could also use the `setfattr`
    command, but that would be the least user-friendly approach for setting contexts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们认为文件的上下文不正确时，需要纠正上下文。SELinux 提供了几种方法来实现这一点，一些发行版甚至增加了更多的选项。我们可以使用诸如 `chcon`、`restorecon`（与
    `semanage` 一起使用）、`setfiles`、`rlpkg`（Gentoo）和 `fixfiles` 等工具。当然，我们也可以使用 `setfattr`
    命令，但那是设置上下文的最不友好的方法。
- en: Let's see how we can set context expressions in a more manageable way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何以更可管理的方式设置上下文表达式。
- en: Using context expressions
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用上下文表达式
- en: In the SELinux policy, a list of regular expressions is kept that informs the
    SELinux utilities and libraries what the context of a file (or other filesystem
    resource) should be. Though this expression list is not enforced on the system
    directly, administrators and SELinux utilities use it to see whether a context
    is correct, and to reset contexts to what they are supposed to be. You can find
    the list itself in `/etc/selinux/targeted/contexts/files` in the various `file_contexts.*`
    files.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SELinux 策略中，保存了一组正则表达式，用于通知 SELinux 工具和库文件应该给文件（或其他文件系统资源）分配什么上下文。尽管此表达式列表不会直接在系统上强制执行，但管理员和
    SELinux 工具会使用它来检查上下文是否正确，并将上下文重置为应有的状态。您可以在 `/etc/selinux/targeted/contexts/files`
    目录下的各种 `file_contexts.*` 文件中找到该列表。
- en: 'As an administrator, we can query this list through `semanage fcontext` as
    follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 作为管理员，我们可以通过 `semanage fcontext` 查询此列表，如下所示：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'An example of a tool that queries this information is `matchpathcon`, which
    we introduced in [*Chapter 2*](B16276_02_Final_VK.xhtml#_idTextAnchor045), *Understanding
    SELinux Decisions and Logging*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 查询此信息的工具之一是 `matchpathcon`，我们在[*第2章*](B16276_02_Final_VK.xhtml#_idTextAnchor045)
    *理解 SELinux 决策与日志记录* 中介绍过：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Not all the entries are visible through the `semanage` application though. Entries
    related to specific user home directories (such as `/home/lisa/.ssh`) are not
    shown as these entries depend on the Linux user (and, more importantly, its associated
    SELinux user).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'But for all other entries, the output of the command contains the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: A regular expression that matches one or more paths
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classes to which the rule is applicable, but translated into a more human-readable
    format
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The context to assign to the resources that match the expression and class list
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The class list allows us to differentiate contexts based on the resource class.
    The `semanage fcontext` output uses human-readable identifiers: resource classes
    can be a regular file (`--`), a directory (`-d`), a socket (`-s`), a named pipe
    (`-p`), a block device (`-b`), a character device (`-c`), or a symbolic link (`-l`).
    When it says all files, the line is valid regardless of the class.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, we have not defined such rules yet, but after the next section,
    even defining custom SELinux context expressions will no longer hold any secrets.
    An important property of the context list is how SELinux prioritizes its application
    – after all, we could easily have two expressions that both match a certain resource
    or path. Within SELinux, the most specific rule wins. The logic used is as follows
    (in order):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: If line A has a regular expression and line B doesn't, then line B is more specific.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the number of characters before the first regular expression in line A is
    less than the number of characters before the first regular expression in line
    B, then line B is more specific.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the number of characters in line A is less than in line B, then line B is
    more specific.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If line A does not map to a specific SELinux type (the policy editor has explicitly
    told SELinux not to assign a type) and line B does, then line B is more specific.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a caveat with the rule order, however. When additional rules are added
    through `semanage` (which we describe in the next section), then SELinux's utilities
    apply the rules in the order they were added rather than their specificity. So,
    instead of the most specific rule, the most recently added rule that matches the
    path is used.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Registering file context changes
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because changing an SELinux context using `chcon` is often just a temporary
    measure, it is seriously recommended to only use `chcon` when testing the impact
    of a context change. Once the change is acceptable, we need to register it through
    `semanage`. For instance, to permanently mark `/srv/web` (and all its subdirectories)
    as `httpd_sys_content_t`, and the DokuWiki `data/` and `conf/` folders as `httpd_sys_rw_content_t`
    (to allow the web server to modify these resources), we need to execute the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What we do here is register `/srv/web` and its subdirectories as `httpd_sys_content_t`
    and the two writable directories as `httpd_sys_rw_content_t` through `semanage`.
    Then, we use `restorecon` to (recursively) reset the contexts of `/srv/web` to
    the value registered in the context list. This is the recommended approach for
    setting contexts on most resources.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: These registrations are local (custom) context expressions and are stored in
    a separate configuration file (`file_contexts.local`). Considering the priority
    of (locally added) expressions, it is important to have the *most specific entries
    added last*, as otherwise the more broadly defined rule for `httpd_sys_content_t`
    would be applied to the entire directory. This is unlike the priority rules for
    (policy added) expressions that do have the concept of *most specific rule wins*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The `semanage fcontext` application can also be used to inform SELinux that
    a part of the filesystem tree should be labeled similarly as a different location
    on the filesystem. Such an `semanage` to apply the same contexts as if the destination
    were the default.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make this more visible through an example, and have everything under
    `/srv/web` be labeled in a similar manner to the files at `/var/www` (including
    subdirectories), so `/srv/web/icons` gets the same context as `/var/www/icons`.
    We use the `-e` option of `semanage fcontext` to create such an equivalency as
    follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will create a substitution entry so that anything under `/srv/web` gets
    the same label as if it were at the same location under `/var/www`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Most distributions already configure a few equivalency rules that we can read
    as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `semanage fcontext -l` command will show these equivalent locations at the
    end of its output as well.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing recursive context operations
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `restorecon` application resets the SELinux context of files and other resources
    based on the context definitions managed through the SELinux policy and `semanage
    fcontext`. When applying `restorecon` in a recursive fashion against directories,
    this might take a while. To improve performance in this situation, the SELinux
    authors support the skipping of `restorecon` operations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `-D` option to `restorecon`, an additional extended attribute will
    be written to the main directory that contains a hash of the file context definitions
    used when invoking the command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Subsequent invocations of `restorecon` with `-D` will check this hash to see
    whether any of the file context definitions that impact this directory have been
    modified (using `semanage fcontext`). If there aren''t, then the restore operation
    will be skipped:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once we update a definition that influences the given location, then `restorecon`
    will reset the contexts appropriately:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `restorecon_xattr` command can be used to manage these extended attributes
    (view or delete) and show how the attributes are formed:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `digest` referenced is the `security.restorecon_last` or `security.sehash`
    extended attributes. More recent user space tools use the latter, and apply their
    logic to each subdirectory, whereas older user space utilities use the former
    and only apply their logic on the selected directory.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The disadvantage of the `security.restorecon_last` usage is that it does not
    work with subdirectories: if we apply a recursive `restorecon` operation against
    `/`, then this tool will ignore the digest on `/home`. With the `security.sehash`
    usage, a recursive operation against `/` will check the digest for `/home` as
    well.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Using customizable types
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some SELinux types are meant for files whose paths cannot be accurately defined
    by administrators or where the administrator does not want the context to be reset
    when a relabeling operation is triggered. For these purposes, SELinux supports
    what it calls `restorecon`) encounter a file with a customizable type set, they
    will not revert its context to the registered context definition.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The customizable types are declared in the `customizable_types` file inside
    `/etc/selinux/targeted/contexts`. To have `restorecon` relabel such files, administrators
    need to pass the force reset option (`-F`) before the tool resets the contexts.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the contents of this `customizable_types` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As an example, we can mark a file in a home directory as `home_bin_t`, which
    is a customizable type, and as such, this file will not be relabeled back to `user_home_t`
    when a filesystem relabeling operation is done:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Marking other types as customizable requires updating the `customizable_types`
    file, as there is no user command that adds or removes type definitions from this
    list. Because this file can be overwritten when the distribution or administrator
    pushes out a new policy package, it needs to be governed carefully.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: That said, the use of customizable types has its advantages. As an administrator,
    we might want to create and support specific types as usable by end users who
    can use `chcon` to set the contexts of individual files in their home directory.
    By having those types marked as customizable types, a relabeling operation against
    `/home` will not reset those contexts.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'When the target type is not a customizable type, administrators generally prefer
    to use `semanage fcontext` to add an expression and `restorecon` to fix the context
    of the files. Most administrators will use directory-based labeling: this is much
    easier to maintain, and much easier to explain to end users. Many will even use
    this approach for customizable types:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this command, user binaries and scripts located in the `~/bin` directory
    will be labeled as `home_bin_t`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the different file_contexts files
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside the `/etc/selinux/targeted/contexts/files` directory, five different
    `file_contexts` files can be found:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The `file_contexts` file itself (without any suffix) is the basic expression
    file provided by the SELinux policy offered through the Linux distribution.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `file_contexts.local` file contains the locally added rules (through the
    `semanage fcontext` command, which we covered earlier in this chapter).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `file_contexts.homedirs` file contains the expressions for the user home
    directories. When new user mappings are created and managed through `semanage
    login` and `semanage user`, this file is adjusted to reflect the new situation.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `file_contexts.subs_dist` file contains equivalency rules, provided by the
    distribution's SELinux policy, which tell SELinux to consider one part of the
    filesystem as having the same labeling rules as another location.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `file_contexts.subs` file contains locally managed equivalency rules (through
    the `semanage fcontext` command, covered earlier in this chapter).
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alongside those files, you will find associated `*.bin` files (so `file_contexts.bin`
    for the `file_contexts` file, `file_contexts.local.bin` for the `file_contexts.local`
    file, and so on). These `*.bin` files are automatically created, but in case of
    a discrepancy, administrators can rebuild the files themselves as well using the
    `sefcontext_compile` command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: These files contain the same information as the main file, but are precompiled
    to make lookups faster. Unless the tools detect that the `*.bin` files are older
    than their source files, the SELinux utilities will use the compiled versions
    of these files.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Exchanging local modifications
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When local modifications are registered through `semanage fcontext`, they only
    apply to a single system. If local definitions need to be reapplied on various
    systems, administrators can extract the local modifications and import them on
    another system.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'To export the local modifications, use `semanage export`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The file that contains the local modifications (`local-mods.conf` in the example)
    can be adjusted at will. This allows administrators to remove all lines except
    those they want to apply on other systems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'With the local modifications stored in the file, transport the file to the
    other system(s) and import the settings:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The imported settings are immediately registered. Of course, in case of filesystem
    changes (`semanage fcontext`), don't forget to run `restorecon` against the target
    directories.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Modifying file contexts
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know how to set SELinux contexts, both directly through tools such as
    `chcon` as well as through the `restorecon` application, which queries the SELinux
    context list to know what context a file should have. Yet `restorecon` is not
    the only application that considers this context list.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Using setfiles, rlpkg, and fixfiles
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `setfiles` application is an older one, which requires the path to the
    context list file itself to reset contexts. It is often used under the hood of
    other applications, so most administrators do not need to call `setfiles` directly
    anymore:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Another set of tools are the `rlpkg` (Gentoo) and `fixfiles` (CentOS and related
    distributions) applications. Both these applications have a nice feature: they
    can be used to reset the contexts of the files of an application rather than having
    to iterate over the files manually and run `restorecon` against them.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we''re using these tools to restore the contexts of the
    files provided by the `nginx` package:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Another feature of both applications is that they can be used to relabel the
    entire filesystem without the need to perform a system reboot, like so:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Of course, this is not as fine-grained as the commands before.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Relabeling the entire filesystem
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `rlpkg` and `fixfiles` commands as listed in the previous section are not
    the only available approaches for relabeling the entire filesystem when working
    with a CentOS (or related) distribution. SELinux offers two other methods to ask
    the system to perform a full filesystem relabeling operation during (re)boot:
    placing a touch file (which the system reads at boot time) or configuring a boot
    parameter.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'The touch file is called `.autorelabel` and should be placed in the root filesystem.
    Once set, the system needs to be rebooted:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We trigger the same behavior if we add the `autorelabel=1` parameter to the
    boot parameter list (like where we can set the `selinux=` and `enforcing=` parameters
    as discussed earlier).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Asking the system to perform a full filesystem relabeling operation will take
    a while. When finished, the system will reboot again. Touch files will be removed
    automatically after the relabeling operation has finished.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Automatically setting context with restorecond
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Contexts can also be applied by the `restorecond` daemon. The purpose of this
    daemon is to enforce the expression list rules onto a configurable set of locations,
    defined in the `/etc/selinux/restorecond.conf` file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'The following set of files and directories is an example list of locations
    configured in the `restorecond.conf` file so that `restorecond` automatically
    applies the SELinux contexts on these files and directories whenever it detects
    a context change in them:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this case, if a process creates a file that matches any of the previously
    created paths, the Linux inotify subsystem will notify `restorecond` of it. `restorecond`
    will then relabel the file according to the expression list, applying the correct
    label regardless of the process (and context) that created the file.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: The use of `restorecond` is primarily for historical reasons, when SELinux didn't
    support named file transitions. At that time, writing `resolv.conf` in `/etc`
    could not be differentiated from writing to the `passwd` file in `/etc`. The introduction
    of named file transitions has considerably reduced the need for `restorecond`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Setting SELinux context at boot with tmpfiles
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the Linux distribution uses `systemd`, then you can use `systemd-tmpfiles`
    to automatically set SELinux context at boot. `systemd` uses the `tmpfiles` application
    to automatically create and manage volatile locations on the system, such as locations
    inside `/run` when `/run` is a `tmpfs`-mounted filesystem (an in-memory filesystem).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Administrators can configure `tmpfiles` to automatically create files, directories,
    device files, symbolic links, and others at boot, and to reset the permissions
    on resources. It is through this reset operation that we can use `tmpfiles` to
    set the right SELinux context at boot time.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B16276_03_Final_VK.xhtml#_idTextAnchor071), *Managing User
    Logins*, we covered polyinstantiation, where users get their own private view
    on filesystem resources. The example we gave used a directory called `/tmp/tmp-inst`,
    which had to have the `000` permission set, and which will host the user-oriented
    `/tmp` views. Rather than having to create and set this permission each time,
    we can configure `tmpfiles` to do this for us, and define the right SELinux context
    up front:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In `/etc/tmpfiles.d`, we create a file called `selinux-polyinstantiation.conf`
    with the following content:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The name of the file can be chosen freely, but make sure it uses the `.conf`
    suffix. Every time the system boots, `systemd-tmpfiles` will ensure that the `/tmp/tmp-inst`
    directory is created with the appropriate permissions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'If a location does not need to be created, but only its SELinux context reset,
    then you can use the `z` (one resource) or `Z` (recursively) options in the `tmpfiles`
    configuration. This is used, for instance, by the default SELinux `tmpfiles` configuration,
    `selinux-policy.conf`, in `/usr/lib/tmpfiles.d`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `-` used is to inform `tmpfiles` not to adjust the permissions and ownership,
    and only to reset the SELinux context.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The context of a process
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As everything in SELinux works with contexts, even processes are assigned a
    context, also known as the domain. Let's see how we can obtain this information,
    how SELinux transitions from one domain to another, and learn how to query the
    SELinux policy to find more information about these transitions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Getting a process context
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw that the `nginx` web server runs in the `httpd_t` domain, which can
    be seen with the `ps -eZ` command, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Several other ways exist to obtain the process context. Although the method
    with `ps` is the most obvious, these other methods can prove useful in scripted
    approaches or through monitoring services.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'A first approach is to read the `/proc/<pid>/attr/current` pseudo-file, which
    we''ve already encountered in [*Chapter 1*](B16276_01_Final_VK.xhtml#_idTextAnchor018),
    *Fundamental SELinux Concepts*. It displays a process''s current security context:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To receive a somewhat more human-readable output, use the `secon` command for
    the given process ID:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, the SELinux user space project has a helper utility called `getpidcon`,
    which the `libselinux` library optionally provides. Although this utility is not
    available on CentOS (or related distributions), other distributions such as Gentoo
    do have it. The utility requires a single PID and returns its context:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, the Apache processes don't themselves inform SELinux that they need to
    run in the `httpd_t` (or, for Gentoo, the `nginx_t`) domain. For that, transition
    rules exist in the SELinux policy that govern when and how processes are executed
    in a specific domain.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning toward a domain
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as we have seen with files, if a process forks and creates a new process,
    this process, by default, inherits the context of the parent process. For the
    web server, the main process is running in the `httpd_t` domain, so all the launched
    worker processes inherit the `httpd_t` domain from it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: To differentiate the domain of one process from another, domain transitions
    can be defined. A `execve()` function, most likely after a `fork()` operation).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the file-based transitions, domain transitions can be queried using `sesearch`.
    Let''s investigate the domains allowed to transition to the `httpd_t` domain:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this case, SELinux will switch the context of a launched web server to `httpd_t`
    if the parent process is running in one of the mentioned domains (such as the
    `initrc_t` domain) and is executing a file labeled as `httpd_exec_t` (the label
    assigned to the `httpd` and `nginx` binaries).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'But for this to truly happen, several other permissions (next to the domain
    transition) need to be in place. The following list describes these various permissions:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'The source process (such as `initrc_t`) needs to be allowed to transition to
    the `httpd_t` domain, governed by the transition privilege on the process class:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The source process (such as `initrc_t`) needs to have the right of execution
    on the file it is launching (`httpd_exec_t`):'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `httpd_exec_t` type must be identified as an entry point for the `httpd_t`
    domain. SELinux uses an **entry point** to ensure that a domain transition only
    occurs when using the specified file context on the executing binary or script:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The target domain must be allowed for the role that the parent process is in.
    In the case of system daemons, the role is `system_r`:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A graphical representation of these rights is as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Graphical overview of the necessary transition permissions ](img/B16276_04_002.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Graphical overview of the necessary transition permissions
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Only when all these privileges are allowed will a domain transition occur. If
    not, then either the execution of the application fails (if the domain has no
    `execute` or `execute_no_trans` rights on the file), or it executes but remains
    running in the same domain as the parent process.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Domain transitions are an important concept as they inform the administrator
    how an application gets into its privileged context. To analyze this, many security
    administrators look at how one context can transition to another. We explain policy
    analysis in [*Chapter 13*](B16276_13_Final_VK.xhtml#_idTextAnchor330), *Analyzing
    Policy Behavior*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: For policy writers, deciding when to create a domain transition and when to
    keep the processes running in the same (source) context is a matter of design.
    Generally, policy developers will try to keep the parent context confined so that
    every additional privilege is a source of consideration for switching to another
    domain (which has that privilege). Basically, policy developers will trigger a
    transition when the target application requires significantly more (or different)
    permissions than the source domain holds.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'That is also why the `unconfined_t` domain has fewer transitions when executing
    user applications compared to the confined user domains, `user_t` or `guest_t`:
    the `unconfined_t` domain already holds many privileges, so transitioning to a
    different domain has little value. Note that this is a decision made by the policy
    writers or Linux distribution, not by the SELinux technology itself. All SELinux
    does is enforce the policy rules.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Verifying a target context
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When executing applications, the SELinux policy might have the command run
    in a different domain. Although we could start querying all rules with `sesearch`,
    a simpler command exists that tells us what the target context is when we execute
    a command or script: `selinuxexeccon`.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: This command requires at least one argument (the path of the binary or script
    that would be executed) and an optional second (the source context). If we omit
    the second argument, the tool will use the current context as the source context.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to find out in which domain the `passwd` command would run when
    executed from the current context, we''d use this command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following example shows the target context when the `init_t` domain executes
    the `nginx` binary:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Using `selinuxexeccon` is much faster than querying all appropriate permissions
    separately.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Other supported transitions
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular domain transitions are the most common transitions in SELinux, but other
    transitions are possible as well. For instance, some applications (such as `cron`
    or `login`) are SELinux-aware and will specify which domain to transition to.
    These applications call the `setexeccon()` method (set execution context) to specify
    the target domain and do not use a type transition rule. The other privilege requirements,
    however, still hold.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Some SELinux-aware applications are even able to change their *current* context
    (and not just the context of the application they execute). To accomplish this,
    the application domain needs the `dyntransition` privilege (one of the privileges
    supported for process-level activities). One example of such an application is
    OpenSSH, which, by default, runs in the `sshd_t` domain but can transition to
    the `sftpd_t` type.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Querying initial contexts
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When SELinux does not have a label yet for a resource, it will assign an initial
    context (or initial **security ID** (**SID**)) to the resource. For a few classes,
    the SELinux policy will have a default initial context from which it can further
    jumpstart and assign labels.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial contexts for various SIDs can be queried using `seinfo`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, not all classes have a default context assigned, as other classes
    have their contexts derived from the contexts of the currently listed initial
    SIDs.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking memory protections
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Legacy binaries on Linux systems might require execution permissions to be set
    on memory regions when these are used for reading, even when the execute permission
    is not actually used. This read-implies-exec is a nuisance for mandatory access
    controls such as SELinux because they need to document the appropriate permissions
    in their policy. If an application needs read access, does the policy then also
    have to include the implied execute rights? And if the policy does not include
    execute rights, should the read operation then fail because it implied execute
    permissions?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Informational note
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Read-implies-exec is a legacy support for running old binaries or binaries compiled
    for other Unix systems where applications do not explicitly mark their executable
    memory as executable, assuming that every memory region that is marked as readable
    is executable. This creates a security risk as malicious actors can load in executable
    code dynamically without the system being able to prevent the application to execute
    this code. Many operating systems nowadays have clear memory protection routines
    in place, including preventing data from becoming executable. Sadly, we often
    need to deal with legacy situations, so all operating systems have methods in
    place that selectively disable these memory controls, and within Linux this is
    done through its `man personality` for more information).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: SELinux developers allow administrators to select their most appropriate permission
    handling by introducing a memory protection check that can be tuned. The `checkreqprot`
    option can be set to `0` to check protections as handled by the kernel, or `1`
    to check protections as asked by the application.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'On older systems, this option will be set to `1` to support these legacy binaries.
    Recent distributions, however, build their applications appropriately, and the
    more secure setting `0` is used, as displayed by the `sestatus` command:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can toggle this support through `/sys/fs/selinux/checkreqprot`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The parameter's default value is configured when building the Linux kernel,
    through the `CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE` kernel configuration
    parameter. Administrators can also boot the system with the `checkreqprot=` boot
    parameter to have the specified value set.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the scope of transitions
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For security reasons, Linux systems can reduce the ability of processes to gain
    elevated privileges under certain situations or provide additional constraints
    to reduce the likelihood of vulnerabilities to be exploitable. SELinux developers,
    too, honor these situations.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing environments on transition
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we execute a higher-privileged command (be it a `setuid` application or
    one where capabilities are added to the session), the **GNU C library** (**glibc**)
    will sanitize the environment. This means that a set of security-sensitive environment
    variables are discarded to make sure that attackers, malicious persons, or malicious
    applications cannot negatively influence the session.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: This secure execution is controlled through an `LD_PRELOAD`, `LD_AUDIT`, `LD_DEBUG`,
    `TMPDIR`, and `NLSPATH` are removed from the session.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: SELinux will force this sanitation on domain transitions as well, ensuring that
    the newly executed domain does not have access to these sensitive environment
    variables. Of course, sometimes the transitioned domain requires these variables.
    Not all domains can deal with sanitized environments, or use these environment
    variables to pass along important information, so always dropping the environment
    variables might result in unusable application domains.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow transitions without sanitizing the environment, the `noatsecure` permission
    can be granted to domain transitions. For instance, let''s consider the execution
    of a Firefox plugin:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When an application running in the `unconfined_t` domain executes the plugin
    (which results in a domain transition to `mozilla_plugin_t`), the environment
    variables need to be kept as otherwise the plugin might not function properly.
    As such, the SELinux policy grants the `noatsecure` permission to the domains
    that invoke Firefox plugins.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Disabling unconstrained transitions
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A second security constraint that Linux supports is to mount a filesystem with
    the `nosuid` option. When set, no `setuid` and `setgid` binaries on that filesystem
    will have any effect on the effective user or group ID of the executing session.
    Essentially, a `setuid` application on a filesystem mounted with `nosuid` will
    act as if no `setuid` bit is set.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that transitions triggered by applications hosted on a `nosuid`-mounted
    filesystem do not allow for elevated privileges, SELinux policy developers must
    explicitly mark a transition as allowed for `nosuid`-mounted filesystems, using
    the `nosuid_transition` permission. This permission is part of the `process2`
    class:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This allows policy developers to differentiate regular domain transitions from
    `nosuid`-constrained domain transitions.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: SELinux has a limit on the number of privileges that can be assigned to a class.
    When the number of privileges exceeds 32, the SELinux developers will create a
    different class and the permissions continue in this second class. Right now,
    the two classes that have more than 32 permissions are the `capability` class
    and the `process` class.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'This permission-based approach might not be in place on all SELinux-enabled
    systems though. It is enabled when the `nnp_nosuid_transition` policy capability
    is defined and set to `1`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If this capability value is `0`, then SELinux will use a concept called `nosuid`-mounted
    filesystems. Any executable with a file context that would result in a domain
    transition will only result in a domain transition if the target domain is bounded
    by the parent domain.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '`nnp_nosuid_transition` capability, the policy developer informs the kernel
    that the `nosuid_transition` and `nnp_transition` permission checks should be
    used rather than bounded domains, and that its policy will generally only include
    support for the transitions and not for the bounded domains.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: If it is not bounded, then the domain transition will not occur, and the session
    will remain in the current context (or the command will fail to execute if the
    application is not allowed to run in the current context).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: A **bounded domain** is not just calculated live based on the permissions though.
    SELinux has an explicit rule that enforces a target domain to be bounded by a
    parent domain. Even when permissions are later added to the bounded domain, they
    will be denied by the SELinux security subsystem if they aren't part of the parent
    domain.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'With `seinfo`, these type bounds can be listed as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Most distributions, however, do not have bounded domains defined in their SELinux
    policy anymore, as the new `nosuid_transition` permission is much more flexible.
    The use of bounded domains required policy developers to extend the permissions
    of the parent domain every time the child domain needed to be extended, which
    was a major nuisance when the parent domain is a generic one (be it a container
    management platform or a system service daemon).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Using Linux's NO_NEW_PRIVS
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of filesystems mounted with `nosuid` is a specific case of Linux's `nnp_transition`
    permission, or toward a bounded domain if the `nnp_nosuid_transition` policy capability
    is not set.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The parameter can be set by applications themselves using the process control
    function `prctl()`, but the user can also influence this. The `setpriv` command
    can be used to launch applications with `PR_SET_NO_NEW_PRIVS` set (the parameter
    that applications can pass through the `prctl()` function).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, create the following simple Python-based CGI script in a `cgi-bin`
    directory inside a regular user''s home directory:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'With this CGI script now available, first launch a simple CGI-capable web server
    (we will pick port `6020` as unprivileged users should be able to bind processes
    to this port) and connect to it:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In a different session, connect to the web server and call the newly created
    Python script (here named `test.py`):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, launch the same CGI-capable web server, but with NNP enabled:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Again, connect to the web server and call the `test.py` CGI script:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Because Linux's NNP is enabled, the `ping` command is not able to obtain the
    higher privileges needed to open the socket.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you'll notice a denial for the `execute_no_trans` permission in the
    SELinux audit logs. This occurs when the SELinux policy does not allow an application
    to be executed without transitioning.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Types, permissions, and constraints
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know more about types (for processes, files, and other resources),
    let's explore how these are used in the SELinux policy in more detail.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Understanding type attributes
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have discussed the `sesearch` application already and how it can be used
    to query the current SELinux policy. Let''s look at a specific process transition:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Even though we asked for the rules related to the `initrc_t` source domain and
    the `httpd_t` target, we get a rule back for the `initrc_domain` source domain
    and the `daemon` target. What `sesearch` did here was show us how the SELinux
    policy allows the requested permission, but through *attributes* assigned to the
    `initrc_t` and `httpd_t` types.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '`initrc_domain`, the following types are all tagged with this attribute, as
    can be seen through the `seinfo` application:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As we can see, the `initrc_t` type is indeed one of the types tagged with `initrc_domain`.
    Similarly, the `daemon` attribute is assigned to several types (several hundred,
    even). So, the single allow rule mentioned earlier consolidates more than a thousand
    rules into one.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Attributes are increasingly used in the policy as a way of consolidating and
    simplifying policy development. With `seinfo -a`, you can get an overview of all
    the attributes supported in the current policy.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Querying domain permissions
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common rules in SELinux are the `allow` rules, informing the SELinux
    subsystem what permissions a domain has. `allow` rules use the following syntax:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `<source>` field is almost always a domain, whereas the `<destination>`
    field can be any type.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<class>` field allows us to differentiate privileges based on the resource,
    whether it is for a regular file, a directory, a TCP socket, a capability, and
    so on. A full overview of all supported classes can be obtained from `seinfo -c`.
    Each class has a set of permissions assigned to it that SELinux can control. For
    instance, the `sem` class (used for semaphore access) has the following permissions
    associated with it:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The reference to `ipc` in the output informs us that the class inherits permission
    from the common `ipc` class, which we can query as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the `<permissions>` field, most rules will bundle a set of permissions using
    curly brackets:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This syntax allows policy developers to make very fine-grained permission controls.
    We can use the `sesearch` command to query these rules. The more options are given
    to the `sesearch` command, the finer-grained our search parameters become. For
    instance, `sesearch -A` would give us all allow rules currently in place. Adding
    a source (`-s`) filters the output to only show the allow rules for this domain.
    Adding a destination or target (`-t`) filters the output even more. Other options
    that can be used to filter through allow rules with `sesearch` are the class (`-c`)
    and permission (`-p`) options.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: As you might have guessed by now, `sesearch` is an extremely versatile command
    for querying the active policy, showing us the SELinux policy rules that match
    the options given.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Learning about constraints
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `allow` statements in SELinux, however, only focus on type-related permissions.
    Sometimes though, we need to restrict certain actions based on the user or role
    information. SELinux supports this through constraints.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '**Constraints** in SELinux are rules applied against a class and a set of its
    permissions that must be true for SELinux to further allow the request. Consider
    the following constraint on process transitions:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This constraint says that at least one of the following rules must be true
    if a `transition`, `dyntransition`, or any of the other three mentioned process
    permissions is invoked:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: The SELinux user of the source (`u1`) and that of the target (`u2`) must be
    the same.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SELinux type of the source (`t1`) must have the `can_change_process_identity`
    attribute set, and the SELinux type of the target (`t2`) must have the `process_user_target`
    attribute set.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SELinux type of the source (`t1`) must have the `cron_source_domain` attribute
    set, and either the target type (`t2`) should have `cron_job_domain` as an attribute,
    or the target SELinux user (`u2`) should be `system_u`.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SELinux type of the source (`t1`) must have the `can_system_change` attribute
    set, and the SELinux user of the target (`u2`) must be `system_u`.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SELinux type of the source (`t1`) must have the `process_uncond_exempt`
    attribute set.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is through constraints that UBAC is implemented as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You can list the currently enabled constraints using `seinfo --constrain`. Multiple
    constraints can be active for the same class and permission set. In that case,
    all the constraints need to be true for the permission to go through.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how file contexts are stored as extended attributes
    on the filesystem and how we can manipulate the contexts of files and other filesystem
    resources. Next, we found out where SELinux keeps the definitions that describe
    which SELinux contexts to assign to the files.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: We also learned to work with the `semanage` tool to manipulate this information
    and worked with a few tools that use this information to enforce contexts on resources.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: On the process level, we got our first taste of SELinux policies, identifying
    when a process launches inside a certain SELinux domain. With it, we covered the
    `sesearch` and `seinfo` applications to query the SELinux policy. Finally, we
    looked at some of Linux's security implementations that limit the transition scope
    of applications, which also influences SELinux domain transitions.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will expand our knowledge of protecting the operating
    system through the networking-related features of SELinux.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the most common option for Linux tools to display or explicitly set
    SELinux contexts?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is an SELinux context for a file or directory stored on the system?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is `chcon` not recommended to persist SELinux context changes?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the order of context definitions using the `semanage fcontext` command important?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you relabel files on the filesystem?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What privileges does a domain need before it can transition to another domain?
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do SELinux policies bundle multiple types together to facilitate policy
    development?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
