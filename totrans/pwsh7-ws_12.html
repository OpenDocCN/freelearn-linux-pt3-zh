<html><head></head><body>
		<div id="_idContainer234">
			<h1 id="_idParaDest-231" class="chapter-number"><a id="_idTextAnchor236"/>12</h1>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor237"/>Securing PowerShell</h1>
			<p>As we’ve seen, PowerShell<a id="_idIndexMarker854"/> is an incredibly powerful tool, and, to quote Uncle Ben, “<em class="italic">with great power comes great responsibility.</em>” If you don’t know who Uncle Ben is, ask your friendly neighborhood Spider-Man. PowerShell can wreak absolute havoc across a system or an organization. This damage can be deliberate, by someone setting out to cause damage, but it can just as easily <span class="No-Break">be inadvertent.</span></p>
			<p>We’re going to start this chapter by looking at one of the features that makes PowerShell so powerful – PowerShell remoting. We’ll continue by looking at how PowerShell protects against inadvertent mistakes, and then move on to the PowerShell features that protect us from deliberate attacks. We’ll then look at the features PowerShell has that let us analyze what has happened on the machine through logging, before wrapping up with a look at the things we can do to make the code we write more secure. Because of PowerShell’s history with Windows, many of these features are exclusive to Windows, or more fully developed in Windows. When this is the case, it will <span class="No-Break">be acknowledged.</span></p>
			<p>The main topics we will cover in this chapter are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Why is security <span class="No-Break">so important?</span></li>
				<li>Securing PowerShell against <span class="No-Break">inadvertent mistakes</span></li>
				<li>Running <span class="No-Break">PowerShell securely</span></li>
				<li><span class="No-Break">PowerShell logging</span></li>
				<li>Writing <span class="No-Break">secure code</span></li>
			</ul>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor238"/>Why is security so important?</h1>
			<p>We’ve<a id="_idIndexMarker855"/> seen that PowerShell is powerful, but we haven’t seen why it can be so dangerous. Everything we’ve done so far has required an interactive logon to the client we are using, which implies someone would need physical access to a device before attacking it. PowerShell, however, has the concept of <strong class="bold">PowerShell remoting</strong>, which <a id="_idIndexMarker856"/>allows us to log on to a remote device and run PowerShell<a id="_idIndexMarker857"/> code as if we were physically there. This is why it is such a powerful administration tool. We’ll not cover much about remoting in this book, as it is very much an admin tool, but it’s important to know the basics. Let’s take a <span class="No-Break">closer look.</span></p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor239"/>A PowerShell remoting whistlestop tour</h2>
			<p>Many older cmdlets <a id="_idIndexMarker858"/>in Windows PowerShell have a <strong class="source-inline">-ComputerName</strong> parameter, which allows PowerShell to query a remote machine for information. The trouble with this parameter is that it relies on the credentials under which we are running our PowerShell session having the authorization to query the remote machine. If we’re lucky, the cmdlet will have a <strong class="source-inline">-Credential</strong> parameter that we can use to supply alternate credentials. Quite often, we’re not lucky; see the <span class="No-Break">following screenshot.</span></p>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="image/B17600_12_001.jpg" alt="Figure 12.1 – Get-Process does not feel lucky"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Get-Process does not feel lucky</p>
			<p>As we can see, the <strong class="source-inline">Get-Process</strong> cmdlet has no <strong class="source-inline">-Credential</strong> parameter, so we just have to hope that our session credentials will work on the remote machine. If we don’t have the right credential on our PowerShell session, we can’t run <strong class="source-inline">Get-Process</strong> on a remote machine. Even if we do have the right credential, it’s quite possible that a remote firewall will block the request. In PowerShell 7.2 and later, it doesn’t have a <strong class="source-inline">–ComputerName</strong> <span class="No-Break">parameter either.</span></p>
			<p>To get around this, PowerShell remoting was developed for Windows PowerShell 3.0. It uses the <strong class="bold">WinRM</strong> (short for <strong class="bold">Windows Remote Management</strong>) protocol, which is part of Windows. WinRM runs <a id="_idIndexMarker859"/>over HTTP/S on ports <strong class="source-inline">5985</strong> (HTTP) and <strong class="source-inline">5986</strong> (HTTPS), which means it can be encrypted using SSL. In enterprise configurations, where Active Directory is used, the traffic is also encrypted, using Kerberos. Obviously, Linux machines don’t include WinRM, so PowerShell 7.x helpfully includes support to run remote sessions over SSH. We’ll cover that in more detail later in this chapter, in the <em class="italic">Running PowerShell securely</em> section. Let’s have a look at how PowerShell remoting works in a Windows environment; we’ll start by enabling PowerShell remoting. Note that I’m running this on a Windows 10 client, and I have created a <a id="_idIndexMarker860"/>new local user called <strong class="source-inline">Admin</strong>, with a password and <span class="No-Break">administrator rights.</span></p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor240"/>Enabling PowerShell remoting</h2>
			<p>By default, PowerShell remoting<a id="_idIndexMarker861"/> is enabled on all Windows servers. However, it’s disabled on Windows clients. The easiest way to get it running is to use the <strong class="source-inline">Enable-PSRemoting</strong> cmdlet. This cmdlet does everything we need, from enabling the endpoints to creating the correct rules in Windows Firewall. This needs to be run from an elevated admin prompt. Take a look at the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="image/B17600_12_002.jpg" alt="Figure 12.2 – Enabling PowerShell remoting"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Enabling PowerShell remoting</p>
			<p>As we can see, I’ve run <strong class="source-inline">Enable-PSRemoting</strong> with a couple of common parameters. The <strong class="source-inline">-Force</strong> parameter means we don’t get asked whether we’re sure we want to do this a bunch of times, and we’ve seen the parameter used this way before. The <strong class="source-inline">-SkipNetworkProfileCheck</strong> is an interesting one, however. Many people haven’t configured their network profile on standalone clients, and the default is public. However, PowerShell remoting won’t operate over a public network, by default. Using the <strong class="source-inline">-SkipNetworkProfileCheck</strong> bypasses the network profile check but creates a firewall rule that only allows remote sessions from the local subnet. This rule is easily edited, but it’s probably better to set the network profile up correctly, or to not try running remote sessions over a <span class="No-Break">public network.</span></p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor241"/>Creating a session</h2>
			<p>Now we’ve got remoting set up <a id="_idIndexMarker862"/>on our client, let’s create a session. We can do that with the <strong class="source-inline">New-PSSession</strong> cmdlet. I’m going to store my <strong class="source-inline">Admin</strong> user credentials in a variable called <strong class="source-inline">$cred</strong>, and then I’m going to run it <span class="No-Break">like this:</span></p>
			<pre class="console">
New-PSSession -ComputerName localhost -Authentication Negotiate -Credential $cred</pre>			<p>And we can see the output we <span class="No-Break">get here:</span></p>
			<div>
				<div id="_idContainer222" class="IMG---Figure">
					<img src="image/B17600_12_003.jpg" alt="Figure 12.3 – Creating a new remoting session"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Creating a new remoting session</p>
			<p>This will create a persistent session that may be connected to and disconnected from <span class="No-Break">as needed.</span></p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor242"/>Joining and leaving a session</h2>
			<p>We can <a id="_idIndexMarker863"/>use the <strong class="source-inline">Enter-PSSession</strong> cmdlet to connect to a session <span class="No-Break">like this:</span></p>
			<pre class="console">
Enter-PSSession -Name &lt;session name&gt;</pre>			<p>The session we create is a PowerShell object (like everything else in PowerShell), and so we can also enter by passing the session through <span class="No-Break">the pipeline:</span></p>
			<pre class="console">
Get-PSSession -Name &lt;session name&gt; | Enter-PSSession</pre>			<p>This is how it looks on <span class="No-Break">my machine:</span></p>
			<div>
				<div id="_idContainer223" class="IMG---Figure">
					<img src="image/B17600_12_004.jpg" alt="Figure 12.4 – Entering and leaving a remoting session"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Entering and leaving a remoting session</p>
			<p>In the first<a id="_idIndexMarker864"/> command, I’ve called the session by name. In the second command, I’ve passed the session object to <strong class="source-inline">Enter-PSSession</strong>. I’ve left the session by using the <strong class="source-inline">exit</strong> keyword. Note that once I am in a session, the PowerShell prompt changes to reflect <strong class="source-inline">ComputerName</strong> of the client I am connected to and the remote <span class="No-Break">working directory.</span></p>
			<p>This is called <a id="_idIndexMarker865"/>a one-to-one remoting session. Once we’re in this sort of session, it is the same as if we were directly connected to the remote machine. Only the PowerShell modules on the remote machine <span class="No-Break">are available.</span></p>
			<p>We can also enter an ad hoc session by not specifying an existing session when we use <strong class="source-inline">Enter-PSSession</strong>; instead, we specify a computer name and a credential <span class="No-Break">like this:</span></p>
			<pre class="console">
Enter-PSSession -ComputerName &lt;name&gt; -Credential &lt;credential&gt;</pre>			<p>As we can see here, creating a session this way means it ceases to exist when we exit it, rather <span class="No-Break">than persisting:</span></p>
			<div>
				<div id="_idContainer224" class="IMG---Figure">
					<img src="image/B17600_12_005.jpg" alt="Figure 12.5 – Ad hoc remoting"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Ad hoc remoting</p>
			<p>In the first command in the preceding screenshot, I’m creating an ad hoc session, which I then <strong class="source-inline">exit</strong>. As we can see, after I type <strong class="source-inline">exit</strong>, the session is no longer available, as shown in the last command, where I run the <span class="No-Break"><strong class="source-inline">Get-PSSession</strong></span><span class="No-Break"> cmdlet.</span></p>
			<p>To remove <a id="_idIndexMarker866"/>persistent sessions, we can either pass the session name to <strong class="source-inline">Remove-PSSession</strong>, <span class="No-Break">like this:</span></p>
			<pre class="console">
Remove-PSSession –Name &lt;session name&gt;</pre>			<p>Alternatively, we pipe the <span class="No-Break">session object:</span></p>
			<pre class="console">
Get-PSSession -Name &lt;session name&gt; | Remove-PSSession</pre>			<p>If we run the <a id="_idIndexMarker867"/>preceding <strong class="source-inline">Get-PSSession</strong> cmdlet without specifying a session name, then all sessions will <span class="No-Break">be removed.</span></p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor243"/>One-to-many sessions</h2>
			<p>We can also run commands and<a id="_idIndexMarker868"/> scripts on multiple machines at once by using the <strong class="source-inline">Invoke-Command</strong> cmdlet, <span class="No-Break">like this:</span></p>
			<pre class="console">
Invoke-Command -ComputerName &lt;name 1&gt;, &lt;name 2&gt; -ScriptBlock {Get-Service}</pre>			<p>This will run the commands or scripts in the scriptblock against the list of names specified in the <strong class="source-inline">-ComputerName</strong> parameter. This command uses PowerShell remoting the same as the previous <span class="No-Break"><strong class="source-inline">PSSession</strong></span><span class="No-Break"> cmdlets.</span></p>
			<p>Being able to run commands on remote machines makes PowerShell an extremely useful administration tool, which unfortunately means that it is also a security risk. Let’s look now at the ways we can help prevent PowerShell from <span class="No-Break">causing problems.</span></p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor244"/>Securing PowerShell against inadvertent mistakes</h1>
			<p>The first set of tools we’ll look at are the ones that protect us from people doing things by accident. The most useful of these is a built-in execution policy that can be used to control how scripts can <span class="No-Break">be run.</span></p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor245"/>Execution policy</h2>
			<p>We encountered the execution policy<a id="_idIndexMarker869"/> feature back in <a href="B17600_08.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Writing Our First Script – Turning Simple Cmdlets into Reusable Code</em>, and noted that we would cover it in more detail in this chapter. The execution policy is a safety feature that controls how we can run scripts, but only in a Windows environment. Don Jones (the Don!) has described the execution policy as intended to “<em class="italic">…slow down an uninformed user who is unintentionally trying to run an untrusted script.</em>” There is a lot of unintentionality in that sentence. The execution policy will present a few obstacles to an educated user who is deliberately trying to run a script. The best way to stop a user from running a potentially destructive script is to make sure that they don’t have the permissions to carry out the commands in the script. I have seen customer environments where the number of domain admin accounts runs into the hundreds, many of them unused for years, but still enabled. These customers have much bigger problems than PowerShell’s <span class="No-Break">execution policy.</span></p>
			<p>The<a id="_idIndexMarker870"/> execution policy has different levels of security and is applied at different scopes. The levels are determined by the script’s origin, and whether it is signed with a code signing certificate from a trusted certificate authority; we’ll discuss code signing certificates later in this chapter, in the <em class="italic">Signing scripts</em> section. Let’s look at the <span class="No-Break">levels first:</span></p>
			<ul>
				<li><strong class="source-inline">Restricted</strong>: This is the default policy on Windows client computers and prevents the running of scripts, including formatting files and modules – any files with the <strong class="source-inline">.ps1xml</strong>, <strong class="source-inline">.psm1</strong>, or <strong class="source-inline">.ps1</strong> extensions. Individual commands may be run at the terminal, but <span class="No-Break">that’s it.</span></li>
				<li><strong class="source-inline">AllSigned</strong>: This level allows scripts with a digital signature from a trusted publisher to be run; this includes scripts that were written on the computer. If it isn’t signed, it can’t run. If it is signed by an untrusted publisher, then PowerShell will prompt the user. Obviously, if a script is malicious and signed, then it can still <span class="No-Break">be run.</span></li>
				<li><strong class="source-inline">RemoteSigned</strong>: Scripts that originated elsewhere than the local machine need a digital signature, but scripts written on the local machine do not. Obviously, there are a number of clandestine ways around this that might involve opening Notepad and using copy and paste. This is the default policy for Windows <span class="No-Break">server computers.</span></li>
				<li><strong class="source-inline">Default</strong>: This sets the default policy. On a Windows client, the default policy is <strong class="source-inline">Restricted</strong>. On a Windows server, the default policy <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">RemoteSigned</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">Undefined</strong>: This removes any execution policy that is set on the current scope. If we use this on all scopes, then the resulting policy is the default policy, as <span class="No-Break">previously mentioned.</span></li>
				<li><strong class="source-inline">Unrestricted</strong>: This is the default policy on non-Windows computers. Unsigned files from anywhere can be run; users may get a warning when running scripts that didn’t originate in the <span class="No-Break">local network.</span></li>
				<li><strong class="source-inline">Bypass</strong>: Nothing is blocked, and there are no warnings. Execution policy is ignored. This can be set by calling the <strong class="source-inline">-ExecutionPolicy</strong> parameter of the <strong class="source-inline">pwsh.exe</strong> program. We can see how this looks in the <span class="No-Break">following figure:</span></li>
			</ul>
			<div>
				<div id="_idContainer225" class="IMG---Figure">
					<img src="image/B17600_12_006.jpg" alt="Figure 12.6 – Bypassing the execution policy"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Bypassing the execution policy</p>
			<p class="list-inset">As we can see, the<a id="_idIndexMarker871"/> execution policy is only bypassed at the <strong class="source-inline">pwsh.exe</strong> process level but remains at the default for the other scopes. When this <strong class="source-inline">pwsh</strong> process ends, the execution policy bypass <span class="No-Break">will lapse.</span></p>
			<p>Let’s consider the scopes at which we can apply execution <span class="No-Break">policies next.</span></p>
			<p>As we can see in <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.6</em>, there are five scopes at which we can apply an execution policy. Each one has a different precedence level. The <strong class="source-inline">MachinePolicy</strong> and <strong class="source-inline">UserPolicy</strong> scopes can only be set in Group Policy – a feature of Windows Active Directory. Group Policy is an enterprise application for controlling the configuration of users and machines centrally, and we’re not going to worry too much about it here. There is a good introductory article on Group Policy<a id="_idIndexMarker872"/> <span class="No-Break">here: </span><a href="https://techcommunity.microsoft.com/t5/ask-the-performance-team/the-basics-of-group-policies/ba-p/372404"><span class="No-Break">https://techcommunity.microsoft.com/t5/ask-the-performance-team/the-basics-of-group-policies/ba-p/372404</span></a><span class="No-Break">.</span></p>
			<p>Scopes<a id="_idIndexMarker873"/> have an order of <a id="_idIndexMarker874"/>precedence, and a scope at a lower level will be overridden by a scope at a higher level. In descending order of precedence, the scopes are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">MachinePolicy</strong>: This scope is set using a group policy and applies to all users of <span class="No-Break">a machine.</span></li>
				<li><strong class="source-inline">UserPolicy</strong>: This scope is set by group policy and applies to the current user of <span class="No-Break">a machine.</span></li>
				<li><strong class="source-inline">Process</strong>: This scope refers to the current PowerShell session. There is no registry location for this; it is governed by the content of the <strong class="source-inline">$env:PSExecutionPolicyPreference</strong> variable. When the session is closed, the content of the variable <span class="No-Break">is removed.</span></li>
				<li><strong class="source-inline">CurrentUser</strong>: This only applies to the current user and is stored in the Windows registry, a database of <span class="No-Break">machine settings.</span></li>
				<li><strong class="source-inline">LocalMachine</strong>: This applies to all users on the machine and is also stored in <span class="No-Break">the registry.</span></li>
			</ul>
			<p>In <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.6</em>, we can see that the scopes are listed in order of precedence. Because the execution policy is <strong class="source-inline">Undefined</strong> at both the <strong class="source-inline">MachinePolicy</strong> and <strong class="source-inline">UserPolicy</strong> levels, the effective execution policy is <strong class="source-inline">Bypass</strong>, defined at the <span class="No-Break"><strong class="source-inline">Process</strong></span><span class="No-Break"> level.</span></p>
			<p>The two cmdlets we can use with the execution policy are <strong class="source-inline">Get-ExecutionPolicy</strong> and <strong class="source-inline">Set-ExecutionPolicy</strong>, which we saw back in <a href="B17600_08.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Writing Our First Script – Turning Simple Cmdlets into Reusable Code</em>. Let’s briefly look at two other features of PowerShell that are intended to help <span class="No-Break">prevent mistakes.</span></p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor246"/>Other features</h2>
			<p>These features only <a id="_idIndexMarker875"/>protect against someone accidentally running a script. Firstly, PowerShell extensions such as <strong class="source-inline">.ps1</strong> are associated with Notepad by default, rather than as executable files. This means that if someone double-clicks a script by accident, they will open it in <a id="_idIndexMarker876"/>Notepad, rather than run it. This is in contrast to earlier Windows script files such as batch files and Visual Basic script files, which would execute if <span class="No-Break">clicked accidentally.</span></p>
			<p>The other way we are protected against accidental execution is that PowerShell doesn’t search the current folder for script files, so either a relative path or absolute path must be provided to run a script at the terminal prompt, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer226" class="IMG---Figure">
					<img src="image/B17600_12_007.jpg" alt="Figure 12.7 – Absolute and relative paths"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Absolute and relative paths</p>
			<p>In the first line, I’ve used an absolute path<a id="_idIndexMarker877"/> to call a script called <strong class="source-inline">HelloWorld.ps1</strong>, which outputs the line <strong class="source-inline">hello world</strong>. In the second line, I switch to the folder containing the script, and in the third line, I attempt to call it by using <strong class="source-inline">HelloWorld</strong>, which would <a id="_idIndexMarker878"/>work for a program Windows recognizes as an executable, such as a batch file, but doesn’t for a PowerShell script. Note how PowerShell helpfully tells me what I was doing wrong. In the fourth line, I call it using a relative path by prefacing the full script name with <strong class="source-inline">.\</strong>, which <span class="No-Break">is successful.</span></p>
			<p>That used to be it for PowerShell security. Thankfully, in recent versions, lots of new features have been added that are more proactive. Let’s explore how we can run <span class="No-Break">PowerShell securely.</span></p>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor247"/>Running PowerShell securely</h1>
			<p>PowerShell has several features that actively increase the security of our environments. Let’s start by looking at <span class="No-Break">application control.</span></p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor248"/>Application control</h2>
			<p>Application control<a id="_idIndexMarker879"/> solutions prevent unauthorized applications from running. There are third-party applications, such as Trellix, but Windows 10 and later come with two built-in applications – <strong class="bold">Windows Defender Application Control</strong> (<strong class="bold">WDAC</strong>) and AppLocker. These<a id="_idIndexMarker880"/> can be used to create policies that enforce a whitelist of applications that are allowed to execute and prevent anything else from running. AppLocker is no longer under development, so WDAC is recommended. These solutions are intended for an enterprise environment and allow for centralized control. I am not aware of any solutions that work with PowerShell on Linux or macOS. When PowerShell runs under a default WDAC policy, then<a id="_idIndexMarker881"/> trusted modules and scripts are granted more access than untrusted ones, using a feature called <span class="No-Break">language modes.</span></p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor249"/>Language modes</h2>
			<p>Language modes<a id="_idIndexMarker882"/> are used to control how scripts can run in a PowerShell environment that is subject to an Application Control policy. It’s worth noting that there are lots of articles on the internet showing you how to set language modes using a variable; this is just for testing how code behaves under a particular mode and is not secure, as we’ll shortly. The only way to use language modes to enforce security policies is through an application such as WDAC, according to Microsoft. There are three <span class="No-Break">language modes:</span></p>
			<ul>
				<li><strong class="source-inline">FullLanguage</strong>: This is the default when not running under an Application <span class="No-Break">Control policy.</span></li>
				<li><strong class="source-inline">ConstrainedLanguage</strong>: This prevents the creation and use of certain .NET types and restricts access to C# code from PowerShell. It also restricts access to features such as <strong class="source-inline">ScheduledJob</strong>. Many scripts will not run in constrained language mode; they will need to be signed, and the publishing authority will need to be added to <span class="No-Break">the whitelist.</span></li>
				<li><strong class="source-inline">NoLanguage</strong>: This disables PowerShell scripting completely. Only native commands and cmdlets can run. <strong class="source-inline">New-Object</strong> is <span class="No-Break">also disabled.</span></li>
			</ul>
			<p>We can check the language mode of our session by calling the <strong class="source-inline">$ExecutionContext.SessionState.LanguageMode</strong> variable, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer227" class="IMG---Figure">
					<img src="image/B17600_12_008.jpg" alt="Figure 12.8 – Getting and setting the language mode"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Getting and setting the language mode</p>
			<p>In the first line, I call the<a id="_idIndexMarker883"/> variable, and we can see that the language mode is set to <strong class="source-inline">FullLanguage</strong>. I then set the variable to <strong class="source-inline">ConstrainedLanguage</strong>; we can see that when I call the variable again, it is now set to <strong class="source-inline">ConstrainedLanguage</strong>. Unfortunately, when I try to set it back to <strong class="source-inline">FullLanguage</strong> in the third line, I can’t, because we’re in <strong class="source-inline">ConstrainedLanguage</strong> mode, and there is limited access to variables. The easiest way to get around this is to close the session and open a new one; the language mode will revert to <strong class="source-inline">FullLanguage</strong>. As we discussed previously, setting this variable does not make <span class="No-Break">PowerShell secure.</span></p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor250"/>Security servicing criteria</h2>
			<p>PowerShell is subject to Microsoft’s Security Servicing Criteria<a id="_idIndexMarker884"/> for Windows, and so some features will receive security updates when vulnerabilities are detected. Unfortunately, those features that are included only operate on Windows, such as the execution policy and <span class="No-Break">Application Control.</span></p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor251"/>Software Bill of Materials</h2>
			<p>A <strong class="bold">Software Bill of Materials</strong> (<strong class="bold">SBOM</strong>) helps provide transparency, integrity, and identity to a piece of software by identifying <a id="_idIndexMarker885"/>each resource used in its creation, and it provides code signing and software identities that can be used to associate the software with known vulnerabilities. SBOMs are required by many governments as a response to the SolarWinds supply chain attack of 2020. This is applicable to both Windows <span class="No-Break">and Linux/Mac.</span></p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor252"/>Windows Antimalware Scan Interface support</h2>
			<p>PowerShell passes script blocks and .NET invocations to the Windows <strong class="bold">Antimalware Scan Interface</strong> (<strong class="bold">AMSI</strong>) API<a id="_idIndexMarker886"/> so that anti-malware applications, such as Windows Defender, can inspect them for malicious code. This is a <span class="No-Break">Windows-only feature.</span></p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor253"/>Secure Shell (SSH) remoting</h2>
			<p>The SSH protocol is a cryptographic protocol<a id="_idIndexMarker887"/> that supports secure network services over an unsecured network. It is cross-platform and works on both Windows and Linux/Mac systems. It relies on public key cryptography; we need to generate a key pair and pass the public key to the system we want to remote to. When we subsequently open a session, we specify the path to the private key on our machine, and SSH verifies that the public key on the remote machine is part of a pair with the local private key. At no point is the private key passed over the network. While setup is quite complex, using SSH once it is set up is <span class="No-Break">very easy.</span></p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor254"/>Just Enough Administration</h2>
			<p><strong class="bold">Just Enough Administration</strong> (<strong class="bold">JEA</strong>) is<a id="_idIndexMarker888"/> another Windows-only security feature that allows us to delegate administration for things that may be managed by PowerShell, such as <strong class="bold">Domain Name Service </strong>(<strong class="bold">DNS</strong>), Active Directory, and<a id="_idIndexMarker889"/> applications such as Exchange. For instance, we may want someone to be able to monitor the processes on a machine but not start new ones. We can configure PowerShell endpoints that only have access to the commands that are needed for a particular task, such as <strong class="source-inline">Get-Process</strong>, using the principle of least privilege, and exclude everything else from running, meaning they would be unable to run <strong class="source-inline">Start-Process</strong>. We can also configure the endpoint to use virtual privileged accounts so that a user doesn’t need to have an admin account at all to run the commands. This allows us to drastically reduce the number of users who have <span class="No-Break">admin-privileged accounts.</span></p>
			<p>As we’ve seen, nearly all of these features are only applicable to Windows environments. Luckily, everyone who uses Linux is entirely trustworthy. Let’s look at the features that are available to us to understand what PowerShell has been used for – <span class="No-Break">logging.</span></p>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor255"/>PowerShell logging</h1>
			<p>PowerShell has a number of ways to<a id="_idIndexMarker890"/> record what we do with it. In this section, we’re going to look at three of them – over the shoulder logging, deep script block logging, and <span class="No-Break">module logging.</span></p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor256"/>Over the shoulder logging</h2>
			<p>PowerShell can <a id="_idIndexMarker891"/>record a transcript of a<a id="_idIndexMarker892"/> session, using the <strong class="source-inline">Start-Transcript</strong> and <strong class="source-inline">Stop-Transcript</strong> cmdlets. The transcript function will record everything that is displayed on the screen. This is useful for recording what we do and the output we get, and then sharing it <span class="No-Break">with others.</span></p>
			<p>We can set the path where the transcript is saved using the <strong class="source-inline">-Path</strong> parameter, and we add to an existing transcript with the <strong class="source-inline">-Append</strong> parameter, followed by the name and path of an existing transcript. The <strong class="source-inline">-InvocationHeader</strong> parameter logs the time each command was run. When we want to stop recording, we can use the <span class="No-Break"><strong class="source-inline">Stop-Transcript</strong></span><span class="No-Break"> cmdlet.</span></p>
			<p>In older versions of PowerShell, we had to perform some magic to ensure that transcription was turned on, and even then, it would only log interactive sessions in the console, but that is no longer the case. We can turn on automatic transcription in Windows systems by either using Group Policy or by editing the <strong class="source-inline">powershell.config.json</strong> file in the <strong class="source-inline">$pshome</strong> location – <strong class="source-inline">C:\Program Files\PowerShell\7</strong> in Windows. Editing the config file works for both Windows and Linux/Mac, although you may need to create it first. To enable transcription, we would need to add the following JSON to <span class="No-Break">the file:</span></p>
			<pre class="source-code">
{
    "Transcription": {
        "EnableTranscripting": true,
        "EnableInvocationHeader": true,
        "OutputDirectory": "c:\\Temp\\MyTranscriptPath"
      }
}</pre>			<p>To stop transcription, delete the <span class="No-Break">JSON entry.</span></p>
			<p>The <a id="_idIndexMarker893"/>transcript contains a useful header that <a id="_idIndexMarker894"/>includes the account the session was run under, whether the session was using <strong class="source-inline">RunAs</strong> credentials, such as administrator, which version of PowerShell was used, and the process number. Let’s take <span class="No-Break">a look:</span></p>
			<div>
				<div id="_idContainer228" class="IMG---Figure">
					<img src="image/B17600_12_009.jpg" alt="Figure 12.9 – The transcript header"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – The transcript header</p>
			<p>I’ve used <strong class="source-inline">Get-Content</strong> with the <strong class="source-inline">-Head</strong> parameter to call the first 19 lines of the transcript file, and we can see the information it contains. When I run <strong class="source-inline">Stop-Transcript</strong>, the name and path of the transcript file <span class="No-Break">is displayed.</span></p>
			<p>Over the shoulder logging is a very powerful tool for recording what is done with PowerShell, especially if transcripts are sent to a central shared location and then scanned by<a id="_idIndexMarker895"/> a <strong class="bold">Security Information and Event Management</strong> (<strong class="bold">SIEM</strong>) application. However, it doesn’t capture everything. Let’s look at the next technique, deep script <span class="No-Break">block logging.</span></p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor257"/>Deep script block logging</h2>
			<p>If we call a <a id="_idIndexMarker896"/>function or a script, the transcript will record that call, but it won’t tell us anything <a id="_idIndexMarker897"/>about the contents of the function or script. This is where we need deep script block logging, which will record the contents of the script and other pertinent information to the logging system. In Windows, this is the <strong class="source-inline">PowerShellCore</strong> log, under <strong class="bold">Applications and Services Logs</strong> in <strong class="bold">Event Viewer</strong>, and it’s the systemd log in Linux, <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">/var/log/journal</strong></span><span class="No-Break">.</span></p>
			<p>We can enable deep script block logging via group policy on Windows, or through the config file if the machine we use is not in an Active <span class="No-Break">Directory domain.</span></p>
			<p>On my machine, I have edited the <strong class="source-inline">PowerShell.config.json</strong> file to include lines 4–16 in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer229" class="IMG---Figure">
					<img src="image/B17600_12_010.jpg" alt="Figure 12.10 – Enabling deep script block logging in PowerShell"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10 – Enabling deep script block logging in PowerShell</p>
			<p>Remember that this is JSON, so it is really important to get the syntax correct. VS Code will underline any syntax errors. We will also need admin privileges to save <span class="No-Break">the file.</span></p>
			<p>Now, if I open a new session and call the <strong class="source-inline">HelloWorld.ps1</strong> script that we used at the start of this chapter, I can expect to see events appear in my event log, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer230" class="IMG---Figure">
					<img src="image/B17600_12_011.jpg" alt="Figure 12.11 – Script block logging events in the event log"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11 – Script block logging events in the event log</p>
			<p>Remember <a id="_idIndexMarker898"/>that the <strong class="source-inline">HelloWorld.ps1</strong> script was a single line of code – <strong class="source-inline">Write-Output "hello world"</strong>. We can see that line clearly in the preceding <a id="_idIndexMarker899"/>event. We can also see the account it was run under, when it was run, and on <span class="No-Break">what machine.</span></p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor258"/>Module logging</h2>
			<p>The final type of<a id="_idIndexMarker900"/> logging we’ll look at is module logging. This is similar to script block logging <a id="_idIndexMarker901"/>and tracks the modules that are being loaded and called in PowerShell. This can generate a lot of information quite quickly, so there is an option to only record specified modules. If we want to record all the modules, then we can use a wildcard (<strong class="source-inline">*</strong>) instead of an array of module names in the JSON we add to the config file. Again, if group policy is available, then we can use it to enable <span class="No-Break">module logging.</span></p>
			<p>There are other types of logging available, but they are quite specialized, such as protected event logging for events that may contain sensitive information, such as personal details. I’ve not needed to <span class="No-Break">use them.</span></p>
			<p>That wraps up the security features we’re going to cover. Let’s move on to the final section of this chapter and look at ways we can write <span class="No-Break">secure code.</span></p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor259"/>Writing secure code</h1>
			<p>Most code has <a id="_idIndexMarker902"/>security flaws; it is our job to make sure that the code we write is as secure as possible. In this section, we will look at some ways to write more secure PowerShell code. We’ll look at how to store passwords our scripts might need, code signing scripts, and <span class="No-Break">parameter validation.</span></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor260"/>Storing passwords securely</h2>
			<p>Quite often, we will write<a id="_idIndexMarker903"/> a script that contains commands that need to be run with a particular set of credentials. We saw how to store credentials in an XML file in <a href="B17600_06.xhtml#_idTextAnchor117"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">PowerShell and Files – Reading, Writing, and Manipulating Data</em>. To recap, we can do it <span class="No-Break">like this:</span></p>
			<pre class="console">
$cred = Get-Credential
$cred | Export-Clixml Credential.xml</pre>			<p>The credential is then stored in an XML object. This object contains an encrypted standard string, which is the password that was entered encrypted with a reversible encryption, based on the account and machine that the string was encrypted on. Let’s look at how <span class="No-Break">this works.</span></p>
			<p>I have a password that I want to save as a <span class="No-Break">secure string:</span></p>
			<pre class="console">
$pwd = "ILovePowershell"</pre>			<p>To turn it into a secure string, I use the <span class="No-Break"><strong class="source-inline">ConvertTo-SecureString</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="console">
$securepwd = $pwd | ConvertTo-SecureString -AsPlainText -Force</pre>			<p>The password is now encrypted, as we can see if we <span class="No-Break">try this:</span></p>
			<pre class="console">
$encryptedpwd = $securepwd | ConvertFrom-SecureString
write-host $encryptedpwd</pre>			<p>Encryption, in this case, is based on the logged-on account and the machine, and the string cannot be decrypted by anyone other than the original user (or someone logged on as them) on the original machine. Let’s see how <span class="No-Break">it looks:</span></p>
			<div>
				<div id="_idContainer231" class="IMG---Figure">
					<img src="image/B17600_12_012.jpg" alt="Figure 12.12 – Putting a password in a secure string"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12 – Putting a password in a secure string</p>
			<p>On line 1, I<a id="_idIndexMarker904"/> create a variable called <strong class="source-inline">$pwd</strong> that holds a string, <strong class="source-inline">ILovePowerShell</strong>. On line 2, I create a new variable, <strong class="source-inline">$securepwd</strong>, by piping <strong class="source-inline">$pwd</strong> to the <strong class="source-inline">ConvertTo-SecureString</strong> cmdlet, with the <strong class="source-inline">-AsPlainText</strong> parameter, and use the <strong class="source-inline">-Force</strong> parameter to suppress any prompts. On line 3, I convert the contents of <strong class="source-inline">$securepwd</strong> back from a secure string to text and store it in the <strong class="source-inline">$encryptedpwd</strong> variable. Finally, on line 4, I write the contents of the <strong class="source-inline">$encryptedpwd</strong> variable, and as we can see, it is now an encrypted string, not the <span class="No-Break">original password.</span></p>
			<p><strong class="source-inline">$encryptedpwd</strong> can be stored in a file or in the registry, and it can be used to create a <strong class="source-inline">PSCredential</strong> object that can be passed to a cmdlet, using the <span class="No-Break"><strong class="source-inline">Add-Content</strong></span><span class="No-Break"> cmdlet:</span></p>
			<div>
				<div id="_idContainer232" class="IMG---Figure">
					<img src="image/B17600_12_013.jpg" alt="Figure 12.13 – Adding a password to a PSCredential as a secure string"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13 – Adding a password to a PSCredential as a secure string</p>
			<p>On line 1, I add the content of <strong class="source-inline">$encryptedpwd</strong> to a file, <strong class="source-inline">encryptedpwd.txt</strong>. On line 2, I add the contents of the file to a variable, <strong class="source-inline">$securepwd2</strong>, after converting it to a secure string. On line 3, I create a new <strong class="source-inline">PSCredential</strong> object with two values – a username string and the <strong class="source-inline">$securepwd2</strong> variable. Finally, on line 4, I check the password property of the credential, and we can see it is <strong class="source-inline">ILovePowerShell</strong>, the string I originally started with, on line 5. In this way, we can store passwords securely in a file on a machine, and they can’t be copied to another machine and decrypted. Of course, someone can remote into PowerShell on the machine and decrypt them, so it’s <span class="No-Break">not bulletproof.</span></p>
			<p>So, what is the<a id="_idIndexMarker905"/> difference between a secure string and an encrypted string? An encrypted string is a plain text string that has been encrypted, as you can see if you look in the <strong class="source-inline">encryptedpwd.txt</strong> file. A secure string is an object of type <strong class="source-inline">System.Security.SecureString</strong>. They are two different types. Many PowerShell cmdlets will only accept passwords of type <strong class="source-inline">System.Security.SecureString</strong>, so it’s important to understand which type <span class="No-Break">is needed.</span></p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor261"/>Signing scripts</h2>
			<p>Earlier in this<a id="_idIndexMarker906"/> chapter, we discussed execution policies and how they rely on scripts being signed to determine their trustworthiness. A digital signature does two things – it provides assurance that the script was signed by a trusted source and verifies that the script has not been edited after it <span class="No-Break">was signed.</span></p>
			<p>To sign a script, we need either a code-signing certificate from a trusted authority, such as VeriSign, that will be trusted by the majority of computers, a certificate from an Active Directory certificate authority that will be trusted by machines within that directory, or we can use a self-signed certificate that will only be trusted on the machine that was used to sign the script. Code-signing certificates are not cheap, and while there are a few companies that may be exploring such a thing, at the time of writing they’re not <span class="No-Break">generally available.</span></p>
			<p>Once we have a code-signing certificate, we can use the <strong class="source-inline">Set-AuthenticodeSignature</strong> cmdlet to sign the script with our certificate. The signature includes a hash of the script, so any changes made after signing will break the signature and lead to the script not being trusted. This signing only works on Windows environments, much like the execution policy feature that makes use <span class="No-Break">of it.</span></p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor262"/>Parameter security</h2>
			<p>We saw <a id="_idIndexMarker907"/>in <a href="B17600_08.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">PowerShell and Files – Reading, Writing, and Manipulating Data</em>, that we can use accelerators to force a parameter to only accept a specific type of input. We can <a id="_idIndexMarker908"/>also use regular expressions to ensure that the input is in the right format, such as a date string or IP address. This code will test a parameter and only accept date strings in the <span class="No-Break">DD/MM/YYYY format:</span></p>
			<pre class="source-code">
function Test-Date {
    param(
        [string]$date
    )
    if ($date -match "^(3[01]|[12][0-9]|0?[1-9])(\/|-)(1[0-2]|0?[1-9])\2([0-9]{2})?[0-9]{2}$")
{
        return $true
    }
    else {
        return $false
    }
}</pre>			<p>We can see how it looks in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer233" class="IMG---Figure">
					<img src="image/B17600_12_014.jpg" alt="Figure 12.14 – Validating parameter input"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14 – Validating parameter input</p>
			<p>I’ve created a <strong class="source-inline">Test-Date</strong> function that uses a regular expression to test whether the input is a valid date or not. When I pass a valid date in the correct format, the function returns <strong class="source-inline">True</strong>. When I pass an invalid date, <strong class="source-inline">21/13/2023</strong>, it returns <strong class="source-inline">False</strong>. We could use that return value to stop a script from continuing, or to prompt for <span class="No-Break">valid input.</span></p>
			<p>The preceding instance is trivial, but it is possible for unvalidated parameters to be used for malicious code injection, where code is inserted into the parameter and then executed. Parameter <a id="_idIndexMarker909"/>validation can help <span class="No-Break">prevent this.</span></p>
			<p>That wraps up what we are going to cover in this chapter. Let’s summarize what <span class="No-Break">we’ve learned.</span></p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor263"/>Summary</h1>
			<p>We started this chapter by looking at PowerShell remoting and saw how the feature can make PowerShell a security risk. We looked at how to create, join, and leave sessions and how to run expressions on multiple remote computers <span class="No-Break">at once.</span></p>
			<p>We then moved on to see how we could secure PowerShell against inadvertent mistakes and saw how the execution policy can <em class="italic">“…slow down an uninformed user who is unintentionally trying to run an untrusted script.</em>” We also saw some of the other early security features, such as requiring an absolute or relative path for <span class="No-Break">script execution.</span></p>
			<p>We then looked at more modern security features, many of which only apply to Windows, such as Application Control and language modes. Unfortunately, the security features for Linux and macOS are still <span class="No-Break">sadly lacking.</span></p>
			<p>We looked at the different ways of recording what PowerShell is doing, with over the shoulder logging, script block logging, and module logging, and saw how to turn these features on and off and where to find <span class="No-Break">the logs.</span></p>
			<p>In the final section, we looked at three techniques for writing scripts more securely – storing passwords as encrypted strings, signing our scripts, and <span class="No-Break">validating parameters.</span></p>
			<p>That’s it for this chapter, and for this part of the book, where we’ve looked at scripting and tooling. In the final part of the book, we’ll be looking at how PowerShell works in three different environments – Windows, Linux/macOS, and ARM – finishing off with a chapter on using PowerShell with .NET, the underlying platform that PowerShell is built on. I’m looking forward <span class="No-Break">to it.</span></p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor264"/>Exercises</h1>
			<ol>
				<li>Which cmdlet is used to create a new PowerShell session for <span class="No-Break">remote administration?</span></li>
				<li>How can we use PowerShell remoting securely <span class="No-Break">on Linux?</span></li>
				<li>Which execution policy in PowerShell allows only signed scripts <span class="No-Break">to run?</span></li>
				<li>What is the purpose of the <strong class="source-inline">-ExecutionPolicy </strong><span class="No-Break"><strong class="source-inline">Bypass</strong></span><span class="No-Break"> switch?</span></li>
				<li>On Windows, what can be used to analyze and block known malicious scripts <span class="No-Break">and configurations?</span></li>
				<li>What is the purpose of the constrained language mode <span class="No-Break">in PowerShell?</span></li>
				<li>How can you restrict the use of specific cmdlets for a particular user in PowerShell <span class="No-Break">on Windows?</span></li>
				<li>What is script block logging in PowerShell, and why is it important <span class="No-Break">for security?</span></li>
				<li>What is the difference between a secure string and an <span class="No-Break">encrypted string?</span></li>
			</ol>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor265"/>Further reading</h1>
			<ul>
				<li><span class="No-Break">PowerShell remoting:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/scripting/learn/ps101/08-powershell-remoting"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/learn/ps101/08-powershell-remoting</span></a></p></li>
				<li><span class="No-Break">Execution policies:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies</span></a></p></li>
				<li><span class="No-Break">Application Control:</span><ul><li><a href="https://learn.microsoft.com/en-gb/Windows/security/application-security/application-control/Windows-defender-application-control/wdac"><span class="No-Break">https://learn.microsoft.com/en-gb/Windows/security/application-security/application-control/Windows-defender-application-control/wdac</span></a></li><li><a href="https://learn.microsoft.com/en-us/powershell/scripting/learn/application-control"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/learn/application-control</span></a></li></ul></li>
				<li><span class="No-Break">Language modes:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_language_modes"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_language_modes</span></a></p></li>
				<li>Security <span class="No-Break">Servicing Criteria:</span><p class="list-inset"><a href="https://www.microsoft.com/en-us/msrc/Windows-security-servicing-criteria"><span class="No-Break">https://www.microsoft.com/en-us/msrc/Windows-security-servicing-criteria</span></a></p></li>
				<li><span class="No-Break">SBOM:</span><p class="list-inset"><a href="https://devblogs.microsoft.com/engineering-at-microsoft/generating-software-bills-of-materials-sboms-with-spdx-at-microsoft/"><span class="No-Break">https://devblogs.microsoft.com/engineering-at-microsoft/generating-software-bills-of-materials-sboms-with-spdx-at-microsoft/</span></a></p></li>
				<li><span class="No-Break">SSH:</span><ul><li><a href="https://en.wikipedia.org/wiki/Secure_Shell"><span class="No-Break">https://en.wikipedia.org/wiki/Secure_Shell</span></a></li><li><a href="https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core</span></a></li></ul></li>
				<li><span class="No-Break">JEA:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/jea/overview"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/jea/overview</span></a></p></li>
				<li>A deep dive into <span class="No-Break">PowerShell logging:</span><p class="list-inset"><a href="https://devblogs.microsoft.com/powershell/powershell-the-blue-team/"><span class="No-Break">https://devblogs.microsoft.com/powershell/powershell-the-blue-team/</span></a></p></li>
				<li>Logging <span class="No-Break">on Windows</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_Windows"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_Windows</span></a></p></li>
				<li>Logging on Linux <span class="No-Break">and macOS</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_non-Windows"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_non-Windows</span></a></p></li>
			</ul>
		</div>
	

		<div id="_idContainer235" class="Content">
			<h1 id="_idParaDest-261" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor266"/>Part 3: Using PowerShell</h1>
			<p>Now we understand how to use PowerShell 7, and how to write simple scripts and modules, it’s time to learn how to use it on different platforms. One of the defining features of PowerShell 7 is that it is cross-platform. This section will detail how to use PowerShell with a variety of platforms. This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B17600_13.xhtml#_idTextAnchor267"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with PowerShell 7 and Windows</em></li>
				<li><a href="B17600_14.xhtml#_idTextAnchor280"><em class="italic">Chapter 14</em></a>, <em class="italic">PowerShell 7 for Linux and macOS</em></li>
				<li><a href="B17600_15.xhtml#_idTextAnchor302"><em class="italic">Chapter 15</em></a>, <em class="italic">PowerShell 7 and the Raspberry Pi</em></li>
				<li><a href="B17600_16.xhtml#_idTextAnchor320"><em class="italic">Chapter 16</em></a>, <em class="italic">Working with PowerShell and .NET</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer236">
			</div>
		</div>
	</body></html>