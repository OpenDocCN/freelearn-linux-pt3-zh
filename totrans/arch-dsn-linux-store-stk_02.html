<html><head></head><body>
<div id="_idContainer024">
<h1 class="chapter-number" id="_idParaDest-29"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.2.1">Explaining the Data Structures in a VFS</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the first chapter of this book, we got </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.4.1">a good look at the </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">virtual filesystem</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.7.1">VFS</span></strong><span class="koboSpan" id="kobo.8.1">), its most common functions, why it is necessary, and how it plays a pivotal role in implementing the </span><em class="italic"><span class="koboSpan" id="kobo.9.1">everything is a file</span></em><span class="koboSpan" id="kobo.10.1"> concept in Linux. </span><span class="koboSpan" id="kobo.10.2">We also explained the system call interface in Linux and how user-space applications can use generic system calls and interact with the VFS. </span><span class="koboSpan" id="kobo.10.3">The VFS is sandwiched between user-space programs and actual filesystems and implements a common file model so that applications can use uniform access methods to perform their operations, regardless of the filesystems being used. </span></p>
<p><span class="koboSpan" id="kobo.11.1">While talking about the different filesystems, we mentioned that the VFS uses structures such as inodes, superblocks, and directory entries to represent a generic view of the filesystems. </span><span class="koboSpan" id="kobo.11.2">These structures are crucial as they ensure a clear distinction between the metadata and the actual data of </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">a file.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">This chapter will introduce you to the different data structures in the kernel’s VFS. </span><span class="koboSpan" id="kobo.13.2">You will get to know how the kernel uses structures such as inodes and directory entries to store metadata about files. </span><span class="koboSpan" id="kobo.13.3">You will also learn how the kernel is able to record the filesystem characteristics through the superblock structure. </span><span class="koboSpan" id="kobo.13.4">At the end, we’ll explain the caching mechanisms </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">in VFS.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">We’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">main topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.17.1">Inodes</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Superblocks</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Directory entries</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.20.1">File objects</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.21.1">Page cache</span></span></li>
</ul>
<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.22.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.23.1">It would be helpful to have a decent understanding of Linux operating system concepts. </span><span class="koboSpan" id="kobo.23.2">This includes knowledge of filesystems, processes, and memory management. </span><span class="koboSpan" id="kobo.23.3">We’re not going to create any new code in this book but if you want to explore the Linux kernel in more detail, understanding C programming concepts is crucial for comprehending VFS data structures. </span><span class="koboSpan" id="kobo.23.4">As a general rule, you should make it a habit to refer to the official kernel documentation as it can provide in-depth information about the kernel’s </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">internal workings.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">The commands and examples presented in this chapter are distribution agnostic and can be run on any Linux operating system, such as Debian, Ubuntu, Red Hat, Fedora, and so on. </span><span class="koboSpan" id="kobo.25.2">There are a few references to the kernel source code. </span><span class="koboSpan" id="kobo.25.3">If you want to download the kernel source, you can download it from </span><a href="https://www.kernel.org"><span class="koboSpan" id="kobo.26.1">https://www.kernel.org</span></a><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">The code segments referred to in this chapter and book are from kernel </span><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">5.19.9</span></strong><span class="koboSpan" id="kobo.29.1">. </span></p>
<h1 id="_idParaDest-32"><span class="koboSpan" id="kobo.30.1">Data structures in VF</span><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.31.1">S</span></h1>
<p><span class="koboSpan" id="kobo.32.1">VFS uses several data structures to implement generic abstraction methods for all filesystems and provides the </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.33.1">filesystem interface to user-space programs. </span><span class="koboSpan" id="kobo.33.2">These structures ensure a certain amount of commonality between the design and operations of filesystems. </span><span class="koboSpan" id="kobo.33.3">One important point to remember is that all the methods defined by VFS are not enforced upon filesystems. </span><span class="koboSpan" id="kobo.33.4">Yes, the filesystems should adhere to the structures defined in VFS and </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.34.1">build upon them to ensure commonality among them. </span><span class="koboSpan" id="kobo.34.2">But there might be a lot of methods and fields in these structures that are not applicable to a particular filesystem. </span><span class="koboSpan" id="kobo.34.3">In such cases, filesystems stick to the relevant fields as per their design and leave out the surplus information. </span><span class="koboSpan" id="kobo.34.4">As we’re going to explain common VFS data structures, it is imperative that we look at the relevant code segments in the kernel for some clarification. </span><span class="koboSpan" id="kobo.34.5">Nevertheless, I’ve tried my best to present the material in a generic way so that most concepts can be understood even without developing an understanding of </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">Ancient Greeks believed that four elements made up everything: earth, water, air, and fire. </span><span class="koboSpan" id="kobo.36.2">Likewise, the following structures make up VFS – well, most </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">of it:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.38.1">Inodes</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.39.1">Directory entries</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.40.1">File objects</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.41.1">Superblocks</span></span></li>
</ul>
<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.42.1">Inodes – indexing files and directories</span></h1>
<p><span class="koboSpan" id="kobo.43.1">When storing </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.44.1">data on disk, Linux follows one strict rule: </span><em class="italic"><span class="koboSpan" id="kobo.45.1">all the outside-of-the-envelope information must be kept apart from the contents inside the envelope</span></em><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">In other words, the data describing a file is isolated from the actual data in the file. </span><span class="koboSpan" id="kobo.46.3">The structure that holds this metadata is called the </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">index node</span></strong><span class="koboSpan" id="kobo.48.1">, shortened as </span><strong class="bold"><span class="koboSpan" id="kobo.49.1">inode</span></strong><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">The inode structure contains metadata for files and directories in Linux. </span><span class="koboSpan" id="kobo.50.3">The name of a file or directory is merely a pointer to an inode, and each file or directory has exactly </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">one inode.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Consider the Marauder’s Map as an analogy (</span><em class="italic"><span class="koboSpan" id="kobo.53.1">Harry Potter</span></em><span class="koboSpan" id="kobo.54.1">, anyone?). </span><span class="koboSpan" id="kobo.54.2">The map shows the location of every person in the school. </span><span class="koboSpan" id="kobo.54.3">Each person is represented by a dot on the map, and when you click on the dot, it reveals information about the person, such as their name, location, and status. </span><span class="koboSpan" id="kobo.54.4">Think of the Marauder’s Map as the filesystem, and the dots representing people as the inodes </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">showing metadata.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">But what constitutes the metadata for a file? </span><span class="koboSpan" id="kobo.56.2">When you do a simple listing of a file through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">ls</span></strong><span class="koboSpan" id="kobo.58.1"> command, you see a bunch of information, such as file permissions, ownership, time stamps, and so on. </span><span class="koboSpan" id="kobo.58.2">All these details constitute the metadata of the file since they are describing some properties of the file, not its </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">actual contents.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">Some of the file </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.61.1">metadata can be checked through a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">ls</span></strong><span class="koboSpan" id="kobo.63.1"> command. </span><span class="koboSpan" id="kobo.63.2">Although a slightly better command for displaying the metadata of a file is </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">stat</span></strong><span class="koboSpan" id="kobo.65.1">, as it provides a lot more information about the file attributes. </span><span class="koboSpan" id="kobo.65.2">For instance, it shows the access, modification, change timestamps, the device where the file is located, the number of blocks reserved on the drive for the file, and the inode number of </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">the file.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">If want to get detailed information about a file’s metadata, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">/etc/hosts</span></strong><span class="koboSpan" id="kobo.69.1">, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">stat</span></strong><span class="koboSpan" id="kobo.71.1"> command </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.73.1">
stat /etc/hosts</span></pre>
<p><span class="koboSpan" id="kobo.74.1">Note the inode number (</span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">67118958</span></strong><span class="koboSpan" id="kobo.76.1">) of </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">/etc/hosts</span></strong><span class="koboSpan" id="kobo.78.1"> in the output of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">stat</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.80.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.81.1">
[root@linuxbox ~]# stat /etc/hosts
  File: /etc/hosts
  Size: 220             Blocks: 8          IO Block: 4096   regular file
Device: fd00h/64768d    Inode: 67118958    Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2022-11-20 04:00:38.054988422 -0500
Modify: 2022-06-15 22:30:32.755324938 -0400
Change: 2022-06-15 22:30:32.755324938 -0400
Birth: 2022-06-15 22:30:32.755324938 -0400
[root@linuxbox ~]#</span></pre>
<p><span class="koboSpan" id="kobo.82.1">An inode number works as a unique identifier for a file. </span><span class="koboSpan" id="kobo.82.2">Consider the example of the </span><strong class="bold"><span class="koboSpan" id="kobo.83.1">Domain Name System</span></strong><span class="koboSpan" id="kobo.84.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.85.1">DNS</span></strong><span class="koboSpan" id="kobo.86.1">). </span><span class="koboSpan" id="kobo.86.2">We use human-readable website names so that we don’t have to remember the IP address of each website. </span><span class="koboSpan" id="kobo.86.3">Similarly, file and directory names ensure that we don’t need to remember the inode number. </span><span class="koboSpan" id="kobo.86.4">The kernel keeps track of each file and directory through its inode. </span><span class="koboSpan" id="kobo.86.5">An inode can be </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.87.1">considered a low-level name for a file. </span><span class="koboSpan" id="kobo.87.2">For instance, it is possible to locate a file through its inode number. </span><span class="koboSpan" id="kobo.87.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">find</span></strong><span class="koboSpan" id="kobo.89.1"> command provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">inum</span></strong><span class="koboSpan" id="kobo.91.1"> argument to search for a file through </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">its inode:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.93.1">
find / -inum 67118958 -exec ls -l {} \;</span></pre>
<p><span class="koboSpan" id="kobo.94.1">If we search for the inode number we retrieved from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">stat</span></strong><span class="koboSpan" id="kobo.96.1"> command, we can retrieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">corresponding file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.98.1">
[root@linuxbox ~]# find / -inum 67118958 -exec ls -l {} \;
-rw-r--r-- 1 root root 220 Jun 15 22:30 /etc/hosts
[root@linuxbox ~]#</span></pre>
<p><span class="koboSpan" id="kobo.99.1">Inodes are only unique within a filesystem boundary. </span><span class="koboSpan" id="kobo.99.2">If directories on your system (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">/home</span></strong><span class="koboSpan" id="kobo.101.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">/tmp</span></strong><span class="koboSpan" id="kobo.103.1">) are on separate disk partitions and filesystems, the same inode number could be assigned to a different file on </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">each filesystem:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.105.1">
[root@linuxbox ~]# ls -li /home/pokemon/pikachu 
134460858 -rw-r--r-- 1 root root 1472 Oct 11 05:10 /home/pokemon/pikachu
[root@linuxbox ~]# 
[root@linuxbox ~]# ls -li /tmp/bulbasaur
134460858 -rw-r--r-- 1 root root 259 Nov 20 04:36 /tmp/bulbasaur
[root@linuxbox ~]#</span></pre>
<p><span class="koboSpan" id="kobo.106.1">The uniqueness of inode numbers within filesystem boundaries ties to the concept of </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">linking</span></strong><span class="koboSpan" id="kobo.108.1">. </span><span class="koboSpan" id="kobo.108.2">As the same inode number can be used by different filesystems, hard links do not cross </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">filesystem boundaries.</span></span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.110.1">Defining an inode in the kernel</span></h2>
<p><span class="koboSpan" id="kobo.111.1">In the kernel source code, the definition of an inode is present in </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">linux/fs.h</span></strong><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">There are an innumerable number </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.114.1">of fields in this definition. </span><span class="koboSpan" id="kobo.114.2">Please note that this definition of </span><strong class="bold"><span class="koboSpan" id="kobo.115.1">struct inode</span></strong><span class="koboSpan" id="kobo.116.1"> is general and all-encompassing. </span><span class="koboSpan" id="kobo.116.2">An inode is a filesystem-specific property. </span><span class="koboSpan" id="kobo.116.3">It is not obligatory for a filesystem to define all these fields in its inode definition. </span><span class="koboSpan" id="kobo.116.4">The definition for the </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.117.1">inode structure is fairly long and, as such, we’re </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.118.1">going to limit ourselves to some </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">basic fields:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.120.1">
struct inode {
        umode_t                 i_mode;
        unsigned short          i_opflags;
        kuid_t                  i_uid;
        kgid_t                  i_gid;
        unsigned int            i_flags;
        const struct inode_operations   *i_op;
        struct super_block      *i_sb;
[………………………...]</span></pre>
<p><span class="koboSpan" id="kobo.121.1">Some fields of interest are </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">defined here:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">i_mapping</span></strong><span class="koboSpan" id="kobo.124.1">: This is a pointer to the address space structure that holds the mappings for the inode’s data blocks. </span><span class="koboSpan" id="kobo.124.2">This field is initialized by the filesystem when an inode is created or when it is read from disk. </span><span class="koboSpan" id="kobo.124.3">For instance, when a process writes data to a file, the kernel uses this field to map the appropriate memory pages to the file’s data blocks. </span><span class="koboSpan" id="kobo.124.4">(The data blocks are explained in the </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">next sections.)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">i_uid</span></strong><span class="koboSpan" id="kobo.127.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">i_gid</span></strong><span class="koboSpan" id="kobo.129.1">: These are for the user and group </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">owner, respectively.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">i_flags</span></strong><span class="koboSpan" id="kobo.132.1">: This defines filesystem-specific flags. </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">i_acl</span></strong><span class="koboSpan" id="kobo.134.1">: This is for access control lists for filesystems. </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">i_op</span></strong><span class="koboSpan" id="kobo.136.1">: This points to the inode operations structure, which defines all the operations that can be performed on an inode, such as creating, reading, writing, and modifying the </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">file attributes.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">i_sb</span></strong><span class="koboSpan" id="kobo.139.1">: This is pointing to the superblock structure of the underlying filesystem where the inode resides. </span><span class="koboSpan" id="kobo.139.2">(There’s a separate topic for explaining the </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">superblock structure.)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">i_rdev</span></strong><span class="koboSpan" id="kobo.142.1">: This field stores the device number for some special files. </span><span class="koboSpan" id="kobo.142.2">For instance, the kernel creates special files to represent hard disks and other devices in the system. </span><span class="koboSpan" id="kobo.142.3">When a special file is created, the kernel assigns it a unique device number, creates an inode for the device, and sets this field to point to the </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">device’s identifier.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">i_atime</span></strong><span class="koboSpan" id="kobo.145.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">i_mtime</span></strong><span class="koboSpan" id="kobo.147.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">i_ctime</span></strong><span class="koboSpan" id="kobo.149.1">: These are the access, modified, and change </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">timestamps, respectively.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">i_bytes</span></strong><span class="koboSpan" id="kobo.152.1">: This is the number of bytes in the file. </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">i_blkbits</span></strong><span class="koboSpan" id="kobo.154.1">: This field stores the number of bits needed to represent the block size of the filesystem to which the </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">inode belongs.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">i_blocks</span></strong><span class="koboSpan" id="kobo.157.1">: This field stores the total number of disk blocks used by the file represented by </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">the inode.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">i_fop</span></strong><span class="koboSpan" id="kobo.160.1">: This is a pointer </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.161.1">to the file operations structure </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.162.1">associated with the inode. </span><span class="koboSpan" id="kobo.162.2">For instance, when a process opens a file, the kernel uses this field to obtain a pointer to the file operations structure for that file. </span><span class="koboSpan" id="kobo.162.3">It can then use the functions defined in the file operations structure to perform operations on the file, such as reading </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">or writing.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">i_count</span></strong><span class="koboSpan" id="kobo.165.1">: This is used to keep track of the number of active references to the inode. </span><span class="koboSpan" id="kobo.165.2">Whenever a new process accesses a file, this counter is incremented for that file. </span><span class="koboSpan" id="kobo.165.3">If this field reaches a value of zero, it means that there are no more references to the inode, and it can be </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">safely deallocated.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">i_nlink</span></strong><span class="koboSpan" id="kobo.168.1">: This field references the number of hard links to the inode. </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">i_io_list</span></strong><span class="koboSpan" id="kobo.170.1">: This is a list used to track inodes that have pending I/O requests. </span><span class="koboSpan" id="kobo.170.2">When the kernel adds an I/O request to the queue for an inode, that inode is added to this list. </span><span class="koboSpan" id="kobo.170.3">When the I/O request has been completed, the inode is removed from </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">this list.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.172.1">There are around 50 fields in the definition for the inode structure, so we’ve barely scratched the surface here. </span><span class="koboSpan" id="kobo.172.2">But this should give us an idea that the inode defines much more than surface-level information for a file. </span><span class="koboSpan" id="kobo.172.3">Don’t worry if you’re confused. </span><span class="koboSpan" id="kobo.172.4">We’re going to explain inodes in a lot more detail. </span><span class="koboSpan" id="kobo.172.5">There are two types of operations applicable to an inode structure, which are defined by </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">file_operations</span></strong><span class="koboSpan" id="kobo.174.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">inode_operations</span></strong><span class="koboSpan" id="kobo.176.1"> structures. </span><span class="koboSpan" id="kobo.176.2">We’ll go through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">file_operation</span></strong><span class="koboSpan" id="kobo.178.1"> structure a bit later when we cover file objects in the </span><em class="italic"><span class="koboSpan" id="kobo.179.1">File objects – representing open </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.180.1">files</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.181.1"> section.</span></span></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.182.1">Defining inode operations</span></h2>
<p><span class="koboSpan" id="kobo.183.1">The inode operations structure contains a set of function pointers that define how the filesystem interacts with </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.184.1">inodes. </span><span class="koboSpan" id="kobo.184.2">Each filesystem has its own inode operations structure, which is registered with the VFS when the filesystem </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">is mounted.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">inode_operations</span></strong><span class="koboSpan" id="kobo.188.1"> struct is </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.189.1">referred to by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">i_op</span></strong><span class="koboSpan" id="kobo.191.1"> pointer. </span><span class="koboSpan" id="kobo.191.2">Remember when we explained the </span><em class="italic"><span class="koboSpan" id="kobo.192.1">everything is a file</span></em><span class="koboSpan" id="kobo.193.1"> concept in </span><a href="B19430_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.194.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.195.1">, </span><em class="italic"><span class="koboSpan" id="kobo.196.1">Where It All Starts From – The Virtual Filesystem</span></em><span class="koboSpan" id="kobo.197.1"> Since everything is a file, albeit of a different type, an inode is assigned to each of them. </span><span class="koboSpan" id="kobo.197.2">Disk drives, disk partitions, regular text files, documents, pipes, and sockets all have an inode assigned to them. </span><span class="koboSpan" id="kobo.197.3">There’s an inode for every directory as well. </span><span class="koboSpan" id="kobo.197.4">But all these </span><em class="italic"><span class="koboSpan" id="kobo.198.1">files</span></em><span class="koboSpan" id="kobo.199.1"> are of a different nature and represent different entities in your system. </span><span class="koboSpan" id="kobo.199.2">For instance, the inode operations applicable to a directory are different than a regular text file. </span><span class="koboSpan" id="kobo.199.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">inode_operations</span></strong><span class="koboSpan" id="kobo.201.1"> structure provides all the functions that an inode needs to implement for each type of file, for managing </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">inode data.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">Each inode is associated with an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">inode_operations</span></strong><span class="koboSpan" id="kobo.205.1"> structure, which provides a set of operations that can be performed on the inode. </span><span class="koboSpan" id="kobo.205.2">This structure contains pointers to different functions that are used to </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">manipulate inodes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
struct inode_operations {
        struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
        const char * (*get_link) (struct dentry *, struct inode *, struct delayed_call *);
        int (*permission) (struct user_namespace *, struct inode *, int);
        struct posix_acl * (*get_acl)(struct inode *, int, bool);
        int (*readlink) (struct dentry *, char __user *,int);
        int (*create) (struct user_namespace *, struct inode *,struct dentry *, umode_t, bool);
        int (*link) (struct dentry *,struct inode *,struct dentry *);
        int (*unlink) (struct inode *,struct dentry *);
        int (*symlink) (struct user_namespace *, struct inode *,struct dentry *,
[……………………………………….]</span></pre>
<p><span class="koboSpan" id="kobo.208.1">Some of the </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.209.1">important operations that can be performed using this structure are </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">described here:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">lookup</span></strong><span class="koboSpan" id="kobo.212.1">: This is used for searching an inode entry in a directory. </span><span class="koboSpan" id="kobo.212.2">It takes a directory inode and a filename as arguments, and it returns a pointer to the inode that corresponds to </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">the filename.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">create</span></strong><span class="koboSpan" id="kobo.215.1">: This function is called when a new file or directory is created, and it is responsible for initializing the inode with the appropriate metadata, such as ownership and permissions. </span><span class="koboSpan" id="kobo.215.2">This is used for constructing an inode object in response to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">open ()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.217.1">system call.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">get_link</span></strong><span class="koboSpan" id="kobo.219.1">: This is used for working with symbolic links. </span><span class="koboSpan" id="kobo.219.2">A symbolic link is pointing to </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">another inode.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">permission</span></strong><span class="koboSpan" id="kobo.222.1">: When a file is to be accessed, VFS invokes this function to check for access rights on </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">the file.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">link</span></strong><span class="koboSpan" id="kobo.225.1">: This is invoked in response to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">link ()</span></strong><span class="koboSpan" id="kobo.227.1"> system call, which creates a new hard link. </span><span class="koboSpan" id="kobo.227.2">It increments the link count of the inode and updates </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">its metadata.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">symlink</span></strong><span class="koboSpan" id="kobo.230.1">: This is invoked in response to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">symlink ()</span></strong><span class="koboSpan" id="kobo.232.1"> system call, which creates a new </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">soft link.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">unlink</span></strong><span class="koboSpan" id="kobo.235.1">: This is invoked in response to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">unlink ()</span></strong><span class="koboSpan" id="kobo.237.1"> system call and deletes the file link. </span><span class="koboSpan" id="kobo.237.2">It decrements the link count of the inode and deletes the inode from the disk if the link count </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">reaches zero.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">mkdir</span></strong><span class="koboSpan" id="kobo.240.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">rmdir</span></strong><span class="koboSpan" id="kobo.242.1">: These are invoked in response to </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">mkdir ()</span></strong><span class="koboSpan" id="kobo.244.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">rmdir ()</span></strong><span class="koboSpan" id="kobo.246.1"> system calls for creating and deleting </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">directories, respectively.</span></span></li>
</ul>
<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.248.1">Tracking file data on disk through inodes</span></h2>
<p><span class="koboSpan" id="kobo.249.1">Since every file in the system is going to have some metadata, it will always have exactly one inode associated with it. </span><span class="koboSpan" id="kobo.249.2">As every inode is storing some information, filesystems need to reserve some space </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.250.1">for them, typically just a few bytes. </span><span class="koboSpan" id="kobo.250.2">For </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.251.1">instance, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">Ext4</span></strong><span class="koboSpan" id="kobo.253.1"> filesystem by default uses 256 bytes for a single inode. </span><span class="koboSpan" id="kobo.253.2">Filesystems </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.254.1">maintain an </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">inode table</span></strong><span class="koboSpan" id="kobo.256.1"> to keep track of used and </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">free inodes.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">The fields present in an inode structure provide the following two types of information about </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">a file:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.260.1">File attributes</span></strong><span class="koboSpan" id="kobo.261.1">: Details about </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.262.1">file ownership, permissions, timestamps, links, and the number of </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">blocks used</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.264.1">Data blocks</span></strong><span class="koboSpan" id="kobo.265.1">: Pointers to </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.266.1">data blocks on disk, where the actual file content </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">is stored</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.268.1">In addition to file permissions, ownership, and timestamps, another important piece of information provided by the inode is the location of actual data on the disk. </span><span class="koboSpan" id="kobo.268.2">A file can span across multiple disk blocks, depending on its size. </span><span class="koboSpan" id="kobo.268.3">The inode structure uses pointers to track this information. </span><span class="koboSpan" id="kobo.268.4">Why is this necessary? </span><span class="koboSpan" id="kobo.268.5">This tracking of disk blocks is required as there is no guarantee that the data in a file will be stored and accessed in a sequential or contiguous manner. </span><span class="koboSpan" id="kobo.268.6">The pointers used by an inode are typically 4 bytes in size and can be classified as direct and indirect pointers. </span><span class="koboSpan" id="kobo.268.7">For smaller files, an inode contains direct pointers to the data blocks of a file. </span><span class="koboSpan" id="kobo.268.8">Each direct pointer points to the disk address that is storing </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">file data.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">Using direct pointers for referring to disk addresses was always going to have a major limitation. </span><span class="koboSpan" id="kobo.270.2">The question was: how many direct pointers are enough? </span><span class="koboSpan" id="kobo.270.3">File sizes can vary from a few bytes to terabytes. </span><span class="koboSpan" id="kobo.270.4">Using 15 direct pointers in the structure meant that for a block size of 4 KB, we could only point to 60 KB of data. </span><span class="koboSpan" id="kobo.270.5">Of course, this wouldn’t work in any dimension, as even small text files tend to be larger than 60 KB. </span><span class="koboSpan" id="kobo.270.6">This is depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.271.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.272.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.274.1"><img alt="Figure 2.1 – Limitation when using direct pointers: for a block size of 4 KB, only 60 KB of data can be addressed" src="image/B19430_02_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.275.1">Figure 2.1 – Limitation when using direct pointers: for a block size of 4 KB, only 60 KB of data can be addressed</span></p>
<p><span class="koboSpan" id="kobo.276.1">To cope with this problem, indirect pointers are used. </span><span class="koboSpan" id="kobo.276.2">An inode structure contains 12 direct and 3 indirect pointers. </span><span class="koboSpan" id="kobo.276.3">Unlike </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.277.1">a direct pointer, an </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">indirect pointer</span></strong><span class="koboSpan" id="kobo.279.1"> is a pointer to a </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.280.1">block of pointers. </span><span class="koboSpan" id="kobo.280.2">When all direct pointers have been exhausted, the filesystem uses a data block to store additional pointers. </span><span class="koboSpan" id="kobo.280.3">The </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.281.1">unlucky 13th or single indirect pointer in an inode points to this data block. </span><span class="koboSpan" id="kobo.281.2">The pointers inside this block point to the data blocks, which actually contain the file data. </span><span class="koboSpan" id="kobo.281.3">When the file size cannot be addressed using the single indirect pointer, double </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.282.1">indirect pointers are used. </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">Double indirect pointers</span></strong><span class="koboSpan" id="kobo.284.1"> point to a block that contains pointers to indirect blocks, each of which contains pointers to on-disk addresses. </span><span class="koboSpan" id="kobo.284.2">Similarly, when the file grows beyond the limits of a double indirect pointer—yes, you </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.285.1">guessed it—</span><strong class="bold"><span class="koboSpan" id="kobo.286.1">triple indirect pointers</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.287.1">are used.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">At this point, you’re probably off your head, and you’re thinking there is no point(-er). </span><span class="koboSpan" id="kobo.288.2">Needless to say, this entire hierarchy is pretty complex. </span><span class="koboSpan" id="kobo.288.3">Some modern filesystems make use of a concept called </span><strong class="bold"><span class="koboSpan" id="kobo.289.1">extents</span></strong><span class="koboSpan" id="kobo.290.1"> for storing </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.291.1">even larger files. </span><span class="koboSpan" id="kobo.291.2">We’re going to cover that when we cover block filesystems in </span><a href="B19430_03.xhtml#_idTextAnchor053"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.292.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.293.1">, </span><em class="italic"><span class="koboSpan" id="kobo.294.1">Exploring the Actual Filesystems Under </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.295.1">the VFS</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">For now, let us simplify this and point ourselves in the right direction. </span><span class="koboSpan" id="kobo.297.2">We’re going to make use of some basic math to explain how indirect pointers help in storing larger files. </span><span class="koboSpan" id="kobo.297.3">We’re going to consider a block size of 4 KB, as this is the default used by </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">most filesystems:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.299.1">Total pointers in an inode = 15 </span></li>
<li><span class="koboSpan" id="kobo.300.1">Number of direct pointers = </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">12</span></span></li>
<li><span class="koboSpan" id="kobo.302.1">Number </span><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.303.1">of indirect pointers = 1</span></li>
<li><span class="koboSpan" id="kobo.304.1">Number of double indirect pointers = 1</span></li>
<li><span class="koboSpan" id="kobo.305.1">Number </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.306.1">of triple indirect pointers = 1</span></li>
<li><span class="koboSpan" id="kobo.307.1">Size of </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.308.1">each pointer (direct or indirect) = </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">4 bytes</span></span></li>
<li><span class="koboSpan" id="kobo.310.1">Number of pointers per block = (block size) / (pointer size) = (4 KB / 4) = </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">1,024 pointers</span></span></li>
<li><span class="koboSpan" id="kobo.312.1">Maximum file size that can be referred by using direct pointers = 12 x 4 KB = </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">48 KB</span></span></li>
<li><span class="koboSpan" id="kobo.314.1">Maximum file size that can be referred by using 12 direct and 1 indirect pointer = [(12 x 4 KB) + (1,024 x 4 KB)] ≈ </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">4 MB</span></span></li>
<li><span class="koboSpan" id="kobo.316.1">Maximum file size that can be referred by using 12 direct, 1 indirect, and one double indirect pointer = [(12 x 4 KB) + (1,024 x 4 KB) + (1,024 x 1,024 x 4 KB)] ≈ </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">4 GB</span></span></li>
<li><span class="koboSpan" id="kobo.318.1">Maximum file size that can be referred by using 12 direct pointers, 1 single indirect, 1 double indirect, and 1 triple indirect pointer = (12 x 4 KB) + (1,024 x 4 KB) + (1,024 x 1,024 x 4 KB) + (1 x 1,024 x 1,024 x 1,024 x 4 KB) ≈ </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">4 TB</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.320.1">The following figure shows how the use of indirect pointers can help in addressing </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">larger files:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.322.1"><img alt="Figure 2.2 – Visual representation of an inode structure" src="image/B19430_02_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.323.1">Figure 2.2 – Visual representation of an inode structure</span></p>
<p><span class="koboSpan" id="kobo.324.1">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.325.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.326.1">.2</span></em><span class="koboSpan" id="kobo.327.1">, filesystems might use a single-level indirect block for smaller files, and then switch to a double-level indirect block for larger files. </span><span class="koboSpan" id="kobo.327.2">Using indirect inode pointers offers multiple </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.328.1">advantages. </span><span class="koboSpan" id="kobo.328.2">First, it eliminates the need for contiguous storage allocation to accommodate large files, thereby enabling the filesystem to handle such </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.329.1">files effectively. </span><span class="koboSpan" id="kobo.329.2">Second, it facilitates efficient space utilization since blocks can be allocated for a file on an as-needed basis rather than the upfront reservation of a significant amount of space. </span><span class="koboSpan" id="kobo.329.3">Each inode typically has 12 direct block pointers, 1 single indirect block pointer, 1 double indirect block pointer, and 1 triple indirect </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">block pointer.</span></span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.331.1">Can a filesystem run out of inodes?</span></h2>
<p><span class="koboSpan" id="kobo.332.1">When managing storage, keeping space available is a major concern. </span><span class="koboSpan" id="kobo.332.2">Running out of disk space is a common </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.333.1">scenario. </span><span class="koboSpan" id="kobo.333.2">An inode is assigned to every file and directory on the filesystem, but what if all inode numbers have been assigned? </span><span class="koboSpan" id="kobo.333.3">It’s highly unlikely, as filesystems usually have several millions of inodes available. </span><span class="koboSpan" id="kobo.333.4">But yes, it is possible for a filesystem to run out of inodes. </span><span class="koboSpan" id="kobo.333.5">And if it does, the amount of free space on the disk won’t be of any use as the filesystem won’t be able to create any new file. </span><span class="koboSpan" id="kobo.333.6">The number of inodes in a filesystem cannot be expanded once the filesystem has been created, so a backup will be the only option. </span><span class="koboSpan" id="kobo.333.7">You can check the inode usage of mounted filesystems using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">df</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.335.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.336.1">
df -Thi</span></pre>
<p><span class="koboSpan" id="kobo.337.1">This situation </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.338.1">is illustrated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.339.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.340.1">.3</span></em><span class="koboSpan" id="kobo.341.1">. </span><span class="koboSpan" id="kobo.341.2">The filesystem mounted on </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">/ford</span></strong><span class="koboSpan" id="kobo.343.1"> has close to 40% of free space, but since all the 6.3 million inodes have been exhausted, it is not possible to create any </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">new file:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.345.1"><img alt="Figure 2.3 – A filesystem can run out of inodes " src="image/B19430_02_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.346.1">Figure 2.3 – A filesystem can run out of inodes </span></p>
<p><span class="koboSpan" id="kobo.347.1">Let us wrap </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.348.1">up our discussion with a few key </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">inode pointers:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.350.1">In addition to metadata, inodes also save information about where a file is stored on the physical disk. </span><span class="koboSpan" id="kobo.350.2">In order to keep track of a file’s physical whereabouts, inodes use several direct and </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">indirect pointers.</span></span></li>
<li><span class="koboSpan" id="kobo.352.1">Inodes are stored in on-disk filesystem structures in an inode table. </span><span class="koboSpan" id="kobo.352.2">When a file needs to be opened, its corresponding inode is loaded </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">into memory.</span></span></li>
<li><span class="koboSpan" id="kobo.354.1">For filesystems that only generate their content in memory, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">procfs</span></strong><span class="koboSpan" id="kobo.356.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">sysfs</span></strong><span class="koboSpan" id="kobo.358.1">, their inodes are only present </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">in memory.</span></span></li>
<li><span class="koboSpan" id="kobo.360.1">While inodes store a lot of metadata about a file, they do not store the name of the file. </span><span class="koboSpan" id="kobo.360.2">So, two things that are not part of the inode structure are the file contents and </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">the filename.</span></span></li>
<li><span class="koboSpan" id="kobo.362.1">Inodes use 15 pointers to keep track of a file’s data blocks on a disk. </span><span class="koboSpan" id="kobo.362.2">The first 12 pointers are direct pointers and can only address a maximum file size of 48 KB. </span><span class="koboSpan" id="kobo.362.3">The remaining three pointers </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.363.1">provide a single, double, and triple level of indirection. </span><span class="koboSpan" id="kobo.363.2">Through the use of these indirect pointers, large files can </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">be addressed.</span></span></li>
<li><span class="koboSpan" id="kobo.365.1">If a filesystem runs out of inodes, no new file can be created on it. </span><span class="koboSpan" id="kobo.365.2">This is very rare, as a filesystem usually has a large number of inodes, amounting </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">to millions.</span></span></li>
</ul>
<h1 id="_idParaDest-38"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.367.1">Directory entries – mapping inodes to filenames</span></h1>
<p><span class="koboSpan" id="kobo.368.1">A directory acts as a catalog or a container for user files. </span><span class="koboSpan" id="kobo.368.2">The operations that are applicable to a directory are </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.369.1">different than regular files. </span><span class="koboSpan" id="kobo.369.2">There are different commands for working with directories. </span><span class="koboSpan" id="kobo.369.3">A file is always going to be </span><em class="italic"><span class="koboSpan" id="kobo.370.1">inside</span></em><span class="koboSpan" id="kobo.371.1"> a directory, and to access that file, you need to specify the absolute or relative path in terms of directories. </span><span class="koboSpan" id="kobo.371.2">But like most things in Linux, directories are also treated as files. </span><span class="koboSpan" id="kobo.371.3">So, how does this </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">all work?</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">Native Linux filesystems treat directories as files and store them like files. </span><span class="koboSpan" id="kobo.373.2">Like all regular files, a directory is also assigned an inode. </span><span class="koboSpan" id="kobo.373.3">There is one difference between the inode of a directory and a file. </span><span class="koboSpan" id="kobo.373.4">In the case of a directory, the </span><strong class="bold"><span class="koboSpan" id="kobo.374.1">type</span></strong><span class="koboSpan" id="kobo.375.1"> field in </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.376.1">an inode is a </span><strong class="bold"><span class="koboSpan" id="kobo.377.1">directory</span></strong><span class="koboSpan" id="kobo.378.1">. </span><span class="koboSpan" id="kobo.378.2">Remember, from our discussion about inodes, that an inode contains a lot of metadata about a file, but it doesn’t contain the name of the file. </span><span class="koboSpan" id="kobo.378.3">The filename is present in a directory. </span><span class="koboSpan" id="kobo.378.4">A directory can be thought of as a special file that contains a table. </span><span class="koboSpan" id="kobo.378.5">This table consists of filenames and their corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">inode numbers.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">When trying to access a file, a process has to traverse the hierarchical directory structure. </span><span class="koboSpan" id="kobo.380.2">Each level in that </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.381.1">structure defines a path that can either be absolute or relative. </span><strong class="bold"><span class="koboSpan" id="kobo.382.1">Absolute pathnames</span></strong><span class="koboSpan" id="kobo.383.1">, also called </span><strong class="bold"><span class="koboSpan" id="kobo.384.1">fully qualified pathnames</span></strong><span class="koboSpan" id="kobo.385.1">, begin with the root directory, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">/etc/ssh/sshd_config</span></strong><span class="koboSpan" id="kobo.387.1">. </span><span class="koboSpan" id="kobo.387.2">In contrast, </span><strong class="bold"><span class="koboSpan" id="kobo.388.1">relative pathnames</span></strong><span class="koboSpan" id="kobo.389.1"> start with the current working directory of the process or user, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">ssh/sshd_config</span></strong><span class="koboSpan" id="kobo.391.1">. </span><span class="koboSpan" id="kobo.391.2">There is no leading </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">/</span></strong><span class="koboSpan" id="kobo.393.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">relative pathnames.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.395.1">Fully qualified</span></em><span class="koboSpan" id="kobo.396.1">, </span><em class="italic"><span class="koboSpan" id="kobo.397.1">mapping of names to numbers</span></em><span class="koboSpan" id="kobo.398.1">, notice how this sounds a bit familiar to the concept of name resolution. </span><span class="koboSpan" id="kobo.398.2">While describing inodes, we used the analogy of the DNS, and we’ll use it here as well. </span><span class="koboSpan" id="kobo.398.3">Just as regular DNS records map website names to IP addresses, a directory maps all filenames to their corresponding inode numbers. </span><span class="koboSpan" id="kobo.398.4">This combination of filenames to </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.399.1">inodes is known as </span><strong class="bold"><span class="koboSpan" id="kobo.400.1">linking</span></strong><span class="koboSpan" id="kobo.401.1">. </span><span class="koboSpan" id="kobo.401.2">The concept of linking is explained toward the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">If you prefer a pop culture reference, think of the star maps in the </span><em class="italic"><span class="koboSpan" id="kobo.404.1">Star Wars</span></em><span class="koboSpan" id="kobo.405.1"> franchise. </span><span class="koboSpan" id="kobo.405.2">In order to travel to a specific planet, the characters consult the star map to find the right location. </span><span class="koboSpan" id="kobo.405.3">Think of the star map as a directory, and each planet as a file or a subdirectory. </span><span class="koboSpan" id="kobo.405.4">The map lists the exact location and coordinates of each planet, much like a directory that lists the inode number and location of </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">each file.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">This mapping comes in handy when performing lookup operations. </span><span class="koboSpan" id="kobo.407.2">Looking up pathnames is a directory-centric operation as files are always present inside a directory. </span><span class="koboSpan" id="kobo.407.3">For looking up pathnames, VFS uses directory entries, also known as </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">dentry objects</span></strong><span class="koboSpan" id="kobo.409.1">. </span><span class="koboSpan" id="kobo.409.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">dentry objects</span></strong><span class="koboSpan" id="kobo.411.1"> are responsible for depicting a directory in memory. </span><span class="koboSpan" id="kobo.411.2">When traversing a path, each component is considered a </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">dentry object</span></strong><span class="koboSpan" id="kobo.413.1">. </span><span class="koboSpan" id="kobo.413.2">If we take the example of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">/etc/hosts</span></strong><span class="koboSpan" id="kobo.415.1"> file, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">/etc</span></strong><span class="koboSpan" id="kobo.417.1"> directory and </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">hosts</span></strong><span class="koboSpan" id="kobo.419.1"> file are both considered </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">dentry objects</span></strong><span class="koboSpan" id="kobo.421.1"> and are mapped in memory. </span><span class="koboSpan" id="kobo.421.2">This helps in caching results of </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">lookup</span></strong><span class="koboSpan" id="kobo.423.1"> operations, which in turn speeds up the overall performance when looking </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">up pathnames.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">Consider the following </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.426.1">example: there is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">/cars</span></strong><span class="koboSpan" id="kobo.428.1"> directory in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">/</span></strong><span class="koboSpan" id="kobo.430.1"> partition, which contains three files: </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">McLaren</span></strong><span class="koboSpan" id="kobo.432.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">Porsche</span></strong><span class="koboSpan" id="kobo.434.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">Lamborghini</span></strong><span class="koboSpan" id="kobo.436.1">. </span><span class="koboSpan" id="kobo.436.2">The following steps provide an oversimplified version of events that take place when a process wants to access the McLaren file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">cars</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.439.1"> directory:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.440.1">The VFS will remodel the path as a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">dentry object</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.443.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">dentry object</span></strong><span class="koboSpan" id="kobo.445.1"> will be created for each component in the pathname. </span><span class="koboSpan" id="kobo.445.2">The VFS will follow each directory entry for path resolution. </span><span class="koboSpan" id="kobo.445.3">For looking up </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">/cars/McLaren</span></strong><span class="koboSpan" id="kobo.447.1">, separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">dentry objects</span></strong><span class="koboSpan" id="kobo.449.1"> will be created for </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">/</span></strong><span class="koboSpan" id="kobo.451.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">cars</span></strong><span class="koboSpan" id="kobo.453.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">McLaren</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.457.1">As our process has specified the absolute path, the VFS will start with the first component in the pathname, that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">/</span></strong><span class="koboSpan" id="kobo.459.1">, and then proceed to the </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">child objects.</span></span></li>
<li><span class="koboSpan" id="kobo.461.1">The VFS will check the relevant permissions on the inode to see whether the calling process has the </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">required privileges.</span></span></li>
<li><span class="koboSpan" id="kobo.463.1">The VFS also calculates a hash value for </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">dentry objects</span></strong><span class="koboSpan" id="kobo.465.1"> and compares it to the values in the </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">hash table.</span></span></li>
<li><span class="koboSpan" id="kobo.467.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">/</span></strong><span class="koboSpan" id="kobo.469.1"> directory contains the mapping of files and subdirectories to their respective inode numbers. </span><span class="koboSpan" id="kobo.469.2">Once the inode of </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">/cars</span></strong><span class="koboSpan" id="kobo.471.1"> has been retrieved, the kernel can use the block pointers to view the on-disk contents of </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">the directory.</span></span></li>
<li><span class="koboSpan" id="kobo.473.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">/cars</span></strong><span class="koboSpan" id="kobo.475.1"> directory will contain the mapping of the three files (</span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">McLaren</span></strong><span class="koboSpan" id="kobo.477.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">Porsche</span></strong><span class="koboSpan" id="kobo.479.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">Lamborghini</span></strong><span class="koboSpan" id="kobo.481.1">) to their inode numbers. </span><span class="koboSpan" id="kobo.481.2">From here, we can use the inode of </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">McLaren</span></strong><span class="koboSpan" id="kobo.483.1">, which will point us to the on-disk data blocks that contain the </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">file data.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.485.1">It’s important to know that the representation of a directory through </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">dentry objects</span></strong><span class="koboSpan" id="kobo.487.1"> only exists in memory. </span><span class="koboSpan" id="kobo.487.2">They’re not stored on disk. </span><span class="koboSpan" id="kobo.487.3">These objects are created by VFS on </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">the fly:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.489.1"><img alt="Figure 2.4 – The exchange between directories and inodes" src="image/B19430_02_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.490.1">Figure 2.4 – The exchange between directories and inodes</span></p>
<p><span class="koboSpan" id="kobo.491.1">The eagle-eyed reader </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.492.1">might be wondering, how did we know the inode of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">/</span></strong><span class="koboSpan" id="kobo.494.1"> directory? </span><span class="koboSpan" id="kobo.494.2">Most filesystems start assigning inode values from </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">2</span></strong><span class="koboSpan" id="kobo.496.1">. </span><span class="koboSpan" id="kobo.496.2">The inode number </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">0</span></strong><span class="koboSpan" id="kobo.498.1"> is not used. </span><span class="koboSpan" id="kobo.498.2">Inode number </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">1</span></strong><span class="koboSpan" id="kobo.500.1"> is used to keep track of bad and defective blocks on the physical disk. </span><span class="koboSpan" id="kobo.500.2">So, inode allocation in filesystems starts from </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">2</span></strong><span class="koboSpan" id="kobo.502.1">, and the root directory of a filesystem is always assigned inode </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">number </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">.</span></span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.506.1">Dentry cache</span></h2>
<p><span class="koboSpan" id="kobo.507.1">In terms </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.508.1">of performance, pathname traversals and directory lookups </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.509.1">can be expensive operations, especially if there are multiple recursive paths that need to be resolved. </span><span class="koboSpan" id="kobo.509.2">Once a path has been resolved, and a process wants to access the same path once again, the VFS will have to perform the entire operation again, which is excessive. </span><span class="koboSpan" id="kobo.509.3">There’s also a dependency on the underlying storage media: how quickly it can retrieve the required information. </span><span class="koboSpan" id="kobo.509.4">This puts brakes on </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">the operation.</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">We’re once again </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.512.1">going to use our go-to analogy here, the DNS. </span><span class="koboSpan" id="kobo.512.2">When a DNS client performs the same DNS query, the client’s local DNS server caches the results of the query. </span><span class="koboSpan" id="kobo.512.3">This is done so that for any identical request, the DNS server wouldn’t have to travel across the entire hierarchy of DNS servers. </span><span class="koboSpan" id="kobo.512.4">On similar lines, to speed up the lookup process of pathnames, the k</span><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.513.1">ernel uses the </span><strong class="bold"><span class="koboSpan" id="kobo.514.1">directory entry cache</span></strong><span class="koboSpan" id="kobo.515.1">. </span><span class="koboSpan" id="kobo.515.2">Frequently accessed pathnames are kept in the memory to accelerate the lookup process. </span><span class="koboSpan" id="kobo.515.3">This saves a lot of unnecessary I/O requests to the underlying filesystem. </span><span class="koboSpan" id="kobo.515.4">The dentry cache plays a pivotal role in the filename </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">lookup operation.</span></span></p>
<p><span class="koboSpan" id="kobo.517.1">A directory maps </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.518.1">filenames to inodes. </span><span class="koboSpan" id="kobo.518.2">You have to ask: if the dentry </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.519.1">object is creating an in-memory representation of directories and results of lookup operations are being cached, that means corresponding inodes are also being cached? </span><span class="koboSpan" id="kobo.519.2">The answer is in the affirmative. </span><span class="koboSpan" id="kobo.519.3">There’s no point in caching one without the other. </span><span class="koboSpan" id="kobo.519.4">If a directory entry is cached, the corresponding inode is also cached. </span><span class="koboSpan" id="kobo.519.5">The dentry objects pin corresponding inodes in memory, and they remain in memory as long as the </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">dentry objects.</span></span></p>
<p><span class="koboSpan" id="kobo.521.1">Dentry objects are defined in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">include/linux/dcache.h</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.523.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.524.1">
struct dentry {
        unsigned int d_flags;           /* protected by d_lock */
        seqcount_spinlock_t d_seq;      /* per dentry seqlock */
        struct hlist_bl_node d_hash;    /* lookup hash list */
        struct dentry *d_parent;        /* parent directory */
        struct qstr d_name;
        struct inode *d_inode;          /* Where the name belongs to – NU
[…………..]</span></pre>
<p><span class="koboSpan" id="kobo.525.1">Some commonly used terms are </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">described here:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">d_name</span></strong><span class="koboSpan" id="kobo.528.1">: This field contains a pointer to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">struct qstr</span></strong><span class="koboSpan" id="kobo.530.1"> object, which represents the name of the file or directory. </span><span class="koboSpan" id="kobo.530.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">qstr</span></strong><span class="koboSpan" id="kobo.532.1"> object is a structure used by the kernel to represent a string or sequence </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">of characters.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">d_parent</span></strong><span class="koboSpan" id="kobo.535.1">: This field contains a pointer to the parent directory of the file or directory associated with the </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">directory entry.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">d_inode</span></strong><span class="koboSpan" id="kobo.538.1">: This field is a pointer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">struct inode</span></strong><span class="koboSpan" id="kobo.540.1"> object of the file </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">or directory.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">d_lock</span></strong><span class="koboSpan" id="kobo.543.1">: This field contains a spinlock used to protect access to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">struct dentry</span></strong><span class="koboSpan" id="kobo.545.1"> object. </span><span class="koboSpan" id="kobo.545.2">It is quite common that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">dentry</span></strong><span class="koboSpan" id="kobo.547.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">inode</span></strong><span class="koboSpan" id="kobo.549.1"> objects are shared among multiple processes that open the same file or directory. </span><span class="koboSpan" id="kobo.549.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">d_lock</span></strong><span class="koboSpan" id="kobo.551.1"> field protects these objects from concurrent modifications that could lead to inconsistent or corrupt </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">filesystem data.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">d_op</span></strong><span class="koboSpan" id="kobo.554.1">: This field contains a pointer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">struct dentry_operations</span></strong><span class="koboSpan" id="kobo.556.1"> structure, which contains a set of function pointers that define the operations that can be performed on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">dentry</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.558.1"> object.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">d_sb</span></strong><span class="koboSpan" id="kobo.560.1">: This is a pointer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">struct super_block</span></strong><span class="koboSpan" id="kobo.562.1"> structure, which defines the superblock of the filesystem that the directory entry </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">belongs to.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.564.1">The cache is </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.565.1">represented in memory using a hash table. </span><span class="koboSpan" id="kobo.565.2">Each entry in the hash table structure points to a list of directory cache entries, having the same hash value. </span><span class="koboSpan" id="kobo.565.3">When a process </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.566.1">attempts to access a file or a directory, the kernel searches the dentry cache for the corresponding directory entry, using the file or directory name as a key. </span><span class="koboSpan" id="kobo.566.2">If the entry is found in the cache, it is returned to the calling process. </span><span class="koboSpan" id="kobo.566.3">If the entry is not found, the kernel must go to disk and perform an I/O operation to read the directory entry from </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">the filesystem.</span></span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.568.1">Dentry states</span></h2>
<p><span class="koboSpan" id="kobo.569.1">Dentry </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.570.1">objects </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.571.1">tend to be in one of the following </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">three states:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.573.1">Used</span></strong><span class="koboSpan" id="kobo.574.1">: A used dentry indicates a dentry object that is currently being used by the VFS and shows that there is a valid inode structure associated with it. </span><span class="koboSpan" id="kobo.574.2">This means that a process is actively using </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">this entry.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.576.1">Unused</span></strong><span class="koboSpan" id="kobo.577.1">: An unused entry also has a valid inode associated with it, but it is not being used by the VFS. </span><span class="koboSpan" id="kobo.577.2">If a pathname lookup operation (related to this entry) is performed again, that operation can be completed using this cached entry. </span><span class="koboSpan" id="kobo.577.3">If a need arises to reclaim memory, then this entry can be </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">disposed of.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.579.1">Negative</span></strong><span class="koboSpan" id="kobo.580.1">: A negative state is a bit unique in that it is a representation of a lookup operation that failed. </span><span class="koboSpan" id="kobo.580.2">For instance, if the file to be accessed has already been deleted or if the pathname </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.581.1">doesn’t exist to begin with, a typical </span><strong class="bold"><span class="koboSpan" id="kobo.582.1">No such file or directory</span></strong><span class="koboSpan" id="kobo.583.1"> message </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.584.1">is returned to the calling process. </span><span class="koboSpan" id="kobo.584.2">As a result of this failed lookup, the VFS will create a negative dentry. </span><span class="koboSpan" id="kobo.584.3">Too many failed lookup operations can create unnecessary negative dentries and can adversely </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">affect performance.</span></span></li>
</ul>
<h2 id="_idParaDest-41"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.586.1">Dentry operations</span></h2>
<p><span class="koboSpan" id="kobo.587.1">The various </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.588.1">filesystem-related operations that can be performed on </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.589.1">dentry objects are defined in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">dentry_operations</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.591.1"> structure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.592.1">
struct dentry_operations {
        int (*d_revalidate)(struct dentry *, unsigned int);
        int (*d_weak_revalidate)(struct dentry *, unsigned int);
        int (*d_hash)(const struct dentry *, struct qstr *);
        int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *);
        int (*d_delete)(const struct dentry *);
        int (*d_init)(struct dentry *);
        void (*d_release)(struct dentry *);
        void (*d_prune)(struct dentry *);
        [……………………….]</span></pre>
<p><span class="koboSpan" id="kobo.593.1">A few important operations are described </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">d_revalidate</span></strong><span class="koboSpan" id="kobo.596.1">: It can often happen that the dentry objects in the cache can become out of sync with the on-disk data. </span><span class="koboSpan" id="kobo.596.2">This is often true in the case of network filesystems. </span><span class="koboSpan" id="kobo.596.3">The kernel is dependent on the network to gather information about the on-disk structures. </span><span class="koboSpan" id="kobo.596.4">In such cases, VFS uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">d_revalidate</span></strong><span class="koboSpan" id="kobo.598.1"> operation to revalidate </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">a dentry.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">d_weak_revalidate</span></strong><span class="koboSpan" id="kobo.601.1">: When a path lookup operation ends at a dentry that was not obtained after a lookup in the parent directory, VFS calls the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">d_weak_revalidate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.603.1"> operation.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">d_hash</span></strong><span class="koboSpan" id="kobo.605.1">: This is used </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.606.1">to calculate the hash value of a dentry. </span><span class="koboSpan" id="kobo.606.2">It takes a </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.607.1">dentry as input and returns a hash value, which is used to look up the dentry in the directory cache. </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">d_compare</span></strong><span class="koboSpan" id="kobo.609.1">: This is used to compare the filenames of two dentries. </span><span class="koboSpan" id="kobo.609.2">It takes two dentries as arguments and returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">true</span></strong><span class="koboSpan" id="kobo.611.1"> if they refer to the same file or directory, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">false</span></strong><span class="koboSpan" id="kobo.613.1"> if they </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">are different.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">d_init</span></strong><span class="koboSpan" id="kobo.616.1">: This is called when initializing a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">dentry object</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">d_release</span></strong><span class="koboSpan" id="kobo.620.1">: This is called when a dentry has to be deallocated. </span><span class="koboSpan" id="kobo.620.2">It frees the memory used by the dentry and any associated resources, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">cached data.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">d_iput</span></strong><span class="koboSpan" id="kobo.623.1">: This is invoked when a dentry object loses its inode. </span><span class="koboSpan" id="kobo.623.2">This is called just </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">before </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">d_release</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">d_dname</span></strong><span class="koboSpan" id="kobo.628.1">: This is used for generating pathnames for pseudo filesystems, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">procfs</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.630.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">sysfs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.633.1">Let us summarize our discussion about </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">directory entries:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.635.1">Linux treats directories as files. </span><span class="koboSpan" id="kobo.635.2">Directories also have an inode assigned to them. </span><span class="koboSpan" id="kobo.635.3">The name of a file is stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">the directory.</span></span></li>
<li><span class="koboSpan" id="kobo.637.1">The difference between the inode of a file and a directory lies in the contents of their corresponding disk blocks. </span><span class="koboSpan" id="kobo.637.2">The on-disk data of a directory contains a mapping of filenames and their </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">inode numbers.</span></span></li>
<li><span class="koboSpan" id="kobo.639.1">Directories are represented in memory through dentry objects. </span><span class="koboSpan" id="kobo.639.2">The dentry objects are created by VFS in memory and are not stored on the </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">physical disk.</span></span></li>
<li><span class="koboSpan" id="kobo.641.1">To optimize lookup operations, a dentry cache is used. </span><span class="koboSpan" id="kobo.641.2">The dentry cache keeps the recently accessed pathnames and their inodes </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">in memory.</span></span></li>
</ul>
<h1 id="_idParaDest-42"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.643.1">File objects – representing open files</span></h1>
<p><span class="koboSpan" id="kobo.644.1">Similar to dentry objects, </span><strong class="bold"><span class="koboSpan" id="kobo.645.1">file objects</span></strong><span class="koboSpan" id="kobo.646.1"> are an in-memory representation of open files. </span><span class="koboSpan" id="kobo.646.2">The file object represents </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.647.1">a process’s view of an open file. </span><span class="koboSpan" id="kobo.647.2">Like dentry objects, file objects also do not correspond to any on-disk structures. </span><span class="koboSpan" id="kobo.647.3">When we covered system calls in </span><a href="B19430_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.648.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.649.1">, it was mentioned that the user-space programs interact with VFS through the system call interface. </span><span class="koboSpan" id="kobo.649.2">These system calls are generic functions for performing common operations such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">read</span></strong><span class="koboSpan" id="kobo.651.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">write</span></strong><span class="koboSpan" id="kobo.653.1">. </span><span class="koboSpan" id="kobo.653.2">The idea behind all this is to ensure that user-space programs don’t have to worry about filesystems and their </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">data structures.</span></span></p>
<p><span class="koboSpan" id="kobo.655.1">When applications generate a system call to access a file, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">open ()</span></strong><span class="koboSpan" id="kobo.657.1">, a file object gets created in memory. </span><span class="koboSpan" id="kobo.657.2">Similarly, when the application no longer needs access to the file and decides to close it using </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">close ()</span></strong><span class="koboSpan" id="kobo.659.1">, the file object is discarded. </span><span class="koboSpan" id="kobo.659.2">It’s important to note that VFS can create multiple file objects for a particular file. </span><span class="koboSpan" id="kobo.659.3">This is because access to a particular file is not limited to a single process; a file can be opened concurrently by multiple processes. </span><span class="koboSpan" id="kobo.659.4">Because of this, the file object is used privately by </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">every process.</span></span></p>
<p><span class="koboSpan" id="kobo.661.1">The following are some of the differences in the way an inode and a file object are used by </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">the kernel:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.663.1">File objects along with inodes are used when a process needs to access </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">a file.</span></span></li>
<li><span class="koboSpan" id="kobo.665.1">To access the inode of the file, the process would need a file object pointing to the file inode. </span><span class="koboSpan" id="kobo.665.2">File objects belong to a single process, whereas an inode can be used by </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">multiple processes.</span></span></li>
<li><span class="koboSpan" id="kobo.667.1">A file object is created whenever a file is to be opened. </span><span class="koboSpan" id="kobo.667.2">When another process wants to access the same file, a new file object, private to that process, will be created. </span><span class="koboSpan" id="kobo.667.3">Hence, we can say that a file object exists for every instance of an open file. </span><span class="koboSpan" id="kobo.667.4">But every file will always have a </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">single inode.</span></span></li>
<li><span class="koboSpan" id="kobo.669.1">When a process closes the file, its corresponding file object is destroyed, but its inode might still be kept in </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">the cache.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.671.1">There can be some </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.672.1">confusion between file objects and another similar entity that is used for accessing files, the </span><strong class="bold"><span class="koboSpan" id="kobo.673.1">file descriptor</span></strong><span class="koboSpan" id="kobo.674.1">. </span><span class="koboSpan" id="kobo.674.2">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">open ()</span></strong><span class="koboSpan" id="kobo.676.1"> system call by a process often returns a file descriptor, which is used by the process for accessing a file. </span><span class="koboSpan" id="kobo.676.2">In a way, a file descriptor also illustrates the relationship between a process and a file. </span><span class="koboSpan" id="kobo.676.3">So, what is the difference? </span><span class="koboSpan" id="kobo.676.4">To play with words, a file object provides an </span><strong class="bold"><span class="koboSpan" id="kobo.677.1">open file description</span></strong><span class="koboSpan" id="kobo.678.1">. </span><span class="koboSpan" id="kobo.678.2">A file object will contain all </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.679.1">data related to a file descriptor. </span><span class="koboSpan" id="kobo.679.2">File descriptors are user-space references to kernel objects. </span><span class="koboSpan" id="kobo.679.3">A file object will contain information such as a file pointer representing the current position in the file and how the file </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">was opened:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.681.1"><img alt="Figure 2.5 – A file object is created as a result of open ()" src="image/B19430_02_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.682.1">Figure 2.5 – A file object is created as a result of open ()</span></p>
<p><span class="koboSpan" id="kobo.683.1">The definition for </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.684.1">a file object is present in </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">include/linux/fs.h</span></strong><span class="koboSpan" id="kobo.686.1">. </span><span class="koboSpan" id="kobo.686.2">This structure stores information about the relationship of the process to the open file. </span><span class="koboSpan" id="kobo.686.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">f_inode</span></strong><span class="koboSpan" id="kobo.688.1"> pointer points to the inode of </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.690.1">
struct file {
        union {
                struct llist_node       fu_llist;
                struct rcu_head         fu_rcuhead;
        } f_u;
        struct path             f_path;
        struct inode            *f_inode;       /* cached value */
        const struct file_operations    *f_op;
[……..]</span></pre>
<p><span class="koboSpan" id="kobo.691.1">Some important </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.692.1">fields are </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">described here:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">f_path</span></strong><span class="koboSpan" id="kobo.695.1">: This field represents the directory path of the file associated with the open file. </span><span class="koboSpan" id="kobo.695.2">When a file is opened, the VFS creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">struct file</span></strong><span class="koboSpan" id="kobo.697.1"> object and initializes its </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">f_path</span></strong><span class="koboSpan" id="kobo.699.1"> field to point to the directory path of </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">the file.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">f_inode</span></strong><span class="koboSpan" id="kobo.702.1">: This is a pointer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">struct inode</span></strong><span class="koboSpan" id="kobo.704.1"> object that represents the file associated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">struct </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">file</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.707.1"> object.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">f_op</span></strong><span class="koboSpan" id="kobo.709.1">: This is a pointer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">struct file_operations</span></strong><span class="koboSpan" id="kobo.711.1"> object that contains a set of function pointers for file operations on the </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">associated file.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">f_lock</span></strong><span class="koboSpan" id="kobo.714.1">: This field is used to ensure synchronization between different threads that are accessing the same </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">file object.</span></span></li>
</ul>
<h2 id="_idParaDest-43"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.716.1">Defining file operations</span></h2>
<p><span class="koboSpan" id="kobo.717.1">Like other structures, the filesystem methods applicable to file objects are defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">file_operations</span></strong><span class="koboSpan" id="kobo.719.1"> table. </span><span class="koboSpan" id="kobo.719.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">f_op</span></strong><span class="koboSpan" id="kobo.721.1"> pointer is pointing to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">file_operations</span></strong><span class="koboSpan" id="kobo.723.1"> table. </span><span class="koboSpan" id="kobo.723.2">The VFS implements </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.724.1">a common interface for all filesystems that hooks up </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.725.1">with the actual mechanisms of the </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">underlying filesystems:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.727.1">
struct file_operations {
        struct module *owner;
        loff_t (*llseek) (struct file *, loff_t, int);
        ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
        ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
        ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
        ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
        int (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *, unsigned int flags);
        int (*iterate) (struct file *, struct dir_context *);
        int (*iterate_shared) (struct file *, struct dir_context *);
        __poll_t (*poll) (struct file *, struct poll_table_struct *);
        long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
        long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
        int (*mmap) (struct file *, struct vm_area_struct *);
[………………]</span></pre>
<p><span class="koboSpan" id="kobo.728.1">The operations </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.729.1">defined here look a lot similar to the generic system </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.730.1">calls we described in </span><a href="B19430_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.731.1">Chapter 1</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.732.1">:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">llseek</span></strong><span class="koboSpan" id="kobo.734.1">: This is called when the VFS needs to move the file </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">position index</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">read</span></strong><span class="koboSpan" id="kobo.737.1">: This is called by </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">read()</span></strong><span class="koboSpan" id="kobo.739.1"> and related </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">system calls</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">open</span></strong><span class="koboSpan" id="kobo.742.1">: This is called when a file (inode) needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">be opened</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">write</span></strong><span class="koboSpan" id="kobo.745.1">: This is called by </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">write()</span></strong><span class="koboSpan" id="kobo.747.1"> and related </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">system calls</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">release</span></strong><span class="koboSpan" id="kobo.750.1">: This is called when an open file is </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">being closed</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">map</span></strong><span class="koboSpan" id="kobo.753.1">: This is called when a process wants to map a file in memory using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">mmap()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.755.1">system call</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.756.1">These are generic operations. </span><span class="koboSpan" id="kobo.756.2">Not all of them can be applied to a single file. </span><span class="koboSpan" id="kobo.756.3">At the end of the day, it’s up to the individual filesystem to pick and choose from this set of operations. </span><span class="koboSpan" id="kobo.756.4">If a particular method is not applicable to a filesystem, that can be simply set </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">NULL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">.</span></span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.760.1">Can a process run out of file descriptors?</span></h2>
<p><span class="koboSpan" id="kobo.761.1">The kernel enforces limits for the maximum number of processes that can be opened at a time. </span><span class="koboSpan" id="kobo.761.2">These limits can </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.762.1">be applied at the user, group, or global system level. </span><span class="koboSpan" id="kobo.762.2">If all the file descriptors have been allocated, the process won’t be able to open any more files. </span><span class="koboSpan" id="kobo.762.3">Many large applications require a lot more than the default number of descriptors allowed for a process. </span><span class="koboSpan" id="kobo.762.4">In such cases, the limits for individual users can be set in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">/etc/security/limits.conf</span></strong><span class="koboSpan" id="kobo.764.1"> file. </span><span class="koboSpan" id="kobo.764.2">For system-wide settings, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">sysctl</span></strong><span class="koboSpan" id="kobo.766.1"> command can </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">be used:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.768.1"><img alt="Figure 2.6 – Too many open files spoil the application" src="image/B19430_02_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.769.1">Figure 2.6 – Too many open files spoil the application</span></p>
<p><span class="koboSpan" id="kobo.770.1">Let’s summarize our discussion before we reach our open </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">file limit:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.772.1">A file object is an in-memory representation of an open file and does not have any corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">on-disk image.</span></span></li>
<li><span class="koboSpan" id="kobo.774.1">A file object is created in response to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">open()</span></strong><span class="koboSpan" id="kobo.776.1"> system call by </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">a process.</span></span></li>
<li><span class="koboSpan" id="kobo.778.1">A file object is private for a process. </span><span class="koboSpan" id="kobo.778.2">As more than one process can access a particular file, the VFS will create multiple file objects for a </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">particular file.</span></span></li>
</ul>
<h1 id="_idParaDest-45"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.780.1">Superblocks – describing filesystem metadata</span></h1>
<p><span class="koboSpan" id="kobo.781.1">If you’ve ever created a filesystem by running </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">mkfs</span></strong><span class="koboSpan" id="kobo.783.1"> on a block device, chances are you must have seen the term </span><strong class="bold"><span class="koboSpan" id="kobo.784.1">superblock</span></strong><span class="koboSpan" id="kobo.785.1"> in the output. </span><span class="koboSpan" id="kobo.785.2">Superblock is one of the more familiar structures to </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.786.1">the casual Linux user. </span><span class="koboSpan" id="kobo.786.2">You might have noticed that the structures used in VFS bear a close resemblance to each other. </span><span class="koboSpan" id="kobo.786.3">Dentry and file objects store in-memory representations of directories and open files, respectively. </span><span class="koboSpan" id="kobo.786.4">Both structures do not have an on-disk image and only exist in memory. </span><span class="koboSpan" id="kobo.786.5">On a similar note, the superblock structure has a lot in common with inodes. </span><span class="koboSpan" id="kobo.786.6">Inodes store metadata about files, whereas superblocks store metadata </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">about filesystems.</span></span></p>
<p><span class="koboSpan" id="kobo.788.1">Consider the example of a library catalog system that keeps track of the books, including their titles, authors, and locations on the shelves. </span><span class="koboSpan" id="kobo.788.2">If the catalog system is lost or damaged, it can be difficult to find and retrieve specific books in the library. </span><span class="koboSpan" id="kobo.788.3">Similarly, if the superblock structure in the kernel is corrupted or damaged, it can lead to data loss or </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">filesystem errors.</span></span></p>
<p><span class="koboSpan" id="kobo.790.1">Just as every file has an inode number assigned to it, every filesystem has a corresponding superblock structure. </span><span class="koboSpan" id="kobo.790.2">Like inodes, a superblock also has an on-disk image. </span><span class="koboSpan" id="kobo.790.3">For filesystems that generate their content on the fly, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">procfs</span></strong><span class="koboSpan" id="kobo.792.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">sysfs</span></strong><span class="koboSpan" id="kobo.794.1">, their superblock structures are stored in memory only. </span><span class="koboSpan" id="kobo.794.2">When a filesystem is to be mounted, the superblock is the first structure that is read. </span><span class="koboSpan" id="kobo.794.3">Similarly, when the filesystem has been mounted, the information regarding the mounted filesystem is stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">the superblock.</span></span></p>
<p><span class="koboSpan" id="kobo.796.1">The superblock of a filesystem contains intricate information about the filesystem, such as the total number of blocks, number of used, unused, and free blocks, filesystem state and type, inodes, and a lot more. </span><span class="koboSpan" id="kobo.796.2">As changes are made to the filesystem, the information stored in the superblock is updated. </span><span class="koboSpan" id="kobo.796.3">Since the superblock is read while mounting a filesystem, we have to ask what would happen if the information stored in the superblock gets erased or corrupted. </span><span class="koboSpan" id="kobo.796.4">To put it simply, a filesystem </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.797.1">cannot be mounted without a superblock. </span><span class="koboSpan" id="kobo.797.2">Given its critical nature, several copies of the superblock are saved in multiple disk locations. </span><span class="koboSpan" id="kobo.797.3">In the case that the primary superblock is corrupted, a filesystem can be mounted using any of the </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">backup superblocks.</span></span></p>
<p><span class="koboSpan" id="kobo.799.1">The superblock structure is defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">include/linux/fs.h</span></strong><span class="koboSpan" id="kobo.801.1">. </span><span class="koboSpan" id="kobo.801.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">s_list</span></strong><span class="koboSpan" id="kobo.803.1"> contains pointers to mounted superblocks and </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">s_dev</span></strong><span class="koboSpan" id="kobo.805.1"> identifies the device. </span><span class="koboSpan" id="kobo.805.2">The superblock operations are defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">super_operations</span></strong><span class="koboSpan" id="kobo.807.1"> table, pointed at by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">s_op</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.809.1"> pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.810.1">
struct super_block {
        struct list_head        s_list;         /* Keep this first */
        dev_t                   s_dev;          /* search index; _not_ kdev_t */
        unsigned char           s_blocksize_bits;
        unsigned long           s_blocksize;
        loff_t                  s_maxbytes;     /* Max file size */
        struct file_system_type *s_type;
        const struct super_operations   *s_op;
        const struct dquot_operations   *dq_op;
        const struct quotactl_ops       *s_qcop;
        const struct export_operations *s_export_op;
[…………………………] </span></pre>
<p><span class="koboSpan" id="kobo.811.1">Some important fields </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.812.1">of the superblock structure are explained </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">s_list</span></strong><span class="koboSpan" id="kobo.815.1">: This field is used to maintain the list of all the currently </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">mounted filesystems.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">s_dev</span></strong><span class="koboSpan" id="kobo.818.1">: This field specifies the device number that corresponds to the filesystem’s root directory inode. </span><span class="koboSpan" id="kobo.818.2">This is used to identify the device on which the </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">filesystem resides.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">s_type</span></strong><span class="koboSpan" id="kobo.821.1">: This field points to the definition of the specific filesystem that is used to interpret the data stored on the filesystem. </span><span class="koboSpan" id="kobo.821.2">For instance, if this points to the XFS filesystem, the kernel knows that it needs to use XFS-specific functions to interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">the filesystem.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">s_root</span></strong><span class="koboSpan" id="kobo.824.1">: This field is used by the kernel to locate the root directory of the filesystem when it is mounted. </span><span class="koboSpan" id="kobo.824.2">Once the root directory has been identified, the directory tree can be traversed to access the other files and directories in </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">the filesystem.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">s_magic</span></strong><span class="koboSpan" id="kobo.827.1">: This field is used to identify the filesystem type on a particular device </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">or partition.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.829.1">Again, there are a considerable number of fields, so it’s not possible to explain all of them. </span><span class="koboSpan" id="kobo.829.2">Some fields are simple integers, while others have far more complex data structures and </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">function pointers.</span></span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.831.1">Superblock operations in the kernel</span></h2>
<p><span class="koboSpan" id="kobo.832.1">As with all VFS structures, all the superblock operations in </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">include/linux/fs.h</span></strong><span class="koboSpan" id="kobo.834.1"> are not mandatory for a filesystem. </span><span class="koboSpan" id="kobo.834.2">The kernel keeps a copy of the filesystem superblock in the memory. </span><span class="koboSpan" id="kobo.834.3">When changes </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.835.1">are made in the filesystem, the information in the superblock is updated in memory. </span><span class="koboSpan" id="kobo.835.2">The superblock copy in memory is thus marked </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">dirty</span></strong><span class="koboSpan" id="kobo.837.1"> as the kernel needs to update the on-disk superblock with the </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">updated information:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.839.1">
struct super_operations {
        struct inode *(*alloc_inode)(struct super_block *sb);
        void (*destroy_inode)(struct inode *);
        void (*free_inode)(struct inode *);
        void (*dirty_inode) (struct inode *, int flags);
        int (*write_inode) (struct inode *, struct writeback_control *wbc);
        int (*drop_inode) (struct inode *);
        void (*evict_inode) (struct inode *);
        void (*put_super) (struct super_block *);
        int (*sync_fs)(struct super_block *sb, int wait);
        int (*freeze_super) (struct super_block *);
[………………………..]</span></pre>
<p><span class="koboSpan" id="kobo.840.1">Some important </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.841.1">methods are defined </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">alloc_inode</span></strong><span class="koboSpan" id="kobo.844.1">: This method is called to initialize and allocate memory for </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">struct inode</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">destroy_inode</span></strong><span class="koboSpan" id="kobo.847.1">: This method is called by </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">destroy_inode()</span></strong><span class="koboSpan" id="kobo.849.1"> to release resources allocated for </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">struct inode</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">dirty_inode</span></strong><span class="koboSpan" id="kobo.852.1">: This method is called by the VFS to mark an inode </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">dirty</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">write_inode</span></strong><span class="koboSpan" id="kobo.856.1">: This method is called when the VFS needs to write an inode </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">to disk</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">delete_inode</span></strong><span class="koboSpan" id="kobo.859.1">: This is called when the VFS wants to delete </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">an inode</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">sync_fs</span></strong><span class="koboSpan" id="kobo.862.1">: This is called when VFS is writing out all </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">dirty</span></strong><span class="koboSpan" id="kobo.864.1"> data associated with </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">a superblock</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">statfs</span></strong><span class="koboSpan" id="kobo.867.1">: This is called when the VFS needs to get filesystem statistics, such as its size, free space, and number </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">of inodes</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">umount_begin</span></strong><span class="koboSpan" id="kobo.870.1">: This is called when the VFS is unmounting </span><span class="No-Break"><span class="koboSpan" id="kobo.871.1">a filesystem</span></span></li>
</ul>
<p><span class="No-Break"><span class="koboSpan" id="kobo.872.1">Let’s summarize:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.873.1">The superblock structure records all </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">filesystem characteristics.</span></span></li>
<li><span class="koboSpan" id="kobo.875.1">The superblock structure is read when mounting and unmounting a filesystem. </span><span class="koboSpan" id="kobo.875.2">Filesystems maintain copies of superblocks in multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">disk locations.</span></span></li>
</ul>
<h2 id="_idParaDest-47"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.877.1">Linking</span></h2>
<p><span class="koboSpan" id="kobo.878.1">In our discussion </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.879.1">regarding directory entries, we mentioned the </span><strong class="bold"><span class="koboSpan" id="kobo.880.1">linking</span></strong><span class="koboSpan" id="kobo.881.1"> operation. </span><span class="koboSpan" id="kobo.881.2">Links </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.882.1">are of two types: symbolic (or soft) links and hard links, as most users would know. </span><span class="koboSpan" id="kobo.882.2">Symbolic (soft) links behave as shortcuts, although there are subtle differences. </span><strong class="bold"><span class="koboSpan" id="kobo.883.1">Soft links</span></strong><span class="koboSpan" id="kobo.884.1"> point to </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.885.1">the path that contains the data, while </span><strong class="bold"><span class="koboSpan" id="kobo.886.1">hard links</span></strong><span class="koboSpan" id="kobo.887.1"> refer </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.888.1">to the </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">data itself.</span></span></p>
<p><span class="koboSpan" id="kobo.890.1">Going back a bit, the inode doesn’t contain the name of the file. </span><span class="koboSpan" id="kobo.890.2">The name of the file is contained within the directory. </span><span class="koboSpan" id="kobo.890.3">That means there can be multiple filenames in a directory list, all of which point to the same inode. </span><span class="koboSpan" id="kobo.890.4">Hard links use this logic. </span><span class="koboSpan" id="kobo.890.5">A hard link points to the inode of the file. </span><span class="koboSpan" id="kobo.890.6">This means that the link and file are indistinguishable as both are pointing to the same inode. </span><span class="koboSpan" id="kobo.890.7">After a while, you might not even know which was the </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">original file:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.892.1"><img alt="Figure 2.7 – It’s impossible to tell which is the original file as both have the same inode" src="image/B19430_02_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.893.1">Figure 2.7 – It’s impossible to tell which is the original file as both have the same inode</span></p>
<p><span class="koboSpan" id="kobo.894.1">In contrast, a symbolic link has a different inode number than the original file. </span><span class="koboSpan" id="kobo.894.2">Note how this symbolic link is pointing to the original file and indicates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">l</span></strong><span class="koboSpan" id="kobo.896.1"> in the permission section of </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">the file:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.898.1"><img alt="Figure 2.8 – For soft links, the first character in the file permissions is “l”" src="image/B19430_02_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.899.1">Figure 2.8 – For soft links, the first character in the file permissions is “l”</span></p>
<p><span class="koboSpan" id="kobo.900.1">Using the same inode number for multiple files results in some limitations. </span><span class="koboSpan" id="kobo.900.2">As inode numbers are only unique within a filesystem, hard links cannot span across filesystem boundaries. </span><span class="koboSpan" id="kobo.900.3">They can only exist within a filesystem. </span><span class="koboSpan" id="kobo.900.4">Hard links can only be used for regular files, not directories. </span><span class="koboSpan" id="kobo.900.5">This is to prevent breaking the filesystem structure. </span><span class="koboSpan" id="kobo.900.6">A hard link to a directory could create an endless </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">loop structure.</span></span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.902.1">Summarizing the four structures</span></h2>
<p><span class="koboSpan" id="kobo.903.1">Some of the concepts that we’ve discussed here might become a lot more clear when we discuss block filesystems in </span><a href="B19430_03.xhtml#_idTextAnchor053"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.904.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.905.1">, </span><em class="italic"><span class="koboSpan" id="kobo.906.1">Exploring the Actual Filesystems Under the VFS</span></em><span class="koboSpan" id="kobo.907.1">. </span><span class="koboSpan" id="kobo.907.2">But we have gotten some understanding of how VFS goes about spinning that web </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">of abstraction.</span></span></p>
<p><span class="koboSpan" id="kobo.909.1">As discussed in </span><a href="B19430_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.910.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.911.1">, the design of VFS is biased toward filesystems that originate from the Linux tribe. </span><span class="koboSpan" id="kobo.911.2">Most non-native filesystems do not speak in terms of inodes, superblocks, files, and directory objects. </span><span class="koboSpan" id="kobo.911.3">To implement the common file model for them, VFS creates these structures in </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.912.1">memory. </span><span class="koboSpan" id="kobo.912.2">So, objects such as inodes and superblocks, which have </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.913.1">an on-disk and in-memory presence for native filesystems, might only be present in memory for non-native filesystems. </span><span class="koboSpan" id="kobo.913.2">Because of the difference in the design of non-native filesystems, they might not support some common filesystem operations in Linux, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">symbolic links.</span></span></p>
<p><span class="koboSpan" id="kobo.915.1">The following table provides a brief summary of the major </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">VFS structures:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.917.1">Structure</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.918.1">Description</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.919.1">Stored on </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.920.1">disk/in memory</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.921.1">Inode</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.922.1">Contains all file metadata except </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">the filename</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.924.1">On disk and </span><span class="No-Break"><span class="koboSpan" id="kobo.925.1">in memory</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.926.1">Dentry</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.927.1">Represents the relationship between a directory entry </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">and files</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.929.1">Only </span><span class="No-Break"><span class="koboSpan" id="kobo.930.1">in memory</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.931.1">File Object</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.932.1">Stores information about the relationship of the process to an </span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">open file</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.934.1">Only </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">in memory</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.936.1">Superblock</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.937.1">Holds filesystem characteristics </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">and metadata</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.939.1">On disk and </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">in memory</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.941.1">Table 2.1 – Summarizing major VFS data structures</span></p>
<p><span class="koboSpan" id="kobo.942.1">The following figure represents how a process will go about opening a file stored </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">on disk:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.944.1"><img alt="Figure 2.9 – Relationship between common VFS structures" src="image/B19430_02_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.945.1">Figure 2.9 – Relationship between common VFS structures</span></p>
<p><span class="koboSpan" id="kobo.946.1">Remember that the superblock structure is created and initialized during the filesystem mount process and it </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.947.1">contains a pointer to the root dentry, which, in turn, contains </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.948.1">a pointer to the inode that represents the root directory of </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">the filesystem.</span></span></p>
<p><span class="koboSpan" id="kobo.950.1">When a process calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">open()</span></strong><span class="koboSpan" id="kobo.952.1"> system call to open a file, the VFS creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">struct file</span></strong><span class="koboSpan" id="kobo.954.1"> object to represent the file in the process’s address space and initializes its </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">f_path</span></strong><span class="koboSpan" id="kobo.956.1"> field to point to the directory path of the file. </span><span class="koboSpan" id="kobo.956.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">struct dentry</span></strong><span class="koboSpan" id="kobo.958.1"> object contains a pointer to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">struct inode</span></strong><span class="koboSpan" id="kobo.960.1"> object, which represents the on-disk inode for </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">the file.</span></span></p>
<p><span class="koboSpan" id="kobo.962.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">struct inode</span></strong><span class="koboSpan" id="kobo.964.1"> object is associated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">struct super_block</span></strong><span class="koboSpan" id="kobo.966.1"> object, which represents the on-disk filesystem. </span><span class="koboSpan" id="kobo.966.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">struct super_block</span></strong><span class="koboSpan" id="kobo.968.1"> object contains pointers to the filesystem-specific functions defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">struct super_operations</span></strong><span class="koboSpan" id="kobo.970.1"> structure, which is used by the VFS to interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">the filesystem.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.972.1">Page cache</span></h2>
<p><span class="koboSpan" id="kobo.973.1">The nomenclature used for defining different concepts and terms in Linux is a bit odd. </span><span class="koboSpan" id="kobo.973.2">The system call for </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.974.1">creating a file is known as </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">creat</span></strong><span class="koboSpan" id="kobo.976.1">. </span><span class="koboSpan" id="kobo.976.2">Ken Thompson, the creator of Unix, once jokingly said that the missing </span><em class="italic"><span class="koboSpan" id="kobo.977.1">e</span></em><span class="koboSpan" id="kobo.978.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">creat</span></strong><span class="koboSpan" id="kobo.980.1"> was his greatest regret in the Unix design. </span><span class="koboSpan" id="kobo.980.2">While explaining a few operations of VFS structures, the word </span><em class="italic"><span class="koboSpan" id="kobo.981.1">dirty</span></em><span class="koboSpan" id="kobo.982.1"> has been used. </span><span class="koboSpan" id="kobo.982.2">How and </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.983.1">why this term has been used in Linux is anybody’s guess. </span><span class="koboSpan" id="kobo.983.2">The term </span><em class="italic"><span class="koboSpan" id="kobo.984.1">dirty</span></em><span class="koboSpan" id="kobo.985.1"> here refers to pages in memory that have been modified but have not yet been </span><em class="italic"><span class="koboSpan" id="kobo.986.1">flushed</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.987.1">to disk.</span></span></p>
<p><span class="koboSpan" id="kobo.988.1">Caching is a common practice used in both hardware and software applications to improve performance. </span><span class="koboSpan" id="kobo.988.2">In terms of hardware, the speed and performance of the CPU, memory subsystem, and physical disks are interconnected. </span><span class="koboSpan" id="kobo.988.3">The CPU is much faster than the memory subsystem, which, in turn, is faster than physical disks. </span><span class="koboSpan" id="kobo.988.4">This discrepancy in speed can result in wasted CPU cycles when waiting for a response from memory </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">or disk.</span></span></p>
<p><span class="koboSpan" id="kobo.990.1">To address this issue, cache layers were added to the CPU to store frequently accessed data from the main memory. </span><span class="koboSpan" id="kobo.990.2">This allows the CPU to operate at its natural speed as long as the required data is available in the cache. </span><span class="koboSpan" id="kobo.990.3">Similarly, software applications also use caching to store frequently accessed data or instructions in a faster and more accessible location to </span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">improve performance.</span></span></p>
<p><span class="koboSpan" id="kobo.992.1">The Linux design is geared toward performance, and the page cache plays a vital role in ensuring this. </span><span class="koboSpan" id="kobo.992.2">The primary purpose of the page cache is to improve the latency of </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">read</span></strong><span class="koboSpan" id="kobo.994.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">write</span></strong><span class="koboSpan" id="kobo.996.1"> operations by ensuring that data is kept in memory (provided there is enough available) so that frequent trips to the underlying physical disks can be avoided. </span><span class="koboSpan" id="kobo.996.2">All this contributes toward performance improvement as disk access is far slower </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">than memory.</span></span></p>
<p><span class="koboSpan" id="kobo.998.1">Operating systems interact with hardware at a lower level and use different units for managing and utilizing the available resources. </span><span class="koboSpan" id="kobo.998.2">For example, filesystems break down the disk space into blocks, which is a higher-level abstraction than individual bytes or bits. </span><span class="koboSpan" id="kobo.998.3">The reason for this is that managing data at a byte or bit level can be complex and time-consuming. </span><span class="koboSpan" id="kobo.998.4">A page is the fundamental unit of memory in the kernel and is 4 KB by default. </span><span class="koboSpan" id="kobo.998.5">This is significant because all I/O operations are aligned to some number of pages. </span><span class="koboSpan" id="kobo.998.6">The following figure summarizes how data is read from and written to disk, using the </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">page cache:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.1000.1"><img alt="Figure 2.10 – Improving I/O performance through Page Cache" src="image/B19430_02_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1001.1">Figure 2.10 – Improving I/O performance through Page Cache</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1002.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1003.1">.10</span></em><span class="koboSpan" id="kobo.1004.1"> highlights how the </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.1005.1">page cache aids in improving read and write performance </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.1006.1">by caching frequently accessed file data in memory, thereby reducing disk access and improving </span><span class="No-Break"><span class="koboSpan" id="kobo.1007.1">system performance.</span></span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.1008.1">Reading</span></h2>
<p><span class="koboSpan" id="kobo.1009.1">The following points </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.1010.1">provide a brief </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.1011.1">summary of what happens when a process running in user space requests data to be read </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">from disk:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1013.1">The kernel first checks whether the required data is already available in the cache. </span><span class="koboSpan" id="kobo.1013.2">If the data is found in the cache, the kernel can avoid performing any disk operation and directly provide </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.1014.1">the requested data to the process. </span><span class="koboSpan" id="kobo.1014.2">This scenario is known as a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1015.1">cache hit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1017.1">If the requested data cannot be found in the cache, the kernel must go to the underlying disk. </span><span class="koboSpan" id="kobo.1017.2">This is </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.1018.1">known as a </span><strong class="bold"><span class="koboSpan" id="kobo.1019.1">cache miss</span></strong><span class="koboSpan" id="kobo.1020.1">. </span><span class="koboSpan" id="kobo.1020.2">Before that, it has to check whether any free memory is available. </span><span class="koboSpan" id="kobo.1020.3">The kernel will then schedule a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">read</span></strong><span class="koboSpan" id="kobo.1022.1"> operation, retrieve the requested data from the disk, save it to the cache, and then hand it over to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">calling process.</span></span></li>
<li><span class="koboSpan" id="kobo.1024.1">If any further requests </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.1025.1">are made to access this page, they can be fulfilled from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">page cache.</span></span></li>
<li><span class="koboSpan" id="kobo.1027.1">In the case where </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.1028.1">the requested data is found in the cache but has already been marked as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">dirty</span></strong><span class="koboSpan" id="kobo.1030.1">, the kernel will first write it back to disk before proceeding with the procedure </span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1">mentioned earlier.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1032.1">Similarly, when a process needs to write data to disk, the </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">following happens:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1034.1">The kernel updates the page cache that is mapped to the file and marks the data as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">dirty</span></strong><span class="koboSpan" id="kobo.1036.1">. </span><span class="koboSpan" id="kobo.1036.2">The pages that are yet to </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.1037.1">be written to the disk are known as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1038.1">dirty pages</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1040.1">The kernel will not immediately write all dirty data to disk. </span><span class="koboSpan" id="kobo.1040.2">Depending upon the configuration of the kernel’s flusher thread, the dirty data will be flushed to </span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">the disk.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1042.1">After a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">write</span></strong><span class="koboSpan" id="kobo.1044.1"> request is completed, the kernel sends an acknowledgment to the calling process. </span><span class="koboSpan" id="kobo.1044.2">However, it doesn’t inform the process about when the corresponding dirty page will actually be written to disk. </span><span class="koboSpan" id="kobo.1044.3">It is interesting to note that this asynchronous approach makes write operations much faster than read operations, as the kernel dodges a trip to the underlying physical disk. </span><span class="koboSpan" id="kobo.1044.4">This also begs the question: </span><em class="italic"><span class="koboSpan" id="kobo.1045.1">If my I/O requests are served from memory, what happens to my data in case of abrupt power loss?</span></em><span class="koboSpan" id="kobo.1046.1"> The dirty pages in memory do get flushed to the physical disks after a certain </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.1047.1">interval; this is called </span><strong class="bold"><span class="koboSpan" id="kobo.1048.1">writeback</span></strong><span class="koboSpan" id="kobo.1049.1">. </span><span class="koboSpan" id="kobo.1049.2">How often or how long data remains in memory depends on certain factors. </span><span class="koboSpan" id="kobo.1049.3">If an application keeps on caching data, it can create problems for other processes in the system. </span><span class="koboSpan" id="kobo.1049.4">The amount of total memory in a system is far less than the physical disk capacity, so it makes sense to clear up the cache after regular intervals. </span><span class="koboSpan" id="kobo.1049.5">In order to prevent the loss of critical data, some applications, such as databases, need guarantees that data has been written to the persistent storage. </span><span class="koboSpan" id="kobo.1049.6">In such cases, it makes sense to flush the dirty data immediately to disk. </span><span class="koboSpan" id="kobo.1049.7">The kernel offers some </span><strong class="bold"><span class="koboSpan" id="kobo.1050.1">tunables</span></strong><span class="koboSpan" id="kobo.1051.1"> (through </span><strong class="source-inline"><span class="koboSpan" id="kobo.1052.1">sysctl</span></strong><span class="koboSpan" id="kobo.1053.1">), which can </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.1054.1">be used for controlling this behavior of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1055.1">page cache.</span></span></p>
<p><span class="koboSpan" id="kobo.1056.1">Despite the risks </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.1057.1">associated with page caching, there is no doubt that it improves </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.1058.1">performance. </span><span class="koboSpan" id="kobo.1058.2">The size of the page cache is not fixed; it is dynamic in nature. </span><span class="koboSpan" id="kobo.1058.3">The page cache can use the available memory resources. </span><span class="koboSpan" id="kobo.1058.4">However, when the free memory available in the system goes below a threshold, the flushing schedulers will kick in and start to unload data from the page cache </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">onto disk.</span></span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.1060.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1061.1">The flexibility of support for Linux filesystems is a direct result of an abstracted set of interfaces implemented by the VFS. </span><span class="koboSpan" id="kobo.1061.2">In this chapter, we learned about the major data structures in the VFS and how they are all working together. </span><span class="koboSpan" id="kobo.1061.3">The VFS uses several data structures to implement generic abstraction methods for the different native and non-native filesystems. </span><span class="koboSpan" id="kobo.1061.4">The four most common structures are inodes, directory entries, file objects, and superblocks. </span><span class="koboSpan" id="kobo.1061.5">These structures ensure commonality between the design and operations of different filesystems. </span><span class="koboSpan" id="kobo.1061.6">Since the methods defined by the VFS are generic, it is not compulsory for filesystems to implement all of them, although the filesystems should adhere to the structures defined in the VFS and build upon them to ensure a generic interface </span><span class="No-Break"><span class="koboSpan" id="kobo.1062.1">is maintained.</span></span></p>
<p><span class="koboSpan" id="kobo.1063.1">In addition to filesystem abstractions, the VFS also provides a number of caches to improve the performance of filesystem operations, such as dentry and inode cache. </span><span class="koboSpan" id="kobo.1063.2">We also explained the mechanism of the page cache in the kernel and saw how it can speed up read and write requests issued by the user-space programs. </span><span class="koboSpan" id="kobo.1063.3">In </span><a href="B19430_03.xhtml#_idTextAnchor053"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1064.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.1065.1">, we’re going to explore the actual filesystems under the VFS layer. </span><span class="koboSpan" id="kobo.1065.2">We’ll cover some popular Linux filesystems, primarily the extended filesystem and how it organizes user data on disk. </span><span class="koboSpan" id="kobo.1065.3">We’ll also explain some common concepts associated with the different filesystems in Linux, such as journaling, copy-on-write, and filesystems in </span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">user space.</span></span></p>
</div>
</body></html>