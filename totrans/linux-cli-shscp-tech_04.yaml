- en: '*Chapter 4*: Using Shell to Configure and Troubleshoot a Network'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*: 使用Shell配置和排除网络故障'
- en: Managing processes is an important job of a Linux system administrator. That
    can be for a variety of reasons – maybe some processes got stuck and we need to
    finish them, or we want to put some process(es) to work in the background, or
    even to be started periodically or at a later date. Whatever the scenario is,
    it's important to know how to administer processes and make them do the work that
    needs to be done efficiently and with regards to other processes running on the
    system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 管理进程是Linux系统管理员的重要工作。这有多种原因——可能是某些进程卡住了，我们需要结束它们，或者我们希望将某些进程放到后台运行，甚至定期启动或在稍后时间启动。无论是哪种情况，了解如何管理进程并高效地完成需要的工作，同时考虑到系统中其他进程的运行，都非常重要。
- en: 'In this chapter, we are going to learn about the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下食谱：
- en: Using `nmcli` and `netplan`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`nmcli`和`netplan`
- en: Using `firewall-cmd` and `ufw`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`firewall-cmd`和`ufw`
- en: Working with open ports and connections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理开放端口和连接
- en: Configuring `/etc/hosts` and DNS resolving
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置`/etc/hosts`和DNS解析
- en: Using network diagnostic tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网络诊断工具
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For these recipes, we''re going to use two Linux machines. We can use the client1
    virtual machine from our previous recipes. We''ll also use another two virtual
    machines running `nmcli` and `firewall-cmd`). Let''s call them `server1` and client2\.
    All in all, we need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些食谱，我们将使用两台Linux机器。我们可以使用之前食谱中的client1虚拟机。同时我们还将使用另一台运行`nmcli`和`firewall-cmd`的虚拟机。我们称它们为`server1`和client2。总的来说，我们需要以下设备：
- en: A virtual machine running Ubuntu 20.10
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行Ubuntu 20.10的虚拟机
- en: Two virtual machines with CentOS 8 2105
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两台运行CentOS 8 2105的虚拟机
- en: So, let's start our virtual machines and let's get cracking!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们启动虚拟机，开始吧！
- en: Using nmcli and netplan
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用nmcli和netplan
- en: Network configuration has changed significantly in the past couple of releases
    – for all Linux distributions. It doesn't really matter whether we are discussing
    Red Hat and its clones or Debian and its clones – these changes happened across
    all of them. For example, Red Hat and its clones went from a network service to
    a mixture of network and NetworkManager services to a fully NetworkManager-based
    configuration. Ubuntu was using a networking service until recently when it switched
    to netplan. Let's explain all of these concepts so that we can have a full overview
    of these configuration methods and cover any situations you might end up in. We
    will also cover a scenario in which someone might want to turn off netplan and
    go back to using the networking service on Ubuntu.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几个版本中，网络配置发生了显著变化——适用于所有Linux发行版。无论是讨论Red Hat及其衍生版，还是Debian及其衍生版，这些变化都发生在所有这些系统中。例如，Red
    Hat及其衍生版从网络服务过渡到混合网络和NetworkManager服务，最终过渡到完全基于NetworkManager的配置。Ubuntu曾经使用网络服务，直到最近才切换到netplan。让我们解释这些概念，以便我们能全面了解这些配置方法，并涵盖任何可能遇到的情况。我们还将介绍一个场景，其中有人可能想要关闭netplan并回到在Ubuntu上使用网络服务。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We just need one Ubuntu and one CentOS machine for this recipe. Let''s say
    we are going to use `server1` and client1 to master `nmcli` and `netplan`. Furthermore,
    on CentOS, we need to deploy the `net-tools` package to get access to some of
    the commands used in this recipe (for example, the `ifconfig` command). Let''s
    do that by using the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一台Ubuntu和一台CentOS机器来完成这个食谱。假设我们将使用`server1`和client1来掌握`nmcli`和`netplan`。此外，在CentOS上，我们需要部署`net-tools`包以访问本食谱中使用的某些命令（例如，`ifconfig`命令）。我们可以使用以下命令来完成：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After that, we're ready to go.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们准备好开始了。
- en: How to do it
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let''s first work with the two most common CentOS scenarios – implementing
    network configuration via `nmcli` for both `ens39` to create a network connection
    called `static` (for the static IP address, for example, `192.168.2.2/24` with
    gateway `192.168.2.254` and DNS servers `8.8.8.8` and `8.8.4.4`) and, later on,
    a network connection called `dynamic` (for DHCP configuration). We just need to
    run a few commands as root per scenario for that:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先处理两种最常见的CentOS场景——通过`nmcli`实现网络配置，分别为`ens39`创建一个名为`static`的网络连接（例如，静态IP地址`192.168.2.2/24`，网关`192.168.2.254`，DNS服务器`8.8.8.8`和`8.8.4.4`），稍后创建一个名为`dynamic`的网络连接（用于DHCP配置）。对于每个场景，我们只需要以root身份运行几个命令：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The expected result should look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果应该如下所示：
- en: '![Figure 4.1 – Adding a static IP configuration via nmcli'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – 通过nmcli添加静态IP配置'
- en: '](img/Figure_4.1_B16269.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.1_B16269.jpg)'
- en: Figure 4.1 – Adding a static IP configuration via nmcli
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 通过 nmcli 添加静态 IP 配置
- en: 'Let''s now remove that connection and define a DHCP-based configuration. For
    that, we need to have a DHCP server available on our network, so that it can assign
    the necessary network configuration information to client2 (IP address, netmask,
    gateway, DNS server addresses, and so on). We need to type in the following commands:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们移除该连接并定义一个基于 DHCP 的配置。为此，我们需要在网络中有一个 DHCP 服务器，以便它能够为 client2 分配所需的网络配置信息（IP
    地址、子网掩码、网关、DNS 服务器地址等）。我们需要输入以下命令：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is our expected result:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的预期结果：
- en: '![Figure 4.2 – Adding a DHCP configuration via nmcli'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – 通过 nmcli 添加 DHCP 配置'
- en: '](img/Figure_4.2_B16269.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.2_B16269.jpg)'
- en: Figure 4.2 – Adding a DHCP configuration via nmcli
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 通过 nmcli 添加 DHCP 配置
- en: If everything is configured correctly on our network, we should've gotten an
    IP address and other networking information and have internet access.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的网络配置正确，我们应该已经获得了 IP 地址和其他网络信息，并且能够访问互联网。
- en: In terms of `netplan` on Ubuntu, this configuration method is more in line with
    the currently popular *infrastructure as code* paradigm, so it's all about configuration
    files. So, we will again implement two of the most common scenarios – a static
    IP address and DHCP, but we will also cover a scenario with multiple network interfaces
    so that we can see what the syntax looks like.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 中，`netplan` 的这种配置方式更符合当前流行的 *基础设施即代码* 思维方式，因此它完全依赖于配置文件。因此，我们将再次实现两种最常见的场景——静态
    IP 地址和 DHCP，但我们还将涵盖一个包含多个网络接口的场景，以便我们可以看到语法的样子。
- en: 'First, let''s start with the `netplan` static networking configuration. Let''s
    say that we need to assign IP address `192.168.1.1/24` to network interface `ens33`,
    with the default gateway being `192.168.1.254` and DNS servers `8.8.8.8`, and
    `8.8.4.4`. We can just change the existing YAML configuration file that''s already
    there, called `00-installer-config.yaml`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从 `netplan` 静态网络配置开始。假设我们需要为网络接口 `ens33` 分配 IP 地址 `192.168.1.1/24`，默认网关为
    `192.168.1.254`，DNS 服务器为 `8.8.8.8` 和 `8.8.4.4`。我们可以直接修改现有的 YAML 配置文件，即 `00-installer-config.yaml`：
- en: '![Figure 4.3 – Adding a static configuration via netplan'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – 通过 netplan 添加静态配置'
- en: '](img/Figure_4.3_B16269.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.3_B16269.jpg)'
- en: Figure 4.3 – Adding a static configuration via netplan
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 通过 netplan 添加静态配置
- en: 'That covers our static IP address scenario. It''s relatively obvious what we
    need to do in terms of a `netplan` DHCP scenario, so the configuration file needs
    to look like this for that specific scenario:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了我们的静态 IP 地址场景。关于 `netplan` DHCP 场景，我们需要做的事情是显而易见的，因此该配置文件在特定场景下应如下所示：
- en: '![Figure 4.4 – Adding a dynamic configuration via netplan'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – 通过 netplan 添加动态配置'
- en: '](img/Figure_4.4_B16269.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.4_B16269.jpg)'
- en: Figure 4.4 – Adding a dynamic configuration via netplan
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 通过 netplan 添加动态配置
- en: 'The last part of our recipe, as we mentioned, is about having multiple network
    interfaces and configuring them properly. Let''s say that we have a network interface
    called `ens33` that needs to be DHCP-configured, and an interface called `ens38`
    that needs to be assigned an IP address, `192.168.1.1/24`, with the same config
    data for gateway and DNS servers as before. The configuration file would look
    like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配方的最后部分，如我们所提到的，涉及到多个网络接口的配置。假设我们有一个名为 `ens33` 的网络接口需要进行 DHCP 配置，另一个名为 `ens38`
    的接口需要分配一个 IP 地址 `192.168.1.1/24`，并且网关和 DNS 服务器配置与之前相同。配置文件应如下所示：
- en: '![Figure 4.5 – Configuring multiple network interfaces via netplan'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – 通过 netplan 配置多个网络接口'
- en: '](img/Figure_4.5_B16269.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.5_B16269.jpg)'
- en: Figure 4.5 – Configuring multiple network interfaces via netplan
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 通过 netplan 配置多个网络接口
- en: For some of the latest versions of Ubuntu, this `yes`/`no` configuration will
    be changed to `true`/`false`, so if you get an error here, you just need to make
    that change. Basically, it looks like a merge of the previous two files, with
    a couple of lines stripped so that we don't have unnecessary repetitions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些最新版本的 Ubuntu，此 `yes`/`no` 配置将更改为 `true`/`false`，因此如果您遇到错误，只需要做出相应的更改。基本上，它看起来像是前两个文件的合并，去掉了一些重复的行，以免出现不必要的重复。
- en: Let's now see how these two concepts work. It's simple enough, but still, it
    requires a bit of background knowledge, so let's dive in.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这两个概念是如何工作的。它足够简单，但仍然需要一些背景知识，因此让我们深入了解一下。
- en: How it works
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Now that we've done a brief primer on how processes and signals work, let's
    continue our quest for knowledge about processes by learning about the management
    of background processes. As we've already explained the basics of background processes,
    that shouldn't be a difficult task.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要介绍了进程和信号的工作原理，让我们继续探索关于进程的知识，学习如何管理后台进程。由于我们已经解释了后台进程的基础知识，这不应该是一个困难的任务。
- en: 'In terms of NetworkManager and its command-line configuration interface (`nmcli`),
    NetworkManager does its configuration via configuration files in the `/etc/sysconfig/network-scripts`
    directory. Let''s show an example from our previous CentOS session – where we
    created an interface called `dynamic`. In that directory, there''s a file called
    `ifcfg-dynamic`, with the following content:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就NetworkManager及其命令行配置接口（`nmcli`）而言，NetworkManager通过`/etc/sysconfig/network-scripts`目录中的配置文件进行配置。让我们通过之前CentOS会话中的一个例子来展示——我们创建了一个名为`dynamic`的接口。在该目录中，有一个名为`ifcfg-dynamic`的文件，内容如下：
- en: '![Figure 4.6 – Regular NetworkManager configuration file'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – 常规 NetworkManager 配置文件'
- en: '](img/Figure_4.6_B16269.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.6_B16269.jpg)'
- en: Figure 4.6 – Regular NetworkManager configuration file
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 常规 NetworkManager 配置文件
- en: 'That''s quite a big configuration file for a simple configuration. Actually,
    if we were to polish this file a bit, we could make it at least two thirds shorter,
    and it would still work, for example, like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的配置文件来说，这是一个相当大的配置文件。实际上，如果我们稍微优化一下这个文件，我们可以将其缩短至少三分之二，并且仍然能够正常工作，例如像这样：
- en: '![Figure 4.7 – Shortened configuration file'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7 – 简化的配置文件'
- en: '](img/Figure_4.7_B16269.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.7_B16269.jpg)'
- en: Figure 4.7 – Shortened configuration file
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 简化的配置文件
- en: These configuration options aren't all that difficult to understand, as well
    as some other configuration options that are needed for static IP configuration
    (`IPADDR`, `PREFIX` or `NETMASK`, `GATEWAY` – these are all pretty self-explanatory).
    But the fact remains that – at least in part – NetworkManager still uses this
    bulky syntax as a history leftover, as we've been using this `/etc/sysconfig/network-scripts`
    directory and files in that directory to configure network interfaces for years
    and years now.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置选项并不难理解，还有一些其他配置选项是静态IP配置所必需的（`IPADDR`、`PREFIX`或`NETMASK`、`GATEWAY` —— 这些选项都非常直观）。但事实仍然是——至少部分原因——NetworkManager依然使用这种冗长的语法，这是历史遗留问题，我们已经使用`/etc/sysconfig/network-scripts`目录及其中的文件来配置网络接口多年了。
- en: When comparing that to netplan, we can clearly see that netplan puts much more
    importance on declarative syntax with all of the structured code and indentation
    that it needs to have, which is what YAML is known for. It will frustrate you
    at the beginning, at least until you learn how to use the vim editor for editing
    YAML files, as it then becomes much easier. Check out the link in the *There's
    more* section to learn how to set up vim to help you with YAML syntax.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与netplan相比，我们可以清楚地看到，netplan更注重声明式语法，所有结构化的代码和缩进都是必需的，而这正是YAML所擅长的。刚开始使用时，它会让你感到有些沮丧，至少在你学会如何使用vim编辑器编辑YAML文件之前，因为那时它会变得容易得多。请查看*更多内容*部分中的链接，了解如何设置vim来帮助你编写YAML语法。
- en: Both of these services – when the system gets booted up – read the aforementioned
    configuration files and set the network interfaces in accordance to the settings
    in them. A pretty straightforward process, as long as we understand the syntax.
    But we'd still recommend using `nmcli` for NetworkManager configuration as its
    syntax gets under your fingers quickly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个服务——当系统启动时——会读取上述配置文件，并根据其中的设置配置网络接口。这个过程相当直接，只要我们理解语法。但我们仍然建议使用`nmcli`进行NetworkManager配置，因为它的语法很容易掌握。
- en: The next stop is firewalling, by using `firewalld` and `ufw`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用`firewalld`和`ufw`进行防火墙设置。
- en: There's more
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容
- en: 'If you need more information about networking in CentOS and Ubuntu, make sure
    that you check the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于CentOS和Ubuntu网络的资料，确保你查看以下内容：
- en: 'Configuring and managing networking: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/configuring_and_managing_networking/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/configuring_and_managing_networking/index%0D)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和管理网络： [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/configuring_and_managing_networking/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/configuring_and_managing_networking/index%0D)
- en: 'Netplan reference: [https://netplan.io/reference/](https://netplan.io/reference/%0D)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netplan参考：[https://netplan.io/reference/](https://netplan.io/reference/%0D)
- en: '`nmcli`: [https://developer-old.gnome.org/NetworkManager/stable/nmcli.html](https://developer-old.gnome.org/NetworkManager/stable/nmcli.html%0D)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nmcli`：[https://developer-old.gnome.org/NetworkManager/stable/nmcli.html](https://developer-old.gnome.org/NetworkManager/stable/nmcli.html%0D)'
- en: 'Setting up vim for YAML editing: [https://www.arthurkoziel.com/setting-up-vim-for-yaml/](https://www.arthurkoziel.com/setting-up-vim-for-yaml/%0D)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置vim以编辑YAML：[https://www.arthurkoziel.com/setting-up-vim-for-yaml/](https://www.arthurkoziel.com/setting-up-vim-for-yaml/%0D)
- en: Using firewall-cmd and ufw
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用firewall-cmd和ufw
- en: Using built-in firewalls has been a de facto standard in Linux for more than
    two decades now. Ever since the *invention* of `ipfwadm` (kernel v2.0), Linux
    kernel developers have been piling up functionality and a firewall has been one
    of those things. `ipfwadm` was followed by `ipchains` (kernel v2.2), `iptables`
    (kernel v2.4), and today it's all about `firewalld` (CentOS) and `ufw` (Ubuntu).
    Let's go through both of these concepts so that we can use them when we need them
    regardless of the Linux distribution we're working on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，使用内置防火墙已经成为事实上的标准，超过二十年。自从`ipfwadm`（内核v2.0）*发明*以来，Linux内核开发者不断增加功能，防火墙就是其中之一。`ipfwadm`之后是`ipchains`（内核v2.2），然后是`iptables`（内核v2.4），如今则是`firewalld`（CentOS）和`ufw`（Ubuntu）。让我们了解这两种概念，以便无论我们使用什么Linux发行版，都能在需要时使用它们。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'As a part of this recipe, we are going to go through a list of dozens of different
    scenarios covering `firewalld` and `ufw`. In other words, we are going to introduce
    the necessary commands to do configuration changes for some of the most commonly
    used scenarios. First, let''s install the necessary packages for CentOS (on our
    client2 machine) and Ubuntu (client1 machine). So, for CentOS, we need to type
    the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个教程的一部分，我们将通过几十种不同场景的列表，涵盖`firewalld`和`ufw`。换句话说，我们将介绍必要的命令，以便对一些最常用的场景进行配置更改。首先，让我们为CentOS（在我们的client2机器上）和Ubuntu（client1机器上）安装必要的包。所以，对于CentOS，我们需要输入以下命令：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Also, use this command for Ubuntu:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于Ubuntu，使用以下命令：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In terms of services, for CentOS, we have these – just in case we used `iptables`
    previously, as `iptables` firewall is supported in CentOS 8:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务方面，对于CentOS，我们有这些——以防我们之前使用过`iptables`，因为CentOS 8支持`iptables`防火墙：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For Ubuntu, it''s the same idea:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ubuntu，思路是一样的：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that the services are configured, let's start!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务已经配置完成，让我们开始吧！
- en: How to do it
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'For `firewalld`, we are going to use its default command, which is `firewall-cmd`.
    For `ufw`, the command has the same name – `ufw`. First, let''s take care of some
    basic commands. Let''s first list all the rules:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`firewalld`，我们将使用其默认命令，即`firewall-cmd`。对于`ufw`，命令相同——`ufw`。首先，让我们处理一些基本命令。首先列出所有规则：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Depending on how many rules we added previously, we should get an output similar
    to this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前添加的规则数量，应该会得到类似这样的输出：
- en: '![Figure 4.8 – firewall-cmd --list-all output'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – firewall-cmd --list-all 输出'
- en: '](img/Figure_4.8_B16269.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.8_B16269.jpg)'
- en: Figure 4.8 – firewall-cmd --list-all output
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – firewall-cmd --list-all 输出
- en: 'Let''s now add and delete a couple of rules. This is what we are going to do:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加和删除一些规则。这是我们要做的：
- en: Add a rule that allows `192.168.2.254/24` to access everything on our `client2`
    machine.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一条规则，允许`192.168.2.254/24`访问我们`client2`机器上的所有内容。
- en: Add a rule that allows network subnet `192.168.1.0/24` to access the `SSH` service
    on our `client2` machine.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一条规则，允许网络子网`192.168.1.0/24`访问我们`client2`机器上的`SSH`服务。
- en: Block the `192.168.3.0/24` network from accessing HTTP/HTTPS services.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻止`192.168.3.0/24`网络访问HTTP/HTTPS服务。
- en: Allow the same subnet to access the DNS service.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许同一子网访问DNS服务。
- en: Forward port `900` to port `9090`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将端口`900`转发到端口`9090`。
- en: Configure `masquerade` so that `client1` can be used as a router/gateway.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置`masquerade`，使`client1`可以作为路由器/网关使用。
- en: As the last step, we are going to delete every single one of these rules, one
    by one.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们将一条一条地删除所有这些规则。
- en: 'Now that we''re clear on what we are trying to do, let''s punch in all of the
    necessary commands to make this happen. First, let''s start by using the default
    configuration and default zone, which means that we need to check which zone it
    is. We can see in the previous screenshot that the public zone is active, so –
    for the time being – we are going to add all of the rules to that zone and explain
    zones and rich rules a bit later:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经清楚了要做的事情，接下来让我们输入所有必要的命令来实现这个目标。首先，我们从使用默认配置和默认区域开始，这意味着我们需要检查当前是哪个区域。我们可以在之前的截图中看到公共区域是激活的，所以——暂时——我们将所有规则添加到该区域，稍后我们会解释区域和富规则：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Echo commands are used to enable IP forwarding right now (first echo), and
    to enable it permanently (second echo), by using a `sysctl` configuration file
    that''s going to be loaded as our system boots up. The last command is to apply
    these settings to the current running state of `firewalld`. When we now type in
    the `firewall-cmd --list-all` command, we should get output like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Echo 命令用于现在启用 IP 转发（第一个 echo），并通过使用一个`sysctl`配置文件使其在系统启动时永久启用（第二个 echo）。最后一条命令是将这些设置应用到当前运行的`firewalld`状态。当我们现在输入`firewall-cmd
    --list-all`命令时，应该会得到如下输出：
- en: '![Figure 4.9 – End result of our configuration in firewalld'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9 – 我们在 firewalld 中配置的最终结果'
- en: '](img/Figure_4.9_B16269.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.9_B16269.jpg)'
- en: Figure 4.9 – End result of our configuration in firewalld
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 我们在 firewalld 中配置的最终结果
- en: 'It''s very important to learn how to remove these rules, as well. So, let''s
    now remove these rules, one by one, going in the opposite direction:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 学会如何移除这些规则也非常重要。所以，接下来让我们一条一条地反向删除这些规则：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That should remove all of the rules and apply the starting state as the current
    state. Let''s check:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该移除所有规则并将起始状态应用为当前状态。让我们检查一下：
- en: '![Figure 4.10 – The firewalld rule set after rule removal'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.10 – 移除规则后的 firewalld 规则集'
- en: '](img/Figure_4.10_B16269.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.10_B16269.jpg)'
- en: Figure 4.10 – The firewalld rule set after rule removal
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 移除规则后的 firewalld 规则集
- en: 'Everything is back to its original state, so we can call this a success. Let''s
    now apply the same ruleset to the Ubuntu virtual machine called client1 by using
    `ufw`. Let''s first check the status by using the `ufw status verbose` command.
    We should get a result like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一切已恢复到原始状态，所以我们可以认为这是成功的。现在让我们使用`ufw`将相同的规则集应用到名为 client1 的 Ubuntu 虚拟机上。首先，我们通过使用`ufw
    status verbose`命令来检查状态。我们应该得到如下结果：
- en: '![Figure 4.11 – ufw configuration starting point'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11 – ufw 配置的起始点'
- en: '](img/Figure_4.11_B16269.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.11_B16269.jpg)'
- en: Figure 4.11 – ufw configuration starting point
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – ufw 配置的起始点
- en: 'Let''s now add the same set of rules that we added in `firewalld`, to see how
    it''s done via `ufw` and to be able to check the syntax differences:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加与在`firewalld`中添加的规则相同的规则，看看如何通过`ufw`来实现，并且检查语法差异：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For port forwarding, we need to edit the `/etc/ufw/before.rules` file and add
    the following configuration options before the `*filter` section:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于端口转发，我们需要编辑`/etc/ufw/before.rules`文件，并在`*filter`部分之前添加以下配置选项：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now check the status of our work by using the `ufw` and `iptables` commands:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过使用`ufw`和`iptables`命令来检查我们的工作状态：
- en: '![Figure 4.12 – ufw status verbose after all the added rules'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.12 – 添加所有规则后的 ufw 状态详细信息'
- en: '](img/Figure_4.12_B16269.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.12_B16269.jpg)'
- en: Figure 4.12 – ufw status verbose after all the added rules
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 添加所有规则后的 ufw 状态详细信息
- en: 'We need to add two configuration options to `ufw` configuration for masquerading
    to work. First, we need to change the default policy for forwarding in the `/etc/default/ufw`
    file. It''s set to `DROP` by default. We just need to change it to `ACCEPT`. It''s
    at the beginning of this file, so the end result should look like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向`ufw`配置中添加两个配置选项，才能使伪装工作。首先，我们需要在`/etc/default/ufw`文件中更改转发的默认策略。默认设置为`DROP`，我们只需将其更改为`ACCEPT`。该设置位于文件的开头，所以最终结果应该是这样的：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is rather than looking like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这样看起来比较合适：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next configuration option is actually in the same file that we previously
    edited, `/etc/ufw/before.rules`. We need to add one additional part to the `*nat`
    section called the `POSTROUTING` subsection, to the same place that we used before.
    So, similar to the previous example, we need to add the following configuration
    options, again before the `*filter` section:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个配置选项实际上就在我们之前编辑过的同一个文件中，即 `/etc/ufw/before.rules`。我们需要在 `*nat` 部分添加一个名为 `POSTROUTING`
    的子部分，添加到之前使用过的地方。所以，类似于之前的示例，我们需要再次在 `*filter` 部分之前添加以下配置选项：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last part of the `ufw` configuration is making sure that the kernel knows
    that it needs to turn on `ip` forwarding. For that to happen, we need to edit
    a file called `/etc/ufw/sysctl.conf` and uncomment the following configuration
    option by removing the comment mark (`#`) before it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`ufw` 配置的最后一部分是确保内核知道需要启用 `ip` 转发。为了实现这一点，我们需要编辑一个名为 `/etc/ufw/sysctl.conf`
    的文件，并取消注释以下配置选项，方法是去掉前面的注释标记（`#`）：'
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This changes a value in the `/proc` filesystem, in a file called `/proc/sys/net/ipv4/ip_forward`.
    If we want to make sure that it works even without rebooting the machine, we need
    to issue the following command, as well:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在 `/proc` 文件系统中更改一个值，文件名为 `/proc/sys/net/ipv4/ip_forward`。如果我们想确保即使不重启机器它也能生效，我们还需要执行以下命令：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That will enable IP forwarding on the kernel level and enable us to use masquerading
    in `ufw`. Let''s now check the end result:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启用内核级别的 IP 转发，并使我们能够在 `ufw` 中使用地址转换。现在让我们检查最终结果：
- en: '![Figure 4.13 – ufw ruleset after configuring masquerading'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13 – 配置地址转换后的 ufw 规则集'
- en: '](img/Figure_4.13_B16269.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.13_B16269.jpg)'
- en: Figure 4.13 – ufw ruleset after configuring masquerading
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 配置地址转换后的 ufw 规则集
- en: 'If we need to remove any of these configuration options, it''s going to be
    done in two parts:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要删除这些配置选项，则需要分两部分进行操作：
- en: Configuration options that we added to files directly via the editor will need
    to be removed via the editor.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编辑器直接添加到文件中的配置选项需要通过编辑器删除。
- en: Configuration options that we added by using the `ufw` command can be easily
    reversed by using ufw's rule indexing.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ufw` 命令添加的配置选项可以通过 `ufw` 的规则索引轻松撤销。
- en: 'Let''s type in the command `ufw status numbered`. This is the expected result:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们输入命令 `ufw status numbered`。这是预期的结果：
- en: '![Figure 4.14 – ufw ruleset indexed by number'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.14 – 按编号索引的 ufw 规则集'
- en: '](img/Figure_4.14_B16269.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.14_B16269.jpg)'
- en: Figure 4.14 – ufw ruleset indexed by number
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 按编号索引的 ufw 规则集
- en: 'We can see that every rule that we punched in has a number attached to it.
    Rules 8 and 9 are rules for ports `900` and `9090` that were automatically added
    for the IPv4 and IPv6 stack. We can remove all of these rules easily by using
    the numbers attached to them. The thing is, `ufw` doesn''t have a mechanism for
    deleting multiple rules one by one, so we would need to delete them one by one,
    something like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，每个我们添加的规则都有一个编号。规则 8 和 9 是为端口 `900` 和 `9090` 自动添加的规则，适用于 IPv4 和 IPv6
    栈。我们可以通过使用附加的编号轻松删除所有这些规则。问题是，`ufw` 并没有删除多个规则的机制，所以我们需要逐个删除它们，像这样：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Yes, we could''ve simplified this with a `for` loop, something like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们本可以用 `for` 循环简化这个过程，像这样：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But shell scripting and using loops is yet to come in this book so... let's
    treat this as an *example in advance*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，本书后面会介绍 shell 脚本和使用循环，所以...我们先把这当作一个 *提前示例*。
- en: Let's now explain how all of this works – firewalld zones, rich rules, `ufw`
    syntax – so that we can get an understanding of the background services and capabilities
    making it happen.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们解释一下这一切是如何工作的——firewalld 区域、富规则、`ufw` 语法——以便我们理解实现这一功能的后台服务和能力。
- en: Note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`Firewalld` is available on Ubuntu, as well. It just needs to be installed,
    enabled, started, and configured, and the opposite needs to be done to `ufw`.
    If you''re more prone to using `firewalld`, we suggest that you try doing that
    as it''s easy and won''t take much of your time.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Firewalld` 也可以在 Ubuntu 上使用。只需要安装、启用、启动并配置它，同时对 `ufw` 进行相反的操作。如果你更倾向于使用 `firewalld`，我们建议你试试这个方法，它很简单，不会浪费你太多时间。'
- en: How it works
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: There's a fundamental difference between `ufw` and `firewalld`, with `ufw` basically
    being just a frontend to `iptables`, while `firewalld` is much more dynamic, having
    the capability to work with zones to which we can assign various trust levels.
    The syntax is also different, `ufw` being a bit more namespace-based while `firewalld`
    requires a bit more effort in terms of rule typing. But, at the same time, `firewalld`
    has a D-Bus interface, which makes configuration easier in terms of applications,
    services, and users making configuration changes, on top of the fact that we don't
    have to restart the firewall for every change to take effect. It also interacts
    well with NetworkManager and `nmcli`, `libvirt`, Docker, and Podman, and other
    utilities such as fail2ban (although fail2ban works with `iptables` just as well).
    Sometimes it's a matter of preference; sometimes it's habits. Generally speaking,
    if you're more of an Ubuntu/Debian user, you're probably going to be more inclined
    to use `ufw`. By the same token, if you're more of a CentOS/Red Hat/Fedora/*SuSe
    user, you'll definitely be more inclined to use `firewalld`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`ufw` 和 `firewalld` 之间有一个根本性的区别，`ufw` 基本上只是 `iptables` 的前端，而 `firewalld` 则更加动态，具有与区域（zones）配合使用的能力，我们可以为这些区域分配不同的信任级别。它们的语法也不同，`ufw`
    更加基于命名空间，而 `firewalld` 在规则编写上则需要更多的努力。但与此同时，`firewalld` 具有 D-Bus 接口，这使得在应用程序、服务和用户进行配置更改时，配置变得更加容易，此外，我们无需在每次更改后重新启动防火墙以使其生效。它还与
    NetworkManager 和 `nmcli`、`libvirt`、Docker、Podman 等工具良好配合，甚至与 fail2ban 兼容（尽管 fail2ban
    同样能与 `iptables` 一起工作）。有时候这取决于个人偏好；有时候是习惯。一般来说，如果你是 Ubuntu/Debian 用户，你可能会更倾向于使用
    `ufw`。同样，如果你是 CentOS/Red Hat/Fedora/*SuSe 用户，你肯定更倾向于使用 `firewalld`。'
- en: 'Firewalld''s concept of using zones, to which we can assign network interfaces
    or IP addresses, is certainly useful, as it gives us much more freedom in terms
    of configuration. If we type in the `firewall-cmd --get-zones command`, we''ll
    see the list of available zones at that point in time:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`firewalld` 使用区域的概念，我们可以将网络接口或 IP 地址分配给这些区域，这无疑非常有用，因为它给了我们更多的配置自由度。如果我们输入
    `firewall-cmd --get-zones` 命令，我们会看到当前时刻可用的区域列表：'
- en: '![Figure 4.15 – Default firewalld zones'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.15 – 默认的 firewalld 区域'
- en: '](img/Figure_4.15_B16269.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.15_B16269.jpg)'
- en: Figure 4.15 – Default firewalld zones
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 默认的 firewalld 区域
- en: By default, `firewalld` is configured in the *deny everything, add exceptions*
    manner, again, for ease of use. We can use it to allow or deny connections based
    on ports, IP addresses, subnets, and services, which enables us to do everything
    we need to do, in terms of host-based firewall functionality. It also has a concept
    called rich rules (as shown in our examples in this recipe), that enables us to
    create complex rules with intricate levels of granularity. These rules can be
    based on source address, destination address, ports, protocols, services, port
    forwarding, and masquerade per subnet. They can be used for rate limiting, which
    allows us to set the number of accepted SSH connections to 5 or 10 per minute
    to make it much harder to do SSH brute force attacks on our Linux servers. All
    in all, it's a very well-thought-out and feature-rich firewall that's free for
    us to use. We just need to configure it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`firewalld` 的配置是 *拒绝所有，添加例外* 的方式，这也是为了方便使用。我们可以根据端口、IP 地址、子网和服务来允许或拒绝连接，这使得我们能够完成主机防火墙功能所需的一切。它还引入了一个叫做丰富规则（rich
    rules）的概念（如本食谱中的示例所示），这使得我们能够创建复杂的规则，并具有细致的粒度控制。这些规则可以基于源地址、目的地址、端口、协议、服务、端口转发和每个子网的伪装。它们可以用于速率限制，允许我们设置每分钟接受的
    SSH 连接数为 5 或 10，从而使得对我们的 Linux 服务器进行 SSH 暴力破解攻击变得更加困难。总的来说，这是一个经过深思熟虑、功能丰富的防火墙，并且是免费的。我们只需要进行配置。
- en: '`ufw`, being just a frontend of `iptables` – or, as people usually describe
    it, a command-line interface for `iptables` – is less feature-packed, but is definitely
    easier to configure, at least for the most commonly used scenarios. Its command-line
    interface is more human-readable (less complex) and easier to learn. Seeing that
    it''s just a frontend for `iptables`, it''s basically a user-space utility that
    manages Linux kernel filtering rules provided by the netfilter module stack.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`ufw` 作为 `iptables` 的前端——或者像人们常说的，`iptables` 的命令行接口——虽然功能相对较少，但绝对更容易配置，至少对于最常见的场景来说是如此。它的命令行接口更具可读性（更简单），也更容易学习。既然它只是
    `iptables` 的前端，本质上是一个用户空间的工具，用来管理由 netfilter 模块堆栈提供的 Linux 内核过滤规则。'
- en: Now that we have discussed some key concepts in Linux firewalling, it's time
    to move on to our next recipe, which is about checking open ports and connections.
    Let's see what that's all about.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了Linux防火墙的一些关键概念，是时候进入下一个操作步骤，学习如何检查开放的端口和连接。让我们看看具体内容。
- en: There's more
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'If you need to learn more about `firewalld` and `ufw`, we recommend the following
    links:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要了解更多关于`firewalld`和`ufw`的内容，建议查看以下链接：
- en: '`firewall-cmd`: [https://firewalld.org/documentation/man-pages/firewall-cmd.html](https://firewalld.org/documentation/man-pages/firewall-cmd.html%0D)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firewall-cmd`: [https://firewalld.org/documentation/man-pages/firewall-cmd.html](https://firewalld.org/documentation/man-pages/firewall-cmd.html%0D)'
- en: 'A beginner''s guide to `firewalld` in Linux: [https://www.redhat.com/sysadmin/beginners-guide-firewalld](https://www.redhat.com/sysadmin/beginners-guide-firewalld%0D)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux中`firewalld`的新手指南：[https://www.redhat.com/sysadmin/beginners-guide-firewalld](https://www.redhat.com/sysadmin/beginners-guide-firewalld%0D)
- en: '`firewalld` rich language: [https://firewalld.org/documentation/man-pages/firewalld.richlanguage.html](https://firewalld.org/documentation/man-pages/firewalld.richlanguage.html%0D)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firewalld`丰富语言：[https://firewalld.org/documentation/man-pages/firewalld.richlanguage.html](https://firewalld.org/documentation/man-pages/firewalld.richlanguage.html%0D)'
- en: '`ufw`: [https://help.ubuntu.com/community/UFW](https://help.ubuntu.com/community/UFW%0D)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ufw`: [https://help.ubuntu.com/community/UFW](https://help.ubuntu.com/community/UFW%0D)'
- en: Working with open ports and connections
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用开放端口和连接
- en: Checking open ports on our local and/or remote machine is often part of security
    and configuration auditing processes. It's something that we use to check if we
    can connect to some remote ports to verify that a service works, whether a firewall
    is configured properly, or whether routing works – just regular, everyday tasks.
    Of course, it can also be a part of some hacking processes, which often start
    by using `nmap` and similar utilities to check for open ports and OS fingerprints.
    But, let's check how we can use utilities such as `netstat`, `lsof`, `ss`, and
    `nmap` to do good for our network and security.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 检查本地和/或远程机器的开放端口通常是安全性和配置审计过程的一部分。这是我们用来检查是否能够连接到某些远程端口，验证服务是否正常工作，防火墙是否配置正确，或路由是否正常工作的操作——就是常规的日常任务。当然，它也可能是一些黑客攻击过程的一部分，这些过程通常开始于使用`nmap`和类似工具检查开放端口和操作系统指纹。但让我们看看如何使用`netstat`、`lsof`、`ss`和`nmap`等工具来为我们的网络和安全带来益处。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Keep the client1 virtual machine powered on and let''s continue using our shell.
    Generally speaking, if we''re doing this on Ubuntu, we need to install some packages
    such as `traceroute` and `nmap` using `apt-get`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 保持client1虚拟机开机，继续使用我们的Shell。一般来说，如果我们在Ubuntu上进行操作，我们需要使用`apt-get`安装一些软件包，如`traceroute`和`nmap`：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If, however, we are using CentOS, we need to use `yum` or `dnf`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用的是CentOS，我们需要使用`yum`或`dnf`：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After that, we are ready for our recipe.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们就可以开始我们的操作步骤了。
- en: How to do it
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let''s first learn the usual ways of checking which ports and sockets are opened
    on our local Linux machine, starting with the `netstat` command. Yes, it''s a
    common thing to check the routing table with `netstat` (the `netstat -rn` command),
    but we can also learn many more interesting details about our local Linux machine
    by using it in a different way. First, let''s check all opened connections and
    ports by using the `netstat -a` command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解一下检查本地Linux机器上哪些端口和套接字已打开的常用方法，从`netstat`命令开始。是的，使用`netstat`（`netstat
    -rn`命令）检查路由表是常见的操作，但通过以不同的方式使用它，我们还可以了解更多有关本地Linux机器的有趣细节。首先，使用`netstat -a`命令检查所有打开的连接和端口：
- en: '![Figure 4.16 – A part of the netstat -a output – the result is much longer
    so we stripped it a bit for formatting reasons'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.16 – netstat -a 输出的一部分 – 由于结果非常长，我们为了格式化的原因略作简化'
- en: '](img/Figure_4.16_B16269.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.16_B16269.jpg)'
- en: Figure 4.16 – A part of the netstat -a output – the result is much longer so
    we stripped it a bit for formatting reasons
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – netstat -a 输出的一部分 – 由于结果非常长，我们为了格式化的原因略作简化
- en: 'A lot of details are here. Let''s see if we can format that a bit better. First,
    let''s show all opened TCP ports by using the `netstat -atp` command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多细节。让我们看看能否将其格式化得更好一些。首先，使用`netstat -atp`命令显示所有打开的TCP端口：
- en: '![Figure 4.17 – netstat with the TCP port list'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.17 – netstat 显示TCP端口列表'
- en: '](img/Figure_4.17_B16269.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.17_B16269.jpg)'
- en: Figure 4.17 – netstat with the TCP port list
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – netstat 显示TCP端口列表
- en: 'Then, let''s show the same thing, but for opened UDP ports, by using the `netstat
    -aup` command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`netstat -aup`命令显示相同内容，但针对打开的UDP端口：
- en: '![Figure 4.18 – netstat with the UDP port list'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.18 – 使用 netstat 查看 UDP 端口列表'
- en: '](img/Figure_4.18_B16269.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.18_B16269.jpg)'
- en: Figure 4.18 – netstat with the UDP port list
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – 使用 netstat 查看 UDP 端口列表
- en: 'We can also show a subset of the information above in terms of listening ports
    (a port that an application or process is listening on). That''s what the `netstat
    -l` command is all about:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以按监听端口（一个应用程序或进程正在监听的端口）来显示上述信息的子集。这就是 `netstat -l` 命令的作用：
- en: '![Figure 4.19 – Checking listening ports via netstat'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.19 – 使用 netstat 查看监听端口'
- en: '](img/Figure_4.19_B16269.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.19_B16269.jpg)'
- en: Figure 4.19 – Checking listening ports via netstat
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – 使用 netstat 查看监听端口
- en: 'We can do similar things with `ss` and `lsof`. Let''s first use `ss`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `ss` 和 `lsof` 做类似的操作。让我们首先使用 `ss`：
- en: '![Figure 4.20 – Checking active connections via ss'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.20 – 使用 ss 查看活动连接'
- en: '](img/Figure_4.20_B16269.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.20_B16269.jpg)'
- en: Figure 4.20 – Checking active connections via ss
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 – 使用 ss 查看活动连接
- en: 'Next on our list is `lsof`, a command that can be used to determine which files
    are being opened by their corresponding processes:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要讨论的是 `lsof`，一个可以用来确定哪些文件正被相应进程打开的命令：
- en: '![Figure 4.21 – The same idea as ss, but with more details about actual commands/services
    using ports'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.21 – 与 ss 相同的思路，但提供了更多关于实际命令/服务使用端口的详细信息'
- en: '](img/Figure_4.21_B16269.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.21_B16269.jpg)'
- en: Figure 4.21 – The same idea as ss, but with more details about actual commands/services
    using ports
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 – 与 ss 相同的思路，但提供了更多关于实际命令/服务使用端口的详细信息
- en: 'The options that we used are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的选项如下：
- en: '`-n` for using port numbers, not port names'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n` 用来使用端口号，而不是端口名称'
- en: '`-P` for using numerical addresses, without DNS resolving'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-P` 用于使用数值地址，而不进行 DNS 解析'
- en: '`-iTCP` `-sTCP:LISTEN` to show only files that have an opened port in the TCP
    state `LISTEN`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-iTCP` `-sTCP:LISTEN` 用来仅显示处于 `LISTEN` 状态的打开端口的文件'
- en: 'Then, if we wanted to narrow that down to a specific TCP port – for example,
    port `22` – we could use a command such as `lsof -nP -iTCP:22 -sTCP:LISTEN`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们想将其缩小到特定的 TCP 端口——例如端口 `22`——我们可以使用类似 `lsof -nP -iTCP:22 -sTCP:LISTEN`
    的命令：
- en: '![Figure 4.22 – Narrowing the lsof output to TCP port 22 only'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.22 – 将 lsof 输出缩小到仅显示 TCP 端口 22'
- en: '](img/Figure_4.22_B16269.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.22_B16269.jpg)'
- en: Figure 4.22 – Narrowing the lsof output to TCP port 22 only
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22 – 将 lsof 输出缩小到仅显示 TCP 端口 22
- en: 'If we need to check opened ports specified by port range, `lsof` allows that,
    by using the `lsof -i` option. For example, let''s use that on port range `22`
    to `1000`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要检查由端口范围指定的开放端口，`lsof` 可以通过使用 `lsof -i` 选项来实现。例如，我们可以对 `22` 到 `1000` 端口范围使用这个选项：
- en: '![Figure 4.23 – lsof by port range'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.23 – 按端口范围使用 lsof'
- en: '](img/Figure_4.23_B16269.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.23_B16269.jpg)'
- en: Figure 4.23 – lsof by port range
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.23 – 按端口范围使用 lsof
- en: Now that we've used some commands on our local machine, let's turn our attention
    to remote machines and discuss how to find open ports on them, as well as other
    information that might be necessary. For that, we are going to use the `nmap`
    command. Let's first use client1 (IP address `192.168.1.1`) to scan `server1`
    (IP address `192.168.1.254`). `server1` is just a vanilla CentOS 8 installation,
    as explained in the last recipe of this chapter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地机器上使用了一些命令，接下来让我们关注远程机器，并讨论如何在它们上查找开放端口以及其他可能需要的信息。为此，我们将使用 `nmap`
    命令。首先让我们使用客户端1（IP 地址 `192.168.1.1`）扫描 `server1`（IP 地址 `192.168.1.254`）。`server1`
    只是一个普通的 CentOS 8 安装，如本章最后一节所解释的。
- en: 'First, let''s do a general scan, by using the `nmap 192.168.1.254` command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们进行一次常规扫描，使用 `nmap 192.168.1.254` 命令：
- en: '![Figure 4.24 – Using nmap on a single IP address'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.24 – 对单个 IP 地址使用 nmap'
- en: '](img/Figure_4.24_B16269.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.24_B16269.jpg)'
- en: Figure 4.24 – Using nmap on a single IP address
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.24 – 对单个 IP 地址使用 nmap
- en: 'If we wanted a bit more verbosity, we could''ve added the `-v` option before
    or after the IP address, as well. Still, we can see that the remote IP address
    has a couple of open TCP ports. Let''s try to find some more information, by initiating
    `nmap` with the `-A` option (OS information scan):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望输出更多的信息，可以在 IP 地址前后加上 `-v` 选项。不过，我们仍然可以看到远程 IP 地址有几个开放的 TCP 端口。接下来我们可以尝试通过使用
    `-A` 选项启动 `nmap`（操作系统信息扫描）来获取更多信息：
- en: '![Figure 4.25 – More detailed version of the previous nmap session'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.25 – 上一次 nmap 会话的更详细版本'
- en: '](img/Figure_4.25_B16269.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.25_B16269.jpg)'
- en: Figure 4.25 – More detailed version of the previous nmap session
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.25 – 上一次 nmap 会话的更详细版本
- en: 'We can see even more details on this output. If we just wanted to do OS fingerprinting,
    we could''ve used the `-O` option:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到更多关于输出的细节。如果我们仅想进行操作系统指纹识别，我们可以使用 `-O` 选项：
- en: '![Figure 4.26 – nmap OS fingerprinting'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.26 – nmap 操作系统指纹识别'
- en: '](img/Figure_4.26_B16269.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.26_B16269.jpg)'
- en: Figure 4.26 – nmap OS fingerprinting
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.26 – nmap 操作系统指纹识别
- en: 'We could also scan for various other things, such as the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以扫描其他一些内容，例如以下内容：
- en: Specific TCP ports – `nmap -p T:9090,22 192.168.1.254`
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定 TCP 端口 – `nmap -p T:9090,22 192.168.1.254`
- en: Specific UDP ports – `nmap -sU 53 192.168.1.254`
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定 UDP 端口 – `nmap -sU 53 192.168.1.254`
- en: Scan port range – `nmap -p 22-2000 192.168.1.254`
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描端口范围 – `nmap -p 22-2000 192.168.1.254`
- en: Find remote host service versions – `nmap -sV 192.168.1.254`
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找远程主机服务版本 – `nmap -sV 192.168.1.254`
- en: Scan a subnet – `nmap 192.168.1.*`
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描子网 – `nmap 192.168.1.*`
- en: Scan multiple hosts – `nmap 192.168.1.252,253,254`
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描多个主机 – `nmap 192.168.1.252,253,254`
- en: Scan a complete IP range – `nmap 192.168.1.1-254`
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描完整的 IP 范围 – `nmap 192.168.1.1-254`
- en: Let's now discuss how these four utilities work and wrap this recipe up.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论这四个工具如何工作，并总结这个操作方法。
- en: How it works
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: '`netstat`, `ss`, and `lsof` are kind of similar, yet have their differences.
    The usual way in which people use `netstat` is just to check their routing table.
    But, having said that, by default, `netstat` is a tool that gives us a list of
    opened TCP sockets/UDP connections on the network layer. `lsof`, on the other
    hand, lists open files (kernel-level functionality), but it''s also capable of
    determining which processes are using those opened files. Keep in mind that, in
    Unix operating systems, almost everything is a file, which also includes objects
    such as network sockets. As such, `lsof` is often used when dealing with security
    aspects of our Linux systems, as it obviously gives many more technical details
    when compared to `netstat`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`netstat`、`ss` 和 `lsof` 是类似的工具，但它们也各有不同。人们通常使用 `netstat` 来查看其路由表。但需要指出的是，默认情况下，`netstat`
    是一个可以列出网络层上已打开的 TCP 套接字/UDP 连接的工具。另一方面，`lsof` 列出了已打开的文件（内核级功能），但它还能够确定哪些进程正在使用这些已打开的文件。请记住，在
    Unix 操作系统中，几乎一切都是文件，其中也包括网络套接字等对象。因此，`lsof` 经常用于处理 Linux 系统的安全相关事项，因为与 `netstat`
    相比，它显然能提供更多的技术细节。'
- en: '`ss`, as an alternative to `netstat`, can be used to work with network information
    and statistics, which makes it kind of similar to `netstat`. It can be used to
    get details about network connections, sockets, statistical data, TCP state filtering,
    connections to and from specific IP addresses, and so on. And, not to be forgotten,
    `ss` is quite a bit simpler to use, and when you compare man page sizes of `netstat`
    and `ss`, you''ll see the difference there as well.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`ss`，作为 `netstat` 的替代，可以用于处理网络信息和统计数据，这使得它与 `netstat` 有些相似。它可以用于获取有关网络连接、套接字、统计数据、TCP
    状态过滤、与特定 IP 地址的连接等详细信息。而且，不容忽视的是，`ss` 使用起来要简单得多，比较 `netstat` 和 `ss` 的 man 页，你也能看到它们之间的差异。'
- en: '`nmap`, on the other hand, is completely different from all of these commands.
    It''s a tool that''s aimed much more broadly in terms of functionality – it can
    scan both local and remote hosts, domains, IP ranges, and ports. It''s a regular
    network scanner, with all the good and the bad that comes with it, as people both
    love and dislike it – love using it, dislike being the target of it. It works
    by establishing connections to remote IP addresses and ports, sending them information
    and gathering output from them to get information. Therefore, it''s a perfect
    tool to do security scanning and auditing as it''s able to find open ports and
    report the fact that there are open ports. It''s also heavily used to search for
    certain security issues.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`nmap` 与所有这些命令完全不同。它是一个功能更加广泛的工具——它可以扫描本地和远程主机、域名、IP 范围和端口。它是一个常规的网络扫描器，既有优点也有缺点，人们既喜欢使用它，也不喜欢成为它的目标。它通过与远程
    IP 地址和端口建立连接，向其发送信息并收集输出信息来获取数据。因此，它是进行安全扫描和审计的完美工具，因为它能够发现开放的端口并报告这些开放端口的事实。它也被广泛用于寻找某些安全问题。'
- en: There's more
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'If you need to learn more about `netstat`, `lsof`, `ss`, and `nmap`, make sure
    that you check the following links:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要了解更多关于 `netstat`、`lsof`、`ss` 和 `nmap` 的信息，请确保查看以下链接：
- en: '`nmap` documentation: [https://nmap.org/docs.html](https://nmap.org/docs.html%0D)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nmap` 文档：[https://nmap.org/docs.html](https://nmap.org/docs.html%0D)'
- en: '`netstat` man page: [https://man7.org/linux/man-pages/man8/netstat.8.html](https://man7.org/linux/man-pages/man8/netstat.8.html%0D)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`netstat`手册页：[https://man7.org/linux/man-pages/man8/netstat.8.html](https://man7.org/linux/man-pages/man8/netstat.8.html%0D)'
- en: '`lsof` man page: [https://man7.org/linux/man-pages/man8/lsof.8.html](https://man7.org/linux/man-pages/man8/lsof.8.html%0D)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lsof`手册页：[https://man7.org/linux/man-pages/man8/lsof.8.html](https://man7.org/linux/man-pages/man8/lsof.8.html%0D)'
- en: '`ss` man page: [https://man7.org/linux/man-pages/man8/ss.8.html](https://man7.org/linux/man-pages/man8/ss.8.html%0D)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ss`手册页：[https://man7.org/linux/man-pages/man8/ss.8.html](https://man7.org/linux/man-pages/man8/ss.8.html%0D)'
- en: Configuring /etc/hosts and DNS resolving
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置`/etc/hosts`和DNS解析
- en: Name resolution is an essential part of any operating system, specifically its
    networking stack. Generally speaking, operating systems have multiple different
    ways of making DNS queries – usually, it involves some kind of `hosts` file, caches,
    and – of course – network interface configuration. Let's go through the configuration
    capabilities of `/etc/hosts` and see how that fits in the grand scheme of name
    resolution.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 名称解析是任何操作系统，特别是其网络堆栈中的一个重要部分。一般来说，操作系统有多种不同的方式来执行DNS查询——通常，这涉及到某种类型的`hosts`文件、缓存，以及——当然——网络接口配置。让我们看看`/etc/hosts`的配置能力，了解它如何融入名称解析的整体方案。
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Keep the CLI1 virtual machine powered on and let's discuss how to work with
    name resolution in general, using `/etc/hosts` (a file that we can fill with hostnames
    and IP addresses for local resolving) and `/etc/resolv.conf` (a file that determines
    which DNS servers are being used for network resolving, and which domain is the
    Linux server a part of) as integral parts of that process. When editing `/etc/hosts`
    or `/etc/resolv.conf`, we have to be logged in as root or use `sudo`, as this
    is a system-wide operation that's only allowed to administrative users. The way
    in which the name resolution process works changed years ago as `systemd` took
    over from `init` and `upstart`, and introduced a service called `systemd-resolved`.
    On top of this, the configuration is different on Ubuntu when compared to CentOS.
    So, let's dig into all of that and explain what's going on.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 保持CLI1虚拟机开机，我们来讨论如何处理名称解析的问题，使用`/etc/hosts`（一个可以填充主机名和IP地址以进行本地解析的文件）和`/etc/resolv.conf`（一个决定使用哪个DNS服务器进行网络解析、以及Linux服务器属于哪个域的文件），它们是这个过程的核心部分。当编辑`/etc/hosts`或`/etc/resolv.conf`时，我们必须以root身份登录或使用`sudo`，因为这是一个系统范围的操作，只有管理员用户才能执行。名称解析过程的工作方式在多年前发生了变化，当时`systemd`取代了`init`和`upstart`，并引入了名为`systemd-resolved`的服务。除此之外，Ubuntu和CentOS的配置方式也不同。那么，让我们深入探讨这些内容，解释一下发生了什么。
- en: How to do it
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let''s first take care of Ubuntu, then we''ll switch to CentOS. This is the
    default `/etc/resolv.conf` file from our Ubuntu CLI1 machine:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先处理Ubuntu的情况，然后再切换到CentOS。这是我们Ubuntu CLI1机器上的默认`/etc/resolv.conf`文件：
- en: '![Figure 4.27 – Default /etc/resolv.conf file'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.27 – 默认的`/etc/resolv.conf`文件'
- en: '](img/Figure_4.27_B16269.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.27_B16269.jpg)'
- en: Figure 4.27 – Default /etc/resolv.conf file
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27 – 默认的`/etc/resolv.conf`文件
- en: 'As we can see, this file is mostly commented out (the `#` sign in config files
    equals a Unix shell-style comment, so these lines are omitted in terms of configuration).
    We only have two configuration lines, which are a by-product of running the systemd-resolved
    service (a local service that provides resolving capabilities for DNS, DNS over
    TLS, DNSSEC, mDNS, and so on), as well as using the netplan service by default:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个文件大部分被注释掉了（配置文件中的`#`符号表示Unix Shell风格的注释，因此这些行在配置中被省略）。我们只有两行配置，这是运行systemd-resolved服务（一个本地服务，提供DNS解析、DNS
    over TLS、DNSSEC、mDNS等功能）以及默认使用netplan服务时的副产品：
- en: '[PRE21]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are two approaches to `resolv.conf` configuration:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以配置`resolv.conf`：
- en: We say that we want to stick with systemd-resolved and configure our system
    that way (and `127.0.0.53` is actually the loopback IP address that systemd-resolved
    binds to).
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们说过，我们希望坚持使用systemd-resolved，并以这种方式配置我们的系统（而`127.0.0.53`实际上是systemd-resolved绑定的回环IP地址）。
- en: We say that we don't want systemd-resolved and we want to go back to the *old
    way* of configuring our system, which means installing a package called `resolvconf`.
    That will give us the capability to configure `/etc/resolv.conf` and `/etc/hosts`
    as they were always configured and not rely on systemd-resolved making changes
    to `/etc/resolv.conf` on the fly (most of us usually don't want this).
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们说我们不想使用 systemd-resolved，想回到*旧方式*来配置系统，这意味着安装一个名为 `resolvconf` 的包。这样我们就可以像过去一样配置
    `/etc/resolv.conf` 和 `/etc/hosts`，而不依赖 systemd-resolved 动态更改 `/etc/resolv.conf`（大多数情况下我们并不希望这样做）。
- en: Let's start with the first approach and then move to the second approach as
    a lot of us Linux administrators are more prone to using our old-school ways and
    we find it easier for things to be configured the way they have always been configured
    since the dawn of Unix time.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从第一种方法开始，然后再转到第二种方法，因为我们很多 Linux 管理员更倾向于使用传统的方式，觉得按 Unix 时代开始时的配置方式进行配置更加容易。
- en: 'If we are using systemd-resolved, we need to mention a couple of files. The
    first file that we need to mention is `/run/systemd/resolve/stub-resolv.conf`
    – this is a file that''s actually linked to `/etc/resolv.conf` when systemd-resolved
    is being used. This file is used for maintaining compatibility with old Linux
    programs that were exclusively using the old way (`/etc/resolv.conf`, `/etc/hosts`)
    to get access to name resolution information. If we want to permanently set DNS
    servers to be used, we need to do it via `systemd`. So, let''s go to the second
    file that we need to discuss. It''s located in the `/etc/systemd` directory, and
    it''s called `resolved.conf`. At the beginning of this file, there''s a `[Resolve]`
    section that''s completely commented out. Let''s change it to this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 systemd-resolved，我们需要提到几个文件。我们首先需要提到的文件是 `/run/systemd/resolve/stub-resolv.conf`
    —— 这是一个实际与 `/etc/resolv.conf` 链接的文件，当使用 systemd-resolved 时。该文件用于保持与旧版 Linux 程序的兼容性，这些程序仅使用旧方法（`/etc/resolv.conf`，`/etc/hosts`）来访问名称解析信息。如果我们想永久设置
    DNS 服务器，必须通过 `systemd` 来实现。那么，我们来看一下第二个文件，它位于 `/etc/systemd` 目录下，名为 `resolved.conf`。在该文件的开头，有一个完全被注释掉的
    `[Resolve]` 部分。让我们将其修改为如下：
- en: '[PRE22]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first and second lines set the main and fallback DNS addresses, while the
    third line sets the default domain that we're querying.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行和第二行设置了主要的和备用的 DNS 地址，而第三行设置了我们查询的默认域名。
- en: 'After we do this change, we need to restart the `systemd-resolved` service,
    which we can do with the following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这些更改后，我们需要重启 `systemd-resolved` 服务，可以通过以下命令完成：
- en: '[PRE23]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can check if our changes have been applied by using `systemd-resolve --status`,
    which should, in accordance with our changes, give us output similar to this one:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `systemd-resolve --status` 来检查我们的更改是否已应用，根据我们的更改，应该会显示类似以下内容的输出：
- en: '![Figure 4.28 – Checking the systemd-resolved status'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.28 – 检查 systemd-resolved 状态](img/Figure_4.28_B16269.jpg)'
- en: '](img/Figure_4.28_B16269.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.29 – 检查 DNS 缓存](img/Figure_4.29_B16269.jpg)'
- en: Figure 4.28 – Checking the systemd-resolved status
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.28 – 检查 systemd-resolved 状态
- en: 'Let''s now check how the DNS cache works – for example, we type in the following
    commands:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们检查 DNS 缓存的工作原理——例如，我们输入以下命令：
- en: '[PRE24]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We did this so that we can check the DNS cache, as the DNS cache first needs
    to be filled with some data at least. If we want to check the state of the `systemd-resolved`
    cache, we can do it with two commands:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了检查 DNS 缓存，因为 DNS 缓存至少需要先填充一些数据。如果我们想检查 `systemd-resolved` 缓存的状态，可以使用两个命令：
- en: '[PRE25]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first command doesn''t kill `systemd-resolved` but tells it to write available
    entries in the DNS cache. The second command exports entries to a file called
    `cache.txt` (it can be called whatever we want). When we check the content of
    that file for the string `CACHE`, we''re going to see entries similar to this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令不会终止 `systemd-resolved`，而是告诉它将可用条目写入 DNS 缓存。第二个命令将条目导出到名为 `cache.txt` 的文件中（我们可以任意命名）。当我们检查该文件中包含
    `CACHE` 字符串的内容时，我们会看到类似于以下的条目：
- en: '![Figure 4.29 – Checking the DNS cache'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.29 – 检查 DNS 缓存](img/Figure_4.29_B16269.jpg)'
- en: '](img/Figure_4.29_B16269.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.29 – 检查 DNS 缓存](img/Figure_4.29_B16269.jpg)'
- en: Figure 4.29 – Checking the DNS cache
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.29 – 检查 DNS 缓存
- en: 'This is correct – on our testing system, those are two entries that we searched
    for by using `nslookup`. If we want to flush the DNS cache, we can use the following
    command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正确的——在我们的测试系统中，这两条是我们通过 `nslookup` 查询的条目。如果我们想刷新 DNS 缓存，可以使用以下命令：
- en: '[PRE26]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you notice errors with DNS violations in the file, there was a problem during
    the system installation or upgrade – one that didn''t set a symbolic link to `resolv.conf`
    properly. As a result of that problem, the symbolic link was created to the wrong
    file (`stub-resolv.conf`) instead of the actual file `(/run/systemd/resolve/resolv.conf`).
    We can mitigate that issue by using the following commands:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到文件中有 DNS 违规错误，说明在系统安装或升级过程中出现了问题——没有正确设置 `resolv.conf` 的符号链接。由于这个问题，符号链接被创建到了错误的文件（`stub-resolv.conf`），而不是实际的文件（`/run/systemd/resolve/resolv.conf`）。我们可以通过以下命令来缓解这个问题：
- en: '[PRE27]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s try the second approach, which is quite a bit more simple. So,
    if we wanted to get rid of all of this `systemd-resolved` configuration and just
    use a good old administration process via `resolv.conf` without all of this additional
    hassle, we could do that easily. So, let''s first install the necessary package:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试第二种方法，这种方法要简单得多。所以，如果我们想摆脱所有这些 `systemd-resolved` 配置，只通过传统的 `resolv.conf`
    管理流程，而不涉及这些额外的麻烦，我们完全可以轻松做到。首先，让我们安装必要的包：
- en: '[PRE28]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, let''s do a bit of configuration. Let''s open the `/etc/resolv.conf`
    file and make it look like this (the commented part is not important, start with
    the `nameserver` part):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进行一些配置。我们打开 `/etc/resolv.conf` 文件，并将其配置如下（注释部分不重要，从 `nameserver` 部分开始）：
- en: '![Figure 4.30 – The resolv.conf configuration'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.30 – resolv.conf 配置'
- en: '](img/Figure_4.30_B16269.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.30_B16269.jpg)'
- en: Figure 4.30 – The resolv.conf configuration
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.30 – resolv.conf 配置
- en: 'Let''s check if this configuration works:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下这个配置是否有效：
- en: '![Figure 4.31 – Checking if DNS resolution works'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.31 – 检查 DNS 解析是否有效'
- en: '](img/Figure_4.31_B16269.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.31_B16269.jpg)'
- en: Figure 4.31 – Checking if DNS resolution works
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.31 – 检查 DNS 解析是否有效
- en: No problem whatsoever, right? Of course, we used `8.8.8.8`, `8.8.4.4`, and `1.1.1.1`
    as examples for DNS servers here – this needs to be configured so that it's valid
    for the environment where our Linux server is actually running.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 完全没有问题，对吧？当然，我们在这里使用了 `8.8.8.8`、`8.8.4.4` 和 `1.1.1.1` 作为 DNS 服务器的示例——这些需要根据我们
    Linux 服务器实际运行的环境进行配置。
- en: 'Working with the DNS cache requires a bit of extra effort. First, we need to
    deploy two additional packages – `nscd` (the service that does the caching), and
    `binutils` (this package contains a command called `strings`, which we''ll use
    to check string content in a binary file):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与 DNS 缓存打交道需要额外的努力。首先，我们需要部署两个额外的包——`nscd`（负责缓存的服务）和 `binutils`（这个包包含了一个叫做 `strings`
    的命令，我们将用它来检查二进制文件中的字符串内容）：
- en: '[PRE29]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output of the second command should look similar to this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令的输出应该类似于以下内容：
- en: '![Figure 4.32 – Checking the nscd cache'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.32 – 检查 nscd 缓存'
- en: '](img/Figure_4.32_B16269.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.32_B16269.jpg)'
- en: Figure 4.32 – Checking the nscd cache
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.32 – 检查 nscd 缓存
- en: 'If we need to clear the `nscd` `hosts` cache, we can use the following commands:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要清除 `nscd` `hosts` 缓存，可以使用以下命令：
- en: '[PRE30]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: or
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE31]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first one just clears the hosts table, while the second one restarts the
    `nscd` service and, as a part of the process, clears the `hosts` table.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令只是清空 hosts 表，而第二个命令则重启 `nscd` 服务，并在此过程中清空 `hosts` 表。
- en: 'And that brings us to the hosts table, and – luckily – it works the same on
    all Linux distributions. If we''re in a situation where we just need to add some
    resolving capabilities without actually building up a DNS server via `BIND`, `dnsmasq`,
    or anything similar to that, using the `hosts` table seems like a reasonably simple
    thing to do. Let''s say that we need to use temporary resolution for the following
    two hosts:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了 hosts 表，而且——幸运的是——在所有 Linux 发行版上都是一样的。如果我们只需要添加一些解析功能，而不打算通过 `BIND`、`dnsmasq`
    或类似工具构建一个 DNS 服务器，使用 `hosts` 表似乎是一个相对简单的选择。假设我们需要为以下两个主机进行临时解析：
- en: '`server1.domain.local`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`server1.domain.local`'
- en: '`server2.domain.local`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`server2.domain.local`'
- en: 'Let''s assume that these two servers'' IP addresses are `192.168.0.101` and
    `192.168.0.102`. We''d add these entries to the `/etc/hosts` file by editing it
    and adding these entries to the bottom of the file:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这两个服务器的 IP 地址分别是 `192.168.0.101` 和 `192.168.0.102`。我们通过编辑 `/etc/hosts` 文件并将这些条目添加到文件底部来进行配置：
- en: '`192.168.0.101 server1.domain.local`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`192.168.0.101 server1.domain.local`'
- en: '`192.168.0.102 server2.domain.local`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`192.168.0.102 server2.domain.local`'
- en: 'So, our `/etc/hosts` file should look like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的 `/etc/hosts` 文件应该像这样：
- en: '![Figure 4.33 – /etc/hosts file with additions'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.33 – 添加了条目的 /etc/hosts 文件'
- en: '](img/Figure_4.33_B16269.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.33_B16269.jpg)'
- en: Figure 4.33 – /etc/hosts file with additions
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.33 – /etc/hosts 文件和新增内容
- en: 'If we now use a command such as `ping` to check if these hosts are alive, we
    will get the following result:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在使用类似 `ping` 的命令来检查这些主机是否可用，我们将得到如下结果：
- en: '![Figure 4.34 – ping not working'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.34 – ping 无法工作'
- en: '](img/Figure_4.34_B16269.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.34_B16269.jpg)'
- en: Figure 4.34 – ping not working
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.34 – ping 无法工作
- en: The `^C` character visible in this output is due to the fact that we used *Ctrl*
    + *C* to stop the ping process as these hosts don't actually exist on our network.
    But that's beside the point – the point of this was to test whether the name resolution
    works. In other words, does `server1` and `server2.domain.local` resolution work?
    And it does – we can clearly see that the `ping` command is trying to ping their
    IP addresses.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中可见的 `^C` 字符是因为我们使用了 *Ctrl* + *C* 来停止 ping 进程，因为这些主机实际上并不存在于我们的网络中。但这不是重点——重点是测试名称解析是否有效。换句话说，`server1`
    和 `server2.domain.local` 的解析是否有效？答案是有效的——我们可以清楚地看到 `ping` 命令正在尝试 ping 它们的 IP 地址。
- en: We need to briefly discuss the way in which CentOS does these things, as it's
    a bit different from what Ubuntu does. By default, the latest couple of generations
    of CentOS use NetworkManager as the default service to configure a network. As
    a result, `/etc/resolv.conf` gets configured by NetworkManager by default, which
    is very important to note, especially in the most common use case – when our CentOS
    machine gets its IP address from the DHCP server. What happens if we need to configure
    custom DNS servers and we don't want to use the DNS servers that we got from our
    DHCP server?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要简要讨论 CentOS 是如何做这些事情的，因为它与 Ubuntu 的做法有些不同。默认情况下，CentOS 的最新几代使用 NetworkManager
    作为默认服务来配置网络。因此，`/etc/resolv.conf` 默认由 NetworkManager 配置，这一点非常重要，尤其是在最常见的使用场景中——当我们的
    CentOS 机器从 DHCP 服务器获取 IP 地址时。如果我们需要配置自定义 DNS 服务器，而又不想使用从 DHCP 服务器获得的 DNS 服务器，应该怎么办呢？
- en: 'There are two basic ways to make sure that everything''s configured correctly
    in CentOS:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 中，确保一切配置正确有两种基本方式：
- en: To configure everything via interface files
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过接口文件配置一切
- en: To configure everything after the fact, by using the `nmcli` command
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `nmcli` 命令配置一切
- en: 'Using configuration files is a hassle here, so let''s just do the second thing
    – configure our DNS entries by using the `nmcli` command. Let''s say that we want
    to assign `8.8.8.8`, `8.8.4.4`, and `1.1.1.1` as DNS servers for our CentOS server.
    Let''s check our network interface name first:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置文件在这里是很麻烦的，所以我们直接做第二种方法——通过 `nmcli` 命令配置我们的 DNS 记录。假设我们想为 CentOS 服务器分配 `8.8.8.8`、`8.8.4.4`
    和 `1.1.1.1` 作为 DNS 服务器。首先，让我们检查一下网络接口名称：
- en: '[PRE32]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our system tells us that it''s using the `ens33` network interface. Let''s
    modify its settings by typing in the following commands:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统告诉我们正在使用 `ens33` 网络接口。让我们通过输入以下命令来修改它的设置：
- en: '[PRE33]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The key aspect of this configuration is the first line – we're basically telling
    NetworkManager to quit automatically using the DNS server that it gets from the
    DHCP server. If we didn't want that, we could've just omitted that specific line.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置的关键在于第一行——我们基本上是在告诉 NetworkManager 停止自动使用从 DHCP 服务器获取的 DNS 服务器。如果我们不想这样做，可以省略这一行。
- en: 'If we check the contents of our `/etc/resolv.conf` file, it should now look
    like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查 `/etc/resolv.conf` 文件的内容，它现在应该是这样的：
- en: '![Figure 4.35 – /etc/resolv.conf configured correctly'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.35 – /etc/resolv.conf 配置正确'
- en: '](img/Figure_4.35_B16269.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.35_B16269.jpg)'
- en: Figure 4.35 – /etc/resolv.conf configured correctly
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.35 – /etc/resolv.conf 配置正确
- en: And that's a wrap in terms of configuration – using both Ubuntu and CentOS.
    Let's now focus on how all of this works *under the hood*.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 配置工作已经完成——无论是在 Ubuntu 还是 CentOS 上。接下来我们来关注一下这一切是如何在 *幕后* 工作的。
- en: How it works
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: There are two concepts that we need to dig into and explain. We need to understand
    how `systemd-resolved` works, and, of course, the opposite – how everything works
    when we remove `systemd-resolved` from the administrative equation, if you will.
    Having in mind that there was Linux before systemd and name resolution before
    `systemd-resolved`, let's start by explaining how the *old method* (pre-systemd-resolved)
    worked.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要深入理解并解释两个概念。我们需要了解 `systemd-resolved` 是如何工作的，当然，反过来也需要了解——当我们将 `systemd-resolved`
    从管理方程中去除时，所有的工作是如何进行的。考虑到在 systemd 和 `systemd-resolved` 之前就有 Linux 和名称解析，首先我们来解释一下
    *旧方法*（即在 systemd-resolved 之前的做法）是如何工作的。
- en: 'The core concept was called the `/etc/passwd`, `/etc/shadow`, and `/etc/group`),
    network configuration, and, of course, services such as name resolution (`/etc/hosts`
    and so on). Our focus will be solely on name resolution, which is why we need
    to discuss a configuration file, `/etc/nsswitch.conf`. Specifically, we will ignore
    all of the configuration options in that file and focus on one configuration line,
    which is usually similar to this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 核心概念包括 `/etc/passwd`、`/etc/shadow` 和 `/etc/group`、网络配置，以及当然还有服务，比如名称解析（`/etc/hosts`
    等）。我们的重点将仅放在名称解析上，这也是我们需要讨论配置文件 `/etc/nsswitch.conf` 的原因。具体来说，我们将忽略该文件中的所有配置选项，专注于一行配置，这行通常像这样：
- en: '[PRE34]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This configuration line tells our name resolution system *how* to do its job.
    The `files` option means *check file /etc/hosts*, while the `dns` option means
    just that – use other network name resolution methods. But the important thing
    about this line is the *order*, which clearly states *files first, dns second*.
    This is the reason why – by default – Linux first checks the contents of the `/etc/hosts`
    file, and then starts issuing network name resolution calls (for example, `nslookup`)
    to get to the IP address of some server that we're trying to communicate with.
    We also have capabilities to store these entries in a database, and we can force
    NSS to access it to read the necessary data. For example, 20 years ago, when Active
    Directory and other LDAP-based directories weren't used so often, we used to use
    NIS/NIS+ a lot – to store user and similar data. We were also able to store host
    data in NIS/NIS+ databases (`hosts.byname` and `hosts.byaddr`). These maps were
    basically forward and reverse DNS tables, stored within an external service. That's
    why we can use the configuration option `db` in `nsswitch.conf`, although pretty
    much nobody uses that nowadays.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这一配置行告诉我们的名称解析系统 *如何* 执行其工作。`files` 选项意味着 *检查文件 /etc/hosts*，而 `dns` 选项意味着就如其字面意思——使用其他网络名称解析方法。但这行的关键在于
    *顺序*，它清晰地表示 *文件优先，dns 次之*。这也是为什么在默认情况下，Linux 会首先检查 `/etc/hosts` 文件的内容，然后才开始发出网络名称解析请求（例如，`nslookup`），以获取我们要连接的服务器的
    IP 地址。我们还可以将这些条目存储在数据库中，并强制 NSS 访问它以读取必要的数据。例如，20 年前，当 Active Directory 和其他基于
    LDAP 的目录尚未普及时，我们通常使用 NIS/NIS+ 来存储用户和类似的数据。我们还可以在 NIS/NIS+ 数据库中存储主机数据（`hosts.byname`
    和 `hosts.byaddr`）。这些映射基本上是存储在外部服务中的正向和反向 DNS 表。正因如此，我们可以在 `nsswitch.conf` 中使用配置选项
    `db`，尽管现在几乎没有人使用这个选项了。
- en: When systemd took over name resolution (`systemd-resolved`), things changed,
    as we described in our last recipe. The whole point of `systemd-resolved` is to
    be able to better integrate with systemd and to offer support for some use cases
    that were – realistically – complicated without it. Stuff such as VPN connections,
    especially corporate ones, were a constant source of problems when using the old-style
    configuration. `systemd-resolved` tries to get around that stack of problems (and
    others) by introducing the capability to do split DNS, which is implemented by
    using DNS routing domains as a way of determining which DNS requests we're actually
    making. Please don't mistake this for IP-based ideas of subnet routing, VLAN routing,
    or anything of the sort – those are completely different concepts, based on completely
    different ideas. We're specifically talking about the DNS routing domain, which
    is nothing more than a term saying *let's determine which DNS server should be
    contacted for correct information about your DNS query*. This has nothing to do
    with the IP aspect of it, which is handled by using standard routing methods.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `systemd` 接管了名称解析（`systemd-resolved`）后，情况发生了变化，正如我们在上一篇教程中所描述的那样。`systemd-resolved`
    的核心目的是能够更好地与 `systemd` 集成，并为一些在没有它的情况下实际复杂的使用场景提供支持。例如，VPN 连接，特别是企业级的 VPN，在使用旧式配置时总是会出现问题。`systemd-resolved`
    试图通过引入分割 DNS 功能来解决这堆问题（以及其他问题），这一功能是通过使用 DNS 路由域来确定我们实际发出的 DNS 请求。请不要把这与基于 IP
    的子网路由、VLAN 路由或类似的概念混淆——那些是完全不同的概念，基于完全不同的思路。我们这里特别讨论的是 DNS 路由域，它只是一个术语，意思是 *让我们确定应该联系哪个
    DNS 服务器，以获取关于你的 DNS 查询的正确信息*。这与 IP 方面无关，IP 部分是通过使用标准的路由方法来处理的。
- en: Having split DNS is nothing new – it's something that a lot of us have been
    using for a decade or two. In short, split DNS means having some DNS servers assigned
    to internal connections and other DNS servers assigned to external connections.
    From an enterprise standpoint, if we connect via VPN connection to our workplace,
    a part of our DNS queries is aimed at internal infrastructure, while the other
    part should be headed to the external DNS servers hosted on the internet. Being
    able to implement this scenario in Linux also isn't something new – we could've
    easily done this with `BIND` more than a decade ago. But a way to do this as tightly
    integrated and as automatically as possible, especially on the client side – which
    is what `systemd-resolved` does – is actually something new.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有分割 DNS 并不是什么新鲜事——我们中的很多人已经使用了十多年。简而言之，分割 DNS 意味着将一些 DNS 服务器分配给内部连接，而将其他 DNS
    服务器分配给外部连接。从企业的角度来看，如果我们通过 VPN 连接到工作场所，我们的一部分 DNS 查询是针对内部基础设施的，而另一部分则应该指向互联网上托管的外部
    DNS 服务器。在 Linux 中实现这一场景也不是什么新事物——我们早在十多年前就可以轻松使用 `BIND` 来实现。但一种更紧密集成、尽可能自动化的方式，特别是在客户端这一侧——这正是
    `systemd-resolved` 所做的——其实是全新的。
- en: Let's imagine for a second that we have a Linux VPN server that we're connecting
    to by using a Linux machine as a VPN client. Let's say that these two systems
    both have multiple network interfaces in different subnets (a couple of physical
    network cards and a wireless network adapter for the VPN client). When we connect
    from our VPN client to the VPN server, how is the VPN client going to determine
    where to send DNS queries? Yes, it's going to use `resolv.conf`, but still, `resolv.conf`
    and `systemd-resolved` need to be configured correctly so that a name resolution
    request gets sent to the correct DNS server. If we have multiple subnets, and
    multiple domains (a larger enterprise, for example), things can get messy very
    quickly. This situation gets taken care of via NetworkManager/netplan's interaction
    with `systemd-resolved`. By using this interaction, we can have different DNS
    servers assigned to different network interfaces, that are assigned to multiple
    different domains. And that's a pretty smart way of dealing with potential VPN
    client problems.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设一下，我们有一台 Linux VPN 服务器，我们通过一台 Linux 机器作为 VPN 客户端来连接它。假设这两个系统都在不同子网中有多个网络接口（VPN
    客户端有几张物理网卡和一个无线网络适配器）。当我们从 VPN 客户端连接到 VPN 服务器时，VPN 客户端将如何决定将 DNS 查询发送到哪里？是的，它会使用
    `resolv.conf`，但仍然需要正确配置 `resolv.conf` 和 `systemd-resolved`，这样名称解析请求才能发送到正确的 DNS
    服务器。如果我们有多个子网和多个域（例如，大型企业），事情会很快变得混乱。这个问题通过 NetworkManager/netplan 与 `systemd-resolved`
    的互动来解决。通过这种互动，我们可以将不同的 DNS 服务器分配给不同的网络接口，并为多个不同的域分配不同的 DNS 服务器。这是一种非常聪明的方式来处理潜在的
    VPN 客户端问题。
- en: There's more
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: 'If we need to learn more about network name resolution, we can check the following
    links:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要了解更多关于网络名称解析的信息，可以查看以下链接：
- en: 'What is DNS?: [https://www.cloudflare.com/learning/dns/what-is-dns/](https://www.cloudflare.com/learning/dns/what-is-dns/%0D)'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '什么是 DNS?: [https://www.cloudflare.com/learning/dns/what-is-dns/](https://www.cloudflare.com/learning/dns/what-is-dns/%0D)'
- en: 'What is DNS?: [https://aws.amazon.com/route53/what-is-dns/](https://aws.amazon.com/route53/what-is-dns/%0D)'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '什么是 DNS?: [https://aws.amazon.com/route53/what-is-dns/](https://aws.amazon.com/route53/what-is-dns/%0D)'
- en: 'NSCD man page, chapter 8: [https://linux.die.net/man/8/nscd](https://linux.die.net/man/8/nscd%0D)'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NSCD 手册页，第 8 章: [https://linux.die.net/man/8/nscd](https://linux.die.net/man/8/nscd%0D)'
- en: '`systemd-resolved` man page: [http://manpages.ubuntu.com/manpages/bionic/man8/systemd-resolved.service.8.html](http://manpages.ubuntu.com/manpages/bionic/man8/systemd-resolved.service.8.html%0D)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd-resolved` 手册页: [http://manpages.ubuntu.com/manpages/bionic/man8/systemd-resolved.service.8.html](http://manpages.ubuntu.com/manpages/bionic/man8/systemd-resolved.service.8.html%0D)'
- en: '`resolved.conf` man page: [https://www.freedesktop.org/software/systemd/man/resolved.conf.html](https://www.freedesktop.org/software/systemd/man/resolved.conf.html%0D)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resolved.conf` 手册页: [https://www.freedesktop.org/software/systemd/man/resolved.conf.html](https://www.freedesktop.org/software/systemd/man/resolved.conf.html%0D)'
- en: Using network diagnostic tools
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网络诊断工具
- en: Diagnosing problems with network connections is an everyday job for a seasoned
    system engineer. It doesn't necessarily happen because we have problems in our
    own network, it can be other factors. For example, sometimes our local network
    works, while the internet connection doesn't. Or, even worse, customers report
    that some of them are able to access the internet, while some others can't. How
    do we approach these situations and which tools should we use? That's what we
    will talk about in this recipe. So, get ready to talk about `ping`, `route`, `netstat`,
    `tracepath`, and similar commands – that's what they're there for!
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 诊断网络连接问题是资深系统工程师的日常工作。这并不一定是因为我们自己的网络出现问题，也可能是其他因素。例如，有时我们的本地网络工作正常，但互联网连接却无法使用。更糟糕的是，客户反映有些客户能够访问互联网，而有些却无法访问。我们应该如何应对这些情况，使用哪些工具呢？这正是我们将在本节中讨论的内容。所以，准备好讨论`ping`、`route`、`netstat`、`tracepath`等命令吧——它们就是为了解决这些问题而存在的！
- en: Getting ready
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's install a CentOS virtual machine called `server1` and use our existing
    clients (an Ubuntu virtual machine called client1 and a CentOS virtual machine
    called client2) to work on this recipe. We are going to use client1 to simulate
    a situation where the server on our local network wants to access internal resources
    and/or the internet by using `server1` as a default gateway. We are going to use
    client2 to simulate a situation where our local client or wireless client wants
    to access internal resources and/or the internet by using `server1` as a default
    gateway. In order for us to be able to do that, we'll temporarily add another
    network interface to client2, so that we can have two network interfaces in two
    different subnets to simulate problems in our scenario. The `server1` virtual
    machine is just going to be a standard CentOS installation, but with four network
    interfaces. In our scenario, `server1`'s `ens33` network interface is going to
    be an external network interface, while network interfaces `ens37`, `ens38`, and
    `ens39` are going to be internal network interfaces.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装一台名为`server1`的CentOS虚拟机，并使用我们现有的客户端（分别为一台名为client1的Ubuntu虚拟机和一台名为client2的CentOS虚拟机）来操作本节内容。我们将使用client1模拟一个情境，即本地网络中的服务器希望通过将`server1`设置为默认网关来访问内部资源和/或互联网。我们将使用client2模拟另一种情境，即本地客户端或无线客户端希望通过将`server1`设置为默认网关来访问内部资源和/或互联网。为了实现这一点，我们将临时为client2添加另一个网络接口，这样我们就可以在两个不同的子网中拥有两个网络接口，模拟场景中的问题。`server1`虚拟机将是一个标准的CentOS安装，但带有四个网络接口。在我们的场景中，`server1`的`ens33`网络接口将作为外部网络接口，而`ens37`、`ens38`和`ens39`网络接口将作为内部网络接口。
- en: How to do it
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let''s create a scenario here so that we can go through the whole process.
    For example, our colleagues from the company that we work for are reporting that
    they have problems accessing both internal resources (the company network) and
    external resources (the internet). The company that we''re discussing has multiple
    network subnets:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个场景，完整地演示整个过程。例如，我们公司的一些同事报告说，他们在访问内部资源（公司网络）和外部资源（互联网）时遇到问题。我们讨论的这家公司有多个网络子网：
- en: '`192.168.1.0/24` – This one is used for all of the server machines; we''ll
    call this connection profile `network1` when we configure it via `nmcli`.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.1.0/24` – 这个子网用于所有服务器机器；我们在通过`nmcli`配置时将其称为`network1`。'
- en: '`192.168.2.0/24` – This one is used for all of the client machines; we''ll
    call this connection profile `network2` when we configure it via `nmcli`.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.2.0/24` – 这个子网用于所有客户端机器；我们在通过`nmcli`配置时将其称为`network2`。'
- en: '`192.168.3.0/24` – This one is used for company wireless; we''ll call this
    connection profile `network3` when we configure it via `nmcli`.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.3.0/24` – 这个子网用于公司无线网络；我们在通过`nmcli`配置时将其称为`network3`。'
- en: The fourth network interface of our machine is going to act as our internet
    connection. As we mentioned in our second recipe in this chapter (*Using firewalld
    and ufw*), let's configure that virtual machine so that it allows connectivity
    for all three of these subnets to the internet and work from there.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们机器的第四个网络接口将作为我们的互联网连接。正如我们在本章的第二节中提到的（*使用firewalld和ufw*），让我们配置这台虚拟机，使其允许所有三个子网连接到互联网并正常工作。
- en: 'The first step will obviously be to allow internet access for these three subnets.
    Let''s do that in the simplest fashion, by using `firewalld`. Specifically, we''ll
    do that by adding these interfaces to the public zone. So, we need a couple of
    standard commands and configuration steps on `server1`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步显然是允许这三个子网访问互联网。我们将采用最简单的方式，通过使用 `firewalld` 来实现。具体来说，我们将通过将这些接口添加到公共区域来实现这一点。因此，我们需要在
    `server1` 上执行一些标准命令和配置步骤：
- en: '[PRE35]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If our configuration is correct, when we type in the `nmcli con show` command,
    we should have something like this (depending on how we configured our external
    network on `ens33` – and in our virtual machine, it''s using the `192.168.159.0/24`
    network):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的配置正确，当我们输入 `nmcli con show` 命令时，应该会看到类似这样的输出（具体取决于我们如何在 `ens33` 上配置外部网络，在我们的虚拟机中，它使用的是
    `192.168.159.0/24` 网络）：
- en: '![Figure 4.36 – Checking our NM connection setup'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.36 – 检查我们的 NM 连接设置'
- en: '](img/Figure_4.36_B16269.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.36_B16269.jpg)'
- en: Figure 4.36 – Checking our NM connection setup
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.36 – 检查我们的 NM 连接设置
- en: 'Also, if we check routing information by using the `ip route` command, we should
    get something similar to this:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们通过 `ip route` 命令检查路由信息，应该会得到类似这样的输出：
- en: '![Figure 4.37 – Checking our routes'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.37 – 检查我们的路由'
- en: '](img/Figure_4.37_B16269.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.37_B16269.jpg)'
- en: Figure 4.37 – Checking our routes
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.37 – 检查我们的路由
- en: 'So, we have our three subnets, the routes are configured accordingly, now we
    need to configure `server1` to act as a router. Let''s type in the following commands
    to set our interfaces to specific zones:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了三个子网，路由已相应配置，现在我们需要配置 `server1` 作为路由器。输入以下命令，将我们的接口设置到特定的区域：
- en: '[PRE36]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When we type in the last command, we should get output similar to this:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入最后一个命令时，应该会看到类似这样的输出：
- en: '![Figure 4.38 – The firewall-cmd --list-all output'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.38 – firewall-cmd --list-all 输出'
- en: '](img/Figure_4.38_B16269.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.38_B16269.jpg)'
- en: Figure 4.38 – The firewall-cmd --list-all output
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.38 – firewall-cmd --list-all 输出
- en: 'On client1, we need to do a bit of reconfiguration as well, as it was initially
    set up to use DHCP to get the IP address. First, let''s install the `traceroute`
    package by typing in the following command:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在 client1 上，我们还需要进行一些重新配置，因为它最初是设置为使用 DHCP 获取 IP 地址的。首先，输入以下命令安装 `traceroute`
    包：
- en: '[PRE37]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After that, let''s configure this Linux virtual machine so that its IP address
    is `192.168.1.1/24` and apply that configuration. First, we need to edit netplan''s
    configuration file. For simplicity reasons, let''s just use the default configuration
    file, `/etc/netplan/00-installer-config.yaml`. It needs to have the following
    content applied via the `netplan apply` command:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们配置这台 Linux 虚拟机，使其 IP 地址为 `192.168.1.1/24` 并应用该配置。首先，我们需要编辑 netplan 配置文件。为了简便起见，我们就使用默认的配置文件
    `/etc/netplan/00-installer-config.yaml`。它需要通过 `netplan apply` 命令应用以下内容：
- en: '``'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '``'
- en: '![Figure 4.39 – The netplan configuration file'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.39 – netplan 配置文件'
- en: '](img/Figure_4.39_B16269.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.39_B16269.jpg)'
- en: Figure 4.39 – The netplan configuration file
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.39 – netplan 配置文件
- en: 'Let''s now test if internet access from this machine works. As noted on the
    screenshot shown previously, we''re using `server1` as the default gateway (`192.168.1.254`):'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试一下从这台机器能否访问互联网。如前所述，我们使用 `server1` 作为默认网关（`192.168.1.254`）：
- en: '![Figure 4.40 – Checking the configuration works'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.40 – 检查配置是否正常'
- en: '](img/Figure_4.40_B16269.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.40_B16269.jpg)'
- en: Figure 4.40 – Checking the configuration works
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.40 – 检查配置是否正常
- en: 'So, connectivity works. Let''s now configure client2\. Our CentOS virtual machine
    called `client2` has a network interface called `ens39`. Let''s set it up so that
    it''s a part of the `network2` subnet (we defined that subnet on `server1`). Let''s
    say client2 is going to temporarily use `192.168.2.2/24` as its IP address:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，连接正常。现在让我们配置 client2。我们的 CentOS 虚拟机 `client2` 有一个网络接口叫做 `ens39`。我们将它设置为 `network2`
    子网的一部分（我们在 `server1` 上定义了该子网）。假设 client2 将临时使用 `192.168.2.2/24` 作为它的 IP 地址：
- en: '[PRE38]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We previously configured `server1` to act as a default gateway, and, as a result,
    `client1` and `client2` can happily use it as a default gateway and access the
    external network. We can easily test that by using `ping`. Let''s use `client2`
    as an example:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经将 `server1` 配置为默认网关，因此 `client1` 和 `client2` 可以愉快地将其作为默认网关并访问外部网络。我们可以通过
    `ping` 命令轻松测试这一点。我们以 `client2` 为例：
- en: '![Figure 4.41 – Checking the configuration works after configuration changes'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.41 – 配置更改后检查配置是否正常'
- en: '](img/Figure_4.41_B16269.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.41_B16269.jpg)'
- en: Figure 4.41 – Checking the configuration works after configuration changes
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.41 – 配置更改后检查配置是否正常工作
- en: 'Now that we have verified that everything is configured correctly, let''s now
    check a few different scenarios that might require additional network troubleshooting:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了所有配置都正确，让我们现在检查一些可能需要额外网络故障排除的不同场景：
- en: '`ping` to an external host is not working, but external network access works.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ping`到外部主机不工作，但外部网络访问正常。'
- en: External network access is not working.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部网络访问不正常。
- en: Can't route between two subnets.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法在两个子网之间路由。
- en: Name resolution not working properly.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称解析未正常工作。
- en: 'Let''s start with the first scenario. Usually, this is a firewall configuration
    setting (we''re not calling it a problem on purpose). Let''s first ping a site
    that we want to access:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个场景开始。通常，这是防火墙配置设置（我们特意不称其为问题）。让我们首先ping一下我们想要访问的网站：
- en: '![Figure 4.42 – Scenario start – ping doesn''t work'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.42 – 场景开始 – ping 不工作'
- en: '](img/Figure_4.42_B16269.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.42_B16269.jpg)'
- en: Figure 4.42 – Scenario start – ping doesn't work
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.42 – 场景开始 – ping 不工作
- en: 'At the same time, if we try to browse `packtpub.com` from our web browser,
    that works without any problems:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，如果我们尝试从浏览器访问`packtpub.com`，则没有任何问题：
- en: '![Figure 4.43 – It works in the browser'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.43 – 浏览器中可以工作'
- en: '](img/Figure_4.43_B16269.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.43_B16269.jpg)'
- en: Figure 4.43 – It works in the browser
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.43 – 浏览器中可以工作
- en: This type of problem is common – and from the output of `ping`, we can see that
    the firewall that we're passing on the way from our client2 to `packtpub.com`
    is filtering `ping` (**ICMP**, or **Internet Control Message Protocol**) traffic.
    This is nothing to be worried about, although it might be confusing. We need to
    keep in mind that ping/ICMP traffic has nothing to do with HTTP(S)/TCP traffic
    and that these protocols can be filtered separately. This is exactly what was
    done here – ping/ICMP traffic was filtered, while HTTP(S)/TCP traffic wasn't.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的问题很常见 – 从`ping`的输出中，我们可以看到，从我们的client2到`packtpub.com`的路径上经过的防火墙在过滤`ping`（**ICMP**，或**Internet
    Control Message Protocol**）流量。这没有什么好担心的，尽管可能会有些困惑。我们需要记住，ping/ICMP流量与HTTP(S)/TCP流量无关，这些协议可以分别进行过滤。这正是这里所做的
    – 过滤了ping/ICMP流量，而HTTP(S)/TCP流量则没有被过滤。
- en: 'Let''s pile up additional complexity now and go through a scenario where external
    network access isn''t available. Let''s try pinging one of Google''s DNSes from
    client2 and `server1`, just to see the symptoms:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们增加一些复杂性，通过一个外部网络访问不可用的场景来进行一些检测，让我们尝试从client2和`server1` ping Google的DNS之一，只是为了看看症状：
- en: '![Figure 4.44 – External network access doesn''t work'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.44 – 外部网络访问不工作'
- en: '](img/Figure_4.44_B16269.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.44_B16269.jpg)'
- en: Figure 4.44 – External network access doesn't work
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.44 – 外部网络访问不工作
- en: It's one thing if the network client (client2) can't get to the external network.
    It's a completely different thing if the default gateway (in our case, `server1`)
    can't get to the external network. That points to a bigger problem, and if we
    didn't touch the firewall configuration and other network devices, it's probably
    some kind of a problem either with connectivity to the **Internet Service Provider**
    (**ISP**), or something on the ISP's end.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网络客户端（client2）无法访问外部网络，那是一回事。如果默认网关（在我们这里是`server1`）无法访问外部网络，那就完全不同了。这指向了一个更大的问题，如果我们没有触及防火墙配置和其他网络设备，那可能是与**互联网服务提供商**（**ISP**）的连接或ISP端的某些问题。
- en: 'We could do a bit more detective work by using additional tools, such as **traceroute**
    or **tracepath**:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用额外的工具，如**traceroute**或**tracepath**，进行更多的侦探工作：
- en: '![Figure 4.45 – Further verification that external network access doesn''t
    work'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.45 – 进一步验证外部网络访问不工作'
- en: '](img/Figure_4.45_B16269.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.45_B16269.jpg)'
- en: Figure 4.45 – Further verification that external network access doesn't work
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.45 – 进一步验证外部网络访问不工作
- en: 'If we are using external DNS servers, we could even use the `nslookup`, `host`,
    or `dig` commands to almost conclusively determine that the problem lies with
    internet access, not our client or server:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用外部 DNS 服务器，甚至可以使用`nslookup`、`host`或`dig`命令几乎可以确定问题在于互联网访问，而非我们的客户端或服务器：
- en: '![Figure 4.46 – resolv.conf is configured correctly; DNS name resolution doesn''t
    work'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.46 – resolv.conf 配置正确；DNS 名称解析不工作'
- en: '](img/Figure_4.46_B16269.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.46_B16269.jpg)'
- en: Figure 4.46 – resolv.conf is configured correctly; DNS name resolution doesn't
    work
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.46 – resolv.conf 配置正确；DNS 名称解析不工作
- en: 'Let''s say that the problem was that a cable connecting from our `server1`
    to the ISP router broke down. When we change that cable, `ping` should work perfectly,
    as shown here:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 假设问题出在连接 `server1` 和 ISP 路由器的那根电缆断了。当我们更换那根电缆时，`ping` 应该能够正常工作，如下所示：
- en: '![Figure 4.47 – The connection works again'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.47 – 连接再次正常工作'
- en: '](img/Figure_4.47_B16269.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.47_B16269.jpg)'
- en: Figure 4.47 – The connection works again
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.47 – 连接再次正常工作
- en: 'Let''s now check a scenario where we can''t go from one subnet to another subnet.
    We''re going to use network1 and network2 as an example – so, we''re going to
    use client2 (`192.168.2.2/24`) to try to access client1 (`192.168.1.1/24`). As
    these two hosts are *not* a part of the same Layer 2 network, we have to have
    some kind of mechanism to *route* traffic between them. Let''s check if that routing
    configuration works properly:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一个无法从一个子网到另一个子网的场景。我们将以 network1 和 network2 为例 —— 所以，我们将使用 client2（`192.168.2.2/24`）来尝试访问
    client1（`192.168.1.1/24`）。由于这两个主机*不*属于同一个第二层网络，我们必须有某种机制来*路由*它们之间的流量。让我们检查一下路由配置是否正常：
- en: '![Figure 4.48 – Routing across subnets working'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.48 – 跨子网的路由工作正常'
- en: '](img/Figure_4.48_B16269.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.48_B16269.jpg)'
- en: Figure 4.48 – Routing across subnets working
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.48 – 跨子网的路由工作正常
- en: 'As previously configured, we allowed the forwarding of traffic between all
    of the networks on `server1`. We achieved that by allowing masquerading and putting
    all interfaces in the public `firewalld` zone. Sometimes when we configure our
    routing devices, we make mistakes. The results of our mistakes might be that two
    networks can''t communicate with each other anymore (usually two VLANs, as we
    are discussing an internal networking scenario here). Let''s see the symptoms:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前所配置，我们允许在 `server1` 上转发所有网络之间的流量。我们通过允许伪装（masquerading）并将所有接口放入公共 `firewalld`
    区域来实现这一点。有时候，当我们配置路由设备时，会犯一些错误。我们的错误可能导致两个网络之间无法再进行通信（通常是两个 VLAN，因为我们在这里讨论的是内部网络的场景）。让我们看看症状：
- en: '![Figure 4.49 – Routing doesn''t work anymore'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.49 – 路由不再工作'
- en: '](img/Figure_4.49_B16269.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.49_B16269.jpg)'
- en: Figure 4.49 – Routing doesn't work anymore
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.49 – 路由不再工作
- en: 'If we check our routing table by using the `netstat -rn` command, we can see
    the following information:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过使用 `netstat -rn` 命令检查路由表，我们可以看到以下信息：
- en: '![Figure 4.50 – Checking that routing on our Linux machine is set up properly,
    which it is'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.50 – 检查我们的 Linux 机器上的路由是否设置正确，确实设置正确'
- en: '](img/Figure_4.50_B16269.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.50_B16269.jpg)'
- en: Figure 4.50 – Checking that routing on our Linux machine is set up properly,
    which it is
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.50 – 检查我们的 Linux 机器上的路由是否设置正确，确实设置正确
- en: So, our gateway works (we can ping it), but it doesn't forward us correctly
    to the `192.168.1.0/24` network. Seeing that we configured the `192.168.1.0/24`
    network to be a local network for `server1`, it's clear that we have some kind
    of routing problem here. It could be a `firewalld` misconfiguration, stopping
    `firewalld` as a service, a routing table misconfiguration, or maybe someone played
    with the `/proc` filesystem and set the `ip_forward` flag back to `0`. Whatever
    the case may be, the source of our problem is our default gateway. In larger enterprises,
    we usually have a networking team taking care of these things, so showing them
    output from `ping`, `traceroute`, and `netstat` should tell them where the problem
    is (in their own backyard). We'd usually tell them that they have a VLAN routing
    problem between VLAN X (subnet 1) and VLAN Y (subnet 2), send them outputs of
    these previously mentioned commands, and let them work from there.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的网关是正常工作的（我们可以 ping 通它），但它没有正确地将我们转发到 `192.168.1.0/24` 网络。看到我们将 `192.168.1.0/24`
    网络配置为 `server1` 的本地网络，很明显我们在这里遇到了一些路由问题。可能是 `firewalld` 配置错误，导致 `firewalld` 服务被停止，或者是路由表配置错误，亦或是有人修改了
    `/proc` 文件系统并将 `ip_forward` 标志重置为 `0`。无论是哪种情况，问题的根源在于我们的默认网关。在大型企业中，通常有网络团队负责这些事情，因此将
    `ping`、`traceroute` 和 `netstat` 的输出提供给他们，应该能帮助他们找到问题所在（在他们的责任范围内）。我们通常会告诉他们，在
    VLAN X（子网 1）和 VLAN Y（子网 2）之间存在 VLAN 路由问题，发送这些命令的输出给他们，让他们从那里着手解决。
- en: Let's finish this recipe by talking about a few name resolution issues. These
    issues can happen because of a service misconfiguration (`systemd-resolved`, for
    example), a wrong `/etc/resolv.conf` configuration, and even an `/etc/hosts` configuration
    that we did ourselves. Let's go through a couple of common problems.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过讨论一些名称解析问题来结束这个教程。这些问题可能由于服务配置错误（例如 `systemd-resolved`）、错误的 `/etc/resolv.conf`
    配置，甚至是我们自己配置的 `/etc/hosts` 文件而发生。让我们来看看一些常见问题。
- en: 'First, we are going to edit `/etc/resolv.conf` on client1 and put some custom
    DNS servers there. Then, we are going to reboot our client1 Linux virtual machine
    and see what happens when we check the content of `/etc/resolv.conf`. This screenshot
    is pre-reboot (we added two name servers, `8.8.8.8` and `8.8.4.4`):'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编辑 client1 上的 `/etc/resolv.conf` 并添加一些自定义的 DNS 服务器。然后，我们将重启 client1 的
    Linux 虚拟机，查看在检查 `/etc/resolv.conf` 内容时会发生什么。这是重启前的截图（我们添加了两个名称服务器，`8.8.8.8` 和
    `8.8.4.4`）：
- en: '![Figure 4.51 – Editing /etc/resolv.conf manually'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.51 – 手动编辑 /etc/resolv.conf'
- en: '](img/Figure_4.51_B16269.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.51_B16269.jpg)'
- en: Figure 4.51 – Editing /etc/resolv.conf manually
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.51 – 手动编辑 /etc/resolv.conf
- en: 'This next screenshot was taken post-reboot. We can clearly see that the content
    of this file has been changed:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图是重启后的结果。我们可以清楚地看到，这个文件的内容已经被更改：
- en: '![Figure 4.52 – /etc/resolv.conf after reboot'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.52 – 重启后的 /etc/resolv.conf'
- en: '](img/Figure_4.52_B16269.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.52_B16269.jpg)'
- en: Figure 4.52 – /etc/resolv.conf after reboot
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.52 – 重启后的 /etc/resolv.conf
- en: This was to be expected – as we described in our previous recipe, changing `/etc/resolv.conf`
    on a Linux machine that's running `systemd-resolved` is always going to end like
    this. If we want to change DNS settings, we need to do it properly. That means
    using `nmcli` in CentOS and, in this case, using netplan configuration on Ubuntu.
    This might only be a *local* issue, but it can still have a big impact in various
    scenarios where `split-dns` is involved.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的结果——正如我们在之前的教程中描述的那样，在运行 `systemd-resolved` 的 Linux 机器上更改 `/etc/resolv.conf`
    总是会以这种方式结束。如果我们想要更改 DNS 设置，我们需要正确操作。这意味着在 CentOS 中使用 `nmcli`，在 Ubuntu 中使用 netplan
    配置。这个问题可能只是*本地*问题，但在涉及 `split-dns` 的各种场景中，它仍然可能会产生很大影响。
- en: 'The next problem is going to be about the opposite – let''s say that we installed
    the `resolvconf` package on our Ubuntu machine, disabled `systemd-resolved`, and
    configured `/etc/resolv.conf` like this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的问题将是相反的——假设我们在 Ubuntu 机器上安装了 `resolvconf` 包，禁用了 `systemd-resolved`，并像这样配置了
    `/etc/resolv.conf`：
- en: '![Figure 4.53 – Putting a wrong config option in /etc/resolv.conf'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.53 – 在 /etc/resolv.conf 中放入错误的配置选项'
- en: '](img/Figure_4.53_B16269.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.53_B16269.jpg)'
- en: Figure 4.53 – Putting a wrong config option in /etc/resolv.conf
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.53 – 在 /etc/resolv.conf 中放入错误的配置选项
- en: 'And when we try to resolve something by using the `nslookup`, `host`, or `dig`
    commands, it ends up nowhere, although our internet connection works, as shown
    with our manual DNS server configuration in `nslookup`:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使用 `nslookup`、`host` 或 `dig` 命令解析某些内容时，虽然我们的互联网连接正常（如通过在 `nslookup` 中手动配置
    DNS 服务器所示），但最终什么也解析不出来：
- en: '![Figure 4.54 – The network obviously works, but DNS name resolution doesn''t,'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.54 – 网络显然工作正常，但 DNS 名称解析不行，'
- en: which points us in the right direction
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这指引我们走向正确的方向
- en: '](img/Figure_4.54_B16269.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.54_B16269.jpg)'
- en: Figure 4.54 – The network obviously works, but DNS name resolution doesn't,
    which points us in the right direction
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.54 – 网络显然工作正常，但 DNS 名称解析不行，这指引我们走向正确的方向
- en: 'This clearly points to a wrong DNS server configuration as the internet access
    works, but we can''t resolve a host. It''s obvious that the option that we used
    (`namserver`) is wrong – it has to be `nameserver`. This brings us to the point:
    we always have to make sure that the syntax of our configuration files – in this
    case, `resolv.conf` – is correct. Mistakes are easily made if we are making changes
    by using a text editor, especially when we, for example, ignore red, highlighted
    fields in vi. If we were using commands to configure this and made an error in
    the syntax (`nmcli` or `netplan`), we would have an error somewhere, which would
    be easy to debug.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然指向了错误的 DNS 服务器配置，因为虽然互联网连接正常，但我们无法解析主机。很明显我们使用的选项（`namserver`）是错误的——应该是`nameserver`。这让我们意识到：我们必须始终确保配置文件的语法正确——在这个案例中是`resolv.conf`。如果我们通过文本编辑器进行更改，错误很容易发生，尤其是当我们忽视了例如在
    vi 中标记为红色的高亮字段时。如果我们使用命令来配置并在语法上犯错（例如使用`nmcli`或`netplan`），我们会在某个地方遇到错误，并且这个错误很容易调试。
- en: The last scenario that we are going to work on is a common one for those of
    us dealing with a public website migration from one provider to another, thus
    changing the public IP address. When we are configuring these scenarios, oftentimes
    we need to have the old website running while we test the new website. We could
    have two IP address entries in our public DNS servers pointing to two different
    web servers, but that's not what we're after, ever. It would confuse our website
    visitors and us as well. So, we want to have a quick way of testing the new website
    until it's fully debugged while offering the general public access to the old
    one.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的最后一种情况是，对于那些从一个提供商迁移公共网站到另一个提供商，从而更改公共 IP 地址的人来说，这是一个常见的情况。在配置这些场景时，我们通常需要在测试新网站时保持旧网站的运行。我们可以在公共
    DNS 服务器中有两个 IP 地址条目，指向两个不同的 Web 服务器，但这永远不是我们想要的。这样会让我们的访问者和我们自己都感到困惑。因此，我们希望能有一种快速的方式来测试新网站，直到它完全调试完毕，同时允许公众访问旧网站。
- en: Obviously, the simplest thing to do would be to add an entry to `/etc/hosts`,
    so that it points to the new website. Then, on the same machine where we made
    that change, we can debug our new website as much as we need – the public DNS
    entry still points to the old website, while our local machine goes to the new
    one.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，最简单的做法是向`/etc/hosts`添加一个条目，指向新网站。然后，在我们进行该更改的同一台机器上，我们可以根据需要调试新网站——公共 DNS
    记录仍然指向旧网站，而我们的本地机器则访问新网站。
- en: After the debugging process is done, we need to do a switchover – we need to
    change the public DNS entries and remove the `/etc/hosts` entry on our debugging
    machine. That's an ideal scenario where we can make some mistakes. So, we go to
    our public DNS provider, change the IP address of our website so that it points
    to the new IP, and save the configuration. Then, we go to our local debugging
    machine and remove the `/etc/hosts` entry pointing to the new website, start a
    web browser, point it to our website URL, and – lo and behold – we are still being
    presented with the old website. What is going on here?
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 调试过程完成后，我们需要进行切换——我们需要更改公共 DNS 记录并删除调试机器上的`/etc/hosts`条目。这是一个理想的场景，我们可以在其中犯一些错误。于是，我们去公共
    DNS 提供商处，更改我们网站的 IP 地址，使其指向新的 IP 地址，并保存配置。接着，我们到本地调试机器上，删除指向新网站的`/etc/hosts`条目，启动一个
    Web 浏览器，访问我们网站的 URL——然后，奇迹般地——我们仍然看到的是旧网站。这是怎么回事？
- en: The simple fact is public DNS records need a bit of time to become active. It
    could be a minute, 15 minutes, an hour, a day – depending on how it's configured,
    but still, it needs time. Also, from various parts of the world – if our website
    is for an international audience – it could take different amounts of time to
    synchronize, which is why we have to be armed with patience when dealing with
    scenarios like these as we are probably going to get some emails about this scenario.
    We just need to do these types of configuration changes over the weekend when
    the amount of website visitors is at its lowest, and then sit and wait it out
    for all of the DNS entries to sync. From the time when we changed the DNS entry
    until everything is working, it's out of our hands. It's just the way it works.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的事实是，公共 DNS 记录需要一些时间才能生效。这可能是一分钟、十五分钟、一小时、一天——取决于配置方式，但无论如何，它需要时间。此外，从世界各地的不同地方——如果我们的网站面向国际受众——同步所需的时间可能不同，这也是我们在处理类似情况时需要保持耐心的原因，因为我们可能会收到一些关于此情况的邮件。我们只需要在周末进行这些类型的配置更改，那时网站访问量最低，然后等待所有
    DNS 记录同步。从我们更改 DNS 记录的时刻起，直到一切正常工作，这个过程超出了我们的控制范围。这就是它的工作方式。
- en: As you can clearly see from these examples, there are quite a few different
    scenarios that might come into play as you're administering your Linux servers,
    clients, and networks.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些例子中，您可以清楚地看到，作为 Linux 服务器、客户端和网络的管理员，可能会遇到许多不同的场景。
- en: How it works
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: All of the commands that we covered in this recipe work on the same idea – we
    have a networking stack that is either configured correctly or not. If it is,
    we mostly don't need them, but if something is misconfigured and/or not working
    properly, which can happen for a variety of external reasons as well, then we
    need to know how these commands work.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中讲解的所有命令都基于同一个理念——我们有一个网络栈，它要么配置正确，要么配置错误。如果配置正确，我们通常不需要使用这些命令，但如果某些配置错误和/或无法正常工作，可能是由于各种外部原因导致的，那么我们就需要了解这些命令是如何工作的。
- en: 'If we are discussing networking generally, there are a few well-known concepts:
    the configured IP address, netmask, gateway, DNS server(s), and a fully qualified
    domain name of any given Linux server. Keeping in mind that networks are isolated
    into multiple subnets and that DNS is a hierarchical structure, if any of these
    concepts aren''t configured correctly, we will have issues with network communication.
    That''s why most of us system engineers take extra care to configure all of these
    settings correctly, as it''s a basis for us to not get permanent headaches, if
    you will.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们一般讨论网络，有几个广为人知的概念：配置的IP地址、子网掩码、网关、DNS服务器，以及任何给定Linux服务器的完全合格域名。记住，网络被隔离成多个子网，而DNS是一个层次结构，如果这些概念中的任何一个配置不正确，我们就会遇到网络通信问题。这就是为什么我们大多数系统工程师特别小心地配置所有这些设置，因为它们是避免我们永远头疼的基础。
- en: When we do `ping`, `traceroute`, and `tracepath`, all of the traffic that we
    generate by using those utilities either goes to our local network or to non-local
    networks, which requires routing. On top of routing, firewalls might get in the
    way – sometimes people configure firewalls with ICMP traffic denied.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`ping`、`traceroute`和`tracepath`时，我们生成的所有流量要么到达本地网络，要么到达非本地网络，而后者需要路由。在路由之上，防火墙可能会成为障碍——有时人们会配置防火墙，拒绝ICMP流量。
- en: Then, even if all of that works as it should, there's the DNS, sitting on top
    of it like a Jedi master trying to balance the Force. And sometimes, it just seems
    a bit evil and as if it's bugging us for no reason whatsoever. That's where utilities
    such as `nslookup`, `host`, and `dig` come in handy – so that we can find out
    if it's something *lower* in the networking stack, or if it's the DNS. As we discussed
    in our previous recipe, using `systemd-resolved` changed quite a few things in
    terms of DNS configuration. We must be extra careful to configure things properly
    when we're using it – so, using `nmcli` and netplan's config files. We shouldn't
    just go and start editing files more often than not. That's just going to make
    more problems.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，即使这些都按预期工作，DNS就像一个绝地大师坐在其上，试图平衡“原力”。有时，它似乎有点邪恶，仿佛没有任何原因就来烦我们。这时，像`nslookup`、`host`和`dig`这样的工具就派上用场了——它们可以帮助我们弄清楚问题是出在网络堆栈中的*较低*层，还是出在DNS。正如我们在前面的教程中讨论的，使用`systemd-resolved`改变了DNS配置的许多方面。当我们使用它时，我们必须格外小心配置，否则使用`nmcli`和netplan的配置文件时，我们不应随意去编辑文件。否则只会制造更多问题。
- en: That being said, when we configure everything correctly and some other device
    on the network (our network or an external network) is at fault, things can get
    complicated very quickly. If a device doing network routing (a switch, router,
    Linux server, firewall, or whatever it might be) isn't configured correctly, we
    won't be able to communicate between multiple subnets. Imagine trying to go from
    Paris to Barcelona without knowing the way. There are so many possible ways of
    going from Paris to Barcelona (which we can equate to routing) that we wouldn't
    know which way to go. Usually, we start our debugging process by pinging some
    addresses on our networks (to check that the local network is working properly),
    then the default gateway, and checking if DNS is available as a service. On a
    more personal note, over the years, I have seen students and course attendees
    becoming painfully aware of just how complex DNS is as a system, especially at
    scale. We have a saying here at our college that students repeat over and over
    again – *It's always DNS*. So, we need to make sure that we have strong foundations
    in terms of DNS knowledge and understanding of how routing works. Then everything
    becomes much, much easier, as combining these two concepts can get insanely complicated.
    Especially when there are dynamic routing protocols such as BGP, EIGRP, and OSPF
    involved with split DNS and multiple locations.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，当我们正确配置一切，而网络上的其他设备（无论是我们的网络还是外部网络）出现故障时，问题可能会迅速变得复杂。如果执行网络路由的设备（如交换机、路由器、Linux
    服务器、防火墙等）配置不正确，我们将无法在多个子网之间进行通信。试想一下，如果你不知道路从巴黎到巴塞罗那的路线，如何前往那座城市。就像我们在路由中有许多不同的路径，从巴黎到巴塞罗那有很多可能的路线，我们无法知道选择哪一条。通常，我们的故障排除过程是先通过
    ping 测试网络上的某些地址（检查本地网络是否正常工作），然后检查默认网关，最后确认 DNS 是否作为服务可用。从个人角度来说，多年来我看到学生和课程参与者越来越清楚地意识到，DNS
    作为一个系统有多复杂，尤其是在大规模部署时。我们学校有一句话，学生们总是反复说——*总是 DNS*。因此，我们需要确保我们在 DNS 知识和理解路由工作原理方面有坚实的基础。这样，一切就变得简单多了，因为将这两个概念结合起来可能会变得极其复杂，尤其是在涉及到动态路由协议，如
    BGP、EIGRP 和 OSPF，同时又有分割 DNS 和多个位置的情况下。
- en: And that's a wrap for this chapter. The next chapter is going to be all about
    using the shell to manage software packages on our Linux systems. We are going
    to discuss how to use `apt` and `apt-get`, `yum`, and `dnf`, software repositories,
    and other subjects related to software management. Until then, we bid you adieu!
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到此结束。下一章将全部介绍如何使用 shell 来管理我们 Linux 系统上的软件包。我们将讨论如何使用`apt`和`apt-get`、`yum`以及`dnf`，软件仓库，以及与软件管理相关的其他主题。在那之前，我们向你告别！
- en: There's more
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'If you need to learn more about network debugging, you can check the following
    links:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要学习更多关于网络故障排除的知识，可以查看以下链接：
- en: 'A beginner''s guide to network troubleshooting in Linux: [https://www.redhat.com/sysadmin/beginners-guide-network-troubleshooting-linux](https://www.redhat.com/sysadmin/beginners-guide-network-troubleshooting-linux%0D)'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 网络故障排除初学者指南：[https://www.redhat.com/sysadmin/beginners-guide-network-troubleshooting-linux](https://www.redhat.com/sysadmin/beginners-guide-network-troubleshooting-linux%0D)
- en: 'Five Linux network troubleshooting commands: [https://www.redhat.com/sysadmin/five-network-commands](https://www.redhat.com/sysadmin/five-network-commands%0D)'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 五个 Linux 网络故障排除命令：[https://www.redhat.com/sysadmin/five-network-commands](https://www.redhat.com/sysadmin/five-network-commands%0D)
