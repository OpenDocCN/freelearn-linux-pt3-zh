- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter aims to provide insight into our (the authors’) personal experience
    in working with embedded devices and embedded Linux development over the years.
    We have gathered some aspects that are often underestimated or wholly neglected
    to serve as inspiration for you in your next project.
  prefs: []
  type: TYPE_NORMAL
- en: We have split this chapter into two independent parts, one about the guidelines
    related to the Yocto Project specifics and the other about more general aspects
    of a project. This is so that you don’t have to study the two sections in a particular
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines to follow for Yocto Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section aims to gather some guidelines for aspects of the Yocto Project
    metadata and project organization tips that make our life easier in terms of short-
    and long-term maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Managing layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As our journey in product development advances, we will naturally use multiple
    repositories to meet the needs we face. Keeping track of the repositories is a
    complex challenge as we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure we can reproduce a previous build in the future
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow multiple team members to work in the same code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate the changes we make using Continuous Integration tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid subtle changes in the layers we use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those goals are intimidating, but a few tools are in use, with different strategies
    to overcome those challenges.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest solution uses the `image-buildinfo` class ([https://docs.yoctoproject.org/4.0.4/ref-manual/classes.html#image-buildinfo-bbclass](https://docs.yoctoproject.org/4.0.4/ref-manual/classes.html#image-buildinfo-bbclass)),
    which writes a plain text file containing build information and layers revisions
    to the target filesystem at `${sysconfdir}/buildinfo` by default. Some tools have
    been developed that can help this process. These tools are discussed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Google developed the **repo** ([https://source.android.com/docs/setup/download#repo](https://source.android.com/docs/setup/download#repo))
    tool for Android development. It has been adopted for use in other projects. A
    critical aspect of repo is that it requires some tooling to integrate with Yocto
    Project-based projects to automate the build directory and environment configuration.
    See the *O.S. Systems Embedded Linux project* ([https://github.com/OSSystemsEmbeddedLinux/ossystems-embedded-linux-platform](https://github.com/OSSystemsEmbeddedLinux/ossystems-embedded-linux-platform))
    as inspiration for using repo in your projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Siemens developed **kas** ([https://github.com/siemens/kas](https://github.com/siemens/kas))
    to provide an easy mechanism for downloading sources, automating the build directory
    and environment configuration, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garmin developed **Whisk** ([https://github.com/garmin/whisk](https://github.com/garmin/whisk))
    to manage complex product configurations using OpenEmbedded and the Yocto Project.
    The key features are a single source tree, multiple axes of configuration, multiple
    product builds, isolated layer configuration, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agilent developed **Yocto Buddy** ([https://github.com/Agilent/yb](https://github.com/Agilent/yb)).
    The design aims to ease the setup and keep Yocto Project-based environments synchronized.
    Yocto Buddy was inspired by all previously mentioned tools and is still early
    in development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a subset of existing tools and shouldn’t be considered a complete list.
    Ideally, you should play with them before deciding, as the choice depends on the
    project use case and team expertise.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid creating too many layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A significant advantage of the Yocto Project is that it has the ability to
    use and create multiple layers. It allows us to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reuse BSP layers from semiconductor vendors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce duplication of work by sharing reusable blocks to enable the use of new
    or specific applications, programming languages, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, creating multiple layers may be unproductive when developing a project
    or a set of products. For example, the development of BSP-only layers makes sense
    in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: The board is the product, as in the **System on Module** (**SoM**) vendors’
    case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When external access to the layer is critical, however, we want to limit the
    access for the non-BSP source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using a single layer for the product, or even the company, has many advantages,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Facilitating the development of reusable components such as a `packagegroup`
    package for development tools or network utilities shared by multiple products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the risk of unexpected side effects due to changes for a specific product
    or board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing the reuse of bug fixes across multiple products and reuse of BSP
    low-level components such as the Linux kernel or bootloader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boosting standardization across multiple products, reducing the learning curve
    for new team members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decision to use one or more layers depends on several aspects; however,
    we recommend starting simple and, in the future, splitting the layer if required.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare the product metadata for new Yocto Project releases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As our product grows, so does our metadata and the need for good organization.
    Some use cases commonly seen during product development are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The need to backport a new recipe version due to a bug fix or a feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A missing package configuration or bug fix is not yet available in the Yocto
    Project recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use two recipe directories to organize this kind of content:'
  prefs: []
  type: TYPE_NORMAL
- en: '`recipes-backport`: Backports of recipes coming from new Yocto Project releases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recipes-staging`: New recipes or `bbappend` files adding missing package configurations
    or bug fixes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We continuously send new recipes or bug fixes from `recipes-staging` to the
    respective upstream project (for example, OpenEmbedded Core). Then, when the patch
    is accepted, we move this change from `recipes-staging` to the `recipes-backport`
    directory. This approach allows us to keep track of pending upstreaming tasks
    and easily upgrade our meta layer to a new Yocto Project release. Furthermore,
    we can quickly act on the backport directory and remove it.
  prefs: []
  type: TYPE_NORMAL
- en: Create your custom distro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using the Yocto Project, we usually add many configurations in `build/conf/local.conf`.
    However, as discussed in the book, this is bad as it is not at source control
    management and is likely to differ among developers. Using a custom distribution
    has many benefits, and some of them are highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows consistent use among multiple developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides a clear view of the different `DISTRO_FEATURES` we use when compared
    to our base distribution (for example, `poky`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides a central place where we can have a global view of all the required
    recipe configurations we need for our product, reducing the number of `bbappend`
    files required to configure our recipes (for example, `PACKAGECONFIG:pn-<myrecipe>:append
    = "` `myfeature"`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides those more technical aspects, using a custom distro also allows the
    proper branding of SDK or other Yocto Project-generated artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to create a custom distribution in the *Using a custom distribution*
    sectiown in [*Chapter 12*](B19361_12.xhtml#_idTextAnchor147), *Creating* *Custom
    Layers*.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid reusing existing images for your product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Images are where everything fits together. When we are developing a product,
    it is important to minimize the number of packages we have installed in our images
    for multiple reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the rootfs size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the build time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the number of licenses to deal with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the surface of attack for security breaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A typical starting point is copying the `core-image-base.bb` file to our custom
    layer as `myproduct-image.bb` and extending it, adding what we need for the product’s
    image. In addition, we create an image called `myproduct-image-dev.bb` for use
    during development and make sure it requires `myproduct-image.bb` along with the
    artifacts used only for development, avoiding code duplication. This way, we have
    two images for production and development, but they share the same core features
    and packages.
  prefs: []
  type: TYPE_NORMAL
- en: Standard SDK is commonly undervalued
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Application development implies an interactive process, mainly because we usually
    continuously build the application until we accomplish what we aim for. This use
    case is not well suited for the Yocto Project, mainly for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Every time we start the build of a recipe, it discards the previous build objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time needed for deploying the application or image is much longer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lack of proper integration in the IDE environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are alternatives for a few of those topics, such as using `devtool` to
    reuse the build objects and helping to deploy the application. We saw how to use
    `devtool` in the *Deploying to the target using devtool* and *Building a recipe
    using devtool* sections from [*Chapter 9*](B19361_09.xhtml#_idTextAnchor115),
    *Developing with the Yocto Project*, but the development experience is still cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: Using Standard SDK for application and other components’ development, such as
    the Linux kernel and bootloader, is still preferable. This way, we focus on faster
    development, postponing or parallelizing the Yocto Project integration task.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid too many patches for Linux kernel and bootloader modifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The need for patches in the Linux kernel and bootloader is inherent to embedded
    Linux development, as we rarely use the hardware without any changes. The level
    of modification on those components is related to your hardware design, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a **Single-Board Computer** (**SBC**), the number of changes should be
    minimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the use of **System-On-Module** (**SOM**) with a custom baseboard, the number
    of changes could vary depending on the number of modifications from the vendor
    baseboard hardware design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultimately, the use of custom hardware design implies the development of a custom
    BSP and, consequently, a considerable number of modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those are not set in stone. So, for example, consider starting the project using
    an SBC. Later, we find out that the vendor does not provide a good reference BSP,
    so the number of modifications and amount of work for the BSP will increase considerably.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have small changes, it is better to tackle the changes as patch files
    added to the component recipe. But when the effort to maintain the component increases,
    it justifies having a separate fork of that component to keep all the changes
    in place. Using a repository fork gives us the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The history of the changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different branches or tags for development and production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility of merging with other providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows the use of much simpler recipes, as we don’t need to carry on individual
    patches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, we should use the strategy that makes sense for the project. Eventually,
    this will change, but using the right approach reduces the total effort to support
    the hardware in use properly.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using AUTOREV as SRCREV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The use of `AUTOREV` as `SRCREV` is usually applied when developing a product.
    We must interactively change the code and try that code inside the Yocto Project.
    That said, this comes with a couple of drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: It is hard to reproduce the previous build as every time we rebuild our image,
    it may use a different revision for our recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AUTOREV` value is only applied when BitBake invalidates the cache of a
    specific recipe. That happens when we modify the recipe itself or when we change
    something that triggers the BitBake cache rebuild, such as changing any `.``conf`
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those drawbacks make `AUTOREV` very fragile, and other alternatives can cover
    the interactive code change more consistently. Typically, `devtool` is used as
    it allows us to change the code directly in the workspace and forces the recipe
    to use this as the source. Another alternative is to use the `externalsrc.bbclass`
    class ([https://docs.yoctoproject.org/4.0.4/index.html#ref-classes-externalsrc](https://docs.yoctoproject.org/4.0.4/index.html#ref-classes-externalsrc)),
    which allows us to configure a recipe to use a directory as the source for the
    build.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Software Bill of Materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Poky build system can describe all the components used in an image from
    the licenses for each software component. This description is generated as a **Software
    Bill of Materials** (**SBOM**) using the **Software Package Data Exchange** (**SPDX**)
    standard ([https://spdx.dev/](https://spdx.dev/)). Using the SPDX format has the
    advantage of leveraging existing tooling, allowing extra automation, which is
    impossible using Poky’s standard license output format.
  prefs: []
  type: TYPE_NORMAL
- en: The SBOM is critical to ensure open source license compliance. However, the
    SBOM is not generated by default. You can refer to the *Creating a Software Bill
    of Materials* section from *The Yocto Project Development Tasks* *Manual* ([https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#creating-a-software-bill-of-materials](https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#creating-a-software-bill-of-materials)).
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines to follow for general projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section discusses some project-related guidelines to follow to reduce the
    general project risk and avoid common pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: Continuously monitor the project license constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Depending on the project we are working on, license compliance might be a big
    or a small topic. Some projects have very restricted license constraints, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The inability to use GPLv3-released software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copyleft contamination of project-specific intellectual property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Company-wise license constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advice is to start this process at the beginning of the project, reducing
    the amount of rework throughout the project. However, the project license constraints
    and the project component’s licenses may change, requiring us to monitor our license
    compliance continuously.
  prefs: []
  type: TYPE_NORMAL
- en: Security can harm your project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our hyper-connected era, every connected device is a potential target for
    a security attack. As embedded device developers, we should contribute to a safer
    place. We should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Scan our embedded Linux software for known security flaws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor critical software for security fixes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a process for fixing field devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the Yocto Project infrastructure, as discussed in the *Checking for
    Vulnerabilities* section of *Yocto Project Development Tasks Manual* ([https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#checking-for-vulnerabilities](https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#checking-for-vulnerabilities)),
    to scan for known **Common Vulnerabilities and Exposures** (**CVE**) for our recipes.
    We should not be limited to this as our BSP components might also require security
    fixes, which the BSP vendors commonly neglect. Still, the paranoia level depends
    on the project niche.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t underestimate maintenance costs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At first, upstreaming our changes might not seem strategic for the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Upstreaming uses resources to adapt modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upstream review feedback may require additional interactions and rework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development work not directly connected to the product needs to be done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usually, development and management teams underestimate the total cost of maintenance.
    But unfortunately, this is frequently the most expensive part of the project,
    as it lasts for years. Upstreaming our changes to the respective project allows
    us to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid work duplication over the years
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the friction during upgrades for new Yocto Project releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receive critical and constructive feedback about the changes we are upstreaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the amount of work with security updates and bug fixes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the amount of code we have to maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The upstream work is continuous. Every time we add a new feature, we potentially
    increase the gap between our code and the upstream. Therefore, we may postpone
    the upstreaming work, but the upstreaming costs will be multiplied when you work
    on updating to the next Yocto Project release.
  prefs: []
  type: TYPE_NORMAL
- en: Tackle project risk points and constraints as soon as possible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the software and hardware must work together, a few aspects directly depend
    on our hardware design. To reduce the project risk, we should anticipate as many
    critical software and hardware requirements as possible so we can validate some
    aspects, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the amount of memory we intend to use enough or too much?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the amount of power the hardware uses sufficient for our constraints?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the target GPU capable of rendering the animations we need?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do all the planned peripheral devices have available Linux kernel drivers ready
    for use or do we need to plan the development for those?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding questions can be answered using a reference or well-known board,
    which we have ready to use BSP. This allows us to produce a **Minimal Viable Product**
    (**MVP**) without the need to design our custom hardware. After we validate the
    project’s risks and constraints, those boards are still valuable assets for the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing the development of our software until the custom board and BSP are
    ready for use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a base of comparison with our custom design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a reference to verify whether a bug is specific to our custom board and BSP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering we can develop our software using a reference or a well-known board,
    we should postpone the design of a custom board for as long as possible. Delaying
    the design gives us the freedom to change many aspects of our project, such as
    changing a peripheral because of a specific driver or even changing the planned
    CPU and memory capabilities after maturing the application and features.
  prefs: []
  type: TYPE_NORMAL
- en: When we finally decide to go with a custom design, we should keep it as close
    as possible to the board we choose as a reference. But, of course, sometimes we
    need to deviate from the reference design. Still, it comes with the risk of introducing
    design issues and increasing the cost of our custom BSP.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phew! In this final chapter, you have been introduced to a set of good practices
    that the authors have been using in their real-life projects. We hope they have
    given you some points to consider when planning your next project.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, we have covered the necessary background information for
    you to learn any other aspect of the Yocto Project that you may need on your own.
    So, you now have a general understanding of what is happening behind the scenes
    when you ask BitBake to build a recipe or an image. From now on, you are ready
    to free your mind and try new things. The ball is in your court now – here’s where
    the fun begins!
  prefs: []
  type: TYPE_NORMAL
