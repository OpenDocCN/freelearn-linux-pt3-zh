- en: '*Chapter 7*: Configuring Application-Specific SELinux Controls'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：配置特定应用的 SELinux 控制'
- en: Several Linux services and applications enable additional SELinux controls besides
    the kernel-enforced SELinux policy. They allow the administrator to further manipulate
    and enforce policy rules through the application itself—isolating users, reducing
    data leakage risks, and mitigating the impact of malicious behavior.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Linux 服务和应用程序启用了额外的 SELinux 控制，除了内核强制的 SELinux 策略外。它们允许管理员通过应用程序本身进一步操作和执行策略规则——隔离用户、减少数据泄露风险，并缓解恶意行为的影响。
- en: In this chapter, we will look at several SELinux-aware applications, such as
    systemd services and how they allow administrators to set up and specify target
    domains and resource labels. We'll also cover the D-Bus service, which allows
    SELinux policies to control the service binding and message communication within
    D-Bus itself. Next, we'll jump to PAM-enabled services that allow users to log
    in through them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将探讨几个支持 SELinux 的应用程序，如 systemd 服务，以及它们如何允许管理员设置和指定目标域和资源标签。我们还将讨论 D-Bus
    服务，D-Bus 服务允许 SELinux 策略控制服务绑定和 D-Bus 内部的消息通信。接下来，我们将介绍启用 PAM 的服务，允许用户通过这些服务登录。
- en: Finally, we'll end the chapter with `mod_selinux`, an Apache module that allows
    SELinux-specific tuning of the web server's behavior. This approach shows how
    applications that do not natively have SELinux support can still be extended to
    address the administrator's requirements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将以 `mod_selinux` 作为本章的结束，它是一个 Apache 模块，允许对 Web 服务器行为进行 SELinux 特定的调整。这种方法展示了没有本地
    SELinux 支持的应用程序如何通过扩展来满足管理员的需求。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Tuning systemd services, logging, and device management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整 systemd 服务、日志记录和设备管理
- en: Communicating over D-Bus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 D-Bus 进行通信
- en: Configuring PAM services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 PAM 服务
- en: Using mod_selinux with Apache
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 mod_selinux 与 Apache 配合
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/37jYtze](https://bit.ly/37jYtze)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/37jYtze](https://bit.ly/37jYtze)
- en: Tuning systemd services, logging, and device management
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整 systemd 服务、日志记录和设备管理
- en: '`init` system, responsible for handling services and boot-up operations.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 系统，负责处理服务和启动操作。'
- en: 'Throughout its development phase, systemd added several other components to
    its portfolio:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发阶段，systemd 向其组件库中添加了几个其他组件：
- en: D-Bus, which offers a system and session bus service allowing the use of D-Bus
    for inter-application communication, merged with systemd.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D-Bus 提供了一个系统和会话总线服务，允许通过 D-Bus 进行应用程序间通信，并与 systemd 合并。
- en: systemd also incorporated `udev`, which offers a flexible device-node management
    application.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: systemd 还集成了 `udev`，它提供了一个灵活的设备节点管理应用程序。
- en: Login capabilities were added to systemd, enabling fine-grained control over
    user sessions.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 systemd 添加了登录功能，实现了对用户会话的精细控制。
- en: The `journald` daemon joined the systemd family to provide a new approach to
    system and service logging, replacing some of the functionality of standard system
    loggers.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`journald` 守护进程加入了 systemd 家族，提供了一种新的系统和服务日志记录方法，替代了部分标准系统日志记录器的功能。'
- en: The `timerd` daemon provides support for the time-based execution of tasks,
    replacing some of the functionality of standard cron daemons.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timerd` 守护进程支持基于时间的任务执行，替代了部分标准 cron 守护进程的功能。'
- en: Network configurations can be managed by systemd-networkd.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络配置可以通过 systemd-networkd 进行管理。
- en: This ongoing approach of absorbing several system services into a single application
    suite has not gone unnoticed and isn't without controversy. Some distributions
    even refuse to have systemd as the default `init` system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个系统服务吸收进一个单一应用程序套件的持续方法未曾被忽视，也不是没有争议的。一些发行版甚至拒绝将 systemd 作为默认的 `init` 系统。
- en: 'The systemd project includes SELinux support for most of its services. Applications
    such as systemd, which not only include SELinux awareness but also enforce access
    controls on specific SELinux classes and permissions (rather than relying on the
    Linux kernel), are called **userspace object managers**:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 项目为大多数服务提供了 SELinux 支持。像 systemd 这样的应用程序，不仅具备 SELinux 意识，而且还在特定的 SELinux
    类和权限上执行访问控制（而不是依赖于 Linux 内核），被称为 **用户空间对象管理器**：
- en: '![Figure 7.1 — The difference between kernel-enforced, standard SELinux, and
    userspace-managed SELinux ](img/B16276_07_001.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 — 内核强制、标准 SELinux 和用户空间管理 SELinux 之间的区别](img/B16276_07_001.jpg)'
- en: Figure 7.1 — The difference between kernel-enforced, standard SELinux, and userspace-managed
    SELinux
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 — 内核强制、标准SELinux和用户空间管理SELinux之间的区别
- en: If an application enforces access controls toward certain classes and permissions,
    then it will also have its own AVC (see [*Chapter 2*](B16276_02_Final_VK.xhtml#_idTextAnchor045),
    *Understanding SELinux Decisions and Logging*, for more information about the
    AVC). Log events resulting from these applications will be identified as `USER_AVC`
    events rather than (kernel-managed) `AVC` events. The systemd application has
    support for systemd-specific classes, as we will see in the *Governing unit operation
    access* section. But before we dive into these specific details, let's first see
    what systemd is all about and what SELinux support it has.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序实施了针对特定类和权限的访问控制，那么它也将拥有自己的AVC（有关AVC的更多信息，请参见[*第2章*](B16276_02_Final_VK.xhtml#_idTextAnchor045)，*理解SELinux决策和日志记录*）。由这些应用程序生成的日志事件将被标识为`USER_AVC`事件，而不是（内核管理的）`AVC`事件。systemd应用程序支持特定于systemd的类，正如我们在*管理单元操作访问*部分中所看到的那样。但在深入探讨这些具体细节之前，让我们先了解一下systemd是什么以及它对SELinux的支持。
- en: Service support in systemd
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: systemd中的服务支持
- en: The main capability of the system daemon that most people know about is its
    support for system services. Unlike traditional SysV-compatible `init` systems,
    systemd does not use scripts to manage services. Instead, it uses a declarative
    approach for the various services, documenting the wanted state and configuration
    parameters while using its own logic to ensure that the right set of services
    start at the right time and in the correct order.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人所知道的systemd主要功能是它对系统服务的支持。与传统的兼容SysV的`init`系统不同，systemd不使用脚本来管理服务。相反，它使用声明性的方法来管理各种服务，记录所需的状态和配置参数，同时使用自己的逻辑确保在正确的时间和顺序启动正确的服务。
- en: Understanding unit files
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解单元文件
- en: 'systemd uses unit files to declare how a service should behave. These unit
    files use the INI-style syntax, supporting sections and key/value pairs within
    each file. A service can have multiple unit files that influence the service at
    large. It is important to remember that different unit files for the same service
    are all related:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: systemd使用单元文件来声明服务应如何运行。这些单元文件使用INI风格的语法，支持每个文件中的节和键/值对。一个服务可以有多个单元文件，它们会对该服务产生整体影响。重要的是要记住，同一个服务的不同单元文件是相关的：
- en: The `*.service` unit files define how a system service should be launched, what
    its dependencies are, how systemd should treat sudden failures, and so on.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*.service`单元文件定义了如何启动系统服务，它的依赖关系是什么，systemd应该如何处理突然的故障等。'
- en: The `*.socket` unit files define which socket(s) should be created and which
    permissions should be assigned to it. systemd uses this for services that can
    be launched on request rather than directly at boot.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*.socket`单元文件定义了应创建哪些套接字以及应分配给它的权限。systemd使用它来处理那些可以按需启动而不是在启动时直接启动的服务。'
- en: The `*.timer` unit files define at what time or frequency the service should
    be launched. Services that do not necessarily run daemonized but need to execute
    a certain logic at defined intervals can use these timer files to ensure regular
    runs. These settings are comparable to the more classic yet still widely used
    crontabs, which we briefly touch upon in *PAM services*, in the subsection called
    *Cron*.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*.timer`单元文件定义了服务应在何时或以何种频率启动。那些不一定以守护进程方式运行，但需要在定义的间隔内执行某些逻辑的服务，可以使用这些定时器文件来确保定期执行。这些设置与经典但仍广泛使用的crontab相似，我们在*PAM服务*的*Cron*小节中简要提到过。'
- en: Other unit files exist as well, although those have more in common with generic
    system configurations (such as slice definitions and automount settings) and less
    with runtime services.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 也存在其他单元文件，尽管它们更像是通用的系统配置（如切片定义和自动挂载设置），与运行时服务的关系较少。
- en: 'System unit files can be placed in one of three locations:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 系统单元文件可以放置在以下三个位置之一：
- en: Unit files are installed by default by the system's package manager inside `/usr/lib/systemd/system`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，单元文件由系统的包管理器安装在`/usr/lib/systemd/system`目录中。
- en: At runtime, updates can be placed inside `/run/systemd/system`, which will override
    the unit files in the default location. However, this location is transient and
    will not persist across reboots.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时，更新可以放置在`/run/systemd/system`目录中，这将覆盖默认位置的单元文件。然而，这个位置是临时的，在重启后不会保留。
- en: System administrators can override the configurations in the two locations by
    placing unit files in `/etc/systemd/system`. These unit files override previous
    definitions, so there is no need to remove the unit files from the previous locations.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统管理员可以通过将单元文件放置在 `/etc/systemd/system` 中来覆盖这两个位置的配置。这些单元文件会覆盖先前的定义，因此无需删除先前位置的单元文件。
- en: 'As an example, check out the default Nginx service unit file, `nginx.service`,
    inside `/usr/lib/systemd/system`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，查看 `/usr/lib/systemd/system` 中的默认 Nginx 服务单元文件 `nginx.service`：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This unit file declares the command to launch Nginx with and informs systemd
    that the service should be launched after successfully reaching the `network`,
    `remote-fs`, and `nss-lookup` targets (which is a milestone in the boot process,
    allowing proper dependency handling). The unit file also declares that it is a
    dependency of the `multi-user` target (which is the equivalent of the default
    run level when using SysV-style `init` services), which means the service should
    launch when the system boots.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单元文件声明了启动 Nginx 的命令，并通知 systemd 服务应该在成功达到 `network`、`remote-fs` 和 `nss-lookup`
    目标之后启动（这是启动过程中的一个里程碑，允许正确处理依赖关系）。该单元文件还声明它是 `multi-user` 目标的依赖项（这相当于使用 SysV 风格的
    `init` 服务时的默认运行级别），意味着该服务应在系统启动时启动。
- en: Setting the SELinux context for a service
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为服务设置 SELinux 上下文
- en: When systemd launches a service, it executes the command defined through the
    `ExecStart=` configuration entry in the service unit file. By default, a standard
    domain transition will occur as defined through the SELinux policy.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当 systemd 启动一个服务时，它会执行在服务单元文件中的 `ExecStart=` 配置项中定义的命令。默认情况下，系统会根据 SELinux 策略执行标准的域转换。
- en: Package developers and system administrators can, however, update the service
    unit files to have the service launched in an explicitly mentioned SELinux domain.
    To accomplish this, the `[Service]` section of the unit file can be extended with
    the `SELinuxContext=` configuration entry.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，软件包开发人员和系统管理员可以更新服务单元文件，以使服务在显式提到的 SELinux 域中启动。为了实现这一点，可以通过在单元文件的 `[Service]`
    部分添加 `SELinuxContext=` 配置项来扩展该部分。
- en: 'For instance, to ensure that Nginx launches with the `httpd_t:s0:c0.c128` context,
    you''d use this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了确保 Nginx 使用 `httpd_t:s0:c0.c128` 上下文启动，你可以使用以下方式：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Of course, it is also possible to use this to have a service running with a
    different context, which can be useful when developing custom policies for daemons.
    However, keep in mind that the SELinux policy rules still apply: you cannot ask
    systemd to launch Nginx, for instance, with the `dnsmasq_t` domain without updating
    the SELinux policy so that `httpd_exec_t` (the entry point for the `httpd_t` domain)
    is also made an entry point for the `dnsmasq_t` domain.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以使用此方法让服务在不同的上下文中运行，这在为守护进程开发自定义策略时非常有用。然而，请记住，SELinux 策略规则仍然适用：例如，你不能要求
    systemd 启动 Nginx，并将其放在 `dnsmasq_t` 域中，而不更新 SELinux 策略，使得 `httpd_exec_t`（`httpd_t`
    域的入口点）也成为 `dnsmasq_t` 域的入口点。
- en: 'When you request systemd to explicitly use an SELinux context for a service,
    systemd will attempt to use this context for all execution-related tasks: `ExecStartPre`,
    `ExecStart`, `ExecStartPost`, `ExecStopPre`, `ExecStop`, `ExecStopPost`, and `ExecReload`.
    As these tasks often are not labeled with the right entry point label, these commands
    can fail. In that case, prefix the commands with `+` so that the SELinux context
    definition does not apply to them:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你请求 systemd 显式使用 SELinux 上下文时，systemd 会尝试在所有与执行相关的任务中使用此上下文：`ExecStartPre`、`ExecStart`、`ExecStartPost`、`ExecStopPre`、`ExecStop`、`ExecStopPost`
    和 `ExecReload`。由于这些任务通常没有标记正确的入口点标签，这些命令可能会失败。在这种情况下，可以在命令前加上 `+`，以便 SELinux 上下文定义不适用于它们：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While developing and changing unit files, the changed settings might not always
    be immediately applied to the system. Running `systemctl daemon-reload` after
    modifying unit files will ensure that the latest changes on the system are read
    by systemd.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发和更改单元文件时，修改的设置可能不会立即应用到系统中。在修改单元文件后，运行 `systemctl daemon-reload` 将确保 systemd
    读取系统中的最新更改。
- en: Using transient services
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用临时服务
- en: systemd can also be used to launch applications as if they are services and
    have them under systemd's control. Such applications are called **transient services**
    as they lack the unit files that generally declare how systemd should behave.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 还可以用来启动应用程序，使其像服务一样在 systemd 的控制下运行。这些应用程序被称为 **临时服务**，因为它们没有通常声明 systemd
    应如何行为的单元文件。
- en: 'Transient services are launched through the `systemd-run` application. To show
    this, let''s create a simple Python script (one that calculates Pi up to 10,000
    digits):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 瞬态服务是通过 `systemd-run` 应用程序启动的。为了展示这一点，让我们创建一个简单的 Python 脚本（一个计算 Pi 到 10,000
    位的小脚本）：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As this takes some time, we can opt to run this Python script under systemd''s
    control:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个过程需要一些时间，我们可以选择在 systemd 控制下运行此 Python 脚本：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As transient services do not have unit files to manage, changing the SELinux
    context must be accomplished through the command line as well. Of course, this
    is only needed if the standard domain transitions defined in the policy do not
    result in the wanted behavior:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于瞬态服务没有单元文件来管理，因此必须通过命令行来更改 SELinux 上下文。当然，只有当策略中定义的标准域转换未能产生所需行为时，才需要这样做：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `systemd-run` application supports this through the `--property` (or `-p`)
    option, through which unit file properties can be added. In the previous example,
    we use this option to run the script in the `guest_t` domain using the `SELinuxContext`
    property, similar to how we would define this in the unit file itself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd-run` 应用程序通过 `--property`（或 `-p`）选项支持此功能，通过该选项可以添加单元文件属性。在前面的示例中，我们使用此选项通过
    `SELinuxContext` 属性在 `guest_t` 域中运行脚本，这类似于我们在单元文件中定义该属性的方式。'
- en: Requiring SELinux for a service
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需要 SELinux 的服务
- en: Some services should only run when SELinux is enabled or disabled. With systemd,
    this can be defined through its conditional parameters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有些服务只有在启用或禁用 SELinux 时才应运行。在 systemd 中，可以通过其条件参数来定义此行为。
- en: A service unit file can contain several conditions that need to be valid before
    systemd will consider executing the service. These conditionals can point to the
    system type (virtualized or not), kernel command-line parameters, files that do
    or don't exist, and so on. The one we are interested in is `ConditionSecurity`,
    which represents the state of the given security system—in our case, SELinux.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务单元文件可以包含几个条件，这些条件需要在 systemd 考虑执行该服务之前验证。这些条件可以指向系统类型（虚拟化或非虚拟化）、内核命令行参数、是否存在的文件等等。我们关心的是
    `ConditionSecurity`，它表示给定安全系统的状态——在我们的案例中是 SELinux。
- en: 'For instance, look at the `selinux-autorelabel.service` unit file inside `/usr/lib/systemd/system`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，查看 `/usr/lib/systemd/system` 中的 `selinux-autorelabel.service` 单元文件：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similarly, the Linux distribution provides the `selinux-autorelabel-mark.service`
    file. This service ensures that, if SELinux is not active when the system boots
    (and no `/.autorelabel` file exists yet), then systemd will create an empty `/.autorelabel`
    file. This file ensures that, when the system reboots with SELinux support, the
    relabeling operation occurs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Linux 发行版提供了 `selinux-autorelabel-mark.service` 文件。该服务确保，如果系统启动时 SELinux
    未激活（且 `/.autorelabel` 文件尚不存在），则 systemd 会创建一个空的 `/.autorelabel` 文件。此文件确保在系统以 SELinux
    支持重新启动时，执行重新标记操作。
- en: Relabeling files during service startup
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务启动期间的重新标记文件
- en: One of the actions that many services require is the preparation of service-specific
    runtime directories, such as `/run/httpd` for the Apache service. systemd supports
    this through `tmpfiles.d`. We have briefly covered `tmpfiles` in [*Chapter 4*](B16276_04_Final_VK.xhtml#_idTextAnchor095),
    *Using File Contexts and Process Domains*. Within `tmpfiles`, we can define the
    files and locations requested to be provided or updated immediately (at boot time)
    when these are not placed in the (persisted) filesystem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 许多服务需要的一项操作是准备服务特定的运行时目录，例如 Apache 服务的 `/run/httpd`。systemd 通过 `tmpfiles.d`
    支持此功能。我们已经在 [*第 4 章*](B16276_04_Final_VK.xhtml#_idTextAnchor095)《使用文件上下文和进程域》中简要介绍了
    `tmpfiles`。在 `tmpfiles` 中，我们可以定义在这些文件未放置在（持久化的）文件系统中时，请求立即（在启动时）提供或更新的文件和位置。
- en: 'For instance, the package that provides the Apache daemon installs the following
    definition as `/usr/lib/tmpfiles.d/httpd.conf` on the system:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，提供 Apache 守护进程的包会在系统上安装以下定义作为 `/usr/lib/tmpfiles.d/httpd.conf`：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Like the systemd unit files, the files that contain these settings should be
    declared in one of the following three locations. Each location overrides the
    settings of the previous one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与 systemd 单元文件类似，包含这些设置的文件应该声明在以下三个位置之一。每个位置都覆盖前一个位置的设置：
- en: The default, package-provided location is `/usr/lib/tmpfiles.d`.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的、软件包提供的位置是 `/usr/lib/tmpfiles.d`。
- en: Runtime declarations can be placed in `/run/tmpfiles.d`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时声明可以放在 `/run/tmpfiles.d` 中。
- en: Local system administrator-provided declarations are placed in `/etc/tmpfiles.d`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地系统管理员提供的声明放在 `/etc/tmpfiles.d` 中。
- en: These definitions can get much more specific than just directory creation. Through
    the `tmpfiles.d` application, definitions can be set to create files, empty directories
    upfront, create sub-volumes, manage special files such as symbolic links or block
    devices, set extended attributes, and more.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义可以比仅创建目录更具体。通过 `tmpfiles.d` 应用程序，可以设置定义来创建文件、预先清空目录、创建子卷、管理特殊文件（如符号链接或块设备）、设置扩展属性等。
- en: One of its features is to set the file mode and ownership, and restore the SELinux
    context on a file (`z`) or recursively against a directory (`Z`). This can be
    used to change contexts on files that have a proper context definition in the
    policy, but whose context is not properly assigned.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其特点之一是设置文件模式和所有权，并恢复文件（`z`）或递归地针对目录（`Z`）的 SELinux 上下文。这可以用于更改具有正确上下文定义的文件的上下文，但其上下文未正确分配。
- en: 'For instance, look at the definitions in the `selinux-policy.conf` file inside
    `/usr/lib/tmpfiles.d`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，查看 `/usr/lib/tmpfiles.d` 中的 `selinux-policy.conf` 文件中的定义：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We need to relabel files inside `/sys` because this location is labeled with
    `sysfs_t` by default and changing the context at runtime does not preserve its
    status across reboots. Yet some of its files should have a different label – the
    `/sys/devices/system/cpu/online` file, for instance, requires the `cpu_online_t`
    label:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重新标记 `/sys` 中的文件，因为该位置默认标记为 `sysfs_t`，并且在运行时更改上下文不会在重启后保留其状态。然而，其中一些文件应该有不同的标签——例如
    `/sys/devices/system/cpu/online` 文件需要 `cpu_online_t` 标签：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The definition ensures that this (pseudo) file is relabeled at boot so that
    all other processes that rely on the file labeled with `cpu_online_t` can happily
    continue working.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该定义确保在启动时重新标记此（伪）文件，以便所有依赖于标有 `cpu_online_t` 的文件的其他进程可以顺利继续工作。
- en: The other arguments to the definition are explicitly marked with a dash in the
    previous example, meaning that no other parameters need to be configured. They
    can be used to set the mode, **User Identifier** (**UID**), **Group Identifier**
    (**GID**), age, and argument related to the rule.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的其他参数在前一个示例中明确标记为破折号，意味着不需要配置其他参数。它们可以用来设置模式、**用户标识符** (**UID**)、**组标识符**
    (**GID**)、年龄以及与规则相关的参数。
- en: 'An example configuration that uses some of these other parameters with the
    `z` or `Z` state is the `systemd.conf` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `z` 或 `Z` 状态的这些其他参数的示例配置是 `systemd.conf` 文件：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For more information about the definition format, see `man tmpfiles.d`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有关定义格式的更多信息，请参见 `man tmpfiles.d`。
- en: Using socket-based activation
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用基于套接字的激活
- en: The system daemon also supports socket-based activation. When configured, systemd
    will create the socket on which the daemon usually listens and will have the daemon
    launched when the socket is first used. This allows systems to boot quickly (as
    many daemons do not need to be launched immediately) while still ensuring that
    all required sockets are available.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 系统守护进程还支持基于套接字的激活。当配置完成时，systemd 会创建守护进程通常监听的套接字，并在第一次使用该套接字时启动守护进程。这使得系统可以快速启动（因为许多守护进程不需要立即启动），同时确保所有必需的套接字都可用。
- en: When a client only writes information to the socket (such as with the `/dev/log`
    socket), the client does not even need to wait for the daemon to be activated.
    The data is stored in a buffer until the daemon can read it. Only when the buffer
    is full will the operation block until the daemon flushes the buffer.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端仅向套接字写入信息时（例如 `/dev/log` 套接字），客户端甚至不需要等待守护进程激活。数据会存储在缓冲区中，直到守护进程能够读取它。只有当缓冲区满时，操作才会阻塞，直到守护进程刷新缓冲区。
- en: 'Take a look at the `systemd-journald.socket` unit file, available inside `/usr/lib/systemd/system`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 查看位于 `/usr/lib/systemd/system` 中的 `systemd-journald.socket` 单元文件：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When a client uses one of the mentioned sockets, then systemd will launch the
    `systemd-journald.service` unit to accommodate the client interaction. As long
    as these sockets are not used, the service will not be started.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端使用上述套接字之一时，systemd 将启动 `systemd-journald.service` 单元来处理客户端交互。只要这些套接字未被使用，服务将不会启动。
- en: 'Inside the `[Socket]` section, an SELinux-specific entry can be defined: `SELinuxContextFromNet=true`.
    When a unit file has this entry set, systemd will obtain the MLS/MCS information
    from the client context (the application connecting to the socket) and append
    this to the context of the service. This sensitivity inheritance can be used to
    prevent any information leakage from taking place when communication is happening
    through sockets.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `[Socket]` 部分中，可以定义一个 SELinux 特定的条目：`SELinuxContextFromNet=true`。当一个单元文件设置了这个条目时，systemd
    会从客户端上下文（连接到套接字的应用程序）中获取 MLS/MCS 信息，并将其附加到服务的上下文中。这种敏感性继承可以用来防止在通过套接字进行通信时发生信息泄露。
- en: Governing unit operation access
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理单元操作访问
- en: Until now, we've looked at configuration settings related to systemd's SELinux
    support. systemd also uses SELinux to control access to services defined through
    unit files. When a user wants to perform an operation against a unit (such as
    starting a service or checking the state of a running service), systemd queries
    the SELinux policy to see whether it will allow this operation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了与 systemd 的 SELinux 支持相关的配置设置。systemd 还使用 SELinux 来控制对通过单元文件定义的服务的访问。当用户想对某个单元执行操作（例如启动服务或检查运行中的服务状态）时，systemd
    会查询 SELinux 策略，以查看是否允许此操作。
- en: 'The systemd daemon uses the service class to validate the permissions of the
    client''s domain toward the requested operation. For instance, to validate whether
    a user context, `sysadm_t`, can view the status of the service associated with
    the `sshd.service` unit file, it checks the context of this file (being `sshd_unit_file_t`)
    and then validates whether the status permission is granted:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 守护进程使用服务类来验证客户端域对请求操作的权限。例如，为了验证用户上下文 `sysadm_t` 是否可以查看与 `sshd.service`
    单元文件相关的服务状态，它会检查该文件的上下文（为 `sshd_unit_file_t`），然后验证是否授予了状态权限：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Other supported permissions are `disable`, `enable`, `reload`, `start`, and
    `stop`. When a permission is not granted, a `USER_AVC` denial message will be
    visible in the audit logs (rather than an `AVC` message) as the message is not
    generated by the Linux kernel, but by systemd. So, while the rules themselves
    are part of the SELinux policy, it is systemd that enforces the access.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其他支持的权限有 `disable`、`enable`、`reload`、`start` 和 `stop`。当权限未被授予时，审计日志中会显示 `USER_AVC`
    拒绝消息（而非 `AVC` 消息），因为该消息不是由 Linux 内核生成的，而是由 systemd 生成的。因此，虽然规则本身是 SELinux 策略的一部分，但访问控制是由
    systemd 强制执行的。
- en: 'systemd, or the client through which systemd is queried, might also provide
    additional error messages to reflect that the SELinux policy prevents the action.
    For instance, if we attempt to query systemd over D-Bus (which we cover in the
    *D-Bus communication* section) from an unprivileged user domain, then we get the
    following error:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 或通过 systemd 查询的客户端可能还会提供额外的错误信息，表明 SELinux 策略阻止了该操作。例如，如果我们尝试通过 D-Bus
    查询 systemd（我们将在 *D-Bus 通信* 部分介绍），并且从一个非特权用户域发起查询，那么我们会得到以下错误：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To facilitate troubleshooting any systemd-triggered failures, systemd also has
    an extensive logging component, called `systemd-journald`, which we'll cover next.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于故障排除，systemd 还具有一个广泛的日志记录组件，叫做 `systemd-journald`，我们将在接下来介绍。
- en: Logging with systemd
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 systemd 进行日志记录
- en: 'systemd is not only responsible for service management: it takes up several
    other tasks as well. One of these tasks is log management, traditionally implemented
    through a system logger.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 不仅负责服务管理，还承担着其他几个任务。其中一个任务是日志管理，传统上通过系统日志记录器来实现。
- en: While systemd still supports running with a traditional system logger, it now
    suggests the use of `systemd-journald`. One of the advantages of the journal daemon
    is that it is not limited to textual, single-line log messages. Daemons can now
    use binaries as well as multiline messages as part of its logging capabilities.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 systemd 仍然支持使用传统的系统日志记录器，但现在建议使用 `systemd-journald`。日志守护进程的一个优势是，它不局限于文本的单行日志消息。守护进程现在可以使用二进制数据以及多行消息作为日志记录的一部分。
- en: The journal daemon also registers information about the sending process alongside
    the log messages themselves. This additional information contains ownership data
    (the process owner) including the SELinux context of the sending process.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 日志守护进程还会注册关于发送进程的信息，并与日志消息本身一起记录。这些附加信息包含了所有者数据（进程所有者），包括发送进程的 SELinux 上下文。
- en: Retrieving SELinux-related information
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索与 SELinux 相关的信息
- en: 'The traditional approach to receive SELinux-related information (excluding
    the audit events we tackled before) is to `grep` through the log information.
    With the journal daemon, we can accomplish this as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的接收 SELinux 相关信息的方法（排除我们之前讨论的审计事件）是通过 `grep` 在日志信息中查找。使用日志守护进程，我们可以通过以下方式实现：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `-b` option passed on to the journal control application informs the journal
    daemon that we are only interested in the log messages that originated for a specific
    boot.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给日志控制应用程序的 `-b` 选项通知日志守护进程，我们只关心来自特定引导的日志消息。
- en: Querying logs given an SELinux context
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据 SELinux 上下文查询日志
- en: 'A unique feature of the journal daemon is to use the information associated
    with the log messages as part of the query to be launched against the journal
    database. For instance, we can ask the journal daemon to only show those messages
    that originated from a daemon or application running in the `udev_t` context:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 日志守护进程的一个独特功能是使用与日志消息相关的信息作为查询的一部分，针对日志数据库进行查询。例如，我们可以要求日志守护进程只显示那些来自于运行在 `udev_t`
    上下文中的守护进程或应用程序的消息：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The available contexts can be retrieved through the Bash completion support
    on the system. After writing `_SELINUX_CONTEXT=`, press *Tab* twice to see the
    possible values.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的上下文可以通过系统上的 Bash 自动补全支持获取。在输入 `_SELINUX_CONTEXT=` 后，按 *Tab* 键两次即可查看可能的值。
- en: Using setroubleshoot integration with journal
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `setroubleshoot` 集成与日志
- en: The SELinux troubleshoot daemon is also integrated with `systemd-journald`.
    Any alert that comes up from `setroubleshootd` is also available through the journal
    daemon.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 故障排除守护进程也与 `systemd-journald` 集成。来自 `setroubleshootd` 的任何警报也可以通过日志守护进程获取。
- en: 'This helps administrators as they will quickly find out about SELinux denials
    when investigating problems. For instance, when the Nginx web server is not working
    properly and this is due to an SELinux policy, a quick investigation of the status
    of the service will reveal that the SELinux policy is preventing some actions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于管理员在调查问题时能快速发现 SELinux 拒绝。例如，当 Nginx Web 服务器无法正常工作，且这是由于 SELinux 策略导致时，快速检查服务的状态会显示
    SELinux 策略正在阻止某些操作：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To get more information about the message, use `journalctl`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更多关于消息的信息，可以使用 `journalctl`：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, `systemd-journald` has captured environment information related
    to the service, which can provide much-needed guidance on resolving potential
    problems.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`systemd-journald` 已经捕获了与服务相关的环境信息，这些信息能够为解决潜在问题提供宝贵的指导。
- en: A third systemd service that has SELinux configuration possibilities is the
    device daemon.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个具有 SELinux 配置功能的 systemd 服务是设备守护进程。
- en: Handling device files
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理设备文件
- en: Linux has a long history of device managers. Initially, administrators needed
    to make sure that the device nodes were already present on the filesystem (`/dev`
    was part of the persisted filesystem). Gradually, Linux adopted more dynamic approaches
    for device management.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 有着悠久的设备管理历史。最初，管理员需要确保设备节点已经存在于文件系统中（`/dev` 是持久化文件系统的一部分）。随着时间的推移，Linux
    逐渐采用了更动态的设备管理方式。
- en: Nowadays, device files are managed through a combination of a pseudo filesystem
    (`devtmpfs`) and a userspace device manager called udev. This device manager is
    merged in systemd as well, becoming `systemd-udevd`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，设备文件通过伪文件系统（`devtmpfs`）和一个名为 udev 的用户空间设备管理器进行管理。这个设备管理器也被并入到 systemd 中，成为
    `systemd-udevd`。
- en: The device manager listens on a kernel socket for kernel events. These events
    inform the device manager about detected or plugged-in devices (or the removal
    of such devices) and allow the device manager to take appropriate action. For
    udev, these actions are defined in udev rules.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 设备管理器通过内核套接字监听内核事件。这些事件向设备管理器报告检测到的或已插入的设备（或此类设备的移除），并允许设备管理器采取适当的行动。对于 udev，这些操作在
    udev 规则中定义。
- en: Using udev rules
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 udev 规则
- en: Configuring the udev subsystem is mainly done through udev rules. These rules
    are one-liners that contain a matching part and an action part.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 udev 子系统主要通过 udev 规则完成。这些规则是包含匹配部分和操作部分的单行指令。
- en: 'The matching part contains validations, executed against the event(s) that
    udev receives from the Linux kernel. This validation uses key/value pairs obtained
    from the event, and includes the following possible keys:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配部分包含对 udev 从 Linux 内核接收到的事件进行的验证。此验证使用从事件中获取的键/值对，包含以下可能的键：
- en: Kernel-provided device name (`KERNEL`)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核提供的设备名称（`KERNEL`）
- en: Device subsystem (`SUBSYSTEM`)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备子系统（`SUBSYSTEM`）
- en: Kernel driver (`DRIVER`)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核驱动程序（`DRIVER`）
- en: Specific attributes (`ATTR`)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定属性（`ATTR`）
- en: Active environment variables (`ENV`)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活跃环境变量（`ENV`）
- en: The action type to inform if the device is detected or removed (`ACTION`)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示设备是否被检测到或移除的操作类型（`ACTION`）
- en: While more match keys are possible, the preceding list is most commonly used.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能有更多的匹配键，但上述列表是最常用的。
- en: 'The Linux kernel will also inform the device manager about the device hierarchy.
    This allows rules to be defined based on, for instance, the USB controller through
    which a USB device is plugged in. Alongside the information for the device itself,
    the kernel will also provide hierarchically related information through similar
    key/value pairs. These pairs, however, use a key definition in plural form: `SUBSYSTEMS`
    instead of `SUBSYSTEM`, `DRIVERS` instead of `DRIVER`, and so on.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核还会向设备管理器通报设备的层级结构。这使得可以基于某些因素定义规则，例如 USB 设备是通过哪个 USB 控制器插入的。除了设备本身的信息，内核还会通过类似的键值对提供层级相关的信息。然而，这些键值对使用复数形式的键定义：`SUBSYSTEMS`
    代替 `SUBSYSTEM`，`DRIVERS` 代替 `DRIVER`，等等。
- en: 'For instance, to match a USB webcam with vendor ID `05a9` and product ID `4519`,
    the match-related pairs could look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要匹配供应商 ID 为 `05a9` 和产品 ID 为 `4519` 的 USB 网络摄像头，匹配相关的键值对可能如下所示：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The second part of a udev rule is the action to take. The most common action
    is to create a symbolic link to the created device file, ensuring that applications
    can always reach the same device through the same symbolic link, even when the
    device from the kernel point of view has a different name. We can, for instance,
    extend the preceding example with `SYMLINK+="webcam1"` to have `/dev/webcam1`
    point to this newly detected device.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: udev 规则的第二部分是要执行的操作。最常见的操作是创建指向已创建设备文件的符号链接，确保即使从内核角度看设备名称发生变化，应用程序仍然可以通过相同的符号链接访问相同的设备。例如，我们可以通过
    `SYMLINK+="webcam1"` 扩展前面的例子，使 `/dev/webcam1` 指向此新检测到的设备。
- en: The udev application supports many more actions than just defining symbolic
    links, of course. It can associate ownership (`OWNER`) or group membership (`GROUP`)
    on the device, controlling who can access the devices. udev can also set environment
    variables (`ENV`) and even run a command (`RUN`) when the matched device is plugged
    in or detached from the system. To make sure the command is only executed when
    the device is added, we need to add an `ACTION` setting such as `ACTION=="add"`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，udev 应用程序支持比仅仅定义符号链接更多的操作。它可以在设备上设置所有权（`OWNER`）或组成员身份（`GROUP`），控制谁可以访问设备。udev
    还可以设置环境变量（`ENV`），甚至在匹配的设备插入或从系统中拔出时执行命令（`RUN`）。为了确保命令仅在设备被添加时执行，我们需要添加一个如 `ACTION=="add"`
    的 `ACTION` 设置。
- en: Important note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: udev can interpret `ENV` as both a matching key as well as an action key. The
    difference is the operation performed (a single equals sign `=` or a double `==`).
    `ENV{envvar}=="value"` is a match operation (checking whether the variable matches
    the given `value`), whereas `ENV{envvar}="value"` is an action (setting the variable
    to `value`).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: udev 可以将 `ENV` 作为匹配键和操作键进行解释。它们的区别在于执行的操作（单个等号 `=` 或双等号 `==`）。`ENV{envvar}=="value"`
    是匹配操作（检查变量是否与给定的 `value` 匹配），而 `ENV{envvar}="value"` 是操作（将变量设置为 `value`）。
- en: udev rules are provided by default through the `/usr/lib/udev/rules.d` location.
    Distributions and applications/drivers will store their default rules in this
    location. Additional rules or rule overrides can be placed in `/etc/udev/rules.d`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: udev 规则默认存储在 `/usr/lib/udev/rules.d` 位置。发行版和应用程序/驱动程序会将其默认规则存储在此位置。额外的规则或规则覆盖可以放在
    `/etc/udev/rules.d` 中。
- en: It's important to remember that udev will continue processing rules even when
    it has already encountered a matching rule. This can be changed on a per-rule
    basis through the `OPTIONS` action, as with `OPTIONS+="last_rule"`, which informs
    udev that it can stop processing further rules for this event.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，即使 udev 已经遇到匹配的规则，它仍会继续处理规则。这可以通过 `OPTIONS` 操作在每条规则的基础上进行更改，例如 `OPTIONS+="last_rule"`，它告诉
    udev 停止进一步处理该事件的规则。
- en: Setting an SELinux label on a device node
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在设备节点上设置 SELinux 标签
- en: 'One of the actions that udev supports is to assign an SELinux context on the
    device node. We can do this using the `SECLABEL{selinux}` action:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: udev 支持的其中一个操作是为设备节点分配 SELinux 标签。我们可以使用 `SECLABEL{selinux}` 操作来实现这一点：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that this action only sets the context on the device node. If the rule
    also sets a symbolic link, then the symbolic link itself will inherit the default
    `device_t` context.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个操作仅设置设备节点上的上下文。如果规则还设置了符号链接，那么符号链接本身将继承默认的 `device_t` 上下文。
- en: Placing an SELinux label on a device node is often done together with the other
    security-related permissions, so the rule often receives additional actions such
    as setting the target owner (`OWNER`), group (`GROUP`), and permission set (`MODE`).
    After all, SELinux security controls only apply *after* the regular, discretionary
    access control checks have passed, so don't forget to make sure your users have
    access to the device nodes outside of the SELinux controls as well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 给设备节点放置 SELinux 标签通常是与其他安全相关权限一起进行的，因此该规则通常会执行附加的操作，例如设置目标所有者（`OWNER`）、组（`GROUP`）和权限集（`MODE`）。毕竟，SELinux
    安全控制仅在常规的自由访问控制检查通过后才会生效，所以不要忘记确保用户在 SELinux 控制之外也能访问设备节点。
- en: All the settings we've seen so far are about systemd service management and
    system support. Another component within the systemd ecosystem is D-Bus, which
    is less about system management and more about facilitating communication and
    interaction between different applications over a programmable communication bus.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的所有设置都与 systemd 服务管理和系统支持有关。systemd 生态系统中的另一个组件是 D-Bus，它更多的是促进不同应用程序之间通过可编程通信总线进行通信和交互，而非系统管理。
- en: Communicating over D-Bus
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 D-Bus 进行通信
- en: The D-Bus daemon provides an inter-process communication channel between applications.
    Unlike traditional IPC methods, D-Bus is a higher-level communication channel
    that offers more than simple signaling or memory sharing. Applications that want
    to chat over D-Bus link with one of the many D-Bus-compatible libraries, such
    as those provided by the libdbus, sd-bus (part of systemd), GDBus, and QtDBus
    applications.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: D-Bus 守护进程提供了一个应用程序之间的进程间通信通道。与传统的 IPC 方法不同，D-Bus 是一个更高级别的通信通道，提供的不仅仅是简单的信号传递或内存共享。想要通过
    D-Bus 进行通信的应用程序可以链接到许多与 D-Bus 兼容的库，如 libdbus、sd-bus（systemd 的一部分）、GDBus 和 QtDBus
    应用程序提供的库。
- en: The D-Bus daemon is part of the systemd application suite.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: D-Bus 守护进程是 systemd 应用程序套件的一部分。
- en: Understanding D-Bus
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 D-Bus
- en: 'Linux generally supports two D-Bus types – system-wide and session-specific
    D-Bus instances:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 通常支持两种 D-Bus 类型——系统范围的和特定会话的 D-Bus 实例：
- en: The system-wide D-Bus is the main instance used for system communication. Many
    services or daemons will associate themselves with the system D-Bus to allow others
    to communicate with them through D-Bus.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统范围的 D-Bus 是用于系统通信的主要实例。许多服务或守护进程会将自己与系统 D-Bus 关联，以便其他应用程序通过 D-Bus 与它们进行通信。
- en: The session-specific D-Bus is an instance running for each logged-in user. It
    is commonly used by graphical applications to communicate with each other within
    a user session.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定会话的 D-Bus 是为每个登录用户运行的实例。它通常被图形化应用程序用来在用户会话内相互通信。
- en: Both D-Bus instances are provided through the `dbus-daemon` application. The
    system-wide D-Bus will run with the `--system` option, whereas a session-specific
    instance will run with the `--session` option.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 D-Bus 实例都是通过 `dbus-daemon` 应用程序提供的。系统范围的 D-Bus 会以 `--system` 选项运行，而特定会话的实例会以
    `--session` 选项运行。
- en: Applications register themselves against D-Bus through a namespace. Conventionally,
    this namespace uses the domain name of the project. For instance, systemd declares
    the `org.freedesktop.systemd1` namespace, whereas D-Bus is at `org.freedesktop.DBus`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通过命名空间向 D-Bus 注册自己。通常，命名空间使用项目的域名。例如，systemd 声明了 `org.freedesktop.systemd1`
    命名空间，而 D-Bus 的命名空间是 `org.freedesktop.DBus`。
- en: 'The currently associated applications can be queried using Python easily:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当前关联的应用程序可以通过 Python 简单查询：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Each application then provides objects on the bus that can be reached by other
    objects (other applications)—of course, assuming they have the privileges to do
    so. These objects are represented through a path-like syntax and generally also
    use the domain of the project as a prefix.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序然后在总线上提供对象，其他对象（其他应用程序）可以访问这些对象——当然，前提是它们具有相应的权限。这些对象通过类似路径的语法表示，通常也会使用项目的域名作为前缀。
- en: 'For instance, to list the objects currently associated with `org.freedesktop.systemd1`,
    we can use the `gdbus` command. To facilitate its use, we first enable auto-completion
    support, after which we can use the *Tab* key to easily add the appropriate values:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要列出当前与`org.freedesktop.systemd1`关联的对象，我们可以使用`gdbus`命令。为了方便使用，我们首先启用自动完成支持，然后可以使用*Tab*键轻松添加适当的值：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Applications can trigger methods on these objects, or send messages to the applications
    bound to these objects through these methods.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以触发这些对象上的方法，或通过这些方法向绑定到这些对象的应用程序发送消息。
- en: 'For instance, to get the state of the `sshd.service` unit through D-Bus, we
    invoke the `org.freedesktop.systemd1.Manager.GetUnitFileState` method on the `org.freedesktop.systemd1`
    object reachable through the `/org/freedesktop/systemd1` path, and with the `sshd.service`
    argument, like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要通过D-Bus获取`sshd.service`单元的状态，我们在`org.freedesktop.systemd1`对象上的`/org/freedesktop/systemd1`路径调用`org.freedesktop.systemd1.Manager.GetUnitFileState`方法，并带有`sshd.service`参数，像这样：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These calls can also be controlled through the SELinux policy, as we will learn
    next.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将学习，这些调用也可以通过SELinux策略进行控制。
- en: Controlling service acquisition with SELinux
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过SELinux控制服务获取
- en: The D-Bus application, like systemd, will query the SELinux policy to verify
    whether to allow an operation. Again, it is the D-Bus application itself that
    enforces the policy and not a Linux kernel subsystem.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: D-Bus应用程序（如systemd）将查询SELinux策略，以验证是否允许操作。再次强调，实施策略的是D-Bus应用程序本身，而不是Linux内核子系统。
- en: The first control that administrators can enable within D-Bus is to ensure that
    only well-established domains can acquire a specified object within D-Bus. Without
    this control, malicious code could register itself as `org.freedesktop.login1`,
    for instance, and act as a system daemon on the bus. Other applications might
    mistakenly send out sensitive information to the application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员可以在D-Bus中启用的第一个控制是确保只有确立良好的域才能在D-Bus中获取指定的对象。如果没有此控制，恶意代码例如可能会注册自己为`org.freedesktop.login1`，并在总线上作为系统守护进程运行。其他应用程序可能会错误地向应用程序发送敏感信息。
- en: 'Applications store this policy information in files hosted in `/usr/share/dbus-1/system.d`.
    The login service, for instance (stored as `org.freedesktop.login1.conf`) has
    the following policy snippet installed:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将此策略信息存储在位于`/usr/share/dbus-1/system.d`的文件中。例如，登录服务（存储为`org.freedesktop.login1.conf`）安装了以下策略片段：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As the login daemon runs in the `systemd_logind_t` domain, we could enhance
    this configuration as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于登录守护程序在`systemd_logind_t`域中运行，我们可以按以下方式增强此配置：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this enhancement in place, D-Bus will check whether the application (which
    we presume is running in the `systemd_logind_t` context) has the `acquire_svc`
    permission (of the `dbus` class) against the `systemd_logind_t` context. By default,
    the SELinux policy does not have this permission, and as such, the registration
    fails:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完毕后，D-Bus将检查应用程序（我们假定其在`systemd_logind_t`上下文中运行）是否具有`acquire_svc`权限（`dbus`类）对`systemd_logind_t`上下文。默认情况下，SELinux策略不具有此权限，因此注册失败：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When we add the following SELinux policy rule, the registration of `systemd-logind`
    will succeed, as expected:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加以下SELinux策略规则时，`systemd-logind`的注册将如预期般成功：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Load this policy (say `test.cil`) and try the `restart` operation again:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 加载此策略（例如`test.cil`）并再次尝试`restart`操作：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By limiting which domains can obtain a given service, we ensure that only trusted
    applications are used. Non-trusted applications will generally not run within
    the domain of that application (end users, for instance, cannot trigger a transition
    to such a domain) even if they receive root privileges (which is another check
    that D-Bus does for the login service, as shown in the first `busconfig` snippet).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过限制哪些域可以获取特定服务，我们确保仅使用受信任的应用程序。即使非受信任的应用程序获得了root权限（这是D-Bus对登录服务进行的另一个检查，如第一个`busconfig`片段所示），它们通常也不会在该应用程序的域中运行。
- en: Administrators can enhance this D-Bus configuration without having to alter
    the existing configuration files. For instance, the previously mentioned SELinux-governing
    `busconfig` snippet could very well be saved as a different file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员可以增强此D-Bus配置，而无需更改现有的配置文件。例如，先前提到的SELinux管理的`busconfig`片段完全可以保存为不同的文件。
- en: Governing message flows
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理消息流
- en: A second control that D-Bus validates is which applications can communicate
    with each other. This is not configurable through the service configurations but
    is a pure SELinux policy control.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: D-Bus 验证的第二个控制是哪些应用程序可以相互通信。这不能通过服务配置进行配置，而是一个纯粹的 SELinux 策略控制。
- en: Whenever a source application is calling a method of a target application, D-Bus
    validates the `send_msg` permission between the two domains associated with the
    source and target applications.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每当源应用程序调用目标应用程序的方法时，D-Bus 会验证源应用程序和目标应用程序之间的 `send_msg` 权限。
- en: 'For instance, communication over D-Bus between a user domain (`sysadm_t`) and
    service domain (`systemd_logind_t`) will check the following permissions:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在用户域（`sysadm_t`）和服务域（`systemd_logind_t`）之间通过 D-Bus 进行的通信将检查以下权限：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If these permissions are not granted, then D-Bus will not allow the communication
    to happen. If at any point, the application context cannot be obtained, then the
    bus daemon context will be used.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有授予这些权限，D-Bus 将不允许通信发生。如果在任何时候，无法获取应用程序上下文，则将使用总线守护进程上下文。
- en: 'Failures will be logged as `USER_AVC` entries in the audit log. If the communication
    should be allowed, we can create a simple SELinux policy file to address this
    like so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 失败将作为 `USER_AVC` 条目记录在审计日志中。如果通信应该被允许，我们可以像这样创建一个简单的 SELinux 策略文件来解决这个问题：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Store these rules in a file with the suffix `.cil` (say, `local_logind_systemd.cil`),
    and load it with `semodule`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些规则存储在以 `.cil` 结尾的文件中（例如，`local_logind_systemd.cil`），并使用 `semodule` 加载它：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's consider a few other applications that have SELinux support, not necessarily
    built-in, but through the SELinux policy and PAM integration within the system.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些其他具有 SELinux 支持的应用程序，这些支持并不一定是内置的，而是通过系统内的 SELinux 策略和 PAM 集成实现的。
- en: Configuring PAM services
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 PAM 服务
- en: systemd and D-Bus are SELinux-aware applications, with explicit SELinux support
    built in. Several other services exist on a Linux system that play nicely together
    with SELinux yet are not SELinux-aware themselves. Many of these services have
    an affinity with SELinux through their PAM integration.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 和 D-Bus 是支持 SELinux 的应用程序，内置了明确的 SELinux 支持。Linux 系统中还有其他一些服务与 SELinux
    配合良好，尽管它们本身并不支持 SELinux。许多这些服务通过 PAM 集成与 SELinux 相关联。
- en: We covered PAM integration in [*Chapter 3*](B16276_03_Final_VK.xhtml#_idTextAnchor071),
    *Managing User Logins*. In this section, we'll cover three example services using
    PAM, and how SELinux can be further fine-tuned to support these services.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第 3 章*](B16276_03_Final_VK.xhtml#_idTextAnchor071)，*管理用户登录*中讨论了 PAM 集成。在本节中，我们将介绍三个使用
    PAM 的示例服务，以及如何进一步微调 SELinux 以支持这些服务。
- en: Cockpit
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cockpit
- en: Cockpit is a simple, browser-based management application that allows administrators
    to easily see system resources (monitoring) as well as to interact with the system.
    It also allows users to log into the system through the browser.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Cockpit 是一个简单的基于浏览器的管理应用程序，它允许管理员轻松查看系统资源（监控）并与系统交互。它还允许用户通过浏览器登录系统。
- en: 'It is this browser-based terminal that we want to configure: by tuning the
    target SELinux roles for the SELinux users, we can selectively put users in a
    specific role. This effectively defines what the users can accomplish through
    this browser-based session.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这个基于浏览器的终端我们需要配置：通过调整 SELinux 用户的目标 SELinux 角色，我们可以有选择地将用户放入特定角色。这实际上定义了用户可以通过此基于浏览器的会话完成的任务。
- en: Installing Cockpit
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Cockpit
- en: 'The Cockpit application is readily available in the CentOS repository, so installing
    it is a breeze:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Cockpit 应用程序在 CentOS 仓库中随时可用，因此安装起来非常简单：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: While the application does not need additional configuration, if you do need
    tweaks, you will need to create the configuration file, `/etc/cockpit/cockpit.conf`,
    yourself as the application does not create a default configuration file. Within
    this configuration file, you can configure the TLS settings, or disable encrypted
    communication generally.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然应用程序无需额外配置，但如果需要调整，您需要自己创建配置文件 `/etc/cockpit/cockpit.conf`，因为该应用程序不会创建默认配置文件。在此配置文件中，您可以配置
    TLS 设置，或者普遍禁用加密通信。
- en: 'Let''s disable the encrypted communication for this demonstration run (but
    if you intend to use Cockpit in production, you should not only keep encryption
    on but also ensure that only trusted hosts are connecting, possibly even requiring
    client certificate authentication using the `ClientCertAuthentication` directive):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示运行，让我们禁用加密通信（但如果你打算在生产环境中使用Cockpit，除了保持加密开启外，还应该确保只有受信任的主机能连接，可能还需要使用`ClientCertAuthentication`指令来要求客户端证书认证）：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this set, we can continue with configuring SELinux for Cockpit.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好这些之后，我们可以继续配置SELinux以支持Cockpit。
- en: Restricting user logins
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制用户登录
- en: Through these instructions, we will add the more restricted `user_r` role to
    the `staff_u` SELinux user, and then ensure that all logins mapped to the `staff_u`
    SELinux user are logged in using the `user_r` role when they log in through Cockpit.
    If they log in through other services, they will continue using the default `staff_r`
    role.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们将把更为受限的`user_r`角色添加到`staff_u` SELinux用户，并确保所有映射到`staff_u` SELinux用户的登录都通过`user_r`角色登录到Cockpit。如果他们通过其他服务登录，则会继续使用默认的`staff_r`角色。
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The use of the `user_r` role rather than the (even more restricted) `guest_r`
    role is to allow the Cockpit application to function properly. The application
    will run a service under the user's privileges, which are not sufficient for Cockpit
    if we use the `guest_t` user domain.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`user_r`角色而不是（更加受限的）`guest_r`角色，是为了让Cockpit应用程序能够正常工作。应用程序将在用户的权限下运行服务，如果我们使用`guest_t`用户域，权限将不足以支撑Cockpit的正常运行。
- en: 'Let''s first add the `user_r` role so that we can put the users in the correct
    context later:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先添加`user_r`角色，以便稍后将用户放入正确的上下文中：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we want to update the SELinux configuration so that any Cockpit login
    by `staff_u` mapped users is going to use the `user_r` role. The Cockpit application
    has logins done through a service running in the `cockpit_session_t` context,
    which we find out by checking the context of the process first, and then logging
    in on Cockpit and checking the context of the processes again. There, we notice
    that a new process (`cockpit-session`) runs with the `cockpit_session_t` context:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望更新SELinux配置，以确保任何由`staff_u`映射的用户登录Cockpit时都将使用`user_r`角色。Cockpit应用程序的登录是通过在`cockpit_session_t`上下文中运行的服务进行的，我们通过先检查进程的上下文，然后登录Cockpit并再次检查进程的上下文来得知这一点。在这里，我们注意到一个新进程（`cockpit-session`）以`cockpit_session_t`上下文运行：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With this information now available, we can edit the `/etc/selinux/targeted/contexts/users/staff_u`
    file as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了这些信息，我们可以按照如下方式编辑`/etc/selinux/targeted/contexts/users/staff_u`文件：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: By adjusting the order of the roles listed for the `cockpit_session_t` context
    (or limiting them to only the `user_r` role), we ensure that users allowed to
    run with the `user_r` role (like the `staff_u` user we configured earlier on)
    do so through the `user_r` role. As this role is more restricted than the default
    `staff_t` user domain, logins through Cockpit are thus more isolated.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调整`cockpit_session_t`上下文中列出的角色顺序（或者将其限制为仅使用`user_r`角色），我们可以确保允许以`user_r`角色运行的用户（就像我们之前配置的`staff_u`用户）通过`user_r`角色进行操作。由于这个角色比默认的`staff_t`用户域更为受限，因此通过Cockpit进行的登录会更加隔离。
- en: This approach can be used for all PAM-enabled services, as this solely relies
    on the `pam_selinux.so` call in the service PAM configuration. For some services,
    the SELinux policy administrators add in a few more tweaks to use, such as with
    cron and SSH, which we'll discuss next.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于所有支持PAM的服务，因为它仅依赖于服务PAM配置中的`pam_selinux.so`调用。对于某些服务，SELinux策略管理员还会加入更多的调整，例如在cron和SSH中，我们接下来会讨论。
- en: Cron
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cron
- en: Cron services on a system allow you to run tasks or commands on predefined schedules.
    Some cron applications are explicitly made SELinux-aware (such as fcron), allowing
    them to compute the target context a job should run in. Even cron systems that
    do not have any specific SELinux logic built in can be fine-tuned.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的Cron服务允许你按预定计划运行任务或命令。一些Cron应用程序明确支持SELinux（如fcron），使其能够计算作业应运行的目标上下文。即使是没有任何SELinux逻辑的Cron系统，也可以进行精细调优。
- en: Switching between user-specific and generic contexts
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切换用户特定与通用上下文
- en: A common setup supported through the SELinux policy is to toggle whether user
    tasks run in the user's default context (such as `staff_t` for staff users) or
    in a default, restricted cron context (`cronjob_t`). Both approaches have their
    pros and cons.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 SELinux 策略支持的常见设置是切换用户任务是否在用户的默认上下文中运行（例如，员工用户的 `staff_t`），或在默认的受限 cron 上下文中运行（`cronjob_t`）。这两种方法各有优缺点。
- en: When we configure the system to have user jobs run in the user's default context,
    then users know what the privileges are of their jobs. A guest user has guest
    privileges, a staff user has staff privileges, and so forth. This is the most
    common configuration, and the default cron system on CentOS uses the context of
    the file containing the user's tasks (located in `/var/spool/cron`) to deduce
    the target runtime context.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们配置系统使得用户作业在用户的默认上下文中运行时，用户将知道他们作业的权限。访客用户有访客权限，员工用户有员工权限，依此类推。这是最常见的配置，CentOS
    上的默认 cron 系统使用包含用户任务的文件上下文（位于 `/var/spool/cron`）来推断目标运行时上下文。
- en: By running user jobs in a more restricted context such as `cronjob_t`, all users'
    cron jobs run with the same privileges, and the administrator can easily fine-tune
    the privileges for all user jobs. This also allows the administrator to grant
    specific privileges for cron jobs while keeping the user contexts free of these
    rights.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在更受限制的上下文中运行用户任务，如`cronjob_t`，所有用户的 cron 作业将以相同的权限运行，管理员可以轻松微调所有用户作业的权限。这还允许管理员为
    cron 作业授予特定权限，同时保持用户上下文不包含这些权限。
- en: 'Let''s have a simple task executed every minute, namely a 59-second sleep.
    As a regular user, create a file (let''s say `lisa.cron`) with the following content:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个简单的任务，每分钟执行一次，即休眠 59 秒。作为普通用户，创建一个文件（假设是 `lisa.cron`），内容如下：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This file uses the common cron syntax, where the following applies:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件使用常见的 cron 语法，其中适用以下规则：
- en: The first field covers the minute.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个字段表示分钟。
- en: The second field covers the hour.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个字段表示小时。
- en: The third field covers the day of the month.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个字段表示日期。
- en: The fourth field covers the month.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四个字段表示月份。
- en: The fifth field covers the day of the week.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第五个字段表示星期几。
- en: The rest of the line is the command to execute.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该行的其余部分是要执行的命令。
- en: The fields can use expressions to facilitate time definitions. For instance,
    to run every 15 minutes, you can use `*/15` in the first field. If you want to
    run only at 8 o'clock and 18 o'clock, you can use the `8,18` value in the second
    field. Another example is if you only want to run on workdays, for which you can
    use `1-5` in the fifth field (in cron, Sunday holds both 0 and 7 as valid values).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 各个字段可以使用表达式来简化时间定义。例如，要每 15 分钟执行一次，可以在第一个字段中使用 `*/15`。如果你只想在 8 点和 18 点执行，可以在第二个字段中使用
    `8,18`。另一个例子是，如果你只想在工作日执行，可以在第五个字段中使用 `1-5`（在 cron 中，星期天的有效值是 0 和 7）。
- en: 'By loading it with the `crontab` command, the file is checked for errors and,
    if error-free, is securely placed inside `/var/spool/cron` (the `crontab` command
    is a `setuid` command that is able to modify `/var/spool/cron` even though this
    location is inaccessible by regular users):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `crontab` 命令加载它，文件会被检查错误，如果没有错误，它将安全地放置在 `/var/spool/cron` 中（`crontab`
    命令是一个 `setuid` 命令，能够修改 `/var/spool/cron`，即使常规用户无法访问此位置）：
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'From here, the cron daemon will pick up this file, and 1 minute later we will
    see the command active in the background:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，cron 守护进程会拾取这个文件，1 分钟后，我们将看到命令在后台激活：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As seen from the output, the command is running in the `staff_t` context. To
    change this to the `cronjob_t` type, rather than editing the SELinux context definition
    file as we did with the Cockpit application, use the `cron_userdomain_transition`
    SELinux boolean:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看到，命令正在 `staff_t` 上下文中运行。要将其更改为 `cronjob_t` 类型，而不是像我们在 Cockpit 应用程序中那样编辑
    SELinux 上下文定义文件，可以使用 `cron_userdomain_transition` SELinux 布尔值：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This boolean changes the active SELinux policy behavior so that any user task
    executed from the cron system executes within the `cronjob_t` domain. You might
    need to reset the crontab definition (this depends on the cron system used), but
    afterward, we will see the job running in the `cronjob_t` domain:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 该布尔值会更改活动的 SELinux 策略行为，使得从 cron 系统执行的任何用户任务都在 `cronjob_t` 域中执行。您可能需要重置 crontab
    定义（这取决于使用的 cron 系统），但之后，我们将看到作业在 `cronjob_t` 域中运行：
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The use of SELinux booleans to allow administrators to differentiate system
    behavior as needed is commonly used. For the SSH daemon, SELinux policy administrators
    have defined something similar.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SELinux布尔值来允许管理员根据需要区分系统行为是常见的做法。对于SSH守护进程，SELinux策略管理员定义了类似的规则。
- en: OpenSSH
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenSSH
- en: The OpenSSH daemon is the most common secure shell daemon around. It allows
    users to remotely access systems through a terminal, as well as to securely transfer
    files, tunnel application communications, and more.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH守护进程是最常见的安全Shell守护进程。它允许用户通过终端远程访问系统，还可以安全地传输文件、建立应用程序通信隧道等。
- en: When logging in through SSH, the PAM controls apply, but the SELinux policy
    also has specific SSH controls embedded and controllable through SELinux booleans.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SSH登录时，PAM控制会生效，但SELinux策略也嵌入了特定的SSH控制，并可以通过SELinux布尔值进行控制。
- en: Directly logging in as sysadm_t
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接以sysadm_t登录
- en: The first change to assess is to allow directly logging in using the `sysadm_r`
    role. Users mapped to the `staff_u` SELinux user by default log in using the (more
    restricted) `staff_r` role, and then need to explicitly switch roles to obtain
    the more privileged `sysadm_r` role.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个需要评估的更改是允许直接以`sysadm_r`角色登录。默认情况下，映射到`staff_u` SELinux用户的用户使用（限制更多的）`staff_r`角色登录，然后需要显式切换角色以获得更特权的`sysadm_r`角色。
- en: 'The first change we need to make is to edit the `/etc/selinux/targeted/contexts/users/staff_u`
    file and adjust the order of the roles listed for the `sshd_t` context:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要进行的第一个更改是编辑`/etc/selinux/targeted/contexts/users/staff_u`文件，并调整`sshd_t`上下文中列出的角色顺序：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: However, this is not enough. The SELinux policy administrators have disabled
    direct logins through SSH to the `sysadm_r` role, forcing users to explicitly
    change roles (and thus reauthenticate). This approach is because SSH is often
    a publicly reachable and not otherwise easily controllable service (unlike services
    such as web servers, which can have reverse proxies and web application firewalls
    in front).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这还不够。SELinux策略管理员已禁用通过SSH直接登录到`sysadm_r`角色，迫使用户显式切换角色（从而重新认证）。这种做法是因为SSH通常是一个公开可访问且难以控制的服务（与如Web服务器等服务不同，后者可以通过反向代理和Web应用防火墙进行保护）。
- en: 'Change the SELinux `ssh_sysadm_login` boolean to `true` to enable the wanted
    behavior:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将SELinux的`ssh_sysadm_login`布尔值更改为`true`以启用所需的行为：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This boolean changes the SELinux policy behavior to allow logins to the `sysadm_r`
    role from the SSH daemon.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 该布尔值更改SELinux策略行为，允许通过SSH守护进程登录到`sysadm_r`角色。
- en: Chrooting Linux users
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chroot Linux用户
- en: Another feature that SSH supports is forcing logins from selected users to be
    chrooted. A **chroot** (which is a portmanteau of **change root**) is an isolation
    method for processes, where the process no longer sees the entire filesystem but
    only a part of it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: SSH支持的另一个功能是强制选定用户的登录进行chroot操作。**chroot**（即**改变根目录**的合成词）是一种进程隔离方法，进程不再看到整个文件系统，而只能看到其中的一部分。
- en: Informational note
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 信息性说明
- en: Now, chroot environments are an easy way to isolate processes, but a chroot
    itself is still governed through Linux's discretionary access controls, and escaping
    chroot environments is not impossible. Using SELinux to further confine the process
    is recommended but is not in the scope of this section. For that, we refer to
    [*Chapter 14*](B16276_14_Final_VK.xhtml#_idTextAnchor354), *Dealing with New Applications*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，chroot环境是隔离进程的一种简便方法，但chroot本身仍然受到Linux的自由访问控制的管理，逃脱chroot环境并非不可能。建议使用SELinux进一步限制进程，但这超出了本节的范围。有关内容，请参见[*第14章*](B16276_14_Final_VK.xhtml#_idTextAnchor354)，*处理新应用程序*。
- en: 'Before we configure SSH to chroot some users, we need to create a properly
    functioning environment: once we change the root for a process, all commands and
    libraries that the process wants to read or execute need to be available within
    this chroot environment.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们配置SSH以chroot某些用户之前，我们需要创建一个正确运行的环境：一旦我们更改了进程的根目录，进程希望读取或执行的所有命令和库都需要在此chroot环境中可用。
- en: Let's first create a chroot environment. A nice utility that assists in creating
    the right folder structure and files is Jailkit. Jailkit is not available by default
    through the regular repositories but can be easily installed and only requires
    a working compiler and Python environment.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个chroot环境。一个有用的工具是Jailkit，它有助于创建正确的文件夹结构和文件。Jailkit默认不在常规仓库中提供，但可以轻松安装，并且只需要一个有效的编译器和Python环境。
- en: 'We start off by installing the necessary dependencies:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先安装必要的依赖项：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we download the Jailkit source code and build it. As CentOS does not
    have a linked Python binary by default (as it requires the use of `python3` as
    the runtime), we need to tell the build scripts how to address Python. We do this
    by declaring the `PYTHONINTERPRETER` environment variable:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们下载 Jailkit 源代码并进行构建。由于 CentOS 默认没有链接的 Python 二进制文件（因为它需要使用 `python3` 作为运行时），我们需要告诉构建脚本如何处理
    Python。我们通过声明 `PYTHONINTERPRETER` 环境变量来实现：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once the installation is complete, you might need to remove a duplicate `includesections`
    call within the Jailkit configuration file (the `jk_init` command, which we will
    use next, will inform you about it if you don''t). The `openvpn` section in `/etc/jailkit/jk_init.ini`
    should look like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可能需要移除 Jailkit 配置文件中重复的 `includesections` 调用（如果您没有移除，接下来的 `jk_init` 命令会提示您）。`/etc/jailkit/jk_init.ini`
    中的 `openvpn` 部分应如下所示：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With the configuration updated, we can now create the chroot environment. Let''s
    create the `/srv/chroot` directory and then populate it with the necessary files,
    directories, device nodes, and more with the `jk_init` command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 配置更新后，我们现在可以创建 chroot 环境。让我们创建 `/srv/chroot` 目录，并使用 `jk_init` 命令将必要的文件、目录、设备节点等添加到该目录中：
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We want to make sure that the SELinux contexts for the resources inside this
    location are equivalent to the root location, so let''s create a file context
    equivalency definition:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望确保此位置内资源的 SELinux 上下文与根位置相等，因此让我们创建一个文件上下文等效定义：
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With the chroot environment set, we can now update the SSH configuration to
    chroot a user:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好 chroot 环境后，我们现在可以更新 SSH 配置，以便将用户限制在 chroot 中：
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'While not applicable to all systems (as it depends on the distribution), we
    might need to tell the SELinux policy that the user domains for the users can
    chroot. This privilege (`sys_chroot`) is often not enabled by default for user
    domains:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并非所有系统都适用（因为这取决于发行版），我们可能需要告诉 SELinux 策略，用户域的用户可以进行 chroot 操作。此权限（`sys_chroot`）通常在默认情况下未启用：
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With this set, restart the SSH daemon and see whether the chroot is successful:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，重启 SSH 守护进程并查看 chroot 是否成功：
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Chroot environments are not only sensible for SSH access; other daemons might
    support chroot environments to further protect the resources on the system. In
    the past, chroot support was a common way to further harden the system. Namespace
    and resource isolation support has, however, largely surpassed the need for chroot
    jails. These new features have also jumpstarted the containerized ecosystem, which
    we will cover in [*Chapter 11*](B16276_11_Final_VK.xhtml#_idTextAnchor293), *Enhancing
    the Security of Containerized Workloads*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Chroot 环境不仅仅对 SSH 访问有意义；其他守护进程也可能支持 chroot 环境，以进一步保护系统资源。在过去，chroot 支持是进一步强化系统的一种常见方式。然而，命名空间和资源隔离的支持已经大大超越了
    chroot 监狱的需求。这些新特性也推动了容器化生态系统的发展，我们将在[*第11章*](B16276_11_Final_VK.xhtml#_idTextAnchor293)中讨论，*增强容器化工作负载的安全性*。
- en: The SELinux support for applications such as Cockpit, cron, and OpenSSH is generally
    provided through the SELinux policy and uses PAM integration to link SELinux controls
    within the application. It is, however, also possible to explicitly build in SELinux
    support in applications not intentionally SELinux-aware, but who support dynamic
    additions of logic through a modular design. As an example of this, we will look
    at Apache and the `mod_selinux` Apache module next.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于诸如 Cockpit、cron 和 OpenSSH 等应用程序，SELinux 的支持通常通过 SELinux 策略提供，并使用 PAM 集成将 SELinux
    控制链接到应用程序中。然而，也可以显式地在未专门支持 SELinux 的应用程序中构建 SELinux 支持，只要这些应用程序支持通过模块化设计动态添加逻辑。作为此例，我们接下来将讨论
    Apache 和 `mod_selinux` Apache 模块。
- en: Using mod_selinux with Apache
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 mod_selinux 配合 Apache
- en: Applications are often web-based, exposing their interface as either a common
    website or a simple web service, and executing the bulk of logic either within
    the web server or in backend services that the web server interacts with for the
    user.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常是基于 Web 的，它们将界面暴露为常见的网站或简单的 Web 服务，并在 Web 服务器中执行大部分逻辑，或者在 Web 服务器与用户交互的后台服务中执行逻辑。
- en: A web-based application has the huge advantage that end users often don't require
    any application or client to be installed on top of what is available by default
    on their device, be it a workstation, laptop, mobile, wristwatch, or smart TV.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Web 的应用程序具有巨大的优势，即最终用户通常不需要在其设备上安装任何额外的应用程序或客户端，无论是工作站、笔记本电脑、手机、手表还是智能电视。
- en: However, unlike the services discussed earlier, Apache does not run individual
    user sessions through PAM logins on the system. Instead, user requests are handled
    by the web server threads and processes themselves, which makes easy SELinux-based
    controls a bit harder to accomplish.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与之前讨论的服务不同，Apache并没有通过系统上的PAM登录运行单独的用户会话。相反，用户请求是由Web服务器线程和进程本身处理的，这使得简单的基于SELinux的控制变得有些困难。
- en: Introducing mod_selinux
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍mod_selinux
- en: 'Apache has support for modules: dynamically loadable code that enhances the
    functionality of the web server, without having to rebuild the web server code
    itself. This modularity has given rise to the popularity of Apache, as we can
    see through its support for features such as PHP, introducing dynamic web applications
    to a server platform that was once meant to serve static content only.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Apache支持模块：可以动态加载的代码，增强Web服务器的功能，而无需重新编译Web服务器的代码。正是这种模块化使Apache变得非常流行，正如我们通过它对PHP等功能的支持所看到的，它将动态Web应用程序引入到一个曾经仅用于提供静态内容的服务器平台中。
- en: '`mod_selinux` uses the same modular support, which allows the Apache web server
    to become SELinux-aware. Once we enable `mod_selinux`, we can configure Apache
    to switch SELinux sensitivity or even SELinux domains for running code, further
    isolating the behavior of the web server and allowing SELinux policies to control
    what the web server can do. `mod_selinux` also supports user mappings, allowing
    the Apache web server to run specific user sessions in different domains.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod_selinux`使用相同的模块化支持，使得Apache Web服务器可以变得对SELinux更加敏感。一旦我们启用`mod_selinux`，就可以配置Apache切换SELinux敏感性，甚至为运行的代码切换SELinux域，从而进一步隔离Web服务器的行为，并允许SELinux策略控制Web服务器能够执行的操作。`mod_selinux`还支持用户映射，使Apache
    Web服务器能够在不同的域中运行特定的用户会话。'
- en: 'Before building the `mod_selinux` module, let''s first install the necessary
    dependencies on the system:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建`mod_selinux`模块之前，我们先在系统上安装必要的依赖项：
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once the dependencies are installed, we can download and build the `mod_selinux`
    code. The code is available on GitHub in Kaigai''s `mod_selinux` repository:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完依赖项后，我们可以下载并构建`mod_selinux`代码。该代码可以从GitHub的Kaigai的`mod_selinux`仓库中获取：
- en: '[PRE52]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `apxs` command is the `-c`) and installs (`-i`) the `mod_selinux` module.
    We have yet to activate it in the Apache configuration though, which we accomplish
    by creating a new module configuration file in `/etc/httpd/conf.modules.d` called
    `99-selinux.conf` (you can pick whatever name you want, but make sure it ends
    with the `.conf` suffix):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`apxs`命令是`-c`）和安装（`-i`）`mod_selinux`模块的命令。不过，我们还没有在Apache配置中激活它，我们通过在`/etc/httpd/conf.modules.d`目录下创建一个新的模块配置文件`99-selinux.conf`（你可以选择任何你喜欢的名称，但确保它以`.conf`后缀结尾）来实现这一点：'
- en: '[PRE53]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, while we have now installed the module, it is not ready for consumption
    yet, as we have not loaded the SELinux policy for it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然我们已经安装了该模块，但它还不能使用，因为我们还没有加载适用于它的SELinux策略。
- en: 'The `mod_selinux` repository contains the necessary SELinux policy code. However,
    it is not fully compatible with the more recent SELinux policy used by Linux distributions.
    We need to edit the `mod_selinux.if` file and remove all references to `httpd_user_script_ro_t`,
    `httpd_user_script_rw_t`, and `httpd_user_script_ra_t`, as those types are no
    longer present in current SELinux policies:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod_selinux`仓库包含了必要的SELinux策略代码。然而，它与Linux发行版使用的较新SELinux策略并不完全兼容。我们需要编辑`mod_selinux.if`文件，并删除所有关于`httpd_user_script_ro_t`、`httpd_user_script_rw_t`和`httpd_user_script_ra_t`的引用，因为这些类型在当前的SELinux策略中已经不再出现：'
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'A second change – cosmetic for now – is to rename the calls from `miscfiles_read_certs`
    to `miscfiles_read_generic_certs`. These are functions used in the reference policy,
    a different – and still the most common way – of writing SELinux policies (which
    we cover in [*Chapter 15*](B16276_15_Final_VK.xhtml#_idTextAnchor373), *Using
    the Reference Policy*), and while both functions are supported at the time of
    writing, the `miscfiles_read_certs` function is no longer recommended for use
    and will disappear soon:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个更改——目前是外观上的——是将函数调用从`miscfiles_read_certs`重命名为`miscfiles_read_generic_certs`。这些是参考策略中使用的函数，参考策略是编写SELinux策略的一种不同方式——仍然是最常见的方式（我们将在[*第15章*](B16276_15_Final_VK.xhtml#_idTextAnchor373)，*使用参考策略*中详细介绍）。虽然在写作时这两个函数都被支持，但`miscfiles_read_certs`函数不再推荐使用，并且很快会被废弃：
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once we have adjusted the policy, we can build and load it. As this policy
    is developed using the reference policy style, the installation first requires
    building the module before we load it (unlike the directly loadable CIL examples
    we''ve used so far):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们调整了策略，就可以构建并加载它。由于该策略是使用参考策略样式开发的，安装时首先需要构建模块，然后再加载它（与我们到目前为止使用的直接可加载的 CIL
    示例不同）。
- en: '[PRE56]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With the SELinux module loaded and the `mod_selinux` Apache module installed,
    we can start configuring the Apache daemon with SELinux-specific controls.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载 SELinux 模块并安装 `mod_selinux` Apache 模块后，我们可以开始使用 SELinux 特定的控制配置 Apache 守护进程。
- en: Configuring the general Apache SELinux sensitivity
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置一般的 Apache SELinux 敏感度
- en: The simplest configuration setting that `mod_selinux` supports is to configure
    Apache to run with a specific SELinux sensitivity. Suppose we want Apache to run
    with the `s0-s0:c0.c100` sensitivity, then we need to adjust the Apache configuration
    and use the `selinuxServerDomain` directive.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod_selinux` 支持的最简单配置设置是配置 Apache 以特定的 SELinux 敏感度运行。假设我们希望 Apache 以 `s0-s0:c0.c100`
    敏感度运行，那么我们需要调整 Apache 配置并使用 `selinuxServerDomain` 指令。'
- en: 'Assuming we want to adjust the sensitivity for the default welcome site, edit
    `/etc/httpd/conf.d/welcome.conf` and add in the following code snippet:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想调整默认欢迎页面的敏感度，可以编辑 `/etc/httpd/conf.d/welcome.conf` 并添加以下代码片段：
- en: '[PRE57]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If the Apache web server uses virtual host definitions (allowing a single web
    server definition to manage multiple websites, based on the hostname that the
    client is using to access the web content), the `selinuxDomainVal` directive needs
    to be used instead of the `selinuxServerDomain` one.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Apache Web 服务器使用虚拟主机定义（允许一个 Web 服务器定义管理多个网站，基于客户端用于访问 Web 内容的主机名），则需要使用 `selinuxDomainVal`
    指令，而不是 `selinuxServerDomain` 指令。
- en: 'For instance, suppose the web server manages two virtual hosts, one for the
    `apps.genfic.local` domain, and the other for `intranet.genfic.local`, then we
    can assign each virtual host with its own sensitivity set like so:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设 Web 服务器管理两个虚拟主机，一个用于 `apps.genfic.local` 域，另一个用于 `intranet.genfic.local`，那么我们可以像这样为每个虚拟主机分配各自的敏感度设置：
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Restart the Apache web server and validate that the setting is active:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 重启 Apache Web 服务器并验证该设置是否已生效：
- en: '[PRE59]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As you can see, the web server is now running with the given sensitivity. An
    important caveat though: the `mod_selinux` code does not support `mcstransd`,
    the translation daemon we covered in [*Chapter 3*](B16276_03_Final_VK.xhtml#_idTextAnchor071),
    *Managing User Logins*, so you cannot use human-readable sensitivity definitions
    such as `SystemLow-SystemHigh`.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Web 服务器现在正在以给定的敏感度运行。不过，重要的警告是：`mod_selinux` 代码不支持 `mcstransd`，即我们在 [*第
    3 章*](B16276_03_Final_VK.xhtml#_idTextAnchor071) 中介绍的翻译守护进程，*管理用户登录*，因此不能使用诸如
    `SystemLow-SystemHigh` 之类的易读敏感度定义。
- en: Mapping end users to specific domains
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将最终用户映射到特定域
- en: To map users, when logged in to a web application, to a specific domain, we
    need to create a user mapping file. This mapping file is then referred to using
    the `selinuxDomainMap` directive in the web server configuration.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要将用户映射到特定域（当用户登录到 Web 应用时），我们需要创建一个用户映射文件。然后，在 Web 服务器配置中使用 `selinuxDomainMap`
    指令引用该映射文件。
- en: 'Let''s first create the mapping file inside `/etc/httpd/conf.d`, naming it
    `mod_selinux.map`, with the following content:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 `/etc/httpd/conf.d` 下创建映射文件，命名为 `mod_selinux.map`，并使用以下内容：
- en: '[PRE60]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This mapping file contains three mappings:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 该映射文件包含三个映射：
- en: The first one is for a user called `test` and is mapped to the `user_webapp_t`
    domain and `s0:c0.c100` sensitivity.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个映射适用于名为 `test` 的用户，映射到 `user_webapp_t` 域，并具有 `s0:c0.c100` 敏感度。
- en: The second one is for any successfully authenticated user and is mapped to the
    `user_webapp_t` domain and `s0:c0,c1` sensitivity.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个映射适用于任何成功通过身份验证的用户，映射到 `user_webapp_t` 域，并具有 `s0:c0,c1` 敏感度。
- en: The third one is for unauthenticated users and is mapped to the `anon_webapp_t`
    domain.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个映射适用于未通过身份验证的用户，映射到 `anon_webapp_t` 域。
- en: 'We can then refer to this map by adjusting the previously created snippet like
    so:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过调整先前创建的代码片段来引用此映射：
- en: '[PRE61]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Restart the web server to apply the changes.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 重启 Web 服务器以应用更改。
- en: Changing domains based on source
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于源更改域
- en: The `mod_selinux` module also supports setting the server domain value based
    on environment variables that we have defined elsewhere in the configuration.
    For instance, we can first declare the value in an environment variable when a
    certain condition triggers, and then tell `mod_selinux` that this environment
    variable's value is to be used for the server domain setting.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod_selinux`模块还支持根据我们在其他地方配置中定义的环境变量设置服务器域值。例如，我们可以在某个条件触发时，首先在环境变量中声明该值，然后告诉`mod_selinux`使用该环境变量的值来设置服务器域。'
- en: Let's make this a bit more tangible with an example. Suppose the website manages
    web applications for both local (internal) people, as well as for people that
    work from remote locations. Assuming these users enter the web server through
    different source IP addresses, we can use the source IP address to differentiate
    between the two and assign a different SELinux sensitivity value.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来更直观地理解这一点。假设网站同时管理本地（内部）用户和远程办公用户的Web应用程序。假设这些用户通过不同的源IP地址访问Web服务器，我们可以通过源IP地址来区分两者，并分配不同的SELinux敏感度值。
- en: We can do this in the Apache configuration with the `SetEnvIf` directive, which
    declares an environment variable but only if a request matches a particular condition.
    The condition we use is then the `Remote_Addr` directive, which checks the source
    IP address against the expression that follows.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Apache配置中使用`SetEnvIf`指令来实现这一点，该指令声明一个环境变量，但仅当请求符合特定条件时才会声明。我们使用的条件是`Remote_Addr`指令，它会检查源IP地址是否与后面的表达式匹配。
- en: 'Suppose local users come from `10.10.0.0/16` and remote users from a load balancer
    or reverse proxy with the IP address `10.121.12.15`, then we can differentiate
    this as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 假设本地用户来自`10.10.0.0/16`，远程用户来自负载均衡器或反向代理，IP地址为`10.121.12.15`，那么我们可以如下区分：
- en: '[PRE62]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: It is possible to mix and match multiple `mod_selinux` directives. The module
    will use the first successful declaration, so you could use a user mapping first,
    and if that user mapping does not result in a hit (because the user is not declared
    in the map), use the environment variable, and if that fails, fall back to a default
    setting.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 可以混合使用多个`mod_selinux`指令。该模块会使用第一个成功的声明，因此你可以首先使用用户映射，如果该映射没有命中（因为该用户没有在映射中声明），则使用环境变量，如果仍然失败，则回退到默认设置。
- en: 'All we have to do to accomplish this fallback definition is to sequentially
    declare the `mod_selinux` directives, like so:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种回退定义，我们只需要按顺序声明`mod_selinux`指令，像这样：
- en: '[PRE63]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Through these declarations, you can fine-tune the web server security using
    SELinux domains and sensitivities. While this should never replace the security
    approach within the application itself, it provides additional isolation in case
    an unauthorized or malicious user exploits an error within the application.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些声明，你可以利用SELinux域和敏感度对Web服务器的安全性进行微调。虽然这永远不能替代应用程序内部的安全措施，但它提供了额外的隔离，以防未经授权或恶意用户利用应用程序中的漏洞。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started out with an introduction to systemd and a strong
    focus on the service management capabilities that systemd offers. We learned how
    to start a service with a custom SELinux context as well as how additional files
    can be properly labeled upon boot. Alongside the service management, through systemd's
    unit files, this chapter also covered transient services and how to immediately
    associate the right SELinux context.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了systemd，并重点讲解了systemd所提供的服务管理功能。我们学习了如何使用自定义SELinux上下文启动服务，以及如何在启动时正确标记附加文件。除了服务管理外，通过systemd的单元文件，本章还涵盖了瞬时服务以及如何立即关联正确的SELinux上下文。
- en: Other systemd capabilities and services were touched upon as well. We saw how
    SELinux contexts are registered as part of the systemd journal and how to query
    for events using this context. We took a brief look at udev and how its rules
    can be used to support administrators in managing devices. One of its actions
    is to set the SELinux context of the device node.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 还简要提到了一些其他systemd的功能和服务。我们看到SELinux上下文如何作为systemd日志的一部分进行注册，以及如何使用该上下文查询事件。我们简要了解了udev及其规则如何帮助管理员管理设备。它的一个操作是设置设备节点的SELinux上下文。
- en: We then looked at D-Bus, how SELinux can be used to control the association
    of applications with services, and how D-Bus uses the `send_msg` permission to
    validate communications across its channels.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们探讨了 D-Bus，了解 SELinux 如何用来控制应用程序与服务的关联，以及 D-Bus 如何使用 `send_msg` 权限来验证其通道之间的通信。
- en: After D-Bus, we looked at several services that use PAM to launch user contexts,
    and we dived into specific examples such as SSH, learning how SELinux policy developers
    have further fine-tuned support for these services.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在讲解 D-Bus 后，我们查看了几个使用 PAM 启动用户上下文的服务，并深入探讨了具体示例，如 SSH，了解 SELinux 策略开发者如何进一步优化这些服务的支持。
- en: We finished with a look at `mod_selinux`, a dynamic module for Apache that enables
    SELinux support within Apache's configuration even though Apache itself does not
    have any SELinux specifics in it.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后查看了 `mod_selinux`，这是一个为 Apache 提供 SELinux 支持的动态模块，尽管 Apache 本身并未包含任何 SELinux
    特性，它依然可以在 Apache 配置中启用 SELinux 支持。
- en: In the next chapter, we will look at another SELinux-aware application, SEPostgreSQL,
    which extends the popular and robust PostgreSQL database with mandatory access
    control support through SELinux.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨另一个支持 SELinux 的应用程序 SEPostgreSQL，它通过 SELinux 为流行且强大的 PostgreSQL 数据库扩展了强制访问控制支持。
- en: Questions
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why should you not update unit files in `/usr/lib/systemd/system` directly?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不应该直接更新 `/usr/lib/systemd/system` 中的单元文件？
- en: What application allows resetting the SELinux context of files during boot?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个应用程序可以在启动时重置文件的 SELinux 上下文？
- en: How can we get all log events in journald associated with a given SELinux context?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何获取与给定 SELinux 上下文相关的所有 journald 日志事件？
- en: How can you set the SELinux label for a device node created by udev?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何为由 udev 创建的设备节点设置 SELinux 标签？
- en: Are SELinux controls always applicable to D-Bus associations?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SELinux 控制是否总是适用于 D-Bus 关联？
- en: How is it possible for Apache to be SELinux-aware without Apache having any
    SELinux code in it?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Apache 如何在没有包含任何 SELinux 代码的情况下，仍然能够识别 SELinux？
