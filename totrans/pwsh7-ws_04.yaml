- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: PowerShell Variables and Data Structures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell 变量和数据结构
- en: It’s time to really understand what we mean when we talk about variables. Variables
    are a common concept in computer science and mathematics, so it’s important to
    have a good grasp of what they are and how they are used in PowerShell.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候真正理解我们谈论变量时的含义了。变量是计算机科学和数学中的常见概念，因此，理解它们是什么以及它们如何在 PowerShell 中使用非常重要。
- en: We’ll start by exploring what a variable is, both literally and metaphorically.
    We will look at how we can use them in PowerShell and contrast the way PowerShell
    works with other languages. We will explore the concept of primitives, the basic
    building blocks of data, before moving on to the common data structures that PowerShell
    uses. Finally, we’ll have some fun with splatting, an important and useful technique
    for simplifying cmdlets.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从探索变量的字面意义和隐喻意义开始。我们将研究如何在 PowerShell 中使用它们，并将 PowerShell 的工作方式与其他语言进行对比。我们将探索基本数据类型的概念，它们是数据的基本构建块，然后再讨论
    PowerShell 使用的常见数据结构。最后，我们将通过解包这一重要且有用的技术来简化 cmdlet，来增加一些乐趣。
- en: In this chapter, we’re going to cover the following main topics.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题。
- en: Understanding PowerShell variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 PowerShell 变量
- en: Exploring object types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索对象类型
- en: Discovering value types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现值类型
- en: Typing explained
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入解释
- en: Navigating reference types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航引用类型
- en: Splatting – using hashtables for fun and profit
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解包 – 用哈希表来获取乐趣和利润
- en: Understanding PowerShell variables
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 PowerShell 变量
- en: A variable is like a box. We can put stuff in it. We can take that stuff out
    and put something else in it. The box may contain one thing, or it may contain
    many things. It may contain multiple things of the same type, for instance, 30
    pairs of socks, or it can be like my kitchen drawer, and contain all sorts of
    different things, including string. We can organize the things it contains in
    different ways or not organize them, like my kitchen drawer. It may contain nothing
    at all.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 变量就像一个盒子。我们可以把东西放进去。我们可以把这些东西拿出来，再放进去别的东西。这个盒子可能包含一件东西，或者可能包含很多东西。它可以包含同一种类型的多个东西，例如，30双袜子，或者它可以像我的厨房抽屉一样，包含各种不同的东西，包括线。我们可以以不同的方式组织它包含的东西，或者像我的厨房抽屉一样不组织它们。它可能什么也不包含。
- en: A variable is really a label for a region of memory. That’s all it is – a name
    and an address in memory. When you tell PowerShell to use the contents of a variable,
    you’re telling it to go to that area of memory and use what it finds there. Using
    a label gives us two advantages; firstly, it saves a lot of typing, especially
    if the variable contains many objects. Secondly, it allows us to assign meaning,
    something that tells us, and other people reading our code, what the purpose of
    the variable is, and a clue as to what it likely contains. This is far more important
    and useful than it may appear right now.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 变量实际上是内存区域的标签。它仅仅是一个名称和内存中的地址。当你告诉 PowerShell 使用变量的内容时，你是在告诉它去那个内存区域并使用那里的内容。使用标签给我们带来两个优势；首先，它节省了大量输入，尤其是当变量包含多个对象时。其次，它允许我们赋予变量含义，这样我们和其他读代码的人就能明白变量的目的，并且有一个线索了解它可能包含的内容。这比它现在看起来的要重要和有用得多。
- en: '![Figure 4.1 – Ceci n’est pas une variable. With apologies to Magritte](img/B17600_04_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 这不是一个变量。向马格里特致歉](img/B17600_04_01.jpg)'
- en: Figure 4.1 – Ceci n’est pas une variable. With apologies to Magritte
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 这不是一个变量。向马格里特致歉
- en: 'PowerShell is intended to be easy to use, so variables can be created dynamically,
    unlike some languages, such as Java, where we must declare the variable before
    we can put something in it. What do I mean? Consider this line of code; don’t
    type it, just think about it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 的设计目的是易于使用，因此变量可以动态创建，这与一些语言（如 Java）不同，在 Java 中我们必须先声明变量，然后才能给它赋值。我的意思是什么？考虑这行代码；不用打出来，只需思考一下：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What am I doing there? I’m dynamically creating a variable with `some stuff`
    in it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我在那里做什么？我正在动态创建一个包含`some stuff`的变量。
- en: 'If I were to do that in a more Java-like style, I would write this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我要以更像 Java 风格的方式做这件事，我会这样写：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Which creates a variable, gives it a name, and then we put a value in it. In
    practice, this is very rare. Most people, in most situations, create variables
    on the fly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个变量，给它一个名字，然后我们将一个值放入其中。在实际操作中，这种情况非常罕见。大多数人在大多数情况下，都是动态创建变量的。
- en: If you read those lines of code closely, you will see that the first example
    contains `$MyVariable`, and in the second one, it’s `MyVariable`, without the
    `$` sign. Let’s talk about why.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细阅读这些代码行，你会看到第一个示例中包含了`$MyVariable`，而第二个示例中则是`MyVariable`，没有`$`符号。让我们来讨论一下为什么。
- en: Variables are not their contents
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量不是它们的内容
- en: We very rarely want to manipulate a variable. Going back to the box metaphor,
    unless we are five years old, we’re usually more interested in the contents of
    the box, not the box itself. `MyVariable` is the name assigned to the variable,
    the label that we can use to refer to it. `$MyVariable` refers to the contents
    of the variable. This is the stuff we are interested in. Let’s demonstrate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很少需要操作一个变量。回到盒子比喻，除非我们五岁，否则通常更感兴趣的是盒子里的内容，而不是盒子本身。`MyVariable`是分配给变量的名称，是我们用来引用它的标签。`$MyVariable`则指的是变量的内容。这就是我们感兴趣的东西。让我们来演示一下。
- en: '![Figure 4.2 – MyVariable is not $MyVariable](img/B17600_04_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – MyVariable 不是 $MyVariable](img/B17600_04_02.jpg)'
- en: Figure 4.2 – MyVariable is not $MyVariable
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – MyVariable 不是 $MyVariable
- en: 'In the first line in *Figure 4**.2*, we’re dynamically creating a variable
    called `MyVariable` and putting `some stuff` into it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 4.2*的第一行，我们动态地创建了一个名为`MyVariable`的变量，并将`some stuff`放入其中：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the second line, we ask PowerShell for the contents of `MyVariable` by typing
    `$MyVariable`, and we get `some` `stuff` back.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们通过输入`$MyVariable`来请求PowerShell获取`MyVariable`的内容，结果返回了`some` `stuff`。
- en: In the third line, we’ve just typed the name of the variable, `MyVariable`,
    and PowerShell has not understood what we want.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行，我们只输入了变量的名称`MyVariable`，但是PowerShell并没有理解我们想要什么。
- en: 'In the fourth line, we explicitly ask for `MyVariable` with the `Get-Variable`
    cmdlet, and again we get the `some stuff` string, but we also get some other stuff
    that isn’t part of the string; the `Get-Variable` cmdlet has returned a `PSVariable`
    object, not the contents of the variable, which is the `some stuff` string. We
    can confirm what sort of variable it is by using `Get-Member`. Type the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四行，我们显式地通过`Get-Variable`命令请求`MyVariable`，再次得到了`some stuff`字符串，但我们还得到了其他一些不属于字符串的内容；`Get-Variable`命令返回了一个`PSVariable`对象，而不是变量的内容，即`some
    stuff`字符串。我们可以使用`Get-Member`来确认它是什么类型的变量。输入以下内容：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the fifth line, PowerShell quite reasonably tells us we don’t have a variable
    called `some stuff` – we’re passing the contents of `MyVariable` to `Get-Variable`
    here, not the name of the variable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在第五行，PowerShell很合理地告诉我们并没有一个名为`some stuff`的变量——我们这里传递的是`MyVariable`的内容，而不是变量的名称。
- en: In the sixth line, it may look like we’re passing a variable to `Write-Output`,
    but we’re not. We’re passing a string with the value `MyVariable`, not the contents
    of `MyVariable`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第六行，看起来我们像是将一个变量传递给`Write-Output`，但实际上并不是。我们传递的是一个值为`MyVariable`的字符串，而不是`MyVariable`的内容。
- en: The seventh line passes the contents of `MyVariable` to `Write-Output` correctly
    by referring to `$MyVariable`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第七行正确地将`MyVariable`的内容传递给`Write-Output`，通过引用`$MyVariable`。
- en: In practice, if we always preface our variable names with a `$` sign, we’ll
    almost always be right. This brings us to names; what is a good variable name,
    and what is not?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们总是以`$`符号开头命名变量，几乎总是会是正确的。这就引出了名字的问题：什么是好的变量名，什么是不好的变量名？
- en: Naming variables
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量命名
- en: There are two things we should consider when naming a variable. Firstly, names
    we can use, and secondly, names we *should* use.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名变量时，有两个因素需要考虑。首先是我们可以使用的名称，其次是我们*应该*使用的名称。
- en: Names we can (and can’t) use
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们可以（和不能）使用的变量名
- en: 'Variable names can contain any combination of letters, numbers, question marks,
    and the underscore symbol, `_`. They are not case sensitive. We can use other
    characters as well if we enclose the variable name in curly braces `{}`, but we
    don’t do this. Really – it makes life difficult, and there’s almost never any
    need for it. Examples of good and bad names are listed in the following table:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名可以包含字母、数字、问号和下划线符号`_`的任意组合。它们不区分大小写。如果我们将变量名放入花括号`{}`中，还可以使用其他字符，但我们并不这么做。真的——这样会让生活变得更复杂，而且几乎没有必要。下面是一些好坏变量名的例子：
- en: '| **Possible** **Variable Name** | **Impossible** **Variable Name** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **合法的** **变量名** | **非法的** **变量名** |'
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Z54` | `z54!` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `Z54` | `z54!` |'
- en: '| `ComputerName` | `$``ComputerName` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `ComputerName` | `$``ComputerName` |'
- en: '| `Computer_Name` | `Computer-Name` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `Computer_Name` | `Computer-Name` |'
- en: '| `{``Computer Name}` | `Computer Name` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `{``Computer Name}` | `Computer Name` |'
- en: '| `ComputerName?` | `{``Computer Name{}}` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `ComputerName?` | `{``Computer Name{}}` |'
- en: Table 4.1 – Names we can and can’t use
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 – 我们可以使用和不能使用的名字
- en: Now that we know what sort of names we *can* use, what sort of names *should*
    we use?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了可以使用什么样的变量名，那么我们应该使用什么样的名字呢？
- en: Names we should (and shouldn’t) use
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们应该（和不应该）使用的名字
- en: One of the purposes of using variables is to assign meaning. We do this by making
    the names meaningful; a variable name should give some clue as to the variable’s
    contents or purpose. While `MyVariable` is a perfectly legal and suitable name
    when we’re typing one or two lines of code, when we write a script, it doesn’t
    give us any clue as to what it contains or how we wanted it to be used; it just
    tells us that it’s a variable and that it’s *mine*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量的一个目的就是赋予其意义。我们通过使变量名具有意义来实现这一点；一个变量名应该给出一些提示，说明变量的内容或用途是什么。虽然`MyVariable`在我们输入一两行代码时是一个完全合法且合适的名字，但当我们编写脚本时，它并没有提供任何关于它包含的内容或我们希望如何使用它的线索；它只告诉我们它是一个变量，并且它是*我的*。
- en: My day job often involves debugging code written by other people. I have nightmares
    caused by scripts with 20 or 30 variables called `a`, `I`, `x`, `y`, `ii`, `x3`,
    `agtd`, and so on. I don’t know what they mean, and I bet the original author
    doesn’t remember, either. When naming variables, we should understand that our
    code will be read many more times than it is written, often by us, sometimes years
    after we wrote it. Let’s do ourselves a favor and write meaningful variable names.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我的日常工作常常涉及调试别人写的代码。我曾经做过因为脚本中有20个或30个变量，名字叫`a`、`I`、`x`、`y`、`ii`、`x3`、`agtd`等而做噩梦的事情。我根本不知道它们是什么意思，而且我敢打赌，原作者也不记得了。在命名变量时，我们应该明白，我们的代码将比编写它时被读取的次数要多得多，通常是我们自己读取，有时甚至是在几年后。为了自己着想，给变量起个有意义的名字吧。
- en: 'We should also use consistent names, such as `ComputerName1`, `ComputerName2`,
    and `ComputerName3`, not `ComputerName1`, `computer_name2`, and `ComputerNameThree`.
    The PowerShell best practice guidelines suggest using Pascal case widely, where
    each word is capitalized, as this is easy to read and works well with screen readers.
    Other languages, such as Python, suggest variable names should be all lowercase
    and the words separated with underscores: `computer_name`. Whichever we choose,
    being consistent will make our lives easier.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该使用一致的命名规则，例如`ComputerName1`、`ComputerName2`和`ComputerName3`，而不是`ComputerName1`、`computer_name2`和`ComputerNameThree`。PowerShell最佳实践指南建议广泛使用Pascal命名法，其中每个单词的首字母都大写，因为这种方式易于阅读，并且与屏幕阅读器兼容。其他语言，如Python，建议变量名应全部小写，并且单词之间使用下划线分隔：`computer_name`。无论我们选择哪种方式，保持一致性会使我们的工作更加轻松。
- en: We don’t use question marks, either. It’s scruffy, and it can cause complications.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不使用问号。这会显得凌乱，而且可能会导致一些复杂的问题。
- en: Finally, we should avoid trying to use the names of automatic or preference
    variables. Wait, what?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该避免尝试使用自动变量或偏好变量的名称。等一下，这是什么？
- en: The three common types of PowerShell variable
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三种常见的PowerShell变量类型
- en: 'So far, we’ve been talking about a particular type of PowerShell variable –
    **user-created variables**. There are two other types: **automatic variables**
    and **preference variables**. User-created variables only exist for as long as
    the session or script that generated them is running; once we close our PowerShell
    window, those variables are destroyed. This is called **scope**, and we’ll cover
    it in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *Writing Our First Script
    – Turning Simple Cmdlets into Reusable Code*. Automatic and preference variables
    exist for every session or script.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在讨论一种特定类型的PowerShell变量——**用户创建的变量**。还有两种其他类型：**自动变量**和**偏好变量**。用户创建的变量只在生成它们的会话或脚本运行时存在；一旦我们关闭PowerShell窗口，这些变量就会被销毁。这被称为**作用域**，我们将在[*第8章*](B17600_08.xhtml#_idTextAnchor162)《编写我们的第一个脚本——将简单的Cmdlet转化为可重用代码》中详细介绍。自动变量和偏好变量则会在每个会话或脚本中存在。
- en: Automatic variables
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动变量
- en: 'These are used internally by PowerShell. We’ve already used one: `$PSItem`
    , or `$_`, which refers to the current object in the pipeline. We can assign a
    value to it if we like, but PowerShell will clear it when the current running
    pipeline completes, as in *Figure 4**.3*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是PowerShell内部使用的变量。我们已经使用过一个：`$PSItem`，或`$_`，它指的是管道中的当前对象。如果我们愿意的话，可以给它赋值，但PowerShell会在当前运行的管道完成时清除它，如*图
    4.3*所示：
- en: '![Figure 4.3 – Don’t use the names of automatic variables](img/B17600_04_03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 不要使用自动变量的名称](img/B17600_04_03.jpg)'
- en: Figure 4.3 – Don’t use the names of automatic variables
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 不要使用自动变量的名称
- en: 'After setting `$PSItem` to `"some stuff"`, the pipeline completes, and the
    variable is cleared, losing the information we were trying to store. Happily,
    most automatic variables are protected, as in *Figure 4**.4*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`$PSItem`设置为`"some stuff"`之后，管道完成，变量被清除，丢失了我们试图存储的信息。幸运的是，大多数自动变量是受保护的，如*图
    4.4*所示：
- en: '![Figure 4.4 – You can’t overwrite some automatic variables](img/B17600_04_04.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 你不能覆盖一些自动变量](img/B17600_04_04.jpg)'
- en: Figure 4.4 – You can’t overwrite some automatic variables
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 你不能覆盖一些自动变量
- en: You can see a list of the automatic variables in the help topic `about_Automatic_Variables`,
    or you can see them online at [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在帮助主题`about_Automatic_Variables`中查看自动变量的列表，或者可以在网上查看它们：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables)。
- en: Preference variables
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 偏好变量
- en: 'Preference variables store information about how PowerShell works, enabling
    us to customize how PowerShell behaves. For instance, we could use a preference
    variable to ensure the `-WhatIf` parameter is applied by default to all cmdlets
    we run (that support it). Let’s see how that works in *Figure 4**.5*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 偏好变量存储关于PowerShell如何工作的相关信息，使我们能够自定义PowerShell的行为。例如，我们可以使用一个偏好变量来确保默认情况下所有我们运行的（支持的）cmdlet都应用`-WhatIf`参数。让我们看看它是如何在*图
    4.5*中工作的：
- en: '![Figure 4.5 – Using preference variables](img/B17600_04_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 使用偏好变量](img/B17600_04_05.jpg)'
- en: Figure 4.5 – Using preference variables
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 使用偏好变量
- en: In the first line, we check the value of the `WhatIfPreference` variable; it’s
    `False`, the default. That makes sense because we’ve just started the PowerShell
    session. In the second line, we assign the value `True` by setting `$whatIfPreference
    = $``true`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们检查了`WhatIfPreference`变量的值；它是`False`，默认值。这是合理的，因为我们刚刚开始了PowerShell会话。在第二行中，我们通过设置`$whatIfPreference
    = $``true`来赋值`True`。
- en: Then we check the value again. Sure enough, it’s now `True`. Let’s see how things
    work now. We run `Get-Process` to get the `Id` parameter of a suitable process;
    in this case, I’m going to get the ID of the `pwsh` process, `407`. Now, when
    we run `Stop-Process -Id 407`, we would normally expect the `pwsh` session to
    end; it doesn’t because, by default, now all processes run with the `-WhatIf`
    parameter set to `True`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们再次检查其值。果然，现在它是`True`。让我们看看现在的情况如何。我们运行`Get-Process`来获取一个合适进程的`Id`参数；在这个例子中，我将获取`pwsh`进程的ID，`407`。现在，当我们运行`Stop-Process
    -Id 407`时，通常会期待`pwsh`会话结束；但它没有，因为默认情况下，现在所有进程都以`-WhatIf`参数设置为`True`运行。
- en: Changing preference variables this way only persists while the current session
    or script is running. If you stop and restart PowerShell, they’re all set back
    to the defaults. If you need to persist a preference, you can change your PowerShell
    profile, a PowerShell script that can be found by querying the `PROFILE` variable
    by typing `$PROFILE`. You’ll learn about editing scripts in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162),
    *Writing Our First Script – Turning Simple Cmdlets into* *Reusable Code*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式更改偏好变量仅在当前会话或脚本运行时有效。如果你停止并重新启动PowerShell，它们会恢复为默认值。如果你需要持久化一个偏好，你可以更改你的PowerShell配置文件，这是一个PowerShell脚本，可以通过查询`PROFILE`变量并键入`$PROFILE`来找到。你将学习如何编辑脚本，在[*第8章*](B17600_08.xhtml#_idTextAnchor162)，“编写我们的第一个脚本——将简单的Cmdlet转换为可重用代码”中。
- en: There’s a full explanation of each of the preference variables in the help topic
    `About_Preference_Variables`, or you can read more about them online at [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 关于每个偏好变量的完整解释可以在帮助主题`About_Preference_Variables`中找到，或者你可以在线阅读：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables)。
- en: Finally, we can see the current values held in all variables by typing `Get-Variable`
    with no parameters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过键入`Get-Variable`（不带参数）来查看当前所有变量中的值。
- en: Now that we understand a bit about the variable – the box – we can start looking
    at what we can put in there. Let’s have a look at object types.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了有关变量（框）的基本情况，我们可以开始看看可以放入其中的内容。让我们来看一下对象类型。
- en: Exploring object types
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索对象类型
- en: 'In the last section, we talked about types of variables. Now, we’re going to
    talk about **object types** – the things that go in the box. The type of the object
    in the variable tells the computer what to do with it – what properties it has
    and what we can do with it. Type the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了变量的类型。现在，我们要讨论**对象类型**——即放入盒子里的东西。变量中对象的类型告诉计算机如何处理它——它有什么属性，以及我们可以对它做什么。输入以下内容：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We should see something like the output in *Figure 4**.6*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能看到类似于*图4.6*中的输出：
- en: '![Figure 4.6 – It’s a string](img/B17600_04_06.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 它是一个字符串](img/B17600_04_06.jpg)'
- en: Figure 4.6 – It’s a string
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 它是一个字符串
- en: 'We’ve put a string in there, and we know this because we’re told it – `TypeName`
    is `System.String`. At the moment, `MyVariable` contains a string. We can change
    what the type is by assigning something else to it. Try typing the following without
    quotation marks:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经把一个字符串放进去，我们知道这一点，因为它被告诉了我们——`TypeName`是`System.String`。此时，`MyVariable`包含一个字符串。我们可以通过赋予其他值来改变其类型。试着输入以下内容，不加引号：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, use `Get-Member` to check the contents. Now we’ve got a `System.Double`
    object type in there, a floating-point number.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`Get-Member`检查内容。现在我们得到的是一个`System.Double`对象类型，表示一个浮动点数。
- en: 'We can do even better things. Type the following, and check the contents of
    the variable with `Get-Member`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做更好的事情。输入以下内容，并使用`Get-Member`检查变量的内容：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we have the output of `Get-Process` held in our variable, and the contents
    have a type of `System.Diagnostics.Process`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将`Get-Process`的输出保存在我们的变量中，并且内容的类型是`System.Diagnostics.Process`。
- en: Variables can hold any type of object. Remember, everything in PowerShell is
    an object. We covered some of the specifics of PowerShell objects in [*Chapter
    3*](B17600_03.xhtml#_idTextAnchor049), *The PowerShell Pipeline – How to String
    Cmdlets Together*, but it is a good idea to review them from a more generic programming
    perspective.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以保存任何类型的对象。记住，PowerShell中的一切都是对象。我们在[*第3章*](B17600_03.xhtml#_idTextAnchor049)《PowerShell管道——如何将Cmdlet连接起来》中介绍了一些PowerShell对象的细节，但从更通用的编程角度回顾它们是个好主意。
- en: What is an object? – redux
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是对象？——redux
- en: Picture a bicycle. What color is it? What sort of handlebars does it have? What
    is the wheel diameter? My bike has ape hanger handlebars, 15” wheels, and is a
    scuffed red glitter. Your bike may be a more sensible item altogether, with riser
    handlebars, 20” wheels, and in a serviceable black. My son Tom’s bike has pursuit
    handlebars, 22” wheels, and is white.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一辆自行车。它是什么颜色的？有什么样的车把？轮径是多少？我的自行车有猿式车把，15英寸的轮子，表面有划痕的红色闪光漆。你的自行车可能是一个更实用的物品，配有升降把手、20英寸的轮子，颜色是可用的黑色。我的儿子汤姆的自行车有追逐把手、22英寸的轮子，颜色是白色。
- en: 'That’s three objects, there, of the (non-existent) `TypeName Imaginary.Bike`.
    We can list the objects in *Table 4.2*. All the objects have the same set of **properties**:
    Name, Handlebar, Wheel (inch), and Color properties. In each instance, they have
    different values for the properties. Other properties may include a basket, lights,
    and so on. Some of those properties may be optional, but some are not; a bicycle
    will always have two wheels of a fixed diameter, and a color.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 那里有三个对象，属于（不存在的）`TypeName Imaginary.Bike`类型。我们可以在*表4.2*中列出这些对象。所有这些对象都有相同的一组**属性**：名称、车把、轮径（英寸）和颜色属性。在每个实例中，它们的属性值不同。其他属性可能包括篮子、车灯等等。有些属性可能是可选的，但有些不是；自行车总会有两个固定直径的轮子和一个颜色。
- en: '| **Name** | **MyBike** | **YourBike** | **TomsBike** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **我的自行车** | **你的自行车** | **汤姆的自行车** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **Handlebar** | Ape hanger | Riser | Pursuit |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **车把** | 猿式把手 | 升降把手 | 追逐把手 |'
- en: '| **Wheel (inch)** | 15 | 20 | 22 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **轮径（英寸）** | 15 | 20 | 22 |'
- en: '| **Color** | Red | Black | White |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **颜色** | 红色 | 黑色 | 白色 |'
- en: Table 4.2 – Our bikes
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2 – 我们的自行车
- en: 'We can create those bikes in PowerShell, list out the properties of each, and
    we can see that they are objects of the `Imaginary.Bike` type by using `Get-Member`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在PowerShell中创建这些自行车，列出每辆车的属性，并且我们可以通过使用`Get-Member`看到它们是`Imaginary.Bike`类型的对象：
- en: '![Figure 4.7 – Three imaginary bikes](img/B17600_04_07.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 三辆假想自行车](img/B17600_04_07.jpg)'
- en: Figure 4.7 – Three imaginary bikes
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 三辆假想自行车
- en: Our bikes also have a common set of things we can do with them. We can pedal
    them to make them speed up. We can use the brakes to make them slow down. These
    are `Get-Member` in [*Chapter 1*](B17600_01.xhtml#_idTextAnchor013), *Introduction
    to PowerShell 7 – What It Is and How to Get It*. We would expect objects of the
    same type to have the same methods as each other.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自行车也有一组共同的操作方式。我们可以踩踏板来加速它们。我们可以使用刹车来减速它们。这些在[*第1章*](B17600_01.xhtml#_idTextAnchor013)中的
    `Get-Member` 是 PowerShell 7 的简介——它是什么及如何获取它。我们期望同一类型的对象具有相同的方法。
- en: 'This concept of an object is common to most modern programming languages, and
    most programming languages handle them in similar ways. The imaginary exercise
    we have just gone through is as relevant in Python as it is in PowerShell. Here
    are the same three imaginary bikes in Python:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象的概念适用于大多数现代编程语言，并且大多数编程语言以类似的方式处理它们。我们刚刚进行的想象练习在 Python 中和在 PowerShell 中同样适用。以下是
    Python 中同样的三辆想象中的自行车：
- en: '![Figure 4.8 – Three imaginary bikes in another language](img/B17600_04_08.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – 另一种语言中的三辆想象中的自行车](img/B17600_04_08.jpg)'
- en: Figure 4.8 – Three imaginary bikes in another language
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 另一种语言中的三辆想象中的自行车
- en: The difference in PowerShell is everything is an object. With that in mind,
    let’s explore some common types of objects that we will want to put in variables.
    Let’s start with value types.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中的区别在于一切都是对象。考虑到这一点，让我们探索一些我们希望放入变量中的常见对象类型。让我们从值类型开始。
- en: Discovering value types
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现值类型
- en: '`System.Object` class in .NET. In general, value types in PowerShell are analogous
    to (but not exactly the same as) primitives. The memory location that holds a
    value-type object holds the actual data. There are also reference types, which
    we’ll look at later, that hold a reference to the actual data; the data is held
    elsewhere, possibly in multiple locations. Value-type data is a fixed size, in
    bits. Value types have a single value. To illustrate, let’s look at some value
    types. We’ll start with the simplest value type, the **Boolean** type.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中的 `System.Object` 类。总体而言，PowerShell 中的值类型类似于（但并非完全相同于）原始类型。保存值类型对象的内存位置保存实际数据。还有引用类型，我们稍后会看到，它们保存对实际数据的引用；数据保存在其他地方，可能在多个位置。值类型数据是固定大小的，以位为单位。值类型具有单个值。为了说明，让我们看一些值类型。我们将从最简单的值类型，布尔类型，开始。
- en: Memory locations – CompSci101 alert!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 内存位置——计算机科学 101 提示！
- en: Data is stored in two different places in memory, the **stack,** and the **heap**.
    The stack is for static allocations (things that don’t change), and the heap is
    dynamic. The heap stores global information and is exactly like it sounds; it’s
    just a heap of data with a tree-like structure. It’s not of fixed size and allows
    random access. Access to the data can be quite slow, and the heap becomes fragmented
    over time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储在内存中的两个不同位置：**栈**和**堆**。栈用于静态分配（不变的事物），而堆则是动态的。堆存储全局信息，其结构就像它的名字一样；这只是一个数据堆，具有树状结构。堆的大小不固定，允许随机访问。对数据的访问可能非常慢，并且随着时间推移，堆会变得分散。
- en: The stack is an orderly memory space of fixed size. It has a linear structure,
    where the last bit of data to be put on the stack is the first bit to be removed.
    Access to information is much quicker than in the heap. However, because space
    is limited, we occasionally get a stack overflow where we try to put more data
    into a stack than it can hold – the computer science equivalent of crossing the
    streams (Ghostbusters reference). Each thread of a running application has its
    own stack, but they all share the application heap.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种有序的固定大小的内存空间。它具有线性结构，最后放入栈的数据位于首位，被移除时也是首先移除的。与堆相比，信息访问要快得多。然而，由于空间有限，我们偶尔会遇到栈溢出，即尝试将更多数据放入栈中而它无法容纳的情况——这相当于计算机科学中的交叉流（《捉鬼敢死队》的参考）。每个运行中应用的线程都有自己的栈，但它们共享应用堆。
- en: When we create a variable, it goes in the stack. The data the variable refers
    to may be in the stack (for a value-type variable), or it may be in the heap (for
    a reference-type variable), but the variable is always in the stack.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个变量时，它被放入栈中。变量引用的数据可能在栈中（对于值类型变量）或者在堆中（对于引用类型变量），但变量本身总是在栈中。
- en: Booleans
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'A Boolean-type variable can hold one of two values; true or false. That’s it.
    It’s called a `System.Boolean` or `[bool]`. `[bool]` is an accelerator and saves
    us from having to type a much longer class name; it’s an alias for the type `System.Boolean`.
    Booleans are easy to assign; we use the automatic variables `$True` and `$False`.
    Try the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型的变量只能保存两个值之一：true 或 false。就是这么简单。它被称为`System.Boolean`或`[bool]`。`[bool]`是一个简写，避免我们输入更长的类名；它是`System.Boolean`类型的别名。布尔值非常容易赋值，我们可以使用自动变量`$True`和`$False`。试试下面的操作：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can see that the type is `System.Boolean`. Variables with this type are useful
    in scripting, as we will see in [*Chapter 5*](B17600_05.xhtml#_idTextAnchor096),
    *PowerShell Control Flow – Conditionals and Loops*. In that chapter, we’ll also
    see a similar but subtly different value type, the `[switch]` type – that can
    also only be true or false but has a different set of members.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到类型是`System.Boolean`。这种类型的变量在脚本中非常有用，正如我们在[*第5章*](B17600_05.xhtml#_idTextAnchor096)中将看到的，*PowerShell
    控制流 – 条件语句和循环*。在那一章中，我们还会看到一个相似但略有不同的值类型——`[switch]`类型——它也只能是true或false，但具有不同的成员集合。
- en: Integers
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: 'Integers are whole numbers, that is, numbers without a decimal point. There
    are three main integer types, `[int32]`, `[int64]`, and `[byte]`. `[int32]` is
    the default type and is a signed value 32 bits long, meaning it can hold decimal
    values between -2,147,483,648 and +2,147,483,647\. If we create a variable that
    holds a whole number between those values, then PowerShell will give it the type
    `[int32]`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 整数是没有小数点的整数。常见的三种整数类型为`[int32]`、`[int64]`和`[byte]`。`[int32]`是默认类型，它是一个有符号的32位数值，表示它可以存储介于-2,147,483,648和+2,147,483,647之间的整数。如果我们创建一个变量来存储这些值范围内的整数，那么PowerShell会为其分配`[int32]`类型：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we try and assign a number outside that range, then PowerShell will give
    it the `[int64]` type, which is 64 bits long and can hold numbers between -9,
    223, 372, 036, 854, 775, 808 and +9, 223, 372, 036, 854, 775, 807.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试赋值超出该范围的数字，PowerShell会将其类型设为`[int64]`，它是64位长，可以存储介于-9,223,372,036,854,775,808和+9,223,372,036,854,775,807之间的数字。
- en: We will sometimes see `[int]` and `[long]` in books and on web pages instead
    of `[int32]` and `[int64]` – the terms are interchangeable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时会在书籍和网页上看到`[int]`和`[long]`，而不是`[int32]`和`[int64]`——这两个术语可以互换使用。
- en: '`[byte]` is a special type of integer; it has no sign and is a whole number
    between 0 and 255, making it 8 bits long – 1 byte.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`[byte]`是一种特殊的整数类型；它没有符号，并且是一个介于0和255之间的整数，长度为8位——即1字节。'
- en: Activity one
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 活动一
- en: Why not have a single integer type – `[int64]`? Why bother complicating things?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不使用单一的整数类型`[int64]`呢？为什么要搞得这么复杂？
- en: Real numbers
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实数
- en: In mathematics, real numbers are numbers that exist – they can be whole numbers
    (42), decimals (3.1), fractions (1/3), or irrational numbers (pi, the square root
    of two). Imaginary numbers like the square root of -1 are not real numbers, although
    they are incredibly useful. In PowerShell, whole numbers are expressed using the
    integer types we’ve just discussed, and common irrational numbers are served by
    the `[math]` type. We mostly use real number types to express floating point numbers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，实数是存在的数字——它们可以是整数（42）、小数（3.1）、分数（1/3）或无理数（π、√2）。例如，-1的平方根这样的虚数并不是实数，尽管它们在很多方面非常有用。在PowerShell中，整数使用我们刚刚讨论的整数类型表示，而常见的无理数则通过`[math]`类型表示。我们大多数时候使用实数类型来表示浮点数。
- en: 'There are three common variable types for working with real numbers, `[single]`
    (or `[float]`), `[double]` (or `[long]`), and `[decimal]`. The `[single]` variable
    type is 32 bits and has seven digits of precision (the numbers to the right of
    the decimal point). The `[double]` variable type is 64 bits and has 15 or 16 digits
    of precision. By default, PowerShell creates variables of the type `[double]`
    when you use a decimal number:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种常见的变量类型用于处理实数：[single]（或`[float]`）、[double]（或`[long]`）和`[decimal]`。[single]类型是32位，精度为7位数字（即小数点右侧的数字）。`[double]`类型是64位，精度为15位或16位数字。默认情况下，当你使用小数时，PowerShell会创建`[double]`类型的变量：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `[Decimal]` type is 128 bits long and has a sliding scale of precision up
    to 28 digits. This is used in scientific and financial calculations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Decimal]`类型是128位长，精度可以达到28位数字。这在科学和金融计算中使用。'
- en: Char
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符
- en: 'The `[char]` type describes a single character, a member of the UTF-16 character
    set that we’re currently using. It’s a 16-bit value that corresponds to a symbol
    in the current character map. Try the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`[char]` 类型描述了一个单一字符，是我们当前使用的 UTF-16 字符集中的一个成员。它是一个 16 位的值，对应于当前字符映射中的一个符号。试试以下操作：'
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On my machine, I see an up-arrow `↑`. You may see something different. What
    you won’t see is `24`. We did something new there; we preceded the variable with
    a type accelerator. To understand why, we need to talk about typing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，我看到一个上箭头 `↑`。你可能看到不同的东西。但你不会看到的是 `24`。我们做了一些新的尝试；我们在变量前面加了一个类型加速器。为了理解为什么，我们需要讨论类型。
- en: Typing explained
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型说明
- en: 'Now we understand some basic types, we need to cover typing and how languages,
    particularly PowerShell, manipulate the type of the object in the variable. How
    does a computer know what type of object it is? Languages can be divided into
    those that only support **static typing**, where the object type the variable
    can hold is declared when the variable is created and doesn’t change, and those
    that support **dynamic typing**, where the contents of the variable determine
    what the type is. In dynamically typed languages, the type of the variable can
    change. Try the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了一些基本类型，接下来需要讨论的是类型声明以及语言，特别是 PowerShell，如何操作变量中对象的类型。计算机是如何知道一个对象的类型的呢？编程语言可以分为两类：一种是只支持
    **静态类型**，其中变量能容纳的对象类型在变量创建时就已声明，并且不会改变；另一种是支持 **动态类型**，其中变量的内容决定了它的类型。在动态类型语言中，变量的类型是可以改变的。试试以下操作：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can see that the object type of `$MyVariable` changes depending on what is
    inside it, making PowerShell a dynamically typed language. In fact, PowerShell
    is described as **Type-Promiscuous** by Bruce Payette in *PowerShell in Action*,
    because it will try to make the thing that we put in a variable do whatever we
    want. So long as the object in the variable has the right sort of property, PowerShell
    doesn’t care what type it is. Let’s play around.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`$MyVariable` 的对象类型会根据其中的内容变化，这使得 PowerShell 成为一种动态类型语言。事实上，Bruce Payette
    在《*PowerShell in Action*》中将 PowerShell 描述为 **类型随意**，因为它会尽力让我们放入变量中的任何东西都能按照我们想要的方式运作。只要变量中的对象具有正确的属性，PowerShell
    就不关心它的类型是什么。我们来试试。
- en: Dynamic versus static typing
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态类型与静态类型
- en: If we type `$x = '4'`, we get `[string]`. If we type `$x = 4` without the quotes,
    we get `[int32]`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入 `$x = '4'`，我们得到 `[string]`。如果我们输入 `$x = 4`，没有引号，我们得到 `[int32]`。
- en: 'Now, let’s see what happens if we type the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果输入以下内容会发生什么：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Try it, and pipe `$x` to `Get-Member` just to confirm the type. PowerShell
    has tried its best to interpret what you want. It’s chosen to treat the second
    `4` as a string and added the two strings together, giving `44`. Amazing, right?
    Try it the other way around:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看，并将 `$x` 传输给 `Get-Member` 来确认类型。PowerShell 会尽力解释你想要的内容。它选择将第二个 `4` 作为字符串处理，并将两个字符串拼接在一起，结果是
    `44`。惊人吧？试试反过来：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now it’s treating the second `''4''` as an integer and returns `8`. This does
    not work in most languages:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它将第二个 `'4'` 视为整数，并返回 `8`。在大多数语言中这行不通：
- en: '![Figure 4.9 – Python is not promiscuous](img/B17600_04_09.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – Python 不是随便的](img/B17600_04_09.jpg)'
- en: Figure 4.9 – Python is not promiscuous
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – Python 不是随便的
- en: In Python, we can add strings together, called **concatenating**, and we can
    add integers together (called **adding**), and Python will happily dynamically
    type the variable contents as either a string or an integer. We cannot, however,
    mix strings and integers together; Python throws an error.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们可以将字符串连接在一起，这叫做 **连接**，我们也可以将整数相加（称为 **加法**），Python 会动态地根据变量内容的不同将其类型定义为字符串或整数。但是，我们不能将字符串和整数混合在一起；Python
    会抛出错误。
- en: This is mostly a blessing, but sometimes it’s a mixed blessing. Because PowerShell
    works so hard trying to do what we want, it will sometimes do things we don’t
    want. It may be that we always want the contents to be a string, but some data
    entry error or an ill-defined operation puts an integer in there. This affects
    what we can do with that variable afterward because it has changed the object
    type to an integer. In a less-accommodating language, we get an error that tells
    us exactly what has gone wrong, but PowerShell may give us unexpected results,
    which take an age to debug if we’re lucky or cause a disaster if we’re not.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是一个好事，但有时也可能是双刃剑。因为 PowerShell 会尽力做我们想要的事情，它有时会做出我们不希望的行为。假设我们始终希望内容是字符串类型，但某个数据输入错误或不当操作将整数放了进去。这会影响我们之后对该变量的操作，因为它已经将对象类型更改为整数。在不太宽容的语言中，我们会得到一个明确指出问题所在的错误，但
    PowerShell 可能会给我们一些意外的结果，若幸运的话可能需要很长时间来调试，若不幸则可能导致灾难性后果。
- en: Casting variables
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量类型转换
- en: 'Luckily, we can make PowerShell act more like a statically typed language by
    defining the contents of the variable when we create it by using an accelerator,
    `[int32]`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过在创建变量时使用加速器`[int32]`来让 PowerShell 更像静态类型语言：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And it’s an `[int32]` type, even though we gave it a string. Note this won’t
    work if we give it something that is less easy to interpret as an integer:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们给它的是字符串，它也是一个`[int32]`类型。请注意，如果我们给它一个不容易解释为整数的内容，它将无法正常工作：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This throws an error. Importantly, it will throw an error even if we just type
    the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这会抛出一个错误。重要的是，即使我们只输入以下内容，它也会抛出错误：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Because when we created `MyNewVariable` a few lines previously, we defined it
    as the `[Int32]` type, and so now that is all it can ever hold. This can also
    lead to some confusing results.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因为当我们在几行前创建`MyNewVariable`时，我们将其定义为`[Int32]`类型，所以现在它只能保存这种类型的内容。这也可能导致一些令人困惑的结果。
- en: 'We might expect this cmdlet to throw an error as we try to put a floating-point
    number into `MyNewVariable`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将一个浮动点数放入`MyNewVariable`时，可能会期望此命令抛出一个错误：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'But no. PowerShell just picks the closest integer and uses that instead:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但是不行。PowerShell 只是选择最接近的整数，并使用它：
- en: '![Figure 4.10 – PowerShell doing as it’s told](img/B17600_04_10.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – PowerShell 按照指示操作](img/B17600_04_10.jpg)'
- en: Figure 4.10 – PowerShell doing as it’s told
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – PowerShell 按照指示操作
- en: 'We can cast the variable, though, to a new type, like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们可以将变量转换为新的类型，如下所示：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And we now have the correct value in there. Casting is an incredibly useful
    technique that we’ll be using a lot later, especially in [*Chapter 7*](B17600_07.xhtml#_idTextAnchor140),
    *PowerShell and the Web – HTTP, REST, and JSON*. It allows us to take a collection
    of strings and turn them into XML and JSON objects that can be used to interact
    with web-based applications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经得到了正确的值。类型转换是一项非常有用的技术，稍后我们将会大量使用，特别是在[*第七章*](B17600_07.xhtml#_idTextAnchor140)，“*PowerShell
    和 Web – HTTP、REST 和 JSON*”中。它允许我们将一系列字符串转换成可以与基于 Web 的应用程序交互的 XML 和 JSON 对象。
- en: 'There are a couple of common ways of using casting to change the type of a
    variable’s contents. Firstly, we can create a new variable by copying the contents
    as a defined type. Let’s create a variable we know contains an integer:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种常见的方法可以使用类型转换来改变变量内容的类型。首先，我们可以通过将内容作为已定义的类型复制来创建一个新变量。让我们创建一个我们知道包含整数的变量：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can cast that to a new variable as a string:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其转换为新变量，并作为字符串使用：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can do it the other way around, as well:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以反过来操作：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Activity two
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 活动二
- en: What is the difference between `$myString` and `$MyOtherString`?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`$myString` 和 `$MyOtherString` 有什么区别？'
- en: 'Hint: what types of objects can we subsequently put in each variable?'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：我们接下来可以将哪些类型的对象放入每个变量中？
- en: Secondly, we can do it without creating a new variable; we can just use `[string]$MyVariable`
    in our code, and PowerShell will treat the contents as an object of the correct
    type if it can.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以在不创建新变量的情况下进行转换；我们可以在代码中使用`[string]$MyVariable`，如果可能，PowerShell 会将其内容视为正确类型的对象。
- en: That’s as much as we need to do on simple value types, and how PowerShell uses
    dynamic and static typing. It’s time to look at the more complex compound variable
    types – reference types.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要了解的简单值类型，以及 PowerShell 如何使用动态和静态类型。接下来，我们需要查看更复杂的复合变量类型——引用类型。
- en: Navigating reference types
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航引用类型
- en: 'Now we understand a bit about typing, and how value types work, we can talk
    about the other main type of object – **reference types**. We compared value type
    objects to primitives in other languages in the previous section, *Discovering
    value types*. Reference-type objects are the equivalent of data structures. Reference-type
    objects only hold a reference in the stack to more data in the heap; this is important
    because reference-type objects do not have a defined size. In general, a reference
    type may hold up to 2 GB of data. To prove it, I turned the Shakespeare play Hamlet
    into a string, by downloading it as a text file from Project Gutenberg:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对类型有了一些了解，也知道了值类型是如何工作的，我们可以讨论另一种主要的对象类型——**引用类型**。在前一节*发现值类型*中，我们将值类型对象与其他语言中的基本数据类型进行了比较。引用类型对象相当于数据结构。引用类型对象只在堆栈中保存指向堆中更多数据的引用；这一点很重要，因为引用类型对象没有固定大小。一般来说，引用类型最多可以包含
    2 GB 的数据。为了证明这一点，我通过从古腾堡计划下载文本文件，将莎士比亚的戏剧《哈姆雷特》转化为字符串：
- en: '![Figure 4.11 – Stringifying Hamlet](img/B17600_04_11.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 字符串化哈姆雷特](img/B17600_04_11.jpg)'
- en: Figure 4.11 – Stringifying Hamlet
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 字符串化哈姆雷特
- en: As we can see, there are around 197,000 characters in the whole string.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，整个字符串大约有 197,000 个字符。
- en: I did two interesting things there; I used the `length` property of the string
    type to see how long my string was, in characters, but I also used the `GetType()`
    method to check the object type rather than using the pipeline to pass it to `Get-Member`.
    Before we talk more about properties and methods and the other exciting things
    we can do with strings, I want to start with a simple reference-type object, the
    array.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里做了两件有趣的事；我使用了字符串类型的 `length` 属性来查看我的字符串有多长（以字符为单位），但我也使用了 `GetType()` 方法来检查对象类型，而不是使用管道将其传递给
    `Get-Member`。在我们进一步讨论属性、方法以及可以用字符串做的其他有趣事情之前，我想先从一个简单的引用类型对象——数组开始。
- en: Arrays
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'An array is a data structure of fixed length that contains a collection of
    objects. They don’t have to be the same type of object, and they are not necessarily
    sorted or ordered. An array can contain zero or more objects. We can tell PowerShell
    we want to create an array by either casting the variable as an array implicitly
    using the comma character `,` or explicitly with `[array]`. Try the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一种固定长度的数据结构，包含一组对象。数组中的对象不一定是同一类型，也不一定是排序或有序的。一个数组可以包含零个或多个对象。我们可以通过隐式使用逗号字符
    `,` 或显式使用 `[array]` 来告诉 PowerShell 创建一个数组。试试下面的操作：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Did you try it? You do need to. As we go through this section, I’ll be calling
    back to the arrays we create here. It would be awful if you got to the end of
    the section and had to come back and start again because you didn’t create the
    array the first time around.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你试过了吗？你真的应该试一下。随着我们继续这个部分，我会回到我们在这里创建的数组。如果你到了部分末尾才发现没创建数组，然后又得回去从头开始，那会很糟糕。
- en: 'To create a single-item array, you can do the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个单元素数组，你可以这样做：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output can be seen in the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可以在以下截图中看到：
- en: '![Figure 4.12 – Two single-element arrays](img/B17600_04_12.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – 两个单元素数组](img/B17600_04_12.jpg)'
- en: Figure 4.12 – Two single-element arrays
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 两个单元素数组
- en: We can see that we create `Object[]` of `BaseType` as `System.Array` each time.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们每次都会创建一个 `Object[]` 类型的 `BaseType`，它是 `System.Array`。
- en: 'We can also create arrays using the range operator (`..`). Try the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用范围运算符（`..`）来创建数组。尝试以下操作：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We should get an array containing all the numbers from 1 to 10, inclusive.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到一个包含从 1 到 10 所有数字（包括 10）的数组。
- en: 'Finally, we can use the array operator `@()`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用数组运算符 `@()`：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note we have to use a semicolon, not a comma, when separating different types
    of objects and using expressions. This is useful when we start scripting and using
    the splatting technique, which we’ll cover in the last section of this chapter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们分隔不同类型的对象并使用表达式时，必须使用分号，而不是逗号。当我们开始编写脚本并使用展开技巧时，这一点特别有用，这将在本章最后一节中讲解。
- en: Array basics
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组基础
- en: 'Each object in the array is called an element. We can list the elements by
    calling the whole array (`$NewArray`), like any other variable:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的每个对象称为元素。我们可以通过调用整个数组（`$NewArray`）来列出元素，和调用其他变量一样：
- en: '![Figure 4.13 – Listing the elements of an array](img/B17600_04_13.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 列出数组的元素](img/B17600_04_13.jpg)'
- en: Figure 4.13 – Listing the elements of an array
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 列出数组的元素
- en: 'We can choose to call a single element in an array by passing its index. This
    gets the first element:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择通过传递索引来调用数组中的单个元素。这将获取第一个元素：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will get the second-to-last element:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取倒数第二个元素：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can call multiple elements:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用多个元素：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And we can call a range of elements:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以调用一系列元素：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can change the values of elements of an array by assigning them directly:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过直接赋值来改变数组元素的值：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can add elements to an array by using the `+=` operator:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`+=`运算符向数组中添加元素：
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: But it’s tricky to delete an element from an array; instead, create a new array
    that only holds the elements you want.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 但是从数组中删除一个元素是有点棘手的；相反，创建一个只包含你想要的元素的新数组。
- en: 'By default, an array can hold objects of multiple types:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，数组可以包含多种类型的对象：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can constrain the type of the objects in an array so that it can only hold
    objects of one type:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以限制数组中对象的类型，使其只能包含某一类型的对象：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now try the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试以下操作：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Oops. We get an error:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，我们遇到了错误：
- en: '![Figure 4.14 – You can’t leave that in there](img/B17600_04_14.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – 你不能把它留在里面](img/B17600_04_14.jpg)'
- en: Figure 4.14 – You can’t leave that in there
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 你不能把它留在里面
- en: 'If we have a look, we can see that the type of the `IntArray` object is `[int32[]]`
    with a base type of `System.Array`, and the type of the elements is `[Int32]`.
    We saw this syntax in [*Chapter 2*](B17600_02.xhtml#_idTextAnchor034), *Exploring
    PowerShell Cmdlets and Syntax*, when we were looking at the `Get-Help` cmdlet.
    An empty pair of square brackets denotes a parameter that can take multiple values;
    in other words, an array:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下，可以看到`IntArray`对象的类型是`[int32[]]`，其基础类型是`System.Array`，而元素的类型是`[Int32]`。我们在[*第
    2 章*](B17600_02.xhtml#_idTextAnchor034)《探索PowerShell Cmdlet和语法》中看到了这个语法，当时我们在查看`Get-Help`
    cmdlet时使用过它。一个空的方括号表示一个可以包含多个值的参数；换句话说，一个数组：
- en: '![Figure 4.15 – System.String accepts an array](img/B17600_04_15.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15 – System.String 接受一个数组](img/B17600_04_15.jpg)'
- en: Figure 4.15 – System.String accepts an array
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – System.String 接受一个数组
- en: 'Finally, we can add arrays together:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将数组合并在一起：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That’s the basics covered. Let’s look at the properties and methods we can use
    with arrays.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 基本内容已经覆盖。让我们来看一下我们可以使用的数组属性和方法。
- en: Properties and methods of arrays
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组的属性和方法
- en: 'It is difficult to use `Get-Member` to see the properties and methods available
    on an array. PowerShell does not pass the array into the pipeline; it passes each
    element in the array in order. Try it by typing the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Get-Member`来查看数组的属性和方法是很困难的。PowerShell不会将数组传递到管道中；它按顺序传递数组中的每个元素。通过输入以下内容来尝试：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: All we get back are the properties and methods for the `[``Int32]` type.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的只是`[Int32]`类型的属性和方法。
- en: 'To see the properties and methods of the array type, you’ll need to either
    go to the help topic `about_Arrays` or look online here: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看数组类型的属性和方法，你需要访问帮助主题`about_Arrays`，或者在线查看：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays)。
- en: Let’s have a brief look at some of the more important ones.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简单看一下其中一些更重要的内容。
- en: Count, Length, and Rank
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Count、Length 和 Rank
- en: These are common properties of arrays. `Count` is an alias for `Length`. They
    both tell us how many elements are in the array. `$NewArray.Count` and `$NewArray.Length`
    are the same. This is back to the muscle memory thing of old admins, again. You’ll
    see both in the PowerShell literature.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是数组的常见属性。`Count`是`Length`的别名。它们都告诉我们数组中有多少个元素。`$NewArray.Count`和`$NewArray.Length`是相同的。这又回到了老管理员的肌肉记忆问题。你会在PowerShell文献中看到这两种说法。
- en: '`Rank` is interesting if you’re working with datasets. All the arrays we have
    been working with are `$ScruffyArray`, which contains the output of `Get-Process`.
    Most arrays you are likely to work with in PowerShell are one-dimensional. In
    data science, however, we quite often need to use multidimensional arrays; they’re
    complicated, and I haven’t seen a good PowerShell module for manipulating them.
    If you are really interested, have a look at the `about_Arrays` help topic. Just
    know it’s possible if you need to do a little bit with multidimensional arrays.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rank` 对于处理数据集时很有趣。我们一直在使用的数组是 `$ScruffyArray`，它包含 `Get-Process` 的输出。在 PowerShell
    中，你处理的大多数数组可能是单维数组。然而，在数据科学中，我们经常需要使用多维数组；它们比较复杂，我还没看到一个好的 PowerShell 模块来操作它们。如果你真的感兴趣，可以看看
    `about_Arrays` 帮助主题。只要知道，如果你需要操作多维数组，这完全是可能的。'
- en: Clear, ForEach, and Where
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Clear、ForEach 和 Where
- en: These are common methods of arrays. Where the element of an array supports the
    `Clear` method, you can use it on the array to clear all the elements. If the
    element doesn’t support it, though, you’ll get an error.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是数组的常见方法。当数组的元素支持`Clear`方法时，你可以在数组上使用它来清除所有元素。如果元素不支持该方法，你会得到一个错误。
- en: '![Figure 4.16 – Some methods are more useful than others](img/B17600_04_16.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16 – 有些方法比其他方法更有用](img/B17600_04_16.jpg)'
- en: Figure 4.16 – Some methods are more useful than others
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – 有些方法比其他方法更有用
- en: 'The `ForEach` method allows us to iterate through each element in an array
    and perform an operation on it. Type the following in to get the squares of the
    numbers in the array:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForEach`方法允许我们遍历数组中的每个元素，并对其执行操作。输入以下代码可以得到数组中数字的平方：'
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Personally, I find this type of code golf willfully complicated and it goes
    against PowerShell’s best practices. It’s fine if we’re doing a couple of lines,
    but I wouldn’t put it in a script. We’ll cover how to do this in a more readable
    way in [*Chapter 5*](B17600_05.xhtml#_idTextAnchor096), *PowerShell Control Flow
    – Conditionals* *and Loops*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我认为这种代码高尔夫（代码简化）故意复杂化，违背了 PowerShell 的最佳实践。如果只处理几行代码，这没问题，但我不会把它放在脚本中。我们将在[*第
    5 章*](B17600_05.xhtml#_idTextAnchor096)中讨论如何以更易读的方式做这件事，*PowerShell 控制流 – 条件语句*
    *和循环*。
- en: 'The `Where` method is similar, although more useful in one-liners. To get the
    elements of `$NewArray` greater than 5, we could type the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Where` 方法类似，虽然在单行表达式中更有用。要获取 `$NewArray` 中大于 5 的元素，我们可以输入以下代码：'
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It’s functionally the same as this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 它在功能上与这个相同：
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And arguably less readable. We covered `Where-Object` in [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049),
    *The PowerShell Pipeline – How to String Cmdlets Together*. Remember, PowerShell
    will output each member of an array into the pipeline in turn. So, why have these
    as methods at all? If we are working with very large arrays, then using the method
    on the array rather than using the pipeline is faster. The following cmdlet takes
    about 300 ms to complete on my laptop:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更不易阅读。我们在[*第 3 章*](B17600_03.xhtml#_idTextAnchor049)中已经讨论过 `Where-Object`，*PowerShell
    管道 – 如何串联 cmdlet*。记住，PowerShell 会依次将数组中的每个成员输出到管道中。那么，为什么这些方法还存在呢？如果我们正在处理非常大的数组，那么直接在数组上使用方法，而不是通过管道，会更快。以下
    cmdlet 在我的笔记本电脑上大约需要 300 毫秒来完成：
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following cmdlet takes about 400 ms:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 cmdlet 大约需要 400 毫秒：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So, it depends on where we want to save time. If the fastest possible code is
    our aim, then use the method on the array. If we want our code to be quickly understood
    when we return to it, then use the pipeline.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这取决于我们想要节省时间的地方。如果最快的代码是我们的目标，那么就对数组使用该方法。如果我们希望代码在回顾时能快速理解，那么使用管道。
- en: Array performance
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组性能
- en: 'One place where it is worth saving time, however, is in our manipulation of
    arrays. While it looks like we can change arrays by adding elements, this is not
    actually the case. Arrays are a fixed size. Every time we add an element, we create
    a new array. Let’s say we see something like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得节省时间的一个地方是我们对数组的操作。虽然看起来我们可以通过添加元素来改变数组，但实际情况并非如此。数组的大小是固定的。每次添加一个元素时，我们都会创建一个新数组。假设我们看到类似下面的代码：
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We’re actually creating and discarding 10,000 arrays. A lot of the documentation
    will tell us that the alternative is to use a .NET type instead of arrays – `[System.Collections.ArrayList]`,
    like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上是在创建和丢弃 10,000 个数组。许多文档会告诉我们，替代方案是使用 .NET 类型而不是数组——例如 `[System.Collections.ArrayList]`，像这样：
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here we have the same sort of programming style, where we create the array variable
    and then add to it, but we have to call a non-PowerShell type and then use the
    `Add()` method. It works, but it’s quite complicated, especially when we’re just
    starting out.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有相同的编程风格，我们先创建数组变量，然后向其添加元素，但我们必须调用非 PowerShell 类型，并使用 `Add()` 方法。它有效，但相当复杂，尤其是当我们刚刚开始学习时。
- en: 'Another alternative is to be clever about how we create our array and construct
    it like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是通过巧妙的方式创建数组，并像这样构造它：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This produces the same array as the other two with the speed of the `ArrayList`
    object type, but with the simplicity of using all PowerShell code. I ran these
    three cmdlets inside `Measure-Command`, so you can see the difference:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成与其他两个方法相同的数组，速度与 `ArrayList` 对象类型相同，但使用全 PowerShell 代码的简单性。我在 `Measure-Command`
    中运行了这三个 cmdlet，你可以看到它们的区别：
- en: '![Figure 4.17 – Three ways of creating the same array](img/B17600_04_17.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.17 – 三种创建相同数组的方法](img/B17600_04_17.jpg)'
- en: Figure 4.17 – Three ways of creating the same array
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – 三种创建相同数组的方法
- en: I first came across this observation on Tobias Weltner’s excellent blog, [https://PowerShell.one](https://PowerShell.one).
    I thoroughly recommend reading his articles.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次看到这个观察是在 Tobias Weltner 的精彩博客中，[https://PowerShell.one](https://PowerShell.one)。我强烈推荐阅读他的文章。
- en: Copying arrays
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制数组
- en: 'Now we have a pretty good idea of what an array is, we can look at one of the
    key differences between value types and reference types: how copying variables
    works. Try this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对数组有了一个相当清晰的了解，可以看看值类型和引用类型之间的一个关键区别：复制变量的方式。试试看：
- en: '[PRE45]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Without typing any more – what is in `$b`? If you said `42`, you would be right.
    Of course it is. The value of `$a` is held in the stack, so when we create `$b`,
    we copy the value `42` to the top of the stack and call it `$b` (if you got an
    error saying `'socks' isn't of type [Int32]`, close your PowerShell session and
    start a new one).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在不再输入任何内容的情况下——`$b` 中的值是什么？如果你说是 `42`，那你说对了。当然是的。`$a` 的值保存在栈中，所以当我们创建 `$b` 时，我们将
    `42` 复制到栈顶，并称之为 `$b`（如果你收到错误信息 `'socks' isn't of type [Int32]`，请关闭 PowerShell
    会话并重新启动一个新的会话）。
- en: 'Copying arrays doesn’t work like that. Try the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 复制数组并不像那样工作。试试以下操作：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Argh! What happened there? `Array2` contains the updated value! That’s because
    all we did when we copied `Array1` to `Array2` was copy the reference to the data
    in the heap, the process storage area. When we then changed the element, we didn’t
    create a new array; we just changed the data in the old location. The references
    remain the same, so all copies of `Array1` will also reference the new data.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！发生了什么？`Array2` 包含了更新后的值！这是因为当我们将 `Array1` 复制到 `Array2` 时，我们只是复制了数据在堆中的引用，即进程存储区域。当我们修改元素时，并没有创建新数组；我们只是修改了旧位置的数据。引用保持不变，因此
    `Array1` 的所有副本也会引用新数据。
- en: 'How do we get around this? Easy. At least, easyish. Have a go by doing the
    following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题呢？很简单。至少，算是简单的。试试看，按照以下步骤操作：
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And, voilà, we can now make changes to `Array1` without it affecting `Array2`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，瞧，我们现在可以对 `Array1` 进行修改，而不影响 `Array2`：
- en: '[PRE48]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We made PowerShell put each element in `Array1` into the pipeline and pipe it
    into `Array2`, creating a separate array of data. It’s a bit slow and clunky,
    but it works, and it’s simple.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让 PowerShell 将 `Array1` 中的每个元素放入管道中，并将其传输到 `Array2`，从而创建了一个独立的数据数组。这有点慢且笨拙，但它有效，而且简单。
- en: 'That’s enough about arrays for now. We’ll be doing lots more with them throughout
    the book. Let’s look at the second reference type we’re going to cover: strings.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 目前关于数组的内容就讲到这里。接下来，我们会在本书的后续内容中继续深入探讨它们。现在，让我们来看第二种引用类型：字符串。
- en: Strings
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: A string is a sequenced collection of `[char]` type objects – it’s text. As
    we saw at the start of this section on reference types, strings are a reference
    type, and they are immutable – read-only. If you want to change a string, you
    need to create a new string and destroy the old one.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一个按顺序排列的`[char]`类型对象集合——它就是文本。正如我们在本节关于引用类型的开始所看到的，字符串是一种引用类型，并且是不可变的——只读的。如果你想改变字符串，你需要创建一个新的字符串并销毁旧的那个。
- en: 'Strings have two properties, `Chars` and `Length`. `Chars` returns the `[char]`
    object at the given index:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串有两个属性，`Chars` 和 `Length`。`Chars` 返回给定索引处的`[char]`对象：
- en: '[PRE49]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`Chars` is a parameterized property – we must give it a value, known as an
    `[int32]`; anything else will throw an error. We can pass it a variable that contains
    a single `[int32]`, however. The `Length` property returns the length of the string
    object in characters:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chars` 是一个带参数的属性——我们必须为其提供一个值，这个值是一个 `[int32]`；否则会抛出错误。不过，我们可以传递一个包含单个 `[int32]`
    的变量。`Length` 属性返回字符串对象的字符长度：'
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'See the following screenshot for how this all looks:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看下面的截图，了解这一切是如何显示的：
- en: '![Figure 4.18 – Properties of strings](img/B17600_04_18.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.18 – 字符串的属性](img/B17600_04_18.jpg)'
- en: Figure 4.18 – Properties of strings
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – 字符串的属性
- en: 'Strings have a lot of methods. Where most of the methods on value types involve
    changing the object type, there are a lot of methods on strings to change the
    formatting. Have a look at this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串有很多方法。大多数值类型的方法涉及改变对象类型，而字符串有许多方法可以改变格式。看看这个：
- en: '[PRE51]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: And we’ll see there are 52 methods available on strings. We’ll not cover them
    all here, but let’s try a few of the common ones. Remember, each time we use these
    methods, we’re manipulating the output of the string, not the contents of the
    string.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到字符串上有 52 个可用方法。我们不会在这里覆盖所有方法，但我们可以尝试一些常见的方法。记住，每次使用这些方法时，我们都在操作字符串的输出，而不是字符串的内容。
- en: 'To get the string all in uppercase:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符串转换为全大写：
- en: '[PRE52]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To get it all in lowercase:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符串转换为全小写：
- en: '[PRE53]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To output the string as an array of single characters:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符串输出为单个字符的数组：
- en: '[PRE54]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To replace a character in a string:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换字符串中的字符：
- en: '[PRE55]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'After all that, type and see that the actual content of the variable is unchanged:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有操作后，键入并查看变量的实际内容没有改变：
- en: '[PRE56]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`Replace()`, along with `Join()` and `Split()`, are also available as PowerShell
    string operators:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`Replace()` 与 `Join()` 和 `Split()` 一起，也是 PowerShell 字符串操作符：'
- en: '[PRE57]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This can also be written as the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以写成以下形式：
- en: '[PRE58]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is shown in the following screenshot:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下面的截图中显示：
- en: '![Figure 4.19 – Two ways to split](img/B17600_04_19.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.19 – 两种分割方式](img/B17600_04_19.jpg)'
- en: Figure 4.19 – Two ways to split
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – 两种分割方式
- en: 'Quite often we find we have a date, but it’s in text format and ends up as
    a string. The `ToDateTime` method allows us to capture that string as a `[DateTime]`
    type, but we need to supply the culture we want as part of the method. We can
    do it like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常发现我们有一个日期，但它是以文本格式存在的，最终变成了一个字符串。`ToDateTime` 方法允许我们将该字符串捕获为 `[DateTime]`
    类型，但我们需要在方法中提供我们想要的文化信息。我们可以像这样操作：
- en: '[PRE59]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can see in the following screenshot that `$ImportantDate` is a `[``DateTime]`
    object:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下面的截图中看到，`$ImportantDate` 是一个 `[DateTime]` 对象：
- en: '![Figure 4.20 – Converting a string to a DateTime object](img/B17600_04_20.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.20 – 将字符串转换为 DateTime 对象](img/B17600_04_20.jpg)'
- en: Figure 4.20 – Converting a string to a DateTime object
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 – 将字符串转换为 DateTime 对象
- en: 'Even easier, though, if we have the chance, is to use the `[DateTime]` value
    type accelerator and cast the variable as the right type of object:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果有机会，使用 `[DateTime]` 值类型加速器并将变量转换为正确类型的对象会更简单：
- en: '[PRE60]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Single and double quote marks
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单引号和双引号
- en: 'In PowerShell, single and double quote marks behave differently. They can both
    be used to define a string, but they have different purposes. Try this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，单引号和双引号的行为不同。它们都可以用来定义字符串，但它们的用途不同。试试这个：
- en: '[PRE61]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can see in the following screenshot that the output is very different:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下面的截图中看到，输出是非常不同的：
- en: '![Figure 4.21 – Single and double quotes](img/B17600_04_21.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.21 – 单引号和双引号](img/B17600_04_21.jpg)'
- en: Figure 4.21 – Single and double quotes
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 – 单引号和双引号
- en: Double quotes tell PowerShell to expand the variables it finds before processing.
    The shell alerts us to what it is going to do by coloring the variable green when
    we use double quotes.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号告诉 PowerShell 在处理之前扩展它找到的变量。我们使用双引号时，Shell 会通过将变量显示为绿色来提醒我们它将要执行的操作。
- en: 'To print the contents of a variable when it’s going to be immediately followed
    by another character, enclose the variable name in curly braces:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印变量的内容并紧跟另一个字符时，将变量名括在大括号中：
- en: '[PRE62]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To print the variable, and not the contents of the variable, use the backtick
    character `` ` ``:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印变量本身，而不是变量的内容，使用反引号字符 `` ` ``：
- en: '[PRE63]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We’ll be doing plenty with strings as we go through the book, but now we should
    look at another important reference type, the hashtable.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将会经常处理字符串，但现在我们应该看一下另一个重要的引用类型——哈希表。
- en: Hashtables
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希表
- en: 'A hashtable is a PowerShell implementation of a type of data structure called
    a dictionary. They consist of a list of **key-value** pairs. We use hashtables
    to look up values for a given key or check which key holds a given value; they
    are basically lookup tables. Let’s create a hashtable and play around with it:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表是PowerShell实现的一种数据结构，叫做字典。它们由**键值**对组成。我们使用哈希表来查找给定键的值，或检查哪个键包含给定值；它们基本上是查找表。让我们创建一个哈希表并进行操作：
- en: '[PRE64]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We’re using `@{}` to create a hashtable there. We shouldn’t confuse it with
    `@()`, which will create an array. Now we’ve got our hashtable, we should put
    something in it. We can do this when we create the hashtable, like this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@{}`来创建一个哈希表。我们不应该将它与`@()`混淆，后者会创建一个数组。现在我们已经有了哈希表，我们应该往里面添加一些内容。我们可以在创建哈希表时这么做，像这样：
- en: '[PRE65]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Note that we use a semicolon to separate the pairs, not a comma as we do in
    arrays:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用分号来分隔键值对，而不是像在数组中那样使用逗号：
- en: '![Figure 4.22 – Creating and populating hashtables](img/B17600_04_22.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图4.22 – 创建和填充哈希表](img/B17600_04_22.jpg)'
- en: Figure 4.22 – Creating and populating hashtables
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22 – 创建和填充哈希表
- en: 'We can add key-value pairs to the hashtable using the `add` method as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`add`方法向哈希表中添加键值对，如下所示：
- en: '[PRE66]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `add` method requires two parameters separated by a comma; the first is
    the key and must be in quotes, and the second is the value. If this is a string,
    it must also be in quotes:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`方法需要两个参数，用逗号分隔；第一个是键，必须用引号括起来，第二个是值。如果值是字符串，它也必须用引号括起来：'
- en: '[PRE67]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Note that, unlike an array, PowerShell treats a hashtable as a single object:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不像数组，PowerShell将哈希表视为单个对象：
- en: '[PRE68]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Compare this with the following:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与以下内容进行比较：
- en: '[PRE69]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'However, we can use the `Count` property to return the number of key-value
    pairs:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用`Count`属性来返回键值对的数量：
- en: '[PRE70]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now that we have our hashtable, what can we do with it? The obvious use is
    to look up values:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了哈希表，我们可以用它做什么呢？显而易见的用途是查找值：
- en: '[PRE71]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'And it returns the value `poor`. We can also use the key like we would use
    an index in an array:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回值`poor`。我们也可以像使用数组索引一样使用键：
- en: '[PRE72]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can use this method to add key-value pairs as well:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用这种方法来添加键值对：
- en: '[PRE73]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The big advantage of using the square brackets is it allows us to pass an array
    of keys and get the values back:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方括号的一个大优点是，它允许我们传递一个键的数组并返回对应的值：
- en: '[PRE74]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Or, we can use a variable to hold the array:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用一个变量来保存这个数组：
- en: '[PRE75]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can list out all the key-value pairs in the hashtable one at a time with
    the `GetEnumerator()` method:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`GetEnumerator()`方法逐个列出哈希表中的所有键值对：
- en: '[PRE76]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Hold on. Can’t we do that just by typing `$MyBike`? No. If we try to do that,
    we get the whole hashtable as a single object. It will look like key-value pairs,
    but it won’t behave like a set of separate ones. Try the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。我们难道不能直接输入`$MyBike`吗？不行。如果我们尝试这样做，整个哈希表会作为一个单独的对象返回。它看起来像是键值对，但不会像一组独立的键值对一样工作。试试下面的操作：
- en: '[PRE77]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We can see there that only one object passed through the pipeline in the first
    line.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在第一行中，只有一个对象通过了管道。
- en: 'We can remove key-value pairs as well with the `remove` method:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`remove`方法删除键值对：
- en: '[PRE78]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can test for the presence of a key:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试某个键是否存在：
- en: '[PRE79]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'And we can test for the presence of a value:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以测试值是否存在：
- en: '[PRE80]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Ordered hashtables
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有序哈希表
- en: 'By default, hashtables are not ordered, and this doesn’t really matter because
    we’re only ever looking for the values they contain in the key-value pairs. Sometimes,
    however, we want our hashtable to be arranged in a particular way. We can use
    the `[ordered]` keyword to do this. Note this doesn’t go before the variable;
    it goes on the right-hand side:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，哈希表是无序的，这其实并不重要，因为我们只是寻找它们包含的键值对中的值。然而，有时候我们希望哈希表以特定的方式排列。我们可以使用`[ordered]`关键字来实现。注意，这个关键字不放在变量前面，而是放在右侧：
- en: '[PRE81]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'And you can see the difference in the following screenshot:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下图中看到它们的区别：
- en: '![Figure 4.23 – Ordered hashtable](img/B17600_04_23.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图4.23 – 有序哈希表](img/B17600_04_23.jpg)'
- en: Figure 4.23 – Ordered hashtable
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23 – 有序哈希表
- en: 'Notice that it’s now a different type – `OrderedDictionary`. We can still get
    values by passing the key, but because it is ordered, we can also now just pass
    the index of the key pair:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在它变成了一个不同的类型——`OrderedDictionary`。我们仍然可以通过传递键来获取值，但由于它是有序的，我们现在也可以直接传递键值对的索引：
- en: '[PRE82]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, you may have noticed that we’re back to bikes again. That’s because
    there’s another cool thing we can do with hashtables – we can turn them into objects:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可能注意到我们又回到了自行车的话题。那是因为我们可以对哈希表做一些很酷的事情——我们可以将它们转换为对象：
- en: '[PRE83]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'As you can see from the following screenshot, we now have a `PSCustomObject`
    called `$MyImaginaryBike` with a set of properties matching the original hashtable
    key-value pairs:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下屏幕截图中可以看到，我们现在有一个名为 `$MyImaginaryBike` 的 `PSCustomObject`，它具有一组与原始哈希表键值对匹配的属性：
- en: '![Figure 4.24 – Turning a hashtable into an object](img/B17600_04_24.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.24 – 将哈希表转换为对象](img/B17600_04_24.jpg)'
- en: Figure 4.24 – Turning a hashtable into an object
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.24 – 将哈希表转换为对象
- en: Cool, eh? We’ll be using hashtables a lot in the rest of the book because they’re
    such a useful type.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 酷吧？我们将在本书的其余部分中经常使用哈希表，因为它们是非常有用的类型。
- en: 'There are other reference types as well that cover other types of data structures,
    such as queues and stacks, but we don’t tend to use them as much, certainly not
    in everyday PowerShell. Before we finish this chapter, we’ll cover one final use
    for hashtables: splatting.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他引用类型，涉及其他类型的数据结构，如队列和栈，但我们通常不常使用它们，至少在日常的 PowerShell 中不会使用。在本章结束之前，我们将介绍哈希表的最终用法：splatting。
- en: Splatting – a cool use for hashtables
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Splatting – 哈希表的一个酷用法
- en: 'Some PowerShell cmdlets take a lot of parameters, and it can be confusing to
    feed them all into the cmdlet one at a time, all on the same line. Hashtables
    to the rescue. Try the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 PowerShell cmdlet 接受大量参数，逐个在同一行中输入这些参数可能会让人感到困惑。这时，哈希表派上了用场。试试以下方法：
- en: '[PRE84]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Notice that we don’t use `$Colors`; we use `@Colors`. Also, notice it doesn’t
    matter which way round we use it:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们没有使用 `$Colors`；我们使用的是 `@Colors`。同时，注意它的顺序没有关系：
- en: '[PRE85]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This will work as well, because we’ve explicitly named the parameters in the
    hashtable:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这样也能工作，因为我们在哈希表中明确指定了参数：
- en: "![Figure 4.25 – \uFEFFA basic example of splatting](img/B17600_04_25.jpg)"
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.25 – 基本的 splatting 示例](img/B17600_04_25.jpg)'
- en: Figure 4.25 – A basic example of splatting
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.25 – 基本的 splatting 示例
- en: We could use an array, but that will only work for positional parameters; the
    first value in the array will be the first positional parameter, the second value
    will be the second, and so on. Because most cmdlets don’t have more than one or
    two positional parameters, this is nothing like as useful as a hashtable.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用数组，但这只对位置参数有效；数组中的第一个值将是第一个位置参数，第二个值是第二个，依此类推。因为大多数 cmdlet 不会有超过一两个位置参数，所以这并不像哈希表那样有用。
- en: We’ll be using splatting a lot as we go on, but for this chapter, that’s it.
    Time to summarize what we’ve covered.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在接下来的章节中将会经常使用 splatting，但对于这一章来说，内容就到这里。现在是总结我们所学的内容的时候了。
- en: Summary
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This has been a long chapter, but we’ve learned a lot. We started by looking
    at variables and how they are used in PowerShell. After that, we took another
    look at objects from a computer science perspective and learned about their properties
    and methods. This gave us a grounding to start exploring object types, and we
    looked at some of the value types, which are equivalent to the computer science
    concept of primitives. From there, we saw how value types can be grouped together
    into data structures or reference types. Finally, for a bit of fun, we looked
    at how splatting can save us time and effort.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章内容比较长，但我们学到了很多东西。我们首先了解了变量及其在 PowerShell 中的使用方式。接着，我们从计算机科学的角度重新审视了对象，学习了它们的属性和方法。这为我们提供了探索对象类型的基础，我们查看了一些值类型，它们相当于计算机科学中的基本类型。接下来，我们看到值类型如何被分组到数据结构或引用类型中。最后，为了增加一些趣味性，我们了解了
    splatting 如何帮助我们节省时间和精力。
- en: In the next chapter, we are going to be looking at flow control in PowerShell,
    conditional statements such as `if` and `else`, and loops using `ForEach` and
    `While`. We’ll also be installing more software because that’s the fun stuff,
    right?
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究 PowerShell 中的流程控制，包括 `if` 和 `else` 等条件语句，以及使用 `ForEach` 和 `While`
    的循环。我们还会安装更多的软件，因为那才是有趣的部分，对吧？
- en: Exercises
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: What’s wrong with the variable `My Variable`?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`My Variable` 这个变量有什么问题？'
- en: Without trying the code, what `TypeName` will this cmdlet return?
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不尝试代码的话，这个 cmdlet 会返回什么 `TypeName`？
- en: '[PRE86]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: How can we change the view of the errors PowerShell shows us?
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何改变 PowerShell 显示错误的视图？
- en: What automatic variable can we use to clear the contents of an array or hashtable?
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用什么自动变量来清空数组或哈希表的内容？
- en: How might we compare two integers?
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何比较两个整数？
- en: What is the object type of `MyVariable` here?
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的 `MyVariable` 对象类型是什么？
- en: '[PRE87]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How would we get each character in a string into an array?
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将字符串中的每个字符放入数组中？
- en: What’s going to go wrong here, and why?
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里会出什么问题，为什么？
- en: '[PRE88]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: How can we create an object of type `OrderedDictionary`?
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何创建一个类型为 `OrderedDictionary` 的对象？
- en: Further reading
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'There is a lot of reading for this chapter because we’ve only really brushed
    the surface of the subject. We really should read the help topics associated with
    what we’ve been doing in this chapter, and some of the official PowerShell language
    documentation:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有很多内容要阅读，因为我们只是略微触及了这个主题的表面。我们确实应该阅读与本章内容相关的帮助主题，以及一些官方的 PowerShell 语言文档：
- en: '`about_Variables`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_variables)'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`about_Variables`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_variables)'
- en: '`about_Automatic_Variables`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables)'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`about_Automatic_Variables`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables)'
- en: '`about_Preference_Variables`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables)'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`about_Preference_Variables`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables)'
- en: '`about_Objects`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_objects](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_objects)'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`about_Objects`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_objects](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_objects)'
- en: 'PowerShell types: [https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-04](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-04)'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PowerShell 类型: [https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-04](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-04)'
- en: 'PowerShell Variables: [https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-05](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-05)'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PowerShell 变量: [https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-05](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-05)'
- en: '`about_Booleans`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_booleans](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_booleans)'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`about_Booleans`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_booleans](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_booleans)'
- en: '`about_Arrays`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays)'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`about_Arrays`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays)'
- en: 'PowerShell Arrays: [https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-09](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-09)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PowerShell 数组: [https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-09](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-09)'
- en: '`about_HashTables`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_hash_tables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_hash_tables)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`about_HashTables`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_hash_tables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_hash_tables)'
- en: 'PowerShell hashtables: [https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-10](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-10)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PowerShell 哈希表: [https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-10](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-10)'
- en: '`about_Splatting`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_splatting](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_splatting)'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`about_Splatting`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_splatting](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_splatting)'
