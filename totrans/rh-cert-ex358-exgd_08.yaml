- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web Servers and Web Traffic – Learning How to Create and Control Traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to overview what a web server is and install it.
    We will dive into securing the web server in order to ensure that the data is
    safe when you access it as a customer. We will also talk about how to automate
    this process using Ansible Automation. Without a good web server setup, you could
    possibly stunt your company’s growth. The ability to provide access to your products
    is vital, and being able to safeguard your customer’s information is equally as
    important. Let’s go ahead and step into the world of web servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with web servers and traffic control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to set up web servers manually and control traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to use Ansible Automation to automate web servers and control traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technical requirements in this chapter are covered in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GitHub access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please refer to the instructions found in [*Chapter 1*](B18607_01.xhtml#_idTextAnchor016),
    *Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise
    Linux*, to gain access to GitHub, and you will find the Ansible automation playbooks
    for this chapter at the following link: [https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter08](https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter08).
    Remember these are suggested playbooks and are not the only way you can write
    them to make the playbooks work for you.'
  prefs: []
  type: TYPE_NORMAL
- en: You can always change them using raw, shell, or cmd to achieve the same results,
    but we are demonstrating the best way to accomplish our goals. Also, keep in mind
    that we are not using the FCQN needed in the future version of Ansible, as that
    will not be supported in the exam since it is testing against Ansible 2.9.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with web servers and traffic control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to set up and run your own web server is important to most companies.
    In this digital age, you must be able to keep up with the demands of the fast-paced
    world. Without a strong website to offer your customers access to your product
    or services you will greatly hinder your sales potential. The ability to grow
    your business, especially internationally, is the dream of most people that start
    a new business. Setting up a web server on RHEL 8 is pretty straightforward using
    Apache httpd or NGINX but can become complex when implementing rules to protect
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to keep these same resources safe is a must for any business. The
    need to be able to block malicious traffic or spoofing is vital to keep your company
    in good standing with your customers. Being able to respond to threats from **distributed
    denial-of-service** (**DDoS**) attacks, for instance, is one of the things you
    need to be prepared for as a web server admin. We will go further, in future sections,
    into keeping your web server safe from unwanted access from third parties trying
    to gain your information for nefarious purposes.
  prefs: []
  type: TYPE_NORMAL
- en: We will showcase how to install a web server using Apache httpd and NGINX and
    how to configure it so that the system is secure. We will showcase how to house
    more than one web server endpoint on a physical server. Next, we will demonstrate
    how to access the web server once you have it up and running. We will do this
    using config files that will allow us to customize what is shown from the web
    server. Finally, we will automate all of this using Ansible Automation to take
    the headache out of deployments that need to be done over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: Learning to set up web servers manually and control traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to start with Apache httpd. We will commence by installing the
    service and configuring the files. We can see in the following screenshot the
    installation of Apache httpd:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Installing Apache httpd web service](img/Figure_8.01_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Installing Apache httpd web service
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to look at the default `httpd.conf` file in order to showcase
    the out-of-the-box setup for Apache httpd. We can see in the following screenshot
    the layout of the `/``etc/httpd/conf/httpd.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The /etc/httpd/conf/httpd.conf truncated file](img/Figure_8.02_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The /etc/httpd/conf/httpd.conf truncated file
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the previous screenshot, information on how to set up a web server
    can be found in the Apache httpd `/etc/httpd/conf/httpd.conf` file is also a good
    place to look for help and reminders, but do not rely on it alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, will use what we can learn from the man pages and the `httpd.conf` file
    to create a `.conf` file within the `/etc/httpd/conf.d/` directory. This will
    allow us to create a web server to meet our needs. We are going to set up virtual
    hosts within Apache httpd and use the `/etc/httpd/conf.d/` directory to store
    our websites. Before we do that, we have to ensure that the web server is set
    up within the default `httpd.conf` file, where we need to check the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code states that `ServerRoot` is `/etc/httpd/`, the web server
    `Listen` port is `80`, and `User` for the web server is set to `apache`. These
    ensure that the ownership of the files is correct when serving the web server
    to the public and tell the server what port to listen on, which in this case would
    be port `80` or HTTP , which most of us are used to, or HTTPS which is more secure.
    For now, we will stick to this basic configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will build the configuration for the virtual servers using the `website.conf`
    file, which we will save to `/etc/httpd/conf.d/website.conf`. We can see the contents
    of the `website.conf` file in the following screenshot, which displays the minimum
    required arguments to set up a web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The website.conf file used to configure the virtual web server](img/Figure_8.03_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – The website.conf file used to configure the virtual web server
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we can see that we are defining a directory for
    files, the IP of the server with a listen port of `80`, and the website name.
    This will allow us to create files such as `index.html` in `/srv/website/www`
    in order to control the content of our web server. We need to create an `index.html`
    file and then start and enable the service. In the following screenshot, you can
    see that I have created a simple `index.html` file within `/srv/website/www/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The index.hmtl file for Apache httpd web server](img/Figure_8.04_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – The index.hmtl file for Apache httpd web server
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will start and enable httpd, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Start, enable and status of Apache httpd](img/Figure_8.05_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Start, enable and status of Apache httpd
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have to open the firewall rules. As a habit I suggest you adopt, we
    will open this for HTTP and HTTPS so that we can utilize both `80` and `443` if
    necessary to access our web server. In the following screenshot, we can see that
    we are opening the firewall rules, making them permanent, and then reloading the
    firewall:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Opening the firewall rules for Apache httpd](img/Figure_8.06_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Opening the firewall rules for Apache httpd
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will restore the SELinux policy so that the web server showcases the
    correct information, which can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – The SELinux command to restore the directory permissions](img/Figure_8.07_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – The SELinux command to restore the directory permissions
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are going to browse to the website, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Successful web server browsing of the index.html file](img/Figure_8.08_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Successful web server browsing of the index.html file
  prefs: []
  type: TYPE_NORMAL
- en: Up until this point, we have successfully opened up our web server to the world.
    By having many servers behind a load balancer, you can alter where the traffic
    goes by the way the load balancer is configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will troubleshoot virtual hosts within Apache httpd. We will show
    you how to narrow down common problems when setting up virtual hosts and how to
    identify and fix them easily. First, let’s create a virtual host with Apache httpd.
    One of the key things to note is the SELinux construct and how to restore it.
    The key takeaway from knowing this understanding what has caused the problem is
    if you receive the normal Apache httpd resource page, as seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – The default Apache httpd page](img/Figure_8.09_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – The default Apache httpd page
  prefs: []
  type: TYPE_NORMAL
- en: 'After using the following command on the directory that you are using as the
    root directory for your server, you should see the **Testing for** **EX358book!!!**
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The next thing you will want to do is look at the VirtualHost information found
    in `/etc/httpd/conf.d/<name of the server>.conf` for where the default files are
    held for the virtual host in case they are not in the default of `/var/www/html`.
    This way, you know where to restore the SELinux context in order to resolve the
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure that you include the `Required all granted` command line for
    the directories; otherwise, you will not be able to see any as, by default, they
    are hidden from the world. This can be observed in the following virtual host
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Example of an httpd virtual host](img/Figure_8.10_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Example of an httpd virtual host
  prefs: []
  type: TYPE_NORMAL
- en: We can use this information to know where to restore the SELinux context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, check the firewall rules to make sure they are allowing `443` in this
    instance, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Firewall rules show HTTP (80) and HTTPS (443) are both open](img/Figure_8.11_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Firewall rules show HTTP (80) and HTT`PS` (443) are both open
  prefs: []
  type: TYPE_NORMAL
- en: 'After we ensure the firewall rules are in place, the web server should function
    correctly. You can ensure that httpd is running through a status check, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Apache httpd status showing it is enabled and running](img/Figure_8.12_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Apache httpd status showing it is enabled and running
  prefs: []
  type: TYPE_NORMAL
- en: After the system status, firewall rules, and SELinux have been checked and corrected
    if needed, your web server should perform correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will set up an Apache web server with TLS certificates. For this,
    we will use `mod_ssl`. We will start by installing `mod_ssl` using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have installed it, you will need to modify the location of the certificates
    to match where you have them saved. This can be set in the `/etc/httpd/conf.d/ssl.conf`
    config file. The areas that need modification can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Key location for the mod_ssl HTTP web server](img/Figure_8.13_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Key location for the mod_ssl HTTP web server
  prefs: []
  type: TYPE_NORMAL
- en: This will default the web server to TLS HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: We will now set up a web server using NGINX. This is a slightly different way
    of configuring web servers, and we will go into detail on how this is accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s remove httpd and the firewall rules so that we have a fresh server
    to work on, which can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Removed Apache httpd and firewall rules](img/Figure_8.14_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – Removed Apache httpd and firewall rules
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that Apache httpd has been removed, we can start with a fresh NGINX install.
    We will install NGINX using the commands in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Installing the NGINX web server](img/Figure_8.15_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – Installing the NGINX web server
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to configure the NGINX web server using the following files,
    which follow a similar pattern to that of Apache httpd. We will be looking at
    the main configuration file and server files separately. The main configuration
    file can be found at `/etc/nginx/nginx.conf`, and the server configuration files
    are found in the `/etc/nginx/conf.d` directory and have a `.conf` naming convention.
    The configuration of these files is slightly different from that of Apache httpd,
    as you can see in the following screenshot of the server configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Configuration example of an NGINX web server](img/Figure_8.16_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – Configuration example of an NGINX web server
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the layout is different, and we will need to adjust it accordingly.
    We will now create a `website.conf` file and save it in the `/etc/nginx/conf.d`
    directory. An example of a web server setup for NGINX is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Example of the configuration file for NGINX web server for
    rhel1](img/Figure_8.17_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 – Example of the configuration file for NGINX web server for rhel1
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have saved the `website.conf` file, we will create `index.html` in
    the `/var/www/html` directory previously specified, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – The index.html file for the NGINX web server](img/Figure_8.18_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.18 – The index.html file for the NGINX web server
  prefs: []
  type: TYPE_NORMAL
- en: 'Following that, we will run the following command on the `/var/` directory
    in order to fix any SELinux issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will start, enable, and open the firewall rules as needed as if this
    was a fresh server, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Start, enable, and open firewall rules for the NGINX web server](img/Figure_8.19_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.19 – Start, enable, and open firewall rules for the NGINX web server
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can successfully browse to the new web server, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Successful browsing to the NGINX web server](img/Figure_8.20_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.20 – Successful browsing to the NGINX web server
  prefs: []
  type: TYPE_NORMAL
- en: After we have our web servers set up, we are going to use HAProxy to control
    traffic to our servers. HAProxy provides load balancer abilities that enable us
    to determine what servers are currently in rotation for `roundrobin`, which allows
    connections to be dispersed on each new connection to a different web host for
    instance. By using HAProxy, we can lower our downtime during maintenance and ensure
    that we have high availability if a server fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by installing HAProxy, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Installing HAProxy](img/Figure_8.21_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.21 – Installing HAProxy
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is installed, we will enable and start the service, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – Starting and enabling HAProxy](img/Figure_8.22_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.22 – Starting and enabling HAProxy
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the service up and running, we will configure the main file that
    controls HAProxy, which is the `/etc/haproxy/haproxy.cfg` file, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – The /etc/haproxy/haproxy.cfg file](img/Figure_8.23_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.23 – The /etc/haproxy/haproxy.cfg file
  prefs: []
  type: TYPE_NORMAL
- en: A takeaway from this review of the config file is that the listening port of
    the frontend has been changed to `80` as normal for HTTP traffic. The backend
    servers are where we should put the web servers we want to control access to.
    Finally, the round robin balancing is set to `roundrobin`, which will rotate whichever
    backend server the user hits when attempting to browse to the web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to take away from HAProxy is that by default, SELinux allows many
    ports to be utilized out of the box, such as `80` and `443`. However, if you wanted
    to change to something that was not a well-known HTTP or HTTPS port, you would
    need to make sure that the following command was set to allow other ports for
    HAProxy through SELinux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we learned how to set up Apache httpd, NGINX, and how to use
    HAProxy as a load balancer. Next, we will work on automating these sections to
    make life easier regardless of what you choose to deploy, whether Apache or NGINX,
    with HAProxy able to utilize both as backend servers.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to use Ansible Automation to automate web servers and control traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will set up a multi-task playbook that allows Apache httpd to be installed
    on the server rhel1 and NGINX to be installed on rhel2\. After that, we will install
    HAProxy and set the two servers to `roundrobin` load balance, all through the
    use of Ansible Automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the inventory, which will include the httpd web server, NGINX
    web server, and the HAProxy server, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24 – Ansible Automation inventory file](img/Figure_8.24_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.24 – Ansible Automation inventory file
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will write out the playbook and files needed to make this work successfully.
    To do that, first, we will write out the beginning part of the playbook for the
    first server shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The files mentioned for copying are displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.25 – httpd.j2](img/Figure_8.25_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.25 – httpd.j2
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the template `.j2` file for the `httpd_html`
    conversion when we configure the web host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.26 – httpd_html.j2](img/Figure_8.26_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.26 – httpd_html.j2
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will configure the NGINX web server within the same playbook, as seen
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The files used within this portion of the playbook can be found in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.27 – nginx.j2](img/Figure_8.27_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.27 – nginx.j2
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the `.j2` file that allows us to copy
    over the configuration of the NGINX web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.28 – nginx_html.j2](img/Figure_8.28_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.28 – nginx_html.j2
  prefs: []
  type: TYPE_NORMAL
- en: 'After those web servers are configured, we will need to set up HAProxy, as
    shown in the remainder of the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The file used to configure the HAProxy can be found in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.29 – haproxy.j2](img/Figure_8.29_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.29 – haproxy.j2
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have created the playbook and the supporting files, we run the playbook
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following screenshot, we have a successful playbook run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.30 – Successful Ansible Automation playbook run](img/Figure_8.30_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.30 – Successful Ansible Automation playbook run
  prefs: []
  type: TYPE_NORMAL
- en: After the playbook runs successfully, we can now browse to `rhel3.example.com`,
    and it will round robin through the two backend servers.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create both Apache httpd web servers and
    NGINX web servers. We also learned how to set up HAProxy to load balance and provide
    high availability to our web servers. This enables us to take servers out of rotation
    without our customers knowing what is happening, all through Ansible Automation
    playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about web servers and how we can create different
    flavors from Apache to NGINX. We learned how to control server access and to resolve
    issues setting them up. Through HAProxy, we learned how to stir traffic through
    load balancing in order to ensure that we have servers up and running for the
    end users at all times. In the next chapter, we will wrap up what we have learned
    throughout this book with an overview followed by practice exam questions. This
    will help prepare you and drive home the information you have learned while studying
    this book. In the next chapter, we will work with mock exam questions to prepare
    you for test day. I look forward to seeing you all there and helping you succeed
    in passing the EX358 certification exam.
  prefs: []
  type: TYPE_NORMAL
