<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer028">
<h1 class="chapter-number" id="_idParaDest-53"><a id="_idTextAnchor059"/>4</h1>
<h1 id="_idParaDest-54"><a id="_idTextAnchor060"/>Processes and Process Control</h1>
<p>The main role of an operating system is to allow applications to run on a computer and use its resources. A lot of the time, the role of the systems administrator boils down to making sure that the right processes are running and diagnosing if they are not running. Thus, it is important to understand how the operating system starts and handles processes and how to start, stop, and <span class="No-Break">monitor them.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Executables <span class="No-Break">versus processes</span></li>
<li>Process termination, exit codes, <span class="No-Break">and signals</span></li>
<li>The <span class="No-Break">process tree</span></li>
<li>Process search <span class="No-Break">and monitoring</span></li>
</ul>
<h1 id="_idParaDest-55"><a id="_idTextAnchor061"/>Executables versus processes</h1>
<p>Programs are distributed as <em class="italic">executable files</em>. In many historical operating systems, programs would be loaded from <a id="_idIndexMarker190"/>files directly into memory byte by byte. That approach was certainly simple to implement, but it has many limitations (most notably, the requirement to <a id="_idIndexMarker191"/>have a fixed memory layout and the inability to store any metadata), so later systems invented special formats for <span class="No-Break">executable files.</span></p>
<p>For example, if we inspect the <strong class="bold">Bourne Again Shell</strong> (<strong class="bold">Bash</strong>) executable with the file command, we’ll see something <span class="No-Break">like this:</span></p>
<pre class="source-code">
$ file /bin/bash
/bin/bash: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=9c4cb71fe5926100833643a8dd221ffb879477a5, for GNU/Linux 3.2.0, stripped</pre>
<p>If you use a Linux distribution other than Debian or Red Hat derivatives (which are the main focus of this book) and the preceding command fails for you, you can find the location of the bash executable with <strong class="source-inline">which bash</strong>, or choose a different executable, such as <span class="No-Break"><strong class="source-inline">cat</strong></span><span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">ls</strong></span><span class="No-Break">.</span></p>
<p><strong class="bold">ELF</strong> stands for <strong class="bold">Executable and Linkable Format</strong>. It’s the default executable file format on Linux and many <a id="_idIndexMarker192"/>other Unix-like operating systems (<strong class="bold">LSB</strong> means <strong class="bold">Linux Standard Base</strong>). An ELF <a id="_idIndexMarker193"/>file stores executable code of programs – machine instructions that are loaded into memory to be executed by the CPU. However, it can also store debug information, such as associations between machine instructions and lines in the program <a id="_idIndexMarker194"/>source code they were compiled from. ELF files can also be <em class="italic">linked</em> with other ELF files, known as <em class="italic">shared libraries</em> – files that contain executable code but aren’t meant to run as programs and only serve as collections of <span class="No-Break">reusable functions.</span></p>
<p>You can see <a id="_idIndexMarker195"/>the library linkage information with the <span class="No-Break"><strong class="source-inline">ldd</strong></span><span class="No-Break"> command:</span></p>
<pre class="source-code">
$ ldd /bin/bash
    linux-vdso.so.1 (0x00007ffc06ddb000)
    libtinfo.so.6 =&gt; /lib64/libtinfo.so.6 (0x00007f30b7293000)
    libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f30b7000000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f30b743e000)</pre>
<p>If you <a id="_idIndexMarker196"/>run <strong class="source-inline">file</strong> on <strong class="source-inline">libc.so.6</strong>, the standard library for the C programming language, you will see that it’s also an <span class="No-Break">ELF file:</span></p>
<pre class="source-code">
$ file /lib64/libc.so.6
/lib64/libc.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=6f5ce514a9e7f51e0247a527c3a41ed981c04458, for GNU/Linux 3.2.0, not stripped</pre>
<p>Finally, ELF stores metadata such as the target operating system and CPU architecture. The file command doesn’t guess that files from the examples earlier are for Linux on x86-64, and simply gets them from the ELF <span class="No-Break">file header.</span></p>
<p>In the output of <strong class="source-inline">file /bin/bash</strong>, you might have noticed an unusual field – <strong class="source-inline">interpreter /lib64/ld-linux-x86-64.so.2</strong>. Bash is written in C, which is a compiled language, and shouldn’t need any interpreter. Indeed, that executable contains machine code, and the Linux kernel knows how to load ELF files; if it didn’t, it couldn’t load that <strong class="source-inline">ld-linux</strong> interpreter, resulting in a <span class="No-Break">chicken-and-egg problem.</span></p>
<p>The role of <strong class="source-inline">ld-linux.so</strong> is not to interpret the executable itself but, instead, to correctly resolve references to functions that come from shared libraries. If you run <strong class="source-inline">file</strong> on it, you will see that it’s <strong class="source-inline">static-pie linked</strong> rather than <strong class="source-inline">dynamically linked</strong>, unlike <strong class="source-inline">/bin/bash</strong> — <strong class="source-inline">static-pie</strong> means <strong class="source-inline">static </strong><span class="No-Break"><strong class="source-inline">position-independent executable</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
$ file /lib64/ld-linux-x86-64.so.2
/lib64/ld-linux-x86-64.so.2: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), static-pie linked, BuildID[sha1]=8fa0bd5df5fa6fff60bb4cbdd753621d00f94dfc, with debug_info, not stripped</pre>
<p>The kernel knows nothing about programs’ library function dependencies and can only load statically linked ELF executables directly. To load dynamically linked executables, it relies on the <strong class="source-inline">ld-linux.so</strong> helper but reuses a general interpreter association mechanism for it, instead of inventing something custom just for <span class="No-Break">that case.</span></p>
<p>Programs written <a id="_idIndexMarker197"/>in interpreted languages such as Python, Ruby, or shell <a id="_idIndexMarker198"/>require an actual interpreter to be loaded first. This is specified using a <em class="italic">shebang line</em> that starts <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">#!</strong></span><span class="No-Break">.</span></p>
<p>You can try it yourself by creating a simple <span class="No-Break">shell script:</span></p>
<pre class="source-code">
$ echo '#!/bin/bash' &gt;&gt; hello.sh
$ echo 'echo "hello world"' &gt;&gt; hello.sh
$ chmod +x ./hello.sh
$ ./hello.sh
hello world</pre>
<p>If a file has an executable bit (<strong class="source-inline">+x</strong>) on it and starts with a shebang line, the kernel will first load its interpreter (in this case, <strong class="source-inline">/bin/bash</strong>) and then give it the executable as <span class="No-Break">an argument.</span></p>
<p>Once an executable file is loaded, directly by the kernel itself or with help from an interpreter, it becomes a <span class="No-Break">running <a id="_idTextAnchor062"/></span><span class="No-Break"><em class="italic">process</em></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor063"/>Process termination and exit codes</h1>
<p>All processes <a id="_idIndexMarker199"/>have to eventually terminate, and there are many situations when process execution cannot continue, either due to errors in its own program logic or problems with the environment (such as missing files, for example). The user may also need to terminate processes by hand, either to make changes to the system, or to prevent a misbehaving process from taking <a id="_idIndexMarker200"/>up resources or interfering with the <span class="No-Break">system’s functioning.</span></p>
<p>In this section, we will learn how to examine the exit code of a terminated process to guess the possible reasons for its termination, and how to communicate with processes and force <span class="No-Break">their te<a id="_idTextAnchor064"/>rmination.</span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor065"/>Exit codes</h2>
<p>Most processes <a id="_idIndexMarker201"/>are short-lived – they do their job and terminate by themselves. Every process terminates with an <em class="italic">exit code</em> – a numeric value that indicates whether it exited normally or <a id="_idIndexMarker202"/>terminated due to an error. By convention, a zero exit code means success, and any non-zero exit code indicates an error. There are no standard meanings for non-zero exit codes – exact meanings vary between programs and operating systems, and many programs simply exit with <strong class="source-inline">1</strong> if they encounter an error, no matter what that <span class="No-Break">error is.</span></p>
<p>In bash, you can find the exit code of the last command in a special variable named <strong class="source-inline">$?</strong>. There’s a pair of Unix commands whose sole purpose is to exit with success and error codes respectively, <strong class="source-inline">true</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
$ true
$ echo $?
0
$ false
$ echo $?
1</pre>
<p>Most of the time, programs set their exit codes themselves. For example, in a shell script, you can use <strong class="source-inline">exit 1</strong> to signal an error. In C, you can use <strong class="source-inline">return 1</strong> in your <strong class="source-inline">main()</strong> function to the same effect. For programs that can be executed non-interactively from scripts, it’s critically important to exit with a non-zero code on errors; otherwise, script authors will have no way to know whether their script steps succeeded <span class="No-Break">or failed.</span></p>
<p>All standard commands do this. For example, let’s try to create a file in <strong class="source-inline">/etc/</strong> from a normal user and see what it leaves in the <strong class="source-inline">$?</strong> <span class="No-Break">variable:</span></p>
<pre class="source-code">
$ touch /etc/my_file
touch: cannot touch '/etc/my_file': Permission denied
$ echo $?
1</pre>
<p>The simplest use case for exit codes is chaining commands with the <strong class="source-inline">||</strong> and <strong class="source-inline">&amp;&amp;</strong> operators. They can be called <em class="italic">on error</em> and <em class="italic">on success</em> – in <strong class="source-inline">cmd1 || cmd2</strong>, the shell will execute <strong class="source-inline">cmd2</strong> if <strong class="source-inline">cmd1</strong> fails (that is, exits with a non-zero code). In <strong class="source-inline">cmd1 &amp;&amp; cmd2</strong>, it’s the other way around – <strong class="source-inline">cmd2</strong> is only executed if <strong class="source-inline">cmd1</strong> succeeds (exits with <span class="No-Break">zero code):</span></p>
<pre class="source-code">
$ touch /etc/my_file || echo "Fail!"
touch: cannot touch '/etc/my_file': Permission denied
Fail!
$ touch /tmp/my_file &amp;&amp; echo "Success!"
Success!</pre>
<p>On errors such as <a id="_idIndexMarker203"/>the file permission error in our example, the kernel simply does not do what <a id="_idIndexMarker204"/>the program asks it to do and, instead, allows the program to continue running as usual. The reasoning is that such errors often occur due to incorrect user input while the program logic is correct, so the program needs to be able to handle them and notify the user. However, in other cases, the kernel will interrupt a process by genera<a id="_idTextAnchor066"/>ting <span class="No-Break">a </span><span class="No-Break"><em class="italic">signal</em></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor067"/>Signals</h2>
<p>A signal is a special <a id="_idIndexMarker205"/>condition that may occur during process execution. There are many signals <a id="_idIndexMarker206"/>defined in the POSIX standard. Some are associated with specific program logic errors, such as <strong class="source-inline">SIGILL</strong> — <em class="italic">illegal instruction</em> (caused, for example, by attempts to divide by zero)  — or <strong class="source-inline">SIGSEV</strong> — <em class="italic">segmentation violation</em> (caused by trying to read or modify memory that wasn’t allocated to the process). Other signals are generated on external conditions to force a process to handle them, such as <strong class="source-inline">SIGPIPE</strong>, which is generated when a network socket or a local pipe is closed by the other end. These signals are only of interest to software developers, but some are designed as process control tools for administrators, such as <strong class="source-inline">SIGINT</strong> (which interrupts a process), <strong class="source-inline">SIGTERM</strong> (which asks the process to clean up its state and terminate), and <strong class="source-inline">SIGKILL</strong> (which tells the kernel to forcibly terminate a process). It’s said that a signal is <em class="italic">sent to a process</em>. That terminology is a good abstraction for users, but in reality, it’s the kernel that has execution control when a signal is generated, not the process. Programmers may anticipate certain signals and register <em class="italic">signal handlers</em> for them. For example, many interpreters for high-level programming languages handle the <strong class="source-inline">SIGILL</strong> signal and convert it into exceptions such as <strong class="source-inline">ZeroDivisionError</strong> in Python. However, if a programmer forgot or chose not to register a handler for <strong class="source-inline">SIGILL</strong> and the <a id="_idIndexMarker207"/>program attempts to divide by zero, the kernel will terminate <span class="No-Break">the process.</span></p>
<p>If you <a id="_idIndexMarker208"/>have <strong class="bold">GNU Compiler Collection</strong> (<strong class="bold">GCC</strong>) installed, you can <a id="_idIndexMarker209"/>see it for yourself with a simple <span class="No-Break">C program:</span></p>
<pre class="source-code">
$ echo "void main() { int x = 0 / 0; }" &gt;&gt; sigill.c
$ gcc -o sigill ./sigill.c
./sigill.c: In function 'main':
./sigill.c:1:25: warning: division by zero [-Wdiv-by-zero]
    1 | void main() { int x = 0 / 0; }
    |                         ^
$ ./sigill
Floating point exception (core dumped)
$ echo $?
136</pre>
<p>GCC helpfully warns you that your program is incorrect, but if you still try to run it, the kernel forcibly terminates it and sets the error code to a <span class="No-Break">non-zero value.</span></p>
<p>Signals such as <strong class="source-inline">SIGILL</strong> or <strong class="source-inline">SIGPIPE</strong> occur regardless of the user’s wishes, but there’s also a class of signals that is meant to be initiated by users (or by processe<a id="_idTextAnchor068"/>s on <span class="No-Break">their behalf).</span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor069"/>The kill command</h2>
<p>The command for <a id="_idIndexMarker210"/>sending signals to processes is called <strong class="bold">kill</strong>. That name is also somewhat <a id="_idIndexMarker211"/>misleading; most often, it’s indeed used to forcibly terminate processes, but it can also send other signals <span class="No-Break">as well.</span></p>
<p>To illustrate its usage, let’s learn how to send a process to the background. In bash, you can do that by appending an ampersand to a command. Using the <strong class="source-inline">jobs</strong> command, you can see a list of background processes, and by using <strong class="source-inline">fg &lt;job number&gt;</strong>, you can bring a job with a certain number to the foreground. Here’s how you can send a <strong class="source-inline">cat</strong> process to the background and then bring <span class="No-Break">it back:</span></p>
<pre class="source-code">
$ cat &amp;
[1] 22501
[1]+  Stopped                 cat
$ jobs
[1]+  Stopped                 cat
$ fg 1
cat
hello world
hello world
^C
$</pre>
<p>When you press <em class="italic">Ctrl</em> + <em class="italic">C</em> to terminate a process in the shell, you actually ask your shell to send it a <strong class="source-inline">SIGINT</strong> signal – a signal to <a id="_idIndexMarker212"/>interrupt execution. If a process is in <a id="_idIndexMarker213"/>the background, we cannot use <em class="italic">Ctrl</em> + <em class="italic">C</em> to interrupt it. However, with <strong class="source-inline">kill</strong>, we can send <span class="No-Break">it manually:</span></p>
<pre class="source-code">
$ cat &amp;
[1] 22739
[1]+  Stopped                 cat
$ kill 22739
$ jobs
[1]+  Stopped                 cat
$ fg 1
cat
Terminated</pre>
<p>Here’s what happened – when we ran <strong class="source-inline">cat &amp;</strong>, the shell told us its <em class="italic">background job number</em> (<strong class="source-inline">1</strong>) and also its <strong class="bold">process identifier</strong> (often abbreviated as <strong class="bold">PID</strong>); in <a id="_idIndexMarker214"/>this case, the number was <strong class="source-inline">22739</strong>, but it can be any number. We then used <strong class="source-inline">kill 22739</strong> to send the process a signal, and indeed, when we tried to bring it to the foreground, the shell told us that it terminated while it was in <span class="No-Break">the background.</span></p>
<p>By default, the <strong class="source-inline">kill</strong> command sends a <strong class="source-inline">SIGTERM</strong> signal. Both <strong class="source-inline">SIGINT</strong> and <strong class="source-inline">SIGTERM</strong> can be caught or ignored by a process. By sending them to a process, you ask it to terminate; a well-behaved process <a id="_idIndexMarker215"/>should comply and may use it as a chance to finalize its current task <a id="_idIndexMarker216"/>before terminating – for example, to finish writing data to a file. That means that neither the <em class="italic">Ctrl</em> + <em class="italic">C</em> key combination in the shell nor the <strong class="source-inline">kill</strong> command with default options is suitable for forcibly terminating a <span class="No-Break">misbehaving process.</span></p>
<p>To force a process to quit, you should use <strong class="source-inline">kill -SIGKILL &lt;PID&gt;</strong> instead, or its numeric equivalent, <strong class="source-inline">kill -9 &lt;PID&gt;</strong>. However, it should be your last resort since the kernel will simply end the process immediately, and that may leave its files in an <span class="No-Break">inconsistent state.</span></p>
<p>If you run <strong class="source-inline">kill -l</strong>, you will see a long list of <span class="No-Break">available signals:</span></p>
<pre class="source-code">
$ kill -l
 1) SIGHUP     2) SIGINT     3) SIGQUIT     4) SIGILL     5) SIGTRAP
 6) SIGABRT     7) SIGBUS     8) SIGFPE     9) SIGKILL    10) SIGUSR1
11) SIGSEGV    12) SIGUSR2    13) SIGPIPE    14) SIGALRM    15) SIGTERM
16) SIGSTKFLT    17) SIGCHLD    18) SIGCONT    19) SIGSTOP    20) SIGTSTP
21) SIGTTIN    22) SIGTTOU    23) SIGURG    24) SIGXCPU    25) SIGXFSZ
26) SIGVTALRM    27) SIGPROF    28) SIGWINCH    29) SIGIO    30) SIGPWR
31) SIGSYS    34) SIGRTMIN    35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3
38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8
43) SIGRTMIN+9    44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13
48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12
53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7
58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2
63) SIGRTMAX-1    64) SIGRTMAX</pre>
<p>Some of those signals have no predefined meanings and, instead, are specific to applications. For example, in <strong class="source-inline">SIGUSR1</strong> and <strong class="source-inline">SIGUSR2</strong>, <strong class="source-inline">USR</strong> stands for <em class="italic">user-defined</em>. Most processes ignore them, but some use them to allow system administrators to force a config reload or <span class="No-Break">another operation.</span></p>
<p>Now, we know <a id="_idIndexMarker217"/>how to examine the error codes of terminated processes and get an idea <a id="_idIndexMarker218"/>of whether they exited normally or failed. We also learned how the operating system kernel communicates with processes using signals, and how we can use the <strong class="source-inline">kill</strong> command to ask the kernel to either tell a process to exit or terminate a misbehaving process forcibly. Now, let’s learn how to explore the running processes and <a id="_idTextAnchor070"/>relationships <span class="No-Break">between them.</span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor071"/>The process tree</h1>
<p>We’ve seen that the shell knows the PIDs of the commands you run and can send them signals to terminate when you press <em class="italic">Ctrl</em> + <em class="italic">C</em>. That implies that it has certain control over the processes you ask it to launch. Indeed, everything you launch from your shell becomes a <em class="italic">child process</em> of that <span class="No-Break">shell process.</span></p>
<p>The shell itself <a id="_idIndexMarker219"/>is a child process — either of your terminal emulator if you are on a Linux desktop, or of the OpenSSH daemon if you connect remotely over SSH. However, is there a parent of all processes, or can there be multiple processes <span class="No-Break">without parents?</span></p>
<p>In fact, there is a parent of all processes, and all running process relationships form a tree with a single root (PID = 1). For historical <a id="_idIndexMarker220"/>reasons, the parent of all processes is often called the <em class="italic">init process</em>. For a long time in general-purpose Linux distributions, that process was System V init, hence <span class="No-Break">the term.</span></p>
<p>The PID=1 process can be anything. When you boot a Linux system, you can tell it which executable to load as PID=1. For example, one way to boot a system in rescue mode is to append <strong class="source-inline">init=/bin/bash</strong> to the GRUB command line (but you are better off using a built-in rescue option in your distro’s boot menu item because it may pass additional useful parameters). That will make your kernel drop into a single-user shell session instead of initiating its normal boot process. Some embedded systems that use Linux just as a hardware abstraction layer may start custom processes instead. However, normally, the process with PID=1 serves as a <span class="No-Break">service manager.</span></p>
<p>The System V init served as the de facto standard service manager for over two decades, but most modern distributions use systemd instead, while some opt for other alternatives to the old System V init, such <span class="No-Break">as OpenRC.</span></p>
<p>The <strong class="source-inline">init</strong> process is the only <a id="_idIndexMarker221"/>process that is launched directly by the kernel. Everything else is launched by the <strong class="source-inline">init</strong> process instead: login managers, the SSH daemon, web servers, database systems – everything you can think of. You can view the full process tree with the <strong class="source-inline">pstree</strong> command. Here’s a tree from a small <span class="No-Break">web server:</span></p>
<pre class="source-code">
$ pstree
systemd─┬─NetworkManager───2*[{NetworkManager}]
     ├─2*[agetty]
     ├─auditd───{auditd}
     ├─chronyd
     ├─crond
     ├─dbus-broker-lau───dbus-broker
     ├─do-agent───5*[{do-agent}]
     ├─droplet-agent───8*[{droplet-agent}]
     ├─nginx───nginx
     ├─sshd───sshd───sshd───bash───pstree
     ├─systemd───(sd-pam)
     ├─systemd-homed
     ├─systemd-hostnam
     ├─systemd-journal
     ├─systemd-logind
     ├─systemd-oomd
     ├─systemd-resolve
     ├─systemd-udevd
     └─systemd-userdbd───3*[systemd-userwor]</pre>
<p>Here, you can see that <strong class="source-inline">pstree</strong> was a child process of a bash session, which in turn was a child of <strong class="source-inline">sshd</strong> (an OpenSSH process), which was itself a child of <strong class="source-inline">systemd</strong> – the root of the <span class="No-Break">process tree.</span></p>
<p>However, most of <a id="_idIndexMarker222"/>the time, you will be interested in finding specific proc<a id="_idTextAnchor072"/>esses and their <span class="No-Break">resource usage.</span></p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor073"/>Process search and monitoring</h1>
<p>The <strong class="source-inline">pstree</strong> command is a great way to visualize all running processes and relationships between them, but in <a id="_idIndexMarker223"/>practice, most of the time administrators look for specific processes or need to <a id="_idIndexMarker224"/>learn about their resource usage, rather than their mere existence. Let’s learn about the tools for those tasks – the <strong class="source-inline">ps</strong> command to search processes, the <strong class="source-inline">top</strong> command to monitor resource usage in real time, and the underlying kern<a id="_idTextAnchor074"/>el interface that those <span class="No-Break">tools use.</span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor075"/>The ps command</h2>
<p><strong class="bold">PS</strong> is an abbreviation for <strong class="bold">process selection</strong> or <strong class="bold">process snapshot</strong>. It’s a utility that allows you to retrieve and <a id="_idIndexMarker225"/>filter information about <span class="No-Break">running processes.</span></p>
<p>Running <strong class="source-inline">ps</strong> without any <a id="_idIndexMarker226"/>arguments will get you a very limited selection – only processes that run from your user and that are attached to a <em class="italic">terminal</em> (that is, aren’t processes that run <a id="_idIndexMarker227"/>with all input and output closed and only communicate with other processes through network or local sockets — usually daemons, but GUI programs may behave the <span class="No-Break">same way).</span></p>
<p>Somewhat confusingly, <strong class="source-inline">ps</strong> itself always shows up in such lists because, when it gathers that information, it’s indeed a <span class="No-Break">running process:</span></p>
<pre class="source-code">
$ ps
    PID TTY          TIME CMD
 771681 pts/0    00:00:00 bash
 771705 pts/0    00:00:00 ps</pre>
<p>The <strong class="source-inline">PID</strong> field is, of course, a process identifier – a unique number that the kernel assigns to every process when that process is launched. If present, the <strong class="source-inline">TTY</strong> field is a terminal – it can be a real serial console (usually <strong class="source-inline">ttyS*</strong> or <strong class="source-inline">ttyUSB*</strong>), a virtual console on a physical display (<strong class="source-inline">tty*</strong>), or a purely virtual pseudo-terminal associated with an SSH connection or a terminal <span class="No-Break">emulator (</span><span class="No-Break"><strong class="source-inline">pts/*</strong></span><span class="No-Break">).</span></p>
<p>The CMD field shows <a id="_idIndexMarker228"/>the command that was used to launch a process with its arguments, if any <span class="No-Break">were used.</span></p>
<p>The <strong class="source-inline">ps</strong> command has a large number of options. Two options you should learn about right away are <strong class="source-inline">a</strong> and <strong class="source-inline">x</strong> — options that remove <em class="italic">owned by me</em> and <em class="italic">have a </em><span class="No-Break"><em class="italic">terminal</em></span><span class="No-Break"> restrictions.</span></p>
<p>A common command to view every process on the system is <strong class="source-inline">ps ax</strong>. Let’s try to <span class="No-Break">run it:</span></p>
<pre class="source-code">
$ ps ax
    PID TTY    STAT    TIME COMMAND
    1 ?        Ss    1:13 /usr/lib/systemd/systemd --switched-root --system --deserialize 30
    2 ?        S       0:01 [kthreadd]
    3 ?        I&lt;      0:00 [rcu_gp]
    4 ?        I&lt;      0:00 [rcu_par_gp]
               …
    509 ?      Ss      7:33 /usr/lib/systemd/systemd-journald
    529 ?      S       0:00 [jbd2/vda2-8]
    530 ?      I&lt;      0:00 [ext4-rsv-conver]
    559 ?      Ss    226:16 /usr/lib/systemd/systemd-oomd
    561 ?      Ss      0:49 /usr/lib/systemd/systemd-userdbd
    562 ?      S&lt;sl    1:17 /sbin/auditd
    589 ?      Ss      0:10 /usr/lib/systemd/systemd-homed
    590 ?      Ss      0:02 /usr/lib/systemd/systemd-logind</pre>
<p>The <strong class="source-inline">STAT</strong> field tells us the process state. The <strong class="source-inline">S</strong> state means a process is in the interruptible sleep state – it waits for external events. Processes that currently do something can be seen in the <strong class="source-inline">R</strong> state – running. The <strong class="source-inline">I</strong> state is special; it is for idle kernel threads. The most concerning state is <strong class="source-inline">D</strong> – uninterruptible sleep. Processes are in the uninterruptible sleep state if they actively wait for input/output operations to complete, so if there is a large number of such processes, it may mean that the input/output systems <span class="No-Break">are overloaded.</span></p>
<p>Note that there are mysterious processes with command names in square brackets that you don’t see in the output of <strong class="source-inline">pstree</strong>. Those are, in fact, kernel services that are made to look like processes for ease of monitoring, or for their own <span class="No-Break">internal reasons.</span></p>
<p>If you want <a id="_idIndexMarker229"/>to also see what user owns each of those processes, you may want to add <strong class="source-inline">u</strong> to <span class="No-Break">your command:</span></p>
<pre class="source-code">
$ ps axu
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root        1  0.0  0.8 108084  8340 ?        Ss   Apr01   1:13 /usr/lib/systemd/systemd --switched-root --system --deserialize 30
root        2  0.0  0.0      0     0 ?     S    Apr01   0:01 [kthreadd]</pre>
<p>There are many more selection and formatting options, which you <a id="_idTextAnchor076"/>can find in the <span class="No-Break">official documentation.</span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor077"/>Process monitoring tools</h2>
<p>The <strong class="source-inline">ps</strong> command gives you a static picture of processes, CPU and memory consumption. If you want to find <a id="_idIndexMarker230"/>out what causes CPU usage spikes, that’s very inconvenient – you need to be lucky to run <strong class="source-inline">ps</strong> exactly when a spike occurs. That’s why people wrote tools that monitor processes continuously and can display them sorted by <span class="No-Break">resource consumption.</span></p>
<p>One of the oldest tools in this class is called <strong class="source-inline">top</strong>. It’s widely available in Linux distribution repositories and may even be installed by default in your system. It displays an interactive process list, with processes that consume the largest amount of resources automatically floating to <span class="No-Break">the top.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<img alt="Figure 4.1 – The top command output" height="593" src="image/B18575_04_01.jpg" width="817"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The top command output</p>
<p>There are other <a id="_idIndexMarker231"/>tools inspired by it, such as <strong class="source-inline">htop</strong>, which offers different user interfaces and additional functionality. There are also tools that monitor resource usage types that <strong class="source-inline">top</strong> or <strong class="source-inline">htop</strong> don’t, such as <strong class="source-inline">iotop</strong>, a tool to monitor<a id="_idTextAnchor078"/> the input/output activity <span class="No-Break">of processes.</span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor079"/>The /proc filesystem</h2>
<p>Finally, let’s examine <a id="_idIndexMarker232"/>the lowest-level interface to process information – the <strong class="source-inline">/proc</strong> filesystem. It’s an example of a <em class="italic">virtual filesystem</em> and a good illustration of the <em class="italic">everything is a file</em> principle widely used by Unix-like <span class="No-Break">operating systems.</span></p>
<p>To users, <strong class="source-inline">/proc</strong> looks like a directory with files. Some of those files have nothing to do with processes and contain other system information instead – for example, <strong class="source-inline">/proc/version</strong> contains the running kernel version. Here’s an example from a Fedora <span class="No-Break">35 system:</span></p>
<pre class="source-code">
$ cat /proc/version
Linux version 5.16.18-200.fc35.x86_64 (mockbuild@bkernel01.iad2.fedoraproject.org) (gcc (GCC) 11.2.1 20220127 (Red Hat 11.2.1-9), GNU ld version 2.37-10.fc35) #1 SMP PREEMPT Mon Mar 28 14:10:07 UTC 2022</pre>
<p>However, those files aren’t files on disk, and not even the root user can write to them or delete them. The kernel simply makes them look like files so that users can use familiar tools to <span class="No-Break">read them.</span></p>
<p>Whenever a <a id="_idIndexMarker233"/>process is launched, the kernel adds a subdirectory named <strong class="source-inline">/proc/&lt;PID&gt;/</strong>. For example, let’s peek into the directory of the <span class="No-Break"><strong class="source-inline">init</strong></span><span class="No-Break"> process:</span></p>
<pre class="source-code">
$ sudo ls /proc/1/
arch_status  auxv     cmdline      cpu_resctrl_groups  environ  fdinfo    
latency   map_files  mountinfo     net     oom_adj       pagemap    
projid_map  schedstat  smaps      stat syscall         timers        wchan
attr         cgroup     comm       cpuset          exe      gid_map    
limits      maps         mounts     ns        oom_score       
patch_state    root        sessionid  smaps_rollup  statm   task         
timerslack_ns
autogroup    clear_refs  coredump_filter  cwd              fd       io    
loginuid  mem         mountstats  numa_maps  oom_score_adj  personality    
sched        setgroups  stack         status  timens_offsets  uid_map</pre>
<p>That interface is too low-level for an end user most of the time. For example, environment variables passed to a process on launch can be found in a file named <strong class="source-inline">environ</strong>, but let’s try to read it <span class="No-Break">and see:</span></p>
<pre class="source-code">
$ sudo cat /proc/1/environ
TERM=vt220BOOT_IMAGE=(hd0,gpt2)/vmlinuz-5.16.18-200.fc35.x86_64</pre>
<p>That output appears to be garbled – variables have no separators. In reality, it’s not a bug; that file simply contains the process environment data exactly as it appears in its memory, with variable pairs separated by non-printable null characters, as per the C programming <span class="No-Break">language convention.</span></p>
<p>The same applies to <strong class="source-inline">/proc/1/cmdline</strong> – the file that contains a full command that was used to launch <span class="No-Break">that process:</span></p>
<pre class="source-code">
$ sudo cat /proc/1/cmdline
/usr/lib/systemd/systemd--switched-root--system--deserialize30</pre>
<p>However, it’s recognizable, and it’s exactly where <strong class="source-inline">ps</strong> takes the process command; it just inserts spaces in place of null bytes to make it correct <span class="No-Break">and readable:</span></p>
<pre class="source-code">
$ ps ax | grep systemd
   1 ?     Ss     1:14 /usr/lib/systemd/systemd --switched-root --system --deserialize 30</pre>
<p>Thus, it’s good <a id="_idIndexMarker234"/>to know about the raw <strong class="source-inline">/proc</strong> interface, but it’s impractical to use it as a source of process information. Tools such as <strong class="source-inline">ps</strong> and <strong class="source-inline">pstree</strong> can present it in a much more readable form and allow you to filter it. However, it’s also important to understand that those tools don’t use any special kernel interfaces other than <strong class="source-inline">/proc</strong>, and in an emergency situation, you can always get the same information from there without any tools <span class="No-Break">at all.</span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor080"/>Summary</h1>
<p>In this chapter, we learned that process startup is not a trivial operation, and even native code binaries are not simply loaded into memory byte by byte. We learned how to explore the process tree with the <strong class="source-inline">pstree</strong> command, how to force processes to terminate or reload with <strong class="source-inline">kill</strong>, and how to examine and interpret <span class="No-Break">exit codes.</span></p>
<p>We also learned that the kernel communicates with running processes using POSIX signals, that different signals have different meanings, and that there are more signals than what the <strong class="source-inline">kill</strong> command allows the user to send. Apart from <strong class="source-inline">SIGTERM</strong> or <strong class="source-inline">SIGKILL</strong>, which are sent by users or userspace tools, there are many signals that the kernel uses to indicate programming errors and special conditions. Among them are <strong class="source-inline">SIGILL</strong>, for programs that attempt to execute illegal CPU instructions, and <strong class="source-inline">SIGPIPE</strong>, for cases when a connection is closed by the <span class="No-Break">other side.</span></p>
<p>In the next chapter, we will learn how to discover and examine the hardware installed in a machine <span class="No-Break">running Linux.</span></p>
</div>
</div></body></html>