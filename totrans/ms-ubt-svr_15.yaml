- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Automating Server Configuration with Ansible
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 自动化服务器配置
- en: Nowadays, it’s not uncommon to have hundreds of servers that make up your organization’s
    infrastructure. As our user base grows, we’re able to scale our environment to
    meet the demands of our customers. As we scale our resources and add additional
    servers, the amount of time we spend configuring them and setting them up increases
    considerably. The time spent setting up new servers can be a major burden—especially
    if we need to create hundreds of servers within a small window of time. As workload
    demands increase, we need to have a solution in place to manage our infrastructure
    and quickly deploy new resources with as small a workload as possible. In this
    chapter, we explore the concept of configuration management along with automated
    deployments. This sure sounds complicated, but it’s not—you’ll be surprised how
    easy it is to automate your configuration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，拥有成百上千台服务器组成组织基础设施并不罕见。随着用户基数的增加，我们能够扩展环境以满足客户需求。当我们扩展资源并增加额外服务器时，配置和设置这些服务器所花费的时间会显著增加。设置新服务器所花费的时间可能成为一项重大负担——特别是当我们需要在短时间内创建数百台服务器时。随着工作负载的增加，我们需要有一个解决方案来管理我们的基础设施，并尽可能以最小的工作量快速部署新资源。在本章中，我们将探讨配置管理的概念以及自动化部署。听起来很复杂，但其实并不难——你会惊讶于自动化配置有多么简单。
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下内容：
- en: Understanding the need for configuration management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解配置管理的需求
- en: Why Ansible?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 Ansible？
- en: Creating a Git repository
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Git 仓库
- en: Getting started with Ansible
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Ansible
- en: Making your servers do your bidding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的服务器按照你的指令行事
- en: Putting it all together – automating web server deployment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一切整合在一起——自动化部署 Web 服务器
- en: Using Ansible’s pull method
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 的拉取方式
- en: In the introduction, I’ve already given you some examples of why you might want
    to consider building automation into your workflow and implement an effective
    solution in your environment. In the next section, we’ll explore the need for
    automation in more detail before we actually get started.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍中，我已经给出了你可能希望将自动化集成到工作流中的一些示例，并在你的环境中实现有效的解决方案。在接下来的部分，我们将更详细地探讨自动化的需求，然后再开始实际操作。
- en: Understanding the need for configuration management
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解配置管理的需求
- en: When I first started working in the IT industry, it was a much different landscape
    than it is today. Servers were all physical, and any time you needed a new server,
    you literally needed to call a vendor and order one.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我刚开始从事 IT 行业时，那个时候的环境和今天有很大的不同。服务器都是物理服务器，每当你需要一台新服务器时，你需要打电话给供应商并订购一台。
- en: You waited for a week or two for the server to be built and sent to you. When
    it arrived, you installed it in a rack, set up an operating system, and then installed
    whatever applications you needed. You then tested the server for a while to make
    sure the combination of software, hardware, and drivers was stable and reliable.
    After some time, you’d deploy the new server into production.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能等待了一到两周才等到服务器搭建并发货给你。收到服务器后，你把它安装到机架上，设置操作系统，然后安装所需的应用程序。你会测试这台服务器一段时间，确保软件、硬件和驱动程序的组合是稳定可靠的。过了一段时间，你就可以将新服务器投入生产使用。
- en: Nowadays, it’s still the case that system administrators often need to purchase
    and install hardware, much like the process I mentioned in the previous paragraph.
    However, with virtual machines and containers, the physical hardware we install
    is commonly just a catalyst to host virtual resources. In the past, we had one
    physical server for each use case, which meant we needed to have very large server
    rooms. But in modern times, you may have a server with dozens of cores that are
    capable of running hundreds of virtual machines. But the problem of configuration
    remains—the process of setting up an operating system and applications is a very
    time-consuming endeavor.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，系统管理员仍然经常需要购买和安装硬件，就像我在前面提到的那样。然而，随着虚拟机和容器的出现，我们安装的物理硬件通常只是托管虚拟资源的催化剂。过去，我们为每个用例配备一台物理服务器，这意味着我们需要非常大的服务器机房。但在现代，你可能有一台具有数十个核心的服务器，能够运行成百上千个虚拟机。但配置问题依然存在——设置操作系统和应用程序的过程是一个非常耗时的工作。
- en: As the landscape changed, the need for automation increased. Servers needed
    to be deployed quickly and efficiently. With the large number of servers in a
    typical data center, it became less and less practical to connect to each of them
    and configure them one by one every time a change was necessary. For example,
    when a security vulnerability hit the news, the typical administrator would need
    to manually install a patch on every server. This could take days or even weeks.
    That’s not very efficient.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术环境的变化，对自动化的需求增加。服务器需要快速高效地部署。在典型数据中心中，由于服务器数量庞大，每次需要变更时，逐一连接每台服务器并进行配置变得越来越不现实。例如，当安全漏洞成为新闻时，通常的管理员需要手动在每台服务器上安装补丁。这可能需要几天甚至几周的时间。这显然效率低下。
- en: To better deal with this issue, the concept of configuration management has
    become very popular. With configuration management, an administrator can write
    some sort of code (such as a script) and then use a utility to execute it across
    every server. Configuration management is also known as **Infrastructure as Code**
    (**IaC**) and basically lets the administrator define a set of guidelines for
    servers of various types and have them automatically be provisioned to meet those
    requirements. This automation saves a ton of work.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地应对这一问题，配置管理的概念变得非常流行。通过配置管理，管理员可以编写某种代码（例如脚本），然后使用工具在每台服务器上执行它。配置管理也被称为**基础设施即代码**（**IaC**），基本上让管理员为各种类型的服务器定义一组指南，并自动配置服务器以满足这些要求。这种自动化节省了大量的工作。
- en: Configuration management also comes into play while provisioning a new server.
    Imagine defining some rules for a specific type of server, and having it come
    to life meeting those exact specifications. The applications you want it to have
    are installed during the provisioning process, configuration files are copied
    over, users are created, and firewall rules are put in place, all automatically
    as defined in your specification. Put even more simply, imagine setting up something
    like a web server with just a single command. No need to install Apache or do
    any of that manual work. You simply request a server, and the configuration management
    solution you have in place will take care of the rest.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理在配置新服务器时也发挥作用。假设为特定类型的服务器定义一些规则，并使其按照这些规则生效。在配置过程中，您希望它安装的应用程序会被自动安装，配置文件被复制，用户被创建，防火墙规则被设置，所有这些都按照您的规范自动完成。更简单地说，假设您只需要通过一个命令就能设置一个类似于
    Web 服务器的环境。无需安装 Apache 或做任何手动工作。您只需要请求一个服务器，您所设置的配置管理解决方案将会处理其余的工作。
- en: IaC, which is basically a fancy term for configuration management, is essentially
    just the automated running of scripts on your servers. In this book, we’ve looked
    at automation already. In *Chapter 6*, *Boosting Your Command-line Efficiency*,
    we wrote a simple script that we could use to back up a server. That same mentality
    can be used for provisioning servers as well, by simply having a server run a
    script when it comes online. For existing servers, you can make a change once
    and apply that change to every server you manage, or even just a subset.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**IaC**，基本上是配置管理的一个花哨术语，本质上就是在服务器上自动运行脚本。在本书中，我们已经介绍过自动化。在*第6章*，*提升命令行效率*中，我们编写了一个简单的脚本，可以用来备份服务器。同样的思路也可以用于服务器的配置，只需在服务器上线时让其运行一个脚本。对于现有的服务器，您可以只修改一次并将该变更应用到您管理的每台服务器，甚至是某些子集。'
- en: This is where configuration management utilities, such as Chef, Puppet, and
    others, come into play. Each of these solutions features a specific type of scripting
    language that is designed from the ground up to facilitate the provisioning of
    resources. With such utilities, there is typically some sort of program (or locally
    installed agent) that interprets the instructions from a central server and runs
    them on its clients. Each solution is relatively smart; it will determine what
    needs to be done and perform the steps.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理工具，如 Chef、Puppet 等，在这里发挥作用。这些解决方案中的每一个都具有一种特定类型的脚本语言，旨在从零开始简化资源的配置过程。使用这些工具时，通常会有某种程序（或本地安装的代理）来解释来自中央服务器的指令，并在其客户端上执行这些指令。每个解决方案都相对智能，它将确定需要完成的任务并执行相关步骤。
- en: If a requirement is met, the instruction is skipped. If a required resource
    is not present, it will be configured appropriately. One such configuration management
    solution is Ansible, which we will use in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足某个要求，指令会被跳过。如果缺少必要的资源，它将被适当配置。一个这样的配置管理解决方案是Ansible，我们将在本章中使用它。
- en: Why Ansible?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Ansible？
- en: In this chapter, I will show you how to set up Ansible, and then we will use
    it to automate some configuration tasks. By the end of this chapter, you’ll understand
    the basic concepts you can use to start the process of automating deployments
    in your organization. You may be wondering, then, why Ansible and not one of the
    other solutions, such as Chef or Puppet?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向你展示如何设置Ansible，接着我们将使用它来自动化一些配置任务。到本章结束时，你将理解一些基本概念，可以开始在你的组织中自动化部署过程。你可能会问，为什么是Ansible，而不是其他解决方案，比如Chef或Puppet？
- en: Some configuration management solutions are relatively heavy from a resource
    perspective. With other solutions, you’ll generally have a central server, which
    will run a master program. This program will periodically *check in* with each
    server under its control by communicating with the agent installed on each server.
    Then, the agent will receive instructions from the central server and carry them
    out.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一些配置管理解决方案在资源角度上比较沉重。对于其他解决方案，你通常会有一个中央服务器，它将运行一个主程序。这个程序会定期与每个受控服务器通过与安装在每台服务器上的代理进行通信，*检查*它们的状态。然后，代理将从中央服务器接收指令并执行。
- en: This means that you’ll need to maintain a server with modest CPU and RAM requirements,
    and the agent on the client side of the communication will also spend valuable
    CPU in order to carry out the instructions. This resource utilization can be very
    heavy on both the primary and client servers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你需要维持一台具有适度CPU和内存要求的服务器，并且通信过程中的客户端代理也需要消耗宝贵的CPU来执行指令。这种资源利用可能会对主服务器和客户端服务器造成很大负担。
- en: Ansible is very different than the other solutions in that there is no agent
    at all. There is typically a server, but it’s not required to run any resource-intensive
    software. The entire configuration process happens via SSH, so you can even carry
    out the instructions from your workstation if you want to skip having to maintain
    a central server. Typically, the administrator will create a user account on each
    server, and then the central Ansible server (or workstation) will execute commands
    over SSH to update the configuration on each machine. Since there is no agent
    installed on each server, the process takes a lot less CPU. Of course, the instructions
    that Ansible gives your servers will definitely result in CPU usage, but certainly
    a lot less than the other solutions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible与其他解决方案的最大不同在于，它根本不需要代理。通常会有一个服务器，但它不需要运行任何资源密集型的软件。整个配置过程通过SSH完成，因此如果你不想维护一个中央服务器，你甚至可以从你的工作站执行指令。通常，管理员会在每台服务器上创建一个用户帐户，然后中央Ansible服务器（或工作站）将通过SSH执行命令来更新每台机器的配置。由于每台服务器上都没有安装代理，整个过程的CPU消耗要少得多。当然，Ansible给服务器下达的指令肯定会导致CPU使用，但肯定比其他解决方案要少得多。
- en: Ansible is typically set up by creating an **inventory file**, which contains
    a list of resources (servers) (in the form of hostnames or IP addresses that Ansible
    will be instructed to connect to and configure). If you want to add a new server,
    you simply make sure that a specific user account exists on that server, then
    you add it to the inventory list. If you want to remove it, you delete the line
    in the inventory file corresponding to that server. It’s very easy.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible通常通过创建一个**清单文件**来设置，这个文件包含了一份资源（服务器）列表（形式为主机名或IP地址，Ansible将被指示连接并配置）。如果你想添加一台新服务器，只需要确保该服务器上存在一个特定的用户帐户，然后将它添加到清单中。如果你想移除它，只需要删除清单文件中与该服务器对应的行。非常简单。
- en: However, something that’s magical about Ansible is that you don’t even have
    to run a central server at all if you don’t want to. You can store your Ansible
    configuration in a Git repository, and have each server download code from the
    repository and run it locally. This means that if you do have a dynamic environment
    where servers come and go all the time (which is very common in cloud deployments),
    you don’t have to worry about maintaining an inventory file. Just instruct each
    server to download the code and provision themselves. This is known as the **pull
    method** of Ansible, which I will also show you.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Ansible 的一个神奇之处在于，你完全不必运行中央服务器，如果你不想的话。你可以将 Ansible 配置存储在 Git 仓库中，然后让每台服务器从仓库中下载代码并在本地运行。这意味着，如果你有一个动态环境，服务器时常增减（这在云部署中非常常见），你不必担心维护一个清单文件。只需要指示每台服务器下载代码并自行配置。这就是
    Ansible 的**pull 方法**，我将在后面展示给你。
- en: While solutions such as Chef and Puppet have their merits and are definitely
    fun to use, I think you’ll find that Ansible scales better and gives you far more
    control over how these hosts are configured. While it’s up to you to figure out
    exactly how you want to implement Ansible, the creative freedom it gives you is
    second to none. I’ve been using Ansible for quite a while now, and I’m still finding
    new ways to use it. It’s a technology that will grow with you.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Chef 和 Puppet 等解决方案各有优点，且使用起来确实很有趣，但我相信你会发现，Ansible 在扩展性方面更优秀，且能让你对这些主机的配置拥有更多的控制权。虽然如何实施
    Ansible 完全取决于你，但它给予你的创作自由无与伦比。我已经使用 Ansible 一段时间了，仍在不断发现新的使用方式。这是一项能与您共同成长的技术。
- en: Creating a Git repository
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Git 仓库
- en: For the examples in this chapter, it’s recommended that you create a Git repository
    to store your Ansible code. This isn’t required, as you can find other ways of
    hosting your code, but it’s highly recommended. This is especially true when we
    get to the pull method of Ansible at the end of this chapter. In this section,
    I’ll walk you through creating a repository. If you already know how to use GitHub,
    you can skip this section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例，建议你创建一个 Git 仓库来存储你的 Ansible 代码。这不是强制性的，因为你可以通过其他方式托管代码，但强烈推荐这么做。尤其是在本章末尾讲解
    Ansible 的 pull 方法时，创建 Git 仓库显得尤为重要。如果你已经知道如何使用 GitHub，可以跳过这一部分。
- en: While a full walkthrough of Git is beyond the scope of this book, the basics
    are more than enough for following along here. When it comes to Git, you can simply
    install the `git` package on a server to have it host your code, but GitHub is
    probably the easiest way to get started. An added bonus is that GitHub is home
    to a lot of great projects you can benefit from, and browsing the code of these
    projects is a great way to become more accustomed to syntax rules with different
    scripting and programming languages. For our purposes, we’re going to use GitHub
    as a central place to store our Ansible code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书无法对 Git 进行全面讲解，但基本概念足以帮助你跟上本书的内容。对于 Git，你可以简单地在服务器上安装`git`软件包来托管你的代码，但 GitHub
    可能是最简单的入门方式。额外的好处是，GitHub 上有许多优秀的项目，你可以从中受益，浏览这些项目的代码是熟悉不同脚本语言和编程语言语法规则的好方法。对于我们的目的，我们将使用
    GitHub 作为存储 Ansible 代码的中央位置。
- en: It probably goes without saying, but GitHub is a public resource. Any code you
    upload to the service will be available for all to see by default. Therefore,
    be mindful of the information you commit to your repository. Make sure you don’t
    include any personally identifiable information, passwords, blueprints, API keys,
    or anything else you don’t want the public to know about you or your organization.
    You can create a private repository to hide confidential information, but it’s
    still safer to not upload protected information at all (whether the repository
    is private or not).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是显而易见的，但 GitHub 是一个公开资源。你上传到服务的任何代码默认都可以供所有人查看。因此，提交到仓库时需要注意你包含的信息。确保不包含任何个人身份信息、密码、蓝图、API
    密钥或任何你不希望公众知道的关于你或你组织的信息。你可以创建一个私有仓库来隐藏机密信息，但即便如此，最好不要上传受保护的信息（无论仓库是否为私有）。
- en: 'To get started, create an account at [https://www.github.com](https://www.github.com)
    if you don’t already have one. This is a free process. Make sure you create a
    reasonably secure password here. After you have created an account, click on **New
    repository**, and then give it a name (simply calling it `ansible` is fine):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请在 [https://www.github.com](https://www.github.com) 创建一个帐户（如果尚未拥有）。这是一个免费的过程。确保在这里创建一个相对安全的密码。创建完帐户后，单击
    **新建仓库**，然后给它命名（简单地称为 `ansible` 即可）：
- en: '![](img/B18425_15_01.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_15_01.png)'
- en: 'Figure 15.1: Creating an Ansible repository on GitHub'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1：在 GitHub 上创建一个 Ansible 仓库
- en: In the example screenshot, I created a repository that is **Public**, which
    means exactly that—anyone will be able to view the code. You can create **Private**
    repositories as well, if you prefer. Since we’re not going to include confidential
    information in the repository during the examples in this book, we don’t need
    to worry about that right now.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例截图中，我创建了一个 **公共** 仓库，这意味着任何人都可以查看代码。如果你喜欢，也可以创建 **私有** 仓库。由于在本书的示例中不会包含仓库中的机密信息，因此我们现在不需要担心这个问题。
- en: 'Once the repository is created using **Create repository**, we’ll need to download
    it locally. For that, we’ll need to install the `git` package:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建仓库后，我们需要下载它到本地，使用 **创建仓库**。为此，我们需要安装 `git` 软件包：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we should set up our local Git client so that we can fill out our name
    and email address, otherwise Git will most likely complain. To do this, we can
    issue the following commands, substituting the content in the quotes with your
    information:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该设置本地的 Git 客户端，以便我们可以填写我们的姓名和电子邮件地址，否则 Git 很可能会抱怨。为此，我们可以使用以下命令，并将引号中的内容替换为你的信息：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To download our repository, the following will do the trick (ignore the warning
    about the repository being empty if you see such a message):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载我们的仓库，以下操作将奏效（如果看到关于仓库为空的警告，请忽略）：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now you have the Git repository downloaded locally. Right now, the repository
    doesn’t include anything useful. To create a file within the repository, you simply
    change your working directory to be inside the repository folder that was downloaded
    when you cloned it, and create whatever files you want inside. By default, Git
    doesn’t care about any files you create inside the repository until you add them.
    For example, we can create a test file and commit it to the repository with the
    following commands:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将 Git 仓库下载到本地。目前，该仓库不包含任何有用的内容。要在仓库中创建文件，只需将工作目录更改为克隆时下载的仓库文件夹内部，并在其中创建任何你想要的文件。默认情况下，Git
    不会关心你在仓库内创建的任何文件，直到你添加它们。例如，我们可以使用以下命令创建一个测试文件并提交到仓库：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With these commands, we used `echo` to create a test file with some text in
    it. Then, we used the `git add` command to tell Git that we want the file to be
    a part of our repository. Finally, we finalized our changes by using `git commit`,
    along with the `-m` flag and a message about the commit. At this point, the changes
    only exist locally. To push our changes back to GitHub, we use the following command
    from inside the repository directory:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些命令，我们使用 `echo` 创建了一个包含一些文本的测试文件。然后，我们使用 `git add` 命令告诉 Git 我们希望这个文件成为仓库的一部分。最后，我们通过
    `git commit` 完成了我们的更改，同时使用了 `-m` 标志并附上了关于提交的消息。此时，这些更改仅存在于本地。要将更改推送回 GitHub，我们从仓库目录内部使用以下命令：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By following the on-screen prompts (GitHub username and password), our changes
    will be placed inside our actual repository.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按照屏幕提示（GitHub 用户名和密码），我们的更改将被放置在我们的实际仓库内部。
- en: So, how does this help us when it comes to configuration management? Typically,
    the code that administrators use to provision servers will be placed inside a
    repository for safekeeping. If the local copy of the code is lost, it can simply
    be cloned again from the repository. GitHub is a safe place to put our code, since
    we can be reasonably sure that our code won’t disappear as the service is very
    stable (you still may want to create a local backup to be safe). Whether you’re
    using Ansible, Chef, Puppet, or another utility, it’s common practice to keep
    the code in a Git repository. With regard to Ansible, this will directly impact
    us in the last section of this chapter since we’ll be using the `ansible-pull`
    command, which expects a repository URL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这如何帮助我们进行配置管理呢？通常，管理员用于配置服务器的代码会保存在一个仓库中以确保安全。如果本地的代码丢失了，只需从仓库中重新克隆即可。GitHub
    是我们存放代码的安全地方，因为我们可以合理地确信，代码不会丢失，因为该服务非常稳定（不过你仍然可能希望创建一个本地备份以确保安全）。无论你是使用 Ansible、Chef、Puppet
    还是其他工具，将代码保存在 Git 仓库中都是常见做法。就 Ansible 而言，这将直接影响本章最后一节，因为我们将使用 `ansible-pull` 命令，它需要一个仓库
    URL。
- en: 'In practice, when we create Ansible playbooks, you should commit those changes
    back to the repository. I won’t specifically call on you to do that, so go ahead
    and keep that in mind as we go. When you create a new playbook, add it to the
    repository, then commit it. If you make changes to existing files, commit those
    changes. Be sure to use the `git push` command to push your changes back to the
    repository. For example, if you created a file inside the repository named `myplaybook.yml`,
    you would execute commands such as these:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，当我们创建 Ansible 剧本时，应该将这些更改提交回仓库。我不会特别要求你这么做，但请在接下来的操作中牢记这一点。当你创建一个新的剧本时，将其添加到仓库中，然后提交。如果你对现有文件进行了更改，记得提交这些更改。确保使用
    `git push` 命令将更改推送回仓库。例如，如果你在仓库中创建了一个名为 `myplaybook.yml` 的文件，你将执行类似以下的命令：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Go ahead and practice this a bit before you move on. Even if you don’t use Ansible
    in production, understanding the basics of Git is invaluable, as you’ll almost
    definitely need it at some point in your career.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，不妨先练习一下。即使你在生产环境中不使用 Ansible，了解 Git 的基础知识也非常宝贵，因为你几乎肯定会在未来的某个时刻需要它。
- en: Getting started with Ansible
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Ansible
- en: The first thing to know about Ansible is that it changes constantly. New versions
    with exciting features are released regularly, and it shows no sign of slowing
    down whatsoever. There is a lot of excitement around this technology, so it’s
    regularly improving.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Ansible 的第一件事是它在不断变化。新版本带有令人兴奋的功能，定期发布，而且完全没有放缓的迹象。这个技术引起了很多的关注，因此它也在不断改进。
- en: The reason I’m bringing this up is that although the examples in this book have
    been written for (and tested on) Ubuntu 22.04, new versions of Ansible are released
    regularly outside of Ubuntu’s repositories, and not only include new features
    but syntax changes as well. For our needs in this book, the version of Ansible
    included in the repositories should be more than fine. However, if you were to
    look at examples of Ansible playbooks online, they might be written for a newer
    version (or even an older version). If for any reason you have an issue with a
    particular example written for Ansible, a good first step in terms of troubleshooting
    is to compare the version of Ansible the tutorial was written for against the
    version installed. When it comes to Ubuntu 22.04, the version of Ansible that’s
    made available is 2.10.x. You can install a newer version of Ansible from the
    official website, but for the purposes of this book, we’ll use the version that’s
    in the default repositories.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以提到这一点，是因为尽管本书中的示例是在 Ubuntu 22.04 上编写并测试的，但 Ansible 的新版本会定期发布，且这些版本不仅包含新功能，还包括语法更改。对于本书的需求，仓库中提供的
    Ansible 版本应该完全足够。然而，如果你查看网上的 Ansible 剧本示例，它们可能是为较新版本（甚至较旧版本）编写的。如果你遇到针对特定示例的 Ansible
    问题，排查的一个好方法是对比教程所用的 Ansible 版本与已安装的版本。对于 Ubuntu 22.04，提供的 Ansible 版本是 2.10.x。你可以从官方网站安装更高版本的
    Ansible，但为了本书的目的，我们将使用默认仓库中的版本。
- en: 'Go ahead and install `ansible` via `apt`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 继续通过 `apt` 安装 `ansible`：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now you should have the `ansible-playbook` command available, which is the main
    binary that we’ll be using as we explore Ansible. There are other commands that
    Ansible provides us, but we’re not concerned with them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该已经能够使用`ansible-playbook`命令了，这是我们在探索Ansible时将使用的主要命令。Ansible还提供了其他一些命令，但我们不关心它们。
- en: In order to follow along with the remainder of this chapter, it’s recommended
    that you have at least two servers to work with; the more the better. If you have
    a **Virtual Machine** (**VM**) solution such as VirtualBox available, simply create
    additional VMs. To save time, consider cloning an existing VM a few times (just
    make sure you don’t overload your computer/server by over-allocating resources).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够跟上本章的其余内容，建议你至少有两台服务器来操作；更多的服务器会更好。如果你有像VirtualBox这样的**虚拟机**(**VM**)解决方案，只需创建更多的虚拟机。为了节省时间，可以考虑克隆现有虚拟机几次（只是确保不要通过过度分配资源来超载你的计算机/服务器）。
- en: 'The most common workflow of Ansible works something like this: you have a main
    server or workstation, on which Ansible is installed. While you don’t need an
    agent on the clients, they will, however, need OpenSSH installed and configured
    as that’s how Ansible communicates. To make things easy, it’s recommended to have
    a dedicated Ansible user on each machine, and the Ansible user on the server should
    be able to connect to each machine without a password. It doesn’t matter what
    you call the Ansible user; you can simply use `ansible` or something clever. We
    covered how to create SSH keys in *Chapter 10*, *Connecting to Networks*, so refer
    to that if you need a reminder. Creating users was covered in *Chapter 2*, *Managing
    Users and Permissions*. In a nutshell, here are the things you should work on
    in order to set up your environment for Ansible:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible最常见的工作流大致是这样的：你有一台安装了Ansible的主服务器或工作站。虽然客户端不需要安装代理，但它们需要安装并配置OpenSSH，因为Ansible通过SSH进行通信。为了简化操作，建议每台机器上都有一个专门的Ansible用户，并且服务器上的Ansible用户应能无密码连接到每台机器。你可以随便为Ansible用户起个名字；你可以使用`ansible`，也可以起个更有创意的名字。我们在*第10章*，*连接到网络*中介绍了如何创建SSH密钥，如果需要回顾，可以参考该章节。创建用户的内容在*第2章*，*管理用户和权限*中有所讲解。总之，以下是你为了设置Ansible环境需要做的几件事：
- en: Install Ansible on a central server or workstation
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中央服务器或工作站上安装Ansible
- en: Create a user for Ansible on each machine you want to manage configuration on
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每台你想管理配置的机器上创建一个Ansible用户
- en: Create the same user on your central server or your local machine
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中央服务器或本地机器上创建相同的用户
- en: Set up the Ansible user on the server so that it can connect to clients via
    SSH without a password
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器上设置Ansible用户，以便它能够通过SSH连接到客户端且无需密码。
- en: Configure `sudo` on the client machines so that the Ansible user can execute
    commands with `sudo` with no password
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置客户端机器上的`sudo`，使得Ansible用户可以在没有密码的情况下执行`sudo`命令
- en: 'In previous chapters, we covered how to create users and SSH keys, but we have
    yet to cover the last point. Assuming you named your Ansible user `ansible`, create
    the following file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们讲解了如何创建用户和SSH密钥，但还没有讲解最后一点。假设你将Ansible用户命名为`ansible`，创建以下文件：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside that file, place the following text:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在该文件中，放入以下内容：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to ensure that the file is owned by `root`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保该文件的所有者是`root`：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we need to adjust the permissions of the file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要调整文件的权限：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Go ahead and test this out. On the server, switch to the `ansible` user:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以开始测试了。在服务器上切换到`ansible`用户：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, to test this out, use SSH to execute a command on a remote machine:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试一下，通过SSH在远程机器上执行一个命令：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How does this work? You may or may not know this, but if you use SSH to execute
    just one command, you don’t necessarily need to set up a persistent connection.
    In this example, we first switch to the `ansible` user. Then, we connect to `192.168.1.123`
    (or whatever the IP address of the client is) and tell it to execute `sudo ls
    /etc`. Executing an `ls` command with `sudo` may seem like a silly thing to do,
    but it’s great—it allows you to test whether or not `sudo` works without doing
    anything potentially dangerous. Listing the contents of a directory is about as
    innocent as you can get.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的呢？你可能知道也可能不知道，如果你使用SSH执行单个命令，其实不一定需要建立一个持久连接。在这个例子中，我们首先切换到`ansible`用户。然后，我们连接到`192.168.1.123`（或者客户端的IP地址），并告诉它执行`sudo
    ls /etc`。用`sudo`执行`ls`命令可能看起来像个傻事，但这非常有用——它让你可以测试`sudo`是否能正常工作，而不会做出任何潜在危险的操作。列出目录的内容是最无害的操作之一。
- en: It may seem like an awful lot of steps in order to get configuration management
    working. But make sure you think with a system administrator’s mindset—these setup
    tips can be automated. In my case, I have a Bash script that I run on each of
    my servers that sets up the required user, keys, and `sudo` access specifically
    for Ansible. Anytime I want to add a new server to Ansible, I simply run that
    script on the machine just once, and from that point forward Ansible will take
    care of the rest.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '这看起来可能像是一个繁琐的过程，但请确保你从系统管理员的角度思考——这些设置步骤是可以自动化的。以我为例，我有一个 Bash 脚本，会在每台服务器上运行，设置所需的用户、密钥和专门用于
    Ansible 的 `sudo` 权限。每当我想将新服务器添加到 Ansible 时，只需要在该机器上运行一次脚本，从此以后，Ansible 将自动处理剩余部分。  '
- en: What should have happened is that the command should have executed and printed
    the contents of `/etc` without prompting you for a password. If this doesn’t work,
    make sure you have completed each of the recommended steps. You should have an
    `ansible` user on each machine, and that user should have access to `sudo` without
    a password since we created a file for that user in `/etc/sudoers.d`. If the SSH
    portion fails, check the log file at `/var/log/auth.log` for clues, as that is
    where related errors will be saved. Once you have met these requirements, we can
    get automating with Ansible!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '正常情况下，命令应该执行并打印 `/etc` 目录的内容，而不会提示你输入密码。如果这不起作用，请确保你已经完成了所有推荐的步骤。每台机器上应该有一个
    `ansible` 用户，该用户应具备无需密码的 `sudo` 权限，因为我们已经在 `/etc/sudoers.d` 中为该用户创建了一个文件。如果 SSH
    部分失败，请检查 `/var/log/auth.log` 日志文件，里面会保存相关错误的线索。一旦你满足了这些要求，就可以开始使用 Ansible 自动化了！  '
- en: Making your servers do your bidding
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '让你的服务器按照你的意愿工作  '
- en: As server administrators, we’re control freaks. There are few things more exciting
    than executing a command and having every single server obey it and carry it out.
    Now that we have Ansible set up, that’s exactly what we’re going to do. I’m assuming
    by now you have some machines you want to configure, and they’re all set up to
    communicate via SSH with your central server. Also, as I mentioned before, I highly
    recommend you utilize something like Git to store your configuration files, but
    that’s not required for this section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '作为服务器管理员，我们都是控制狂。没有什么比执行一个命令，看到每一台服务器都服从并执行它更让人兴奋了。既然我们已经设置好 Ansible，接下来正是要做这件事。我假设你现在已经有了一些要配置的机器，它们都已经配置好通过
    SSH 与中央服务器进行通信。另外，正如我之前提到的，我强烈推荐你使用类似 Git 的工具来存储你的配置文件，但这部分并不是本节的必要内容。  '
- en: Setting up an inventory file and configuring Ansible settings
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置清单文件并配置 Ansible 设置
- en: First, we’ll need an inventory file, which is a special text file Ansible expects
    to find that tells it where to find servers to connect to. In previous versions,
    the process of installing the `ansible` package would provide you with some default
    configuration, located in `/etc/ansible`. In Ubuntu 22.04, at least with the version
    of Ansible that’s offered in the default repositories, this is no longer the case.
    For our purposes, that’s fine, though – we were going to create an empty configuration
    anyway.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们需要一个清单文件，这是一种特殊的文本文件，Ansible 需要从中读取信息以确定连接到哪些服务器。在以前的版本中，安装 `ansible`
    包的过程中会为你提供一些默认的配置，位于 `/etc/ansible` 目录下。但在 Ubuntu 22.04 中，至少对于默认仓库中提供的 Ansible
    版本，情况发生了变化。对于我们的目的来说，这没关系——反正我们是要创建一个空的配置文件。  '
- en: 'First, let’s create the directory that we’ll be using for the configuration
    on our “controller” server (the one we’ll be using to control, or “configure,”
    other nodes):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，让我们创建一个目录，在“控制器”服务器上用于配置管理（即我们用来控制或“配置”其他节点的服务器）：  '
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After that, we can create an empty inventory file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '之后，我们可以创建一个空的清单文件：  '
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There’s actually a way to avoid needing to create an inventory file, which we’ll
    get into later in this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '事实上，有一种方法可以避免创建清单文件，稍后我们将在本章中讨论这一点。  '
- en: 'We should also make sure that only the Ansible user account can read it. Execute
    the following command to change ownership (replace `ansible` with whatever user
    account you chose as your Ansible account if you’re using something different):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还应该确保只有 Ansible 用户帐户可以读取该文件。执行以下命令以更改文件的所有权（如果你使用的是不同的用户帐户，请将 `ansible` 替换为你选择的帐户名）：  '
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, modify the permissions such that only the owner can view or change the
    file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，修改文件的权限，使得只有所有者可以查看或更改该文件：  '
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let’s edit the `/etc/ansible/hosts` file and populate it. If you did
    end up having a default `hosts` file created for you when you installed Ansible,
    you can simply empty the file since we’ll be creating our own anyway. What we’ll
    do with this file is populate it with the IP addresses of the servers we wish
    to manage. Feel free to make a backup of the original host file, if it already
    exists. For right now, we’re only including the IP addresses of the nodes we want
    to control with Ansible, so the file will end up looking similar to the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That’s it; it’s simply just a list of IP addresses. I bet you were expecting
    some long configuration with all kinds of syntax requirements? Sorry to disappoint.
    All you need to do is copy a list of IP addresses of the servers you want to manage
    into this file. If you have DNS names set up for the machines you want to configure,
    you can use them instead:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since Ansible understands IP addresses as well as DNS names, we can use either
    or a combination of both in order to set up our inventory file. We can also split
    up our hosts within the inventory file between different roles, but that is outside
    the scope of this book. I do recommend learning about roles in Ansible if you
    wish to take your knowledge further (see the *Relevant videos* section for more
    information).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decide not to store your inventory file at `/etc/ansible/hosts`, you
    must tell Ansible where to find it. There is another important file to Ansible,
    and that is its configuration file, located at `/etc/ansible/ansible.cfg`. Inside
    this file, we can fine-tune Ansible to get the best performance possible. While
    we won’t go over this file in detail, just know that you can seriously increase
    the performance of Ansible by fine-tuning its settings, and Ansible will read
    settings from its configuration file every time it runs. In our case, if we wish
    to store our inventory file somewhere other than `/etc/ansible/hosts`, we will
    need to add the following two lines to this file (most likely, you’ll need to
    create this file since it probably doesn’t already exist at this point):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With the first setting, we’re basically telling Ansible where to find its inventory
    file. There are many more configuration items we can place in the `ansible.cfg`
    file to configure it further, but that’s all we need to configure right now. With
    the second line, we’re setting a default user to use for Ansible playbooks, which
    must exist on any servers you wish to manage with it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the inventory file, Ansible also checks the local directory for a
    file named `ansible.cfg` to fetch its configuration, so you could actually include
    the configuration file in the Git repository as well, and then execute Ansible
    commands from within the repository directory. This works because Ansible will
    check for the existence of a configuration file in your current working directory,
    and use it if it’s found there. You may want to be careful about including your
    configuration file in your Git directory, though. While it’s not as private as
    the inventory file, it can potentially contain privileged information. Therefore,
    you may want to keep the file at `/etc/ansible/ansible.cfg` and manage it outside
    of the Git repository if you include anything private in the file (for example,
    encryption keys).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can test out whether or not Ansible is working at this point. Thankfully,
    this is also easy. Just simply execute the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The results should look similar to this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_15_02.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: Testing Ansible'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how many servers you have set up, you should see that output one
    or more times. You may think that all that command has done is a simple ping test,
    but `ping` means something different to Ansible than usual. It’s actually attempting
    to make a connection to the server, to test its availability. If it fails, double-check
    that the hosts are available over SSH. Success here simply means that Ansible
    is able to communicate with your hosts via SSH. Now that the communication exists,
    we can build some actual configuration.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Configuring client servers
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible uses something called a **playbook** in order to store configuration.
    A playbook is essentially a file in the YAML format with instructions that Ansible
    understands, that are interpreted as a set of tasks run against hosts A full guide
    on YAML isn’t something we’ll be covering here – you don’t have to master this
    format or even fully understand it to use it with Ansible. That will automatically
    come in time. The takeaway here is that YAML is simply the format that Ansible
    uses, and it’s a file format that’s not specific to Ansible itself. A playbook
    is basically just a collection of instructions written in YAML format, and each
    individual instruction is known as a play.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: You can think of this with the analogy of a sport, like football. Although I
    don’t know the first thing about football, I do know that football coaches have
    playbooks containing things that they want their players to do, and each action
    by a player is a play. It’s the same concept here.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write our first playbook. Create a file called `packages.yml` in your
    local Ansible directory. You can fill it with this content (make sure you include
    the hyphens):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can run this playbook with the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will produce an output that looks something like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_15_03.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: Ansible in action'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Just like that, all of the hosts in your inventory file will have the `htop`
    package installed. It really doesn’t matter which package you install, so long
    as it exists in the repositories; I just used `htop` as a simple example. But
    once you run it, you should see an overview of what was changed. Ansible will
    tell you how many items your hosts updated, how many tasks have failed, and how
    many targets weren’t reachable at the time the playbook was run.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at what the instructions in this sample playbook do.
    The hyphens at the beginning are part of the YAML format, so we really don’t need
    to get into that. Spacing is very important with the YAML format, as you need
    to be consistent throughout.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'In my examples, I am inserting two spaces underneath each heading. A heading
    starts with a hyphen:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we declare which hosts we want to have the commands apply to. I added
    `all` here, which basically runs the configuration against every host in the inventory
    file. With advanced usage, you can actually create `roles` in Ansible and divide
    your hosts between them, such as a web server, database server, and so on. Then,
    you can apply configuration only to hosts inside a particular role. We’re not
    going to get into that in this chapter, but just know that it is possible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line is `become`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This line is basically Ansible’s term for describing `sudo`. We’re telling
    Ansible to use `sudo` to execute the commands, since installing packages requires
    `root` privileges. The next part of the playbook is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This line starts the next section, which is where we place our individual tasks.
    Next, we name our new task (Ansible refers to a “task” as a “play”):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With `name`, we give the play a name. This isn’t required but you should always
    include it. The importance of this is that whatever we type here is what is going
    to show up in the logs if we enable logging, and will also print to the terminal
    as the play runs. We should be descriptive here, as it will certainly help if
    a play fails and we need to locate it in a log file that has hundreds of lines.
    Next, we utilize the `apt` module and tell it to install a package, `htop` in
    this case:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We use the `ansible.builtin.apt` module simply because Ubuntu uses the `apt`
    command to manage packages, but modules exist for all of the popular Linux distributions.
    Ansible’s support of package managers among various distributions is actually
    fairly extensive. All of the major distributions, such as Red Hat, Fedora, openSUSE,
    Arch Linux, and Debian, are supported (and those are just the ones I’ve used in
    my lab off the top of my head). If you want to execute a play against a server
    that’s running a distribution other than Ubuntu, simply adjust `ansible.builtin.apt`
    to something else, such as `ansible.builtin.dnf`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Since Ansible allows you to use additional resources from Galaxy, a site that’s
    specific to Ansible that gives you access to additional capabilities, we use `ansible.builtin.apt`
    instead of simply `apt` in order to clarify that we’re using a built-in module,
    not something we’re using from an external resource.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: This new naming scheme is new since the previous edition of this book was published.
    The older versions of the playbooks should still work just fine, but since the
    naming scheme has changed since then, we’ll use the new naming style going forward.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, of course, add additional packages by simply adding more plays to
    the existing playbook:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, that’s not an extremely efficient method. I’ll show you how we can
    combine multiple similar plays in one play. Sure, you don’t have to, but I think
    you’ll agree that this method looks cleaner:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With the new format, we include just one play to install multiple packages.
    This is similar to the concept of a *for loop* if you have programming knowledge.
    For every package we list, it will run the `ansible.builtin.apt` module against
    it. If we want to add additional packages, we just add a new one to the list.
    Simple.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also copy files to our hosts. Consider the following example playbook,
    which I will call `copy_files.yml`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, you can run this playbook with the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Inside the same directory, create a file called `motd` and place any text in
    it. It doesn’t really matter what you type into the file, but this file in particular
    acts as a message that is printed any time a user logs into a server. When you
    run the playbook, it will copy that file over to the server at the destination
    you configured. Since we created a message of the day (`motd`), we should see
    the new message the next time we log in to the server.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: By now, you’re probably seeing just how useful Ansible can be. Sure, we only
    installed a few packages and copied one file. We could’ve performed those tasks
    easily ourselves without Ansible, but this is only a start. Ansible lets you automate
    everything, and we have to start somewhere. You can tell it to not only install
    packages and copy files, but you can also use it to start services, apply configuration
    file templates, and much more—it will surprise you. In fact, you can go as far
    as to automate the setup of a web server, a user’s workstation... you name it!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together – automating web server deployment
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Speaking of automating the setup of a web server, why don’t we go ahead and
    do exactly that? It’ll be another simple example, but it will serve you well if
    we demonstrate more of what Ansible can do. We will set up a playbook to perform
    the following tasks:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Install Apache
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the `apache2` service
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy an HTML file for the new site
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, let’s set up the playbook to simply install Apache. I called mine `apache.yml`,
    but the name is arbitrary:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'No surprises here; we’ve already installed a package at this point. Let’s add
    an additional instruction to start the `apache2` service:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So far, the syntax should be self-explanatory. Ansible has a `service` module,
    which can be used to start a service on a host. In this case, we start the `apache2`
    service (the service would’ve already been started when `apache2` was installed,
    but at least this way we can make sure it’s started). You do have to know the
    service name ahead of time, but you don’t have to pay attention to what utility
    needs to be used in the background to start the service. Ansible already knows
    how to start services on all the popular distributions and takes care of the specifics
    for you in the background.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a play that starts `apache2` may seem a bit redundant since most packages
    you install on an Ubuntu server will automatically start the associated service
    as soon as it’s installed (and `apache2` is no exception). But when we write automation
    code, it’s important to be clear and explicit about what the desired end result
    is supposed to be. Even though `apache2` will automatically start once Ansible
    installs the package, we’re adding a `service` play to clarify the fact that it
    needs to be running, so anyone looking at it will know what’s expected. Also,
    we can make sure `apache2` is `enabled` by adding one more line to that section
    of the code (note the bold line):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I’ll leave it up to you whether or not to include that extra line, but the takeaway
    is to be as clear and direct as you can when writing automation, so there’s no
    confusion about what the end result is supposed to be.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, that was easy. Let’s create a simple web page for Apache to serve for
    us. It doesn’t need to be fancy, we just want to see that it works. Create the
    following content inside a file named `index.xhtml` in the same working directory
    as the other Ansible files:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, that HTML file is fairly lame, but it will work just fine for
    what we need. Next, let’s add another instruction to our Apache playbook:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With the `copy` module, we can copy a file from our local Ansible directory
    to the server. All we need to do is provide it with a source (`src`) and destination
    (`dest`).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and run the new playbook:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will produce an output like the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_15_04.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: Installing Apache and copying a default site file with Ansible'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a few minutes, you should have at least one web server configured by
    Ansible. In a real production environment, you would’ve only run this on servers
    within a specific role, but roles are beyond the scope of this chapter. But from
    the simple playbook we created, you should be able to see the power of this amazing
    piece of software:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_15_05.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: An example of a web page provisioned by Ansible'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: At this point in our exploration into configuration management with Ansible,
    we’ve installed packages, started services, and copied files. Admittedly, this
    isn’t much, but it’s really all you need in order to practice the basics. The
    documentation for Ansible includes guides on how to do all sorts of things, and
    you’ll be able to utilize the various modules it provides to perform many different
    tasks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: To explore Ansible further, I recommend that you think about things you do on
    a regular basis that you would benefit from automating. Things like installing
    security updates, creating user accounts, setting passwords, and enabling services
    to automatically start at boot time are tasks that are easy to get started with.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you may want to consider adding a simple **cron job** to run under
    your `ansible` user, to run the playbook every hour or so. We covered cron jobs
    in *Chapter 7*, *Controlling and Managing Processes*. Adding a cron job shouldn’t
    add any overhead from a resource perspective, since Ansible won’t actually be
    doing much unless you add a new command. In more advanced usage, you’ll want to
    have Ansible check out code from a repository and then apply the configuration
    if it has changed. This way, all you have to do is commit to a Git repository
    and all of your servers will download the configuration and run it at the next
    scheduled time. One of the things I love most about Ansible is that it’s easy
    to get started, but you’ll continue to find new ways to use it and benefit from
    it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible’s pull method
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way we set up our Ansible configuration in the previous section works very
    well if we have a list of specific servers that we want it to manage. To add a
    new server, we create the user account and set up the SSH configuration on the
    new host, and then add it to the inventory file. If we decommission that server,
    we simply remove it from the inventory file. This works well in a static environment,
    where servers you deploy typically stay around for a while. In a dynamic environment,
    though, this may not work as well.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic environments are very typical in the cloud. With cloud computing, you
    typically have one or more virtual servers that provide a service to your company
    or users. These servers may come and go at any time. With dynamic environments,
    servers will come online as needed to handle load and will also get decommissioned
    automatically as load decreases. Therefore, you never really know when a server
    is going to come online, and having to manually provision a server in such an
    environment is inefficient.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, Ansible’s inventory file may not be a good fit for dynamic
    infrastructure. There certainly are ways to make Ansible’s inventory work in such
    an environment, as you can actually replace the inventory file with an executable
    script that can make API calls and customize itself for your infrastructure if
    you so desire. However, that’s out of the scope of this book, and there’s an easier
    method anyway.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve seen, Ansible uses an inventory file and connects to every server listed
    in that file. However, Ansible also features a **pull mode**, where instead of
    having a central server that connects to other machines, each server in pull mode
    will actually run Ansible against itself. In my opinion, this is a great way to
    use Ansible and it doesn’t seem to get the attention it deserves. First, I’ll
    explain the theory of how it works, and then we can work through an actual example.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: With pull mode, you’ll want to have your Ansible playbooks inside a Git repository.
    This repository must be accessible from the servers you will manage. For example,
    if you store the Git repository on GitHub, you’ll want to make sure the servers
    can access GitHub externally. If you host your own Git server internally, you’ll
    want to make sure your servers are able to access it through your firewall or
    any security rules you may have in place.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Pull mode is used with the `ansible-pull` command, which comes bundled with
    Ansible. The syntax looks like the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Of course, you’d replace the URL with the actual HTTP or HTTPS URL to your Git
    repository. However, that’s basically it. The `ansible-pull` command simply expects
    the `-U` option (short for URL) along with the URL to a Git repository.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for this to work, you’ll need a playbook inside the repository with
    a special name, `local.yml`. If you don’t declare a specific playbook with Ansible,
    it will expect to find a playbook with that name inside the root of the repository.
    If you choose to use a name for the main playbook that’s something other than
    `local.yml`, you’ll need to specify it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, the `ansible-pull` command will cache the Git repository located
    at the specified URL locally, and run the playbook `myplaybook.yml` that you would
    have inside the repository. One thing you may find is that Ansible might complain
    about not finding an inventory file, even though that’s the entire point of the
    `ansible-pull` command. You can ignore this error. This will likely be fixed in
    Ansible at some point in the future, but as of the time of this writing, it will
    print a warning if it doesn’t detect an inventory file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'With the theory out of the way, let’s work through an actual example. If you’ve
    been following along so far, we created a playbook in the previous section that
    automates the deployment of a hypothetical web server. We can reuse that code.
    However, it’s best practice to have a file with the name `local.yml`, so you can
    simply rename the `apache.yml` playbook we created earlier to `local.yml`. There’s
    one small change we need to make to the file, which I’ve highlighted here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Since we’re executing the playbook locally (without SSH) we changed the `hosts`:
    line to point to `localhost`, to instruct Ansible that we want to execute the
    commands locally rather than remotely. Now, we can push this playbook to our Git
    repository and execute it directly from the repository URL.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay careful attention to the `hosts:` line of any playbook you intend to run.
    If you are using the pull method, this line will need to be changed from `hosts:
    all` to `hosts: localhost`, the reason being, we are executing the playbooks directly
    on localhost, rather than from a remote SSH connection. If you don’t make this
    change, you’ll see an error similar to the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Before you run the playbook, you’ll want to first switch to your Ansible user,
    since the playbook will need to be run as a user with `sudo` privileges since
    it will execute system-level commands:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, execute the playbook:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we kept the name as `apache.yml`, we would just specify that:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Keep in mind that since `ansible-pull` executes playbooks directly on localhost,
    the playbook must be executed by a user that has access to `sudo`. If `sudo` is
    not configured to run as that user without a password, the playbook will fail
    as it’s not interactive (it won’t ask for the password). You can also use `sudo`
    in front of the `ansible-pull` command and provide the password before it runs,
    but that won’t work if you set it up to run automatically via cron.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: If all goes according to plan, the playbook repository should be cached to the
    server, and the instructions carried out. If there is an error, Ansible is fairly
    good about presenting logical error messages. As long as the user has permission
    to execute privileged commands on the server, the required files are present in
    the repository, and the server has access to download the repository (a firewall
    isn’t blocking it), then the playbook will run properly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to implementing the pull method in production across various server
    types, there are several ways we can go about this. One way is to have a separate
    playbook per server type. For example, perhaps you’d have an Apache playbook,
    as well as playbooks specific to database servers, file servers, user workstations,
    and so on. Then, depending on the type of server you’re deploying, you’d specify
    the appropriate playbook when you called the `ansible-pull` command. If you’re
    using a service such as cloud computing, you can actually provide a script for
    each server to execute upon creation. You can then instruct the service to automatically
    run the `ansible-pull` command any time a new server is created. In AWS, for example,
    you can use a feature known as user data to place a script for a server to execute
    when it’s launched for the first time. This saves you from having to provision
    anything manually. For this to work, you would first include a command for the
    server to install Ansible itself, and then the next command would be the `ansible-pull`
    command along with the URL to the repository. Just those two lines would completely
    automate the installation of Ansible and the application of your playbook. Try
    to think of the possibilities ahead of time so you can understand the many ways
    that automation can benefit you.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: While provisioning new servers properly and efficiently is very important, so
    too is maintaining your existing servers. When you need to install a new package
    or apply a security update, the last thing you want to do is connect to all of
    your servers manually and update them one by one. The `ansible-pull` command allows
    simple management as well; you just simply run the command again. Every time you
    run `ansible-pull`, it will download the latest version of the code within your
    repository and run it. If there are any changes, they will be applied, while things
    that have already been applied will be skipped. For example, if you include a
    play to install the `apache2` package, Ansible won’t reinstall the package if
    you run the playbook a second time; it will skip that play since that requirement
    has already been met.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: One trick worth knowing with `ansible-pull` is the `-o` option. This option
    will ensure that the playbook inside the repository is only run if there have
    been any actual changes to the repository. If you haven’t committed any changes
    to the repository, it will skip the entire thing. This is very useful if you set
    up the `ansible-pull` command syntax to be run periodically via cron, for example,
    every hour.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t include the `-o` option, Ansible will run the entire playbook every
    hour. This will consume valuable CPU resources for no good reason at all. With
    the `-o` option, Ansible will only use as much CPU as required for simply checking
    the repository for changes. The playbook will only be run if you actually commit
    changes to the repository.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The introduction to Ansible within this chapter has been very basic, as we’ve
    only used the very core of the required components. By looking deeper into Ansible,
    you’ll find more advanced techniques, and some more clever ways to implement it.
    Examples include automating firewall rules, security patches, and user passwords,
    as well as having Ansible send you an email any time a server is successfully
    provisioned (or even when that fails). Basically, just about anything you can
    do manually, you can automate with Ansible. In the future, I recommend looking
    at server administration with an automation mindset. As I’ve mentioned several
    times before, if you will need to perform a task more than once, automate it.
    Ansible is one of the best ways of automating server administration.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at configuration management using Ansible. Ansible
    is an exciting technology that is exploding in popularity. It gives you the full
    power of configuration management utilities such as Chef or Puppet, without all
    the resource overhead. It allows you to automate just about everything. During
    our exploration, we walked through installing packages, copying files, and starting
    services. Near the end of the chapter, we worked through an example of using Ansible
    to provision a simple web server, and we even explored the pull method, which
    is very useful in dynamic environments. These concepts form the basis of knowledge
    that can be expanded to automate more complex rollouts.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter will be fun: we’ll set up our very own virtualization server
    with KVM. This is one of my favorite topics, and I’m sure you’ll enjoy it too.
    See you there!'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Relevant videos
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Git Essentials (LearnLinuxTV): [https://linux.video/git-essentials](https://linux.video/git-essentials)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting Started with Ansible (LearnLinuxTV): [https://linux.video/learn-ansible](https://linux.video/learn-ansible)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible workstation/laptop configuration (LearnLinuxTV): [https://linux.video/ansible-workstation](https://linux.video/ansible-workstation)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible Vault (LearnLinuxTV): [https://linux.video/ansible-vault](https://linux.video/ansible-vault)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible Pull (LearnLinuxTV): [https://linux.video/ansible-pull](https://linux.video/ansible-pull)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible documentation: [https://learnlinux.link/ansible-docs](https://learnlinux.link/ansible-docs)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible Roles documentation: [https://learnlinux.link/reuse-roles](https://learnlinux.link/reuse-roles)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible config file documentation article: [https://learnlinux.link/a-config](https://learnlinux.link/a-config)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible-pull` documentation: [https://learnlinux.link/a-pull](https://learnlinux.link/a-pull)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to manage your workstation configuration with Ansible: [https://learnlinux.link/a-ws](https://learnlinux.link/a-ws)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Git basics: [https://learnlinux.link/git-book](https://learnlinux.link/git-book)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting up Git (GitHub): [https://learnlinux.link/setup-git](https://learnlinux.link/setup-git)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
