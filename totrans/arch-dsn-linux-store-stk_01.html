<html><head></head><body>
<div id="_idContainer013">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.2.1">Where It All Starts From – The Virtual Filesystem</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Even with astronomical advances in software development, the Linux kernel remains one of the most complex pieces of code. </span><span class="koboSpan" id="kobo.3.2">Developers, programmers, and would-be kernel hackers constantly look to dive into kernel code and push for new features, whereas hobbyists and enthusiasts try to understand and unravel </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">those mysteries.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Naturally, a lot has been written on Linux and its internal workings, from general administration to kernel programming. </span><span class="koboSpan" id="kobo.5.2">Over the decades, hundreds of books have been published, which cover a diverse range of important operating system topics, such as process creation, threading, memory management, virtualization, filesystem implementations, and CPU scheduling. </span><span class="koboSpan" id="kobo.5.3">This book that you’ve picked up (thank you!) will focus on the storage stack in Linux and its </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">multilayered organization.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We’ll start by introducing the Virtual Filesystem in the Linux kernel and its pivotal role in allowing end user programs to access data on filesystems. </span><span class="koboSpan" id="kobo.7.2">Since we intend to cover the entire storage stack in this book, from top to bottom, getting a deeper understanding of the Virtual Filesystem is extremely important, as it is the starting point of an I/O request in the kernel. </span><span class="koboSpan" id="kobo.7.3">We’ll introduce the concept of user space and kernel space, understand system calls, and see how the </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Everything is a file</span></em><span class="koboSpan" id="kobo.9.1"> philosophy in Linux is tied to the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Virtual Filesystem.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Understanding storage in a modern-day </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">data center</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Defining </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">system calls</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Explaining the need for a </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Virtual Filesystem</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Describing the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Virtual Filesystem</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Explaining the </span><em class="italic"><span class="koboSpan" id="kobo.22.1">Everything is a </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.23.1">file</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.24.1"> philosophy</span></span></li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.26.1">Before going any further, I think is important to acknowledge here that certain technical topics may be more challenging for beginners to comprehend than others. </span><span class="koboSpan" id="kobo.26.2">Since the goal here is to comprehend the inner workings of the Linux kernel and its major subsystems, it will be helpful to have a decent foundational understanding of operating system concepts in general and Linux in particular. </span><span class="koboSpan" id="kobo.26.3">Above all, it is important to approach these topics with patience, curiosity, and a willingness </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">to learn.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">The commands and examples presented in this chapter are distribution-agnostic and can be run on any Linux operating system, such as Debian, Ubuntu, Red Hat, and Fedora. </span><span class="koboSpan" id="kobo.28.2">There are a few references to the kernel source code. </span><span class="koboSpan" id="kobo.28.3">If you want to download the kernel source, you can download it from </span><a href="https://www.kernel.org"><span class="koboSpan" id="kobo.29.1">https://www.kernel.org</span></a><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">The operating system packages relevant to this chapter can be installed </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.32.1">For Ubuntu/Debian:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">sudo apt </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">install strace</span></strong></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">sudo apt </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">install bcc</span></strong></span></li></ul></li>
<li><span class="koboSpan" id="kobo.37.1">For Fedora/CentOS/Red </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">Hat-based systems:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">sudo yum </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">install strace</span></strong></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">sudo yum </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">install bcc-tools</span></strong></span></li></ul></li>
</ul>
<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.43.1">Understanding storage in a modern-day data center</span></h1>
<p class="author-quote"><span class="koboSpan" id="kobo.44.1">It is a capital mistake to theorize before one has data. </span><span class="koboSpan" id="kobo.44.2">Insensibly one begins to twist facts to suit theories, instead of theories to suit facts. </span><span class="koboSpan" id="kobo.44.3">– Sir Arthur Conan Doyle</span></p>
<p><span class="koboSpan" id="kobo.45.1">Compute, storage, and networking </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.46.1">are the basic building blocks of any infrastructure. </span><span class="koboSpan" id="kobo.46.2">How well your applications do is often dependent on the combined performance of these three layers. </span><span class="koboSpan" id="kobo.46.3">The workloads running in a modern data center vary from streaming services to machine learning applications. </span><span class="koboSpan" id="kobo.46.4">With the meteoric rise and adoption of cloud computing platforms, all the basic building blocks are now abstracted from the end user. </span><span class="koboSpan" id="kobo.46.5">Adding more hardware resources to your application, as it becomes resource-hungry, is the new normal. </span><span class="koboSpan" id="kobo.46.6">Troubleshooting performance issues is often skipped in favor of migrating applications to better </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">hardware platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">Of the three building blocks, compute, storage, and networking, storage is often considered the bottleneck in most scenarios. </span><span class="koboSpan" id="kobo.48.2">For applications</span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.49.1"> such as databases, the performance of the underlying storage is of prime importance. </span><span class="koboSpan" id="kobo.49.2">In cases where infrastructure hosts mission-critical and time-sensitive applications such as </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">Online Transaction Processing</span></strong><span class="koboSpan" id="kobo.51.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.52.1">OLTP</span></strong><span class="koboSpan" id="kobo.53.1">), the performance of storage frequently comes under the radar. </span><span class="koboSpan" id="kobo.53.2">The smallest of delays in servicing I/O requests can impact the overall response of </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">The most common metric used to measure storage performance is latency. </span><span class="koboSpan" id="kobo.55.2">The response times of storage devices are usually measured in milliseconds. </span><span class="koboSpan" id="kobo.55.3">Compare that with your average processor or memory, where such measurements are measured in nanoseconds, and you’ll see how the performance of the storage layer can impact the overall working of your system. </span><span class="koboSpan" id="kobo.55.4">This results in a state of incongruity </span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.56.1">between the application requirements and what the underlying storage can actually deliver. </span><span class="koboSpan" id="kobo.56.2">For the last few years, most of the advancements in modern-day storage drives have been geared toward sizing – the </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">capacity arena</span></strong><span class="koboSpan" id="kobo.58.1">. </span><span class="koboSpan" id="kobo.58.2">However, performance</span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.59.1"> improvement of the storage hardware has not progressed at the same rate. </span><span class="koboSpan" id="kobo.59.2">Compared to the compute functions, the performance of storage pales in comparison. </span><span class="koboSpan" id="kobo.59.3">For these reasons, it is often termed the </span><em class="italic"><span class="koboSpan" id="kobo.60.1">three-legged dog of the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.61.1">data center</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">Having made a point about the choice of a storage medium, it’s pertinent to note that no matter how powerful it is, the hardware will always have limitations in its functionality. </span><span class="koboSpan" id="kobo.63.2">It’s equally important for the application and operating system to tune themselves according to the hardware. </span><span class="koboSpan" id="kobo.63.3">Fine-tuning your application, operating system, and filesystem parameters can give a major boost to the overall performance. </span><span class="koboSpan" id="kobo.63.4">To utilize the underlying hardware to its full potential, all layers of the I/O hierarchy need to </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">function efficiently.</span></span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.65.1">Interacting with storage in Linux</span></h2>
<p><span class="koboSpan" id="kobo.66.1">The Linux kernel </span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.67.1">makes a clear distinction between the user</span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.68.1"> space and kernel space processes. </span><span class="koboSpan" id="kobo.68.2">All the hardware resources, such as CPU, memory, and storage, lie in the kernel space. </span><span class="koboSpan" id="kobo.68.3">For any user space application wanting to </span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.69.1">access the resources in kernel space, it has to generate a </span><strong class="bold"><span class="koboSpan" id="kobo.70.1">system call</span></strong><span class="koboSpan" id="kobo.71.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.72.1">Figure 1</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.73.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.75.1"><img alt="Figure 1.1 – The interaction between user space and kernel space" src="image/B19430_01_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.76.1">Figure 1.1 – The interaction between user space and kernel space</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.77.1">User space</span></strong><span class="koboSpan" id="kobo.78.1"> refers to all the applications and processes that live outside of the kernel. </span><span class="koboSpan" id="kobo.78.2">The kernel space includes programs </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.79.1">such as device drivers, which have unrestricted access to the underlying hardware. </span><span class="koboSpan" id="kobo.79.2">The user space can be considered a form of sandboxing to restrict the end user programs from modifying critical </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">kernel functions.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">This concept of user and kernel space is deeply rooted in the design of modern processors. </span><span class="koboSpan" id="kobo.81.2">A traditional x86 CPU uses the concept of </span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.82.1">protection domains, called </span><strong class="bold"><span class="koboSpan" id="kobo.83.1">rings</span></strong><span class="koboSpan" id="kobo.84.1">, to share and limit access to hardware resources. </span><span class="koboSpan" id="kobo.84.2">Processors offer four rings or modes, which are numbered from 0 to 3. </span><span class="koboSpan" id="kobo.84.3">Modern-day processors </span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.85.1">are designed to operate in two of these modes, ring 0 and ring 3. </span><span class="koboSpan" id="kobo.85.2">The user space applications are handled in ring 3, which has limited access to kernel resources. </span><span class="koboSpan" id="kobo.85.3">The kernel occupies ring 0. </span><span class="koboSpan" id="kobo.85.4">This is where the kernel code executes and interacts with the underlying </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">hardware resources.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">When processes need to read from or write to a file, they need to interact with the filesystem structures on top of the physical disk. </span><span class="koboSpan" id="kobo.87.2">Every filesystem uses different methods to organize data on the physical disk. </span><span class="koboSpan" id="kobo.87.3">The request from the process doesn’t directly reach the filesystem or physical disk. </span><span class="koboSpan" id="kobo.87.4">In order for the I/O request of the process to be served by the physical disk, it has to traverse through the entire storage hierarchy in the kernel. </span><span class="koboSpan" id="kobo.87.5">The first layer in that hierarchy is known as the </span><strong class="bold"><span class="koboSpan" id="kobo.88.1">Virtual Filesystem</span></strong><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">The following figure, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.90.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.91.1">.2</span></em><span class="koboSpan" id="kobo.92.1">, highlights the major components of the </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">Virtual Filesystem:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.94.1"><img alt="Figure 1.2 – The Virtual Filesystem (VFS) layer in the kernel" src="image/B19430_01_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.95.1">Figure 1.2 – The Virtual Filesystem (VFS) layer in the kernel</span></p>
<p><span class="koboSpan" id="kobo.96.1">The storage stack in Linux </span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.97.1">consists of a multitude of cohesive layers, all of which ensure that the access to physical storage media is abstracted through a unified interface. </span><span class="koboSpan" id="kobo.97.2">As we move forward, we’re going to build upon this structure and add more layers. </span><span class="koboSpan" id="kobo.97.3">We’ll try to dig deep into each of them and see how they all work </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">in harmony.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">This chapter will focus solely on the Virtual Filesystem and its various features. </span><span class="koboSpan" id="kobo.99.2">In the coming chapters, we’re going to explain and uncover some under-the-hood workings of the more frequently used filesystems in Linux. </span><span class="koboSpan" id="kobo.99.3">However, bearing in mind the number of times the word </span><em class="italic"><span class="koboSpan" id="kobo.100.1">filesystem</span></em><span class="koboSpan" id="kobo.101.1"> is going to be used here, I think it’s prudent to briefly categorize the different filesystem types, just to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">any confusion:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.103.1">Block filesystems</span></strong><span class="koboSpan" id="kobo.104.1">: Block- or disk-based filesystems are the most common way to store user data. </span><span class="koboSpan" id="kobo.104.2">As a regular operating system user, these are the filesystems that users mostly interact with. </span><span class="koboSpan" id="kobo.104.3">Filesystems such as </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">Extended filesystem version 2/3/4</span></strong><span class="koboSpan" id="kobo.106.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.107.1">Ext 2/3/4</span></strong><span class="koboSpan" id="kobo.108.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">Extent filesystem</span></strong><span class="koboSpan" id="kobo.110.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.111.1">XFS</span></strong><span class="koboSpan" id="kobo.112.1">), Btrfs, FAT, and NTFS are all categorized as disk-based or block filesystems. </span><span class="koboSpan" id="kobo.112.2">These filesystems speak in terms of </span><strong class="bold"><span class="koboSpan" id="kobo.113.1">blocks</span></strong><span class="koboSpan" id="kobo.114.1">. </span><span class="koboSpan" id="kobo.114.2">The block size is</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.115.1"> a property of the</span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.116.1"> filesystem, and it can only be set when creating a filesystem on a device. </span><span class="koboSpan" id="kobo.116.2">The block size indicates what size the filesystem will use when reading or writing data. </span><span class="koboSpan" id="kobo.116.3">We can refer to it as the logical unit of storage allocation and retrieval for a filesystem. </span><span class="koboSpan" id="kobo.116.4">A device that can be accessed in terms of blocks is, therefore, called a </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">block device</span></strong><span class="koboSpan" id="kobo.118.1">. </span><span class="koboSpan" id="kobo.118.2">Any storage</span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.119.1"> device attached to a computer, whether it is a hard drive or an external USB, can be classified as a block device. </span><span class="koboSpan" id="kobo.119.2">Traditionally, block filesystems are mounted on a single host and do not allow sharing between </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">multiple hosts.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.121.1">Clustered filesystems</span></strong><span class="koboSpan" id="kobo.122.1">: Clustered filesystems are also block filesystems and use block-based access methods to read and write data. </span><span class="koboSpan" id="kobo.122.2">The difference is that they allow a single filesystem to be mounted and used simultaneously by multiple hosts. </span><span class="koboSpan" id="kobo.122.3">Clustered filesystems are based on the concept of </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">shared storage</span></strong><span class="koboSpan" id="kobo.124.1">, meaning that multiple hosts can </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.125.1">concurrently access the same block device. </span><span class="koboSpan" id="kobo.125.2">Common clustered filesystems used in Linux are Red Hat’s </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">Global File System 2</span></strong><span class="koboSpan" id="kobo.127.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.128.1">GFS2</span></strong><span class="koboSpan" id="kobo.129.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.130.1">Oracle Clustered File </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.131.1">System</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.132.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.133.1">OCFS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.135.1">Network filesystems (NFS)</span></strong><span class="koboSpan" id="kobo.136.1">: NFS is a protocol that allows for remote file sharing. </span><span class="koboSpan" id="kobo.136.2">Unlike regular block filesystems, NFS is</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.137.1"> based on the concept of sharing data between multiple hosts. </span><span class="koboSpan" id="kobo.137.2">NFS works with the concept of a client and a server. </span><span class="koboSpan" id="kobo.137.3">The backend storage is provided by an NFS server. </span><span class="koboSpan" id="kobo.137.4">The host systems on which the NFS filesystem is mounted are called </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">clients</span></strong><span class="koboSpan" id="kobo.139.1">. </span><span class="koboSpan" id="kobo.139.2">The connectivity between the client and server is achieved using conventional Ethernet. </span><span class="koboSpan" id="kobo.139.3">All NFS clients share a single copy of the file on the NFS server. </span><span class="koboSpan" id="kobo.139.4">NFS doesn’t offer the same performance as block filesystems, but it is still used in enterprise environments, mostly to store long-term backups and share </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">common data.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.141.1">Pseudo filesystems</span></strong><span class="koboSpan" id="kobo.142.1">: Pseudo filesystems exist in the kernel and generate their content dynamically. </span><span class="koboSpan" id="kobo.142.2">They are not used to store data persistently. </span><span class="koboSpan" id="kobo.142.3">They do not behave like regular disk-based filesystems such </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.143.1">as Ext4 or XFS. </span><span class="koboSpan" id="kobo.143.2">The main purpose of a pseudo filesystem is to allow the user space programs to interact with the kernel. </span><span class="koboSpan" id="kobo.143.3">Directories such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">/proc (procfs)</span></strong><span class="koboSpan" id="kobo.145.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">/sys (sysfs)</span></strong><span class="koboSpan" id="kobo.147.1"> fall under this category. </span><span class="koboSpan" id="kobo.147.2">These directories contain virtual or temporary files, which include information about the different kernel subsystems. </span><span class="koboSpan" id="kobo.147.3">These pseudo filesystems are also a part of the Virtual Filesystem landscape, as</span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.148.1"> we’ll see in the </span><em class="italic"><span class="koboSpan" id="kobo.149.1">Everything is a </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.150.1">file</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.151.1"> section.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.152.1">Now that we have a basic idea about user space, kernel space, and the different types of filesystems, let’s explain how an application can request resources in kernel space through </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">system calls.</span></span></p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.154.1">Understanding system calls</span></h1>
<p><span class="koboSpan" id="kobo.155.1">While looking at</span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.156.1"> the figure explaining the interaction between applications and the Virtual Filesystem, you may have noticed the intermediary layer between user space programs and the Virtual Filesystem; that layer is known as the </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">system call interface</span></strong><span class="koboSpan" id="kobo.158.1">. </span><span class="koboSpan" id="kobo.158.2">To request some service from the</span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.159.1"> kernel, user space programs invoke the system call interface. </span><span class="koboSpan" id="kobo.159.2">These system calls provide the means for end user applications to access the resources in the kernel space, such as the processor, memory, and storage. </span><span class="koboSpan" id="kobo.159.3">The system call interface serves three </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">main purposes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.161.1">Ensuring security</span></strong><span class="koboSpan" id="kobo.162.1">: System calls prevent user space applications from directly modifying resources in the </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">kernel space</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.164.1">Abstraction</span></strong><span class="koboSpan" id="kobo.165.1">: Applications do not need to concern themselves with the underlying </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">hardware specifications</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.167.1">Portability</span></strong><span class="koboSpan" id="kobo.168.1">: User programs can be run correctly on all kernels that implement the same set </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">of interfaces</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.170.1">There’s often some confusion about the </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.171.1">differences between system calls and an </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">application programming interface</span></strong><span class="koboSpan" id="kobo.173.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.174.1">API</span></strong><span class="koboSpan" id="kobo.175.1">). </span><span class="koboSpan" id="kobo.175.2">An API is a set of programming interfaces used by a program. </span><span class="koboSpan" id="kobo.175.3">These interfaces define a method of communication between two components. </span><span class="koboSpan" id="kobo.175.4">An API is implemented in user space and outlines how to acquire a particular service. </span><span class="koboSpan" id="kobo.175.5">A system call is a much lower-level mechanism that uses interrupts to make an explicit request to the kernel. </span><span class="koboSpan" id="kobo.175.6">The system call interface is provided by the standard C library </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">in Linux.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">If the system call generated by the calling process succeeds, a file descriptor is returned. </span><span class="koboSpan" id="kobo.177.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">file descriptor</span></strong><span class="koboSpan" id="kobo.179.1"> is an integer number that is</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.180.1"> used to access files. </span><span class="koboSpan" id="kobo.180.2">For example, when a file is opened using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">open ()</span></strong><span class="koboSpan" id="kobo.182.1"> system call, a file descriptor is returned to the calling process. </span><span class="koboSpan" id="kobo.182.2">Once a file has been opened, programs use the file descriptor to perform operations on the file. </span><span class="koboSpan" id="kobo.182.3">All read, write, and other operations are performed using the </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">file descriptor.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">Every process always has a minimum of three files opened – standard input, standard output, and standard error – represented by the 0, 1, and 2 file descriptors, respectively. </span><span class="koboSpan" id="kobo.184.2">The next file opened will be assigned the file descriptor value of 3. </span><span class="koboSpan" id="kobo.184.3">If we do some file listing through </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">ls</span></strong><span class="koboSpan" id="kobo.186.1"> and run a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">strace</span></strong><span class="koboSpan" id="kobo.188.1">, the open system </span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.189.1">call will return a value of 3, which is the file descriptor representing the file – </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">/etc/hosts</span></strong><span class="koboSpan" id="kobo.191.1">, in this case. </span><span class="koboSpan" id="kobo.191.2">After that, this file descriptor value of 3 is used by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">fstat</span></strong><span class="koboSpan" id="kobo.193.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">close</span></strong><span class="koboSpan" id="kobo.195.1"> calls to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">further operations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.197.1">
strace ls /etc/hosts
root@linuxbox:~# strace ls /etc/hosts
execve("/bin/ls", ["ls", "/etc/hosts"], 0x7ffdee289b48 /* 22 vars */) = 0
brk(NULL)                               = 0x562b97fc6000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=140454, ...}) = 0
mmap(NULL, 140454, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fbaa2519000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libselinux.so.1", O_RDONLY|O_CLOEXEC) = 3</span></pre>
<p><span class="koboSpan" id="kobo.198.1">[The rest of the code is skipped </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">for brevity.]</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">On x86 systems, there are around 330 system calls. </span><span class="koboSpan" id="kobo.200.2">This number could be different for other architectures. </span><span class="koboSpan" id="kobo.200.3">Each system call is represented by a unique integer number. </span><span class="koboSpan" id="kobo.200.4">You can list the available system calls on your system</span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.201.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">ausyscall</span></strong><span class="koboSpan" id="kobo.203.1"> command. </span><span class="koboSpan" id="kobo.203.2">This will list the system calls and their corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">integer values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.205.1">
ausyscall –dump
root@linuxbox:~# ausyscall --dump
Using x86_64 syscall table:
0       read
1       write
2       open
3       close
4       stat
5       fstat
6       lstat
7       poll
8       lseek
9       mmap
10      mprotect</span></pre>
<p><span class="koboSpan" id="kobo.206.1">[The rest of the code is </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.207.1">skipped </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">for brevity.]</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.209.1">
root@linuxbox:~# ausyscall --dump|wc -l
334
root@linuxbox:~#</span></pre>
<p><span class="koboSpan" id="kobo.210.1">The following table lists some common </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">system calls:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.212.1">System call</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.213.1">Description</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">open ()</span></strong><span class="koboSpan" id="kobo.215.1">, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">close ()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.217.1">Open and </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">close files</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">create ()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.220.1">Create </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">a file</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">chroot ()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.223.1">Change the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">root</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.225.1"> directory</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">mount ()</span></strong><span class="koboSpan" id="kobo.227.1">, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">umount ()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.229.1">Mount and </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">unmount filesystems</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">lseek ()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.232.1">Change the pointer position in </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">a file</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">read ()</span></strong><span class="koboSpan" id="kobo.235.1">, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">write ()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.237.1">Read and write in </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">a file</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">stat ()</span></strong><span class="koboSpan" id="kobo.240.1">, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">fstat ()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.242.1">Get a </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">file status</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">statfs ()</span></strong><span class="koboSpan" id="kobo.245.1">, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">fstatfs ()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.247.1">Get </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">filesystem statistics</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">execve ()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.250.1">Execute the program referred to </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">by pathname</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">access ()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.253.1">Checks whether the calling process can access the </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">file pathname</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">mmap ()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.256.1">Creates a new mapping in the virtual address space of the </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">calling process</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.258.1">Table 1.1 – Some common system calls</span></p>
<p><span class="koboSpan" id="kobo.259.1">So, what role do the system calls play in interacting with filesystems? </span><span class="koboSpan" id="kobo.259.2">As we’ll see in the succeeding section, when a user space process generates a system call to access resources in the kernel space, the first component it interacts with is the Virtual Filesystem. </span><span class="koboSpan" id="kobo.259.3">This system call is first handled by the</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.260.1"> corresponding system call handler in the kernel, and after validating the operation requested, the handler makes a call to the appropriate function in the VFS layer. </span><span class="koboSpan" id="kobo.260.2">The VFS layer passes the request on to the appropriate filesystem driver module, which performs the actual operations on </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">the file.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">We need to understand the </span><em class="italic"><span class="koboSpan" id="kobo.263.1">why</span></em><span class="koboSpan" id="kobo.264.1"> here – why would the process interact with the Virtual Filesystem and not the actual filesystem on the disk? </span><span class="koboSpan" id="kobo.264.2">In the upcoming section, we’ll try to figure </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">this out.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">To summarize, the system calls interface in Linux implements generic methods that can be used by the applications in user space to access resources in the </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">kernel space.</span></span></p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.268.1">Explaining the need for a Virtual Filesystem</span></h1>
<p><span class="koboSpan" id="kobo.269.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.270.1">standard filesystem</span></strong><span class="koboSpan" id="kobo.271.1"> is a set of data </span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.272.1">structures that determine how user data is organized on a disk. </span><span class="koboSpan" id="kobo.272.2">End users are able to interact with</span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.273.1"> this standard filesystem through regular file access methods and perform common tasks. </span><span class="koboSpan" id="kobo.273.2">Every operating system (Linux or non-Linux) provides at least one such filesystem, and naturally, each of them claims to be </span><em class="italic"><span class="koboSpan" id="kobo.274.1">better, faster, and more secure</span></em><span class="koboSpan" id="kobo.275.1"> than the other. </span><span class="koboSpan" id="kobo.275.2">A great majority of modern Linux </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.276.1">distributions use </span><strong class="bold"><span class="koboSpan" id="kobo.277.1">XFS or Ext4</span></strong><span class="koboSpan" id="kobo.278.1"> as the default filesystem. </span><span class="koboSpan" id="kobo.278.2">These filesystems have several</span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.279.1"> features and are considered stable and reliable for </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">daily usage.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">However, the support for filesystems in Linux is not limited to only these two. </span><span class="koboSpan" id="kobo.281.2">One of the great benefits of using Linux is that it offers support for multiple filesystems, all of which can be considered perfectly acceptable alternatives to Ext4 and XFS. </span><span class="koboSpan" id="kobo.281.3">Because of this, Linux can peacefully coexist with other operating systems. </span><span class="koboSpan" id="kobo.281.4">Some of the more commonly used filesystems include older versions of Ext4, such as Ext2 and Ext3, Btrfs, ReiserFS, OpenZFS, FAT, and NTFS. </span><span class="koboSpan" id="kobo.281.5">When using multiple partitions, users can choose from a long list of available filesystems and create a different one on every disk partition as per </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">their needs.</span></span></p>
<p><span class="koboSpan" id="kobo.283.1">The smallest addressable unit of a physical hard drive is a sector. </span><span class="koboSpan" id="kobo.283.2">For filesystems, the smallest writable unit is called a block. </span><span class="koboSpan" id="kobo.283.3">A </span><strong class="bold"><span class="koboSpan" id="kobo.284.1">block</span></strong><span class="koboSpan" id="kobo.285.1"> can be</span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.286.1"> considered a group of consecutive sectors. </span><span class="koboSpan" id="kobo.286.2">All operations by a filesystem are performed in terms of blocks. </span><span class="koboSpan" id="kobo.286.3">There is no singular way in which these blocks are addressed and organized by different filesystems. </span><span class="koboSpan" id="kobo.286.4">Each filesystem may use a different set of data structures to allocate and store data on these blocks. </span><span class="koboSpan" id="kobo.286.5">The presence of a different filesystem on each storage partition can be difficult to manage. </span><span class="koboSpan" id="kobo.286.6">Given the wide range of supported filesystems in Linux, imagine if applications needed to understand the distinct details of every filesystem. </span><span class="koboSpan" id="kobo.286.7">In order to be compatible with a filesystem, the application would need to implement a unique access method for each filesystem it uses. </span><span class="koboSpan" id="kobo.286.8">This would make the design of an application </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">almost impractical.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">Abstraction interfaces play a critical role in the Linux kernel. </span><span class="koboSpan" id="kobo.288.2">In Linux, regardless of the filesystem being used, the end users or applications can interact with the filesystem using uniform access methods. </span><span class="koboSpan" id="kobo.288.3">All this is achieved through the Virtual Filesystem layer, which hides the filesystem implementations under an </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">all-inclusive interface.</span></span></p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.290.1">Describing the VFS</span></h1>
<p><span class="koboSpan" id="kobo.291.1">To ensure that applications do not face any</span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.292.1"> such obstacles (as mentioned earlier) when working with different filesystems, the Linux kernel implements a layer between end user applications and the filesystem on which data is being stored. </span><span class="koboSpan" id="kobo.292.2">This layer is known as the </span><strong class="bold"><span class="koboSpan" id="kobo.293.1">Virtual Filesystem</span></strong><span class="koboSpan" id="kobo.294.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.295.1">VFS</span></strong><span class="koboSpan" id="kobo.296.1">). </span><span class="koboSpan" id="kobo.296.2">The VFS is not a standard filesystem, such as Ext4 or XFS. </span><span class="koboSpan" id="kobo.296.3">(There is no </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">mkfs.vfs</span></strong><span class="koboSpan" id="kobo.298.1"> command!) For this reason, some</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.299.1"> prefer the term </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">Virtual </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.301.1">Filesystem Switch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">Think of the </span><em class="italic"><span class="koboSpan" id="kobo.304.1">magic wardrobe</span></em><span class="koboSpan" id="kobo.305.1"> from </span><em class="italic"><span class="koboSpan" id="kobo.306.1">The Chronicles of Narnia</span></em><span class="koboSpan" id="kobo.307.1">. </span><span class="koboSpan" id="kobo.307.2">The wardrobe is actually a portal to the magical world of Narnia. </span><span class="koboSpan" id="kobo.307.3">Once you step through the wardrobe, you can explore the new world and interact with its inhabitants. </span><span class="koboSpan" id="kobo.307.4">The wardrobe facilitates accessing the magical world. </span><span class="koboSpan" id="kobo.307.5">In a similar way, the VFS provides a doorway to </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">different filesystems.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">The VFS defines a generic interface that allows multiple filesystems to coexist in Linux. </span><span class="koboSpan" id="kobo.309.2">It’s worth mentioning again that with the VFS, we’re not talking about a standard block-based filesystem. </span><span class="koboSpan" id="kobo.309.3">We’re talking about an abstraction layer that provides a link between the end user application and the actual block filesystems. </span><span class="koboSpan" id="kobo.309.4">Through the standardization implemented in the VFS, applications can perform read and write operations, without worrying about the </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">underlying filesystem.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.312.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.313.1">.3</span></em><span class="koboSpan" id="kobo.314.1">, the VFS is interposed between the user space programs and </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">actual filesystems:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.316.1"><img alt="Figure 1.3 – The VFS acts as a bridge between user space programs and filesystems" src="image/B19430_01_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.317.1">Figure 1.3 – The VFS acts as a bridge between user space programs and filesystems</span></p>
<p><span class="koboSpan" id="kobo.318.1">For the VFS to provide services to both parties, the following has </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">to apply:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.320.1">All end user applications need to define their filesystem operations in terms of the standard interface provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">the VFS</span></span></li>
<li><span class="koboSpan" id="kobo.322.1">Every filesystem needs to provide an implementation of the common interface provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">the VFS</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.324.1">We explained that applications in user space need to generate system calls when they want to access resources in the kernel space. </span><span class="koboSpan" id="kobo.324.2">Through the </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.325.1">abstraction provided by the VFS, system calls such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">read()</span></strong><span class="koboSpan" id="kobo.327.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">write()</span></strong><span class="koboSpan" id="kobo.329.1"> function properly, regardless of the filesystem in use. </span><span class="koboSpan" id="kobo.329.2">These system calls work across filesystem boundaries. </span><span class="koboSpan" id="kobo.329.3">We don’t need a special mechanism to move data to a different or non-native filesystem. </span><span class="koboSpan" id="kobo.329.4">For instance, we can easily move data from an Ext4 filesystem to XFS, and vice versa. </span><span class="koboSpan" id="kobo.329.5">At a very high level, when a process issues the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">read()</span></strong><span class="koboSpan" id="kobo.331.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">write()</span></strong><span class="koboSpan" id="kobo.333.1"> system call to read or write a file, the VFS will search for the filesystem driver to use and forward these system calls to </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">that driver.</span></span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.335.1">Implementing a common filesystem interface through the VFS</span></h2>
<p><span class="koboSpan" id="kobo.336.1">The primary goal of the VFS is to</span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.337.1"> represent a diverse set of filesystems in the kernel with minimum overhead. </span><span class="koboSpan" id="kobo.337.2">When a process requests a read or write operation on a file, the kernel substitutes this with the filesystem-specific function on which the file resides. </span><span class="koboSpan" id="kobo.337.3">In order to achieve this, every filesystem must adapt itself in terms of </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">the VFS.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">Let’s go through the following example for a </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">better understanding.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">Consider the example of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">cp</span></strong><span class="koboSpan" id="kobo.343.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">copy</span></strong><span class="koboSpan" id="kobo.345.1">) command in Linux. </span><span class="koboSpan" id="kobo.345.2">Let’s suppose we’re trying to copy a file from an Ext4 to an XFS filesystem. </span><span class="koboSpan" id="kobo.345.3">How does this copy operation complete? </span><span class="koboSpan" id="kobo.345.4">How does the </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">cp</span></strong><span class="koboSpan" id="kobo.347.1"> command interact with the two filesystems? </span><span class="koboSpan" id="kobo.347.2">Have a look at </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.348.1">Figure 1</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.349.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.351.1"><img alt="Figure 1.4 – The VFS ensures interoperability between different filesystems" src="image/B19430_01_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.352.1">Figure 1.4 – The VFS ensures interoperability between different filesystems</span></p>
<p><span class="koboSpan" id="kobo.353.1">First off, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">cp</span></strong><span class="koboSpan" id="kobo.355.1"> command doesn’t care about the filesystems being used. </span><span class="koboSpan" id="kobo.355.2">We’ve defined the VFS as the layer that implements abstraction. </span><span class="koboSpan" id="kobo.355.3">So, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">cp</span></strong><span class="koboSpan" id="kobo.357.1"> command doesn’t need to concern itself about the filesystem details. </span><span class="koboSpan" id="kobo.357.2">It will interact with the VFS layer through the standard system call interface. </span><span class="koboSpan" id="kobo.357.3">Specifically, it will issue the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">open ()</span></strong><span class="koboSpan" id="kobo.359.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">read ()</span></strong><span class="koboSpan" id="kobo.361.1"> system calls to open and read the file to be copied. </span><span class="koboSpan" id="kobo.361.2">An open file is represented by the file data structure in the kernel (as we’ll learn in the next chapter, </span><a href="B19430_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.362.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.363.1">, </span><em class="italic"><span class="koboSpan" id="kobo.364.1">Explaining the Data Structures in </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.365.1">a VFS</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">cp</span></strong><span class="koboSpan" id="kobo.369.1"> generates these generic system calls, the kernel will redirect these calls to the appropriate function of the </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.370.1">filesystem through a pointer, on which the file resides. </span><span class="koboSpan" id="kobo.370.2">To copy the file to the XFS filesystem, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">write()</span></strong><span class="koboSpan" id="kobo.372.1"> system call is passed to the VFS. </span><span class="koboSpan" id="kobo.372.2">This will again be redirected to the particular function of the XFS filesystem that implements this feature. </span><span class="koboSpan" id="kobo.372.3">Through system calls issued to the VFS, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">cp</span></strong><span class="koboSpan" id="kobo.374.1"> process can perform a copy operation using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">read ()</span></strong><span class="koboSpan" id="kobo.376.1"> method of Ext4 and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">write ()</span></strong><span class="koboSpan" id="kobo.378.1"> method of XFS. </span><span class="koboSpan" id="kobo.378.2">Just like a </span><em class="italic"><span class="koboSpan" id="kobo.379.1">switch</span></em><span class="koboSpan" id="kobo.380.1">, the VFS will switch the common file access methods between their designated </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">filesystem implementations.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">The read, write, or any other function for that matter does not have a default definition in the kernel – hence the name </span><strong class="bold"><span class="koboSpan" id="kobo.383.1">virtual</span></strong><span class="koboSpan" id="kobo.384.1">. </span><span class="koboSpan" id="kobo.384.2">The interpretation of these operations depends upon the underlying filesystem. </span><span class="koboSpan" id="kobo.384.3">Just like user programs that take advantage of this abstraction offered by the VFS, filesystems also reap the benefits of this approach. </span><span class="koboSpan" id="kobo.384.4">Common access methods for files do not need to be reimplemented </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">by filesystems.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">That was pretty neat, right? </span><span class="koboSpan" id="kobo.386.2">But what if we want to copy something from Ext4 to a non-native filesystem? </span><span class="koboSpan" id="kobo.386.3">Filesystems such as Ext4, XFS, and Btrfs were specifically designed for Linux. </span><span class="koboSpan" id="kobo.386.4">What if one of the filesystems involved in this operation is FAT </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">or NTFS?</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">Admittedly, the design of the VFS is biased toward filesystems that come from the Linux tribe. </span><span class="koboSpan" id="kobo.388.2">To an end user, there is a clear distinction between a file and a directory. </span><span class="koboSpan" id="kobo.388.3">In the Linux philosophy, everything is a file, including directories. </span><span class="koboSpan" id="kobo.388.4">Filesystems native to Linux, such as Ext4 and XFS, were designed keeping these nuances in mind. </span><span class="koboSpan" id="kobo.388.5">Because of the differences in the implementation, non-native filesystems such as FAT and NTFS do not support all of the VFS operations. </span><span class="koboSpan" id="kobo.388.6">The VFS in Linux uses structures such </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.389.1">as inodes, superblocks, and directory entries to represent a generic view of a filesystem. </span><span class="koboSpan" id="kobo.389.2">Non-native Linux filesystems do not speak in terms of these structures. </span><span class="koboSpan" id="kobo.389.3">So how does Linux accommodate these filesystems? </span><span class="koboSpan" id="kobo.389.4">Take the example of the FAT filesystem. </span><span class="koboSpan" id="kobo.389.5">The FAT filesystem comes from a different world and doesn’t use these structures to represent files and directories. </span><span class="koboSpan" id="kobo.389.6">It doesn’t treat directories as files. </span><span class="koboSpan" id="kobo.389.7">So, how does the VFS interact with the </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">FAT filesystem?</span></span></p>
<p><span class="koboSpan" id="kobo.391.1">All filesystem-related operations in the kernel are firmly integrated with the VFS data structures. </span><span class="koboSpan" id="kobo.391.2">To accommodate non-native filesystems on Linux, the kernel constructs the corresponding data structures dynamically. </span><span class="koboSpan" id="kobo.391.3">For instance, to satisfy the common file model for filesystems such as FAT, files corresponding to directories will be created in memory on the fly. </span><span class="koboSpan" id="kobo.391.4">These </span><em class="italic"><span class="koboSpan" id="kobo.392.1">files</span></em><span class="koboSpan" id="kobo.393.1"> are </span><em class="italic"><span class="koboSpan" id="kobo.394.1">virtual</span></em><span class="koboSpan" id="kobo.395.1"> and will only exist in memory. </span><span class="koboSpan" id="kobo.395.2">This is an important concept to understand. </span><span class="koboSpan" id="kobo.395.3">On native filesystems, structures such as inodes and superblocks are not only present in memory but also stored on the physical medium itself. </span><span class="koboSpan" id="kobo.395.4">Conversely, non-Linux filesystems merely have to perform the enactment of such structures </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">in memory.</span></span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.397.1">Peeking at the source code</span></h2>
<p><span class="koboSpan" id="kobo.398.1">If we take a look at the kernel </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.399.1">source code, the different functions provided by the VFS are present in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">fs</span></strong><span class="koboSpan" id="kobo.401.1"> directory. </span><span class="koboSpan" id="kobo.401.2">All source files ending in </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">.c</span></strong><span class="koboSpan" id="kobo.403.1"> contain implementations of the different VFS methods. </span><span class="koboSpan" id="kobo.403.2">The subdirectories contain specific filesystem implementations, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.404.1">Figure 1</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.405.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.407.1"><img alt="Figure 1.5 – The source for kernel 5.19.9" src="image/B19430_01_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.408.1">Figure 1.5 – The source for kernel 5.19.9</span></p>
<p><span class="koboSpan" id="kobo.409.1">You’ll notice source files such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">open.c</span></strong><span class="koboSpan" id="kobo.411.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">read_write.c</span></strong><span class="koboSpan" id="kobo.413.1">, which are the functions invoked when a user space process generates </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">open ()</span></strong><span class="koboSpan" id="kobo.415.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">read ()</span></strong><span class="koboSpan" id="kobo.417.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">write ()</span></strong><span class="koboSpan" id="kobo.419.1"> system calls. </span><span class="koboSpan" id="kobo.419.2">These files contain a lot of code, and since we won’t create any new code here, this is merely a poking exercise. </span><span class="koboSpan" id="kobo.419.3">Nevertheless, there</span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.420.1"> are a few important pieces of code in these files that highlight what we explained earlier. </span><span class="koboSpan" id="kobo.420.2">Let’s take a quick peek at the read and </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">write functions.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">SYSCALL_DEFINE3</span></strong><span class="koboSpan" id="kobo.424.1"> macro is the standard way to define a system call and takes the name of the system call as one of </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">the parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">write</span></strong><span class="koboSpan" id="kobo.428.1"> system call, this definition looks as follows. </span><span class="koboSpan" id="kobo.428.2">Note that one of the parameters is the </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">file descriptor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.430.1">
SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf, size_t, count)
{
        return ksys_write(fd, buf, count);
}</span></pre>
<p><span class="koboSpan" id="kobo.431.1">Similarly, this is the definition for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">read</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.433.1">system call:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.434.1">
SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)
{
        return ksys_read(fd, buf, count);
}</span></pre>
<p><span class="koboSpan" id="kobo.435.1">Both call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">ksys_write ()</span></strong><span class="koboSpan" id="kobo.437.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">ksys_read ()</span></strong><span class="koboSpan" id="kobo.439.1"> functions. </span><span class="koboSpan" id="kobo.439.2">Let’s see</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.440.1"> the code for these </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">two functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.442.1">
ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)
{
        struct fd f = fdget_pos(fd);
        ssize_t ret = -EBADF;
******* Skipped *******
                ret = vfs_read(f.file, buf, count, ppos);
******* Skipped *******
        return ret;
}
ssize_t ksys_write(unsigned int fd, const char __user *buf, size_t count)
{
        struct fd f = fdget_pos(fd);
        ssize_t ret = -EBADF;
******* Skipped *******
                ret = vfs_write(f.file, buf, count, ppos);
                ******* Skipped *******
        return ret;
}</span></pre>
<p><span class="koboSpan" id="kobo.443.1">The presence of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">vfs_read ()</span></strong><span class="koboSpan" id="kobo.445.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">vfs_write ()</span></strong><span class="koboSpan" id="kobo.447.1"> functions indicates that we’re transitioning to the VFS. </span><span class="koboSpan" id="kobo.447.2">These functions look up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">file_operations</span></strong><span class="koboSpan" id="kobo.449.1"> structure for the underlying filesystem</span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.450.1"> and invoke the appropriate </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">read ()</span></strong><span class="koboSpan" id="kobo.452.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">write ()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.454.1">methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.455.1">
ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
{
******* Skipped *******
        if (file-&gt;f_op-&gt;read)
                ret = file-&gt;f_op-&gt;read(file, buf, count, pos);
        else if (file-&gt;f_op-&gt;read_iter)
                ret = new_sync_read(file, buf, count, pos);
******* Skipped *******
return ret;
}
ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)
{
******* Skipped *******
        if (file-&gt;f_op-&gt;write)
                ret = file-&gt;f_op-&gt;write(file, buf, count, pos);
        else if (file-&gt;f_op-&gt;write_iter)
                ret = new_sync_write(file, buf, count, pos);
 ******* Skipped *******
       return ret;
}</span></pre>
<p><span class="koboSpan" id="kobo.456.1">Each filesystem defines the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">file_operations</span></strong><span class="koboSpan" id="kobo.458.1"> structure of pointers for supporting operations. </span><span class="koboSpan" id="kobo.458.2">There are multiple definitions of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">file_operations</span></strong><span class="koboSpan" id="kobo.460.1"> structure in the kernel source code, unique to </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.461.1">each filesystem. </span><span class="koboSpan" id="kobo.461.2">The operations defined in this structure describe how read or write functions will </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">be performed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.463.1">
root@linuxbox:/linux-5.19.9/fs# grep -R "struct file_operations" * | wc -l
453
root@linuxbox:/linux-5.19.9/fs# grep -R "struct file_operations" *
9p/vfs_dir.c:const struct file_operations v9fs_dir_operations = {
9p/vfs_dir.c:const struct file_operations v9fs_dir_operations_dotl = {
9p/v9fs_vfs.h:extern const struct file_operations v9fs_file_operations;
9p/v9fs_vfs.h:extern const struct file_operations v9fs_file_operations_dotl;
9p/v9fs_vfs.h:extern const struct file_operations v9fs_dir_operations;
9p/v9fs_vfs.h:extern const struct file_operations v9fs_dir_operations_dotl;
9p/v9fs_vfs.h:extern const struct file_operations v9fs_cached_file_operations;
9p/v9fs_vfs.h:extern const struct file_operations v9fs_cached_file_operations_dotl;
9p/v9fs_vfs.h:extern const struct file_operations v9fs_mmap_file_operations;
9p/v9fs_vfs.h:extern const struct file_operations v9fs_mmap_file_operations_dotl;</span></pre>
<p><span class="koboSpan" id="kobo.464.1">[The rest of the code is skipped </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">for brevity.]</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">As you can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">file_operations</span></strong><span class="koboSpan" id="kobo.468.1"> structure is used for a wide range of file types, including regular files, directories, device files, and </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.469.1">network sockets. </span><span class="koboSpan" id="kobo.469.2">In general, any type of file that can be opened and manipulated using standard file I/O operations can be covered by </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">this structure.</span></span></p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.471.1">Tracing VFS functions</span></h1>
<p><span class="koboSpan" id="kobo.472.1">There are quite </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.473.1">a few tracing mechanisms available in Linux that can offer a glance at how things work under the hood. </span><span class="koboSpan" id="kobo.473.2">One </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.474.1">of them is the </span><strong class="bold"><span class="koboSpan" id="kobo.475.1">BPF Compiler Collection</span></strong><span class="koboSpan" id="kobo.476.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.477.1">BCC</span></strong><span class="koboSpan" id="kobo.478.1">) tools. </span><span class="koboSpan" id="kobo.478.2">These tools offer a wide range of scripts that can record events for different subsystems in the kernel. </span><span class="koboSpan" id="kobo.478.3">You can install these tools for your operating system by following the instructions in the </span><em class="italic"><span class="koboSpan" id="kobo.479.1">Technical requirements</span></em><span class="koboSpan" id="kobo.480.1"> section. </span><span class="koboSpan" id="kobo.480.2">For now, we’re just going to use one of the programs from this toolkit, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">funccount</span></strong><span class="koboSpan" id="kobo.482.1">. </span><span class="koboSpan" id="kobo.482.2">As the name suggests, </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">funccount</span></strong><span class="koboSpan" id="kobo.484.1"> counts the number of </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">function calls:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.486.1">
root@linuxbox:~# funccount --help
usage: funccount [-h] [-p PID] [-i INTERVAL] [-d DURATION] [-T] [-r] [-D]
                 [-c CPU]
                 pattern
Count functions, tracepoints, and USDT probes</span></pre>
<p><span class="koboSpan" id="kobo.487.1">Just to test and verify our understanding of what we stated earlier, we’re going to run a simple copy process in the background and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">funccount</span></strong><span class="koboSpan" id="kobo.489.1"> program to trace the VFS functions that are invoked as a result of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">cp</span></strong><span class="koboSpan" id="kobo.491.1"> command. </span><span class="koboSpan" id="kobo.491.2">As we’re going to count the VFS calls for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">cp</span></strong><span class="koboSpan" id="kobo.493.1"> process only, we need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">-p</span></strong><span class="koboSpan" id="kobo.495.1"> flag to specify a process ID. </span><span class="koboSpan" id="kobo.495.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">vfs_*</span></strong><span class="koboSpan" id="kobo.497.1"> parameter will trace all the VFS functions for the process. </span><span class="koboSpan" id="kobo.497.2">You’ll see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">vfs_read ()</span></strong><span class="koboSpan" id="kobo.499.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">vfs_write ()</span></strong><span class="koboSpan" id="kobo.501.1"> functions are invoked by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">cp</span></strong><span class="koboSpan" id="kobo.503.1"> process. </span><span class="koboSpan" id="kobo.503.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">COUNT</span></strong><span class="koboSpan" id="kobo.505.1"> column specifies the number of times the function </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">was called:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.507.1">
funccount -p process_ID 'vfs_*'
[root@linuxbox ~]# nohup cp myfile /tmp/myfile &amp;
[1] 1228433
[root@linuxbox ~]# nohup: ignoring input and appending output to 'nohup.out'
[root@linuxbox ~]#
[root@linuxbox ~]# funccount -p 1228433 "vfs_*"
Tracing 66 functions for "b'vfs_*'"... </span><span class="koboSpan" id="kobo.507.2">Hit Ctrl-C to end.
</span><span class="koboSpan" id="kobo.507.3">^C
FUNC                                    COUNT
b'vfs_read'                             28015
b'vfs_write'                            28510
Detaching...
</span><span class="koboSpan" id="kobo.507.4">[root@linuxbox ~]#</span></pre>
<p><span class="koboSpan" id="kobo.508.1">Let’s run this again and see what</span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.509.1"> system calls are used when doing a simple copy operation. </span><span class="koboSpan" id="kobo.509.2">As expected, the most frequently used system calls when doing </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">cp</span></strong><span class="koboSpan" id="kobo.511.1"> are read </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">and write:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.513.1">
funccount 't:syscalls:sys_enter_*' -p process_ID
[root@linuxbox ~]# nohup cp myfile /tmp/myfile &amp;
[1] 1228433
[root@linuxbox ~]# nohup: ignoring input and appending output to 'nohup.out'
[root@linuxbox ~]#
[root@linuxbox ~]# /usr/share/bcc/tools/funccount -p 1228433 "vfs_*"
Tracing 66 functions for "b'vfs_*'"... </span><span class="koboSpan" id="kobo.513.2">Hit Ctrl-C to end.
</span><span class="koboSpan" id="kobo.513.3">^C
FUNC                                    COUNT
b'vfs_read'                             28015
b'vfs_write'                            28510
Detaching...
</span><span class="koboSpan" id="kobo.513.4">[root@linuxbox ~]#</span></pre>
<p><span class="koboSpan" id="kobo.514.1">Let’s summarize what we covered in this section. </span><span class="koboSpan" id="kobo.514.2">Linux offers support for a wide range of filesystems, and the VFS layer in the kernel ensures that this can be achieved without any hassle. </span><span class="koboSpan" id="kobo.514.3">The VFS provides a standardized way for end user processes to interact with the different filesystems. </span><span class="koboSpan" id="kobo.514.4">This standardization is</span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.515.1"> achieved by implementing a common file mode. </span><span class="koboSpan" id="kobo.515.2">The VFS defines several virtual functions for common file operations. </span><span class="koboSpan" id="kobo.515.3">As a result of this approach, applications can universally perform regular file operations. </span><span class="koboSpan" id="kobo.515.4">When a process generates a system call, the VFS will redirect these calls to the appropriate function of </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">the filesystem.</span></span></p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.517.1">Explaining the Everything is a file philosophy</span></h1>
<p><span class="koboSpan" id="kobo.518.1">In Linux, all of the following</span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.519.1"> are </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">considered files:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.521.1">Directories</span></span></li>
<li><span class="koboSpan" id="kobo.522.1">Disk drives and </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">their partitions</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.524.1">Sockets</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.525.1">Pipes</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.526.1">CD-ROM</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.527.1">The phrase </span><em class="italic"><span class="koboSpan" id="kobo.528.1">everything is a file</span></em><span class="koboSpan" id="kobo.529.1"> implies that all the preceding entities in Linux are represented by file descriptors, abstracted over the VFS. </span><span class="koboSpan" id="kobo.529.2">You could also say that </span><em class="italic"><span class="koboSpan" id="kobo.530.1">everything has a file descriptor</span></em><span class="koboSpan" id="kobo.531.1">, but let’s not indulge in </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">that debate.</span></span></p>
<p><span class="koboSpan" id="kobo.533.1">The </span><em class="italic"><span class="koboSpan" id="kobo.534.1">everything is a file</span></em><span class="koboSpan" id="kobo.535.1"> ideology that characterizes the architecture of a Linux system is also implemented courtesy of the VFS. </span><span class="koboSpan" id="kobo.535.2">Earlier, we defined pseudo filesystems as filesystems that generate their content on the fly. </span><span class="koboSpan" id="kobo.535.3">These filesystems are also referred to as VFSes and play a major role in implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">this concept.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">You can retrieve the list of filesystems currently registered with the kernel through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">procfs</span></strong><span class="koboSpan" id="kobo.539.1"> pseudo filesystem. </span><span class="koboSpan" id="kobo.539.2">When seeing this list, note </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">nodev</span></strong><span class="koboSpan" id="kobo.541.1"> in the first column against some filesystems. </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">nodev</span></strong><span class="koboSpan" id="kobo.543.1"> indicates that this is a pseudo filesystem and is not backed by a block device. </span><span class="koboSpan" id="kobo.543.2">Filesystems such as Ext2, 3, and 4 are created on a block device; hence, they do not have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">nodev</span></strong><span class="koboSpan" id="kobo.545.1"> entry in the </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">first column:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.547.1">
cat /proc/filesystems
[root@linuxbox ~]# cat /proc/filesystems
nodev   sysfs
nodev   tmpfs
nodev   bdev
nodev   proc
nodev   cgroup
nodev   cgroup2
nodev   cpuset
nodev   devtmpfs
nodev   configfs
nodev   debugfs
nodev   tracefs
nodev   securityfs
nodev   sockfs
nodev   bpf
nodev   pipefs
nodev   ramfs</span></pre>
<p><span class="koboSpan" id="kobo.548.1">[The rest of the code is skipped </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">for brevity.]</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">mount</span></strong><span class="koboSpan" id="kobo.552.1"> command to find </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.553.1">out about the currently mounted pseudo filesystems in </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">your system:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.555.1">
mount | grep -v sd | grep -ivE ":/|mapper"
[root@linuxbox ~]# mount | grep -v sd | grep -ivE ":/|mapper"
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
devtmpfs on /dev type devtmpfs (rw,nosuid,size=1993552k,nr_inodes=498388,mode=755)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,nodev,mode=755)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
efivarfs on /sys/firmware/efi/efivars type efivarfs (rw,nosuid,nodev,noexec,relatime)</span></pre>
<p><span class="koboSpan" id="kobo.556.1">[The rest of the code is skipped </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">for brevity.]</span></span></p>
<p><span class="koboSpan" id="kobo.558.1">Let’s take a tour of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">/proc</span></strong><span class="koboSpan" id="kobo.560.1"> directory. </span><span class="koboSpan" id="kobo.560.2">You’ll see </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.561.1">a long list of numbered directories; these numbers represent the IDs of all the processes that currently run on </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">your system:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.563.1">
[root@linuxbox ~]# ls /proc/
1    1116   1228072  1235  1534  196  216  30   54   6  631  668  810      ioports     scsi
10   1121   1228220  1243  1535  197  217  32   55   600  632  670  9      irq         self
1038  1125  1228371  1264  1536  198  218  345  56   602  
633  673  905      kallsyms     slabinfo
1039  1127  1228376  13    1537  199  219  347  570  603  
634  675  91       kcore      softirqs
1040  1197  1228378  14    1538  2    22   348  573  605  635  677  947      keys       stat
1041  12    1228379  1442  16    20   220  37   574  607  
636  679  acpi     key-users  swaps
1042  1205  1228385  1443  1604  200  221  38   576  609  
637  681  buddyinfo  kmsg       sys
1043  1213  1228386  1444  1611  201  222  39   577  610  638  684  bus      kpagecgroup  sysrq-</span></pre>
<p><span class="koboSpan" id="kobo.564.1">[The rest of the code is skipped </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">for brevity.]</span></span></p>
<p><span class="koboSpan" id="kobo.566.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">procfs</span></strong><span class="koboSpan" id="kobo.568.1"> filesystem offers us a glimpse into the running state of the kernel. </span><span class="koboSpan" id="kobo.568.2">The content in </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">/proc</span></strong><span class="koboSpan" id="kobo.570.1"> is generated when we want to view this information. </span><span class="koboSpan" id="kobo.570.2">This information is not persistently present on your disk drive. </span><span class="koboSpan" id="kobo.570.3">This all </span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.571.1">happens in memory. </span><span class="koboSpan" id="kobo.571.2">As you can see from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">ls</span></strong><span class="koboSpan" id="kobo.573.1"> command, the size of </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">/proc</span></strong><span class="koboSpan" id="kobo.575.1"> on disk is </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">zero bytes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.577.1">
[root@linuxbox ~]# ls -ld /proc/
dr-xr-xr-x 292 root root 0 Sep 20 00:41 /proc/
[root@linuxbox ~]#</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">/proc</span></strong><span class="koboSpan" id="kobo.579.1"> provides an on-the-spot view of the processes running on the system. </span><span class="koboSpan" id="kobo.579.2">Consider the </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">/proc/cpuinfo</span></strong><span class="koboSpan" id="kobo.581.1"> file. </span><span class="koboSpan" id="kobo.581.2">This file displays the processor-related information for your system. </span><span class="koboSpan" id="kobo.581.3">If we check this file, it will be shown </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">empty</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.585.1">
[root@linuxbox ~]# ls -l /proc/cpuinfo
-r--r--r-- 1 root root 0 Nov  5 02:02 /proc/cpuinfo
[root@linuxbox ~]#
[root@linuxbox ~]# file /proc/cpuinfo
/proc/cpuinfo: empty
[root@linuxbox ~]#</span></pre>
<p><span class="koboSpan" id="kobo.586.1">However, when the file contents are viewed through </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">cat</span></strong><span class="koboSpan" id="kobo.588.1">, they show a lot </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">of information:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.590.1">
[root@linuxbox ~]# cat /proc/cpuinfo
processor       : 0
vendor_id       : GenuineIntel
cpu family      : 6
model           : 79
model name      : Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz
stepping        : 1
microcode       : 0xb00003e
cpu MHz         : 2099.998
cache size      : 40960 KB
physical id     : 0
siblings        : 1
core id         : 0
cpu cores       : 1
apicid          : 0
initial apicid  : 0
fpu             : yes
fpu_exception   : yes
cpuid level     : 20
wp              : yes</span></pre>
<p><span class="koboSpan" id="kobo.591.1">[The rest of the code is skipped </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">for brevity.]</span></span></p>
<p><span class="koboSpan" id="kobo.593.1">Linux abstracts all entities such as processes, directories, network sockets, and storage devices into the VFS. </span><span class="koboSpan" id="kobo.593.2">Through</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.594.1"> the VFS, we can retrieve information from the kernel. </span><span class="koboSpan" id="kobo.594.2">Most Linux distributions offer a variety of tools for monitoring the consumption of storage, compute, and memory resources. </span><span class="koboSpan" id="kobo.594.3">All these tools gather stats for various metrics through the data available in </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">procfs</span></strong><span class="koboSpan" id="kobo.596.1">. </span><span class="koboSpan" id="kobo.596.2">For instance, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">mpstat</span></strong><span class="koboSpan" id="kobo.598.1"> command, which provides stats about all the processors in a system, retrieves data from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">/proc/stat</span></strong><span class="koboSpan" id="kobo.600.1"> file. </span><span class="koboSpan" id="kobo.600.2">It then presents this data in a human-readable format for a </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">better understanding:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.602.1">
[root@linuxbox ~]# cat /proc/stat
cpu  5441359 345061 4902126 1576734730 46546 1375926 942018 0 0 0
cpu0 1276258 81287 1176897 394542528 13159 255659 280236 0 0 0
cpu1 1455759 126524 1299970 394192241 13392 314865 178446 0 0 0
cpu2 1445048 126489 1319450 394145153 12496 318550 186289 0 0 0
cpu3 1264293 10760 1105807 393854806 7498 486850 297045 0 0 0</span></pre>
<p><span class="koboSpan" id="kobo.603.1">[The rest of the code is skipped </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">for </span></span><span class="No-Break"><a id="_idIndexMarker052"/></span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">brevity.]</span></span></p>
<p><span class="koboSpan" id="kobo.606.1">If we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">strace</span></strong><span class="koboSpan" id="kobo.608.1"> utility on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">mpstat</span></strong><span class="koboSpan" id="kobo.610.1"> command, it will show that under the hood, </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">mpstat</span></strong><span class="koboSpan" id="kobo.612.1"> uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">/proc/stat</span></strong><span class="koboSpan" id="kobo.614.1"> file to display </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">processor stats:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.616.1">
strace mpstat 2&gt;&amp;1 |grep "/proc/stat"
[root@linuxbox ~]# strace mpstat 2&gt;&amp;1 |grep "/proc/stat"
openat(AT_FDCWD, "/proc/stat", O_RDONLY) = 3
[root@linuxbox ~]#</span></pre>
<p><span class="koboSpan" id="kobo.617.1">Similarly, popular commands such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">top</span></strong><span class="koboSpan" id="kobo.619.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">ps</span></strong><span class="koboSpan" id="kobo.621.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">free</span></strong><span class="koboSpan" id="kobo.623.1"> gather memory-related information from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">proc/meminfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.626.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.627.1">
[root@linuxbox ~]# strace free -h 2&gt;&amp;1 |grep meminfo
openat(AT_FDCWD, "/proc/meminfo", O_RDONLY) = 3
[root@linuxbox ~]#</span></pre>
<p><span class="koboSpan" id="kobo.628.1">Similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">/proc</span></strong><span class="koboSpan" id="kobo.630.1">, another commonly used pseudo filesystem is </span><strong class="bold"><span class="koboSpan" id="kobo.631.1">sysfs</span></strong><span class="koboSpan" id="kobo.632.1">, which is mounted at </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">/sys</span></strong><span class="koboSpan" id="kobo.634.1">. </span><span class="koboSpan" id="kobo.634.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.635.1">sysfs filesystem</span></strong><span class="koboSpan" id="kobo.636.1"> mostly contains information about hardware devices on your system. </span><span class="koboSpan" id="kobo.636.2">For example, to find information about the disk drive in your system, such as its model, you can issue the </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.638.1">
cat /sys/block/sda/device/model
[root@linuxbox ~]# cat /sys/block/sda/device/model
SAMSUNG MZMTE512
[root@linuxbox ~]#</span></pre>
<p><span class="koboSpan" id="kobo.639.1">Even LEDs on a keyboard have a corresponding file </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">/sys</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.643.1">
[root@linuxbox ~]# ls /sys/class/leds
ath9k-phy0  input4::capslock  input4::numlock  input4::scrolllock
[root@linuxbox ~]#</span></pre>
<p><span class="koboSpan" id="kobo.644.1">The </span><em class="italic"><span class="koboSpan" id="kobo.645.1">everything is a file</span></em><span class="koboSpan" id="kobo.646.1"> philosophy is one of the defining features of the Linux kernel. </span><span class="koboSpan" id="kobo.646.2">It signifies that everything in a system, including regular text files, directories, and devices, can be abstracted over the VFS layer in the kernel. </span><span class="koboSpan" id="kobo.646.3">As a result, all these entities can be represented as file-like objects through the VFS layer. </span><span class="koboSpan" id="kobo.646.4">There are several pseudo filesystems in Linux that contain information about the different</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.647.1"> kernel subsystems. </span><span class="koboSpan" id="kobo.647.2">The content of these pseudo filesystems is only present in memory and </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">generated dynamically.</span></span></p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.649.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.650.1">The Linux storage stack is a complex design and consists of multiple layers, all of which work in coordination. </span><span class="koboSpan" id="kobo.650.2">Like other hardware resources, storage lies in the kernel space. </span><span class="koboSpan" id="kobo.650.3">When a user space program wants to access any of these resources, it has to invoke a system call. </span><span class="koboSpan" id="kobo.650.4">The system call interface in Linux allows user space programs to access resources in the kernel space. </span><span class="koboSpan" id="kobo.650.5">When a user space program wants to access something on the disk, the first component it interacts with is the VFS subsystem. </span><span class="koboSpan" id="kobo.650.6">The VFS provides an abstraction of filesystem-related interfaces and is responsible for accommodating multiple filesystems in the kernel. </span><span class="koboSpan" id="kobo.650.7">Through its common filesystem interface, the VFS intercepts the generic system calls (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">read()</span></strong><span class="koboSpan" id="kobo.652.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">write()</span></strong><span class="koboSpan" id="kobo.654.1">) from the user space programs and redirects them to their appropriate interfaces in the filesystem layer. </span><span class="koboSpan" id="kobo.654.2">Because of this approach, the user space programs do not need to worry about the underlying filesystems being used, and they can uniformly perform </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">filesystem operations.</span></span></p>
<p><span class="koboSpan" id="kobo.656.1">This chapter served as an introduction to the major Linux kernel subsystem Virtual Filesystem and its primary functions in the Linux kernel. </span><span class="koboSpan" id="kobo.656.2">The VFS provides a common interface for all filesystems through data structures, such as inodes, superblocks, and directory entries. </span><span class="koboSpan" id="kobo.656.3">In the next chapter, we will take a look at these data structures and explain how they all help the VFS to manage </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">multiple filesystems.</span></span></p>
</div>
</body></html>