- en: '*Chapter 5*: Using Commands for File, Directory, and Service Management'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with files and folders, `systemctl` command. This is exactly what
    we''re going to cover in this chapter, by covering the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic file and directory-based commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional commands for manipulating file/directory security aspects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files and folders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating text files by using commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archiving and compressing files and folders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing services and targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For these recipes, we're going to use one Linux machine – in our case, let's
    use `cli1`. We just need to make sure that it's powered on.
  prefs: []
  type: TYPE_NORMAL
- en: Basic file and directory-based commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discuss various shell commands that can be used to work with files and
    directories. In a nutshell, what we''re interested in are these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ls` – for listing folder contents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touch` – for creating an empty text file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd` – for changing directories, both in absolute and relative terms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pwd` – for showing the current directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mkdir` and `rm` – for creating and deleting a file or directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cp` and `mv` – for copying or moving a file or a directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ln` – for working with soft and hard links'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These commands are some of the most frequently used commands in the everyday
    life of a system administrator/engineer. Let's see what they are all about.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to go through these commands to really understand what happens on the
    filesystem as we execute them. So, let's make sure that our `cli1` machine is
    running and let's do it!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with the simplest command of them all, `ls`, it''s all about checking
    the content of a folder. So, if we want to check the content of a directory in
    a nice, readable format, we can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Using ls with the most common options'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Using ls with the most common options
  prefs: []
  type: TYPE_NORMAL
- en: 'The *nice, readable* part is achieved by using `-la` options, where the `l`
    option stands for *long listing*, and the `a` option stands for *all files (including
    the ones starting with a dot)*. We can also see that, by default, the `ls` command
    colors its output. For example, folders are colored blue, while files marked in
    red are archive files (in this case, the `tar.gz` file). We will go into more
    detail regarding archive files a bit later, when we start dealing with archiving
    and compressing files and folders later in this chapter. There are other colors
    that `ls` uses in its default output. Here are a couple of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Green – executable file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cyan – symbolic link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red with black background – broken link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ls` command can be used in a `/etc/network`, and its recursive option
    (capital letter `R`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Using ls in recursive mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Using ls in recursive mode
  prefs: []
  type: TYPE_NORMAL
- en: By using the `R` option, we instructed the `ls` command to do its job in recursive
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `ls` to display the content of the folder and sort the output
    by using the last modified time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Sorting the ls output according to the last modification time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.3_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Sorting the ls output according to the last modification time
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command on our list is `touch`, and it''s a simple one. We use the
    `touch` command to create an empty file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Touching a file in Linux means creating an empty file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.4_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Touching a file in Linux means creating an empty file
  prefs: []
  type: TYPE_NORMAL
- en: 'Following that, it''s time to explain two commands that are closely related
    – `cd` and `pwd. cd`, or the *change directory* command, is there so that we can
    leave one directory in the shell and go to another. In contrast, `pwd` is a command
    that tells us what our current directory is. Let''s try that out by again using
    `/etc/network` as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Using cd and pwd to get our bearings in terms of directories'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.5_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Using cd and pwd to get our bearings in terms of directories
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two commands that we''re going to deal with are `mkdir` and `rm`.
    We use `mkdir` to create a directory, while we use the `rm` command to remove
    a file or a folder. So, let''s show how these commands are used by means of an
    example. First, we are going to create a directory called `temporary`. Then, we''re
    going to create two files in that directory called `tempfile` and `tempfile2`.
    After that, we''re going to remove `tempfile2`, and then remove the entire temporary
    directory with all its contents, recursively. Let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Working with mkdir and rm'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.6_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – Working with mkdir and rm
  prefs: []
  type: TYPE_NORMAL
- en: 'The next topic of our discussion is the `cp` and `mv` commands – they enable
    us to copy or move files and/or folders where we want to move them. So, let''s
    copy a file and folder (recursively), and then let''s move them someplace else.
    We''re going to use the same example as with `mkdir` and `rm`, but we''re going
    to adjust the example slightly to fit the purpose. Specifically, we''re going
    to create a directory with two files, but this time these files are going to be
    in a subdirectory. Then, we''re going to add additional files to the first folder,
    after which we''re going to copy and move a single file to a new location, and
    then a folder to another location. Let''s see how that''s going to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Copying and moving files and folders'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.7_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Copying and moving files and folders
  prefs: []
  type: TYPE_NORMAL
- en: The first two commands can be aggregated into one by executing `mkdir -p temporary/tempdir2`.
  prefs: []
  type: TYPE_NORMAL
- en: This will create both of these directories in one command.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, let''s discuss the `ln` command, which can be used to create hard
    links (pointers to the file content) and soft links (pointers to the file/directory
    name, usually referred to as shortcuts). For hard links, we just use the `ln`
    command without any additional options, while soft links require us to use the
    `ln` command with the `-s` option. Let''s create an example to drive the point
    of this home, and we''ll explain how it works as soon as we''re done with this
    example. The scenario is going to include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Copying a file with a bit of content to a new location so that we have a source
    file that's going to be used for hard and soft links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a hard link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a soft link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting the original file, and then checking what happens with the soft link
    and the hard link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying the hard link to the original file, then checking what happens with
    soft link and hard link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Hard link and soft link operations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.8_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – Hard link and soft link operations
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone through all the predetermined scenarios, let's explain
    some of the concepts behind these commands so that we can understand what happens
    on the filesystem as we execute them.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of these commands are very straightforward and don't necessarily require
    further explanation, such as `ls`, `touch`, `cd`, `mkdir`, and `pwd`. But others
    do require a bit of background and technical explanation, especially `ln`. So,
    let's build on that premise and go through how `rm`, `cp`, `mv`, and `ln` work.
  prefs: []
  type: TYPE_NORMAL
- en: First, to cover basic file-related commands that we use the most often – `rm`,
    `cp`, and `mv`. These commands are straightforward, as we use them to remove files
    or folders (`rm`), copy files or folders (`cp`), or move files or folders (`mv`).
    Please note *remove* and *move* in our description of `rm` and `mv`, as those
    two things are different – removing is about deleting, while moving is about placing
    something someplace else. This sometimes confuses novice users, although it shouldn't.
  prefs: []
  type: TYPE_NORMAL
- en: However, the most technically demanding command from the bunch is `ln`, which
    requires us to explain what soft links are, and what hard links are. So, let's
    do that first.
  prefs: []
  type: TYPE_NORMAL
- en: Soft links are what we usually refer to as *shortcuts*, similarly to what we
    can do in Windows – create a shortcut to a file or a folder. As it's obvious from
    the picture of our scenario, when we removed the original file, the soft link
    stopped working. The reason for this is simple – soft links point to a *file or
    folder name*. If we delete a file or folder to which a soft link is pointing,
    that effectively means that the soft link points to nothing. And that's the reason
    why, in our scenario, we had a soft link turning red in color.
  prefs: []
  type: TYPE_NORMAL
- en: Hard links are a completely different concept. They don't point to a filename
    – they point to *file content*. When using hard links, try to think of them as
    two files pointing to the same content. If we delete the original file, the file
    content is still there, as that's the way modern filesystems work – they don't
    waste time deleting content, especially if another file is pointing to the same
    content. That would introduce a lot of latency into the process of deleting files
    if the files are big. A file delete operation therefore just deletes a pointer
    (filename) to the file content from a filesystem table. The filesystem takes care
    of the rest – when the time comes, if that file content is no longer used, the
    filesystem is going to use it to write new content over it.
  prefs: []
  type: TYPE_NORMAL
- en: We could've deduced this much from checking the original scenario, where we
    can clearly see the *difference in size* between soft and hard links – the soft
    link points to a filename and is therefore related to the size of a filename (the
    number of characters in the filename). As we explained, the hard link points to
    the file content, which is why the hard link has the same size as the file that
    it's pointing to.
  prefs: []
  type: TYPE_NORMAL
- en: There are two fundamental differences between these two concepts. Having in
    mind that the hard links point to *file content*, it's logical that they have
    two limitations – they can't point to a directory (just a file), and they can't
    go across partitions. So, if we have a disk partition mounted to `/directory`
    and another disk partition mounted to `/home directory`. We can't go to `/home
    directory` and create a hard link that points to a file that's located in `/partition`.
    One partition can't see the content of another partition, which is an important
    security concept. It also precludes any chance that hard links across partitions
    are going to work.
  prefs: []
  type: TYPE_NORMAL
- en: The next recipe is going to go much deeper into file-directory security concepts,
    as we're going to discuss permissions, special permissions, and **Access Control
    Lists** (**ACLs**). These concepts are core concepts of IT security and something
    that we deal with daily. So, let's go through a scenario related to that next.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need more information about these commands, we suggest that you visit
    these links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ls` man page: `https://man7.org/linux/man-pages/man1/ls.1.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touch` man page: `https://man7.org/linux/man-pages/man1/touch.1.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd` man page: `https://linuxcommand.org/lc3_man_pages/cdh.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pwd` man page: `https://man7.org/linux/man-pages/man1/pwd.1.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mkdir` man page: `https://man7.org/linux/man-pages/man1/mkdir.1.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rm` man page: `https://man7.org/linux/man-pages/man1/rm.1.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cp` man page: `https://man7.org/linux/man-pages/man1/cp.1.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mv` man page: `https://linux.die.net/man/1/mv`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ln` man page: `https://man7.org/linux/man-pages/man1/ln.1.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional commands for manipulating file/directory security aspects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we''re going to use our users – Jack, Joe, Jill, and Sarah
    – to create a specific scenario to explain permissions, ACLs, and umask usage.
    A short explanation of these concepts is as follows: permissions are used to control
    access to files and folders in read, write, and execute mode. As they''re limited
    in granularity, a concept of ACL was developed, to be able to manage permissions
    on a more finely grained level. Umask is a variable that pre-determines which
    permissions are going to be assigned to a newly created file or directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipe will go like this:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to create a collaborative directory for our students located at `/share/students`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to create a collaborative directory for our professors located at `/share/professors`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Members of the student group need to have access to `/share/students` to collaborate
    on project files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Members of the student group can create new files, which need to be group-owned
    by group students, in their `/share/students` folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One member of the student group can't use the `rm` command to delete other members'
    files in their `/share/students` folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One member of the student group must have permission to edit other members'
    files in their `/share/students` folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Professors need to have read-write access to all the student files, and all
    of the newly created student files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only professors have access to their shared folder, `/share/professors`, where
    they can delete each other's files, read them, and edit them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's make this recipe happen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's use our `cli2` machine (CentOS) for this recipe, so make sure that it's
    powered on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to first create our users and groups by using the `useradd` and
    `groupadd` commands by using a scenario. Let''s say that our task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create four users called `jack`, `joe`, `jill`, and `sarah`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create two user groups called `profs` and `pupils`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reconfigure the `jack` and `jill` user accounts to be members of the `profs`
    group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reconfigure the `joe` and `sarah` user accounts to be members of the `students`
    group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign a standard password to all the accounts (we're going to use `P@ckT2021`
    for this purpose)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure user accounts so that they must change their password when next logging
    in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set specific expiry data for the professors' user group – the minimum days before
    the password change should be set to `15`, the maximum days before a forced password
    change should be set to `30`, the warning regarding a password change needs to
    start a week before it expires, and the expiry date for accounts should be set
    to 2023/01/01 (January 1, 2023)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set specific expiry data for the students' user group – the minimum days before
    the password change should be set to `7`, the maximum days before a forced password
    change should be set to `30`, the warning regarding a password change needs to
    start 10 days before it expires, and the expiry date for accounts should be set
    to 2022/09/01 (September 1, 2022)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the `profs` group to be called `professors`, and the `pupils` group to
    be called `students`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are a lot of commands in this recipe, so make sure that you refer to the
    *How it works…* section of the recipe to understand everything about the new commands
    that we haven't used before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first task is to create user accounts, with their unique home directories
    and the Bash shell as the default shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will create entries for these four users in the `/etc/passwd` file (where
    most of the users' information is stored – username, user ID, group ID, default
    home directory, and default shell), and the `/etc/shadow` file (where users' passwords
    and aging information are stored).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to create groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will create entries for these groups in the`/etc/group` file, where the
    system keeps all of the system groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to manage the membership of the user groups, for both the
    professors and student user groups. Before we do that, we need to be aware of
    one fact. There are two distinctive local group types – *primary group* and *supplementary
    group*. The *primary group* is important in terms of being the key parameter used
    when creating new files and directories, as the users'' primary group will be
    used by default for that (there are exceptions, as we''ll mention in recipe #4
    in this chapter, about umask, permissions, and ACLs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *supplementary group* is important when dealing with sharing files and
    folders and related scenarios and exceptions. This is what''s usually used for
    some additional settings for more advanced scenarios. These scenarios are going
    to be explained partially in the aforementioned recipe #4 in this chapter, as
    well as in recipes regarding NFS and Samba in [*Chapter 9*](B16269_09_Final_PD_ePub.xhtml#_idTextAnchor206)*,
    An Introduction to Shell Scripting*.'
  prefs: []
  type: TYPE_NORMAL
- en: Primary and supplementary groups are stored in `/etc/group` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve gotten that out of the way, let''s modify our users'' settings
    so that they belong to the *supplementary* groups as assigned by the scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now check how that changes the `/etc/group` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Entries in the /etc/group file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.9_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – Entries in the /etc/group file
  prefs: []
  type: TYPE_NORMAL
- en: The first four entries in the `/etc/group` file were actually created when we
    used the `useradd` command to create these user accounts. The next two entries
    (except for the last part, after the `:` sign), were created by `groupadd` commands,
    while entries after the `:` sign were created after the `usermod` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now set their initial password and set a forced password change when
    next logging in. We can do it in a couple of different ways, but let''s learn
    the more *programmatic* approach to doing this by echoing a string and using it
    as the plaintext password for a user account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is not necessarily something that we should recommend doing as it would
    leave these commands in the command history. We're just using this as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `echo` part – without the rest of the command – would just type `P@ckT2021`
    to a terminal, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In CentOS and similar distributions, we could use the `passwd` command with
    the `--stdin` parameter, which would mean that we want to add a password for the
    user account via standard input (keyboard, variable, ...). In Ubuntu, this is
    not available. So, we can echo the `username:P@ckT2021` string to `shell` and
    pipe that to the `chpasswd` command, which achieves just that purpose – instead
    of outputting the string to our terminal, the `chpasswd` command uses it as standard
    input into itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set the expiry data for professors and students. For this purpose, we
    need to learn how to use the `chage` command and some of its parameters (`-m`,
    `-M`, `-W`, `-E`):'
  prefs: []
  type: TYPE_NORMAL
- en: If we use the `-m` parameter, this means that we want to assign the minimum
    number of days before a password change is allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use the `-M` parameter, this means that we want to assign the maximum
    number of days before a password change is forced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use the `-W` parameter, this means that we want to set the number of warning
    days prior to password expiration, which, in turn, means that the shell is going
    to start throwing us messages about needing to change our password before it expires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use the `-E` parameter, this means that we want to set account expiration
    to a certain date (in YYYY-MM-DD format)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now translate that into commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, let''s modify the groups to their final settings by modifying
    the group name from `professors` to `profs` and from `students` to `pupils`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands will only change group names, not their other data (such as
    group ID), which is going to be reflected in our users'' information as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Checking created users'' settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.10_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – Checking created users' settings
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, `jack` and `jill` are members of a group that's now called `professors`,
    while `joe` and `sarah` are now members of a group called `students`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We deliberately left the `userdel` and `groupdel` commands for last, as they
    come with some caveats and shouldn''t be used lightly. Let''s create a user called
    `temp` and a group called `temporary`, and then let''s delete them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will work just fine. The thing is, because we used the `userdel` command
    without any parameters, it will leave the user's home directory intact. Since
    users' home directories are usually stored in the `/home` directory, by default,
    this means that the `/home/temp` directory is still going to be there. When deleting
    users, this is sometimes something we want – to delete a user, but not to delete
    their files. If you specifically want to delete a user account and all the data
    from that user account, use the `userdel -r username` command. But think twice
    before doing it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we obviously need to create a bunch of directories and files and
    change a whole stack of permissions and ACLs. As a general note, the `chmod` command
    changes permissions, while the `setfacl` command modifies ACLs. This is the correct
    way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's now test this to check whether it works. First, we're going to log in
    as our two students from the first recipe (`joe` and `sarah`) and create a couple
    of files. Then we're going to use joe's account to try to delete Sarah's files,
    and vice versa, so we should first use `su` to log in as `joe`, `su - joe`, and
    type in the root password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how that works out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The scenario works flawlessly from the students'' perspective'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.11_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.11 – The scenario works flawlessly from the students' perspective
  prefs: []
  type: TYPE_NORMAL
- en: 'Part of our scenario required us to be able to edit each other''s files, while
    not being able to delete them outright. Let''s test that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Changing the content of the file works, while removing the
    file doesn''t'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.12_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.12 – Changing the content of the file works, while removing the file
    doesn't
  prefs: []
  type: TYPE_NORMAL
- en: There's a reason why we picked this type of scenario – this is a real-life scenario
    that file server administrators often encounter. It's basically the best of both
    worlds – collaboration works, but users can't delete each other's files by accident.
    Therefore, this recipe covers some of the most common things that happen on a
    file server, such as one user deleting another user's file by accident (the key
    point here being the *lack of intention* to delete a file). It has happened to
    all of us. On the other hand, changing a file's content is something that we can
    only do *intentionally*, *consciously*. This is also something that we can easily
    track by using filesystem auditing and file attributes, if we set up our system
    that way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now review things from the professor''s perspective. We''ll use the
    `jill` account for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Checking whether our configuration works for Jill'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.13_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.13 – Checking whether our configuration works for Jill
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to check whether the professors'' share works. Let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – From the professors'' standpoint, their share works as requested'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.14_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.14 – From the professors' standpoint, their share works as requested
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to use a student''s account to get into the professors'' shared
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – A student tries to get to the professors'' share and is denied
    access'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.15_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.15 – A student tries to get to the professors' share and is denied
    access
  prefs: []
  type: TYPE_NORMAL
- en: We can also see that these files created by users get the `664` default permission.
    That's what umask is all about. Check how umask works in the *How it works…* section
    of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: So, the whole scenario works, but how exactly does it work? Let's check that
    out now.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we get to the detailed explanations of these commands, let''s just cover
    the basics and describe the commands that we have used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`useradd` – the command that''s used to create a local user account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usermod` – the command that''s used to modify a local user account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userdel` – the command that''s used to delete a local user account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupadd` – the command that''s used to create a local group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupmod` – the command that''s used to modify a local group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupdel` – the command that''s used to delete a local group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`passwd` – the command that''s most often used to assign passwords to user
    accounts, but it can be used for some other scenarios (for example, locking user
    accounts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chage` – the command that''s used to manage user password expiry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chgrp` – the command that changes the group ownership of a file or folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chmod` – the command that changes the permission of a file or folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setfacl` – the command that changes the ACL of a file or folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have discussed these commands, let's explain the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every file or directory on a Linux filesystem has a number of attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date of creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File/directory name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will focus on permissions and ownership in this recipe as that''s the core
    of this specific recipe. When we issue a command such as `ls -al` in the `/share/students`
    directory, this is what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's now use the `myfile1` output as an example. Reading from left to right,
    the `-rw-rw-r--+` part is related to permissions on that specific file. The second
    part (`joe`, followed by `students`) is related to ownership of that specific
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s parse through this a bit, going with permissions first:'
  prefs: []
  type: TYPE_NORMAL
- en: The first `–` means that this is a file – this field is used for the type of
    content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first `rw-` means that we have read and write permission for the file owner
    (`joe`) – which we refer to as the user class (u).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second `rw-` means that we have read and write permission for the group
    owner (`students`) – which we refer to as the group class (g).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R—`means that all the other users have just read permissions – we refer to
    this class as `others` (o).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+` at the end means that we have an active ACL on this specific file (to be
    discussed |a bit later in this explanation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can assign numerical values (weights) to these permissions. The read permission
    has a weight of 4 (22), the write permission has a weight of 2 (21), and the execute
    permission has a weight of 1 (20).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we wanted to assign all permissions to all classes of users (user owner,
    group owner, others), we''d use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Why? If we add 4+2+1, that equals 7\. That means read + write + execute. And
    we can use that on all three classes – u, g, and o – so that gives us 777\. The
    first `7` refers to `u` (user owner), the second one to `g` (group owner), and
    the third one to everyone else (others). That simplifies the management of permissions
    significantly.
  prefs: []
  type: TYPE_NORMAL
- en: If we're talking about files, the meaning of these permissions is straightforward
    – read means read, write means write, delete, and modify, and execute means the
    ability to start the file.
  prefs: []
  type: TYPE_NORMAL
- en: With directories, it gets a bit trickier. Default permissions that we need in
    order to be able to read directory content and pass through it (folder traverse)
    are read and execute permissions. Write permission on a directory and read permission
    is needed to list the contents of the directory, while x permission is needed
    to traverse the directory (being able to go into subfolders of that directory).
    Write permission means write, delete, and modify on the folder level for the files
    in that folder (unless there are explicit denies, for example, set by ACL).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can clearly see in the command output, files have two types of ownership:'
  prefs: []
  type: TYPE_NORMAL
- en: '`joe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`students`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does that mean?
  prefs: []
  type: TYPE_NORMAL
- en: It means that a *user called Joe* owns that file. At the same time, it means
    that a *group called students* own that file from the group perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add to that discussion by talking about the second line of this
    output, specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The same principles apply, it's just that we need to discuss a couple of new
    settings. We can clearly see a couple of letters that we didn't mention previously
    – `s` in the group ownership class, and `t` in the others class. What is that
    all about?
  prefs: []
  type: TYPE_NORMAL
- en: 'The thing is, there are additional, special permissions on top of r(ead), w(rite),
    and (e)x(ecute). These are used for special use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sticky bit` – we set this special permission on a folder level. When enabled
    on a folder level, it''s there to protect from accidental file deletion from our
    scenario. For example, `myfile1` is owned by the user `joe`. Although `sarah`
    is the member of the same group (students), which group-owns the file, she still
    can''t delete that file. That''s what the sticky bit is all about.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setgid` – we set this special permission on the folder level as well. When
    set on the folder level, this special permission means that all of the newly created
    files (after `setgid` was set) are going to take their group ownership from the
    parent folder. In our scenario, that means that all of the newly created files
    are group-owned by the student group, as requested by the scenario. This is why
    we used the `chgrp` command on the folder level to set folder ownership to students.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setuid` – almost never used now, as it''s a security risk. It used to be used
    on files a bit, specifically, so that when files are started by a non-owner user,
    it seems that the user owning the file started it (similar to Run As IDEA in Windows).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These permissions are also set by the `chmod` command, like the first number.
    That's why our `chmod` command had four numbers instead of three – the first number
    is all about special permissions. In general, when we use a three-digit number
    with `chmod`, it expands that to include a zero from the left side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our recipe, we issued the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That means that we used `chmod` to set the sticky bit and `setgid` (1+2 equals
    3 on the first digit) on the folder, as well as `rwx` for user and group owners
    (77) and `rx` for others (5).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next, more complicated part relates to ACLs. ACLs are most commonly used
    to take care of *exceptions* (regular ACLs) or *permission inheritance* (default
    ACLs). Let''s describe them in a bit more detail. We used the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This means that we want to modify (the `-m` parameter) the ACL on the directory
    called `/share/students`. And we want to modify it so that the group called `professors`
    gets `rwx` (read-write-execute) permissions on that directory. You can clearly
    see why we said that ACLs are most commonly used to treat exceptions. Our scenario
    required that the `/share/students` folder has group ownership of students. We
    can't assign two users to be owners of a directory (there can be only one, (c)
    according to the Highlander movie). So, there's no direct way for us to do that,
    which means we have to use something else to create an exception. That's where
    ACL comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could''ve done this differently (not that we should have). We could have
    issued two user-based ACLs for both members of our professors'' group. Those two
    commands would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The trouble with that approach is really simple to understand. Let's say that
    we add five more professors to our system. We then need to issue five more `setfacl`
    commands to set the same ACLs to them. It's just easier to use a group and add
    users to a group. It's a well-known concept that everyone uses on all of the operating
    systems used today.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to set explicit deny ACL for `others`, we could have used this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This way, we make sure that all of the members of that `others` class don't
    get access to the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second `setfacl` command that we used was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This command sets a *default ACL*, which is a completely different concept to
    regular ACL we described just before this. Default ACLs are used so that every
    newly created file or folder under a directory (in this case, `/share/students`)
    automatically inherits permissions from the parent folder as set by the default
    ACL. In our scenario, this command means that every single file or folder that
    gets created after we set this default ACL is going to have an ACL set to `g:professors:rwx`.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, you can see how ACLs and default ACLs are useful, as without them,
    we'd have way less scope to configure more advanced, finely-grained scenarios
    for data access.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now discuss the last important aspect of this scenario – default file
    permissions. We mentioned in the recipe that we need to cover the subject of `umask`.
    Let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we check the output from one of the previous screenshots, we can see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The question is, why are default permissions `rw-rw-r--`?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this question is called `umask` (user mask).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a concept, `umask` is used specifically for that – to set default permissions
    for newly created files and directories. It can be set by shell configuration
    files, by a user profile, or by a command. Let''s use the `umask` command to explain
    how it does what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can clearly see that as we change the `umask` variable for a user, the default
    permissions for newly created files change. When we used an `umask` value of `0002`,
    the `prof4` file was created with permission `664`. When we used an `umask` value
    of `0022`, the `prof5` file was created with permission `644`. Lastly, when we
    used an `umask` value of `0222`, the `prof6` file was created with permission
    `444`. We could also ignore the leading zero when assigning `umask` in accordance
    with the same principle we used for the `chmod` command.
  prefs: []
  type: TYPE_NORMAL
- en: Mask for files is set to `666`, and for directories, it's set to `777`. So,
    if we want to calculate default permissions for newly created files or folders,
    we just need to subtract the `umask` value from these values (`666` or `777`)
    and get default permissions for files (or folders).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t resort to manual configuration, all users'' umask values are set
    by the `/etc/profile` file, which is loaded by default when a user logs in. In
    that file, there''s an `if` statement that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Basically, what this `if`-`then`-`else` structure does is, for all the UIDs
    that are greater than `199`, `umask` is set to `002`, otherwise, it's set to `022`.
    That's why regular users have `umask 002`, while the root user has `umask 022`
    (the root's UID is 0).
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move to our next recipe, which is all about using commands to manipulate
    text files – commands including `cat`, `cut`, `more`, `less`, `head`, and `tail`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need more information about file permissions, special permissions, or
    ACLs, we suggest that you visit these links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Managing file permissions: `https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/assembly_managing-file-permissions_configuring-basic-system-settings`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux permissions – SUID, SGID, and sticky bit: `https://www.redhat.com/sysadmin/suid-sgid-sticky-bit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An introduction to Linux ACLs: `https://www.redhat.com/sysadmin/linux-access-control-lists`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating text files by using commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now switch our attention to learning about commands that enable us to
    manipulate text files – just for output reasons `head`, `tail`, `more`, `less`,
    `cat`. Some other commands related to the same concepts are going to be covered
    in later chapters, such as [*Chapter 8*](B16269_08_Final_PD_ePub.xhtml#_idTextAnchor178),
    *Using the Command Line to Find, Extract, and Manipulate Text Content*, where
    we discuss more advanced scenarios with text files, such as merging, cutting,
    and using regular expressions with `grep` and `sed` to manipulate text content.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We still need the same virtual machines as with our previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by using `head` and `tail` command, commands that can be used
    to show the beginning and end of a text file. For example, let''s use the `/root/.bashrc`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now check the tail end of the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike `that`, `more` and `less` are used to just display output, but in a
    page-by-page formatted fashion, making a long output much more humanly readable.
    So, when we execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output from these commands is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Using the more and less commands looks very similar'
  prefs: []
  type: TYPE_NORMAL
- en: to this – page-by-page viewing of text content
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.16_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.16 – Using the more and less commands looks very similar to this –
    page-by-page viewing of text content
  prefs: []
  type: TYPE_NORMAL
- en: '`Cat` (the command, not a feline) is completely opposite to the *discipline*
    of `more` or `less` – it just displays the whole file content, without any stoppages.
    This is cool when a text file is short, but mostly useless if that file is long,
    and is one of the most common reasons why we use `more` or `less` commands. So,
    let''s pick a short file and `cat` it, for example, the `/root/.profile` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Using the cat command on an appropriate file – a text file'
  prefs: []
  type: TYPE_NORMAL
- en: that's not too big to fit on one terminal page
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.17_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.17 – Using the cat command on an appropriate file – a text file that's
    not too big to fit on one terminal page
  prefs: []
  type: TYPE_NORMAL
- en: '`Cat` can be used for one more thing, which is to combine multiple text files
    into one. This operation is often used when combining multiple log files into
    one to concatenate them. We''re going to discuss this scenario later in this book,
    in [*Chapter 8*](B16269_08_Final_PD_ePub.xhtml#_idTextAnchor178), *Using the Command
    Line to Find, Extract, and Manipulate Text Content*.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`more` and `less` are page viewers – they enable us to display content page
    by page. As we can see in the last line of our example, using these commands didn''t
    *finish* – the command stopped showing the file content after displaying one page
    of that file. Now it''s interactively waiting for us to either continue listing
    file content page by page, do something else (for example, searching by using
    the `/` sign), or quit by using the `q` key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `head` and `tail` commands are named appropriately – they show the head
    (beginning) and the tail (end) of a text file. They can also be used with a variety
    of options to further parametrize the output that we want. For example, if we
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We're going to get the last 15 lines of that file. The same can be done with
    the `head` command.
  prefs: []
  type: TYPE_NORMAL
- en: Our next topic of discussion is using the `find` command to find files and folders.
    Let's deal with that first and then move on to the next recipes, which are going
    to involve archiving, compression, and dealing with services via `systemctl`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we need to learn more about these commands, we can check the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`head` man page: [https://man7.org/linux/man-pages/man1/head.1.html](https://man7.org/linux/man-pages/man1/head.1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tail` man page: [https://man7.org/linux/man-pages/man1/tail.1.html](https://man7.org/linux/man-pages/man1/tail.1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`more` man page: [https://man7.org/linux/man-pages/man1/more.1.html](https://man7.org/linux/man-pages/man1/more.1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`less` man page: [https://man7.org/linux/man-pages/man1/less.1.html](https://man7.org/linux/man-pages/man1/less.1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cat` man page: [https://man7.org/linux/man-pages/man1/cat.1.html](https://man7.org/linux/man-pages/man1/cat.1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files and folders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next topic of the day is to learn to use the `find` command, an incredibly
    useful command. It can be used in a variety of different ways – to find files
    and folders according to specific criteria (permissions, ownership, modified date,
    and others), but also to *prepare data* to be further manipulated *after* the
    `find` command. We'll go through some examples of both principles in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to leave our `cli1` virtual machine running. If it's not powered on,
    we need to power it back on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s use a couple of examples to explain how the `find` command works. Here
    are some examples that we''re going to use:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding files in the `/` directory that have permission `2755`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files in the `/` directory owned by the user `jill`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files in the `/` directory owned by a group student
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files in the `/` directory with a specific name (for example, `network`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files of a specific type (for example, all files with the `php` extension)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding all empty directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files that have been modified in the past two hours (120 minutes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files that are 100-200 MB in size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s make these scenarios happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To further drive home the importance of this command, let''s use it, as we
    mentioned previously, to *prepare* data to do something *after* we find the necessary
    content. For example, let''s find all files that have the `.avi` extension on
    the whole filesystem and remove them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This command finds all files with the `.avi` extension, puts them in an array,
    and removes them, one by one, by using the `rm -f` command. This is very useful
    if you have users who are abusing corporate resources for unnecessary content.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding files and folders by name is something that we often do. For example,
    let's say that we have a rudimentary shell script that performs a backup and that
    it uses specific criteria to create a list of files that it's going to copy to
    a pre-determined backup folder. If we're doing this kind of operation on a large
    production server with hundreds of users, chances are that there will be a lot
    of new files daily. Using the `find` command makes a lot of sense in these sorts
    of scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Most commonly, we use the `find` command to locate files (`-type f` option)
    or folders (`-type d` option), and then we narrow our search by using more criteria.
    Criteria such as modification date, user or group ownership, permissions – there
    are a lot of options available. If we look at the `find` command man page, we'll
    quickly become painfully aware of how many options and advanced scenarios can
    be covered by using the `find` command. This is why there's a common way of using
    `find`, which is to start with something such as a file type or extension, and
    then narrow it down further by using other options that we mentioned. If we start
    with that in mind, we'll get to our results quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The next recipe on our plate is related to archiving and compressing files and
    folders. So, let's learn how to use `tar` and its sidekicks, `gzip`, `bzip`, `xzip`,
    and commands alike.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to learn more about Bash reserved variables and PS variables, refer
    to the `Find` command man page: `https://man7.org/linux/man-pages/man1/find.1.html.`'
  prefs: []
  type: TYPE_NORMAL
- en: Archiving and compressing files and folders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being efficient in terms of how we use disk space is nothing new – it's always
    been around. Yes, we're at a point in history where large capacity hard drives
    and other media is available, but that doesn't mean we can be reckless about it.
    This is the reason why we've been using archiving and compressing for decades,
    and it's a topic that we're going to cover now as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to make sure that our `cli1` machine is ready to be used, which will
    make our work on this recipe easy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go through another scenario-based example to cover all the necessary
    topics. So, this is what we''re going to do in the first part of our recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `tar` archive with the current folder content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `tar.gz` compressed archive with the current folder content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `tar.bz2` compressed archive with the current folder content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `tar.xz` compressed archive with the current folder content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the second part of our recipe, we''re going to extract these archives:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract a `tar`, `tar.gz`, `tar.bz2`, or `tar.xz` archive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract a `tar`, `tar.gz`, `tar.bz2`, or `tar.xz` archive to a specific folder
    (let's say `/tmp/extract`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s say that we''re located in the `/root` directory, and that we want to
    save all of our archives to the `/tmp` directory. This is how we''d do the first
    part of our scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were creating the `tar.gz` archive, we''d do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were creating the `tar.bz2` archive, we''d do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were creating the `tar.xz` archive, we''d do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of our scenario begins by opening an archive. We just need
    to change one `tar` parameter when compared to the first set of examples in our
    scenario and ditch the last part of our command (`.` for the current directory).
    So, we''d need to do this (don''t do this in the real world; this is merely for
    illustration purposes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this is the location of the output – where''s the output of
    this extraction process going to go? So, the correct way to do this would be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Again, this depends on the archive type.
  prefs: []
  type: TYPE_NORMAL
- en: '`Tar` has a myriad of other available options, for example, for manipulating
    ACLs and SELinux contexts such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--acls` – Use ACLs when creating an archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-acls` – Ignore ACLs when creating an archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--selinux` – Use SELinux contexts when creating an archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--noselinux` – Ignore SELinux contexts when creating an archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot stress how important it is to check the corresponding man page if
    we're looking for something specific. So, we need to make sure that we do.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`tar`, or `Tape ARchiver`, has been around for decades now. Its original use
    case included archiving content on tape, which is how it got its name. Archiving,
    as the manual states, means storing multiple files in a single file. All the other
    options that we use are additional options that have been added over the past
    40+ years, given that it was introduced way back in 1979.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of the parameters used in our examples, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`c` – Create an archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` – Extract an archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` – Or `--file`, to select an output archive filename'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p` – Option to preserve permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C` – Select an output folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`z` – Use `gzip` to compress the `tar` archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`j` – Use `bzip2` to compress the `tar` archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`J` – Use `xzip` to compress the `tar` archive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the most frequently used `tar` parameters, which is why we specifically
    selected those for our recipe.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our `tar` recipe, and we're ready to move on to the final recipe
    in this chapter, which is all about managing services by using the `systemctl`
    command. Let's work on that for a bit.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to learn more about the `tar` command, make sure that you refer
    to the `tar` command man page: [https://man7.org/linux/man-pages/man1/tar.1.html](https://man7.org/linux/man-pages/man1/tar.1.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Managing services and targets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing services tends to be something that we need to do at times. For example,
    when we install a new piece of software that comes bundled as a service, we need
    to be able to manage it so that it can work properly. This is what we're going
    to work on as we go through this recipe. We're also going to give a short description
    of how `systemctl` configuration files work, but without going on a 100 mile-long
    journey, as it's the recipe that's the focus. However, we will make sure that
    we provide you with additional links where you can learn a whole lot more about
    `systemd` as it's a big topic and an important one.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to use our `cli2` CentOS for this recipe, just so that it doesn't
    feel left out.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic idea behind managing services in practical terms is to have services
    start either at the point in time when we want them to be started, or to have
    them available after we boot our Linux server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The management of services and targets became quite a bit easier over the past
    couple of releases of any Linux distribution. If you''ve been using CentOS for
    an extended period, you will probably remember upstart, init, and all those beautiful
    things that will remain buried deep in our not-so-fond memories. In terms of the
    management of services, both from the administrative and *development* perspective
    (we''ll get to that in a sec), things became much easier with CentOS 7\. CentOS
    8 follows the same path. There are, and always will be, differing opinions regarding
    the whole idea of `systemd`, but that''s not the subject at hand here. So, let''s
    focus on services and targets. First, we''ll log in as root and type some commands,
    starting with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to switch our default boot target to multi-user, which means
    that our CentOS machine is going to be booted to text mode by default. So, after
    we reboot the machine, it''s going to be started in text mode. Then, we''re going
    to switch to using text mode instantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is going to kill all the GUI processes, check the service delta between
    `graphical.target` and `multi-user.target`, and do its magic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing that we''re going to do is, we''re going to pick a service (for
    example, `sshd`), and use the `systemctl` command to manage it – both momentarily
    (manage its state at the time of command execution) and permanently (manage what
    happens with the `sshd` service during system boot). Let''s type in these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of these two commands is going to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Using systemctl to manage a service – in this case, the SSH
    service'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.18_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.18 – Using systemctl to manage a service – in this case, the SSH service
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s telling us that `sshd.service` is disabled – Active: inactive (dead).
    We will enable it and check its state by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the result of these last two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Checking the state of the SSH service following a configuration
    change'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.19_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.19 – Checking the state of the SSH service following a configuration
    change
  prefs: []
  type: TYPE_NORMAL
- en: We can see that `sshd.service` is now active and ready to accept network connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another aspect of this, which is to configure a service so that it''s
    enabled on system boot. If we use `sshd.service` as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, if we don''t want `sshd.service` to be enabled on system boot, we can
    do the opposite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When we deploy a new service, we can start and enable it at the same time.
    For example, let''s say that we just installed the `sshd` service from a package.
    Let''s enable and start it by using one command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Of course, that pre-supposes that we know the name of any given service, which
    isn't always the case. Let's learn how to overcome this problem in a text mode-driven
    way before we wrap this scenario up with a summary table to make things easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to list all of the available services, we can use the following
    command, as `systemd` and `systemctl` *know* more objects than just services (not
    the topic of this scenario):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When we were going through one of our previous recipes, we discussed `vdo`.
    We can clearly see the `vdo` service listed here. Remember that we started it
    by using the `systemctl` command?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to check the list of all enabled services, we can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need a list of services running currently, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `systemctl` command – because of how it works and the related config files
    (covered in the *How it works…* section a bit later) – can also list service dependencies.
    For example, the `sshd` service needs some other services to be started so that
    it can work. Let''s list the `sshd` dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, let''s just create a table with some of the most common service
    names so that we can manage this problem more efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.1 – A table with details about services and systemd service names'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16269_05_Table1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.1 – A table with details about services and systemd service names
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the short names of these services (without `.service`) as well as
    the *Tab* key to use Bash shell completion to scroll through options and service
    names in `systemctl`. We can also mask `systemd` services, and therefore make
    them invisible to the system, by linking them from the service start up perspective
    to `/dev/null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can get an idea of how all of this works. The `systemctl` command obviously
    uses some configuration files to do its job. Let's now discuss how and what's
    done.
  prefs: []
  type: TYPE_NORMAL
- en: We could write books about systemd, but having this specific scenario in mind,
    we need to stick to the job at hand. We used the `systemctl` command to manage
    a service – right now (start/stop/restart), and permanently (enable/disable).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the perspective of purely managing services, the `systemctl` command looks
    by checking into its configuration files. So, let''s check the anatomy of a service
    file for `systemd`, again, using `sshd` as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Systemd configuration file – in this example, SSHD'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.20_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.20 – Systemd configuration file – in this example, SSHD
  prefs: []
  type: TYPE_NORMAL
- en: It's almost readable without a lot of explanation, which is one of the big differences
    between these service files and what was used in the past.
  prefs: []
  type: TYPE_NORMAL
- en: The first part, which starts with the `[Unit]` section, is related to the general
    settings of the service – with a description and man pages for documentation being
    the first part of that. Then a statement tells us the order; that is, after which
    services should this specific service be started. `Wants` is related to dependencies
    – in this case, which targets need to be enabled for this service to be successfully
    started.
  prefs: []
  type: TYPE_NORMAL
- en: The `[Service]` section is a bit trickier, as it tells us basic configuration
    details and start up options (the `EnvironmentFile` option), which commands should
    be used for starting and reloading the service, how to kill the service, and details
    related to restarting. Restarting is for selecting if the service will be restarted
    when there's a timeout, kill, or exit from the process service. `RestartSec` is
    about sleep time before the service restart.
  prefs: []
  type: TYPE_NORMAL
- en: The `[Install]` section is a bit more global and related to how `systemd` works
    with this unit. `WantedBy` is used in the sense of creating additional dependencies
    between this specific service and other services, completely opposite to what
    `[Unit]` statements do.
  prefs: []
  type: TYPE_NORMAL
- en: This is why, when we change or create new systemd unit/service/whatever files,
    we have to use the `systemctl daemon-reload` command. That command specifies that
    `systemctl` goes through all the config files and treats them as *yes, the administrator
    might have changed something in any of these files, but this is on purpose and
    OK*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bearing in mind the importance of systemd and its internals, as promised, let''s
    provide our readers with some additional content related to systemd:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Introduction to systemd: `https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/introduction-to-systemd_configuring-basic-system-settings`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Managing system services with systemctl: `https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/managing-system-services-with-systemctl_configuring-basic-system-settings`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with systemd targets: `https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/working-with-systemd-targets_configuring-basic-system-settings`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with systemd unit files: `https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/assembly_working-with-systemd-unit-files_configuring-basic-system-settings`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optimizing systemd to shorten the boot time: `https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/optimizing-systemd-to-shorten-the-boot-time_configuring-basic-system-settings`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Demystifying systemd: `https://www.youtube.com/watch?v=tY9GYsoxeLg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
