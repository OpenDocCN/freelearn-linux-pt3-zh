- en: '*Chapter 15*: Using the Reference Policy'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：使用参考策略'
- en: Up until now, we've covered how to interact with the SELinux subsystem and gradually
    adjusted the SELinux policy to our liking. As we add more applications and users,
    we notice that developing custom SELinux policies might help us tune the system
    more to our liking. There are two main approaches to develop SELinux policies,
    and using reference policy style development is one of them. The other is discussed
    in [*Chapter 16*](B16276_16_Final_VK.xhtml#_idTextAnchor391), *SELinux Common
    Intermediate Language*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何与SELinux子系统进行交互，并逐步调整SELinux策略以满足我们的需求。当我们添加更多的应用程序和用户时，我们会发现开发自定义的SELinux策略可能有助于更好地调整系统。开发SELinux策略有两种主要方法，其中使用参考策略样式开发是其中之一。另一个方法在[*第16章*](B16276_16_Final_VK.xhtml#_idTextAnchor391)中讨论，*SELinux通用中间语言*。
- en: 'To properly develop an SELinux policy, we''ll learn how to use and understand
    the macros that the reference policy provides, and apply the main coding and development
    style patterns that the project requires to ensure consistency across SELinux
    policy modules. We then apply this to two main types of modules: application policies
    and user policies.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地开发SELinux策略，我们将学习如何使用和理解参考策略提供的宏，并应用项目所要求的主要编码和开发风格模式，以确保SELinux策略模块之间的一致性。然后，我们将其应用于两种主要类型的模块：应用程序策略和用户策略。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: Introducing the reference policy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍参考策略
- en: Using and understanding the policy macros
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和理解策略宏
- en: Creating application-level policies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建应用程序级别的策略
- en: Getting help with supporting tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取支持工具的帮助
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found in our Git repository at [https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition](https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在我们的Git仓库中找到：[https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition](https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3jcBDvI](https://bit.ly/3jcBDvI)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/3jcBDvI](https://bit.ly/3jcBDvI)
- en: Introducing the reference policy
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍参考策略
- en: The reference policy, available through [https://github.com/SELinuxProject/refpolicy](https://github.com/SELinuxProject/refpolicy),
    is the source SELinux policy for most, if not all, Linux distributions out there.
    While it is possible that the plain reference policy will not work out of the
    box for any Linux distribution (as many Linux distributions add their own touch
    to the policy, or adjust it so it fits the applications and support tooling installed),
    the development methodology, structure, and approach used by the reference policy
    are applicable to all major distribution policies.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过[https://github.com/SELinuxProject/refpolicy](https://github.com/SELinuxProject/refpolicy)提供的参考策略是大多数（如果不是全部）Linux发行版的源SELinux策略。虽然纯粹的参考策略可能无法直接在任何Linux发行版上使用（因为许多Linux发行版会对策略进行自定义或调整，以适应安装的应用程序和支持工具），但参考策略使用的开发方法、结构和方式适用于所有主要的发行版策略。
- en: 'We recommend checking out the SELinux policy of your distribution to see and
    easily modify SELinux policies for the system. In this chapter, we''ll use a checkout
    of the reference policy:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议查看你所在发行版的SELinux策略，以查看并轻松修改系统的SELinux策略。在本章中，我们将使用参考策略的一个版本：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The SELinux policy repositories for the Linux distributions should be documented
    by the distributions themselves. A few example repositories are listed next:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Linux发行版的SELinux策略库应由发行版本身进行文档化。以下列出了几个示例库：
- en: For CentOS, the policy repository can be found at [https://github.com/fedora-selinux/selinux-policy](https://github.com/fedora-selinux/selinux-policy).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于CentOS，可以在[https://github.com/fedora-selinux/selinux-policy](https://github.com/fedora-selinux/selinux-policy)找到策略库。
- en: For Gentoo Linux, the policy repository can be found at [https://gitweb.gentoo.org/proj/hardened-refpolicy.git/](https://gitweb.gentoo.org/proj/hardened-refpolicy.git/).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Gentoo Linux，可以在[https://gitweb.gentoo.org/proj/hardened-refpolicy.git/](https://gitweb.gentoo.org/proj/hardened-refpolicy.git/)找到策略库。
- en: For Debian, the policy repository can be found at [https://salsa.debian.org/cgzones/selinux-policy-debian](https://salsa.debian.org/cgzones/selinux-policy-debian).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Debian，可以在[https://salsa.debian.org/cgzones/selinux-policy-debian](https://salsa.debian.org/cgzones/selinux-policy-debian)找到策略库。
- en: For Arch Linux, the policy repository can be found at [https://github.com/archlinuxhardened/selinux-policy-arch/](https://github.com/archlinuxhardened/selinux-policy-arch/).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Arch Linux，策略库可以在 [https://github.com/archlinuxhardened/selinux-policy-arch/](https://github.com/archlinuxhardened/selinux-policy-arch/)
    找到。
- en: If the Linux distribution does not have a publicly reachable repository for
    its SELinux policy, we can often still obtain it through the packages themselves,
    as used in [*Chapter 12*](B16276_12_Final_VK.xhtml#_idTextAnchor312), *Working
    with SELinux Policies*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Linux 发行版没有公开可访问的 SELinux 策略库，我们通常仍然可以通过软件包本身获得它，如 [*第 12 章*](B16276_12_Final_VK.xhtml#_idTextAnchor312)
    中所使用的，*与 SELinux 策略一起工作*。
- en: While it is not the intention to do full policy rebuilds, we can easily copy
    over the necessary policy files to our own development environment and fine-tune
    or extend the policy as needed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们并不打算进行完整的策略重建，但我们可以轻松地将必要的策略文件复制到自己的开发环境中，并根据需要调整或扩展策略。
- en: Navigating the policy
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航策略
- en: 'At its base directory, the reference policy hosts all the common files for
    building the policies, explaining how to install them, and so forth. The policy
    itself is in the `policy` folder, which contains three directories:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在其基础目录中，参考策略托管所有用于构建策略的公共文件，说明如何安装这些策略等。策略本身位于 `policy` 文件夹中，该文件夹包含三个目录：
- en: '`flask` contains the initial definitions used to jumpstart SELinux, such as
    listing the supported classes, creating initial security identifiers, and more.
    We will not touch this location further.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flask` 包含用于启动 SELinux 的初始定义，如列出支持的类、创建初始安全标识符等。我们将不再进一步讨论这个位置。'
- en: '`modules` contains the SELinux policy code and is the main location for all
    policy rules.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modules` 包含 SELinux 策略代码，是所有策略规则的主要位置。'
- en: '`support` contains macros and definitions that are reused across the policy
    and are not associated with a single policy module.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`support` 包含在策略中重用的宏和定义，这些宏和定义不与单个策略模块相关联。'
- en: 'If we enter the `modules` directory further, we get directories that represent
    the type of modules or policies contained. This representation by itself is merely
    to have some structure across the hundreds of modules that are developed:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进一步进入 `modules` 目录，就会得到表示模块或策略类型的目录。此表示本身只是为了在开发的数百个模块中有一些结构：
- en: '`admin` contains system administration related policy modules.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin` 包含与系统管理相关的策略模块。'
- en: '`apps` contains general application policy modules.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apps` 包含一般应用程序的策略模块。'
- en: '`kernel` contains core system policy modules (not just kernel related ones).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kernel` 包含核心系统策略模块（不仅仅是与内核相关的模块）。'
- en: '`roles` contains SELinux role definitions and default user domain policy modules.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roles` 包含 SELinux 角色定义和默认用户域策略模块。'
- en: '`services` contains general service policy modules (and is by far the largest
    set of policy modules).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`services` 包含一般服务策略模块（也是最多的策略模块集合）。'
- en: '`system` contains common system related policy modules.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system` 包含常见的系统相关策略模块。'
- en: 'The interpretation of which folder a policy is placed in is left to the reference
    policy project itself, and discussed on its mailing list when it is not obvious.
    As policy files are required to have a unique name, we can find the appropriate
    location easily. For instance, to see where the `ipsec` policy module is stored:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 策略放置在哪个文件夹中的解释留给参考策略项目本身，如果不明显，会在其邮件列表中讨论。由于策略文件需要有唯一的名称，我们可以轻松找到合适的位置。例如，要查看
    `ipsec` 策略模块存储的位置：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While browsing, you'll notice that the policy modules are always represented
    by three files, which we describe next.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览时，你会注意到策略模块总是由三个文件组成，我们接下来会描述这些文件。
- en: Structuring policy modules
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化策略模块
- en: 'If we analyze an SELinux policy module''s code, such as for the `dhcp` module
    in the `services` folder, we''ll notice that it has three files associated with
    it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分析一个 SELinux 策略模块的代码，例如 `services` 文件夹中的 `dhcp` 模块，我们会注意到它与三个文件相关联：
- en: '`dhcp.te`, which contains the type enforcement rules, and is the main area
    of attention for most changes'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dhcp.te` 包含类型强制规则，是大多数更改的主要关注区域。'
- en: '`dhcp.fc`, which contains the file context definitions, informing the policy
    which files or resources need to be labeled with `dhcp` related SELinux types'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dhcp.fc` 包含文件上下文定义，告知策略哪些文件或资源需要标记为与 `dhcp` 相关的 SELinux 类型。'
- en: '`dhcp.if`, which contains interface definitions, which are reusable functions
    or macros that can be used in the `dhcp` SELinux policy code as well as elsewhere'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dhcp.if` 包含接口定义，它是可以在 `dhcp` SELinux 策略代码及其他地方重复使用的函数或宏。'
- en: Let's quickly see how each of these files is structured.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一下这些文件的结构。
- en: Understanding type enforcement files
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解类型强制文件
- en: 'The type enforcement file, `dhcp.te` in our example, has the following structure:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 类型强制文件，例子中是 `dhcp.te`，具有以下结构：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's look at each of these areas with an example.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来逐一看看这些内容。
- en: Declaring SELinux objects
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 声明 SELinux 对象
- en: The `Declarations` section in a policy tells us what SELinux types, or other
    SELinux objects such as SELinux booleans and SELinux roles, are defined within
    this module.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 策略中的`声明`部分告诉我们在该模块内定义了哪些 SELinux 类型，或者其他 SELinux 对象，如 SELinux 布尔值和 SELinux 角色。
- en: 'The following declarations are common in SELinux policies:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下声明在 SELinux 策略中是常见的：
- en: 'The first declaration in the `dhcp` SELinux policy declares an SELinux boolean
    for this module. It is best practice to start the boolean with the SELinux policy
    module name, although in this case the choice is made to explicitly use `dhcpd`
    rather than `dhcp` to make it obvious for administrators it is about the DHCP
    daemon and not possible clients or other use cases:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dhcp` SELinux 策略中的第一个声明声明了该模块的 SELinux 布尔值。最好将布尔值以 SELinux 策略模块名称开头，尽管在此情况下，选择明确使用
    `dhcpd` 而不是 `dhcp`，以便管理员可以明显知道这是关于 DHCP 守护进程，而不是可能的客户端或其他用例：'
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The SELinux boolean is accompanied by a specifically structured comment. Comments
    within the reference policy that use a double hash prefix (`##`) will be parsed
    by the build code and used to update information outside of the SELinux policy.
    In this case, the description of the SELinux boolean is created, which will be
    made visible later on through commands such as `semanage boolean`.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SELinux 布尔值伴随着一个特定结构的注释。在参考策略中，使用双哈希前缀（`##`）的注释将被构建代码解析，并用于更新 SELinux 策略外的信息。在这种情况下，会创建
    SELinux 布尔值的描述，稍后通过如 `semanage boolean` 等命令显示出来。
- en: Once a module is loaded that defines an SELinux policy, other modules can use
    this boolean as well.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦加载了定义 SELinux 策略的模块，其他模块也可以使用这个布尔值。
- en: 'Some domains might also declare a role attribute, which allows easy management
    of which roles are allowed to use the domain:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些域可能还会声明角色属性，这可以轻松管理哪些角色可以使用该域：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The rest of the declarations in the `dhcp` SELinux policy declare the SELinux
    types that the policy owns:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dhcp` SELinux 策略中的其余声明声明了该策略拥有的 SELinux 类型：'
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: SELinux policy modules in the reference policy only declare the types and other
    objects that they own, not those they use. The objects used but defined by other
    modules should always be hidden away and interacted with through the interface
    calls.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考策略中的 SELinux 策略模块仅声明它们拥有的类型和其他对象，而不包括它们使用的对象。由其他模块定义但使用的对象应该始终被隐藏，并通过接口调用进行交互。
- en: While other definitions can be added to the section as well, these are the most
    common. Next up are the local policy rules.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其他定义也可以添加到此部分，但这些是最常见的。接下来是本地策略规则。
- en: Adding the domain's local rules
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加域的本地规则
- en: The local policy within the type enforcement defines the allowed behavior of
    the domains owned by the SELinux policy module. For the `dhcp` SELinux policy
    module, this is only focusing on the `dhcpd_t` SELinux domain. Other SELinux policy
    modules, especially if they offer a more fine-grained policy structure, will do
    this for several of its own SELinux domains, or even SELinux user roles.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 类型强制内的本地策略定义了由 SELinux 策略模块拥有的域的允许行为。对于 `dhcp` SELinux 策略模块，这只关注 `dhcpd_t` SELinux
    域。其他 SELinux 策略模块，尤其是如果它们提供更细粒度的策略结构，会对多个 SELinux 域或甚至 SELinux 用户角色进行定义。
- en: 'Let''s go through the SELinux policy rules for the `dhcp.te` example we are
    looking at:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一看我们正在查看的 `dhcp.te` 示例中的 SELinux 策略规则：
- en: 'The policy starts with the internal SELinux rules, which are interactions between
    the SELinux types owned by the SELinux policy module itself:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略从 SELinux 内部规则开始，这些规则是 SELinux 策略模块本身拥有的 SELinux 类型之间的交互：
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The most simple rules are the standard `allow` rules, similar to those that
    `audit2allow` would recommend. These `allow` rules can refer to support macros
    (such as `signal_perms`), which we'll discuss in the *Using and understanding
    the policy macros* section. The second line, which is a call to `manage_files_pattern`,
    is also a support macro.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最简单的规则是标准的`allow`规则，类似于 `audit2allow` 推荐的规则。这些 `allow` 规则可以引用支持宏（例如 `signal_perms`），我们将在
    *使用和理解策略宏* 部分进行讨论。第二行，调用 `manage_files_pattern`，也是一个支持宏。
- en: 'The second set of local policy definitions are the core interfaced SELinux
    rules:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二组本地策略定义是核心接口化SELinux规则：
- en: '[PRE7]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These calls use the code that another SELinux policy module has defined in its
    interface file. In the case of the `kernel_read_system_state` interface, this
    will grant the `dhcpd_t` SELinux domain the rights to read `proc_t` labeled resources.
    As `proc_t` is not defined by the `dhcp` SELinux policy module, an interface call
    has to be used.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些调用使用由另一个SELinux策略模块在其接口文件中定义的代码。在`kernel_read_system_state`接口的情况下，这将授予`dhcpd_t`
    SELinux域读取`proc_t`标记资源的权限。由于`proc_t`未由`dhcp` SELinux策略模块定义，因此必须使用接口调用。
- en: Core interfaced SELinux rules are rules that should at all times be available
    to the system. Unlike application related SELinux policy modules, which can be
    disabled or unloaded, these core rules are associated with type definitions that
    cannot be removed from the system or disabled at will.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 核心接口化SELinux规则是始终应当对系统可用的规则。与可以禁用或卸载的应用程序相关SELinux策略模块不同，这些核心规则与类型定义相关，无法从系统中删除或随意禁用。
- en: 'The third set of local policy definitions are the SELinux boolean controlled
    calls:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三组本地策略定义是由SELinux布尔值控制的调用：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the SELinux interface calls (which can also be standard rules such as
    `allow` rules) are surrounded by a `tunable_policy()` call, which identifies the
    SELinux boolean (in our case `dhcpd_use_ldap`) that will influence the SELinux
    policy rules. Most policy modules will only have a single block (for the rules
    that are activated if the SELinux boolean is true) but it is possible to have
    two blocks, where the second one defines the rules in case the SELinux boolean
    is false.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，SELinux接口调用（也可以是标准规则，如`allow`规则）被一个`tunable_policy()`调用包围，该调用标识将影响SELinux策略规则的SELinux布尔值（在我们的例子中是`dhcpd_use_ldap`）。大多数策略模块只会有一个块（用于激活的规则，如果SELinux布尔值为true），但也可以有两个块，其中第二个块定义了如果SELinux布尔值为false时的规则。
- en: 'The final set of local policy definitions are the non-blocking interfaced SELinux
    rules:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终的本地策略定义集是非阻塞的接口化SELinux规则：
- en: '[PRE9]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These are the calls that use definitions provided by other SELinux policy modules,
    but where these SELinux policy modules might not be loaded on the system.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些是使用其他SELinux策略模块提供的定义的调用，但这些SELinux策略模块可能并未在系统中加载。
- en: In our example, the `bind_read_dnssec_keys()` call allows the `dhcpd_t` SELinux
    domain to read `dnssec_t` labeled resources, as defined by the bind SELinux policy
    module. However, BIND might not be installed on the system, and the Linux distribution
    might thus not have its policy loaded. So this call is optional and only active
    if the bind SELinux policy module is loaded.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的示例中，`bind_read_dnssec_keys()`调用允许`dhcpd_t` SELinux域读取`dnssec_t`标记的资源，这是由bind
    SELinux策略模块定义的。然而，BIND可能未安装在系统上，因此Linux发行版可能没有加载其策略。因此，这个调用是可选的，只有在bind SELinux策略模块加载时才会激活。
- en: The type enforcement file is the file that will change most often. The file
    context definition file, which we discuss next, is a close second.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类型强制文件是最常变化的文件。接下来我们讨论的文件上下文定义文件紧随其后。
- en: Declaring file contexts
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明文件上下文
- en: The file context definition file, with the `.fc` suffix, tells the SELinux subsystem
    what SELinux types have to be associated with the file resources on the system.
    This information is used by tools such as `restorecon` to reset the context appropriately.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 文件上下文定义文件，带有`.fc`后缀，告诉SELinux子系统哪些SELinux类型必须与系统上的文件资源关联。此信息由`restorecon`等工具使用，以适当重置上下文。
- en: 'The rules inside the file are generally grouped based on the directory for
    which the rules apply. Each rule is structured like so:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的规则通常按规则适用的目录进行分组。每条规则的结构如下：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s see what these entries imply:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些条目意味着什么：
- en: The *path expressions* are the same ones we saw in [*Chapter 4*](B16276_04_Final_VK.xhtml#_idTextAnchor095),
    *Using File Contexts and Process Domains*. Keep in mind that characters such as
    dot (`.`) have a specific meaning (in this case, it reflects any possible character)
    so that paths that really require a dot inside must escape the dot.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*路径表达式*与我们在[*第4章*](B16276_04_Final_VK.xhtml#_idTextAnchor095)中看到的一样，*使用文件上下文和进程域*。请记住，像点号（`.`）这样的字符有特定含义（在此情况下，它表示任何可能的字符），因此真正需要在路径中使用点号时，必须对点号进行转义。'
- en: The *type/class* is an optional setting. If omitted, then it means any possible
    class is used. The most common values to use are regular files (`--`), directories
    (`-d`), sockets (`-s`), and symbolic links (`-l`).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类型/类别* 是一个可选的设置。如果省略，则意味着使用任何可能的类别。最常见的值有常规文件（`--`）、目录（`-d`）、套接字（`-s`）和符号链接（`-l`）。'
- en: The *context* is a reference to the target SELinux type for this resource. In
    the reference policy, these context references always need to be encased by the
    `gen_context()` macro, which will add or remove the sensitivity depending on the
    MLS or MCS support built inside the policy.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上下文* 是对该资源目标 SELinux 类型的引用。在参考策略中，这些上下文引用总是需要被 `gen_context()` 宏包裹，这样会根据策略中内置的
    MLS 或 MCS 支持来添加或移除敏感度。'
- en: 'Let''s look at a simple example from the `dhcp` SELinux policy module:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个来自 `dhcp` SELinux 策略模块的简单示例：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the `/var/named/data` directory, and any resource below it,
    will be labeled with the `named_cache_t` SELinux type.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`/var/named/data` 目录及其下的所有资源，将被标记为 `named_cache_t` SELinux 类型。
- en: The last file that is associated with an SELinux policy module is the interface
    definition file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SELinux 策略模块相关的最后一个文件是接口定义文件。
- en: Exposing SELinux rules through interfaces
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过接口暴露 SELinux 规则
- en: Interfaces within an SELinux policy module are meant to support a more flexible,
    modular development of SELinux policies across different modules. Whenever a domain
    or SELinux role needs to interact with resources that are defined in a different
    SELinux policy module, that module should create a properly named interface for
    the interaction.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 策略模块中的接口旨在支持在不同模块之间更灵活、模块化的 SELinux 策略开发。每当一个域或 SELinux 角色需要与在另一个 SELinux
    策略模块中定义的资源进行交互时，该模块应该为该交互创建一个正确命名的接口。
- en: Interfaces should be accompanied by a minimal amount of documentation, although
    this documentation is only used when building the documentation of the entire
    policy. When this is done, the resulting documentation is made available on the
    system, for instance in `/usr/share/doc/selinux-policy/html`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接口应该附带最少量的文档，尽管这些文档仅在构建整个策略文档时使用。当构建完成时，生成的文档会在系统上提供，例如在 `/usr/share/doc/selinux-policy/html`。
- en: 'Let''s look at the definition for the `dhcpd_domtrans()` interface:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 `dhcpd_domtrans()` 接口的定义：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As is best practice, the interface name starts with the SELinux policy name
    and is followed by the action that is allowed. Sometimes, this action is suffixed
    with the target resource. The interface itself can reference the arguments passed
    along to the interface using `$1` (first argument), `$2` (second argument), and
    so on. So a call such as `dhcpd_domtrans(init_t)` will have the interface called,
    where `$1` is substituted with `init_t`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 按照最佳实践，接口名称以 SELinux 策略名称开头，后面跟着允许的操作。有时，这个操作会加上目标资源的后缀。接口本身可以通过 `$1`（第一个参数）、`$2`（第二个参数）等引用传递给接口的参数。所以像
    `dhcpd_domtrans(init_t)` 这样的调用会调用接口，其中 `$1` 会被替换为 `init_t`。
- en: 'Let''s look at a few examples with common actions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个常见操作的示例：
- en: '`dhcpd_domtrans()`). If there are multiple domains, then the target resource
    will define which domain (as with `bind_domtrans_ndc()`) to allow a domain transition
    to the `ndc_t` SELinux domain.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dhcpd_domtrans()`。如果有多个域，则目标资源将定义允许哪个域（如 `bind_domtrans_ndc()`）进行到 `ndc_t`
    SELinux 域的域转换。'
- en: '`dhcpd_setattr_state_files()` allows the domain to set the attributes of the
    `dhcpd_state_t` labeled resources, whereas `bind_signal()` allows the domain to
    send signals to the `named_t` labeled processes. Most of the interface definitions
    will be permission interactions.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dhcpd_setattr_state_files()` 允许域设置 `dhcpd_state_t` 标签资源的属性，而 `bind_signal()`
    允许域向 `named_t` 标签进程发送信号。大多数接口定义将涉及权限交互。'
- en: '`dhcpd_admin()` role will allow managing the `dhcpd` related resources, starting
    and stopping the `dhcpd` service, and so on.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dhcpd_admin()` 角色将允许管理与 `dhcpd` 相关的资源，启动和停止 `dhcpd` 服务等。'
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While developing SELinux policies, it is recommended to look into the interface
    definitions of the SELinux policy modules to see which ones exist and what they
    provide. Policy developers will put often requested permissions in such interfaces,
    so the available interfaces give a good view of what you will most likely need
    for your own SELinux policy module.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 SELinux 策略时，建议查看 SELinux 策略模块的接口定义，了解哪些接口存在以及它们提供了什么。策略开发人员通常会将常见的权限放入这些接口中，因此可用的接口可以很好地显示你可能需要的
    SELinux 策略模块内容。
- en: 'The interface definitions are also made available on the system at `/usr/share/selinux/devel/include`
    so that you can create and modify SELinux policy modules even without checking
    out the main source repository. Whenever we build a reference policy style module,
    we use a command like the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义也可以在系统的 `/usr/share/selinux/devel/include` 位置找到，这样即使不检查主源代码库，你也可以创建和修改 SELinux
    策略模块。每当我们构建参考策略风格的模块时，都会使用如下命令：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will cause the build process to look for the interfaces inside the `/usr/share/selinux/devel/include`
    location, as well as inside the current working directory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致构建过程查找 `/usr/share/selinux/devel/include` 位置中的接口，同时也会在当前工作目录中查找。
- en: Using and understanding the policy macros
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用和理解策略宏
- en: Across the various SELinux policy definitions, we have come across macros that
    are not tied to a specific SELinux policy module. These are support macros, available
    inside the `policy/support/*.spt` files.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种 SELinux 策略定义中，我们遇到了一些不与特定 SELinux 策略模块绑定的宏。这些是支持宏，位于 `policy/support/*.spt`
    文件中。
- en: The most common macros are those declared inside the `obj_perm_sets.spt` file
    (which group common permissions for the same class in a single definition) and
    the `*_patterns.spt` files (which group permissions across different classes in
    a single definition).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的宏是在 `obj_perm_sets.spt` 文件中声明的（该文件将同一类别的常见权限组合为一个定义），以及 `*_patterns.spt`
    文件（将跨不同类别的权限组合为一个定义）。
- en: Making use of single-class permission groups
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用单一类别权限组
- en: '`execute` permission. You also need the `open` and `read` permissions (as otherwise,
    the domain cannot read the executable) and the `map` permission (to allow mapping
    the file in memory).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute` 权限。你还需要 `open` 和 `read` 权限（否则域无法读取可执行文件），以及 `map` 权限（以允许将文件映射到内存中）。'
- en: 'If you were to put all these permissions in your own SELinux policy module,
    then the rule could look like so:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将所有这些权限放入你自己的 SELinux 策略模块中，那么规则可能会是这样：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If, later on, the SELinux policy is extended with an additional permission that
    is associated with executing resources, then you will need to look for and update
    these permissions all over the different SELinux policy modules.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以后 SELinux 策略扩展了一个与执行资源相关的新权限，那么你将需要在不同的 SELinux 策略模块中查找并更新这些权限。
- en: 'So the reference policy moves all these permissions in a macro called `exec_file_perms`,
    defined as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，参考策略将所有这些权限放入名为 `exec_file_perms` 的宏中，其定义如下：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this macro defined, our policy line can be simplified as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这个宏后，我们的策略行可以简化如下：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If at any point the permissions need to be extended, all that has to happen
    is to extend the macro definition itself, and the SELinux policy modules can be
    left untouched.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某个时刻需要扩展权限，只需扩展宏定义本身，SELinux 策略模块可以保持不变。
- en: Calling permission groups
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用权限组
- en: While single-class permission groups are a good use for simplifying policy development,
    **permission groups** that cover multiple classes are even more common.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单一类别的权限组适用于简化策略开发，但涵盖多个类别的**权限组**更加常见。
- en: For instance, if a domain needs full management privileges (implying `read`,
    `write`, as well as creating and removing resources) on resources inside `/var/lib/dhcpd`,
    then not only are these privileges needed on the files inside that directory (which
    are labeled with the `dhcpd_state_t` SELinux type), but you also need read/write
    permissions on the directory itself.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果某个域需要对 `/var/lib/dhcpd` 中的资源具有完整的管理权限（意味着 `read`、`write`，以及创建和删除资源），那么不仅这些权限在该目录中的文件上是必要的（这些文件被标记为
    `dhcpd_state_t` SELinux 类型），你还需要对该目录本身的读/写权限。
- en: 'Such a privilege definition would result in something like so:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的权限定义可能会是这样：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Rather than declaring these as separate calls, they can be put into a single
    one that groups the two:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与其将这些声明为单独的调用，不如将它们组合到一个调用中：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: SELinux policy developers best get acquainted with the various macros available
    to allow for rapid and efficient SELinux policy development.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 策略开发者最好熟悉各种可用的宏，以便快速高效地进行 SELinux 策略开发。
- en: Creating application-level policies
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用级别策略
- en: 'Application-level policies provide confinement for applications or services.
    There are a number of different types of application-level policies around:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 应用级别的策略为应用程序或服务提供隔离。有多种不同类型的应用级别策略：
- en: End user application policies, which focus on accessing end user data, and will
    often call various `userdom_*` interfaces (which are provided through the `system/userdomain.if`
    file). Most of these applications are inside the `apps/` directory).
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端用户应用程序策略，主要关注访问终端用户数据，并且通常会调用各种`userdom_*`接口（这些接口通过`system/userdomain.if`文件提供）。这些应用程序大多位于`apps/`目录下。
- en: Administration applications, which are still user-facing, are more likely to
    enable interacting with system services and resources.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理应用程序，尽管仍面向用户，但更可能启用与系统服务和资源的交互。
- en: Services, which are generally daemonized applications, often interact mostly
    with their own resources and have a simpler structure.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务，通常是守护进程化的应用程序，通常主要与自己的资源交互，并且结构较为简单。
- en: When we covered the `sepolicy generate` command in [*Chapter 14*](B16276_14_Final_VK.xhtml#_idTextAnchor354),
    *Dealing with New Applications*, we could select these types (and more) to generate
    a simple skeleton for those applications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第14章*](B16276_14_Final_VK.xhtml#_idTextAnchor354)《处理新应用程序》中介绍`sepolicy
    generate`命令时，我们可以选择这些类型（以及更多）来为这些应用程序生成一个简单的骨架。
- en: Let's look into some example policies and identify useful calls that you might
    need when developing your own policies.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例策略，并识别在开发自己策略时可能需要的有用调用。
- en: Constructing network-facing service policies
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建面向网络的服务策略
- en: Services that are network-facing (meaning they can be interacted with from outside
    the system itself) are the first set of services that need to be confined. Hence,
    building SELinux policy modules for network-facing services should be a primary
    focus of any Linux administrator that needs to ensure the confinement of applications
    that do not have a working policy yet.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 面向网络的服务（即可以从系统外部进行交互的服务）是需要被限制的第一批服务。因此，为面向网络的服务构建SELinux策略模块应该是任何需要确保尚未有有效策略的应用程序被限制的Linux管理员的主要关注点。
- en: If we look at the OpenVPN service, then we find that there is an SELinux policy
    under `services/openvpn.te` that we can look into.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看OpenVPN服务，发现`services/openvpn.te`下有一个SELinux策略，我们可以查看。
- en: Identifying the resources that the service interacts with
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定服务与哪些资源进行交互
- en: 'As a policy starts with identifying the types and other SELinux objects, we
    need to consider the resources on the system that the service interacts with.
    When comparing service policies with each other, you''ll notice that the definitions
    are often very similar:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于策略始于识别类型和其他SELinux对象，我们需要考虑系统中服务交互的资源。在比较服务策略时，你会发现这些定义通常非常相似：
- en: 'The main domain type and its entry point executable are declared first. Depending
    on the type of service, it contains a call as to how it would be started: as a
    system service (using `init_daemon_domain()`) or through the D-Bus system bus
    (using `dbus_system_domain()`).'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先声明主域类型及其入口可执行文件。根据服务类型，它包含了如何启动该服务的调用：作为系统服务（使用`init_daemon_domain()`）或通过D-Bus系统总线（使用`dbus_system_domain()`）。
- en: The configuration files for the service (such as `openvpn_etc_t`), which could
    also differentiate between read-only files and read-write (such as `openvpn_etc_rw_t`).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务的配置文件（例如`openvpn_etc_t`），这些文件也可以区分只读文件和可读写文件（例如`openvpn_etc_rw_t`）。
- en: Runtime files (which are generally stored in `/var/run`) such as `openvpn_runtime_t`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时文件（通常存储在`/var/run`中），例如`openvpn_runtime_t`。
- en: Temporary files (which are generally stored in `/tmp` or `/var/tmp`) such as
    `openvpn_tmp_t`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时文件（通常存储在`/tmp`或`/var/tmp`中），例如`openvpn_tmp_t`。
- en: Log files (which are generally stored in `/var/log`) such as `openvpn_var_log_t`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志文件（通常存储在`/var/log`中），例如`openvpn_var_log_t`。
- en: Each of the type declarations is followed by a call that marks the type appropriately.
    For instance, the `logging_log_file()` call will associate the type with the logfile
    SELinux attribute. This allows general logfile management domains to deal with
    the newly created resource through this attribute.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型声明后面跟着一个调用，它会正确地标记该类型。例如，`logging_log_file()`调用会将类型与日志文件SELinux属性关联。这使得一般的日志文件管理域能够通过此属性处理新创建的资源。
- en: Handling the internal SELinux rules
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理内部SELinux规则
- en: With the resources declared, we have to define the internal SELinux rules within
    the SELinux policy. These rules tell SELinux what the domain can do with its own
    resources, and how SELinux should behave when the resources are interacted with.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了资源后，我们必须在SELinux策略中定义内部的SELinux规则。这些规则告诉SELinux域可以如何处理其自己的资源，以及当资源被交互时，SELinux应如何行为。
- en: 'We will generally have two sets of internal rules declared. One is the fine-grained
    permissions of the domain itself, such as if the domain is allowed to have any
    capabilities, creating sockets, and so on. The development of these rules is trial-and-error
    based: start with close to no permissions, see what AVC denials come up, extend
    the policy, and repeat.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会声明两组内部规则。一组是域本身的细粒度权限，例如是否允许该域拥有任何能力、创建套接字等。这些规则的开发是基于试错的：从几乎没有权限开始，查看哪些AVC拒绝出现，扩展策略，然后重复。
- en: The other set of internal rules focuses on the interaction with the types declared
    earlier on. This not only includes which permissions the domain has (such as through
    the `manage_files_pattern()` calls) but also whether transitions have to occur.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组内部规则侧重于与之前声明的类型的交互。这不仅包括域拥有的权限（例如通过`manage_files_pattern()`调用），还包括是否必须发生过渡。
- en: 'Setting the right set of transitions is one of the more important first steps
    to take while developing application policies because `audit2allow` and AVC denials
    generally do not consider the fact that a target resource has the wrong type assigned.
    So when we have a service that creates files in `/tmp` (which is labeled as `tmp_t`),
    we really want the target files to be labeled correctly (such as `openvpn_tmp_t`)
    and not inherit the `tmp_t` label from the directory:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 设置正确的过渡集是开发应用策略时需要采取的更重要的第一步之一，因为`audit2allow`和AVC拒绝通常没有考虑到目标资源被分配了错误类型这一事实。因此，当我们有一个在`/tmp`中创建文件的服务时（该目录被标记为`tmp_t`），我们真的希望目标文件被正确标记（如`openvpn_tmp_t`），而不是继承目录的`tmp_t`标签：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'File transitions should be declared for all the resources involved. If a transition
    has to occur for both files and directories, you can mix the classes in a single
    call like so:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 文件过渡应为所有涉及的资源声明。如果文件和目录都需要发生过渡，可以在一次调用中混合类，如下所示：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can also tell SELinux that a transition should only occur if a specific
    filename is used:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以告诉SELinux，仅在使用特定文件名时才应该发生过渡：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is really recommended to first consider the file transitions (and other resource
    transitions) before expanding the actual permissions for the domain to make sure
    that we are not tempted to allow the domain privileges to general types when that
    is not necessary.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议在扩展域的实际权限之前，首先考虑文件过渡（和其他资源过渡），以确保我们不会因为不必要的原因而允许域的权限应用到一般类型。
- en: Adding network related permissions
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加网络相关的权限
- en: While developing and expanding the policy, several core functions will be added,
    such as the `kernel_*` calls to allow processes to interact with the `proc_t`
    resources, system control settings, and more. Tools such as `audit2allow` will
    reasonably be able to deduce the right interfaces to call, although it does not
    hurt to review the interfaces to make sure not too many privileges are assigned.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发和扩展策略时，将添加几个核心功能，如`kernel_*`调用，允许进程与`proc_t`资源、系统控制设置等进行交互。像`audit2allow`这样的工具可以合理地推断出正确的接口进行调用，尽管检查接口以确保不会分配过多权限也是有益的。
- en: Network related permissions on the other hand might require some more attention.
    As we saw in [*Chapter 5*](B16276_05_Final_VK.xhtml#_idTextAnchor138), *Controlling
    Network Communications*, SELinux can dynamically address certain network flows
    based on the system configuration.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，网络相关的权限可能需要更多关注。正如我们在[*第5章*](B16276_05_Final_VK.xhtml#_idTextAnchor138)中看到的，*控制网络通信*，SELinux可以根据系统配置动态处理某些网络流量。
- en: 'It is likely that systems who do not have specific controls in place, such
    as labelled networking or SECMARK, will find that three interface calls could
    allow the application to work as intended:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统没有特别的控制措施，例如标签化的网络或SECMARK，则很可能会发现三个接口调用可以让应用程序按预期工作：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: These three interface calls allow the domain to be network-oriented (`corenet_tcp_bind_generic_node`),
    listen to the OpenVPN port (`corenet_tcp_bind_openvpn_port`), as well as connecting,
    as a client, to HTTP ports (`corenet_tcp_connect_http_port`).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: But other calls exist that you might need to add, even though they are currently
    not detected. They might become necessary when the system is tuned further, such
    as adding support for labeled networking or introducing SECMARK filtering.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'The first set is to allow sending and receiving packets on generic nodes (hosts)
    and interfaces:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For NetLabel support, you might need to add support to receive labeled network
    packets:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For SECMARK support, you need to add support for sending and receiving SECMARK
    labeled packets:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These calls might not show up in early tests, but could be needed later on,
    and it is recommended to consider the impact of labeled networking and SECMARK
    on your policy from the beginning.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Building the service interface methods
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We next focus our efforts on the interface methods. These are used to facilitate
    other SELinux policy modules to interact with the domain we're developing, although
    they can also be used to simplify policy development for your own policy.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'The three most common interfaces to define, and which other policy developers
    will assume exist, are the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: A `openvpn_domtrans`, allowing the given SELinux domain to execute the appropriate
    binaries or scripts and have the executed commands or applications run in our
    domain (and as such transition from the source domain to ours).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `openvpn_run`, which is like the domain transition interface (and in fact
    will call it) but also allows our domain for the role. Without this interface,
    some roles might not be able to transition even if they call the domain transition
    interface.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `openvpn_admin`, which will be assigned to user roles/domains to allow them
    to administer our service. This will allow the user to interact with the processes
    of our domain (including killing the processes, tracing their actions, and so
    on) as well as to administer the files and resources used.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within the interfaces, we need to declare the SELinux objects that we are going
    to explicitly reference. This allows the SELinux subsystem to validate whether
    the code is applicable or not: if the objects are not present in the current policy,
    then this interface is not valid and will not be used. Declaring objects is done
    with the `gen_require()` macro:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Other interfaces can be added as needed. While you can add interfaces already
    just in case, be aware that once you define an interface it can be used by other
    policies, and you might not be made aware of this if you are not developing all
    policies yourself. If you, later on, want to change the behavior of interfaces
    or remove them, you might break other policies.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Addressing user applications
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we develop end user applications, their structure will be very similar to
    those for more service-oriented applications. Content-wise, however, there are
    a few areas of attention to consider. Let''s use the `apps/thunderbird.te` policy
    as an example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we notice is that many resource defining interfaces are prefixed
    with `userdom_`. For instance, a temporary file is not `files_tmp_file()` but
    `userdom_user_tmp_file()`. This will ensure that the resources are known as **user-managed**
    temporary files and not regular system temporary files.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another important addition is the support for the `~/.cache`, application cache
    data is stored, whereas configuration data is in `~/.config`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To easily establish user content access, user applications should also call
    the `userdom_user_content_access_template()` template. This will automatically
    create booleans as well, which administrators can toggle. For instance, for the
    thunderbird SELinux policy, this will create `thunderbird_manage_generic_user_content`.
    If set, then thunderbird can not only access the downloads-related resources but
    all user resources.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another template that user application policies will need if they are graphical
    in nature, is `xserver_user_x_domain_template()`. This template will generate
    X server related SELinux objects for the application, and allow the application
    to use the graphical environment on the server.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The reference policy makes a distinction between regular interfaces and templates.
    Interfaces grant privileges to the domains and roles that are passed to it. Templates
    on the other hand will generate new objects, such as SELinux booleans, types,
    attributes, and more. Code-wise, templates cannot be part of boolean-triggered
    statements (as they do not just add type enforcement rules).
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When the baseline of a user application policy is drafted, including the preceding
    templates, then expanding the policy through trial and error should suffice. Do
    make sure, however, that all resources on the user location for which you are
    testing the application are correctly labeled, as otherwise, the denials might
    trick you into granting more privileges to the domain than necessary.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Adding user-level policies
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to create custom user and role policies, then the most confusing
    choice is the choice of user template to pick. This template creates a role and
    user domain with a specific purpose in mind, and grants a number of permissions
    by default:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Relationship between user domain templates ](img/B16276_15_001.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – Relationship between user domain templates
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common templates to pick for user/role policies are the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '`userdom_restricted_user_template()` for (by default) unprivileged end user
    roles.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userdom_admin_user_template()` for (by default) highly privileged end user
    roles.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other templates can be used as well, especially if more fine-grained controls
    over the roles and user domains are needed. Note, however, that the privileges
    assigned by the templates are mentioned as *by default*. If we want to create
    a role and user domain for administrating a specific service, then we do not want
    to use `userdom_admin_user_template()`, as this will grant many more privileges
    than needed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider the `roles/dbadm.te` SELinux policy for the database
    administration role. This role is based upon the `userdom_base_user_template()`
    interface to ensure minimal permissions are granted. The role is not meant to
    be used in a direct fashion (login), but rather transitioned toward (for instance,
    through the `newrole` command, or through well-defined role transitions within
    the policy).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Getting help with supporting tools
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are tools out there that help in developing SELinux policies, and if needed
    we can build our own support tools as well. Let's see what support environments
    we can use.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Verifying code with selint
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While SELinux policies can be functionally working, validating whether the code
    itself is proper and follows best practices is important to ensure that the code
    is maintainable in the long run.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the tools that support validating SELinux policy code is `selint`, as
    offered from [https://github.com/TresysTechnology/selint](https://github.com/TresysTechnology/selint).
    Once built and installed, `selint` offers insights into four main areas:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Convention checks validate whether the SELinux policy follows the reference
    policy convention on how code should be structured and documented.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style checks give hints for code style that might be wrong, and where the developer
    might have intended a different behavior.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warnings are triggered when the code has bad calls that might trigger runtime
    issues or security issues.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors catch construction faults that will result in compile issues or runtime
    issues.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows the use of `selint` in automated build processes, as well as facilitating
    the development of policies.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling `selint` is simple:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, two convention malpractices were detected. One is in the ordering
    of permissions, while another has an explicit require block mentioned for a domain
    that is not part of that policy module.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Querying the interfaces and macros locally
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To help in finding the right interface or macro, we also want to quickly be
    able to show interface and macro information. With some shell scripting, we can
    create a few functions that help us along.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions are provided as code together with this book. You might want
    to change the path that the `POLICY_LOCATION` variable points to at the beginning
    of the script. By default, it points to the system-installed interface and macros,
    but you can point it to repository checkouts as well:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Source the file to have access to the helper functions:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The helper functions you can use are the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: With `sefindif` you can search for an SELinux interface that has a specific
    SELinux rule inside. You can use regular expressions to find the appropriate one.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With `seshowif` the interface in its entirety (excluding the comment) is displayed.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With `sefinddef` and `seshowdef`, the same is possible but for the supporting
    macros.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: While such functions do not offer the same versatility as a full-fledged policy
    editor suite would, they can help in quickly finding the right interface or macro.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reference policy is the most common source for SELinux policy development,
    and with years of development effort and maintenance, it has grown to be a full
    policy set with a vivid development community, and active support by various tools
    (including `audit2allow`, as well as the `selint` application).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve learned how policies are generally structured, and how to start building
    SELinux policy modules for the most common use cases: application services, end
    user applications, and user roles. To help us in developing these policies, we''ve
    seen that `selint` can do code-style analysis, whereas some shell scripts can
    help us parse the interface files for quick help.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: In our final chapter, we will look into CIL style SELinux development.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why don't Linux distributions use the reference policy natively?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three main policy files needed for an SELinux module, and what
    is their purpose?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is a permission set such as `exec_file_perms` preferred over explicitly
    listing the permissions?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between interfaces and templates?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the database administration role defined in `dbadm.te` not using `userdom_admin_user_template`?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
