- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Containerizing Applications with Docker
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 对应用程序进行容器化
- en: Over the last decade, Docker containerization has become a kind of default packaging
    format for web applications and modern microservices. In a container, your program
    sits in a very lightweight, isolated shell of Linux filesystem, process, user,
    and network abstractions, safely separate from the host environment. Container
    images also happen to be incredibly portable – they’re easy to shuffle around
    from a developer’s laptop to a testing or staging environment to a production
    server. This solves many of the problems that have plagued software and infrastructure
    over the last several decades.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十年里，Docker 容器化已经成为 Web 应用和现代微服务的默认打包格式。在容器中，您的程序处于一个非常轻量级、与宿主环境安全隔离的 Linux
    文件系统、进程、用户和网络抽象的壳层中。容器镜像也非常便携——它们可以轻松地从开发者的笔记本电脑转移到测试或预发布环境，再到生产服务器。这解决了过去几十年中困扰软件和基础设施的许多问题。
- en: In some sense, containers are quite similar to the Linux packages you’ve learned
    how to install from repositories. A container image is, roughly, a compressed
    archive (such as, a `.tar.gz` file) of your application, along with all the configuration
    files and dependencies the application needs. That little package – an image –
    is executable by Docker. The revolutionary thing about such a container is that
    it neatly holds everything together in a single artifact and can run on any Linux
    system that has a container runtime (like Docker) installed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，容器与您从软件仓库中学习如何安装的 Linux 包非常相似。容器镜像大致上是您应用程序的压缩档案（例如 `.tar.gz` 文件），以及应用程序所需的所有配置文件和依赖项。这个小包——镜像——可以通过
    Docker 执行。关于这种容器的革命性之处在于，它将一切都整齐地打包在一个单一的工件中，并且可以在任何安装了容器运行时（如 Docker）的 Linux
    系统上运行。
- en: This chapter could easily be a book on its own – Docker and Linux containers
    in general are fairly large subjects. However, like with everything else in this
    book, we’re focusing on only the basic theory and practical skills that are necessary
    for you to be comfortable interacting with Docker-based infrastructure in your
    applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容本身就足以成为一本书——Docker 和 Linux 容器总体上是非常庞大的主题。然而，像本书中的其他内容一样，我们只关注让您能够舒适地与基于
    Docker 的基础设施进行交互所需的基本理论和实践技能。
- en: 'In this chapter, you’ll learn about the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解以下内容：
- en: The application development and operational problems that containers solve
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器解决的应用开发和运营问题
- en: What containers are, and how they’re similar to Linux packages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是什么，它们与 Linux 包的相似之处
- en: The difference between Docker images and Docker containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 镜像与 Docker 容器的区别
- en: All the practical basics for using Docker in your development workflow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发工作流中使用 Docker 的所有实用基础
- en: How to build your own container images with Dockerfiles (you’ll containerize
    a real Python web application)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过 Dockerfile 构建自己的容器镜像（您将容器化一个真实的 Python Web 应用）
- en: Some more advanced topics like how virtual machines and containers are different,
    and how Linux creates container abstraction via namespacing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些更高级的话题，比如虚拟机和容器的区别，以及 Linux 如何通过命名空间实现容器抽象
- en: Some hard-earned container tips, tricks, and best practices
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些经过实践验证的容器技巧、窍门和最佳实践
- en: Let’s jump in.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: How containers work as packages
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器如何作为包工作
- en: Docker became standard tooling to package up software when the goal is to include
    a system that is known to be a working setup. A Docker container typically contains
    both the software you want to run as well as a whole, though frequently trimmed
    down, Linux system as its execution environment. This execution environment provides
    libraries and tools, as well as some other things, like basic system configuration,
    so that it can function as a standalone entity, independent of the system running
    the container. The primary goal is to make sure that the application can successfully
    be run on the developer’s machine, production and test environments, and elsewhere,
    without having to take care of details, such as the operating system versions,
    installed libraries.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 成为打包软件的标准工具，目的是包括一个已知的、能够正常工作的系统。Docker 容器通常包含您想要运行的软件以及一个完整的，虽然常常经过精简的，Linux
    系统作为其执行环境。这个执行环境提供了库和工具，以及一些其他内容，如基本的系统配置，使得容器可以作为一个独立实体运行，不依赖于运行容器的系统。主要目标是确保应用程序能够在开发者的机器、生产和测试环境以及其他地方成功运行，而不需要处理操作系统版本、已安装的库等细节问题。
- en: It is important to keep in mind that the operating system and libraries don’t
    disappear. Bugs in libraries may still exist and any packaged dependencies should
    be updated for security and other reasons. However, the consumers of the packaged
    software, be it end users or your system operators, as well as any orchestration
    software, are now provided with a common package and don’t need to take care about
    system dependencies. While the details of how the software is run and configured
    still depend on the software, the way it is executed (in a container) is somewhat
    standardized.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，操作系统和库并不会消失。库中的漏洞仍然存在，任何打包的依赖项都应因安全等原因进行更新。然而，软件的使用者，无论是最终用户、系统运维人员，还是任何编排软件，现在都获得了一个通用的软件包，不需要关心系统依赖项。虽然软件的运行和配置细节仍然取决于软件本身，但它的执行方式（在容器中）在某种程度上是标准化的。
- en: In summary, that means that any specific setup of the environment, such as installing
    dependencies, is now described as part of the Dockerfile, and once a working container
    image is created, short of specific configuration, the container is expected to
    run on any system capable of running Docker, or more broadly, **OCI** images.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这意味着环境的任何特定设置（例如安装依赖项）现在都在 Dockerfile 中描述，一旦创建了有效的容器镜像，除了特定配置之外，容器应该能在任何支持
    Docker 运行的系统上运行，或者更广泛地说，**OCI** 镜像。
- en: '**OCI** (short for **Open Container Initiative**) provides standards to specify
    things like image format and the execution of Linux containers. Sometimes it used
    synonymously with Docker in the sense that a developer might use Docker to create
    the image, but the execution on an orchestrator might not use Docker at all.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**OCI**（**Open Container Initiative**的缩写）提供了指定镜像格式、执行 Linux 容器等标准。它有时与 Docker
    同义使用，意思是开发者可能使用 Docker 创建镜像，但在编排器上执行时可能完全不使用 Docker。'
- en: There’s no better way to get started than to install Docker on your machine
    and start trying some commands, so let’s do that.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 没有比在你的机器上安装 Docker 并开始尝试一些命令更好的入门方式了，来，我们开始吧。
- en: 'Prerequisite: Docker install'
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前提：安装 Docker
- en: First, download and install Docker Desktop. You can find instructions for this
    at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，下载并安装 Docker Desktop。你可以在这里找到安装说明：[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)。
- en: There is also an excellent official tutorial for getting started at [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/),
    but we recommend that you wait to read that until after you’ve gone through this
    chapter. We’re going to cover some of the basics, but with less focus on specific
    command-line flags, and more focus on how you’ll use these commands and workflows
    as an application developer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，官方提供了一个出色的入门教程，链接在这里：[https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)，但是我们建议在完成本章内容后再阅读它。我们会介绍一些基础内容，但重点不在于特定的命令行标志，而是如何作为应用开发者使用这些命令和工作流程。
- en: Now that you’ve got Docker installed, let’s jump into actually starting our
    first container!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了 Docker，接下来让我们开始启动第一个容器吧！
- en: Docker crash course
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 快速入门
- en: 'A **Docker image** is the “package” from our metaphor – it’s a static artifact
    that is saved, stored, and moved around. It becomes a **container** when it’s
    executed on a machine. This is important because you’ll sometimes hear these terms
    used incorrectly: Docker images are the immutable base from which a container
    – a running, namespaced process – is launched. Images are the pre-built template
    from which live containers are generated at runtime.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker 镜像**是我们比喻中的“包”——它是一个静态的工件，保存、存储并传输。当它在机器上执行时，就变成了一个**容器**。这点很重要，因为你有时会听到这些术语被误用：Docker
    镜像是容器的不可变基础——容器是一个正在运行的、有命名空间的进程。镜像是预构建的模板，从中生成运行时的活容器。'
- en: 'Images are designed to be immutable: if you download an nginx web server image
    and run it, any changes you make to the resulting container don’t affect the underlying
    image at all. This is the part that trips up most developers who are used to long-running
    virtual machines that are provisioned once and then started and stopped many times,
    preserving their internal state the whole time.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像设计为不可变的：如果你下载一个 nginx 网页服务器镜像并运行它，所做的任何更改都不会影响基础镜像。这是大多数开发者容易犯错的地方，因为他们习惯了长时间运行的虚拟机，虚拟机通常是一次性配置，然后多次启动和停止，并在整个过程中保持其内部状态。
- en: Docker containers are different. Ideally, they are designed to be ephemeral
    and stateless, while the images they’re spawned from act as a long-lived blueprint
    that can be used to spawn an infinite number of containers across many different
    execution environments.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器是不同的。理想情况下，它们被设计为短暂和无状态的，而它们所基于的镜像则充当长期存在的蓝图，可以在多个执行环境中启动无限多个容器。
- en: What follows is an example of a basic Docker workflow that’s designed to get
    you acquainted with the most important Docker commands. Don’t worry about memorizing
    the commands; we’ll cover them in depth later in this chapter. For now, we’ll
    just explain what’s happening at each step, so you can get used to what you’ll
    see on the screen at your next microservices gig.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个基本的Docker工作流示例，旨在帮助你熟悉最重要的Docker命令。无需担心记住命令；我们稍后将在本章中深入讲解它们。目前，我们只会解释每一步发生了什么，这样你就能适应下次微服务工作中会看到的内容。
- en: 'First, let’s start the nginx container (`docker run`) and interactively (`-it`)
    run the Bash shell (`/bin/bash`) inside of it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们启动nginx容器（`docker run`）并交互式地（`-it`）运行Bash shell（`/bin/bash`）：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This gets us a shell prompt for the unique container that was started from
    the `nginx` image. The container’s Bash shell is now connected to our terminal:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个唯一容器的shell提示符，该容器是从`nginx`镜像启动的。现在，容器的Bash shell已连接到我们的终端：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s write a file called `test.txt` and verify that it exists:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个名为`test.txt`的文件并验证它是否存在：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can exit the shell with the usual command, `ctrl-d`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过常规命令`ctrl-d`退出shell：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The container exits and we’re now back in our regular shell. Here’s where it
    gets confusing for most first-time Docker users: let’s re-run the first command
    to start a container from the nginx Docker image again, and check on our file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 容器退出后，我们回到了常规的shell。这是大多数第一次使用Docker的用户感到困惑的地方：让我们重新运行第一个命令，再次从nginx Docker镜像启动容器，并检查我们的文件：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: FILE A BUG REPORT! DOCKER IS BROKEN!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 文件A错误报告！Docker坏了！
- en: Actually, it’s not. This is not the same container as the one you wrote the
    `test.txt` file in. If you were looking closely, you may have noticed that the
    hostname in the shell prompt was different on the second container. That’s because
    each `docker run` command launches a new container from the specified image. Containers
    are designed to run, exit, and disappear forever.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 其实不是的。这并不是你写入`test.txt`文件的那个容器。如果你仔细看，你可能注意到第二个容器的shell提示符中的主机名不同。这是因为每次运行`docker
    run`命令时，都会从指定的镜像启动一个新的容器。容器的设计是运行、退出并永远消失。
- en: 'The original container is actually still around:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，原始容器仍然存在：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get rid of them, you can use `docker rm` with the ID of the container you
    want to delete:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除它们，你可以使用`docker rm`并指定你要删除的容器的ID：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It is possible to start a stopped container with `docker start`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`docker start`启动一个停止的容器：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At which point, you would see the container running in your Docker process
    list:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你将看到容器在Docker进程列表中运行：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then you could use `docker exec` to execute a command inside that container,
    again starting and attaching to the Bash shell program with `–it`. From there,
    you can view the filesystem state (`test.txt`) that we modified:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以使用`docker exec`在容器内执行命令，再次通过`–it`启动并附加到Bash shell程序。然后，你可以查看我们修改过的文件系统状态（`test.txt`）：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, keeping containers around for a long time – modifying their state and
    stopping and restarting them instead of always starting new containers from an
    image – is discouraged and leads back to many of the same bugs that Docker helped
    solve.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，长时间保留容器——修改它们的状态、停止并重新启动它们，而不是每次都从镜像启动新容器——是不被鼓励的，这会导致很多Docker最初帮助解决的相同问题。
- en: 'Let’s avoid all of those mistakes and delete this running container forever
    by force-removing it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们避免所有这些错误，通过强制删除它来永远删除这个正在运行的容器：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You could have also run `docker stop` followed by `docker rm`, but force-removing
    with `docker rm -f` will stop and remove a running container in one fell swoop.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以先运行`docker stop`，然后运行`docker rm`，但是使用`docker rm -f`强制删除将会一举停止并删除一个正在运行的容器。
- en: You can see how Docker encourages immutable containers to keep the state from
    drifting away from the image, which is the “source of truth” for your application’s
    initial environment. If you want to make changes to an image, you can’t do so
    directly – images are immutable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到Docker鼓励使用不可变容器来保持状态不偏离镜像，而镜像是应用程序初始环境的“真理源”。如果你想修改镜像，不能直接修改——镜像是不可变的。
- en: Changes should be *explicit* and *intentional*, which is important for creating
    and running reliable software. How do we do this? We start with the original image,
    make our changes in a controlled and reproducible way (not “SSH to the server
    and try running these commands”), and then save them by creating a new image.
    Enter the mighty Dockerfile.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 变更应该是*明确的*和*有意图的*，这对于创建和运行可靠的软件至关重要。我们怎么做呢？我们从原始镜像开始，以可控和可复现的方式做出更改（而不是“SSH
    登录到服务器并尝试运行这些命令”），然后通过创建新镜像来保存这些更改。这里就需要强大的 Dockerfile。
- en: Creating images with a Dockerfile
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Dockerfile 创建镜像
- en: If you’re ever tasked with building a new Docker image, or modifying an existing
    one – perhaps for a web application that you’re developing – you’ll be making
    heavy use of Dockerfiles (see the official Dockerfile documentation at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经被要求构建新的 Docker 镜像，或修改现有镜像——可能是为你正在开发的 Web 应用程序——你将会大量使用 Dockerfile（请参阅官方的
    Dockerfile 文档：[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)）。
- en: A large percentage of new software will already have an official (or at least
    open-source, third-party) Dockerfile available. Even if you need to do some customizing
    before you use these, a good place to look for examples is the documentation for
    the software or framework you use. These examples don’t tend to break as easily
    as your own custom Dockerfile when major upgrades are released for the packaged
    software.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分新的软件都已经有了官方的（或者至少是开源的、第三方的）Dockerfile。即使你需要在使用这些 Dockerfile 之前做一些自定义，查找你所使用软件或框架的文档也是一个不错的选择。这些示例在软件发布重大升级时通常不会像你自己编写的自定义
    Dockerfile 那样容易出错。
- en: Also, some frameworks or development environments, for example, Spring Boot
    (Java), can generate Docker images as part of the build process.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些框架或开发环境，例如 Spring Boot（Java），可以在构建过程中生成 Docker 镜像。
- en: So, even though there’s a chance you’ll never have to touch a Dockerfile yourself,
    it’s unlikely, and you should have a basic idea of how they work.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，即使你有可能永远不需要自己接触 Dockerfile，但这种可能性不大，你应该对它们的工作原理有基本的了解。
- en: 'Let’s look at a very simple Dockerfile, from the open-source HTTP echo server
    project ([https://github.com/hashicorp/http-echo](https://github.com/hashicorp/http-echo)).
    This creates a Docker image that packages a Go binary that acts as a simple web
    server:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下一个非常简单的 Dockerfile，来自开源的 HTTP 回显服务器项目（[https://github.com/hashicorp/http-echo](https://github.com/hashicorp/http-echo)）。它创建了一个
    Docker 镜像，将一个作为简单 Web 服务器的 Go 二进制文件打包在内：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Basically, this creates a new container image by:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这通过以下方式创建一个新的容器镜像：
- en: Using the `alpine` Linux image as a base to build on.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `alpine` Linux 镜像作为基础进行构建。
- en: Downloading some certificates and adding them to an image layer (essentially
    adding something to the resulting container’s filesystem).
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载一些证书并将它们添加到镜像层中（本质上是将某些东西添加到最终容器的文件系统中）。
- en: Copying the `http-echo` binary from the build directory into the container image.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构建目录中的 `http-echo` 二进制文件复制到容器镜像中。
- en: Running an alpine package installation command to install the `curl` program.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Alpine 包管理命令来安装 `curl` 程序。
- en: Defining the executable or command that is run when a container started from
    this image is launched.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义在从这个镜像启动的容器启动时运行的可执行文件或命令。
- en: Each of these steps is invoked by a (capitalized) *Instruction* that the Dockerfile
    parser knows how to execute. This specific Dockerfile only uses a subset of the
    instructions available to you in a Dockerfile (`FROM`, `ADD`, `RUN`, and `ENTRYPOINT`).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤中的每一个都由 Dockerfile 解析器知道如何执行的（大写）*指令*触发。这个特定的 Dockerfile 只使用了 Dockerfile
    中可用指令的子集（`FROM`、`ADD`、`RUN` 和 `ENTRYPOINT`）。
- en: 'Here’s the full complement of instructions available to you when you’re creating
    new Docker images via a Dockerfile:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建新 Docker 镜像时，Dockerfile 中可用的完整指令集：
- en: '`ARG`: Declares a build-time argument; basically, a variable to be used later
    in the build.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARG`：声明一个构建时参数；基本上是一个在构建过程中稍后使用的变量。'
- en: '`ENV`: Environment vars to set during the build, which will persist in your
    running container environment (*not* just during the build!). Takes a `key=value`
    format.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`：在构建过程中设置的环境变量，这些变量将在你的运行容器环境中持久存在（*不仅仅在构建期间*）。采用 `key=value` 格式。'
- en: '`FROM`: Base image.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`：基础镜像。'
- en: '`CMD`: This provides a default command (or default `ENTRYPOINT` args) for the
    container to run when it’s started. It can be overridden, but you should have
    one in your Dockerfile. Only one per Dockerfile is allowed – if there’s more than
    one `CMD`, only the last one will count.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`：为容器启动时运行的默认命令（或默认 `ENTRYPOINT` 参数）。可以被覆盖，但在 Dockerfile 中应有一个。每个 Dockerfile
    只能有一个 `CMD`，如果有多个 `CMD`，只有最后一个会生效。'
- en: '`ADD`: A flexible instruction that copies files and directories, adding them
    to the image’s filesystem. This can also be used to copy files from outside the
    image or from remote URLs (via HTTP), and to do complex things like expansion,
    decompression, unarchiving, and more. You saw it as a stand-in for the `curl`
    command in the sample Dockerfile above, to download a CA certificate file.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD`：一个灵活的指令，复制文件和目录，将它们添加到镜像的文件系统中。它也可以用于从镜像外部或远程 URL（通过 HTTP）复制文件，并进行复杂操作，如扩展、解压、解档等。你在上面的示例
    Dockerfile 中看到它作为 `curl` 命令的替代，用于下载 CA 证书文件。'
- en: '`COPY`: Just copies files and directories – less complicated, magical, and
    powerful than `ADD`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY`：仅复制文件和目录，比 `ADD` 更简单、魔法性和功能性更强。'
- en: '`LABEL`: Adds image metadata, in a `key=value` format.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LABEL`：添加镜像元数据，格式为 `key=value`。'
- en: '`EXPOSE`: Informs consumers of this image about which network protocols and
    ports this container will be listening on.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE`：通知使用此镜像的消费者，该容器将监听哪些网络协议和端口。'
- en: '`ENTRYPOINT`: Tells the container what command to run when it starts. Use the
    *exec form* (`ENTRYPOINT ["executable", "param1", "param2"]`) to make sure your
    container can receive and respond to signals from outside the container process.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`：告诉容器启动时运行哪个命令。使用 *exec 形式* (`ENTRYPOINT ["executable", "param1",
    "param2"]`) 以确保容器能够接收并响应来自容器外部的信号。'
- en: '`RUN command arg1 arg2`: Run `command` with arguments `arg1` and `arg2` in
    the image’s shell:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN command arg1 arg2`：在镜像的 shell 中运行 `command`，并传入参数 `arg1` 和 `arg2`：'
- en: '`RUN ["command", "arg1", "arg2, "argN"]`: Same as above, but useful to avoid
    shell string munging.'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN ["command", "arg1", "arg2", "argN"]`：与上面相同，但有助于避免 shell 字符串混乱。'
- en: Each `RUN` instruction executes in a new image layer (we’re not diving into
    layers here but this can be helpful to know).
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 `RUN` 指令都会在新的镜像层中执行（我们在这里不深入探讨镜像层，但知道这一点可能会有帮助）。
- en: '`RUN --mount` can be used to temporarily mount filesystems into the container
    during the build, without copying the files themselves into an image layer.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN --mount` 可用于在构建过程中暂时将文件系统挂载到容器中，而无需将文件本身复制到镜像层中。'
- en: '`RUN --network` and `RUN --security` also exist for managing network context
    and privileged containers, respectively.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN --network` 和 `RUN --security` 也存在，用于分别管理网络上下文和特权容器。'
- en: '`WORKDIR`: Sets the working directory for instructions that follow in the Dockerfile.
    Equivalent to `cd` in Unix-like operating systems.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR`：为 Dockerfile 中随后的指令设置工作目录。相当于类 Unix 操作系统中的 `cd`。'
- en: '`SHELL`: Override the default shell used to interpret commands during the Docker
    build. Commands must use the exec form.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHELL`：覆盖在 Docker 构建过程中用于解释命令的默认 shell。命令必须使用 exec 形式。'
- en: '`STOPSIGNAL`: Set the system call signal that this container should interpret
    as the signal to exit. By default, this is SIGTERM, like any other Linux process.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STOPSIGNAL`：设置此容器应解释为退出信号的系统调用信号。默认情况下，这是 SIGTERM，像其他 Linux 进程一样。'
- en: '`VOLUME`: Define volumes that will be mounted in from the host.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VOLUME`：定义将从主机挂载进来的卷。'
- en: '`USER`: Change (container) user to use for build commands, from this point
    forward (can be used multiple times to switch users during a build).'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER`：将构建命令使用的（容器）用户更改为此后的用户（可以在构建过程中多次切换用户）。'
- en: '`ONBUILD`: Define an instruction that’s triggered when this image is used as
    the base for another build.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONBUILD`：定义一个指令，当该镜像作为基础镜像用于另一个构建时触发。'
- en: '`HEALTHCHECK`: Some health-checking functionality, which you likely won’t use
    because your container scheduler has its own health-checking functionality.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEALTHCHECK`：一些健康检查功能，你可能不会使用它，因为你的容器调度器有自己的健康检查功能。'
- en: We’ll jump into a practical, end-to-end example of how to tie all of this together
    with a small project, but first let’s revisit the commands we just used in a bit
    more depth.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个实际的、端到端的示例来演示如何将这些内容结合起来，但首先让我们更加深入地回顾一下我们刚才使用过的命令。
- en: Container commands
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器命令
- en: Now let’s dive deeper into some of the more complicated, but important, commands
    and command invocations that you may run into when working with Docker.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入探讨一些较为复杂但重要的命令和命令调用，这些命令你在使用 Docker 时可能会遇到。
- en: docker run
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker run
- en: 'Let’s look at a more complex invocation of the `docker run` command we used
    earlier:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下之前使用过的`docker run`命令的一个更复杂的调用：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`--rm`: Clean up (remove) this container when it exits.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--rm`：容器退出时清理（删除）此容器。'
- en: '`--name mywebcontainer`: Give this container a friendly name – `mywebcontainer`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name mywebcontainer`：给这个容器起一个友好的名字——`mywebcontainer`。'
- en: '`-p 80:80`: Map port `80` of the host to port `80` in the container. The left
    port number is on the “outside” (the environment running the container), and the
    right port number represents the “inside” (container) port. For example, `-p 4000:80`
    will map the container’s port `80` to `localhost:4000`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p 80:80`：将主机的`80`端口映射到容器的`80`端口。左边的端口号代表“外部”（运行容器的环境），右边的端口号代表“内部”（容器）端口。例如，`-p
    4000:80`将容器的`80`端口映射到`localhost:4000`。'
- en: '`-v /tmp:/usr/share/nginx/html:ro`: Mount a volume – the host environment’s
    `/tmp` directory will be mounted into the container at `/usr/share/nginx/html`;
    `:ro` ensures that this will be a read-only mount (mounted files can’t be modified
    from inside the container).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v /tmp:/usr/share/nginx/html:ro`：挂载一个卷——主机环境中的`/tmp`目录将被挂载到容器中的`/usr/share/nginx/html`目录；`:ro`确保这是一个只读挂载（挂载的文件不能从容器内修改）。'
- en: '`-d`: Run the container in detached mode (in the background).'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：以分离模式（在后台）运行容器。'
- en: '`nginx`: The image to launch this container from.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nginx`：用于启动此容器的镜像。'
- en: 'If you want to see some HTML at `http://localhost:80`, you can add an `index.html`
    file to your `/tmp` directory:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在`http://localhost:80`上查看一些HTML内容，你可以将一个`index.html`文件添加到你的`/tmp`目录中：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because our `/tmp` directory is mapped to the container’s `/usr/share/nginx/html`
    directory (where nginx will look for HTML files), nginx will immediately recognize
    and begin serving this file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的`/tmp`目录映射到了容器的`/usr/share/nginx/html`目录（nginx会在此目录中查找HTML文件），nginx会立即识别并开始提供该文件。
- en: Volumes are the mechanism by which stateful applications can still be run using
    stateless containers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 卷是有状态应用程序可以使用无状态容器运行的机制。
- en: docker image list
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: docker image list
- en: To see which images you’ve downloaded locally, you can run `docker images` (or
    `docker image list`, if you prefer).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你本地下载的镜像，可以运行`docker images`（或如果你更喜欢，可以运行`docker image list`）。
- en: The list may be long if you’ve been building and using lots of Docker images!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经构建并使用了很多Docker镜像，列表可能会很长！
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: docker ps
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker ps
- en: '`docker ps` is a bit like the `ps` command in Linux. It lets you see which
    containers are running on your host, along with some context like their ID, which
    command they are running, their creation time and uptime, port mapping, and more.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps`有点像Linux中的`ps`命令。它让你查看哪些容器正在主机上运行，并显示一些信息，比如它们的ID、正在运行的命令、创建时间和运行时间、端口映射等。'
- en: Running the command
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'will produce output like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将产生类似以下的输出：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: docker exec
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker exec
- en: 'During the development of a container image, it’s common to jump into a container
    and run commands. To start an interactive shell in a running container, use `docker
    exec`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器镜像的开发过程中，通常会进入容器并运行命令。要在运行中的容器中启动一个交互式的shell，可以使用`docker exec`：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the case of our previously started nginx container, this will spawn a Bash
    shell inside the container environment. Any state changes you make (file creation,
    kernel settings, and so on) will be lost when the container is stopped – the next
    `docker run` will simply spool up a new container from the same base image state.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们之前启动的nginx容器，这将会在容器环境内启动一个Bash shell。你所做的任何状态更改（如文件创建、内核设置等）将在容器停止时丢失——下一个`docker
    run`会简单地从相同的基础镜像状态启动一个新的容器。
- en: docker stop
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker stop
- en: 'To stop a container, run `docker stop $CONTAINERNAME` – you can also use the
    container ID if it doesn’t have a friendly name:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止一个容器，运行`docker stop $CONTAINERNAME`——如果容器没有友好名称，你也可以使用容器ID：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the container was started with the `--rm` option, as our nginx container
    was, the container will be deleted and its state (if that state diverged from
    the base image) will be lost.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器是使用`--rm`选项启动的，就像我们启动的nginx容器一样，容器将在停止后被删除，并且其状态（如果与基础镜像有差异）将丢失。
- en: If the container was not started with `--rm`, its state remains on your filesystem
    and you can start the container again with `docker start $CONTAINERNAME`. Its
    state will be preserved.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器没有使用`--rm`选项启动，它的状态将保留在你的文件系统中，你可以通过`docker start $CONTAINERNAME`再次启动该容器。其状态将被保留。
- en: 'Docker project: Python/Flask application container'
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker项目：Python/Flask应用容器
- en: We’re going to containerize a small Python web service that uses the Flask web
    framework. This is an extremely common pattern, and Python lends itself well to
    containerization because packaging and dependency management are famously messy
    in a lot of Python projects. You’ll create all the files yourself – try to use
    a command-line text editor for practice!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将容器化一个使用 Flask Web 框架的小型 Python Web 服务。这是一个非常常见的模式，Python 非常适合容器化，因为很多 Python
    项目的打包和依赖管理非常混乱。你将自己创建所有文件——试着使用命令行文本编辑器进行练习！
- en: 1\. Set up the application
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1\. 设置应用程序
- en: 'First, create a new directory and enter it:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新目录并进入该目录：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the tiny Python web application. I’m using vim in this example, but
    use whichever editor you like:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个小型的 Python Web 应用程序。在这个示例中，我使用的是 vim 编辑器，但你可以使用任何你喜欢的编辑器：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Paste the following text inside:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下文本粘贴进去：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That’s the whole web application – it simply reads some of the information from
    an incoming request and uses that to push a response back to the client.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是整个 Web 应用程序——它只是读取一些来自传入请求的信息，并利用这些信息将响应推送回客户端。
- en: Save and exit the file (`esc`, `:x`).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并退出文件（`esc`，`:x`）。
- en: 'Create a file named `requirements.txt` containing just the following line:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `requirements.txt` 的文件，文件内容仅包含以下一行：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, create your Dockerfile:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建你的 Dockerfile：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Enter the following text:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下内容：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That’s all you need for now. Your `dockerpy` directory should now contain three
    files:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你只需要这些。你的 `dockerpy` 目录现在应该包含三个文件：
- en: Dockerfile
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile
- en: '`echo_server.py`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`echo_server.py`'
- en: '`requirements.txt`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requirements.txt`'
- en: 2\. Create the Docker image
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2\. 创建 Docker 镜像
- en: 'Build a new Docker image with the `docker build` command. The `-t` is for “tagging”
    the container with a name:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker build` 命令构建一个新的 Docker 镜像。`-t` 用于为容器打标签并命名：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice the `.` character at the end, which is telling Docker to use the current
    directory as its build context.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意末尾的 `.` 字符，它指示 Docker 使用当前目录作为其构建上下文。
- en: 3\. Start a container from your image
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3\. 从你的镜像启动一个容器
- en: 'You’ve already used the `docker run` command earlier in this chapter. Use it
    to launch a container from your newly built image:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在本章之前使用过 `docker run` 命令。现在用它从你新构建的镜像启动一个容器：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are a few new arguments here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新的参数：
- en: '`--rm` tells Docker to delete the container when it exits. This prevents old
    containers from hanging around on your filesystem, as you saw in the first examples
    in this chapter.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--rm` 告诉 Docker 在容器退出时删除该容器。这防止了旧的容器在文件系统中滞留，就像你在本章的第一个示例中看到的那样。'
- en: '`-d` tells Docker to daemonize the container. This keeps it from attaching
    to your terminal in the foreground.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d` 告诉 Docker 将容器后台运行，这样它就不会在前台附加到你的终端。'
- en: '`-p` sets up a port mapping: the left side of the colon is the container port,
    while the right side is the host port that it’ll be mapped to. If the container
    application were running on port `1234` and you wanted it to map to host port
    `80`, this would read `–p 1234:80`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p` 设置端口映射：冒号左边是容器端口，右边是它映射到的主机端口。如果容器应用程序在端口 `1234` 上运行，并且你希望它映射到主机的端口 `80`，那么命令会写成
    `–p 1234:80`。'
- en: '`--name` tags your container with a name so you can find it easily in the output
    of `docker ps`.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name` 为你的容器标记一个名字，方便你在 `docker ps` 的输出中找到它。'
- en: 'Now you’ve got your containerized application running, and can access it in
    a browser or on the command line. Let’s use the `curl` command to connect to send
    a request to the web service:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的容器化应用程序已经运行，并且可以通过浏览器或命令行访问它。让我们使用 `curl` 命令连接并向 web 服务发送请求：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For those who have suffered through impossible-to-recreate dependency nightmares
    (Python, Ruby, and others are famous for this), this should be a revelation. All
    of the complexity that you used to have to drag around with your application –
    from local dev environments to CI and testing, to staging, and finally to production
    – is now condensed into a single artifact that’s guaranteed to contain the same
    stuff no matter where you run it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些经历过无法重现的依赖地狱（Python、Ruby 等因这类问题而出名）的人来说，这应该是一个启示。你过去需要与应用程序一起拖动的所有复杂性——从本地开发环境到
    CI 和测试，再到预生产，最后到生产——现在都浓缩成一个单一的制品，保证无论在哪里运行，它都包含相同的内容。
- en: 'One command we haven’t used before is `docker exec`, which lets you execute
    a command inside a running container. This is useful if, for some reason, you
    absolutely have to inspect or modify a running container:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有用过的一个命令是 `docker exec`，它允许你在正在运行的容器内执行命令。如果由于某些原因，你必须检查或修改一个正在运行的容器，这个命令非常有用：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This launches and attaches to `/bin/sh` in the container (most production containers
    will only have a minimal shell at `/bin/sh`, and won’t ship with something as
    full-featured as Bash).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这会启动并连接到容器中的 `/bin/sh`（大多数生产容器中只会有一个最小的 shell，在 `/bin/sh`，并且不会配备像 Bash 这样功能全面的
    shell）。
- en: 'Let’s stop the server with the last command we’ll cover here, which is `docker
    kill`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过接下来要讲解的最后一个命令 `docker kill` 停止服务器：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This sends a `SIGKILL` (Signal 9) as opposed to a `SIGTERM` (Signal 15) to the
    process and stops it immediately without giving it the chance to shut down gracefully.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这会向进程发送 `SIGKILL`（信号 9），而不是 `SIGTERM`（信号 15），并立即停止进程，而不给它机会优雅地关闭。
- en: Containers vs. virtual machines
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器与虚拟机
- en: You’ve now gotten a taste of the workflow that you’ll use to create and work
    with Docker images. However, it pays to know a bit about the underlying differences
    between containers and virtual machines. This knowledge can make a difference
    when you’re troubleshooting operational issues, and it’s also a common interview
    question to gauge how well you understand the principles underlying containerization.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经初步了解了创建和使用 Docker 镜像的工作流程。然而，了解容器和虚拟机之间的基本区别也是非常有益的。当你在排除操作问题时，这些知识可能会派上用场，同时它也是面试中常见的一个问题，用来评估你对容器化原理的理解程度。
- en: '**Virtual Machines** (**VMs**) allow you to run complete operating systems
    like Linux, Windows, or DragonFly BSD on top of another host operating system.
    VMs run independently of the host system. In fact, running Docker on macOS will
    transparently use a VM to provide the Linux OS that’s needed for Docker.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟机**（**VMs**）允许你在另一个主机操作系统上运行完整的操作系统，如 Linux、Windows 或 DragonFly BSD。虚拟机独立于宿主系统运行。实际上，在
    macOS 上运行 Docker 会透明地使用虚拟机来提供 Docker 所需的 Linux 操作系统。'
- en: As a result, a virtual machine runs a full operating system like Linux, which
    in turn uses an init system like `systemd`. Because of this, you manage services
    and processes exactly as if your VM were a physical machine. In terms of day-to-day
    use, everything that applies to a physical machine also applies to virtual machines.
    However, this is not how containers are typically used.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虚拟机会运行完整的操作系统，如 Linux，这又使用像 `systemd` 这样的初始化系统。由于这一点，你管理服务和进程的方式就像管理物理机器一样。就日常使用而言，适用于物理机器的所有操作也适用于虚拟机。然而，容器的使用方式通常并非如此。
- en: '**Docker containers** usually contain single applications; in fact, they frequently
    contain only a single process. If there happen to be multiple processes inside
    a container, this is typically because of a multi-process application that has
    spawned child processes (web servers or command runners usually do this). Since
    the widely agreed-upon best practice is for a container to run only a single process,
    and to exit as soon as that process exits, any kind of internal process supervision
    and management would be wasted here.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker 容器**通常只包含单个应用程序；实际上，它们通常只包含一个进程。如果容器内有多个进程，通常是因为一个多进程的应用程序生成了子进程（例如，网页服务器或命令执行程序通常会这样做）。由于广泛认同的最佳实践是让容器只运行一个进程，并且在该进程退出时容器也会退出，所以任何形式的内部进程监督和管理在这里都是多余的。'
- en: Instead, you’ll find that the jobs typically done by an operating system’s init
    system have moved outside the container runtime environment, to the external systems
    *managing* the containers, such as Kubernetes, Nomad, and others.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你会发现通常由操作系统的初始化系统完成的工作已经转移到容器运行时环境之外，转移到外部系统中，这些系统负责*管理*容器，例如 Kubernetes、Nomad
    等。
- en: In this new model, containers are what operating system processes used to be,
    and container orchestrators play assorted OS and scheduler roles.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种新模型中，容器类似于操作系统进程，而容器编排器则扮演各种操作系统和调度器的角色。
- en: In a Docker container, PID1, which is the init system on a full Linux operating
    system, is whatever your CMD or ENTRYPOINT is. Usually, that’s the main process
    of the software you’re running. Typically, a container is expected to run a single
    process. While there are scenarios where people intentionally run their containers
    in a different way, running a single process and having the container halt when
    the process halts is the expected behavior. Especially when simply containerizing
    a service to be run in production, one should make sure to follow this approach.
    There are exceptions to this rule, especially when running software that predates
    the popularization of Docker containers, but in these cases, you’ll likely be
    aware and often base off containers made for this purpose.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 容器中，PID1（一个完整 Linux 操作系统中的初始化系统）是你的 CMD 或 ENTRYPOINT。通常，这就是你正在运行的软件的主进程。通常情况下，容器应该运行一个单一的进程。虽然在某些场景中，人们故意以不同的方式运行容器，但运行一个单独的进程，并在该进程停止时让容器停止，是预期的行为。尤其是在将服务容器化并运行在生产环境中时，应该确保遵循这种方式。这个规则有例外，特别是当运行一些早于
    Docker 容器普及的旧软件时，但在这种情况下，你通常会有所了解，并且往往是基于专为此目的制作的容器。
- en: A quick note on Docker image repositories
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 Docker 镜像仓库的快速说明
- en: We’ve been working quite a bit with the `nginx` image in this chapter. But where
    exactly is this image coming from? By default, Docker attempts to download images
    from Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)), which is
    a central repository of public Docker images. Docker Hub works like a Linux package
    repository, which contains uploaded Docker images ready for you to use. Most popular
    server software can be found there and can be downloaded and used as easily as
    you just saw with `nginx`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直在使用 `nginx` 镜像。但这个镜像到底来自哪里呢？默认情况下，Docker 会尝试从 Docker Hub 下载镜像（[https://hub.docker.com/](https://hub.docker.com/)），Docker
    Hub 是一个公共 Docker 镜像的中央仓库。Docker Hub 的工作方式类似于 Linux 软件包仓库，包含了可以随时使用的上传 Docker 镜像。大多数流行的服务器软件都可以在那里找到，像你刚刚看到的
    `nginx` 一样，下载并使用非常简单。
- en: Not all applications are public, however, and it’s normal to use private repositories
    to store Docker images. There is an ever-changing list of Docker image repository
    providers, so we won’t list them here, but it’s enough to understand that they
    all work the same way as Docker Hub.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并不是所有的应用都是公开的，使用私有仓库来存储 Docker 镜像是很常见的。Docker 镜像仓库提供商的名单不断变化，所以我们不会在这里列出它们，但了解它们都与
    Docker Hub 的工作方式相同就足够了。
- en: Painfully learned container lessons
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 痛苦的容器化经验教训
- en: 'As you start building your own containers, you can avoid many problems by keeping
    in mind the best practices discussed in Docker’s official documentation here:
    [https://docs.docker.com/get-started/09_image_best/](https://docs.docker.com/get-started/09_image_best/).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始构建自己的容器时，记住 Docker 官方文档中讨论的最佳实践可以帮助你避免许多问题，详细内容请参考：[https://docs.docker.com/get-started/09_image_best/](https://docs.docker.com/get-started/09_image_best/)。
- en: That said, we’ve compiled a small list of the most egregious containerization
    mistakes we’ve noticed, and how to avoid them. This section is the result of many
    sleepless nights, outages, and learning things the hard way.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们列出了一些我们注意到的最严重的容器化错误，以及如何避免它们。这个部分是许多不眠之夜、故障和艰难学习的结果。
- en: Image size
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像大小
- en: Start with minimal images, like Scratch or Alpine. To deploy most applications,
    it’s a good idea to try to stay away from big images and distributions like Ubuntu.
    When build dependencies are required, removing these, or using intermediate build
    containers when building larger/multi-container projects, is recommended.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从最小的镜像开始，比如 Scratch 或 Alpine。为了部署大多数应用程序，尽量避免使用像 Ubuntu 这样的大型镜像和发行版是一个好主意。如果构建过程中需要依赖项，建议在构建较大或多容器项目时，删除这些依赖项或使用中间构建容器。
- en: Small, minimal images don’t just mean faster download speeds and less resource
    usage, but also make it a lot easier for you to manage. If an image doesn’t include
    software and libraries you don’t need, that’s less for you to keep updated, less
    surface area for criminals to attack, and fewer noisy warnings from container
    security scanners.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 小巧、精简的镜像不仅意味着更快的下载速度和更少的资源消耗，还使得你更容易管理它们。如果一个镜像没有包含你不需要的软件和库，那么你需要更新的内容就更少，攻击者可以利用的漏洞面更小，容器安全扫描工具发出的噪声警告也更少。
- en: C standard library
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C 标准库
- en: Be aware of which **C Standard Library** (also known as *libc*) you’re using.
    Many Linux distributions use `glibc`; some, like Alpine Linux, use `musl` or others.
    The libraries and any resulting binaries might not be compatible across those.
    For example, on Alpine, you may need to compile less popular tools yourself. If
    your projects depend on certain libraries being available via packages on your
    base image, you might run into incompatibilities. Of course, upgrading, downgrading,
    or switching base images completely might cause similar issues.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 需要了解你正在使用的**C 标准库**（也叫做 *libc*）。许多 Linux 发行版使用 `glibc`；一些像 Alpine Linux 则使用
    `musl` 或其他库。这些库及其生成的二进制文件可能在不同的系统间不兼容。例如，在 Alpine 上，你可能需要自己编译一些不太常见的工具。如果你的项目依赖于基础镜像中通过包提供的某些库，你可能会遇到不兼容的问题。当然，升级、降级或完全切换基础镜像可能会引发类似的问题。
- en: However, because Alpine and `musl` have been steadily gaining adoption, these
    sorts of issues are becoming less likely (and, at the very least, more googlable!).
    If you don’t depend on any C libraries, this usually won’t be an issue. Also,
    statically compiling your code can make you more independent of the underlying
    system and therefore the base image.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 Alpine 和 `musl` 已稳步获得普及，这些问题变得不太可能发生（至少，更容易通过 Google 搜索找到解决办法！）。如果你不依赖任何
    C 库，通常这不会是个问题。另外，静态编译你的代码可以使你更独立于底层系统，从而不再依赖基础镜像。
- en: 'Production is not your laptop: outside dependencies'
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生产环境不是你的笔记本：外部依赖
- en: Don’t depend on local mounts or other local containers. The environment for
    a deployed container will likely be very different from your laptop. Just because
    you’ve got a database container next to your web app container on your laptop,
    doesn’t mean these containers will be scheduled on the same machines in production.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 不要依赖本地挂载或其他本地容器。已部署容器的环境通常与你的笔记本电脑大不相同。仅仅因为你在笔记本上把数据库容器和 Web 应用容器放在一起，并不意味着这些容器在生产环境中会被调度到同一台机器上。
- en: The same thing goes for data volumes – these outside-your-container touchpoints
    are where you’ll have to do some planning with your Ops/DevOps co-workers. You’ll
    likely be hooking into service discovery, health checking, and shared volumes
    via a scheduler or other DevOps tooling construct.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 数据卷也是如此——这些容器外的接触点是你需要与 Ops/DevOps 同事进行规划的地方。你可能会通过调度器或其他 DevOps 工具集成服务发现、健康检查和共享卷。
- en: 'Container theory: namespacing'
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器理论：命名空间
- en: If you’re wondering how some of this container magic works underneath, or just
    worried that you’ll have to troubleshoot a container environment under pressure
    one day, it’s useful to familiarize yourself with the concept of namespacing.
    You can skip this section if you’re not interested in how the container abstraction
    is built on Linux.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想这些容器魔法是如何在底层工作的，或者只是担心有一天在压力下需要排查一个容器环境，那么了解命名空间的概念会很有帮助。如果你不关心容器抽象是如何在
    Linux 上构建的，可以跳过这一部分。
- en: Namespacing is an overloaded term, used to mean different things in different
    technological niches. In the context of Linux containers, the idea of namespacing
    is best explained via `chroot` (change root). `chroot` is an old utility for Unix
    and Unix-like operating systems that allows a user to change the root (the `/`
    path) of the filesystem.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是一个多重含义的术语，在不同的技术领域有不同的解释。在 Linux 容器的上下文中，命名空间的概念最好通过 `chroot`（更改根目录）来解释。`chroot`
    是一个老旧的 Unix 和类 Unix 操作系统工具，允许用户更改文件系统的根路径（即 `/` 路径）。
- en: 'The usage of this tool is really quite simple: `chroot /some/path` will set
    whatever is in `/some/path` to be the new `/`. In addition to allowing OS installers
    to change into the system that is currently being installed to run commands, it
    also allows for basic namespacing. In fact, various software and the configuration
    of various Linux distributions have been making use of this to enhance security,
    because using `chroot` essentially excludes parts of the filesystem from the currently
    readable scope – it makes anything outside the new root inaccessible. So, if an
    attacker uses an exploit that allows for remote code execution on a web server
    running inside a `chroot` environment, the system and any files outside this directory
    will remain unaffected.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具的使用其实非常简单：`chroot /some/path`将设置`/some/path`为新的根目录`/`。除了允许操作系统安装程序切换到当前正在安装的系统以执行命令外，它还允许进行基本的命名空间隔离。事实上，许多软件和不同Linux发行版的配置已经在利用`chroot`来增强安全性，因为使用`chroot`本质上将文件系统的某些部分排除在当前可读范围之外——它使得新根目录外的任何内容都无法访问。因此，如果攻击者利用某个漏洞在运行在`chroot`环境中的web服务器上执行远程代码，那么系统和此目录外的任何文件将保持不受影响。
- en: The technical primitives used to implement containers on Linux and other operating
    systems have changed significantly over the last decade, and will likely continue
    to change. Thankfully, the low-level implementation is not critically important
    for you as a software engineer who is mainly a consumer of containerization, as
    opposed to an operator or implementer of this technology.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在Linux和其他操作系统上实现容器的技术原语在过去十年中发生了显著变化，未来可能还会继续变化。幸运的是，低级实现对你作为主要使用容器化技术的软件工程师并不至关重要，而对于容器技术的操作员或实施者则非常重要。
- en: 'The “container” abstraction relies on underlying technologies like:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: “容器”抽象依赖于像以下技术：
- en: Filesystem namespacing (for example, with `chroot`).
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统命名空间（例如，使用`chroot`）。
- en: User and process namespacing, making processes outside the container invisible
    from within the container. In other words, root and PID 5 in the container would
    respectively map to an unprivileged user and another process ID outside of the
    container namespace.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户和进程的命名空间，使得容器外部的进程在容器内部不可见。换句话说，容器中的root和PID 5将分别映射到容器命名空间外的非特权用户和另一个进程ID。
- en: Resource grouping and accounting technologies such as `cgroups`.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源分组和计费技术，如`cgroups`。
- en: Network virtualization/namespacing, so a container can’t access a network interface
    directly, but also so that port number overlaps can be handled. For example, you
    can run two different containers that expose port `8080`; there won’t be an error
    about the port being already in use, because the containers’ networking stacks
    are independent of each other.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络虚拟化/命名空间，使得容器无法直接访问网络接口，同时也可以处理端口号重叠问题。例如，你可以运行两个不同的容器并暴露端口`8080`；由于容器的网络栈相互独立，因此不会出现端口已被占用的错误。
- en: How do we do Ops with containers?
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何通过容器进行运维？
- en: Although this is not a book for system administrators or site reliability engineers,
    you should know the basic context in which containers are generally run. The main
    idea is that containers are largely stateless “functions” that process inputs
    (web requests or HTTP messages from other services) and produce outputs (web responses,
    side effects, and logs streamed to STDOUT). In a well-run operations environment,
    containers can be thought of as an analog to Linux processes, or to functions
    in programming.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书不是面向系统管理员或站点可靠性工程师的，但你应该了解容器通常运行的基本背景。主要思想是，容器大致上是无状态的“函数”，它们处理输入（来自其他服务的web请求或HTTP消息）并生成输出（web响应、侧面效应和流向STDOUT的日志）。在运行良好的操作环境中，容器可以视为Linux进程或编程中的函数的类比。
- en: Containers are usually “scheduled” onto hosts by a third-party tooling layer
    such as Kubernetes, Nomad, and others. If containers are like processes, then
    these fill the role of the operating system scheduler (the whole thing is a distributed
    system instead of a single host).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通常通过像Kubernetes、Nomad等第三方工具层“调度”到主机上。如果容器类似于进程，那么这些工具就充当操作系统调度器的角色（整体系统是一个分布式系统，而不是单一主机）。
- en: Container output is usually captured by the same tooling and redirected to logging
    solutions such as Logstash, Graylog, and Datadog. Metrics from all running containers
    may be extracted and fed into tools like Prometheus for analysis and troubleshooting.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的输出通常由相同的工具捕获，并重定向到日志解决方案，如 Logstash、Graylog 和 Datadog。所有运行中的容器的度量指标可以被提取并输入像
    Prometheus 这样的工具进行分析和故障排除。
- en: Conclusion
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, you got a whirlwind tour of the most important things you need
    to know about working with Docker, and containers in general. Although individual
    technologies may change – which container scheduler is in vogue, or how log streaming
    is best handled – we’ve tried to stay focused on the core theory and skills that
    every modern software developer should have.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你对与 Docker 及容器工作相关的最重要的事项进行了快速浏览。虽然单独的技术可能会发生变化——比如哪个容器调度器流行，或如何最好地处理日志流——但我们始终专注于每个现代软件开发者应该掌握的核心理论和技能。
- en: We hope that you take away a few main ideas from this chapter. First, we hope
    you have an intuitive grasp of the problems that containerization solves for people,
    mainly by controlling complexity and packaging dependencies into a single artifact.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你从这一章中带走几个主要观点。首先，我们希望你能直观地理解容器化为人们解决了哪些问题，主要通过控制复杂性并将依赖打包成一个单一的工件。
- en: It’s also important to remember the difference between images and containers,
    and to get some practice building your own Dockerfiles from scratch, using the
    official documentation.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是要记住图像和容器之间的区别，并且通过使用官方文档，练习从零开始构建自己的 Dockerfile。
- en: We hope that visiting a few more advanced topics, like how virtual machines
    and containers are different and how namespacing works, comes in handy during
    troubleshooting or a job interview. The best practices we discussed will come
    in handy there, too.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望访问一些更高级的话题，比如虚拟机和容器的区别，以及命名空间是如何工作的，这些会在故障排除或面试时派上用场。我们讨论的最佳实践也会在这些情况下有所帮助。
- en: Finally, to cement your learning, we recommend that you practice these skills
    by containerizing one of your own applications. You’ll learn a lot and it’ll be
    much easier to start while all of the information from this chapter is still fresh
    in your mind.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了巩固你的学习，我们建议你通过将自己的应用程序容器化来练习这些技能。你将学到很多东西，而且在本章的所有信息仍然鲜活在你脑海中的时候开始会更加容易。
- en: Learn more on Discord
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在这里你可以分享反馈、向作者提问并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code1768422420210094187.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1768422420210094187.png)'
