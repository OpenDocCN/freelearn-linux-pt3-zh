- en: '*Chapter 4*: Using File Contexts and Process Domains'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SELinux-enabled systems are strongly dependent on the notion of contexts (on
    resources) and domains (on processes). The access controls that SELinux enforces
    use these contexts to identify the resources, and define the enforcement rules
    within the policy. Because of its inherent reliance on these contexts, this chapter
    will go into detail on file contexts, context definitions, and process domains.
  prefs: []
  type: TYPE_NORMAL
- en: We will work with the file contexts and learn where they are stored so that
    you can easily adjust your system to work optimally with SELinux. We assign contexts
    to resources both temporarily (for testing purposes) and permanently, and learn
    how these contexts are used to automatically deduce the process domain. Once we
    know how to obtain process domain information, we will query the SELinux policy
    to learn about the current access controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to SELinux file contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping or ignoring contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux file context expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying file contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The context of a process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the scope of transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types, permissions, and constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3m3JzkP](https://bit.ly/3m3JzkP)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to SELinux file contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SELinux file contexts are the most important configuration that a system administrator
    will have to work with when working with SELinux on the system. Contexts for files
    are generally identified through a label that is assigned to the file. Mislabeled
    files are a constant source of headaches for sysadmins, and most common SELinux
    issues are resolved by correcting the SELinux context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing where and how SELinux contexts are used is key to understanding and
    resolving SELinux related issues. The following diagram shows how contexts are
    applied on regular Linux resources, and how the LSM subsystem uses these contexts
    for decision making:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Distinction between contexts and regular Linux info ](img/B16276_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Distinction between contexts and regular Linux info
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a web-based deployment as an example: DokuWiki. This is a popular
    PHP wiki that uses files rather than a database as its backend system, and is
    easy to install and manage. As a web hosting platform, we will use nginx.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting context information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume that the DokuWiki application will be hosted at `/srv/web/localhost/htdocs/dokuwiki`
    and that it will store its wiki pages (user content) in the `data/` subdirectory.
    We start by downloading the latest DokuWiki tarball from the project site, [http://download.dokuwiki.org](http://download.dokuwiki.org),
    and extract it to this location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: While distributions might have prepackaged DokuWiki installations available,
    we will use the manual installation approach to show the various file context-related
    actions in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The contexts of files can easily be acquired using the `-Z` option of the `ls`
    command. Most utilities that can provide feedback on contexts will try to do so
    using the `-Z` option, as we saw with the `id` utility in [*Chapter 1*](B16276_01_Final_VK.xhtml#_idTextAnchor018),
    *Fundamental SELinux Concepts*, and [*Chapter 3*](B16276_03_Final_VK.xhtml#_idTextAnchor071),
    *Managing User Logins*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the current context of the `dokuwiki` directory itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The context displayed here is `var_t`. In the *Keeping or ignoring contexts*
    section, we will change this to the correct context (as `var_t` is too generic
    and not meant for hosting web content).
  prefs: []
  type: TYPE_NORMAL
- en: File and directory contexts are stored in the filesystem as extended attributes
    when the filesystem supports this. An **extended attribute** (often abbreviated
    to **xattr**) is a key/value combination associated with a resource's inode (an
    information block that represents a file, directory, or symbolic link on a filesystem).
    Each resource can have multiple extended attributes, but only one value per unique
    key. When we talk about assigning a **label** to a file or directory (or relabeling
    a file), then we imply setting or updating this extended attribute, as it is the
    label that SELinux will use to obtain the SELinux context for the file.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems that do not support extended attributes can still be used on SELinux-enabled
    systems. However, the entire filesystem (including all its files and directories)
    will then be shown with a single context, and differentiation across resources
    on the filesystem is not possible. We explain how to define file contexts on these
    filesystems in the *Using mount options to set SELinux contexts* subsection in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'By convention, extended attributes on Linux use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The namespace of an extended attribute allows for additional access controls
    or features. Of the currently supported extended attribute namespaces (`security`,
    `system`, `trusted`, and `user`), the `security` namespace enforces specific restrictions
    on manipulating the attribute: if no security module is loaded (for instance,
    SELinux is not enabled), then only processes with the `CAP_SYS_ADMIN` capability
    (basically root or similarly privileged processes) can modify this parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can query the existing extended attributes using the `getfattr` application,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `security.selinux` extended attribute hosts the SELinux context.
    This ensures that non-administrative users cannot alter the SELinux context of
    a file when SELinux is disabled and that the SELinux policy controls who can manipulate
    contexts when SELinux is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `stat` application can also be used to show SELinux contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Getting context information from a file or directory should be as common to
    an administrator as getting regular access control information (the read (`r`),
    write (`w`), and execute (`x`) flags).
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting SELinux context types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After using SELinux for a while, the motive behind using file labels to assign
    an SELinux context to the file becomes somewhat clearer. SELinux contexts are
    named after their purpose, allowing administrators to more easily see whether
    a context is correctly assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the context of a user file in its home directory (`user_home_t`), a
    directory in `/tmp` for a Java application (`java_tmp_t`), or a socket of `rpcbind`
    (`rpcbind_var_run_t`). All these files or directories have considerably different
    purposes on the filesystem, and this reflects itself in the assigned contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Policy writers will always try to name the context consistently, making it easier
    for us to understand the purpose of the file, but also to make the policy almost
    self-explanatory so that administrators can understand the purpose of the policy
    without additional documentation needs.
  prefs: []
  type: TYPE_NORMAL
- en: For the regular filesystem, for instance, files are labeled with a context resembling
    their main location as they have similar security properties. For example, we
    find binaries in the `/bin` folder (and `/usr/bin`) to be associated with the
    `bin_t` type, boot files in `/boot` associated with `boot_t`, and generic system
    resources in `/usr` associated with `usr_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also find more application-specific contexts. For instance, for the
    PostgreSQL database server, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `postgresql_t` context is meant for the application itself (process type
    or domain).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `postgresql_port_t` context is meant for the TCP port on which the PostgreSQL
    daemon listens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `postgresql_server_packet_t` and `postgresql_client_packet_t` contexts are
    types associated with network packets received (in case of the `postgresql_server_packet_t`
    type) or sent to the PostgreSQL port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `postgresql_exec_t` type is assigned to the `postgres` binary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The various `postgresql_*_t` types for specific filesystem locations related
    to the daemon, such as `postgresql_var_run_t` (to apply to resources in `/var/run`),
    `postgresql_etc_t` (to apply to resources in `/etc`), `postgresql_log_t` (to apply
    to resources in `/var/log`), and `postgresql_tmp_t` (to apply to resources in
    `/tmp`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mysqld_db_t` type for the database files themselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the context of a file or resource, administrators can easily detect
    anomalies in the system setup. An example of an anomaly is when we move a file
    from the user's home directory to a web server location. When this occurs, the
    file retains the `user_home_t` context as extended attributes are moved with it.
    As the web server process isn't allowed to access `user_home_t` by default, it
    will not be able to serve this file to its users.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to properly set contexts during such copy or move operations.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping or ignoring contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are aware that file contexts are stored as extended attributes,
    how do we ensure that files receive the correct label when they are written or
    modified? To set an SELinux context on a filesystem resource, a few guidelines
    exist, ranging from inheritance rules to explicit commands.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting the default contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the SELinux security subsystem uses context inheritance to identify
    which context should be assigned to a file (or directory, socket, and so on) when
    it is created. A file created in a directory with a `var_t` context will be assigned
    the `var_t` context as well. This means that the file inherits the context from
    the parent directory and not from the context of the executing process.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few exceptions to this though:'
  prefs: []
  type: TYPE_NORMAL
- en: SELinux-aware applications can force the context of a file to be different (assuming
    the SELinux policy allows it, of course). As this is within the software code
    itself, this behavior cannot be generally configured.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application called `restorecond` can be used that enforces contexts on various
    paths/files based on SELinux's context rules. We will cover these rules and the
    `restorecond` application in the *SELinux file context expressions* and *Modifying
    file contexts* sections, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SELinux policy allows for transition rules that consider the context of
    the process creating new files or directories, as well as the name of the file
    the process is creating.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is these transition rules we will cover next.
  prefs: []
  type: TYPE_NORMAL
- en: Querying transition rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type transition rules are policy rules that force the use of a different type
    upon certain conditions. For file contexts, such a type transition rule can be
    as follows: if a process running in the `httpd_t` domain creates a file in a directory
    labeled with the `var_log_t` SELinux type, then the type identifier of the file
    becomes `httpd_log_t`.'
  prefs: []
  type: TYPE_NORMAL
- en: Basically, this rule assigns the `httpd_log_t` web server log context to any
    file placed in a log directory by web servers, rather than the default `var_log_t`,
    which would be the case when standard inheritance was used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can query these type transition rules using `sesearch`. The `sesearch` application
    is one of the most important tools available to query the current SELinux policy.
    For the previous example, we need the (source) domain and the (target) context
    of the directory: `httpd_t` and `var_log_t`. In the following example, we use
    `sesearch` to find the type transition declaration related to the `httpd_t` domain
    toward the `var_log_t` context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `type_transition` line is an SELinux policy rule, which maps perfectly
    to the description. Let''s look at another set of type transition rules for the
    `tmp_t` type (assigned to the directory used for temporary files, such as `/tmp`
    and `/var/tmp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The policy tells us that, if a file, directory, symbolic link, or socket is
    created in a directory labeled `tmp_t`, then this newly created resource gets
    the `httpd_tmp_t` context assigned (and thus not the default, inherited `tmp_t`
    one). Alongside these rules, it also contains two named file transitions, which
    are more flexible transition rules.
  prefs: []
  type: TYPE_NORMAL
- en: With `HTTP_23` or `HTTP_48` is created in a directory labeled `tmp_t`, then
    it does not get the `httpd_tmp_t` context assigned (as would be implied by the
    regular type transition rules), but the `krb5_host_rcache_t` type (used for Kerberos
    implementations) instead.
  prefs: []
  type: TYPE_NORMAL
- en: Type transitions not only give us insight into what labels (and thus also SELinux
    contexts) are going to be assigned, but also give us some clues as to which types
    are related to a particular domain. In the web server example, we found out by
    querying the policy that its log files are most likely labeled `httpd_log_t`,
    and its temporary files `httpd_tmp_t`.
  prefs: []
  type: TYPE_NORMAL
- en: Copying and moving files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'File contexts can also be transferred together with the file itself during
    copy or move operations. By default, Linux will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Retain the file context in case of a move (`mv`) operation on the same filesystem
    (as this operation does not touch extended attributes, but merely adjusts the
    metadata of the file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore the current file context in case of a move operation across a filesystem
    boundary, as this creates a new file, including content and extended attributes.
    Instead, it uses the inheritance (or file transition rules) to define the target
    context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore the file context in case of a copy (`cp`) operation, instead using the
    inheritance (or file transition rules) to define the target context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Luckily, this is just default behavior (based on the extended attribute support
    of these utilities) that can be manipulated freely.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `-Z` option to tell `mv` that the context of the file should
    be set to the default type associated with the target location. For instance,
    in the next example, two files are moved from a user''s home directory to the
    `/srv` directory. The first example will retain its file context (`user_home_t`
    or `admin_home_t`), while the second one will receive the type associated with
    user files placed in `/srv` (`var_t`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can tell the `cp` command through the `--preserve=context` option
    to preserve the SELinux context while copying files. Using the same example, we
    now get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the utilities provided through the `coreutils` package support the
    `-Z` option: `mkdir` (to create a directory), `mknod` (to create a device file),
    `mkfifo` (to create a named pipe), and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If the `mv` command returns `failed to set the security context` when using
    the `-Z` option, then it is very likely that the location either does not have
    a valid context associated with it, or that the filesystem does not support SELinux
    labels. The former is for instances applicable when moving files to `/tmp` as
    the CentOS SELinux policy does not have any default context set for files and
    directories inside `/tmp`. Newly created resources always need to have their own
    affiliated labels applied (such as `user_tmp_t`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Even more so, many of these utilities allow the user to explicitly provide
    a context through the `--context` option. For instance, to create a directory,
    `/srv/foo`, with the context `user_home_t`, using `mkdir` by default would not
    work, as the target context would be set to `var_t`. With the `--context` option,
    we can tell the utility to set a specific context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For other utilities, it is best to consult the manual page and see how the utility
    deals with extended attributes. For instance, the `rsync` command can preserve
    the extended attributes by using the `-X` or `--xattrs` option.
  prefs: []
  type: TYPE_NORMAL
- en: Temporarily changing file contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `chcon` tool to update the context of the file (or files) directly.
    In our previous example, we noticed the `var_t` label on the DokuWiki files. This
    is a generic type for variable data and is not the right context for web content.
    We can use `chcon` to put the `httpd_sys_content_t` label on these files, which
    would allow web servers to have read access on these resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Another feature that `chcon` offers is to tell it to label a file or location
    with the same context as a different file. In the next example, we use `chcon`
    to label `/srv/web` and its resources with the same context as used for the `/var/www`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we change the context of a file through `chcon` and set it to a context
    different from the one in the context list, then the context might be reverted
    later: package managers might reset the file contexts back to their intended value,
    or the system administrator might trigger a fill filesystem relabeling operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, we''ve only focused on the type part of a context. Contexts, however,
    also include a role part and an SELinux user part. If UBAC is not enabled, then
    the SELinux user has no influence on any decisions, and resetting it has little
    value. If UBAC is enabled, though, it might be necessary to reset the SELinux
    user values on files. Utilities such as `chcon` can set the SELinux user as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The role for a file is usually `object_r` as roles currently only make sense
    for users (processes).
  prefs: []
  type: TYPE_NORMAL
- en: To be able to change contexts, we do need the proper SELinux privileges, named
    `relabelfrom` and `relabelto`. These rights are granted on domains to indicate
    whether the domain can change a label from one type to another. If we find denials
    in the audit log related to these permissions, then this means that the policy
    prohibits the domain from changing the contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Placing categories on files and directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We focused primarily on changing types and briefly touched SELinux users, but
    another important part is to support categories and sensitivity levels. With `chcon`,
    we can add sensitivity levels and categories as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Another tool that can be used to assign categories is the `chcat` tool. With
    `chcat`, we can assign additional categories rather than having to reiterate them,
    as would be the case with `chcon`, and even enjoy the human-readable category
    levels provided by the `setrans.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove a category, just use the minus sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove all categories, use the `-d` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Users and administrators should keep in mind that applications generally do
    not set categories themselves, so they need to be added ad hoc.
  prefs: []
  type: TYPE_NORMAL
- en: Using multilevel security on files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the system uses an MLS policy, the `chcon` tool needs to be used. The
    syntax is the same as with categories. For instance, to set the sensitivity `s1`
    and category set `c2` and `c4` to `c10` on all files of a user''s home directory,
    you''d do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Remember that both the context of the user executing `chcon` and the context
    of the user who will use the data must be able to deal with the mentioned sensitivity.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up and restoring extended attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with the regular file operation tools (such as `mv` and `cp`), backup software,
    too, needs to consider SELinux contexts. Two important requirements exist for
    a backup tool when working with SELinux-enabled systems:'
  prefs: []
  type: TYPE_NORMAL
- en: The backup tool must run in an SELinux context capable of reading all files
    in scope of the backup, and, of course, of restoring those files as well. If no
    specific SELinux policy for the backup tool exists, then it might need to run
    in an unconfined or highly privileged domain to succeed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The backup tool must be able to back up and restore extended attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A popular tool for taking backups (or archives) is the `tar` application, which
    supports SELinux contexts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When creating a tar archive, add `--selinux` to include SELinux contexts (both
    during the creation of the archive and when extracting files from the archive).
  prefs: []
  type: TYPE_NORMAL
- en: Using mount options to set SELinux contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not all filesystems support extended attributes. When we use a filesystem without
    extended attribute support, then the SELinux context of a file is either based
    on the filesystem type itself (each filesystem has its own associated context)
    or is passed on to the system using a `mount` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used `mount` option in these situations is the `context=`
    option. When set, it will use the mentioned context as the context for all the
    resources in the filesystem. For instance, to mount an external USB drive that
    hosts a FAT filesystem while ensuring that end users can write to it, we could
    mount it with the `user_home_t` context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If the filesystem supports extended attributes but doesn''t have all files
    labeled yet, then we can use the `defcontext=` option to tell Linux that, if no
    SELinux context is available, then the default context provided should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Another mount option is `fscontext=`. This assigns a context on the filesystem
    type rather than the context of the files on the filesystem. For instance, a CD/DVD
    filesystem can be ISO 9660, Joliet, or UDF. SELinux uses this type definition
    on a filesystem to map permissions such as mount operations and file creation.
    With the `fscontext=` option, the filesystem type can be set differently from
    what the default filesystem type would be.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last option that can be used when mounting filesystems is the `rootcontext=`
    option. This will force the root inode of the filesystem to have the given context
    even before the filesystem is visible to the user space. Permission checks on
    the location during the mount operation itself can cause havoc when the location
    does not have the expected context (especially when filesystems are mounted outside
    their expected location). The `rootcontext=` option provides a reusable configuration
    option to set the expected context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it – these are all the context-related mount options. A final note
    though: the `context=` option is mutually exclusive to the `defcontext=` and `fscontext=`
    options. So, while the `defcontext=` and `fscontext=` options can be used together,
    they cannot be used with the `context=` option. Assuming the target filesystem
    allows for extended attributes, then we can use the file context expressions,
    which we will cover in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: SELinux file context expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we think that the context of a file is wrong, we need to correct the context.
    SELinux offers several methods to do so, and some distributions even add in more.
    We can use tools such as `chcon`, `restorecon` (together with `semanage`), `setfiles`,
    `rlpkg` (Gentoo), and `fixfiles`. Of course, we could also use the `setfattr`
    command, but that would be the least user-friendly approach for setting contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can set context expressions in a more manageable way.
  prefs: []
  type: TYPE_NORMAL
- en: Using context expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the SELinux policy, a list of regular expressions is kept that informs the
    SELinux utilities and libraries what the context of a file (or other filesystem
    resource) should be. Though this expression list is not enforced on the system
    directly, administrators and SELinux utilities use it to see whether a context
    is correct, and to reset contexts to what they are supposed to be. You can find
    the list itself in `/etc/selinux/targeted/contexts/files` in the various `file_contexts.*`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an administrator, we can query this list through `semanage fcontext` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of a tool that queries this information is `matchpathcon`, which
    we introduced in [*Chapter 2*](B16276_02_Final_VK.xhtml#_idTextAnchor045), *Understanding
    SELinux Decisions and Logging*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Not all the entries are visible through the `semanage` application though. Entries
    related to specific user home directories (such as `/home/lisa/.ssh`) are not
    shown as these entries depend on the Linux user (and, more importantly, its associated
    SELinux user).
  prefs: []
  type: TYPE_NORMAL
- en: 'But for all other entries, the output of the command contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A regular expression that matches one or more paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classes to which the rule is applicable, but translated into a more human-readable
    format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The context to assign to the resources that match the expression and class list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The class list allows us to differentiate contexts based on the resource class.
    The `semanage fcontext` output uses human-readable identifiers: resource classes
    can be a regular file (`--`), a directory (`-d`), a socket (`-s`), a named pipe
    (`-p`), a block device (`-b`), a character device (`-c`), or a symbolic link (`-l`).
    When it says all files, the line is valid regardless of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, we have not defined such rules yet, but after the next section,
    even defining custom SELinux context expressions will no longer hold any secrets.
    An important property of the context list is how SELinux prioritizes its application
    – after all, we could easily have two expressions that both match a certain resource
    or path. Within SELinux, the most specific rule wins. The logic used is as follows
    (in order):'
  prefs: []
  type: TYPE_NORMAL
- en: If line A has a regular expression and line B doesn't, then line B is more specific.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the number of characters before the first regular expression in line A is
    less than the number of characters before the first regular expression in line
    B, then line B is more specific.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the number of characters in line A is less than in line B, then line B is
    more specific.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If line A does not map to a specific SELinux type (the policy editor has explicitly
    told SELinux not to assign a type) and line B does, then line B is more specific.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a caveat with the rule order, however. When additional rules are added
    through `semanage` (which we describe in the next section), then SELinux's utilities
    apply the rules in the order they were added rather than their specificity. So,
    instead of the most specific rule, the most recently added rule that matches the
    path is used.
  prefs: []
  type: TYPE_NORMAL
- en: Registering file context changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because changing an SELinux context using `chcon` is often just a temporary
    measure, it is seriously recommended to only use `chcon` when testing the impact
    of a context change. Once the change is acceptable, we need to register it through
    `semanage`. For instance, to permanently mark `/srv/web` (and all its subdirectories)
    as `httpd_sys_content_t`, and the DokuWiki `data/` and `conf/` folders as `httpd_sys_rw_content_t`
    (to allow the web server to modify these resources), we need to execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: What we do here is register `/srv/web` and its subdirectories as `httpd_sys_content_t`
    and the two writable directories as `httpd_sys_rw_content_t` through `semanage`.
    Then, we use `restorecon` to (recursively) reset the contexts of `/srv/web` to
    the value registered in the context list. This is the recommended approach for
    setting contexts on most resources.
  prefs: []
  type: TYPE_NORMAL
- en: These registrations are local (custom) context expressions and are stored in
    a separate configuration file (`file_contexts.local`). Considering the priority
    of (locally added) expressions, it is important to have the *most specific entries
    added last*, as otherwise the more broadly defined rule for `httpd_sys_content_t`
    would be applied to the entire directory. This is unlike the priority rules for
    (policy added) expressions that do have the concept of *most specific rule wins*.
  prefs: []
  type: TYPE_NORMAL
- en: The `semanage fcontext` application can also be used to inform SELinux that
    a part of the filesystem tree should be labeled similarly as a different location
    on the filesystem. Such an `semanage` to apply the same contexts as if the destination
    were the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make this more visible through an example, and have everything under
    `/srv/web` be labeled in a similar manner to the files at `/var/www` (including
    subdirectories), so `/srv/web/icons` gets the same context as `/var/www/icons`.
    We use the `-e` option of `semanage fcontext` to create such an equivalency as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will create a substitution entry so that anything under `/srv/web` gets
    the same label as if it were at the same location under `/var/www`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most distributions already configure a few equivalency rules that we can read
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `semanage fcontext -l` command will show these equivalent locations at the
    end of its output as well.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing recursive context operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `restorecon` application resets the SELinux context of files and other resources
    based on the context definitions managed through the SELinux policy and `semanage
    fcontext`. When applying `restorecon` in a recursive fashion against directories,
    this might take a while. To improve performance in this situation, the SELinux
    authors support the skipping of `restorecon` operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `-D` option to `restorecon`, an additional extended attribute will
    be written to the main directory that contains a hash of the file context definitions
    used when invoking the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Subsequent invocations of `restorecon` with `-D` will check this hash to see
    whether any of the file context definitions that impact this directory have been
    modified (using `semanage fcontext`). If there aren''t, then the restore operation
    will be skipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we update a definition that influences the given location, then `restorecon`
    will reset the contexts appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `restorecon_xattr` command can be used to manage these extended attributes
    (view or delete) and show how the attributes are formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `digest` referenced is the `security.restorecon_last` or `security.sehash`
    extended attributes. More recent user space tools use the latter, and apply their
    logic to each subdirectory, whereas older user space utilities use the former
    and only apply their logic on the selected directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The disadvantage of the `security.restorecon_last` usage is that it does not
    work with subdirectories: if we apply a recursive `restorecon` operation against
    `/`, then this tool will ignore the digest on `/home`. With the `security.sehash`
    usage, a recursive operation against `/` will check the digest for `/home` as
    well.'
  prefs: []
  type: TYPE_NORMAL
- en: Using customizable types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some SELinux types are meant for files whose paths cannot be accurately defined
    by administrators or where the administrator does not want the context to be reset
    when a relabeling operation is triggered. For these purposes, SELinux supports
    what it calls `restorecon`) encounter a file with a customizable type set, they
    will not revert its context to the registered context definition.
  prefs: []
  type: TYPE_NORMAL
- en: The customizable types are declared in the `customizable_types` file inside
    `/etc/selinux/targeted/contexts`. To have `restorecon` relabel such files, administrators
    need to pass the force reset option (`-F`) before the tool resets the contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the contents of this `customizable_types` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, we can mark a file in a home directory as `home_bin_t`, which
    is a customizable type, and as such, this file will not be relabeled back to `user_home_t`
    when a filesystem relabeling operation is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Marking other types as customizable requires updating the `customizable_types`
    file, as there is no user command that adds or removes type definitions from this
    list. Because this file can be overwritten when the distribution or administrator
    pushes out a new policy package, it needs to be governed carefully.
  prefs: []
  type: TYPE_NORMAL
- en: That said, the use of customizable types has its advantages. As an administrator,
    we might want to create and support specific types as usable by end users who
    can use `chcon` to set the contexts of individual files in their home directory.
    By having those types marked as customizable types, a relabeling operation against
    `/home` will not reset those contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the target type is not a customizable type, administrators generally prefer
    to use `semanage fcontext` to add an expression and `restorecon` to fix the context
    of the files. Most administrators will use directory-based labeling: this is much
    easier to maintain, and much easier to explain to end users. Many will even use
    this approach for customizable types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With this command, user binaries and scripts located in the `~/bin` directory
    will be labeled as `home_bin_t`.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the different file_contexts files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside the `/etc/selinux/targeted/contexts/files` directory, five different
    `file_contexts` files can be found:'
  prefs: []
  type: TYPE_NORMAL
- en: The `file_contexts` file itself (without any suffix) is the basic expression
    file provided by the SELinux policy offered through the Linux distribution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `file_contexts.local` file contains the locally added rules (through the
    `semanage fcontext` command, which we covered earlier in this chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `file_contexts.homedirs` file contains the expressions for the user home
    directories. When new user mappings are created and managed through `semanage
    login` and `semanage user`, this file is adjusted to reflect the new situation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `file_contexts.subs_dist` file contains equivalency rules, provided by the
    distribution's SELinux policy, which tell SELinux to consider one part of the
    filesystem as having the same labeling rules as another location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `file_contexts.subs` file contains locally managed equivalency rules (through
    the `semanage fcontext` command, covered earlier in this chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alongside those files, you will find associated `*.bin` files (so `file_contexts.bin`
    for the `file_contexts` file, `file_contexts.local.bin` for the `file_contexts.local`
    file, and so on). These `*.bin` files are automatically created, but in case of
    a discrepancy, administrators can rebuild the files themselves as well using the
    `sefcontext_compile` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: These files contain the same information as the main file, but are precompiled
    to make lookups faster. Unless the tools detect that the `*.bin` files are older
    than their source files, the SELinux utilities will use the compiled versions
    of these files.
  prefs: []
  type: TYPE_NORMAL
- en: Exchanging local modifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When local modifications are registered through `semanage fcontext`, they only
    apply to a single system. If local definitions need to be reapplied on various
    systems, administrators can extract the local modifications and import them on
    another system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To export the local modifications, use `semanage export`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The file that contains the local modifications (`local-mods.conf` in the example)
    can be adjusted at will. This allows administrators to remove all lines except
    those they want to apply on other systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the local modifications stored in the file, transport the file to the
    other system(s) and import the settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The imported settings are immediately registered. Of course, in case of filesystem
    changes (`semanage fcontext`), don't forget to run `restorecon` against the target
    directories.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying file contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know how to set SELinux contexts, both directly through tools such as
    `chcon` as well as through the `restorecon` application, which queries the SELinux
    context list to know what context a file should have. Yet `restorecon` is not
    the only application that considers this context list.
  prefs: []
  type: TYPE_NORMAL
- en: Using setfiles, rlpkg, and fixfiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `setfiles` application is an older one, which requires the path to the
    context list file itself to reset contexts. It is often used under the hood of
    other applications, so most administrators do not need to call `setfiles` directly
    anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Another set of tools are the `rlpkg` (Gentoo) and `fixfiles` (CentOS and related
    distributions) applications. Both these applications have a nice feature: they
    can be used to reset the contexts of the files of an application rather than having
    to iterate over the files manually and run `restorecon` against them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we''re using these tools to restore the contexts of the
    files provided by the `nginx` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Another feature of both applications is that they can be used to relabel the
    entire filesystem without the need to perform a system reboot, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this is not as fine-grained as the commands before.
  prefs: []
  type: TYPE_NORMAL
- en: Relabeling the entire filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `rlpkg` and `fixfiles` commands as listed in the previous section are not
    the only available approaches for relabeling the entire filesystem when working
    with a CentOS (or related) distribution. SELinux offers two other methods to ask
    the system to perform a full filesystem relabeling operation during (re)boot:
    placing a touch file (which the system reads at boot time) or configuring a boot
    parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The touch file is called `.autorelabel` and should be placed in the root filesystem.
    Once set, the system needs to be rebooted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We trigger the same behavior if we add the `autorelabel=1` parameter to the
    boot parameter list (like where we can set the `selinux=` and `enforcing=` parameters
    as discussed earlier).
  prefs: []
  type: TYPE_NORMAL
- en: Asking the system to perform a full filesystem relabeling operation will take
    a while. When finished, the system will reboot again. Touch files will be removed
    automatically after the relabeling operation has finished.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically setting context with restorecond
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Contexts can also be applied by the `restorecond` daemon. The purpose of this
    daemon is to enforce the expression list rules onto a configurable set of locations,
    defined in the `/etc/selinux/restorecond.conf` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following set of files and directories is an example list of locations
    configured in the `restorecond.conf` file so that `restorecond` automatically
    applies the SELinux contexts on these files and directories whenever it detects
    a context change in them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this case, if a process creates a file that matches any of the previously
    created paths, the Linux inotify subsystem will notify `restorecond` of it. `restorecond`
    will then relabel the file according to the expression list, applying the correct
    label regardless of the process (and context) that created the file.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `restorecond` is primarily for historical reasons, when SELinux didn't
    support named file transitions. At that time, writing `resolv.conf` in `/etc`
    could not be differentiated from writing to the `passwd` file in `/etc`. The introduction
    of named file transitions has considerably reduced the need for `restorecond`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting SELinux context at boot with tmpfiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the Linux distribution uses `systemd`, then you can use `systemd-tmpfiles`
    to automatically set SELinux context at boot. `systemd` uses the `tmpfiles` application
    to automatically create and manage volatile locations on the system, such as locations
    inside `/run` when `/run` is a `tmpfs`-mounted filesystem (an in-memory filesystem).
  prefs: []
  type: TYPE_NORMAL
- en: Administrators can configure `tmpfiles` to automatically create files, directories,
    device files, symbolic links, and others at boot, and to reset the permissions
    on resources. It is through this reset operation that we can use `tmpfiles` to
    set the right SELinux context at boot time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B16276_03_Final_VK.xhtml#_idTextAnchor071), *Managing User
    Logins*, we covered polyinstantiation, where users get their own private view
    on filesystem resources. The example we gave used a directory called `/tmp/tmp-inst`,
    which had to have the `000` permission set, and which will host the user-oriented
    `/tmp` views. Rather than having to create and set this permission each time,
    we can configure `tmpfiles` to do this for us, and define the right SELinux context
    up front:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In `/etc/tmpfiles.d`, we create a file called `selinux-polyinstantiation.conf`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The name of the file can be chosen freely, but make sure it uses the `.conf`
    suffix. Every time the system boots, `systemd-tmpfiles` will ensure that the `/tmp/tmp-inst`
    directory is created with the appropriate permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a location does not need to be created, but only its SELinux context reset,
    then you can use the `z` (one resource) or `Z` (recursively) options in the `tmpfiles`
    configuration. This is used, for instance, by the default SELinux `tmpfiles` configuration,
    `selinux-policy.conf`, in `/usr/lib/tmpfiles.d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `-` used is to inform `tmpfiles` not to adjust the permissions and ownership,
    and only to reset the SELinux context.
  prefs: []
  type: TYPE_NORMAL
- en: The context of a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As everything in SELinux works with contexts, even processes are assigned a
    context, also known as the domain. Let's see how we can obtain this information,
    how SELinux transitions from one domain to another, and learn how to query the
    SELinux policy to find more information about these transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a process context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw that the `nginx` web server runs in the `httpd_t` domain, which can
    be seen with the `ps -eZ` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Several other ways exist to obtain the process context. Although the method
    with `ps` is the most obvious, these other methods can prove useful in scripted
    approaches or through monitoring services.
  prefs: []
  type: TYPE_NORMAL
- en: 'A first approach is to read the `/proc/<pid>/attr/current` pseudo-file, which
    we''ve already encountered in [*Chapter 1*](B16276_01_Final_VK.xhtml#_idTextAnchor018),
    *Fundamental SELinux Concepts*. It displays a process''s current security context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To receive a somewhat more human-readable output, use the `secon` command for
    the given process ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the SELinux user space project has a helper utility called `getpidcon`,
    which the `libselinux` library optionally provides. Although this utility is not
    available on CentOS (or related distributions), other distributions such as Gentoo
    do have it. The utility requires a single PID and returns its context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now, the Apache processes don't themselves inform SELinux that they need to
    run in the `httpd_t` (or, for Gentoo, the `nginx_t`) domain. For that, transition
    rules exist in the SELinux policy that govern when and how processes are executed
    in a specific domain.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning toward a domain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as we have seen with files, if a process forks and creates a new process,
    this process, by default, inherits the context of the parent process. For the
    web server, the main process is running in the `httpd_t` domain, so all the launched
    worker processes inherit the `httpd_t` domain from it.
  prefs: []
  type: TYPE_NORMAL
- en: To differentiate the domain of one process from another, domain transitions
    can be defined. A `execve()` function, most likely after a `fork()` operation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the file-based transitions, domain transitions can be queried using `sesearch`.
    Let''s investigate the domains allowed to transition to the `httpd_t` domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this case, SELinux will switch the context of a launched web server to `httpd_t`
    if the parent process is running in one of the mentioned domains (such as the
    `initrc_t` domain) and is executing a file labeled as `httpd_exec_t` (the label
    assigned to the `httpd` and `nginx` binaries).
  prefs: []
  type: TYPE_NORMAL
- en: 'But for this to truly happen, several other permissions (next to the domain
    transition) need to be in place. The following list describes these various permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The source process (such as `initrc_t`) needs to be allowed to transition to
    the `httpd_t` domain, governed by the transition privilege on the process class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The source process (such as `initrc_t`) needs to have the right of execution
    on the file it is launching (`httpd_exec_t`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `httpd_exec_t` type must be identified as an entry point for the `httpd_t`
    domain. SELinux uses an **entry point** to ensure that a domain transition only
    occurs when using the specified file context on the executing binary or script:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The target domain must be allowed for the role that the parent process is in.
    In the case of system daemons, the role is `system_r`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A graphical representation of these rights is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Graphical overview of the necessary transition permissions ](img/B16276_04_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Graphical overview of the necessary transition permissions
  prefs: []
  type: TYPE_NORMAL
- en: Only when all these privileges are allowed will a domain transition occur. If
    not, then either the execution of the application fails (if the domain has no
    `execute` or `execute_no_trans` rights on the file), or it executes but remains
    running in the same domain as the parent process.
  prefs: []
  type: TYPE_NORMAL
- en: Domain transitions are an important concept as they inform the administrator
    how an application gets into its privileged context. To analyze this, many security
    administrators look at how one context can transition to another. We explain policy
    analysis in [*Chapter 13*](B16276_13_Final_VK.xhtml#_idTextAnchor330), *Analyzing
    Policy Behavior*.
  prefs: []
  type: TYPE_NORMAL
- en: For policy writers, deciding when to create a domain transition and when to
    keep the processes running in the same (source) context is a matter of design.
    Generally, policy developers will try to keep the parent context confined so that
    every additional privilege is a source of consideration for switching to another
    domain (which has that privilege). Basically, policy developers will trigger a
    transition when the target application requires significantly more (or different)
    permissions than the source domain holds.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is also why the `unconfined_t` domain has fewer transitions when executing
    user applications compared to the confined user domains, `user_t` or `guest_t`:
    the `unconfined_t` domain already holds many privileges, so transitioning to a
    different domain has little value. Note that this is a decision made by the policy
    writers or Linux distribution, not by the SELinux technology itself. All SELinux
    does is enforce the policy rules.'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying a target context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When executing applications, the SELinux policy might have the command run
    in a different domain. Although we could start querying all rules with `sesearch`,
    a simpler command exists that tells us what the target context is when we execute
    a command or script: `selinuxexeccon`.'
  prefs: []
  type: TYPE_NORMAL
- en: This command requires at least one argument (the path of the binary or script
    that would be executed) and an optional second (the source context). If we omit
    the second argument, the tool will use the current context as the source context.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to find out in which domain the `passwd` command would run when
    executed from the current context, we''d use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows the target context when the `init_t` domain executes
    the `nginx` binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Using `selinuxexeccon` is much faster than querying all appropriate permissions
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: Other supported transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular domain transitions are the most common transitions in SELinux, but other
    transitions are possible as well. For instance, some applications (such as `cron`
    or `login`) are SELinux-aware and will specify which domain to transition to.
    These applications call the `setexeccon()` method (set execution context) to specify
    the target domain and do not use a type transition rule. The other privilege requirements,
    however, still hold.
  prefs: []
  type: TYPE_NORMAL
- en: Some SELinux-aware applications are even able to change their *current* context
    (and not just the context of the application they execute). To accomplish this,
    the application domain needs the `dyntransition` privilege (one of the privileges
    supported for process-level activities). One example of such an application is
    OpenSSH, which, by default, runs in the `sshd_t` domain but can transition to
    the `sftpd_t` type.
  prefs: []
  type: TYPE_NORMAL
- en: Querying initial contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When SELinux does not have a label yet for a resource, it will assign an initial
    context (or initial **security ID** (**SID**)) to the resource. For a few classes,
    the SELinux policy will have a default initial context from which it can further
    jumpstart and assign labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial contexts for various SIDs can be queried using `seinfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, not all classes have a default context assigned, as other classes
    have their contexts derived from the contexts of the currently listed initial
    SIDs.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking memory protections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Legacy binaries on Linux systems might require execution permissions to be set
    on memory regions when these are used for reading, even when the execute permission
    is not actually used. This read-implies-exec is a nuisance for mandatory access
    controls such as SELinux because they need to document the appropriate permissions
    in their policy. If an application needs read access, does the policy then also
    have to include the implied execute rights? And if the policy does not include
    execute rights, should the read operation then fail because it implied execute
    permissions?
  prefs: []
  type: TYPE_NORMAL
- en: Informational note
  prefs: []
  type: TYPE_NORMAL
- en: Read-implies-exec is a legacy support for running old binaries or binaries compiled
    for other Unix systems where applications do not explicitly mark their executable
    memory as executable, assuming that every memory region that is marked as readable
    is executable. This creates a security risk as malicious actors can load in executable
    code dynamically without the system being able to prevent the application to execute
    this code. Many operating systems nowadays have clear memory protection routines
    in place, including preventing data from becoming executable. Sadly, we often
    need to deal with legacy situations, so all operating systems have methods in
    place that selectively disable these memory controls, and within Linux this is
    done through its `man personality` for more information).
  prefs: []
  type: TYPE_NORMAL
- en: SELinux developers allow administrators to select their most appropriate permission
    handling by introducing a memory protection check that can be tuned. The `checkreqprot`
    option can be set to `0` to check protections as handled by the kernel, or `1`
    to check protections as asked by the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'On older systems, this option will be set to `1` to support these legacy binaries.
    Recent distributions, however, build their applications appropriately, and the
    more secure setting `0` is used, as displayed by the `sestatus` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can toggle this support through `/sys/fs/selinux/checkreqprot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The parameter's default value is configured when building the Linux kernel,
    through the `CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE` kernel configuration
    parameter. Administrators can also boot the system with the `checkreqprot=` boot
    parameter to have the specified value set.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the scope of transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For security reasons, Linux systems can reduce the ability of processes to gain
    elevated privileges under certain situations or provide additional constraints
    to reduce the likelihood of vulnerabilities to be exploitable. SELinux developers,
    too, honor these situations.
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing environments on transition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we execute a higher-privileged command (be it a `setuid` application or
    one where capabilities are added to the session), the **GNU C library** (**glibc**)
    will sanitize the environment. This means that a set of security-sensitive environment
    variables are discarded to make sure that attackers, malicious persons, or malicious
    applications cannot negatively influence the session.
  prefs: []
  type: TYPE_NORMAL
- en: This secure execution is controlled through an `LD_PRELOAD`, `LD_AUDIT`, `LD_DEBUG`,
    `TMPDIR`, and `NLSPATH` are removed from the session.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux will force this sanitation on domain transitions as well, ensuring that
    the newly executed domain does not have access to these sensitive environment
    variables. Of course, sometimes the transitioned domain requires these variables.
    Not all domains can deal with sanitized environments, or use these environment
    variables to pass along important information, so always dropping the environment
    variables might result in unusable application domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow transitions without sanitizing the environment, the `noatsecure` permission
    can be granted to domain transitions. For instance, let''s consider the execution
    of a Firefox plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: When an application running in the `unconfined_t` domain executes the plugin
    (which results in a domain transition to `mozilla_plugin_t`), the environment
    variables need to be kept as otherwise the plugin might not function properly.
    As such, the SELinux policy grants the `noatsecure` permission to the domains
    that invoke Firefox plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling unconstrained transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A second security constraint that Linux supports is to mount a filesystem with
    the `nosuid` option. When set, no `setuid` and `setgid` binaries on that filesystem
    will have any effect on the effective user or group ID of the executing session.
    Essentially, a `setuid` application on a filesystem mounted with `nosuid` will
    act as if no `setuid` bit is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that transitions triggered by applications hosted on a `nosuid`-mounted
    filesystem do not allow for elevated privileges, SELinux policy developers must
    explicitly mark a transition as allowed for `nosuid`-mounted filesystems, using
    the `nosuid_transition` permission. This permission is part of the `process2`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This allows policy developers to differentiate regular domain transitions from
    `nosuid`-constrained domain transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: SELinux has a limit on the number of privileges that can be assigned to a class.
    When the number of privileges exceeds 32, the SELinux developers will create a
    different class and the permissions continue in this second class. Right now,
    the two classes that have more than 32 permissions are the `capability` class
    and the `process` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This permission-based approach might not be in place on all SELinux-enabled
    systems though. It is enabled when the `nnp_nosuid_transition` policy capability
    is defined and set to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: If this capability value is `0`, then SELinux will use a concept called `nosuid`-mounted
    filesystems. Any executable with a file context that would result in a domain
    transition will only result in a domain transition if the target domain is bounded
    by the parent domain.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`nnp_nosuid_transition` capability, the policy developer informs the kernel
    that the `nosuid_transition` and `nnp_transition` permission checks should be
    used rather than bounded domains, and that its policy will generally only include
    support for the transitions and not for the bounded domains.'
  prefs: []
  type: TYPE_NORMAL
- en: If it is not bounded, then the domain transition will not occur, and the session
    will remain in the current context (or the command will fail to execute if the
    application is not allowed to run in the current context).
  prefs: []
  type: TYPE_NORMAL
- en: A **bounded domain** is not just calculated live based on the permissions though.
    SELinux has an explicit rule that enforces a target domain to be bounded by a
    parent domain. Even when permissions are later added to the bounded domain, they
    will be denied by the SELinux security subsystem if they aren't part of the parent
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `seinfo`, these type bounds can be listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Most distributions, however, do not have bounded domains defined in their SELinux
    policy anymore, as the new `nosuid_transition` permission is much more flexible.
    The use of bounded domains required policy developers to extend the permissions
    of the parent domain every time the child domain needed to be extended, which
    was a major nuisance when the parent domain is a generic one (be it a container
    management platform or a system service daemon).
  prefs: []
  type: TYPE_NORMAL
- en: Using Linux's NO_NEW_PRIVS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of filesystems mounted with `nosuid` is a specific case of Linux's `nnp_transition`
    permission, or toward a bounded domain if the `nnp_nosuid_transition` policy capability
    is not set.
  prefs: []
  type: TYPE_NORMAL
- en: The parameter can be set by applications themselves using the process control
    function `prctl()`, but the user can also influence this. The `setpriv` command
    can be used to launch applications with `PR_SET_NO_NEW_PRIVS` set (the parameter
    that applications can pass through the `prctl()` function).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, create the following simple Python-based CGI script in a `cgi-bin`
    directory inside a regular user''s home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'With this CGI script now available, first launch a simple CGI-capable web server
    (we will pick port `6020` as unprivileged users should be able to bind processes
    to this port) and connect to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In a different session, connect to the web server and call the newly created
    Python script (here named `test.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, launch the same CGI-capable web server, but with NNP enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, connect to the web server and call the `test.py` CGI script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Because Linux's NNP is enabled, the `ping` command is not able to obtain the
    higher privileges needed to open the socket.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you'll notice a denial for the `execute_no_trans` permission in the
    SELinux audit logs. This occurs when the SELinux policy does not allow an application
    to be executed without transitioning.
  prefs: []
  type: TYPE_NORMAL
- en: Types, permissions, and constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know more about types (for processes, files, and other resources),
    let's explore how these are used in the SELinux policy in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding type attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have discussed the `sesearch` application already and how it can be used
    to query the current SELinux policy. Let''s look at a specific process transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Even though we asked for the rules related to the `initrc_t` source domain and
    the `httpd_t` target, we get a rule back for the `initrc_domain` source domain
    and the `daemon` target. What `sesearch` did here was show us how the SELinux
    policy allows the requested permission, but through *attributes* assigned to the
    `initrc_t` and `httpd_t` types.
  prefs: []
  type: TYPE_NORMAL
- en: '`initrc_domain`, the following types are all tagged with this attribute, as
    can be seen through the `seinfo` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `initrc_t` type is indeed one of the types tagged with `initrc_domain`.
    Similarly, the `daemon` attribute is assigned to several types (several hundred,
    even). So, the single allow rule mentioned earlier consolidates more than a thousand
    rules into one.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes are increasingly used in the policy as a way of consolidating and
    simplifying policy development. With `seinfo -a`, you can get an overview of all
    the attributes supported in the current policy.
  prefs: []
  type: TYPE_NORMAL
- en: Querying domain permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common rules in SELinux are the `allow` rules, informing the SELinux
    subsystem what permissions a domain has. `allow` rules use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `<source>` field is almost always a domain, whereas the `<destination>`
    field can be any type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<class>` field allows us to differentiate privileges based on the resource,
    whether it is for a regular file, a directory, a TCP socket, a capability, and
    so on. A full overview of all supported classes can be obtained from `seinfo -c`.
    Each class has a set of permissions assigned to it that SELinux can control. For
    instance, the `sem` class (used for semaphore access) has the following permissions
    associated with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The reference to `ipc` in the output informs us that the class inherits permission
    from the common `ipc` class, which we can query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `<permissions>` field, most rules will bundle a set of permissions using
    curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This syntax allows policy developers to make very fine-grained permission controls.
    We can use the `sesearch` command to query these rules. The more options are given
    to the `sesearch` command, the finer-grained our search parameters become. For
    instance, `sesearch -A` would give us all allow rules currently in place. Adding
    a source (`-s`) filters the output to only show the allow rules for this domain.
    Adding a destination or target (`-t`) filters the output even more. Other options
    that can be used to filter through allow rules with `sesearch` are the class (`-c`)
    and permission (`-p`) options.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have guessed by now, `sesearch` is an extremely versatile command
    for querying the active policy, showing us the SELinux policy rules that match
    the options given.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `allow` statements in SELinux, however, only focus on type-related permissions.
    Sometimes though, we need to restrict certain actions based on the user or role
    information. SELinux supports this through constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '**Constraints** in SELinux are rules applied against a class and a set of its
    permissions that must be true for SELinux to further allow the request. Consider
    the following constraint on process transitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This constraint says that at least one of the following rules must be true
    if a `transition`, `dyntransition`, or any of the other three mentioned process
    permissions is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: The SELinux user of the source (`u1`) and that of the target (`u2`) must be
    the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SELinux type of the source (`t1`) must have the `can_change_process_identity`
    attribute set, and the SELinux type of the target (`t2`) must have the `process_user_target`
    attribute set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SELinux type of the source (`t1`) must have the `cron_source_domain` attribute
    set, and either the target type (`t2`) should have `cron_job_domain` as an attribute,
    or the target SELinux user (`u2`) should be `system_u`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SELinux type of the source (`t1`) must have the `can_system_change` attribute
    set, and the SELinux user of the target (`u2`) must be `system_u`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SELinux type of the source (`t1`) must have the `process_uncond_exempt`
    attribute set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is through constraints that UBAC is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You can list the currently enabled constraints using `seinfo --constrain`. Multiple
    constraints can be active for the same class and permission set. In that case,
    all the constraints need to be true for the permission to go through.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how file contexts are stored as extended attributes
    on the filesystem and how we can manipulate the contexts of files and other filesystem
    resources. Next, we found out where SELinux keeps the definitions that describe
    which SELinux contexts to assign to the files.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned to work with the `semanage` tool to manipulate this information
    and worked with a few tools that use this information to enforce contexts on resources.
  prefs: []
  type: TYPE_NORMAL
- en: On the process level, we got our first taste of SELinux policies, identifying
    when a process launches inside a certain SELinux domain. With it, we covered the
    `sesearch` and `seinfo` applications to query the SELinux policy. Finally, we
    looked at some of Linux's security implementations that limit the transition scope
    of applications, which also influences SELinux domain transitions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will expand our knowledge of protecting the operating
    system through the networking-related features of SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the most common option for Linux tools to display or explicitly set
    SELinux contexts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is an SELinux context for a file or directory stored on the system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is `chcon` not recommended to persist SELinux context changes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the order of context definitions using the `semanage fcontext` command important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you relabel files on the filesystem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What privileges does a domain need before it can transition to another domain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do SELinux policies bundle multiple types together to facilitate policy
    development?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
