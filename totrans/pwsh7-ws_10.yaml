- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error Handling – Oh No! It’s Gone Wrong!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are, broadly, two types of problems that we encounter when using PowerShell:
    problems that our code encounters and problems with our code. The first type may
    be as simple as a `FileNotFound` message in response to `Get-ChildItem`. The second
    type can be much harder to understand, as it may involve problems related to scope,
    which we saw in [*Chapter 9*](B17600_09.xhtml#_idTextAnchor184), *Don’t Repeat
    Yourself – Functions and Scriptblocks*, or an unexpected divide by zero error.
    We’ll deal with problems that our code encounters in the first half of this chapter,
    and then move on to problems we may find in our code in the second half.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by defining what an error is and look at the two types of errors
    our code will encounter: terminating and non-terminating errors. We will explore
    how PowerShell deals with both types, how we can change that behavior, and why
    we might want to. We will then move on to how we can catch errors so that we can
    understand them and code around them.'
  prefs: []
  type: TYPE_NORMAL
- en: In the second half of the chapter, we will look at how we can identify the causes
    of errors in our code through the process of debugging and look at some of the
    options available in VS Code to make the process easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the main topics we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is an error?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding error actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catching errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging with VS Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an error?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we’ve seen repeatedly, PowerShell, as with most languages, has its own terminology
    and definitions for common words. **Error** is no exception (except… sometimes
    it is, as we’ll see. That is an extremely funny joke. You’ll laugh later, I promise.).
    An error in PowerShell is, broadly, anything that might produce red text in the
    console. Let’s look at an example. In the console, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see a red message saying `Get-ChildItem: cannot find path because it
    does` `not exist`.'
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell is an extremely friendly and helpful language. It will always try
    to recover from an error and continue with what it was asked to do. In the preceding
    instance, it was asked to do one thing, couldn’t do it, and delivered a helpful
    error message written in plain language describing why it was unable to do the
    thing we asked for.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of work going on in the background here. The previous error we
    see is not just a text string; it is part of a complex error object that was generated
    when PowerShell couldn’t find the file. There is a lot more information available
    to understand what happened and help us get it working.
  prefs: []
  type: TYPE_NORMAL
- en: 'The amount of information we see is determined by an automatic variable called
    `$ErrorView`. By default, in PowerShell 7, this variable is set to `ConciseView`,
    and PowerShell displays a short friendly message. When we’re researching on the
    internet, we’ll see that PowerShell can display a lot more information by setting
    the `$ErrorView` variable to the `NormalView` value, as we can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Changing the $ErrorView variable](img/B17600_10_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Changing the $ErrorView variable
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, *box 1*, `$ErrorView` was set to the default, `ConciseView`,
    and we only saw a friendly message. In the second example, *box 2*, we’ve changed
    the value of `$errorView` to `NormalView`, and we get additional information telling
    us where the error occurred (`line:1` and `char:1`) and what category of error
    it was (`ObjectNotFound`). `ConciseView` was introduced in PowerShell 7; Windows
    PowerShell continues to use `NormalView` as the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the rest of this chapter, let’s set our `$ErrorView` variable to `NormalView`
    by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`NormalView` still isn’t the whole story, though. To see the entire error object
    that was generated, type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And we should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The error object](img/B17600_10_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The error object
  prefs: []
  type: TYPE_NORMAL
- en: '`Get-Error` is a PowerShell 7 cmdlet that allows us to access errors stored
    in the `$Error` variable; we won’t find this cmdlet in Windows PowerShell. Each
    error we encounter in a session is written to this variable. It consists of an
    array of error objects, up to a maximum set by the `$MaximumErrorCount` automatic
    variable. By default, this is 256 in PowerShell 7 – hopefully, that’ll be enough.
    We can use `Get-Error` with the `-Newest` parameter followed by an integer to
    get a specified number of errors, starting with the most recent. We can also access
    individual array members using the standard syntax, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will get the most recent error – this is how we have to do it in Windows
    PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Not every error we encounter will have a friendly message associated with it.
    Sometimes we will just see the error code, which is highlighted in the box indicated
    in the previous screenshot. This code is usually either 10 decimal digits, as
    in the screenshot, starting with `-2`, or it may be hexadecimal, in which case
    it will start with `0x`, followed by 8 characters. This frequently happens with
    networking errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is quite cryptic, but luckily there is a tool we can use to decipher
    it, called `err.exe`. It is available as a free download on the Microsoft website;
    just do a search for `err.exe`. Once it is downloaded, we don’t need to install
    it; we can just run it as it is from the PowerShell console or from Command Prompt,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Running err.exe](img/B17600_10_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Running err.exe
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the output is only slightly less cryptic, and can be highly context-specific;
    in this case, if I received the code `0x80010002`, as seen in *Figure 10**.3*,
    while I was trying to open a file over a network, I would interpret that as `ERROR_FILE_NOT_FOUND`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a better understanding of what an error is, let’s look at the two
    types of errors we will encounter with PowerShell: terminating and non-terminating.'
  prefs: []
  type: TYPE_NORMAL
- en: Terminating and non-terminating exceptions and errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Programming languages have the concept of an **exception**: an anomalous condition
    requiring special handling. In general, when a piece of code encounters an exception,
    it stops what it is doing and switches to executing its exception handler: a function
    or subroutine that records what has gone wrong. For most languages, an error is
    an exception, and an exception results in an error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerShell is unusual in that an error isn’t always an exception (although
    an exception is always an error). PowerShell will attempt to recover from errors;
    it will try to continue what it was doing rather than stop dead. It recognizes
    two types of error: terminating and non-terminating. Terminating errors are the
    same as exceptions. PowerShell will output the error and stop what it was doing.
    Non-terminating errors mean PowerShell will record the error and then carry on
    if possible (unless we tell it otherwise).'
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell exceptions versus .NET exceptions
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this can be confusing, and much of the information available on this is
    more so (at least, it confuses me). For instance, Don Jones, in *Learn Windows
    PowerShell in a Month of Lunches*, explains it as I have here: non-terminating
    errors are not exceptions. However, Bruce Payette, in *Windows PowerShell in Action*,
    says that every PowerShell error is an exception, both terminating and non-terminating.
    Both authors (and their books) are brilliant. I’d hate to say one is right and
    the other wrong; luckily, I don’t have to. A careful reading of pages 532, 543,
    and 546 of *Windows PowerShell in Action* suggests the following.'
  prefs: []
  type: TYPE_NORMAL
- en: Every time PowerShell records an error, there is an underlying .NET exception.
    Remember, though, that PowerShell sits on top of .NET, and for a .NET exception
    to be an exception for PowerShell, then it would have to stop PowerShell and start
    an exception handler function. Non-terminating errors do not stop PowerShell,
    and the exception handling functions aren’t run, so they’re not exceptions for
    PowerShell, even though they are exceptions for .NET. Clear as mud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s illustrate. In the previous section, we looked at the error we received
    when we tried to get information about a non-existent file, by running `Get-ChildItem
    -Name nosuchfile`. Let’s try it again, as part of a pipeline. In my `ch10` directory,
    I have two files: `foo.txt` and `bar.txt`. Let’s see what happens when I run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the results in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – A non-terminating error](img/B17600_10_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – A non-terminating error
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, PowerShell gets the details for the first item, `foo.txt`, reports
    an error for the second item, `nosuchfile`, and then continues to get information
    for the third item, `bar.txt`. This is an example of a non-terminating error.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is a terminating error? This is an error that stops PowerShell altogether
    – an error that will stop a script or pipeline from running. A good example is
    a misspelled cmdlet, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – A terminating error](img/B17600_10_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – A terminating error
  prefs: []
  type: TYPE_NORMAL
- en: Here, I’ve used a non-existent cmdlet, `Get-ChildItems` (remember – PowerShell
    cmdlets are always singular, never plural), and PowerShell has stopped dead in
    its tracks on the first attempt to run the cmdlet. If this were a non-terminating
    error, I would expect to see the error appear three times, once for each filename
    in the pipeline. Instead, we see it once because the pipeline has terminated altogether.
  prefs: []
  type: TYPE_NORMAL
- en: It’s great that PowerShell distinguishes between terminating and non-terminating
    errors; it’s extremely useful in the console environment, but when we’re running
    scripts, we’re unlikely to always be around to see the error flash up on the screen
    and then disappear. When we’re writing scripts, we are going to want to turn our
    non-terminating errors into terminating ones and turn all our errors into exceptions.
    This is so that we can set an exception handler that will do things such as log
    errors to a file. Before we look at how we can handle terminating errors, let’s
    look at how we can turn all our errors into exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding error actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two easy ways to change the way that PowerShell processes errors:
    the `$ErrorAction` **Preference** variable and the `-ErrorAction` parameter. Let’s
    look at the variable first.'
  prefs: []
  type: TYPE_NORMAL
- en: The $ErrorActionPreference variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `$ErrorActionPreference` automatic variable can be used to alter how PowerShell
    processes errors. By default, it is set to `Continue`, which means it displays
    any error and carries on. These are the more important valid settings for the
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Break`: This causes PowerShell to enter debug mode when an error occurs. More
    on debug mode in the second half of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Continue` (default): This displays the error message and continues processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Inquire`: This displays the error message and asks for permission to continue
    or stop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SilentlyContinue`: The error message is not displayed but is added to the
    `$Error` variable. PowerShell continues processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stop`: This displays the error message and stops processing. This generates
    an `Action``PreferenceStopException` exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the help document for preference variables (`about_Preference_Variables`)
    states that the variable is only effective for non-terminating errors; this is
    not the case. Changing the variable affects both terminating and non-terminating
    errors, although after a terminating error, `Continue` and `SilentlyContinue`
    will not force the cmdlet or script to continue; it’s still a terminating error.
  prefs: []
  type: TYPE_NORMAL
- en: The `$ErrorActionPreference` variable is scoped, as we would expect. So, while
    the value for the session may be `Continue`, we can set it differently inside
    our scripts. What we must not do, though, is write `$ErrorActionPreference = 'SilentlyContinue'`
    at the top of the script, no matter how tempting it is, or how many times we see
    people do it on the internet. This suppresses all errors in our script and makes
    it incredibly difficult to troubleshoot when things go wrong, as well as making
    Don Jones (the Don of PowerShell) sad. Instead, if there is a cmdlet in our script
    that we know is going to create a lot of non-terminating errors – for instance,
    a function that tests for active machines using `Test-NetConnection` – we can
    use the `-ErrorAction` common parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The -ErrorAction parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `-ErrorAction` parameter is part of the common parameters available to
    all cmdlets and advanced functions. Note this will only change the actions for
    non-terminating errors. In the following screenshot, I have set `$ErrorActionPreference`
    to `Inquire`, by typing `$ErrorActionPreference = Inquire`, and I’m then using
    the `-ErrorAction` parameter to try to change the behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – The -ErrorAction parameter](img/B17600_10_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – The -ErrorAction parameter
  prefs: []
  type: TYPE_NORMAL
- en: In the first cmdlet, we’re generating a non-terminating error, and the error
    action is `Silently` **Continue**. As we can see, there is no output; the default
    value of `Continue` would display the error in red. In the second cmdlet, we’re
    generating a terminating error by getting the cmdlet name wrong, and the `-ErrorAction`
    parameter is ignored; we get a prompt for action.
  prefs: []
  type: TYPE_NORMAL
- en: The `-ErrorAction` parameter has the same values as the `$ErrorPreference` variable.
    Let’s look at the `Ignore` value. This suppresses the error message, as with `SilentlyContinue`.
    Unlike `SilentlyContinue`, the error is not written to the `$Error` variable;
    it is completely ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 1
  prefs: []
  type: TYPE_NORMAL
- en: What is going to happen if we run the following cmdlets?
  prefs: []
  type: TYPE_NORMAL
- en: '**$ErrorActionPreference = “****SilentlyContinue”**'
  prefs: []
  type: TYPE_NORMAL
- en: '**“foo.txt”, “nosuchfile”, “bar.txt” | Get-ChildItem -****ErrorAction “Stop”**'
  prefs: []
  type: TYPE_NORMAL
- en: Now we know how to make all our errors terminating errors, let’s look at why
    we might want to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Catching errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve discovered, errors contain lots of useful information we can use to
    make our code run smoothly. While `Get-Error` and the `$Error` variable are useful
    for real-time troubleshooting, we need to have another way to deal with errors
    when we are writing scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Try/Catch/Finally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to handle terminating errors in PowerShell is with a `Try`/`Catch`/`Finally`
    statement. This statement allows us to set up alternate courses of action, depending
    on whether or not an error occurred. The statement consists of a mandatory `Try`
    block, which contains code that might generate an error, and then either a `Catch`
    block, a `Finally` block, or both. The `Catch` block will run if the code in the
    `Try` block generates a terminating error; this is our exception handler. The
    code in the `Finally` block will run regardless of whether an error is generated
    or not; this block is used for any code that may be required to clean up after
    the code in the `Try` block. We don’t see many instances of the `Finally` block
    – I never use it. We can write multiple `Catch` blocks to handle different errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try an example. In a new file in VS Code, type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, here, we’re creating a function called `Get-Files`. We’re starting with
    a `PROCESS` block so that we can feed it input from the pipeline. We open a `Try`
    block on the third line and include the operating code for the function. Next,
    we create a variable called `$filename` and store the current contents of the
    pipeline in it; we might need that for the `Catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 2
  prefs: []
  type: TYPE_NORMAL
- en: Why can’t we just use the pipeline variable for the `Catch` block? Why do we
    need to store the current pipeline variable in a different variable?
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we write the cmdlet that actually does the processing: `Get-ChildItem`.
    We add `-ErrorAction "Stop"` to ensure that all errors are terminating errors;
    remember that the `Catch` block will only execute for an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we write the `Catch` block itself. We use this block to contain code we
    want to execute if a terminating error is caught; in this case, we just want an
    onscreen error message and the current string, which we wrote to `$filename`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, on the last line, we put our three strings in the pipeline and feed
    them to our function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how it all looks when we run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Using Try/Catch](img/B17600_10_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Using Try/Catch
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding terminal, `foo.txt` and `bar.txt` are processed,
    but because `nosuchfile` can’t be found, the `Catch` block action is triggered
    – in this case, writing an error string to the screen with the filename.
  prefs: []
  type: TYPE_NORMAL
- en: Writing multiple `Catch` blocks is relatively easy, but we need to know what
    sort of errors we can expect; specifically, we need to know the full .NET name,
    including the namespace. We can see from *Figure 10**.4* that the .NET exception
    name when we can’t find a file is `ItemNotFoundException`, but we also need the
    namespace; in this case, it’s `System.Management.Automation`. If we don’t know
    what the namespace for an error is, then this one is always worth a try before
    hunting around on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We put the error type in square brackets between `Catch` and the opening brace
    (`{`), as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Multiple catch blocks](img/B17600_10_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Multiple catch blocks
  prefs: []
  type: TYPE_NORMAL
- en: Our first `Catch` block starts on *line 7* and will only trigger if an error
    of the `System.Management.Automation.ItemNotFoundException` type is thrown. All
    other errors will trigger the second `Catch` block. Try it; change the cmdlet
    to `Get-ChildItems` to trigger a `CommandNotFound` error. We should see `an unspecified
    error. boo.` written three times.
  prefs: []
  type: TYPE_NORMAL
- en: So, what can we do with `Try`/`Catch`? Well, instead of writing to the screen,
    we can combine it with the logging function we wrote in the last chapter and use
    the `Catch` block to write the error message to the log file.
  prefs: []
  type: TYPE_NORMAL
- en: We may see on the internet references to the `Trap` statement. This goes back
    all the way to PowerShell v1\. It’s really fiddly to use and has issues with scope,
    and the advice is that we should use the newer `Try`/`Catch` statement instead.
    As with the `Finally` block, I never use the `Trap` statement.
  prefs: []
  type: TYPE_NORMAL
- en: This almost wraps it up for errors that we might experience running our script;
    just one last scenario to consider. What about things that aren’t errors, but
    stop our script from running?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What happens if there are no `.csv` files in the directory? PowerShell won’t
    display an error; it won’t display anything at all. We might see this as an error
    for our script, though. Let’s look at how we can turn this into a terminating
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Creating errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `Throw` statement is used to create a terminating error in a script so that
    the script stops at that point and an exception can be recorded – for instance,
    written to a log. Let’s look at an example. Try this in VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a pair of `Try`/`Catch` blocks. In the `Try` block, we’re creating
    a variable, `$files`, that contains the results of `Get-ChildItem -Path *.csv`:
    all the `.csv` files in the current directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’re running an `if` statement with a condition of `!($files)` – that
    is, if `$files` is `$null`, then carry out the `Throw` statement, which throws
    a `There are no CSV files here!` message. This message is wrapped into an error
    object that is passed to the `Catch` block. We can then display just the message
    by using `Write-Output $_.tostring()`, just as with a real error. Let’s see how
    it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Throwing our own error](img/B17600_10_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Throwing our own error
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in the red box, the `Throw` statement has produced an error that
    we can handle in exactly the same way as any other terminating error. How we can
    write a non-terminating error is something for the next section of this chapter:
    debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s enough about how we handle errors. In the next section, we’ll take a
    look at debugging our code.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My code has bugs in it. Your code has bugs in it. We’re not bad coders; all
    code has bugs – we just haven’t found them all yet. According to Coverity (a code-quality
    scanning company), quality-controlled professionally written software has around
    1 defect (or bug) per 1,000 lines of code. Some of these bugs are never found
    because the particular set of rare circumstances where the code doesn’t behave
    as expected (an edge case, in the jargon) hasn’t occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bugs largely consist of two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax errors, where we’ve misspelled a cmdlet or parameter name or missed out
    a closing bracket or quotation mark. Syntax errors are basically typing errors
    – just sometimes we’ve typed the wrong thing thinking it’s the right thing. We’ve
    seen already how using VS Code can help us enormously with this, by color coding,
    syntax checking, code hints, and tab autocomplete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic errors, where our understanding of how PowerShell works is insufficient.
    For instance, the problems we might run into with scope would fall into this category.
    Arguably, many of the errors we have already encountered might do as well; a check
    to see whether a file exists before trying to use it would prevent an unexpected
    error from being thrown at all, as we’ve just seen when we discussed the `Throw`
    statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we are going to have a whistlestop tour through the various
    features of PowerShell 7 that can help us find and understand the bugs in our
    code. Before we get into the fun stuff, though, we should remind ourselves of
    the cardinal rules of troubleshooting:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileNotFound`, don’t start troubleshooting the network connection until we’ve
    gone and confirmed with our own eyes that the file is actually where we think
    it is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read the help file**: Have we got the names of the parameters correct? Does
    the cmdlet do what we think it does?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understand how expectation and reality differ**: We need to read the script
    that we are troubleshooting and understand exactly what we expect it to do and
    what it is actually doing. An example – I have recently been working with a customer
    who was having trouble putting his servers into a quiescent state so that he could
    perform maintenance on them. He believed the script he was using would do that
    for him, but when we examined it, it did something slightly different. There was
    nothing wrong with the script; it was his expectation that needed adjusting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That said, let’s look at how we can provide some script instrumentation.
  prefs: []
  type: TYPE_NORMAL
- en: Script instrumentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Script instrumentation refers to pieces of code embedded within our scripts
    to give us information about what a script is doing and how well it is doing it.
    It can mean the progress bars we see when loading modules, messages to say how
    many times a loop has completed, how many objects were found, or simply how long
    a portion of the script took to run. In this section, we’re going to look at how
    we can use some of the `write-*` cmdlets to provide us with troubleshooting information.
    In [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *Writing Our First Script
    – Turning Simple Cmdlets into Reusable Code*, we looked in some detail at the
    `Write-Verbose` cmdlet, and in [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049),
    *The PowerShell Pipeline – How to String Cmdlets Together*, we looked at standard
    streams and the `Write-*` cmdlets associated with each stream. Let’s remind ourselves
    of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Stream #** | **Description** | **Cmdlet** | **Common Parameters** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Success | `Write-Output` | None – this is the default output |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Error | `Write-Error` | `-ErrorAction` and `-``ErrorVariable` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Warning | `Write-Warning` | `-WarningAction` and `-``WarningPreference`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Verbose | `Write-Verbose` | `-``Verbose` |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Debug | `Write-Debug` | `-``Debug` |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Information | `Write-Information` | `-InformationAction` and `-``InformationVariable`
    |'
  prefs: []
  type: TYPE_TB
- en: Table 10.1 – PowerShell streams
  prefs: []
  type: TYPE_NORMAL
- en: These streams are intended for different communities; `Write-Output`, `Write-Warning`,
    `Write-Error`, and `Write-Verbose` are intended for the end user of a script.
    `Write-Information` is for script operators, and `Write-Debug` is for developers;
    that’s us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve used `Write-Output` and `Write-Verbose` previously; we’ll not cover them
    again here. They provide different levels of information for the person running
    the script. `Write-Error`, however, is new. We can use the `Write-Error` cmdlet
    to produce a non-terminating error, much the same as we can use `Throw` to generate
    a terminating error. In the `Write-Error.ps1` script shown next, I’ve set `$ErrorActionPreference`
    to the default and replaced the `Throw` message we were using previously with
    a `Write-Error` cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – The Write-Error cmdlet](img/B17600_10_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – The Write-Error cmdlet
  prefs: []
  type: TYPE_NORMAL
- en: On *line 4*, I’ve replaced the `Throw` statement with `Write-Error "There are
    no CSV files here"` and added a `Write-Output` cmdlet on *line 9*, inside the
    `try` statement that opens on *line 1*.
  prefs: []
  type: TYPE_NORMAL
- en: When we run it, we can see that the `Write-Error` cmdlet outputs a message in
    red to the console. We can see that it is a non-terminating error because the
    `Write-Output` cmdlet on *line 9* also runs and produces a `the script continues`
    string in the console. As we can see from the console window in the screenshot,
    the error is also written to the `$Error` variable. We control its display with
    the same `$ErrorActionPreference` variable we saw earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So, when do we use `Write-Error`, and when do we use `Throw`? `Write-Error`
    is when we want to tell the user that something is wrong but let the script continue
    with what it is doing. `Throw` is for when we want the script to stop what it’s
    doing and process the error.
  prefs: []
  type: TYPE_NORMAL
- en: '`Write-Warning` is a cmdlet that I almost never use. It writes text to the
    warning stream, which is output as yellow text. That’s it. It produces yellow
    text. We can use the `$WarningActionPreference` variable and the `-WarningAction`
    parameter to force the script to stop or silently continue when something is written
    to the warning stream, but it seems to me this is needless redundancy; better
    to use `Write-Error` and write the output to the `$Error` variable as well. Other
    opinions are available.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Write-Information` is generally used to provide details of what our script
    has done; it is useful when we’re working with log aggregators that target the
    information stream, for instance, but I generally don’t bother with it.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Write-Debug` is the cmdlet we’re interested in here. This writes to the debug
    stream and can be accessed by making sure our script is an advanced script, using
    the `CmdletBinding` attribute we saw in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162),
    *Writing Our First Script – Turning Simple Cmdlets into Reusable Code*. If we’ve
    used that attribute, then we have access to the `-``Debug` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When should we use `Write-Verbose` and when should we use `Write-Debug`? The
    `Write-Verbose` output is for the user, and we use it to tell the user what the
    script is doing – for example, a message such as loading files when we have a
    loop to process and ingest files from a directory. We use `Write-Debug` inside
    the loop to enumerate the files that we are loading. Consider the following short
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Write-Verbose versus Write-Debug](img/B17600_10_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Write-Verbose versus Write-Debug
  prefs: []
  type: TYPE_NORMAL
- en: This contains a `Write-Verbose` message on *line 7*, outside the `foreach` loop,
    and a `Write-Debug` message inside the loop on *line 9*. The `Write-Verbose` message
    targets script users and tells them that the script is doing something, even if
    they think it isn’t. The `Write-Debug` message is targeted at us and tells us
    exactly what the script is doing and which file it is processing. `Write-Debug`
    and `Write-Host` actions are controlled by the `$DebugPreference` and `$VerbosePreference`
    variables, respectively. These variables are both set to `SilentlyContinue` by
    default and are overridden by their respective `-Debug` and `-Verbose` switch
    parameters, as we can see in the console output in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: This is all very well, but this only tells us how to deal with errors we anticipate.
    What happens when we don’t know what’s going wrong? We turn to the debugging cmdlets.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging cmdlets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Debugging is hugely complex, and as we dig into it, we quickly come to realize
    we need a pretty good grasp of computer science to understand it thoroughly. That
    doesn’t mean that a working knowledge of the more common cmdlets isn’t incredibly
    useful. In this section, we’re going to look at how to use breakpoints in the
    console when running scripts. A breakpoint will pause a script from running and
    start the built-in PowerShell debugger. The cmdlets that set and manipulate them
    all use the `PSBreakpoint` noun. These are the `PSBreakpoint` cmdlets that we
    should be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set-PSBreakpoint` enables a breakpoint at a particular line of a script, variable,
    or command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Get-PSBreakpoint` lists the breakpoints that are set in a session'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Remove-PSBreakpoint` removes the specified breakpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Disable-PSBreakpoint` stops a breakpoint from triggering but doesn’t remove
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enable-PSBreakpoint` enables a disabled breakpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s use the previous `debugVsVerbose.ps1` script. If you haven’t already,
    create a new file, save it as `debugVsVerbose.ps1`, and add this content. You’ll
    need to change the `$path` variable to a location where you’ve got some files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the console, *not* in VS Code, navigate to the directory where you
    saved it, and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This tells PowerShell that when the `debugVsVerbose.ps1` script is run, start
    the debugger when the value of the `$file` variable is read. Remember – the variable
    name doesn’t include the preceding dollar sign (`$`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the script to enter debug mode when the variable is read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are in debug mode, we can check the values of variables, run cmdlets,
    interrogate the call stack, display the script, and do lots of other things. Try
    it; get the current value of `$file` by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the name of the first file in your location. It should all look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Using the console debugger](img/B17600_10_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Using the console debugger
  prefs: []
  type: TYPE_NORMAL
- en: We can see here that in the first command, I set the breakpoint to trigger when
    `$file` is read. The next command is to run the script. The console tells us that
    we’ve hit a variable breakpoint in yellow and tells us where in the script that
    breakpoint is. The prompt then switches to the debug mode prompt `[DBG]`. I type
    `$file`, and the contents of the variable are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The last command I type is `h`, which is a debugger command, not part of the
    debugging process. Try this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type `h` to get the help contents. This will show us a list of the commands
    we can use inside the debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `s`, `stepInto` | Single step (step into functions, scripts, and so on).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `v`, `stepOver` | Step to the next statement (step over functions, scripts,
    etc.). This will run a function or script block as a single step. |'
  prefs: []
  type: TYPE_TB
- en: '| `o`, `stepOut` | Step out of the current function, script, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `c`, `continue` | Continue the operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `q`, `quit` | Stop the operation and exit the debugger. |'
  prefs: []
  type: TYPE_TB
- en: '| `d`, `detach` | Continue the operation and detach the debugger. |'
  prefs: []
  type: TYPE_TB
- en: '| `k`, `Get-PSCallStack` | Display the call stack. |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `l`, `list` | List the source code for the current script. |'
  prefs: []
  type: TYPE_TB
- en: '|  | Use `list` to start from the current line, `list <m>` to start from line
    `<m>`, and `list <m> <n>` to list `<n>` lines starting from line `<m>`. |'
  prefs: []
  type: TYPE_TB
- en: '| *Enter* | Repeat the last command if it was `stepInto`, `stepOver`, or `list`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `?`, `h` | Displays the help message. |'
  prefs: []
  type: TYPE_TB
- en: Table 10.2 – PowerShell debugger commands
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of commands that help us navigate through our script and
    need a little more explanation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StepOver` will take us to the next statement; if that statement is a function,
    the debugger will just run the function. It won’t work through it line by line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StepInto` will take us to the next line of code after the breakpoint and run
    it. It will step into functions and run them line by line, rather than just running
    the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StepOut` will complete a function if we are in it and take us to the next
    statement after the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Continue` will run the script, either to the end or to the next breakpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Get-PSCallStack` will show us where we are in terms of scripts and functions.
    For instance, if we press the *K* key in our preceding debugger, it will show
    us that we are in the `debugVsVerbose.ps1` script, at *line 9*. If we were in
    a function in a script, it would show us the function name and our location within
    it, followed by the script name and location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List` will show us the script, from whichever line we choose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `quit` will exit the debugger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In my experience, it’s not very often we’ll need to debug at the command line.
    Generally, debugging is easier in an editor such as VS Code. Let’s have a look
    at how we can do that.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with VS Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VS Code is probably the best tool for debugging PowerShell. It has all the debugging
    features most people will need, such as remote debugging capabilities for connecting
    to other machines; far too many to cover here. This section is going to cover
    the basics and show how we can use VS Code to perform the basic debugging procedures
    we’ve just covered in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new VS Code session, press *Ctrl* + *Shift* + *P* to open the Command
    Palette and type `exam`; you should see a link for the PowerShell extension examples
    folder, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – The PowerShell extension examples folder shortcut](img/B17600_10_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – The PowerShell extension examples folder shortcut
  prefs: []
  type: TYPE_NORMAL
- en: In the File Explorer in the left-hand pane, double-click the `DebugTest.ps1`
    file to open it.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite a short tutorial script that is provided with the PowerShell VS
    Code extension. It consists of two functions, `Do-Work` and `Write-Item`. Neither
    function does very much; `Do-Work` writes two lines of text, using two different
    cmdlets, `Write-Output` and `Write-Host`, and also calls the `Write-Item` function.
    `Write-Item` is a counting function that will count up to the value of the `$Count`
    variable, outputting a string each time, with a short delay between each iteration.
    `Do-Work` is called by the final line of the script, *line 28*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s set a breakpoint. Either select *line 15* by clicking on it and
    pressing *F9* or hover the mouse to the left of the line number and click. The
    dull red dot seen in the following screenshot will become bright red:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Setting a breakpoint](img/B17600_10_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Setting a breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a breakpoint set, we can start the debugger. The easiest way to
    do this is to press *Ctrl* + *Shift* + *D*, or we can select **Run** from the
    **View** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – The VS Code Debug interface](img/B17600_10_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – The VS Code Debug interface
  prefs: []
  type: TYPE_NORMAL
- en: The **Debug** view is quite complex, and we’ll need to run the file to the breakpoint
    to see what it does. In the top-left corner, press the green arrow next to **RUN
    AND DEBUG** (number *1* in *Figure 10**.15*). The script will run to the breakpoint
    on *line 15* and stop. Let’s explore the interface. Firstly, we have the run controls
    (*2*). From left to right, these are *continue*, *step over*, *step in*, *step
    out*, *restart*, and *stop*, and are analogous to the controls in the console
    debugger in the last section. If we hover the mouse over them, we can see the
    associated keyboard shortcuts; for instance, we can also continue by pressing
    *F5*. These commands are also available from the **Run** menu in the top toolbar.
    We can see the breakpoint we’ve stopped at highlighted in the script (*3*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The panel on the left contains some really interesting tools in three windows,
    `Write-Item` function, and the variables are `$i`, `$str`, and `$itemCount`. If
    we hover the mouse over them, we can see the type of the variable. Ironically,
    `Write-Item`. If we click the arrow to the left of the word `$args` and `$MyInvocation`.
    If we expand `$PSBoundParameters`, we can see the parameter associated with `Write-Item`:
    `[itemCount]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`$i` variable exists in the local scope, but not in the script or global scopes.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the `<ScriptBlock>`, here. This runs to *line 28* and calls
    the `Do-Work` function, which runs to *line 24* and calls the `Write-Item` function,
    which runs to the breakpoint on *line 15*. This allows us to trace the flow of
    execution through the script. If we click on the items in the call stack, we can
    see that the variable values in the top pane change to show their values in the
    relevant scope. For instance, if we select `Do-Work` instead of `Write-Item`,
    we can see that `$PSBoundParameter` now contains `[workCount]`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the `$i*2` and press *Enter*. We should see the expression
    evaluated to `4`. If we now press the `6`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve barely scratched the surface of debugging with VS Code, but we’ve done
    enough to see how we can use it to understand why our code isn’t behaving as we
    think it should. Debugging is an incredibly complex topic and the best way to
    learn it is to do it. VS Code can make that task a lot easier, though. Let’s summarize
    what we’ve covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by looking at what an error actually is and covered
    some computer science that is applicable to most programming languages. We saw
    how PowerShell is different from many languages by having the concept of terminating
    and non-terminating errors, and how this is a feature of it being an interpreted
    language that sits on top of .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Once we understood what errors are, we looked at different ways in which PowerShell
    can handle those errors using the `$ErrorActionPreference` variable and the`-ErrorAction`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how we must turn errors into terminating errors so that we can use the
    most common way of trapping errors, the `Try`/`Catch`/`Finally` family of statements.
    We also learned how we can use those statements to provide custom error-handling
    routines.
  prefs: []
  type: TYPE_NORMAL
- en: Having seen how we work with errors, we learned how we can use a `Throw` statement
    to generate our own terminating errors when we encounter situations that are undesirable
    but don’t naturally cause an error.
  prefs: []
  type: TYPE_NORMAL
- en: Having explored how we deal with errors, we looked at the art of debugging in
    the second half of the chapter. We started by looking at the concept of script
    instrumentation using `Write-Debug`, and how we can use it to generate insights
    into what our code is doing when we use the `-Debug` parameter to access the debug
    output stream.
  prefs: []
  type: TYPE_NORMAL
- en: We moved on to looking at how we can perform interactive debugging on our scripts
    using debugging cmdlets such as `Set-PSBreakPoint` to access the built-in PowerShell
    debugger. After seeing how difficult that is, we concluded the chapter by looking
    at a far more powerful and much easier way of interactively debugging our scripts
    using VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to be looking at how we can distribute our
    code so that others can use it in a flexible fashion, by turning our scripts into
    modules. Can’t wait!
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In terms of running a script, what is the main difference between terminating
    and non-terminating errors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we access detailed information about errors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `-ErrorActionPreference` variable in PowerShell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `Write-Error` cmdlet in PowerShell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why might we want to use a `Throw` statement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we display debug messages in a script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we write debug messages in a script, and who are we writing them for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a breakpoint in PowerShell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `stepOver` debugger command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If debugging interests you, the best way to learn is by doing it. However,
    you can get a head start by reading *The Science of Debugging*, by Matt Telles
    and Yuan Hsieh:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Science of Debugging*, *Matt Telles* and *Yuan Hsieh*, *2001*, *Coriolis
    Group*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are some good docs on debugging PowerShell with VS Code that go into
    far more detail:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-1/](https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-1/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-2/](https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-2/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here is a more general link about the VS Code debugger:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://code.visualstudio.com/Docs/editor/debugging](https://code.visualstudio.com/Docs/editor/debugging)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This article has lots of interesting links, although some of them are a little
    old now:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode?view=powershell-7.3'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
