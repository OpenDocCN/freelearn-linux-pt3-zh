- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: PowerShell 7 for Linux and macOS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 和 macOS 的 PowerShell 7
- en: It is commonly said that Linux is the most popular operating system for servers,
    and while this is true, it doesn’t acknowledge that there are nearly as many types
    of Linux as there are actual servers. Whereas Windows and macOS are closely engineered
    and maintained by companies that are concerned that everybody should be running
    homogenous, secure, and often forcibly updated code, the Linux world is far more
    unrestricted, with a multiplicity of free, open source, and often barely maintained
    variations that seem to hang around on servers for years or sometimes decades.
    In this chapter, we’re going to look at how we can use PowerShell on some of the
    more common varieties of Linux; in our case, Ubuntu and CentOS, a free version
    of **Red Hat Enterprise** **Linux** (**RHEL**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通常说，Linux 是最受欢迎的服务器操作系统，虽然这是真的，但这并没有说明几乎每台服务器都有几种不同类型的 Linux。与 Windows 和 macOS
    的紧密工程化和维护不同，这些系统的公司致力于确保每个人都在运行同质、安全、并且经常强制更新的代码，而 Linux 世界则更加自由，拥有多种免费、开源且常常维护不足的变种，这些变种可能在服务器上存活多年甚至几十年。在本章中，我们将看看如何在一些常见的
    Linux 版本上使用 PowerShell；在我们的例子中，使用 Ubuntu 和 CentOS，它们是免费的 **Red Hat Enterprise
    Linux** (**RHEL**) 版本。
- en: We’re going to start by looking at how we can get access to a Linux machine
    to practice on; without that, this chapter would be pretty boring. Once we’ve
    got a machine, we will look at three different ways of installing PowerShell,
    using package managers and direct download.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解如何访问一台 Linux 机器进行练习；如果没有这个，本章内容会非常无聊。一旦我们有了机器，我们将探索三种不同的安装 PowerShell
    的方法，使用包管理器和直接下载。
- en: After that, we’ll install VS Code and see how to set it up on CentOS 7 before
    going on to look at some of the main differences we will see running PowerShell
    on Linux rather than Windows.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将安装 VS Code，并在 CentOS 7 上设置它，然后看看在 Linux 上运行 PowerShell 和在 Windows 上运行之间的主要区别。
- en: 'We will look at one of the most common ways of using PowerShell on Linux: remote
    sessions over the **Secure Shell** (**SSH**) protocol. This is important and is
    easily the most common way I see people logging in to Linux machines.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解在 Linux 上使用 PowerShell 的最常见方法之一：通过 **安全外壳协议** (**SSH**) 进行远程会话。这一点很重要，而且无疑是我看到人们登录
    Linux 机器时最常用的方法。
- en: Finally, we’ll take a quick look at how easy it is to install PowerShell and
    VS Code on macOS using the free open source package manager, Homebrew.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将快速了解如何使用免费开源包管理器 Homebrew 在 macOS 上轻松安装 PowerShell 和 VS Code。
- en: 'The main topics we will cover in this chapter are the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖的主要主题如下：
- en: Installing PowerShell 7
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 PowerShell 7
- en: Installing VS Code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 VS Code
- en: Running PowerShell on Linux
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 上运行 PowerShell
- en: Remoting with OpenSSH
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OpenSSH 远程连接
- en: PowerShell for macOS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS 上的 PowerShell
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Unless we already have a client running some form of Linux, we’ll need a Linux
    device to work on. There’s a really easy way to get one and a slightly harder
    way to get one. I’ve done both on my machine to get the screenshots for this chapter,
    providing a Ubuntu server (with no graphical interface) and a CentOS desktop client.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们已经有了运行某种 Linux 的客户端，否则我们需要一台 Linux 设备来工作。获取一台设备有两种方法，一种简单，另一种稍微困难一些。我在我的机器上做了这两种方法，获取了本章的截图，提供了一个没有图形界面的
    Ubuntu 服务器和一个 CentOS 桌面客户端。
- en: 'The Ubuntu server is very easy to install:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 服务器非常容易安装：
- en: 'Go to **Control Panel** | **Programs and Features** | **Turn Windows features
    on and off** and make sure the checkbox for **Windows Subsystem for Linux** is
    checked, like this:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 **控制面板** | **程序和功能** | **启用或关闭 Windows 功能**，确保选中 **Windows Subsystem for
    Linux**（Windows 子系统 Linux）的复选框，像这样：
- en: '![Figure 14.1 – Enabling Windows Subsystem for Linux](img/B17600_14_1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – 启用 Windows 子系统 Linux](img/B17600_14_1.jpg)'
- en: Figure 14.1 – Enabling Windows Subsystem for Linux
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – 启用 Windows 子系统 Linux
- en: '**Windows Subsystem for Linux** is displayed inside the red box.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows Subsystem for Linux** 在红色框中显示。'
- en: 'Once **Windows Subsystem for Linux** (**WSL**) is enabled, reboot, go to the
    Microsoft Store ([https://apps.microsoft.com](https://apps.microsoft.com)), and
    select a Linux application. I’m using the latest version of Ubuntu – 22.04:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦启用了 **Windows Subsystem for Linux**（**WSL**），重启计算机，访问 Microsoft Store ([https://apps.microsoft.com](https://apps.microsoft.com))，并选择一个
    Linux 应用。我使用的是最新版本的 Ubuntu – 22.04：
- en: '![Figure 14.2 – An Ubuntu app on the Microsoft Store](img/B17600_14_2.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – 在 Microsoft Store 中的 Ubuntu 应用](img/B17600_14_2.jpg)'
- en: Figure 14.2 – An Ubuntu app on the Microsoft Store
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 在 Microsoft Store 中的 Ubuntu 应用
- en: All I’ve done here is search for Ubuntu in the search box and select the most
    recent app.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里做的就是在搜索框中搜索 Ubuntu，并选择了最新的应用程序。
- en: 'Click on **Install**, and a Microsoft Store window will open; click on **Get**,
    and once the app is downloaded, the button will change to **Open**:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **安装**，会弹出一个 Microsoft Store 窗口；点击 **获取**，下载应用程序后，按钮会变成 **打开**：
- en: '![Figure 14.3 – The Microsoft Store app](img/B17600_14_3.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3 – Microsoft Store 应用](img/B17600_14_3.jpg)'
- en: Figure 14.3 – The Microsoft Store app
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – Microsoft Store 应用
- en: 'Click `Installing, this may take a few minutes...`. After a few minutes, we’ll
    be asked to create a username and then input a password twice, and that’s it.
    We now have a Ubuntu server running inside WSL on Windows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`正在安装，这可能需要几分钟...`。几分钟后，我们会被要求创建用户名，然后输入两次密码，完成后就可以了。现在，我们已经在 Windows 上的 WSL
    中运行了一个 Ubuntu 服务器：
- en: '![Figure 14.4 – Ubuntu on WSL](img/B17600_14_4.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4 – Ubuntu 在 WSL 上运行](img/B17600_14_4.jpg)'
- en: Figure 14.4 – Ubuntu on WSL
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – Ubuntu 在 WSL 上运行
- en: In the first line, I’ve created a new username, `nickp` (imaginative), and in
    the second and third, I’ve input the new password. Ubuntu hides the password when
    you type, but unlike Windows, it doesn’t do it by displaying dots or asterisks.
    It just displays... nothing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我创建了一个新的用户名 `nickp`（富有创意吧），在第二行和第三行，我输入了新的密码。Ubuntu 在输入时隐藏密码，但与 Windows
    不同，它不会通过显示点或星号来隐藏，而是完全不显示……什么都不显示。
- en: And that’s it – our Ubuntu environment is ready to have PowerShell installed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——我们的 Ubuntu 环境已经准备好安装 PowerShell。
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: These instructions are for Windows 10 Pro build 19045\. Different platforms
    such as Windows 11 or Windows Server may have different instructions for installing
    WSL. Also, this is WSL. There is another version called WSL2 for later operating
    systems.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些说明适用于 Windows 10 Pro 版本 19045。其他平台，如 Windows 11 或 Windows Server，可能有不同的安装
    WSL 的说明。另外，这是 WSL，后来的操作系统还有一个版本叫做 WSL2。
- en: I’ve also installed CentOS into Oracle VirtualBox; it would work just as well
    from the Microsoft Store, but I want a separate machine with a GUI we can use
    for this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我还在 Oracle VirtualBox 中安装了 CentOS；从 Microsoft Store 安装也完全可以，但我需要一台单独的机器，并且希望它有图形用户界面（GUI），我们可以在本章中使用。
- en: 'Instructions for installing VirtualBox are available here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 VirtualBox 的说明可以在这里找到：
- en: '[https://www.virtualbox.org/manual/UserManual.html#installation](https://www.virtualbox.org/manual/UserManual.html#installation)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.virtualbox.org/manual/UserManual.html#installation](https://www.virtualbox.org/manual/UserManual.html#installation)'
- en: It’s pretty straightforward.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单。
- en: 'Once VirtualBox is installed, we’ll need to download a CentOS image from here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 VirtualBox 安装完成，我们需要从这里下载 CentOS 镜像：
- en: '[http://isoredirect.centos.org/centos/7/isos](http://isoredirect.centos.org/centos/7/isos)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://isoredirect.centos.org/centos/7/isos](http://isoredirect.centos.org/centos/7/isos)'
- en: 'And we need to create a VM to install it on. There are good instructions for
    that here: [https://www.linuxfordevices.com/tutorials/centos/centos-on-virtualbox](https://www.linuxfordevices.com/tutorials/centos/centos-on-virtualbox).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个虚拟机来安装它。这里有很好的说明：[https://www.linuxfordevices.com/tutorials/centos/centos-on-virtualbox](https://www.linuxfordevices.com/tutorials/centos/centos-on-virtualbox)。
- en: I’ve installed CentOS 7 with a GNOME desktop GUI so that we can have a look
    at how to install PowerShell on older operating systems; I find that a lot of
    the Linux systems I work with are getting on a bit. I’m still using Ubuntu 12.04
    in some places. Precise Pangolin was a great name for an operating system, but
    really, we should all be on Jammy Jellyfish – at least for the sake of security.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我安装了带有 GNOME 桌面图形界面的 CentOS 7，这样我们就可以看看如何在较旧的操作系统上安装 PowerShell；我发现我使用的许多 Linux
    系统都已经有些年头了。有些地方我仍在使用 Ubuntu 12.04。精确穿山甲（Precise Pangolin）是一个很棒的操作系统名称，但实际上，我们都应该使用
    Jammy Jellyfish——至少为了安全起见。
- en: Finally, to follow the section on macOS, we’ll need a Mac of some description.
    I’m an absolute cheapskate, so I’ve borrowed a MacBook from my friend Paul that’s
    running OS 13, Ventura, which is pretty recent. Thanks, Paul.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了跟进 macOS 部分，我们需要一台 Mac。我是个极度节省的人，所以我借了朋友 Paul 的一台 MacBook，运行的是 OS 13 Ventura，这个版本相当新。谢谢你，Paul。
- en: Now we’ve covered the sort of environment we’ll need and how to install it,
    let’s look at installing PowerShell.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了我们需要的环境类型以及如何安装它，让我们来看看如何安装 PowerShell。
- en: Installing PowerShell 7
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 PowerShell 7
- en: 'Somewhat perversely, I find that installing PowerShell on Linux is probably
    easier than installing it on Windows, despite PowerShell being developed for Windows.
    Microsoft publishes good scripts that we can use for the supported versions of
    Linux; note, though, that there are very few supported flavors: RHEL, Ubuntu,
    Alpine, and Debian.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有些许反常的是，我发现将PowerShell安装在Linux上可能比在Windows上安装更容易，尽管PowerShell是为Windows开发的。微软发布了适用于支持版本Linux的好脚本；不过请注意，支持的Linux版本非常有限：RHEL、Ubuntu、Alpine和Debian。
- en: This doesn’t mean we can’t install PowerShell on other versions, only that Microsoft
    doesn’t provide any support for us. Microsoft only supports specific recent versions
    as well. Because of the rate at which both operating systems change, it’s worth
    making sure that our versions of PowerShell and Linux are on the supportability
    matrix; otherwise, we may get unexpected results, as we will see when we look
    at installing on CentOS.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们不能在其他版本上安装PowerShell，只是微软不提供任何支持。微软只支持特定的较新版本。而且，由于操作系统更新的速度较快，确保我们的PowerShell和Linux版本处于支持矩阵中是值得的；否则，我们可能会遇到意想不到的结果，正如我们在尝试在CentOS上安装时会看到的。
- en: Let’s start with Ubuntu, which I’ve got running in WSL on my Windows 10 client.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Ubuntu开始，我在我的Windows 10客户端中运行着Ubuntu的WSL。
- en: Installing PowerShell on Ubuntu 22.04
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Ubuntu 22.04上安装PowerShell
- en: 'In this section, we are going to install PowerShell 7.4 on Ubuntu 22.04\. Ubuntu
    is running inside WSL on my Windows 10 client, but it will work just as well on
    a VM or a physical machine. There are detailed alternative instructions here:
    [https://learn.microsoft.com/en-us/powershell/scripting/install/install-ubuntu](https://learn.microsoft.com/en-us/powershell/scripting/install/install-ubuntu).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装PowerShell 7.4版本在Ubuntu 22.04上。Ubuntu在我的Windows 10客户端中通过WSL运行，但在虚拟机或物理机器上同样适用。这里有详细的替代安装说明：[https://learn.microsoft.com/en-us/powershell/scripting/install/install-ubuntu](https://learn.microsoft.com/en-us/powershell/scripting/install/install-ubuntu)。
- en: 'Let’s have a go. We’re going to run the commands shown next:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试吧。我们将运行接下来的命令：
- en: 'In the first line, we are updating the local packages with the latest versions
    from the default repositories. This is good practice before installing any software
    on Linux. We use the `sudo` command to tell Linux that we want to use administrator
    privileges, or root privileges, to run the command. Obviously, to do that, we
    need to actually have those privileges, and we will be asked to input our account
    password to confirm that before we can run the command:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一行，我们正在从默认的软件库更新本地软件包至最新版本。在Linux上安装任何软件之前，这是一个好习惯。我们使用`sudo`命令告诉Linux我们希望使用管理员权限或根权限来执行该命令。显然，要做到这一点，我们需要拥有这些权限，并且在运行命令之前，系统会要求我们输入账户密码以确认：
- en: '[PRE0]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the second line, we’re installing some prerequisite packages:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二行，我们正在安装一些前置的软件包：
- en: '[PRE1]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the third line, we are grabbing the exact version of the operating system
    and then using that in the fourth line:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三行，我们正在获取操作系统的确切版本，然后在第四行使用它：
- en: '[PRE2]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'dpkg, the Ubuntu package management system:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: dpkg，Ubuntu的软件包管理系统：
- en: '[PRE3]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the sixth line, we’re deleting the key file for security:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第六行，我们正在删除密钥文件以确保安全：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: sudo apt-get update
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo apt-get update
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, in the eighth line, we’re installing PowerShell:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在第八行，我们正在安装PowerShell：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Linux is quite chatty, and we’ll see 60 or 70 lines of output as we type the
    preceding commands, but the process is very straightforward and works well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Linux输出非常详细，我们在输入上述命令时会看到60到70行输出，但整个过程非常直接，且运行良好。
- en: 'To start PowerShell, we simply type `pwsh`, and we will be taken to a PowerShell
    prompt, as in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动PowerShell，我们只需输入`pwsh`，即可进入PowerShell提示符，如下图所示：
- en: '![Figure 14.5 – Starting PowerShell on Ubuntu](img/B17600_14_5.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5 – 在Ubuntu上启动PowerShell](img/B17600_14_5.jpg)'
- en: Figure 14.5 – Starting PowerShell on Ubuntu
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – 在Ubuntu上启动PowerShell
- en: In the preceding screenshot, I started PowerShell with `pwsh`. Once PowerShell
    started, I called the `$PSVersionTable` automatic variable to get some information
    about the environment, including the version of PowerShell, the edition, and which
    operating system is running. I closed PowerShell by typing `exit`. If I’d wanted
    to keep PowerShell running in the background, I could have typed `bash` and gone
    to a Bash prompt instead. As we can see, we get the same color coding on Linux
    that we see on Windows, which helps to keep the experience consistent across platforms.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我用 `pwsh` 启动了 PowerShell。一旦 PowerShell 启动，我调用了 `$PSVersionTable` 自动变量来获取有关环境的一些信息，包括
    PowerShell 的版本、版本号以及运行的操作系统。我通过输入 `exit` 关闭了 PowerShell。如果我想让 PowerShell 在后台运行，我可以输入
    `bash`，然后切换到 Bash 提示符。正如我们所看到的，在 Linux 上，我们获得了与 Windows 相同的颜色编码，这有助于跨平台保持一致的体验。
- en: It’s good to know that tab completion works in Linux as well. One of the things
    that trips me up most often with Linux is capitalization; PowerShell on Windows
    has made me lazy. Therefore, being able to use tabs to complete paths is really
    useful. Note that PowerShell itself is not case-sensitive on Linux; `get-process`
    works just as well as `Get-Process`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Linux 中也支持制表符补全是很好的。Linux 中最常让我困惑的事情之一就是大小写问题；Windows 上的 PowerShell 已经让我变得懒惰。因此，能够使用制表符来完成路径非常有用。请注意，PowerShell
    在 Linux 上对大小写不敏感；`get-process` 和 `Get-Process` 作用一样。
- en: Let’s look now at installing PowerShell on CentOS.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下如何在 CentOS 上安装 PowerShell。
- en: Installing PowerShell on CentOS 8 and 9
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 CentOS 8 和 9 上安装 PowerShell
- en: 'Installing the latest version of PowerShell on recent versions of CentOS, CentOS
    8, or CentOS 9 (and also RHEL and Fedora) is very similar to installing it on
    Ubuntu, but using the `yum` package manager for RHEL 8 or the `dnf` package manager
    for RHEL 9; if anything, it’s even easier. Do note, however, that Microsoft only
    officially supports PowerShell on RHEL, not on CentOS or Fedora. We’re going to
    run the commands shown next:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 的最新版本（CentOS 8 或 CentOS 9）上安装 PowerShell 的过程与在 Ubuntu 上安装非常相似，只是使用了
    RHEL 8 的 `yum` 包管理器，或使用 RHEL 9 的 `dnf` 包管理器；如果说有区别的话，它甚至更简单。不过需要注意的是，微软官方只在 RHEL
    上支持 PowerShell，而不是 CentOS 或 Fedora。我们接下来要运行的是以下命令：
- en: 'In the first line, we’re using the `curl` application rather than `wget` to
    fetch PCM:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一行，我们使用 `curl` 应用程序而不是 `wget` 来获取 PCM：
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: sudo rpm -i packages-microsoft-prod.rpm
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo rpm -i packages-microsoft-prod.rpm
- en: '[PRE9]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the third line, we’re removing the key files, again:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三行，我们再次移除密钥文件：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the fourth line, we’re updating the package lists now we’ve registered the
    new repository:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第四行，我们正在更新软件包列表，现在我们已经注册了新的仓库：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: sudo dnf install powershell -y
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo dnf install powershell -y
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Troubleshooting tip
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除提示
- en: If this doesn’t work, there’s a pretty good chance that it’s the proxy settings.
    There are at least three different places in CentOS where we might find the proxy
    settings. For `yum`, it’s `/etc/yum.conf`. For `dnf`, it’s `/etc/dnf/dnf.conf`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不起作用，很有可能是代理设置的问题。在 CentOS 中，至少有三个不同的地方可能包含代理设置。对于 `yum`，它在 `/etc/yum.conf`。对于
    `dnf`，它在 `/etc/dnf/dnf.conf`。
- en: What happens if we want to use PowerShell on an older version, though? We must
    install a specific older version of PowerShell.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们想在旧版本上使用 PowerShell 怎么办？我们必须安装一个特定的旧版本 PowerShell。
- en: 'For RHEL 7 (and, therefore, CentOS 7), the last definitely good version of
    PowerShell was 7.2\. Early releases of 7.3 work, but later releases don’t, as
    they rely on Linux libraries that aren’t compatible with CentOS 7\. What we see
    if we try to install a recent version of PowerShell are error messages such as
    this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 RHEL 7（因此，也包括 CentOS 7），PowerShell 的最后一个可用版本是 7.2\. 7.3 的早期版本可以使用，但后续版本不行，因为它们依赖于与
    CentOS 7 不兼容的 Linux 库。如果我们尝试安装 PowerShell 的新版本，我们会看到类似这样的错误信息：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The answer here is to install PowerShell 7.2\. Let’s see how we do that.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的答案是安装 PowerShell 7.2\. 让我们看看如何做到这一点。
- en: Installing PowerShell on CentOS 7
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 CentOS 7 上安装 PowerShell
- en: 'Installing by direct download is really easy on CentOS; it’s one line:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 上通过直接下载安装非常简单；只需要一行命令：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All we’re doing here is using `yum`, the package manager on CentOS 7, to fetch
    and install a package from a URL. The trick here is knowing the URL of the package
    you need to download, though. All the packages are maintained on GitHub by Microsoft,
    here: [https://github.com/PowerShell/PowerShell/releases/](https://github.com/PowerShell/PowerShell/releases/).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是使用`yum`，CentOS 7上的包管理器，从URL获取并安装一个包。这里的技巧是知道你需要下载的包的URL。所有这些包都由Microsoft在GitHub上维护，网址是：[https://github.com/PowerShell/PowerShell/releases/](https://github.com/PowerShell/PowerShell/releases/)。
- en: 'To download a release, click on the link in the name of the package (in our
    case, `powershell-7.2.17-1.rh.x86_64.rpm`, and copy the hyperlink: [https://github.com/PowerShell/PowerShell/releases/download/v7.2.17/powershell-7.2.17-1.rh.x86_64.rpm](https://github.com/PowerShell/PowerShell/releases/download/v7.2.17/powershell-7.2.17-1.rh.x86_64.rpm).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载版本，点击软件包名称中的链接（在我们的例子中是`powershell-7.2.17-1.rh.x86_64.rpm`），并复制超链接：[https://github.com/PowerShell/PowerShell/releases/download/v7.2.17/powershell-7.2.17-1.rh.x86_64.rpm](https://github.com/PowerShell/PowerShell/releases/download/v7.2.17/powershell-7.2.17-1.rh.x86_64.rpm)。
- en: 'Once we have that, we pass it to `sudo yum install`, like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了它，就可以像这样将其传递给`sudo yum install`：
- en: '![Figure 14.6 – Installing PowerShell on CentOS 7 using a direct download](img/B17600_14_6.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6 - 在CentOS 7上使用直接下载安装PowerShell](img/B17600_14_6.jpg)'
- en: Figure 14.6 – Installing PowerShell on CentOS 7 using a direct download
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 - 在CentOS 7上使用直接下载安装PowerShell
- en: In the first line, I’ve run the direct download command, as shown previously.
    The rest of the screen output is chat from the operating system, telling us what
    it is doing. There are quite a few more lines of this before we finally get to
    run PowerShell. It’s a very easy way to install PowerShell; the downside is that
    we don’t register the Microsoft repository.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我运行了之前展示过的直接下载命令。其余的屏幕输出是操作系统的聊天信息，告诉我们它正在做什么。在我们最终运行PowerShell之前，还有很多行这样的输出。这是安装PowerShell的一个非常简单的方法；缺点是我们没有注册Microsoft的仓库。
- en: That is pretty much all we’re going to cover on installing PowerShell on Linux;
    we’ve covered representatives of the two main families of Linux, Ubuntu and CentOS,
    and we’ve looked at how we can install different versions of PowerShell. Let’s
    look now at how we can install VS Code on Linux. We’ll be using my CentOS system
    because that has a GUI.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是我们在Linux上安装PowerShell时要涵盖的内容；我们已经涵盖了两个主要Linux发行版的代表，Ubuntu和CentOS，并且我们已经了解了如何安装不同版本的PowerShell。现在让我们来看看如何在Linux上安装VS
    Code。我们将使用我的CentOS系统，因为它有图形界面。
- en: Installing VS Code
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装VS Code
- en: 'Installing VS Code on Linux is straightforward. On recent Ubuntu machines,
    we can use `snapd`, a package management system for Ubuntu, like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上安装VS Code是简单的。在最近的Ubuntu机器上，我们可以像这样使用`snapd`，一个Ubuntu的包管理系统：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And that’s it. On RHEL and CentOS machines, we may need to enable `snapd` first,
    before we can use it to install code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。在RHEL和CentOS机器上，我们可能需要先启用`snapd`，然后才能使用它来安装VS Code。
- en: 'We’re going to run the commands shown next:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行接下来的命令：
- en: 'In the first line, we are installing the `snapd` package:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一行中，我们正在安装`snapd`包：
- en: '[PRE16]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '/snap to /var/lib/snapd/snap:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /snap 到 /var/lib/snapd/snap：
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, we need to log out and log back in, or reboot the machine, to make
    sure that everything is updated.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要注销并重新登录，或者重启计算机，以确保所有内容都已更新。
- en: We’re now ready to use `snap` to install VS Code, as before. The big advantage
    of using `snap` is that it will keep VS Code updated in the background.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备像之前一样使用`snap`来安装VS Code。使用`snap`的最大优势是它会在后台保持VS Code的更新。
- en: 'We can also install VS Code manually if we don’t have access to `snap`. We
    can do it like this on CentOS 7:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法使用`snap`，也可以手动安装VS Code。在CentOS 7上，我们可以这样做：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will register the Microsoft GPG encryption keys with `rpm`, the CentOS
    7 package manager. Next, type the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`rpm`，CentOS 7的包管理器，注册Microsoft的GPG加密密钥。接下来，键入以下内容：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will create an empty text file called `vscode.repo`. We need to add some
    lines to this file and save it, so type this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`vscode.repo`的空文本文件。我们需要向该文件中添加一些行并保存，因此请键入以下内容：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Press *Ctrl* and *X* to exit, and answer `y` when prompted to save the file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Ctrl*和*X*退出，并在提示保存文件时按`y`。
- en: 'The `vscode.repo` file should look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`vscode.repo`文件应该是这样的：'
- en: '![Figure 14.7 – The vscode.repo file in nano](img/B17600_14_7.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图14.7 - 使用nano查看vscode.repo文件](img/B17600_14_7.jpg)'
- en: Figure 14.7 – The vscode.repo file in nano
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7 - 使用nano查看vscode.repo文件
- en: When we create the file, it is empty, and we must type in the code and then
    save and exit.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建文件时，它是空的，我们必须输入代码并保存退出。
- en: 'Finally, to install VS Code, type the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，安装 VS Code，请输入以下命令：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That’s it. We can start VS Code by typing `code` at the terminal prompt. VS
    Code works exactly the same way in Linux as it does in Windows. Refer to the *Configuring
    VS Code for PowerShell* section of [*Chapter 5*](B17600_05.xhtml#_idTextAnchor096),
    *PowerShell Control Flow – Conditionals* *and Loops*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们可以通过在终端提示符下输入`code`来启动 VS Code。VS Code 在 Linux 和 Windows 上的工作方式完全相同。请参阅
    [*第 5 章*](B17600_05.xhtml#_idTextAnchor096) 的 *配置 VS Code 用于 PowerShell* 部分，*PowerShell
    控制流 – 条件语句* *和循环*。
- en: Now we’ve got everything installed, let’s look at how we can use PowerShell
    on Linux.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装好了一切，让我们看看如何在 Linux 上使用 PowerShell。
- en: Running PowerShell on Linux
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 上运行 PowerShell
- en: Mostly, PowerShell works exactly the same on Linux as it does on Windows, but
    obviously, there are some differences between the two underlying operating systems
    that we need to be aware of and subsequently understand how PowerShell handles
    them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，PowerShell 在 Linux 上的工作方式与 Windows 上完全相同，但显然，两种操作系统之间存在一些差异，我们需要注意并理解 PowerShell
    如何处理这些差异。
- en: 'Case sensitivity is the obvious one; while `get-content` works as well as `Get-Content`
    on Linux, `get-content ./myfile.txt` doesn’t work if the file is called `MyFile.txt`;
    see the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 大小写敏感是显而易见的区别；虽然在 Linux 上 `get-content` 与 `Get-Content` 是等效的，但如果文件名是 `MyFile.txt`，则
    `get-content ./myfile.txt` 不会生效；请看下面的截图：
- en: '![Figure 14.8 – The importance of capitalization](img/B17600_14_8.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.8 – 大小写的重要性](img/B17600_14_8.jpg)'
- en: Figure 14.8 – The importance of capitalization
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8 – 大小写的重要性
- en: As you can see, if the capitalization of the path or filename is incorrect,
    then PowerShell can’t find the file. The best way I have found to compensate for
    this is to use tab completion as much as possible, as tab completion ignores capitalization,
    so typing `myfi` and pressing *Tab* will find a file called `MyFile.txt`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果路径或文件名的大小写不正确，PowerShell 将无法找到该文件。我找到的最佳解决方法是尽可能使用 Tab 完成，因为 Tab 完成忽略大小写，所以输入
    `myfi` 并按下 *Tab* 键会找到名为 `MyFile.txt` 的文件。
- en: 'The filesystems are different, also. Linux doesn’t use letters to distinguish
    drives and uses forward slashes (`/`) instead of backslashes (`\`). PowerShell
    recognizes both as a file path separator, so there is no functional difference
    between `Get-Content ./MyFile.txt` and `Get-Content .\MyFile.txt`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统也不同。Linux 不使用字母区分驱动器，而是使用正斜杠 (`/`)，而不是反斜杠 (`\`)。PowerShell 识别两者作为文件路径分隔符，因此
    `Get-Content ./MyFile.txt` 和 `Get-Content .\MyFile.txt` 没有功能上的区别：
- en: '![Figure 14.9 – Versatile path separators](img/B17600_14_9.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.9 – 多功能路径分隔符](img/B17600_14_9.jpg)'
- en: Figure 14.9 – Versatile path separators
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9 – 多功能路径分隔符
- en: As you can see, we get the contents of the file whichever file path separator
    we choose. This makes writing cross-platform scripts easier.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，无论我们选择哪种文件路径分隔符，都能获取到文件的内容。这使得编写跨平台脚本变得更容易。
- en: 'I have made my views on aliases known already, and it appears my furious letter
    writing has paid off, because PowerShell 7 on Linux no longer includes common
    aliases such as `ls`, although they persist when running PowerShell 7 on Windows.
    Instead, PowerShell now calls the Bash command, like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经表明了我对别名的看法，看来我的愤怒信件写作有了回报，因为 PowerShell 7 在 Linux 上不再包含像 `ls` 这样的常用别名，尽管它们在
    Windows 上运行 PowerShell 7 时仍然存在。相反，PowerShell 现在调用 Bash 命令，像这样：
- en: '![Figure 14.10 – Fewer aliases in PowerShell 7 on Linux](img/B17600_14_10.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.10 – PowerShell 7 在 Linux 上的别名减少](img/B17600_14_10.jpg)'
- en: Figure 14.10 – Fewer aliases in PowerShell 7 on Linux
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10 – PowerShell 7 在 Linux 上的别名减少
- en: We can see the difference between running `ls` in Bash and PowerShell in the
    preceding screenshot. The output is the same, but we don’t get the color coding
    we get when running in Bash. By contrast, we get a completely different type of
    output when we run `Get-ChildItem`. Compare this to the behavior on Windows, where
    `ls` is an alias for `Get-ChildItem`. Other Linux commands that are no longer
    aliased include `cp`, `mv`, `rm`, `cat`, `man`, `mount`, and `ps`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到在 Bash 和 PowerShell 中运行 `ls` 的区别。输出是相同的，但我们在 Bash 中运行时没有颜色编码。相比之下，当我们运行
    `Get-ChildItem` 时，输出完全不同。与 Windows 上的行为对比，`ls` 在 Windows 上是 `Get-ChildItem` 的别名。其他不再有别名的
    Linux 命令包括 `cp`、`mv`、`rm`、`cat`、`man`、`mount` 和 `ps`。
- en: 'Running as an administrator is different on Linux, as well. People familiar
    with Linux will be used to running commands with the `sudo` prefix to run the
    command as root. This won’t work in PowerShell. Instead, we must start PowerShell
    with `sudo`, like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上以管理员身份运行也有所不同。熟悉 Linux 的人通常习惯使用 `sudo` 前缀来以 root 用户身份运行命令。这在 PowerShell
    中不起作用。相反，我们必须以 `sudo` 启动 PowerShell，像这样：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will give us a new PowerShell session running with root privileges.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供一个具有 root 权限的新 PowerShell 会话。
- en: Given that one of the big attractions of running PowerShell on Linux (and macOS,
    and ARM) is that we can start to write cross-platform scripts, how do we know
    which platform our script is running on? Easy – we test the automatic variables.
    There are three automatic variables called `$IsWindows`, `$IsLinux`, and `$IsMacOS`,
    which return either `true` or `false`, depending on the operating system. We can
    use these variables to write `if` statements in our scripts that alter behavior
    depending on the environment.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于在 Linux（以及 macOS 和 ARM）上运行 PowerShell 的一个主要吸引力是我们可以开始编写跨平台脚本，那么如何知道我们的脚本在哪个平台上运行呢？很简单——我们测试自动变量。有三个自动变量，分别是
    `$IsWindows`、`$IsLinux` 和 `$IsMacOS`，根据操作系统的不同，这些变量会返回 `true` 或 `false`。我们可以使用这些变量在脚本中编写
    `if` 语句，以根据环境改变行为。
- en: Activity – Writing a cross-platform script
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 —— 编写跨平台脚本
- en: Given what we’ve learned previously, write a cross-platform script that will
    run on both Windows and Linux and return five running processes with the highest
    current CPU usage. Output the processes in descending order to a text file with
    a name that includes the name of the computer it was run on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前学到的内容，编写一个跨平台脚本，能够在 Windows 和 Linux 上运行，并返回当前 CPU 使用率最高的五个进程。将进程按降序输出到一个文本文件中，文件名应包含运行该脚本的计算机名称。
- en: We can get the name of the computer in Windows with `$env:computername`, and
    in Linux by typing `hostname`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Windows 中使用 `$env:computername` 获取计算机名称，而在 Linux 中可以通过输入 `hostname` 来获取。
- en: Of course, much of the time, we won’t actually be running commands and scripts
    directly on a Linux machine; most of the time, we will want to remote into it.
    In the next section, we’ll look at the recommended way of remoting into Linux
    machines.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，大多数时候，我们不会直接在 Linux 机器上运行命令和脚本；大多数时候，我们会想要远程连接到它。在接下来的部分中，我们将看看远程连接到 Linux
    机器的推荐方法。
- en: Remoting with OpenSSH
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenSSH 进行远程连接
- en: We saw in [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236), *Securing PowerShell*,
    that remoting was a powerful way to establish a connection with a machine and
    take control. When we looked at remoting in that chapter, we explored remoting
    over the **Windows Remote Management** (**WinRM**) protocol on other Windows machines.
    We mentioned that we could also use SSH to establish remote sessions. Linux does
    not support the WinRM protocol, so we must use SSH to remotely administer it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B17600_12.xhtml#_idTextAnchor236)《确保 PowerShell 安全》一节中，我们看到远程连接是一种强大的方式，可以与机器建立连接并进行控制。当我们在该章节中探讨远程连接时，我们研究了在其他
    Windows 机器上通过**Windows 远程管理**（**WinRM**）协议进行远程连接。我们还提到过可以使用 SSH 来建立远程会话。由于 Linux
    不支持 WinRM 协议，因此我们必须使用 SSH 来远程管理它。
- en: OpenSSH is an open source SSH toolset that is almost ubiquitous on Linux and
    other Unix machines. Since 2018, it has been available for Windows and makes managing
    heterogeneous environments much easier. It can be a bit tricky to set up, but
    once it is working, it makes remoting very easy. Let’s take a look.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH 是一个开源的 SSH 工具集，在 Linux 和其他 Unix 系统上几乎是无处不在的。从 2018 年起，它也可以在 Windows
    上使用，使得管理异构环境变得更加容易。设置它可能有些复杂，但一旦配置完成，它会让远程连接变得非常简单。让我们来看看。
- en: Checking that PowerShell has OpenSSH support
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 PowerShell 是否支持 OpenSSH
- en: 'The first thing to check is that our version of PowerShell 7 has got OpenSSH
    support; if we’ve downloaded and installed it from GitHub, then we should be OK,
    but first, let’s check using the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要检查的是，我们的 PowerShell 7 版本是否支持 OpenSSH；如果我们从 GitHub 下载并安装了它，那么应该没问题，但首先让我们使用以下命令进行检查：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we see parameter sets called `SSHHost` and `SSHHostHashParam`, then we are
    good to go. If not, then we should download a recent version of PowerShell 7 from
    GitHub.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看到名为 `SSHHost` 和 `SSHHostHashParam` 的参数集，那么我们就可以继续了。如果没有，则应从 GitHub 下载最新版本的
    PowerShell 7。
- en: Installing OpenSSH on Windows
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 OpenSSH
- en: We only need to install OpenSSH on Windows if we are going to want to remote
    into that Windows machine. If we’re going to remote from it to other machines,
    then we can skip installing it; PowerShell already has a working SSH client that
    will allow us to connect to Linux machines using PowerShell remoting.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在Windows上安装OpenSSH，前提是我们想要远程连接到这台Windows机器。如果我们要从这台机器远程连接到其他机器，则可以跳过安装它；PowerShell已经内置了一个可以使用PowerShell远程连接Linux机器的SSH客户端。
- en: 'If we decide we want to install an OpenSSH server, then we first need to check
    if we are running on a viable version of Windows and that we have the correct
    rights. Start an elevated administrator PowerShell session, and type the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定要安装OpenSSH服务器，那么首先需要检查我们是否正在运行一个可行版本的Windows，并且我们是否拥有正确的权限。启动一个提升权限的管理员PowerShell会话，然后输入以下内容：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is what I get on my machine:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在机器上得到的结果：
- en: '![Figure 14.11 – Checking OpenSSH prerequisites on Windows](img/B17600_14_11.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图14.11 – 检查Windows上OpenSSH的前提条件](img/B17600_14_11.jpg)'
- en: Figure 14.11 – Checking OpenSSH prerequisites on Windows
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11 – 检查Windows上OpenSSH的前提条件
- en: 'As we can see, my rights test returns `True`, so I do have the correct rights,
    and when I run `winver.exe`, the pop-up window shows I am running Windows 10 22H2,
    more recent than the minimum version of Windows 10 1809\. We’re ready to install.
    In the elevated prompt we’ve just used, type the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我的权限测试返回了`True`，说明我确实拥有正确的权限，当我运行`winver.exe`时，弹出窗口显示我正在运行Windows 10
    22H2版本，比最低要求的Windows 10 1809版本还要新。我们已经准备好安装了。在刚才使用的提升权限提示符中，输入以下内容：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will install OpenSSH. We also need to start the `sshd` service and set
    it to automatically start up:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装OpenSSH。我们还需要启动`sshd`服务，并将其设置为自动启动：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we need to configure `sshd` to allow PowerShell to use it. Open `notepad.exe`
    as an administrator (right-click and choose `C:\ProgramData\ssh\sshd_config` file,
    add the following lines above the last entry in the file, and save the file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要配置`sshd`以允许PowerShell使用它。以管理员身份打开`notepad.exe`（右键点击并选择`C:\ProgramData\ssh\sshd_config`文件，在文件的最后一行之前添加以下行，并保存文件：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `-``nologo` parameter isn’t needed if we’re using PowerShell 7.4 or later.
    Be careful not to save the file as `sshd_config.txt`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是PowerShell 7.4或更高版本，则`-``nologo`参数不再需要。小心不要将文件保存为`sshd_config.txt`。
- en: Warning!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！
- en: Wait! What’s that `c:/progra~1/powershell/7/pwsh.exe` path all about? Working
    with non-Microsoft open source software on Windows can be frustrating at times.
    OpenSSH is an example. It doesn’t understand paths with a space in them, even
    if the path is enclosed in single or double quotes, and so we have to use something
    called 8.3 format, which is the short filename format that we used to use with
    older Microsoft operating systems.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！那条`c:/progra~1/powershell/7/pwsh.exe`路径是怎么回事？在Windows上使用非微软的开源软件有时会令人沮丧。OpenSSH就是一个例子。它无法理解带有空格的路径，即使路径被单引号或双引号括起来，因此我们不得不使用一种叫做8.3格式的东西，这是一种旧版微软操作系统中使用的短文件名格式。
- en: 'Unfortunately, it’s even more complicated. Some releases of OpenSSH don’t like
    that format either; when we add the PowerShell subsystem into the `sshd_config`
    file, the `sshd` service refuses to start. The answer here is to side-load another
    copy of PowerShell into a directory with no spaces and no names longer than eight
    characters. To get mine to work, I downloaded the PowerShell 7.4 ZIP file from
    the PowerShell GitHub pages, unblocked it by right-clicking on the downloaded
    file, selecting `c:\scratch\pwsh`. I then added this line to `sshd_config`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，情况更复杂。一些版本的OpenSSH也不喜欢这种格式；当我们将PowerShell子系统添加到`sshd_config`文件中时，`sshd`服务拒绝启动。这里的解决办法是将另一个PowerShell副本侧载到一个没有空格、且文件夹名不超过八个字符的目录中。为了让它正常工作，我从PowerShell
    GitHub页面下载了PowerShell 7.4的ZIP文件，通过右键点击下载的文件并选择`c:\scratch\pwsh`来解锁它。然后，我将以下行添加到`sshd_config`中：
- en: '`Subsystem powershell` `c:/scratch/pwsh/pwsh.exe -sshs`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subsystem powershell` `c:/scratch/pwsh/pwsh.exe -sshs`'
- en: And now, the `sshd` service will start normally.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`sshd`服务将正常启动。
- en: 'Finally, restart the service with the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用以下命令重新启动服务：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And that’s it. Our Windows machine is ready to receive PowerShell remoting over
    OpenSSH.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们的Windows机器已经准备好通过OpenSSH接收PowerShell远程连接。
- en: Installing OpenSSH on Linux
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Linux上安装OpenSSH
- en: 'Now, we have to configure OpenSSH on Linux. We’re going to use my CentOS 7
    machine, which already has OpenSSH installed, but if we wanted to install it on
    an Ubuntu machine, we’d need to install it first with the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在Linux上配置OpenSSH。我们将使用我的CentOS 7机器，它已经安装了OpenSSH，但如果我们想在Ubuntu机器上安装它，首先需要使用以下命令安装：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once OpenSSH is installed, we need to edit the `sshd_config` file at `/etc/ssh`.
    To do this, we need to start our text editor with `sudo`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了OpenSSH，我们需要编辑`/etc/ssh`下的`sshd_config`文件。为此，我们需要使用`sudo`启动文本编辑器：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We need to add the following lines:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加以下几行：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we save the file. Next, we need to restart the `sshd` service:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们保存文件。接下来，我们需要重新启动`sshd`服务：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And then, we set it to start automatically:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置它自动启动：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And that’s us set up for remoting. Note that the final command may throw an
    error if it is already enabled.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们设置远程连接的方式。请注意，如果最后的命令已经启用，可能会抛出错误。
- en: Running remote sessions
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行远程会话
- en: 'Using remote sessions over SSH is just as easy as using them over WinRM, which
    we saw in [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236), *Securing PowerShell*.
    We start out by creating a session object:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SSH使用远程会话和使用WinRM一样简单，我们在[*第12章*](B17600_12.xhtml#_idTextAnchor236)中看到过，*Securing
    PowerShell*。我们首先创建一个会话对象：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Notice that we’re using the `-HostName` parameter, not the `-ComputerName`
    parameter. This tells PowerShell to create an SSH session, not a WinRM one. We’ll
    be asked to input the user’s password, and then the session object is created.
    We can then use the variable containing the session object to start a remote session:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用的是`-HostName`参数，而不是`-ComputerName`参数。这告诉PowerShell创建一个SSH会话，而不是WinRM会话。系统会要求我们输入用户的密码，然后创建会话对象。然后我们可以使用包含会话对象的变量来启动远程会话：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We’ll see the prompt change to reflect the machine that we are remoting into,
    and we are straight into a PowerShell session on that machine. To leave the session,
    we can just type `exit` and return to the local machine. This is how it looks
    in practice:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会看到提示符变化，反映我们正在远程连接的机器，并且直接进入该机器上的PowerShell会话。要离开会话，我们只需输入`exit`并返回本地机器。这是实际操作的样子：
- en: '![Figure 14.12 – SSH remoting into a Linux server](img/B17600_14_12.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图14.12 – 通过SSH远程连接到Linux服务器](img/B17600_14_12.jpg)'
- en: Figure 14.12 – SSH remoting into a Linux server
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12 – 通过SSH远程连接到Linux服务器
- en: 'The numbering in the preceding screenshot is explained as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图中的编号解释如下：
- en: In *line 1*, I’m creating a new session object and storing it in a variable.
    I’m passing the IP address of the remote machine because I haven’t set up name
    resolution. I’m also passing the username of a user on the remote machine who
    has the right to log in.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第1行*，我创建了一个新的会话对象并将其存储在变量中。我传递了远程机器的IP地址，因为我没有设置名称解析。我还传递了一个具有登录权限的远程机器用户的用户名。
- en: In *line 2*, I am asked for the remote user’s password; once it is provided,
    the session object is created.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第2行*，系统会要求输入远程用户的密码；一旦密码输入，会创建会话对象。
- en: In *line 3*, I’m calling the `$session` variable, and the properties of the
    new session are displayed.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第3行*，我调用了`$session`变量，显示了新会话的属性。
- en: In *line 4*, I’m passing the `$session` variable to `Enter-PSSession`, and I’m
    entering a remote session.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第4行*，我将`$session`变量传递给`Enter-PSSession`，并进入了远程会话。
- en: 'In *line 5*, we can see that the prompt has changed to `[nick@192.168.56.101]:
    PS /home/nick>`, which tells us I’m in a PowerShell session on the machine at
    `192.168.56.101` and I’m logged in as `nick`. The working directory is `/home/nick`.
    I’m running the `Get-Process` PowerShell cmdlet, looking for processes containing
    the `shell` string, and I get two `gnome` processes returned. This is definitely
    Linux – my CentOS 7 GUI box, to be precise. If we run it on Ubuntu, we may not
    see any processes at all if there is no GUI installed.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在*第5行*，我们可以看到提示符已经变更为`[nick@192.168.56.101]: PS /home/nick>`，这告诉我们我正在`192.168.56.101`的机器上进行PowerShell会话，并且登录用户名是`nick`。工作目录是`/home/nick`。我正在运行`Get-Process`
    PowerShell cmdlet，查找包含`shell`字符串的进程，返回了两个`gnome`进程。这显然是Linux——更准确地说，是我的CentOS
    7图形界面系统。如果我们在Ubuntu上运行，可能根本看不到任何进程，前提是没有安装图形界面。'
- en: 'In *line 6*, I run the `hostname` Bash command, and the name of the remote
    system is returned: `localhost.localdomain`.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第6行*，我运行了`hostname` Bash命令，返回了远程系统的名称：`localhost.localdomain`。
- en: In *line 7*, just so there is no doubt, we can see that the value of the `$IsLinux`
    automatic variable is `True`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第7行*，为了避免疑惑，我们可以看到`$IsLinux`自动变量的值是`True`。
- en: Finally, on *line 8*, I type `exit` and am returned to my local PowerShell session
    running on Windows.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在*第8行*，我输入`exit`并返回到我本地运行在Windows上的PowerShell会话。
- en: The trouble is, I’ve used a username and password combination here, and many
    Linux machines will be set up to use key-based authentication. Let’s take a look
    at how we can set that up.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，我在这里使用了用户名和密码组合，而许多Linux机器将被设置为使用基于密钥的身份验证。让我们来看看如何设置它。
- en: Authentication
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证
- en: Key-based authentication is a more secure way of using SSH for PowerShell remoting.
    It also makes it easier to automate scripts, as once it is set up, no one needs
    to manually enter a password. Let’s look at how we can get it working.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 基于密钥的身份验证是一种更安全的SSH远程访问方式。它还使得自动化脚本更加简单，因为一旦设置完成，就不需要手动输入密码。让我们看看如何使它正常工作。
- en: 'PowerShell 7 includes a utility called `Ssh-keygen` that we can use to create
    a public/private key pair that we can use to authenticate ourselves to the remote
    machine. We can use it like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 7包括一个名为`Ssh-keygen`的工具，我们可以使用它来创建公钥/私钥对，进而用来认证我们自己到远程机器。我们可以这样使用它：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We’re asking PowerShell to generate a key pair using the Ed21559 algorithm,
    which is quite modern. Older systems may require that we use the RSA algorithm
    instead. We will be asked for a path to save the files to; it’s best to accept
    the default one by just pressing *Enter*. We will also be asked to enter a passphrase;
    again, this is optional, and we can just press *Enter* twice to save the files
    with no passphrase.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在要求PowerShell使用Ed21559算法生成一个密钥对，这是相当现代的算法。较旧的系统可能需要我们改用RSA算法。系统会要求我们提供保存文件的路径，最好接受默认路径，只需按*Enter*即可。系统还会要求输入密码短语；同样，这个步骤是可选的，我们可以按*Enter*两次以保存没有密码短语的文件。
- en: 'Now, we can save the public key onto the Linux machine in the `.ssh` directory
    of the user we want to log in with. PowerShell has another utility called `scp`
    that we can use to copy the file across (note that we might need to create a .`ssh`
    directory first):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将公钥保存到Linux机器的`.ssh`目录中，保存路径是我们想要登录的用户目录。PowerShell还有一个叫做`scp`的工具，我们可以用它来复制文件（注意，可能需要先创建一个.`ssh`目录）：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'I’m using `scp` with two parameters here – the first is the path to the file
    we’ve created, and the second is the path we want it copied to. We’ll be asked
    to provide the password for the remote user again, but that’s the last time we’ll
    need to do that. Now, when we log in as that user, we will pass a hash of our
    private key on the local machine that pairs with the hash of the public key on
    the remote machine, and we will be recognized as the remote user. This is how
    it looks on my machine:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用`scp`传递两个参数——第一个是我们创建的文件路径，第二个是我们希望将文件复制到的路径。我们会再次被要求提供远程用户的密码，但这是我们最后一次需要这样做。现在，当我们以该用户身份登录时，我们将传递本地机器上私钥的哈希值，这个哈希与远程机器上公钥的哈希值配对，我们就会被识别为远程用户。这就是它在我的机器上的表现：
- en: '![Figure 14.13 – Setting up key-based authentication](img/B17600_14_13.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.13 – 设置基于密钥的身份验证](img/B17600_14_13.jpg)'
- en: Figure 14.13 – Setting up key-based authentication
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13 – 设置基于密钥的身份验证
- en: 'In the preceding screenshot, I’ve run the commands needed to set up key-based
    authentication:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我已经运行了设置基于密钥身份验证所需的命令：
- en: In *line 1*, I am running `Ssh-keygen` to create my key pair.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第1行*，我运行`Ssh-keygen`来创建我的密钥对。
- en: In *line 2*, I’m accepting the default path by pressing *Enter*.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第2行*，我通过按*Enter*接受默认路径。
- en: In *line 3*, I’m setting a blank passphrase by pressing *Enter* twice.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第3行*，我通过按*Enter*两次设置了一个空的密码短语。
- en: In *line 4*, I’m using `scp` to copy the public key across to the user `.ssh`
    directory on the remote machine.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第4行*，我使用`scp`将公钥复制到远程机器上用户的`.ssh`目录中。
- en: In *line 5*, I’m providing the password – hopefully for the last time ever.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第5行*，我提供了密码——希望这是最后一次提供密码。
- en: In *line 6*, I am storing a new session object in a variable called `$sessionSSH`.
    Notice that I am not providing a password, but I am providing the path to the
    private key in the `-``KeyFilePath` parameter.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第6行*，我将一个新的会话对象存储在名为`$sessionSSH`的变量中。请注意，我没有提供密码，而是提供了`-``KeyFilePath`参数中的私钥路径。
- en: In *line 7*, I’m calling the variable to check the properties.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第7行*，我正在调用变量以检查其属性。
- en: In *line 8*, I am entering the session using the `$``sessionSSH` variable.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第8行*，我正在使用`$``sessionSSH`变量进入会话。
- en: In the final line, we can see that the prompt has changed to reflect that I
    am working in a remote session.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一行，我们可以看到提示符已经改变，表明我正在远程会话中工作。
- en: 'There’s an awful lot more to using SSH, but that is enough to get us started.
    Let’s move on to the final section of this chapter: *PowerShell* *for macOS*.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SSH 还有很多要学的内容，但这些已经足够让我们入门。接下来，我们进入本章的最后部分：*macOS 上的 PowerShell*。
- en: PowerShell for macOS
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS 上的 PowerShell
- en: macOS is very similar to Linux; both operating systems are based on elements
    of Unix, and many Linux programs can run on macOS without modifying the source
    code. The differences we will focus on here are how we install PowerShell and
    VS Code. I’ve used a friend’s MacBook, which is running Ventura (macOS 13). If
    anything, installing on macOS is even easier than installing on Linux.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: macOS 与 Linux 非常相似；这两个操作系统都基于 Unix 元素，并且许多 Linux 程序可以在 macOS 上运行，无需修改源代码。我们将关注的差异在于如何安装
    PowerShell 和 VS Code。我使用了一个朋友的 MacBook，它运行的是 Ventura（macOS 13）。如果有什么不同的话，在 macOS
    上安装比在 Linux 上更简单。
- en: Installing Homebrew on macOS
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 Homebrew
- en: 'Homebrew is a free open source package manager that works on Linux and macOS,
    but mostly we see it on macOS. It’s very easy to install and use, and it’s what
    we’re going to use to install PowerShell and VS Code on macOS. It’s a one-line
    installation. Open the terminal and type the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Homebrew 是一个免费的开源包管理器，适用于 Linux 和 macOS，但我们大多在 macOS 上看到它。它非常容易安装和使用，正是我们用来在
    macOS 上安装 PowerShell 和 VS Code 的工具。它是通过一行命令安装的。打开终端并输入以下命令：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We’re passing a `curl` command to the `bash` shell here to download and run
    a Bash script from a URL. We’ll probably be asked to provide our password. macOS
    is just as chatty as Linux, but after a few minutes, we should see a message saying
    `Installation successful!`. Now, we’re ready to install PowerShell.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `curl` 命令传递给 `bash` shell，从一个 URL 下载并运行一个 Bash 脚本。可能会要求我们提供密码。macOS 和 Linux
    一样健谈，但几分钟后，我们应该会看到一条消息，显示 `安装成功！`。现在，我们可以安装 PowerShell 了。
- en: Installing PowerShell on macOS
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 PowerShell
- en: 'Once we’ve got Homebrew installed, everything else is easy. To install PowerShell,
    we type the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Homebrew，其他一切都很简单。要安装 PowerShell，我们输入以下命令：
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And that’s it. We can start PowerShell by typing `pwsh` in the terminal. This
    is how it looks on Paul’s machine:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们可以通过在终端中输入 `pwsh` 启动 PowerShell。这是 Paul 机器上的样子：
- en: '![Figure 14.14 – Installing PowerShell on macOS](img/B17600_14_14.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.14 – 在 macOS 上安装 PowerShell](img/B17600_14_14.jpg)'
- en: Figure 14.14 – Installing PowerShell on macOS
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.14 – 在 macOS 上安装 PowerShell
- en: In *line 1*, I’m installing PowerShell using Homebrew. In *line 2*, I’m starting
    PowerShell with `pwsh`, and in *line 3*, I’m calling `$PSVersionTable` to check
    what we’ve got.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 1 行* 中，我使用 Homebrew 安装 PowerShell。在 *第 2 行* 中，我使用 `pwsh` 启动 PowerShell，在
    *第 3 行* 中，我调用 `$PSVersionTable` 来检查我们安装了什么版本。
- en: 'We’ll need to keep PowerShell updated. We can do that with these two lines:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要保持 PowerShell 更新。我们可以通过这两行命令来实现：
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first line updates the Homebrew database, and the second upgrades PowerShell
    based on the most recent information.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行更新 Homebrew 数据库，第二行根据最新信息升级 PowerShell。
- en: 'Finally, to uninstall PowerShell, we can just type the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要卸载 PowerShell，我们只需输入以下命令：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: However, I’ve no idea why we would want to do that. Let’s look at installing
    VS Code next.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我不知道为什么我们会想这样做。接下来我们来看如何安装 VS Code。
- en: Installing VS Code on macOS
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 VS Code
- en: 'We can use Homebrew to download and install VS Code using the following command,
    which updates the latest files for Homebrew:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Homebrew 下载并安装 VS Code，使用以下命令，这会更新 Homebrew 的最新文件：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This installs the `cask` repository if it’s not already present:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `cask` 仓库尚未存在，这将安装该仓库：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This searches for VS Code in the repository:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在仓库中搜索 VS Code：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And this line installs it:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这行命令安装它：
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can use the launcher application to start VS Code, or we can add it to the
    `PATH` variable with this `cat` command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用启动器应用程序启动 VS Code，或者也可以通过以下 `cat` 命令将其添加到 `PATH` 变量中：
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We can also install it by downloading it directly from [https://code.visualstudio.com/](https://code.visualstudio.com/)
    and double-clicking the downloaded file.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过直接从 [https://code.visualstudio.com/](https://code.visualstudio.com/)
    下载并双击下载的文件来安装它。
- en: 'We can uninstall VS Code by running the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令卸载 VS Code：
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: But I bet we won’t want to.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 但我敢打赌我们不想这么做。
- en: That’s it for this chapter. Let’s review what we’ve learned.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到此为止。让我们回顾一下所学的内容。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we saw that there is no standard way to install PowerShell
    and VS Code. We saw how to use package managers to install PowerShell 7 on Ubuntu
    and RHEL, and then used the direct download method to install on an older version
    of Linux: CentOS 7.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到安装 PowerShell 和 VS Code 没有标准的方式。我们展示了如何使用包管理器在 Ubuntu 和 RHEL 上安装 PowerShell
    7，然后使用直接下载的方法在较旧版本的 Linux（CentOS 7）上进行安装。
- en: After that, we looked at how we can install VS Code on Linux, with a practical
    example on CentOS 7, again.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们查看了如何在 Linux 上安装 VS Code，并且在 CentOS 7 上进行了实际操作演示。
- en: We looked at a number of ways PowerShell on Linux differs from running PowerShell
    on Windows, including the filesystem, capitalization, and the use of aliases.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看了 PowerShell 在 Linux 上与 Windows 上运行的不同之处，包括文件系统、大小写和别名的使用。
- en: 'We spent some time on an important topic: how we can remote into Linux machines
    using SSH. The use of Linux as a desktop is rare, and the majority of work carried
    out on Linux machines is over remote sessions on SSH, whether that is with PowerShell
    or directly into a Bash terminal.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了一些时间讨论了一个重要话题：如何通过 SSH 远程连接到 Linux 机器。Linux 作为桌面操作系统的使用较为罕见，大多数在 Linux 机器上的工作都是通过
    SSH 远程会话进行的，无论是使用 PowerShell 还是直接进入 Bash 终端。
- en: Finally, we had a quick tour of ways of installing PowerShell and VS Code on
    macOS. We saw that it was very easy to both install and uninstall these applications
    using the free open source package manager, Homebrew.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们快速浏览了在 macOS 上安装 PowerShell 和 VS Code 的几种方法。我们看到，通过免费的开源包管理器 Homebrew 安装和卸载这些应用程序非常容易。
- en: In the next chapter, we’re going to look at running PowerShell on a different
    processor, ARM, and the associated operating system, Raspbian.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将介绍如何在不同的处理器 ARM 和相关的操作系统 Raspbian 上运行 PowerShell。
- en: Exercises
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Where would we go to get support installing PowerShell on Kali Linux?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们需要在 Kali Linux 上安装 PowerShell，应该去哪里寻求支持？
- en: Which command are we calling when we type `ls` into a PowerShell session on
    Linux?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在 Linux 上的 PowerShell 会话中输入 `ls` 时，调用的是哪个命令？
- en: Which file path separator does PowerShell use on Linux?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PowerShell 在 Linux 上使用哪个文件路径分隔符？
- en: How could we easily tell if we were working on a macOS machine?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何轻松判断是否在 macOS 机器上工作？
- en: How would we run a PowerShell script with root privileges in Linux?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Linux 中以 root 权限运行 PowerShell 脚本？
- en: Which cmdlet and parameter would we use to create a new remote session to a
    Linux machine?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该使用哪个 cmdlet 和参数来创建到 Linux 机器的远程会话？
- en: Which cmdlet and parameter would we use to avoid having to send a password across
    the network?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该使用哪个 cmdlet 和参数来避免通过网络发送密码？
- en: What does `scp` do?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`scp` 做什么？'
- en: What is Ed25519?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Ed25519？
- en: Further reading
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Install PowerShell* *on Linux*:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Linux 上安装 PowerShell*：'
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-linux](https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-linux)'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-linux](https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-linux)'
- en: '*Installing PowerShell* *on Ubuntu*:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Ubuntu 上安装 PowerShell*：'
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/install/install-ubuntu](https://learn.microsoft.com/en-us/powershell/scripting/install/install-ubuntu)'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/powershell/scripting/install/install-ubuntu](https://learn.microsoft.com/en-us/powershell/scripting/install/install-ubuntu)'
- en: '*Installing PowerShell on Red Hat Enterprise* *Linux (RHEL)*:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Red Hat Enterprise* *Linux (RHEL) 上安装 PowerShell*：'
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/install/install-rhel](https://learn.microsoft.com/en-us/powershell/scripting/install/install-rhel)'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/powershell/scripting/install/install-rhel](https://learn.microsoft.com/en-us/powershell/scripting/install/install-rhel)'
- en: '*Installing PowerShell* *on macOS*:'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 macOS 上安装 PowerShell*：'
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-macos](https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-macos)'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-macos](https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-macos)'
- en: '*Running Visual Studio Code* *on macOS*:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 macOS 上运行 Visual Studio Code*：'
- en: '[https://code.visualstudio.com/docs/setup/mac](https://code.visualstudio.com/docs/setup/mac)'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://code.visualstudio.com/docs/setup/mac](https://code.visualstudio.com/docs/setup/mac)'
- en: '*PowerShell remoting* *over SSH*:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PowerShell 远程操作* *通过 SSH*：'
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell](https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell)'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell](https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell)'
- en: '*Get started with OpenSSH* *for Windows*:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始使用Windows的OpenSSH*：'
- en: '[https://learn.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse?tabs=gui](https://learn.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse?tabs=gui)'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_install_firstuse?tabs=gui](https://learn.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_install_firstuse?tabs=gui)'
- en: '*OpenSSH Server configuration for Windows Server* *and Windows*:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Windows Server的OpenSSH服务器配置* *和Windows*：'
- en: '[https://learn.microsoft.com/en-us/windows-server/administration/openssh/openssh_server_configuration](https://learn.microsoft.com/en-us/windows-server/administration/openssh/openssh_server_configuration)'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_server_configuration](https://learn.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_server_configuration)'
