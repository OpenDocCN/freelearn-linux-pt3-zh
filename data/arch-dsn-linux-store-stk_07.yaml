- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: The SCSI Subsystem
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SCSI 子系统
- en: Throughout this book, we’ve gradually traversed from the higher layers in the
    storage stack to the lower layer. We started from VFS, explored the major VFS
    structures and filesystems, and explored the structures and scheduling techniques
    in the block layer. The VFS and block layer represent a major portion of the software
    side of things in the I/O hierarchy. As we gradually move down the ladder and
    enter the physical layer, things are slightly more generic, as the lower-level
    standards used to address physical drives are the same for most systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们逐步从存储栈的高层走向低层。我们从 VFS 开始，探讨了主要的 VFS 结构和文件系统，接着研究了块层中的结构和调度技术。VFS 和块层代表了
    I/O 层次结构中软件部分的一个重要组成部分。随着我们逐步进入物理层，事情变得稍微更通用，因为用于访问物理硬盘的底层标准在大多数系统中是相同的。
- en: The *third part* of this book contains two chapters that are dedicated to building
    an understanding of the physical side of things. In this chapter, we’ll mainly
    focus on one particular subsystem that has existed for a while and is the most
    common standard and protocol for addressing physical devices, **Small Computer
    System** **Interface** (**SCSI**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的*第三部分*包含了两章，专门用于建立对物理层面的理解。在本章中，我们将主要关注一个已经存在一段时间的子系统，它是最常用的标准和协议，用于访问物理设备——**小型计算机系统接口**（**SCSI**）。
- en: The development of the SCSI protocol aimed to facilitate seamless data transfer
    between computers and peripheral devices, including disk drives, CD-ROMs, printers,
    scanners, and various other resources, ensuring efficient and reliable communication.
    Since we’re focusing on storage here, we’re only going to discuss its role in
    terms of disk drives. Any read or write request that is handed to SCSI from the
    upper layers is transformed into an equivalent SCSI command. It’s important to
    understand that SCSI does not handle the arrangement of blocks for transportation
    or their physical placement on disk. That comes under the ownership of the upper
    layers in the I/O hierarchy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: SCSI 协议的发展旨在促进计算机与外设之间无缝的数据传输，包括磁盘驱动器、光盘驱动器、打印机、扫描仪以及其他各种资源，从而确保高效可靠的通信。由于我们这里主要关注存储，我们将仅讨论它在磁盘驱动器方面的作用。任何传递给
    SCSI 的读写请求都会被转换成等效的 SCSI 命令。需要理解的是，SCSI 不处理数据块的传输安排或它们在磁盘上的物理布局，这些属于 I/O 层次结构中的上层职责。
- en: Before we dive into SCSI, it is important to get a basic understanding of the
    device model in Linux. The `kobject` structure in the kernel, provides a range
    of constructs that enable smooth communication and interaction between hardware
    devices and their corresponding device drivers. After getting some basic knowledge
    of the device model, we’ll try to explain the major components of the SCSI subsystem.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解 SCSI 之前，首先需要对 Linux 中的设备模型有一个基本的了解。内核中的 `kobject` 结构提供了一系列构造体，使硬件设备与相应的设备驱动程序之间能够顺利地进行通信和交互。掌握了设备模型的一些基本知识后，我们将尝试解释
    SCSI 子系统的主要组成部分。
- en: 'In this chapter, we will discuss the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要主题：
- en: The device driver model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备驱动程序模型
- en: The SCSI subsystem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SCSI 子系统
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As SCSI is a protocol used to communicate with peripheral devices, such as hard
    drives, some basic knowledge about the functioning of these devices will aid in
    understanding the SCSI subsystem.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SCSI 是一种用于与外设通信的协议，例如硬盘，了解这些设备的基本工作原理有助于理解 SCSI 子系统。
- en: The commands and examples presented in this chapter are distribution-agnostic
    and can be run on any Linux operating system, such as Debian, Ubuntu, Red Hat,
    or Fedora. There are quite a few references to the kernel source code. If you
    want to download the kernel source, you can download it from [https://www.kernel.org](https://www.kernel.org).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的命令和示例不依赖于特定的发行版，可以在任何 Linux 操作系统上运行，例如 Debian、Ubuntu、Red Hat 或 Fedora。本书中有不少引用了内核源代码。如果你想下载内核源代码，可以从
    [https://www.kernel.org](https://www.kernel.org) 下载。
- en: The device driver model
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备驱动程序模型
- en: There are different subsystems in the kernel, such as the **system call interface**,
    **VFS**, **process and memory management**, and the **network stack**. Throughout
    this book, we’ve strictly kept our focus on the structures and entities that are
    a part of the I/O hierarchy in Linux. However, in reality, the process of reading
    and writing data to a storage device has to pass through most of these subsystems.
    As we saw, abstraction layers are the alpha and omega of the I/O stack, but this
    abstracted approach is not just limited to storage devices. For the kernel, the
    disk is just one of several pieces of hardware that it must manage. If there was
    a unique subsystem for managing the different types of devices, it would result
    in a bloated piece of code. Of course, different types of devices tend to be treated
    differently, as they might have contrasting roles, but for the end user, there
    should be a general abstract view of the system structure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 内核中有不同的子系统，例如 **系统调用接口**、**虚拟文件系统（VFS）**、**进程和内存管理**、以及 **网络栈**。在本书中，我们严格聚焦于
    Linux I/O 层级结构中的各个结构和实体。然而，实际上，读取和写入存储设备的数据过程必须经过这些子系统中的大部分。正如我们所见，抽象层次是 I/O 栈的核心，但这种抽象方式不仅限于存储设备。对于内核来说，磁盘只是其必须管理的多个硬件中的一个。如果有一个专门的子系统来管理不同类型的设备，那么代码将会变得臃肿。当然，不同类型的设备通常会有不同的处理方式，因为它们的角色可能截然不同，但对于最终用户来说，应该有一个关于系统结构的通用抽象视图。
- en: To achieve this unification, the Linux Device Model extracts the common attributes
    of device operations, abstracts them, and implements these common attributes in
    the kernel, providing a unified interface for newly added devices. This makes
    the driver development process much easier and smoother, as the developers only
    need to familiarize themselves with the interface.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种统一，Linux 设备模型提取了设备操作的共性属性，将其抽象化，并在内核中实现这些共性属性，为新加入的设备提供统一的接口。这使得驱动开发过程更加简便顺畅，因为开发者只需要熟悉接口即可。
- en: 'The device model’s main objective is to maintain internal data structures that
    accurately represent a system’s state and configuration. This encompasses vital
    information such as the presence of devices, their associated buses and drivers,
    as well as the overall hierarchy and structure of buses, devices, and drivers
    within the system. To keep track of this information, the device model makes use
    of the following entities to map them to their physical counterparts:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 设备模型的主要目标是维护准确反映系统状态和配置的内部数据结构。这包括设备的存在、它们的关联总线和驱动程序，以及系统中总线、设备和驱动的整体层级和结构等重要信息。为了跟踪这些信息，设备模型利用以下实体将它们映射到物理对应物：
- en: '**Bus**: There are several components in a system, such as CPU, memory, and
    input and output devices. Communication between these devices is dependent on
    a channel, which is the bus. The bus is a channel to transmit data. Think of it
    as a linear channel for the conveyance of traffic, similar to a road. In order
    to facilitate the abstraction of the device model, all devices should be connected
    to a bus. The bus in the device model is an abstraction based on the physical
    bus.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总线**：系统中有多个组件，例如 CPU、内存以及输入输出设备。这些设备之间的通信依赖于一个通道，这个通道就是总线。总线是用来传输数据的通道。你可以把它想象成一个线性通道，用于传递交通信号，类似于一条道路。为了方便设备模型的抽象，所有设备都应该连接到总线上。设备模型中的总线是基于物理总线的抽象。'
- en: '**Device**: This represents a physical device that is attached to a bus. In
    the device model, the *device* abstracts all hardware devices in the system and
    describes their attributes, the bus it is connected to, and other information.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备**：这是指连接到总线的物理设备。在设备模型中，*设备*抽象了系统中的所有硬件设备，并描述了它们的属性、所连接的总线以及其他信息。'
- en: '**Device driver**: The driver is a software entity that is associated with
    a device. The device model uses the driver to abstract the driver of the hardware
    device, which includes device initialization and power management-related interface
    implementations.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备驱动**：驱动程序是与设备关联的软件实体。设备模型通过驱动程序来抽象硬件设备的驱动，包括设备初始化和电源管理相关的接口实现。'
- en: '**Class**: The concept of class is a bit interesting. A class represents a
    collection of devices with similar functions or attributes. For example, there
    are SCSI and **Advanced Technology Attachment** (**ATA**) drivers, which fall
    under the same disk class. Classes serve as a means of categorizing devices based
    on their functionality rather than their connectivity or operational mechanisms.
    This is a bit similar to the concept of classes in object-oriented programming.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Class**: 类的概念有些有趣。类代表具有类似功能或属性的设备集合。例如，SCSI 和 **Advanced Technology Attachment**
    (**ATA**) 驱动程序属于同一磁盘类别。类用于根据功能而不是连接性或操作机制对设备进行分类。这与面向对象编程中类的概念有些相似。'
- en: 'The device model provides a generic mechanism to represent and operate on every
    device in the system. As we explained in [*Chapter 1*](B19430_01.xhtml#_idTextAnchor015)
    of this book, the kernel provides a window to export information about various
    kernel subsystems through VFS. The representation of the device model in user
    space can be viewed through the `Sysfs` VFS. The `Sysfs` filesystem is mounted
    on the `/sys` directory, as shown in the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '设备模型提供一种通用机制来表示和操作系统中的每个设备。正如我们在本书的 [*第1章*](B19430_01.xhtml#_idTextAnchor015)
    中解释的那样，内核通过 VFS 提供了一个窗口来导出有关各种内核子系统的信息。用户空间中设备模型的表示可以通过 `Sysfs` VFS 查看。`Sysfs`
    文件系统被挂载在 `/sys` 目录下，如下截图所示:'
- en: '![Figure 7.1 – The contents of Sysfs](img/B19430_07_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – Sysfs 的内容](img/B19430_07_01.jpg)'
- en: Figure 7.1 – The contents of Sysfs
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – Sysfs 的内容
- en: 'The directories contain the following information:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '目录包含以下信息:'
- en: '`block`: This encompasses all available block devices within the system, including
    disks and partitions'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block`: 这包含系统中所有可用的块设备，包括磁盘和分区'
- en: '`bus`: This represents various types of buses to which physical devices are
    connected, such as PCI, IDE, and USB'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bus`: 这表示连接物理设备的各种总线类型，例如 PCI、IDE 和 USB'
- en: '`class`: This denotes the available driver classes in the system, such as network,
    sound, and USB'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class`: 这表示系统中可用的驱动程序类别，如网络、声音和 USB'
- en: '`devices`: This signifies the hierarchical structure of connected devices within
    the system'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devices`: 这表示系统中连接设备的分层结构'
- en: '`firmware`: This contains information retrieved from system firmware, particularly
    ACPI'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firmware`: 这包含从系统固件检索的信息，特别是 ACPI'
- en: '`fs`: This provides details regarding the mounted file systems'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs`: 这提供有关已挂载文件系统的详细信息'
- en: '`kernel`: This offers kernel status information, including logged-in users
    and hotplug events'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kernel`: 这提供内核状态信息，包括已登录用户和热插拔事件'
- en: '`module`: This presents the current list of loaded modules'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module`: 这显示当前加载的模块列表'
- en: '`power`: This encompasses information pertaining to the power management subsystem.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`power`: 这包含有关电源管理子系统的信息。'
- en: 'There is a correlation between the kernel data structures within the described
    model and the sub-directories in the `Sysfs` VFS. There are a number of structures
    in the device model that allow communication between a device driver and the corresponding
    hardware device. We’re not going to explore these structures, but just so you
    know, the basic structure of the Linux Device Model is `kobject`. Think of `kobject`
    as the glue that holds the device model and the `Sysfs` interface together. The
    structures in the higher levels of the model, as depicted in *Figure 7**.2*, are
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '描述模型中内核数据结构与 `Sysfs` VFS 中的子目录之间存在关联。设备模型中有多个结构允许设备驱动程序与相应的硬件设备之间进行通信。我们不打算探索这些结构，但只需知道，Linux
    设备模型的基本结构是 `kobject`。将 `kobject` 想象为将设备模型和 `Sysfs` 接口粘合在一起的胶水。模型较高级别中的结构如 *图 7**.2*
    所示:'
- en: '`struct bus_type`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct bus_type`'
- en: '`struct device`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct device`'
- en: '`struct device_driver`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct device_driver`'
- en: 'Here is *Figure 7**.2*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '这里是 *图 7**.2*:'
- en: '![Figure 7.2 – The device model components](img/B19430_07_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 设备模型组件](img/B19430_07_02.jpg)'
- en: Figure 7.2 – The device model components
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 设备模型组件
- en: To summarize, the Linux device model classifies hardware devices and implements
    abstraction through a set of standard data structures and interfaces. This model
    can be seen through user space by viewing the contents of the `Sysfs` filesystem.
    The entities present in `Sysfs` have a close association with the actual physical
    implementations. Let’s move on and explore the architecture of the SCSI subsystem
    in more detail.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Linux 设备模型通过一套标准的数据结构和接口对硬件设备进行分类和抽象。通过查看 `Sysfs` 文件系统的内容，可以在用户空间中看到这个模型。`Sysfs`
    中的实体与实际的物理实现紧密相关。接下来，让我们更详细地探讨 SCSI 子系统的架构。
- en: Explaining the SCSI subsystem
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释 SCSI 子系统
- en: 'People can mean a couple of things when referring to the **SCSI (**pronounced
    SKUZ-ee):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当提到**SCSI**（发音为 SKUZ-ee）时，人们可能指代几个不同的意思：
- en: A hardware bus to connect peripherals to a computer
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接外设与计算机的硬件总线
- en: A command set to communicate with devices over different types of buses
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组用于通过不同总线与设备通信的命令集
- en: For a long time, SCSI was the primary technology for I/O buses in computers.
    SCSI defines both an interface and a data protocol for connecting different types
    of devices to a computer. As a medium, SCSI defines a bus for data transmission.
    As a protocol, it defines how devices communicate with each other via the SCSI
    bus.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间以来，SCSI 是计算机中 I/O 总线的主要技术。SCSI 定义了一个接口和一个数据协议，用于将不同类型的设备连接到计算机上。作为一种媒介，SCSI
    定义了一个用于数据传输的总线。作为协议，它定义了设备如何通过 SCSI 总线进行相互通信。
- en: Initially, the connectivity of peripheral devices was achieved through a parallel
    SCSI bus. Over the years, the SCSI parallel bus has fallen out of favor and has
    been replaced with serial interfaces. The most common of these interfaces include
    **Serial Attached SCSI** (**SAS**) and **SCSI over Fibre Channel**. The serial
    interfaces provide far better data transfer rates and reliability. There is also
    an implementation of the SCSI protocol over TCP/IP, known as **Internet** **SCSI**
    (**iSCSI**).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，外设设备的连接是通过并行 SCSI 总线实现的。多年来，SCSI 并行总线逐渐被淘汰，取而代之的是串行接口。其中最常见的接口包括**串行附加 SCSI**（**SAS**）和**SCSI
    通过光纤通道**。串行接口提供了更高的数据传输速率和可靠性。还有一种通过 TCP/IP 实现的 SCSI 协议，称为**互联网 SCSI**（**iSCSI**）。
- en: We will keep our focus here on the Linux side of things and discuss the organization
    of the SCSI subsystem in the I/O hierarchy. The SCSI standard defines command
    sets for a wide variety of devices, not just for hard drives. The SCSI commands
    can be sent over just about any kind of transporting mechanism. This makes SCSI
    the ipso facto standard for storage devices accessed via the SATA, SAS, or Fibre
    Channel protocol.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里聚焦于 Linux 方面，讨论 SCSI 子系统在 I/O 层次结构中的组织方式。SCSI 标准为各种设备定义了命令集，不仅仅是硬盘。SCSI
    命令可以通过几乎任何类型的传输机制发送。这使得 SCSI 成为通过 SATA、SAS 或光纤通道协议访问存储设备的事实标准。
- en: SCSI architecture
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SCSI 架构
- en: 'The SCSI subsystem uses a three-level architecture. The layer at the top represents
    the kernel’s highest interface for end user applications. The layer at the center
    provides some common services to the upper and lower layers of the SCSI stack.
    At the very bottom is the lower layer. The lower layer contains the actual drivers
    that interact with the underlying physical devices. Every operation involving
    the SCSI subsystem uses one driver at each of three layers. *Figure 7**.3* highlights
    the multilayered design of the SCSI subsystem:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: SCSI 子系统采用三层架构。顶部的层代表内核的最高接口，用于最终用户应用程序。中间层为 SCSI 堆栈的上下层提供一些公共服务。最底层是底层，它包含与底层物理设备交互的实际驱动程序。每个涉及
    SCSI 子系统的操作都在三个层级中各使用一个驱动程序。*图 7.3* 强调了 SCSI 子系统的多层设计：
- en: '![Figure 7.3 – SCSI architecture](img/B19430_07_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – SCSI 架构](img/B19430_07_03.jpg)'
- en: Figure 7.3 – SCSI architecture
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – SCSI 架构
- en: The three layers are described in a bit more detail in the following subsections.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节中将更详细描述这三层。
- en: Upper layer
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上层
- en: 'The **upper layer** contains specific device-type drivers that are closest
    to the user space applications. These upper-layer drivers provide the interface
    between user space and kernel space. The most commonly used upper-layer drivers
    include the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**上层**包含最接近用户空间应用程序的特定设备类型驱动程序。这些上层驱动程序提供用户空间和内核空间之间的接口。最常用的上层驱动程序包括以下几种：'
- en: '`sd`: The disk driver'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sd`：磁盘驱动程序'
- en: '`sr`: The CD-ROM driver'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sr`：CD-ROM 驱动程序'
- en: '`sg`: The generic SCSI driver'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sg`：通用的 SCSI 驱动程序'
- en: After looking at these driver names, it should come as no surprise that the
    device names for the corresponding device types are abbreviated with the prefix
    of the driver, such as `sda`. The upper layer accepts requests from higher layers
    in the storage stack, such as VFS, and translates them into equivalent SCSI requests
    with the help of the middle and lower layers. After the completion of SCSI commands,
    the upper-level drivers inform the higher layers. The generic SCSI driver, `sg`,
    allows you to directly send SCSI commands to SCSI devices, bypassing the filesystem
    layer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这些驱动程序名称之后，设备名称通常会以驱动程序的前缀缩写表示，如 `sda`，这也就不足为奇了。上层接受来自存储栈更高层的请求，如 VFS，并通过中间层和下层将它们转化为相应的
    SCSI 请求。在 SCSI 命令完成后，上层驱动程序会通知更高层。通用的 SCSI 驱动程序 `sg` 允许直接向 SCSI 设备发送 SCSI 命令，绕过文件系统层。
- en: The upper-level SCSI disk drivers are implemented in `/linux/drivers/scsi/sd.c`.
    The upper-layer SCSI disk drivers self-initialize by calling `register_blkdev`
    to register as block devices, providing a set of functions through the `scsi_register_driver`
    function to represent all the SCSI devices.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上层 SCSI 磁盘驱动程序实现于 `/linux/drivers/scsi/sd.c`。上层 SCSI 磁盘驱动程序通过调用 `register_blkdev`
    注册为块设备，进行自我初始化，并通过 `scsi_register_driver` 函数提供一组功能来表示所有 SCSI 设备。
- en: Mid layer
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间层
- en: The **mid layer** is common to all SCSI operations and contains the core of
    the SCSI support. The mid layer stitches together the upper and lower layers by
    defining internal interfaces and providing common services to the upper- and lower-level
    drivers. It oversees the management of SCSI command queues, ensures efficient
    error handling, and facilitates power management functions. The upper- and lower-level
    drivers cannot function without the functionality provided by the mid layer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**中间层** 是所有 SCSI 操作的共同部分，包含了 SCSI 支持的核心。中间层通过定义内部接口并向上下层驱动程序提供公共服务，将上层和下层连接起来。它负责管理
    SCSI 命令队列，确保高效的错误处理，并促进电源管理功能。没有中间层提供的功能，上层和下层驱动程序无法正常工作。'
- en: The generic mid-level SCSI driver is implemented in `linux/drivers/scsi/scsi.c`.
    The mid layer abstracts the implementation of the lower-level drivers and transforms
    commands from the upper layers into equivalent SCSI requests. The mid layer also
    implements command queuing. When a request is received from the upper layer, the
    mid layer queues the requests for processing. Once the requests have been served,
    it receives the response from the lower layer and notifies the upper layer. If
    a request times out, it is the responsibility of the mid layer to perform error
    handling or resend the request.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的中间层 SCSI 驱动程序实现于 `linux/drivers/scsi/scsi.c`。中间层抽象了低层驱动程序的实现，并将上层的命令转化为等效的
    SCSI 请求。中间层还实现了命令排队功能。当接收到上层的请求时，中间层会将请求排队以便处理。一旦请求处理完成，它会接收来自下层的响应并通知上层。如果请求超时，中间层负责执行错误处理或重新发送请求。
- en: There are a couple of important functions through which the mid layer serves
    as a bridge between the upper and lower layers, `sd_probe` and `sd_init`. During
    driver initialization and whenever a new SCSI device is connected to the system,
    the `sd_probe` function plays a crucial role in determining whether the device
    is under the management of a SCSI disk driver. If the device falls within the
    purview of management, `sd_probe` generates a fresh `scsi_disk` structure to serve
    as its representative entity. When a read or write request is received from higher
    layers in the storage stack, such as a filesystem, the `sd_init_command` function
    converts that request into an equivalent SCSI read or write command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个重要的函数，通过它们，中间层作为上层和下层之间的桥梁，`sd_probe` 和 `sd_init`。在驱动程序初始化期间以及每当新的 SCSI 设备连接到系统时，`sd_probe`
    函数在确定设备是否受 SCSI 磁盘驱动程序管理方面发挥着关键作用。如果设备在管理范围内，`sd_probe` 会生成一个新的 `scsi_disk` 结构体来作为该设备的代表实体。当来自存储栈更高层的读取或写入请求（如文件系统）被接收时，`sd_init_command`
    函数将该请求转换为相应的 SCSI 读写命令。
- en: Lower layer
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下层
- en: The `lpfc` is the device driver for Emulex HBAs. The lower-level drivers are
    present in the `linux/drivers/scsi/` directory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`lpfc` 是 Emulex HBA 的设备驱动程序。低层驱动程序位于 `linux/drivers/scsi/` 目录中。'
- en: Now, let’s delve deeper into how the SCSI subsystem can be classified as operating
    within a client-server model.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地探讨 SCSI 子系统如何在客户端-服务器模型中运行。
- en: The client and server model
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端和服务器模型
- en: The SCSI subsystem receives requests from higher layers in the storage stack
    to send or retrieve blocks of data from a storage device. When an application
    initiates a read or write request, the SCSI layer treats this request by transforming
    it into the equivalent SCSI command. The SCSI subsystem does not handle how data
    blocks are organized and placed on the storage device; that is the job of the
    higher layers in the I/O stack. SCSI sends blocks to a destination device, which
    can either be an individual disk or a **redundant array of independent disks**
    (**RAID**) controller.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SCSI 子系统接收来自存储栈上层的请求，要求从存储设备发送或检索数据块。当应用程序发起读取或写入请求时，SCSI 层通过将该请求转换为等效的 SCSI
    命令来处理它。SCSI 子系统不处理数据块如何在存储设备上组织和存放；这是 I/O 栈上层的工作。SCSI 将数据块发送到目标设备，这个目标设备可以是一个单独的磁盘，或一个**独立冗余磁盘阵列**（**RAID**）控制器。
- en: As the SCSI layer on the operating system side commences an operation on the
    storage device and the storage device, in turn, responds by performing said operation,
    this flow of events can be categorized as a client-server exchange model. In SCSI
    parlance, the two parties are referred to as **initiators** and **targets**. The
    host operating system that initiates the request is said to act as an SCSI initiator.
    The destination storage device that receives and processes this request is known
    as an SCSI target.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统侧的 SCSI 层开始对存储设备执行操作，并且存储设备反过来响应并执行该操作时，这一事件流程可以被归类为客户端-服务器交换模型。在 SCSI
    术语中，双方被称为**发起者**和**目标**。发起请求的主机操作系统被称为 SCSI 发起者。接收并处理此请求的目标存储设备被称为 SCSI 目标。
- en: 'The SCSI initiator resides on the host and generates requests on behalf of
    the higher layers in the I/O stack, such as applications and filesystems. The
    SCSI target waits for the initiator’s commands and then performs the requested
    data transfers. There has to be an underlying transport mechanism that ensures
    that the SCSI command from the initiator is delivered to the target. This is implemented
    through the SCSI transport layer. There are multiple transfer protocols available,
    such as **Serial Attached SCSI** (**SAS**) for direct attached disks, and the
    Fibre Channel or iSCSI for SCSI targets that are part of a **Storage Area Network**
    (**SAN**). The relationship between the SCSI initiator and the target is shown
    in *Figure 7**.4*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: SCSI 发起者驻留在主机上，代表 I/O 栈中的上层（如应用程序和文件系统）生成请求。SCSI 目标等待发起者的命令，并执行请求的数据传输。必须有一个底层的传输机制来确保发起者的
    SCSI 命令能够传送到目标。这是通过 SCSI 传输层来实现的。有多种传输协议可用，例如用于直接附加磁盘的**串行附加 SCSI**（**SAS**），以及用于
    SCSI 目标的光纤通道或 iSCSI，这些 SCSI 目标属于**存储区域网络**（**SAN**）。SCSI 发起者和目标之间的关系如*图 7.4*所示：
- en: '![Figure 7.4 – The SCSI initiator and the target](img/B19430_07_04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – SCSI 发起者和目标](img/B19430_07_04.jpg)'
- en: Figure 7.4 – The SCSI initiator and the target
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – SCSI 发起者和目标
- en: Let us move on to the addressing scheme.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们来讨论地址方案。
- en: Device addressing
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备地址
- en: 'Linux uses a four-part hierarchical addressing scheme to identify SCSI devices.
    This combination of four numbers uniquely identifies the location of a SCSI device
    within a system. If you run `lsscsi` or `sg_map -x` on the command line, you’ll
    see that a sequence of four numbers is used to represent every SCSI device in
    your system:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 使用四部分层次化的地址方案来标识 SCSI 设备。这四个数字的组合唯一标识了系统中 SCSI 设备的位置。如果你在命令行中运行 `lsscsi`
    或 `sg_map -x`，你会看到每个 SCSI 设备都会用一组四个数字来表示：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This quad addressing scheme is known as **Host, Bus, Target, and LUN** (**HBTL**),
    and its fields are explained as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种四元地址方案被称为**主机、总线、目标和 LUN**（**HBTL**），其字段解释如下：
- en: '**Host**: The host represents a controller that can send and receive SCSI commands.
    The SCSI Host ID is the ID of the HBA, also referred to as the SCSI controller
    or SCSI adapter. The identifier represents an arbitrary numbering assigned to
    adapter cards present on the internal system buses. The kernel assigns this number
    in an ascending manner on the basis of the adapter discovery order. For instance,
    the first adapter will be assigned zero, the second will be assigned one, and
    so on.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机**：主机表示一个能够发送和接收 SCSI 命令的控制器。SCSI 主机 ID 是 HBA 的 ID，也被称为 SCSI 控制器或 SCSI
    适配器。该标识符表示分配给内部系统总线上的适配器卡的任意编号。内核根据适配器发现顺序按升序分配这个编号。例如，第一个适配器将被分配为零，第二个适配器为一，依此类推。'
- en: '**Bus**: This is the bus or channel used within the SCSI controller. A controller
    can have more than one SCSI bus. This identifier is assigned by the kernel and
    reflects part of the hardware and firmware architecture of the SCSI controller.
    Usually, SCSI controllers will only have a single bus. High-end devices such as
    RAID controllers can have multiple buses.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总线**：这是在 SCSI 控制器中使用的总线或通道。一个控制器可以有多个 SCSI 总线。此标识符由内核分配，反映了 SCSI 控制器的硬件和固件架构的一部分。通常，SCSI
    控制器只有一个总线。高端设备，如 RAID 控制器，可以拥有多个总线。'
- en: '**Target**: Each bus can have multiple devices or targets connected to it.
    The target is the destination device within the bus. This identifier is also assigned
    by the kernel in the order of target discovery within a given SCSI controller.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**：每个总线可以连接多个设备或目标。目标是总线内的目的设备。这个标识符也由内核分配，按给定 SCSI 控制器内目标发现的顺序进行分配。'
- en: '**The Logical Unit Number (LUN)**: This is the logical device within the SCSI
    target, as seen by the host operating system. The LUN is the entity capable of
    receiving SCSI commands from the host, meaning a disk drive. Each LUN has an exclusive
    request queue in the kernel’s block layer. The LUN identifier is assigned by the
    storage, making it the only part in the SCSI addressing scheme that is not assigned
    by the kernel.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑单元号（LUN）**：这是主机操作系统看到的 SCSI 目标中的逻辑设备。LUN 是能够接收主机发送的 SCSI 命令的实体，意味着一个磁盘驱动器。每个
    LUN 在内核的块层中都有一个独占的请求队列。LUN 标识符由存储设备分配，使其成为 SCSI 寻址方案中唯一一个不是由内核分配的部分。'
- en: 'The following figure illustrates this addressing mechanism and the path from
    a host to a SCSI disk. Note that there is a relative SCSI target index associated
    with a SCSI controller or an HBA. The first SCSI storage target discovered attached
    to `host0` is assigned the SCSI target (relative index) 0, then 1, and 2, and
    so on:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了这一寻址机制以及从主机到 SCSI 硬盘的路径。请注意，与 SCSI 控制器或 HBA 相关联的是一个相对的 SCSI 目标索引。第一次在 `host0`
    上发现的 SCSI 存储目标被分配为 SCSI 目标（相对索引）0，然后是 1、2，以此类推：
- en: '![Figure 7.5 – SCSI addressing](img/B19430_07_05.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – SCSI 寻址](img/B19430_07_05.jpg)'
- en: Figure 7.5 – SCSI addressing
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – SCSI 寻址
- en: 'If you look inside `/sys/class/scsi_host/`, you will see that hosts 0 to 6
    correspond to SCSI controllers:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `/sys/class/scsi_host/`，你会看到主机 0 到 6 对应于 SCSI 控制器：
- en: '![Figure 7.6 – The SCSI hosts in Sysfs](img/B19430_07_06.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – Sysfs 中的 SCSI 主机](img/B19430_07_06.jpg)'
- en: Figure 7.6 – The SCSI hosts in Sysfs
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – Sysfs 中的 SCSI 主机
- en: 'Similarly, a structure of the `targetX:Y:Z` format exists in `/sys/bus/scsi/devices/`
    and is attached to the SCSI bus:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`targetX:Y:Z` 格式的结构存在于 `/sys/bus/scsi/devices/` 中，并附加到 SCSI 总线：
- en: '![Figure 7.7 – The SCSI targets in Sysfs](img/B19430_07_07.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – Sysfs 中的 SCSI 目标](img/B19430_07_07.jpg)'
- en: Figure 7.7 – The SCSI targets in Sysfs
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – Sysfs 中的 SCSI 目标
- en: 'The LUNs can be identified through the unique four-level hierarchical addressing
    scheme, as discussed earlier:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: LUN 可以通过之前讨论的四级层次寻址方案进行标识：
- en: '![Figure 7.8 – The SCSI LUNs in Sysfs](img/B19430_07_08.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – Sysfs 中的 SCSI LUN](img/B19430_07_08.jpg)'
- en: Figure 7.8 – The SCSI LUNs in Sysfs
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – Sysfs 中的 SCSI LUN
- en: We’ll now explore some major data structures in the kernel that are relevant
    to the SCSI subsystem.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探索一些与 SCSI 子系统相关的内核中的主要数据结构。
- en: Major data structures
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主要数据结构
- en: The preceding concepts are implemented in the kernel using three major data
    structures – `Scsi_Host`, `scsi_target`, and `scsi_device`. Of course, these are
    not the only SCSI-related structures in the kernel. In addition to these three,
    there are several auxiliary structures, such as `scsi_host_template` and `scsi_transport_template`.
    As the name might suggest, these structures are used to represent some common
    features for SCSI adapters and transport types. For instance, `scsi_host_template`
    provides common content for the host adapters of the same model, including the
    request queue depth, the SCSI command processing callback function, and the error
    handling recovery functions. SCSI devices include hard disks, SSDs, optical drives,
    and so on, and all of these devices have some common functions. These common functions
    are extracted into templates in the kernel.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述概念通过三个主要数据结构在内核中实现——`Scsi_Host`、`scsi_target`和`scsi_device`。当然，这些并不是内核中唯一与SCSI相关的结构。除了这三种结构外，还有几个辅助结构，例如`scsi_host_template`和`scsi_transport_template`。顾名思义，这些结构用于表示SCSI适配器和传输类型的一些共通特性。例如，`scsi_host_template`为相同型号的主机适配器提供共通内容，包括请求队列深度、SCSI命令处理回调函数以及错误处理恢复函数。SCSI设备包括硬盘、SSD、光驱等，所有这些设备都具有一些共通功能。这些共通功能被提取为内核中的模板。
- en: 'These three major structures are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种主要结构如下：
- en: '`Scsi_Host`: This is the data structure corresponding to the controller or
    the HBA, which is located under the SCSI bus. It contains information about the
    HBA, such as its unique identifier, maximum transfer size, supported features,
    and host-specific data. Multiple SCSI host structures can exist in the system,
    each representing a separate host adapter. The `SCSI``_``Host` structure acts
    as the top-level structure for managing SCSI communication.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scsi_Host`：这是对应于控制器或HBA的数据结构，位于SCSI总线下。它包含关于HBA的信息，例如其唯一标识符、最大传输大小、支持的特性和主机特定的数据。系统中可以存在多个SCSI主机结构，每个结构代表一个独立的主机适配器。`SCSI_Host`结构作为管理SCSI通信的顶级结构。'
- en: '`scsi_target`: This structure corresponds to a target device that is attached
    to a specific host adapter. It contains information about the target, such as
    its SCSI ID, **LUN**, and some other flags and parameters. The SCSI target structure
    is associated with a specific SCSI Host structure and is used to manage communication
    and commands specific to that target device. The target device can be either physical
    or virtual.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scsi_target`：该结构对应于附加到特定主机适配器的目标设备。它包含关于目标的信息，例如其SCSI ID、**LUN**以及其他一些标志和参数。SCSI目标结构与特定的SCSI主机结构相关联，并用于管理与该目标设备相关的通信和命令。目标设备可以是物理设备或虚拟设备。'
- en: '`scsi_device`: This structure represents a LUN within a SCSI target device.
    It denotes a specific device or partition within a target. When the operating
    system scans for a logical device connected to the host adapter, it creates a
    `scsi_device` structure for the upper-level SCSI driver to communicate with the
    device. It includes information such as the device’s SCSI ID, LUN, and queue depth.
    It is associated with both a SCSI Target structure and a SCSI Host structure and
    is used to manage communication and I/O operations for that specific device.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scsi_device`：该结构表示SCSI目标设备中的一个LUN。它表示目标内的特定设备或分区。当操作系统扫描连接到主机适配器的逻辑设备时，它会为上层SCSI驱动程序创建一个`scsi_device`结构，以便与设备进行通信。它包含设备的SCSI
    ID、LUN和队列深度等信息。它与SCSI目标结构和SCSI主机结构都相关联，并用于管理该特定设备的通信和I/O操作。'
- en: 'This hierarchical scheme allows the kernel to manage SCSI devices and their
    communication efficiently. Commands and data transfers can be directed to specific
    SCSI devices or logical units, and error handling and status tracking can be performed
    at each level of the hierarchy. The interplay of these structures is highlighted
    in *Figure 7**.9*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分层方案允许内核高效地管理SCSI设备及其通信。命令和数据传输可以被定向到特定的SCSI设备或逻辑单元，并且可以在层次结构的每一层进行错误处理和状态跟踪。这些结构的相互作用在*图7.9*中得到了突出展示：
- en: '![Figure 7.9 – Major SCSI structures](img/B19430_07_09.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9 – 主要的SCSI结构](img/B19430_07_09.jpg)'
- en: Figure 7.9 – Major SCSI structures
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 主要的SCSI结构
- en: Please note that the actual implementation of SCSI devices in the Linux kernel
    is far more complex and involves additional data structures and interfaces. However,
    this simplified diagram demonstrates the basic interconnections between the SCSI
    Host, SCSI Target, and SCSI Device structures.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Linux 内核中 SCSI 设备的实际实现要复杂得多，涉及到额外的数据结构和接口。然而，这个简化的图示展示了 SCSI 主机、SCSI 目标和
    SCSI 设备结构之间的基本连接。
- en: Communicating with SCSI devices
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与 SCSI 设备通信
- en: 'As shown in *Figure 7**.10*, there are three different ways of communicating
    with SCSI devices:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 7.10*所示，和 SCSI 设备通信有三种不同的方式：
- en: '![Figure 7.10 – Communicating with SCSI devices](img/B19430_07_10.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 与 SCSI 设备通信](img/B19430_07_10.jpg)'
- en: Figure 7.10 – Communicating with SCSI devices
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 与 SCSI 设备通信
- en: 'There are explained as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所述：
- en: '**Filesystem-based**: The most common method is to access the SCSI device through
    the interface provided by the filesystem. This is how most regular user-space
    applications interact with SCSI devices.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于文件系统**：最常见的方法是通过文件系统提供的接口访问 SCSI 设备。这是大多数常规用户空间应用与 SCSI 设备交互的方式。'
- en: '`dd` command in Linux. Using a raw access method does not require address mapping
    by the filesystem.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 中的`dd`命令。使用原始访问方法不需要文件系统进行地址映射。
- en: '`sg3_utils` package available in Linux provides a set of utilities that can
    send SCSI commands to a device via the SCSI pass-through interface provided by
    the host operating system.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 中可用的`sg3_utils`包提供了一组工具，可以通过主机操作系统提供的 SCSI 直通接口将 SCSI 命令发送到设备。
- en: Interaction between the SCSI and block layers
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SCSI 层与块层之间的交互
- en: The SCSI layer and the block layer work together to facilitate the interaction
    between SCSI devices and the filesystem. The SCSI layer acts as an intermediate
    layer between the block layer and the device driver specific to the SCSI Host
    adapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: SCSI 层和块层协同工作，以促进 SCSI 设备与文件系统之间的交互。SCSI 层作为块层与特定 SCSI 主机适配器设备驱动程序之间的中间层。
- en: 'The following provides an overview of how the SCSI layer interacts with the
    block layer:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 SCSI 层与块层交互的概述：
- en: When a filesystem sends an I/O request, such as a read or write operation, it
    gets translated into a SCSI command by the block layer. The block layer constructs
    a SCSI **Command Descriptor Block** (**CDB**) that corresponds to the requested
    operation and passes it to the SCSI layer.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当文件系统发送 I/O 请求（如读写操作）时，块层将其转换为 SCSI 命令。块层构建一个与请求操作对应的 SCSI **命令描述块**（**CDB**），并将其传递给
    SCSI 层。
- en: The SCSI mid layer receives the SCSI command from the block layer and performs
    the necessary processing, including command queuing, error handling, and data
    transfer.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SCSI 中间层从块层接收 SCSI 命令并执行必要的处理，包括命令排队、错误处理和数据传输。
- en: The SCSI mid layer forwards the SCSI command to the appropriate lower-level
    SCSI device driver associated with the specific SCSI host adapter. The device
    driver interacts directly with the hardware and sends the SCSI command to the
    target device over the SCSI bus.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SCSI 中间层将 SCSI 命令转发给与特定 SCSI 主机适配器相关的适当底层 SCSI 设备驱动程序。设备驱动程序直接与硬件交互，并通过 SCSI
    总线将 SCSI 命令发送到目标设备。
- en: Once the SCSI command is executed by the target device, the lower-level SCSI
    device driver receives the command completion status and communicates this information
    back to the SCSI mid layer, which then passes it to the block layer.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦目标设备执行了 SCSI 命令，底层的 SCSI 设备驱动程序接收到命令完成状态，并将此信息传递回 SCSI 中间层，随后再传递给块层。
- en: The block layer receives the command completion status from the SCSI mid layer
    and uses this information to handle any errors, update the I/O request status,
    and notify the filesystem about the completion or failure of the I/O request.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块层接收来自 SCSI 中间层的命令完成状态，并使用此信息处理任何错误，更新 I/O 请求状态，并通知文件系统关于 I/O 请求的完成或失败。
- en: Please note that this is a summarized view of the interaction between the block
    and SCSI layers. The block layer provides a standardized interface to the higher
    layers, such as filesystems. The SCSI layer handles the translation of block-level
    I/O requests into equivalent SCSI commands, and it manages the communication with
    the SCSI devices through lower-level device drivers specific to the SCSI host
    adapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是块层和SCSI层之间交互的概述视图。块层为高层（如文件系统）提供标准化接口，而SCSI层负责将块级I/O请求转换为等效的SCSI命令，并通过特定于SCSI主机适配器的底层设备驱动程序管理与SCSI设备的通信。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: This chapter focused on two major topics, the device model and the SCSI subsystem
    in Linux. We started by giving a brief overview of the device model in Linux and
    how the kernel provides its view in user space through the `Sysfs` VFS. We then
    moved on to the exploration of the SCSI subsystem and explained its three-level
    architecture.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论了两个主要主题：Linux中的设备模型和SCSI子系统。我们首先简要概述了Linux中的设备模型，以及内核如何通过`Sysfs`虚拟文件系统在用户空间提供其视图。接着我们探讨了SCSI子系统，并解释了其三级架构。
- en: As explained in this chapter, SCSI defines both an interface and a data protocol
    to connect different types of devices to a system. As a medium, it defines a bus
    for data transmission, and as a protocol, it defines how devices communicate with
    each other via the SCSI bus. When an application in user space initiates a write
    request to store data, the SCSI subsystem converts this write request into a SCSI
    command, to write the requested data on the specified disk location. It acts as
    a mediator between the higher layers in the I/O stack and the physical storage.
    SCSI does not assume responsibility for the assembly of blocks during transport
    or their physical placement on disk. The side that initiates a request is known
    as the initiator, while the destination side is known as the target in SCSI terminology.
    The target of the SCSI protocol can encompass a single physical drive, an HBA,
    or a RAID controller. The primary duty of the SCSI protocol is to guarantee the
    successful completion of the write task and report its status to the higher layers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章所述，SCSI定义了一个接口和一个数据协议，用于将不同类型的设备连接到系统。作为一种媒介，它定义了一个用于数据传输的总线；作为协议，它定义了设备如何通过SCSI总线相互通信。当用户空间中的应用程序发起写入请求以存储数据时，SCSI子系统将此写入请求转换为SCSI命令，将请求的数据写入指定的磁盘位置。它充当I/O栈中高层和物理存储之间的中介。SCSI不负责传输过程中数据块的组装或它们在磁盘上的物理放置。在SCSI术语中，发起请求的一方被称为发起者，而目标方则称为目标。SCSI协议的目标可以是单个物理驱动器、HBA或RAID控制器。SCSI协议的主要职责是确保写入任务的成功完成，并将其状态报告给高层。
- en: In the next chapter, we’ll discuss the different physical storage options available
    in today’s world, such as mechanical drives, SSDs, and NVMe drives. We’ll describe
    the differences in their design and see how they compare to each other.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论当今世界中可用的不同物理存储选项，如机械硬盘、固态硬盘（SSD）和NVMe硬盘。我们将描述它们在设计上的差异，并比较它们之间的异同。
