- en: CIS Hardening with Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible进行CIS加固
- en: In [Chapter 13](3d4a9c0a-452f-4fbb-85c8-372149303613.xhtml), *Using CIS Benchmarks*,
    we explored in detail the concept of CIS Benchmarks, how they benefit Linux security
    in the enterprise, and how to apply them. We examined in some detail an example
    of the CIS hardening benchmarks, that being the one for Red Hat Enterprise Linux
    (and CentOS) 7\. Although we concluded that the benchmark document provided a
    great deal of detail regarding the validation checks, and even how to implement
    the benchmarks, we also saw that the whole process was incredibly manual. Further,
    with almost 400 pages of detail to a single operating system benchmark, we established
    that the potential workload for an engineer to implement this on just one server
    would be huge.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](3d4a9c0a-452f-4fbb-85c8-372149303613.xhtml)中，*使用CIS基准*，我们详细探讨了CIS基准的概念，它们如何在企业中提升Linux安全性，以及如何应用它们。我们还详细审查了CIS加固基准的一个示例，即Red
    Hat Enterprise Linux（和CentOS）7的基准。尽管我们得出结论，基准文档提供了大量关于验证检查的详细信息，甚至包括如何实施基准，但我们也看到整个过程极其手动。此外，对于单一操作系统基准，近400页的详细内容，我们认为工程师在仅为一台服务器实施该基准时，所需的工作量将是巨大的。
- en: In this chapter, we will once again bring Ansible into consideration. We have
    already established that Ansible lends itself extremely well to automation at
    enterprise scale, and implementation of the CIS Benchmarks is no exception. As
    we proceed through this chapter, we will learn how to rewrite the CIS Benchmarks
    in Ansible, and then how to apply them at enterprise scale and even maintain oversight
    of the ongoing compliance of your Linux servers against these benchmarks going
    forward. In doing this, we will develop a highly scalable, repeatable approach
    to implementing security benchmarks in the enterprise in a manner that is manageable,
    repeatable, reliable, and secure – all the hallmarks of effective automation in
    the enterprise.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将再次考虑Ansible。我们已经确认Ansible非常适合在企业规模上实现自动化，实施CIS基准也不例外。在本章中，我们将学习如何用Ansible重写CIS基准，然后如何在企业规模上应用它们，甚至如何持续监督Linux服务器对这些基准的合规性。通过这样做，我们将开发一种高度可扩展、可重复的方法，在企业中以可管理、可重复、可靠且安全的方式实现安全基准——这正是企业自动化有效性的标志。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Writing Ansible security policies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Ansible安全策略
- en: Application of enterprise-wide policies with Ansible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible应用企业范围的策略
- en: Testing security policies with Ansible
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible测试安全策略
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter includes examples based on the following technologies:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含基于以下技术的示例：
- en: CentOS 7.6
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CentOS 7.6
- en: Ansible 2.8
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.8
- en: To run through these examples, you will need access to a server or virtual machine
    running the operating system listed previously, alongside Ansible. Note that the
    examples given in this chapter may be destructive in nature (for example, they
    delete files and make changes to server configuration) and if run as shown are
    only intended to be run in an isolated test environment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些示例，您需要访问一台运行前述操作系统和Ansible的服务器或虚拟机。请注意，本章中的示例可能具有破坏性（例如，它们会删除文件并修改服务器配置），如果按示例运行，只应在隔离的测试环境中执行。
- en: Once you are satisfied that you have a safe environment to operate in, we can
    get started with routine system maintenance with Ansible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确认您拥有一个安全的操作环境，就可以开始使用Ansible进行常规系统维护。
- en: All example code discussed in this chapter is available on GitHub at the following
    URL: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter14](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter14).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中讨论的所有示例代码都可以在GitHub上找到，网址为：[https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter14](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter14)。
- en: Writing Ansible security policies
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Ansible安全策略
- en: In [Chapter 13](3d4a9c0a-452f-4fbb-85c8-372149303613.xhtml), *Using CIS Benchmarks*,
    we explored the CIS Benchmark for Red Hat Enterprise Linux 7 (version 2.2.0) and
    looked in detail at the document and implementation techniques. Although throughout
    this book we have focused on two of the more common operating systems found in
    the enterprise – Ubuntu Server LTS and RHEL/CentOS 7 – in the previous chapter,
    we chose to focus on the CIS Benchmark for RHEL 7 alone. This was purely for simplicity,
    as many of the good security practices that apply to RHEL 7 will also apply to
    Ubuntu Server LTS. For example, neither system should have root SSH logins enabled,
    and neither should have packet redirect sending enabled unless it is core to their
    role.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 13 章](3d4a9c0a-452f-4fbb-85c8-372149303613.xhtml)《使用 CIS 基准》中，我们探索了 Red
    Hat Enterprise Linux 7（版本 2.2.0）的 CIS 基准，并详细查看了文档和实现技术。虽然在本书中我们重点关注了企业中常见的两种操作系统——Ubuntu
    Server LTS 和 RHEL/CentOS 7，但在上一章中，我们仅专注于 RHEL 7 的 CIS 基准。这是出于简化考虑，因为许多适用于 RHEL
    7 的良好安全实践同样适用于 Ubuntu Server LTS。例如，两个系统都不应启用 root SSH 登录，且除非它们的角色核心需要，否则也不应启用数据包重定向发送。
- en: In this chapter, we will continue to develop our RHEL 7-based example. Please
    know that most of the techniques employed in this chapter for automating the implementation
    of this benchmark with Ansible will apply equally well to Ubuntu Server LTS, and
    so it is hoped that the knowledge you gain from this chapter will serve you well
    when it comes to implementing security benchmarks on Ubuntu, or any other Linux
    server to which they may apply.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续开发基于 RHEL 7 的示例。请注意，本章中用于通过 Ansible 自动化实现此基准的大多数技术，同样适用于 Ubuntu Server
    LTS，因此希望您从本章中获得的知识能帮助您在实施安全基准时，特别是在 Ubuntu 或其他适用的 Linux 服务器上应用这些技术。
- en: Let's get straight into some practical, hands-on examples of developing CIS
    Benchmark implementations, only this time we will use Ansible rather than shell
    scripts based on the example code in the CIS Benchmark document.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入一些实际操作的示例，开发 CIS 基准实现，这一次我们将使用 Ansible 而不是基于 CIS 基准文档中的示例代码的 shell 脚本。
- en: Let's start by considering our old friend, the remote root login.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从考虑我们老朋友——远程 root 登录开始。
- en: Ensuring remote root login is disabled
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保禁用远程 root 登录
- en: 'In the previous chapter, we devised the following shell script to test for
    the condition described in CIS Benchmark recommendation 5.2.8 (RHEL 7, benchmark
    version 2.2.0), and then implemented it if the condition was not met. It is included
    here so that it can be contrasted against the Ansible solution we are about to
    create:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们编写了以下 shell 脚本，以测试 CIS 基准建议 5.2.8（RHEL 7，基准版本 2.2.0）中描述的条件，并在条件不满足时实现该条件。它在这里被包含进来，以便与我们即将创建的
    Ansible 解决方案进行对比：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This shell script is for just one of the numerous benchmarks, and although it
    does work, it is quite fragile and does not scale across multiple systems. Further,
    the script is not at all easy to read, and so imagine the scale of the script
    that would be required if all the CIS Benchmark recommendations were implemented!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 shell 脚本仅适用于众多基准中的一个，虽然它确实能够工作，但它相当脆弱，且无法跨多个系统扩展。此外，该脚本完全不易于阅读，想象一下如果要实现所有
    CIS 基准建议，所需要的脚本规模会有多大！
- en: Let's consider how we might rewrite this functionality in an Ansible role instead.
    First of all, we know we are testing for a specific line of configuration in a
    single file. If it is not present, then we know that the configuration (implicit
    or otherwise) is to allow remote root logins. In this instance, we carry out two
    actions: first of all, we modify the configuration file to insert the correct
    line (or modify the existing line if it exists but has the wrong value configured).
    Then, we restart the SSH daemon if the configuration file was changed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑如何将此功能改写为 Ansible 角色。首先，我们知道我们正在测试单个文件中的特定配置行。如果该行不存在，我们就知道该配置（无论是隐式的还是其他）允许远程
    root 登录。在这种情况下，我们执行两个操作：首先，我们修改配置文件，插入正确的行（如果该行已存在但配置值错误，则修改现有行）。然后，如果配置文件已更改，我们将重启
    SSH 守护进程。
- en: Our experience with Ansible has shown us that the `lineinfile` module can handle
    nearly all of the work-related to both checking the configuration file and modifying
    it if the requisite line isn't correctly configured. We have also learned that
    the `service` module can easily restart the SSH daemon, and that this module would
    be run from a `handler` rather than in the main task flow to ensure that the daemon
    is not restarted unless the configuration is actually modified.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在使用Ansible的经验表明，`lineinfile`模块几乎可以处理与检查配置文件和修改配置文件（如果未正确配置必需的行）相关的所有工作。我们还学到了`service`模块可以轻松地重新启动SSH守护程序，并且这个模块将从一个`handler`而不是在主任务流中运行，以确保只有在实际修改配置时才重新启动守护程序。
- en: 'Thus, we might define a role containing a single task that looks like this
    in a role called `rhel7cis_recommendation528`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以定义一个角色，其中包含一个单独的任务，如在名为`rhel7cis_recommendation528`的角色中所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice how we have given the task a meaningful name – taken, in fact, directly
    from the CIS Benchmark document itself. Thus, we know exactly which benchmark
    this is, what it is for, and whether or not it is scored.  We have also inserted
    the level information into the title as again this would save us from cross-referencing
    the original CIS Benchmark document later on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经为任务赋予了一个有意义的名称– 实际上直接来自CIS基准文档本身。因此，我们完全知道这是哪个基准，它的用途以及是否计分。我们还在标题中插入了级别信息，因此这样可以避免在后面交叉参考原始的CIS基准文档。
- en: 'Alongside our role tasks, we also want to create a handler to restart the SSH
    daemon if we modify the configuration file (it will not pick up the changes without
    this) – an example of suitable code for this handler is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们的角色任务外，我们还希望创建一个处理程序，在修改配置文件后重新启动SSH守护程序（如果不这样做，它将无法获取更改）– 这个处理程序的示例代码如下：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can already see that this playbook is much easier to read than our original
    shell script – there is none of the code duplication we found when we implemented
    this benchmark in a shell script, and the `lineinfile` module is so powerful that
    it wraps all of our various checks up into one single Ansible task.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经可以看到，这个playbook比我们最初的shell脚本要容易阅读得多– 当我们在shell脚本中实现这个基准时，我们发现没有任何代码重复，并且`lineinfile`模块非常强大，可以将我们所有的各种检查都包装成一个单一的Ansible任务。
- en: 'Running the role should yield output similar to that shown in the following
    screenshot on a system that has remote root logins enabled:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该角色应该会产生类似于在启用了远程root登录的系统上显示的以下屏幕截图的输出：
- en: '![](img/441adfc0-b2c3-4ab3-bd44-fea8096075a8.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/441adfc0-b2c3-4ab3-bd44-fea8096075a8.png)'
- en: 'By contrast, if the recommendation is already implemented, then the output
    will look like that shown in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果建议已经实施，则输出将如以下屏幕截图所示：
- en: '![](img/9524fed6-2ed1-41cf-8aa5-bd63ecf68a6b.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9524fed6-2ed1-41cf-8aa5-bd63ecf68a6b.png)'
- en: As you can see, if the condition is met, the `lineinfile` module makes no changes
    (resulting in the `ok` status seen in the preceding screenshot), and the handler
    does not run at all.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，如果条件得到满足，`lineinfile`模块将不会进行任何更改（导致在前面截图中看到的`ok`状态），而处理程序根本不会运行。
- en: This in itself is extremely powerful, and a huge improvement over our shell
    script in terms of both manageability and coding effort. Nonetheless, the RHEL
    7 CIS Benchmark contains almost 400 recommendations, and you would not want to
    have to create and include 400 roles in a playbook run as this would detract from
    the otherwise manageable nature of our Ansible automation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身就非常强大，并且在可管理性和编码工作方面明显优于我们的shell脚本。尽管如此，RHEL 7 CIS基准包含了几乎400个建议，您不希望在playbook运行中创建和包含400个角色，因为这会削弱我们Ansible自动化的可管理性。
- en: In the next section of this chapter, we will look at expanding our current playbook
    by adding another recommendation from *section 5* of the CIS Benchmark, thus building
    up our playbook code in a scalable, manageable fashion.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一节中，我们将查看如何通过添加CIS基准*第5节*中的另一个建议来扩展我们当前的playbook，从而以可扩展和可管理的方式构建我们的playbook代码。
- en: Building up security policies in Ansible
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Ansible中构建安全策略
- en: If we were to proceed precisely as we did in the previous section, then when
    it comes to *section 5.2.9* of the RHEL 7 CIS Benchmark version 2.2.0 (Ensure
    SSH `PermitEmptyPasswords` is disabled), we would create a new role called `rhel7cis_recommendation529`
    and put the relevant tasks and handlers inside it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按之前的方式进行，那么当涉及到RHEL 7 CIS基准版本2.2.0的*第5.2.9节*（确保禁用SSH `PermitEmptyPasswords`）时，我们会创建一个新的角色，名为`rhel7cis_recommendation529`，并将相关的任务和处理程序放入其中。
- en: 'I''m sure that you will be able to see that this does not scale well – the
    creation of a new role means we need to specify it in our top-level playbook,
    which would look something like the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你会发现，这种方式并不具备良好的扩展性——创建一个新角色意味着我们需要在顶级剧本中指定它，可能会像下面这样：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Having one role per line, with almost 400 roles to include, would quickly become
    tedious and detract from the highly manageable nature of our Ansible code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每行一个角色，且几乎需要包含400个角色，这会很快变得繁琐，从而削弱我们Ansible代码的高可管理性。
- en: Exactly how you divide up your Ansible tasks into roles is up to you, and you
    should utilize the method that you find most manageable. As a suggestion, though,
    looking at the table of contents for our example CIS Benchmark, we can see that
    the recommendations are divided into six sections. Those in *section 5* relate
    specifically to *Access, Authentication*, *and Authorization*, and thus it is
    entirely logical that we might want to group all of these together into one role,
    perhaps called `rhel7cis_section5`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何将Ansible任务划分为角色完全取决于你自己，你应该采用你认为最易于管理的方法。然而，作为建议，通过查看我们示例CIS基准的目录结构，我们可以看到建议被分为六个部分。*第5部分*特别涉及*访问、认证*和*授权*，因此，我们完全可以将所有这些建议集中到一个角色中，可能称为`rhel7cis_section5`。
- en: 'With this decision made regarding playbook structure, we can now proceed to
    build both the checks for recommendations 5.2.8 and 5.2.9 into the same role.
    They can share the same handler too, as both relate to SSH daemon configuration.
    Thus, our new role''s tasks could look like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定了剧本结构后，我们现在可以继续将建议5.2.8和5.2.9的检查构建到同一个角色中。它们也可以共享相同的处理程序，因为它们都与SSH守护进程配置相关。因此，我们新角色的任务可能如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The resulting code is still highly readable and is broken down into manageable
    chunks, but is now not so granular that it would be difficult to maintain the
    top-level playbook.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 结果代码仍然具有很高的可读性，并被分解为可管理的块，但现在的粒度不再细致到难以维护顶级剧本。
- en: 'Our handler code remains the same as before, and now when we run the role on
    a system that does not meet either of these recommendations, the output should
    look something like the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理程序代码保持不变，现在当我们在一个不符合这些建议的系统上运行角色时，输出应该类似于下面的截图：
- en: '![](img/2a96f435-4509-4ab3-b77b-431271ea1c27.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a96f435-4509-4ab3-b77b-431271ea1c27.png)'
- en: 'This is very clean and tidy, and hopefully you can see how this could scale
    well when it comes to implementing all of the nearly 400 recommendations from
    the CIS Benchmark if you chose to do so. However, it also raises an important
    consideration: in an ideal world, all of the CIS recommendations would be applied
    to every machine, yet in reality, this is not always possible. In the *Applying
    security policy wisely* section of [Chapter 13](3d4a9c0a-452f-4fbb-85c8-372149303613.xhtml),
    *Using CIS Benchmarks*, we discussed a variety of recommendations that you would
    apply caution to implementing. In addition, as much as it is desirable to never
    perform a remote login with the root account over SSH, I have come across systems
    where this is actually required to support some kind of legacy system until it
    can be updated.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简洁整洁，希望你能看到，如果你选择实施CIS基准中的近400个建议时，这种方法能够很好地扩展。然而，这也引出了一个重要的考虑：在理想的情况下，所有CIS建议都会应用于每一台机器，但在现实中，这并不总是可能的。在[第13章](3d4a9c0a-452f-4fbb-85c8-372149303613.xhtml)的*明智地应用安全策略*部分中，*使用CIS基准*，我们讨论了在实施时需要谨慎对待的各种建议。此外，尽管永远避免使用root账户通过SSH进行远程登录是理想的，但我遇到过一些系统，实际上需要这样做，以支持某种遗留系统，直到它能够更新。
- en: In short, there will always be a requirement for exceptions in the process of
    policy enforcement. The important thing is to handle this in a graceful manner.
    Say you have 100 Linux machines to apply our newly written mini security policy
    to, but that two require remote root logins to be enabled.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在政策执行的过程中，始终会有例外的需求。重要的是要以优雅的方式处理这一点。假设你有100台Linux机器需要应用我们新编写的小型安全策略，但其中有两台需要启用远程root登录。
- en: 'In this instance, we have two choices:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，我们有两个选择：
- en: Maintain a separate set of playbooks for the two servers where the exceptions
    are required
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为需要例外的两台服务器维护一组独立的playbook
- en: Find a way to selectively run the tasks in our role without having to modify
    it
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到一种方法，在不修改角色的情况下选择性地运行任务
- en: Of these choices, the second is clearly the better of them as it supports us
    in maintaining one single playbook. But how do we achieve this?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些选择中，第二种显然是更好的选择，因为它帮助我们维护一个单一的playbook。但我们该如何实现呢？
- en: Ansible offers us two tools to approach this problem. The first is the `when`
    clause that we have already considered several times in this book. So far, we
    have only looked at this clause to evaluate a condition programatically (for example,
    to run a disk cleanup on the condition that free space on the disk falls below
    a certain value). In this instance, we employ a much simpler implementation – simply
    evaluating whether a Boolean value is true or not.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible为我们提供了两种方法来处理这个问题。第一种是我们在本书中已经多次提到的`when`子句。到目前为止，我们只是查看了这个子句来编程地评估条件（例如，在磁盘的空闲空间低于某个值时执行磁盘清理）。在这个实例中，我们使用了一个更简单的实现——只需要评估布尔值是否为真。
- en: 'Suppose that we add the following code below our task to implement recommendation
    5.2.8:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在任务下方添加以下代码来实现推荐 5.2.8：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These two lines evaluate a variable called `recommendation_528` and applies
    two Jinja2 filters to ensure it is processed correctly, even when the variable
    is undefined:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码评估一个名为`recommendation_528`的变量，并应用两个Jinja2过滤器，确保即使该变量未定义，也能正确处理：
- en: The `default` filter sets the variable to `true` by default as Ansible will
    fail the play with an error if any variable it encounters is undefined. This removes
    the need for us to define these variables up-front – our role simply defaults
    them to `true` unless we set them otherwise.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`过滤器将变量默认设置为`true`，因为如果Ansible遇到任何未定义的变量，都会导致play失败并报错。这就避免了我们必须事先定义这些变量——我们的角色只是默认将它们设置为`true`，除非我们另行设置。'
- en: The second filter casts them to a `bool` type to ensure a reliable evaluation
    of the condition.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个过滤器将其转换为`bool`类型，以确保可靠地评估条件。
- en: Remember that `true` can be both a string and a Boolean value, depending on
    how you interpret it. Using the `|bool` filter ensures that Ansible evaluates
    it in the Boolean context.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`true`可以是字符串类型或布尔值，取决于你如何解释它。使用`|bool`过滤器确保Ansible将其在布尔上下文中进行评估。
- en: 'Similarly, for the second task, we would add the following immediately below
    the `notify` clause:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于第二个任务，我们将在`notify`子句下方立即添加以下内容：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, if we run the playbook without doing anything else to it against a system
    that is not compliant, it behaves exactly as it did before, as shown in the following
    screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在没有做任何其他修改的情况下，针对一个不符合要求的系统运行playbook，它将像之前一样运行，如下图所示：
- en: '![](img/f8a1bba0-e42d-4a57-b870-6177e5143dba.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8a1bba0-e42d-4a57-b870-6177e5143dba.png)'
- en: 'The magic now happens when we want to run it against a system where we wish
    to skip one or both of these recommendations. Imagine that our host, `legacy-testhost`,
    is a legacy system where remote root logins are still a requirement. To use this
    role on this particular system, we know that we must set `recommendation_528`
    to `false`. This can be performed at a variety of levels, and the inventory is
    probably the most sensible place to define it as it prevents someone from accidentally
    running the playbook in the future without defining this and hence breaking our
    legacy code by denying remote root logins. We can create a new inventory for this
    system that might look something like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望在系统上运行时，跳过这些推荐之一或两个时，魔法就发生了。假设我们的主机`legacy-testhost`是一个遗留系统，仍然要求启用远程root登录。为了在这个系统上使用这个角色，我们知道必须将`recommendation_528`设置为`false`。这可以在不同的级别进行，并且在清单中定义它可能是最合适的地方，因为它可以防止有人在未来意外运行playbook时没有定义这一点，从而破坏我们的遗留代码并拒绝远程root登录。我们可以为这个系统创建一个新的清单，可能看起来像这样：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Having set the variable for the recommendation we want to skip to `false`,
    we can then run our role against this new inventory, and the results should look
    something like those shown in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们想要跳过的推荐变量设置为`false`后，我们可以使用这个新的清单运行角色，结果应该类似于以下截图所示：
- en: '![](img/16be69cc-264c-4f70-8467-4d7f41256025.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16be69cc-264c-4f70-8467-4d7f41256025.png)'
- en: This was exactly what we desired – recommendation 5.2.8 was skipped on our legacy
    system, and all we had to do was define a variable in the inventory – the role
    code from all our other servers was reused.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们所期望的——推荐5.2.8在我们的旧系统中被跳过，我们所需要做的就是在清单中定义一个变量——来自所有其他服务器的角色代码被复用。
- en: Using the `when` clause with a simple Boolean variable works well for simple
    decisions like this, but what about when you have multiple criteria to evaluate?
    Although the `when` clause can evaluate both logical `and` and `or` constructs,
    this could become somewhat difficult to manage as complexity increases.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`when`条件和简单的布尔变量对于像这样的简单决策效果很好，但如果你有多个标准需要评估呢？尽管`when`条件可以评估逻辑上的`and`和`or`构造，但随着复杂性增加，这可能变得有些难以管理。
- en: 'Ansible tags are the second tool that will help us here, and these are a special
    feature that is designed specifically to allow you to run only desired portions
    of a role or playbook, rather than having to run the whole thing from start to
    finish. Suppose that we add the following tags below our task for implementing
    recommendation 5.2.8:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible标签是我们在这里的第二个工具，它们是一个特殊功能，专门设计用于允许你只运行所需的部分角色或剧本，而不需要从头到尾运行整个内容。假设我们在实现推荐5.2.8的任务下方添加以下标签：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Below the task for recommendation 5.2.9, we might add the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在推荐5.2.9的任务下，我们可能会添加以下内容：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The behavior of these tags is best explained by example, and as this is a hands-on
    book, we will do exactly that. The first thing to note is that adding tags to
    a playbook (or role within a playbook) does absolutely nothing unless you specify
    which tags to run, or to skip. Thus, if we run our playbook in its current form,
    it behaves exactly as it always has, in spite of the addition of the tags, as
    the following screenshot shows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签的行为最好通过示例来解释，既然这是一本实践手册，我们将准确地做到这一点。首先需要注意的是，向剧本（或剧本中的角色）添加标签，除非你指定要运行或跳过哪些标签，否则完全没有任何作用。因此，如果我们以当前形式运行剧本，它的行为将和以往一样，尽管添加了标签，正如以下截图所示：
- en: '![](img/803ae32e-11bf-4136-91c3-add7780bcee1.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/803ae32e-11bf-4136-91c3-add7780bcee1.png)'
- en: 'The magic comes when we specify which tags are to be run. Let''s repeat the
    previous command, but this time add `--skip-tags=notlegacy`. The switch does exactly
    what it implies – all tasks with the `notlegacy` tag are ignored. The following
    screenshot shows the output from such a run of this playbook:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 魔力就在于当我们指定要运行的标签时。让我们重复前面的命令，但这次添加`--skip-tags=notlegacy`。这个开关正如其名所示——所有带有`notlegacy`标签的任务都会被忽略。以下截图显示了运行该剧本后的输出：
- en: '![](img/f51d5c68-3554-41b4-9f11-23e80006f74e.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f51d5c68-3554-41b4-9f11-23e80006f74e.png)'
- en: Here, we see a marked difference from the use of the `when` clause – where previously
    we observed that our task for recommendation 5.2.8 was evaluated but subsequently
    skipped, it does not even appear in the preceding playbook output – in short,
    the entire task has been treated as if it didn't exist.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到与`when`条件的使用有明显不同——之前我们观察到推荐5.2.8的任务被评估后跳过，但它甚至没有出现在之前的剧本输出中——简而言之，整个任务被当做不存在。
- en: If we had run the playbook with the `--tags=allservers` option, we would have
    observed both tasks running, as both were tagged with this value.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`--tags=allservers`选项运行剧本，我们会看到两个任务都在运行，因为它们都带有这个标签。
- en: This becomes incredibly useful not only for our example here, but when considering
    the wider benchmark document. For example, we have already discussed that all
    recommendations are either level 1 or level 2\. Equally, we know that some are
    scored, and some not.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于我们这里的示例非常有用，也适用于考虑更广泛的基准文档。例如，我们已经讨论过，所有的推荐都分为1级或2级。同样，我们知道有些是有评分的，而有些则没有。
- en: 'Knowing that level 1 benchmarks are less likely to disrupt the day-to-day running
    of a Linux server, we could implement all recommendations in a playbook with the
    level as one of the tags for each, and then if we were to run the playbook with
    `--tag=level1`, then only the level 1 recommendations would be implemented. Working
    with this example, the tags for our task for recommendation 5.2.8 might be as
    follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 知道级别 1 基准不太可能干扰 Linux 服务器的日常运行，我们可以在 playbook 中实施所有建议，并将级别作为每个建议的标签之一。然后，如果我们使用
    `--tag=level1` 运行 playbook，那么只有级别 1 的建议将被实施。以此例子为基础，我们为建议 5.2.8 的任务的标签可能如下所示：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you are building up your roles and playbooks to implement security benchmarks,
    regardless of the operating system or security standard, it is recommended that
    you make use of the when clause and tags to the best of your advantage. Remember
    – when automating at enterprise scale, the last thing you want is lots of fragmented
    pieces of code to manage, all of which are similar but do slightly different things.
    The more you can standardize, the more manageable your enterprise will be, and
    appropriate use of these features will serve you well in ensuring you can maintain
    a single Ansible code base, and yet tailor its actions at runtime to handle the
    exceptions in your server estate.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建角色和 playbooks 来实施安全基准时，无论操作系统或安全标准如何，建议您充分利用 when 子句和标签。请记住，在企业规模自动化时，您最不希望管理许多碎片化的代码片段，它们都相似但功能稍有不同。您可以标准化的部分越多，您的企业管理就会越容易，合理使用这些功能将有助于确保您可以维护单一的
    Ansible 代码库，并在运行时调整其操作以处理服务器群中的异常情况。
- en: Since we have been considering appropriate playbook and role structure for our
    security benchmark, we have deliberately kept our examples simple in this section.
    In the next section, we will revisit some of the more complex examples we highlighted
    in [Chapter 13](3d4a9c0a-452f-4fbb-85c8-372149303613.xhtml), *Using CIS Benchmarks*,
    and demonstrate how Ansible makes them far easier to code and understand.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们一直在考虑适合我们安全基准的适当 playbook 和 role 结构，因此我们在本节中故意保持了我们的例子简单。在下一节中，我们将重新审视我们在
    [第 13 章](3d4a9c0a-452f-4fbb-85c8-372149303613.xhtml) 中突出显示的一些更复杂的例子，并演示 Ansible
    如何使它们更容易编码和理解。
- en: Implementing more complex security benchmarks in Ansible
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Ansible 中实施更复杂的安全基准
- en: One of the examples we considered in detail in [Chapter 13](3d4a9c0a-452f-4fbb-85c8-372149303613.xhtml),
    *Using CIS Benchmarks*, was recommendation 3.1.2, which is concerned with packet
    redirect sending being disabled. This is considered important on any machine that
    is not supposed to be acting as a router (though it should not be implemented
    on a router as it would stop the router from functioning correctly).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 13 章](3d4a9c0a-452f-4fbb-85c8-372149303613.xhtml) 中我们详细考虑的一个例子是 *使用 CIS
    基准*，建议 3.1.2，这关注的是禁用数据包重定向发送。这在任何不应充当路由器的机器上都被认为是重要的（尽管在路由器上不应实施它，因为这会导致路由器功能异常）。
- en: 'On the face of it, this recommendation looks quite straightforward – we simply
    need to set these two kernel parameters, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，这个建议看起来非常简单 – 我们只需设置这两个内核参数，如下所示：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In spite of this apparent simplicity, we ended up developing almost 60 lines
    of shell script to implement this check because we had to check both the currently
    active kernel parameters and persistent configuration file values, and then perform
    the appropriate changes if the values were not set as desired.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管表面上看起来很简单，但我们最终开发了将近 60 行的 Shell 脚本来实施这个检查，因为我们需要检查当前活动的内核参数和持久配置文件的值，并在这些值未按预期设置时执行适当的更改。
- en: Here, once again, Ansible comes to our rescue. The `sysctl` module within Ansible
    wraps up many of the tests and configuration work that we constructed into our
    shell script. Further, we can use a loop so that the same task code can we run
    twice – once against each of the aforementioned kernel parameters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，再次，Ansible 来到我们的救援。Ansible 中的 `sysctl` 模块封装了我们在 Shell 脚本中构建的许多测试和配置工作。此外，我们可以使用循环使得相同的任务代码可以运行两次
    – 一次针对上述每个内核参数。
- en: 'When developing a role for this, we could define a single task that looks something
    like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在为此开发角色时，我们可以定义一个类似以下的单个任务：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The recommendation also says that if we implement these changes, we should
    also flush out the IPv4 routes on the system. This is also achieved through a
    `sysctl` parameter, and so we simply use the `sysctl` module again, only this
    time in a `handler`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 基准推荐还指出，如果我们实施这些更改，我们还应该刷新系统上的 IPv4 路由。这也是通过 `sysctl` 参数来实现的，因此我们只需再次使用 `sysctl`
    模块，不过这次是在 `handler` 中使用：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running this against a test system might yield output similar to that shown
    in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试系统上运行此命令可能会产生类似于以下截图的输出：
- en: '![](img/836b6104-e9c2-4e1e-b1a8-9ab7d26b6217.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/836b6104-e9c2-4e1e-b1a8-9ab7d26b6217.png)'
- en: As we can see from the preceding screenshot, this code has run successfully
    and applied the setting recommended by the benchmark, and as a direct result of
    the change, the handler has fired and flushed the IPv4 routes. The overall result
    of this is that what took 57 lines of fairly unreadable shell script can now be
    achieved in 14 lines of far more readable YAML.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的截图可以看到，这段代码已经成功运行，并应用了基准推荐的设置，作为此更改的直接结果，处理程序已被触发并刷新了 IPv4 路由。最终结果是，原本需要
    57 行难以阅读的 shell 脚本，现在可以通过 14 行更加可读的 YAML 完成。
- en: So far, we have built up a clear picture of how Ansible can make the design
    and implementation of CIS recommendations straightforward, especially when compared
    to alternatives such as shell scripting. We have noted that native Ansible modules
    such as `sysctl` and `lineinfile` can gracefully wrap up a multitude of steps
    that would have have been performed by a shell script. However, there are times
    when you, as the playbook author, must make some important decisions for your
    playbooks, and we will look at this in more detail in the following section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经清楚地了解了 Ansible 如何使 CIS 推荐的设计和实施变得简单，特别是与诸如 shell 脚本等替代方案相比。我们注意到，原生的
    Ansible 模块，如 `sysctl` 和 `lineinfile`，可以优雅地封装许多原本由 shell 脚本执行的步骤。然而，作为剧本作者的你，有时必须为你的剧本做出一些重要决策，接下来的章节将更详细地探讨这一点。
- en: Making appropriate decisions in your playbook design
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在剧本设计中做出合适的决策
- en: As you build up your roles and playbooks to implement security baselines, you
    will discover that some of your implementation will be cut and dried (for example,
    you will almost certainly know whether you want root SSH logins to be possible
    or not), whereas there will be decisions to be made for other aspects. Time synchronization
    is one such example, and in this section, we will explore this in more detail
    to demonstrate the kinds of decisions you can expect to make when designing your
    roles, as well as how to address them in a constructive manner.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在你构建角色和剧本来实现安全基准时，你会发现有些实现是非常明确的（例如，你几乎肯定会知道是否希望允许 root 用户通过 SSH 登录），而对于其他方面则需要做出决策。时间同步就是一个例子，在本节中，我们将更详细地探讨这个问题，以展示在设计角色时可能需要做出的决策，以及如何以建设性的方式解决它们。
- en: If you review *section 2.2.1* of the RHEL 7 CIS Benchmark (version 2.2.0), you
    will see that it is entirely concerned with time synchronization. Indeed, this
    is an important function in just about every Enterprise Linux infrastructure,
    and discrepancies between the clocks on servers can cause issues such as with
    certificate validity and Kerberos tickets.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 RHEL 7 CIS 基准（版本 2.2.0）中的 *2.2.1 节*，你会看到它完全关注时间同步。事实上，这是几乎所有企业 Linux 基础设施中的重要功能，服务器时钟之间的差异可能会导致如证书有效性和
    Kerberos 票据等问题。
- en: 'Although it is almost universally agreed that time synchronization is vitally
    important, there is less agreement on the way to achieve it. For example, there
    are two main time synchronization services available for most mainstream Linux
    distributions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管几乎所有人都一致认为时间同步至关重要，但对于如何实现这一目标却意见不一。例如，大多数主流 Linux 发行版有两种主要的时间同步服务：
- en: '`chrony`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chrony`'
- en: '`ntpd`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ntpd`'
- en: Although `chrony` is now the standard on RHEL 7, this does not mean that the
    venerable `ntpd` service will no longer work – in fact, some enterprises still
    choose to implement this because they have extensive experience with it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 RHEL 7 上 `chrony` 现在是标准工具，这并不意味着老牌的 `ntpd` 服务将不再工作——实际上，一些企业仍然选择实施它，因为他们在这方面有着丰富的经验。
- en: 'It is entirely possible to get Ansible to detect which of these two services
    a given Linux server is using – at a high level, we could get Ansible to do the
    following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 完全有可能让 Ansible 检测到给定 Linux 服务器正在使用这两项服务中的哪一项——从高层次来看，我们可以让 Ansible 做如下操作：
- en: Query the RPM package database to see whether `ntpd`, `chrony`, or both are
    installed.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询 RPM 软件包数据库，查看是否安装了 `ntpd`、`chrony` 或两者。
- en: 'If one or both are installed, detect which one is active:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果安装了一个或两个服务，请检测哪一个是活跃的：
- en: a. If neither are active, this needs rectifying as we have established the need
    for time synchronization.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: a. 如果两者都未活跃，则需要纠正，因为我们已经确认需要时间同步。
- en: b. If both are active, the services will clash and one should be disabled.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果两者都活跃，则服务将发生冲突，应禁用其中一个。
- en: As I'm sure you will see, there comes a point in the preceding process where
    an intervention is required – if neither service is started, we need to choose
    one to start. If both are active, we need to disable one. This is where Ansible's
    ability to help ends – it cannot decide for your particular enterprise which of
    these two perfectly valid services is best for your use case.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我相信您会看到的，前述过程中会有一个干预点 – 如果两个服务都未启动，我们需要选择一个来启动。如果两者都活跃，我们需要禁用一个。这是 Ansible
    的帮助能力止步的地方 – 它无法为您的特定企业决定这两个完全有效的服务中哪一个最适合您的用例。
- en: Thus, it is important to make a decision up-front about which time synchronization
    service you are using. With this decision made, playbooks can then be specifically
    coded to perform the appropriate checks and equally perform the appropriate remediation
    steps as required. In addition, we know from our discussion in [Chapter 1](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml),
    *Building a Standard Operating Environment on Linux*, that automation at enterprise
    scale is supported by commonality and standards – so we know from these principles
    that we should choose a standard time synchronization service and stick with it
    except where there is a good business reason to raise an exception.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，重要的是提前做出关于使用哪种时间同步服务的决定。有了这个决定，playbook 可以专门编码以执行适当的检查，并按需要执行适当的补救步骤。此外，从我们在
    [第1章](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml) 中的讨论中知道，*在 Linux 上构建标准操作环境*，企业规模的自动化受到共同性和标准的支持
    – 因此，我们知道根据这些原则，我们应选择一个标准的时间同步服务，并坚持使用，除非有很好的业务理由提出例外。
- en: 'To progress this example, let''s look at recommendation 2.2.1.1\. This states
    that we should ensure that a time synchronization service is in use – though it
    is agnostic about which one. If we have made our decision up-front about which
    service is relevant, our playbook development is easy. Suppose we have chosen
    `chrony` (the default for RHEL 7); our role for this recommendation might be as
    follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了推进这个例子，让我们看看建议 2.2.1.1\. 这项建议指出我们应确保正在使用时间同步服务 – 尽管它对于哪一个是不可知的。如果我们已经提前决定了哪个服务是相关的，我们的
    playbook 开发就很容易。假设我们选择了 `chrony`（RHEL 7 的默认选择）；我们为这个建议的角色可能如下所示：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This simple code ensures that we both check for and satisfy recommendation 2.2.1.1
    without the need for any logic to detect which time service is in use. Of course,
    we could choose to be more thorough and check that `ntpd` is not started, but
    this is left as an exercise to you.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简单的代码确保我们检查并满足建议 2.2.1.1，而无需检测正在使用哪个时间服务的任何逻辑。当然，我们可以选择更彻底地检查 `ntpd` 是否未启动，但这留给您作为一个练习。
- en: Naturally, we cannot fit all the Ansible code that's required for the roughly
    400 recommendations in this CIS Benchmark into this book – that would deserve
    an entire book to itself! In addition, this example is just for one benchmark
    – if your enterprise introduces a new operating system such as RHEL 8, you can
    be sure there will be a separate CIS Benchmark for this operating system that
    will need to be implemented. However, it is hoped that the development of these
    examples from the RHEL 7 CIS Benchmark is sufficient for you to design and build
    your own policy. Thus, in the next section of this chapter, we will look at techniques
    for making this task manageable at enterprise scale.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们无法将大约 400 个建议中所需的所有 Ansible 代码都放入这本书中 – 这本身就值得一本书！此外，这个例子仅适用于一个基准 – 如果您的企业引入了新的操作系统，如
    RHEL 8，您可以肯定会有一个单独的适用于该操作系统的 CIS 基准需要实施。但希望这些来自 RHEL 7 CIS 基准的示例足以让您设计和构建自己的策略。因此，在本章的下一部分，我们将探讨在企业规模下管理此任务的技术。
- en: Application of enterprise-wide policies with Ansible
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 应用企业范围的策略
- en: Although we have seen the significant benefits that Ansible can bring to CIS
    Benchmark implementation, I'm sure it is apparent at this stage that development
    and maintenance of these policies could turn into a full-time job, especially
    when coupled with the need to run them against the infrastructure and manage the
    results of each run.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经看到 Ansible 在实施 CIS 基准方面带来的显著好处，但我相信现在你应该能够看出，开发和维护这些策略可能会变成一份全职工作，尤其是当需要在基础设施上运行它们，并管理每次运行的结果时。
- en: Fortunately, the spirit of open source development brings a solution to this
    dilemma. Imagine if someone had already spent a great deal of time and effort
    developing a high-quality set of Ansible roles for implementing CIS Benchmarks,
    and that this was available as open source code so that you could audit it, ensure
    it was fit for your environment, and tailor it easily if required. Further, imagine
    that they had put a great deal of time and effort into tagging each task, and
    adding appropriate variable structure to allow you to easily specify your choices
    such as which time synchronization service your enterprise uses.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，开源开发精神为这一难题带来了一个解决方案。试想，如果有人已经花费大量时间和精力开发出了一套高质量的 Ansible 角色，用于实施 CIS 基准，而且这些角色以开源代码的形式提供，这样你就可以审计它，确保它适合你的环境，并在需要时轻松调整。此外，假设他们已经投入了大量时间和精力，为每个任务添加标签，并且加入了适当的变量结构，以便你能够轻松指定你的选择，比如你的企业使用的时间同步服务。
- en: Thankfully, this work has already been completed by MindPoint Group, and their
    code has been made freely available on GitHub at [https://github.com/MindPointGroup/RHEL7-CIS](https://github.com/MindPointGroup/RHEL7-CIS).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这项工作已经由 MindPoint Group 完成，他们的代码已经免费提供在 GitHub 上，网址是 [https://github.com/MindPointGroup/RHEL7-CIS](https://github.com/MindPointGroup/RHEL7-CIS)。
- en: At the time of writing, the latest CIS Benchmark available for EL7 systems is
    version 2.2.0, whereas the aforementioned playbooks are written against version
    2.1.1 of the benchmark. It is up to you to ensure you are aware of the benchmark
    version you are implementing, as well as any possible security implications if
    you implement a slightly older version.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文写作时，适用于 EL7 系统的最新 CIS 基准版本是 2.2.0，而前面提到的 playbook 是针对基准版本 2.1.1 编写的。你需要确保了解你正在实施的基准版本，并注意如果使用稍旧版本可能带来的安全隐患。
- en: In addition to this, just as users of Ubuntu may choose paid support or to use
    the free open source operating system, and EL7 users may choose between Red Hat
    Enterprise Linux 7 or CentOS 7, MindPoint Group also offers a commercially supported
    version of their Ansible hardening code, available via [https://www.lockdownenterprise.com/](https://www.lockdownenterprise.com/).
    Thus, they offer support for both ends of the spectrum, respecting that some enterprises
    will absolutely require an enterprise support contract, while others will prefer
    to use freely available open source software.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，正如 Ubuntu 的用户可以选择付费支持或使用免费的开源操作系统一样，EL7 用户也可以选择 Red Hat Enterprise Linux
    7 或 CentOS 7，MindPoint Group 也提供了他们的 Ansible 加固代码的商业支持版本，网址为 [https://www.lockdownenterprise.com/](https://www.lockdownenterprise.com/)。因此，他们在整个领域提供了支持，尊重一些企业绝对需要企业支持合同，而另一些企业则更倾向于使用免费的开源软件。
- en: 'Let''s explore how we might use the open source code against our CentOS 7 server:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一下如何在我们的 CentOS 7 服务器上使用开源代码：
- en: 'First of all, we need to clone the GitHub repository:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要克隆 GitHub 仓库：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once this is complete, we can then proceed to use the code exactly as we would
    use any other role. Where appropriate, we should set variables, which can be set
    either in the inventory or in the main playbook (more on this in a second).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成这些工作，我们就可以像使用任何其他角色一样使用这段代码。在适当的地方，我们应该设置变量，这些变量可以在清单中或在主 playbook 中设置（稍后会详细说明）。
- en: 'Thus, the purest and simplest possible implementation of the MindPoint Group
    CIS Benchmark in Ansible once the role has been cloned from GitHub is a playbook
    that looks like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦从 GitHub 克隆了角色，使用 MindPoint Group 的 CIS 基准在 Ansible 中的最纯粹、最简单的实现就是一个像下面这样的
    playbook：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With these steps complete, you can literally begin implementing the EL7 benchmark
    and its near 400 recommendations on your Linux servers in a matter of minutes
    – the playbook is run in the normal manner, and will produce many pages of output
    as all the checks are performed and recommendations implemented (if/when required).
    The following screenshot shows the playbook being run and the initial page of
    output:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些步骤后，你实际上可以在几分钟内开始在 Linux 服务器上实现 EL7 基准及其近 400 项推荐——playbook 按照正常方式运行，并且在执行所有检查和实现推荐时（如需要）会生成许多页面的输出。以下截图展示了
    playbook 的运行情况和初始输出页面：
- en: '![](img/a25b3be9-a3c6-48bb-86a8-1eb96437f806.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a25b3be9-a3c6-48bb-86a8-1eb96437f806.png)'
- en: Now, a word on variables. As we established in the previous section (*Writing
    Ansible security policies*), there will be occasions where you need to vary your
    playbook run. The variables and tags are all documented in the `README.md` file
    that accompanies the GitHub repository we cloned earlier, and for purposes of
    illustration, let's consider a few examples.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于变量的一点说明。正如我们在上一节中所提到的（*编写 Ansible 安全策略*），会有一些情况下你需要改变 playbook 的运行方式。变量和标签都在我们之前克隆的
    GitHub 仓库中附带的 `README.md` 文件中有详细说明，为了说明问题，我们来看几个例子。
- en: 'First off, suppose we only want to implement the level 1 recommendations (those
    that are less risky to day-to-day operations). This can be achieved by running
    the playbook and using the `level1` tag:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设我们只想实施第一级推荐（那些对日常操作风险较小的）。可以通过运行 playbook 并使用 `level1` 标签来实现：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Alternatively, you might be running the hardening playbooks against a set of
    servers that act as routers. In this instance, we would need to set the `rhel7cis_is_router`
    variable to `false` to ensure that kernel parameters that disable router functionality
    are not set.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能在对一组作为路由器的服务器运行加固 playbooks。在这种情况下，我们需要将`rhel7cis_is_router`变量设置为`false`，以确保不会设置那些禁用路由器功能的内核参数。
- en: 'This could be done on the command line as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过如下命令在命令行上完成：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, this is very manual, and it would be far too easy for someone to accidentally
    run the playbook without setting this variable, suddenly disabling the router.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这非常手动化，如果有人不小心在没有设置此变量的情况下运行了 playbook，可能会导致路由器被突然禁用。
- en: 'It would be far better to set this variable at the inventory level, thus ensuring
    that it is always set correctly whenever the playbook is run. Thus, we might create
    an inventory such as this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最好是在清单级别设置这个变量，从而确保每次运行 playbook 时它都能正确设置。因此，我们可以创建一个这样的清单：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With this inventory in place, running the playbook against the routers is performed
    using a command such as the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个清单就位后，使用如下命令来执行 playbook 并对路由器进行操作：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As long as this inventory file is used, there is no danger of someone forgetting
    to set the `rhel7cis_is_router` variable to `true`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 只要使用这个清单文件，就不会有人忘记将`rhel7cis_is_router`变量设置为`true`。
- en: Of course, this discussion does not mean that you must download and use these
    playbooks – it is still entirely possible to develop and maintain your own playbooks
    to your own requirements. Indeed, there may be situations in which this strategy
    is actually preferable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段讨论并不是说你必须下载并使用这些 playbooks——完全可以根据自己的需求开发和维护属于自己的 playbooks。实际上，在某些情况下，这种策略可能是更好的选择。
- en: 'What is important is that you choose the strategy that is best for your enterprise.
    When selecting your strategy for implementing security policy at scale, you should
    take the following into account:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，你要选择最适合你企业的策略。在选择大规模实施安全策略时，你应考虑以下因素：
- en: Whether you want to own your own code (with all the advantages and disadvantages
    that brings)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论你是否希望拥有自己的代码（以及由此带来的所有优缺点）
- en: Whether you want to be responsible for the maintenance of your code base going
    forward
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论你是否希望今后继续负责维护你的代码库
- en: That you should standardize on one code base as far as possible to ensure your
    code structure remains maintainable
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该尽可能地标准化一个代码库，以确保代码结构保持可维护
- en: Whether you need third-party support on implementing these benchmarks or whether
    you are happy that you have the skills and resources in-house
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论你是否需要第三方支持来实现这些基准，还是你自信自己拥有足够的技能和资源来内部完成
- en: Once you have made your evaluation, you will be well placed to define your path
    forward with creating Ansible playbooks to implement your chosen security standards.
    It is intended that the information provided to you in this chapter so far will
    be sufficient to support you in whichever path you choose. Although we have focused
    on EL7 (Red Hat Enterprise Linux 7 and CentOS 7) in this chapter, everything we
    have discussed will scale well to other operating systems for which there exist
    security benchmarks (for example, Ubuntu Server 18.04). In fact, if you run through
    the processes we have discussed within this chapter using the CIS Benchmark for
    Ubuntu Server 18.04, you will find a great deal of similarity can be achieved.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成评估，你将能够很好地定义前进的道路，通过创建 Ansible playbook 来实现你选择的安全标准。本章迄今为止提供的信息足以支持你选择任何路径。虽然本章重点讨论的是
    EL7（Red Hat Enterprise Linux 7 和 CentOS 7），但我们讨论的内容同样适用于其他有安全基准的操作系统（例如，Ubuntu
    Server 18.04）。实际上，如果你使用 Ubuntu Server 18.04 的 CIS 基准，按照本章讨论的流程操作，你会发现能够实现很大的相似性。
- en: So far, we have dealt almost exclusively with the implementation of CIS Benchmarks.
    This chapter would not be complete, however, without providing a method to check
    levels of enforcement without the need to make changes. After all, auditing is
    an important part of most enterprise policies, especially where security is concerned,
    yet changes must be made under an authorized change request window.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们几乎专注于实现 CIS 基准。然而，本章如果没有提供在不进行更改的情况下检查执行级别的方法，就不完整。毕竟，审计是大多数企业政策中重要的一部分，尤其是涉及安全时，而更改必须在授权的变更请求窗口内进行。
- en: Testing security policies with Ansible
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 测试安全策略
- en: As we have discussed so far, it is important to ensure that not only can you
    implement security policies in an efficient and repeatable manner, but that it
    should also be possible to audit them. There are a variety of tools available
    for this task, both closed source and open source. Before we consider any other
    tools, though, it is worthwhile looking at how Ansible itself can assist with
    this task.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所讨论的那样，确保不仅能够高效且可重复地实施安全政策，而且还应该能够进行审计，这一点非常重要。为此任务提供了多种工具，包括闭源和开源工具。在考虑其他工具之前，值得先看看
    Ansible 本身如何帮助完成这一任务。
- en: Let's return to one of our original examples, where we were implementing two
    of the recommendations from *section 5* of the CIS Benchmark.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到最初的一个例子，我们在其中实施了 CIS 基准 *第 5 节* 的两个建议。
- en: 'Previously, we ran this with the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用以下命令运行了这个：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This ran through the two checks, implementing the changes if the system was
    not already compliant with the security recommendations. However, Ansible also
    has a mode of operation called check mode. In this mode, Ansible does not make
    any changes to the remote system(s) – rather, it tries to predict all changes
    that might be made to the systems instead.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过了两个检查，如果系统未符合安全建议，它会实施相应的更改。然而，Ansible 还有一个叫做检查模式的操作模式。在此模式下，Ansible 不会对远程系统进行任何更改——而是尝试预测可能对系统进行的所有更改。
- en: Not all modules are compatible with check mode, and so some care is advised
    when using this mode. For example, Ansible cannot possibly know the output of
    running a particular shell command using the `shell` module, as there are so many
    possible permutations of commands. Also, running shell commands might be destructive
    or cause a change to the system, and so any tasks that use the `shell` module
    are skipped during a check run.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有模块都与检查模式兼容，因此在使用此模式时需要小心。例如，Ansible 无法预知运行特定 shell 命令时的输出，因为命令的组合可能有很多种。此外，运行
    shell 命令可能具有破坏性或导致系统发生变化，因此，在检查运行期间，任何使用 `shell` 模块的任务都会被跳过。
- en: However, many of the core modules we have already used, such as `yum`, `lineinfile`,
    and `sysctl`, do support check mode and so can be used quite effectively in this
    mode.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们已经使用过的许多核心模块，如 `yum`、`lineinfile` 和 `sysctl`，都支持检查模式，因此可以在此模式下有效使用。
- en: 'Thus, if we run our example playbook again, only this time in check mode, we
    would see an output similar to what''s shown in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们再次运行我们的示例 playbook，只是这次在检查模式下运行，我们将看到类似于以下屏幕截图的输出：
- en: '![](img/e6323e0e-a2a5-498b-ae66-4c90ee855323.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6323e0e-a2a5-498b-ae66-4c90ee855323.png)'
- en: You will notice that this looks exactly like any other playbook run – there
    are, in fact, no clues at all that it is running in check mode, other than the
    `-C` flag on the command line invoking this run. However, if you examine the target
    system, you will see that no changes were made.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，这看起来与其他任何剧本的运行完全相同——实际上，唯一表明它正在运行检查模式的线索是命令行中调用此运行的 `-C` 标志。然而，如果你检查目标系统，你会发现没有进行任何更改。
- en: The preceding output is very useful, though, for auditing processes – it demonstrates
    to us that the target system does not meet the recommendations for either *section
    5.2.8* or *5.2.9* of the benchmark – if these were met, then the result should
    have been `ok`. Equally, we know that the handler only fires in the event that
    changes are required on the remote system, and again this tells us that the system
    is not compliant in some way.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出对于审计过程非常有用——它向我们展示了目标系统不符合基准 *第 5.2.8 节* 或 *第 5.2.9 节* 的建议——如果这些建议已满足，结果应该是
    `ok`。同样，我们知道处理程序只在需要对远程系统进行更改时才会触发，再次表明该系统在某些方面不符合要求。
- en: It is accepted that some interpretation of the output is going to be required
    – however, by exercising good design practices in your roles when you write them
    (especially when putting the benchmark section number and title into the task
    names), then you can very quickly start to interpret the output and see which
    systems are not compliant, and further, which recommendations specifically they
    fail on.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 可以接受输出需要一定解释——然而，通过在编写角色时运用良好的设计实践（特别是在任务名称中加入基准章节号和标题），你可以非常迅速地开始解读输出，了解哪些系统不符合要求，进一步了解它们具体在哪些建议上没有达标。
- en: 'Further, the variable structure we put in place to determine which tasks are
    run and when still applies in check mode, so if we run this playbook on the legacy
    hosts that need remote root logins enabled (but this time in check mode), we can
    see that this task is skipped, ensuring that we don''t get false positives during
    an audit. The following screenshot shows this being run:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们设立的变量结构用来确定哪些任务在何时运行，仍然适用于检查模式，因此，如果我们在需要启用远程 root 登录的旧主机上运行此剧本（但这次在检查模式下），我们可以看到该任务被跳过，确保我们在审计过程中不会得到假阳性。以下截图显示了此操作：
- en: '![](img/aba6824e-590c-46b6-be73-2c9fde8772f9.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aba6824e-590c-46b6-be73-2c9fde8772f9.png)'
- en: In this manner (coupled with good playbook design), Ansible code can be reused
    not just for implementation purposes, but for auditing purposes too.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式（结合良好的剧本设计），Ansible 代码不仅可以用于实现目的，还可以用于审计目的。
- en: It is hoped that this chapter has given you sufficient knowledge to proceed
    with confidence when it comes to implementing security hardening on your Linux
    servers at enterprise scale, and even auditing them as part of an ongoing process.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 希望本章内容能为你提供足够的知识，使你在实施企业级 Linux 服务器安全加固时充满信心，甚至能够将其作为持续过程的一部分进行审计。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Ansible is an incredibly powerful tool that lends itself well to the implementation
    and auditing of security benchmarks such as the CIS security benchmark. We have
    demonstrated through practical example how it can reduce a shell script of nearly
    60 lines down to less than 20, and how the same code can be easily reused in a
    variety of scenarios, and even be used to audit security policies across the enterprise.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一个功能强大的工具，非常适合用于实施和审计安全基准，如 CIS 安全基准。我们通过实践示例展示了它如何将一个接近 60 行的 shell
    脚本简化为不到 20 行，并且如何将相同的代码轻松地在多种场景中复用，甚至可以用于在整个企业范围内审计安全政策。
- en: In this chapter, you learned how to write Ansible playbooks to apply server
    hardening benchmarks such as CIS. You then gained hands-on knowledge of applying
    server hardening policies across the enterprise using Ansible, and how to make
    use of publicly available open source roles to assist you in this. Finally, you
    learned about how Ansible supports testing and auditing of successful policy application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何编写 Ansible 剧本来应用服务器加固基准，如 CIS。然后你获得了在整个企业范围内使用 Ansible 应用服务器加固政策的实操知识，并了解了如何利用公开的开源角色来帮助你实现这一目标。最后，你了解了
    Ansible 如何支持测试和审计成功的政策应用。
- en: In the next chapter, we will look at an open source tool called **OpenSCAP**
    that can be used to perform effective auditing of security policies across the
    enterprise.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一个名为 **OpenSCAP** 的开源工具，它可以用于有效地审计整个企业范围内的安全政策。
- en: Questions
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do Ansible modules such as `lineinfile` make security benchmark implementation
    code more efficient than shell scripting?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像 `lineinfile` 这样的 Ansible 模块是如何让安全基准实现代码比 Shell 脚本更高效的？
- en: How can Ansible tasks be made conditional for a specific server or group of
    servers?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何为特定的服务器或服务器组设置条件性 Ansible 任务？
- en: What are good practices for naming your tasks when writing Ansible tasks to
    implement the CIS Benchmark?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写 Ansible 任务以实现 CIS 基准时，命名任务时有哪些最佳实践？
- en: How might you modify a playbook so that you can easily get the CIS level 1 benchmarks
    to run without any of the level 2 ones being evaluated?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何修改 playbook，使得你能够轻松运行 CIS 1 级基准，而不评估任何 2 级基准？
- en: What is the difference between the `--tags` and `--skip-tags` options when running
    an Ansible playbook?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Ansible playbook 时，`--tags` 和 `--skip-tags` 选项有什么区别？
- en: Why would you want to make use of publicly available open source code for your
    CIS Benchmark implementation?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你会想利用公开的开源代码来实现 CIS 基准？
- en: What does the `-C` flag do to a playbook run when used with the `ansible-playbook`
    command?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ansible-playbook` 命令时，`-C` 标志对 playbook 运行有什么影响？
- en: Does the `shell` module support check mode?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shell` 模块是否支持检查模式（check mode）？'
- en: Further reading
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To review common questions about the CIS Benchmarks, please refer to [https://www.cisecurity.org/cis-benchmarks/cis-benchmarks-faq/](https://www.cisecurity.org/cis-benchmarks/cis-benchmarks-faq/).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要查看关于 CIS 基准的常见问题，请参阅[https://www.cisecurity.org/cis-benchmarks/cis-benchmarks-faq/](https://www.cisecurity.org/cis-benchmarks/cis-benchmarks-faq/)。
- en: A full list of CIS Benchmarks is available at [https://www.cisecurity.org/cis-benchmarks/](https://www.cisecurity.org/cis-benchmarks/).
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CIS 基准的完整列表可以在[https://www.cisecurity.org/cis-benchmarks/](https://www.cisecurity.org/cis-benchmarks/)上查看。
- en: For an in-depth understanding of Ansible, please refer to *Mastering Ansible,
    Third Edition* by *James Freeman* and *Jesse Keating* ([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition)).
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要深入了解 Ansible，请参考 *James Freeman* 和 *Jesse Keating* 所著的《Mastering Ansible, Third
    Edition》([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition))。
