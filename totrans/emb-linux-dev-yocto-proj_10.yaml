- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging with the Yocto Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The debug process is an essential step in every development cycle. In this chapter,
    we will learn how to configure Poky to help us with the debugging process; for
    example, how we can configure our system to provide the tools needed for a remote
    debug using the `buildhistory`, and how we can use handy debug tools, such as
    `oe-pkgdata-util`, `bitbake-getvar`, and `devshell`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating metadata and application debugging
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we delve into the details of debugging, we need to realize that there
    are different types of debugging, such as metadata and runtime code debugging.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Metadata debugging is needed to ensure that the behavior of BitBake’s tasks
    aligns with our goals and to identify the culprit when it’s not aligned. For example,
    a recipe may need to be fixed to enable a feature. In such a case, we can use
    several log files generated by BitBake in the host to help trace the execution
    path of the involved task.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, debugging runtime code is more natural as it is essentially
    the same as the typical development cycle of an application, a library, or a kernel.
    Depending on the issue we are seeking to resolve, the right tool to help may vary
    from a debugger to code instrumentation (for example, adding debug prints).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Tracking image, package, and SDK contents
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to ensure we have the image, packages, and `buildhistory` mechanism.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: When a recipe is updated for a new version or has its code changed, it may influence
    the contents of the generated packages and, consequently, the image or SDK.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Poky deals with many recipes and images or SDKs frequently have tens or hundreds
    of packages. Therefore, it may be challenging to track the package contents. The
    Poky tool that helps in this task is `buildhistory`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '`buildhistory`, as the name suggests, keeps a history of the contents of several
    artifacts built during the use of Poky. It tracks package, image, and SDK building
    and their contents.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable `buildhistory` in our system, we need to add the following lines
    of code in our `build/conf/local.conf` file:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 10.1 – How to enable \uFEFFbuildhistory support](img/Figure_10.01_B19361.jpg)"
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – How to enable buildhistory support
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The `INHERIT` method includes the `buildhistory` class hooks in the building
    process. At the same time, the `BUILDHISTORY_COMMIT` line enables BitBake to create
    a new Git commit in the `buildhistory` repository for every new package, image,
    or SDK build. The Git commit makes tracking as simple as using `git diff` between
    two commits. The data is stored under the `build/buildhistory` directory as text
    files for ease of use.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Poky provides a utility that outputs the difference between two `buildhistory`
    states, called `buildhistory-diff`, in a more concise way, which is very useful
    when checking for changes. The `buildhistory-diff` utility outputs the difference
    between any two Git revisions more meaningfully.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we add the `strace` package in the `core-image-minimal`
    image and build it. In that case, the `buildhistory-diff` command can be used
    to check the resultant changes, as in the following screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The result of buildhistory-diff](img/Figure_10.02_B19361.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The result of buildhistory-diff
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: For every package build, `buildhistory` creates a list of generated sub-packages,
    installation scripts, a list of file ownership and sizes, the dependency relation,
    and more. In addition, the dependency relationship between the packages, filesystem
    files, and dependency graph is created for images and SDKs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the capabilities and features provided by `buildhistory`,
    refer to *Maintaining Build Output Quality in Yocto Project Development Tasks*
    *Manual* ([https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#maintaining-build-output-quality](https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#maintaining-build-output-quality)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Debugging packaging
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In more sophisticated recipes, we split the installed contents into several
    sub-packages. The sub-packages can be optional features, modules, or any other
    set of files that is optional to install.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: To inspect how the recipe’s content has been split, we can use the `build/tmp/work/<arch>/<recipe
    name>/<software version>/packages-split` directory. It contains a sub-directory
    for every sub-package and has its contents in the sub-tree.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the possible reasons for a mistaken content split, we have defined the
    following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The contents not being installed (for example, an error in installation scripts)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application or library configuration error (for example, a disabled feature)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata errors (for example, the wrong package order)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another common issue for build failure is lacking the required artifacts in
    the `sysroot` directory (for example, headers or dynamic libraries). The counterpart
    of the `sysroot` generation can be seen at `build/tmp/work/<arch>/<recipe_name>/<software_version>/sysroot-destdir`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: If this is not enough, we can instrument the task code with these logging functions
    to determine the logical error or bug that has caused the unexpected result.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting packages
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A central aspect of the Yocto Project is dealing with the packages. Therefore,
    the project has designed `oe-pkgdata-util` to help us to inspect the built packages
    and related data. For example, after running `bitbake bluez5`, we can use the
    following command to find all the packages related to `bluez`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Listing all the available packages and filtering those related
    with bluez](img/Figure_10.03_B19361.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Listing all the available packages and filtering those related
    with bluez
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we need to find the package that includes this specific file. We
    can inquire about the packages database using the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Finding which package provides /usr/bin/rfcomm](img/Figure_10.04_B19361.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Finding which package provides /usr/bin/rfcomm
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use case is when we need to find out the current version of a package.
    This can be done with the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Listing the package info for bluez5](img/Figure_10.05_B19361.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Listing the package info for bluez5
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also list all the files for the given package using the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Listing the files from the bluez5 package](img/Figure_10.06_B19361.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Listing the files from the bluez5 package
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The `oe-pkgdata-util` script is a handy tool to help us debug packaging.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Logging information during task execution
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The logging utilities provided by BitBake are handy for tracing the code execution
    path. BitBake provides logging functions for use in Python and Shell Script code,
    described as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '`bb.fatal`, `bb.error`, `bb.warn`, `bb.note`, `bb.plain`, and `bb.debug`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bbfatal`, `bberror`, `bbwarn`, `bbnote`, `bbplain`, and `bbdebug`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These logging functions are very similar to each other but have minor differences,
    described as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '`bb.fatal` and `bbfatal`: These have the highest priority for logging messages
    as they print the message and terminate the processing. They cause the build to
    be interrupted.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb.error` and `bberror`: These display an error but do not force the build
    to stop.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb.warn` and `bbwarn`: These warn the users about something.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb.note` and `bbnote`: These add a note to the user. They are only informative.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb.plain` and `bbplain`: These output a message.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb.debug` and `bbdebug`: These add debugging information that is shown depending
    on the debug level used.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is one subtle difference between using the logging functions in Python
    and Shell Script. The logging functions in Python are directly handled by BitBake,
    seen on the console, and stored in the execution log inside `build/tmp/log/cooker/<machine>`.
    When the logging functions are used in Shell Script, the information is outputted
    to an individual task log file, which is available in `build/tmp/work/<arch>/<recipe`
    `name>/<software version>/temp`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Inside the temp directory, we can inspect the scripts for every task with the
    `run.<task>.<pid>` pattern and use the `log.<task>.<pid>` pattern for its output.
    Symbolic links point to the last log files using the `log.<task>` pattern. For
    example, we can check for `log.do_compile` to verify whether the right files were
    used during the build process.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The `build/tmp/work` directory is detailed in [*Chapter 6*](B19361_06.xhtml#_idTextAnchor089),
    *Detailing the Temporary* *Build Directory*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Debugging metadata variables
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To debug the metadata variables, we can use the `bitbake-getvar` script. It
    uses the BitBake internal data to get a specific variable value and its attribution
    history.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to inspect the `PACKAGECONFIG` variable for the `procps` recipe,
    we can use the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – The result of bitbake-getvar -r procps PACKAGECONFIG](img/Figure_10.07_B19361.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – bitbake-getvar -r procps PACKAGECONFIG 的结果](img/Figure_10.07_B19361.jpg)'
- en: Figure 10.7 – The result of bitbake-getvar -r procps PACKAGECONFIG
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – bitbake-getvar -r procps PACKAGECONFIG 的结果
- en: From *Figure 10**.7*, we can see that `PACKAGECONFIG` at the end is empty. We
    can also see that `defaultval` was set to `"${@bb.utils.filter('DISTRO_FEATURES',
    'systemd', d)}"` at line 33 from the `meta/recipes-extended/procps/procps_3.3.17.bb`
    file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *图 10.7* 中，我们可以看到 `PACKAGECONFIG` 在末尾是空的。我们还可以看到 `defaultval` 在 `meta/recipes-extended/procps/procps_3.3.17.bb`
    文件的第 33 行被设置为 `"${@bb.utils.filter('DISTRO_FEATURES', 'systemd', d)}"`。
- en: 'We can see the `procps` recipe lines 33 and 34 in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下截图中看到 `procps` 食谱的第 33 行和第 34 行：
- en: '![Figure 10.8 - The procps recipe 33 and 34 lines](img/Figure_10.08_B19361.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 - procps 食谱的第 33 行和第 34 行](img/Figure_10.08_B19361.jpg)'
- en: Figure 10.8 - The procps recipe 33 and 34 lines
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 - procps 食谱的第 33 行和第 34 行
- en: The `bitbake-getvar` script can be used to check whether a feature is enabled
    or to be sure a variable has been expanded as we expect.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`bitbake-getvar` 脚本可以用来检查某个特性是否启用，或者确保某个变量已按预期展开。'
- en: Utilizing a development shell
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用开发 shell
- en: 'A development shell can be a helpful tool when editing packages or debugging
    build failures. The following steps take place when we use `devshell`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 开发 shell 在编辑软件包或调试构建失败时是一个有用的工具。使用 `devshell` 时会执行以下步骤：
- en: Source files are extracted into the working directory.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源文件被提取到工作目录中。
- en: Patches are applied.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 补丁已应用。
- en: A new terminal is opened in the working directory.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工作目录中打开了一个新的终端。
- en: All the environment variables needed for the build are available in the new
    terminal, so we can use commands such as `configure` and `make`. The commands
    execute just as if the build system were running them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有构建所需的环境变量都可以在新终端中使用，因此我们可以使用 `configure` 和 `make` 等命令。这些命令的执行方式就像构建系统正在运行它们一样。
- en: 'The following command is an example that uses `devshell` on a target named
    `linux-yocto`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令是一个示例，使用 `devshell` 在名为 `linux-yocto` 的目标上：
- en: '![Figure 10.9 – Running devshell for the linux-yocto recipe](img/Figure_10.09_B19361.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 运行 devshell 为 linux-yocto 食谱](img/Figure_10.09_B19361.jpg)'
- en: Figure 10.9 – Running devshell for the linux-yocto recipe
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 运行 linux-yocto 食谱的 devshell
- en: 'The command from *Figure 10**.9* allows us to rework the Linux kernel source
    code, build it, and change its code as needed. In *Figure 10**.10*, you can see
    the log after executing the `bitbake linux-yocto -c` `devshell` command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 *图 10.9* 的命令使我们能够重新处理 Linux 内核源代码、构建它，并根据需要修改其代码。在 *图 10.10* 中，您可以看到执行 `bitbake
    linux-yocto -c devshell` 命令后的日志：
- en: '![Figure 10.10 – The log for bitbake linux-yocto -c devshell](img/Figure_10.10_B19361.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – bitbake linux-yocto -c devshell 的日志](img/Figure_10.10_B19361.jpg)'
- en: Figure 10.10 – The log for bitbake linux-yocto -c devshell
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – bitbake linux-yocto -c devshell 的日志
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is crucial to remember that changes made inside `devshell` do not persist
    between builds; thus, we must be careful to record any critical change before
    leaving it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特别注意的是，`devshell` 内部所做的更改在不同的构建之间不会持久化；因此，我们必须在离开时记录任何重要的更改。
- en: Since we have the source at our disposal, we can use it to generate extra patches.
    A convenient way of doing that is using Git and `git format-patch` to create the
    patch to be included in the recipe afterward.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有源代码可用，可以使用它生成额外的补丁。一个方便的方法是使用 Git 和 `git format-patch` 创建补丁，然后将其包含到食谱中。
- en: 'The following screenshot shows the `devshell` window open after calling the
    `devshell` task:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在调用 `devshell` 任务后打开的 `devshell` 窗口：
- en: '![Figure 10.11 – The list of files inside the WORKDIR directory](img/Figure_10.11_B19361.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – WORKDIR 目录中的文件列表](img/Figure_10.11_B19361.jpg)'
- en: Figure 10.11 – The list of files inside the WORKDIR directory
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – WORKDIR 目录中的文件列表
- en: The `devshell` command is convenient for small tasks. But when a more involved
    change is needed, using an external toolchain or `devtool` might be a better option.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`devshell` 命令适合处理小任务。但当需要进行更复杂的修改时，使用外部工具链或 `devtool` 可能是更好的选择。'
- en: To include the generated patch in the recipe and make it persistent, see [*Chapter
    13*](B19361_13.xhtml#_idTextAnchor158), *Customizing* *Existing Recipes*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要将生成的补丁包含到食谱中并使其持久化，请参见 [*第 13 章*](B19361_13.xhtml#_idTextAnchor158)，*自定义* *现有食谱*。
- en: Using the GNU Debugger for debugging
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GNU 调试器进行调试
- en: While developing any project, from time to time, we end up struggling to understand
    subtle bugs. The GDB is available as a package in Poky. It is installed in SDK
    images by default, as was detailed in [*Chapter 9*](B19361_09.xhtml#_idTextAnchor115),
    *Developing with the* *Yocto Project*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发任何项目时，我们时常会遇到难以理解的微妙错误。GDB作为一个包包含在Poky中。它默认安装在SDK镜像中，正如在[*第9章*](B19361_09.xhtml#_idTextAnchor115)中详细介绍的那样，*使用Yocto项目进行开发*。
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To install debugging packages containing the debug symbols and tools in an image,
    add `IMAGE_FEATURES += "dbg-pkgs tools-debug"` in `build/conf/local.conf`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要在镜像中安装包含调试符号和工具的调试包，请在`build/conf/local.conf`中添加`IMAGE_FEATURES += "dbg-pkgs
    tools-debug"`。
- en: Using the SDK or an image with the debugging packages and tools installed allows
    us to debug applications directly in the target, replicating the same development
    workflow we usually do on our machine.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SDK或包含调试包和工具的镜像，可以直接在目标设备上调试应用程序，复制我们通常在机器上进行的相同开发工作流程。
- en: The GDB may not be usable on some targets because of memory or disk space constraints.
    The main reason for this limitation is that the GDB needs to load the debugging
    information and the binaries of the debugging process before starting the debugging
    process.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内存或磁盘空间限制，GDB可能无法在某些目标设备上使用。此限制的主要原因是GDB需要在开始调试之前加载调试信息和调试过程的二进制文件。
- en: To overcome these constraints, we can use `gdbserver`, included by default when
    using `tools-debug` in `IMAGE_FEATURES`. It runs on the target and doesn’t load
    any debugging information from the debugged process. Instead, a GDB instance processes
    the debugging information on the build host. The host GDB sends control commands
    to `gdbserver` to control the debugged application, so the target does not need
    to have the debugging symbols installed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些限制，我们可以使用`gdbserver`，它在使用`tools-debug`时默认包含在`IMAGE_FEATURES`中。它在目标设备上运行，不会从被调试进程加载任何调试信息。相反，GDB实例会在构建主机上处理调试信息。主机GDB向`gdbserver`发送控制命令，以控制被调试的应用程序，因此目标设备不需要安装调试符号。
- en: However, we must ensure the host can access the binaries with their debugging
    information. Therefore, it is recommended that the target binaries are compiled
    with no optimization to facilitate the debugging process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须确保主机能够访问包含调试信息的二进制文件。因此，建议目标设备的二进制文件在没有优化的情况下编译，以便于调试过程。
- en: The process for using `gdbserver` and adequately configuring the host and target
    is detailed in the *Debugging With the GNU Project Debugger (GDB) Remotely section
    in Yocto Project Development Tasks* *Manual* ([https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#debugging-with-the-gnu-project-debugger-gdb-remotely](https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#debugging-with-the-gnu-project-debugger-gdb-remotely)).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gdbserver`并正确配置主机和目标的过程详细介绍了在Yocto项目开发任务手册中的*远程调试GNU项目调试器(GDB)部分*（[https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#debugging-with-the-gnu-project-debugger-gdb-remotely](https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#debugging-with-the-gnu-project-debugger-gdb-remotely)）。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to configure Poky to help us with the debugging
    process. We learned about the contents of deployed directories that can be used
    for debugging and how we can track our changes using `buildhistory`. We also covered
    the use of `oe-pkgdata-util` to inspect package information, use `bitbake-getvar`
    to debug variable expansion, how we can use `devshell` to emulate the same build
    environment found by BitBake, and how we configure our system to provide the tools
    needed for GDB debugging.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们学习了如何配置Poky来帮助我们进行调试过程。我们了解了可用于调试的部署目录内容，并且学习了如何使用`buildhistory`跟踪我们的更改。我们还介绍了如何使用`oe-pkgdata-util`查看包信息，使用`bitbake-getvar`调试变量展开，如何使用`devshell`模拟BitBake找到的相同构建环境，以及如何配置系统以提供进行GDB调试所需的工具。
- en: In the next chapter, we will learn how to expand the Poky source code using
    external layers. First, we will introduce the concept of layering. Then, we will
    learn in detail about the directory structure and the content of each layer type.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用外部层扩展Poky源代码。首先，我们将介绍层次结构的概念。接下来，我们将详细学习每种层类型的目录结构和内容。
