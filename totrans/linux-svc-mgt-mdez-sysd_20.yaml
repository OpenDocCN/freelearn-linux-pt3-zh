- en: '*Chapter 17*: Understanding systemd and Bootloaders'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第17章*：理解 systemd 和引导加载程序'
- en: A bootloader is necessary for any operating system, including Linux. In this
    chapter, we'll look at the GRUB2 and systemd-boot bootloaders, and we'll discuss
    the differences between them. Becoming familiar with the material in this chapter
    can help you choose which bootloader is best suited for your needs, and to troubleshoot
    things that might go wrong.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序对任何操作系统都是必需的，包括 Linux。在本章中，我们将讨论 GRUB2 和 systemd-boot 引导加载程序，并讨论它们之间的区别。熟悉本章内容可以帮助你选择最适合自己需求的引导加载程序，并解决可能出现的问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding the basic computer architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基本的计算机架构
- en: Understanding GRUB2
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 GRUB2
- en: Understanding systemd-boot
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 systemd-boot
- en: Understanding Secure Boot
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解安全启动
- en: Note that there are several different bootloaders in use, some of which are
    specific to embedded and IoT devices. In this chapter, we'll only concentrate
    on GRUB2 and systemd-boot, which are used on servers and normal workstations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目前使用的引导加载程序有多个，其中一些是特定于嵌入式和物联网设备的。本章我们只会集中讨论 GRUB2 和 systemd-boot，它们用于服务器和普通工作站。
- en: Now, let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We'll start with the same Ubuntu Server and Alma virtual machines that we have
    been using throughout. We'll use these to look at a normal BIOS-based GRUB2 configuration.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一直使用的 Ubuntu Server 和 Alma 虚拟机开始。我们将用它们来看一个基于 BIOS 的普通 GRUB2 配置。
- en: 'To see how the GRUB2 bootloader works on an EFI-based machine, you''ll need
    to create another pair of Alma and Ubuntu Server virtual machines with the EFI
    feature enabled. To do that, create the initial VirtualBox setup for the Alma
    and Ubuntu machines as you always do. Then, before you start up the machines to
    install the operating system, open the **Settings** dialog box. Under the **System**
    menu, click the **Enable EFI** checkbox, as shown here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 GRUB2 引导加载程序如何在基于 EFI 的机器上工作，你需要创建一对启用了 EFI 功能的 Alma 和 Ubuntu Server 虚拟机。为此，像平常一样创建
    Alma 和 Ubuntu 虚拟机的初始 VirtualBox 设置。然后，在启动机器并安装操作系统之前，打开 **设置** 对话框。在 **系统** 菜单下，勾选
    **启用 EFI** 复选框，如下所示：
- en: '![](img/Figure_17.1_B17491.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_17.1_B17491.jpg)'
- en: Figure 17.1 – Checking the Enable EFI box
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1 – 勾选启用 EFI 框
- en: Then, install the operating system as you normally would.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像平常一样安装操作系统。
- en: To look at a systemd-boot environment, you'll need to create a virtual machine
    with Pop!_OS Linux. Enable the EFI feature as you did for the Alma and Ubuntu
    machines, and install the operating system as you normally would.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 systemd-boot 环境，你需要创建一个安装了 Pop!_OS Linux 的虚拟机。像为 Alma 和 Ubuntu 虚拟机一样启用 EFI
    功能，并像平常一样安装操作系统。
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Pop!_OS Linux is built from Ubuntu source code by the System76 computer vendor.
    Pop!_OS is the only Linux distro I know of that uses systemd-boot by default.
    You can set up Clear Linux and Arch Linux with either GRUB2 or systemd-boot, but
    installing either of them involves more complexity than we want to deal with now.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Pop!_OS Linux 是由计算机厂商 System76 基于 Ubuntu 源代码构建的。Pop!_OS 是我知道的唯一一款默认使用 systemd-boot
    的 Linux 发行版。你可以使用 GRUB2 或 systemd-boot 安装 Clear Linux 和 Arch Linux，但安装它们比我们现在要处理的要复杂得多。
- en: 'You can download Pop!_OS from here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这里下载 Pop!_OS：
- en: '[https://pop.system76.com/](https://pop.system76.com/)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://pop.system76.com/](https://pop.system76.com/)'
- en: Now that you have your virtual machines, let's briefly define a few terms that
    we need to know about.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了虚拟机，让我们简要定义一下我们需要了解的几个术语。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3pkVA8D](https://bit.ly/3pkVA8D)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接，观看《代码实战》视频：[https://bit.ly/3pkVA8D](https://bit.ly/3pkVA8D)
- en: Understanding the basic computer architecture
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基本的计算机架构
- en: 'Before we can talk about bootloaders, we need to define a few terms that describe
    the basic computer architecture:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论引导加载程序之前，我们需要定义一些描述基本计算机架构的术语：
- en: '`init` system.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init` 系统。'
- en: '**Boot manager**: When you first power on your computer, a boot manager will
    present you with a boot menu. If you have multiple operating systems installed,
    the boot manager will allow you to choose which one to boot. If a Linux distro
    has multiple kernels installed, the boot manager will allow you to choose which
    kernel to boot.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引导管理器**：当你第一次开启计算机时，引导管理器会显示一个引导菜单。如果你安装了多个操作系统，引导管理器会让你选择启动哪个系统。如果一个 Linux
    发行版安装了多个内核，引导管理器也会让你选择启动哪个内核。'
- en: '**BIOS**: The **Basic Input/Output System** (**BIOS**) is firmware that resides
    in a chip on a computer motherboard. It contains the basic instructions that start
    up a computer. After the computer is started, the BIOS will perform a **Power-on
    Self Test** (**POST**) to verify that the hardware is working properly. Then,
    the BIOS will start the bootloader. It worked well for its time but is now outdated.
    One problem is that it can''t deal with drives of more than two terabytes in size.
    I mean, if you were to install a three-Terabyte drive in a BIOS-based machine,
    you''d be able to use the drive, but one Terabyte of drive space would go to waste.
    BIOS also can''t deal with the Secure Boot feature.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BIOS**：**基本输入输出系统**（**BIOS**）是位于计算机主板上的固件。它包含了启动计算机的基本指令。计算机启动后，BIOS 将执行**上电自检**（**POST**），以验证硬件是否正常工作。然后，BIOS
    会启动启动加载器。它在当时表现良好，但现在已经过时。一个问题是它无法处理大于两 TB 的硬盘。如果你在一台 BIOS 基础的机器上安装了三 TB 的硬盘，虽然可以使用这个硬盘，但其中一个
    TB 的空间会浪费掉。BIOS 也无法处理安全启动功能。'
- en: '**EFI/UEFI**: This was originally called the **Extensible Firmware Interface**
    (**EFI**), but the name was changed to **Unified Extensible Firmware Interface**
    (**UEFI**) for the Version 2 variant. It has replaced BIOS on newer computers.
    Unlike BIOS, EFI/UEFI works very well with very large drives. It also works with
    the Secure Boot feature.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EFI/UEFI**：最初称为**可扩展固件接口**（**EFI**），但在版本 2 变体中名称被更改为**统一可扩展固件接口**（**UEFI**）。它已经取代了较新的计算机上的
    BIOS。与 BIOS 不同，EFI/UEFI 在处理非常大的硬盘时表现良好。它还与安全启动功能兼容。'
- en: '**MBR**: There are two general categories of partition types. The **Master
    Boot Record** (**MBR**) type is the older type. Its main flaw is that it doesn''t
    work with partitions that are larger than two terabytes. Even if you have an EFI/UEFI-based
    machine that can work with large drives, MBR still limits you to these smaller
    partitions. What''s a bit confusing is that the term *MBR* also refers to the
    first 512-byte sector of a drive, which is where the bootloader gets installed
    on BIOS-based machines.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MBR**：分区类型大致分为两类。**主引导记录**（**MBR**）类型是较旧的类型。它的主要缺陷是无法处理大于两 TB 的分区。即使你有一台基于
    EFI/UEFI 的机器，可以支持大硬盘，MBR 仍然将你限制在较小的分区中。有点令人困惑的是，*MBR* 这个术语也指代硬盘的第一个 512 字节扇区，这里是
    BIOS 基础机器上安装启动加载器的地方。'
- en: '**GPT**: The **GUID Partition Table** (**GPT**) type of partition has replaced
    the old MBR type. It works well with partitions that are larger than two Terabytes.
    (The exact maximum partition size depends on which filesystem you''ve used to
    format the partition.) On EFI/UEFI machines, you need to install the bootloaders
    in a GPT partition instead of in an MBR. (I''ll explain why I''ve said *bootloaders*
    instead of *bootloader* later.)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPT**：**GUID 分区表**（**GPT**）类型的分区已取代旧的 MBR 类型。它在处理大于两 TB 的分区时表现良好。（确切的最大分区大小取决于你用于格式化分区的文件系统。）在
    EFI/UEFI 机器上，你需要将启动加载器安装在 GPT 分区中，而不是 MBR 中。（稍后我会解释为什么我使用*启动加载器*而不是*启动加载程序*。）'
- en: '**GRUB2**: The **Grand Unified Bootloader Version 2** (**GRUB2**) is currently
    the most popular bootloader on laptops, desktops, and servers. It works well on
    machines with multiple installed operating systems. It''s not part of the systemd
    ecosystem, but it can be used on systemd machines.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GRUB2**：**GRUB2**（**Grand Unified Bootloader Version 2**）目前是笔记本、台式机和服务器上最流行的启动加载器。它在安装了多个操作系统的机器上表现良好。它不是
    systemd 生态系统的一部分，但可以在 systemd 机器上使用。'
- en: '**systemd-boot**: This bootloader is part of the systemd ecosystem. It isn''t
    widely used just yet, but it could be someday. It''s lighter-weight and simpler
    to configure than GRUB2, and it also works well for machines with multiple operating
    systems installed.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**systemd-boot**：这个启动加载器是 systemd 生态系统的一部分。它目前还不被广泛使用，但未来有可能会变得流行。它比 GRUB2
    更轻量级，配置更简单，也非常适合安装了多个操作系统的机器。'
- en: Okay, now that we have the terminology nailed down, let's look at GRUB2.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经弄清楚了术语，接下来看看 GRUB2。
- en: Understanding GRUB2
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 GRUB2
- en: The original GRUB, which is now referred to as *GRUB Legacy*, first came on
    the scene in 1995 as a replacement for the old LILO bootloader. It was easy to
    work with because it was easy to configure and it was implemented consistently
    on all Linux distros that used it. Unlike LILO, it can boot non-Linux operating
    systems. So, you can install Windows and Linux on the same computer, and GRUB
    lets you choose which one to boot up. GRUB Legacy worked well on the old BIOS-based
    computers, but it doesn't work with the newer EFI/UEFI computers. (Well, actually,
    the Fedora team did create a forked version of GRUB Legacy that would work with
    EFI/UEFI, but they abandoned it in favor of GRUB2 in 2013.)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 GRUB，现在被称为 *GRUB Legacy*，首次出现在 1995 年，作为替代旧的 LILO 启动加载程序。它易于使用，因为它配置简单，并且在所有使用它的
    Linux 发行版中实现方式一致。与 LILO 不同，它可以启动非 Linux 操作系统。所以，你可以在同一台计算机上安装 Windows 和 Linux，GRUB
    让你选择启动哪个系统。GRUB Legacy 在旧的基于BIOS的计算机上运行良好，但在新的 EFI/UEFI 计算机上无法使用。（实际上，Fedora 团队确实创建了一个可以与
    EFI/UEFI 一起使用的 GRUB Legacy 分支版本，但他们在 2013 年放弃了这个版本，转而使用 GRUB2。）
- en: GRUB2 isn't an update of GRUB Legacy. Instead, it's a whole new bootloader that
    was created from scratch. Now, I have to tell you that there are both good things
    and bad things about it. The good thing is that it can work with the new EFI/UEFI
    computers. The bad things are that it's a lot more complicated to configure, and
    different Linux distros implement it differently. So, things can get a bit confusing
    when you have to work with multiple distros.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB2 不是 GRUB Legacy 的更新版本。相反，它是一个全新的启动加载程序，从头开始创建。现在，我得告诉你，它有优点也有缺点。优点是它可以与新的
    EFI/UEFI 计算机一起工作。缺点是它的配置要复杂得多，而且不同的 Linux 发行版实现方式不同。因此，当你需要处理多个发行版时，可能会感到有些困惑。
- en: Almost all Linux distros, including the Ubuntu and Alma distros that we've been
    using, use GRUB2\. On a BIOS-based machine, GRUB2 gets installed into the primary
    drive's MBR, which is the first 512-byte sector of the drive. On an EFI/UEFI machine,
    GRUB2 gets installed into a special EFI partition, which always has to be a GPT-type
    partition. (This special partition is referred to as the **EFI System Partition**
    or **ESP**.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有 Linux 发行版，包括我们一直在使用的 Ubuntu 和 Alma 发行版，都使用 GRUB2。在基于BIOS的机器上，GRUB2 被安装到主驱动器的
    MBR 中，即驱动器的前 512 字节扇区。在 EFI/UEFI 机器上，GRUB2 被安装到一个特殊的 EFI 分区中，该分区必须是 GPT 类型的分区。（这个特殊的分区被称为
    **EFI 系统分区** 或 **ESP**。）
- en: Now, here's where things get a bit confusing. As I said, unlike GRUB Legacy,
    GRUB2 isn't implemented in the same way across all Linux distros, as we'll see
    in a bit. To see how this all works, let's begin by comparing the GRUB2 setup
    on our BIOS-based and EFI/UEFI-based AlmaLinux virtual machines.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，事情变得有些复杂。正如我所说的，与 GRUB Legacy 不同，GRUB2 在不同的 Linux 发行版中并不是以相同的方式实现的，稍后我们会看到。为了了解这一切是如何工作的，我们先从比较在基于BIOS和EFI/UEFI的
    AlmaLinux 虚拟机上的 GRUB2 设置开始。
- en: Comparing GRUB2 on BIOS and EFI/UEFI systems
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较基于 BIOS 和 EFI/UEFI 系统的 GRUB2
- en: On both BIOS-based and EFI/UEFI-based machines, the Linux kernel and the `initramfs`
    files get installed in the `/boot` partition. But this is where the similarities
    end. Let's see how it's done with BIOS.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于BIOS和EFI/UEFI的机器上，Linux 内核和 `initramfs` 文件被安装到 `/boot` 分区。但这里是相似之处的终点。我们来看一下在
    BIOS 上是如何做的。
- en: GRUB2 on a BIOS-based Alma 8 machine
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于BIOS的 Alma 8 机器上的 GRUB2
- en: 'On a BIOS-based machine, the `/boot` partition is normally `/dev/sda1`, as
    we see here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于BIOS的机器上，`/boot` 分区通常是 `/dev/sda1`，如我们所见：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We also see that the `/boot` partition is formatted with just a normal Linux
    filesystem. On RHEL-type machines, this would normally be `xfs`. On Ubuntu machines,
    this would normally be `ext4`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到 `/boot` 分区仅使用普通的 Linux 文件系统格式化。在 RHEL 类型的机器上，这通常是 `xfs`。在 Ubuntu 机器上，这通常是
    `ext4`。
- en: 'The Master Boot Record, where the bootloader is installed, isn''t a partition.
    Rather, the MBR is just the first 512 bytes of the drive. The GRUB2 configuration
    file (`grub2.cfg`) is in the `/boot/grub2/` directory. On RHEL-type machines,
    the `/etc/grub.cfg` symbolic link points to the actual configuration file, as
    we see here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 主引导记录（MBR），即启动加载程序安装的位置，并不是一个分区。相反，MBR 只是驱动器的前 512 字节。GRUB2 配置文件（`grub2.cfg`）位于
    `/boot/grub2/` 目录下。在 RHEL 类型的机器上，`/etc/grub.cfg` 的符号链接指向实际的配置文件，如我们所见：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Understand though, that if you ever need to reconfigure GRUB2, you''ll never
    edit this `grub.cfg` file. Instead, you''ll edit the `/etc/default/grub` file.
    Then, you''ll rebuild the `grub.cfg` file by doing:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但请理解，如果你需要重新配置 GRUB2，你永远不会编辑这个 `grub.cfg` 文件。相反，你需要编辑 `/etc/default/grub` 文件。然后，你可以通过以下命令重新构建
    `grub.cfg` 文件：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is an `efi/` directory within the `/boot/` directory, but it isn''t used.
    It contains a nest of subdirectories, but there are no files, as we see here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/boot/` 目录下有一个 `efi/` 目录，但它并未被使用。它包含一些子目录，但没有文件，如下所示：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Whenever we boot the machine, we see a boot menu with our different boot-up
    choices:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们启动机器时，都会看到一个包含不同引导选项的引导菜单：
- en: '![](img/Figure_17.2_B17491.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_17.2_B17491.jpg)'
- en: Figure 17.2 – The GRUB2 boot menu on AlmaLinux
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2 – AlmaLinux上的GRUB2引导菜单
- en: 'The configuration files for these menu choices are in the `/boot/loader/entries/`
    directory. This directory requires root privileges to enter. So, let''s make things
    easier on ourselves by going to the `root` shell:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些菜单选项的配置文件位于 `/boot/loader/entries/` 目录下。该目录需要 root 权限才能进入。因此，为了简化操作，我们先进入
    `root` shell：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let''s see what we have:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们有什么：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These configuration files are known as `BootLoaderSpec` (`BLS`) files. Whenever
    you boot your machine, GRUB2 will take information from these `BLS` files and
    use it to populate the boot menu. A new `BLS` file will be generated automatically
    every time a new Linux kernel is installed, even if it''s a kernel that you''ve
    compiled yourself. If you do a system update and `dnf` removes any older kernels,
    the `BLS` files for those older kernels will be deleted. Let''s peek inside one
    of these files to see what''s there:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置文件被称为 `BootLoaderSpec` (`BLS`) 文件。每当你启动机器时，GRUB2 会从这些 `BLS` 文件中获取信息，并用它来填充引导菜单。每次安装新的
    Linux 内核时，都会自动生成一个新的 `BLS` 文件，即使是你自己编译的内核也是如此。如果你进行系统更新并且 `dnf` 删除了任何较旧的内核，那么那些较旧内核的
    `BLS` 文件也会被删除。让我们看一下其中一个文件，看看里面有什么内容：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we see here, this file defines which kernel and `initramfs` images to load,
    along with the various kernel options. But we don't see specific kernel options
    here. Instead, we see variable names preceded by a `$`. This just means that the
    kernel option information will be pulled in from the `/boot/grub2/grub.cfg` file
    and the `/boot/grub2/grubenv` file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，这个文件定义了要加载的内核和 `initramfs` 镜像，以及各种内核选项。但我们没有看到具体的内核选项。相反，我们看到的是以 `$`
    为前缀的变量名。这意味着内核选项信息将从 `/boot/grub2/grub.cfg` 文件和 `/boot/grub2/grubenv` 文件中获取。
- en: If you install Linux alongside an already existing installation of another operating
    system, the boot menu entry for that operating system should also be created automatically.
    (This works even if the other operating system is Windows.) The `/etc/grub.d/30_os-prober`
    script is what finds the other operating systems for you.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在已经安装了其他操作系统的计算机上安装 Linux，那么该操作系统的引导菜单项也应该会自动创建。（即使另一个操作系统是 Windows，这也有效。）`/etc/grub.d/30_os-prober`
    脚本是用来为你找到其他操作系统的。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is different from what you might be used to. Older Linux distros, such
    as the RHEL 7-type distros, don't use `BLS` files. Instead, all boot menu information
    is listed in the `grub.cfg` file. Red Hat first introduced `BLS` files in Fedora
    30, and they're now used in all RHEL 8-type distros. (As we'll see later, even
    the newest Ubuntu distros still don't use them.)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这与你可能习惯的情况不同。旧版 Linux 发行版，如 RHEL 7 系列的发行版，不使用 `BLS` 文件。相反，所有的引导菜单信息都列在 `grub.cfg`
    文件中。Red Hat 在 Fedora 30 中首次引入了 `BLS` 文件，现在所有 RHEL 8 系列的发行版都使用它们。（正如我们稍后将看到的，即使是最新的
    Ubuntu 发行版仍然没有使用它们。）
- en: Now, let's look at an EFI/UEFI machine.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下EFI/UEFI机器。
- en: GRUB2 on an EFI/UEFI-based Alma machine
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在基于EFI/UEFI的 Alma 机器上的 GRUB2
- en: 'On our EFI/UEFI machine, the `/boot/` partition is mounted on `/dev/sda2`,
    while the `/boot/efi/` partition is mounted on `/dev/sda1`, as we see here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 EFI/UEFI 机器上，`/boot/` 分区挂载在 `/dev/sda2`，而 `/boot/efi/` 分区挂载在 `/dev/sda1`，如图所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `/boot/efi/` partition is where the bootloaders reside. We can also see
    that the normal boot partition is formatted with the normal `xfs` Linux filesystem,
    but that the `/boot/efi/` partition is formatted with the `vfat` filesystem. The
    `efi` partition must always be formatted with `vfat` because nothing else works.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`/boot/efi/` 分区是引导加载程序所在的位置。我们还可以看到，正常的引导分区使用的是常规的 `xfs` Linux 文件系统格式化，但 `/boot/efi/`
    分区是使用 `vfat` 文件系统格式化的。`efi` 分区必须始终使用 `vfat` 格式化，因为其他格式无法正常工作。'
- en: 'Next, we see that the symbolic link in the `/etc/` directory has a different
    name and that it points to the `grub.cfg` file in a different location:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到 `/etc/` 目录中的符号链接有一个不同的名称，并且指向一个不同位置的 `grub.cfg` 文件：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As before, the directories that we want to explore require root privileges
    to enter. Let''s make things a bit easier by going to a `root` shell:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所说，我们想要查看的目录需要 root 权限才能进入。为了简化操作，我们先进入 `root` shell：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There''s still a `/boot/grub2/` directory, but the only thing it contains is
    a symbolic link that points to the GRUB environmental settings file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然存在一个`/boot/grub2/`目录，但它唯一包含的内容是指向GRUB环境设置文件的符号链接：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Almost everything else of importance is in the `/boot/efi/` directory:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有其他重要的内容都在`/boot/efi/`目录中：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At the bottom of this nest, we see the `/boot/efi/EFI/almalinux/` and `/boot/efi/EFI/BOOT/`
    directories. Let''s look in the `BOOT/` directory:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个嵌套结构的底部，我们看到`/boot/efi/EFI/almalinux/`和`/boot/efi/EFI/BOOT/`目录。我们来看看`BOOT/`目录：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `BOOTX64.EFI` file is part of the `shim` system, which allows Linux to boot
    on machines that have the Secure Boot feature enabled. (We'll talk about Secure
    Boot at the end of this chapter.) The `fbx64.efi` file is the fallback bootloader.
    Its job is to recreate the boot manager options that are built into the firmware
    in case they somehow get deleted. It does this by scanning the `BOOTX64.CSV` files
    that are in the subdirectories for any operating systems that are installed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOTX64.EFI`文件是`shim`系统的一部分，允许Linux在启用了安全启动功能的机器上启动。（我们将在本章末讨论安全启动。）`fbx64.efi`文件是回退启动加载器。它的作用是重新创建内置于固件中的启动管理器选项，以防它们被意外删除。它通过扫描`BOOTX64.CSV`文件来完成这项工作，这些文件位于子目录中，包含任何已安装操作系统的条目。'
- en: 'Now, here''s what we see in the `almalinux/` directory:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以下是我们在`almalinux/`目录中看到的内容：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In addition to the normal `GRUB2` files that we''d see on a BIOS-based machine,
    we see several files that are specific to EFI/UEFI machines:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在BIOS机器上看到的正常`GRUB2`文件外，我们还看到了几个特定于EFI/UEFI机器的文件：
- en: '`grubx64.efi`: This is what makes GRUB2 work on an EFI/UEFI machine.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grubx64.efi`：这使得GRUB2能够在EFI/UEFI机器上运行。'
- en: '`shim64-almalinux.efi` and `shimx64.efi`: These files go along with the `BOOTX64.EFI`
    file to make Alma work on a Secure Boot machine.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shim64-almalinux.efi`和`shimx64.efi`：这些文件与`BOOTX64.EFI`文件一起工作，使Alma能够在启用了安全启动的机器上运行。'
- en: '`mmx64.efi`: This is part of the *Machine Owner Key* system, which also helps
    out with Secure Boot.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mmx64.efi`：这是*机器所有者密钥*系统的一部分，它也有助于安全启动。'
- en: '`BOOTX64.CSV`: This file works with the fallback bootloader and contains a
    boot menu entry for this installation of Alma. (If multiple operating systems
    were installed, they would all have their own `BOOTX64.CSV` files.) If you peek
    inside this file, you''ll see this:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOTX64.CSV`：这个文件与回退启动加载器一起工作，并包含此Alma安装的启动菜单条目。（如果安装了多个操作系统，它们将有各自的`BOOTX64.CSV`文件。）如果你查看这个文件的内容，你会看到：'
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'Something to keep in mind is that the `BOOTX64.CSV` file is not an ASCII text
    file as most Linux configuration files are. (That would explain those two funny-looking
    questions marks that you see in this code.) Instead, it''s a UTF-16 Unicode file,
    as we see here:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要记住的是，`BOOTX64.CSV`文件不是像大多数Linux配置文件那样的ASCII文本文件。（这可以解释你在代码中看到的那两个奇怪的问号。）相反，它是一个UTF-16
    Unicode文件，正如我们在这里看到的：
- en: '`BOOTX64.CSV` file, you''ll need to convert it into UTF-16 format. Let''s say
    that you''ve created a `boot.csv` file in your home directory. You can convert
    it with the `iconv` tool, like this:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`BOOTX64.CSV`文件，你需要将其转换为UTF-16格式。假设你已经在主目录中创建了一个`boot.csv`文件。你可以使用`iconv`工具进行转换，如下所示：'
- en: '**[donnie@alma-efi ~]$ iconv -t UTF-16 < ~/boot.csv > BOOTX64.CSV**'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**[donnie@alma-efi ~]$ iconv -t UTF-16 < ~/boot.csv > BOOTX64.CSV**'
- en: '**[donnie@alma-efi ~]$**'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**[donnie@alma-efi ~]$**'
- en: Now, you're ready to copy the file to its proper location.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你准备好将文件复制到正确的位置了。
- en: 'Next, we have the `BLS` files for the boot menu choices, just as we had on
    the BIOS machine:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有与BIOS机器上的启动菜单选项相同的`BLS`文件：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we boot an EFI/UEFI machine, we''ll see that the boot menu looks somewhat
    different than what it does on a BIOS machine:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动一个EFI/UEFI机器时，我们会看到启动菜单与在BIOS机器上的显示有所不同：
- en: '![](img/Figure_17.3_B17491.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_17.3_B17491.jpg)'
- en: Figure 17.3 – The boot menu on an EFI/UEFI machine
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.3 – EFI/UEFI机器上的启动菜单
- en: 'We now see a **System setup** choice, which takes us into the EFI management
    utility we see here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在看到一个**系统设置**选项，它将我们带入到我们在这里看到的EFI管理工具：
- en: '![](img/Figure_17.4_B17491.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_17.4_B17491.jpg)'
- en: Figure 17.4 – The EFI management utility
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.4 – EFI管理工具
- en: 'This can do several things for us. If we select **Boot Maintenance Manager**,
    we''ll see the **Boot Options** option. If we select that, we''ll see that we
    can add or delete boot options, or change the default boot order:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以为我们做几件事情。如果我们选择**启动维护管理器**，我们会看到**启动选项**选项。如果选择它，我们会看到可以添加或删除启动选项，或更改默认启动顺序：
- en: '![](img/Figure_17.5_B17491.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_17.5_B17491.jpg)'
- en: Figure 17.5 – The Boot Options screen
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.5 – 启动选项屏幕
- en: This could come in handy if we ever need to boot from a DVD or USB device rather
    than from the default device.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要从 DVD 或 USB 设备引导，而不是从默认设备引导，这可能会派上用场。
- en: 'Under the **Boot Manager** option, we see the **EFI Internal Shell** option:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在**引导管理器**选项下，我们可以看到**EFI 内部 Shell**选项：
- en: '![](img/Figure_17.6_B17491.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_17.6_B17491.jpg)'
- en: Figure 17.6 – The Boot Manager screen
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.6 – 引导管理器屏幕
- en: 'This internal shell can help you troubleshoot boot-up problems and looks like
    this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内部 Shell 可以帮助你排查启动问题，界面如下所示：
- en: '![](img/Figure_17.7_B17491.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_17.7_B17491.jpg)'
- en: Figure 17.7 – The EFI internal shell
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.7 – EFI 内部 Shell
- en: To see the commands that you can run from this shell, just type `help`. I'm
    not going to cover this shell in detail because it's not something that you'll
    use very often. However, I've linked to a good tutorial in the *Further reading*
    section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你可以在这个 shell 中运行的命令，只需输入 `help`。我不会详细介绍这个 shell，因为你不会经常使用它。不过，我在*进一步阅读*部分链接了一个很好的教程。
- en: Okay, that covers it for GRUB2 on the AlmaLinux machine. Now, let's look at
    how things are a bit different on the Ubuntu machine.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就涵盖了 AlmaLinux 机器上的 GRUB2 部分。现在，让我们来看看 Ubuntu 机器上情况是如何有所不同的。
- en: GRUB2 on BIOS-based and EFI/UEFI-based Ubuntu machines
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BIOS 和 EFI/UEFI 系统上的 GRUB2（以 Ubuntu 为例）
- en: 'The biggest difference is that Ubuntu doesn''t use `BootLoaderSpec` files,
    as the RHEL 8-type distros do. Instead, all menu entries are defined within the
    `/boot/grub/grub.cfg` file. To see these menu entries, open the file and search
    for stanzas that begin with `menuentry`. Here''s a snippet from one such menu
    entry:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的不同之处在于，Ubuntu 并没有像 RHEL 8 类发行版那样使用 `BootLoaderSpec` 文件。相反，所有菜单项都定义在 `/boot/grub/grub.cfg`
    文件中。要查看这些菜单项，打开该文件并搜索以 `menuentry` 开头的段落。以下是其中一个菜单项的片段：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only other real difference is that there's no symbolic link to the `grub.cfg`
    file in the `/etc/` directory.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的另一个实际区别是，在 `/etc/` 目录下没有指向 `grub.cfg` 文件的符号链接。
- en: Next, let's reboot to get to the good stuff. Let's look at *systemd-boot*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们重启系统，看看好玩的内容。让我们来看一下*systemd-boot*。
- en: Understanding systemd-boot
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 systemd-boot
- en: The first thing to note here is the name, *systemd-boot*. It's shocking, I know.
    We have a systemd component whose name does *not* end in the letter *d*. But seriously,
    systemd-boot is a component of systemd that has some cool features. Compared to
    GRUB2, it's lighter-weight, easier to configure, boots faster, and works well
    with the modern implementations of Secure Boot. Contrary to popular belief, systemd-boot
    is a *boot manager*, not a *bootloader*. It can automatically probe for other
    operating systems on the machine and add them to the boot menu. (GRUB2 only does
    this when you first install the operating system, while systemd-boot does this
    each time you boot the machine.) Once you've booted the machine and have chosen
    your desired boot option, systemd-boot hands the boot operation over to a *real*
    bootloader.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的第一件事是名称，*systemd-boot*。这真让人震惊，我知道。我们有一个 systemd 组件，它的名称居然*没有*以字母 *d*
    结尾。但说真的，systemd-boot 是 systemd 的一个组件，具有一些很酷的功能。与 GRUB2 相比，它更轻量，配置更简单，启动更快，并且能很好地与现代的安全启动（Secure
    Boot）实现兼容。与广泛的看法相反，systemd-boot 是一个*引导管理器*，而不是*引导加载器*。它可以自动探测机器上的其他操作系统并将其添加到引导菜单中。（GRUB2
    只有在首次安装操作系统时才会这样做，而 systemd-boot 每次启动机器时都会这样做。）一旦你启动了机器并选择了所需的引导选项，systemd-boot
    会将引导操作交给一个*真正的*引导加载器。
- en: So, why isn't it more widely used? Well, it's just that systemd-boot *only*
    works on EFI/UEFI systems. There are still a lot of older BIOS-based computers
    in use, and all of them would become unusable if all operating systems were to
    switch to EFI/UEFI-only bootloaders.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么它没有被更广泛使用呢？其实是因为 systemd-boot*仅*在 EFI/UEFI 系统上工作。现在仍有很多旧的基于 BIOS 的计算机在使用，如果所有操作系统都切换到仅支持
    EFI/UEFI 的引导加载器，那么这些旧机器就无法使用了。
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: You can read about the various features of systemd-boot on the `systemd-boot`
    man page.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `systemd-boot` 手册页中阅读有关 systemd-boot 的各种功能。
- en: For our demos, we'll use **Pop!_OS** Linux, which is a product of the System76
    company. System76 is a computer vendor, so it made sense for them to produce an
    operating system that would only run on newer machines. It's based on Ubuntu,
    so you can use the same Ubuntu commands that you're used to using, other than
    any commands that deal with the bootloader. (At the time of writing, it was based
    on Ubuntu 21.04.)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的演示，我们将使用**Pop!_OS** Linux，这是 System76 公司的一款产品。System76 是一家计算机供应商，所以他们生产只能运行在新型机器上的操作系统是合情合理的。它基于
    Ubuntu，因此你可以使用与你习惯使用的 Ubuntu 命令相同的命令，除了涉及引导加载器的命令。（在撰写本文时，它基于 Ubuntu 21.04。）
- en: 'When I created the Pop!_OS virtual machine, I just accepted the installer''s
    default partition setup. Here''s what it looks like:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我创建Pop!_OS虚拟机时，我只是接受了安装程序的默认分区设置。它长这样：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we see that `/dev/sda1` is mounted as `/boot/efi/`, which is the EFI system
    partition where the bootloaders reside. We also see a `/recovery/` partition,
    which is something I've never before seen on any Linux machine. This `/recovery/`
    partition contains a live version of Pop!_OS. Boot from this partition if you
    ever need to repair or even reinstall the operating system without losing users'
    files.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们看到`/dev/sda1`被挂载为`/boot/efi/`，这是EFI系统分区，启动加载程序就存放在这里。我们还看到一个`/recovery/`分区，这是我在任何Linux机器上都没见过的东西。这个`/recovery/`分区包含了一个Pop!_OS的实时版本。如果你需要修复或重新安装操作系统而不丢失用户文件，就从这个分区启动。
- en: 'Unlike GRUB2, systemd-boot does not have any configuration files in the `/etc/`
    directory. Instead, they''re all in the `/boot/efi/` directory. As we did previously,
    we''ll make things easier by going to a `root` shell:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与GRUB2不同，systemd-boot在`/etc/`目录下没有任何配置文件。相反，它们都在`/boot/efi/`目录下。像之前一样，我们通过进入`root`
    shell来简化操作：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here''s what''s inside the `/boot/efi/` directory:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`/boot/efi/`目录下的内容：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s look in the `loader/` subdirectory first:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一下`loader/`子目录：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ll come back to the two files in just a bit. First, let''s look into the
    `entries/` subdirectory:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们会回到这两个文件。首先，让我们看看`entries/`子目录：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These three `BootLoaderSpec` files represent the three choices that will come
    up on the boot menu when you boot up your machine. (I know that you haven''t seen
    the boot menu yet, but that''s okay. We''ll fix that shortly.) Just for fun, let''s
    peek inside the `Pop_OS-current.conf` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个`BootLoaderSpec`文件代表了在你启动机器时，启动菜单上出现的三个选项。（我知道你还没见过启动菜单，不过没关系，我们很快就能解决这个问题。）开个玩笑，让我们先看看`Pop_OS-current.conf`文件：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Unlike GRUB2, there are no other files for storing the kernel options. So, they
    all have to be stored here. What you might think of as a bit unusual is that the
    kernel file that this `BLS` file calls in has a `.efi` filename extension. I'll
    explain why that is in just a few moments.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与GRUB2不同，这里没有其他文件来存储内核选项。所以，所有选项都必须存储在这里。你可能觉得有点不寻常的是，这个`BLS`文件所调用的内核文件具有`.efi`的文件扩展名。稍后我会解释为什么会这样。
- en: The `/boot/efi/loader/random-seed` file stores a random seed value. (I bet you
    would never have guessed that.) This allows the machine to boot with a fully initialized
    entropy pool, which allows the `/dev/urandom` device to create better random numbers.
    This makes security better by allowing the system to create security keys that
    are harder to crack. (Note though, that this feature doesn't work on virtual machines.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`/boot/efi/loader/random-seed`文件存储了一个随机种子值。（我敢打赌你绝对猜不到这个。）这允许机器以完全初始化的熵池启动，从而使`/dev/urandom`设备能够生成更好的随机数。通过允许系统生成更难破解的安全密钥，这增强了安全性。（不过请注意，这个功能在虚拟机上不起作用。）'
- en: 'Next, let''s look at the `/boot/efi/loader/loader.conf` file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`/boot/efi/loader/loader.conf`文件：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Wait a minute. That''s all there is to it? Well yeah. (Didn''t I tell you that
    systemd-boot is much easier to configure than GRUB2?) I do see a slight problem
    here, though. It''s just that the boot menu won''t show up unless you quickly
    press the proper key after you turn on the machine. Let''s edit this file to have
    the boot menu show for five seconds. The edited file should look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，这就这么简单？嗯，是的。（我不是告诉过你systemd-boot比GRUB2更容易配置吗？）不过，我确实发现了一个小问题。那就是，启动菜单不会显示，除非你在开机后迅速按下正确的按键。让我们编辑这个文件，让启动菜单显示五秒钟。编辑后的文件应该是这样：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Okay, that was tough. I just hope that you were able to handle it. Seriously,
    though, there are a few more options that you can read about on the `loader.conf`
    man page and they're all very easy to configure. (By the way, don't reboot the
    machine just yet. We'll make one more change in just a bit, and then you can reboot.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那有点难。我希望你能处理好。不过，说正经的，还有一些选项你可以在`loader.conf`的手册页中阅读，配置起来都很简单。（顺便提一下，别急着重启机器。稍后我们还会做一次更改，然后你就可以重启了。）
- en: 'In the `/boot/efi/EFI/` directory, we see these subdirectories:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/boot/efi/EFI/`目录下，我们看到了这些子目录：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Linux/` subdirectory is empty, so we won''t bother looking into it. In
    the `BOOT/` subdirectory, we only see one file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Linux/`子目录是空的，所以我们不需要看它。在`BOOT/`子目录中，我们只看到一个文件：'
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we saw on the Alma and Ubuntu machines, we have the `BOOTX64.EFI` file, which
    makes this machine work with Secure Boot. However, we don't have the fallback
    bootloader file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 Alma 和 Ubuntu 机器上看到的那样，我们有 `BOOTX64.EFI` 文件，这使得这台计算机能与安全启动一起工作。然而，我们没有备用引导程序文件。
- en: 'In the `systemd/` subdirectory, we see the executable file that makes systemd-boot
    work:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `systemd/` 子目录中，我们看到使 systemd-boot 工作的可执行文件：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, let''s look inside the `Pop_OS-bc156c8a-fcb8-4a74-b491-089c77362828/`
    subdirectory:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看看 `Pop_OS-bc156c8a-fcb8-4a74-b491-089c77362828/` 子目录中的内容：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is much different than what you saw on the GRUB2 machines. Here, we're
    using the *EFI Stub Loader* feature that's built into the Linux kernel. The `vmlinuz.efi`
    file is just a copy of the `/boot/vmlinuz-5.11.0-7633-generic` file, which is
    the newest installed Linux kernel. By renaming this kernel file with a `.efi`
    filename extension, systemd-boot effectively turned this kernel file into its
    own bootloader. (Pretty slick, eh?) The `vmlinuz-previous.efi` file is a copy
    of the `/boot/vmlinuz-5.11.0-7620-generic` file, which is the second oldest installed
    kernel. Every time we install a new kernel on this systemd-boot machine, the original
    copy will go into the top-level `/boot/` directory, and a copy with the `.efi`
    filename extension will go into this directory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这与你在 GRUB2 机器上看到的完全不同。在这里，我们使用的是内建于 Linux 内核中的 *EFI Stub Loader* 功能。`vmlinuz.efi`
    文件只是 `/boot/vmlinuz-5.11.0-7633-generic` 文件的副本，它是最新安装的 Linux 内核。通过将这个内核文件重命名为
    `.efi` 文件扩展名，systemd-boot 实际上将这个内核文件变成了它自己的引导加载程序。（相当巧妙，不是吗？）`vmlinuz-previous.efi`
    文件是 `/boot/vmlinuz-5.11.0-7620-generic` 文件的副本，它是第二旧的已安装内核。每次我们在这个 systemd-boot
    机器上安装一个新内核时，原始副本将放入顶层的 `/boot/` 目录，而带 `.efi` 文件扩展名的副本将放入这个目录。
- en: Another thing to note here is that there are no `shimx64*.efi` files, as we
    saw on the Alma and Ubuntu machines. That's because systemd-boot doesn't need
    the shim system to work with Secure Boot. (I'll explain this in more detail in
    the *Understanding Secure Boot* section.)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要注意的地方是，这里没有我们在 Alma 和 Ubuntu 机器上看到的 `shimx64*.efi` 文件。这是因为 systemd-boot
    不需要 shim 系统来与安全启动一起工作。（我将在 *理解安全启动* 部分更详细地解释这一点。）
- en: Okay, we don't need the root shell anymore, so type `exit` to get back to your
    normal user shell.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们不再需要根 shell 了，所以输入 `exit` 回到你的普通用户 shell。
- en: 'The final systemd-boot component I want to show you is the `bootctl` tool.
    To see the status of systemd-boot, run the command without any options:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我想向你展示的最后一个 systemd-boot 组件是`bootctl`工具。要查看 systemd-boot 的状态，可以运行不带任何选项的命令：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Use the `list` option to view all of the boot menu entries:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `list` 选项来查看所有的启动菜单条目：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Use the `set-default` option to permanently change the default boot option,
    or the `set-oneshot` option to set the default boot option for only the next boot-up.
    Take the ID of the boot option that you want to use from the list output and specify
    it with either option, like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`set-default`选项可以永久更改默认启动选项，或使用`set-oneshot`选项只为下一次启动设置默认启动选项。从输出的启动选项列表中获取你想使用的启动选项
    ID，并通过任一选项指定，像这样：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, go ahead and reboot the machine. This time, you'll see the boot menu come
    up. After the five-second menu timer expires, you'll see the machine boot up on
    the alternate kernel that you chose with this `bootctl set-oneshot` command.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续重新启动计算机。这次，你会看到启动菜单出现。五秒钟的菜单计时器到期后，你将看到计算机启动到你通过 `bootctl set-oneshot`
    命令选择的备用内核。
- en: There's more that you can do with `bootctl`, but I'll let you read all about
    it in the `bootctl` man page.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 `bootctl` 做更多的事情，但我让你在 `bootctl` 手册页中自行阅读。
- en: Let's wrap this chapter up by briefly look at the Secure Boot feature.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过简要地了解一下安全启动功能来结束本章。
- en: Understanding Secure Boot
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解安全启动
- en: 'Secure Boot is an EFI/UEFI feature that prevents computers from loading any
    operating system, operating system modules, or device drivers that haven''t been
    signed by an authorized security key. It helps prevent computers from loading
    various types of malware, such as rootkits. To enable or disable it, boot your
    machine to its setup screen, as you see here on my late-model Acer machine:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动是一个 EFI/UEFI 功能，它防止计算机加载任何未由授权安全密钥签名的操作系统、操作系统模块或设备驱动程序。它有助于防止计算机加载各种类型的恶意软件，如
    rootkit。要启用或禁用安全启动，请将计算机启动到设置屏幕，如我在我的最新款 Acer 电脑上所示：
- en: '![](img/Figure_17.8_B17491.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_17.8_B17491.jpg)'
- en: Figure 17.8 – UEFI setup screen with Secure Boot enabled
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.8 – 启用安全启动的 UEFI 设置屏幕
- en: For some strange reason, it's still called the *BIOS Setup Utility*, even though
    this machine has a UEFI. What I want you to notice is the **TPM Support** option,
    which shows as **[Enabled]**. **TPM** stands for **Trusted Platform Module** and
    is the firmware chip on the motherboard that contains the signing keys that the
    Secure Boot option needs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 出于某种奇怪的原因，即使这台机器使用的是 UEFI，它仍然被称为 *BIOS 设置实用程序*。我希望你注意到的是 **TPM 支持** 选项，它显示为
    **[已启用]**。**TPM** 代表 **受信平台模块**，它是主板上的固件芯片，包含 Secure Boot 所需的签名密钥。
- en: On a Windows machine, Secure Boot is a big deal, because Windows has traditionally
    been very susceptible to malware infections. Linux is much less susceptible, although
    Secure Boot could be useful even for it. Ever since Microsoft introduced Windows
    8, all new computers that come with Windows have Secure Boot enabled by default.
    For now, it's possible to disable Secure Boot on a Windows machine if you need
    to. With Windows 11, that will no longer be an option.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 机器上，Secure Boot 是一个重要的功能，因为 Windows 传统上非常容易受到恶意软件的感染。Linux 则不太容易受到感染，尽管
    Secure Boot 对其也可能有用。自从微软推出 Windows 8 以来，所有预装 Windows 的新计算机默认启用了 Secure Boot。目前，如果需要的话，仍然可以在
    Windows 机器上禁用 Secure Boot。但在 Windows 11 中，这将不再是一个选项。
- en: When Secure Boot first came on the market, it caused much wailing and gnashing
    of teeth among the Linux faithful. That's because Secure Boot works by looking
    at the cryptographic signature of the machine's bootloader, and then compares
    it to the signature list that's in the computer's TPM. Okay, that doesn't sound
    so bad. What is bad is that the necessary signatures and signing keys are loaded
    into the TPM when the computer is manufactured, and Microsoft pretty much controls
    which signatures and keys get loaded. So, at first, Windows was the only operating
    system that was guaranteed to boot on a machine with Secure Boot enabled. Linux
    developers had to come up with a way to make Linux work with Secure Boot. The
    Linux faithful wailed and gnashed their teeth even more when they learned that
    this would have to involve letting Microsoft issue the signing keys for Linux
    bootloaders. (Yeah, the same Microsoft whose CEO at the time once stated that
    Linux is a *cancer*.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Secure Boot 最初面市时，它引起了 Linux 用户的极大不满和强烈反应。这是因为 Secure Boot 是通过查看机器引导程序的加密签名，然后将其与计算机
    TPM 中的签名列表进行比较来工作的。好吧，听起来似乎没那么糟糕。糟糕的是，必要的签名和签名密钥在计算机制造时就已加载到 TPM 中，并且微软几乎控制了哪些签名和密钥会被加载。因此，一开始，Windows
    是唯一一个在启用 Secure Boot 的机器上能保证启动的操作系统。Linux 开发者不得不想出一种方法，让 Linux 能与 Secure Boot
    一起工作。当 Linux 用户得知这意味着必须让微软为 Linux 引导程序发布签名密钥时，他们更是痛苦万分。（没错，就是那个曾经有 CEO 说 Linux
    是 *癌症* 的微软。）
- en: In this chapter, although you don't realize it yet, we've seen how GRUB2 and
    systemd-boot handle the Secure Boot feature in different ways. GRUB2 works with
    the shim system, which uses pre-signed shim files. On the Alma machine, these
    are the `shimx64.efi` and `shimx64-almalinux.efi` files, which we saw in the `/boot/efi/EFI/almalinux/`
    directory. On the Ubuntu Server machine, all we have is the `shimx64.efi` file
    in the `/boot/efi/EFI/ubuntu/` directory. So, why do we have this shim system,
    instead of just signing the GRUB2 bootloader files? Well, there are two reasons.
    One is that GRUB2 is already rather bloated and adding the Secure Boot code to
    it would bloat it even more. The other reason is that the GRUB2 code is licensed
    under the GPL3 free-as-in-speech software license. For some reason that I don't
    know, Microsoft refuses to issue signing keys for anything that's under GPL3\.
    For that reason, systemd-boot is licensed under GPL2, which Microsoft seems to
    like better.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，尽管你可能还没有意识到，我们已经看到 GRUB2 和 systemd-boot 如何以不同的方式处理 Secure Boot 功能。GRUB2
    与 shim 系统配合使用，该系统使用预签名的 shim 文件。在 Alma 机器上，这些文件是 `/boot/efi/EFI/almalinux/` 目录下的
    `shimx64.efi` 和 `shimx64-almalinux.efi` 文件。在 Ubuntu Server 机器上，我们只有 `/boot/efi/EFI/ubuntu/`
    目录中的 `shimx64.efi` 文件。那么，为什么我们需要这个 shim 系统，而不是直接对 GRUB2 引导程序文件进行签名呢？有两个原因。一个是
    GRUB2 本身已经相当臃肿，如果在其上增加 Secure Boot 代码，会使其更加臃肿。另一个原因是 GRUB2 的代码是按照 GPL3 开源许可证发布的。由于某些原因，我并不清楚，微软拒绝为任何
    GPL3 许可下的内容提供签名密钥。因此，systemd-boot 是根据 GPL2 许可证发布的，而微软似乎更喜欢这个许可证。
- en: When we looked at Pop!_OS Linux, I pointed out that it doesn't have any `shimx64*.efi`
    files. Since systemd-boot is under GPL2, Microsoft will sign its files, making
    the shim system unnecessary.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看 Pop!_OS Linux 时，我指出它没有任何 `shimx64*.efi` 文件。由于 systemd-boot 是根据 GPL2 发布的，微软会为其文件签名，这使得
    shim 系统变得不必要。
- en: Okay, I'm reading your mind again, hopefully for the final time. You're thinking,
    *But, Donnie. What if I've created a kernel module, and I need it to load on a
    Secure Boot machine? And what if I install Linux on a Secure Boot machine, and
    then decide that I don't trust any signing keys that are issued by Microsoft?
    What can I do?*
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我又在读你的心思了，希望这次是最后一次。你在想，*但，Donnie。如果我创建了一个内核模块，我需要它在安全启动的机器上加载怎么办？如果我在一个启用了安全启动的机器上安装了Linux，然后决定不信任任何由微软颁发的签名密钥呢？我该怎么办？*
- en: Well, in both cases, it is possible to create signing keys and load them into
    the TPM yourself. It's a long procedure that I can't go into here, so I'll refer
    you to the *Managing EFI bootloaders for Linux* site that's linked in the *Further
    reading* section. In its *Table of Contents*, you'll see a link to the Secure
    Boot page, where you'll find the procedure.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在这两种情况下，您都可以自己创建签名密钥并将其加载到TPM中。这是一个复杂的过程，我无法在这里详细讲解，所以我会参考《*Linux EFI引导程序管理*》网站，该网站链接在“*进一步阅读*”部分。在它的*目录*中，您会看到指向“安全启动”页面的链接，您将在那里找到具体的操作流程。
- en: And that, guys and gals, is it for the bootloader chapter. Let's summarize and
    then wrap this baby up in swaddling clothes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，大家，这就是引导程序章节的全部内容。让我们总结一下，然后把这部分内容收尾整理好。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As always, we've covered much ground in this chapter. We started by providing
    an overview of the computer architecture and then discussed how the GRUB2 bootloader
    works on both BIOS-based and EFI/UEFI-based computers. Then, we covered systemd-boot
    on the Pop!_OS Linux machine, and wrapped up with a discussion of Secure Boot.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如往常一样，我们在这一章中涵盖了很多内容。我们首先概述了计算机架构，然后讨论了GRUB2引导程序在基于BIOS和EFI/UEFI计算机上的工作原理。接着，我们介绍了在Pop!_OS
    Linux机器上的systemd-boot，并以对“安全启动”的讨论做了总结。
- en: In the next chapter, which will be our final one, we'll talk about systemd-logind.
    I'll see you there.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，也是我们最后一章中，我们将讨论systemd-logind。到时候见。
- en: Questions
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To test your knowledge of this chapter, answer the following questions:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试你对本章内容的掌握，请回答以下问题：
- en: Which of the following statements is true?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个陈述是正确的？
- en: A. Only GPT partitions can be used on BIOS-based computers.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 只有GPT分区可以用于基于BIOS的计算机。
- en: B. Only a GPT partition can be used to install GRUB2.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 只有GPT分区才能用于安装GRUB2。
- en: C. Only a GPT partition can be used to install systemd-boot.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 只有GPT分区才能用于安装systemd-boot。
- en: D. Only an MBR partition can be used to install systemd-boot.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 只有MBR分区才能用于安装systemd-boot。
- en: How does GRUB2 work with Secure Boot?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GRUB2如何与安全启动兼容？
- en: A. It uses the shim system.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 它使用了shim系统。
- en: B. Its files are directly signed by Microsoft.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 它的文件是由微软直接签名的。
- en: C. GRUB2 doesn't work with Secure Boot.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. GRUB2不能与安全启动兼容。
- en: How does systemd-boot work?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: systemd-boot是如何工作的？
- en: A. It uses the `grubx64.efi` file to activate the bootloader.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 它使用`grubx64.efi`文件来激活引导程序。
- en: B. It copies the kernel file over to a file with a `.efi` filename extension
    so that the kernel can act as its own bootloader.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 它将内核文件复制到具有`.efi`文件扩展名的文件中，以便内核可以充当其自己的引导程序。
- en: C. It directly calls in the Linux kernel from the `/boot/` directory.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 它直接从`/boot/`目录调用Linux内核。
- en: D. It doesn't work at all.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 它根本不起作用。
- en: What is necessary to make Secure Boot work?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使安全启动工作，必须具备什么条件？
- en: A. Nothing. It works on all computers.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 没有任何作用。它在所有计算机上都能工作。
- en: B. That the machine has a BIOS chip, and that TPM is enabled.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 机器具有BIOS芯片，并且启用了TPM。
- en: C. That the machine has an EFI/UEFI, and that TPM is enabled.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 机器有EFI/UEFI，并且启用了TPM。
- en: D. Nothing. It never works.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 没有任何作用。它从未工作过。
- en: Answers
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: C
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: A
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: B
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: C
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: Further reading
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解更多关于本章所涵盖的主题，请查看以下资源：
- en: 'The 15 best bootloaders for home and embedded systems: [https://www.ubuntupit.com/best-linux-bootloader-for-home-and-embedded-systems/](https://www.ubuntupit.com/best-linux-bootloader-for-home-and-embedded-systems/)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 家用和嵌入式系统的15款最佳引导程序：[https://www.ubuntupit.com/best-linux-bootloader-for-home-and-embedded-systems/](https://www.ubuntupit.com/best-linux-bootloader-for-home-and-embedded-systems/)
- en: 'The UEFI Interactive Shell: [https://linuxhint.com/use-uefi-interactive-shell-and-its-common-commands/](https://linuxhint.com/use-uefi-interactive-shell-and-its-common-commands/)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UEFI交互式Shell：[https://linuxhint.com/use-uefi-interactive-shell-and-its-common-commands/](https://linuxhint.com/use-uefi-interactive-shell-and-its-common-commands/)
- en: 'What is `vmlinux.efi`?: [https://askubuntu.com/questions/330541/what-is-vmlinuz-efi](https://askubuntu.com/questions/330541/what-is-vmlinuz-efi)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是`vmlinux.efi`？：[https://askubuntu.com/questions/330541/what-is-vmlinuz-efi](https://askubuntu.com/questions/330541/what-is-vmlinuz-efi)
- en: 'How to modify systemd-boot: [https://www.techrepublic.com/article/how-to-modify-systemd-boot-on-linux/](https://www.techrepublic.com/article/how-to-modify-systemd-boot-on-linux/)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如何修改 systemd-boot: [https://www.techrepublic.com/article/how-to-modify-systemd-boot-on-linux/](https://www.techrepublic.com/article/how-to-modify-systemd-boot-on-linux/)'
- en: '`Pop!_OS` recovery partition: [https://support.system76.com/articles/pop-recovery](https://support.system76.com/articles/pop-recovery)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pop!_OS` 恢复分区: [https://support.system76.com/articles/pop-recovery](https://support.system76.com/articles/pop-recovery)'
- en: 'Secure Boot overview: [https://www.dell.com/support/kbdoc/en-us/000145423/secure-boot-overview](https://www.dell.com/support/kbdoc/en-us/000145423/secure-boot-overview)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '安全启动概述: [https://www.dell.com/support/kbdoc/en-us/000145423/secure-boot-overview](https://www.dell.com/support/kbdoc/en-us/000145423/secure-boot-overview)'
- en: 'An explanation of Secure Boot: [https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-secure-boot](https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-secure-boot)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '安全启动的解释: [https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-secure-boot](https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-secure-boot)'
- en: 'Secure Boot Linux: [https://linuxhint.com/secure-boot-linux/](https://linuxhint.com/secure-boot-linux/)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '安全启动 Linux: [https://linuxhint.com/secure-boot-linux/](https://linuxhint.com/secure-boot-linux/)'
- en: 'Installing Linux with Secure Boot: [https://www.linux.org/threads/installing-linux-with-secure-boot-and-friends.29454/](https://www.linux.org/threads/installing-linux-with-secure-boot-and-friends.29454/)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '带安全启动的 Linux 安装: [https://www.linux.org/threads/installing-linux-with-secure-boot-and-friends.29454/](https://www.linux.org/threads/installing-linux-with-secure-boot-and-friends.29454/)'
- en: 'Changing to `BootLoaderSpec` files: [https://fedoraproject.org/wiki/Changes/BootLoaderSpecByDefault](https://fedoraproject.org/wiki/Changes/BootLoaderSpecByDefault)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '更改为 `BootLoaderSpec` 文件: [https://fedoraproject.org/wiki/Changes/BootLoaderSpecByDefault](https://fedoraproject.org/wiki/Changes/BootLoaderSpecByDefault)'
- en: 'Managing EFI bootloaders for Linux: [https://www.rodsbooks.com/efi-bootloaders/index.html](https://www.rodsbooks.com/efi-bootloaders/index.html)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '管理 Linux 的 EFI 启动加载器: [https://www.rodsbooks.com/efi-bootloaders/index.html](https://www.rodsbooks.com/efi-bootloaders/index.html)'
- en: 'Ballmer: Linux is a cancer: [https://www.theregister.com/2001/06/02/ballmer_linux_is_a_cancer/](https://www.theregister.com/2001/06/02/ballmer_linux_is_a_cancer/)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ballmer：Linux 是一种癌症: [https://www.theregister.com/2001/06/02/ballmer_linux_is_a_cancer/](https://www.theregister.com/2001/06/02/ballmer_linux_is_a_cancer/)'
