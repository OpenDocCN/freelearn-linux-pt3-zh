<html><head></head><body>
<div class="_idGenObjectStyleOverride-1" id="_idContainer281">
<p class="Chapter-Title" id="_idParaDest-209" lang="en-US"><span class="ChapterMarker"><span class="koboSpan" id="kobo.1.1">22. </span></span><a id="_idTextAnchor361"/><span class="koboSpan" id="kobo.2.1">An Overview of Virtualization Techniques</span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.3.1">Virtualization is the ability to run multiple operating systems simultaneously on a single computer system. </span><span class="koboSpan" id="kobo.3.2">While not necessarily a new concept, Virtualization has come to prominence in recent years because it provides a way to fully utilize the CPU and resource capacity of a server system while providing stability (in that if one virtualized guest system crashes, the host and any other guest systems continue to run). </span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.4.1">Virtualization is also helpful in trying out different operating systems without configuring dual boot environments. </span><span class="koboSpan" id="kobo.4.2">For example, you can run Windows in a virtual machine without re-partitioning the disk, shut down Ubuntu, and boot from Windows. </span><span class="koboSpan" id="kobo.4.3">Instead, you start up a virtualized version of Windows as a guest operating system. </span><span class="koboSpan" id="kobo.4.4">Similarly, virtualization allows you to run other Linux distributions within an Ubuntu system, providing concurrent access to both operating systems.</span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.5.1">When deciding on the best approach to implementing virtualization, clearly understanding the different virtualization solutions currently available is essential. </span><span class="koboSpan" id="kobo.5.2">Therefore, this chapter’s purpose is to describe in general terms the virtualization techniques in common use today. </span></p>
<p class="Heading-1-1" id="_idParaDest-210" lang="en-US"><span class="Heading11Marker"><span class="koboSpan" id="kobo.6.1">22.1 </span></span><a id="_idTextAnchor362"/><span class="koboSpan" id="kobo.7.1">Guest Operating System </span><a id="_idIndexMarker536"/><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.8.1">Virtualization </span></p>
<p class="My-Basic-Paragraph" lang="en-US"><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.9.1">Guest OS virtualization, also called application-based virtualization, is the most straightforward concept to understand. </span><span class="koboSpan" id="kobo.9.2">In this scenario, the physical host computer runs a standard unmodified operating system such as Windows, Linux, UNIX, or macOS. </span><span class="koboSpan" id="kobo.9.3">Running on this operating system is a virtualization application that executes in much the same way as any other application, such as a word processor or spreadsheet, would run on the system. </span><span class="koboSpan" id="kobo.9.4">Within this virtualization application, one or more virtual machines are created to run the guest operating systems on the host computer. </span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.10.1">The virtualization application is responsible for starting, stopping, and managing each virtual machine and essentially controlling access to physical hardware resources on behalf of the individual virtual machines. </span><span class="koboSpan" id="kobo.10.2">The virtualization application also engages in a process known as binary rewriting, which involves scanning the instruction stream of the executing guest system and replacing any privileged instructions with safe emulations. </span><span class="koboSpan" id="kobo.10.3">This makes the guest system think it is running directly on the system hardware rather than in a virtual machine within an application. </span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.11.1">The following figure illustrates guest OS-based virtualization: </span></p>
<p class="My-Basic-Paragraph ParaOverride-1" lang="en-US"><span class="koboSpan" id="kobo.12.1"><img alt="" class="_idGenObjectAttribute-1" src="image/guest_os_virtualization.jpg"/></span></p>
<p class="Figure-Caption" lang="en-US"><span class="FigureCaptionMarker"><span class="koboSpan" id="kobo.13.1">Figure 22-1</span></span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.14.1">As outlined in the above diagram, the guest operating systems operate in virtual machines within the virtualization application, which, in turn, runs on top of the host operating system in the same way as any other application. </span><span class="koboSpan" id="kobo.14.2">The multiple layers of abstraction between the guest operating systems and the underlying host hardware are not conducive to high levels of virtual machine performance. </span><span class="koboSpan" id="kobo.14.3">However, this technique has the advantage that no changes are necessary to host or guest operating systems, and no special CPU hardware virtualization support is required. </span></p>
<p class="Heading-1-1" id="_idParaDest-211" lang="en-US"><span class="Heading11Marker"><span class="koboSpan" id="kobo.15.1">22.2 </span></span><a id="_idTextAnchor363"/><a id="_idIndexMarker539"/><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.16.1">Hypervisor Virtualization </span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.17.1">In hypervisor virtualization, the task of a hypervisor is to handle resource and memory allocation for the virtual machines and provide interfaces for higher-level administration and monitoring tools. </span><span class="koboSpan" id="kobo.17.2">Hypervisor-based solutions are categorized as being either </span><a id="_idIndexMarker541"/><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.18.1">Type-1 or Type-2. </span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.19.1">Type-2 </span><a id="_idIndexMarker543"/><a id="_idIndexMarker544"/><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.20.1">hypervisors (sometimes called hosted hypervisors) are installed as software applications that run on top of the host operating system, providing virtualization capabilities by coordinating access to resources such as the CPU, memory, and network for guest virtual machines. </span><span class="koboSpan" id="kobo.20.2">Figure 21-2 illustrates the typical architecture of a system using Type-2 hypervisor virtualization:</span></p>
<p class="My-Basic-Paragraph ParaOverride-1" lang="en-US"> <span class="koboSpan" id="kobo.21.1"><img alt="" class="_idGenObjectAttribute-2" src="image/type-2_hypervisor_virtualization.jpg"/></span></p>
<p class="Figure-Caption" lang="en-US"><span class="FigureCaptionMarker"><span class="koboSpan" id="kobo.22.1">Figure 22-2</span></span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.23.1">To understand how Type-1 hypervisors work, it helps to understand </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.24.1">Intel x86 processor architecture. </span><span class="koboSpan" id="kobo.24.2">The </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.25.1">x86 family of CPUs provides a range of protection levels known as rings in which code can execute. </span><span class="koboSpan" id="kobo.25.2">Ring 0 has the highest level privilege, and it is in this ring that the operating system kernel normally runs. </span><span class="koboSpan" id="kobo.25.3">Code executing in ring 0 is said to be running in system space, kernel mode, or supervisor mode. </span><span class="koboSpan" id="kobo.25.4">All other code, such as applications running on the operating system, operate in less privileged rings, typically ring 3.</span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.26.1">In contrast to </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.27.1">Type-2 hypervisors, </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.28.1">Type-1 hypervisors (also referred to as metal or native hypervisors) run directly on the hardware of the host system in ring 0. </span><span class="koboSpan" id="kobo.28.2">With the hypervisor occupying ring 0 of the CPU, the kernels for any guest operating systems running on the system must run in less privileged CPU rings. </span><span class="koboSpan" id="kobo.28.3">Unfortunately, most operating system kernels are written explicitly to run in ring 0 because they need to perform tasks only available in that ring, such as the ability to execute privileged CPU instructions and directly manipulate memory. </span><span class="koboSpan" id="kobo.28.4">Several different solutions to this problem have been devised in recent years, each of which is described below: </span></p>
<p class="Heading-1-1-1" id="_idParaDest-212" lang="en-US"><span class="Heading111Marker"><span class="koboSpan" id="kobo.29.1">22.2.1 </span></span><a id="_idTextAnchor364"/><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.30.1">Paravirtualization </span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.31.1">Under paravirtualization, the kernel of the guest operating system is modified specifically to run on the hypervisor. </span><span class="koboSpan" id="kobo.31.2">This typically involves replacing privileged operations that only run in ring 0 of the CPU with calls to the hypervisor (known as</span><a id="_idIndexMarker551"/><a id="_idIndexMarker552"/><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.32.1"> hypercalls). </span><span class="koboSpan" id="kobo.32.2">The hypervisor, in turn, performs the task on behalf of the guest kernel. </span><span class="koboSpan" id="kobo.32.3">Unfortunately, this typically limits support to open-source operating systems such as Linux, which may be freely altered, and proprietary operating systems where the owners have agreed to make the necessary code modifications to target a specific hypervisor. </span><span class="koboSpan" id="kobo.32.4">These issues notwithstanding, the ability of the guest kernel to communicate directly with the hypervisor results in greater performance levels than other virtualization approaches. </span></p>
<p class="Heading-1-1-1" id="_idParaDest-213" lang="en-US"><span class="Heading111Marker"><span class="koboSpan" id="kobo.33.1">22.2.2 </span></span><a id="_idTextAnchor365"/><a id="_idIndexMarker554"/><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.34.1">Full Virtualization</span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.35.1">Full virtualization provides support for unmodified guest operating systems. </span><span class="koboSpan" id="kobo.35.2">The term unmodified refers to operating system kernels that have not been altered to run on a hypervisor and, therefore, still execute privileged operations as though running in ring 0 of the CPU. </span><span class="koboSpan" id="kobo.35.3">In this scenario, the hypervisor provides CPU emulation to handle and modify privileged and protected CPU operations made by unmodified guest operating system kernels. </span><span class="koboSpan" id="kobo.35.4">Unfortunately, this emulation process requires both time and system resources to operate, resulting in inferior performance levels when compared to those provided by </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.36.1">paravirtualization. </span></p>
<p class="Heading-1-1-1" id="_idParaDest-214" lang="en-US"><span class="Heading111Marker"><span class="koboSpan" id="kobo.37.1">22.2.3 </span></span><a id="_idTextAnchor366"/><a id="_idIndexMarker557"/><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.38.1">Hardware Virtualization </span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.39.1">Hardware virtualization leverages virtualization features built into the latest generations of CPUs from both Intel and AMD. </span><span class="koboSpan" id="kobo.39.2">These technologies, called </span><a id="_idIndexMarker559"/><a id="_idIndexMarker560"/><a id="_idIndexMarker561"/><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.40.1">Intel VT and AMD-V, respectively, provide extensions necessary to run unmodified guest virtual machines without the overheads inherent in full virtualization CPU emulation. </span><span class="koboSpan" id="kobo.40.2">In very simplistic terms, these processors provide an additional privilege mode (ring -1) above ring 0 in which the hypervisor can operate, thereby leaving ring 0 available for unmodified guest operating systems. </span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.41.1">The following figure illustrates the Type-1 hypervisor approach to virtualization: </span></p>
<p class="My-Basic-Paragraph ParaOverride-1" lang="en-US"><span class="koboSpan" id="kobo.42.1"><img alt="" class="_idGenObjectAttribute-3" src="image/type-1_hypervisor_virtualization.jpg"/></span></p>
<p class="Figure-Caption" lang="en-US"><span class="FigureCaptionMarker"><span class="koboSpan" id="kobo.43.1">Figure 22-3</span></span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.44.1">As outlined in the above illustration, in addition to the virtual machines, an administrative operating system or management console also runs on top of the hypervisor allowing the virtual machines to be managed by a system administrator.</span></p>
<p class="Heading-1-1" id="_idParaDest-215" lang="en-US"><span class="Heading11Marker"><span class="koboSpan" id="kobo.45.1">22.3 </span></span><a id="_idTextAnchor367"/><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.46.1">Virtual Machine Networking</span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.47.1">Virtual machines will invariably need to be connected to a network to be of any practical use. </span><span class="koboSpan" id="kobo.47.2">One option is for the guest to be connected to a virtual network running within the host computer’s operating system. </span><span class="koboSpan" id="kobo.47.3">In this configuration, any virtual machines on the virtual network can see each other, but </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.48.1">Network Address Translation (</span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.49.1">NAT) provides access to the external network. </span><span class="koboSpan" id="kobo.49.2">When using the virtual network and NAT, each virtual machine is represented on the external network (the network to which the host is connected) using the IP address of the host system. </span><span class="koboSpan" id="kobo.49.3">This is the default behavior for </span><a id="_idIndexMarker566"/><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.50.1">KVM virtualization on Ubuntu and generally requires no additional configuration. </span><span class="koboSpan" id="kobo.50.2">Typically, a single virtual network is created by default, represented by the name </span><span class="My-Italic _idGenCharOverride-1"><span class="koboSpan" id="kobo.51.1">default</span></span><span class="koboSpan" id="kobo.52.1"> and the device </span><span class="My-Italic _idGenCharOverride-1"><span class="koboSpan" id="kobo.53.1">virbr0</span></span><span class="koboSpan" id="kobo.54.1">.</span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.55.1">For guests to appear as individual and independent systems on the external network (i.e., with their own IP addresses), they must be configured to share a physical network interface on the host. </span><span class="koboSpan" id="kobo.55.2">The quickest way to achieve this is to configure the virtual machine to use the “direct connection” network configuration option (also called </span><a id="_idIndexMarker568"/><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.56.1">MacVTap), which will provide the guest system with an IP address on the same network as the host. </span><span class="koboSpan" id="kobo.56.2">Unfortunately, while this gives the virtual machine access to other systems on the network, it is not possible to establish a connection between the guest and the host when using the MacVTap driver. </span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.57.1">A better option is to configure a network bridge interface on the host system to which the guests can connect. </span><span class="koboSpan" id="kobo.57.2">This provides the guest with an IP address on the external network while also allowing the guest and host to communicate, a topic covered in the chapter entitled </span><a href="KVM_Network_Bridge.xhtml#_idTextAnchor407"><span class="My-Italic _idGenCharOverride-1"><span class="koboSpan" id="kobo.58.1">“Creating an Ubuntu 23.04 KVM Networked Bridge Interface”</span></span></a><span class="koboSpan" id="kobo.59.1">. </span></p>
<p class="Heading-1-1" id="_idParaDest-216" lang="en-US"><span class="Heading11Marker"><span class="koboSpan" id="kobo.60.1">22.4 </span></span><a id="_idTextAnchor368"/><span class="koboSpan" id="kobo.61.1">Summary</span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.62.1">Virtualization is the ability to run multiple guest operating systems within a single host operating system. </span><span class="koboSpan" id="kobo.62.2">Several approaches to virtualization have been developed, including a guest operating system and hypervisor virtualization. </span><span class="koboSpan" id="kobo.62.3">Hypervisor virtualization falls into two categories known as Type-1 and Type-2. </span><span class="koboSpan" id="kobo.62.4">Type-2 virtualization solutions are categorized as paravirtualization, full virtualization, and hardware virtualization, the latter using special virtualization features of some Intel and AMD processor models.</span></p>
<p class="My-Basic-Paragraph" lang="en-US"><span class="koboSpan" id="kobo.63.1">Virtual machine guest operating systems have several options in terms of networking, including NAT, direct connection (MacVTap), and network bridge configurations.</span></p>
</div>
</body></html>