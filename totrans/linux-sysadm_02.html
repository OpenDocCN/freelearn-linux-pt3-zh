<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer018">
<h1 class="chapter-number" id="_idParaDest-28"><a id="_idTextAnchor034"/>2</h1>
<h1 id="_idParaDest-29"><a id="_idTextAnchor035"/>The Shell and Its Commands</h1>
<p>We’ll be doing a lot of things in the shell, such as installing packages, making new users, creating directories, modifying permissions of files, and so on. These will be the basics but will be your first interaction with the shell to understand what is happening behind it and to get more confident. In order to improve our effectiveness with the shell, we’ll be devoting an entire chapter to it this <span class="No-Break">time around.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>A basic definition of a shell in order to understand how it works, including an overview of its features and a description of the most <span class="No-Break">common shells</span></li>
<li>How to use basic commands in order to get familiarized with Linux (in this chapter, CentOS version 8 will <span class="No-Break">be used)</span></li>
<li>Basic notions about how to use commands to change the ownership of files <span class="No-Break">and directories</span></li>
</ul>
<h1 id="_idParaDest-30"><a id="_idTextAnchor036"/>What is a shell?</h1>
<p>Computer software <a id="_idIndexMarker051"/>known as a <em class="italic">shell</em> makes an operating system’s services accessible to users or <span class="No-Break">other programs.</span></p>
<p>A shell is a program that receives commands and sends them to the operating system for processing, to put it simply. In an interactive session, the user has the option of typing commands from the keyboard, or they can be written in a shell script that can be reused. On a Unix-type system such as Linux <a id="_idIndexMarker052"/>in the past, it was the sole <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) accessible. Today, in <a id="_idIndexMarker053"/>addition to <strong class="bold">command-line interfaces</strong> (<strong class="bold">CLIs</strong>) such as <a id="_idIndexMarker054"/>shells, we also have <strong class="bold">graphical </strong><span class="No-Break"><strong class="bold">UIs</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">GUIs</strong></span><span class="No-Break">).</span></p>
<p>The fundamental capability of shells is the ability to launch command-line programs that are already installed on the system. They also offer built-ins and scripting control structures such as conditionals and loops. Each shell has its own way of doing that. Some shells still support the Bourne shell, one of the original shells that was created for an early Unix system by a programmer <a id="_idIndexMarker055"/>named Steve Bourne and later standardized in the <strong class="bold">Portable Operating System Interface</strong> (<strong class="bold">POSIX</strong>) standard. Other projects, such as <strong class="source-inline">csh</strong>/<strong class="source-inline">tcsh</strong>, <strong class="source-inline">zsh</strong>, and <strong class="source-inline">fish</strong>, purposefully utilize a <span class="No-Break">different syntax.</span></p>
<p>In order to use command-line shells, a user must be knowledgeable about commands, their calling syntax, and the <a id="_idIndexMarker056"/>fundamentals of the shell’s specific <span class="No-Break">scripting language.</span></p>
<p>A Linux user can utilize a variety of shells, including <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="source-inline">sh</strong>: A POSIX-compatible <a id="_idIndexMarker057"/>Bourne shell. In modern distros, it’s usually just <strong class="bold">Bourne again shell</strong> (<strong class="bold">Bash</strong>) running in <a id="_idIndexMarker058"/><span class="No-Break">compatibility mode.</span></li>
<li><strong class="source-inline">csh</strong>/<strong class="source-inline">tcsh</strong>: These come <a id="_idIndexMarker059"/>from the <strong class="bold">Berkeley Software Distribution</strong> (<strong class="bold">BSD</strong>) Unix system family but <a id="_idIndexMarker060"/>are also available on Linux; their scripting syntax is similar to that of C, and they are incompatible with the <span class="No-Break">Bourne shell.</span></li>
<li><strong class="source-inline">ksh</strong>: A Bourne shell <a id="_idIndexMarker061"/>derivative that was once <span class="No-Break">very popular.</span></li>
<li><strong class="source-inline">bash</strong>: Bash is the most <a id="_idIndexMarker062"/>common Linux shell and was created for the <span class="No-Break">GNU project.</span></li>
<li><strong class="source-inline">zsh</strong> and <strong class="source-inline">fish</strong>: These are <a id="_idIndexMarker063"/>highly customizable and feature-rich shells that are intentionally different from <strong class="source-inline">sh</strong> derivatives and require learning, but have large communities <span class="No-Break">of enthusiasts.</span></li>
</ul>
<p>They all share similar properties, but each has its own <span class="No-Break">unique attributes.</span></p>
<p>In this book, we will assume you are using Bash since it’s the default in most <span class="No-Break">Linux distributions.</span></p>
<p>The Unix shell and Bash command language were both developed by Brian Fox for the GNU project. These were intended to serve as free software replacements for the Bourne shell. Since its introduction in 1989, it has remained the default login shell for the vast majority of Linux <a id="_idIndexMarker064"/>distributions. Linus Torvalds ported Bash and the <strong class="bold">GNU Compiler Collection</strong> (<strong class="bold">GCC</strong>) to Linux as one of the <span class="No-Break">initial applications.</span></p>
<p>Bash has the <span class="No-Break">following features:</span></p>
<ul>
<li>The shell will check to see whether a command is built in before searching through a list of directories to locate the <a id="_idIndexMarker065"/>program if not. This set is known as the search path. By running the <strong class="source-inline">echo $PATH</strong> command in Bash, you can view it. The <strong class="source-inline">home</strong> directory and its subdirectory are included in the search path in addition to the current directory. You are able to create your own programs and call them up just by inputting their names. No matter which directory you are now in, a program such as this will be found and launched if it is stored in the <strong class="source-inline">bin</strong> directory. We will find out more about the Linux directory structure in <a href="B18575_03.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">The </em><span class="No-Break"><em class="italic">Linux </em></span><span class="No-Break"><em class="italic">Filesystem</em></span><span class="No-Break">.</span></li>
<li>As with other Linux programs, the shell has a current directory linked to it. When looking for files, Linux-based programs begin in the current directory. To move the current directory to another location in the Linux filesystem, use the <strong class="source-inline">cd</strong> shell command. The current working directory is typically visible in the command prompt of modern shells. To check the version of your shell, run the <strong class="source-inline">echo $SHELL</strong> command. You will get an output such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">/bin/bash</strong></span><span class="No-Break">.</span></li>
<li>A command is executed by designating it. The majority of Linux commands are just programs that the shell runs. For instance, the following <strong class="source-inline">ls</strong> command scans the current directory and lists the names of its files: <span class="No-Break"><strong class="source-inline">ls -la</strong></span><span class="No-Break">.</span></li>
<li>Commands frequently <a id="_idIndexMarker066"/>have argument strings that could, for example, be filenames. For instance, the following command switches to the <strong class="source-inline">tmp</strong> directory in your <strong class="source-inline">home</strong> directory. The shell interprets the tilde character as your <span class="No-Break"><strong class="source-inline">home</strong></span><span class="No-Break"> directory:</span><pre class="source-code">
<strong class="bold">cd ~/tmp</strong></pre></li>
<li>Multiple arguments are required for some commands. The copy command, for instance, requires two arguments: the file to copy and its destination. This is demonstrated as follows by copying <strong class="source-inline">file1</strong> to a new <span class="No-Break">file, </span><span class="No-Break"><strong class="source-inline">file2</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">cp file1 file2</strong></pre></li>
<li>The flag or option argument strings for some commands typically start with <strong class="source-inline">-</strong>. The flags change how the invoked application behaves. When the following command is used, <strong class="source-inline">ls</strong> outputs a lengthy listing of files arranged by <span class="No-Break">creation time:</span><pre class="source-code">
<strong class="bold">ls -lt</strong></pre></li>
<li>Wildcards will be expanded by the shell to match filenames in the current directory. For example, to display a directory listing of files named <strong class="source-inline">anything.sh</strong>, type <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">ls -l *.sh</strong></pre></li>
<li><strong class="bold">Standard input</strong> (<strong class="bold">stdin</strong>) and <strong class="bold">standard output</strong> (<strong class="bold">stdout</strong>) are concepts that are followed by the <a id="_idIndexMarker067"/>majority of Linux commands and programs. The program <a id="_idIndexMarker068"/>receives a stream of data as stdin and produces a stream of output as stdout. These are frequently both connected to Terminal so that input is made via the keyboard and output is displayed on the <a id="_idIndexMarker069"/>screen. You can reroute stdin and stdout using the shell. <strong class="source-inline">cat</strong> is an abbreviation for <em class="italic">concatenate</em>. When run, the following command will show you the contents of one or more files without requiring you to open them <span class="No-Break">for editing:</span><pre class="source-code">
<strong class="bold">cat /etc/passwd</strong></pre></li>
<li>The shell has the ability to pipe data from one program’s output to another’s input. <strong class="source-inline">|</strong> is the pipe symbol. To count <a id="_idIndexMarker070"/>the number of words in <strong class="source-inline">testfile.txt</strong>, we can concatenate the file and pass the output into the <strong class="source-inline">wc</strong> program, <span class="No-Break">like so:</span><pre class="source-code">
<strong class="bold">cat testfile.txt | wc -w</strong></pre><pre class="source-code">
<strong class="bold">1198</strong></pre></li>
</ul>
<p>Or, to count the number of lines from a <strong class="source-inline">testfile.txt</strong> file, we can use the <span class="No-Break">following command:</span></p>
<pre class="source-code">
<strong class="bold">cat testfile.txt | wc -l</strong>
<strong class="bold">289</strong></pre>
<ul>
<li>You can create aliases for commands or groups of commands that you use frequently or find difficult to input. For instance, we could use the <strong class="source-inline">top10</strong> alias to find the top 10 files in the current directory. <strong class="source-inline">head</strong> will show only the top lines. An alias is a shortcut for a command—for example, rather than remembering a very long command, you can create an alias that you can remember easily. Here’s <span class="No-Break">an example:</span><pre class="source-code">
<strong class="bold">alias top10="du -hsx * | sort -rh | head -10"</strong></pre></li>
<li>Some variables are predefined, such as <strong class="source-inline">$HOME</strong>, which is your <strong class="source-inline">home</strong> directory. To see a list of assigned variables, type the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">set</strong></pre></li>
<li>A <strong class="bold">manual</strong> (<strong class="bold">man</strong>) page is like a <a id="_idIndexMarker071"/>manual with instructions and descriptions about each command. Run the following command to view the man page <span class="No-Break">for Bash:</span><pre class="source-code">
<strong class="bold">bash-3.2$ man bash</strong></pre></li>
<li><em class="italic">Scripts</em> of shell commands can be written. These can be called just like compiled programs (that is, just by naming them). For instance, we first create a file in <strong class="source-inline">/bin</strong> containing the following in order to construct a script named <strong class="source-inline">top10.sh</strong> that displays the top 10 biggest files in the <span class="No-Break">current directory:</span><pre class="source-code">
<strong class="bold">#! /bin/bash</strong></pre><pre class="source-code">
<strong class="bold">du -hsx * | sort -rh | head -10</strong></pre></li>
<li>We must next use <a id="_idIndexMarker072"/>the <strong class="source-inline">chmod</strong> command to make the file executable before we can run <span class="No-Break">it normally:</span><pre class="source-code">
<strong class="bold">chmod +x ~/bin/top10.sh</strong></pre><pre class="source-code">
<strong class="bold">./top10.sh</strong></pre></li>
</ul>
<p>See the man page on <strong class="source-inline">bash</strong> for more details (type <span class="No-Break"><strong class="source-inline">man bash</strong></span><span class="No-Break">).</span></p>
<p>The up arrow key on the <a id="_idIndexMarker073"/>keyboard in Bash’s extra mechanism enables you to access and modify past commands. The most recent command is displayed on Terminal again when you press the up arrow key. To access previous commands, press the up arrow key once more. Press <em class="italic">Enter</em> to run the command once more. Use the <em class="italic">Delete</em> key to remove characters from the command’s end, or the back arrow key to move the cursor and change the command’s contents by inserting or <span class="No-Break">deleting characters.</span></p>
<p>By using the <strong class="source-inline">history</strong> command, you can view the history <span class="No-Break">of commands.</span></p>
<p>You can rerun any command from the history by pressing <strong class="source-inline">!</strong> and the line number—for <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">!345</strong></span><span class="No-Break">.</span></p>
<p>Now that you know how to interact with the shell and what is happening when you type these commands, in the next section, we will try to practice some basic commands to make you more confident when you interact <span class="No-Break">with Terminal.</span></p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor037"/>Basic shell commands</h1>
<p>Here’s a rundown of some of the <a id="_idIndexMarker074"/>possible commands. For more information, see the man page for <a id="_idIndexMarker075"/>each command. Using the <strong class="source-inline">man</strong> command, you can view these online. Simply type <strong class="source-inline">man</strong> followed by the command name you wish to see (for example, if you want to learn more about the <strong class="source-inline">cat</strong> command, simply type <span class="No-Break"><strong class="source-inline">man cat</strong></span><span class="No-Break">):</span></p>
<ul>
<li><strong class="source-inline">pwd</strong>: The <strong class="source-inline">pwd</strong> command can be used to determine which directory you are in. Its name is an <a id="_idIndexMarker076"/>abbreviation for <strong class="bold">print working directory</strong>. It provides us with the <a id="_idIndexMarker077"/>absolute path, which is the path that begins at the root. The root directory is the foundation of the Linux filesystem. It’s indicated <a id="_idIndexMarker078"/>by a forward slash (<strong class="source-inline">/</strong>). You can see the <strong class="source-inline">pwd</strong> command in use in the <span class="No-Break">following screenshot:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer008">
<img alt="Figure 2.1 – pwd command, showing the working directory" height="107" src="image/Figure_2.01_B18575.jpg" width="366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – pwd command, showing the working directory</p>
<ul>
<li><strong class="source-inline">mkdir</strong>: <strong class="source-inline">mkdir</strong> is the command to use when you need to make a new directory. Put <strong class="source-inline">mkdir packt</strong> on <a id="_idIndexMarker079"/>your command line to make a directory with that name. To list your created directory, use the <strong class="source-inline">ls –ld &lt;directory_name&gt;</strong> command. You can see the <strong class="source-inline">mkdir</strong> command in <span class="No-Break">use here:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer009">
<img alt="Figure 2.2 – mkdir command" height="122" src="image/Figure_2.02_B18575.jpg" width="870"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – mkdir command</p>
<ul>
<li><strong class="source-inline">rmdir</strong>: To delete a directory, use <strong class="source-inline">rmdir</strong>. However, <strong class="source-inline">rmdir</strong> can only be used to remove an empty <a id="_idIndexMarker080"/>directory. To remove files and directories, use <strong class="source-inline">rm -rf directoryname/</strong> (where <strong class="source-inline">–rf</strong> will recursively remove all the files and directories from <a id="_idIndexMarker081"/>inside the directory). To check whether a directory has been removed, use <strong class="source-inline">ls –ld &lt;directory_name&gt;</strong>. The <strong class="source-inline">rmdir</strong> command is <span class="No-Break">shown here:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer010">
<img alt="Figure 2.3 – rmdir command" height="121" src="image/Figure_2.03_B18575.jpg" width="849"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – rmdir command</p>
<ul>
<li><strong class="source-inline">touch</strong>: The command’s initial <a id="_idIndexMarker082"/>intent was to set the file modification date to the current time. But since it will make a file if one doesn’t already exist, it’s frequently used to make empty files. Here’s <span class="No-Break">an example:</span><pre class="source-code">
<strong class="bold">touch filename.txt</strong></pre></li>
<li><strong class="source-inline">ls</strong>: Use the <strong class="source-inline">ls</strong> command <a id="_idIndexMarker083"/>to see all files and directories inside the directory you are in. If you want to see hidden files, use the <strong class="source-inline">ls -a</strong> command. By using the <strong class="source-inline">ls -la</strong> command, you can see all the files and directories as a list, as <span class="No-Break">illustrated here:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer011">
<img alt="Figure 2.4 – ls command" height="404" src="image/Figure_2.04_B18575.jpg" width="884"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – ls command</p>
<ul>
<li><strong class="source-inline">cp</strong>: To copy files from the command line, use the <strong class="source-inline">cp</strong> command. This requires two arguments: the first <a id="_idIndexMarker084"/>specifies the location of the file to be copied, and the second <a id="_idIndexMarker085"/>specifies where to copy it. It could be a new folder or a new file (in case you need a copy of it). You can see the <strong class="source-inline">cp</strong> command in <span class="No-Break">use here:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer012">
<img alt="Figure 2.5 – cp and ls commands" height="379" src="image/Figure_2.05_B18575.jpg" width="872"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – cp and ls commands</p>
<ul>
<li><strong class="source-inline">mv</strong>: You can use the <strong class="source-inline">mv</strong> command to move a file or directory from one location to another or even to rename <a id="_idIndexMarker086"/>a file. For example, you can rename a file from <strong class="source-inline">file1.txt</strong> to <strong class="source-inline">file2.txt</strong> by running the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">mv file1.txt file2.txt</strong></pre></li>
<li><strong class="source-inline">rm</strong>: <strong class="source-inline">rm</strong> is used to remove files or directories, while the <strong class="source-inline">-r</strong> or <strong class="source-inline">–f</strong> parameter is used to recursively <a id="_idIndexMarker087"/>remove a directory (<strong class="source-inline">-r</strong>) or force remove a file or directory (<strong class="source-inline">-f</strong>). As always, use <strong class="source-inline">man</strong> to find out all the <span class="No-Break">options possible.</span></li>
<li><strong class="source-inline">locate</strong>: The <strong class="source-inline">locate</strong> command is useful when you forget the location of a file. Using the <strong class="source-inline">-i</strong> argument helps <a id="_idIndexMarker088"/>to ignore case sensitivity. So, if you want to find a file <a id="_idIndexMarker089"/>named <strong class="source-inline">file1.txt</strong>, run the <strong class="source-inline">locate -i file1.txt</strong> command. This is the equivalent of search <span class="No-Break">in Windows.</span></li>
</ul>
<p>These are some basic commands that showed you how to list a file, check your working directory, create a directory, copy a file to another file, and so on. In the next section, we will use some more <span class="No-Break">advanced commands.</span></p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor038"/>Intermediate shell commands</h1>
<p>In the previous section, we used some basic commands in order to get used to Terminal. In this section, we will get familiar with more advanced commands, <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="source-inline">echo</strong>: The <strong class="source-inline">echo</strong> command <a id="_idIndexMarker090"/>allows you to display <a id="_idIndexMarker091"/>content that can be added to either a new or an existing file or to replace <span class="No-Break">the content.</span></li>
<li>If you want to add content to an existing file, you can use <strong class="source-inline">echo "content to be appended" &gt;&gt;file1.txt</strong>. Or, you can use <strong class="source-inline">echo "this content will replace" &gt; file1.txt</strong> to replace the content of <span class="No-Break">a file.</span></li>
</ul>
<p>You can see the <strong class="source-inline">echo</strong> command in <span class="No-Break">use here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<img alt="Figure 2.6 – echo command" height="62" src="image/Figure_2.06_B18575.jpg" width="1094"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – echo command</p>
<ul>
<li><strong class="source-inline">cat</strong>: The <strong class="source-inline">cat</strong> command is <a id="_idIndexMarker092"/>normally used to <a id="_idIndexMarker093"/>read the content of a file, as <span class="No-Break">illustrated here:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer014">
<img alt="Figure 2.7 – cat command" height="120" src="image/Figure_2.07_B18575.jpg" width="590"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – cat command</p>
<p>You can use the <strong class="source-inline">cat</strong> command <a id="_idIndexMarker094"/>and append the <a id="_idIndexMarker095"/>output to a new file using <strong class="source-inline">&gt;&gt;</strong>. This is the same for any output—for example, you can use <strong class="source-inline">ls –la &gt;&gt; files-directories.txt</strong> to redirect the result of the <strong class="source-inline">ls –la</strong> command into <span class="No-Break">a file.</span></p>
<ul>
<li><strong class="source-inline">df</strong>: A great command for quickly viewing your filesystem and all mounted drives is the <strong class="source-inline">df</strong> command (which stands for <em class="italic">disk-free</em>). You can see the overall disk size, the amount of space <a id="_idIndexMarker096"/>used, the amount of space <a id="_idIndexMarker097"/>available, the utilization percentage, and the partition that the disk is mounted on. I advise using it along with the <strong class="source-inline">-h</strong> parameter to make the data legible by humans. The data that you see here was derived from the filesystem level or <span class="No-Break">mount point:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer015">
<img alt="Figure 2.8 – df command" height="375" src="image/Figure_2.08_B18575.jpg" width="822"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – df command</p>
<ul>
<li><strong class="source-inline">du</strong>: When used <a id="_idIndexMarker098"/>appropriately, the <strong class="source-inline">du</strong> command (which stands for disk usage) works great. When you <a id="_idIndexMarker099"/>need to know the size of a specific directory or subdirectory, this command excels. It only reports on the supplied stats at the time of execution and operates at the object level. For instance, you can <a id="_idIndexMarker100"/>use the <strong class="source-inline">du -sh /Documents</strong> command to find <a id="_idIndexMarker101"/>out how much disk space Linux’s <strong class="source-inline">Documents</strong> folder consumes. This command works well when combined with the <strong class="source-inline">-sh</strong> flags to provide a summary of a given item in human-readable form (the directory and all subdirectories). You can see the <strong class="source-inline">du</strong> command in <span class="No-Break">use here:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer016">
<img alt="Figure 2.9 – du command" height="96" src="image/Figure_2.09_B18575.jpg" width="694"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – du command</p>
<ul>
<li><strong class="source-inline">uname</strong>: The <strong class="source-inline">uname</strong> command displays information regarding the operating system that your Linux distribution <a id="_idIndexMarker102"/>is currently using. The <a id="_idIndexMarker103"/>majority of the information on the system can be printed by using the <strong class="source-inline">uname -a</strong> command. This displays the kernel release date, the version, the processor type, and other related information. You can see the <strong class="source-inline">uname</strong> command in <span class="No-Break">use here:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer017">
<img alt="Figure 2.10 – uname command" height="67" src="image/Figure_2.10_B18575.jpg" width="1086"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – uname command</p>
<ul>
<li><strong class="source-inline">chmod</strong>: The system call and command used to modify the special mode flags and access permissions <a id="_idIndexMarker104"/>of filesystem <a id="_idIndexMarker105"/>objects are called <strong class="source-inline">chmod</strong>. These were first referred to collectively as its modes, and the name <strong class="source-inline">chmod</strong> was chosen as an acronym for change mode (more details about this in <a href="B18575_07.xhtml#_idTextAnchor118"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">User and </em><span class="No-Break"><em class="italic">Group Management</em></span><span class="No-Break">).</span></li>
</ul>
<p>Let’s imagine you wish to change the permissions of a file called <strong class="source-inline">file1.txt</strong> so that the following <span class="No-Break">is possible:</span></p>
<ul>
<li>The user can execute, read, and <span class="No-Break">write it</span></li>
<li>Those in your group can read it and <span class="No-Break">use it</span></li>
<li>Others may only <span class="No-Break">read it</span></li>
</ul>
<p>This command does <span class="No-Break">the trick:</span></p>
<pre class="source-code">
<strong class="bold">chmod u-rwx,g=rx,o=r file1.txt</strong></pre>
<p>The symbolic permissions <a id="_idIndexMarker106"/>notation is used <a id="_idIndexMarker107"/>in this example. <strong class="source-inline">u</strong>, <strong class="source-inline">g</strong>, and <strong class="source-inline">o</strong> stand for <em class="italic">user</em>, <em class="italic">group</em>, and <em class="italic">other</em>, respectively. The letters <strong class="source-inline">r</strong>, <strong class="source-inline">w</strong>, and <strong class="source-inline">x</strong> stand for <em class="italic">read</em>, <em class="italic">write</em>, and <em class="italic">execute</em>, respectively, while the equals sign (<strong class="source-inline">=</strong>) signifies <em class="italic">establish the permissions precisely like this</em>. There are no spaces between the various authorization classes; only commas are used to <span class="No-Break">divide them.</span></p>
<p>Here is the equivalent command using octal <span class="No-Break">permissions notation:</span></p>
<pre class="source-code">
<strong class="bold">chmod 754 file1.txt</strong></pre>
<p>Here, the numbers <strong class="source-inline">7</strong>, <strong class="source-inline">5</strong>, and <strong class="source-inline">4</strong> stand for the user, group, and other permissions, respectively, in that sequence. Each digit is made up of the digits <strong class="source-inline">4</strong>, <strong class="source-inline">2</strong>, <strong class="source-inline">1</strong>, and <strong class="source-inline">0</strong>, which denote <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="source-inline">4</strong> stands <span class="No-Break">for </span><span class="No-Break"><em class="italic">read</em></span></li>
<li><em class="italic">Write</em> has the <span class="No-Break">prefix </span><span class="No-Break"><strong class="source-inline">2</strong></span></li>
<li><strong class="source-inline">1</strong> <span class="No-Break">denotes </span><span class="No-Break"><em class="italic">execute</em></span></li>
<li><strong class="source-inline">0</strong> means <span class="No-Break"><em class="italic">no authorization</em></span></li>
</ul>
<p>Therefore, <strong class="source-inline">7</strong> is made up of the permissions <strong class="source-inline">4</strong>+<strong class="source-inline">2</strong>+<strong class="source-inline">1</strong> (read, write, and execute), <strong class="source-inline">5</strong> (read, no write, and execute), and <strong class="source-inline">4</strong> (read, no write, and <span class="No-Break">no execute).</span></p>
<ul>
<li><strong class="source-inline">chown</strong>: To change the owner of system files and directories on Unix and Unix-like operating systems, use the <strong class="source-inline">chown</strong> command. This will change the ownership to the user (<strong class="source-inline">voxsteel</strong>) and <a id="_idIndexMarker108"/>group (<strong class="source-inline">voxsteel</strong>) for a specified <a id="_idIndexMarker109"/>filename or directory, as <span class="No-Break">illustrated here:</span><pre class="source-code">
<strong class="bold">chown voxsteel:voxsteel &lt;filename or directory name&gt;</strong></pre></li>
</ul>
<p>Use <strong class="source-inline">chgrp</strong> if you’re a non-privileged user and want to modify the group membership of a file <span class="No-Break">you own.</span></p>
<ul>
<li><strong class="source-inline">chgrp</strong>: A filesystem <a id="_idIndexMarker110"/>object’s group can be <a id="_idIndexMarker111"/>changed to one to which they belong using the <strong class="source-inline">chgrp</strong> command, as illustrated in the following snippet. Three sets of access permissions are available for a filesystem object: one for owner, one for  group, and one <span class="No-Break">for others:</span><pre class="source-code">
<strong class="bold">chgrp groupname &lt;filename&gt; (or directory name)</strong></pre></li>
</ul>
<p>Searching the man pages with keywords can help you find a command even if you’ve forgotten its name. The <strong class="source-inline">man -k</strong> keyword is the syntax to use. Running this command on Terminal, for <a id="_idIndexMarker112"/>instance, will list <span class="No-Break">Terminal-specific commands.</span></p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor039"/>Summary</h1>
<p>Redirection, Bash history, command aliases, command-line trickery, and more were some of the more sophisticated ideas related to shell commands that we covered in this chapter. Don’t worry if you’re having problems memorizing everything; it’s normal to feel overwhelmed by the amount of information presented here at first. I’ve been using Linux professionally for over 15 years, and I still don’t know everything there is to know <span class="No-Break">about it.</span></p>
<p>In the next chapter, we will talk about filesystems, the differences between them, and the structure of the main system directories and what are they <span class="No-Break">used for.</span></p>
</div>
</div></body></html>