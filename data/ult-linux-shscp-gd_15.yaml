- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Using awk – Part 2
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 awk —— 第二部分
- en: 'In this chapter, we’ll continue the discussion about `awk`, but from a different
    perspective. In the previous chapter, I showed you the basics of creating one-line
    `awk` commands that you can use in your normal shell scripts. In this chapter,
    I’ll show you a bit about how to write `awk` scripts in the `awk` language. Topics
    in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从不同的角度继续讨论 `awk`。在上一章中，我向你展示了如何创建可以在普通 shell 脚本中使用的单行 `awk` 命令。在本章中，我将向你展示如何用
    `awk` 语言编写 `awk` 脚本。本章的内容包括：
- en: Basic `awk` script construction
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的 `awk` 脚本构建
- en: Using conditional statements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件语句
- en: Using a `while` construct and setting variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `while` 结构并设置变量
- en: Using for loops and arrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 for 循环和数组
- en: Using floating point math and `printf`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浮动点数学和 `printf`
- en: Working with multi-line records
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多行记录
- en: If you’re ready, let’s dig in.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你准备好了，让我们深入探讨。
- en: Technical Requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can use either a Fedora or Debian virtual machine for this. And, as always,
    you can grab the scripts by doing:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Fedora 或 Debian 虚拟机来执行这个操作。而且，和往常一样，你可以通过以下方式获取脚本：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Basic awk Script Construction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的 awk 脚本构建
- en: 'Let’s begin with the simplest `awk` script that you can imagine, which we’ll
    call `awk_kernel1.awk`. It looks like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从你能想象的最简单的 `awk` 脚本开始，我们将其命名为 `awk_kernel1.awk`。它看起来像这样：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you’ve likely guessed, this script will look through a specified file to
    search for all lines that contain the text string `kernel`. You already know that
    `{print $0}` is the default action if no action is specified. So, this script
    will print out every line that contains the specified text string.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，这个脚本会查看指定的文件，搜索包含文本字符串 `kernel` 的所有行。你已经知道，如果没有指定操作，`{print $0}`
    是默认操作。因此，这个脚本将打印出包含指定文本字符串的每一行。
- en: 'In actual `awk` scripts, there’s no need to preface every command with `awk`,
    and there’s no need to surround the commands with pairs of single quotes, as you
    have to do when embedding `awk` commands in normal shell scripts. I didn’t put
    a shebang line into this script, so there’s no need to set the executable permission.
    Instead, just invoke the script like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的 `awk` 脚本中，不需要在每个命令前加上 `awk`，也不需要像在普通的 shell 脚本中嵌入 `awk` 命令时那样，用单引号括起来。我没有在这个脚本中加入
    shebang 行，因此不需要设置可执行权限。相反，只需像这样调用脚本：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sure, that works. But, wouldn’t you really rather have a stand-alone, executable
    script? That’s easy enough to do. Just add the shebang line, like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这样也可以。但你不觉得还是更希望有一个独立的、可执行的脚本吗？这其实很简单。只需添加 shebang 行，像这样：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then, make the script executable, the same as you would do with normal `bash`
    scripts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使脚本可执行，就像你处理普通的`bash`脚本一样。
- en: There are two things that I want you to notice about this shebang line. First,
    is that I’m using `/usr/bin/` instead of `/bin/` as the path to the `awk` executable.
    That’s because I want to make this script portable, so that it will run on Linux,
    Unix, and Unix-like systems such as FreeBSD and macOS.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件事我希望你注意到这个 shebang 行。首先，我使用的是 `/usr/bin/` 而不是 `/bin/` 作为 `awk` 可执行文件的路径。这是因为我想让这个脚本具备可移植性，这样它就可以在
    Linux、Unix 以及像 FreeBSD 和 macOS 这样的 Unix-like 系统上运行。
- en: The `/bin/` path that you’re used to seeing in shebang lines is an artifact
    that’s been carried over from older Linux systems. On current Linux systems, `/bin/`
    is a symbolic link that points to `/usr/bin/`. On older Linux systems, `/bin/`
    and `/usr/bin/` used to be two separate directories, which each contained two
    separate sets of program files. That’s no longer the case. Nowadays, you’ll find
    the `awk` executable in `/usr/bin/` on all Linux systems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你习惯在 shebang 行中看到的 `/bin/` 路径，实际上是一个遗留物，它来自较早的 Linux 系统。在当前的 Linux 系统中，`/bin/`
    是指向 `/usr/bin/` 的符号链接。在旧版 Linux 系统中，`/bin/` 和 `/usr/bin/` 曾经是两个独立的目录，每个目录都包含各自的程序文件集。现在已经不是这样了。如今，你会发现在所有
    Linux 系统中，`awk` 可执行文件都位于 `/usr/bin/` 中。
- en: FreeBSD still uses separate `/bin/` and `/usr/bin/` directories with different
    sets of program files. But, `awk` is in `/usr/bin/`, and there’s no symbolic link
    for it in `/bin/`. So, just use `#!/usr/bin/awk`, and you’ll be good-to-go for
    most operating systems.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 仍然使用独立的 `/bin/` 和 `/usr/bin/` 目录，其中包含不同的程序文件集。但 `awk` 位于 `/usr/bin/`
    中，并且在 `/bin/` 中没有它的符号链接。因此，只需使用 `#!/usr/bin/awk`，大多数操作系统就能正常运行。
- en: The second thing to notice is that I still have to invoke `awk` with the `-f`
    option, which causes `awk` to read the program file. If you leave out the `-f`,
    the script won’t work.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二件事要注意的是，我仍然需要使用`-f`选项来调用`awk`，这样`awk`才会读取程序文件。如果你省略了`-f`，脚本将无法运行。
- en: Now that you’ve seen the basic structure of an `awk` script, let’s look at some
    `awk` programming constructs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了`awk`脚本的基本结构，接下来我们来看看一些`awk`编程结构。
- en: Using Conditional Statements
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用条件语句
- en: 'You’ve already been using `if` constructs without even knowing it. That’s because
    you don’t have to explicitly declare them as such. The simple `/kernel/` command
    that you just saw in the `awk_kernel1.awk` script means that if the *kernel* string
    is found on a line, then print that line. However, `awk` also offers the whole
    array of programming constructs that you would expect to see in other languages.
    For example, let’s create the `awk_kernel2.awk` script, which will look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你其实已经在使用`if`语句了，只是你可能没有意识到。因为你不需要明确声明它们。你在`awk_kernel1.awk`脚本中看到的简单`/kernel/`命令意味着，如果在某行中找到*kernel*字符串，就打印该行。然而，`awk`还提供了你在其他编程语言中会看到的完整编程结构。例如，我们来创建`awk_kernel2.awk`脚本，内容如下：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is somewhat different from what you’re used to seeing in `bash` scripts,
    because in `awk` there’s no need to use `then` or `fi` statements. This is because
    `awk` uses C language syntax for its programming constructs. So, if you’re used
    to programming in C, rejoice!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这和你在`bash`脚本中习惯看到的有所不同，因为在`awk`中，不需要使用`then`或`fi`语句。这是因为`awk`使用C语言语法来编写编程结构。所以，如果你习惯用C语言编程，那就高兴吧！
- en: 'Also, note how you need to surround the pattern with a pair of parentheses,
    and how you have to surround the entire multi-line script with a pair of curly
    braces. At any rate, just specify the name and location of your log file when
    running the script, like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意如何需要将模式用一对括号括起来，以及如何必须用一对花括号将整个多行脚本括起来。无论如何，在运行脚本时，只需指定你的日志文件的名称和位置，像这样：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, you’re probably wondering why anyone would want to do the extra typing
    to create a full-blown `if` construct when just typing `/kernel/` will do the
    job. Well, it’s so that you can create full-blown `if. .else` constructs, like
    this one in the `awk_kernel3.awk` script:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想，为什么有人会想输入额外的代码来创建一个完整的`if`语句结构，而仅仅输入`/kernel/`就能完成任务呢？原因是这样可以创建完整的`if.
    .else`结构，就像在`awk_kernel3.awk`脚本中的这个结构：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let’s see how many times each type of message shows up in the log file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看每种类型的消息在日志文件中出现的次数：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Cool, it works.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，它工作了。
- en: 'For our final `if` trick, let’s create the `awk_kernel4.awk` script, like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最后一个`if`技巧，让我们创建`awk_kernel4.awk`脚本，如下所示：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The Number of Records (`NR`) built-in variable causes the line numbers to print
    out along with the messages. There will be lots of output, so you might want to
    pipe it into `less`, like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 记录数（`NR`）内建变量会将行号和消息一起打印出来。输出会很多，你可能需要将其管道传送到`less`，像这样：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s a sample of the output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出的示例：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Okay, I think you get the idea. Other than the different syntax, it’s really
    no different from using `if` in normal `bash` scripts. So, let’s move on for a
    while.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想你已经明白了。除了语法不同外，它其实和在普通`bash`脚本中使用`if`没有什么不同。所以，接下来我们继续。
- en: Using a while Construct and Setting Variables
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`while`结构并设置变量
- en: In this section, I’ll show you two new concepts at once. You’ll see how to use
    a `while` loop, and how to use `awk` programming variables. Let’s begin with something
    simple.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我将同时介绍两个新概念。你将看到如何使用`while`循环，以及如何使用`awk`编程变量。让我们从简单的开始。
- en: Summing Numbers in a Line
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 求一行中的数字和
- en: 'In this scenario, we have a file with several lines of numbers. We want to
    add the numbers on each line and show the sum for each line. First, create the
    input file and make it look something like this `numbers_fields.txt` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们有一个包含几行数字的文件。我们希望将每一行的数字相加，并显示每一行的总和。首先，创建输入文件并使其看起来像这样`numbers_fields.txt`文件：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This looks like quite a challenging task because each line has a different
    number of fields. But, it’s actually quite easy. Here’s the `add_fields.awk` script
    that does the job:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是一个相当具有挑战性的任务，因为每一行的字段数量不同。但实际上，这个任务非常简单。下面是执行此任务的`add_fields.awk`脚本：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first thing I’ve done is to initialize the `addend` and `sum` variables.
    The `addend` variable represents the field numbers. By initializing it to a value
    of `1`, the script will always begin at the first field of every line. The `sum`
    variable is initialized to `0`, for obvious reasons. The `while (addend <= NF)`
    line causes the `while` loop to execute until it reaches the last field in a line.
    (The built-in `NF` variable holds the number of fields in a given line.) In the
    next line, using `$addend` is the same as listing a field number, such as `$1`
    or `$2`. So, as you might expect, `$addend` returns the value that’s contained
    in a given field. By using a variable in place of a hard-coded field number, we
    can use the `addend++` command in the next line to advance to the next field in
    a line. (This `variable++` construct increments the value of the variable by 1,
    the same as it does in C.)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我做的第一件事是初始化`addend`和`sum`变量。`addend`变量表示字段号。通过将其初始化为`1`，脚本将始终从每行的第一个字段开始。`sum`变量被初始化为`0`，这是显而易见的。`while
    (addend <= NF)`这一行使得`while`循环会一直执行，直到到达行中的最后一个字段。（内建变量`NF`保存当前行中的字段数。）在下一行，使用`$addend`与列出字段号（例如`$1`或`$2`）是一样的。因此，正如你所预期的，`$addend`返回的是给定字段中包含的值。通过使用变量代替硬编码的字段号，我们可以在下一行使用`addend++`命令来进到下一字段。（这种`variable++`结构会将变量的值增加1，和
    C 语言中一样。）
- en: If you’re a bit confused by this, allow me to clarify.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个有些困惑，请允许我进一步说明。
- en: Unlike in normal shell scripting, in `awk`, you don’t preface the name of a
    variable with a `$` to call back its value. In `awk`, the `$` is instead used
    to reference the number of a field. So, prefacing a variable name with a `$` in
    `awk` just means that you’re referencing the field number that’s been assigned
    to that variable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通的 shell 脚本不同，在`awk`中，你不需要在变量名前加上`$`来引用其值。在`awk`中，`$`用于引用字段的编号。因此，在`awk`中给变量名前加`$`，意味着你引用的是分配给该变量的字段号。
- en: 'After the `while` loop finishes, the script prints out its message, with the
    sum of all the numbers on a line. Then, it returns to the beginning of the script
    and keeps going until all lines in the file have been processed. Here’s what the
    output looks like:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环结束后，脚本会输出其信息，并显示一行中所有数字的总和。然后，它返回脚本的开头，继续执行，直到文件中的所有行都被处理完。输出如下：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It works, so everything is cool. Now, let’s fancy things up a bit. Let’s add
    a line that will produce the average of the numbers on each line and format the
    output. Name the file `average_fields.awk`, and make it look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它能正常工作，一切都很顺利。现在，让我们做一些改进。添加一行代码，计算每行数字的平均值并格式化输出。将文件命名为`average_fields.awk`，并使其如下所示：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'What’s so cool about this is that I can use the `NF` built-in variable in math
    operations. In this case, I’m just dividing the sum of each line by the number
    of fields in each line. The output looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常酷，因为我可以在数学运算中使用`NF`内建变量。在这种情况下，我只是将每行的总和除以每行的字段数。输出如下：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you’re used to C programming, understand that there’s a difference between
    how `awk` and C use variables. Unlike in C, it’s not necessary to declare `awk`
    variables before you use them. But, it is sometimes necessary to initialize them
    to a certain value before you use them. Also, unlike in C, there’s only one variable
    type in `awk`. All `awk` variables are of the string type, and all `awk` math
    operators automatically recognize numerical values that these variables might
    represent.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了 C 语言编程，请理解`awk`和 C 在使用变量上的区别。与 C 不同，在`awk`中，你不需要在使用变量之前声明它们。然而，有时确实需要在使用之前将它们初始化为某个特定值。此外，与
    C 不同的是，`awk`中只有一种变量类型。所有`awk`变量都是字符串类型，所有`awk`数学运算符会自动识别这些变量可能代表的数值。
- en: Next, let’s look at something a bit more complex.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一些稍微复杂的内容。
- en: Finding the CPU Generation
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找 CPU 世代
- en: Let’s consider another scenario. You have an old server that’s powered by an
    AMD Opteron CPU. You just tried to install Red Hat Enterprise Linux 9 (RHEL 9)
    on it, and you can’t get it to work. What could be the problem?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一种情况。你有一台老旧的服务器，搭载的是 AMD Opteron CPU。你刚刚尝试在其上安装 Red Hat Enterprise Linux
    9（RHEL 9），但无法成功安装。问题可能出在哪里？
- en: 'Well, it’s just that your trusty Opteron CPU is too old, which means that it
    lacks certain capabilities that newer CPUs have. Ever since AMD created the first
    64-bit x86 CPUs in 2003, both AMD and Intel have kept adding new capabilities
    to their newer models. In 2020, representatives from Intel, AMD, Red Hat, and
    SUSE got together and defined the four generations of x86_64\. Each successive
    generation has capabilities that aren’t in the previous generations. Here’s a
    list of when each generation was introduced:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其实，就是因为你那颗可靠的Opteron CPU太旧了，这意味着它缺少了新一代CPU的一些功能。自从AMD在2003年推出第一款64位x86 CPU以来，AMD和英特尔一直在为其新型号增加新的功能。2020年，英特尔、AMD、Red
    Hat和SUSE的代表们聚集在一起，定义了x86_64的四个代次。每个新的代次都包含上一代没有的功能。以下是每一代发布的时间：
- en: 'Generation 1: 2003'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一代：2003年
- en: 'Generation 2: 2009'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二代：2009年
- en: 'Generation 3: 2013 for Intel, 2015 for AMD'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三代：2013年发布的英特尔，2015年发布的AMD
- en: 'Generation 4: 2017 for Intel, 2022 for AMD'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四代：2017年发布的英特尔，2022年发布的AMD
- en: Software that was created for a first generation x86_64 CPU will also run fine
    on the three newer generations. But, if you have a newer CPU, you can make things
    run faster by using software that was optimized for it. Of course, that means
    that it won’t run on the older CPUs. So, if you’re still running a first generation
    x86_64 CPU, you won’t be able to run either RHEL 9 or any of its clones. (Rumor
    has it that RHEL 10, which should be out sometime in 2025, will require at least
    a third generation x86_64 CPU. You’ll find a link to the rumor in the *Further
    Reading* section.) That’s actually okay, because Red Hat’s target customers are
    the large enterprises that upgrade their gear on a regular basis.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为第一代x86_64 CPU创建的软件也可以在后三代CPU上正常运行。但是，如果你拥有更新的CPU，你可以通过使用专门为其优化的软件来提升性能。当然，这也意味着它无法在旧版CPU上运行。因此，如果你仍在使用第一代x86_64
    CPU，你将无法运行RHEL 9或任何它的克隆版本。（有传言称，RHEL 10将至少需要第三代x86_64 CPU，预计将在2025年某个时候发布。你可以在*进一步阅读*部分找到关于这一传闻的链接。）其实这也没关系，因为Red
    Hat的目标客户是那些定期更新设备的大型企业。
- en: This makes it very unlikely that any of them still run any of these first generation
    machines. This doesn’t really affect normal home users of desktop Linux, because
    very few home users use either RHEL or a RHEL clone for that purpose, and most
    non-RHEL distros still support the old machines. So, how do you know which generation
    your CPU is? That’s easy. Just write a script.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得几乎不可能有任何设备仍在运行这些第一代机器。对于普通的桌面Linux用户来说，这并不会造成太大影响，因为很少有家庭用户会使用RHEL或其克隆版本，且大多数非RHEL发行版仍然支持旧机器。那么，如何知道你的CPU属于哪一代呢？很简单，写一个脚本。
- en: 'To get an idea of how this works, look in the `/proc/cpuinfo` file, and scroll
    down to the `flags` section. What you’ll see depends upon which generation of
    x86_64 CPU is in your machine. Here on my 2012-model Dell workstation with an
    Intel Xeon CPU that’s of the second generation x86_64 variety, the `flags` section
    looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这一过程的工作原理，可以查看`/proc/cpuinfo`文件，并滚动到`flags`部分。你看到的内容将取决于你机器中的x86_64 CPU属于哪一代。这里是我那台2012年款戴尔工作站上的Intel
    Xeon CPU的`flags`部分，它是第二代x86_64架构：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On my vintage 2009-model Hewlett-Packard machine with a pair of first generation
    Opteron CPUs, the `flags` section looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的那台2009年款的惠普老机器上，它配有一对第一代Opteron CPU，`flags`部分如下所示：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You see here that the second generation CPU in my Dell has newer capabilities,
    such as `sse4_1`, `sse4_2`, and a few others that aren’t in the old Opterons.
    On a Linux system, you can create either a `bash` script or an `awk` script that
    will automatically parse the `/proc/cpuinfo` file to determine the generation
    to which your CPU belongs. Here’s the `x86_64_check.awk` script, which I borrowed
    from a post on the StackExchange site:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我的戴尔电脑上的第二代CPU拥有更新的功能，例如`sse4_1`、`sse4_2`，以及一些旧版Opteron所不具备的其他特性。在Linux系统中，你可以创建一个`bash`脚本或`awk`脚本，它会自动解析`/proc/cpuinfo`文件，从而确定你的CPU属于哪个代次。下面是我从StackExchange网站的一篇帖子中借来的`x86_64_check.awk`脚本：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first thing to note is that the whole script needs to be part of a `BEGIN`
    block. That’s because we need to process the whole `cpuinfo` file at once, instead
    of just one line at a time as `awk` would normally do. The `BEGIN` block helps
    us out with that.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要注意的是，整个脚本必须放在`BEGIN`块中。这是因为我们需要一次性处理整个`cpuinfo`文件，而不是像`awk`通常那样逐行处理。`BEGIN`块帮助我们完成这项任务。
- en: Then, note that this script uses a different style for the `if` constructs.
    Instead of formatting them in the C language style as I showed you before, the
    author instead placed each `if` construct on its own line. Each style works equally
    well, and I’ll leave it to you to decide which one you like better. Anyway, here’s
    the breakdown of how it all works.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，请注意这个脚本使用了不同风格的 `if` 结构。与我之前给你展示的 C 语言风格不同，作者将每个 `if` 结构单独放在一行。两种风格都可以正常工作，接下来我留给你决定你喜欢哪一种。总之，这里是它如何工作的详细说明。
- en: At the end of each of the first four `if` statements, the `level` variable is
    set to a new value.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前四个 `if` 语句的末尾，`level` 变量会被设置为新的值。
- en: The first `if` statement looks for capabilities that are in the first generation,
    and then assigns `1` as the value of `level`.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个 `if` 语句查找第一代的功能，然后将 `1` 赋值给 `level`。
- en: The second `if` statement verifies that the CPU contains level 1 capabilities,
    looks for another set of capabilities that are in second generation CPUs, and
    then assigns `2` as the value of `level`.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个 `if` 语句验证 CPU 是否包含一级功能，查找第二代 CPU 的另一组功能，然后将 `2` 赋值给 `level`。
- en: The process repeats for the third and fourth `if` statements, in order to detect
    either third or fourth generation CPUs.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该过程会重复执行第三和第四个 `if` 语句，用于检测第三代或第四代的 CPU。
- en: Finally, the fifth `if` statement verifies that the value of `level` is greater
    than `0`, prints out the message, and then exits the script with an exit code
    that’s the value of `level` plus 1.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，第五个 `if` 语句验证 `level` 的值是否大于 `0`，打印出消息，然后以 `level` 加 1 的值作为退出码退出脚本。
- en: The `exit 1` line at the end causes the script to exit with exit code `1` if
    the script fails to run correctly for whatever reason. (The `level + 1` command
    at the end of the fourth `if` statement prevents a successful run of the program
    from returning a `1` for the exit code. Remember, `1` is normally an exit code
    for a program that doesn’t run correctly.)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exit 1` 行的作用是，如果脚本因任何原因无法正确运行，则会以退出码 `1` 退出脚本。（第四个 `if` 语句末尾的 `level + 1`
    命令防止程序成功运行时返回 `1` 作为退出码。记住，`1` 通常是表示程序未正确运行的退出码。）'
- en: 'An interesting thing about `awk` variables is that all of them are string variables,
    which greatly simplifies the coding process. If you assign the value of `1` to
    the `level` variable, the value is stored as a string instead of as an integer.
    But, when you use variables to perform math operations in `awk`, everything works
    correctly because `awk` automatically recognizes when a string is really a number.
    Also, unlike `bash`, `awk` can natively perform floating point math operations.
    So, you can perform math operations much easier and faster in `awk` than you can
    in either `bash` scripting or a normal programming language. To demonstrate this,
    let’s run this script on my both of the workstations that I currently have running.
    Here’s what it looks like on my old Opteron-powered Hewlett-Packard:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `awk` 变量的一件有趣的事情是，它们都是字符串变量，这大大简化了编码过程。如果你将值 `1` 赋给 `level` 变量，该值会作为字符串存储，而不是整数。但是，当你使用变量进行数学运算时，`awk`
    会自动识别字符串是否是数字，因此一切都会正常工作。另外，与 `bash` 不同，`awk` 原生支持浮点数运算。所以，你可以比在 `bash` 脚本或普通编程语言中更轻松、更快速地进行数学运算。为了演示这一点，让我们在我目前运行的两台工作站上运行这个脚本。这是我那台使用
    Opteron 处理器的惠普机器上运行的情况：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As expected, the script shows that this is a first generation x86_64 machine.
    The `echo $?` command shows the exit code, which was created by the `level + 1`
    command in the script. Now, here’s how it looks on my Xeon-powered Dell:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，脚本显示这是一个第一代 x86_64 机器。`echo $?` 命令显示退出码，这是由脚本中的 `level + 1` 命令生成的。现在，这就是我那台使用
    Xeon 处理器的戴尔机器上的情况：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So yeah, everything works fine.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，是的，一切运行正常。
- en: Ah, but wait. We’re not done yet, because I haven’t yet explained the `while`
    construct. It’s a bit tricky, so I saved it for last.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，不过等等，我们还没完，因为我还没有解释 `while` 结构。这个有点复杂，所以我把它留到最后讲。
- en: 'I’ve already shown you that in the `/proc/cpuinfo` file, the strings that you
    seek are in the stanza with the text string `flags` in the first field. But, the
    `while (!/flags/)` statement makes it appear that we’re *not* looking for the
    `flags` stanza. (Remember that the `!` is a negation operator.) To understand
    what’s really going on, view the entire `cpuinfo` file by entering `cat /proc/cpuinfo`.
    You’ll see that the same set of information prints out once for every CPU core
    in your system. For example, my Dell workstation is running with an octo-core
    Xeon. Hyperthreading is enabled, which means that I have a total of 16 virtual
    CPU cores. So, running `cat /proc/cpuinfo` causes the same CPU information to
    print 16 times. You’ll also see that several more stanzas of information print
    out after the `flags` stanza. To understand how this `while` loop works, run the
    following one-line `awk` command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经向你展示过，在 `/proc/cpuinfo` 文件中，你要查找的字符串在第一字段包含 `flags` 字符串的段落中。但是，`while (!/flags/)`
    语句让人看起来像是我们*没有*在寻找 `flags` 段落。（记住，`!` 是取反运算符。）要理解发生了什么，查看整个 `cpuinfo` 文件，可以通过输入
    `cat /proc/cpuinfo` 来实现。你会看到相同的信息会为你系统中的每个 CPU 核心打印一次。例如，我的戴尔工作站配备了一个八核 Xeon 处理器，启用了超线程技术，这意味着我总共有
    16 个虚拟 CPU 核心。因此，运行 `cat /proc/cpuinfo` 会导致相同的 CPU 信息打印 16 次。你还会看到在 `flags` 段之后会打印出更多的信息段。要理解这个
    `while` 循环的工作原理，可以运行以下单行的 `awk` 命令：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `flags` stanza is actually just a single long line that wraps around on
    both your terminal and on the printed page. So, `awk` treats the `flags` line
    as a single record. The `while (!/flags/)` statement in this command causes `getline`
    to read the `cpuinfo` file until it encounters the first `flags` string. This
    means that the CPU information for only the first CPU core will show up, and any
    information that comes after the first `flags` line will not show up. (Yeah, it
    looks a bit confusing, but it makes total sense when you think about it.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`flags` 这一段实际上只是一个很长的单行，它会在你的终端和打印页面上换行。因此，`awk` 将 `flags` 行视为单个记录。这个命令中的 `while
    (!/flags/)` 语句使得 `getline` 会读取 `cpuinfo` 文件，直到遇到第一个 `flags` 字符串为止。这意味着只有第一个 CPU
    核心的 CPU 信息会显示出来，任何在第一个 `flags` 行之后的信息都不会显示。（是的，看起来有点困惑，但仔细想一想就能明白。）'
- en: In the original script, the `if (getline < "/proc/cpuinfo" != 1) exit 1` that’s
    within the `while` loop does two things for us. First, it uses the `!=1` parameter
    to check for the existence of the `cpuinfo` file. If `!=1`, which is the same
    as saying *not true*, evaluates to *true,* then the script will exit with exit
    code `1`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始脚本中，`while` 循环中的 `if (getline < "/proc/cpuinfo" != 1) exit 1` 做了两件事。首先，它使用
    `!=1` 参数检查 `cpuinfo` 文件是否存在。如果 `!=1`，也就是相当于说 *不正确*，其结果为 *正确* 时，脚本会以退出码 `1` 退出。
- en: If the `!=1` parameter evaluates to *false*, which would mean that the file
    exists, then `getline`, a built-in `awk` function, will read in the `cpuinfo`
    file. This way, if you run this script on an operating system that doesn’t have
    a `/proc/cpuinfo` file, such as FreeBSD, it will gracefully exit.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `!=1` 参数的结果为 *假*，即文件存在，那么 `getline`，一个内置的 `awk` 函数，会读取 `cpuinfo` 文件。这样，如果你在没有
    `/proc/cpuinfo` 文件的操作系统（如 FreeBSD）上运行此脚本，它会优雅地退出。
- en: 'Now, some of you might prefer using C-style syntax to make the script a bit
    more readable. Fortunately, that’s easy to do. Changing the style makes the script
    too long to show here in its entirety, but I can show you a snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有些人可能更喜欢使用 C 风格的语法来让脚本更易读。幸运的是，这很容易做到。改变语法会使脚本变得太长，无法在这里完整展示，但我可以给你看一小段代码：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you want to see the converted script in its entirety, just download the `x86-64-level_check2.awk`
    file from GitHub.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看完整的转换脚本，只需从 GitHub 下载 `x86-64-level_check2.awk` 文件。
- en: I believe that we’re done with this script. Let’s see what we can do with a
    `for` loop and an array.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们已经完成了这个脚本。让我们看看如何使用 `for` 循环和数组。
- en: Using for loops and Arrays
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `for` 循环和数组
- en: Certain languages, such as Spanish and French, have the concept of masculine
    and feminine nouns. For this demo, we’ll work with a list of English nouns, their
    Spanish equivalents, and the gender designations for the Spanish nouns.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言，如西班牙语和法语，具有阳性和阴性名词的概念。在这个演示中，我们将使用一组英文名词、它们在西班牙语中的对应词以及西班牙语名词的性别标注。
- en: Why is someone with a French last name creating a list of Spanish words? Well,
    it’s just that despite my French ancestry, I chose to learn Spanish instead of
    French in high school. So, I do know some Spanish, but I don’t know French. (I
    know, I’m weird.) Also, I realize that the Spanish word *camiόn* has an accent
    over the last syllable. Alas, inserting accents with an English-language keyboard
    isn’t easily done in a plain-text file, at least not without messing up how the
    `awk` script works.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么一个法国姓氏的人在创建西班牙语单词列表？嗯，尽管我有法国血统，但我在高中选择学习西班牙语而非法语。所以，我会一些西班牙语，但我不会法语。（我知道，我有点怪。）此外，我也意识到西班牙语单词*camiόn*的最后一个音节上有一个重音符号。可惜的是，在英语键盘上插入重音符号并不容易，特别是在纯文本文件中，至少不使用`awk`脚本时，不会破坏其工作。
- en: 'To begin, create the `spanish_words.txt` file, and make it look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建`spanish_words.txt`文件，并使其如下所示：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you see, we’re using colons as field separators, and using either M or F
    to designate if a word is masculine or feminine. The first line is a header, so
    we’ll need to take that into account when we process the file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用冒号作为字段分隔符，并用`M`或`F`来表示单词是阳性还是阴性。第一行是表头，因此我们在处理文件时需要考虑到这一点。
- en: 'Next, create the `masc-fem.awk` script, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`masc-fem.awk`脚本，如下所示：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `BEGIN` section, we’re setting the `:` as the field separator. The `NR
    == 1 {next}` line means to ignore line 1 and move on to the next line. The next
    two lines build the `masc` and `fem` arrays. Any line that has an `M` in field
    3 goes into the `masc` array, and any line that has an `F` in field 3 goes into
    the `fem` array. The `END` section contains code that will run after the code
    in the main body has finished building the arrays. The two `for` loops work the
    same as you saw with the normal shell scripting `for` loops, except that we’re
    now using C language syntax. The first loop prints out the list of masculine nouns
    and uses the `count` variable to add up the total of masculine nouns. The second
    loop does the same for the feminine nouns, except that it uses the `count2` variable
    to total the number of feminine nouns. Running the script looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BEGIN`部分，我们设置了`:`作为字段分隔符。`NR == 1 {next}`这一行表示忽略第一行，直接跳到下一行。接下来的两行构建了`masc`和`fem`数组。任何第三列是`M`的行都会被放入`masc`数组，而任何第三列是`F`的行则会被放入`fem`数组。`END`部分包含在主体代码运行完成后执行的代码。两个`for`循环的工作原理与正常的Shell脚本`for`循环相同，只是我们现在使用的是C语言的语法。第一个循环打印出所有的阳性名词，并使用`count`变量统计阳性名词的总数。第二个循环对阴性名词执行相同的操作，只是它使用`count2`变量统计阴性名词的数量。运行脚本时，效果如下：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And, that’s all there is to it. Easy, right?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，完工了。简单吧？
- en: For our next trick, let’s do some floating-point math.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们做一些浮点数学运算。
- en: Using Floating Point Math and printf
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用浮点数学和`printf`
- en: 'For some strange reason, you’ve found yourself working a job that requires
    you to keep track of weather-related statistics. Your boss has just sent you a
    text file that contains a list of temperatures. Some of the temperatures are Celsius
    temperatures, and some are Fahrenheit temperatures. Your assigned task is to convert
    the Fahrenheit temperatures to Celsius temperatures. You can do that the hard
    way by using a calculator to manually convert each Fahrenheit temperature, or
    you can write a script that will automate the process. You’ve decided that it
    would be easier to write a script. The list of temperatures is in the `temps.txt`
    file, which looks like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某种奇怪的原因，你发现自己正在做一份需要跟踪与天气相关的统计数据的工作。你的老板刚刚发给你一个文本文件，里面包含了一系列温度。有些温度是摄氏温度，有些是华氏温度。你被分配的任务是将华氏温度转换为摄氏温度。你可以通过使用计算器手动转换每个华氏温度来完成这个任务，或者你可以编写一个脚本来自动化这个过程。你决定编写脚本会更容易一些。温度列表保存在`temps.txt`文件中，内容如下：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first three temperatures are checks to verify that the script works correctly.
    We know that 32 degrees F equals 0 degrees C, that 212 degrees F equals 100 degrees
    C, and finally that -40 degrees F equals -40 degrees C. If the script converts
    those three temperatures correctly, we can be reasonably sure that the rest of
    the temperatures are getting converted correctly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个温度是用来检查脚本是否正确工作的。我们知道32华氏度等于0摄氏度，212华氏度等于100摄氏度，最后，-40华氏度等于-40摄氏度。如果脚本能正确转换这三个温度，我们可以合理地确信其余的温度也会被正确转换。
- en: Be sure that you haven’t inserted a blank line after the last temperature line,
    or else the script will insert non-sense information after the last actual line
    of output data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你没有在最后一行温度数据之后插入空行，否则脚本将在最后一行实际输出数据后插入无意义的信息。
- en: 'There are two ways to express the conversion formula. Here’s one way:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以表达转换公式。这里是其中一种方法：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s the other way:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种方法：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `$1` represents the field that holds the original Fahrenheit temperature.
    So, we begin by subtracting 32 from the Fahrenheit value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`$1` 代表保存原始华氏温度的字段。所以，我们首先从华氏值中减去 32。'
- en: 'Either formula works equally well, so it really doesn’t matter which one we
    use. Just for fun, I’ll use the first method in the `fahrenheit_to_celsius.awk`
    script, which looks like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 两种公式都同样有效，因此我们使用哪一种其实并不重要。为了好玩，我会在 `fahrenheit_to_celsius.awk` 脚本中使用第一种方法，脚本内容如下：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you see, it’s just a simple one-liner. The `NR==1` causes the header to
    print out, and the `NR>1` ensures that the conversions are performed only on the
    lines that contain actual data. The combination of the `?` and the `:` in the
    `print` action is known as a **ternary operator**. If the first term (`$2=="F"`)
    evaluates to true, then the original value of field 1 will be replaced by the
    value that’s between the `?` and the `:`. In this case, the new value is derived
    from performing the conversion calculation. After the new temperature value on
    each line, we want to print out a pair of tabs, followed by the word Celsius.
    Here’s what happens when I run the script:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这只是一个简单的单行代码。`NR==1` 使得标题被打印出来，而 `NR>1` 确保转换只在包含实际数据的行上进行。`print` 操作中 `?`
    和 `:` 的组合被称为**三元运算符**。如果第一个条件 (`$2=="F"`) 为真，那么字段 1 的原始值将被 `?` 和 `:` 之间的值替换。在这种情况下，新值是通过执行转换计算得出的。在每行的新温度值后，我们希望打印出一对制表符，后跟“Celsius”一词。运行脚本时的结果如下：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That doesn’t look so good, because some of the Celsius values are longer than
    the others, which causes the second column of those lines to not line up correctly.
    We’ll fix this by using `printf` instead of `print`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不太好，因为一些摄氏值比其他的要长，这导致第二列的那些行没有正确对齐。我们将通过使用 `printf` 替代 `print` 来修复这个问题。
- en: 'The `printf` command allows you to customize the output in ways that you can’t
    do with `print`. It works pretty much the same way in `awk` as it does in C, so
    once again you C programmers can rejoice. Here’s how the solution works in the
    `fahrenheit_to_celsius2.awk` script:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf` 命令允许你以 `print` 无法做到的方式定制输出。在 `awk` 中它的工作方式与 C 中相同，所以再次让 C 程序员们高兴吧。以下是
    `fahrenheit_to_celsius2.awk` 脚本中解决方案的工作方式：'
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `%` signs in the `printf` command represent formatting directives. Let’s
    take the `%-11s` directive, which formats the first field in each line. The `-`
    tells `printf` to left-justify the output. (By default, the output is right-justified.)
    The `11s` tells `printf` to allocate 11 spaces for the first field of output.
    If the string in any given line is less than 11 characters long, then `printf`
    will pad the output with enough blank spaces to make up the difference. Finally,
    `%s\n` causes `printf` to print out the designated text string as the second field,
    followed by a newline. (Unlike `print`, `printf` doesn’t automatically add a newline
    at the end of a line.) Anyway, here’s the output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf` 命令中的 `%` 符号代表格式化指令。让我们来看一下 `%-11s` 指令，它格式化每行的第一个字段。`-` 告诉 `printf`
    左对齐输出。（默认情况下，输出是右对齐的。）`11s` 告诉 `printf` 为第一个字段分配 11 个空格。如果任何给定行的字符串长度小于 11 个字符，`printf`
    会用足够的空白填充输出，直到达到差距。最后，`%s\n` 使得 `printf` 打印出指定的文本字符串作为第二个字段，后跟换行符。（与 `print` 不同，`printf`
    不会自动在行末添加换行符。）无论如何，输出如下：'
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Yes, that looks much better. But, what if you don’t need to see all of those
    decimal places? Easy, just use a different formatting directive for the first
    field, as you see here in the `fahrenheit_to_celsius3.awk` script:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，看起来好多了。但是，如果你不需要看到所有的小数位怎么办？很简单，只需要为第一个字段使用不同的格式化指令，正如你在 `fahrenheit_to_celsius3.awk`
    脚本中看到的那样：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, I’m using `%.2f` to format the output as a floating point number with
    only two digits after the decimal point. Here’s how the output looks:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我使用 `%.2f` 将输出格式化为一个浮点数，且小数点后只有两位数字。输出的结果如下：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The only slight catch is that now the second column doesn’t line up correctly.
    You can’t use two directives together for a single field, so we’ll just have to
    live with it like this. That’s okay though, because if you decide to redirect
    this output into a file, you’ll still be able to import it into a spreadsheet
    program.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的小问题是，现在第二列对不齐了。你不能将两个指令用于单个字段，所以我们只能接受这样的格式。不过，这也没关系，因为如果你决定将输出重定向到文件中，依然可以将它导入到电子表格程序中。
- en: 'With a slight change in the formula, you can also change Celsius temperatures
    to Fahrenheit. Here’s the `celsius_to_fahrenheit2.awk` script that does that:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过稍微修改公式，你也可以将摄氏温度转换为华氏温度。以下是执行此操作的`celsius_to_fahrenheit2.awk`脚本：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And, here’s the output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, let’s say that we don’t care about seeing the list of temperatures, and
    only want to see the average. Well, here’s the `average_temp.awk` script which
    does that:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设我们不关心查看温度列表，只想看到平均温度。那么，以下是实现这一目标的`average_temp.awk`脚本：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This time, I decided to use the alternate formula for converting from Fahrenheit
    to Celsius. In both of the `$2==` lines, I’m using the `+=` operator to sum the
    temperatures in the first field and to increment the `total_records` variable.
    Here’s the output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我决定使用从华氏度转换为摄氏度的替代公式。在两个`$2==`的行中，我使用了`+=`运算符来求和第一个字段中的温度，并递增`total_records`变量。以下是输出结果：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To verify that it’s giving you accurate averages, play around with different
    temperature values in the `temps.txt` file to see what happens.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证它是否给出了准确的平均值，可以尝试修改`temps.txt`文件中的不同温度值，看看会发生什么。
- en: The final thing I’ll say on this topic is that `awk` offers the full range of
    math operators, as well as a good selection of math functions. You can find out
    more by following the links in the *Further Reading* section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个话题最后要说的是，`awk`提供了全套数学运算符，并且有很多有用的数学函数。你可以通过查阅*进一步阅读*部分中的链接了解更多信息。
- en: Next, let’s see what we can do with multi-line records.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何处理多行记录。
- en: Working with Multi-Line Records
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理多行记录
- en: 'So far, we’ve been using `awk` to parse text files in which each line is its
    own distinct record. Sometimes though, you might have to work with files that
    have each record spread across several lines. For example, look at this `inventory.txt`
    file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用`awk`解析每一行都是独立记录的文本文件。不过，有时你可能需要处理一些文件，其中每条记录跨越多行。例如，看看这个`inventory.txt`文件：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The first and third records each consist of three lines, and the second record
    consists of four lines. Each record is separated by a blank space. Now, let’s
    say that we need to import this information into a spreadsheet. That won’t work
    well with multi-line records, so we’ll need to find an easy way to convert it
    into a spreadsheet-friendly format. Once again, `awk` to the rescue! Here’s the
    `inventory.awk` script that helps us out:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条和第三条记录各由三行组成，第二条记录由四行组成。每条记录由空行分隔。现在，假设我们需要将这些信息导入到电子表格中。由于多行记录的存在，这样做效果不好，所以我们需要找到一种简单的方法将其转换为适合电子表格格式的内容。再次使用`awk`来拯救我们！以下是帮助我们完成这一任务的`inventory.awk`脚本：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `BEGIN` block defines the newline (`\n`) as the field separator, which means
    that each line in a record is its own field. The record separator (`RS`) and the
    output record separator (`ORS`) are each defined as a null value (`""`). The `RS`
    variable interprets the null value as a blank line, but the `ORS` variable doesn’t.
    In this case, having `ORS` defined as a null value just prevents the `print` command
    in the `while` loop from adding a newline at the end of each field.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`BEGIN`块将换行符（`\n`）定义为字段分隔符，这意味着每一行都算作记录中的一个独立字段。记录分隔符（`RS`）和输出记录分隔符（`ORS`）都被定义为空值（`""`）。`RS`变量将空值解读为空白行，而`ORS`变量不会。在这种情况下，`ORS`被定义为空值只是为了防止`while`循环中的`print`命令在每个字段末尾添加换行符。'
- en: 'There’s not much in the `while` loop that you haven’t seen before. It just
    uses the `count` variable to hold the number of the field that’s being processed.
    The value of this `count` variable gets incremented by 1 after each iteration
    of the `while` loop. You might think it strange that the loop parameter is defined
    as `count<NF` instead of `count<=NF`. I mean, wouldn’t we want to process the
    last field in every record? Well, we do process that last field with the `print
    $NF "\n"` command that comes after the `while` loop. As I said, defining the `OFS`
    as `""` prevents the `print` command from adding a newline character at the end
    of each field. So, in order to have each record on a separate line, we have to
    have a separate `print` command for the final field, and specify that it will
    add a newline at the end of the line. At any rate, here’s how things look when
    I use the script to parse the `inventory.txt` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环中没有什么是你没见过的。它只是使用 `count` 变量来保存正在处理的字段的编号。这个 `count` 变量的值在每次迭代 `while`
    循环后都会增加 1。你可能会觉得奇怪，为什么循环条件定义为 `count<NF` 而不是 `count<=NF`。我的意思是，我们难道不想处理每个记录的最后一个字段吗？嗯，确实是的，我们通过
    `while` 循环后的 `print $NF "\n"` 命令来处理最后一个字段。正如我所说，定义 `OFS` 为 `""` 可以防止 `print` 命令在每个字段的末尾添加换行符。因此，为了让每条记录在单独的一行上，我们必须为最后一个字段单独使用一个
    `print` 命令，并指定它在行末添加换行符。无论如何，以下是我使用该脚本解析 `inventory.txt` 文件时的结果：'
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Of course, you can redirect the output into a `.tsv` file that you can open
    in your favorite spreadsheet program. If you’d rather use a `.csv` file, just
    replace the print `$count "\t"` line in the `while` loop with print `$count ","`.
    The output will then look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以将输出重定向到 `.tsv` 文件中，这样你就可以在你喜欢的电子表格程序中打开它。如果你更愿意使用 `.csv` 文件，只需在 `while`
    循环中的 `print $count "\t"` 行替换为 `print $count ","`。输出将如下所示：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The beauty of this script is that it doesn’t matter how many fields you have
    in each record. The `NF` built-in variable keeps track of how many fields there
    are, and the `while` loop processes each record accordingly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的优点是，无论每条记录中有多少字段都不重要。`NF` 内建变量跟踪字段的数量，`while` 循环根据记录的字段数量进行处理。
- en: Okay, I think that this will pretty much wrap up our introduction to `awk` scripting.
    So, let’s summarize and move on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想这差不多就结束了我们对 `awk` 脚本的介绍。所以，让我们总结一下并继续前进。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The `awk` scripting language is exceedingly useful for anyone who needs to extract
    meaningful data from plain-text files. I began this chapter by showing you the
    basic construction of an `awk` script. Then, I showed you how to use `if` and
    `if..else` to create conditional commands, how to use `while` loops, and how to
    parse text files with multi-line records. For the demos, I showed you various
    `awk` scripts that do the types of jobs that you might encounter in real life.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk` 脚本语言对于需要从纯文本文件中提取有意义数据的人来说极其有用。我从这一章开始时，首先向你展示了一个 `awk` 脚本的基本结构。接着，我展示了如何使用
    `if` 和 `if..else` 创建条件命令，如何使用 `while` 循环，以及如何解析包含多行记录的文本文件。在演示中，我向你展示了各种 `awk`
    脚本，这些脚本执行的任务是你在现实生活中可能遇到的类型。'
- en: Unfortunately, there’s no way that I can do complete justice with this presentation
    of `awk`. It’s another of those topics about which entire books have been written,
    so the best I can do here is to just whet your appetite.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我无法完全展现 `awk` 的所有内容。它是一个那种有完整书籍专门讨论的主题，所以我能做的最好就是让你对它产生兴趣。
- en: In the next chapter, we’ll get back to the main topic of shell scripting, by
    looking at a couple of utilities that allow you to create user interfaces for
    your scripts. I’ll see you there.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到 Shell 脚本的主要主题，介绍几个工具，它们允许你为脚本创建用户界面。我们在那里见。
- en: Questions
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: For the best portability, which of the following shebang lines should you place
    in your `awk` scripts?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了最佳的可移植性，你应该在 `awk` 脚本中使用以下哪一行 shebang？
- en: '`#!/bin/awk`'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#!/bin/awk`'
- en: '`#!/usr/bin/awk -f`'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#!/usr/bin/awk -f`'
- en: '`#!/bin/awk -f`'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#!/bin/awk -f`'
- en: '`#!/usr/bin/awk`'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#!/usr/bin/awk`'
- en: Which of the following statements is true?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项陈述是正确的？
- en: All `awk` programming variables must be declared before you use them.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有 `awk` 编程变量必须在使用之前声明。
- en: There are various types of `awk` variables, such as integer, floating-point,
    and string.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`awk` 变量有多种类型，例如整数、浮点数和字符串。'
- en: All `awk` programming variables are string-type variables.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有 `awk` 编程变量都是字符串类型的变量。
- en: You must convert string-type variables to either integer or floating-point variables
    before using them in math operations.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行数学运算之前，你必须将字符串类型的变量转换为整数或浮点数类型。
- en: Within an `awk` script, how would you define the comma as the field separator?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`awk`脚本中，如何定义逗号为字段分隔符？
- en: '`-F=,`'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-F=,`'
- en: '`-F=","`'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-F=","`'
- en: '`FS=,`'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FS=,`'
- en: . `FS=","`
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: . `FS=","`
- en: You have a text file with several lines of numbers, with blank spaces between
    the numbers. Each line has a different number of numbers. You want to sum the
    numbers on each line. When you write an `awk` script to create these sums, how
    would you account for the fact that each line has a different number of fields?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你有一个包含多行数字的文本文件，数字之间有空格。每一行的数字数量不同。你想计算每行的数字之和。当你编写一个`awk`脚本来计算这些和时，如何处理每行字段数量不同的问题？
- en: Create a variable array to hold the number of fields in each line, and use a
    `for` loop to build the array.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量数组来存储每行的字段数，并使用`for`循环构建该数组。
- en: Use the `NF` built-in variable.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内建变量`NF`。
- en: Use the `NR` built-in variable.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内建变量`NR`。
- en: You can only do this when each line has the same number of fields.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当每一行有相同数量的字段时，才能执行此操作。
- en: Which of the following `printf` directives would you use to ensure that a floating-point
    number always displays with four digits after the decimal point?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个`printf`指令可以确保浮点数总是显示四位小数？
- en: '`%.4f`'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%.4f`'
- en: '`%4`'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%4`'
- en: '`#4.f`'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#4.f`'
- en: '`#4`'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#4`'
- en: Further Reading
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'How do I check if my CPU supports x86_v2?: [https://unix.stackexchange.com/questions/631217/how-do-i-check-if-my-cpu-supports-x86-64-v2](https://unix.stackexchange.com/questions/631217/how-do-i-check-if-my-cpu-supports-x86-64-v2)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如何检查我的CPU是否支持x86_v2？: [https://unix.stackexchange.com/questions/631217/how-do-i-check-if-my-cpu-supports-x86-64-v2](https://unix.stackexchange.com/questions/631217/how-do-i-check-if-my-cpu-supports-x86-64-v2)'
- en: 'Exploring x86-64-v3 for Red Hat Enterprise Linux 10: [https://developers.redhat.com/articles/2024/01/02/exploring-x86-64-v3-red-hat-enterprise-linux-10](https://developers.redhat.com/articles/2024/01/02/exploring-x86-64-v3-red-hat-enterprise-linux-10)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '探索x86-64-v3在Red Hat Enterprise Linux 10中的应用: [https://developers.redhat.com/articles/2024/01/02/exploring-x86-64-v3-red-hat-enterprise-linux-10](https://developers.redhat.com/articles/2024/01/02/exploring-x86-64-v3-red-hat-enterprise-linux-10)'
- en: 'x86_64 Levels: [https://medium.com/@BetterIsHeather/x86-64-levels-944e92cd6d83](mailto:https://medium.com/@BetterIsHeather/x86-64-levels-944e92cd6d83)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'x86_64级别: [https://medium.com/@BetterIsHeather/x86-64-levels-944e92cd6d83](mailto:https://medium.com/@BetterIsHeather/x86-64-levels-944e92cd6d83)'
- en: 'How the awk Command Made Me a 10x Engineer: [https://youtu.be/FbSpuZVb164?si=ri9cnjBh1sxM_STz](https://youtu.be/FbSpuZVb164?si=ri9cnjBh1sxM_STz)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '《awk命令如何让我成为10倍工程师》: [https://youtu.be/FbSpuZVb164?si=ri9cnjBh1sxM_STz](https://youtu.be/FbSpuZVb164?si=ri9cnjBh1sxM_STz)'
- en: 'Ternary Operators: [https://www.tutorialspoint.com/awk/awk_ternary_operators.htm](https://www.tutorialspoint.com/awk/awk_ternary_operators.htm)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '三元运算符: [https://www.tutorialspoint.com/awk/awk_ternary_operators.htm](https://www.tutorialspoint.com/awk/awk_ternary_operators.htm)'
- en: 'printf Examples: [https://www.gnu.org/software/gawk/manual/html_node/Printf-Examples.html](https://www.gnu.org/software/gawk/manual/html_node/Printf-Examples.html)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'printf示例: [https://www.gnu.org/software/gawk/manual/html_node/Printf-Examples.html](https://www.gnu.org/software/gawk/manual/html_node/Printf-Examples.html)'
- en: 'Doing math with awk: [https://www.networkworld.com/article/942538/doing-math-with-awk.html](https://www.networkworld.com/article/942538/doing-math-with-awk.html)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用awk进行数学运算: [https://www.networkworld.com/article/942538/doing-math-with-awk.html](https://www.networkworld.com/article/942538/doing-math-with-awk.html)'
- en: 'Numeric functions in awk: [https://www.gnu.org/software/gawk/manual/html_node/Numeric-Functions.html](https://www.gnu.org/software/gawk/manual/html_node/Numeric-Functions.html)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'awk中的数值函数: [https://www.gnu.org/software/gawk/manual/html_node/Numeric-Functions.html](https://www.gnu.org/software/gawk/manual/html_node/Numeric-Functions.html)'
- en: Answers
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: b
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: c
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: d
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: b
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: a
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a
- en: Join our community on Discord!
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Linux专家以及作者本人一起阅读这本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 提问、为其他读者提供解决方案、通过“问我任何问题”环节与作者交流，等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
