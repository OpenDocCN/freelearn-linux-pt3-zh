- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Oracle Linux 8 – Patching Doesn’t Have to Mean Rebooting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Oracle Linux 8 – 补丁安装不一定意味着重启
- en: I’ve rebooted when patching for my entire life, why change now?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我这一生都在为补丁安装而重启，为什么现在要改变？
- en: Since Linux was released back in 1991, when the kernel was patched, you had
    to reboot the system. At the time, even the IBM mainframes that dominated corporate
    IT needed to be rebooted when patched, so it was considered normal for all other
    systems to be rebooted when patched. This process appeared to work fine for almost
    the next 20 years, but the seeds of change were planted in 2005 when a **Massachusetts
    Institute of Technology** (**MIT**) student came up with a simple question. *What
    if you could patch without rebooting the system?* His team came up with an answer
    in 2009 when Ksplice was released, enabling the ability to patch a Linux kernel
    while the system was running.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1991 年 Linux 发布以来，每当内核进行补丁更新时，您都必须重启系统。那时，即便是主导企业 IT 的 IBM 大型机，在进行补丁更新时也需要重启，因此对所有其他系统而言，补丁更新时重启是正常的。这个过程在接下来的
    20 年里似乎运行良好，但变革的种子在 2005 年被播下，当时一位**麻省理工学院**（**MIT**）的学生提出了一个简单的问题。*如果能在不重启系统的情况下打补丁会怎样？*
    他的团队在 2009 年找到了答案，发布了 Ksplice，使得在系统运行时也能进行 Linux 内核的补丁更新。
- en: In this chapter, we will cover why you should start using Ksplice and how it
    is used to improve the security of your system.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍为什么您应该开始使用 Ksplice，以及如何利用它来提升系统的安全性。
- en: 'This chapter contains the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下操作：
- en: Setting up Ksplice with internet access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Ksplice 以实现互联网访问
- en: Using Ksplice with no internet access
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有互联网访问的情况下使用 Ksplice
- en: Installing and enabling Known Exploit Detection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并启用已知漏洞检测
- en: Setting up Ksplice with internet access
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Ksplice 以实现互联网访问
- en: Before we get into the recipe, let’s understand what’s all the fuss around Ksplice.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始操作前，让我们了解一下关于 Ksplice 的讨论。
- en: What’s all the fuss about Ksplice?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 Ksplice 为什么这么热议？
- en: The first question is, *Why is this important to IT, and more importantly, to
    defending the applications running on the servers?* Before we get to that, you
    first need to understand the process that hackers use to compromise systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是，*为什么这对 IT 重要，更重要的是，对保护服务器上运行的应用程序有何意义？* 在解答这个问题之前，您首先需要了解黑客入侵系统的过程。
- en: 'The basic process includes three main stages: reconnaissance, gaining access,
    and then maintaining access. Once a system is compromised, the process is repeated
    on other systems on the network:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基本流程包括三个主要阶段：侦察、获取访问权限和维持访问权限。一旦系统被攻破，该过程会在网络中的其他系统上重复进行：
- en: '![Figure 7.1 – Security life cycle](img/B18349_07_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 安全生命周期](img/B18349_07_01.jpg)'
- en: Figure 7.1 – Security life cycle
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 安全生命周期
- en: 'In the first phase, **reconnaissance**, hackers use a variety of methods to
    scan the system for vulnerabilities. Often, this attacking phase against servers
    starts after hackers have gained access to a low-level support account that has
    access to the server. Once there, it is a trivial task to look at the kernel version
    and identify what vulnerabilities the kernel is susceptible to. Oracle offers
    a free site ([https://ksplice.oracle.com/inspector](https://ksplice.oracle.com/inspector))
    that lets you easily check the vulnerabilities of the kernel. The results of such
    a check are shown in *Figure 7**.2*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一阶段，**侦察**，黑客使用各种方法扫描系统以寻找漏洞。通常，针对服务器的攻击阶段始于黑客获得对具有访问权限的低级支持帐户的控制。一旦获得该权限，查看内核版本并识别内核易受的漏洞就变得轻而易举。Oracle
    提供了一个免费的站点 ([https://ksplice.oracle.com/inspector](https://ksplice.oracle.com/inspector))，让您可以轻松检查内核的漏洞。检查结果如
    *图 7.2* 所示：
- en: '![Figure 7.2 – Ksplice Inspector](img/B18349_07_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – Ksplice 检查器](img/B18349_07_02.jpg)'
- en: Figure 7.2 – Ksplice Inspector
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – Ksplice 检查器
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The MITRE Corporation is a non-profit company funded by the US federal government
    that researches ways to improve safety across multiple industries, including aviation,
    healthcare, homeland security, defense, and cybersecurity. The **Common Vulnerabilities
    and Exposures** (**CVE**) program was launched in 1999 and quickly became the
    go-to location to track cybersecurity vulnerabilities. More information about
    the CVE program can be found at [https://cve.org](https://cve.org).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MITRE 公司是一家由美国联邦政府资助的非盈利组织，致力于研究改善多个行业安全性的方法，包括航空、医疗保健、国土安全、国防和网络安全。**常见漏洞和暴露**（**CVE**）项目于
    1999 年启动，并迅速成为跟踪网络安全漏洞的首选平台。关于 CVE 项目的更多信息可以在 [https://cve.org](https://cve.org)
    查阅。
- en: Not only will the system identify the CVE that the kernel is susceptible to
    but it also links to the MITRE site with the CVE details. In the example report,
    you can see the kernel is susceptible to several CVEs, including a few that would
    allow the attacker to gain root access. Surprisingly, unlike other similar technologies,
    Ksplice also helps defend against this phase with its ability to detect attacks
    against the running kernel, seeking to gain privileged escalation using the **Known
    Exploit Detection** technology. This effectively turns every system using Ksplice
    into a free intrusion detection system for the kernel.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 系统不仅会识别内核易受攻击的CVE，还会链接到MITRE网站，提供CVE详细信息。在示例报告中，您可以看到内核易受几个CVE的影响，其中一些CVE允许攻击者获得root权限。令人惊讶的是，与其他类似技术不同，Ksplice还通过其**已知漏洞检测**技术，帮助防御这一阶段的攻击。它能够检测到针对正在运行的内核的攻击，试图通过特权升级获取访问权限。这有效地将使用Ksplice的每个系统转变为一个免费的内核入侵检测系统。
- en: In the next phase, gaining access, the hacker exploits the vulnerability, gaining
    access to the data. This is often done weeks after the initial discovery phase.
    Hackers take their time; they do this to run under the radar, and they know that
    most environments are only patched on a quarterly basis at best. Additionally,
    many attacks come from inside the organization, from people who have limited access
    to systems as part of their normal role. Ksplice disrupts this pattern, enabling
    the system admin to easily patch daily, closing the window of opportunity for
    the hacker.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个阶段，即获取访问权限时，黑客利用漏洞，获取数据访问权限。这通常发生在初步发现阶段后的几周。黑客会慢慢进行操作，他们这样做是为了保持低调，并且他们知道大多数环境最多每季度才会打一次补丁。此外，许多攻击来自组织内部，这些人作为其正常职责的一部分，通常拥有有限的系统访问权限。Ksplice打破了这一模式，使系统管理员能够轻松地进行每日打补丁，从而缩短了黑客攻击的机会窗口。
- en: 'In the last phase, the hackers work to maintain access, often using the same
    vulnerability to continually mine the system for data. Ksplice allows this to
    also be shut down, as it closes the vulnerability not only for exploits post-patch
    but also shuts down the exploit for the attack while in progress. This is an important
    feature of Ksplice: the ability to patch the kernel and close the exploit while
    the exploit is being used. This shuts down the exploit mid-flight, significantly
    enhancing the system’s security.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后阶段，黑客试图保持访问权限，通常会利用相同的漏洞不断从系统中挖取数据。Ksplice还可以关闭这一过程，因为它不仅在补丁后关闭漏洞，还能在攻击进行时关闭漏洞。这是Ksplice的一项重要功能：能够在漏洞被利用时修补内核并关闭漏洞。这能够在漏洞利用进行中的过程中中断攻击，显著增强系统安全性。
- en: 'Now, about that patching effort – once a quarter at best? Kernel patches are
    released almost daily, yet systems can remain unpatched for almost a quarter of
    the year or more. This gives attackers a huge window of opportunity to compromise
    your systems. Not only is scheduling the patch a challenge for most mission-critical
    systems but the patch process itself is very time- and labor-intensive. Let’s
    look at why this is the case. As seen in the following diagram, there are many
    steps required to patch a server:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于补丁工作——最多每季度一次？内核补丁几乎每天都会发布，但系统可能会保持未打补丁的状态长达一个季度或更长时间。这为攻击者提供了一个巨大的入侵窗口。大多数关键任务系统不仅在安排补丁时面临挑战，而且补丁过程本身也非常耗时且需要大量劳动力。让我们来看一下为什么会这样。如下面的图示所示，打补丁需要经过多个步骤：
- en: '![Figure 7.3 – Legacy patch process](img/B18349_07_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 传统的补丁过程](img/B18349_07_03.jpg)'
- en: Figure 7.3 – Legacy patch process
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 传统的补丁过程
- en: 'The following list provides a short description of each of these steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对这些步骤的简要描述：
- en: '**Block users from accessing the application**: Disable load balancers or disable
    user logins to the application so users do not accidentally corrupt data.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**阻止用户访问应用程序**：禁用负载均衡器或禁用用户登录应用程序，以防止用户意外破坏数据。'
- en: '**Shut down the application**: Shut down the databases, application servers,
    schedulers, load balancers, and so on. This is to prepare for the operating system
    reboot.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**关闭应用程序**：关闭数据库、应用服务器、调度器、负载均衡器等。这是为了准备操作系统的重启。'
- en: '**Sanity reboot the servers**: Perform a reboot of the servers, with no other
    changes made. This is to verify that the servers can perform a clean reboot. Often
    in this step, a snapshot is made of the app servers.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对服务器进行正常重启**：对服务器进行重启，且不做其他更改。目的是验证服务器是否能够顺利重启。在此步骤中，通常会对应用服务器进行快照。'
- en: '**Restart the application**: Start the application back up to verify that it
    is working. This is to verify the sanity reboot.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重新启动应用程序**：重新启动应用程序以验证其是否正常工作。这是为了验证重启的合理性。'
- en: '**Test post sanity reboot**: Often, some changes get made to the application
    and/or its infrastructure that can cause issues with the application. This step
    verifies that there is a good system before the patches are applied.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试重启后的合理性**：通常，一些更改会对应用程序和/或其基础设施产生影响，从而导致应用程序出现问题。此步骤验证在应用补丁之前系统是否处于良好状态。'
- en: '**Shut down the application**: Shut everything down again to prepare for the
    patching.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**关闭应用程序**：再次关闭所有内容以准备进行修补。'
- en: '**Patch the servers**: Apply the operating system patches.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修补服务器**：应用操作系统的修补。'
- en: '**Reboot post patch**: Reboot so the patches take effect.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修补后重启**：重启以使修补生效。'
- en: '**Restart the application**: Restart the application again.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重新启动应用程序**：再次重新启动应用程序。'
- en: '**Test the application**: Test the application, and verify all is good.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试应用程序**：测试应用程序，确认一切正常。'
- en: '**Let users back in**: Allow users back into the application.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**允许用户重新进入**：允许用户重新进入应用程序。'
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Not every organization follows the full path process, skipping steps to save
    some time. While this can save some time in the short term, all it takes is one
    bad patch cycle where changes were made to the application and/or its infrastructure
    between patch cycles to make for a very bad, long night, or worse, long days.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不是每个组织都遵循完整的流程，会跳过某些步骤以节省时间。虽然这可以在短期内节省一些时间，但只要有一个坏的修补周期，在修补周期之间对应用程序和/或其基础设施进行更改，就可能导致非常糟糕、漫长的夜晚，甚至更糟，变成漫长的几天。
- en: As you can see, properly patching takes a lot of time, and the more complex
    the application, the more people and time are required for each patch cycle. Most
    of this time and effort is caused due to the reboots required.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，正确地修补需要花费大量时间，而且应用程序越复杂，每个修补周期所需的人力和时间也就越多。大部分的时间和精力都是由于需要重启而造成的。
- en: When you avoid the reboot, the patch process is significantly simplified; as
    shown in the following diagram, there are only two steps!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你避免重启时，修补过程会显著简化；如下图所示，只有两个步骤！
- en: '![Figure 7.4 – Ksplice patching process](img/B18349_07_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – Ksplice修补过程](img/B18349_07_04.jpg)'
- en: Figure 7.4 – Ksplice patching process
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – Ksplice修补过程
- en: 'The following list provides a short description of these two steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了这两个步骤的简短描述：
- en: '**Ksplice the servers**: Apply the kernel and user space patches with ksplice.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对服务器进行Ksplice**：使用Ksplice应用内核和用户空间的修补。'
- en: '**Testing**: Test the application'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：测试应用程序'
- en: By using Ksplice, your team can save a ton of time, reduce late nights, and
    improve security. Best of all, it’s easy to set up and use!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ksplice后，你的团队可以节省大量时间，减少加班夜晚，并提高安全性。最棒的是，它易于设置和使用！
- en: Discovering Ksplice
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发现Ksplice
- en: 'Ksplice is easy to configure. There are a few concepts and points you need
    to understand before Ksplicing your servers:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Ksplice配置起来很容易。在对你的服务器进行Ksplice之前，有一些概念和要点需要你理解：
- en: If your servers are running on **Oracle Cloud Infrastructure** (**OCI**), using
    Oracle’s default platform images, all the Ksplice preparation work and access
    to the Ksplice repo is already performed to support online Ksplice usage. Systems
    will also need a route (usually done with a NAT gateway) to the Ksplice endpoint.
    This is automatically set up when using the **Virtual Cloud Network** (**VCN**)
    wizard.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的服务器运行在**Oracle Cloud Infrastructure**（**OCI**）上，并使用Oracle的默认平台镜像，所有Ksplice的准备工作和访问Ksplice仓库的权限都已经完成，以支持在线使用Ksplice。系统还需要有一条通路（通常是通过NAT网关）到Ksplice的端点。当使用**虚拟云网络**（**VCN**）向导时，这会自动设置好。
- en: If you are using Autonomous Linux on OCI, your systems are already being Kspliced
    automatically.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在OCI上使用自主Linux，你的系统已经在自动进行Ksplice操作。
- en: 'There are two Ksplice clients: the legacy Uptrack client and the Enhanced client.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ksplice有两个客户端：传统的Uptrack客户端和增强版客户端。
- en: You do not need internet access to use Ksplice; you can use specially built
    Ksplice `.rpm` files using the offline mode. This will require that you mirror
    the ULN Ksplice repos on a local YUM server. This was covered in [*Chapter 5*](B18349_05.xhtml#_idTextAnchor135).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ksplice时无需互联网访问；你可以使用特别构建的Ksplice `.rpm` 文件来离线模式使用。这需要你在本地YUM服务器上镜像ULN Ksplice仓库。有关内容已在[*第5章*](B18349_05.xhtml#_idTextAnchor135)中讲解。
- en: Both the Enhanced client and the Uptrack client allow you to Ksplice the kernel,
    but the Enhanced client also offers the ability to Ksplice user space libraries,
    KVM hypervisors, and Arm-based systems and offers Known Exploit Detection on x86_64
    platforms. Most new users should use the Enhanced client.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 增强版客户端和 Uptrack 客户端都允许您进行内核 Ksplice，但增强版客户端还提供了对用户空间库、KVM 虚拟机监控程序、基于 Arm 的系统的
    Ksplice 支持，并且在 x86_64 平台上提供已知漏洞检测。大多数新用户应选择使用增强版客户端。
- en: The older Uptrack client does not offer the advantages the Enhanced client offers,
    but it does support the ability to patch some non-Oracle Linux systems.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版的 Uptrack 客户端没有增强版客户端提供的优势，但它确实支持修补一些非 Oracle Linux 系统。
- en: 'Ksplice offers two different modes: the online mode and the offline mode. The
    online mode requires that each system registers to the Oracle ULN but offers a
    Ksplice web interface, the Ksplice Uptrack API, for advanced automation and the
    ability to patch a Xen hypervisor. However, since this requires every system to
    not only register with ULN but also for internet access, many system administrators
    use the offline mode.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Ksplice 提供了两种不同的模式：在线模式和离线模式。在线模式要求每个系统注册到 Oracle ULN，但它提供了 Ksplice Web 界面、Ksplice
    Uptrack API，用于高级自动化，并且能够修补 Xen 虚拟机监控程序。然而，由于这要求每个系统不仅要在 ULN 上注册，还需要能够访问互联网，因此许多系统管理员选择使用离线模式。
- en: 'The offline mode allows the system to use Ksplice without internet access.
    This is most often used by Enterprise and Government environments where all servers
    do not have internet access. In these use cases, the most common method is to
    set up a ULN mirror, giving that system access to the internet, and the local
    Oracle Linux servers will pull from that mirror to use Ksplice:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 离线模式允许系统在没有互联网访问的情况下使用 Ksplice。这通常用于企业和政府环境，其中所有服务器都没有互联网连接。在这些用例中，最常见的方法是设置一个
    ULN 镜像，允许该系统访问互联网，本地的 Oracle Linux 服务器将从该镜像中拉取并使用 Ksplice：
- en: '![Figure 7.5 – Ksplice offline mode using RPMs](img/B18349_07_05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 使用 RPM 的 Ksplice 离线模式](img/B18349_07_05.jpg)'
- en: Figure 7.5 – Ksplice offline mode using RPMs
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 使用 RPM 的 Ksplice 离线模式
- en: 'With the offline mode, only the local ULN mirror needs to be able to access
    the Oracle ULN, via the HTTPS protocol. This can be done via a basic firewall
    rule or a more advanced proxy server. Once the ULN mirror is registered and synced
    from the ULN, the servers behind the firewall can pull their RPMs via HTTP/HTTPS
    from the ULN mirror. There are a couple of advantages to the offline mode: less
    bandwidth is used for the internet and not every client needs to be registered.
    Of course, having no API, there are some limitations with more advanced automation.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在离线模式下，只有本地的 ULN 镜像需要能够通过 HTTPS 协议访问 Oracle ULN。这可以通过基础防火墙规则或更高级的代理服务器实现。一旦
    ULN 镜像注册并从 ULN 同步，防火墙后面的服务器就可以通过 HTTP/HTTPS 从 ULN 镜像拉取 RPM。离线模式有几个优势：减少了互联网带宽的使用，并且并非每个客户端都需要注册。当然，由于没有
    API，离线模式在更复杂的自动化方面有一些限制。
- en: 'Regardless of what mode is used, the clients must have access to a few specific
    Ksplice channels. The following table describes the channels that are available
    for Ksplice in Oracle Linux:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用什么模式，客户端必须能够访问一些特定的 Ksplice 渠道。下表描述了在 Oracle Linux 中可用的 Ksplice 渠道：
- en: '| **Channel Name** | **Enhanced** **Client** | **Channel Label** | **Description**
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **渠道名称** | **增强版** **客户端** | **渠道标签** | **描述** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Ksplice for Oracle Linux 7 (x86_64) | Optional | `ol7_x86_64_ksplice` | Ksplice
    RPMs for Oracle Linux 7 on x86_64 systems |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| Oracle Linux 7（x86_64）的 Ksplice | 可选 | `ol7_x86_64_ksplice` | 针对 x86_64 系统的
    Oracle Linux 7 上的 Ksplice RPM |'
- en: '| Ksplice for Oracle Linux 7 (aarch64) | Optional | `ol7_aarch64_ksplice` |
    Ksplice RPMs for Oracle Linux 7 on aarch64 systems |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| Oracle Linux 7（aarch64）的 Ksplice | 可选 | `ol7_aarch64_ksplice` | 针对 aarch64
    系统的 Oracle Linux 7 上的 Ksplice RPM |'
- en: '| Ksplice for Oracle Linux 8 (x86_64) | Optional | `ol8_x86_64_ksplice` | Ksplice
    RPMs for Oracle Linux 8 on x86_64 systems |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| Oracle Linux 8（x86_64）的 Ksplice | 可选 | `ol8_x86_64_ksplice` | 针对 x86_64 系统的
    Oracle Linux 8 上的 Ksplice RPM |'
- en: '| Ksplice for Oracle Linux 8 (aarch64) | Optional | `ol8_aarch64_ksplice` |
    Ksplice RPMs for Linux 8 on aarch64 systems |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| Oracle Linux 8（aarch64）的 Ksplice | 可选 | `ol8_aarch64_ksplice` | 针对 aarch64
    系统的 Oracle Linux 8 上的 Ksplice RPM |'
- en: '| Ksplice-aware user space packages for Oracle Linux 7 (x86_64) | Required
    | `ol7_x86_64_userspace_ksplice` | Latest RPMs for Ksplice-aware user space packages
    for Oracle Linux 7 (x86_64) |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| Oracle Linux 7（x86_64）的 Ksplice 感知用户空间包 | 必需 | `ol7_x86_64_userspace_ksplice`
    | 针对 Oracle Linux 7（x86_64）的 Ksplice 感知用户空间包的最新 RPM |'
- en: '| Ksplice-aware user space packages for Oracle Linux 7 (aarch64) | Required
    | `ol7_aarch64_userspace_ksplice` | Latest RPMs for Ksplice-aware user space packages
    for Oracle Linux 7 (aarch64) |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| Oracle Linux 7（aarch64）Ksplice-aware 用户空间软件包 | 必需 | `ol7_aarch64_userspace_ksplice`
    | Oracle Linux 7（aarch64）Ksplice-aware 用户空间软件包的最新 RPM |'
- en: '| Ksplice-aware user space packages for Oracle Linux 8 (x86_64) | Required
    | `ol8_x86_64_userspace_ksplice` | Latest RPMs for Ksplice-aware user space packages
    for Oracle Linux 8 (x86_64) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| Oracle Linux 8（x86_64）Ksplice-aware 用户空间软件包 | 必需 | `ol8_x86_64_userspace_ksplice`
    | Oracle Linux 8（x86_64）Ksplice-aware 用户空间软件包的最新 RPM |'
- en: '| Ksplice-aware user space packages for Oracle Linux 8 (aarch64) | Optional
    | `ol8_aarch64_userspace_ksplice` | Latest RPMs for Ksplice-aware user space packages
    for Oracle Linux 8 (aarch64) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| Oracle Linux 8（aarch64）Ksplice-aware 用户空间软件包 | 可选 | `ol8_aarch64_userspace_ksplice`
    | Oracle Linux 8（aarch64）Ksplice-aware 用户空间软件包的最新 RPM |'
- en: Table 7.1 – Ksplice channels
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1 – Ksplice 频道
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If `prelink` is installed, revert the pre-linked binaries to their original
    state (`prelink -au`) and then uninstall `prelink` (`dnf remove prelink -y`).
    While not often used, `prelink` is not compatible with Ksplice.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装了 `prelink`，请将预链接的二进制文件恢复到其原始状态（`prelink -au`），然后卸载 `prelink`（`dnf remove
    prelink -y`）。虽然不常用，但 `prelink` 与 Ksplice 不兼容。
- en: Now that you have an understanding of why you need to use Ksplice and the basics
    of how it works, let’s get to the recipe.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了为什么需要使用 Ksplice 以及它的基本工作原理，接下来我们来看看具体的操作步骤。
- en: The easiest way to use Ksplice is to allow each system to access the Oracle
    Ksplice service directly. This is called online mode. This can be done via an
    internet proxy, direct access, or by running the systems in OCI.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ksplice 最简单的方式是让每个系统直接访问 Oracle Ksplice 服务，这称为在线模式。可以通过互联网代理、直接访问，或者将系统运行在
    OCI 中来实现。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To do this, you will need a test system, running Oracle Linux 8, with access
    to the internet.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行此操作，你需要一台运行 Oracle Linux 8 且能够访问互联网的测试系统。
- en: How to do it…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'When using Ksplice, make sure you match each system for both the operating
    system version, and the user-space libraries. Do not use an Oracle Linux 9 repo
    for an Oracle Linux 8 system. An example of what a system should look like can
    be seen in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ksplice 时，确保操作系统版本和用户空间库相匹配。不要为 Oracle Linux 8 系统使用 Oracle Linux 9 的软件库。系统应如下图所示：
- en: '![Figure 7.6 – Required channels](img/B18349_07_06.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 所需的频道](img/B18349_07_06.jpg)'
- en: Figure 7.6 – Required channels
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 所需的频道
- en: 'If you are using an internet proxy server, you will need to export some environmental
    variables to set the proxy servers:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用互联网代理服务器，你需要导出一些环境变量来设置代理服务器：
- en: '[PRE0]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Set `proxy_server_URL` to the proxy server, and `http_port` to the port the
    proxy server uses.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `proxy_server_URL` 设置为代理服务器，`http_port` 设置为代理服务器使用的端口。
- en: 'Next, Ksplice will be installed using `dnf`. Both the `ksplice` and `uptrack`
    packages are needed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ksplice 将通过 `dnf` 安装。需要安装 `ksplice` 和 `uptrack` 包：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the installation is complete, please verify that your system is seen in
    the ULN and that an access key has been populated in `/etc/uptrack/uptrack.conf`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，请验证你的系统是否已出现在 ULN 中，并且 `/etc/uptrack/uptrack.conf` 中已填充访问密钥。
- en: 'The access key should be in the `[Auth]` section and should look similar to
    this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 访问密钥应位于 `[Auth]` 部分，应该类似于以下内容：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once done, perform a normal `dnf update` and then reboot the system. This `dnf
    update` is required so the Ksplice-aware user space libraries are loaded; it is
    only required the first time Ksplice is used.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，执行正常的 `dnf update` 然后重启系统。第一次使用 Ksplice 时需要执行此 `dnf update`，以加载 Ksplice-aware
    用户空间库。
- en: Once the server is rebooted, Ksplice can now be used to patch user space libraries
    and the kernel.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器重启，Ksplice 现在可以用于修补用户空间库和内核。
- en: 'To see what updates are available for the kernel, you can run the Ksplice `kernel
    upgrade` command, passing `-n` for no action:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看内核有哪些更新可用，可以运行 Ksplice 的 `kernel upgrade` 命令，传递 `-n` 参数表示不执行任何操作：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output from this command is seen in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出如下图所示：
- en: '![Figure 7.7 – Ksplice available upgrades](img/B18349_07_07.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 可用的 Ksplice 升级](img/B18349_07_07.jpg)'
- en: Figure 7.7 – Ksplice available upgrades
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 可用的 Ksplice 升级
- en: 'In this system, only one update is available, patching `CVE-2021-4034`. To
    splice the system, run the same command, replacing `-n` with `-y` to say yes to
    applying the kernel path:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在此系统中，只有一个更新可用，修补 `CVE-2021-4034`。要应用该修补程序，请运行相同的命令，将 `-n` 替换为 `-y`，以表示同意应用内核路径：
- en: '![Figure 7.8 – Ksplice updating the kernel](img/B18349_07_08.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – Ksplice 更新内核](img/B18349_07_08.jpg)'
- en: Figure 7.8 – Ksplice updating the kernel
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – Ksplice 更新内核
- en: From here, you can see that the CVE patch has now taken place without a reboot!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到 CVE 补丁已经在没有重启的情况下应用！
- en: The kernel that has been patched is referred to as the effective kernel. When
    you use the `ksplice kernel uname -r` command in Ksplice, it displays the effective
    kernel version, which indicates the current security status of the kernel based
    on the applied patches. This version typically varies from the initially booted
    kernel version and is meant to reflect the present condition of the kernel regarding
    any potential security threats or major issues.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 已经被修补的内核被称为有效内核。当您在 Ksplice 中使用`ksplice kernel uname -r`命令时，它会显示有效内核版本，该版本反映了基于已应用补丁的内核当前的安全状态。这个版本通常与初始启动的内核版本不同，旨在反映内核当前对于潜在安全威胁或重大问题的状况。
- en: 'You can now validate what your effective kernel is by using the following Ksplice
    command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过以下 Ksplice 命令验证您的有效内核：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that the version of the running kernel and the installed kernel will not
    match! This is because when Ksplice splices the kernel, it splices the RAM of
    the running kernel with the new code. This patches the kernel (and selected user
    space libraries) but has the effect of `uname` no longer matching the effective
    kernel:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正在运行的内核版本和已安装的内核版本不会匹配！这是因为当 Ksplice 给内核打补丁时，它会将运行内核的 RAM 与新代码拼接。这修补了内核（和选定的用户空间库），但导致`uname`不再与有效内核匹配：
- en: '![Figure 7.9 – Ksplice uname](img/B18349_07_09.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – Ksplice uname](img/B18349_07_09.jpg)'
- en: Figure 7.9 – Ksplice uname
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – Ksplice uname
- en: Here, the installed kernel is `5.4.17-2136.302.7.2.1.el8uek.aarch64`, but the
    effective kernel that has been Kspliced is a newer kernel at version `5.4.17-2136.306.1.3.el8uek`.
    This is normal behavior with Ksplice.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，已安装的内核是`5.4.17-2136.302.7.2.1.el8uek.aarch64`，但已经被 Ksplice 处理的有效内核是一个更新的内核，版本为`5.4.17-2136.306.1.3.el8uek`。这是
    Ksplice 的正常行为。
- en: 'User space libraries can be patched in the same way, replacing the kernel with
    the user. As a note, if the Ksplice user space libraries are *not* installed,
    the first time the command is run, you will be prompted to upgrade the user libraries
    to a Ksplice-compatible version:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间库也可以以相同的方式进行补丁处理，将内核替换为用户空间。如果没有安装 Ksplice 用户空间库，首次运行该命令时，您会被提示将用户库升级到支持
    Ksplice 的版本：
- en: '![Figure 7.10 – Installing Ksplice user libraries for the first time](img/B18349_07_10.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 首次安装 Ksplice 用户库](img/B18349_07_10.jpg)'
- en: Figure 7.10 – Installing Ksplice user libraries for the first time
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 首次安装 Ksplice 用户库
- en: Note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can also check user space available packages to Ksplice with the `ksplice
    user show --available` command but if you did not install the Ksplice-aware packages,
    you will get this error:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过`ksplice user show --available`命令检查可用的 Ksplice 用户空间包，但是如果没有安装支持 Ksplice
    的包，您将看到以下错误：
- en: '`No active user-space` `Ksplice targets`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`没有活动的用户空间` `Ksplice 目标`'
- en: '`Have you installed Ksplice-aware libraries` `and rebooted?`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`您是否已经安装了支持 Ksplice 的库` `并重启了系统？`'
- en: 'You can also check what user space targets are currently running and can be
    patched. This is done with the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以检查当前运行的用户空间目标，并可以对其进行补丁处理。可以使用以下命令来完成此操作：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The sample output is shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例输出的截图：
- en: '![Figure 7.11 – Ksplice targets](img/B18349_07_11.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – Ksplice 目标](img/B18349_07_11.jpg)'
- en: Figure 7.11 – Ksplice targets
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – Ksplice 目标
- en: 'The Ksplice command can also be used to roll back a splice. By using the `ksplice
    kernel show` command, you can see all the splices currently installed:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Ksplice 命令也可以用来回滚补丁。通过使用`ksplice kernel show`命令，您可以查看当前安装的所有补丁：
- en: '![Figure 7.12 – Installed kernel patches](img/B18349_07_12.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 已安装的内核补丁](img/B18349_07_12.jpg)'
- en: Figure 7.12 – Installed kernel patches
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 已安装的内核补丁
- en: Each Ksplice patch has a unique **Ksplice identifier** (**KID**). The KID is
    also unique to the specific kernel build and patch, so when comparing KIDs across
    different kernels, be careful. If using automation to leverage the KID, make sure
    that you limit the automation to systems with the same kernel build and architecture.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Ksplice 补丁都有一个唯一的**Ksplice 标识符**（**KID**）。KID 还特定于某个内核版本和补丁，因此在比较不同内核的 KID
    时，请小心。如果使用自动化工具来利用 KID，请确保将自动化限制在具有相同内核版本和架构的系统上。
- en: 'This is the first column in the list of installed patches. If you need to uninstall
    a specific patch, it is possible. In this example, KID `qd1g4vxd` (CVE-2021-4149:
    denial-of-service in the BTRFS filesystem) will be uninstalled using the Ksplice
    `undo` command, passing the specific KID. You can also pass `-v` for verbose.
    Once uninstalled, check the list of installed KIDs to verify the removal of the
    single KID:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是已安装补丁列表中的第一列。如果你需要卸载特定的补丁，这是可能的。在这个示例中，KID `qd1g4vxd`（CVE-2021-4149：BTRFS
    文件系统中的拒绝服务漏洞）将使用 Ksplice `undo` 命令卸载，并传递特定的 KID。你也可以使用 `-v` 参数查看详细信息。卸载后，检查已安装的
    KID 列表，验证是否已成功移除该 KID：
- en: '![Figure 7.13 – Ksplice undo](img/B18349_07_13.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – Ksplice 撤销](img/B18349_07_13.jpg)'
- en: Figure 7.13 – Ksplice undo
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – Ksplice 撤销
- en: 'Optionally, all installed KIDs can be removed from a running system by using
    the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，可以使用以下命令从运行中的系统中移除所有已安装的 KID：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will remove all the KIDs from the running kernel in memory:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从内存中的运行内核中移除所有 KID：
- en: '![Figure 7.14 – Ksplice remove](img/B18349_07_14.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – Ksplice 移除](img/B18349_07_14.jpg)'
- en: Figure 7.14 – Ksplice remove
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – Ksplice 移除
- en: Ksplice also allows for automatic updates. They can be enabled or disabled by
    simply touching a file, or removing a file. If the `/etc/uptrack/disable` file
    exists, Ksplice will not automatically update the system when you reboot. If the
    file is not there, then Ksplice will check on reboot for any new KIDs and apply
    them. You can also modify this behavior by updating the `uptrack.conf` file. This
    is covered later in this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Ksplice 还允许自动更新。你可以通过简单地触摸一个文件或删除一个文件来启用或禁用自动更新。如果存在 `/etc/uptrack/disable`
    文件，则在重启时，Ksplice 将不会自动更新系统。如果该文件不存在，Ksplice 将在重启时检查是否有新的 KID，并应用它们。你也可以通过更新 `uptrack.conf`
    文件来修改此行为，本章后面会介绍。
- en: How it works…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: When you are using Ksplice with internet access, the Ksplice client connects
    to the Oracle ULN Ksplice system, and downloads and applies the required splices.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用带有互联网连接的 Ksplice 时，Ksplice 客户端会连接到 Oracle ULN Ksplice 系统，下载并应用所需的补丁。
- en: Using Ksplice with no internet access
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在没有互联网连接的情况下使用 Ksplice
- en: Not all systems have internet access. That is fine, as it’s possible to use
    Ksplice against a local patch repository.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有系统都有互联网连接。没关系，因为可以使用 Ksplice 从本地补丁库进行操作。
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To do this, you will need a test system running Oracle Linux 8, with access
    to a local YUM repository on the network.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你需要一台运行 Oracle Linux 8 的测试系统，并且可以访问网络中的本地 YUM 仓库。
- en: How to do it…
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: To install the client, make sure that your server is using an RPM repo that
    is mirrored locally. To install Ksplice, you must decide on either the online
    or offline client. As a reminder, the online client requires that the system be
    registered with ULN, and the offline client will use a local RPM repository.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 安装客户端时，请确保你的服务器正在使用本地镜像的 RPM 仓库。安装 Ksplice 时，你必须选择使用在线客户端或离线客户端。提醒一下，在线客户端需要系统已注册到
    ULN，而离线客户端则使用本地 RPM 仓库。
- en: 'To install the online client, run the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装在线客户端，请运行以下命令：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To install the offline client, run the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装离线客户端，请运行以下命令：
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output from this command is shown in the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出如下图所示：
- en: '![Figure 7.15 – Offline Ksplice installation](img/B18349_07_15.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.15 – 离线安装 Ksplice](img/B18349_07_15.jpg)'
- en: Figure 7.15 – Offline Ksplice installation
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – 离线安装 Ksplice
- en: Once Ksplice is installed, you can now splice the server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Ksplice，你现在可以开始为服务器打补丁。
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since the Uptrack client has no advantages over the new client with Oracle Linux
    8 (or Oracle Linux 7 for that matter), we will focus on the Enhanced client. If
    you are using an older operating system, you may need to use the older Uptrack
    client.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Uptrack 客户端在 Oracle Linux 8（或 Oracle Linux 7）中不再优于新客户端，因此我们将重点介绍增强版客户端。如果你使用的是较旧的操作系统，可能需要使用旧版的
    Uptrack 客户端。
- en: 'Ksplice with the offline method is really easy; simply use `dnf` to patch the
    system:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用离线方式的 Ksplice 非常简单；只需使用 `dnf` 来打补丁：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will patch in both the normal way and then with Ksplice for the kernel
    and user libraries. If you want to disable this behavior, you can set `skip_apply_after_pkg_install`
    to `true` in `/``etc/uptrack/uptrack.conf`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将同时以常规方式和使用 Ksplice 对内核及用户库进行打补丁。如果你想禁用此行为，可以在 `/etc/uptrack/uptrack.conf`
    中将 `skip_apply_after_pkg_install` 设置为 `true`。
- en: 'Before you patch, make sure you have added a Ksplice entry in `/etc/yum.repos.d`.
    A sample Ksplice entry may look like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在打补丁之前，请确保在 `/etc/yum.repos.d` 中添加了 Ksplice 条目。一个示例 Ksplice 条目可能如下所示：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Ksplice is a tool that allows Linux systems to stay current with security fixes
    and vital updates without requiring system reboots. This is especially beneficial
    for servers and settings that need to stay up and running with little downtime.
    It’s worth noting that while Ksplice can handle many patches, some changes may
    be too intricate to apply in a live environment and will require a traditional
    reboot-based update.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Ksplice 是一个工具，它允许 Linux 系统保持最新的安全修复和重要更新，而无需重启系统。这对于需要尽量减少停机时间的服务器和环境特别有益。值得注意的是，尽管
    Ksplice 可以处理许多补丁，但某些更复杂的更改可能无法在实时环境中应用，这时将需要传统的基于重启的更新。
- en: Installing and enabling Known Exploit Detection
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和启用已知漏洞检测
- en: One of the most critical things to do to secure your system (and, more importantly,
    the data in the system) is to implement the ability to detect when the bad guys
    are trying to break in. Ksplice has a unique feature called **Known Exploit Detection**
    (**KED**) that will report on known attacks against the kernel. Normally, only
    exploits that allow the hacker to access additional privileges are instrumented
    for KED and, for these to trigger, the kernel should already have been spliced
    for the vulnerability.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保系统安全（更重要的是，保护系统中的数据），最关键的操作之一就是实现检测功能，以便发现坏人试图闯入。Ksplice 有一个独特的功能，称为 **已知漏洞检测**
    (**KED**)，它会报告针对内核的已知攻击。通常，只有那些允许黑客获得额外权限的漏洞才会被用于 KED，并且要触发这些漏洞，内核应该已经为该漏洞进行了拼接。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To do this, you will need a test system running Oracle Linux 8, with Ksplice
    set up.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你需要一台运行 Oracle Linux 8 且已设置 Ksplice 的测试系统。
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: This is done via tripwire code, which is triggered when specific events are
    detected. Normally, only events that enable the attacker to gain privileged access
    are monitored. This package is available on both x86 and ARM systems.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过 tripwire 代码完成的，当检测到特定事件时会触发。通常，只有那些使攻击者能够获得特权访问的事件才会被监控。此软件包在 x86 和 ARM
    系统上都可用。
- en: 'To enable this, the pack must first be installed by using the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用此功能，首先必须使用以下命令安装该软件包：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Regardless of whether the installation is on an ARM or x64 server, the installation
    is almost identical, with the major differences being more about the software
    already installed on each system. This brings a point to mind: regardless of whether
    ARM or x64, the admin tasks are the same.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 无论安装是在 ARM 还是 x64 服务器上，安装过程几乎完全相同，主要的区别在于每个系统上已安装的软件。这让我想起一点：无论是 ARM 还是 x64，管理员的任务都是一样的。
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When KED is installed, `postfix` is also installed to enable sending emails
    as part of the notification system.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装了 KED 后，`postfix` 也会被安装，以启用作为通知系统一部分的邮件发送功能。
- en: 'The output from installing this on an ARM-based system is shown in the following
    screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 ARM 的系统上安装时的输出结果如下图所示：
- en: '![Figure 7.16 – KED installation on ARM](img/B18349_07_16.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.16 – 在 ARM 上安装 KED](img/B18349_07_16.jpg)'
- en: Figure 7.16 – KED installation on ARM
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – 在 ARM 上安装 KED
- en: 'The output from installing this on an x86_64-based system is shown in the following
    screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 x86_64 系统上安装时的输出结果如下图所示：
- en: '![Figure 7.17 – KED installation on x64](img/B18349_07_17.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.17 – 在 x64 上安装 KED](img/B18349_07_17.jpg)'
- en: Figure 7.17 – KED installation on x64
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 – 在 x64 上安装 KED
- en: 'Once KED is installed, the feature needs to be enabled. This is done by adding
    the following lines to `/``etc/uptrack/uptrack.conf`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 KED 后，需要启用此功能。这可以通过将以下行添加到 `/etc/uptrack/uptrack.conf` 来完成：
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, you will need to Ksplice the kernel to enable the feature in the running
    kernel:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要通过 Ksplice 来启用运行中的内核中的此功能：
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output for this is shown in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后输出结果如下图所示：
- en: '![Figure 7.18 – Enabling KED in a running kernel](img/B18349_07_18.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.18 – 在运行中的内核中启用 KED](img/B18349_07_18.jpg)'
- en: Figure 7.18 – Enabling KED in a running kernel
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 – 在运行中的内核中启用 KED
- en: As a note, if no Ksplice patches are available, you will get a notification
    that the kernel is up to date, as shown in the preceding screenshot. But if the
    system requires patches, Ksplice will patch the kernel at this time while enabling
    KED.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，如果没有可用的 Ksplice 补丁，你将收到一个通知，表示内核是最新的，如前面的截图所示。但是，如果系统需要补丁，Ksplice 会在此时打补丁，同时启用
    KED。
- en: 'To verify that KED is enabled, `cat /proc/sys/kernel/known_exploit_detection`
    and look for an output of `1`. If the file is missing or there is a zero there,
    KED is not enabled so won’t be monitoring your system:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证 KED 是否启用，执行 `cat /proc/sys/kernel/known_exploit_detection`，并查找输出是否为 `1`。如果文件缺失或输出为零，说明
    KED 没有启用，因此不会监控你的系统：
- en: '![Figure 7.19 – Checking whether KED is enabled](img/B18349_07_19.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.19 – 检查 KED 是否启用](img/B18349_07_19.jpg)'
- en: Figure 7.19 – Checking whether KED is enabled
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19 – 检查 KED 是否启用
- en: 'Notifications from KED are controlled from the `/etc/log-known-exploit.conf`
    configuration file. A sample configuration file is shown in the following screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: KED 的通知由 `/etc/log-known-exploit.conf` 配置文件控制。以下截图显示了一个示例配置文件：
- en: '![Figure 7.20 – KED notifications configuration](img/B18349_07_20.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.20 – KED 通知配置](img/B18349_07_20.jpg)'
- en: Figure 7.20 – KED notifications configuration
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20 – KED 通知配置
- en: 'In the config file, you can control the following actions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件中，你可以控制以下操作：
- en: '`[syslog]`: Most admins log events to syslog for capture and analysis using
    log analytics tools such as OCI Log Analytics or Splunk. The `enabled: 0` setting
    will disable logging to syslog.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[syslog]`：大多数管理员将事件记录到 syslog，以便使用如 OCI Log Analytics 或 Splunk 等日志分析工具进行捕获和分析。`enabled:
    0` 设置将禁用记录到 syslog。'
- en: '`[email]`: This section allows you to enable emails to be sent when a tripwire
    is triggered. Add email addresses for recipients as needed. This will also require
    that the system can send emails, either through a cloud service such as the OCI
    Email Delivery Service or your own **Simple Mail Transport Protocol** (**SMTP**)
    relay.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[email]`：此部分允许在触发 tripwire 时发送电子邮件通知。根据需要添加收件人的电子邮件地址。此操作还要求系统能够发送电子邮件，可以通过云服务（如
    OCI 邮件投递服务）或自己的 **简单邮件传输协议** (**SMTP**) 中继来完成。'
- en: '`[actions]`: You can specifically disable notifications for a specific CVE.
    This is helpful if you have an accidental false positive on a system. To disable
    a CVE, add a line with the CVE and `ignore`. The `default:` parameter sets the
    default behavior for all CVE.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[actions]`：你可以为特定的 CVE 禁用通知。如果系统上出现意外的误报，这会很有帮助。要禁用某个 CVE，只需添加一行包含 CVE 和 `ignore`。`default:`
    参数设置所有 CVE 的默认行为。'
- en: Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you enable email notification, make sure your email subsystem is configured
    before enabling emails from KED.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启用了电子邮件通知，确保在启用来自 KED 的电子邮件之前，已经配置好了你的电子邮件子系统。
- en: 'You can also test the system with the `log-known-exploit` command. This will
    log a test message in the kernel:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `log-known-exploit` 命令测试系统。这将在内核中记录一条测试消息：
- en: '[PRE14]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The test event will look like the following in `/var/log/messages`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 测试事件在 `/var/log/messages` 中的显示如下：
- en: '[PRE15]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the log, you will see the time, the CVE that was triggered, and also the
    **Process ID** (**PID**) and **User ID** (**UID**) of the process and user that
    triggered the event.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中，你将看到时间、触发的 CVE，以及触发事件的进程和用户的 **进程 ID** (**PID**) 和 **用户 ID** (**UID**)。
- en: How it works…
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理是…
- en: Ksplice installs a piece of tripwire code in the kernel for specific exploits,
    detecting when something tries to exploit the exploit. These triggers then kick
    off the notification subsystem, letting you know when an attack happens.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Ksplice 在内核中安装了特定漏洞的 tripwire 代码，用于检测是否有人试图利用该漏洞。这些触发器会启动通知子系统，让你知道何时发生攻击。
