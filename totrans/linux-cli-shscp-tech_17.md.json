["```\nsudo apt install apache2 -y\n```", "```\n#!/bin/bash\n# V1.0 / Jasmin Redzepagic / 01/11/2021\n# Distribution allowed under GNU Licence V2.0\n\n# Script configures apache DocumentRoot with a given path \n# and sets firewall accordingly\n# Script is interactive, no arguments are accepted\n# This script has to be run as root, we need to check that\nif [[ $(id -u) -ne 0 ]] \nthen \n    echo \"This script needs to be run as root!\" >&2 \n    exit 1 \nfi\n# If there are multiple sites configured we will show a warning\nif [[ $(ls /etc/apache2/sites-enabled/ | wc -l) -gt 1 ]] \nthen \necho \"Warning: you may have more than one site!\" >&2 \n             exit 1 \nfi\n# First we are going to get what the root of the site is now\n# When checking for DocumentRoot we are only checking \n# in default web site\nHTTPDIR='grep DocumentRoot /etc/apache2/sites-available/000-\\default.conf'\nHTTPDIR=\"/$( cut -d '/' -f 2- <<< \"$HTTPDIR\" )\"\n# We are going to print current directory \n# that we read from inside the configuration file\necho \"Current HTTPDIR is set as $HTTPDIR\"\nread -p  \"Press Enter to accept current value or input absolute\\\npath for new DocumentRoot: \" NEWDIR\n# If user pressed enter we are going to \n# simply use the value we already read, \n# otherwise we use the new value\n# Note: there is absolutely no sanity checking \n# if the given value is actually a path\nNEWDIR=${NEWDIR:-$HTTPDIR}\necho \"Directory is going to be set to $NEWDIR\"\n# Since we are dealing with a path we need to\n# preprocess it before we use it in sed\n# otherwise this is going to break\n# There is an alternative, sed allows for \n# any other character in place of /\n# but this is going to be a problem \n# if our path contains any nonstandard character\n# so we simply escape all the slashes\n# we need to use the _ character in this \n# case to be able to search for slash \nESCNEWDIR=$(echo $NEWDIR | sed 's_/_\\\\/_g')\nESCHTTPDIR=$(echo $HTTPDIR | sed 's_/_\\\\/_g')\n# before we change the configuration \n# we are going to back it up so we can restore if we need to \ncp /etc/apache2/sites-available/000-default.conf /etc/apache2/l\\\nsites-available/000-default.conf.backedup\nsed -i \"s/$ESCHTTPDIR/$ESCNEWDIR/g\" /etc/apache2/sites-available/000-default.conf\n# now we need to restart the service\n# in order to use the new configuration.\nsystemctl reload apache2\n# after every command we must check to see if there were any errors.\n# In this particular case, we restore from backup if there were\nif [ $? -ne 0 ]\n then \n     cp /etc/apache2/sites-available/000-default.conf. \\\n     backedup/etc/apache2/sites-available/000-default.conf\n# we need to exit if we triggered this condition \n# since we are finished here, nothing was changed.\n# before exit we need to reload apache once more \n# to make sure old configuration is used\n# we are doing a start and stop here \n# because reload obviously failed in the step above \n     echo \"Apache was not reloaded correctly, maybe there was \\\n     an error in the syntax\"\n     systemctl stop apache2\n     systemctl start apache2\n     return 1\nfi\n# if we came this far we need to get our firewall sorted out\n# we are adding ports 80 and 443 as permitted. \nufw allow http\nufw allow https\n# alternative to this is ufw allow \"Apache Full\" \n# but using exact ports and aliases makes this easier to read. \n# end of script\n```", "```\n#!/bin/bash\n# V1.0 / Jasmin Redzepagic / 01/11/2021\n# Distribution allowed under GNU Licence V2.0\n# script creates users from a csv file, and makes the user \n# change his password at next logon\n# argument for the script is csv file name\n# csv file is structured as follows: \n# user1,password1\n# user2,password2\n# ....\n# First thing to do is check if we have any arguments supplied\nif [ $# -eq 0 ]\n  then\n    echo \"No arguments, proper usage is $0 <CSV file>\"\nfi\n# next we need to get our information from the file\n# here we are doing it one line at a time \n# and to do that we need to adjust the delimeter \n# that shell uses to understand how values are \n# separated. \nIFS=$'\\n'\n# Read the lines into an array\nread -d '' -ra USRCREDS < $1\n# Now we are going to deal with individual lines\n# since right now our array contains both the user \n# and the appropriate password in one value\n# separated by a , character \n# we chose to do this by telling the shell \n# we want to use , as a value separator\nIFS=','\n# Iterate over the lines\nfor USER in \"${USRCREDS[@]}\"\ndo\n# Split values into separate variables\n   read usr pass <<< \"$USER\"\n# Create the user\n   useradd -m $usr\n# Set the password, we need to do this using passwd command\n# alternative would be to use a hashing function\n# passwd asks for password twice!\n   echo \"$pass\"$'\\n'\"$pass\" | passwd $usr\n# then we expire the user password\n   passwd --expire $usr\ndone\n```", "```\n#!/bin/bash\n# V1.0 / Jasmin Redzepagic / 01/11/2021\n# Distribution allowed under GNU Licence V2.0\n# script creates users from a csv file \n# creating a group specified for each user\n# and adding the user to a group\n# password is generated and printed with the username\n# argument for the script is csv file name\n# csv file is structured as follows: \n# user1,group1\n# user2,group2\n# ....\n# output is structured as: \n# user / password\n# First thing to do is check if we have any arguments supplied\nif [ $# -eq 0 ]\n  then\n    echo \"No arguments, proper usage is $0 <CSV file>\"\nfi\n# This script has to be run as root, we need to check that\nif [[ $(id -u) -ne 0 ]] \n             then \n              echo \"In order to add users and groups this \\\n              scripts needs to be run as root!\" >&2 \n              exit 1 \nfi\n# next we need to get our information from the file \n# here we are doing it one line at a time \n# and to do that we need to adjust the delimeter \n# that shell uses to understand how values are \n# separated. \nIFS=$'\\n'\n# Read the lines into an array\nread -d '' -ra USRCREDS < $1\n# Now we are going to deal with individual lines\n# since right now our array contains both the user \n# and the appropriate password in one value\n# separated by a , character \n# we chose to do this by telling the shell \n# we want to use , as a value separator\nIFS=','\n# Iterate over the lines\nfor USER in \"${USRCREDS[@]}\"\ndo\n# Split values into separate variables\nread usr grp <<< \"$USER\"\n# Create the user\nuseradd -m $usr\n\n# if the group does not exist, create it\ngetent group $grp || groupadd $grp\n# add the user to a group\nusermod -a -G $grp $usr\n# now we create a random password\npass=$(cat /dev/urandom | tr -dc A-Za-z0-9 | head -c8)\n# Set the password, we need to do this using passwd command\n# alternative would be to use a hashing function\n# passwd asks for password twice!\necho \"$pass\"$'\\n'\"$pass\" | passwd $usr\n\n# in the end we print user and password \n\necho $usr/$pass\ndone\n```", "```\n#!/bin/bash\n# V1.0 / Jasmin Redzepagic / 01/11/2021\n# Distribution allowed under GNU Licence V2.0\n# script creates a virtual machine on the host it is run on\n# asking the user for parameters of the VM\n# in this script we are going to use dialog to show\n# how a script can get values that way\nname=$(dialog --inputbox \"What is the name of the VM?\" 8 25 \\\n--output-fd 1)\ncpus=$(dialog --inputbox \"How many VCPUs?\" 8 25  --output-fd 1)\nmem=$(dialog --inputbox \"Enter the amount of memory in MB\" 8 25 \\\n--output-fd 1)\ncdrom=$(dialog --inputbox \"Path to CDROM:\" 8 25 --output-fd 1)\ndisksize=$(dialog --inputbox \"Enter the disk size:\" 8 25 \\\n--output-fd 1)\nosv=$(dialog --inputbox \"What is the OS variant installed?\" 8 \\\n25 --output-fd 1)\nvirt-install --name=$name --vcpus=$cpus --memory=$mem \\\n--cdrom=$cdrom --disk size=$disksize --os-variant=$osv\n```", "```\n#!/bin/bash\n# V1.0 / Jasmin Redzepagic / 01/11/2021\n# Distribution allowed under GNU Licence V2.0\n# script installs lamp, creates a user and assigns him SSH key\n# key is provided in a file \n# script expects filename that contains SSH key\n# First thing to do is check if we have any arguments supplied\nif [ $# -eq 0 ]\n  then\n   echo \"No arguments, proper usage is $0 <file containing SSH \\\nkey>\"\nfi\n# This script has to be run as root, we need to check that\nif [[ $(id -u) -ne 0 ]] \n             then \n                          echo \"In order to add services this \\\nscripts needs to be run as root!\" >&2 \n                          exit 1 \nfi\n# now we follow the standard installation procedure for LAMP\n# first we aquire new updates\napt update\n# then we install apache server\napt install apache2 –y\n# we reconfigure the firewall to allow all the traffic in\nufw allow \"Apache Full\"\n# then we install mysql server\n# we could also install mariadb as the alternative\napt install mysql-server –y\n# then we install php and required modules\napt install php libapache2-mod-php php-mysql –y\n# we create our user\nuseradd lampuser\n# we create directory for the ssh keys\nmkdir /home/lampuser/.ssh\n# we copy the key directly, allowing login without password\n# note that user has no password by default, only ssh works\ncp $1 /home/lampuser/.ssh/authorized_keys\n# apply permissions to files in directory\nchown -R lampuser:lampuser /home/lampuser/.ssh\nchmod 700 /home/lampuser/.ssh\nchmod 600 /home/lampuser/.ssh/authorized_keys\n# add user to sudo group enabling sudo command\nusermod -a -G sudo lampuser\n# finally we run the secure installation to finish setting up \\\nmysql\nmysql_secure_installation\n```", "```\nvirsh list –all \n```", "```\n#!/bin/bash\n# V1.0 / Jasmin Redzepagic / 01/11/2021\n# Distribution allowed under GNU Licence V2.0\n# Simple interface to virsh command\n# this script enumerates all machines on this KVM host \n# and enables user to perform basic commands\n# script is interactive and has no command line arguments\n# in this script we are going to create a simple two level menu \n# that will first ask user what virtual machine he wants to \\\n  perform commands on. \n# User has to specify the machine from a list or type ALL\n# if he wants to run the command on all the machines on the host\n# we need to get the list of virtual\nMachines\n# notice we are not redirecting errors in order for the user\n# to be able to see what actually happened \nvirsh list --all \n# then we do some rudimentary error checking to make sure\n# we are at least able to use virsh\nif [ $? -ne 0 ]\n then \n    echo \"Something is wrong with your KVM instance, exiting!\"\n    return 1\nfi \n# if we come this far our script can talk to the user\nread -p \"Choose VM you want to change state of or type ALL for \\\nall machines:\" HOSTN\necho -e \"\\n\"\nif [ $HOSTN == \"ALL\" ];\nthen\n             echo \"You chose all machines.\"\nelse\n             echo \"You chose: \" $HOSTN \".\"\nfi\necho \"What do you want to do\"\necho \"1 = START\"\necho \"2 = STOP\"\necho \"3 = RESET\"\necho \"4 = STATUS\"\necho -e \"\\n\"\nread CHOSENOP\nif [ $HOSTN == \"ALL\" ]; # we are running the commands on all the machines\n# every command is run in a loop on all the machines\nthen \n                if [ $CHOSENOP -eq 1 ];    # user chose start\n                 then\n                          for i in $(virsh list --name --all);\n                          do \n                          echo \"Starting  $i\"                          \n                          virsh start $i;\n                          done\n                          exit 0\n               elif [ $CHOSENOP -eq 2 ]; # user chose stop\n               then\n                         for i in $(virsh list --name --all);\n              do \n                         echo \"Stopping  $i\"                       virsh shutdown $i\ndone\n                         exit 0\n             elif [ $CHOSENOP -eq 3 ]; # user chose to revert \\\nto snapshot\n               then\n                          for i in $(virsh list --name --all);\n                          do \n                          echo \"Reverting $i to latest snapshot: \"               \n                          virsh snapshot-revert $i start;\n                          done\n                          exit 0\n                elif [ $CHOSENOP -eq 4 ]; # user chose to \\\n                display status of machines\n                then\n                           for i in $(virsh list --name --all);\n                           do \n                           echo \"Status of $i: \"\n                           virsh dominfo $i;\n                           done\n                           exit 0\n                else\n# user made an invalid input\n                          echo \"Input was not valid!\"\n                          exit 0\n               fi\nelse\n# we do everything the same way but with a particular VM\n\n             if [ $CHOSENOP -eq 1 ];\n             then\n                          echo \"Starting $HOSTN\"\n                          virsh start $HOSTN                            \n                          exit 0\n             elif [ $CHOSENOP -eq 2 ];\n             then\n                          echo \"Stopping $HOSTN\"\n                          virsh shutdown $HOSTN                \n                           exit 0\n             elif [ $CHOSENOP -eq 3 ];\n             then\n                          echo \"Reverting $HOSTN to last \\\n                          snapshot\"\n                          virsh snapshot-revert $HOSTN                 \n                          exit 0\n             elif [ $CHOSENOP -eq 4 ];\n             then\n                          echo \"Status of $HOSTN: \"\n                          virsh dominfo $HOSTN                \n                          exit 0\n              else\n# user made an invalid input\n                          echo \"Input was not valid!\"/ \\\n                          exit 0\n              fi\nfi\n```"]