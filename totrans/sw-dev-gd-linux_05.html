<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer045">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 class="chapterTitle" id="_idParaDest-83"><span class="koboSpan" id="kobo.2.1">Introducing Files</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">In Linux, everything is – or can be represented as – a file. </span><span class="koboSpan" id="kobo.3.2">Files are organized into a filesystem, which is just a hierarchy of files and directories (directories are just a special kind of file). </span><span class="koboSpan" id="kobo.3.3">As a developer, just about everything you do on a Linux system will require knowledge about files: writing and copying source code, building Docker images, application logging, configuring dependencies, and more.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">In this chapter, we’ll cover the details of files in Linux. </span><span class="koboSpan" id="kobo.4.2">You’ll learn about the difference between plaintext files and binary files, which are the two most common types of file content you’ll be working with. </span><span class="koboSpan" id="kobo.4.3">We’ll show you how those are laid out and organized into a filesystem “tree” in Linux, before diving into the practical commands you’ll need to create, modify, move, and edit files. </span><span class="koboSpan" id="kobo.4.4">Then we’ll complete our tour of the basics with a practical introduction to file editing, using the most commonly available command-line text editors.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5.1">However, in this chapter, we don’t stop at the basics. </span><span class="koboSpan" id="kobo.5.2">Linux files are one topic where it pays (sometimes quite literally) to dive a bit deeper into some advanced knowledge. </span><span class="koboSpan" id="kobo.5.3">After all, “working with files” is one of the primary things you’ll be doing on Linux as a developer: writing and reading source code and configuration files, searching for specific file content, copying and moving log files around, and more. </span><span class="koboSpan" id="kobo.5.4">The more efficient you are at these basics, the more competent you’ll be as a well-rounded developer who doesn’t have to google basic Linux commands over and over, or get embarrassingly stuck in a command-line text editor during a troubleshooting Zoom call with your peers. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.6.1">First, we’ll talk about searching for files in the filesystem tree and finding specific content or patterns inside individual files. </span><span class="koboSpan" id="kobo.6.2">Then, we’ll talk about special files and alternate filesystems that you’re likely to come across, and what you need to know to work with them effectively.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.7.1">By the end, you’ll know about:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">The many file types you might encounter, and what they’re used for</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">The most important kinds of file data you’ll need to work with</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">The Linux filesystem and the commands you’ll use to work with it</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">File editing basics</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Some common problems and how to avoid them</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.13.1">There’s a lot of content in this chapter, and it’s one of the most important foundations for the rest of your Linux skills. </span><span class="koboSpan" id="kobo.13.2">Make sure you understand each part before moving on – you don’t have to memorize everything on your first readthrough, but try to get as much practical experience as you can in your own Linux environment while working through this chapter. </span><span class="koboSpan" id="kobo.13.3">There’s a tangible payoff to knowing this stuff when you’re troubleshooting real-world problems or interviewing for a job.</span></p>
<h1 class="heading-1" id="_idParaDest-84"><span class="koboSpan" id="kobo.14.1">Files on Linux: the absolute basics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.15.1">In order </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.16.1">to break up the larger topic of files on Linux, let’s cover some of the absolute basics that you probably already have some intuition of: plaintext files and binary files. </span><span class="koboSpan" id="kobo.16.2">We’ll also cover a practical error that you might see if you move Windows files to a Unix system, or vice versa.</span></p>
<h2 class="heading-2" id="_idParaDest-85"><span class="koboSpan" id="kobo.17.1">Plaintext files</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.18.1">One of the</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.19.1"> simplest forms of text files you’ll encounter </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.20.1">is the mighty plaintext file. </span><span class="koboSpan" id="kobo.20.2">While historically they were ASCII files, they are now typically UTF-8 encoded. </span><span class="koboSpan" id="kobo.20.3">You might come across other file encodings, but this is rare as they are generally considered obsolete.</span></p>
<h2 class="heading-2" id="_idParaDest-86"><span class="koboSpan" id="kobo.21.1">What is a binary file?</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.22.1">Unix doesn’t differentiate</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.23.1"> between binary and text files, the way many other operating systems do. </span><span class="koboSpan" id="kobo.23.2">All files can be streamed through pipes, edited, and </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.24.1">appended to. </span><span class="koboSpan" id="kobo.24.2">A file is just a file. </span><span class="koboSpan" id="kobo.24.3">When a file is set to be executable, Unix will do its best to execute it, either</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.25.1"> succeeding in the case of </span><strong class="keyWord"><span class="koboSpan" id="kobo.26.1">ELF</span></strong><span class="koboSpan" id="kobo.27.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.28.1">Executable and Linkable Format</span></strong><span class="koboSpan" id="kobo.29.1">, probably the most widely used executable format today) or failing – for example, when trying to execute an image or audio file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.30.1">This simple mechanism opens up some amazing possibilities. </span><span class="koboSpan" id="kobo.30.2">For example, executables can be piped through a compression utility, then a network tunnel (such as SSH), before being decompressed</span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.31.1"> and written back into a file – all in one command, without any temporary files.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.32.1">It also means, however, that you should be careful to avoid creating a situation where random files, for example, ones uploaded or modified by users of a website (including log files!), have any possibility of being executed. </span><span class="koboSpan" id="kobo.32.2">This can lead to serious security issues.</span></p>
<h2 class="heading-2" id="_idParaDest-87"><span class="koboSpan" id="kobo.33.1">Line endings</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.34.1">While </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.35.1">Unix files, especially text files, function similarly to files on other operating systems, it is worth mentioning that Windows (and DOS), among others, uses a different line-ending character, which can produce errors in many programs that use those text files. </span><span class="koboSpan" id="kobo.35.2">Although this is only the case for files that were created on one kind of system and then copied to another (for example, moving a file from Linux to DOS), it’s worth knowing about.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.36.1">The reasons for the different line endings are historical, and many tools (for example, Git and various text editors) will automatically handle that difference for you. </span><span class="koboSpan" id="kobo.36.2">However, in rare circumstances, you might have to convert files manually. </span><span class="koboSpan" id="kobo.36.3">There are famous commands like </span><code class="inlineCode"><span class="koboSpan" id="kobo.37.1">dos2unix</span></code><span class="koboSpan" id="kobo.38.1"> to do so, but these have to be manually installed on most Unix-like operating systems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.39.1">There are, however, some methods to convert them using more traditional utilities.</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.40.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.41.1">sed</span></code><span class="koboSpan" id="kobo.42.1">: </span><code class="inlineCode"><span class="koboSpan" id="kobo.43.1">sed 's/^M$//' original_dos_file &gt; unix_file</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.44.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.45.1">tr</span></code><span class="koboSpan" id="kobo.46.1">: </span><code class="inlineCode"><span class="koboSpan" id="kobo.47.1">tr -d '\r' &lt; original_dos_file &gt; unix_file</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.48.1">In place, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.49.1">perl</span></code><span class="koboSpan" id="kobo.50.1">: </span><code class="inlineCode"><span class="koboSpan" id="kobo.51.1">perl -pi -e 's/\r\n/\n/g' original_file</span></code></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.52.1">Now that we’ve talked about the crucial basic concepts you need to know to understand files on Unix-like systems, let’s talk about the context that all of these files actually exist in: the Linux filesystem.</span></p>
<h1 class="heading-1" id="_idParaDest-88"><span class="koboSpan" id="kobo.53.1">The filesystem tree</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.54.1">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.55.1">Filesystem Hierarchy Standard</span></strong><span class="koboSpan" id="kobo.56.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.57.1">FHS</span></strong><span class="koboSpan" id="kobo.58.1">) describes</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.59.1"> the </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.60.1">conventional directory layout of Unix-like systems. </span><span class="koboSpan" id="kobo.60.2">Linux conforms to this standard, essentially making it “the official folder structure of Linux.” </span><span class="koboSpan" id="kobo.60.3">The FHS is a standardized tree structure where every file and directory stems from the root (a directory simply named “</span><code class="inlineCode"><span class="koboSpan" id="kobo.61.1">/</span></code><span class="koboSpan" id="kobo.62.1">"). </span><span class="koboSpan" id="kobo.62.2">This hierarchy is crucial: although there’s a place for end-users to go wild with their own directory structure, every single subdirectory inside of </span><code class="inlineCode"><span class="koboSpan" id="kobo.63.1">/</span></code><span class="koboSpan" id="kobo.64.1"> (the root directory) has a specific purpose.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.65.1">The basic layout </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.66.1">of this filesystem hierarchy doesn’t take long to learn, and by investing a few minutes now, you’ll develop an intuition for where things go – whether they’re application binaries, logs, data files, or external devices that your code needs access to. </span><span class="koboSpan" id="kobo.66.2">In other words, it eases both development and troubleshooting: when you know where things </span><em class="italic"><span class="koboSpan" id="kobo.67.1">should</span></em><span class="koboSpan" id="kobo.68.1"> be, you spend less time confused and unsure of where to look during an incident. </span><span class="koboSpan" id="kobo.68.2">Additionally, this knowledge is required when it comes to writing your own scripts and doing the light system administration tasks expected of a senior developer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.69.1">Here are some of the important places in the filesystem that you’ll often see referenced, or have to use yourself:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.70.1">/etc</span></code><span class="koboSpan" id="kobo.71.1">: System and software configuration files go here, organized into many subdirectories.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.72.1">/bin</span></code><span class="koboSpan" id="kobo.73.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.74.1">/sbin</span></code><span class="koboSpan" id="kobo.75.1">: System binaries go here. </span><span class="koboSpan" id="kobo.75.2">Don’t mess with these.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.76.1">/usr/bin</span></code><span class="koboSpan" id="kobo.77.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.78.1">/usr/local/bin</span></code><span class="koboSpan" id="kobo.79.1">: Your installed software and your own binaries go here, so that anyone on the system can see and execute them.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.80.1">/var/log</span></code><span class="koboSpan" id="kobo.81.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.82.1">/var/lib</span></code><span class="koboSpan" id="kobo.83.1">: </span><code class="inlineCode"><span class="koboSpan" id="kobo.84.1">/var</span></code><span class="koboSpan" id="kobo.85.1"> contains variable data, things that are prone to change while the system is running, such as application logs (</span><code class="inlineCode"><span class="koboSpan" id="kobo.86.1">/var/log</span></code><span class="koboSpan" id="kobo.87.1">) and dynamic libraries (</span><code class="inlineCode"><span class="koboSpan" id="kobo.88.1">/var/lib</span></code><span class="koboSpan" id="kobo.89.1">), files, and other state for running applications.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.90.1">/var/lib/systemd</span></code><span class="koboSpan" id="kobo.91.1">: One of several places on the filesystem that contain </span><code class="inlineCode"><span class="koboSpan" id="kobo.92.1">systemd</span></code><span class="koboSpan" id="kobo.93.1"> configuration.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.94.1">/etc/systemd/system</span></code><span class="koboSpan" id="kobo.95.1">: A good place for custom system unit files, if you’re creating services.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.96.1">/dev</span></code><span class="koboSpan" id="kobo.97.1">: A special filesystem used to represent hardware devices.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.98.1">/proc</span></code><span class="koboSpan" id="kobo.99.1">: A special filesystem used to query or change system state.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-89"><span class="koboSpan" id="kobo.100.1">Basic filesystem operations</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.101.1">It’s time to dive</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.102.1"> into the foundational Unix commands you’ll use every single day as a developer. </span><span class="koboSpan" id="kobo.102.2">This set of commands will allow you to accomplish a range of basic command-line tasks you need to do on any system you interact with. </span><span class="koboSpan" id="kobo.102.3">Once you have learned and practiced the commands in this chapter, you’ll be able to do things like:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.103.1">Follow your application logs in real time.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.104.1">Fix a broken configuration file to get your application working.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.105.1">Move from one directory to another in a Git repository on your local macOS development machine.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.106.1">Let’s get started with listing a directory. </span><span class="koboSpan" id="kobo.106.2">Make sure you’re logged in to a Linux or Unix system (Ubuntu or macOS is fine), and have the Terminal application open, ready to follow along.</span></p>
<h2 class="heading-2" id="_idParaDest-90"><span class="koboSpan" id="kobo.107.1">ls</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.108.1">List a file or</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.109.1"> directory. </span><span class="koboSpan" id="kobo.109.2">This command is similar to “opening a folder” in a </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.110.1">graphical user interface. </span><span class="koboSpan" id="kobo.110.2">It lists the contents of the directory it’s given. </span><span class="koboSpan" id="kobo.110.3">By default, it uses your current directory:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.111.1">/home/steve# ls
my_document.txt
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.112.1">In this example, my shell’s current location is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.113.1">/home/steve</span></code><span class="koboSpan" id="kobo.114.1"> directory, which contains a single file (</span><code class="inlineCode"><span class="koboSpan" id="kobo.115.1">my_document.txt</span></code><span class="koboSpan" id="kobo.116.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.117.1">You can ask </span><code class="inlineCode"><span class="koboSpan" id="kobo.118.1">ls</span></code><span class="koboSpan" id="kobo.119.1"> to list any directory path on the system, though, by passing the directory as an argument:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.120.1">/home/steve# ls /var/log/
alternatives.log  apt  bootstrap.log  btmp  dpkg.log  faillog  lastlog  wtmp
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.121.1">For a more orderly output, you may want to add the “</span><code class="inlineCode"><span class="koboSpan" id="kobo.122.1">-l</span></code><span class="koboSpan" id="kobo.123.1">" option. </span><span class="koboSpan" id="kobo.123.2">This will give you a “long listing,” which means a single file or directory per line, along with extra information.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.124.1"># ls -l /var/log/
total 296
-rw-r--r-- 1 root root   4686 Jun 24 02:31 alternatives.log
drwxr-xr-x 2 root root   4096 Jun 24 02:31 apt
-rw-r--r-- 1 root root  64547 Jun 24 02:06 bootstrap.log
-rw-rw---- 1 root utmp      0 Jun 24 02:06 btmp
-rw-r--r-- 1 root root 177139 Jun 24 02:31 dpkg.log
-rw-r--r-- 1 root root  32032 Oct 28 14:26 faillog
-rw-rw-r-- 1 root utmp 296296 Oct 28 14:26 lastlog
-rw-rw-r-- 1 root utmp      0 Jun 24 02:06 wtmp
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.125.1">In short, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.126.1">ls</span></code><span class="koboSpan" id="kobo.127.1"> command is how you “look around” on a Unix filesystem.</span></p>
<h2 class="heading-2" id="_idParaDest-91"><span class="koboSpan" id="kobo.128.1">pwd</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.129.1">Short </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.130.1">for “print working directory.” </span><span class="koboSpan" id="kobo.130.2">This shows “where you are” on</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.131.1"> the filesystem, in the context of your current shell session. </span><span class="koboSpan" id="kobo.131.2">If I’m logged in to a Linux system as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.132.1">steve</span></code><span class="koboSpan" id="kobo.133.1"> user, and I’m in my home directory, I can expect to see </span><code class="inlineCode"><span class="koboSpan" id="kobo.134.1">pwd</span></code><span class="koboSpan" id="kobo.135.1"> print something like this:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.136.1">pwd
/home/steve
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-92"><span class="koboSpan" id="kobo.137.1">cd</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.138.1">Change</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.139.1"> the</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.140.1"> current working directory in your shell. </span><span class="koboSpan" id="kobo.140.2">The commands you run after using this command will run from the perspective of your new, changed location on the filesystem.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.141.1">Here’s an example directory:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.142.1">Desktop
├── anotherfile
├── documents
│   └── contract.txt
├── somefile.txt
└── stuff
    ├── nothing
    └── important
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.143.1">If you’re sitting in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.144.1">Desktop</span></code><span class="koboSpan" id="kobo.145.1"> directory, but then change to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.146.1">documents</span></code><span class="koboSpan" id="kobo.147.1"> directory with </span><code class="inlineCode"><span class="koboSpan" id="kobo.148.1">cd documents</span></code><span class="koboSpan" id="kobo.149.1">, you’ll get a different listing from that new perspective when using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.150.1">ls</span></code><span class="koboSpan" id="kobo.151.1"> command. </span><span class="koboSpan" id="kobo.151.2">Let’s see this in action:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.152.1">/home/steve/Desktop# ls
anotherfile  documents  somefile.txt  stuff
/home/steve/Desktop# cd documents/
/home/steve/Desktop/documents# ls
contract.txt
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.153.1">Now that we can see our surroundings (</span><code class="inlineCode"><span class="koboSpan" id="kobo.154.1">ls</span></code><span class="koboSpan" id="kobo.155.1">), move around on the filesystem (</span><code class="inlineCode"><span class="koboSpan" id="kobo.156.1">cd</span></code><span class="koboSpan" id="kobo.157.1">), and find out where we are (</span><code class="inlineCode"><span class="koboSpan" id="kobo.158.1">pwd</span></code><span class="koboSpan" id="kobo.159.1">), let’s get into actually affecting the filesystem by creating and modifying files.</span></p>
<h2 class="heading-2" id="_idParaDest-93"><span class="koboSpan" id="kobo.160.1">touch</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.161.1">This</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.162.1"> operation is written as</span><code class="inlineCode"><span class="koboSpan" id="kobo.163.1"> touch filepath</span></code><span class="koboSpan" id="kobo.164.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.165.1">Depending on whether the filepath you give it already exists or not, this </span><code class="inlineCode"><span class="koboSpan" id="kobo.166.1">touch</span></code><span class="koboSpan" id="kobo.167.1"> command will do one of two things:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.168.1">If a file does not already exist at that path, </span><code class="inlineCode"><span class="koboSpan" id="kobo.169.1">touch</span></code><span class="koboSpan" id="kobo.170.1"> will create it:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.171.1">→  /tmp touch filepath
→  /tmp ls -l filepath
-rw-r--r--  1 dcohen  wheel  0 Aug  7 16:02 filepath
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.172.1">If a file </span><em class="italic"><span class="koboSpan" id="kobo.173.1">does</span></em><span class="koboSpan" id="kobo.174.1"> exist at that path, </span><code class="inlineCode"><span class="koboSpan" id="kobo.175.1">touch</span></code><span class="koboSpan" id="kobo.176.1"> will update the access and modification times for that file:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.177.1">→  /tmp touch filepath
→  /tmp ls -l filepath
-rw-r--r--  1 dcohen  wheel  0 Aug  7 16:03 filepath
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.178.1">Notice that the only thing that’s changed is the modification time shown in the long listing.</span></p>
<h2 class="heading-2" id="_idParaDest-94"><span class="koboSpan" id="kobo.179.1">less</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.180.1">less</span></code><span class="koboSpan" id="kobo.181.1"> is</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.182.1"> what’s known as a “pager” – a program that allows you to </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.183.1">view file content, one screen (page) at a time:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.184.1">less /etc/hosts
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.185.1">It’s interactive – once you’re using it to view a file, you can:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.186.1">Scroll up or down, line by line, using your mouse wheel or arrow keys.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.187.1">Scroll down a whole page with </span><strong class="keyWord"><span class="koboSpan" id="kobo.188.1">SPACE</span></strong><span class="koboSpan" id="kobo.189.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.190.1">Search with </span><em class="keystroke"><span class="koboSpan" id="kobo.191.1">/</span></em><span class="koboSpan" id="kobo.192.1"> (enter your search pattern) </span><em class="keystroke"><span class="koboSpan" id="kobo.193.1">RETURN</span></em><span class="koboSpan" id="kobo.194.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.195.1">Go to the next match: </span><strong class="keyWord"><span class="koboSpan" id="kobo.196.1">n</span></strong><span class="koboSpan" id="kobo.197.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.198.1">Use </span><strong class="keyWord"><span class="koboSpan" id="kobo.199.1">q</span></strong><span class="koboSpan" id="kobo.200.1"> to quit the program.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.201.1">Practice using it for a minute or two, and you’ll be fine.</span></p>
<h2 class="heading-2" id="_idParaDest-95"><span class="koboSpan" id="kobo.202.1">tail</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.203.1">tail</span></code><span class="koboSpan" id="kobo.204.1"> is </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.205.1">used </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.206.1">to view the last few lines of a file.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.207.1">tail /some/file
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.208.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.209.1">-f</span></code><span class="koboSpan" id="kobo.210.1"> (follow) option for tail is very useful for live-streaming logs to your terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.211.1">tail -f /var/log/some.log
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.212.1">Use </span><strong class="keyWord"><span class="koboSpan" id="kobo.213.1">q</span></strong><span class="koboSpan" id="kobo.214.1"> to quit </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.215.1">out of tail.</span></p>
<h2 class="heading-2" id="_idParaDest-96"><span class="koboSpan" id="kobo.216.1">mv</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.217.1">mv</span></code><span class="koboSpan" id="kobo.218.1"> (move) is</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.219.1"> used</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.220.1"> to move and rename files.</span></p>
<h3 class="heading-3" id="_idParaDest-97"><span class="koboSpan" id="kobo.221.1">Moving</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.222.1">Imagine </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.223.1">you have a file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.224.1">somefile.txt</span></code><span class="koboSpan" id="kobo.225.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.226.1">→  Desktop ls -alh somefile.txt
-rw-r--r--  1 dcohen  wheel     0B Aug  7 11:02 somefile.txt
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.227.1">Provided you’re sitting in the same directory as the file, here’s how you’d move it to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.228.1">/var/log</span></code><span class="koboSpan" id="kobo.229.1"> directory, without renaming it:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.230.1">mv somefile.txt /var/log/
</span></code></pre>
<h3 class="heading-3" id="_idParaDest-98"><span class="koboSpan" id="kobo.231.1">Renaming</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.232.1">Now you </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.233.1">want to rename that file to </span><code class="inlineCode"><span class="koboSpan" id="kobo.234.1">foobar</span></code><span class="koboSpan" id="kobo.235.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.236.1">mv /var/log/somefile /var/log/foobar
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.237.1">That’s it!</span></p>
<h2 class="heading-2" id="_idParaDest-99"><span class="koboSpan" id="kobo.238.1">cp</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.239.1">To </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.240.1">copy </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.241.1">files and directories, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.242.1">cp</span></code><span class="koboSpan" id="kobo.243.1"> command:</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.244.1">cp file destination</span></code><span class="koboSpan" id="kobo.245.1"> copies a file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.246.1">file</span></code><span class="koboSpan" id="kobo.247.1"> to a destination filepath, </span><code class="inlineCode"><span class="koboSpan" id="kobo.248.1">destination</span></code><span class="koboSpan" id="kobo.249.1">. </span><span class="koboSpan" id="kobo.249.2">The most commonly used option is </span><code class="inlineCode"><span class="koboSpan" id="kobo.250.1">-r</span></code><span class="koboSpan" id="kobo.251.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.252.1">–recursive</span></code><span class="koboSpan" id="kobo.253.1">; if you’re copying a directory, this will copy </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.254.1">everything</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.255.1"> inside as well.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.256.1">cp -r /home/dave /storage/userbackups/
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-100"><span class="koboSpan" id="kobo.257.1">mkdir</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.258.1">Create </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.259.1">a new, empty </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.260.1">directory named </span><code class="inlineCode"><span class="koboSpan" id="kobo.261.1">directoryname</span></code><span class="koboSpan" id="kobo.262.1"> with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.263.1">mkdir directoryname
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.264.1">A useful option is </span><code class="inlineCode"><span class="koboSpan" id="kobo.265.1">-p</span></code><span class="koboSpan" id="kobo.266.1">, which allows you to create nested directories in a single command. </span><span class="koboSpan" id="kobo.266.2">For example, if you want to create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.267.1">Documents</span></code><span class="koboSpan" id="kobo.268.1"> directory that contains a directory named </span><code class="inlineCode"><span class="koboSpan" id="kobo.269.1">school</span></code><span class="koboSpan" id="kobo.270.1">, which in turn contains a directory named </span><code class="inlineCode"><span class="koboSpan" id="kobo.271.1">reports</span></code><span class="koboSpan" id="kobo.272.1">, you could run the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.273.1">mkdir -p Documents/school/reports
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-101"><span class="koboSpan" id="kobo.274.1">rm</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.275.1">rm</span></code><span class="koboSpan" id="kobo.276.1"> removes (deletes) files</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.277.1"> and </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.278.1">directories:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.279.1">rm filename</span></code><span class="koboSpan" id="kobo.280.1"> deletes a file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.281.1">filename</span></code><span class="koboSpan" id="kobo.282.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.283.1">rm -r directoryname</span></code><span class="koboSpan" id="kobo.284.1"> will delete a directory named </span><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">directoryname</span></code><span class="koboSpan" id="kobo.286.1">, and every file and directory inside of it, recursively.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.287.1">There’s a separate command for deleting empty directories named </span><code class="inlineCode"><span class="koboSpan" id="kobo.288.1">rmdir</span></code><span class="koboSpan" id="kobo.289.1">, but it’s usually only used in scripts where developers are being careful to limit the blast radius of an unintentional deletion.</span></p>
<h1 class="heading-1" id="_idParaDest-102"><span class="koboSpan" id="kobo.290.1">Editing files</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.291.1">Whether it’s updating</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.292.1"> configuration files, creating new Linux services, or taking notes during a troubleshooting session, your work on Linux is occasionally going to require you to edit files on the command line. </span><span class="koboSpan" id="kobo.292.2">We’re going to cover command-line file editing in detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.293.1">Chapter 6</span></em><span class="koboSpan" id="kobo.294.1">, </span><em class="italic"><span class="koboSpan" id="kobo.295.1">Editing Files on the Command Line</span></em><span class="koboSpan" id="kobo.296.1">, but we’ll give you a very brief overview here.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.297.1">If you’re limited to a command-line-only environment, there are a few CLI text editors you might use:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.298.1">nano</span></strong><span class="koboSpan" id="kobo.299.1">: Almost always installed or available; easy to use</span><strong class="keyWord"> </strong></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.300.1">vi</span></strong><span class="koboSpan" id="kobo.301.1">: Installed almost everywhere; takes a bit of getting used to</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.302.1">vim</span></strong><span class="koboSpan" id="kobo.303.1">: Easy to install everywhere; more full-featured than </span><code class="inlineCode"><span class="koboSpan" id="kobo.304.1">vi</span></code></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.305.1">If any of these </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.306.1">are not installed, you can install them via your package manager. </span><span class="koboSpan" id="kobo.306.2">For example, if you’re using Ubuntu Linux, that’ll be a command like </span><code class="inlineCode"><span class="koboSpan" id="kobo.307.1">sudo apt-get install nano</span></code><span class="koboSpan" id="kobo.308.1"> (or substitute </span><code class="inlineCode"><span class="koboSpan" id="kobo.309.1">nano</span></code><span class="koboSpan" id="kobo.310.1"> for </span><code class="inlineCode"><span class="koboSpan" id="kobo.311.1">vim</span></code><span class="koboSpan" id="kobo.312.1">). </span><span class="koboSpan" id="kobo.312.2">We’ll dive deeper into package management commands in </span><em class="chapterRef"><span class="koboSpan" id="kobo.313.1">Chapter 9</span></em><span class="koboSpan" id="kobo.314.1">, </span><em class="italic"><span class="koboSpan" id="kobo.315.1">Managing Installed Software</span></em><span class="koboSpan" id="kobo.316.1">. </span><span class="koboSpan" id="kobo.316.2">Regardless of which editor you choose, you’ll edit a file by simply typing </span><code class="inlineCode"><span class="koboSpan" id="kobo.317.1">[$EDITOR filename]</span></code><span class="koboSpan" id="kobo.318.1"> on the command line; for example:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.319.1">vi filename
vim /some/file
nano /another/file
</span></code></pre>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.320.1">If the file exists, you’ll be able to edit it in your editor.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.321.1">If it doesn’t, but the directory exists, you’ll create a new file at that path the first time you save it in the editor.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.322.1">If the directory doesn’t exist, you might be able to edit the file, but the editor won’t be able to write it to the filesystem without a few extra steps.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.323.1">In the next chapter, </span><em class="chapterRef"><span class="koboSpan" id="kobo.324.1">Chapter 6</span></em><span class="koboSpan" id="kobo.325.1">, </span><em class="italic"><span class="koboSpan" id="kobo.326.1">Editing Files on the Command Line</span></em><span class="koboSpan" id="kobo.327.1">, we’re going to dive much more deeply into the practical skills involved in file editing on the Linux command line. </span><span class="koboSpan" id="kobo.327.2">If you absolutely need to edit a file before you finish this chapter, just type nano </span><code class="inlineCode"><span class="koboSpan" id="kobo.328.1">/path/to/the/file</span></code><span class="koboSpan" id="kobo.329.1"> and follow the on-screen cheatsheet to save and quit. </span><span class="koboSpan" id="kobo.329.2">In the meantime, let’s learn about the many kinds of files you’ll run into as a developer on Linux.</span></p>
<h1 class="heading-1" id="_idParaDest-103"><span class="koboSpan" id="kobo.330.1">File types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.331.1">We’ve already </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.332.1">covered “regular” files, such as plaintext files or the binary data in your image files and executable programs. </span><span class="koboSpan" id="kobo.332.2">But there are several other file types that you’ll need to know how to recognize and work with in Linux. </span><span class="koboSpan" id="kobo.332.3">Whether you’re looking for the USB stick or keyboard you just plugged into your machine, creating a link that points to a file, or inspecting the network sockets that a web process has opened, you’ll want to know a bit about </span><em class="italic"><span class="koboSpan" id="kobo.333.1">all</span></em><span class="koboSpan" id="kobo.334.1"> of these.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.335.1">Here are all of the Linux file types and what they’re used for:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.336.1">Regular file</span></strong><span class="koboSpan" id="kobo.337.1">: This is </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.338.1">the most common file type, containing text or binary data. </span><span class="koboSpan" id="kobo.338.2">As a software engineer, you’ll encounter regular files in nearly every programming task, whether you’re writing code, editing configuration files, or executing programs. </span><span class="koboSpan" id="kobo.338.3">A typical example that you might see in a long listing could be a source code file like:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.339.1">-rw-r--r-- 1 dave dave 210 Jan 04 09:30 main.c
</span></code></pre>
</li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.340.1">Directory</span></strong><span class="koboSpan" id="kobo.341.1">: Directories are</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.342.1"> special files that are used to organize other files and directories. </span><span class="koboSpan" id="kobo.342.2">You’re already familiar with directories if you’ve ever used Windows or macOS (where they’re called “folders”); they contain other files and directories. </span><span class="koboSpan" id="kobo.342.3">In a long listing, a directory like </span><code class="inlineCode"><span class="koboSpan" id="kobo.343.1">/etc</span></code><span class="koboSpan" id="kobo.344.1"> will appear as:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.345.1">drwxr-xr-x 5 root root 4096 Jan 04 09:21 /etc
</span></code></pre>
</li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.346.1">Block special</span></strong><span class="koboSpan" id="kobo.347.1">: This </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.348.1">special file type provides buffered access to hardware devices, which makes them particularly useful for devices like hard disks where data is accessed in large, fixed-size blocks. </span><span class="koboSpan" id="kobo.348.2">You’ll rarely work with these directly, except when mounting filesystems. </span><span class="koboSpan" id="kobo.348.3">An example could be a hard disk partition, shown as:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.349.1">brw-rw---- 1 root disk 8, 2 Jan 19 11:00 sda2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.350.1">This represents a block device with read and write permissions for the owner and group.</span></p>
</li>
</ul>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.351.1">Character special</span></strong><span class="koboSpan" id="kobo.352.1">: Similar </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.353.1">to block files, character files provide unbuffered, raw access to hardware devices, but they are designed for devices where data is not block-oriented, like keyboards or mice. </span><span class="koboSpan" id="kobo.353.2">You’ll never need to worry about these, although you may occasionally use them in the course of your work (for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">/dev/urandom</span></code><span class="koboSpan" id="kobo.355.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.356.1">/dev/null</span></code><span class="koboSpan" id="kobo.357.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">/dev/zero</span></code><span class="koboSpan" id="kobo.359.1">). </span><span class="koboSpan" id="kobo.359.2">A character device like a terminal might appear in a long listing as:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.360.1">crw-rw-rw- 1 root tty 5, 1 Jan 19 22:00 /dev/tty1
</span></code></pre>
</li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.361.1">FIFO special (“named pipes”)</span></strong><span class="koboSpan" id="kobo.362.1">: Named pipes, not to be confused with the anonymous pipes </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.363.1">frequently used in shells, are used for interprocess communication. </span><span class="koboSpan" id="kobo.363.2">You’ll almost never have to deal with these, although </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.364.1">you’ll be using their anonymous cousins to become a Unix wizard in </span><em class="chapterRef"><span class="koboSpan" id="kobo.365.1">Chapter 11</span></em><span class="koboSpan" id="kobo.366.1">, </span><em class="italic"><span class="koboSpan" id="kobo.367.1">Pipes and Redirection</span></em><span class="koboSpan" id="kobo.368.1">. </span><span class="koboSpan" id="kobo.368.2">You won’t often come across these, but one example is a named pipe file, which might look like this:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.369.1">prw-r--r-- 1 user user 0 Jan 21 10:00 mynamedpipe
</span></code></pre>
</li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.370.1">Links</span></strong><span class="koboSpan" id="kobo.371.1">: Links</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.372.1"> are a kind of shortcut to another file. </span><span class="koboSpan" id="kobo.372.2">There are two types of links – hard and symbolic (soft). </span><span class="koboSpan" id="kobo.372.3">You’ll almost never need to deal with hard links, but you might use symbolic links to create convenient paths to frequently accessed files or to ensure multiple paths lead to the same file. </span><span class="koboSpan" id="kobo.372.4">We’ll cover these more below. </span><span class="koboSpan" id="kobo.372.5">A symbolic link may appear as:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.373.1">lrwxrwxrwx 1 user user 7 Jan 21 10:30 versions/latest -&gt; bin/app-3.1
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.374.1">This example indicates a link named </span><code class="inlineCode"><span class="koboSpan" id="kobo.375.1">latest</span></code><span class="koboSpan" id="kobo.376.1"> that points to a file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.377.1">app-3.1</span></code><span class="koboSpan" id="kobo.378.1">.</span></p>
</li>
</ul>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.379.1">Sockets</span></strong><span class="koboSpan" id="kobo.380.1">: Unix </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.381.1">sockets are used for IPC, similar to pipe files. </span><span class="koboSpan" id="kobo.381.2">You might encounter socket files when troubleshooting services that need to talk to each other (“Why is nginx not able to reach my application server?”). </span><span class="koboSpan" id="kobo.381.3">A socket file – in this case a socket used by nginx and </span><code class="inlineCode"><span class="koboSpan" id="kobo.382.1">php-fpm</span></code><span class="koboSpan" id="kobo.383.1"> to communicate so that a WordPress application can run – might look like this:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.384.1">srwxrwx--- 1 root socket 0 Jan 23 11:31 /run/wordpress.sock
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.385.1">This list has covered the additional, special file types you might encounter, and given you some intuition about how (and why) you might encounter them in the wild. </span><span class="koboSpan" id="kobo.385.2">To help you build useful practical skills, there are a few types in particular that we should explore in more detail. </span><span class="koboSpan" id="kobo.385.3">Let’s start by getting some real-world experience with the most common of these special file types: links.</span></p>
<h2 class="heading-2" id="_idParaDest-104"><span class="koboSpan" id="kobo.386.1">Symbolic links</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.387.1">Symbolic links, often</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.388.1"> referred to as symlinks or soft links, are a type of file</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.389.1"> that serves as a reference to another file or directory. </span><span class="koboSpan" id="kobo.389.2">Unlike a hard link, a symbolic link can point to a file or directory across different filesystems, and it maintains a separate inode from the file or directory it references.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.390.1">You can </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.391.1">create a symbolic link using this basic syntax:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.392.1">ln -s document.txt /path/to/create/link
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.393.1">ln</span></code><span class="koboSpan" id="kobo.394.1"> (lowercase L) is the “link” command.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.395.1">For example, if</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.396.1"> you have a file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.397.1">file1.txt</span></code><span class="koboSpan" id="kobo.398.1"> in your current directory and you want to create a symlink to it named </span><code class="inlineCode"><span class="koboSpan" id="kobo.399.1">link1</span></code><span class="koboSpan" id="kobo.400.1">, you would use the command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.401.1">ln -s file1.txt link1
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.402.1">Now, if you do a long listing of your directory with </span><code class="inlineCode"><span class="koboSpan" id="kobo.403.1">ls -l</span></code><span class="koboSpan" id="kobo.404.1">, you will see </span><code class="inlineCode"><span class="koboSpan" id="kobo.405.1">link1</span></code><span class="koboSpan" id="kobo.406.1"> listed as a link to </span><code class="inlineCode"><span class="koboSpan" id="kobo.407.1">file1.txt</span></code><span class="koboSpan" id="kobo.408.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.409.1">ls -l
total 0
-rw-r--r-- 1 root root 0 Oct 28 16:08 file1.txt
lrwxrwxrwx 1 root root 9 Oct 29 17:20 link1 -&gt; file1.txt
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.410.1">When you access </span><code class="inlineCode"><span class="koboSpan" id="kobo.411.1">link1</span></code><span class="koboSpan" id="kobo.412.1">, for example, by printing out the file’s contents using </span><code class="inlineCode"><span class="koboSpan" id="kobo.413.1">cat link1</span></code><span class="koboSpan" id="kobo.414.1">, the system will automatically dereference the link and give you the contents of </span><code class="inlineCode"><span class="koboSpan" id="kobo.415.1">file1.txt</span></code><span class="koboSpan" id="kobo.416.1">. </span><span class="koboSpan" id="kobo.416.2">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.417.1">file1.txt</span></code><span class="koboSpan" id="kobo.418.1"> is moved, deleted, or renamed, the symbolic link will not update automatically and will be left pointing to a non-existing file (a broken link).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.419.1">Symbolic links are particularly useful for creating shortcuts, organizing files and directories, and maintaining flexible and logical filesystem structures.</span></p>
<h2 class="heading-2" id="_idParaDest-105"><span class="koboSpan" id="kobo.420.1">Hard links</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.421.1">A</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.422.1"> hard link is </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.423.1">an additional name for an existing file on the same filesystem, effectively acting as an alias. </span><span class="koboSpan" id="kobo.423.2">Both the original file and the hard link share the same inode, meaning changes to one are reflected in the other. </span><span class="koboSpan" id="kobo.423.3">Unlike symbolic links, hard links can’t cross filesystem boundaries or link to directories. </span><span class="koboSpan" id="kobo.423.4">If the original file is removed, the hard link will still maintain the data. </span><span class="koboSpan" id="kobo.423.5">To create a hard link named </span><code class="inlineCode"><span class="koboSpan" id="kobo.424.1">link1</span></code><span class="koboSpan" id="kobo.425.1"> to a file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.426.1">file1.txt</span></code><span class="koboSpan" id="kobo.427.1">, you would use the command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.428.1">ln file1.txt link1.
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-106"><span class="koboSpan" id="kobo.429.1">The file command</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.430.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.431.1">file</span></code><span class="koboSpan" id="kobo.432.1"> command </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.433.1">is a utility that can let you inspect the type of a file. </span><span class="koboSpan" id="kobo.433.2">The basic usage of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.434.1">file</span></code><span class="koboSpan" id="kobo.435.1"> command is simple: type </span><code class="inlineCode"><span class="koboSpan" id="kobo.436.1">file</span></code><span class="koboSpan" id="kobo.437.1"> followed by the filename. </span><span class="koboSpan" id="kobo.437.2">For example:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.438.1">file mysecret.txt
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.439.1">might output </span><code class="inlineCode"><span class="koboSpan" id="kobo.440.1">mysecret.txt: ASCII text</span></code><span class="koboSpan" id="kobo.441.1">, indicating that </span><code class="inlineCode"><span class="koboSpan" id="kobo.442.1">mysecret.txt</span></code><span class="koboSpan" id="kobo.443.1"> is a plaintext file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.444.1">If you have a binary file, like a compiled program named </span><code class="inlineCode"><span class="koboSpan" id="kobo.445.1">mybinary</span></code><span class="koboSpan" id="kobo.446.1">, running </span><code class="inlineCode"><span class="koboSpan" id="kobo.447.1">file mybinary</span></code><span class="koboSpan" id="kobo.448.1"> might output something like </span><code class="inlineCode"><span class="koboSpan" id="kobo.449.1">mybinary: ELF 64-bit LSB executable</span></code><span class="koboSpan" id="kobo.450.1">, indicating that </span><code class="inlineCode"><span class="koboSpan" id="kobo.451.1">program</span></code><span class="koboSpan" id="kobo.452.1"> is a binary executable file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.453.1">For a directory, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.454.1">/home/user</span></code><span class="koboSpan" id="kobo.455.1">, running </span><code class="inlineCode"><span class="koboSpan" id="kobo.456.1">file /home/user</span></code><span class="koboSpan" id="kobo.457.1"> will likely return </span><code class="inlineCode"><span class="koboSpan" id="kobo.458.1">/home/user: directory</span></code><span class="koboSpan" id="kobo.459.1">, signifying that </span><code class="inlineCode"><span class="koboSpan" id="kobo.460.1">/home/user</span></code><span class="koboSpan" id="kobo.461.1"> is a directory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.462.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.463.1">file</span></code><span class="koboSpan" id="kobo.464.1"> command is a powerful tool for quickly understanding the types of files you’re working with, especially when dealing with unknown or unfamiliar files.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.465.1">If you feel like exploring, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.466.1">file</span></code><span class="koboSpan" id="kobo.467.1"> command to inspect the following files:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.468.1">file /bin/sh</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.469.1">file /dev/zero</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.470.1">file /dev/urandom</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.471.1">file /dev/sda1</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.472.1">file ~/.bashrc</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.473.1">file /bin/ls</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.474.1">file /home</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.475.1">file /proc/1/cwd</span></code></li>
</ul>
<h1 class="heading-1" id="_idParaDest-107"><span class="koboSpan" id="kobo.476.1">Advanced file operations</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.477.1">When </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.478.1">you’re working with files in Unix-like operating systems, you’ll often want to perform actions on them, with them, or with their content, but without directly modifying them in an editor. </span><span class="koboSpan" id="kobo.478.2">For example, you may want to:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.479.1">Search a file to see if it contains some content you’re looking for.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.480.1">Identify a batch of files that was modified at a specific time.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.481.1">Securely move a file to another system, instead of just copying it around with </span><code class="inlineCode"><span class="koboSpan" id="kobo.482.1">mv</span></code><span class="koboSpan" id="kobo.483.1"> on the local machine.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.484.1">You may even want to combine all three into a single action! </span><span class="koboSpan" id="kobo.484.2">This type of knowledge can really come in handy during troubleshooting (searching for a specific request ID or error code in a log), during development (finding recently modified source code files), or when you want to do some testing (copying updated application source code to a test system).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.485.1">Here’s a quick look at these kinds of file operations, to give you an idea of the tools and commands you’ll use to accomplish them.</span></p>
<h2 class="heading-2" id="_idParaDest-108"><span class="koboSpan" id="kobo.486.1">Searching file content with grep</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.487.1">Text matching is </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.488.1">traditionally done with </span><code class="inlineCode"><span class="koboSpan" id="kobo.489.1">grep</span></code><span class="koboSpan" id="kobo.490.1">. </span><span class="koboSpan" id="kobo.490.2">On your personal or work laptop, you may want to install </span><code class="inlineCode"><span class="koboSpan" id="kobo.491.1">ag</span></code><span class="koboSpan" id="kobo.492.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.493.1">rg</span></code><span class="koboSpan" id="kobo.494.1">, which are more programmer-friendly and faster versions of this idea (for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.495.1">sudo apt-get install silversearcher-ag</span></code><span class="koboSpan" id="kobo.496.1">), but on production systems, you’ll always have </span><code class="inlineCode"><span class="koboSpan" id="kobo.497.1">grep</span></code><span class="koboSpan" id="kobo.498.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.499.1">Search for the pattern </span><code class="inlineCode"><span class="koboSpan" id="kobo.500.1">search_pattern</span></code><span class="koboSpan" id="kobo.501.1"> in the file </span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">path/to/file</span></code><span class="koboSpan" id="kobo.503.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.504.1">grep "search_pattern" path/to/file
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.505.1">You can, of course, search for string literals like this, but </span><code class="inlineCode"><span class="koboSpan" id="kobo.506.1">grep</span></code><span class="koboSpan" id="kobo.507.1"> is so powerful because it allows you to use regular expressions (regexes) to search for patterns. </span><span class="koboSpan" id="kobo.507.2">The following command will return lines that start with </span><code class="inlineCode"><span class="koboSpan" id="kobo.508.1">startswith</span></code><span class="koboSpan" id="kobo.509.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.510.1">grep ^startswith /some/file
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.511.1">And this command will return lines that end with </span><code class="inlineCode"><span class="koboSpan" id="kobo.512.1">endswith</span></code><span class="koboSpan" id="kobo.513.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.514.1">grep endswith$ /some/file
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.515.1">Regular expressions are tremendously useful, and every developer and Linux user should be familiar with the basics.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.516.1">You can also use </span><code class="inlineCode"><span class="koboSpan" id="kobo.517.1">grep</span></code><span class="koboSpan" id="kobo.518.1"> to search recursively through a directory – that is, search through all files in all directories it contains:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.519.1">root@c7f1417df8d2:/tmp# grep -r -i "hello world" /tmp
/tmp/secret/dontlook.key:hello world
/tmp/hi.txt:hello world
/tmp/hi.txt:HeLlO WoRlD! </span><span class="koboSpan" id="kobo.519.2">You found me!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.520.1">But what if you don’t want to find strings </span><em class="italic"><span class="koboSpan" id="kobo.521.1">inside</span></em><span class="koboSpan" id="kobo.522.1"> of a file – what if you want to find specific files themselves?</span></p>
<h2 class="heading-2" id="_idParaDest-109"><span class="koboSpan" id="kobo.523.1">Finding files with find</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.524.1">find</span></code><span class="koboSpan" id="kobo.525.1"> can help you</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.526.1"> find files and directories by name, modification time, or other attributes. </span><span class="koboSpan" id="kobo.526.2">It’s essentially a breadth-first search of the filesystem tree, which is quite useful for things like:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.527.1">Finding all application log files that were created or modified in the last day.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.528.1">Identifying all source code test files with names that end in </span><code class="inlineCode"><span class="koboSpan" id="kobo.529.1">_test.go</span></code><span class="koboSpan" id="kobo.530.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.531.1">Locating all of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.532.1">php.ini</span></code><span class="koboSpan" id="kobo.533.1"> files left behind by an intern programmer so you can delete them.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.534.1">In the following examples, </span><code class="inlineCode"><span class="koboSpan" id="kobo.535.1">/search/path</span></code><span class="koboSpan" id="kobo.536.1"> is the part of the filesystem you want to search. </span><span class="koboSpan" id="kobo.536.2">If you want to search your current directory and all of its subdirectories, you can use the period character (</span><code class="inlineCode"><span class="koboSpan" id="kobo.537.1">.</span></code><span class="koboSpan" id="kobo.538.1">), for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.539.1">find . </span><span class="koboSpan" id="kobo.539.2">-name 'file.txt'</span></code><span class="koboSpan" id="kobo.540.1">:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.541.1">Find files by extension:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.542.1">find /search/path -name '*.ext'
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.543.1">Find files matching multiple path/name patterns:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.544.1">find /search/path -path '**/path/**/*.ext' -or -name '*pattern*'
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.545.1">Find directories matching a given name, in case-insensitive mode:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.546.1">find /search/path -type d -iname '*lib*'
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.547.1">Find files matching a given pattern, excluding specific paths:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.548.1">find /search/path -name '*.py' -not -path '*/site-packages/*'
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.549.1">Find files matching a given size range:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.550.1">find /search/path -size +500k -size –10M
</span></code></pre>
</li>
</ul>
<h3 class="heading-3" id="_idParaDest-110"><span class="koboSpan" id="kobo.551.1">Copying files between local and remote hosts with rsync</span></h3>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.552.1">rsync</span></code><span class="koboSpan" id="kobo.553.1"> is an </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.554.1">extremely </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.555.1">useful tool that copies files and directories between and across hosts. </span><span class="koboSpan" id="kobo.555.2">It works just like </span><code class="inlineCode"><span class="koboSpan" id="kobo.556.1">cp</span></code><span class="koboSpan" id="kobo.557.1">, except it works when one or both hosts are remote.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.558.1">rsync</span></code><span class="koboSpan" id="kobo.559.1"> is essentially a combination of </span><code class="inlineCode"><span class="koboSpan" id="kobo.560.1">cp</span></code><span class="koboSpan" id="kobo.561.1"> (for copying data) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.562.1">ssh</span></code><span class="koboSpan" id="kobo.563.1"> (for secure, encrypted transport). </span><span class="koboSpan" id="kobo.563.2">If you’re </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.564.1">unfamiliar with </span><code class="inlineCode"><span class="koboSpan" id="kobo.565.1">ssh</span></code><span class="koboSpan" id="kobo.566.1">, you’ll need to learn how it works (and set up your own SSH keys and access) before trying </span><code class="inlineCode"><span class="koboSpan" id="kobo.567.1">rsync</span></code><span class="koboSpan" id="kobo.568.1"> commands.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.569.1">Here are a </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.570.1">few sample invocations, thanks to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.571.1">tldr</span></code><span class="koboSpan" id="kobo.572.1"> project:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.573.1">Transfer a file from a local to a remote host:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.574.1">rsync path/to/local_file remote_host:path/to/remote_directory
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.575.1">Transfer a file from a remote host to the local host:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.576.1">rsync remote_host:path/to/remote_file path/to/local_directory
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.577.1">Transfer file in [</span><code class="inlineCode"><span class="koboSpan" id="kobo.578.1">a</span></code><span class="koboSpan" id="kobo.579.1">]rchive mode (to preserve attributes) and compressed ([</span><code class="inlineCode"><span class="koboSpan" id="kobo.580.1">z</span></code><span class="koboSpan" id="kobo.581.1">]ipped) mode with [</span><code class="inlineCode"><span class="koboSpan" id="kobo.582.1">v</span></code><span class="koboSpan" id="kobo.583.1">]erbose and [</span><code class="inlineCode"><span class="koboSpan" id="kobo.584.1">h</span></code><span class="koboSpan" id="kobo.585.1">]uman-readable [</span><code class="inlineCode"><span class="koboSpan" id="kobo.586.1">P</span></code><span class="koboSpan" id="kobo.587.1">]rogress:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.588.1">rsync -azvhP path/to/local_directory remote_host:path/to/remote_directory
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.589.1">That last example is one I’ve used a hundred times to make quick, automated backups.</span></p>
<h3 class="heading-3" id="_idParaDest-111"><span class="koboSpan" id="kobo.590.1">Combining find, grep, and rsync</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.591.1">We’ll take a detailed look at combining commands with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.592.1">|</span></code><span class="koboSpan" id="kobo.593.1"> character in </span><em class="chapterRef"><span class="koboSpan" id="kobo.594.1">Chapter 11</span></em><span class="koboSpan" id="kobo.595.1">, </span><em class="italic"><span class="koboSpan" id="kobo.596.1">Pipes and Redirection</span></em><span class="koboSpan" id="kobo.597.1">, but here’s a quick preview.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.598.1">If, for</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.599.1"> example, you want to combine the examples you just saw, for example, to make a backup of all files in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.600.1">/tmp</span></code><span class="koboSpan" id="kobo.601.1"> directory that were modified in the last week, that’s just one clever command away:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.602.1">find /tmp -type f -mtime -7 -exec grep -l "hello world" {} \; | xargs -I _ backupscript.sh _ backup@backupserver.local:/backups_
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.603.1">First, we run </span><code class="inlineCode"><span class="koboSpan" id="kobo.604.1">find</span></code><span class="koboSpan" id="kobo.605.1">, looking for files that have a modification time of less than 7 days ago. </span><span class="koboSpan" id="kobo.605.2">We use find’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.606.1">-exec</span></code><span class="koboSpan" id="kobo.607.1"> flag to execute a </span><code class="inlineCode"><span class="koboSpan" id="kobo.608.1">grep</span></code><span class="koboSpan" id="kobo.609.1"> command with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.610.1">-l</span></code><span class="koboSpan" id="kobo.611.1"> flag, which simply returns the filename of the matching file. </span><span class="koboSpan" id="kobo.611.2">Then, we pipe those filenames into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.612.1">xargs</span></code><span class="koboSpan" id="kobo.613.1"> command, which applies an action to every line of input that it receives from the previous command. </span><span class="koboSpan" id="kobo.613.2">In this case, the action is to run a made-up backup script on each matching file, along with a made-up destination path that someone might want to back this file up to.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.614.1">If we have </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.615.1">the same files as in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.616.1">grep</span></code><span class="koboSpan" id="kobo.617.1"> section above, this wild-looking command will run two commands for you:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.618.1">backupscript.sh /tmp/secret/dontlook.key backup@backupserver.local:/backups/tmp/secret/dontlook.key
backupscript.sh /tmp/hi.txt backup@backupserver.local:/backups/tmp/hi.txt
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.619.1">It’s doing exactly what we wanted: running the backup script on ONLY the two files that contain the “hello world” content we care about </span><em class="italic"><span class="koboSpan" id="kobo.620.1">and</span></em><span class="koboSpan" id="kobo.621.1"> that were modified in the last 7 days.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.622.1">While a command like this can certainly take a few minutes (and some googling) to put together, it may save you hours in the long run. </span><span class="koboSpan" id="kobo.622.2">That’s the power of the command-line environment, combined with small, focused Unix tools that you can arrange together however you need.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.623.1">You’ll learn more about Unix pipes and </span><code class="inlineCode"><span class="koboSpan" id="kobo.624.1">xargs</span></code><span class="koboSpan" id="kobo.625.1"> in </span><em class="chapterRef"><span class="koboSpan" id="kobo.626.1">Chapter 11</span></em><span class="koboSpan" id="kobo.627.1">, </span><em class="italic"><span class="koboSpan" id="kobo.628.1">Pipes and Redirection</span></em><span class="koboSpan" id="kobo.629.1">, but we’ve given you this example because it’s important for you to get a taste of how you’re going to combine all these simple commands together as you learn them.</span></p>
<h1 class="heading-1" id="_idParaDest-112"><span class="koboSpan" id="kobo.630.1">Advanced filesystem knowledge for the real world</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.631.1">You’ve gotten an introduction to the various Linux filetypes now, and have some experience working with the most common ones. </span><span class="koboSpan" id="kobo.631.2">Now let’s take a look at some less-common filesystem knowledge that will come in handy during your time working on Linux systems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.632.1">You’ll meet these when you’re:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.633.1">Troubleshooting your first Docker application that has mounted storage volumes.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.634.1">Working on an application that talks to industrial controllers, cameras, or other external hardware.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.635.1">Writing application code that needs access to randomness for securely generating passwords or API tokens. </span><span class="koboSpan" id="kobo.635.2">One of the special file types you’ll see are </span><strong class="keyWord"><span class="koboSpan" id="kobo.636.1">block devices</span></strong><span class="koboSpan" id="kobo.637.1">, which </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.638.1">are devices resembling some form of disk, where data is fetched and read in blocks.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.639.1">Classical disk devices </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.640.1">are block devices, and you’ll usually find them attached to your filesystem at these locations:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.641.1">/dev/hdX</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.642.1">/dev/sdX</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.643.1">/dev/nvmeN</span></code></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.644.1">Where </span><code class="inlineCode"><span class="koboSpan" id="kobo.645.1">X</span></code><span class="koboSpan" id="kobo.646.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.647.1">N</span></code><span class="koboSpan" id="kobo.648.1"> are alphabetical or numerical indices of the respective disks, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.649.1">/dev/sda</span></code><span class="koboSpan" id="kobo.650.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.651.1">/dev/nvme0</span></code><span class="koboSpan" id="kobo.652.1">. </span><strong class="keyWord"><span class="koboSpan" id="kobo.653.1">Partitions</span></strong><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.654.1"> look just like disks, but with an additional digit or character appended, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.655.1">/dev/sda0</span></code><span class="koboSpan" id="kobo.656.1">, for the first partition on the first drive.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.657.1">Note that even once the operating system detects a new hard drive and attaches it (and any detected partitions) in one of these locations, you’ll still have to intentionally “mount” the filesystem that’s on the drive, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.658.1">mount</span></code><span class="koboSpan" id="kobo.659.1"> command. </span><span class="koboSpan" id="kobo.659.2">This isn’t a particularly common thing for developers to do, so we’ll leave it at that.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.660.1">There are also</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.661.1"> special “</span><strong class="keyWord"><span class="koboSpan" id="kobo.662.1">software devices</span></strong><span class="koboSpan" id="kobo.663.1">.” </span><span class="koboSpan" id="kobo.663.2">These range from </span><code class="inlineCode"><span class="koboSpan" id="kobo.664.1">/dev/null</span></code><span class="koboSpan" id="kobo.665.1">, which you might have seen output to be piped to in the form of </span><code class="inlineCode"><span class="koboSpan" id="kobo.666.1">somecommand &gt; /dev/null</span></code><span class="koboSpan" id="kobo.667.1">, to </span><code class="inlineCode"><span class="koboSpan" id="kobo.668.1">/dev/random</span></code><span class="koboSpan" id="kobo.669.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.670.1">/dev/urandom</span></code><span class="koboSpan" id="kobo.671.1">, which provide you with random bytes. </span><span class="koboSpan" id="kobo.671.2">This is where the programming language of your choice will most likely retrieve its cryptographically secure random numbers from.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.672.1">Another directory is </span><code class="inlineCode"><span class="koboSpan" id="kobo.673.1">/proc</span></code><span class="koboSpan" id="kobo.674.1">, which is a filesystem popularized by the Plan 9 operating system, but envisioned in the early days of Unix. </span><span class="koboSpan" id="kobo.674.2">As the name suggests, it was created to represent processes as files. </span><code class="inlineCode"><span class="koboSpan" id="kobo.675.1">/proc</span></code><span class="koboSpan" id="kobo.676.1"> contains directories named after process IDs, which contain files that can be used to read those processes’ state. </span><span class="koboSpan" id="kobo.676.2">Particularly on Linux, it has been extended with various other interfaces, including ways to configure kernel drivers, read hardware information and sensor outputs, and even interact with BIOS and UEFI.</span></p>
<h2 class="heading-2" id="_idParaDest-113"><span class="koboSpan" id="kobo.677.1">FUSE: Even more fun with Unix filesystems</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.678.1">As you’ve</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.679.1"> just seen, many things can be interpreted as files in Unix. </span><span class="koboSpan" id="kobo.679.2">The philosophy is that it’s common to edit files, so commands and programming languages able to interact with files provide a well-understood interface. </span><strong class="keyWord"><span class="koboSpan" id="kobo.680.1">FUSE</span></strong><span class="koboSpan" id="kobo.681.1">, short for </span><strong class="keyWord"><span class="koboSpan" id="kobo.682.1">Filesystem in Userspace</span></strong><span class="koboSpan" id="kobo.683.1">, is an API that allows anyone to implement new Unix filesystems without having to become a kernel programmer. </span><span class="koboSpan" id="kobo.683.2">In other words, because lots of things can talk to files, it’s useful to be able to “fake” the Unix file API for things that aren’t the kind of normal, locally stored data that you’d expect a file to be. </span><span class="koboSpan" id="kobo.683.3">If this sounds a bit wild, check out some of the things people have written with FUSE. </span><span class="koboSpan" id="kobo.683.4">FUSE has been used to implement many classical filesystem drivers, for example, NTFS, so you can read your old Windows filesystems on a Linux machine. </span><span class="koboSpan" id="kobo.683.5">However, because of FUSE’s flexibility and accessibility, there are also some pretty wild </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.684.1">filesystems that have been implemented this way:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.685.1">sshfs</span></code><span class="koboSpan" id="kobo.686.1">, for example, allows you to locally mount a directory on another machine accessible via SSH.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.687.1">Other FUSE filesystems allow you to mount remote cloud storage (like Amazon’s S3) as a local directory.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.688.1">Some even more obscure ones allow you to mount Wikipedia as a directory of files, or to represent protocols such as IRC and services like weather APIs as filesystems.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.689.1">FUSE is so useful that it has found its way into many Unix-like operating systems besides Linux, and is now even available on Windows. </span><span class="koboSpan" id="kobo.689.2">It’s worth knowing about, not just because it’s a novel use of the file abstraction in Unix but because it can be extremely useful when you are dealing with information that’s stored somewhere without a classical API that your application can use at the application layer. </span><span class="koboSpan" id="kobo.689.3">Any programming language you’re likely to use has a standard library that lets you talk to files on a Unix filesystem, and FUSE is a way of creating that interface for just about any kind of information.</span></p>
<h1 class="heading-1" id="_idParaDest-114"><span class="koboSpan" id="kobo.690.1">Conclusion</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.691.1">This chapter was an intense journey through the basics – and some of the more advanced bits – of files and the filesystem on Linux. </span><span class="koboSpan" id="kobo.691.2">You saw the difference between plaintext files and binary files, explored how the Linux filesystem tree is laid out, and learned all the basic commands you need to work with files. </span><span class="koboSpan" id="kobo.691.3">If you did it right, you also spent some time in your own Linux environment, practicing the important command-line file editing skills we showed you here.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.692.1">After covering the basics, we jumped into the most critical intermediate and advanced topics that you’ll need. </span><span class="koboSpan" id="kobo.692.2">You saw how to find files and search them for content, and we also gave you a taste of special files and filesystems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.693.1">All of this together arms you with the most important skills and knowledge you need in order to use Linux to solve real-world problems. </span><span class="koboSpan" id="kobo.693.2">We hope you had fun on this whirlwind tour!</span></p>
<h1 class="heading-1"><span class="koboSpan" id="kobo.694.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.695.1">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SecNet"><span class="url"><span class="koboSpan" id="kobo.696.1">https://packt.link/SecNet</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.697.1"><img alt="" role="presentation" src="../Images/QR_Code1768422420210094187.png"/></span></p>
</div>
</body></html>