- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software Management with DNF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without packages, a fresh Linux installation is about as useful as a car with
    no tires! You need to be able to add software to the system to make it useful.
    This can be done in several ways. Back in the old days (hey, I am a true gray-bearded
    Unix/Linux guy), you used to download the source files and then build and install
    them manually. On occasion, you could get prebuilt packages but, often, the dependencies
    that were required would take hours to run down manually. Then, in 1997, along
    came **Red Hat Package Manager** (**RPM**) files. These really simplified the
    process, as all you needed to do was track down all the RPM files needed to install
    an application, and off you went.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the applications started getting more complex; an example is the Apache
    HTTP server – all of its optional features went from 2-3 RPMs to a dozen, plus
    all the required dependencies. Tracking down all the RPMs and their dependencies
    became a chore… and due to mismatched versions, chaos quickly took control. This
    came to a screeching halt when **Yellowdog Updater, Modified** (**YUM**) was released
    in 2003\. Now you could have a centralized location for all of the RPMs, with
    an easy way to install and patch the packages and all of the dependencies. **Red
    Hat Enterprise Linux** (**RHEL**) moved to YUM, and life was good.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: YUM replaced **Yellowdog Update Program** (**YUP**), which was the original
    tool used by Yellowdog Linux for the installer. Yellowdog Linux was a Linux distribution
    built for the POWER7 CPU used on the PlayStation 3 and IBM systems and was CentOS/RHEL
    based. While it died in 2012, it lives on with YUM.
  prefs: []
  type: TYPE_NORMAL
- en: Linux distributions (such as RHEL and Oracle Linux) maintained YUM servers specific
    to their distribution online, but what if you could build your own RPM packages
    and maintain your own RPM repositories? What if these custom RPMs could be used
    to deploy internally built applications, and also make the required configuration
    changes so they run as expected? This chapter covers the management of RPM files,
    from moving from the `yum` command to the `dnf` command to managing RPMs, creating
    private RPM repositories, and making new RPMs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: What have they done to YUM, moving to DNF?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the DNF time machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a DNF/YUM mirror from ULN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new RPM package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What have they done to YUM, moving to DNF?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: YUM was good – it worked and it allowed admins to easily install and patch software.
    You could even use it to roll back a bad installation. So, what happened to it?
    Why was DNF released? What is DNF and how hard will it be to learn a new tool?
  prefs: []
  type: TYPE_NORMAL
- en: First, **DNF** stands for **Dandified YUM** and is a rewrite of the YUM software.
    It was released in 2013 in Fedora 18 and was built to address many issues that
    YUM was starting to face.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two most common problems with YUM were performance and RAM usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Poor performance**: YUM had performance issues. A lot of this was caused
    by dependency resolution, the process in which all the packages and their dependencies
    are put together. This process could take as long as 10 minutes. DNF moved to
    libsolv, which significantly decreased the time to resolve complex dependencies.
    This is now more common that ever, with some applications requiring 30+ RPMs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High RAM usage**: YUM uses a lot of RAM; this really started to become an
    issue with RHEL/CentOS 7, with smaller servers often running out of RAM while
    updating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DNF changes are not just in performance; there are also some key differences
    in its behavior. In order to test these changes, you will need an Oracle Linux
    8 system and access to at least the free public repos, such as [https://yum.oracle.com](https://yum.oracle.com).
    You may also want to be running Oracle Linux in a virtualized environment where
    you can leverage snapshots to keep copies of the OS before and after a change.
    Oracle VM VirtualBox is a great way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the most part, DNF and YUM work the same: `dnf install` and `yum install`
    appear to work the same way, but with DNF being faster. The same applies to `dnf
    upgrade` and `yum upgrade`, so you probably already know the basics.'
  prefs: []
  type: TYPE_NORMAL
- en: In YUM, `update` and `upgrade` have slightly different behaviors, with `yum
    update` removing the older packages from the system. With DNF, both `update` and
    `upgrade` will update the installed software but the `upgrade` option will also
    remove the obsolete packages. Additionally, the `auto-remove` option will remove
    packages that are no longer required on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Oracle Linux 8, the `yum` command is a `dnf` command.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in the development of DNF, most of the commands are the same,
    but DNF does have a few tricks up its sleeve, such as automatically running an
    update.
  prefs: []
  type: TYPE_NORMAL
- en: DNF automatic updates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can set up DNS to run automatically. To do this, install the `dnf-automatic`
    package, and enable the service with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, edit the `/etc/dnf/automatic.conf` file. There are a few tricks in this
    file. You can override whether patches are applied when downloaded by setting
    the `apply_updates` parameter to `yes`. This will force patches to be applied
    when the job runs.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to set the `system_name` parameter so that emails and notifications
    will have the correct name.
  prefs: []
  type: TYPE_NORMAL
- en: You can also set up the system to email you a report of what was installed.
    Set up email in the `[email]` stanza. If using an email relay, make sure it does
    not require authentication, or add that to the configuration if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final trick, you can change the `emit_via` parameter from `stdio` to `motd`.
    When set to `motd`, the system `motd` file is updated to reflect what patches
    were installed. When users log in to the system, they will see a complete list
    of what patches were installed and when, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – MOTD on login](img/B18349_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – MOTD on login
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the service checks for updates at 6 A.M. This can be changed by
    editing the `/``etc/systemd/system/timers.target.wants/dnf-automatic.timer` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The dnf-automatic.timer file](img/B18349_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The dnf-automatic.timer file
  prefs: []
  type: TYPE_NORMAL
- en: In this file, the `[Timer]` stanza controls the time, as well as a randomized
    delay. To change when this runs, replace `6:00` with whatever time you want, in
    a 24-hour format. For example, if you want the check to run at 10 P.M., the time
    should be 22:00.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this uses the standard `OnCalendar` function, you have other options.
    `OnCalendar` is a very flexible method; the following are some of the most commonly
    used examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **OnCalendar Example** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| DOW YYYY-MM-DD HH:MM:SS | Generic time formatting methods. |'
  prefs: []
  type: TYPE_TB
- en: '| *-*-* 2:00 | Runs every day at 2:00 A.M. |'
  prefs: []
  type: TYPE_TB
- en: '| Weekly | Every Monday at midnight. |'
  prefs: []
  type: TYPE_TB
- en: '| Sat *-*-* 2:00 | Every Saturday at 2:00 A.M. |'
  prefs: []
  type: TYPE_TB
- en: '| Sat | Every Saturday at midnight. |'
  prefs: []
  type: TYPE_TB
- en: '| Sun 2022-*-* | Every Sunday in 2022 at midnight. |'
  prefs: []
  type: TYPE_TB
- en: '| *-*-1,15 22:15 | The 1st and 15th of every month at 10:15 P.M. |'
  prefs: []
  type: TYPE_TB
- en: '| *-05-03/2 | Runs on the third day of the month in May, and then on the second
    day of every other month. Runs every year with the same cycle. This date format
    expression uses the dash for formatting. |'
  prefs: []
  type: TYPE_TB
- en: Table 5.1 – OnCalendar example date rules
  prefs: []
  type: TYPE_NORMAL
- en: '`RandomizedDelaySec` is also an important setting. This will add a random delay
    to the clock, which is helpful in enterprise environments where large numbers
    of systems are running. Having 200 servers hitting a YUM repo at 6 A.M. can be
    a little overwhelming to the server. Adding a randomized delay in `/etc/dnf/automatic.conf`
    of maybe 600 seconds would spread the load across a few minutes.'
  prefs: []
  type: TYPE_NORMAL
- en: DNF is an upgraded version of YUM, with a few enhancements. As seen in the recipe,
    it does have a few tricks up its sleeve, but it still does a great job of providing
    an easy way for admins to install and patch software on an Oracle Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: Using the DNF time machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DNF has a time machine built into it! This isn’t just a way to look back through
    the cosmos; it actually allows you to see the history of what was installed and
    also allows you to roll back a single change, or all changes up to a point.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To do this, you will need a test system, running Oracle Linux 8, with access
    to an RPM repo.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When DNF installs software, it keeps a history of all the actions performed.
    This includes upgrades to the software, installed software, and removal of the
    software. The `dnf history` command shows this history:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The dnf history command](img/B18349_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The dnf history command
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five columns – `ID`, `Command line`, `Date and time`, `Action(s)`,
    and `Altered`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ID`: This is the identifier for the history, and is used in commands that
    will show info, roll back, undo, or store a transaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Command line`: This is the option passed to DNF when the command was run that
    added to the transaction history'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date and time`: This is the timestamp of when the transaction was run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Action(s)`: This is what actions were taken; multiple actions can performed
    in the same transaction:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(`D`) `Downgrade`: A package was downgraded'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '(`E`) `Erase`: A package was removed'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '(`I`) `Installed`: A package was installed'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '(`R`) `Reinstall`: A package was reinstalled'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '(`O`) `Obsoleting`: A package was flagged as obsolete'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '(`U`) `Update`: A package was updated'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Altered`: This is the number of packages altered when the command was run,
    in addition to several exception flags:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E`/`EE`: The transaction was completed but had an output generated. Not all
    outputs are errors!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`P`: The transaction was completed but problems exist in the `rpm` database.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: The transaction was completed but since the `--skip-broken` parameter
    was enabled, some packages were skipped.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>`: The `rpm` database was changed outside of DNF after the transaction ran.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<`: The `rpm` database was changed outside of DNF before the transaction ran.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: The transaction was aborted before completion.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#`: The transaction was completed but returned a non-zero status.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When there are error codes, you can see the details with the `dnf history info
    {ID}` command, as seen in *Figure 5**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The dnf history info command](img/B18349_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The dnf history info command
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the output is more informational, with no actual errors. This
    is not uncommon.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `dnf history` to uninstall a package. There are two ways to
    do this: `rollback` or `undo`. A `rollback` command attempts to reverse out all
    of the DNF transactions from the current point to the transaction ID specified.
    An `undo` command simply undoes the transactions in the ID identified.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the test system, let’s undo the installation of Nmap from 4/17/2022, which
    was ID 34, using the `dnf history undo` `34` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The dnf history undo command](img/B18349_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – The dnf history undo command
  prefs: []
  type: TYPE_NORMAL
- en: 'This was a fairly simple undo, with Nmap being uninstalled. When the DNF history
    is looked at after the transaction, you will see a new ID of `40`, showing the
    `undo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – DNF history after the undo](img/B18349_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – DNF history after the undo
  prefs: []
  type: TYPE_NORMAL
- en: Now, if the goal was to roll back all of the changes, let’s say to ID `37`,
    the command would be `dnf history rollback 37`. This will roll back the system
    to match the state it was in when transaction 37 was completed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – DNF rollback](img/B18349_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – DNF rollback
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rollback` command rolls back the transitions, so Nmap is actually reinstalled,
    and the `oracle-cloud-agent` RPM is downgraded. This is reflected in the new history
    summary as ID `41` (shown in the following screenshot) where we see the install
    and downgrade actions in ID 41:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – DNF history post rollback](img/B18349_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – DNF history post rollback
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While the `rollback` and `undo` commands often work well, it is still good practice
    to keep OS snapshots using hypervisor or cloud-native tooling. You can also take
    snapshots using Btrfs. Sometimes, the `rollback` scripts in the RPMs do not undo
    all the changes to the system. When leveraging a storage-based snapshot, you reduce
    the risk of having issues due to this.
  prefs: []
  type: TYPE_NORMAL
- en: The DNF system maintains a database of all transactions, with the `dnf history`
    command and its options giving you access to the database to examine what happened,
    as well as the ability to undo a single transaction or roll back from the latest
    transaction to a specific ID in the history. This is a very helpful tool for admins
    when they need to back out of patches and software installation.
  prefs: []
  type: TYPE_NORMAL
- en: Building a DNF/YUM mirror from ULN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is very common for admins to not enable internet access for the systems running
    in a secure network, like banking of Government networks. A local mirror of Oracle’s
    **Unbreakable Linux Network** (**ULN**) is a great way to allow systems to access
    patches without having to reach out across the internet to access them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To do this, you will need a YUM server system running Oracle Linux 8\. The local
    system should have internet access to be able to reach the ULN servers via direct
    access or a proxy server. Only the system (often called a YUM server) synchronizing
    to ULN will require this access; all the systems using this system will not need
    access to the internet, they will use this system to access patches.
  prefs: []
  type: TYPE_NORMAL
- en: The system is not CPU- or RAM-intensive – 2 cores and 4 GB of RAM are often
    more than enough for the server, but the system will use a lot of disk space.
    You can check how much space is needed by running the `dnf repolist -``v` command.
  prefs: []
  type: TYPE_NORMAL
- en: A terabyte can go quickly, depending on how many repos the server is subscribed
    to. The good news on space is that high-performance storage is not required. You
    will also need a valid support contract with Oracle, which is included with the
    hardware support contract if you are running on Oracle servers. On my local repos,
    I keep the repo in `/var/www` and mount it as a separate filesystem under **Logical
    Volume Management** (**LVM**). This way, additional space can easily be added
    when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, an HTTP server should be installed and you must ensure that the
    firewall ports are opened. If you need help doing that, go back to [*Chapter 2*](B18349_02.xhtml#_idTextAnchor052),
    *Installing with and without Automation Magic*, where setting up a HTTP server
    is covered.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build the mirror, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to validate that enough space is in `/var/www`. For even a
    small mirror, 600 GB is recommended as a starting point. Watch the disk space
    carefully, as more will be needed down the road. Larger mirrors can easily consume
    2 TB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, install the `uln-yum-mirror` package using the `dnf install uln-yum-mirror
    -y` command. The `uln-yum-mirror` package includes the scripts that automate the
    replication of the Oracle ULN repository to a local server. Make sure that the
    system has access to the `ol8_addons` repo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.9 – The uln-yum-mirror install](img/B18349_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – The uln-yum-mirror install
  prefs: []
  type: TYPE_NORMAL
- en: 'This will install the scripts from Oracle. Next, let’s register the system
    with ULN. This is done using the `uln_register` command. You will need to know
    the `uln_register` command. From there, you will get the main screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.10 – The uln_register start screen](img/B18349_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – The uln_register start screen
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** to continue. On the next screen, you will be prompted to put
    in your Oracle SSO credentials. The CSI is the support identifier. Use the CSI
    assigned to you with your Premier hardware support, or your Oracle Linux subscription.
    Do *not* use a CSI for the Oracle database, WebLogic, E-Business Suite, and so
    on. The CSI should be for Oracle Linux.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In production environments, you may want to consider creating a shared account
    to register all your servers using ULN directly. This makes it easier to manage
    the servers as staff members come and go.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The uln_register credentials](img/B18349_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – The uln_register credentials
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will need to identify the server for ULN. Normally, you would use
    the **Fully Qualified Domain Name** (**FQDN**) of the server, but the choice is
    yours. You can also choose to upload the hardware details, but this is optional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.12 – The uln_register system name](img/B18349_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – The uln_register system name
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the system will update ULN with the software installed on the server,
    which will let you track installed RPMs via ULN but *only* for systems directly
    registered with ULN. When using a local repository, you may want to consider using
    a tool such as Oracle Linux Manager to track software installed on systems not
    registered with ULN:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.13 – The uln_register initial packages](img/B18349_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – The uln_register initial packages
  prefs: []
  type: TYPE_NORMAL
- en: 'Registering the server with ULN is almost complete. The last step is to send
    the info to ULN to register the server, this is done automatically in the next
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.14 – uln_register send](img/B18349_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – uln_register send
  prefs: []
  type: TYPE_NORMAL
- en: The upload can take up to a minute, depending on your internet speed.
  prefs: []
  type: TYPE_NORMAL
- en: After the upload, the system is now registered in ULN. The next step is optional.
    It will set up Ksplice for the server. If you do not want to use Ksplice, you
    are done. Ksplice also requires that you have an Oracle Linux Premier Support
    subscription. This is included with Oracle hardware support and Oracle Cloud VMs.
    You can also purchase this for third-party systems, often at a cheaper price than
    other commercial Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – uln_register ksplice](img/B18349_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – uln_register ksplice
  prefs: []
  type: TYPE_NORMAL
- en: 'Ksplice is a quick step; just review the settings, as seen in the following
    screenshot, and click **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.16 – The uln_register settings](img/B18349_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – The uln_register settings
  prefs: []
  type: TYPE_NORMAL
- en: 'The registration is now complete. You should now patch the server with `dnf
    -y update` (as recommended in the tool) before continuing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Completed uln_register](img/B18349_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Completed uln_register
  prefs: []
  type: TYPE_NORMAL
- en: Next, go ahead and patch the system with `dnf update -y` and reboot the system.
    As a note, the position of the `-y` option does not matter for the command. Once
    the system is back online, you need to log in to [https://linux.oracle.com/](https://linux.oracle.com/).
    While this server is registered to ULN now, it is not a local repo yet! We need
    to tell ULN this is a local repo and select what repos we need to mirror.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do this, head over to [https://linux.oracle.com](https://linux.oracle.com)
    and click the **Sign** **In** button:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.18 – ULN main page](img/B18349_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – ULN main page
  prefs: []
  type: TYPE_NORMAL
- en: When managing the server, use the same login used to register the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are logged in to ULN, you will see all the servers registered to your
    account. You will also see what channels have been recently updated and added
    to the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Managed servers](img/B18349_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – Managed servers
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, we need to promote a server to be a YUM repo. This will tell ULN
    to allow this server to have any channel assigned to it, allowing it to download
    RPMs not required by the specific servers. This includes patches for different
    major versions of Oracle Linux, different CPU architectures such as AArch64, and
    special patches for platforms such as Exadata. To do this, click on the server
    name, and then the **Edit** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Editing the server](img/B18349_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – Editing the server
  prefs: []
  type: TYPE_NORMAL
- en: 'On this page, we will update the server properties to make it a YUM server.
    Select the **Yum Server** checkbox and then click **Apply Changes**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Making it a repo](img/B18349_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – Making it a repo
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to assign additional channels to the server. This will allow
    the server to serve up any channel it is subscribed to. To manage the RPM channels
    that contain a grouping of related RPMs, click the **Manage** **Subscriptions**
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Manage Subscriptions](img/B18349_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22 – Manage Subscriptions
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will see all the available channels on the left and the channels assigned
    to the server on the right. While you can bulk-select all channels, it is better
    to only select the channels you need. In this example, **Oracle Linux 8 Addons
    x86_64** is being added. You can also add channels for a different major release
    number, such as Oracle Linux 7\. When selecting a channel, make sure to select
    the **<** or **>** symbol to subscribe to or unsubscribe from the local server.
    This is seen in step 2 in the following figure. Also, once you are done with the
    selection, you must click on the **Save Subscriptions** option to update the subscription.
    Exiting without saving the subscription will cause any changes made to be lost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Adding more repos](img/B18349_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.23 – Adding more repos
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When adding channels, only add what you need to conserve space and bandwidth.
    You can easily download a few terabytes if not careful. Also, the archived channels
    can be very large and are normally not needed for most sites, as they contain
    older releases. Expect multiple terabytes of disk space if you start using these
    channels locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you see the **Subscriptions** **saved** message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.24 – Saving the config](img/B18349_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.24 – Saving the config
  prefs: []
  type: TYPE_NORMAL
- en: Now, we finally have that local repo set. Next up is to run the `uln-yum-mirror`
    command as root, and the repo will start to sync. This process can take several
    hours, depending on your internet speed and how many channels you are subscribed
    to. The system will also run daily automatically, keeping your local copy current.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When doing your first sync, watch your disk space closely. You may need to add
    more space quickly the first time. If this happens, add the space, and manually
    restart the `uln-yum-mirror` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you finish a manual run, the script will let you know how much data was
    copied for each repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25 – Completed mirror](img/B18349_05_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.25 – Completed mirror
  prefs: []
  type: TYPE_NORMAL
- en: Once configured, the system will automatically synchronize your local repository
    with ULN. As you add new channels, they will automatically be downloaded when
    the `cron` job runs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new RPM package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Oracle provides a large number of RPMs, sometimes you just need to create
    a custom RPM package that allows you to easily deploy your own software. Creating
    an RPM file is easy to do!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To do this, you will need a development system, running Oracle Linux 8, with
    access to the **Extra Packages for Enterprise Linux** (**EPEL**) channel. It is
    highly recommended to have a dedicated system to build RPMs on, and to not build
    RPMs on production systems. You will also need a system to test installing the
    RPM on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the package being built, you may need additional channels, such
    as CodeReady or Distro Builder.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few things we need to do first – mainly, installing the RPM developer
    tools. In order to do this, we also need to add the EPEL repo to the system.
  prefs: []
  type: TYPE_NORMAL
- en: While most of the recipes in this book use the `root` user for most of the work,
    this recipe will only use root for the installation of the software. Perform the
    next few steps as `root`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the EPEL repo, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the following commands to enable EPEL and the `codeready` and `distro_builder`
    repos. Having all of these on your build system will make it easier down the road
    to take advantage of more advanced build tools such as Mock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will install the basic utilities to build `rpm` files. Run the following
    command to install these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are pulling software from Git, you may need to install `git` and `git-lfs`
    (`gcc`, `make` and `python3-service-identity` RPMs are also common. You can install
    all of these with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have all the tools installed, switch to your non-root user:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a directory for the RPM. Here, we will have a source file for the software,
    plus all of the files and directories required to make it an RPM. In my case,
    I am putting everything in `/home/erik/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to make the RPM directory tree. This is done by running the `rpmdev-setuptree`
    command. Once you run the command, the tree is created in your `$HOME` under `rpmbuild`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.26 – The rpmbuild directories](img/B18349_05_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.26 – The rpmbuild directories
  prefs: []
  type: TYPE_NORMAL
- en: 'Five directories are also built, each with a specific purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BUILD`: This is where binaries are saved after being compiled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RPMS`: RPMs are created here, with `rpm` files ready for use. There will be
    subdirectories for different CPU architectures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOURCES`: This is where the source code is put, usually a tar file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SPECS`: This is where the `.spec` files live.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SRPMS`: Source RPMs are built here – usually, packages containing the source
    code for the software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a simple Bash shell script to distribute as an RPM. This will live in
    the `xyzzy` directory in the `rpmbuild` directory. A simple Bash script is also
    created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.27 – The xyzzy.sh script](img/B18349_05_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.27 – The xyzzy.sh script
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a compressed tar file with the contents of the `xyzzy` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: rpmdev-newspec SPECS/xyzzy.spec
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 5.28 – Basic .spec file](img/B18349_05_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.28 – Basic .spec file
  prefs: []
  type: TYPE_NORMAL
- en: Much has to be done to make this functional.
  prefs: []
  type: TYPE_NORMAL
- en: The `Version` and `Summary` sections need to be filled in, as well as the `License`
    details and a URL for the project. Additionally, set the build architecture to
    `noarch`, as this will install on both ARM and X64 systems. It is important to
    make sure that you include the **Name, Epoch, Version, Release, and Architecture**
    (**NEVRA**) information. This is used to help make sure the correct RPMs are installed
    on the system.
  prefs: []
  type: TYPE_NORMAL
- en: A description is set, and the `%install` section is updated to reflect the script
    being installed in the normal binary directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `%files` section shows that `/usr/bin/xyzzy.sh` because all `.sh` files
    are added to the installer. Unused sections are also removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.29 – Finished .spec file](img/B18349_05_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.29 – Finished .spec file
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rpm` file will be built using the `rpmbuild` command, passing it the location
    of the `.spec` file. The `rpmbuild -bb -v SPECS/xyzzy.spec` command is used, with
    the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.30 – The output of rpmbuild](img/B18349_05_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.30 – The output of rpmbuild
  prefs: []
  type: TYPE_NORMAL
- en: 'The RPM file is now in the `RPMS` directory, under the `noarch` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.31 – The RPM file](img/B18349_05_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.31 – The RPM file
  prefs: []
  type: TYPE_NORMAL
- en: This RPM file can now be copied over to systems to be manually installed, or
    it can be added to a YUM repo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, you can use the `rpm -qi xyzzy-1.0` command to see the details
    from the `.spec` file for license, description, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.32 – RPM file details](img/B18349_05_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.32 – RPM file details
  prefs: []
  type: TYPE_NORMAL
- en: The RPM tool allows you to easily build custom RPM files for distribution. This
    is driven by the `.spec` file, which contains all the dependencies, descriptions,
    file locations, and even build info to create the RPM file.
  prefs: []
  type: TYPE_NORMAL
