<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer077" class="Basic-Text-Frame">
    <h1 class="chapterNumber"><a id="_idTextAnchor199"/>6</h1>
    <h1 id="_idParaDest-176" class="chapterTitle"><a id="_idTextAnchor200"/>Selecting a Build System</h1>
    <p class="normal">The preceding chapters covered the first four elements of embedded Linux. You built a bootloader, kernel, and root filesystem step by step before combining them into a basic embedded Linux system. That’s a lot of steps! Now it is time to simplify the process by automating as much of it as possible. Embedded Linux build systems can help, and we will look at two in particular: Buildroot and The Yocto Project. Both are complex tools that require an entire book to explain how they work.</p>
    <p class="normal">In this chapter I will only present the general ideas behind build systems, laying the groundwork for <em class="italic">Chapters 7</em> and <em class="italic">8</em>. First, I will show you how to build a simple image to get an overall feel for the system. Then, I will show you how to make some useful modifications to the Nova board and Raspberry Pi 4 examples from the previous chapters. In subsequent chapters, we will dive deeper into The Yocto Project, now the preeminent build system for embedded Linux.</p>
    <p class="normal">In this chapter we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Comparing build systems</li>
      <li class="bulletList">Distributing binaries</li>
      <li class="bulletList">Introducing Buildroot</li>
      <li class="bulletList">Introducing The Yocto Project</li>
    </ul>
    <h1 id="_idParaDest-177" class="heading-1"><a id="_idTextAnchor201"/>Technical requirements</h1>
    <p class="normal">To follow along with the examples, make sure you have the following:</p>
    <ul>
      <li class="bulletList">An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space</li>
      <li class="bulletList">A microSD card reader and card</li>
      <li class="bulletList">balenaEtcher for Linux</li>
      <li class="bulletList">An Ethernet cable and router with an available port for network connectivity</li>
      <li class="bulletList">A USB-to-TTL serial cable with a 3.3 V logic level</li>
      <li class="bulletList">Raspberry Pi 4</li>
      <li class="bulletList">BeaglePlay</li>
      <li class="bulletList">A 5 V USB-C power supply capable of delivering 3A</li>
    </ul>
    <p class="normal">The code used in this chapter can be found in the chapter folder in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter06"><span class="url">https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter06</span></a>.</p>
    <h1 id="_idParaDest-178" class="heading-1"><a id="_idTextAnchor202"/>Comparing build systems</h1>
    <p class="normal">In <a href="Chapter_05.xhtml#_idTextAnchor138"><em class="italic">Chapter 5</em></a>, I described the process of creating an image manually as the <strong class="keyWord">Roll Your Own</strong> (<strong class="keyWord">RYO</strong>) process. This approach gives you complete control over the software so that you can tailor it to do anything <a id="_idIndexMarker420"/>you like. If you want to do something truly odd but innovative, or if you want to reduce the memory footprint to the smallest size possible, then RYO is the way to go. But in most situations, building manually is a waste of time and produces inferior, unmaintainable systems.</p>
    <p class="normal">The idea behind a build system is to automate all the steps described up to this point. A build system should be able to build some or all of the following from upstream source code:</p>
    <ul>
      <li class="bulletList">toolchain</li>
      <li class="bulletList">bootloader</li>
      <li class="bulletList">kernel</li>
      <li class="bulletList">root filesystem</li>
    </ul>
    <p class="normal">Building from upstream source code is important for several reasons. It gives you the peace of mind that you can rebuild at any time without external dependencies. It also means you can debug at the source level and meet your license requirements to distribute the code to users where necessary.</p>
    <p class="normal">To do its job, a build system must be able to:</p>
    <ul>
      <li class="bulletList">Download the source code from upstream, either directly from the version control system or as an archive, and cache it locally.</li>
      <li class="bulletList">Apply patches to enable cross-compilation, fix architecture-dependent bugs, apply local configuration policies, and so on.</li>
      <li class="bulletList">Build the various components along with their compile-time and runtime dependencies.</li>
      <li class="bulletList">Create a staging area and assemble a root filesystem.</li>
      <li class="bulletList">Create image files in various formats ready to be loaded onto the target.</li>
    </ul>
    <p class="normal">Some other useful things are:</p>
    <ul>
      <li class="bulletList">Add your own packages containing applications or kernel changes.</li>
      <li class="bulletList">Select various root filesystem profiles: large or small, with or without graphics, and other features.</li>
      <li class="bulletList">Create a standalone SDK that you can distribute to other developers so they don’t have to install the complete build system.</li>
      <li class="bulletList">Track which open source licenses are used by the various packages you selected.</li>
      <li class="bulletList">Have a friendly user interface.</li>
    </ul>
    <p class="normal">In all cases, build systems encapsulate the components of a system into packages, some for the host and some for the target. Each package defines a set of rules to get the source, build it, and install the results in the correct location. There<a id="_idIndexMarker421"/> are dependencies between packages and a mechanism to resolve the dependencies and build the set of packages required.</p>
    <p class="normal">Open source build systems have matured over the past few years. There are many around, including:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Buildroot</strong>: Is an<a id="_idIndexMarker422"/> easy-to-use system using GNU Make and Kconfig (<a href="https://buildroot.org/"><span class="url">https://buildroot.org/</span></a>).</li>
      <li class="bulletList"><strong class="keyWord">OpenEmbedded</strong>: Is a powerful<a id="_idIndexMarker423"/> system and a core component of Yocto (<a href="https://openembedded.org"><span class="url">https://openembedded.org</span></a>).</li>
      <li class="bulletList"><strong class="keyWord">OpenWrt</strong>: Is a build <a id="_idIndexMarker424"/>tool oriented toward building firmware for wireless routers (<a href="https://openwrt.org/"><span class="url">https://openwrt.org/</span></a>) that supports runtime package management out of the box. It is a derivative of Buildroot.</li>
      <li class="bulletList"><strong class="keyWord">PTXdist</strong>: Is an open <a id="_idIndexMarker425"/>source build system sponsored by Pengutronix (<a href="https://www.ptxdist.org/"><span class="url">https://www.ptxdist.org/</span></a>).</li>
      <li class="bulletList"><strong class="keyWord">Yocto</strong>: Extends the OpenEmbedded core<a id="_idIndexMarker426"/> with metadata, tools, and documentation. It is the most popular embedded Linux build system today (<a href="https://www.yoctoproject.org/"><span class="url">https://www.yoctoproject.org/</span></a>).</li>
    </ul>
    <p class="normal">I will concentrate on two of them: Buildroot and Yocto. They approach the problem in different ways and with different objectives.</p>
    <p class="normal">Buildroot has the primary aim of building root filesystem images, hence the name. But it can build bootloaders, kernels, and even toolchains as well. It is easy to install and configure. Most importantly, Buildroot generates target images quickly.</p>
    <p class="normal">Yocto is more general in how it defines the target system, so it can build more complex embedded devices. Every component is generated as a binary package by default using the RPM format. Packages are then combined to make the filesystem image. You can install a package manager in the filesystem image that allows you to update packages at runtime. In other words, when you build with Yocto, you are creating your own custom Linux distribution. Bear in mind that enabling runtime package management also means provisioning and running your own corresponding package feed repository.</p>
    <h1 id="_idParaDest-179" class="heading-1"><a id="_idTextAnchor203"/>Distributing binaries</h1>
    <p class="normal">Mainstream Linux <a id="_idIndexMarker427"/>distributions are in most cases constructed from collections of binary (precompiled) packages in either RPM or DEB format. <strong class="keyWord">RPM</strong> stands for <strong class="keyWord">Red Hat Package Manager</strong> and is used<a id="_idIndexMarker428"/> in Red Hat, SUSE, Fedora, and other RPM-based distributions. Debian and Debian-derived distributions, including Ubuntu and Mint, use<a id="_idIndexMarker429"/> the <strong class="keyWord">Debian package manager </strong>(<strong class="keyWord">DEB</strong>) format. There is also a lightweight format for embedded devices known as the <strong class="keyWord">Itsy package </strong>(<strong class="keyWord">IPK</strong>) format, which is <a id="_idIndexMarker430"/>based on DEB.</p>
    <p class="normal">The ability to include a package manager on the device is one of the big differentiators between build systems. Once you have a package manager on the target device, you have an easy path to deploy new packages and to update the existing ones. I will talk about the implications of this in <a href="Chapter_10.xhtml#_idTextAnchor341"><em class="italic">Chapter 10</em></a>.</p>
    <p class="normal">Now for the main event. We will start with Buildroot. As the simpler of the two build systems, Buildroot is easier to get started with than Yocto and the quickest way of generating a bootable image for all three of our targets.</p>
    <h1 id="_idParaDest-180" class="heading-1"><a id="_idTextAnchor204"/>Introducing Buildroot</h1>
    <p class="normal">The current versions of Buildroot can<a id="_idIndexMarker431"/> build a toolchain, a bootloader, a kernel, and a root filesystem. Buildroot uses GNU Make as its principal build tool. There is good online documentation at <a href="https://buildroot.org/docs.html"><span class="url">https://buildroot.org/docs.html</span></a> along with <em class="italic">The Buildroot user manual</em> at <a href="https://buildroot.org/downloads/manual/manual.html"><span class="url">https://buildroot.org/downloads/manual/manual.html</span></a>.</p>
    <h2 id="_idParaDest-181" class="heading-2"><a id="_idTextAnchor205"/>Background</h2>
    <p class="normal">Buildroot was one of the first build systems. It began when the uClinux and uClibc projects needed a way to generate a<a id="_idIndexMarker432"/> small root filesystem for testing. Buildroot became a separate project in late 2001 and continued to evolve through 2006, after which it went into a dormant phase. </p>
    <p class="normal">However, since Peter Korsgaard took over stewardship in 2009, it has been developing rapidly, adding support for glibc-based toolchains and a greatly increased number of packages and target boards. Peter is still the lead maintainer of Buildroot and has had a long and illustrious career as a software engineer at Barco in Belgium.</p>
    <p class="normal">Buildroot is the ancestor of OpenWrt, another popular build system that forked from Buildroot around 2004. The primary focus of OpenWrt is to produce software for wireless routers so the package mix is oriented toward networking infrastructure. It also has a runtime IPK package manager so that a device can be updated or upgraded without a complete reflash of the image. Buildroot and OpenWrt have diverged to such an extent that they are now almost completely different build systems. Packages built with one are not compatible with the other.</p>
    <h2 id="_idParaDest-182" class="heading-2"><a id="_idTextAnchor206"/>Stable releases and long-term support</h2>
    <p class="normal">The Buildroot developers produce stable releases four times a year in February, May, August, and November. They <a id="_idIndexMarker433"/>are marked by Git tags of the form <code class="inlineCode">&lt;year&gt;.02</code>, <code class="inlineCode">&lt;year&gt;.05</code>, <code class="inlineCode">&lt;year&gt;.08</code>, and <code class="inlineCode">&lt;year&gt;.11</code>. Each <code class="inlineCode">&lt;year&gt;.02</code> release is marked for <strong class="keyWord">Long-Term Support</strong> (<strong class="keyWord">LTS</strong>), which means there will be point releases to fix security and other important bugs for 12 months after the initial release. The <code class="inlineCode">2017.02</code> release is the first to receive the LTS label.</p>
    <h2 id="_idParaDest-183" class="heading-2"><a id="_idTextAnchor207"/>Installing</h2>
    <p class="normal">You install Buildroot either by cloning the repository or downloading an archive. Here is an example <a id="_idIndexMarker434"/>of obtaining version <code class="inlineCode">2024.02.6</code>, which was the latest stable version at the time of writing:</p>
    <pre class="programlisting con"><code class="hljs-con">$ git clone git://git.buildroot.net/buildroot -b 2024.02.6
</code></pre>
    <p class="normal">The equivalent TAR archive is available at <a href="https://buildroot.org/downloads/"><span class="url">https://buildroot.org/downloads/</span></a>.</p>
    <p class="normal">Read the section titled <em class="italic">System requirements</em> in <em class="italic">The Buildroot user manual</em>, available at <a href="https://buildroot.org/downloads/manual/manual.html,"><span class="url">https://buildroot.org/downloads/manual/manual.html,</span></a> and make sure to install all the packages listed there.</p>
    <h2 id="_idParaDest-184" class="heading-2"><a id="_idTextAnchor208"/>Configuring</h2>
    <p class="normal">Buildroot uses the kernel Kconfig/Kbuild mechanism I described in the <em class="italic">Understanding kernel configuration</em> section from <a href="Chapter_04.xhtml#_idTextAnchor096"><em class="italic">Chapter 4</em></a>. You can configure Buildroot from scratch <a id="_idIndexMarker435"/>directly using <code class="inlineCode">make menuconfig</code> (<code class="inlineCode">xconfig</code> or <code class="inlineCode">gconfig</code>). Or you can choose one of the 100+ configurations for various development boards that you can find stored in the <code class="inlineCode">configs</code> directory. Typing <code class="inlineCode">make list-defconfigs</code> lists all the default configurations.</p>
    <p class="normal">Let’s begin by building a default configuration that you can run on the 64-bit Arm QEMU emulator:</p>
    <pre class="programlisting con"><code class="hljs-con">$ cd buildroot
$ make qemu_aarch64_virt_defconfig
$ make
</code></pre>
    <div class="note">
      <p class="normal"><strong class="keyWord">IMPORTANT NOTE</strong></p>
      <p class="normal">Do not tell GNU Make how many parallel jobs to run with the <code class="inlineCode">-j</code> option. Buildroot will make optimum use of your CPU cores all by itself. If you want to limit the number of jobs, then run <code class="inlineCode">make menuconfig</code> and look for <strong class="screenText">Number of jobs to run simultaneously</strong> under <strong class="screenText">Build options</strong>.</p>
    </div>
    <p class="normal">The build can take up to an hour depending on how many CPU cores your host system has and the speed of your internet. It will download approximately 502 MB of code and consume about 12 GB of disk space. When it completes, you will find two new directories have been created:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">dl</code>: Contains archives of the upstream projects that Buildroot has built.</li>
      <li class="bulletList"><code class="inlineCode">output</code>: Contains all the intermediate and final compiled artifacts.</li>
    </ul>
    <p class="normal">Inside <code class="inlineCode">output</code> you will find the following subdirectories:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">build</code>: Contains the build directory for each component.</li>
      <li class="bulletList"><code class="inlineCode">host</code>: Contains various tools required by Buildroot on the host, including the executables of the toolchain (in <code class="inlineCode">output/host/usr/bin</code>).</li>
      <li class="bulletList"><code class="inlineCode">images</code>: Contains the finished results of the build. Depending on what you selected when configuring, you will find a bootloader, a kernel, and one or more root filesystem images.</li>
      <li class="bulletList"><code class="inlineCode">staging</code>: Is a symbolic link to the <code class="inlineCode">sysroot</code> of the toolchain. The name of the link is a little confusing because it does not point to a staging area as defined in <a href="Chapter_05.xhtml#_idTextAnchor138"><em class="italic">Chapter 5</em></a>.</li>
      <li class="bulletList"><code class="inlineCode">target</code>: Is the staging area for the root directory. Note that you cannot use it as a root filesystem because the file ownership and permissions are not set correctly. Buildroot uses a device table as described in the previous chapter to set ownership and permissions when the filesystem image is created in the <code class="inlineCode">image</code> directory.</li>
    </ul>
    <h2 id="_idParaDest-185" class="heading-2"><a id="_idTextAnchor209"/>Running</h2>
    <p class="normal">Some of the sample targets have a subfolder in the <code class="inlineCode">board</code> directory containing custom <a id="_idIndexMarker436"/>configuration files and informationon how to install the results. </p>
    <p class="normal">In the case of the system you just built, the relevant file is <code class="inlineCode">board/qemu/aarch64-virt/readme.txt</code>. This <code class="inlineCode">readme.txt</code> file tells you how to start QEMU with this target. Assuming you have already installed <code class="inlineCode">qemu-system-aarch64</code> as described in <a href="Chapter_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, you can run QEMU with this command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ qemu-system-aarch64 -M virt -cpu cortex-a53 -nographic -smp 1 -kernel output/images/Image -append "rootwait root=/dev/vda console=ttyAMA0" -netdev user,id=eth0 -device virtio-net-device,netdev=eth0 -drive file=output/images/rootfs.ext4,if=none,format=raw,id=hd0 -device virtio-blk-device,drive=hd0
</code></pre>
    <p class="normal">There is a script named <code class="inlineCode">start-qemu.sh</code> in <code class="inlineCode">output/images</code> that includes the command. When QEMU boots up, you should see the kernel boot messages appear in the same terminal window where you started QEMU followed by a login prompt:</p>
    <pre class="programlisting con"><code class="hljs-con">Booting Linux on physical CPU 0x0000000000 [0x410fd034]
Linux version 6.1.44 (frank@frank-nuc) (aarch64-buildroot-linux-gnu-gcc.br_real (Buildroot 2024.02.6) 12.4.0, GNU ld (GNU Binutils) 2.40) #1 SMP Wed Oct  9 21:24:21 PDT 2024
random: crng init done
Machine model: linux,dummy-virt
efi: UEFI not found.
&lt;…&gt;
VFS: Mounted root (ext4 filesystem) readonly on device 254:0.
devtmpfs: mounted
Freeing unused kernel memory: 1280K
Run /sbin/init as init process
EXT4-fs (vda): re-mounted. Quota mode: disabled.
Saving 256 bits of creditable seed for next boot
Starting syslogd: OK
Starting klogd: OK
Running sysctl: OK
Starting network: udhcpc: started, v1.36.1
udhcpc: broadcasting discover
udhcpc: broadcasting select for 10.0.2.15, server 10.0.2.2
udhcpc: lease of 10.0.2.15 obtained from 10.0.2.2, lease time 86400
deleting routers
adding dns 10.0.2.3
OK
Welcome to Buildroot
buildroot login:
</code></pre>
    <p class="normal">Log in as <code class="inlineCode">root</code> with <a id="_idIndexMarker437"/>no password.</p>
    <p class="normal">To exit QEMU type <em class="italic">Ctrl + A</em> and then <em class="italic">x</em>.</p>
    <h2 id="_idParaDest-186" class="heading-2"><a id="_idTextAnchor210"/>Targeting real hardware</h2>
    <p class="normal">The steps for <a id="_idIndexMarker438"/>configuring and building a bootable image for Raspberry Pi 4 are almost the same as for 64-bit Arm QEMU:</p>
    <pre class="programlisting con"><code class="hljs-con">$ cd buildroot
$ make clean
$ make raspberrypi4_64_defconfig
$ make
</code></pre>
    <p class="normal">The finished image is written to a file named <code class="inlineCode">output/images/sdcard.img</code>. The <code class="inlineCode">post-image.sh</code> script and the <code class="inlineCode">genimage.cfg.in</code> configuration file used to write the image file are both located in the <code class="inlineCode">board/raspberrypi4-64 directory</code>. To write <code class="inlineCode">sdcard.img</code> onto a microSD card and boot it on your Raspberry Pi 4:</p>
    <ol>
      <li class="numberedList" value="1">Insert a microSD card into your Linux host machine.</li>
      <li class="numberedList">Launch balenaEtcher.</li>
      <li class="numberedList">Click <strong class="screenText">Flash from file</strong> from Etcher.</li>
      <li class="numberedList">Locate the <code class="inlineCode">sdcard.img</code> image that you built for Raspberry Pi 4 and open it.</li>
      <li class="numberedList">Click <strong class="screenText">Select target</strong> from Etcher.</li>
      <li class="numberedList">Select the microSD card that you inserted in <em class="italic">step 1</em>.</li>
      <li class="numberedList">Click <strong class="screenText">Flash</strong> from Etcher to write the image.</li>
      <li class="numberedList">Eject the microSD card when Etcher is done flashing.</li>
      <li class="numberedList">Insert the microSD card into your Raspberry Pi 4.</li>
      <li class="numberedList">Apply power to Raspberry Pi 4 by way of the USB-C port.</li>
    </ol>
    <p class="normal">Confirm that your Raspberry Pi 4 booted successfully by plugging it into Ethernet and observing that the network activity lights blink. This default image is very minimal and includes little else <a id="_idIndexMarker439"/>besides BusyBox. To SSH into your Raspberry Pi 4, you will need to add an SSH server like <code class="inlineCode">dropbear</code> or <code class="inlineCode">openssh</code> to your Buildroot image configuration.</p>
    <h2 id="_idParaDest-187" class="heading-2"><a id="_idTextAnchor211"/>Creating a custom BSP</h2>
    <p class="normal">Now let’s use Buildroot to create a <strong class="keyWord">Board Support Package </strong>(<strong class="keyWord">BSP</strong>) for our Nova board using the same versions of U-Boot<a id="_idIndexMarker440"/> and Linux from earlier chapters. You can see the changes I made to Buildroot during this <a id="_idIndexMarker441"/>section of the book under <code class="inlineCode">MELD/Chapter06/buildroot</code>.</p>
    <p class="normal">The recommended places to store your changes are:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">board/&lt;organization&gt;/&lt;device&gt;</code>: Contains any patches, blobs, extra build steps, and configuration files for Linux, U-Boot, and other components</li>
      <li class="bulletList"><code class="inlineCode">configs/&lt;device&gt;_defconfig</code>: Contains the default configuration for the board</li>
      <li class="bulletList"><code class="inlineCode">package/&lt;organization&gt;/&lt;package_name&gt;</code>: Is the place to put any additional packages for this board</li>
    </ul>
    <p class="normal">Create a directory to store changes to the Nova board:</p>
    <pre class="programlisting con"><code class="hljs-con">$ mkdir -p board/meld/nova
</code></pre>
    <p class="normal">Copy <code class="inlineCode">nova_defconfig</code> from <code class="inlineCode">MELD/Chapter06/buildroot/configs</code> to <code class="inlineCode">buildroot</code>/<code class="inlineCode">configs</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">$ cp ../MELD/Chapter06/buildroot/configs/nova_defconfig configs/.
</code></pre>
    <p class="normal">Copy the contents of <code class="inlineCode">MELD/Chapter06/buildroot/board/meld/nova</code> to <code class="inlineCode">buildroot/board/meld/nova</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">$ cp ../MELD/Chapter06/buildroot/board/meld/nova/* board/meld/nova/.
</code></pre>
    <p class="normal">Clean the artifacts from any previous build (always do this when changing configurations):</p>
    <pre class="programlisting con"><code class="hljs-con">$ make clean
</code></pre>
    <p class="normal">Select the Nova configuration:</p>
    <pre class="programlisting con"><code class="hljs-con">$ make nova_defconfig
</code></pre>
    <p class="normal">The <code class="inlineCode">make nova_defconfig</code> command configures Buildroot to build an image targeting the BeaglePlay. This configuration is a good starting point, but we still need to customize it for our Nova board. Let’s start by selecting the custom U-Boot patch we created for Nova.</p>
    <h3 id="_idParaDest-188" class="heading-3"><a id="_idTextAnchor212"/>U-Boot</h3>
    <p class="normal">In <a href="Chapter_03.xhtml#_idTextAnchor061"><em class="italic">Chapter 3</em></a><em class="italic">,</em> we created a custom bootloader for Nova based on the <code class="inlineCode">f036fb</code> version of TI’s U-Boot fork and created a patch file for it saved as <code class="inlineCode">MELD/Chapter03/0001-BSP-for-Nova.patch</code>. We can<a id="_idIndexMarker442"/> configure Buildroot to select the same version of U-Boot and apply our patch. Running <code class="inlineCode">make nova_defconfig</code> already set the U-Boot version to <code class="inlineCode">f036fb</code>.</p>
    <p class="normal">Copy the patch file into <code class="inlineCode">board/meld/nova</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">$ cp ../MELD/Chapter03/0001-BSP-for-Nova.patch board/meld/nova/.
</code></pre>
    <p class="normal">Now run <code class="inlineCode">make menuconfig</code> and drill down into the <strong class="screenText">Bootloaders</strong> page. From that page, navigate down to <strong class="screenText">Custom U-Boot patches</strong> and verify the path to our patch as shown:</p>
    <figure class="mediaobject"><img src="../Images/B18466_06_01.png" alt="Figure 6.1 – Selecting custom U-Boot patches" width="1644" height="1165"/></figure>
    <p class="packt_figref">Figure 6.1 – Selecting custom U-Boot patches</p>
    <p class="normal">Now that we’ve patched <a id="_idIndexMarker443"/>U-Boot for our Nova board, the next step is patching the kernel.</p>
    <h3 id="_idParaDest-189" class="heading-3"><a id="_idTextAnchor213"/>Linux</h3>
    <p class="normal">In <a href="Chapter_04.xhtml#_idTextAnchor096"><em class="italic">Chapter 4</em></a><em class="italic">, </em> we based the kernel on Linux 6.6.46 and supplied a new device tree from <code class="inlineCode">MELD/Chapter04/nova.dts</code>. Running <code class="inlineCode">make nova_defconfig</code> already<a id="_idIndexMarker444"/> set the kernel version to Linux 6.6.46 and changed the kernel series used for kernel headers to match the kernel being built. Back out of the <strong class="screenText">Bootloaders</strong> page and drill down into the <strong class="screenText">Kernel</strong> page. Confirm that the value of <strong class="screenText">Out-of-tree Device Tree Source file paths</strong> is set to <code class="inlineCode">board/meld/nova/nova.dts</code>:</p>
    <figure class="mediaobject"><img src="../Images/B18466_06_02.png" alt="Figure 6.2 – Selecting the device tree source" width="1644" height="1319"/></figure>
    <p class="packt_figref">Figure 6.2 – Selecting the device tree source</p>
    <p class="normal">Now that we’ve defined the device tree, let’s build <a id="_idIndexMarker445"/>the system image complete with the kernel and root filesystem.</p>
    <h3 id="_idParaDest-190" class="heading-3"><a id="_idTextAnchor214"/>Build</h3>
    <p class="normal">In the last stage of the build, Buildroot uses a tool named <code class="inlineCode">genimage</code> to create an image for the microSD that we can copy <a id="_idIndexMarker446"/>directly to the card. We need a configuration file to lay out the image in the right way. Modify the existing <code class="inlineCode">board/meld/nova/genimage.cfg</code> file by replacing <code class="inlineCode">"k3-am625-beagleplay.dtb"</code> with <code class="inlineCode">"nova.dtb"</code> as shown:</p>
    <pre class="programlisting code"><code class="hljs-code">image boot.<span class="hljs-title">vfat</span> <span class="hljs-punctuation">{</span>
                <span class="hljs-title">vfat</span> <span class="hljs-punctuation">{</span>
                                <span class="hljs-attr">files</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span>
                                                <span class="hljs-string">"tiboot3.bin"</span>,
                                                <span class="hljs-string">"tispl.bin"</span>,
                                                <span class="hljs-string">"u-boot.img"</span>,
                                                <span class="hljs-string">"Image.gz"</span>,
                                                <span class="hljs-string">"nova.dtb"</span>,  // HERE
                                <span class="hljs-punctuation">}</span>
                <span class="hljs-punctuation">}</span>
                <span class="hljs-attr">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>M
<span class="hljs-punctuation">}</span>
image sdcard.<span class="hljs-title">img</span> <span class="hljs-punctuation">{</span>
                <span class="hljs-title">hdimage</span> <span class="hljs-punctuation">{</span>
                <span class="hljs-punctuation">}</span>
                partition <span class="hljs-title">u-boot</span> <span class="hljs-punctuation">{</span>
                                <span class="hljs-attr">partition-type</span> <span class="hljs-operator">=</span> <span class="hljs-number">0xC</span>
                                <span class="hljs-attr">bootable</span> <span class="hljs-operator">=</span> <span class="hljs-string">"true"</span>
                                <span class="hljs-attr">image</span> <span class="hljs-operator">=</span> <span class="hljs-string">"boot.vfat"</span>
                <span class="hljs-punctuation">}</span>
                partition <span class="hljs-title">rootfs</span> <span class="hljs-punctuation">{</span>
                                <span class="hljs-attr">partition-type</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x83</span>
                                <span class="hljs-attr">image</span> <span class="hljs-operator">=</span> <span class="hljs-string">"rootfs.ext4"</span>
                <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">This will create a file named <code class="inlineCode">sdcard.img</code>, which contains two partitions named <code class="inlineCode">u-boot</code> and <code class="inlineCode">rootfs</code>. The first contains <a id="_idIndexMarker447"/>the boot files listed in <code class="inlineCode">boot.vfat</code> and the second contains the root filesystem image named <code class="inlineCode">rootfs.ext4</code>, which will be generated by Buildroot.</p>
    <p class="normal">Finally, we need a <code class="inlineCode">post-image.sh</code> script that will call <code class="inlineCode">genimage</code> and create the microSD card image. See <code class="inlineCode">board/meld/nova/post-image.sh</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">#!/bin/sh</span>
BOARD_DIR=<span class="hljs-string">"</span><span class="hljs-subst">$(dirname $0)</span><span class="hljs-string">"</span>
<span class="hljs-built_in">cp</span> <span class="hljs-variable">${BUILD_DIR}</span>/ti-k3-r5-loader-2022.10/tiboot3.bin <span class="hljs-variable">$BINARIES_DIR</span>/tiboot3.bin
GENIMAGE_CFG=<span class="hljs-string">"</span><span class="hljs-variable">${BOARD_DIR}</span><span class="hljs-string">/genimage.cfg"</span> GENIMAGE_TMP=<span class="hljs-string">"</span><span class="hljs-variable">${BUILD_DIR}</span><span class="hljs-string">/genimage.tmp"</span>
<span class="hljs-built_in">rm</span> -rf <span class="hljs-string">"</span><span class="hljs-variable">${GENIMAGE_TMP}</span><span class="hljs-string">"</span>
genimage \
    --rootpath <span class="hljs-string">"</span><span class="hljs-variable">${TARGET_DIR}</span><span class="hljs-string">"</span> \
    --tmppath <span class="hljs-string">"</span><span class="hljs-variable">${GENIMAGE_TMP}</span><span class="hljs-string">"</span> \
    --inputpath <span class="hljs-string">"</span><span class="hljs-variable">${BINARIES_DIR}</span><span class="hljs-string">"</span> \
    --outputpath <span class="hljs-string">"</span><span class="hljs-variable">${BINARIES_DIR}</span><span class="hljs-string">"</span> \
    --config <span class="hljs-string">"</span><span class="hljs-variable">${GENIMAGE_CFG}</span><span class="hljs-string">"</span>
</code></pre>
    <p class="normal">This script copies the R5 firmware image into the <code class="inlineCode">output/images</code> directory and runs <code class="inlineCode">genimage</code> with <a id="_idIndexMarker448"/>our configuration file.</p>
    <p class="normal">Note that <code class="inlineCode">post-image.sh</code> needs to be executable; otherwise the build will fail at the end:</p>
    <pre class="programlisting con"><code class="hljs-con">$ chmod +x board/meld/nova/post-image.sh
</code></pre>
    <p class="normal">Now, run <code class="inlineCode">make menuconfig</code> and drill down into the <strong class="screenText">System configuration</strong> page. From that page, navigate down to <strong class="screenText">Custom scripts to run before creating filesystem images</strong> and notice the path to our <code class="inlineCode">post-image.sh</code> script:</p>
    <figure class="mediaobject"><img src="../Images/B18466_06_03.png" alt="Figure 6.3 – Selecting custom scripts to run after creating filesystem images" width="1654" height="1003"/></figure>
    <p class="packt_figref">Figure 6.3 – Selecting custom scripts to run after creating filesystem images</p>
    <p class="normal">Finally, you can build Linux for the Nova board just by typing <code class="inlineCode">make</code>. When the build is done, you will see these files in the <code class="inlineCode">output/images</code> directory:</p>
    <pre class="programlisting con"><code class="hljs-con">bl31.bin                 rootfs.ext2  tee-header_v2.bin    tispl.bin
boot.vfat                rootfs.ext4  tee-pageable_v2.bin  u-boot.img
Image.gz                 rootfs.tar   tee-pager_v2.bin    
nova.dtb                 sdcard.img   tiboot3.bin
r5-u-boot-spl.bin        tee.bin      ti-connectivity
</code></pre>
    <p class="normal">To test it, insert a microSD card into your card reader and use balenaEtcher to write <code class="inlineCode">output/images/sdcard.img</code> out to a microSD card like we did for the Raspberry Pi 4. There is no need to format the microSD beforehand like we did in the previous chapter because <code class="inlineCode">genimage</code> has created the exact disk layout required.</p>
    <p class="normal">Having shown that our custom configuration for the Nova board works, it would be nice to save our changes back to the <code class="inlineCode">nova_defconfig</code> file so that we and others can use it again. You can do that with this command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ make savedefconfig BR2_DEFCONFIG=configs/nova_defconfig
</code></pre>
    <p class="normal">Now you have a custom Buildroot configuration for the Nova board. You can retrieve this configuration by typing the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ make nova_defconfig
</code></pre>
    <p class="normal">With that, we have successfully configured Buildroot. In the next section, we will learn how to add our own code to a Buildroot image.</p>
    <h2 id="_idParaDest-191" class="heading-2"><a id="_idTextAnchor215"/>Adding your own code</h2>
    <p class="normal">Suppose you develop a program and you want to include it in the build. You have two options. Firstly, build it separately using its own build system and then roll the binary into the final build as <a id="_idIndexMarker449"/>an overlay. Secondly, create a Buildroot package that can be selected from the menu and build it like any other.</p>
    <h3 id="_idParaDest-192" class="heading-3"><a id="_idTextAnchor216"/>Overlays</h3>
    <p class="normal">An overlay is simply a directory structure that is copied over the top of the Buildroot root filesystem at a later stage in the <a id="_idIndexMarker450"/>build process. It can contain executables, libraries, and anything else you may want to include. Note that any compiled code must be compatible with the libraries deployed at runtime, which means that it must be compiled with the same toolchain that Buildroot uses. Using the Buildroot toolchain is quite easy; just add it to <code class="inlineCode">PATH</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">$ PATH=&lt;path_to_buildroot&gt;/output/host/usr/bin:$PATH
</code></pre>
    <p class="normal">The prefix for the toolchain is <code class="inlineCode">&lt;ARCH&gt;-linux-</code>. So, to compile a simple program, you would do something like this:</p>
    <pre class="programlisting con"><code class="hljs-con">$ PATH=/home/frank/buildroot/output/host/usr/bin:$PATH
$ aarch64-linux-gcc helloworld.c -o helloworld
</code></pre>
    <p class="normal">Once you have compiled your program with the correct toolchain, install the executables and other supporting files into a <a id="_idIndexMarker451"/>staging area and mark it as an overlay for Buildroot. For the <code class="inlineCode">helloworld</code> example, you can put it in the <code class="inlineCode">board/meld/nova</code> directory:</p>
    <pre class="programlisting con"><code class="hljs-con">$ mkdir -p board/meld/nova/overlay/usr/bin
$ cp helloworld board/meld/nova/overlay/usr/bin
</code></pre>
    <p class="normal">Finally, set <code class="inlineCode">BR2_ROOTFS_OVERLAY</code> to the path pointing at the overlay. It can be configured in <code class="inlineCode">menuconfig</code> with the <strong class="screenText">System configuration | Root filesystem overlay directories</strong> option.</p>
    <h3 id="_idParaDest-193" class="heading-3"><a id="_idTextAnchor217"/>Adding a package</h3>
    <p class="normal">Buildroot packages (over 2,000 of them) are stored in the <code class="inlineCode">package</code> directory, each in its own subdirectory. A package <a id="_idIndexMarker452"/>consists of at least two files: <code class="inlineCode">Config.in</code>, containing the snippet of Kconfig code required to make the package visible in the configuration menu, and a makefile named <code class="inlineCode">&lt;package_name&gt;.mk</code>.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">IMPORTANT NOTE</strong></p>
      <p class="normal">Note that a Buildroot package does not contain the code, just the instructions to get the code by downloading a tarball, doing <code class="inlineCode">git clone</code>, or whatever is necessary to obtain the upstream source.</p>
    </div>
    <p class="normal">The makefile is written in a format expected by Buildroot and contains directives that allow Buildroot to download, configure, compile, and install the program. Writing a new package makefile is a complex operation which is covered in detail in <em class="italic">The Buildroot user manual</em>.</p>
    <p class="normal">Here is an example that shows you how to create a package for a simple program such as our <code class="inlineCode">helloworld</code> program. Begin by creating a <code class="inlineCode">package/helloworld</code> subdirectory with a <code class="inlineCode">Config.in</code> file that looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">config BR2_PACKAGE_HELLOWORLD
    bool "helloworld"
    help
      A friendly program that prints Hello World! every 10s
</code></pre>
    <p class="normal">The first line must be of the format <code class="inlineCode">BR2_PACKAGE_&lt;uppercase package name&gt;</code>. This is followed by <code class="inlineCode">bool</code> and the package name as it will appear in the configuration menu. The second line is what enables a user to select this package. The <code class="inlineCode">help</code> section is optional but usually a good idea because it acts as self-documentation.</p>
    <p class="normal">Link the new package into the <strong class="screenText">Target Packages</strong> menu by editing <code class="inlineCode">package/Config.in</code> and sourcing the configuration file as shown below:</p>
    <pre class="programlisting code"><code class="hljs-code">menu "My programs"
  source "package/helloworld/Config.in"
endmenu
</code></pre>
    <p class="normal">You could append this new <code class="inlineCode">helloworld</code> package to an existing submenu, but it’s cleaner to create a new submenu with only our package and insert it before the <strong class="screenText">Audio and video applications</strong> menu.</p>
    <p class="normal">After inserting the <strong class="screenText">My programs</strong> menu into <code class="inlineCode">package/Config.in</code>, create a <code class="inlineCode">package/helloworld/helloworld.mk</code> file to supply the data needed by Buildroot:</p>
    <pre class="programlisting code"><code class="hljs-code">HELLOWORLD_VERSION = 1.0.0
HELLOWORLD_SITE = /home/frank/MELD/Chapter06/helloworld
HELLOWORLD_SITE_METHOD = local
<span class="hljs-keyword">define</span> HELLOWORLD_BUILD_CMDS
    <span class="hljs-variable">$(MAKE)</span> CC="<span class="hljs-variable">$(TARGET_CC)</span>" LD="<span class="hljs-variable">$(TARGET_LD)</span>" -C $(@D) all
endef
<span class="hljs-keyword">define</span> HELLOWORLD_INSTALL_TARGET_CMDS
    <span class="hljs-variable">$(INSTALL)</span> -D -m 0755 $(@D)/helloworld <span class="hljs-variable">$(TARGET_DIR)</span>/usr/bin/helloworld
endef
<span class="hljs-variable">$(</span><span class="hljs-built_in">eval</span><span class="hljs-variable"> $(generic-package)</span>)
</code></pre>
    <p class="normal">You can find my <code class="inlineCode">helloworld</code> package in the book’s code archive at <code class="inlineCode">MELD/Chapter06/buildroot/package/helloworld</code> and the source code for the program in <code class="inlineCode">MELD/Chapter06/helloworld</code>. The location of the code is hardcoded to a local path name. </p>
    <p class="normal">In a more realistic case, you <a id="_idIndexMarker453"/>would get the code from a source code system or from a central server of some kind. There are details on how to do this in <em class="italic">The Buildroot user manual</em> and plenty of examples in other packages.</p>
    <h2 id="_idParaDest-194" class="heading-2"><a id="_idTextAnchor218"/>License compliance</h2>
    <p class="normal">Buildroot is based on open source software. So are the packages it compiles. At some point during the project, you should check the licenses by running:</p>
    <pre class="programlisting con"><code class="hljs-con">$ make legal-info
</code></pre>
    <p class="normal">The license <a id="_idIndexMarker454"/>information is gathered in the <code class="inlineCode">output/legal-info</code> directory. There are summaries of the licenses used to compile the host tools in <code class="inlineCode">host-manifest.csv</code> and on the target in <code class="inlineCode">manifest.csv</code>. There is more information in the <code class="inlineCode">README</code> file and in <em class="italic">The Buildroot user manual</em>.</p>
    <p class="normal">Now let’s switch build systems and start learning about The Yocto Project.</p>
    <h1 id="_idParaDest-195" class="heading-1"><a id="_idTextAnchor219"/>Introducing The Yocto Project</h1>
    <p class="normal">The Yocto Project is a <a id="_idIndexMarker455"/>more complex beast than Buildroot. Not only can it build toolchains, bootloaders, kernels, and root filesystems, but it can generate an entire Linux distribution for you with binary packages that can be installed at runtime. The build process is structured around groups of recipes written using a combination of Python and shell script. The Yocto Project includes a task scheduler called <strong class="keyWord">BitBake</strong> that <a id="_idIndexMarker456"/>produces whatever <a id="_idIndexMarker457"/>you have configured from the recipes. There is plenty of online<a id="_idIndexMarker458"/> documentation at <a href="https://www.yoctoproject.org/"><span class="url">https://www.yoctoproject.org/</span></a>.</p>
    <h2 id="_idParaDest-196" class="heading-2"><a id="_idTextAnchor220"/>Background</h2>
    <p class="normal">The structure of The Yocto Project makes <a id="_idIndexMarker459"/>more sense if you look at the background first. Its roots are in <strong class="keyWord">OpenEmbedded</strong> (<a href="https://openembedded.org"><span class="url">https://openembedded.org</span></a>), which grew out of a number of projects to port Linux to <a id="_idIndexMarker460"/>various hand-held computers, including the Sharp Zaurus and the Compaq iPAQ. OpenEmbedded came to life in 2003 as the build system for those hand-held computers. Soon after, other developers began to use it as a general build system for devices running embedded Linux. It was developed and continues to be developed by an enthusiastic community of programmers.</p>
    <p class="normal">The OpenEmbedded project set out to create a set of binary packages using the compact IPK format. These packages could then be installed on the target at runtime to create a variety of systems. It did this by creating recipes for each package and using BitBake as the task scheduler. OpenEmbedded is very flexible. By supplying the right metadata, you can create an entire Linux distribution according to your specifications.</p>
    <p class="normal">Back in 2005, Richard Purdie, then a developer at OpenedHand, created a fork of OpenEmbedded that had a more conservative choice of packages and created releases that were stable over a period of time. He named it <strong class="keyWord">Poky</strong> (rhymes with hockey) after the Japanese snack. Although Poky was a fork, OpenEmbedded and Poky continued to track each other, sharing updates and keeping architectures in step. Intel bought OpenedHand in 2008 and transferred Poky to the Linux Foundation in 2010 when they formed The Yocto Project.</p>
    <p class="normal">Since 2010, the common components of OpenEmbedded and Poky have been combined into a separate project known as <strong class="keyWord">OpenEmbedded Core</strong>, or just <strong class="keyWord">OE-Core</strong>.</p>
    <p class="normal">The Yocto Project collects together <a id="_idIndexMarker461"/>several components, the most important of which are:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">OE-Core</strong>: Is the core metadata that is shared with OpenEmbedded.</li>
      <li class="bulletList"><strong class="keyWord">BitBake</strong>: Is the task scheduler that is shared with OpenEmbedded and other projects.</li>
      <li class="bulletList"><strong class="keyWord">Poky</strong>: Is the reference distribution. The Git repo for Poky also includes a <code class="inlineCode">meta-yocto-bsp </code>layer with reference hardware machines.</li>
      <li class="bulletList"><strong class="keyWord">Documentation</strong>: Is the user manuals and developer guides for each component.</li>
      <li class="bulletList"><strong class="keyWord">Toaster</strong>: is a web-based interface to BitBake and its metadata.</li>
    </ul>
    <p class="normal">Yocto provides a stable base that can be used as-is or extended using <strong class="keyWord">meta layers</strong> which I will discuss later in this chapter. Many SoC vendors provide BSPs for their devices in this way. Meta layers can also be used to create extended or different build systems. Some are open source like Poky and others are commercial like Wind River Linux. Yocto has a branding and compatibility testing scheme to ensure that there is interoperability between components. You will see statements like “Yocto Project compatible” on various web pages.</p>
    <p class="normal">Consequently, you should think of Yocto as the foundation for a whole sector of embedded Linux in addition to being a complete build system in its own right.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">IMPORTANT NOTE</strong></p>
      <p class="normal">You may be wondering about the name. It turns out <em class="italic">yocto</em> is the SI prefix for 10<sup class="superscript">-24</sup> in the same way that <em class="italic">micro</em> is 10<sup class="superscript">-6</sup>. Why name the project Yocto? The name was chosen partly to indicate that it could build very small Linux systems (although to <a id="_idIndexMarker462"/>be fair so can other build systems). It is also a dig at the now defunct Ångström Distribution, which was based on OpenEmbedded. An Ångström is 10<sup class="superscript">10</sup>. That’s huge compared to a <em class="italic">yocto</em>!</p>
    </div>
    <h2 id="_idParaDest-197" class="heading-2"><a id="_idTextAnchor221"/>Stable releases and supports</h2>
    <p class="normal">Routinely, there is a <a id="_idIndexMarker463"/>release of Yocto every six months: in April and October. They are principally known by their code names, but it is also useful to know their Yocto and BitBake version numbers. Here is a table of the six most recent releases at the time of writing:</p>
    <table id="table001-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Code Name</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Release Date</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Yocto Version</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">BitBake Version</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Scarthgap</p>
          </td>
          <td class="table-cell">
            <p class="normal">April 2024</p>
          </td>
          <td class="table-cell">
            <p class="normal">5.0</p>
          </td>
          <td class="table-cell">
            <p class="normal">2.8</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Nanbield</p>
          </td>
          <td class="table-cell">
            <p class="normal">November 2023</p>
          </td>
          <td class="table-cell">
            <p class="normal">4.3</p>
          </td>
          <td class="table-cell">
            <p class="normal">2.6</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Mickledore</p>
          </td>
          <td class="table-cell">
            <p class="normal">May 2023</p>
          </td>
          <td class="table-cell">
            <p class="normal">4.2</p>
          </td>
          <td class="table-cell">
            <p class="normal">2.4</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Langdale</p>
          </td>
          <td class="table-cell">
            <p class="normal">October 2022</p>
          </td>
          <td class="table-cell">
            <p class="normal">4.1</p>
          </td>
          <td class="table-cell">
            <p class="normal">2.2</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Kirkstone</p>
          </td>
          <td class="table-cell">
            <p class="normal">May 2022</p>
          </td>
          <td class="table-cell">
            <p class="normal">4.0</p>
          </td>
          <td class="table-cell">
            <p class="normal">2.0</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Honister</p>
          </td>
          <td class="table-cell">
            <p class="normal">October 2021</p>
          </td>
          <td class="table-cell">
            <p class="normal">3.4</p>
          </td>
          <td class="table-cell">
            <p class="normal">1.52</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 6.1 – Six most recent releases of Yocto</p>
    <p class="normal">The stable releases are supported with security and critical bug fixes for the current release cycle and the next cycle. In other words, each stable version is supported for approximately 12 months after release. In addition to stable releases, Yocto also provides LTS releases. The 3.1 (dunfell) release of Yocto back in April 2020 was the first LTS release. The LTS designation means that the version of Yocto will receive defect fixes and updates for an extended period of two years. Consequently, the plan going forward is to choose an LTS release of Yocto every two years.</p>
    <p class="normal">As with Buildroot, if you want continued support, you can update to the next stable release or you can backport changes to your version. With Yocto, you also have the option of commercial support for several years from operating system vendors such as Siemens and Wind River.</p>
    <h2 id="_idParaDest-198" class="heading-2"><a id="_idTextAnchor222"/>Installing The Yocto Project</h2>
    <p class="normal">To get a<a id="_idIndexMarker464"/> copy of The Yocto Project, clone the repo choosing the code name (<code class="inlineCode">scarthgap</code> in this case) as the branch:</p>
    <pre class="programlisting con"><code class="hljs-con">$ git clone -b scarthgap git://git.yoctoproject.org/poky.git
</code></pre>
    <p class="normal">Since we are building images for BeaglePlay, we also need to clone the <code class="inlineCode">meta-ti</code> repo:</p>
    <pre class="programlisting con"><code class="hljs-con">$ git clone -b scarthgap https://github.com/TexasInstruments-Sandbox/meta-ti
</code></pre>
    <p class="normal">And since the <code class="inlineCode">meta-ti-bsp</code> layer depends on the <code class="inlineCode">meta-arm</code> layer, we must clone that repo well:</p>
    <pre class="programlisting con"><code class="hljs-con">$ git clone -b scarthgap git://git.yoctoproject.org/meta-arm
</code></pre>
    <p class="normal">Note that both the <code class="inlineCode">meta-ti</code> and <code class="inlineCode">meta-arm</code> branch names must match the Yocto code name to ensure these additional layers are compatible with the scarthgap version of Yocto. It is also good practice to run <code class="inlineCode">git pull</code> periodically to grab the latest bug fixes and security patches from all the remote branches.</p>
    <p class="normal">Read the <em class="italic">Compatible Linux Distribution</em> and <em class="italic">Build Host Packages</em> sections in the <em class="italic">Yocto Project Quick Build</em> guide (<a href="https://docs.yoctoproject.org/brief-yoctoprojectqs/"><span class="url">https://docs.yoctoproject.org/brief-yoctoprojectqs/</span></a>). Make sure that the essential packages for your Ubuntu host distribution are installed on your host computer. The next step is configuring.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">IMPORTANT NOTE</strong></p>
      <p class="normal">Ubuntu 24.04 LTS (Noble Numbat) was not officially supported by The Yocto Project at the time of writing. Upon Noble Numbat’s release, users experienced numerous BitBake errors related to permissions. These errors were a result of increased security restrictions placed on the operating system by AppArmor. To temporarily disable these AppArmor protections:</p>
      <p class="normal"><code class="inlineCode">$ echo 0 | sudo tee /proc/sys/kernel/apparmor_restrict_unprivileged_userns</code></p>
      <p class="normal">Remember to rerun this command every time you reboot your Ubuntu host before using Yocto. </p>
    </div>
    <h2 id="_idParaDest-199" class="heading-2"><a id="_idTextAnchor223"/>Configuring</h2>
    <p class="normal">Let’s begin by building the 64-bit Arm QEMU emulator. Start by sourcing a script to set up the environment:</p>
    <pre class="programlisting con"><code class="hljs-con">$ source poky/oe-init-build-env
</code></pre>
    <p class="normal">This creates a<a id="_idIndexMarker465"/> working directory for you named <code class="inlineCode">build</code> and makes it the current directory. All the configuration, intermediate, and target image files will be put in this directory. You must source this script each time you want to work on this project.</p>
    <p class="normal">To choose a different working directory, add it as a parameter to <code class="inlineCode">oe-init-build-env</code> like so:</p>
    <pre class="programlisting con"><code class="hljs-con">$ source poky/oe-init-build-env build-qemu-arm64
</code></pre>
    <p class="normal">This will put you into the <code class="inlineCode">build-qemu-arm64</code> directory. This way, you can have several build directories, each for a different project. You choose which one you want to work with through the parameter passed to <code class="inlineCode">oe-init-build-env</code>.</p>
    <p class="normal">Initially, the <code class="inlineCode">build</code> directory contains only one subdirectory named <code class="inlineCode">conf</code> with the configuration files for this project:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">local.conf</code>: Contains a specification of the device you are going to build and the build environment.</li>
      <li class="bulletList"><code class="inlineCode">bblayers.conf</code>: Contains paths of the meta layers you are going to use. I will describe layers later.</li>
    </ul>
    <p class="normal">For now, we just need to set the <code class="inlineCode">MACHINE</code> variable in <code class="inlineCode">conf/local.conf</code> to <code class="inlineCode">qemuarm64</code> by removing the comment character (<em class="italic">#</em>) at the start of this line:</p>
    <pre class="programlisting code"><code class="hljs-code">MACHINE ?= "qemuarm64"
</code></pre>
    <p class="normal">Now we are ready to <a id="_idIndexMarker466"/>build our first image with Yocto.</p>
    <h2 id="_idParaDest-200" class="heading-2"><a id="_idTextAnchor224"/>Building</h2>
    <p class="normal">To perform the build, you<a id="_idIndexMarker467"/> need to run BitBake and tell it which root filesystem image you want to create. Some common images are:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">core-image-minimal</code>: Is a small console-based system that is useful for tests and as the basis for custom images.</li>
      <li class="bulletList"><code class="inlineCode">core-image-minimal-initramfs</code>: Is similar to <code class="inlineCode">core-image-minimal</code> but built as a RAM disk.</li>
      <li class="bulletList"><code class="inlineCode">core-image-x11</code>: Is a basic image with support for graphics through an X11 server and the XTerminal terminal app.</li>
      <li class="bulletList"><code class="inlineCode">core-image-full-cmdline</code>: Is a console-based system that offers a standard CLI experience and full support for the target hardware.</li>
    </ul>
    <p class="normal">By giving BitBake the final target, it will work backward and build all the dependencies starting with the toolchain. For now, we just want to create a minimal image to see how it works:</p>
    <pre class="programlisting con"><code class="hljs-con">$ bitbake core-image-minimal
</code></pre>
    <p class="normal">The first build will take some time (likely more than an hour) even with several CPU cores and lots of RAM. It will download about 4.9 GB of source code and consume about 49 GB of disk space. When the build completes, you will find several new directories in the <code class="inlineCode">build</code> directory. </p>
    <p class="normal">These include <code class="inlineCode">downloads</code>, which contains all the source downloaded for the build, and <code class="inlineCode">tmp</code>, which contains most of the build artifacts. Inside <code class="inlineCode">tmp</code> you will find the following:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">work</code>: Contains the build directory and the staging area for the root filesystem.</li>
      <li class="bulletList"><code class="inlineCode">deploy</code>: Contains the final binaries to be deployed on the target:</li>
      <li class="bulletList"><code class="inlineCode">deploy/images/&lt;machine name&gt;</code>: Contains the bootloader, kernel, and root filesystem images for the target.</li>
      <li class="bulletList"><code class="inlineCode">deploy/rpm</code>: Contains the RPM packages that make up the images.</li>
      <li class="bulletList"><code class="inlineCode">deploy/licenses</code>: Contains the license files extracted from each package.</li>
    </ul>
    <p class="normal">When the build is done, we can boot the finished image on QEMU.</p>
    <h2 id="_idParaDest-201" class="heading-2"><a id="_idTextAnchor225"/>Running the QEMU target</h2>
    <p class="normal">When you build a QEMU target, an internal version of QEMU is generated. This eliminates the need to install the QEMU package for your distribution. There is a wrapper script named <code class="inlineCode">runqemu</code> to run this internal <a id="_idIndexMarker468"/>version of QEMU.</p>
    <p class="normal">To run the QEMU emulation, make sure to first run <code class="inlineCode">source oe-init-build-env build-qemu-arm64</code> and then type:</p>
    <pre class="programlisting con"><code class="hljs-con">$ runqemu qemuarm64
</code></pre>
    <p class="normal">In this case, QEMU has been configured with a graphic console so that the login prompt appears in a black framebuffer. Log in as root without a password. Close the framebuffer window to exit QEMU.</p>
    <p class="normal">To launch QEMU without the graphic window, add <code class="inlineCode">nographic</code> to the command line:</p>
    <pre class="programlisting con"><code class="hljs-con">$ runqemu qemuarm64 nographic
</code></pre>
    <p class="normal">In the <code class="inlineCode">nographic</code> case, close QEMU using the key sequence <em class="italic">Ctrl + A</em> and then <em class="italic">x</em>.</p>
    <p class="normal">The <code class="inlineCode">runqemu</code> script has many other options. Type <code class="inlineCode">runqemu help</code> for more information.</p>
    <h2 id="_idParaDest-202" class="heading-2"><a id="_idTextAnchor226"/>Layers</h2>
    <p class="normal">Yocto metadata is structured as layers. A layer is a directory containing a collection of BitBake metadata in the form <a id="_idIndexMarker469"/>of recipe files. Each recipe file is used to build an individual software package. The layers are stacked on top of each other to build or “bake” all the software recipes into a finished Linux image much like baking a cake. By convention, each layer has a name beginning with <code class="inlineCode">meta</code>. The core layers are:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">meta</code>: Is the equivalent of an unmodified OpenEmbedded core.</li>
      <li class="bulletList"><code class="inlineCode">meta-poky</code>: Is the metadata specific to the Poky distribution.</li>
      <li class="bulletList"><code class="inlineCode">meta-yocto-bsp</code>: Contains the BSPs for the reference machines that Yocto regularly tests.</li>
    </ul>
    <p class="normal">The list of layers in which BitBake searches for recipes is stored in <code class="inlineCode">&lt;your build directory&gt;/conf/bblayers.conf</code> and by default includes all three layers from the preceding list.</p>
    <p class="normal">Structuring the recipes and other configuration data in this way makes it very easy to extend Yocto by adding new layers. Additional layers are available from SoC manufacturers, The Yocto Project itself, and a wide range of people wishing to add value to Yocto and OpenEmbedded. There is a useful list of layers at <a href="https://layers.openembedded.org/layerindex/"><span class="url">https://layers.openembedded.org/layerindex/</span></a>. Here are some examples:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">meta-qt5</code>: Qt 5 libraries and utilities</li>
      <li class="bulletList"><code class="inlineCode">meta-intel</code>: BSPs for Intel CPUs and SoCs</li>
      <li class="bulletList"><code class="inlineCode">meta-raspberrypi</code>: BSPs for the Raspberry Pi boards</li>
      <li class="bulletList"><code class="inlineCode">meta-ti</code>: BSPs for TI Arm-based SoCs</li>
    </ul>
    <p class="normal">Adding a layer is as simple as copying the meta directory to a suitable location and adding it to <code class="inlineCode">bblayers.conf</code>. Make sure that you read the <code class="inlineCode">REAMDE</code> file that should accompany each layer to see what dependencies it has on other layers and which versions of Yocto it is compatible with.</p>
    <p class="normal">To illustrate how layers work, let’s create a layer for our Nova board that we can use for the remainder of the chapter as we add features. You can see the complete implementation of the layer under <code class="inlineCode">MELD/Chapter06/meta-nova</code> in the code archive.</p>
    <p class="normal">Each meta layer must have at least one configuration file named <code class="inlineCode">conf/layer.conf</code> and should also have a <code class="inlineCode">README</code> file and a license.</p>
    <p class="normal">To create our <code class="inlineCode">meta-nova</code> layer, perform the following steps:</p>
    <pre class="programlisting con"><code class="hljs-con">$ source poky/oe-init-build-env build-nova
$ bitbake-layers create-layer nova
$ mv nova ../meta-nova
</code></pre>
    <p class="normal">This will put you in a working directory named <code class="inlineCode">build-nova</code> and create a layer named <code class="inlineCode">meta-nova</code> with a <code class="inlineCode">conf/layer.conf</code>, an outline <code class="inlineCode">README</code>, and a <code class="inlineCode">COPYING.MIT</code> license under <code class="inlineCode">../meta-nova</code>. The <code class="inlineCode">layer.conf</code> file looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"># We have a conf and classes directory, add to BBPATH
BBPATH .= ":${LAYERDIR}"
# We have recipes-* directories, add to BBFILES
BBFILES += "${LAYERDIR}/recipes-*/*/*.bb \
            ${LAYERDIR}/recipes-*/*/*.bbappend"
BBFILE_COLLECTIONS += "nova"
BBFILE_PATTERN_nova = "^${LAYERDIR}/"
BBFILE_PRIORITY_nova = "6"
LAYERDEPENDS_nova = "core"
LAYERSERIES_COMPAT_nova = "scarthgap"
</code></pre>
    <p class="normal">The layer adds itself to <code class="inlineCode">BBPATH</code> and the recipes it contains to <code class="inlineCode">BBFILES</code>. From looking at the code, you can see that the recipes are found in the directories with names beginning with <code class="inlineCode">recipes-</code> and have filenames ending in <code class="inlineCode">.bb</code> (for normal BitBake recipes) or <code class="inlineCode">.bbappend</code> (for recipes that extend existing recipes by overriding or adding to the instructions). This layer has the name <code class="inlineCode">nova</code> and is added to the list of layers in <code class="inlineCode">BBFILE_COLLECTIONS</code> with a priority of <code class="inlineCode">6</code>. The layer priority is used if the same recipe appears in several layers. The one in the layer with the highest priority wins.</p>
    <p class="normal">Before adding the Nova layer, we must first add the <code class="inlineCode">meta-arm-toolchain</code>, <code class="inlineCode">meta-arm</code>, and <code class="inlineCode">meta-ti-bsp</code> layers in that precise order:</p>
    <pre class="programlisting con"><code class="hljs-con">$ bitbake-layers add-layer ../meta-arm/meta-arm-toolchain
$ bitbake-layers add-layer ../meta-arm/meta-arm
$ bitbake-layers add-layer ../meta-ti/meta-ti-bsp
</code></pre>
    <p class="normal">Now add the Nova layer to your build configuration:</p>
    <pre class="programlisting con"><code class="hljs-con">$ bitbake-layers add-layer ../meta-nova
</code></pre>
    <p class="normal">Make sure to run all these <code class="inlineCode">bitbake-layers add-layer</code> commands from your <code class="inlineCode">build-nova</code> working directory <a id="_idIndexMarker470"/>after sourcing that environment.</p>
    <p class="normal">Confirm that your layer structure is set up correctly like this:</p>
    <pre class="programlisting con"><code class="hljs-con">$ bitbake-layers show-layers
NOTE: Starting bitbake server...
layer                 path                                      priority
==========================================================================
core                  /home/frank/poky/meta                     5
yocto                 /home/frank/poky/meta-poky                5
yoctobsp              /home/frank/poky/meta-yocto-bsp           5
arm-toolchain         /home/frank/meta-arm/meta-arm-toolchain   5
meta-arm              /home/frank/meta-arm/meta-arm             5
meta-ti-bsp           /home/frank/meta-ti/meta-ti-bsp           6
nova                  /home/frank/meta-nova                     6
</code></pre>
    <p class="normal">There you can see the new layer. Because it has a priority of <code class="inlineCode">6</code>, it can override recipes in the other layers that all have a lower priority.</p>
    <p class="normal">Run a build using this empty layer. The final target will be the Nova board, but for now, build for the BeaglePlay by adding <code class="inlineCode">MACHINE ?= "beagleplay-ti"</code> to <code class="inlineCode">conf/local.conf</code>. Then build a small image using <code class="inlineCode">bitbake core-image-minimal</code> like before.</p>
    <p class="normal">In addition to recipes, layers may contain BitBake classes, configuration files, distributions, and more. I will look at recipes next and show you how to create a customized image and a package.</p>
    <h3 id="_idParaDest-203" class="heading-3"><a id="_idTextAnchor227"/>BitBake and recipes</h3>
    <p class="normal">BitBake processes metadata of <a id="_idIndexMarker471"/>several different types:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">recipes </strong>(files ending in <code class="inlineCode">.bb</code>): Contain information about building a unit of software, including how to get a copy of the source code, the dependencies on other components, and how to build and install it.</li>
      <li class="bulletList"><strong class="keyWord">append</strong> (files ending in <code class="inlineCode">.bbappend</code>): Override or extend some details of a recipe. A <code class="inlineCode">.bbappend</code> file appends its instructions to the end of a recipe (<code class="inlineCode">.bb</code>) file with the same root name.</li>
      <li class="bulletList"><strong class="keyWord">include</strong> (files ending in <code class="inlineCode">.inc</code>): Contain information that is common to several recipes allowing information to be shared among them. The files may be included using the <strong class="keyWord">include</strong> or <strong class="keyWord">require</strong> keyword. The difference is that <code class="inlineCode">require</code> produces an error if the file does not exist whereas <code class="inlineCode">include</code> does not.</li>
      <li class="bulletList"><strong class="keyWord">classes</strong> (files ending in <code class="inlineCode">.bbclass</code>): Contain common build information like how to build a kernel or how to build an Autotools project. Classes are inherited by recipes and by other classes using the <code class="inlineCode">inherit</code> keyword. The class <code class="inlineCode">classes/base.bbclass</code> is implicitly inherited by every recipe.</li>
      <li class="bulletList"><strong class="keyWord">configuration</strong> (files ending in <code class="inlineCode">.conf</code>): Define various configuration variables that govern a project’s build process.</li>
    </ul>
    <p class="normal">A <strong class="keyWord">recipe</strong> is a collection of tasks written in a combination of Python and shell script. The tasks have names such as <code class="inlineCode">do_fetch</code>, <code class="inlineCode">do_unpack</code>, <code class="inlineCode">do_patch</code>, <code class="inlineCode">do_configure</code>, <code class="inlineCode">do_compile</code>, and <code class="inlineCode">do_install</code>. You use <a id="_idIndexMarker472"/>BitBake to execute these tasks. The default task is <code class="inlineCode">do_build</code>, which performs all the subtasks required to build the recipe. You can list the tasks available in a recipe using <code class="inlineCode">bitbake -c listtasks &lt;recipe&gt;</code>. For example, to list the tasks in <code class="inlineCode">core-image-minimal</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">$ bitbake -c listtasks core-image-minimal
</code></pre>
    <div class="note">
      <p class="normal"><strong class="keyWord">IMPORTANT NOTE</strong></p>
      <p class="normal">The <code class="inlineCode">-c</code> option tells BitBake to run a specific task from a recipe without having to include the <code class="inlineCode">do_</code> part at the beginning of the task name.</p>
    </div>
    <p class="normal"><code class="inlineCode">do_listtasks</code> is a special task that lists all the tasks defined within a recipe. Here is the <code class="inlineCode">fetch</code> task, which downloads the source code for a recipe:</p>
    <pre class="programlisting con"><code class="hljs-con">$ bitbake -c fetch busybox
</code></pre>
    <p class="normal">To get the code for a target and all its dependencies (which is useful when you want to make sure you have downloaded all the code for the image you are about to build), use the following:</p>
    <pre class="programlisting con"><code class="hljs-con">$ bitbake core-image-minimal --runall=fetch
</code></pre>
    <p class="normal">The recipe files are usually named <code class="inlineCode">&lt;package-name&gt;_&lt;version&gt;.bb</code>. They may have dependencies on other recipes, which would allow BitBake to work out all the subtasks that need to be executed to complete the top-level job.</p>
    <p class="normal">To create a recipe for <a id="_idIndexMarker473"/>our <code class="inlineCode">helloworld</code> program in <code class="inlineCode">meta-nova</code>, you would create a directory structure like this:</p>
    <pre class="programlisting con"><code class="hljs-con">meta-nova/recipes-local/helloworld
├── files
│   └── helloworld.c
└── helloworld_1.0.bb
</code></pre>
    <p class="normal">The recipe is <code class="inlineCode">helloworld_1.0.bb</code> and the source is kept local to the recipe in the <code class="inlineCode">files</code> subdirectory. The recipe contains these instructions:</p>
    <pre class="programlisting code"><code class="hljs-code">DESCRIPTION = "A friendly program that prints Hello World!"
SECTION = "examples"
LICENSE = "GPL-2.0-only"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/GPL-2.0-only;md5=801f80980d171dd6425610833a22dbe6"
SRC_URI = "file://helloworld.c"
S = "${WORKDIR}"
do_compile() {
    ${CC} ${CFLAGS} ${LDFLAGS} helloworld.c -o helloworld
}
do_install() {
    install -d ${D}${bindir}
    install -m 0755 helloworld ${D}${bindir}
}
</code></pre>
    <p class="normal">The location of the source code is set by <code class="inlineCode">SRC_URI</code>. In this case, the <code class="inlineCode">file://</code> URI means that the code is local to the recipe directory. BitBake will search the <code class="inlineCode">files</code>, <code class="inlineCode">helloworld</code>, and <code class="inlineCode">helloworld-1.0</code> directories relative to the directory that contains the recipe. The tasks that need to be defined are <code class="inlineCode">do_compile</code> and <code class="inlineCode">do_install</code>, which compile the source file and install it into the target root filesystem: <code class="inlineCode">${D}</code> expands to the staging area of the recipe and <code class="inlineCode">${bindir}</code> to the default <code class="inlineCode">/usr/bin</code> binary directory.</p>
    <p class="normal">Every recipe has a license defined by <code class="inlineCode">LICENSE</code>, which is set to <code class="inlineCode">GPL-2.0-only</code> here. The file containing the text of the license and a checksum is defined by <code class="inlineCode">LIC_FILES_CHKSUM</code>. BitBake will terminate the build if the checksum does not match, indicating that the license has changed in some way. Note that the MD5 checksum value and <code class="inlineCode">COMMON_LICENSE_DIR</code> are on the same line separated by a semicolon. The license file may be part of the package, or it may point to one of the standard license texts in <code class="inlineCode">meta/files/common-licenses</code> as is the case here.</p>
    <p class="normal">Commercial licenses are disallowed by default, but it is easy to enable them. You need to specify the license in the recipe as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code">LICENSE_FLAGS = "commercial"
</code></pre>
    <p class="normal">Then, in your <code class="inlineCode">conf/local.conf</code>, explicitly allow this license like so:</p>
    <pre class="programlisting code"><code class="hljs-code">LICENSE_FLAGS_ACCEPTED = "commercial"
</code></pre>
    <p class="normal">To make sure that<a id="_idIndexMarker474"/> our <code class="inlineCode">helloworld</code> recipe compiles correctly, ask BitBake to build it:</p>
    <pre class="programlisting con"><code class="hljs-con">$ bitbake helloworld
</code></pre>
    <p class="normal">If all goes well, you should see that it has created a working directory for it in <code class="inlineCode">tmp/work/aarch64-poky-linux/helloworld</code>. You should also see that there is an RPM package for it in <code class="inlineCode">tmp/deploy/rpm/aarch64/helloworld-1.0-r0.aarch64.rpm</code>.</p>
    <p class="normal">The package is not part of the target image yet. The list of packages to be installed is held in a variable named <code class="inlineCode">IMAGE_INSTALL</code>. You can append to the end of that list by adding this line to <code class="inlineCode">conf/local.conf</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">IMAGE_INSTALL:append = " helloworld"
</code></pre>
    <p class="normal">Note that there needs to be a space between the opening double quote and the first package name. Now the package will be added to any image that you <code class="inlineCode">bitbake</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">$ bitbake core-image-minimal
</code></pre>
    <p class="normal">If you look in <code class="inlineCode">deploy-ti/images/beagleplay-ti/core-image-minimal-beagleplay-ti.rootfs.tar.xz</code>, you will see that <code class="inlineCode">/usr/bin/helloworld</code> has indeed been installed.</p>
    <h2 id="_idParaDest-204" class="heading-2"><a id="_idTextAnchor228"/>Customizing images via local.conf</h2>
    <p class="normal">You often may want to<a id="_idIndexMarker475"/> add a package to an image during development or tweak it in other ways. As we’ve just seen, you can simply append to the list of packages to be installed by adding a statement like:</p>
    <pre class="programlisting code"><code class="hljs-code">IMAGE_INSTALL:append = " helloworld"
</code></pre>
    <p class="normal">You can make more sweeping changes via <code class="inlineCode">EXTRA_IMAGE_FEATURES</code>. Here is a short list, which should give you an idea of the features you can enable:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">dbg-pkgs</code>: Installs debug symbol packages for all the packages installed in the image.</li>
      <li class="bulletList"><code class="inlineCode">debug-tweaks</code>: Allows <code class="inlineCode">root</code> logins without passwords and other changes that make development easier. Never enable <code class="inlineCode">debug-tweaks</code> in production images.</li>
      <li class="bulletList"><code class="inlineCode">package-management</code>: Installs package management tools and preserves the package manager database.</li>
      <li class="bulletList"><code class="inlineCode">read-only-rootfs</code>: Makes the root filesystem read-only. We will cover this in more detail in <a href="Chapter_09.xhtml#_idTextAnchor293"><em class="italic">Chapter 9</em></a>.</li>
      <li class="bulletList"><code class="inlineCode">x11</code>: Installs the X server.</li>
      <li class="bulletList"><code class="inlineCode">x11-base</code>: Installs <a id="_idIndexMarker476"/>the X server with a minimal environment.</li>
    </ul>
    <p class="normal">There are many more features you can add in this way. I recommend you look at the <em class="italic">Image Features</em> section of the <em class="italic">Yocto Project Reference Manual</em> at <a href="https://docs.yoctoproject.org/ref-manual/"><span class="url">https://docs.yoctoproject.org/ref-manual/</span></a> and read through the code in <code class="inlineCode">meta/classes-recipe/core-image.bbclass</code>.</p>
    <h2 id="_idParaDest-205" class="heading-2"><a id="_idTextAnchor229"/>Writing an image recipe</h2>
    <p class="normal">The problem with making<a id="_idIndexMarker477"/> changes to <code class="inlineCode">local.conf</code> is that they are, well, local. If you want to create an image that is to be shared with other developers or to be loaded onto a production system, then you should put the changes in an <strong class="keyWord">image recipe</strong>.</p>
    <p class="normal">An image recipe contains <a id="_idIndexMarker478"/>instructions about how to create the image files for a target, including the bootloader, kernel, and root filesystem images. By convention, image recipes are put into a directory named <code class="inlineCode">images</code>. You can get a list of all the images that are available by scanning the <code class="inlineCode">poky</code> directory and any additional layers that you cloned:</p>
    <pre class="programlisting con"><code class="hljs-con">$ cd ~
$ ls poky/meta*/recipes*/images/*.bb
$ ls meta*/recipes*/images/*.bb
</code></pre>
    <p class="normal">You will find that the recipe for <code class="inlineCode">core-image-minimal</code> is in <code class="inlineCode">poky</code>/<code class="inlineCode">meta/recipes-core/images/core-image-minimal.bb</code>.</p>
    <p class="normal">A simple approach is to take an existing image recipe and modify it using statements like the ones you used in <code class="inlineCode">local.conf</code>.</p>
    <p class="normal">Imagine that you want an image that is the same as <code class="inlineCode">core-image-minimal</code> but includes your <code class="inlineCode">helloworld</code> program and the <code class="inlineCode">strace</code> utility. You can do that with a two-line recipe file that includes (using the <code class="inlineCode">require</code> keyword) the base image and adds the packages you want. It is conventional to put the image in a directory named <code class="inlineCode">images</code>, so add the recipe <code class="inlineCode">nova-image.bb</code> with this content in <code class="inlineCode">meta-nova/recipes-local/images</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">require recipes-core/images/core-image-minimal.bb
IMAGE_INSTALL:append = " helloworld strace"
</code></pre>
    <p class="normal">Now remove the <code class="inlineCode">IMAGE_INSTALL:append</code> line from your <code class="inlineCode">local.conf</code> and build the image:</p>
    <pre class="programlisting con"><code class="hljs-con">$ bitbake nova-image
</code></pre>
    <p class="normal">This time, the build should proceed much quicker because BitBake reuses the intermediate build objects built during prior runs.</p>
    <p class="normal">Not only does BitBake<a id="_idIndexMarker479"/> build images for running on a target device, but it <a id="_idIndexMarker480"/>can also build an SDK for doing cross-development on a host machine.</p>
    <h2 id="_idParaDest-206" class="heading-2"><a id="_idTextAnchor230"/>Creating an SDK</h2>
    <p class="normal">It is very useful to be able to create a standalone toolchain that other developers can install. This avoids the need for <a id="_idIndexMarker481"/>everyone on the team to have a full installation of Yocto. Ideally, you want the toolchain to include development libraries and header files for all the libraries installed on the target. You can do that for any image using the <code class="inlineCode">populate_sdk</code> task, as shown:</p>
    <pre class="programlisting con"><code class="hljs-con">$ bitbake -c populate_sdk nova-image
</code></pre>
    <p class="normal">The result is a self-installing shell script in <code class="inlineCode">deploy-ti/sdk</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">poky-&lt;c_library&gt;-&lt;host_machine&gt;-&lt;target_image&gt;-&lt;target_machine&gt;-toolchain-&lt;version&gt;.sh
</code></pre>
    <p class="normal">For the SDK built with the <code class="inlineCode">nova-image</code> recipe:</p>
    <pre class="programlisting con"><code class="hljs-con">poky-glibc-x86_64-nova-image-aarch64-beagleplay-toolchain-&lt;version&gt;.sh
</code></pre>
    <p class="normal">If you only want a basic toolchain with just C and C++ cross-compilers, the C library, and header files, then run this instead:</p>
    <pre class="programlisting con"><code class="hljs-con">$ bitbake meta-toolchain
</code></pre>
    <p class="normal">To install the SDK, just run the shell script. The default install directory is <code class="inlineCode">/opt/poky</code> but the install script allows you to change this:</p>
    <pre class="programlisting con"><code class="hljs-con">$ deploy-ti/sdk/poky-glibc-x86_64-nova-image-aarch64-beagleplay-toolchain-5.0.3.sh
Poky (Yocto Project Reference Distro) SDK installer version 5.0.3
=================================================================
Enter target directory for SDK (default: /opt/poky/5.0.3):
You are about to install the SDK to "/opt/poky/5.0.3". Proceed [Y/n]? Y
[sudo] password for frank:
Extracting SDK................................................................................................................done
Setting it up...done
SDK has been successfully set up and is ready to be used.
Each time you wish to use the SDK in a new shell session, you need to source the environment setup script e.g.
 $ . /opt/poky/5.0.3/environment-setup-aarch64-poky-linux
</code></pre>
    <p class="normal">To make use of the toolchain, first source the environment and set up the script:</p>
    <pre class="programlisting con"><code class="hljs-con">$ source /opt/poky/&lt;version&gt;/environment-setup-aarch64-poky-linux
</code></pre>
    <div class="packt_tip">
      <p class="normal"><strong class="keyWord">TIP</strong></p>
      <p class="normal">The <code class="inlineCode">environment-setup-*</code> script that sets things up for the SDK is not compatible with the <code class="inlineCode">oe-init-build-env</code> script that you source when working in the Yocto build directory. It is a good rule to always start a new terminal session before you source either script.</p>
    </div>
    <p class="normal">The toolchain generated by The Yocto Project does not have a valid <code class="inlineCode">sysroot</code> directory. We know this to be true <a id="_idIndexMarker482"/>because passing the <code class="inlineCode">-print-sysroot</code> option to the toolchain’s compiler returns <code class="inlineCode">/not/exist</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">$ aarch64-poky-linux-gcc -print-sysroot
/not/exist
</code></pre>
    <p class="normal">Consequently, if you try to cross-compile, it will fail like this:</p>
    <pre class="programlisting con"><code class="hljs-con">$ aarch64-poky-linux-gcc helloworld.c -o helloworld
helloworld.c:1:10: fatal error: stdio.h: No such file or directory
<a id="_idTextAnchor231"/>    1 | #include &lt;stdio.h&gt;
      |          ^~~~~~~~~
compilation terminated.
</code></pre>
    <p class="normal">This is because the compiler has been configured to work for a wide range of Arm processors and the fine-tuning is done when you launch it using the right set of flags. Instead, you should use the shell variables that are created when you source the <code class="inlineCode">environment-setup</code> script for cross-compiling. These include:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">CC</code>: C compiler</li>
      <li class="bulletList"><code class="inlineCode">CXX</code>: C++ compiler</li>
      <li class="bulletList"><code class="inlineCode">CPP</code>: C preprocessor</li>
      <li class="bulletList"><code class="inlineCode">AS</code>: Assembler</li>
      <li class="bulletList"><code class="inlineCode">LD</code>: Linker</li>
    </ul>
    <p class="normal">This is what we find <code class="inlineCode">CC</code> has been set to:</p>
    <pre class="programlisting con"><code class="hljs-con">$ echo $CC
aarch64-poky-linux-gcc -mbranch-protection=standard -fstack-protector-strong -O2 -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -Werror=format-security --sysroot=/opt/poky/5.0.3/sysroots/aarch64-poky-linux
</code></pre>
    <p class="normal">As long as you use <code class="inlineCode">$CC</code> to compile, everything<a id="_idIndexMarker483"/> should work fine:</p>
    <pre class="programlisting con"><code class="hljs-con">$ $CC -O helloworld.c -o helloworld
</code></pre>
    <h2 id="_idParaDest-207" class="heading-2"><a id="_idTextAnchor232"/>The license audit</h2>
    <p class="normal">The Yocto Project insists that each package has a license. A copy of the license is placed in <code class="inlineCode">tmp/deploy/licenses/&lt;package name&gt;</code> for each package as it is built. In addition, a summary of the packages and<a id="_idIndexMarker484"/> licenses used in an image is put into the directory: <code class="inlineCode">&lt;image name&gt;-&lt;machine name&gt;.rootfs-&lt;date stamp&gt;</code>. For the <code class="inlineCode">nova-image</code> we just built, the directory would be named something like this:</p>
    <pre class="programlisting con"><code class="hljs-con">tmp/deploy/licenses/beagleplay/nova-image-beagleplay.rootfs-20241012221506
</code></pre>
    <p class="normal">This completes our survey of the two leading build systems for embedded Linux. Buildroot is simple and quick, making it a good choice for simple single-purpose devices. Yocto is more complex and flexible. Even though there is good support throughout the community and industry for Yocto, the tool still has a very steep learning curve. You can expect it will take several months for you to become proficient with Yocto, and even then, it will sometimes do things that surprise you.</p>
    <h1 id="_idParaDest-208" class="heading-1"><a id="_idTextAnchor233"/>Summary</h1>
    <p class="normal">In this chapter, you learned how to use both Buildroot and The Yocto Project to configure, customize, and build embedded Linux images. We used Buildroot to create a BSP with a custom U-Boot patch and device tree specification for a hypothetical board based on the BeaglePlay. We then learned how to add our own code to an image in the form of a Buildroot package. You were introduced to The Yocto Project, which we will cover in depth over the next two chapters. In particular, you learned some basic BitBake terminology, how to write an image recipe, and how to create an SDK.</p>
    <p class="normal">Don’t forget that any devices you create using these tools will need to be maintained in the field for a period of time, often over many years. Both Yocto and Buildroot provide point releases for about one year after the initial release, and Yocto now offers long-term support for at least four years. In either case, you will find yourself having to maintain your own releases or paying for commercial support. The third possibility, ignoring the problem, is not an option!</p>
    <h1 id="_idParaDest-209" class="heading-1"><a id="_idTextAnchor234"/>Further study</h1>
    <ul>
      <li class="bulletList"><em class="italic">The Buildroot user manual, Buildroot Association </em>–<em class="italic"> </em><a href="https://buildroot.org/downloads/manual/manual.html%0D%0A"><span class="url">https://buildroot.org/downloads/manual/manual.html</span></a></li>
      <li class="bulletList"><em class="italic">Yocto Project Documentation, Yocto Project </em>–<em class="italic"> </em><a href="https://docs.yoctoproject.org/"><span class="url">https://docs.yoctoproject.org/</span></a></li>
    </ul>
  </div>
</div></div></body></html>