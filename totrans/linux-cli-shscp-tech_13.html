<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer240">
			<h1 id="_idParaDest-309"><em class="italic"><a id="_idTextAnchor316"/>Chapter 13</em>: Using Arrays</h1>
			<p>In one of the recipes in a previous chapter, we mentioned arrays as one of the possible compound data types that <strong class="source-inline">bash</strong> supports. We said that what <strong class="source-inline">bash</strong> has is two different data types (strings and numbers), but that there are ways that we can use more than that if we need to. Arrays are just that—something that we need to be able to use since we need something a little bit more complex than single-value variables to solve some problems. </p>
			<p>In this chapter, we are going to cover two basic recipes connected to arrays: </p>
			<ul>
				<li>Basic array manipulation</li>
				<li>Advanced array manipulation</li>
			</ul>
			<p>You can already see that we are being intentionally broad here; arrays are like that—simple on the surface, but with quite a few small tricks if we need to use them. </p>
			<h1 id="_idParaDest-310"><a id="_idTextAnchor317"/>Technical requirements </h1>
			<p>As with all the chapters that cover scripting, we are using any machine that works, and things as fundamental as arrays are going to work on all machines that run <strong class="source-inline">bash</strong>. You will therefore need the following:</p>
			<p>A <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>) with any distributuon of Linux (in our case, it's going to be <strong class="bold">Ubuntu 20.10</strong>)</p>
			<p>So, start your VM!</p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor318"/>Basic array manipulation</h1>
			<p>The thing <a id="_idIndexMarker956"/>with <strong class="source-inline">bash</strong> and variables in <strong class="source-inline">bash</strong> is that they look deceptively simple. There are no formal declarations of type, or basically declarations of any kind. Typing is done by the shell itself, and we can do a lot of things implicitly. This is especially true for <em class="italic">regular</em> variables. Arrays are a little bit more complex, and they offer a few syntactic peculiarities when used, but they are an extremely useful tool. You may wonder why we are even mentioning them in any context since they are nothing more than one value under the same variable name. Well, the main reason is that we often actually need exactly this. A lot of times, we must store multiple values that belong to some set of data. Typically, that will be something such as an unordered list of values in case it is something that we do not care about having in a particular order, or an ordered list of values if we do. </p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor319"/>Getting ready</h2>
			<p>Usually, arrays are defined as <em class="italic">one-dimensional indexed arrays</em>, since they have an explicit order embedded in the very definition of an array. In essence, when we have any multi-value variable, it can be <em class="italic">ordered</em> and <em class="italic">unordered</em>. The difference is in whether we can define in which order the values are declared in the variable. If we can store values but are unable to get the order in which they are stored, that is called an unordered set. In <strong class="source-inline">bash</strong>, we only have ordered lists, which we call arrays. This means that every value in the variable has not only the value itself but a defined index or place. Not only can we add or remove values from an array, but we can also directly read any of them and we can reorder them if we need to. </p>
			<p>We have two types of arrays at our disposal. Both are ordered but one is <em class="italic">indexed</em>, which means<a id="_idIndexMarker957"/> that we have a numerical value that defines a particular element of the array. We also have something named associative arrays, sometimes also called <em class="italic">hash tables</em>. This type of array is useful because it doesn't use a numeric value but instead uses a string key to define a particular array element. We will talk a lot about both. </p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor320"/>How to do it…</h2>
			<p>The first thing we need to do is to declare a variable:</p>
			<p class="source-code">demo@ubuntu:~/includes$ TEST=(first second third fourth fifth)</p>
			<p class="source-code">demo@ubuntu:~/includes$ echo $TEST</p>
			<p class="source-code">first</p>
			<p>We are off to a bad start. Obviously, we declared our variable correctly since there were no errors, but as soon as we tried to print it, we ran into problems. We had those before when we tried to print arrays. The solution is to use a special character to denote the index and tell bash that we want to print not only the first value but all values in the array: </p>
			<p class="source-code">demo@ubuntu:~/includes$ echo ${TEST[@]}</p>
			<p class="source-code">first second third fourth fifth</p>
			<p>This works as intended since <strong class="source-inline">bash</strong> understands it needs to do a quick loop and go through every index in the array, printing all the values. An alternative to that is to use the following: </p>
			<p class="source-code">demo@ubuntu:~/includes$ echo ${TEST[*]}</p>
			<p class="source-code">first second third fourth fifth</p>
			<p>This has the exact same output as the previous command. </p>
			<p>This should get you thinking: <em class="italic">Is there another way to use indexing?</em> Of course there is—we can use it to directly access a single value in the array: </p>
			<p class="source-code">demo@ubuntu:~/includes$ echo ${TEST[2]}</p>
			<p class="source-code">third</p>
			<p class="source-code">demo@ubuntu:~/includes$ echo ${TEST[4]}</p>
			<p class="source-code">fifth</p>
			<p>Make a note <a id="_idIndexMarker958"/>we are <em class="italic">off by one</em> in this example since the first element in an array has an index of <strong class="source-inline">0</strong>. There is one more very interesting property rarely mentioned in terms of arrays. Before we show it, we need to explain another way of declaring an array. </p>
			<p>Declaring a variable using simple brackets is the most common way to do this, but we can also do it by directly specifying elements in an array. The interesting thing is that we can do it in any order we want to: </p>
			<p class="source-code">demo@ubuntu:~/includes$ ORDER[2]=second</p>
			<p class="source-code">demo@ubuntu:~/includes$ ORDER[3]=third</p>
			<p>If we now try to print our array, the result is going to be more dangerous than surprising: </p>
			<p class="source-code">demo@ubuntu:~/includes$ echo ${ORDER[*]}</p>
			<p class="source-code">second third</p>
			<p>Our array has two values stored under indexes. We intentionally made an error in indexing—the value of <strong class="source-inline">second</strong> is stored under index number <strong class="source-inline">2</strong>, making it the third array element. What we didn't do is declare the first element of our array. The reason we said that the result of the previous command is dangerous is that from its output, you cannot see the index of a particular element, so you have no idea what the actual index of a particular value is. This makes it easy to confuse the values—or, to make it more obvious, something such as this will not return a value, although we might think it should: </p>
			<p class="source-code">demo@ubuntu:~/includes$ echo ${ORDER[0]}</p>
			<p class="source-code">demo@ubuntu:~/includes$ echo ${ORDER[1]}</p>
			<p>Things such as these are a common source of errors that we need to troubleshoot, and they are especially complicated to spot if we use the direct syntax of specifying both a value and its index. </p>
			<p>What we are <a id="_idIndexMarker959"/>trying to say is to never use this way of declaring an array, unless you have a particular reason why you need it. Otherwise, things can become confusing later. </p>
			<p>There is a third way to declare an array that is the least commonly used method. Using the <strong class="source-inline">declare</strong> statement and the <strong class="source-inline">-a</strong> switch, you explicitly declare that a particular variable is going to hold an array of values. The reason we rarely see this in code is that when we use either of the already mentioned implicit declarations, our variable will become appropriately typed, so there is simply no reason to do this twice unless you want to do so to make your code readable. </p>
			<p>All of this was just different ways to create and print normal, indexed arrays. We mentioned that there is another type of array called an associative array, also known as a hash table, dictionary, or key-value paired array. This type was introduced in <strong class="source-inline">bash</strong> 4.0 and is still not available on some platforms; most notably, some versions of OS X require you to upgrade <strong class="source-inline">bash</strong> to be able to use this type. </p>
			<p>Real life contains a lot of things that can be considered pairs of values. Things such as username/password, name/address, name/telephone number are naturally created pairs of data that are often used in scripts. Obviously, we could use a normal array to store this, but to do it in a way that enables us to understand which values are a part of a given pair, we would need not one but two separate arrays and a little bit of focus on how we declare indexes for them so that we can use the same index to get the first and the second value:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#we are declaring two arrays, one for the names, one for the #phone numbers</p>
			<p class="source-code">NAMES=(John Luke "Ivan from work" Ida "That guy")</p>
			<p class="source-code">NUMBERS=(12345 12344 113312 11111 122222)</p>
			<p class="source-code">#now we need to pair them up:</p>
			<p class="source-code">for i in {0..4}</p>
			<p class="source-code">do</p>
			<p class="source-code">              echo Name:${NAMES[i]} number:${NUMBERS[i]}</p>
			<p class="source-code">done</p>
			<p>This is going <a id="_idIndexMarker960"/>to give us an output that looks like this: </p>
			<p class="source-code">demo@ubuntu:~/variable$ bash pairs.sh </p>
			<p class="source-code">Name:John number:12345</p>
			<p class="source-code">Name:Luke number:12344</p>
			<p class="source-code">Name:Ivan from work number:113312</p>
			<p class="source-code">Name:Ida number:11111</p>
			<p class="source-code">Name:That guy number:122222</p>
			<p>This looks and works fine if we need to print out all of the data. Imagine now that we have information that we need to search for—imagine we are looking for a telephone number of a particular person. If we needed to do this using regular arrays, something like this could be done: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#we are declaring two arrays, one for the names, one for the #phone numbers</p>
			<p class="source-code">NAMES=(John Luke "Ivan from work" Ida "That guy")</p>
			<p class="source-code">NUMBERS=(12345 12344 113312 11111 122222)</p>
			<p class="source-code">#now we need to pair them up:</p>
			<p class="source-code">for i in {0..4}</p>
			<p class="source-code">do</p>
			<p class="source-code">            if [ "${NAMES[i]}" == "$1" ]</p>
			<p class="source-code">                          then</p>
			<p class="source-code">                                       echo Name:${NAMES[i]} number:${NUMBERS[i]}</p>
			<p class="source-code">            fi</p>
			<p class="source-code">done</p>
			<p>In order to check all the values, we need to go through every element of one array and then print pairs<a id="_idIndexMarker961"/> if we find a match. First, we are going to test this: </p>
			<p class="source-code">demo@ubuntu:~/variable$ bash search.sh John</p>
			<p class="source-code">Name:John number:12345</p>
			<p class="source-code">demo@ubuntu:~/variable$ bash search.sh </p>
			<p class="source-code">demo@ubuntu:~/variable$</p>
			<p>Although this is working, it is not the right way to do it. Some of the downsides of this approach are obvious: </p>
			<ul>
				<li>An array is indexed, so it can hold the same content at different indexes.</li>
				<li>In order to find something, we need to go through all values.</li>
				<li>If we mess up any of the arrays, we can create invalid data.</li>
				<li>The script is very complicated for a simple task. </li>
			</ul>
			<p>That other <em class="italic">associative</em> array type we mentioned is the solution to this and many more problems. While in normal arrays, the values we are using are indexed by numbers. In this particular array type, we use any value as a <em class="italic">key</em> to reference a specific value in an array. </p>
			<p>Doing this requires an explicit declaration of the array type that has to be done using the <strong class="source-inline">declare</strong> statement and the <strong class="source-inline">-A</strong> switch. Be very careful about this switch since it uses a capital letter <em class="italic">A</em>, while <em class="italic">normal</em> arrays are declared using the same letter in lowercase. While you may implicitly declare an indexed array in multiple ways, an associative array can be declared only by using this method and must be declared explicitly. Before we can do a script to fully demonstrate that, we need to show you how to declare an array of this type. Besides the fact that we must use the <strong class="source-inline">declare</strong> statement, we also need to declare the indexes since they can be any string, not just a number. The output looks something like this: </p>
			<p class="source-code">demo@ubuntu:~/variable$ declare -A NAMES</p>
			<p class="source-code">demo@ubuntu:~/variable$ NAMES["John"]=12345</p>
			<p class="source-code">demo@ubuntu:~/variable$ NAMES["Luke"]=12344</p>
			<p class="source-code">demo@ubuntu:~/variable$ NAMES["Ivan from work"]=113312</p>
			<p>There is also a way to declare these arrays in one line, by specifying pairs: </p>
			<p class="source-code">demo@ubuntu:~/variable$ NAMES=([Ida]=11111 ["That guy"]=122222)</p>
			<p>Now that we <a id="_idIndexMarker962"/>have defined this array in two ways, let's do a small follow-up with other operations that we can carry out. We should be able to write out the array values. First, we will try the method we used with regular arrays: </p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${NAMES[*]}</p>
			<p class="source-code">11111 122222</p>
			<p>This is, of course, a problem, but we were expecting it. This syntax is designed for arrays that have a numerical index and is translated into something a human can understand, which means: <em class="italic">print all the values from an array called NAMES by using all possible indices</em>. </p>
			<p>The key here is that we are not printing the index of a value, just the value itself. Since we are using both the key and the value in our arrays, we need to be able to see what the key for a particular value is. This can be done using a <strong class="source-inline">for</strong> loop, but before we do that, we have a point to make—by design, arrays have multiple values, so not only can we redefine the whole array, but we can also add and remove elements from it. We already showed an example in which we added elements to a variable, and we did this by creating a new value under a new index. </p>
			<p>All this applies not only to associative arrays but to arrays in general; however, we are going to use associative arrays just to make you more familiar with this type. We are going to repeat the example from before, but with a twist: </p>
			<p class="source-code">demo@ubuntu:~/variable$ declare -A NAMES</p>
			<p class="source-code">demo@ubuntu:~/variable$ NAMES["John"]=12345</p>
			<p class="source-code">demo@ubuntu:~/variable$ NAMES["Luke"]=12344</p>
			<p class="source-code">demo@ubuntu:~/variable$ NAMES["Ivan from work"]=113312</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${NAMES[*]}</p>
			<p class="source-code">113312 12344 12345</p>
			<p class="source-code">demo@ubuntu:~/variable$ NAMES=([Ida]=11111 ["That guy"]=122222)</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${NAMES[*]}</p>
			<p class="source-code">11111 122222</p>
			<p>What happened? First, we<a id="_idIndexMarker963"/> defined an array that consists of three value pairs. We did this by declaring every single pair by itself. After that, we used the alternative way of array declaration, but since we basically redeclared the array, the values we used completely replaced values that the array had before. What we should have done is <em class="italic">add</em> those values. There are two ways to do this—one is to just define the right values for the pairs again: </p>
			<p class="source-code">demo@ubuntu:~/variable$ NAMES["John"]=12345</p>
			<p class="source-code">demo@ubuntu:~/variable$ NAMES["Ivan from work"]=113312</p>
			<p class="source-code">demo@ubuntu:~/variable$ NAMES["Luke"]=12344</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${NAMES[*]}</p>
			<p class="source-code">113312 11111 12344 12345 122222</p>
			<p>We can now see our array has the expected number of values, although we still don't know how to get them printed. </p>
			<p>Another way to do this is by using addition. We are going to change only one character in our example to do this: </p>
			<p class="source-code">demo@ubuntu:~/variable$ declare -A NAMES</p>
			<p class="source-code">demo@ubuntu:~/variable$ NAMES["John"]=12345</p>
			<p class="source-code">demo@ubuntu:~/variable$ NAMES["Luke"]=12344</p>
			<p class="source-code">demo@ubuntu:~/variable$ NAMES["Ivan from work"]=113312</p>
			<p class="source-code">demo@ubuntu:~/variable$ NAMES+=([Ida]=11111 ["That guy"]=122222)</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${NAMES[*]}</p>
			<p class="source-code">113312 11111 12344 12345 122222</p>
			<p>Can you even notice the change? What we did is use the plus operator in front of the equals sign to tell <strong class="source-inline">bash</strong> that we want these pairs added to our array. This notation is completely <a id="_idIndexMarker964"/>the same as if we had used <strong class="source-inline">NAMES=NAMES+([Ida]=11111 ["That guy"]=122222)</strong>—it is just a little shorter. </p>
			<p>The last thing we need to know is how to remove a value from an array. </p>
			<p>The solution to this is simple—there is a command called <strong class="source-inline">unset</strong> that simply removes the value associated with a particular index or a key. More often than not, this is used on key-value pairs since it makes much more sense there, but you can also do it on a regular array:</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${NAMES[*]}</p>
			<p class="source-code">113312 11111 12344 12345 122222</p>
			<p class="source-code">demo@ubuntu:~/variable$ unset NAMES["John"]</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${NAMES[*]}</p>
			<p class="source-code">113312 11111 12344 122222</p>
			<p>Now, we are going to tackle the big problem and rewrite our script from before, using our only associative array.</p>
			<p>The idea of how to do this is based on the way <strong class="source-inline">bash</strong> uses sets of objects. We are going to create one such set out of all the keys, and then print both the key and the value it points to. To access keys directly, we can use an exclamation point:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#we are declaring one associative array for pairs of values: </p>
			<p class="source-code">declare -A PAIRS</p>
			<p class="source-code">PAIRS=(["John"]=12345 ["Luke"]=12344 ["Ivan from work"] =113312 \</p>
			<p class="source-code">["Ida"]=11111 ["That guy"]=122222)</p>
			<p class="source-code">#now we need to get them printed</p>
			<p class="source-code">for name in "${!PAIRS[@]}"</p>
			<p class="source-code">do</p>
			<p class="source-code">              echo Name:"$name" number:${PAIRS["$name"]} </p>
			<p class="source-code">done</p>
			<p>There are some <a id="_idIndexMarker965"/>small things you need to notice in this script. For example, quotes are important since our keys contain spaces. The general rule here is that as soon you are using any string as a value of anything, it should be enclosed in quotes to get the space parsed correctly. </p>
			<p>The <strong class="source-inline">for</strong> loop is going to go through keys one by one, and keys are going to be used as an entire key value, including a space. Some manuals will state that a key must be a single word, but officially it can be anything. The usage scenario for this type of variable is, however, that we will be using a word or two in most cases:</p>
			<p class="source-code">demo@ubuntu:~/variable$ bash associative.sh </p>
			<p class="source-code">Name:Ivan from work number:113312</p>
			<p class="source-code">Name:Ida number:11111</p>
			<p class="source-code">Name:Luke number:12344</p>
			<p class="source-code">Name:John number:12345</p>
			<p class="source-code">Name:That guy number:122222</p>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor321"/>How it works…</h2>
			<p>We have demonstrated the way arrays work in practice, how to create them, how to read from them, and how to delete individual elements inside an array. What makes arrays a little bit different from regular variables is that variables hold one value, so there are no operations that can modify that value. If we need to change it, we simply redeclare the entire value. When dealing with arrays, we are dealing with multiple values in one array, and that still means we must redeclare any that we need to change, but we are then changing just a single value out of many, not the entire array. This is the main reason we have operations that add and remove elements. </p>
			<p>Some of you already familiar with different programming languages will probably be a little bit confused by the relaxed way some things are defined, especially when we are talking about regular arrays and the way they address individual values and print them. Probably the most confusing part is how you can completely skip a range of indexes and still get a valid array. We are going to talk a little bit more about this in the next recipe, but <strong class="source-inline">bash</strong> is inconsistently vague in some ways, and this is one of them. </p>
			<p>Associative arrays are going to be something you will need from time to time, especially when you need to deal with objects that have some properties. It is not possible to store more than one property per key, but even this makes for a nice environment since this single value<a id="_idIndexMarker966"/> can, for example, be an indexed value that then points to different arrays containing everything else that we need to store about a particular object. </p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor322"/>See also</h2>
			<p>Arrays are complicated and, at the same time, very simple in their syntax. Check out these links<a id="_idIndexMarker967"/> for many more examples:</p>
			<ul>
				<li>https://www.shell-tips.com/bash/arrays/</li>
				<li><a href="https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays">https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays</a></li>
			</ul>
			<h1 id="_idParaDest-316"><a id="_idTextAnchor323"/>Advanced array manipulation</h1>
			<p>Now we have <a id="_idIndexMarker968"/>finished dealing with the basics, we need to add much more to your knowledge of arrays. What we first need to do is to give you some ideas on how to make the arrays you create in your scripts more persistent, so we need to deal with storing and restoring them. </p>
			<p>The reason why this is important is that arrays can be quite large, depending on the script you are creating. Dumping and reusing variables in scripts is easy since we can use the <em class="italic">source</em> to declare variables we stored in a file. Arrays make for more complicated work since they can contain multiple variables, and sometimes we even need to create them from another data source. </p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor324"/>Getting ready</h2>
			<p>The thing with scripts is that they sometimes need to deal with a lot of data. In a lot of cases, we can use files to both store data in and load data from. There are, however, some cases where arrays—especially associative arrays—are a necessity for working with large amounts of data, and then we need to know how to save that data to the disk and reuse it. We are going to show you how to solve those problems and advise you when to do it. </p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor325"/>How to do it…</h2>
			<p>When talking about all of this, we always need an example where a particular feature makes sense. Some of the <strong class="source-inline">bash</strong> features we dealt with were so generic that our examples also <a id="_idIndexMarker969"/>had to be generic. Associative arrays are not like that. Although they can be used for a number of things, some scenarios are so common that you will automatically start to declare an array even before you think how and why you are doing it. </p>
			<p>The most common scenario is saving user settings. </p>
			<p>Any larger script that deals with any task will have to be configurable. We mentioned that when we said that you can include files, and the most common ones are going to be the ones containing variables, storing values for different settings. </p>
			<p>Most of the time, all the settings in a script look something like this: </p>
			<p class="source-code">USER=demo</p>
			<p class="source-code">CMD=testing</p>
			<p class="source-code">HOSTNAME=demounit</p>
			<p>These settings are just an example, but most scripts have a block of these either in a separate file or at the start of the script. </p>
			<p>Notice that all of them have a format of <strong class="source-inline">KEY=VALUE</strong> and look like they are created to be used in an associative array. Having said that, we need to make a point about using any feature of any programming language—do what is best for the performance and clarity of a given solution and don't use a feature just because you <em class="italic">know</em> it is used in a particular situation. </p>
			<p>This is where your experience is required. If a script has a set of settings that never change after we initially set them while loading and saving them from the disk, this makes no sense. The same goes for if a script only has a few variables defined when it starts—there is no point in using arrays here. </p>
			<p>But if a script has more than a few things that change between different script executions, and if you are using them to store some important runtime operations that are needed not only when the script starts but also during its run, arrays may be a solution. </p>
			<p>Our example is going to be a small script that will have a few settings it needs to remember, and <a id="_idIndexMarker970"/>we are going to use arrays to load them from disk, use them, and store them later back to disk. Working on this, we are also going to perform some tasks on a given array to demonstrate how to manipulate pairs in a script. </p>
			<p>But before we do any of that, we need to go through a few advanced examples to show you how some things we previously glanced over work. </p>
			<p>First, we are going to deal with the difference between using <strong class="source-inline">*</strong> and <strong class="source-inline">@</strong> operators to read indices and keys in arrays. We said that for a given array, those two operators are different ways of going through all indices. Here's an example to illustrate this: </p>
			<p class="source-code">demo@ubuntu:~/variable$ SOMEARRAY=(0 1 2 3 4 5)</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${!SOMEARRAY[*]}</p>
			<p class="source-code">0 1 2 3 4 5</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${!SOMEARRAY[@]}</p>
			<p class="source-code">0 1 2 3 4 5</p>
			<p>The same goes for associative arrays: </p>
			<p class="source-code">demo@ubuntu:~/variable$ declare -A PAIRS</p>
			<p class="source-code">demo@ubuntu:~/variable$ PAIRS=(["John"]=12345 ["Luke"]=12344 ["Ivan from work"]=113312 ["Ida"]=11111 ["That guy"]=122222)</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${!PAIRS[@]}</p>
			<p class="source-code">Ivan from work Ida Luke John That guy</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${!PAIRS[*]}</p>
			<p class="source-code">Ivan from work Ida Luke John That guy</p>
			<p>So far, the results are at first glance identical. This is one of those things in <strong class="source-inline">bash</strong> that will sometimes make you pull your hair out in despair because when we use them for loops, there <a id="_idIndexMarker971"/>will be a big difference that we are going to show by creating a small example script: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">declare -A PAIRS</p>
			<p class="source-code">PAIRS=(["John"]=12345 ["Luke"]=12344 ["Ivan from work"] =113312 \</p>
			<p class="source-code">["Ida"]=11111 ["That guy"]=122222)</p>
			<p class="source-code">#now we are going to print keys, once using @ and then using \</p>
			<p class="source-code">#*</p>
			<p class="source-code">echo "for first example we are using @ sign"</p>
			<p class="source-code">for name in "${!PAIRS[@]}"</p>
			<p class="source-code">do</p>
			<p class="source-code">             echo Number: ${PAIRS["$name"]}</p>
			<p class="source-code">             echo Name: "$name"</p>
			<p class="source-code">             echo</p>
			<p class="source-code">done</p>
			<p class="source-code">echo --------------------------</p>
			<p class="source-code">echo "then we are using * sign"</p>
			<p class="source-code">for name in "${!PAIRS[*]}"</p>
			<p class="source-code">do</p>
			<p class="source-code">        echo Number: ${PAIRS["$name"]}</p>
			<p class="source-code">             echo Name: "$name"</p>
			<p class="source-code">             echo</p>
			<p class="source-code">done</p>
			<p>If we run this script and both of those expressions return the same set of values, the output should <a id="_idIndexMarker972"/>be identical. But if we actually run it, we get this: </p>
			<p class="source-code">demo@ubuntu:~/variable$ bash arrayops.sh </p>
			<p class="source-code">for first example we are using @ sign</p>
			<p class="source-code">Number: 113312</p>
			<p class="source-code">Name: Ivan from work</p>
			<p class="source-code">Number: 11111</p>
			<p class="source-code">Name: Ida</p>
			<p class="source-code">Number: 12344</p>
			<p class="source-code">Name: Luke</p>
			<p class="source-code">Number: 12345</p>
			<p class="source-code">Name: John</p>
			<p class="source-code">Number: 122222</p>
			<p class="source-code">Name: That guy</p>
			<p class="source-code">--------------------------</p>
			<p class="source-code">then we are using * sign</p>
			<p class="source-code">Number:</p>
			<p class="source-code">Name: Ivan from work Ida Luke John That guy</p>
			<p>We see that when we use <strong class="source-inline">@</strong>, we get what we expected, but as soon as we replace it with <strong class="source-inline">*</strong>, we can see the keys (or indices) but get no values in return. </p>
			<p>The reason behind this is, as always, the way <strong class="source-inline">bash</strong> works. Using the <strong class="source-inline">@</strong> sign signals to <strong class="source-inline">bash</strong> that we are trying to get each index or key separately. Using the <strong class="source-inline">*</strong> sign, on the other hand, makes <strong class="source-inline">bash</strong> return all the indices or keys as a single string divided by spaces. So, our script in one case reads each element one by one, and the other loop is run only once. Since the value that we are trying to look up is different from any single key value in our array, this one run gets no results. In the end, those two expressions are not identical, but the simple printout is—don't let that fool you. </p>
			<p>Now, we are going to create our master script for manipulating arrays and then add a few elements to it. </p>
			<p>The obvious starting point is to create a file containing our array. There are multiple ways to do that, some more complicated than others, but almost all of them depend on using some loop to go through the array and either read it or write it to a file. </p>
			<p>We are going to do <a id="_idIndexMarker973"/>it the canonical Linux way by using the <strong class="source-inline">declare</strong> statement. If we do the <strong class="source-inline">-p</strong> switch, we are telling it to print a particular variable with both its definition and the values stored in it: </p>
			<p class="source-code">demo@ubuntu:~/variable$ declare -p PAIRS</p>
			<p class="source-code">declare -A PAIRS=(["Ivan from work"]="113312" [Ida]="11111" [Luke]="12344" [John]="12345" ["That guy"]="122222" )</p>
			<p>Obviously, this is great since this is the only thing we need to remember to have everything that is stored in the variable itself. To save it, we just redirect it to a file on disk: </p>
			<p class="source-code">demo@ubuntu:~/variable$ declare -p PAIRS &gt; PAIRS.save</p>
			<p>To show that this worked, we are going to unset the variable and verify it was deleted so that the values only exist in a file:</p>
			<p class="source-code">demo@ubuntu:~/variable$ unset PAIRS</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${!PAIRS[@]}</p>
			<p>Now, let's look at how to reload the script from a disk. Notice that the output of the <strong class="source-inline">declare</strong> statement was an actual <strong class="source-inline">declare</strong> statement defining the variable. If we load it from disk and execute it, everything should be fine: </p>
			<p class="source-code">demo@ubuntu:~/variable$ source PAIRS.save </p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${!PAIRS[@]}</p>
			<p class="source-code">Ivan from work Ida Luke John That guy</p>
			<p>The internet is full of more complicated solutions, but for an array of a reasonable size, this should work great. At the same time, this is easy to read in a script, and the file that contains the data is in a universal format readable by any other <strong class="source-inline">bash</strong> version installed on any system (if it is <strong class="source-inline">bash</strong> 4.0 since that is when these types of arrays were introduced).</p>
			<p>We now know how to read and write an array to disk, but what else can we do with it? In our example, we are going to switch to a regular array to show you some things you can do:</p>
			<p class="source-code">demo@ubuntu:~/variable$ REGULAR=( zero one two three five four \</p>
			<p class="source-code">)</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${REGULAR[@]}</p>
			<p class="source-code">zero one two three five four</p>
			<p>So, we have<a id="_idIndexMarker974"/> created an array and we made an error. Since the array is already in the wrong order, we are going to reshuffle it even more (the <strong class="source-inline">shuf</strong> command randomizes the array): </p>
			<p class="source-code">demo@ubuntu:~/variable$ shuf -e "${REGULAR[@]}"</p>
			<p class="source-code">three</p>
			<p class="source-code">one</p>
			<p class="source-code">zero</p>
			<p class="source-code">five</p>
			<p class="source-code">two</p>
			<p class="source-code">four</p>
			<p>Although you could create your own solution for the randomization of values, using an external command is the simplest solution. </p>
			<p>Shuffling is easy but it is not permanent. What the command is doing is taking our array as its input, shuffling the values, and then printing the result while the original array stays the same. </p>
			<p>We reassigned the array to the result of the command. The main reason we also created another variable and printed it is that we had to show that shuffling happens in real time, and the results are different each time the <strong class="source-inline">shuf</strong> command is started. </p>
			<p>Sorting an array is going to be more of a problem since it requires some sorting mechanism. Either you will create one yourself or you can, with a little care, use the <strong class="source-inline">sort</strong> command already included in <strong class="source-inline">bash</strong>. </p>
			<p>The next thing we are going to do is show you how to work with ranges of indices. We are going to reset our array and then show you some examples. When we declare ranges, in reality, we are using a mechanism built into <strong class="source-inline">bash</strong> that enables us to define a range of numbers. We already used that to create loops and iterators in them, so this will not be<a id="_idIndexMarker975"/> too much of a surprise to you: </p>
			<p class="source-code">demo@ubuntu:~/variable$ REGULAR=( zero one two three four five \</p>
			<p class="source-code">)</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${REGULAR[*]} </p>
			<p class="source-code">zero one two three four five</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${REGULAR[*]:2:3}</p>
			<p class="source-code">two three four</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${REGULAR[*]:0:3}</p>
			<p class="source-code">zero one two</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${REGULAR[*]:0:}</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${REGULAR[*]:0:2}</p>
			<p class="source-code">zero one</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${REGULAR[*]:3}</p>
			<p class="source-code">three four five</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${REGULAR[*]:2}</p>
			<p class="source-code">two three four five</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${REGULAR[*]:2:-2}</p>
			<p class="source-code">bash: -2: substring expression &lt; 0</p>
			<p>We are using standard notation in <strong class="source-inline">bash</strong>. The first number after the variable is the starting index we want to print, and the optional number after it is the number of values we need. Notice that negative numbers do not work here unlike in some other places; we cannot go back from the end of the array this way. </p>
			<p>The next thing we can do is concatenate two arrays. </p>
			<p>Depending on what you want to do, the result of that operation will not get you what you might have been expecting: </p>
			<p class="source-code">demo@ubuntu:~/variable$ ANOTHER=(sixth seventh eighth ninth)</p>
			<p class="source-code">demo@ubuntu:~/variable$ NEW="${REGULAR[*]} ${ANOTHER[*]}"</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${NEW[*]}</p>
			<p class="source-code">zero one two three four five sixth seventh eighth ninth</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${NEW[@]}</p>
			<p class="source-code">zero one two three four five sixth seventh eighth ninth</p>
			<p>Another <a id="_idIndexMarker976"/>operation we can do is count the number of values in an array. We also already did this before, so let's check if our arrays were merged correctly: </p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${#REGULAR[@]}</p>
			<p class="source-code">6</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${#ANOTHER[@]}</p>
			<p class="source-code">4</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${#NEW[@]}</p>
			<p class="source-code">1</p>
			<p>What happened here? </p>
			<p>In our concatenation, we made a huge error. What we wanted to do is create a new array that will hold the values from both arrays. What we did is create a <strong class="source-inline">string</strong> variable that contains one huge string created from all values in the arrays. We need to fix this by using brackets:</p>
			<p class="source-code">demo@ubuntu:~/variable$ NEW=(${REGULAR[*]} ${ANOTHER[*]})</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${#NEW[@]}</p>
			<p class="source-code">10</p>
			<p class="source-code">demo@ubuntu:~/variable$ NEW=(${REGULAR[@]} ${ANOTHER[@]})</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${#NEW[@]}</p>
			<p class="source-code">10</p>
			<p class="source-code">demo@ubuntu:~/variable$ declare -p NEW</p>
			<p class="source-code">declare -a NEW=([0]="zero" [1]="one" [2]="two" [3]="three" [4]="four" [5]="five" [6]="sixth" [7]="seventh" [8]="eighth" [9]="ninth")</p>
			<p>So, we created our array and checked how many values it holds. Since we wanted to be completely sure, we used the <strong class="source-inline">declare</strong> statement to show all the index/value pairs. </p>
			<p>Before we move on, we need to make a small mistake by using a pair of quotation marks: </p>
			<p class="source-code">demo@ubuntu:~/variable$ NEW=("${REGULAR[@]} ${ANOTHER[@]}")</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${#NEW[@]}</p>
			<p class="source-code">9</p>
			<p class="source-code">demo@ubuntu:~/variable$ declare -p NEW</p>
			<p class="source-code">declare -a NEW=([0]="zero" [1]="one" [2]="two" [3]="three" [4]="four" [5]="five sixth" [6]="seventh" [7]="eighth" [8]="ninth")</p>
			<p>What we did is<a id="_idIndexMarker977"/> create something extremely similar to our first example, but at the same time, completely wrong. One of the values is a combination of two strings, not two separate values. Try all different combinations of quotation marks to try to see how they work and if using either <strong class="source-inline">@</strong> or <strong class="source-inline">*</strong> makes a difference to the resulting array.</p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor326"/>How it works…</h2>
			<p>We have dealt with different things you can do to an array in detail. What's left is to see what else is there to know about arrays and how to check if an array contains a value. The length—or, more precisely, the number of values is something we just looked at, and if you need to know if an array already exists, you should check if the length of it is longer than <strong class="source-inline">0</strong>. This will tell you that either the array you are testing is not defined or it contains no elements. If you explicitly want to check if the variable is defined, use the <strong class="source-inline">declare</strong> statement and count the results. In our example, we have a variable called <strong class="source-inline">TEST1</strong> and an undefined name, <strong class="source-inline">TEST2</strong>: </p>
			<p class="source-code">demo@ubuntu:~/variable$ TEST1=()</p>
			<p class="source-code">demo@ubuntu:~/variable$ declare -p TEST1</p>
			<p class="source-code">declare -a TEST1=()</p>
			<p class="source-code">demo@ubuntu:~/variable$ declare -p TEST2</p>
			<p class="source-code">bash: declare: TEST2: not found</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${#TEST1[@]}</p>
			<p class="source-code">0</p>
			<p class="source-code">demo@ubuntu:~/variable$ echo ${#TEST2[@]}</p>
			<p class="source-code">0</p>
			<p>For most intents <a id="_idIndexMarker978"/>and purposes, just checking for the value count is enough, but sometimes you need to know if a variable is even defined.</p>
			<p>Another common thing to do is try to find if there is a particular value inside an array. You can do this by creating your own loop to check for the values, or you can use the built-in test that <strong class="source-inline">bash</strong> already has. For example, you could do something like this: </p>
			<p class="source-code">demo@ubuntu:~/variable$ [[ ${REGULAR[*]} =~ "one" ]] &amp;&amp; echo \</p>
			<p class="source-code">yes || echo no</p>
			<p class="source-code">yes</p>
			<p class="source-code">demo@ubuntu:~/variable$ [[ ${REGULAR[*]} =~ "something" ]] &amp;&amp; \</p>
			<p class="source-code">echo yes || echo no</p>
			<p class="source-code">no</p>
			<p>Once again, we used a one-line logical expression to quickly see the result. </p>
			<p>Now, here's a small script that will show some of the things we learned in this recipe: </p>
			<p class="source-code">        #!/bin/bash</p>
			<p class="source-code">        #check if<a id="_idIndexMarker979"/> settings exist</p>
			<p class="source-code">                   function checkfile {</p>
			<p class="source-code">               if [ -f setting.list ] </p>
			<p class="source-code">                          then</p>
			<p class="source-code">                                         return 0</p>
			<p class="source-code">                          else.</p>
			<p class="source-code">                                      return 1</p>
			<p class="source-code">                                       fi</p>
			<p class="source-code">}</p>
			<p class="source-code">function assign_settings {</p>
			<p class="source-code">             echo assigning settings</p>
			<p class="source-code">             SETTINGS=(["USER"]=John ["LOCALDIR"]=$PWD \</p>
			<p class="source-code">["HOSTNAME"]=hostname)</p>
			<p class="source-code">                 </p>
			<p class="source-code">}</p>
			<p class="source-code">declare -A SETTINGS</p>
			<p class="source-code">SETTINGS=()</p>
			<p class="source-code">if checkfile</p>
			<p class="source-code">then </p>
			<p class="source-code">             source setting.list</p>
			<p class="source-code">else </p>
			<p class="source-code">             assign_settings</p>
			<p class="source-code">fi</p>
			<p class="source-code">echo Settings are:</p>
			<p class="source-code">for name in "${!SETTINGS[@]}"</p>
			<p class="source-code">do</p>
			<p class="source-code">             echo "$name"=${SETTINGS["$name"]}</p>
			<p class="source-code">done</p>
			<p class="source-code">declare -p SETTINGS &gt; setting.list</p>
			<p>We already know most of this, but we will go through the script. </p>
			<p>The first function in that script tests if a file exists. We could have done the same thing by using the <strong class="source-inline">if</strong> statement later in the code, but we wanted to remind you how to use functions and logical checks. The function returns <strong class="source-inline">0</strong> if the file is there, and <strong class="source-inline">1</strong> if it is not. </p>
			<p>Next, we have the function we called <strong class="source-inline">assign_settings</strong> that is used if the file is not found. What it does is simply create a new associative array that contains some data. </p>
			<p>Then, we are in<a id="_idIndexMarker980"/> the main body of code in our script, and first, we are declaring our arrays since they cannot be declared implicitly. Then, we decide if we have our file saved and if we should load our array from there or whether we need to reassign the defaults. </p>
			<p>After that, we are just printing out the values and then saving them to disk. </p>
			<p>In a normal script, this would be a part of the script that does the importing and saving of important settings. The rest of the script would be right before the line that saves the variables. </p>
			<p>We are going to start the script two times in a row. The result should be that it will detect we have no configuration and make it for us: </p>
			<p class="source-code">demo@ubuntu:~/variable$ bash settings.sh </p>
			<p class="source-code">assigning settings</p>
			<p class="source-code">Settings are:</p>
			<p class="source-code">USER=John</p>
			<p class="source-code">HOSTNAME=hostname</p>
			<p class="source-code">LOCALDIR=/home/demo/variable</p>
			<p class="source-code">demo@ubuntu:~/variable$ bash settings.sh </p>
			<p class="source-code">Settings are:</p>
			<p class="source-code">USER=John</p>
			<p class="source-code">HOSTNAME=hostname</p>
			<p class="source-code">LOCALDIR=/home/demo/variable</p>
			<p>When you are doing something such as this, we must also warn you that there may be big problems with local and global variables. Be very careful if you are declaring any variable that is supposed to be global in a function or—even worse—if you are sourcing it from a function since the scope will limit your values from propagating throughout the script. </p>
			<p>This is where <a id="_idIndexMarker981"/>we will leave arrays and go on to more interesting stuff—starting to create some interfaces.</p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor327"/>See also</h2>
			<ul>
				<li><em class="italic">How to use bash array in a shell script</em>: <a href="https://linuxconfig.org/how-to-use-arrays-in-bash-script">https://linuxconfig.org/how-to-use-arrays-in-bash-script</a></li>
				<li><em class="italic">The Ultimate Bash Array Tutorial with 15 Examples</em>: <a href="https://www.thegeekstuff.com/2010/06/bash-array-tutorial/">https://www.thegeekstuff.com/2010/06/bash-array-tutorial/</a></li>
			</ul>
		</div>
	</div></body></html>