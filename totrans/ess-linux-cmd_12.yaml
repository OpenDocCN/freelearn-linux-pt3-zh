- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Exploring Linux Security
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Linux 安全
- en: In the ever-evolving landscape of information technology, the security of systems
    and data stands as an unwavering priority. As the backbone of countless infrastructures,
    Linux operating systems have solidified their presence in various domains, from
    servers to embedded devices. Within this realm, this chapter embarks on a comprehensive
    journey, delving into the realm of Linux security. This exploration isn’t just
    an exercise in fortifying digital fortresses; it’s a pivotal pursuit that safeguards
    sensitive information, guarantees operational integrity, and upholds user trust.
    In the contemporary digital era, where interconnectedness dominates, the importance
    of Linux security cannot be overstated. Organizations of all sizes rely on Linux-based
    systems to manage databases, power websites, and orchestrate complex networks.
    These systems contain troves of sensitive information, from proprietary algorithms
    to personal user data. Ensuring the security of this data is imperative not only
    to maintain the competitive edge but also to safeguard the reputation of the entity
    in question. Breaches in security can lead to dire consequences, including financial
    losses, legal ramifications, and the erosion of customer confidence.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在信息技术不断发展的背景下，系统和数据的安全始终是一个坚定的优先事项。作为无数基础设施的支柱，Linux 操作系统在各个领域巩固了其存在，从服务器到嵌入式设备。在这一领域，本章将展开一场全面的旅程，深入探讨
    Linux 安全。此次探索不仅仅是强化数字堡垒的练习，它是保护敏感信息、保证操作完整性、维护用户信任的关键追求。在当今互联互通的数字时代，Linux 安全的重要性不可过分强调。各类组织依赖基于
    Linux 的系统来管理数据库、驱动网站以及协调复杂的网络。这些系统包含大量敏感信息，从专有算法到个人用户数据。确保这些数据的安全不仅是保持竞争优势的必要条件，也是保护相关实体声誉的关键。安全漏洞可能导致严重后果，包括财务损失、法律后果和客户信任的丧失。
- en: The purpose of this exploration transcends the realm of routine system administration.
    It’s a proactive stance against potential threats that could exploit vulnerabilities
    and wreak havoc. Linux administrators, armed with a profound understanding of
    security mechanisms, can erect potent defenses against a multitude of cyber threats,
    from malware and ransomware to data breaches and denial-of-service attacks. By
    comprehending the intricacies of Linux security, administrators can effectively
    mitigate risks, respond swiftly to emerging threats, and prevent security incidents
    that could otherwise cripple operations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本次探索的目的超越了常规系统管理的范畴。这是针对可能利用漏洞并造成破坏的潜在威胁采取的主动立场。掌握深厚安全机制的 Linux 管理员可以建立强大的防御体系，抵御各种网络威胁，从恶意软件、勒索病毒到数据泄露和拒绝服务攻击。通过理解
    Linux 安全的复杂性，管理员能够有效减轻风险、迅速应对新兴威胁，并防止可能摧毁操作的安全事件。
- en: Linux security isn’t just a technical checklist – it’s an integral component
    of responsible administration. First and foremost, Linux is an open source ecosystem,
    meaning that its source code is publicly accessible. While this fosters collaboration
    and rapid development, it also exposes the system to potential scrutiny and exploitation.
    Hence, understanding Linux security is paramount to identify and rectify vulnerabilities
    that might otherwise go unnoticed. Moreover, the diverse applications of Linux,
    from personal computing to corporate servers, demand a nuanced approach to security.
    Administrators must navigate this spectrum while factoring in the unique security
    requirements of each scenario. This necessitates a deep comprehension of Linux
    security mechanisms, such as access controls, encryption, authentication protocols,
    and intrusion detection systems. By harnessing these tools effectively, administrators
    can customize security strategies that align with specific needs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 安全不仅仅是一个技术清单——它是负责任管理的一个核心组成部分。首先，Linux 是一个开源生态系统，这意味着其源代码是公开可获取的。虽然这促进了协作和快速开发，但也使系统暴露于潜在的审查和利用之中。因此，了解
    Linux 安全至关重要，以便发现并修复可能被忽视的漏洞。此外，Linux 的多样化应用，从个人计算到企业服务器，要求对安全采取细致入微的方法。管理员必须在考虑到每种场景的独特安全需求的同时，穿越这一广泛的安全领域。这需要深入理解
    Linux 安全机制，如访问控制、加密、身份验证协议和入侵检测系统。通过有效利用这些工具，管理员可以定制符合特定需求的安全策略。
- en: In essence, this chapter serves as a compass in the labyrinth of Linux administration.
    It equips administrators with the knowledge and strategies needed to uphold the
    resilience and integrity of Linux-based systems, fostering a digital landscape
    where security stands as an unwavering pillar of operational success.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，本章作为 Linux 管理的指南针，帮助管理员掌握必要的知识和策略，维护基于 Linux 的系统的韧性和完整性，构建一个安全作为运营成功不动摇支柱的数字环境。
- en: 'In this chapter, we will delve into the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨以下主要内容：
- en: Utilizing enforcing and permissive modes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用强制模式和宽容模式
- en: Enabling or disabling SELinux Boolean values
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用或禁用 SELinux 布尔值
- en: Locking user accounts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定用户账户
- en: Securing SSH
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSH 安全配置
- en: Utilizing enforcing and permissive modes
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用强制模式和宽容模式
- en: In the realm of access control and security management, the concepts of **enforcing**
    and **permissive** modes assume crucial roles, particularly within the context
    of operating systems such as Linux. These modes pertain to the behavior of security
    mechanisms, such as **Mandatory Access Control** (**MAC**) frameworks. For instance,
    RHEL and Fedora Linux use **Security-Enhanced Linux** (**SELinux**) as their MAC
    framework, while Ubuntu employs AppArmor for similar purposes. Enforcing mode
    signifies a state where strict adherence to security policies is upheld, disallowing
    any actions that contravene these rules. On the other hand, permissive mode adopts
    a more lenient stance, allowing actions that would typically be denied under “enforcing.”
    The purpose of these modes lies in striking a balance between maintaining system
    integrity and facilitating essential operations without undue hindrance. These
    modes are essential for system administrators aiming to enhance system security
    while ensuring the smooth operation of their systems. By utilizing enforcing mode,
    administrators can ensure that all actions, whether initiated by users or applications,
    adhere rigidly to established security policies. This prevents unauthorized access,
    reduces the potential attack surface, and mitigates the risks associated with
    breaches, malware infiltration, and unauthorized data manipulation. Conversely,
    permissive mode proves invaluable in scenarios where the immediate implementation
    of strict security measures might disrupt critical operations or lead to unintended
    consequences. Administrators can temporarily switch to the permissive mode to
    identify potential issues that would arise under enforcing mode. This approach
    aids in fine-tuning security policies without causing system-wide disruptions.
    Additionally, permissive mode allows administrators to understand the scope and
    impact of security policy changes before fully committing to them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问控制和安全管理领域，**强制**模式和**宽容**模式起着至关重要的作用，特别是在像 Linux 这样的操作系统中。这些模式与安全机制的行为有关，例如
    **强制访问控制**（**MAC**）框架。例如，RHEL 和 Fedora Linux 使用 **增强安全 Linux**（**SELinux**）作为其
    MAC 框架，而 Ubuntu 则使用 AppArmor 达到类似目的。强制模式表示一种严格遵守安全策略的状态，禁止任何违反这些规则的操作。另一方面，宽容模式采取更加宽松的态度，允许那些在“强制”模式下通常会被拒绝的操作。这些模式的目的是在保持系统完整性和促进必要操作之间找到平衡，避免不必要的阻碍。这些模式对于系统管理员来说至关重要，管理员可以通过它们增强系统安全性，同时确保系统平稳运行。通过使用强制模式，管理员可以确保所有操作，无论是用户还是应用程序发起的，都严格遵守既定的安全策略。这可以防止未经授权的访问，减少潜在的攻击面，并降低与漏洞、恶意软件渗透和未经授权的数据操作相关的风险。相反，宽容模式在需要严格安全措施立即实施可能会干扰关键操作或导致意外后果的场景中非常有价值。管理员可以暂时切换到宽容模式，以识别在强制模式下可能出现的问题。这种方法有助于在不造成系统广泛中断的情况下微调安全策略。此外，宽容模式允许管理员在完全执行安全策略更改之前，了解其范围和影响。
- en: A short introduction to Linux hardening and the role of SELinux’s enforcing
    and passive modes
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简要介绍 Linux 加固和 SELinux 强制模式与宽容模式的作用
- en: In the ever-evolving landscape of cybersecurity, the term **Linux hardening**
    emerges as a critical practice to enhance the security posture of Linux-based
    systems. Linux hardening refers to the systematic process of fortifying the security
    of a Linux operating system by minimizing vulnerabilities, reducing attack surfaces,
    and implementing robust defense mechanisms. At its core, Linux hardening seeks
    to create an environment that withstands a broad spectrum of threats, ranging
    from cyberattacks to unauthorized data breaches. In this intricate dance between
    technology and security, the roles of SELinux’s enforcing and permissive modes
    stand out as pivotal players, shaping the defense strategies adopted by system
    administrators.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在不断变化的网络安全领域，**Linux 加固**一词成为了一项重要的实践，用于提高基于 Linux 的系统的安全性。Linux 加固指的是通过最小化漏洞、减少攻击面并实施强有力的防御机制，系统化地增强
    Linux 操作系统的安全性。在其核心，Linux 加固旨在创建一个能够抵御广泛威胁的环境，从网络攻击到未经授权的数据泄露。在技术与安全的精妙配合中，SELinux
    的强制模式和宽容模式扮演着重要角色，塑造了系统管理员采用的防御策略。
- en: The role of enforcing mode
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制模式的角色
- en: 'In the realm of MAC, SELinux stands as a pioneering framework that enforces
    fine-grained security policies within a Linux system. SELinux’s enforcing mode
    assumes a role akin to an unyielding guardian, allowing only actions that align
    with meticulously defined security rules. When operating in enforcing mode, SELinux
    rigidly enforces access controls and security contexts, thereby confining potentially
    malicious actions and reducing the likelihood of unauthorized intrusion. This
    mode ensures that even if an attacker gains access, their ability to maneuver
    and exploit vulnerabilities is severely curtailed, thereby enhancing the overall
    resilience of the system to enable enforcing mode:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MAC（强制访问控制）领域，SELinux 是一个开创性的框架，在 Linux 系统内强制执行细粒度的安全策略。SELinux 的强制模式扮演着类似于坚定守护者的角色，只允许与精确定义的安全规则一致的操作。当在强制模式下运行时，SELinux
    会严格执行访问控制和安全上下文，从而限制潜在的恶意行为，降低未经授权入侵的可能性。此模式确保即使攻击者获得了访问权限，他们的活动和利用漏洞的能力也会受到严重限制，从而增强系统的整体韧性。要启用强制模式：
- en: '![Figure 12.1 – SELinux’s enforcing mode](img/B18212_12_1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – SELinux 的强制模式](img/B18212_12_1.jpg)'
- en: Figure 12.1 – SELinux’s enforcing mode
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – SELinux 的强制模式
- en: 'Let’s take a closer look:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解：
- en: The `setenforce` command is used to modify SELinux’s enforcing mode. By running
    `sudo setenforce 1`, you are instructing SELinux to switch to enforcing mode.
    In this mode, SELinux will strictly enforce the defined security policies, denying
    actions that violate those policies.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setenforce` 命令用于修改 SELinux 的强制模式。通过运行 `sudo setenforce 1`，你指示 SELinux 切换到强制模式。在此模式下，SELinux
    将严格执行定义的安全策略，拒绝违反这些策略的操作。'
- en: To verify that SELinux is in enforcing mode, you can use the `getenforce` command.
    The `getenforce` command provides a simple way to query the status of SELinux
    and determine whether it’s currently operating in enforcing mode or permissive
    mode.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要验证 SELinux 是否处于强制模式，可以使用 `getenforce` 命令。`getenforce` 命令提供了一种简单的方法来查询 SELinux
    的状态，并确定它是处于强制模式还是宽容模式。
- en: The role of permissive mode
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宽容模式的角色
- en: 'In contrast, SELinux’s permissive mode serves as an insightful observer in
    the security landscape. When switched to permissive mode, SELinux refrains from
    blocking actions that breach security policies, but it actively logs these incidents.
    This mode serves as an essential tool for system administrators seeking to fine-tune
    their security policies without abruptly disrupting operations. By analyzing the
    logs generated in permissive mode, administrators can identify potential issues
    that would arise if the system were operating in enforcing mode. This invaluable
    feedback loop empowers administrators to iteratively refine security policies,
    ensuring they strike an optimal balance between stringent security and operational
    functionality to enable SELinux’s permissive mode:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，SELinux 的宽容模式则在安全领域中充当了一个具有洞察力的观察者。当切换到宽容模式时，SELinux 不会阻止违反安全策略的操作，但会积极记录这些事件。此模式为系统管理员提供了一个重要工具，帮助他们在不突然中断操作的情况下微调安全策略。通过分析在宽容模式下生成的日志，管理员可以识别如果系统处于强制模式时可能出现的问题。这一宝贵的反馈循环使管理员能够反复优化安全策略，确保在严格的安全性和操作功能之间找到最佳平衡，从而启用
    SELinux 的宽容模式：
- en: '![Figure 12.2 – SELinux’s permissive mode](img/B18212_12_2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – SELinux 的宽容模式](img/B18212_12_2.jpg)'
- en: Figure 12.2 – SELinux’s permissive mode
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – SELinux 的宽松模式
- en: 'Let’s take a closer look:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看：
- en: This time, by running `sudo setenforce 0`, you are instructing SELinux to switch
    to permissive mode. In permissive mode, SELinux does not actively block actions
    that violate security policies. Instead, it logs these actions for later analysis.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一次，通过运行 `sudo setenforce 0`，您指示 SELinux 切换到宽松模式。在宽松模式下，SELinux 不会主动阻止违反安全策略的操作，而是记录这些操作以便后续分析。
- en: To verify that SELinux is in enforcing mode, you can use the `getenforce` command
    to verify whether it’s switched to permissive mode.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要验证 SELinux 是否处于强制模式，可以使用 `getenforce` 命令来检查它是否已经切换到宽松模式。
- en: To summarize, the dynamic interplay of SELinux’s enforcing and permissive modes
    exemplifies the delicate art of Linux hardening. These modes offer administrators
    a granular approach to security, allowing them to choose between airtight enforcement
    and pragmatic observation. By judiciously deploying these modes, administrators
    can navigate the labyrinthine world of Linux security, creating fortified environments
    that confidently withstand the evolving landscape of cyber threats.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，SELinux 的强制模式和宽松模式之间的动态互动展示了 Linux 强化的微妙艺术。这些模式为管理员提供了细致的安全管理方式，使他们可以在严格执行和务实观察之间做出选择。通过谨慎地部署这些模式，管理员能够在错综复杂的
    Linux 安全世界中游刃有余，创建能够自信应对不断变化的网络威胁的强化环境。
- en: Enabling or disabling SELinux Boolean values
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用或禁用 SELinux 布尔值
- en: In the intricate landscape of Linux security, SELinux emerges as a dynamic framework
    that empowers administrators to finely tune access controls and enforce security
    policies. At the heart of SELinux’s configurational arsenal lie Boolean values,
    encapsulating binary settings that enable or disable specific security features.
    These Boolean values serve as cryptographic keys that can unlock a multitude of
    security configurations, allowing administrators to sculpt the behavior of the
    system with precision. From enabling network connectivity for web servers to permitting
    specific user interactions, Boolean values offer a nuanced approach to tailoring
    security protocols, ensuring that the system operates within the desired security
    boundaries. The importance of enabling or disabling SELinux Boolean values transcends
    the realm of mere customization. It plays a pivotal role in aligning system security
    with the ever-evolving operational demands of the digital landscape. A tangible
    example of their significance is found in web server scenarios. When deploying
    a web application, certain functionalities might require network connectivity,
    such as sending emails or accessing remote databases. By manipulating Boolean
    values, administrators can enable specific network-related permissions for the
    web server process while keeping other potentially vulnerable actions locked down.
    This granular control not only mitigates risks but also ensures that security
    is an enabler, not an inhibitor, of functionality.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的 Linux 安全环境中，SELinux 作为一个动态框架，使管理员能够精细地调整访问控制并执行安全策略。SELinux 配置工具的核心是布尔值，它封装了能够启用或禁用特定安全功能的二进制设置。这些布尔值就像是加密密钥，能够解锁各种安全配置，允许管理员精确地塑造系统行为。从启用网络连接以支持
    Web 服务器到允许特定用户交互，布尔值为定制安全协议提供了细致的方式，确保系统在所需的安全边界内运行。启用或禁用 SELinux 布尔值的重要性超越了单纯的定制化，它在将系统安全与数字环境日益变化的操作需求对接中起着关键作用。一个实际的例子可以在
    Web 服务器场景中找到。在部署 Web 应用时，某些功能可能需要网络连接，比如发送电子邮件或访问远程数据库。通过操作布尔值，管理员可以为 Web 服务器进程启用特定的网络相关权限，同时将其他潜在的易受攻击操作锁定。这种细致的控制不仅可以降低风险，还确保了安全性是功能实现的推动力，而非阻碍。
- en: 'The use of SELinux Boolean values extends to scenarios where system administrators
    need to balance security and usability. For instance, when introducing a new software
    package, it might demand unconventional access rights to function optimally. Rather
    than compromising the overall system security, administrators can modify Boolean
    values to grant temporary permissions. This empowers administrators to evaluate
    the software’s behavior in a controlled environment while preserving the integrity
    of the larger system. Moreover, the ability to enable or disable specific Boolean
    values facilitates the implementation of security policies that are congruent
    with organizational policies and regulatory requirements. This not only enhances
    security posture but also streamlines compliance efforts by allowing administrators
    to cater to unique operational needs. Now, let’s take a look at the current values
    for all SELinux Boolean settings and understand the output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux布尔值的使用扩展到系统管理员需要平衡安全性和可用性的场景。例如，在引入新的软件包时，它可能需要不寻常的访问权限才能发挥最佳功能。管理员可以修改布尔值，授予临时权限，而不是妥协整个系统的安全性。这使得管理员能够在受控环境中评估软件的行为，同时保持大系统的完整性。此外，启用或禁用特定布尔值的能力有助于实施符合组织政策和法规要求的安全策略。这不仅增强了安全性，还通过允许管理员满足独特的操作需求，简化了合规工作。现在，让我们看一下所有SELinux布尔设置的当前值，并了解输出：
- en: '![Figure 12.3 – Output of current Boolean values](img/B18212_12_3.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 当前布尔值输出](img/B18212_12_3.jpg)'
- en: Figure 12.3 – Output of current Boolean values
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 当前布尔值输出
- en: 'The provided outputs are the results of running the `getsebool -a` command.
    This command is used to display the current values of all SELinux Boolean settings.
    SELinux Boolean values are binary settings that determine whether a specific security
    feature or permission is enabled (on) or disabled (off). These Boolean values
    allow administrators to finely control the behavior and security policies enforced
    by SELinux. Let’s break down the output and explain each line:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的输出是运行`getsebool -a`命令的结果。此命令用于显示所有SELinux布尔设置的当前值。SELinux布尔值是二进制设置，决定是否启用（on）或禁用（off）特定的安全功能或权限。这些布尔值允许管理员精细控制SELinux强制执行的行为和安全策略。让我们分解输出并解释每一行：
- en: '`abrt_anon_write --> off`: This indicates that the SELinux Boolean value for
    allowing the **Automatic Bug Reporting Tool** (**ABRT**) to write to anonymous
    memory is currently disabled.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abrt_anon_write --> off`：这表示允许**自动错误报告工具**（**ABRT**）写入匿名内存的SELinux布尔值当前已禁用。'
- en: '`abrt_handle_event --> off`: This Boolean value controls whether ABRT can handle
    events is disabled. ABRT handles system events such as crashes or abnormal terminations.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abrt_handle_event --> off`：此布尔值控制是否允许ABRT处理事件，当前已禁用。ABRT处理系统事件，如崩溃或异常终止。'
- en: '`abrt_upload_watch_anon_write --> on`: This means that the Boolean value that
    allows ABRT to watch for uploads with anonymous write access is enabled.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abrt_upload_watch_anon_write --> on`：这意味着允许ABRT监视具有匿名写入访问权限的上传的布尔值已启用。'
- en: '`antivirus_can_scan_system --> off`: This states that the Boolean value that
    permits antivirus software to scan the entire system is currently disabled.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`antivirus_can_scan_system --> off`：这表示允许杀毒软件扫描整个系统的布尔值当前已禁用。'
- en: '`antivirus_use_jit --> off`: The Boolean value controlling whether antivirus
    software can use **Just-In-Time** (**JIT**) scanning is disabled.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`antivirus_use_jit --> off`：控制是否允许杀毒软件使用**即时扫描**（**JIT**）的布尔值已禁用。'
- en: '`auditadm_exec_content --> on`: This indicates that the Boolean value allowing
    the `auditadm` user to execute content is enabled.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auditadm_exec_content --> on`：这表示允许`auditadm`用户执行内容的布尔值已启用。'
- en: '`authlogin_nsswitch_use_ldap --> off`: The Boolean value that determines whether
    the `authlogin` program should use the **Network Security Services** (**NSS**)
    LDAP module is disabled.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authlogin_nsswitch_use_ldap --> off`：决定`authlogin`程序是否应使用**网络安全服务**（**NSS**）LDAP模块的布尔值已禁用。'
- en: '`authlogin_radius --> off`: The Boolean value that controls whether the `authlogin`
    program can use the `radius` protocol for authentication is disabled.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authlogin_radius --> off`：控制`authlogin`程序是否可以使用`radius`协议进行身份验证的布尔值已禁用。'
- en: '`authlogin_yubikey --> off`: This means that the Boolean value permitting the
    `authlogin` program to use YubiKey for authentication is disabled.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authlogin_yubikey --> off`：这意味着禁止`authlogin`程序使用YubiKey进行身份验证的布尔值已禁用。'
- en: '`awstats_purge_apache_log_files --> off`: The Boolean value that decides whether
    `awstats` should be allowed to purge Apache log files is disabled.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awstats_purge_apache_log_files --> off`：决定是否允许 `awstats` 清除 Apache 日志文件的布尔值已被禁用。'
- en: Each of these lines represents a specific SELinux Boolean value and its current
    status. The value next to the arrow (that is, `on` or `off`) indicates whether
    the Boolean is enabled or disabled. These Boolean values allow system administrators
    to tailor the security policies of their systems to match their specific operational
    requirements while maintaining a robust security posture.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都代表一个特定的 SELinux 布尔值及其当前状态。箭头旁边的值（即 `on` 或 `off`）表示该布尔值是启用还是禁用。这些布尔值允许系统管理员根据具体的操作需求调整系统的安全策略，同时保持系统的强大安全性。
- en: Searching for a Boolean and getting its information
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索布尔值并获取其信息
- en: 'Follow these steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'If you’re not sure about the exact name of a Boolean but want to search for
    it, you can use the `semanage boolean -``l` command:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您不确定布尔值的确切名称，但想要搜索它，可以使用 `semanage boolean -l` 命令：
- en: '![Figure 12.4 – Searching for Booleans](img/B18212_12_4.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – 搜索布尔值](img/B18212_12_4.jpg)'
- en: Figure 12.4 – Searching for Booleans
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – 搜索布尔值
- en: 'To check the status of a specific SELinux Boolean, use the `getsebool` command
    followed by the name of the Boolean. For example, to check its status, you can
    run the following command:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查特定 SELinux 布尔值的状态，请使用 `getsebool` 命令，并输入布尔值的名称。例如，要检查其状态，您可以运行以下命令：
- en: '![Figure 12.5 – Checking a specific Boolean’s status](img/B18212_12_5.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – 检查特定布尔值的状态](img/B18212_12_5.jpg)'
- en: Figure 12.5 – Checking a specific Boolean’s status
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 检查特定布尔值的状态
- en: 'Now, let’s run a command to get information about a Boolean:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行一个命令来获取布尔值的信息：
- en: '![Figure 12.6 – Getting information about a Boolean](img/B18212_12_6.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6 – 获取布尔值的信息](img/B18212_12_6.jpg)'
- en: Figure 12.6 – Getting information about a Boolean
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 获取布尔值的信息
- en: The preceding command searches through the list of SELinux Booleans, finds the
    one named `xguest_connect_network`, and displays its current status as `on`, indicating
    that network connections are allowed for the `xguest` user or process. The comment
    provides additional context about why this particular Boolean exists and what
    it controls.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令会在 SELinux 布尔值列表中进行搜索，找到名为 `xguest_connect_network` 的布尔值，并显示其当前状态为 `on`，表示允许
    `xguest` 用户或进程进行网络连接。注释提供了关于该布尔值存在原因以及它所控制内容的额外背景信息。
- en: Now, let’s enable and disable a Boolean value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启用并禁用一个布尔值。
- en: Enabling a SELinux Boolean value
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用 SELinux 布尔值
- en: 'To enable a SELinux Boolean value, you can use the `setsebool` command with
    the `-P` option (which makes the change permanent), followed by the name of the
    Boolean and `1` to indicate `on`. For instance, if you want to enable the `xguest_use_bluetooth`
    Boolean, you can run the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 SELinux 布尔值，可以使用 `setsebool` 命令并加上 `-P` 选项（该选项使更改永久），然后输入布尔值的名称和 `1` 表示启用。例如，如果您想启用
    `xguest_use_bluetooth` 布尔值，可以运行以下代码：
- en: '![Figure 12.7 – Enabling Boolean values](img/B18212_12_7.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – 启用布尔值](img/B18212_12_7.jpg)'
- en: Figure 12.7 – Enabling Boolean values
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 启用布尔值
- en: After executing this command, we used the `semanage` command to get information
    about the changes that were made. This command sets the `xguest_use_bluetooth`
    Boolean to `on` and makes the change permanent across system reboots.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，我们使用 `semanage` 命令获取有关所做更改的信息。此命令将 `xguest_use_bluetooth` 布尔值设置为 `on`，并使该更改在系统重启后保持永久。
- en: Disabling a SELinux Boolean value
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用 SELinux 布尔值
- en: 'To disable an SELinux Boolean value, use the `setsebool` command with the `-P`
    option, followed by the name of the Boolean and `0` to indicate `off`. For example,
    to disable the `mount_anyfile` boolean, follow these steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用 SELinux 布尔值，请使用 `setsebool` 命令并加上 `-P` 选项，接着输入布尔值的名称和 `0` 表示禁用。例如，要禁用 `mount_anyfile`
    布尔值，请按以下步骤操作：
- en: 'Query the current state:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询当前状态：
- en: '`semanage boolean -l | grep mount_anyfile`: This command lists all SELinux
    Boolean values and filters the output using `grep` to find the line containing
    `mount_anyfile`. This line shows that the `mount_anyfile` Boolean is currently
    enabled, as indicated by (`on, on`). Additionally, it provides a description,
    `Allow mount to anyfile`, which explains the purpose of this Boolean.'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`semanage boolean -l | grep mount_anyfile`：此命令列出所有SELinux布尔值，并使用`grep`过滤输出，查找包含`mount_anyfile`的行。该行显示`mount_anyfile`布尔值当前已启用，如（`on,
    on`）所示。此外，它还提供了描述`Allow mount to anyfile`，解释了此布尔值的目的。'
- en: 'Disable the Boolean:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用布尔值：
- en: '`setsebool -P mount_anyfile 0`: This command uses `setsebool` to change the
    status of the `mount_anyfile` Boolean. The `-P` flag makes this change permanent
    (persisting across reboots), and `0` signifies `off`. After running this command,
    SELinux is configured to disallow the `mount` command to mount any file as a filesystem.'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`setsebool -P mount_anyfile 0`：此命令使用`setsebool`来更改`mount_anyfile`布尔值的状态。`-P`标志使此更改永久生效（即使在重启后也能保持），`0`表示“关闭”。运行此命令后，SELinux被配置为禁止`mount`命令将任何文件挂载为文件系统。'
- en: 'Verify the change:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证更改：
- en: '`semanage boolean -l | grep mount_anyfile`: This command is used to query the
    status of the `mount_anyfile` Boolean after it has been modified. Now, it shows
    (`off, off`) for this Boolean, confirming that it has been disabled. The description
    remains the same, indicating that the `mount` command is not allowed to mount
    any file as a filesystem:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`semanage boolean -l | grep mount_anyfile`：此命令用于查询在修改后`mount_anyfile`布尔值的状态。现在，它显示为（`off,
    off`），确认该布尔值已被禁用。描述保持不变，表明`mount`命令不允许将任何文件挂载为文件系统：'
- en: '![Figure 12.8 – Disabling Boolean values](img/B18212_12_8.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8 – 禁用布尔值](img/B18212_12_8.jpg)'
- en: Figure 12.8 – Disabling Boolean values
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – 禁用布尔值
- en: This command sets the `mount_anyfile` Boolean to `off` and ensures that the
    change persists after the system reboots.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将`mount_anyfile`布尔值设置为`off`，并确保此更改在系统重启后依然有效。
- en: In summary, the command checks the status of the `mount_anyfile` SELinux Boolean,
    disables it, and verifies that the change took effect. SELinux Booleans allow
    administrators to finely control access and permissions within the system, and
    modifying them should be done with a clear understanding of the security implications
    for the system’s operation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，命令检查了`mount_anyfile` SELinux布尔值的状态，禁用了它，并验证更改是否生效。SELinux布尔值使管理员能够精细控制系统中的访问权限和权限，修改这些布尔值时应清楚了解它们对系统操作的安全影响。
- en: Locking user accounts
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定用户账户
- en: 'In SELinux, the concept of locking user accounts is often associated with standard
    Linux account management practices, such as using the `passwd` command. SELinux
    itself does not directly handle account locking; rather, it relies on Linux’s
    account management tools to lock and unlock user accounts. Here are some Terminal
    examples of how to lock and unlock a user account:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在SELinux中，锁定用户账户的概念通常与标准的Linux账户管理实践相关，例如使用`passwd`命令。SELinux本身并不直接处理账户锁定；相反，它依赖Linux的账户管理工具来锁定和解锁用户账户。以下是一些锁定和解锁用户账户的终端示例：
- en: 'Locking a user account:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定用户账户：
- en: 'To lock a user account, you typically disable the account by changing the account’s
    password. This can be achieved by using the `passwd` command with the `-l` (lock)
    option:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要锁定用户账户，通常通过更改账户的密码来禁用该账户。这可以通过使用`passwd`命令并加上`-l`（锁定）选项来实现：
- en: '![Figure 12.9 – Locking a user account](img/B18212_12_9.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9 – 锁定用户账户](img/B18212_12_9.jpg)'
- en: Figure 12.9 – Locking a user account
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – 锁定用户账户
- en: 'Unlocking a user account:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁用户账户：
- en: 'To unlock a user account that has been locked, you can use the `passwd` command
    again, with `-u` to unlock and `f` for the force option:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要解锁已被锁定的用户账户，可以再次使用`passwd`命令，并加上`-u`选项来解锁，同时使用`f`选项强制执行：
- en: '![Figure 12.10 – Unlocking a user account](img/B18212_12_10.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10 – 解锁用户账户](img/B18212_12_10.jpg)'
- en: Figure 12.10 – Unlocking a user account
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 – 解锁用户账户
- en: The first command unlocks the password for the `intruder` user, and the output
    confirms that the account was unlocked successfully. The second command provides
    information about the user’s current password status, indicating that they have
    a password set and it is securely encrypted using SHA-512\. This scenario ensures
    that the `intruder` user can now access their account with their password.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令解锁了 `intruder` 用户的密码，输出确认该账户已成功解锁。第二个命令提供了关于该用户当前密码状态的信息，表明他们已设置密码，并且密码使用
    SHA-512 加密。这一场景确保 `intruder` 用户现在可以使用他们的密码访问账户。
- en: Securing SSH
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加固 SSH
- en: '**Secure Shell** (**SSH**) is a widely used protocol for secure remote access
    and secure file transfers over an insecure network. It plays a pivotal role in
    modern IT infrastructures, enabling administrators, developers, and users to access
    remote systems securely. However, to harness the full potential of SSH and maintain
    the confidentiality and integrity of data during remote connections, it’s paramount
    to implement robust security measures.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全外壳**（**SSH**）是一种广泛使用的协议，用于通过不安全的网络进行安全远程访问和文件传输。它在现代 IT 基础设施中扮演着至关重要的角色，使管理员、开发人员和用户能够安全地访问远程系统。然而，要充分发挥
    SSH 的潜力，并在远程连接过程中维护数据的机密性和完整性，实施强有力的安全措施至关重要。'
- en: 'The primary purpose of securing SSH is to protect sensitive information and
    prevent unauthorized access to remote systems. SSH achieves this by encrypting
    data during transmission and employing strong authentication mechanisms. By utilizing
    cryptographic protocols, SSH ensures that data that’s exchanged between the client
    and server remains confidential and is not susceptible to eavesdropping by malicious
    actors. Furthermore, SSH’s public-key authentication and password-based authentication
    mechanisms enhance the security of remote access, reducing the risk of unauthorized
    logins. The ability to securely tunnel various network services through SSH, known
    as SSH tunneling, also extends its use beyond remote access, making it a versatile
    tool for secure data transfer and network management. In essence, securing SSH
    is integral to safeguarding sensitive data, protecting against malicious intrusions,
    and ensuring the trustworthiness of remote connections. The importance of SSH
    security is underscored by its ubiquity in enterprise environments and the critical
    role it plays in securing remote access to servers, networking devices, and cloud
    infrastructure. Inadequate SSH security can lead to devastating consequences,
    including data breaches, unauthorized system access, and exposure to confidential
    information. This underscores the necessity of implementing best practices, such
    as enforcing strong password policies, using multi-factor authentication, and
    configuring SSH servers to allow only trusted users and hosts. SSH security also
    aligns with compliance requirements and regulatory standards, making it indispensable
    for organizations subject to data protection regulations such as GDPR or HIPAA.
    Here are some examples:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 加固 SSH 的主要目的是保护敏感信息，并防止未经授权访问远程系统。SSH 通过在传输过程中加密数据，并采用强大的身份验证机制来实现这一目标。通过使用加密协议，SSH
    确保客户端与服务器之间交换的数据保持机密，并且不易受到恶意攻击者的窃听。此外，SSH 的公钥认证和基于密码的认证机制增强了远程访问的安全性，降低了未经授权登录的风险。SSH
    的安全隧道功能（即 SSH 隧道）还扩展了它的使用范围，除了远程访问外，还可用于安全的数据传输和网络管理。总之，保护 SSH 安全对于保护敏感数据、抵御恶意入侵以及确保远程连接的可信度至关重要。SSH
    安全性的重要性在于其在企业环境中的普及性及其在保障远程访问服务器、网络设备和云基础设施安全方面的关键作用。SSH 安全性不足可能导致灾难性的后果，包括数据泄露、未经授权的系统访问和机密信息泄露。这强调了实施最佳实践的必要性，例如强制执行强密码策略、使用多因素认证，并配置
    SSH 服务器以仅允许受信任的用户和主机访问。SSH 安全性还符合合规要求和监管标准，因此对于受到 GDPR 或 HIPAA 等数据保护法规约束的组织至关重要。以下是一些示例：
- en: 'Change the default SSH port:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改默认 SSH 端口：
- en: Changing the default SSH port (`22`) to a non-standard port can help deter automated
    scanning and brute-force attacks.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将默认的 SSH 端口（`22`）更改为非标准端口有助于防止自动扫描和暴力破解攻击。
- en: 'To change the SSH port to `2222`, edit the SSH configuration file, `/etc/ssh/sshd_config`,
    located in the corner of the shell, as shown in the following screenshot:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要将 SSH 端口更改为 `2222`，请编辑位于终端角落的 SSH 配置文件 `/etc/ssh/sshd_config`，如以下截图所示：
- en: '![Figure 12.11 – Changing the default port](img/B18212_12_11.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.11 – 更改默认端口](img/B18212_12_11.jpg)'
- en: Figure 12.11 – Changing the default port
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11 – 更改默认端口
- en: Inside the file, locate the line with `Port 22` and change it to `Port 2222`
    or any other port number of your choice. Save the file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中，找到 `Port 22` 这一行并将其更改为 `Port 2222` 或您选择的任何其他端口号。保存文件。
- en: 'Update SELinux rules:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 SELinux 规则：
- en: When SELinux is enabled, it’s important to note that SELinux policies are designed
    to enhance system security by enforcing strict rules and restrictions on various
    system resources, including network ports. These policies might initially prevent
    SSH traffic on a new port that you’ve configured.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当启用 SELinux 时，需要注意的是，SELinux 策略旨在通过对各种系统资源（包括网络端口）强制执行严格的规则和限制来增强系统安全性。这些策略可能最初会阻止您在新端口上配置的
    SSH 流量。
- en: To ensure that SSH traffic can flow smoothly on the new port, you’ll need to
    update the SELinux policy to allow it. You can achieve this using the `semanage`
    command, which is a powerful tool for managing SELinux policies. Specifically,
    you’ll need to use `semanage` to modify the SELinux port policy to permit SSH
    communication on the new port.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为确保 SSH 流量能够顺畅地流动到新端口，您需要更新 SELinux 策略以允许它。您可以使用 `semanage` 命令来实现这一点，`semanage`
    是一个强大的 SELinux 策略管理工具。具体来说，您需要使用 `semanage` 修改 SELinux 端口策略，以允许在新端口上进行 SSH 通信。
- en: 'Once you’ve made the necessary policy adjustments, it’s crucial to apply these
    changes and then restart the SSH service to put the new configuration into effect.
    This ensures that SSH connections on the modified port are allowed as per the
    updated SELinux policy. Here’s how you can accomplish this:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦您完成了必要的策略调整，务必应用这些更改，并重启 SSH 服务以使新配置生效。这确保了根据更新后的 SELinux 策略，修改端口上的 SSH 连接能够被允许。以下是您可以执行的步骤：
- en: '![Figure 12.12 – Updating SELinux rules and restarting sshd](img/B18212_12_12.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.12 – 更新 SELinux 规则并重启 sshd](img/B18212_12_12.jpg)'
- en: Figure 12.12 – Updating SELinux rules and restarting sshd
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12 – 更新 SELinux 规则并重启 sshd
- en: 'We can verify this by running the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来验证这一点：
- en: '![Figure 12.13 – Verifying the changes](img/B18212_12_13.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.13 – 验证更改](img/B18212_12_13.jpg)'
- en: Figure 12.13 – Verifying the changes
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13 – 验证更改
- en: 'Disable password authentication:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用密码认证：
- en: Disabling password-based authentication in favor of public key authentication
    enhances security by eliminating the risk of password-guessing attacks.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 禁用基于密码的认证，改用公钥认证可以通过消除密码猜测攻击的风险来增强安全性。
- en: 'Edit the SSH configuration file, `/etc/ssh/sshd_config`, located in the corner
    of the shell, as shown in the following screenshot:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编辑 SSH 配置文件 `/etc/ssh/sshd_config`，该文件位于 shell 的角落，如下所示的截图所示：
- en: '![Figure 12.14 – Disabling password authentication](img/B18212_12_14.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.14 – 禁用密码认证](img/B18212_12_14.jpg)'
- en: Figure 12.14 – Disabling password authentication
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14 – 禁用密码认证
- en: 'Find the line with `PasswordAuthentication yes` and change it to `Password`
    **Authentication no**. Save the file and restart SSH:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 找到 `PasswordAuthentication yes` 这一行并将其更改为 `Password` **Authentication no**。保存文件并重启
    SSH：
- en: '![Figure 12.15 – Restarting sshd](img/B18212_12_15.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.15 – 重启 sshd](img/B18212_12_15.jpg)'
- en: Figure 12.15 – Restarting sshd
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.15 – 重启 sshd
- en: Ultimately, securing SSH is not only a matter of technological implementation
    but a fundamental component of comprehensive cybersecurity strategies, contributing
    to the resilience and trustworthiness of IT systems.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，确保 SSH 安全不仅仅是技术实施的问题，更是全面网络安全策略的基本组成部分，它有助于增强 IT 系统的韧性和可信度。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter provided Linux administrators with a deep understanding of SELinux
    modes and how they influence system security. We explored the concepts of enforcing
    and permissive modes and their significance in the context of Linux administration.
    Administrators need to learn to leverage these modes to strike a balance between
    security and system functionality, ensuring that SELinux policies are effectively
    enforced. This chapter also covered the crucial topic of *enabling or disabling
    SELinux Boolean values*. We delved into the reasons, importance, and practical
    use of SELinux Boolean values, demonstrating how they allow administrators to
    fine-tune security policies to meet specific system requirements. By enabling
    or disabling Boolean values, administrators gain flexibility in tailoring SELinux
    policies to their system’s needs while maintaining a high level of security. Another
    essential aspect of system security that we explored in this chapter was *locking
    user accounts in SELinux security*. Here, you discovered the reasons for locking
    user accounts, the importance of doing so, and the methods to achieve it within
    the SELinux framework. This knowledge should have equipped you to effectively
    manage user access and enhance the overall security posture of your system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为Linux管理员提供了关于SELinux模式及其如何影响系统安全的深入理解。我们探讨了强制模式和宽松模式的概念，以及它们在Linux管理中的重要性。管理员需要学会利用这些模式，以在安全性和系统功能之间找到平衡，确保有效执行SELinux策略。本章还涵盖了*启用或禁用SELinux布尔值*这一关键主题。我们深入探讨了SELinux布尔值的原因、重要性及其实际应用，展示了它们如何帮助管理员根据特定的系统需求微调安全策略。通过启用或禁用布尔值，管理员可以在确保高安全性的同时，为系统量身定制SELinux策略，提供更大的灵活性。本章还探讨了系统安全的另一个重要方面，即*在SELinux安全中锁定用户帐户*。在这一部分，你了解了锁定用户帐户的原因、重要性及其在SELinux框架内实现的方法。这些知识应该帮助你有效管理用户访问权限，提升系统的整体安全性。
- en: Finally, we delved into securing SSH, a critical component of remote system
    administration. Administrators learn best practices for securing SSH, including
    changing the default SSH port, disabling password authentication in favor of public
    key authentication, and limiting SSH access to specific users or groups. By implementing
    these security measures, administrators bolster the security of remote access
    to their Linux systems.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们深入探讨了SSH的安全性，这是远程系统管理的一个关键组件。管理员学习了确保SSH安全的最佳实践，包括更改默认SSH端口、禁用密码认证并使用公钥认证、以及将SSH访问限制为特定用户或组。通过实施这些安全措施，管理员增强了远程访问Linux系统的安全性。
- en: In the next chapter, we’ll explore the world of cloud computing and how Linux
    plays a pivotal role in it. This chapter will take you on a journey through running
    Linux machines on the cloud, creating Linux instances, and various administrative
    tasks within a cloud-based Linux environment. By the end, you will have the knowledge
    and skills to thrive in the cloud computing era.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索云计算的世界，以及Linux在其中扮演的关键角色。本章将带领你了解如何在云端运行Linux机器、创建Linux实例，以及在基于云的Linux环境中的各种管理任务。到本章结束时，你将掌握在云计算时代中茁壮成长所需的知识和技能。
