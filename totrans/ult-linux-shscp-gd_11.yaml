- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Performing Mathematical Operations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行数学运算
- en: The various operating system shells all have means of performing mathematical
    operations either from the command-line, or from within a shell script. In this
    chapter, we’ll look at how to perform operations with both integer and floating
    point math.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 各种操作系统的shell都可以从命令行或shell脚本中执行数学运算。在本章中，我们将讨论如何使用整数和浮点数数学进行运算。
- en: 'Topics in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下内容：
- en: Performing integer math with expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表达式进行整数运算
- en: Performing integer math with integer variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用整数变量进行整数运算
- en: Performing floating point math with `bc`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`bc`进行浮点数学运算
- en: If you’re ready, let’s get started.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你准备好了，我们开始吧。
- en: Technical Requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Use any of your Linux virtual machines for this. And, as always, you can download
    the scripts by doing:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何Linux虚拟机来进行此操作。而且，和往常一样，你可以通过以下方式下载脚本：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Performing Integer Math with Expressions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表达式进行整数运算
- en: You can do integer math directly in `bash`, which is sometimes handy. But, `bash`
    doesn’t have the capability of doing floating point math. For that, you’ll need
    to use a separate utility, which we’ll look at later.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在`bash`中进行整数运算，这有时非常方便。但是，`bash`没有进行浮点运算的能力。对于浮点运算，你需要使用一个单独的工具，稍后我们会讨论。
- en: 'If you ever try to use `echo` to perform math on the command-line, you’ll find
    that it doesn’t work. What you’ll get will look something like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用`echo`在命令行上执行数学运算，你会发现它无法正常工作。你得到的结果可能像这样：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is because `echo` treats your math problem as just a normal text string.
    So, you’ll need some other way to solve your math problems. Fortunately, there
    are a few different ways to do this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`echo`将你的数学问题视为普通文本字符串。所以，你需要其他方法来解决数学问题。幸运的是，有几种不同的方法可以做到这一点。
- en: Using the expr Command
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`expr`命令
- en: 'The `expr` command is for evaluating expressions. These expressions can be
    normal text strings, regular expressions, or mathematical expressions. For now,
    I’ll just talk about using it to evaluate math expressions. Here’s an example
    of its basic usage:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`expr`命令用于计算表达式。这些表达式可以是普通文本字符串、正则表达式或数学表达式。现在，我将仅讨论如何使用它来计算数学表达式。以下是其基本用法示例：'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that you need a blank space between the operator and each operand, or
    else you’ll get this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要在运算符和每个操作数之间留有空格，否则你会得到如下结果：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Without the blank spaces, `expr` just echos back whatever you type in.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有空格，`expr`只是将你输入的内容原样回显。
- en: 'You can use `expr` with the `+`, `-`, `/`, `*`, and `%` operators to perform
    addition, subtraction, division, multiplication, or modulus operations. (Modulus
    operations show you the remainder after a division operation.) Special care is
    needed for using the `*` operator, because a shell will interpret it as a wild
    card. So, when performing multiplication, you’ll need to escape the `*` with a
    `\`, like so:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`expr`与`+`、`-`、`/`、`*`和`%`运算符来执行加法、减法、除法、乘法或取余操作。（取余操作会显示除法操作后的余数。）使用`*`运算符时需要特别注意，因为在shell中它会被解释为通配符。因此，在执行乘法时，你需要用`\`对`*`进行转义，像这样：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Without the backslash in front of the `*`, you will receive an error, which
    will look like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`*`前面没有反斜杠，你将会收到一个错误，错误信息如下：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For more complex problems, the normal rules of math apply, as you see here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的问题，正常的数学规则适用，如你所见：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The laws of math dictate that division and multiplication always take precedence
    over subtraction and addition. So, you see here that the `2 \* 3` operation gets
    performed before adding `1`. But, just as in normal math, you can change the order
    in which operations are performed by placing a pair of parentheses around the
    operation that you want to perform first. Here’s what that looks like:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数学法则规定，除法和乘法总是优先于减法和加法。所以，你可以看到`2 * 3`的运算先于加`1`。但是，就像在常规数学中一样，你可以通过在你想先执行的操作周围放置一对括号来改变运算顺序。它看起来是这样的：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice how I had to escape each parenthesis symbol with a backslash, and leave
    a blank space between the `(` and the `1`, and between the `2` and the `\`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我如何使用反斜杠转义每个括号符号，并且在`(`和`1`之间、`2`和`\`之间留有空格。
- en: 'You can also use `expr` with variables. To demo that, create the `math1.sh`
    script, like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`expr`中使用变量。为了演示这一点，创建一个名为`math1.sh`的脚本，像这样：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running the script with 88 and 23 as the input values looks something like
    this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用88和23作为输入值运行脚本，看起来像这样：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that `expr` can only work with integers. So, any results that involve
    a decimal get rounded up or down to the nearest integer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`expr`只能处理整数。所以，任何涉及小数的结果都会四舍五入到最接近的整数。
- en: 'And of course, you can also use `expr` with command substitution, as you see
    here in this `math2.sh` script:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以像在这个`math2.sh`脚本中一样，使用`expr`和命令替换。
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That’s all there is to it for `expr`. Next, let’s take another look at `echo`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`expr`的全部内容。接下来，让我们再看看`echo`。
- en: Using echo with Math Expressions
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`echo`与数学表达式
- en: 'I know, I just told you that you can’t use `echo` to perform math. Well, you
    actually can, but there’s a special way to do it. You’ll just have to place your
    math problem within either a `$(( ))` construct or a `$[ ]` construct, like so:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，我刚刚告诉你不能使用`echo`来执行数学运算。嗯，实际上你是可以的，但有一种特殊的方式。你只需要将数学问题放入`$(( ))`构造或`$[ ]`构造中，像这样：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Both constructs give the same results, so—on `bash` at least—whichever you use
    is a matter of personal preference.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 两种构造给出的结果是一样的，所以——至少在`bash`中——你使用哪种只是个人喜好的问题。
- en: 'A very cool thing about these two constructs is that you don’t have to use
    a `$` to call back the values of any variables that are within them. Likewise,
    you don’t have to escape the `*` character with a backslash. Here’s the `math3.sh`
    script to show you that:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个构造的一个非常酷的地方是，你不需要使用`$`来回调它们内部任何变量的值。同样，你也不需要用反斜杠来转义`*`字符。以下是`math3.sh`脚本，展示给你看：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You also see that in the second `echo` command, I surrounded `val1+val2` with
    its own set of parentheses in order to give the addition operation precedence
    over the multiplication operation. Anyway, here’s what happens when I run the
    script:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到，在第二个`echo`命令中，我用一对括号将`val1+val2`括起来，以便让加法运算优先于乘法运算。无论如何，以下是我运行脚本时发生的情况：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you find the use of nested parentheses too confusing, you might want to
    use the square bracket construct instead, like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得使用嵌套括号太混乱，你可能想改用方括号构造，像这样：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Either way, you’ll get the same results.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，你会得到相同的结果。
- en: There is a catch to this, though. It’s just that the square bracket construct
    doesn’t work on certain other shells, such as `/bin/sh` on FreeBSD and OpenIndiana,
    and `/bin/dash` on Debian and its derivatives. So, to make your scripts more portable,
    you’ll need to use the `((..))` construct for your math problems, even though
    it can get a bit confusing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这里有一个陷阱。方括号构造在某些其他shell中不起作用，比如FreeBSD和OpenIndiana中的`/bin/sh`，以及Debian及其衍生版中的`/bin/dash`。所以，为了让你的脚本更具可移植性，你需要使用`((..))`构造来处理数学问题，尽管它可能会让人有点困惑。
- en: 'Here’s a more practical example of using parentheses to change the precedence
    of operations. In this `new_year.sh` script, I’m calculating the number of weeks
    left until the New Year. I start by using the `date +%j` command to calculate
    the numbered day of the year. Here’s the output of that command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个更实用的例子，展示了如何使用括号来改变运算的优先级。在这个`new_year.sh`脚本中，我在计算距离新年还有多少周。我首先使用`date
    +%j`命令来计算当年的天数。以下是该命令的输出：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'I’m writing this on 31 October, which is the 304^(th) day of the year 2023\.
    I’ll then subtract that result from the number of days in a year, and divide that
    by 7 to give me the final answer. Here’s what the script looks like:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我是在10月31日写的这个，这一天是2023年的第304^(天)。然后，我将这个结果从一年中的天数中减去，并将其除以7，得到最终的答案。以下是脚本的样子：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You see that I used the square bracket construct in order to avoid the confusion
    of having so many nested parentheses. But, as I said before, that won’t work on
    certain other non-`bash` shells.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我使用了方括号构造，以避免有太多嵌套括号带来的混乱。但正如我之前所说，这在某些非`bash`的shell中是无法使用的。
- en: 'Here’s what I get when I run the script:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我运行脚本时得到的结果：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Of course, you might be reading this in 2024, 2028, or even 2032, which are
    all leap years with 366 days, but that’s okay. That extra day won’t matter with
    this particular math problem.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能正在2024年、2028年或甚至2032年阅读这篇文章，那些年份都是闰年，有366天，但这没关系。那一天的额外天数对这个特定的数学问题不会产生影响。
- en: 'Okay, how about one more example of a script with math expressions? Create
    the `math4.sh` script, like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，再来一个带有数学表达式的脚本示例？创建一个`math4.sh`脚本，像这样：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This script begins with the number 0 as the initial value of `start`. It then
    prints out the value of `start`, increments it by 1, and then prints the next
    value. The loop continues until the value of `limit` is reached. Here’s what that
    looks like:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本以0作为`start`的初始值开始。然后它打印出`start`的值，将其增加1，再打印下一个值。循环会一直进行，直到达到`limit`的值。以下是它的运行结果：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This pretty much covers it for using math expressions. Let’s now see about using
    a new type of variable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上涵盖了使用数学表达式的内容。现在让我们来看一下使用新类型变量的方法。
- en: Performing Integer Math with Integer Variables
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用整数变量进行整数数学运算
- en: Instead of using mathematical expressions, you can use **integer variables**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**整数变量**来代替数学表达式。
- en: 'You’ve already seen the kind of thing that doesn’t work, which looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了不适用的情况，它看起来是这样的：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That’s because by default, the values of variables are text strings, rather
    than numbers. To make this work, use the `declare -i` command to create integer
    variables, like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为默认情况下，变量的值是文本字符串，而不是数字。为了使其正常工作，可以使用`declare -i`命令来创建整数变量，像这样：
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here’s how it look in the `math5.sh` script:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`math5.sh`脚本中的实现方式：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `declare -i` commands, you don’t need to precede variable names with
    a `$` to call their values. You also don’t need to use command substitution to
    assign the results of a math operation to a variable. Anyway, here’s how it looks
    when I run it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`declare -i`命令中，你不需要在变量名前加上`$`来调用它们的值。你也不需要使用命令替换来将数学运算的结果赋值给变量。总之，以下是我运行它时的样子：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And, since this is integer math, any results that contain a decimal get rounded
    up or down to the nearest integer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是整数运算，任何包含小数的结果都会被四舍五入到最近的整数。
- en: Sometimes, integer math is all you need. But, what if you need more? That’s
    in the next section, so stay tuned.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，整数运算已经足够了。但如果你需要更多呢？那就在下一部分，我们敬请期待。
- en: Performing Floating Point Math with bc
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用bc进行浮点数学运算
- en: The methods you’ve just seen for performing math operations from the shell all
    have two limitations. First, these methods can only work with integers. Secondly,
    when using these methods, you’re limited to just basic math. Fortunately, the
    `bc` utility solves both of those problems. In fact, you’d need to be an expert
    mathematician to take full advantage of `bc`'s features. (I don’t fall into that
    category, but I can still show you the basics of using `bc`.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才看到的几种从shell执行数学运算的方法都有两个限制。首先，这些方法只能处理整数。其次，当使用这些方法时，你只能进行基本的数学运算。幸运的是，`bc`工具解决了这两个问题。事实上，要充分利用`bc`的特性，你需要成为一名数学专家。（我不属于这个类别，但我还是可以向你展示使用`bc`的基本操作。）
- en: You should find that `bc` is already installed on your Linux or Unix system,
    so you likely won’t have to mess around with installing it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会发现`bc`已经安装在你的Linux或Unix系统上，因此你可能不需要再去安装它。
- en: 'There are three ways to use `bc`, which are:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`bc`有三种方式，分别是：
- en: 'Interactive mode: You’ll just open `bc`, and enter math commands on its own
    command-line.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互模式：你只需打开`bc`，然后在其命令行中输入数学命令。
- en: 'Program files: Create programs in the `bc` language, and use `bc` to execute
    them.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序文件：在`bc`语言中创建程序，并使用`bc`执行它们。
- en: 'Pipe math problems into bc: You can do this either from the shell command-line,
    or from within shell scripts.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数学问题通过管道传递给bc：你可以从shell命令行或shell脚本中执行此操作。
- en: Let’s look at interactive mode first.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看交互模式。
- en: Using bc in Interactive Mode
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在交互模式下使用bc
- en: 'You can start `bc` in interactive mode by entering `bc` at the command-line,
    like so:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在命令行输入`bc`来启动`bc`的交互模式，像这样：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, you just type a math problem at the `bc` command prompt. Let’s start by
    dividing 3 by 4, like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需在`bc`命令提示符下输入一个数学问题。让我们先从3除以4开始，如下所示：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You see that this gives us 0 as the result. But wait, isn’t `bc` supposed to
    be floating point-capable? Well, it is, but you have to start it with the `-l`
    option to bring in the optional math libraries. So, let’s type `quit` to shut
    it down and start over, like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到结果是0。但等等，`bc`不应该支持浮点运算吗？当然支持，但你必须使用`-l`选项启动它，以加载可选的数学库。所以，我们先输入`quit`退出并重新启动，如下所示：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you don’t want to see this many decimal places, use the `scale` command.
    Let’s say that you only want to see two decimal places. Just set it like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想看到这么多小数位，可以使用`scale`命令。假设你只想看到两位小数，可以这样设置：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let’s do something a bit more practical, by solving some geometry problems.
    As you likely know, a triangle has three angles, and the number of degrees in
    all three angles always adds up to 180 degrees, as you see here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们做一些更实际的事情，来解决一些几何问题。正如你可能知道的，三角形有三个角，三个角度的总和总是等于 180 度，正如你在这里看到的：
- en: '![](img/B21693_11_01.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21693_11_01.png)'
- en: 'Figure 11.1: A triangle with three 60-degree angles'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：一个三角形，三个 60 度的角
- en: 'So, for example, you could have a triangle with a 40-degree angle, a 50-degree
    angle, and a 90-degree angle. At times though, you might only know the number
    of degrees in two of the angles, and will want to find the number of degrees for
    the third angle. You can do that by adding together the number of degrees for
    the two known angles, and subtracting the sum from 180\. Here’s what it looks
    like in `bc` interactive mode:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以有一个三角形，角度分别为 40 度、50 度和 90 度。然而，有时候你可能只知道两个角度的度数，并且需要找出第三个角度的度数。你可以通过将已知的两个角度的度数相加，并从
    180 中减去它们的和来得到第三个角度。下面是在 `bc` 交互模式下的计算方式：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This also demonstrates how you can use variables in `bc`. This is handy, because
    if I want to run the calculation again on another set of values, I only have to
    type in the new variable assignments. Then, I’ll just use the up-arrow key on
    the keyboard to get back to the formula.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这也演示了如何在 `bc` 中使用变量。这非常方便，因为如果我想在另一组数值上重新运行计算，我只需要输入新的变量赋值。然后，我只需使用键盘上的上箭头键回到公式。
- en: 'Next, we’ll look at a circle with a diameter of 25 and a radius of 12.5\. (The
    unit-of-measure doesn’t matter. It could be inches, centimeters, miles, or kilometers.
    It really doesn’t matter.) To calculate the circumference of a circle, we need
    to multiply the circle’s diameter by the value of `pi` (Π), like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一个直径为 25，半径为 12.5 的圆。（单位不重要，可以是英寸、厘米、英里或公里，实际上都没关系。）要计算圆的周长，我们需要将圆的直径乘以
    `pi`（Π）的值，如下所示：
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To calculate the area of a circle, multiply П by the squared value of the radius,
    like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算圆的面积，使用 Π 乘以半径的平方，如下所示：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You see here that the `^` is used to denote an exponent, which in this case
    is 2\. You also see that there’s no `echo` command in the `bc` language. Instead,
    you’ll use `print`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到，`^` 用来表示指数运算，在这个例子中是 2。你还会看到，在 `bc` 语言中没有 `echo` 命令。相反，你需要使用 `print`。
- en: 'You’ll find many useful functions in the optional libraries, besides just the
    ability to deal with floating point math. For example, you can use the `ibase`
    and `obase` functions to convert numbers from one number system to another. Here,
    you see me converting a decimal number to a hexadecimal number:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理浮点数学的功能外，你还会在可选库中找到许多有用的函数。例如，你可以使用 `ibase` 和 `obase` 函数将数字从一种数字系统转换为另一种。在这里，你看到我将一个十进制数转换为十六进制数：
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `obase=16` line tells `bc` that I want all numbers to be output in hexadecimal
    format. I don’t have to use an `ibase` line to specify the input number system,
    because it already defaults to decimal. When I entered 10 as the number to convert,
    I got A as a result, which is the hexadecimal equivalent of decimal number 10\.
    I can also convert from hexadecimal back to decimal, like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`obase=16` 行告诉 `bc` 我希望所有的数字以十六进制格式输出。我不需要使用 `ibase` 行来指定输入的数字系统，因为它默认是十进制。当我输入
    10 作为要转换的数字时，得到的结果是 A，这就是十进制数字 10 的十六进制等价。我还可以将十六进制转换回十进制，像这样：'
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Again, since decimal is the default, I didn’t have to specify it for the `obase`.
    (Well, I would have had to, if I hadn’t closed and reopened `bc` after setting
    the `obase` to 16 for the previous example.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于十进制是默认值，我不需要为 `obase` 指定它。（如果我在之前的例子中设置了 `obase` 为 16 后没有关闭并重新打开 `bc`，那我就得指定了。）
- en: 'Here’s an example of setting both the `ibase` and the `obase`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是同时设置 `ibase` 和 `obase` 的一个例子：
- en: '[PRE33]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this one, I chose to convert a binary number to hexadecimal.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我选择将一个二进制数转换为十六进制。
- en: 'You can also set the `ibase` and the `obase` to the same value in order to
    perform math in a different number system. Here’s an example of how to perform
    binary math:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将 `ibase` 和 `obase` 设置为相同的值，以便在不同的数字系统中进行数学运算。以下是如何进行二进制运算的示例：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Yeah, I wish that I would have had this back in the 1980s, when I had to learn
    binary math in my early computer classes. It would have made things so much easier.
    But seriously, note that in the division command, there are so many trailing zeros
    that a `\` was used to continue them on the next line.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我希望在上世纪八十年代学习二进制数学时能有这个，那时候会方便很多。但是要注意，在除法命令中，有太多的尾随零，所以使用`\`来将它们继续到下一行。
- en: 'You can use a `scale=` command to change that, but you’ll get some rather surprising
    results when using it in binary mode. Here’s what I mean:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`scale=`命令来进行更改，但是在二进制模式下使用它时，可能会得到一些令人惊讶的结果。这里是我的意思：
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: I don’t know why that is, but that’s okay.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道为什么是这样，但没关系。
- en: Tip
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Be aware that if you decide to convert a hexadecimal number to another format,
    the digits A through F must be typed in upper-case.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你决定将一个十六进制数转换为另一种格式，那么字母 A 到 F 必须以大写形式输入。
- en: 'Other functions in the `bc` libraries include:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`bc` 库中的其他函数包括：'
- en: '`s (x)`: The sine of x, in radians.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s (x)`: x 的正弦，单位是弧度。'
- en: '`c (x)`: The cosine of x, in radians.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c (x)`: x 的余弦，单位是弧度。'
- en: '`a (x)`: The arctangent of x, in radians.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a (x)`: x 的反正切，单位是弧度。'
- en: '`l (x)`: The natural logarithm of x.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l (x)`: x 的自然对数。'
- en: '`e (x)`: The exponential function of raising e to the value x.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e (x)`: 对数 e 的 x 次幂。'
- en: '`j (n,x)`: The Bessel function of integer order n of x.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`j (n,x)`: x 的整数阶贝塞尔函数。'
- en: 'For example, let’s say that you need to find the natural logarithm of the number
    80\. Just do it like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你需要找到数字 80 的自然对数。只需像这样做：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Okay, I think that that should cover it for interactive mode. Let’s now look
    some `bc` programs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想这应该涵盖了交互模式。现在让我们看看一些`bc`程序。
- en: Using bc Program Files
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 bc 程序文件
- en: 'The main problem with using interactive mode is that as soon as you shut down
    `bc`, all of your work will disappear. One way to make your work permanent is
    to create a program file. Let’s begin by creating the `geometry1.txt` file, which
    will look like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交互模式的主要问题是，一旦关闭`bc`，所有的工作都会消失。使你的工作永久化的一种方法是创建一个程序文件。让我们开始创建`geometry1.txt`文件，它看起来像这样：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You’ve already seen how to do the math, so I won’t go over that again. But,
    I do want you to notice that the `print` command doesn’t automatically insert
    a newline character at the end of lines. So, you’ll have to do that yourself by
    adding a `\n` sequence at the end of your `print` commands. Also, notice on line
    3 how I used the `read()` function to take the user’s input and assign it to the
    `radius` variable. The last command must be `quit`, or else the program won’t
    exit. To run this program, just type `bc -l`, followed by the name of the program
    file, like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到如何进行数学计算了，所以我不会再重复了。但是，我想让你注意到`print`命令不会自动在行末插入换行符。因此，在你的`print`命令末尾加上`\n`序列来手动换行。另外，请注意第
    3 行如何使用`read()`函数接收用户输入并将其赋值给`radius`变量。最后一个命令必须是`quit`，否则程序将无法退出。要运行此程序，只需输入`bc
    -l`，然后输入程序文件的名称，就像这样：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Tip**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: 'I cheated a bit here, by copying the value of П from a website where it had
    already been calculated. If you’d rather calculate the value of П yourself, you
    can do it with this formula:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里有点作弊，从一个已经计算好的网站上复制了 П 的值。如果你愿意自己计算 П 的值，可以用这个公式：
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The next example is a checkbook balancing program that I borrowed from the
    `bc` documentation page. Here’s what it looks like:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例是我从`bc`文档页面借来的支票簿平衡程序。它的样子是这样的：
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, you see that the `bc` language has the same programming constructs that
    you’ve already seen in normal shell scripting. (In this case, you see a `while`
    loop.) The `bc` language implements them a bit differently, but that’s okay. The
    next things to note are the `scale=2` and the `bal /= 1` lines. These two commands
    ensure that the program’s output will always have two digits after the decimal
    point, even when you only enter an integer without any decimals. To show what
    I mean, open `bc` in interactive mode and type in these commands:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到`bc`语言具有与普通Shell脚本中已经看到的相同的编程结构。（在这种情况下，你看到了一个`while`循环。）`bc`语言对它们实现有些不同，但没关系。接下来要注意的是`scale=2`和`bal
    /= 1`这两行。这两个命令确保程序的输出始终保留小数点后两位，即使你只输入一个没有小数的整数。为了说明我的意思，打开交互模式中的`bc`，并输入这些命令：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You see that before I invoked the `bal /= 1` command, `print bal` only shows
    1000, without any decimals. So, why does this work? Well, it’s just that the `bal
    /= 1` command is just a shorthand way of expressing a division by 1\. In other
    words, it does the same thing that the `bal=(bal/1)` command does, except with
    less typing. In this case, we’re dividing 1000 by 1, which still gives us 1000\.
    But, because we set the scale to 2, printing any number that’s a result of a math
    operation will now always show two decimal places.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到在我调用`bal /= 1`命令之前，`print bal`只显示1000，没有小数点。所以，为什么这样做有效呢？其实就是`bal /= 1`命令是表达除以1的简写方式。换句话说，它做的和`bal=(bal/1)`命令完全一样，只不过少了些输入。在这种情况下，我们将1000除以1，结果还是1000。但因为我们将scale设置为2，所以任何数学操作的结果打印出来时都会显示两位小数。
- en: The next thing to note in the program file is the `bal -= trans` line. The `-=`
    operator causes the balance to decrement by the amount of the financial transaction
    that’s represented by `trans`. Now, I really don’t know why the program’s author
    did this, because it means that the user has to enter a positive number to reduce
    the balance, and a negative number to add to the balance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 程序文件中的下一个需要注意的地方是`bal -= trans`这一行。`-=`运算符使得余额根据代表财务交易的`trans`数值减少。我真不明白程序作者为什么这么做，因为这意味着用户必须输入一个正数来减少余额，输入负数来增加余额。
- en: Changing the line to `bal +=` trans would make much more sense. That way a negative
    number would represent a debit, a positive number would represent a deposit, and
    all would be right with the world. Anyway, I digress.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一行改为`bal +=` trans会更有意义。这样，负数代表扣款，正数代表存款，一切都会顺利进行。无论如何，我有点跑题了。
- en: 'Running the program looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序的效果如下：
- en: '[PRE42]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, just enter your transactions, and then enter 0 to quit.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需输入你的交易记录，然后输入0退出。
- en: There’s a lot more that you can do with `bc` program files, but I think you
    get the overall idea. Let’s now look at using `bc` in normal shell scripts.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用`bc`程序文件做更多的事情，但我想你已经掌握了大致的思路。现在，让我们看看如何在普通的Shell脚本中使用`bc`。
- en: Using bc in Shell Scripts
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Shell脚本中使用bc
- en: 'The third and final way to use `bc` is to run `bc` commands from a normal shell
    environment. So, you can either run `bc` commands from the shell command-line,
    or place them into normal shell scripts. Here’s an example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`bc`的第三种也是最后一种方式是从普通的Shell环境中运行`bc`命令。所以，你可以从Shell命令行运行`bc`命令，或者将它们放入普通的Shell脚本中。这里有一个示例：
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, I’m using command substitution to assign a value to `pi`. Within the command
    substitution construct, I’m echoing a `bc`-style math formula into `bc`. The first
    thing you see is that I’ve set the scale to 10\. The `4*a(1)` means that I’m taking
    the arctangent of 1 and multiplying it by 4, which is one of the many formulas
    that you can use to approximate the value of `pi` (П). (Remember that П is an
    irrational number, which means that you will never find its exact value.)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用命令替换将一个值赋给`pi`。在命令替换构造中，我将一个`bc`风格的数学公式传递给`bc`。你首先看到的是我将scale设置为10。`4*a(1)`意味着我正在计算1的反正切，并将结果乘以4，这是你可以用来近似`pi`（π）值的许多公式之一。（记住，π是一个无理数，这意味着你永远无法得到它的准确值。）
- en: 'Now, let’s put this into the `pi_bc.sh` shell script, which looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些内容放入`pi_bc.sh`脚本中，它看起来是这样的：
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'I’ve fancied things up a bit, by allowing you to specify your own scaling value
    when you invoke the script. You see that if you don’t enter a scaling value, it
    will return a message that tells you to do so. Running the script looks like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我稍微优化了一下，允许你在调用脚本时指定自己的缩放值。你可以看到，如果不输入缩放值，它会返回一条提示信息，告诉你需要输入。运行脚本的效果如下：
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Of course, you can enter even larger scaling values if you’d like.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以根据需要输入更大的缩放值。
- en: 'You can also use `bc` to create your own function libraries. For example, check
    out this `baseconv.lib` library file that I created in my `/usr/local/lib/` directory:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`bc`来创建你自己的函数库。例如，查看我在`/usr/local/lib/`目录下创建的这个`baseconv.lib`库文件：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `bc-func_demo.sh` script that uses this library is too long to show here
    in its entirety. But, you can download it from the GitHub repository. For now,
    I’ll just show you a few snippets and provide some explanation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个库的`bc-func_demo.sh`脚本太长，无法在此完整展示。但是，你可以从GitHub仓库下载它。目前，我只会展示一些片段并提供解释。
- en: 'The top part of the script looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的顶部部分看起来是这样的：
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The first thing you see is that I’m sourcing the library file with the `. /usr/local/lib/baseconv.lib`
    command. After that, you see a construct that I’ve neglected to show you before.
    The `until. .do` construct will keep showing you a menu until you hit the *q*
    key. I mean, if you make any of the other choices, you’ll be prompted to enter
    a number that you want to convert. When the conversion is done, the menu will
    pop right back up, and will stay there until you hit the *q*. The next bit of
    code is a `case. .esac` construct, which performs the task that you choose from
    the menu. Here’s the first part of that:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先看到的是我通过`. /usr/local/lib/baseconv.lib`命令引入库文件。接下来，你会看到一个我之前没展示过的结构。`until.
    .do`结构会一直显示菜单，直到你按下*q*键。也就是说，如果你做出其他选择，系统会提示你输入一个想要转换的数字。转换完成后，菜单会立即重新出现，直到你按下*q*。接下来是一个`case.
    .esac`结构，它根据你从菜单中选择的任务执行相应的操作。这里是其中的第一部分：
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Running the script looks like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本时会是这样：
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Below this, which is beyond the point where I can show you here, the menu re-appears,
    waiting for your next response.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，超出了我在此处能够展示的范围，菜单会重新出现，等待你的下一个输入。
- en: 'Now, this does work, but it uses global variables to pass values from the functions
    back to the main script. I’ve already told you that this isn’t the safest way
    of doing business, and that it’s better to use a combination of local variables
    and command substitution. The modified library file is also too long to show here
    in its entirety, but here’s a snippet:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这种方式确实有效，但它使用全局变量将函数中的值传递回主脚本。我已经告诉过你，这并不是最安全的做法，最好是结合使用局部变量和命令替换。修改后的库文件内容过长，无法在这里完全展示，但这里有一段代码示例：
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can download this entire `baseconv_local.lib` file, as well as the `bc-func_local_demo.sh`
    script that uses it, from Github. The script is mostly the same as the previous
    one, except for the code in the `case. .esac` construct that invokes the functions.
    Here’s a snippet:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从Github下载整个`baseconv_local.lib`文件，以及使用它的`bc-func_local_demo.sh`脚本。该脚本与之前的版本大致相同，除了在`case.
    .esac`结构中的代码，它调用了不同的函数。这里有一段代码示例：
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: I’ve already explained this construction in *Chapter 10--Understanding Functions*,
    so I won’t say anything more about it here.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在*第10章——理解函数*中解释过这个结构，所以在这里不再赘述。
- en: 'The final example I’ll show you uses one of the many text stream filters that
    you thought you’d never use. This involves using the `paste` command to help calculate
    the total combined market share for the various versions of the Windows operating
    system. To see what I mean, take a look at this `os_combined-ww-monthly-202209-202309-bar.csv`
    file that you can download from Github:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向你展示的最后一个例子，使用了你曾以为永远不会用到的许多文本流过滤器之一。这涉及到使用`paste`命令来帮助计算各种版本Windows操作系统的总市场份额。为了让你理解我的意思，看看这个你可以从Github下载的`os_combined-ww-monthly-202209-202309-bar.csv`文件：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: These market share stats are for the various desktop operating systems, as reported
    by the *Statcounter Global Stats* site.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些市场份额统计数据来自于*Statcounter Global Stats*网站，针对的是各种桌面操作系统。
- en: Well, kind of. That’s because many years ago when I first created this demo
    for a shell scripting class that I was teaching, the Statcounter people broke
    down the Windows share by its different versions, as you see here. Now though,
    they only list the overall Windows market share in this combined report, and break
    down the market share for the various versions of Windows in a separate Windows-only
    report. So, I had to doctor up this file a bit to recreate how the report used
    to be so that the demo can work. (But hey, whatever works, right?) The demo script
    for this is the `report_os.sh` script, which you can also download from Github.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，有点像是这样。因为很多年前，当我首次为我教的Shell脚本课程创建这个演示时，Statcounter的人们把Windows市场份额按不同版本进行了划分，如你所见。但现在，他们只在这份综合报告中列出Windows的总体市场份额，并在单独的Windows-only报告中细分Windows各版本的市场份额。所以，我不得不稍微修改一下这个文件，以重现以前的报告方式，使得演示能继续进行。（不过，管它怎么做，只要有效就好，对吧？）这个演示的脚本是`report_os.sh`，你也可以从Github下载。
- en: 'The first `echo` command in the script is what adds the market share for all
    of the various versions of Windows together, in order to calculate the total combined
    market share for Windows. Here’s how that looks:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中的第一个`echo`命令会将所有版本的Windows市场份额加总，以计算Windows的总市场份额。以下是显示方式：
- en: '[PRE53]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: So, after I cut the second field out of all of the Windows lines, I use `paste`
    in serial mode, with the `+` as the `paste` field delimiter. I’ll pipe all that
    into `bc` and then redirect the output to a text file with today’s date in the
    filename.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在我从所有 Windows 行中提取出第二字段之后，我使用 `paste` 以串行模式，并使用 `+` 作为 `paste` 字段分隔符。我将所有内容通过管道传输给
    `bc`，然后将输出重定向到一个以今天日期命名的文本文件中。
- en: 'The `echo` commands for the rest of the operating systems are more straightforward,
    since they don’t require any math calculations. Here’s the one for macOS:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 其余操作系统的 `echo` 命令更加简单，因为它们不需要进行数学计算。以下是 macOS 的命令：
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Yes, I do know that Apple changed the name of their operating system to macOS.
    But, the Statcounter people still list it as OS X, so that’s what I need for the
    search term in the script. Anyway, running the script looks like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道苹果将他们的操作系统更名为 macOS。但是，Statcounter 的人们仍然将其列为 OS X，所以我需要在脚本中使用这个作为搜索词。无论如何，运行脚本的命令是这样的：
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The resultant report file looks like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 结果报告文件如下所示：
- en: '[PRE56]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When I doctored the input file to have it list the various versions of Windows,
    I took care to ensure that the total Windows share still adds up to what it’s
    supposed to be. So yes, as I’m writing this in October 2023, the total Windows
    market share really is 69.73%.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我修改输入文件以列出各种版本的 Windows 时，我确保 Windows 的总市场份额仍然符合预期。所以，是的，当我在 2023 年 10 月写这篇文章时，Windows
    的市场份额确实是 69.73%。
- en: 'By the way, if you’re interested in seeing more statistics about operating
    system usage, check out the Statcounter Global Stats site here: [https://gs.statcounter.com/](https://gs.statcounter.com/)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，如果你有兴趣查看更多关于操作系统使用的统计信息，请访问 Statcounter Global Stats 网站：[https://gs.statcounter.com/](https://gs.statcounter.com/)
- en: I do believe that this about covers it for shell scripting math. Let’s summarize
    and move on.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这已经涵盖了 shell 脚本数学运算的内容。让我们总结一下并继续前进。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I’ve shown you several ways to perform math operations in `bash`,
    and even provided a couple of tips on how to ensure that your math scripts can
    run on non-`bash` shells. I started with the various methods of performing integer
    math, and then showed you various ways to use `bc` to perform floating point math.
    As I said before, you’d need to be a math expert to take full advantage of all
    of `bc`'s features. But, even if you aren’t, there’s still a lot you can do with
    it. And, there are plenty of math tutorials online that can help. Just use your
    favorite search engine to find them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我向你展示了几种在 `bash` 中进行数学运算的方法，并提供了一些技巧，帮助你确保你的数学脚本可以在非 `bash` 的 shell 中运行。我从执行整数运算的各种方法开始，然后展示了使用
    `bc` 进行浮点数运算的多种方法。正如我之前所说，你需要成为数学专家，才能充分利用 `bc` 的所有功能。但即使你不是数学专家，依然能做很多事情。而且，网上有很多数学教程可以帮助你。只需使用你喜欢的搜索引擎找到它们。
- en: In the next chapter, I’ll show you how to use here documents. I’ll see you there.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将向你展示如何使用 here 文档。到时见。
- en: Questions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following methods would you used to perform integer math from the
    command-line?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种方法可以在命令行中执行整数运算？
- en: '`echo 1+1`'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`echo 1+1`'
- en: '`echo 1 + 1`'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`echo 1 + 1`'
- en: '`echo $(bc 1+1)`'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`echo $(bc 1+1)`'
- en: '`expr 1+1`'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`expr 1+1`'
- en: '`expr 1 + 1`'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`expr 1 + 1`'
- en: You want to ensure that your shell script works on `bash`, as well as on non-`bash`
    shells. Which of the following commands could you use in your script?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你希望确保你的 shell 脚本不仅能在 `bash` 上运行，还能在非 `bash` 的 shell 上运行。以下哪些命令可以在你的脚本中使用？
- en: '`echo $((1+2+3+4))`'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`echo $((1+2+3+4))`'
- en: '`echo $[1+2+3+4]`'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`echo $[1+2+3+4]`'
- en: '`echo $[[1+2+3+4]]`'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`echo $[[1+2+3+4]]`'
- en: '`echo $(1+2+3+4)`'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`echo $(1+2+3+4)`'
- en: You want to perform floating point math. Which of the following commands would
    you use?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想进行浮点数运算。以下哪些命令可以使用？
- en: '`bc`'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bc`'
- en: '`bc -f`'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bc -f`'
- en: '`bc -l`'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bc -l`'
- en: '`bc --float`'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bc --float`'
- en: You need to find the natural logarithm of 8\. How would you do it?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要找到 8 的自然对数。你该如何做？
- en: '`expr log(8)`'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`expr log(8)`'
- en: '`echo [log(8)]`'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`echo [log(8)]`'
- en: Use `l(8)` with `bc`
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `l(8)` 和 `bc`
- en: Use `log(8)` with `bc`
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `log(8)` 和 `bc`
- en: Which of these commands would you use to find the approximate value of П?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令可以用来找到 П 的近似值？
- en: '`pi=$("scale=10; 4*a(1)" | bc -l)`'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pi=$("scale=10; 4*a(1)" | bc -l)`'
- en: '`pi=$(echo "scale=10; 4*a(1)" | bc -l)`'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pi=$(echo "scale=10; 4*a(1)" | bc -l)`'
- en: '`pi=$(bc -l "scale=10; 4*a(1)" )`'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pi=$(bc -l "scale=10; 4*a(1)" )`'
- en: '`pi=$(echo "scale=10; 4*arc(1)" | bc -l)`'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pi=$(echo "scale=10; 4*arc(1)" | bc -l)`'
- en: Further Reading
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Bash Math Operations (Bash Arithmetic) Explained: [https://phoenixnap.com/kb/bash-math](https://phoenixnap.com/kb/bash-math)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash 数学运算（Bash Arithmetic）解析：[https://phoenixnap.com/kb/bash-math](https://phoenixnap.com/kb/bash-math)
- en: 'bc Command Manual: [https://www.gnu.org/software/bc/manual/html_mono/bc.html](https://www.gnu.org/software/bc/manual/html_mono/bc.html)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bc命令手册：[https://www.gnu.org/software/bc/manual/html_mono/bc.html](https://www.gnu.org/software/bc/manual/html_mono/bc.html)
- en: 'What is a good command-line calculator on Linux: [https://www.xmodulo.com/command-line-calculator-linux.html](https://www.xmodulo.com/command-line-calculator-linux.html)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux上使用什么是好的命令行计算器：[https://www.xmodulo.com/command-line-calculator-linux.html](https://www.xmodulo.com/command-line-calculator-linux.html)
- en: 'Geometry Cheat Sheet: [https://s3-us-west-1.amazonaws.com/math-salamanders/Geometry/Geometry-Information-Pages/Geometry-Cheat-Sheets/geometry-cheat-sheet-4-2d-shapes-formulas.pdf](https://s3-us-west-1.amazonaws.com/math-salamanders/Geometry/Geometry-Information-Pages/Geometry-Cheat-Sheets/geometry-cheat-sheet-4-2d-shapes-formulas.pdf)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何速查表：[https://s3-us-west-1.amazonaws.com/math-salamanders/Geometry/Geometry-Information-Pages/Geometry-Cheat-Sheets/geometry-cheat-sheet-4-2d-shapes-formulas.pdf](https://s3-us-west-1.amazonaws.com/math-salamanders/Geometry/Geometry-Information-Pages/Geometry-Cheat-Sheets/geometry-cheat-sheet-4-2d-shapes-formulas.pdf)
- en: 'Mathematics LibreTexts: [https://math.libretexts.org/](https://math.libretexts.org/)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学LibreTexts：[https://math.libretexts.org/](https://math.libretexts.org/)
- en: 'Statcounter Global Stats: [https://gs.statcounter.com/](https://gs.statcounter.com/)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Statcounter全球统计：[https://gs.statcounter.com/](https://gs.statcounter.com/)
- en: Answers
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: e
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: e
- en: a
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a
- en: c
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: c
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: b
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: Join our community on Discord!
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Linux专家以及作者本人一同阅读本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 提问、为其他读者提供解决方案、通过“问我任何问题”环节与作者聊天，等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
