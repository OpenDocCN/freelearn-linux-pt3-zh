- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: System Administration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike many professions, there is no single path to becoming a system administrator.
    Many **SysAdmins** have a degree in a wide range of fields: **computer science**,
    **systems engineering**, **Information Technology**, **software engineering**,
    **mechanical engineering**, **meteorology**, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Plus, given the hands-on nature of system administration, and the availability
    of open source server software, many SysAdmins enter this field on a self-taught
    basis. Generally, it requires some prior experience with the system expected to
    be managed. In some cases, SysAdmin candidates must hold a certificate before
    they can be considered for the position.
  prefs: []
  type: TYPE_NORMAL
- en: This profession becomes more difficult if you don’t have the habit of undertaking
    *best practices*.
  prefs: []
  type: TYPE_NORMAL
- en: But where do you learn them? Where are they written down?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we intend to clear up those doubts and help you on your way
    to becoming a **Linux** **system administrator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The three laws of the SysAdmin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A little bit of Git and programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t forget to back up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never-ending study
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the topics in this chapter, you will need to install the packages
    indicated in each section. In each section, you will find instructions for the
    different types of packages you will need to install.
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples for this chapter can be downloaded from this book’s **GitHub**
    repository: [https://github.com/PacktPublishing/Fedora-Linux-System-Administration/tree/main/chapter10](https://github.com/PacktPublishing/Fedora-Linux-System-Administration/tree/main/chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: The three laws of the SysAdmin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “*Because, if you stop to think of it, the three laws of robotics are the essential
    guiding principles of a good many of the world’s ethical systems. [...] To put
    it simply, if Byerley follows all the laws of robotics, he may be a robot, or
    may simply be a very* *good man.*”
  prefs: []
  type: TYPE_NORMAL
- en: '*Dr. Susan Calvin in Evidence from* *Isaac Asimov*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more than 20 years, I was a SysAdmin for different companies. In those
    years, some young people asked me what the best practices were and if could they
    apply them to consider themselves a good SysAdmin. Over the years, I have read
    different articles about these *best practices*: **Ethics Code for SysAdmins**,
    **The 10 Commandments of the SysAdmin**, and even **Fundamental Laws** **of Computing**.'
  prefs: []
  type: TYPE_NORMAL
- en: This job of becoming a platform SysAdmin is an arduous task that becomes complicated
    if we don’t get into the habit of applying best practices. But where do you learn
    them? Where are they written down?
  prefs: []
  type: TYPE_NORMAL
- en: One of the best philosophies, in my experience, is to follow the **KISS principle**
    and, based on it, simplify the recommendations into fundamental principles that
    help us develop our skills.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s provide an overview of this principle.
  prefs: []
  type: TYPE_NORMAL
- en: The KISS principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The KISS principle (an acronym for *Keep It Simple, Stupid!*) is a design principle
    that was outlined by the US Navy in 1960\. It states that most systems work better
    if they’re kept simple than if they become complicated. Thus, simplicity should
    be a key aim in design, and unnecessary complexity should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'A text attributed to *Leonardo Da Vinci* gives us a broad outline of the principle:'
  prefs: []
  type: TYPE_NORMAL
- en: “*Simplicity is the* *ultimate sophistication.*
  prefs: []
  type: TYPE_NORMAL
- en: '*When once you have tasted flight, you will forever walk the Earth with your
    eyes turned skyward, for there you have been, and there you will always long*
    *to return.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Learning never exhausts* *the mind.*”'
  prefs: []
  type: TYPE_NORMAL
- en: – *Leonardo* *da Vinci*
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, simple solutions are more effective. Over the years, I have seen
    young SysAdmins fall into applying complex solutions that lead to more issues.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on how to apply the KISS principle in code creation, refer
    to *The Kiss Principle* at [https://people.apache.org/~fhanik/kiss.html](https://people.apache.org/~fhanik/kiss.html).
  prefs: []
  type: TYPE_NORMAL
- en: Based on this, let me share with you the fundamental principles that guide me
    in my work as a SysAdmin.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how these fundamental principles originated, and then delve deeper
    into them.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the basic tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is from Wikipedia ([https://en.wikipedia.org/wiki/System_administrator](https://en.wikipedia.org/wiki/System_administrator)):'
  prefs: []
  type: TYPE_NORMAL
- en: “*A System Administrator is the person who handles implementing, configuring,
    maintaining, monitoring, documenting, and ensuring the proper functioning of a
    computer system, or some aspect* *of it.*”
  prefs: []
  type: TYPE_NORMAL
- en: Their purpose is to guarantee the *uptime*, *performance*, *resource usage*,
    and *security* of the servers that they manage.
  prefs: []
  type: TYPE_NORMAL
- en: They have different roles, such as *server administrator*, *database administrator*,
    *network administrator*, *email server administrator*, *web server administrator*,
    *security administrator*, *backup administrator*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the role, the tasks change, but they converge on fundamental points.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the most basic point, which is to *always use the command-line
    interface*. As mentioned in [*Chapter 1*](B19121_01_split_000.xhtml#_idTextAnchor014),
    the Terminal is the primary tool for operating system administration. Its use
    extends the capabilities of system administration and operation.
  prefs: []
  type: TYPE_NORMAL
- en: From my own experience, *any productive system will fail one day*, no matter
    how many precautions we have provided or maintenance we’ve undertaken. The best
    solution is to prepare for that day with a valid backup.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do not know what is critical in our system, then we should investigate
    what is critical and, thus, plan to have a backup. How do we know that a backup
    will serve us in case of disaster? Here are some questions you should ask when
    planning:'
  prefs: []
  type: TYPE_NORMAL
- en: What software (or script) is used for backing up?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much space do we have for backups (internal and external, on disk, or on
    tape)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How often should we rotate the backups?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of the total backup (full backup), do we need incremental backups?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have a clear idea of how we make the backup, we must take the necessary
    time to verify it. Although we have a good plan for creating backups, this does
    not mean that they won’t be corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up, and how often we do it, is *the most basic and generic task* in
    all types of system administration.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of backup solutions allow us to handle this task via the command
    line. Thanks to this facility, the task could become *automated*, like many others.
    Automating tasks streamlines SysAdmins’ work.
  prefs: []
  type: TYPE_NORMAL
- en: The statement *Lazy SysAdmin is the best SysAdmin* is well known. This means
    that if you are proactive enough to automate all processes, you will have a lot
    of *free time* and be considered lazy. The best SysAdmin never seems to be very
    busy and prefers relaxing and letting the system do the work for them. *Work smarter,*
    *not harder*.
  prefs: []
  type: TYPE_NORMAL
- en: But the free time we can get from *automating processes* should be used productively
    – maybe by studying some new language or emerging technologies we haven’t mastered
    (Perl, Python, Kubernetes, and so on) or optimizing some script to turn it into
    an *orchestration*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the evolution of these principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Fundamental principles](img/B19121_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Fundamental principles
  prefs: []
  type: TYPE_NORMAL
- en: Following these basic principles helped me improve many systems administration
    skills. Although they do not cover all aspects of systems administration per se,
    they create good habits that could develop many skills needed for this job.
  prefs: []
  type: TYPE_NORMAL
- en: 'These principles constitute my *fundamental laws of effective management* –
    that is, my three laws of the SysAdmin:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Back up**: A SysAdmin must back up the entire system and always verify the
    backup'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automate**: A SysAdmin should automate as much as possible, except if it
    conflicts with the first law'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Study**: A SysAdmin must have free time to study, so long this free time
    does not conflict with the first or second law'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we dive deep into each of the laws of system administration, let’s take
    a quick look at a couple of indispensable tools for implementing them.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll look at programming and version management.
  prefs: []
  type: TYPE_NORMAL
- en: A little bit of Git and programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typical system administration tasks involve command-line tools. Tasks of greater
    complexity often need to chain several commands and share the results with each
    other. Linux commands can be combined to solve repetitive and difficult tasks
    using the Bash shell environment and basic programming functions.
  prefs: []
  type: TYPE_NORMAL
- en: As a command interpreter and a programming language in its own right, the Bash
    shell environment allows you to run routines and use expressions, besides running
    other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: These routines simplify the lists of commands, which can be included in a file
    called a *Bash script*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll learn how to create Bash scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Bash scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Bash scripting* consists of programming using commands as the program’s instructions.
    This strategy automates repetitive tasks, reducing them to a single line through
    expressions such as logic gates, conditions, loops, and so on. Thus, it facilitates
    the consolidation of several long commands into a *single piece of code* *to run*.'
  prefs: []
  type: TYPE_NORMAL
- en: It provides a structured, formatted, and modular sequence of activities, as
    well as commands with dynamic values through the use of command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: In its simplest form, a Bash script consists of a runnable file containing a
    list of commands, and with programming logic to control decision-making in the
    task. Skill in shell scripting is essential for administering systems in any operating
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a lot of literature and many references on how to write a Bash script
    in the best way. However, by following the principle of simplicity mentioned at
    the beginning of this chapter, it could summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[**1**] **she-bang** or **sh-bang**: The first line of a script starts with
    the **#!** notation. This is a *two-byte magic number* that indicates an interpretative
    script. The syntax that follows is the name of the command interpreter needed
    to run the lines of this script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To understand how magic numbers indicate file types in Linux, refer to the **file(1)**
    and **magic(5)** man pages.
  prefs: []
  type: TYPE_NORMAL
- en: '[**2**] **IDENTIFICATION**: The identification section of the script is essential
    and indispensable. This is the documentation of the script and includes the description
    of the routines run, as well as the version and even the author’s details and
    license of use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**3**] **VARIABLES**: This section declares the variables that run the script
    during its operation. The variables store information in the system’s memory.
    The script uses local variables. These variables store information for short periods.
    Local variables exist and are valid only for the shell or session in which the
    script runs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**4**] **COMMANDS**: This section lists the routines and commands to run.
    It also includes functions used to specify *run* commands in specific situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see an example of a Bash script. Create a script that covers the following
    routines:'
  prefs: []
  type: TYPE_NORMAL
- en: Name the file **mytasks.sh**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a *working directory* named **class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Concatenate the following files as a **data** file in the working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**/****etc/passwd**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/****etc/group**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/****etc/shadow**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create the following users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**John**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Peter**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mark**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **data** file to the users’ home.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate an *activity log*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The routines are simple: creating a *working directory* gives the administrator
    a single point of consolidation of working files. This makes backing up much easier.
    And, from system files, we create a data file, which must exist in each of the
    users’ home directories – the same users that, if they do not exist in the system,
    must create them. All routines and activities performed by the Bash script should
    be recorded in the log for documentation purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: The Bash script involves creating users, so the user running the script must
    have the *appropriate privileges* to do so. One of the best options is to use
    the `sudo` command. Then, you can grant the *non-root user* the privilege to create
    users and assign the permissions needed to the files involved in the activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this example a little simpler, we’ll use the `root` user. To switch
    to the `root` user, use the `sudo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the Bash script, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create and change to the **class** working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use your preferred text editor to create the **mytasks.sh** script file. In
    this example, we will use the **vim** editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As a **she-bang**, add the **#!/****bin/bash** line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Creating the mytasks.sh script](img/B19121_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Creating the mytasks.sh script
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the **IDENTIFICATION** section with descriptive information about the
    script routine, including the version and the author of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Script identification section](img/B19121_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Script identification section
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **VARIABLES** section, we need to declare the static information, which
    won’t change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The path and name of the **class** working directory:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The path and name of **DATA_FILE**:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the command section, test the use of variables and how tasks are logged
    and run by creating the **data** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start recording a header with symbols to separate the activities in **log**:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about kernel log levels, refer to the **syslog(2)** man page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Record the first activity – that is, creating the data file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This same first activity can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – The first version of mytasks.sh](img/B19121_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – The first version of mytasks.sh
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s test this first version of the Bash script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set *run rights* to the **mytasks.sh** script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.5 – Setting run rights to mytasks.sh](img/B19121_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Setting run rights to mytasks.sh
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the **mytasks.sh** script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify the creation of the **data** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Verifying the data file](img/B19121_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Verifying the data file
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that activities are recorded in the **log** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Verifying the log file](img/B19121_10_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Verifying the log file
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the `data` file was created and the activities were recorded
    in the `log` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the users. However, note that every time the Bash
    script runs, the `data` file must be created. Before continuing, now is a good
    time to add a validation:'
  prefs: []
  type: TYPE_NORMAL
- en: If the **data** file exists, continue with the following instruction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the **data** file is not present, then you can create it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For validation, use an `COMMANDS` section, add the following `if-else` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: for i in passwd group shadow
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: do
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cat /etc/$i >> $DATA_FILE
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for loop in Bash is a statement that allows code to run repeatedly.The `COMMANDS`
    section looks as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.8 – The COMMANDS section of mytasks.sh](img/B19121_10_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – The COMMANDS section of mytasks.sh
  prefs: []
  type: TYPE_NORMAL
- en: Save the changes and test them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the run in the **log** file record:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Verifying the run on the log file](img/B19121_10_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Verifying the run on the log file
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the **data** file and rerun the **mytasks.sh** script to confirm the
    creation of the **data** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.10 – Validating the creation of the data file](img/B19121_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Validating the creation of the data file
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this change worked, the version of the Bash script could change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 10.11 – Modifying the version of mytasks.sh](img/B19121_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Modifying the version of mytasks.sh
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue by adding the routine activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The routine includes creating users and copying the `data` file to their home
    directories. Here, a combination of statements and loops is used so that the script
    can be reused every time extra users are added to it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by recording the activity in the **log** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a **for** loop to confirm the users and the **data** file in their home
    directories. Instead of adding the usernames to the script, instruct the loop
    to take the reading of a **users** file as input. So, add the **users** file to
    the **VARIABLES** section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the **users** file with the requested usernames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.12 – The users file](img/B19121_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – The users file
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `data` file to the user’s home directory. Alternatively, you can copy
    the `data` file to its home directory, in case the user exists but the `data`
    file doesn’t. This statement takes the form of a *nested* *if statement*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.13 – A nested if statement](img/B19121_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – A nested if statement
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the **mytasks.sh** script and confirm that the users were created and that
    the **data** file was copied to their home directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Testing user creation and data file copying](img/B19121_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Testing user creation and data file copying
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerun the test for user creation and data file copy to confirm the condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Creation and copy condition confirmed](img/B19121_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Creation and copy condition confirmed
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the **lucas** user to the **user** file and run the **mytasks.sh** script
    to confirm the creation of the user and that the **data** file was copied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Adding the lucas user](img/B19121_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Adding the lucas user
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script and review the **log** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Reviewing user creation and copying the data file](img/B19121_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Reviewing user creation and copying the data file
  prefs: []
  type: TYPE_NORMAL
- en: 'The nested **if** statement works and results in the version of the script
    being changed. Since this is a working version that meets the needs of the routine,
    this makes it the first version of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the **mytasks.sh** script in this book’s GitHub repository at [https://github.com/PacktPublishing/Fedora-Linux-System-Administration/tree/main/chapter10/](https://github.com/PacktPublishing/Fedora-Linux-System-Administration/tree/main/chapter10/).
  prefs: []
  type: TYPE_NORMAL
- en: 'This small script exemplifies how to simplify routine day-to-day tasks. If
    you have any doubts about whether a routine could be a Bash script, remember one
    of the most well-known statements among SysAdmins:'
  prefs: []
  type: TYPE_NORMAL
- en: “*If you typed it twice, you should have scripted* *it once.*”
  prefs: []
  type: TYPE_NORMAL
- en: The problems come when you’re modifying the scripts and managing their versions.
  prefs: []
  type: TYPE_NORMAL
- en: A tool that could help us when we need to manage different versions of scripts
    or configuration files is Git.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn a little bit about this tool.
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Git** is a form of control version software designed by *Linus Torvalds*
    and released in 2007\. It maintains versions of applications, prioritizes *efficiency*,
    *reliability*, and *compatibility*, and provides a record of changes to the files.
    It also coordinates the work that several people do on shared files in a code
    repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Git has supported the growth of open source software in recent years, making
    collaboration between programmers around the world easier.
  prefs: []
  type: TYPE_NORMAL
- en: Version control allows you to record changes that have been made to a file or
    set of files over time so that specific versions can be retrieved later.
  prefs: []
  type: TYPE_NORMAL
- en: Git is a *distributed version control system*. Besides the central repository,
    the clients replicate the entire repository, including its complete history. Thus,
    if a server fails, any of the repository clients could get copied back to the
    server to restore it. Each clone is a complete backup of all data.
  prefs: []
  type: TYPE_NORMAL
- en: '**GitLab** and **GitHub** provide the most important *Git-based* web services.
    Each of them allows us to share repositories of our projects, both *private* *and
    public*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To access GitHub, use your preferred browser and navigate to [https://github.com/login](https://github.com/login).
    Log in or create your account by following the instructions on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – GitHub login page](img/B19121_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – GitHub login page
  prefs: []
  type: TYPE_NORMAL
- en: 'To access GitLab, use your preferred browser and navigate to [https://gitlab.com/users/login](https://gitlab.com/users/login).
    Log in or register to create your account by following the instructions on the
    page. Also, consider signing in using other web services such as **Google**, **GitHub**,
    **Twitter**, **Bitbucket**, or **Salesforce** for authentication. Each service
    will ask you if you want GitLab to access your account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19 – GitLab – The Sign in page](img/B19121_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 – GitLab – The Sign in page
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to work with Git. We use a local repository, but it could
    live on a dedicated server or a web service platform.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The examples that follow illustrate how to use Git, so the public repository
    on the web could use either of the two free services. *Choose wisely*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the basics.
  prefs: []
  type: TYPE_NORMAL
- en: The basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git handles files as a set of snapshots of a mini filesystem. Most operations
    in Git only need local files and resources to work. Everything in Git gets verified
    before storage. Therefore, it is identified by a *checksum* (as an identification
    number). Git generally adds information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Git has three main states that files come in: *modified*, *staged*, and *committed*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modified** means that the file has changed but the changes have not been
    committed to the database yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Staged** means that a modified file, in its current version, gets marked
    to go to the next commit instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Committed** means that the changes are stored in the local database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure illustrates the state changes of a file within Git:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 10.20 – File state change flow in \uFEFFGit](img/B19121_10_20.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 – File state change flow in Git
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B19121_02.xhtml#_idTextAnchor087), we installed Git on our
    workstation. Let’s set up our session and create a sample repository. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a *non-root user*, set up a username and associate it with an email address.
    This data gets saved with the changes that are made. Use the **git** **config**
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a directory and switch to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the directory as a **git** repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `git-basics` directory is now a `git` repo, so it might contain one of
    the states mentioned previously:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.21 – The git-basics directory](img/B19121_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.21 – The git-basics directory
  prefs: []
  type: TYPE_NORMAL
- en: To be able to see the state of the repository, add a custom configuration in
    the user’s profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines to the **.bashrc** file of the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.22 – Adding git-prompt to the .bashrc file](img/B19121_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.22 – Adding git-prompt to the .bashrc file
  prefs: []
  type: TYPE_NORMAL
- en: 'After saving this change to the **.bashrc** file, return to the **git-basics**
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.23 – git-basics](img/B19121_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.23 – git-basics
  prefs: []
  type: TYPE_NORMAL
- en: Note that the prompt now shows the initial branch of the repo, which is named
    `master`.
  prefs: []
  type: TYPE_NORMAL
- en: '`master` is the initial name of the branch by default. Before we start adding
    files, let’s rename the branch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **git branch** command to change the branch’s name from **master**
    to **main**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.24 – Renaming the initial branch](img/B19121_10_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.24 – Renaming the initial branch
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to add files to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Python script called **my-script.py** with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upon running this script, you will asked for your name and you’ll see a welcome
    message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After saving the file, review the status of the repository by running the **git**
    **status** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.25 – Reviewing the status of the repository](img/B19121_10_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.25 – Reviewing the status of the repository
  prefs: []
  type: TYPE_NORMAL
- en: The output of the command shows that the repository has changed. Note that some
    files are not *tracked* until their status changes.
  prefs: []
  type: TYPE_NORMAL
- en: At the *prompt*, you should now see the `%` symbol, which indicates that a file
    has been added to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some other symbols that were added to the prompt concerning the
    repository’s status:'
  prefs: []
  type: TYPE_NORMAL
- en: Unstaged (*****)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Staged (**+**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about **git-prompt**, refer to the documentation of the **git-prompt.sh**
    script at **/usr/share/git-core/contrib/completion/git-prompt.sh**.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s change the repository’s status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **git add** command to add the file to the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.26 – Changing the repository’s status](img/B19121_10_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.26 – Changing the repository’s status
  prefs: []
  type: TYPE_NORMAL
- en: Now, the repository’s status appears as `staged`, and the prompt displays the
    respective symbol (`+`).
  prefs: []
  type: TYPE_NORMAL
- en: Before we store the changes in the database, we need to test the file and review
    that no other changes need to be made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the **my-script.py** script and verify that it works fine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.27 – Testing the my-script.py script](img/B19121_10_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.27 – Testing the my-script.py script
  prefs: []
  type: TYPE_NORMAL
- en: Since the script ran successfully, let’s commit to adding the file to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **git commit** command to change the status of the branch to **committed**
    so that you can apply the change that was made to the repository. This command
    supports adding a comment. This comment helps notify you about the modifications
    that are made in the repository by providing a brief description of the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ git log
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.28 – Committing and reviewing the repository’s history](img/B19121_10_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.28 – Committing and reviewing the repository’s history
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you have doubts about how to add a good commit message, please visit the
    online resource *Conventional Commits* at [https://www.conventionalcommits.org/](https://www.conventionalcommits.org/).
  prefs: []
  type: TYPE_NORMAL
- en: With these simple steps, our script repository has *version control* and is
    managed by Git.
  prefs: []
  type: TYPE_NORMAL
- en: Having a repository that contains the scripts that are used for daily tasks,
    aside from acting as a backup, can be turned into a collaborative resource for
    our area. If we wish to publish it on a web platform, we need to *remove sensitive
    data* from it so that we can turn it into a valuable resource for the community.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to publish both script directories in a public repository
    on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For this example, I’m using a repository on GitHub, but it could be created
    the same way on any *Git-based web platform* of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the repository on any web platform, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log into the web platform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.29 – Web platform dashboard](img/B19121_10_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.29 – Web platform dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Click on the plus (**+**) button and click on **New repository**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Create a new repository** screen will appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.30 – The Create a new repository screen](img/B19121_10_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.30 – The Create a new repository screen
  prefs: []
  type: TYPE_NORMAL
- en: Enter the repository’s name and a brief description of its use. Leave the repository
    set to **Public** and choose to **Add a README file**. This file provides a welcome
    message or a detailed description of the repository’s usage.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re finished, click **Create repository**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The repository will be created. Click the **Code** button and copy the **HTTPS**
    address of the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.31 – Public repository](img/B19121_10_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.31 – Public repository
  prefs: []
  type: TYPE_NORMAL
- en: Let’s copy the remote repository as local.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a working directory and switch to it. Use the **git clone** command
    to download a copy of the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.32 – Cloning the repository](img/B19121_10_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.32 – Cloning the repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the repository, verify the *main branch*, and review the files contained
    within:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.33 – Verifying the repository](img/B19121_10_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.33 – Verifying the repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the directory of the Bash script example and the preceding example script
    into this directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.34 – The daily-tasks-scripts repository](img/B19121_10_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.34 – The daily-tasks-scripts repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Before adding the files with Git, note that the `class` directory, from the
    Bash script, has some ownership issues. Also, take note of the `log` file, which
    is not needed in the repository but is created when the script is run. The `users`
    file contains *sensitive information* about the users that have been created.
    Both files must remain, but their contents must be restarted (this is referred
    to as *blanking*). Fix these issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.35 – Fixing issues](img/B19121_10_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.35 – Fixing issues
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example directory, `git-basics`, is also a repository. Remove
    the hidden `.git` directory inside it so that Git doesn’t take it as a *submodule*
    of the main repository. A backup of our scripts is all we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.36 – Removing the .git directory](img/B19121_10_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.36 – Removing the .git directory
  prefs: []
  type: TYPE_NORMAL
- en: With the files ready, let’s add them to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **git add** command to add all the files to the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit the changes to the repository by adding the corresponding comment. Then,
    run the **git** **commit** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.37 – Committing changes to the repository](img/B19121_10_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.37 – Committing changes to the repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s synchronize the *local changes* with the *remote repository*. Set the
    *original repository* as the *upstream repository* to reference it. Use the **git
    push** command to set up the upstream repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.38 – Pushing changes to the repository](img/B19121_10_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.38 – Pushing changes to the repository
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The authentication for the repository depends on the web platform in use. In
    the case of GitHub, it requests a *token*. To generate one, go to **Settings**
    | **Developer settings** | **Personal access token** | **Generate new token**
    and copy it to a safe place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modified files will appear on the web platform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.39 – The repository on GitHub](img/B19121_10_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.39 – The repository on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have a collaborative repository of the scripts that will be used
    in our day-to-day tasks.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, the repository serves as a backup of our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a walk through the alternatives that could help us make a backup.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to back up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Back up: A SysAdmin must back up the entire system, and always verify* *the
    backup.*'
  prefs: []
  type: TYPE_NORMAL
- en: Backing up is the most basic task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Good practice begins with good habits. One of the habits that I have made over
    the years is to back up a file before editing it, either in the file path or by
    creating a backup directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.40 – Backing up before modifying](img/B19121_10_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.40 – Backing up before modifying
  prefs: []
  type: TYPE_NORMAL
- en: On the surface, it doesn’t seem like a big task. However, if you incorporate
    this step into your tasks, then you have a simple backup of the files that you
    work with.
  prefs: []
  type: TYPE_NORMAL
- en: Besides copying files to change, another good habit is to create a package that
    contains archives or compressed files.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Archiving and compression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, note the difference between an **archive** file and a **compressed**
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: An **archive** file consists of *files and directories* stored in a single file.
    The archive file remains uncompressed – it uses the same disk space as all the
    individual files and directories are combined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **compressed** file also consists of files and directories stored in a single
    file. However, they are stored in such a way that they use less disk space than
    all the individual files and directories combined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An archive file itself is not compressed, but a compressed file could contain
    an archive file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux provides several utilities for compressing and decompressing files. The
    following table shows the most used utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Utility** | **Syntax** | **Examples** |'
  prefs: []
  type: TYPE_TB
- en: '| `gzip` | `gzip <file>``gunzip <file>` | `$` `gzip test``$` `gunzip test.gz`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bzip2` | `bzip2 <file>``bunzip2 <file>` | `$` `bzip2 test``$` `bunzip2 test.bz2`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `xz` | `xz <file>``xz -``d <file>` | `$` `xz test``$ xz -``d test.xz` |'
  prefs: []
  type: TYPE_TB
- en: '| `zip` | `zip .``zip-file <file>``unzip <.zip-file>` | `$ zip` `test.zip test``$`
    `unzip test.zip` |'
  prefs: []
  type: TYPE_TB
- en: Table 10.1 – Compress and decompress utilities
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the difference between the utilities in the compression algorithms
    that are used by each:'
  prefs: []
  type: TYPE_NORMAL
- en: The **gzip** utility compresses the size of files using **Lempel-Ziv** (**LZ77**)
    encoding. Each file gets replaced by one with the **.****gz** extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bzip2** compresses files using the *Burrows-Wheeler* block-sorting text compression
    algorithm and *Huffman encoding*. Each file gets replaced with another file with
    the **.****bz2** extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**xz** uses the **Lempel-Ziv-Markov chain algorithm** (**LZMA**) for compression/decompression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **.zip** format uses a *32-bit CRC algorithm*. It includes two copies of
    the metadata for each entry to provide greater protection against data loss.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about compression utilities, refer to the **gzip**, **bzip2**,
    **xz**, and **zip** man pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practical use cases, compression utilities share the same goal: *to reduce
    the space usage* of the file in question. Beyond the algorithm, what needs to
    be considered is the size of space usage that the file reduces. This is due to
    portability reasons. The following illustrative example shows the differences
    practically. However, note that more compression or decompression requires more
    resources (CPU and memory).'
  prefs: []
  type: TYPE_NORMAL
- en: Another best practice habit is to *compress* backups so that any space that’s
    used doesn’t become an issue. This can also be enhanced if we compress file archives.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, we can use the `tar` tool to create, manage, and extract archive files.
    With this command, many files that are stored in a single archive file become
    portable. A `tar` archive is a structured sequence of metadata and file data with
    an index.
  prefs: []
  type: TYPE_NORMAL
- en: Archives might be compressed when they’re created using one of the supported
    compression algorithms. Besides creating archive files, the `tar` command provides
    further options, such as listing the contents of an archive without extracting
    it or extracting files from compressed and uncompressed archives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tar` command’s options provide us with *three* *different styles*:'
  prefs: []
  type: TYPE_NORMAL
- en: In the *traditional style*, the first argument is a group of option letters,
    and the arguments that follow supply arguments to those options that need them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *UNIX or short option style*, each option letter comes preceded by a
    single hyphen (**-**). If an option has an argument, the argument follows it,
    either as a separate word on the command line or immediately after the option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *GNU or long option style*, each option begins with two hyphens (**--**)
    and has a meaningful name, consisting of lowercase letters and hyphens. The long
    option could be abbreviated to its initial letters. Long option arguments are
    supplied as separate words on the command line, immediately following the option,
    or separated from the option by an equals (**=**) sign with no intervening whitespace.
    Optional arguments should always use the latter method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `tar` command requires an action with at least one option. The most common
    actions and options are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Description** | **Traditional Style** | **Short Style** | **Long Style**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Creates an archive file | `c` | `-c` | `--``create` |'
  prefs: []
  type: TYPE_TB
- en: '| Lists the content of an archive file | `t` | `-t` | `--``list` |'
  prefs: []
  type: TYPE_TB
- en: '| Extracts an archive file | `x` | `-x` | `--``extract` |'
  prefs: []
  type: TYPE_TB
- en: '| Shows the currently archived or extracted files | `v` | `-v` | `--``verbose`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Use this option with the name of the file to create or open | `f` | `-f`
    | `--``file` |'
  prefs: []
  type: TYPE_TB
- en: '| Keeps the original permissions of the files by extracting them | `p` | `-p`
    | `--``preserve-permissions` |'
  prefs: []
  type: TYPE_TB
- en: '| Uses the file suffix to determine the algorithm to use for compression |
    `a` | `-a` | `--``auto-compress` |'
  prefs: []
  type: TYPE_TB
- en: '| Uses the `gzip` compression algorithm | `z` | `-z` | `--``gzip` |'
  prefs: []
  type: TYPE_TB
- en: '| Uses the `bzip2` compression algorithm | `j` | `-j` | `--``bzip2` |'
  prefs: []
  type: TYPE_TB
- en: '| Uses the `xz` compression algorithm | `J` | `-J` | `--``xz` |'
  prefs: []
  type: TYPE_TB
- en: '| Uses an LZ-variant algorithm | `Z` | `-Z` | `--``compress` |'
  prefs: []
  type: TYPE_TB
- en: '| Enables extended attribute support and stores file-extended attributes |
    NA | NA | `--``xattrs` |'
  prefs: []
  type: TYPE_TB
- en: '| Enables SELinux context support and stores SELinux contexts | NA | NA | `--``selinux`
    |'
  prefs: []
  type: TYPE_TB
- en: Table 10.2 – Common tar command actions and options
  prefs: []
  type: TYPE_NORMAL
- en: Let’s analyze an example of how to create an archive of compressed files with
    two different compression algorithms so that we can compare the space that’s used.
  prefs: []
  type: TYPE_NORMAL
- en: As a non-root user, in our backup directory, use the `tar` command to create
    an archive file of the day-to-day script repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, use the **gzip** compression algorithm option. Run the following **tar**
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.41 – Creating an archive with the tar command](img/B19121_10_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.41 – Creating an archive with the tar command
  prefs: []
  type: TYPE_NORMAL
- en: 'Now use the **bzip2** compression algorithm and create the file archive from
    the same directory by running the following **tar** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.42 – Using the bzip2 compression algorithm with the tar command](img/B19121_10_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.42 – Using the bzip2 compression algorithm with the tar command
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the size of both file archives to compare the compression rate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.43 – Comparing file sizes](img/B19121_10_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.43 – Comparing file sizes
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the repository’s directory size is `42272` bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: $ du -sb daily-tasks-scripts.bkp.tar.gz
  prefs: []
  type: TYPE_NORMAL
- en: 'bzip2 algorithm, is 18594 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at what this means:'
  prefs: []
  type: TYPE_NORMAL
- en: The **gzip** compression algorithm reduced the size of the repository by 44.82%
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **bzip2** compression algorithm reduced the size of the repository by 43.98%
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The difference is minimal, and these are the most used formats for backups.
    It is up to you to decide which one to use – just remember: *don’t forget to*
    *back up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about archiving files, refer to the **tar** man page.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the previous section, the Git repository also helps us back
    up the information contained in it. It also provides us with a snapshot of the
    data at the time it was taken.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s learn how to manage versions with Git.
  prefs: []
  type: TYPE_NORMAL
- en: Version management with Git
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn how Git handles versioning, we’ll use the example from the previous
    section. As a *non-root user*, switch to the `daily-tasks-scripts` repository
    directory and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a good habit, ensure that the local repository keeps updated and in sync
    with the remote repository before starting. Use the **git fetch** and **git pull**
    commands to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.44 – Keeping the repository updated and in sync](img/B19121_10_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.44 – Keeping the repository updated and in sync
  prefs: []
  type: TYPE_NORMAL
- en: The `git fetch` command extracts all the data from a remote project that doesn’t
    already exist locally. The `git fetch` command only downloads the data to the
    local repository – it doesn’t merge it or change anything you’re currently working
    on. The changes have to be merged manually.
  prefs: []
  type: TYPE_NORMAL
- en: The `git pull` command incorporates changes from a remote repository into the
    current branch of the local repository.
  prefs: []
  type: TYPE_NORMAL
- en: As another good practice, Git gives you the option to branch the repository.
    Branching means deviating from the main line of development and continuing to
    work without altering that main line.
  prefs: []
  type: TYPE_NORMAL
- en: To change the repository without altering its original content, let’s create
    a branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the enhancement branch of the **daily-tasks-scripts** repository. Use
    the **git branch** command and the appropriate branch name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Include the author of the changes in the *branch name* as good practice.
  prefs: []
  type: TYPE_NORMAL
- en: The `git branch` command only creates the branch. To switch to it, use the `git
    switch` command and the branch’s name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both commands can be combined to create the branch and switch to it. To do
    this, use the `git switch` command with the `-``c` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: $ git diff
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ git add README.md
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ git commit –m "Updating README.md file"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ git push –u origin acallejas/repo-enhancement
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ git branch
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ git branch -r
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ git branch -a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ /etc/ansible/ansible.cfg file, but as a best practice, create a custom file
    to get better control of automated tasks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ mkdir ansible; cd ansible
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[defaults]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inventory = inventory
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ssh-keygen -t rsa -b 2048
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ssh-copy-id -i id_rsa.pub localhost
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ssh -i id_rsa localhost
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[workstation]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: localhost
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[workstation:vars]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ansible_ssh_private_key_file=/home/acallejas/wdir/ansible/id_rsa
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ansible all -m ping
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ansible workstation -a "hostname"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: verify_webserver.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: $ ansible-playbook --syntax-check verify_webserver.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: $ ansible-playbook --syntax-check verify_webserver.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: $ ansible-playbook --check verify_webserver.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: $ ansible-playbook verify_webserver.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
