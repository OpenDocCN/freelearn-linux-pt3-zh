<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer097">
<h1 class="chapterNumber">7</h1>
<h1 class="chapterTitle" id="_idParaDest-101">Controlling and Managing Processes</h1>
<p class="normal">On a typical Linux server, there can be over a hundred processes running at any given time. The purposes of these <a id="_idIndexMarker357"/>processes range from system services, such as the <strong class="keyWord">Network Time Protocol</strong> (<strong class="keyWord">NTP</strong>) service, to processes that serve information to others, such as the Apache web server. As an administrator of Ubuntu servers, you will need to be able to manage these processes, as well as managing the resources available to them. In this chapter, we’ll take a look at process management, including the <code class="inlineCode">ps</code> command, managing job control commands, and more.</p>
<p class="normal">As we work through these concepts, we will cover the following topics:</p>
<ul>
<li class="bulletList">Managing jobs</li>
<li class="bulletList">Understanding the <code class="inlineCode">ps</code> command</li>
<li class="bulletList">Changing the priority of processes</li>
<li class="bulletList">Dealing with misbehaving processes</li>
<li class="bulletList">Managing system processes</li>
<li class="bulletList">Scheduling tasks with <code class="inlineCode">cron</code></li>
</ul>
<p class="normal">To begin our exploration of managing processes, let’s take a look first at managing jobs. Not only will this help us understand the concepts better, but it will also provide us with a better understanding of backgrounding and foregrounding.</p>
<h1 class="heading-1" id="_idParaDest-102">Managing jobs</h1>
<p class="normal">Up until now, everything we <a id="_idIndexMarker358"/>have been doing on the shell has been right in front of us, from execution to completion. We’ve installed applications, run programs, and walked through various commands. Each time, we’ve had control of our shell taken from us, and we’ve only been able to start a new task when the previous one had finished. For example, if we were to install the <code class="inlineCode">vim-nox</code> package with the <code class="inlineCode">apt install</code> command, we would watch helplessly while <code class="inlineCode">apt</code> takes care of fetching the package and installing it for us. </p>
<p class="normal">While this is going on, our cursor goes away and our shell completes the task for us without allowing us to queue up another command. We can always open a new shell to the server and multitask by having two windows open at once, each doing different tasks. But that’s likely not going to be the most efficient method of multitasking when working with the command line.</p>
<p class="normal">Instead, we can actually background a process without waiting for it to complete while working on something else. Then, we can bring that process back to the front to return to working on it or to check whether or not it finished successfully. Think of this as a similar concept to a windowing desktop environment, or user interfaces on the Windows or macOS operating systems. We can work on an application, minimize it to get it out of the way, and then maximize it to continue working with it. Essentially, that’s the same concept as backgrounding a process in a Linux shell.</p>
<p class="normal">So how exactly do you background and foreground a process? This concept can be somewhat difficult to explain. In my opinion, the easiest way to learn a new concept is to try it out, and the easiest example I can think of is by (yet again) using a text editor. I promise that this time, using a text editor as an example won’t be boring. In fact, this example is extremely useful and may just become a part of your daily workflow. To do this exercise, you can use any command-line text editor you prefer, such as Vim or Nano. On Ubuntu Server, <code class="inlineCode">nano</code> is usually installed by default, so you already have it if you want to go with that. If you prefer to use Vim, feel free to install the <code class="inlineCode">vim-nox</code> package if you haven’t already installed it:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install vim-nox 
</code></pre>
<p class="normal">You can actually install <code class="inlineCode">vim</code> rather than <code class="inlineCode">vim-nox</code>, but I always default to <code class="inlineCode">vim-nox</code> since it features built-in support for scripting languages.</p>
<p class="normal">Again, feel free to use whichever text editor you feel comfortable with. In the following examples, I’ll be using <code class="inlineCode">nano</code>, but if you use <code class="inlineCode">vim</code>, just replace <code class="inlineCode">nano</code> with <code class="inlineCode">vim</code> every time you see it.</p>
<p class="normal">Anyway, to see backgrounding in action, open up your text editor. Feel free to open a file or just start a blank session. (If in doubt, type <code class="inlineCode">nano</code> and press <em class="keystroke">Enter</em>.) With the text editor open, we can background it at any time by pressing <em class="keystroke">Ctrl + z</em> on our keyboard.</p>
<p class="normal">If you are using <code class="inlineCode">vim</code> instead of <code class="inlineCode">nano</code>, you can only background <code class="inlineCode">vim</code> when you are <em class="italic">not</em> in <em class="italic">insert mode</em>, since it captures <em class="keystroke">Ctrl + z</em> rather than passing it to the shell.</p>
<p class="normal">Did you see what happened? You were immediately taken away from your editor and returned to the shell so you can now get back to executing commands. You should have seen some output similar to the following:</p>
<pre class="programlisting con"><code class="hljs-con">[1]+ Stopped nano 
</code></pre>
<p class="normal">Here, we see the <code class="inlineCode">job</code> number of our process, its status, and then the name of the process. Even though the process of your text editor shows a status of <code class="inlineCode">Stopped</code>, it’s still running. You can confirm this with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">ps au | grep nano 
</code></pre>
<p class="normal">In my case, I see <a id="_idIndexMarker359"/>the <code class="inlineCode">nano</code> process running with a PID of <code class="inlineCode">43231</code>:</p>
<pre class="programlisting con"><code class="hljs-con">jay        43231  0.0  0.1   5468  3632 pts/0    T    11:27   0:00 nano 
</code></pre>
<p class="normal">At this point, I can execute additional commands, navigate around my filesystem, and get additional work done. When I want to bring my text editor back, I can use the <code class="inlineCode">fg</code> command to foreground the process, which will resume it. If I have multiple background processes, the <code class="inlineCode">fg</code> command will bring back the one I was working on most recently.</p>
<p class="normal">I gave you an example of the <code class="inlineCode">ps</code> command to show that the process was still running in the background, but there’s actually a dedicated command for that purpose, and that is the <code class="inlineCode">jobs</code> command. </p>
<p class="normal">If you execute the <code class="inlineCode">jobs</code> command, you’ll see in the output a list of all the processes running in the background:</p>
<figure class="mediaobject"><img alt="" height="205" src="../Images/B18425_07_01.png" width="668"/></figure>
<p class="packt_figref">Figure 7.1: Running the jobs command after backgrounding two nano processes</p>
<p class="normal">The output shows that I have two <code class="inlineCode">nano</code> sessions in use, one modifying <code class="inlineCode">file1.txt</code>, and the other modifying <code class="inlineCode">file2.txt</code>. If I were to execute the <code class="inlineCode">fg</code> command, that would bring up the <code class="inlineCode">nano</code> session that’s editing <code class="inlineCode">file2.txt</code>, since that was the last one I was working in. That may or may not be the one I want to return to editing, though. Since I have the job ID on the left, I can bring up a specific background process by using its ID with the <code class="inlineCode">fg</code> command:</p>
<pre class="programlisting con"><code class="hljs-con">fg 1 
</code></pre>
<p class="normal">Knowing how to<a id="_idIndexMarker360"/> background a process can add quite a bit to your workflow. For example, let’s say, hypothetically, that I’m editing a config file for a server application, such as Apache. While I’m editing this config file, I need to consult the documentation (man page) for Apache because I forgot the syntax for something. I could open a new shell and an SSH session to my server and view the documentation in another window. This could get very messy if I open up too many shells. It would be much simpler to background the current <code class="inlineCode">nano</code> session, read the documentation, and then foreground the process with the <code class="inlineCode">fg</code> command to return to working on it, all from one SSH session!</p>
<p class="normal">To background a process, you don’t have to use <em class="keystroke">Ctrl + z</em>; you can actually background a process right when you execute it by entering a command with the ampersand symbol (<code class="inlineCode">&amp;</code>) typed at the end. To show you how this works, I’ll use <code class="inlineCode">htop</code> as an example. Admittedly, this may not necessarily be the most practical example, but it does work to show you how to start a process and have it backgrounded right away. </p>
<p class="normal">We might not have <code class="inlineCode">htop</code> installed yet, but for now, feel free to install this package (if it isn’t already) and then run it with the ampersand symbol:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install htop 
htop &amp; 
</code></pre>
<p class="normal">The first command, as you already know, installs the <code class="inlineCode">htop</code> package on our server. With the second command, I’m opening <code class="inlineCode">htop</code> but backgrounding it immediately. What I’ll see when it’s backgrounded is its job ID and process ID (more on this in the next section). Now, at any time, I can bring <code class="inlineCode">htop</code> to the foreground with <code class="inlineCode">fg</code>. Since I just backgrounded it, <code class="inlineCode">fg</code> will bring <code class="inlineCode">htop</code> back since it considers it the most recent. As you know, if it wasn’t the most recent, I could reference its job ID with the <code class="inlineCode">fg</code> command to bring it back even if it wasn’t my most recently used job. Go ahead and practice using the ampersand symbol with a command and then bringing it back to the foreground. In the case of <code class="inlineCode">htop</code>, it can be useful to start it, background it, and then bring it back anytime you need to check the performance of your server.</p>
<p class="normal">Keep in mind, though, that when you exit your shell, all your backgrounded processes will close. If you have unsaved work in your text editors, you’ll lose what you were working on. For this reason, if you utilize background processes, you may want to check to see if you have any pending jobs still running by executing the <code class="inlineCode">jobs</code> command before logging out.</p>
<p class="normal">In addition, you’ll <a id="_idIndexMarker361"/>probably notice that some applications background cleanly, while others don’t. In the case of using a text editor and <code class="inlineCode">htop</code>, those applications stay paused in the background, allowing us to perform other tasks and then return to those commands later. However, some applications may still spit out diagnostic text regularly in your main window, whether they’re backgrounded or not. To get even more control over your Bash sessions, you can learn how to use a multiplexer, such as <code class="inlineCode">tmux</code> or <code class="inlineCode">screen</code>, to allow these processes to run in their own session such that they don’t interrupt your work. Going over the use of a program such as <code class="inlineCode">tmux</code> is beyond the scope of this book, but it is a useful utility to learn if you’re interested.</p>
<p class="normal">Being able to background and foreground a process allows us to manage tasks on the command line more effectively, and is definitely useful. Now, we can expand this and look at viewing other processes on the server, including those that we didn’t manually start such as a text editor. In the next section, we’ll take a look at the <code class="inlineCode">ps</code> command, which can help us understand what is actually running on our server.</p>
<h1 class="heading-1" id="_idParaDest-103">Understanding the ps command</h1>
<p class="normal">While managing our<a id="_idIndexMarker362"/> server, we’ll need to understand what processes are running and how to manage them. Later in this chapter, we’ll work through starting, stopping, and monitoring processes. But before we get to those concepts, we first need to be able to determine what is actually running on our server. The <code class="inlineCode">ps</code> command allows us to do this.</p>
<h2 class="heading-2" id="_idParaDest-104">Viewing running processes with ps</h2>
<p class="normal">When executed<a id="_idIndexMarker363"/> by itself, the <code class="inlineCode">ps</code> command will<a id="_idIndexMarker364"/> show a list of processes run by the user who called the command:</p>
<figure class="mediaobject"><img alt="" height="230" src="../Images/B18425_07_02.png" width="602"/></figure>
<p class="packt_figref">Figure 7.2: The output of the ps command, when run as a normal user and with no options</p>
<p class="normal">In <em class="italic">Figure 7.2</em>, you can see that when I ran the <code class="inlineCode">ps</code> command as my own user with no options, it showed me a list of processes that I am running as myself. In this case, I have a <code class="inlineCode">vim</code> session open (running in the background), and in the last line, we also see <code class="inlineCode">ps</code> itself, which is also included in the output.</p>
<p class="normal">On the left side of the output, you’ll see a number for each of the running processes. This is known as<a id="_idIndexMarker365"/> the <strong class="keyWord">Process ID</strong> (<strong class="keyWord">PID</strong>), which we mentioned in the <em class="italic">Managing jobs</em> section. Before we continue on, the PID is something that you really should be familiar with, so we may as well cover it right now.</p>
<p class="normal">Each process running on your server is assigned a PID, which differentiates it from other processes on your system. You may understand a process as <code class="inlineCode">vim</code>, or <code class="inlineCode">top</code>, or some other name. However, our server knows processes by their ID. When you open a program or start a process, it’s given a PID by the kernel. As you work on managing your server, you’ll find that the PID is useful to know, especially for the commands we’ll be covering in this very chapter. If you want to kill a misbehaving process, for example, a typical workflow would be for you to find the PID of that process and then reference that PID when you go to kill the process (which I’ll show you how to do in a later section). PIDs are actually more complex than just a number assigned to running processes, but for the purposes of this chapter, that’s the main purpose we’ll need to remember.</p>
<p class="normal">You can also use the <code class="inlineCode">pidof</code> command to find the PID of a process if you know the name of it. For example, I showed you a screenshot of a <code class="inlineCode">vim</code> process running with a PID of <code class="inlineCode">1385</code>. You can also <a id="_idIndexMarker366"/>do <a id="_idIndexMarker367"/>so by running the following command:</p>
<pre class="programlisting con"><code class="hljs-con">pidof vim 
</code></pre>
<p class="normal">The output will give you the PID(s) of the process without you having to use the <code class="inlineCode">ps</code> command.</p>
<h2 class="heading-2" id="_idParaDest-105">Configuring arguments to ps</h2>
<p class="normal">Continuing with the <code class="inlineCode">ps</code> command, there <a id="_idIndexMarker368"/>are several useful arguments <a id="_idIndexMarker369"/>you can give in order to change the way in which it produces an output. If you use the <code class="inlineCode">a</code> option, you’ll see more information than you normally would:</p>
<pre class="programlisting con"><code class="hljs-con">ps a 
</code></pre>
<p class="normal">This will produce an output something like the following:</p>
<figure class="mediaobject"><img alt="" height="244" src="../Images/B18425_07_03.png" width="583"/></figure>
<p class="packt_figref">Figure 7.3: The output of the ps a command</p>
<p class="normal">With <code class="inlineCode">ps a</code>, we’re seeing the same output as before, but with additional information, as well as column headings at the top. We now see a heading for <code class="inlineCode">PID</code>, <code class="inlineCode">TTY</code>, <code class="inlineCode">STAT</code>, <code class="inlineCode">TIME</code>, and <code class="inlineCode">COMMAND</code>. From this new output, you can see that the <code class="inlineCode">vim</code> processes I have running are editing a file named <code class="inlineCode">testfile.txt</code>. This is great to know, because if I had more than one <code class="inlineCode">vim</code> session open and one of them was misbehaving, I would probably want to know which one I specifically needed to stop.</p>
<p class="normal">We already <a id="_idIndexMarker370"/>saw<a id="_idIndexMarker371"/> the <code class="inlineCode">PID</code> and <code class="inlineCode">COMMAND</code> fields, although we didn’t see a formal heading at the top. The <code class="inlineCode">PID</code> column we’ve already covered, so I won’t go into any additional detail about that. The <code class="inlineCode">COMMAND</code> field tells us the actual command being run, which is very useful if we either want to ensure we’re managing the correct process or to see what a particular user is running (I’ll demonstrate how to display processes for other users soon).</p>
<p class="normal">The <code class="inlineCode">STAT</code>, field is new; we didn’t see it when we ran <code class="inlineCode">ps</code> by itself. The <code class="inlineCode">STAT</code> field gives us the status code of the process, which refers to which state the process is currently in. The state can be uninterruptible sleep (<code class="inlineCode">D</code>), defunct (<code class="inlineCode">Z</code>), stopped (<code class="inlineCode">T</code>), interruptible sleep (<code class="inlineCode">S</code>), and in the run queue (<code class="inlineCode">R</code>). There is also paging (<code class="inlineCode">W</code>), but that is not used anymore, so there’s no need to cover it. Uninterruptible sleep is a state in which a process is generally waiting on input and cannot handle additional signals (we’ll briefly talk about signals later on in this chapter). A defunct process (also referred to as a zombie process) has, for all intents and purposes, finished its job but is waiting on the parent to perform cleanup. Defunct processes aren’t actually running, but remain in the process list and should normally close on their own. If such a process remains in the list indefinitely and doesn’t close, it can be a candidate for the <code class="inlineCode">kill</code> command, which we will discuss later. A stopped process is generally a process that has been sent to the background, which will be discussed in the next section. Interruptible sleep means that the program is idle: it’s waiting for input in order to awaken.</p>
<p class="normal">The <code class="inlineCode">TTY</code> column tells us which TTY the process is attached to. A TTY refers to a <strong class="keyWord">teletypewriter</strong>, which<a id="_idIndexMarker372"/> is a term used from a much different time period. In the past, during the time of big mainframes, users would use such computers using “terminals” – a device consisting of a monitor and keyboard, connected (via the wire) to the mainframe. Such devices could only display the output received from the mainframe, and receive data typed on the keyboard. Teletypewriter was the term used to refer to such devices. Obviously, we don’t use machines like these nowadays, but the concept is similar from a virtual standpoint. </p>
<p class="normal">On our server, we’re using our keyboard to send input to a device that then displays output to another device. In our case, the input device is our keyboard and the output device is our screen, which is either connected directly to our server or is located on our computer, which is connected to our server over a service such as SSH. On a<a id="_idIndexMarker373"/> Linux <a id="_idIndexMarker374"/>system, most processes run on a TTY, which is (for all intents and purposes) a terminal that grabs input and manages the output, similar to a teletypewriter in a virtual sense. A terminal is our method of interacting with our server.</p>
<p class="normal">In <em class="italic">Figure 7.3</em>, we have a process running on a TTY of <code class="inlineCode">tty1</code>, and the other processes are running on <code class="inlineCode">pts/0</code>. The TTY we see is the actual terminal device, and <code class="inlineCode">pts</code> references a virtual (pseudo) terminal device. Our server is actually able to run several <code class="inlineCode">tty</code> sessions, typically one to seven. Each of these can be running its own programs and processes. To understand this better, try pressing <em class="keystroke">Ctrl + Alt +</em> any function key, from <em class="keystroke">F1</em> through <em class="keystroke">F7</em> (if you have a physical keyboard plugged into a physical server). Each time, you should see your screen cleared and then moved to another terminal. Each of these terminals is independent of one another. Each of your function keys represents a specific TTY, so by pressing <em class="keystroke">Ctrl + Alt + F6</em>, you’re switching your display to TTY 6.</p>
<p class="normal">Essentially, you’re switching from TTY 1 through to TTY 7, with each being able to contain its own running processes. If you run <code class="inlineCode">ps a</code> again, you’ll see any processes you start on those TTYs show up in the output as a <code class="inlineCode">tty</code> session, such as <code class="inlineCode">tty2</code> or <code class="inlineCode">tty4</code>. Processes that you start in a terminal emulator will be given a designation of <code class="inlineCode">pts</code>, because they’re not running in an actual TTY, but rather a pseudo-TTY.</p>
<p class="normal">This was a long discussion for something that ends up being simple (TTY or pseudo-TTY), but with this knowledge, you should be able to differentiate between a process running on the actual server or through a shell.</p>
<p class="normal">Continuing, let’s take a look at the <code class="inlineCode">TIME</code> field of our <code class="inlineCode">ps</code> command output. This field represents the total amount of time the CPU has been utilized for that particular process. However, the time is <code class="inlineCode">0:00</code> for each of the processes in the screenshot I’ve provided. This may be confusing at first. In my case, the <code class="inlineCode">vim</code> processes in particular have been running for about 15 minutes or so since I took the screenshot, and they still show <code class="inlineCode">0:00</code> utilization time even now. Actually, this isn’t the amount of time the process has been running, but rather the amount of time the process has been actively engaging with the CPU. In the case of <code class="inlineCode">vim</code>, each of these processes is just a buffer with a file open. For the sake of comparison, the Linux machine I’m writing this chapter on has a process ID of <code class="inlineCode">759</code> with a time of <code class="inlineCode">92:51</code>. PID <code class="inlineCode">759</code> belongs to my X server, which provides the foundation for my <strong class="keyWord">graphical user interface</strong> (<strong class="keyWord">GUI</strong>) and <a id="_idIndexMarker375"/>windowing capabilities. However, this laptop currently has an uptime of 6 days and 22 hours as I type this, which is roughly equivalent to 166 hours, which is not the same amount of time that PID <code class="inlineCode">759</code> is reporting in its <code class="inlineCode">TIME</code> entry. Therefore, we<a id="_idIndexMarker376"/> can <a id="_idIndexMarker377"/>deduce that even though my laptop has been running for 6 days straight, the X server has only utilized 92 hours and 51 minutes of actual CPU time. In summary, the <code class="inlineCode">TIME</code> column refers to the amount of time a process needs the CPU in order to calculate something and is not necessarily equal to how long something has been running, or for how long a graphical process is showing on your screen.</p>
<p class="normal">Let’s continue on with the <code class="inlineCode">ps</code> command and look at some additional options. First, let’s see what we get when we add the <code class="inlineCode">u</code> option to our previous example, which gives us the following example command:</p>
<pre class="programlisting con"><code class="hljs-con">ps au
</code></pre>
<p class="normal">This will produce an output that will look similar to the following:</p>
<figure class="mediaobject"><img alt="" height="179" src="../Images/B18425_07_04.png" width="883"/></figure>
<p class="packt_figref">Figure 7.4: The output of the ps au command</p>
<p class="normal">When you run it, you should notice the difference from the <code class="inlineCode">ps a</code> command right away. With this variation, you’ll see processes listed that are being run by your user ID, as well as other users. When I run it, I see processes listed in the output for my user (<code class="inlineCode">jay</code>), as well as one for <code class="inlineCode">root</code>. The <code class="inlineCode">u</code> option will be a common option you’re likely to use, since most of the time while managing servers, you’re probably more interested in keeping an eye on what kinds of shenanigans your users are getting themselves into. But perhaps the most common use of the <code class="inlineCode">ps</code> command is the following variation:</p>
<pre class="programlisting con"><code class="hljs-con">ps aux 
</code></pre>
<p class="normal">With the <code class="inlineCode">x</code> option added, we’re no longer limiting our output to processes within a TTY (either native or pseudo). The result is that we’ll see a lot more processes, including system-level processes <a id="_idIndexMarker378"/>that are not tied to a process we started <a id="_idIndexMarker379"/>ourselves. Go ahead and try it. In practice, though, the <code class="inlineCode">ps aux</code> command is most commonly used with <code class="inlineCode">grep</code> to look for a particular process or string. For example, let’s say you want to see a list of all <code class="inlineCode">nginx</code> worker processes. To do that, you may execute a command such as the following:</p>
<pre class="programlisting con"><code class="hljs-con">ps aux | grep nginx 
</code></pre>
<p class="normal">Here, we’re executing the <code class="inlineCode">ps aux</code> command as before, but we’re piping the output into <code class="inlineCode">grep</code>, where we’re looking only for lines of output that include the string <code class="inlineCode">nginx</code>. In practice, this is the way I often use <code class="inlineCode">ps</code>, as well as the way I’ve noticed many other administrators using it. With <code class="inlineCode">ps aux</code>, we are able to see a lot more output, and then we can narrow that down with search criteria by piping into <code class="inlineCode">grep</code>. However, if all we wanted to do was to show processes that have a particular string, we could also do the following:</p>
<pre class="programlisting con"><code class="hljs-con">ps u -C nginx 
</code></pre>
<p class="normal">This would produce output containing a list of processes matching <code class="inlineCode">nginx</code>, and related details. Another useful variation of the <code class="inlineCode">ps</code> command is to sort the output by sorting the processes using the most CPU first:</p>
<pre class="programlisting con"><code class="hljs-con">ps aux --sort=-pcpu 
</code></pre>
<p class="normal">Unfortunately, that command shows a lot of output, and we would have to scroll back to the top in order to see the top processes. Depending on your terminal, you may not have the ability to scroll back very far (or at all), so the following command will narrow it down further:</p>
<pre class="programlisting con"><code class="hljs-con">ps aux --sort=-pcpu | head -n 5 
</code></pre>
<p class="normal">Now that is useful! With that example, I’m using the <code class="inlineCode">ps aux</code> command with the <code class="inlineCode">--sort</code> option, sorting by the percentage of CPU utilization (<code class="inlineCode">-pcpu</code>). Then I’m piping the output into the <code class="inlineCode">head</code> command, where I’m instructing it to show me only five lines (<code class="inlineCode">-n 5</code>). Essentially, this is giving me a list of the top five processes that have used the most CPU since boot time. In fact, I can do the same, but with the most-used memory instead:</p>
<pre class="programlisting con"><code class="hljs-con">ps aux --sort=-pmem | head -n 5 
</code></pre>
<p class="normal">If you want to determine which processes are misbehaving and using a non-ordinary amount of memory or CPU, those commands will help you narrow it down. The <code class="inlineCode">ps</code> command is a very useful command for your admin toolbox. Feel free to experiment with it beyond the examples I’ve provided; you can consult the man pages for the <code class="inlineCode">ps</code> command to learn even more tricks. In fact, the second section of the man page for <code class="inlineCode">ps</code> (under <em class="italic">examples</em>) gives<a id="_idIndexMarker380"/> you even more neat examples to try<a id="_idIndexMarker381"/> out.</p>
<p class="normal">Now that we know how to inspect running processes, in the next section, we’ll take a look at how to change the priority of the processes to ensure those that are more important are given extra attention by the CPU.</p>
<h1 class="heading-1" id="_idParaDest-106">Changing the priority of processes</h1>
<p class="normal">Processes on a Linux <a id="_idIndexMarker382"/>system can be run with an altered priority, giving some processes more priority and others less. This gives you, the administrator, full reign when it comes to ensuring that the most important processes on the system are running with an adequate level of prioritization. There are dedicated commands for this purpose: <code class="inlineCode">nice</code> and <code class="inlineCode">renice</code>. These commands allow you to launch a process with a specific priority, or change the priority of a process that’s already running.</p>
<p class="normal">Nowadays, manually editing the priority of a process is something administrators will find themselves doing less often than they used to. A processor with 32 cores (or many more) is not all that uncommon, and neither is hundreds of gigabytes of RAM. Servers nowadays are certainly more powerful than they used to be, and are nowhere near as resource-starved as machines of old. Many servers (such as virtual machines) and containers are dedicated to a single task, so process tuning may not be of extreme value anymore. However, data processing firms and companies utilizing deep learning functions may find themselves needing to fine-tune some things.</p>
<p class="normal">Regardless of whether or not prioritizing processes is something that will be immediately useful to you, it’s a good idea to at least understand the concept just in case you do find yourself needing to increase or decrease the priority of a process some day. Let’s revisit the <code class="inlineCode">ps</code> command, this<a id="_idIndexMarker383"/> time with the <code class="inlineCode">-l</code> argument:</p>
<pre class="programlisting con"><code class="hljs-con">ps -l
</code></pre>
<p class="normal">The output of this command will appear as follows:</p>
<figure class="mediaobject"><img alt="" height="210" src="../Images/B18425_07_05.png" width="884"/></figure>
<p class="packt_figref">Figure 7.5: The output of the ps -l command</p>
<p class="normal">With the output of the <code class="inlineCode">ps -l</code> command, notice the <code class="inlineCode">PRI</code> and <code class="inlineCode">NI</code> columns. <code class="inlineCode">PRI</code> refers to the priority, and <code class="inlineCode">NI</code> pertains to the “niceness” value, which we’ll discuss in more detail later in this section. In this example, each process that I’m running has a <code class="inlineCode">PRI</code> of <code class="inlineCode">80</code>, and an <code class="inlineCode">NI</code> of <code class="inlineCode">0</code>. I didn’t change or alter any of these; these are the values that I get when I start processes with no special tweaks. A <code class="inlineCode">PRI</code> value of <code class="inlineCode">80</code> is the starting value for that value on all processes, and will change as we increase or decrease the niceness value.</p>
<p class="normal">As I mentioned, we have dedicated commands that allow us to alter priorities, <code class="inlineCode">nice</code> and <code class="inlineCode">renice</code>. To determine which to use, it all comes down to whether or not the process is already running. With regard to the processes listed in <em class="italic">Figure 7.5</em>, we would want to use <code class="inlineCode">renice</code> to change the priority for those, since they’re all already running. If we wanted to launch a process with a specific priority right from the beginning, we would use <code class="inlineCode">nice</code> instead.</p>
<p class="normal">For example, let’s change the process of the <code class="inlineCode">vim</code> session I have running. Sure, this is a somewhat lame example, as <code class="inlineCode">vim</code> isn’t a very important process. In the real world, you’d be prioritizing processes that are actually important. In my case, since the <code class="inlineCode">vim</code> process has a PID of <code class="inlineCode">1789</code>, the<a id="_idIndexMarker384"/> command I would need to run in order to change the niceness would become this:</p>
<pre class="programlisting con"><code class="hljs-con">renice -n 10 -p 1789
</code></pre>
<p class="normal">The output of this command will appear as follows:</p>
<figure class="mediaobject"><img alt="" height="148" src="../Images/B18425_07_06.png" width="698"/></figure>
<p class="packt_figref">Figure 7.6: Changing the priority of a process with renice</p>
<p class="normal">If we run <code class="inlineCode">ps -l</code> again, we can see the new nice value for <code class="inlineCode">vim</code>:</p>
<figure class="mediaobject"><img alt="" height="199" src="../Images/B18425_07_07.png" width="877"/></figure>
<p class="packt_figref">Figure 7.7: The output of the ps -l command after changing the priority of a process</p>
<p class="normal">The new nice value of <code class="inlineCode">10</code> now shows up for <code class="inlineCode">vim</code> under <code class="inlineCode">NI</code>, and the <code class="inlineCode">PRI</code> value has increased to <code class="inlineCode">90</code>. Now, this instance of <code class="inlineCode">vim</code> will run at a lower priority than my other tasks, the reason being that the higher the nice value, the lower the priority. Notice that I didn’t use <code class="inlineCode">sudo</code> with the command when I changed the priority. In this example, that’s okay because I’m increasing the nice value of the process, and that’s allowed. However, let’s try to decrease the nice value without <code class="inlineCode">sudo</code>, using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">renice -n 5 -p 1789
</code></pre>
<p class="normal">As you can see in the<a id="_idIndexMarker385"/> following output, I won’t be as successful:</p>
<figure class="mediaobject"><img alt="" height="133" src="../Images/B18425_07_08.png" width="879"/></figure>
<p class="packt_figref">Figure 7.8: Attempting to decrease the priority of a process</p>
<p class="normal">My attempt to decrease the nice value from 10 down to 5 was blocked. If I were able to lower the niceness, then my process would be running at a higher priority. Instead, I received a <code class="inlineCode">Permission denied</code> error. So essentially, users are allowed to increase the niceness of their processes, but are not allowed to decrease it, not even for processes they’ve initiated themselves. If you wish to decrease the nice value, you’ll need to do so with <code class="inlineCode">sudo</code>. So essentially, if you want to be “nicer,” you can go ahead and do so. If you wish to be “meaner,” you’ll need <code class="inlineCode">root</code> privileges. In addition, a user won’t be able to change the priority of a process they don’t own. So, if you attempt to use <code class="inlineCode">renice</code> to change the niceness of a task running as a different user, you’ll receive an <code class="inlineCode">Operation not permitted</code> error.</p>
<p class="normal">At this point, we know how to re-prioritize our running processes with <code class="inlineCode">renice</code>. Now, let’s take a look at starting a new process with a specific priority with <code class="inlineCode">nice</code>. Consider the following command:</p>
<pre class="programlisting con"><code class="hljs-con">nice -n 10 vim 
</code></pre>
<p class="normal">Here, we’re launching a new instance of <code class="inlineCode">vim</code>, but with the priority set to a specific value right from the start. If we want to change the priority of <code class="inlineCode">vim</code> again later, we’ll need to use <code class="inlineCode">renice</code>. As I mentioned earlier, <code class="inlineCode">nice</code> is used to launch a new process with a specific priority, and <code class="inlineCode">renice</code> is for changing the priority of a pre-existing process. In this example, we launched <code class="inlineCode">vim</code> and set its nice value to <code class="inlineCode">10</code> in one command.</p>
<p class="normal">Changing the priority of a text editor such as <code class="inlineCode">vim</code> may seem like an odd choice for a test case, and it is. But the <code class="inlineCode">vim</code> editor is harmless, as the likelihood of us changing the priority of it leading to a system halt is extremely minimal. There’s no practical reason I can think of where it would be useful to re-prioritize something like a text editor. The takeaway, though, is that you <em class="italic">can</em> change the priority of the processes running on your server. On a real server, you may have an important process that runs and generates a report, and that report <a id="_idIndexMarker386"/>must be delivered on time. Or perhaps you have a process that generates an export of data that a client needs to have in order to make an on-time deliverable. So, if you think of the bigger picture, you can replace <code class="inlineCode">vim</code> with the name of a process that is actually important for you or your organization.</p>
<p class="normal">You might be wondering what “nice” means in the context of the <code class="inlineCode">nice</code> and <code class="inlineCode">renice</code> commands. The “nice” number essentially refers to how nice a process is to other users. The higher the nice value, the lower the priority. So, a value of 20 is nicer than a value of 10. In that case, processes with a niceness of 20 are running at a lower priority, and so are kinder to the other processes on the system. The niceness can range from -20 to 19. A process with a nice value of -20 is the highest priority possible, while 19 is the lowest priority it can have. The entire system is quite a bit more complicated than this simple description. Although I refer to the nice value as the priority, it actually isn’t. The nice value is used to calculate the actual priority. But for now, if we simplify the nice value to be representative of the priority, and the nice value to equate to a lower priority, the higher the number gets, that’s enough for now.</p>
<p class="normal">So far, we’ve been using the <code class="inlineCode">nice</code> and <code class="inlineCode">renice</code> commands along with the <code class="inlineCode">-n</code> option to set the nice values directly. It may be interesting to note though that you can simplify the <code class="inlineCode">renice</code> command and leave out the <code class="inlineCode">-n</code> option:</p>
<pre class="programlisting con"><code class="hljs-con">renice 10 42467
</code></pre>
<p class="normal">That command sets the nice value of the process to a positive 10, similar to our other examples. We can also use a negative number for the niceness if we want to increase the priority:</p>
<pre class="programlisting con"><code class="hljs-con">sudo renice -10 42467
</code></pre>
<p class="normal">Although it doesn’t save us much typing to leave out the <code class="inlineCode">-n</code> option, now you know that it is a possibility. The other difference with that example was that I needed to use <code class="inlineCode">sudo</code> since I’m decreasing the nice value (more on that later).</p>
<p class="normal">When it comes to the <code class="inlineCode">nice</code> command, we can also leave out the <code class="inlineCode">-n</code> option, but the command works a bit differently in this regard. The following won’t work:</p>
<pre class="programlisting con"><code class="hljs-con">nice 15 vim
</code></pre>
<p class="normal">The syntax of <code class="inlineCode">nice</code> is a bit <a id="_idIndexMarker387"/>different, so giving it a positive number directly won’t work as it does with <code class="inlineCode">renice</code>. For that, we’ll need to add a hyphen in front:</p>
<pre class="programlisting con"><code class="hljs-con">nice -15 vim
</code></pre>
<p class="normal">When you look at that command, you may assume we’re applying a negative number. Actually, that’s not true. Since the syntax is different with <code class="inlineCode">nice</code>, the <code class="inlineCode">-15</code> value we used results in a positive 15. We needed the hyphen in front of the value to signify to <code class="inlineCode">nice</code> that we’re applying a value as an option. If we actually do want to use a negative value with <code class="inlineCode">nice</code> while also avoiding the <code class="inlineCode">-n</code> option, we would need to use two hyphens:</p>
<pre class="programlisting con"><code class="hljs-con">nice --10 vim
</code></pre>
<p class="normal">The difference in syntax between the two commands with the <code class="inlineCode">-n</code> option is a bit confusing in my opinion, so I recommend simply using the <code class="inlineCode">-n</code> option with <code class="inlineCode">nice</code> and <code class="inlineCode">renice</code>, as that’s going to be more uniform between them:</p>
<pre class="programlisting con"><code class="hljs-con">nice -n 10 vim
sudo nice -n -10 vim
renice -n 10 42467
sudo renice -n -10 42467
</code></pre>
<p class="normal">Those examples show both <code class="inlineCode">nice</code> and <code class="inlineCode">renice</code> using the <code class="inlineCode">-n</code> option, and setting both positive and negative values. Since the <code class="inlineCode">-n</code> option is used the same way between the two commands, it may be easier to focus on committing that to memory rather than focusing on the specifics. As previously discussed, I used <code class="inlineCode">sudo</code> with commands that set a negative value for niceness, since only <code class="inlineCode">root</code> can change a process to, or start a process with, a niceness below <code class="inlineCode">0</code>. You’ll receive the following error if you try to do it anyway:</p>
<pre class="programlisting con"><code class="hljs-con">nice: cannot set niceness: Permission denied
</code></pre>
<p class="normal">This type of protection is somewhat important, because you may have some users who feel as though their processes are the most important, and try to prioritize them all the way to <code class="inlineCode">-19</code>. At the end of the day, it’s better for a system administrator to make decisions on which processes are allowed to reach a niceness value in the negative.</p>
<p class="normal">As an administrator of Ubuntu servers, it’s up to you to decide which processes should be running, and at <a id="_idIndexMarker388"/>what priority. You’ll then determine the best way to achieve the exact system state that’s appropriate, and tuning process priority may be a part of that. If nothing else, learning the <code class="inlineCode">nice</code> and <code class="inlineCode">renice</code> commands gives you another utility for your toolset.</p>
<h1 class="heading-1" id="_idParaDest-107">Dealing with misbehaving processes</h1>
<p class="normal">Regarding the <code class="inlineCode">ps</code> command, by <a id="_idIndexMarker389"/>this point you know how to display processes running on your server, as well as how to narrow down the output by string or resource usage. But what can you actually do with that knowledge? As much as we hate to admit it, sometimes the processes our server runs fail or misbehave and you need to restart them. If a process refuses to close normally, you may need to kill that process. In this section, we introduce the <code class="inlineCode">kill</code> and <code class="inlineCode">killall</code> commands to serve that purpose.</p>
<p class="normal">The <code class="inlineCode">kill</code> command accepts a PID as an argument and attempts to close a process gracefully. In a typical workflow where you need to terminate a process that won’t do so on its own, you will first use the <code class="inlineCode">ps</code> command to find the PID of the culprit. Then, knowing the PID, you can attempt to <code class="inlineCode">kill</code> the process. For example, if PID <code class="inlineCode">31258</code> needed to be killed, you could execute the following:</p>
<pre class="programlisting con"><code class="hljs-con">sudo kill 31258 
</code></pre>
<p class="normal">If all goes well, the process will end. You can restart it or investigate why it failed by perusing its logs.</p>
<p class="normal">To better understand what the <code class="inlineCode">kill</code> command does, you first will need to understand the basics of <strong class="keyWord">Linux signals</strong>. Signals <a id="_idIndexMarker390"/>are used by both administrators and developers and can be sent to a process either by the kernel, another process, or manually with a command. A signal instructs the process of a request or change, and in some cases, to completely terminate. An example of such a signal is <code class="inlineCode">SIGHUP</code>, which tells processes that their controlling terminal has exited. One situation in which this may occur is when you have a terminal emulator open, with several processes inside it running. If you close the terminal window (without stopping the processes you were running), they’ll be sent the <code class="inlineCode">SIGHUP</code> signal, which basically tells them to quit (essentially, it means the shell quit or hung up).</p>
<p class="normal">Other examples<a id="_idIndexMarker391"/> include <code class="inlineCode">SIGINT</code> (where an application is running in the foreground and is stopped by pressing <em class="keystroke">Ctrl + c</em> on the keyboard) and <code class="inlineCode">SIGTERM</code>, which, when sent to a process, asks it to cleanly terminate. Yet another example is <code class="inlineCode">SIGKILL</code>, which forces a process to terminate uncleanly. In addition to a name, each signal is also represented by a value, such as <code class="inlineCode">15</code> for <code class="inlineCode">SIGTERM</code> and <code class="inlineCode">9</code> for <code class="inlineCode">SIGKILL</code>. Going over each of the signals is beyond the scope of this chapter (the advanced topics of signals are mainly only useful for developers), but you can view more information about them by consulting the man page if you’re curious:</p>
<pre class="programlisting con"><code class="hljs-con">man 7 signal 
</code></pre>
<p class="normal">For the purposes of this section, the two types of signals we are most concerned about are <code class="inlineCode">SIGTERM(15)</code> and <code class="inlineCode">SIGKILL(9)</code>. When we want to stop a process, we send one of these signals to it, and the <code class="inlineCode">kill</code> command allows us to do just that. By default, the <code class="inlineCode">kill</code> command sends signal <code class="inlineCode">15</code> (<code class="inlineCode">SIGTERM</code>), which tells the process to cleanly terminate. If successful, the process will free its memory and gracefully close. With our previous example <code class="inlineCode">kill</code> command, we sent signal <code class="inlineCode">15</code> to the process, since we didn’t clarify which signal to send.</p>
<p class="normal">Terminating a process with <code class="inlineCode">SIGKILL(9)</code> is considered an extreme last resort. When you send signal <code class="inlineCode">9</code> to a process, it’s the equivalent of ripping the carpet out from underneath it or blowing it up with a stick of dynamite. The process will be force-closed without giving it any time to react at all, so it’s one of those things you should avoid using unless you’ve literally tried absolutely everything you can think of. In theory, sending signal <code class="inlineCode">9</code> can cause corrupted files, memory issues, or other shenanigans to occur. As for me, I’ve never actually run into long-term damage to software from using it, but theoretically it can happen, so you want to only use it in extreme cases. One case where such a signal may be necessary is <a id="_idIndexMarker392"/>regarding <code class="inlineCode">defunct</code> or a <strong class="keyWord">zombie process</strong> in a situation where they don’t close on their own. These processes are basically dead already and are typically waiting on their parent processes to reap them.</p>
<p class="normal">If the parent process never attempts to do so, they will remain on the process list. This in and of itself may not really be a big issue, since these processes aren’t technically doing anything. But if their presence is causing problems and you can’t kill them, you could try to send <code class="inlineCode">SIGKILL</code> to the process. There should be no harm in eliminating a zombie process, but you would want to give them time to be reaped first.</p>
<p class="normal">To send signal <code class="inlineCode">9</code> to a process, you would use the <code class="inlineCode">-9</code> option of the <code class="inlineCode">kill</code> command. It should go without <a id="_idIndexMarker393"/>saying, though, to make sure you’re executing it against the proper process ID:</p>
<pre class="programlisting con"><code class="hljs-con">sudo kill -9 31258 
</code></pre>
<p class="normal">Just like that, the process with a PID of <code class="inlineCode">31258</code> will vanish without a trace. Anything it was writing to will be in limbo, and it will be removed from memory instantly. If, for some reason, the process still manages to stay running (which is extremely rare), you probably would need to reboot the server to get rid of it, which is something I’ve only seen in a few, very rare cases. An example of this is a zombie process, which is a process that shows up in the process list but isn’t impacted by having signals sent to it, since such a process won’t be scheduled for CPU time anyway. When it all comes down to it, if <code class="inlineCode">kill</code> <code class="inlineCode">-9</code> doesn’t get rid of the process, nothing will.</p>
<p class="normal">Another method of killing a process is with the <code class="inlineCode">killall</code> command, which is probably safer than the <code class="inlineCode">kill</code> command (if for no other reason than there’s a smaller chance you’ll accidentally kill the wrong process). Like <code class="inlineCode">kill</code>, <code class="inlineCode">killall</code> allows you to send <code class="inlineCode">SIGTERM</code> to a process, but unlike <code class="inlineCode">kill</code>, you can do so by name. In addition, <code class="inlineCode">killall</code> doesn’t just kill one process, it kills any process it finds with the name you’ve given it as an option. To use <code class="inlineCode">killall</code>, you would simply execute <code class="inlineCode">killall</code> along with the name of a process:</p>
<pre class="programlisting con"><code class="hljs-con">sudo killall myprocess 
</code></pre>
<p class="normal">Just like the <code class="inlineCode">kill</code> command, you can also send signal <code class="inlineCode">9</code> to the process as well:</p>
<pre class="programlisting con"><code class="hljs-con">sudo killall -9 myprocess 
</code></pre>
<p class="normal">Again, use that only when necessary. In practice, though, you probably won’t use <code class="inlineCode">killall -9</code> very often (if ever), because it’s rare for multiple processes under the same process name to become locked. If you need to send signal <code class="inlineCode">9</code>, stick to the <code class="inlineCode">kill</code> command if you can.</p>
<p class="normal">The <code class="inlineCode">kill</code> and <code class="inlineCode">killall</code> commands can be incredibly useful in the situation of a stuck process, but these are commands you would hope you don’t have to use very often. Stuck processes can occur in situations where applications encounter a situation from which they can’t recover, so if you constantly find yourself needing to kill processes, you may want to check for an update to the package responsible for the service or check your server for hardware<a id="_idIndexMarker394"/> issues.</p>
<p class="normal">In the next section, let’s take a look at system processes that run in the background and provide a service to us or our users, such as a web server process or DHCP server.</p>
<h1 class="heading-1" id="_idParaDest-108">Managing system processes</h1>
<p class="normal">System processes, also <a id="_idIndexMarker395"/>known as <strong class="keyWord">daemons</strong>, are <a id="_idIndexMarker396"/>programs that run in the background on your server and are typically started automatically when it boots. We don’t usually manage these services directly as they run in the background to perform their duty, with or without needing our input. For example, if our server is a DHCP server and runs the <code class="inlineCode">isc-dhcp-server</code> process, this process will run in the background, listening for DHCP requests and providing new IP assignments to them as they come in. Most of the time, when we install an application that runs as a service, Ubuntu will configure it to start when we boot our server, so we don’t have to start it ourselves. Assuming the service doesn’t run into an issue, it will happily continue performing its job forever until we tell it to stop. In Linux, services are managed by its init system, also referred to as PID 1 since the init system of a Linux system always receives that PID. In recent years, the way in which processes are managed in Ubuntu Server has changed considerably. Ubuntu has switched to <code class="inlineCode">systemd</code> for its <code class="inlineCode">init</code> system, which was previously Upstart until a few years ago. Ubuntu 16.04 was the first LTS release of Ubuntu with <code class="inlineCode">systemd</code>, and this continues to be used today in Ubuntu 22.04. Since <code class="inlineCode">systemd</code> has been the standard for quite some time now, we’ll focus our attention on the commands used with it to manage our services. Older <code class="inlineCode">init</code> systems are aging out.</p>
<p class="normal">With <code class="inlineCode">systemd</code>, services are known<a id="_idIndexMarker397"/> as <strong class="keyWord">units</strong>, but for all intents and purposes, the terms “service,” “daemon,” and “unit” all essentially mean the same thing. Since I started using Linux over 20 years ago, I still refer to <code class="inlineCode">systemd</code> units as services, out of habit. To help us manage these “units,” <code class="inlineCode">systemd</code> includes the <code class="inlineCode">systemctl</code> command, which allows you to start, stop, and view the status of units on our server. To help illustrate this, I’ll use OpenSSH as an example. The name of the unit doesn’t really matter, as the syntax of the <code class="inlineCode">systemctl</code> command is the same regardless of the name of the unit we’re interacting with. You can use <code class="inlineCode">systemctl</code> to start, stop, or restart your Apache instance, your database server, or even use it to restart the entire networking stack. The <code class="inlineCode">systemctl</code> command, with no options or parameters, assumes the <code class="inlineCode">list-units</code> option, which dumps a list of units to your shell. This can be a bit messy, though, so if you already know the name of a unit you’d like to search for, you can pipe the output into <code class="inlineCode">grep</code> and search for a string. This is handy in a situation where you may not know the exact name of the unit, but you know part <a id="_idIndexMarker398"/>of it:</p>
<pre class="programlisting con"><code class="hljs-con">systemctl | grep ssh 
</code></pre>
<p class="normal">If you want to check the health of a unit, the best way is to actually use the <code class="inlineCode">status</code> keyword, which will show you some very useful information regarding the unit. This information includes whether or not the unit is running, if it’s enabled (meaning it’s configured to start at boot time), as well as the most recent log entries for the unit:</p>
<pre class="programlisting con"><code class="hljs-con">systemctl status ssh 
</code></pre>
<p class="normal">This command will produce an output something like the following:</p>
<figure class="mediaobject"><img alt="" height="427" src="../Images/B18425_07_09.png" width="876"/></figure>
<p class="packt_figref">Figure 7.9: Checking the status of a unit with systemctl</p>
<p class="normal">Most of the time, you can actually check the status of units without needing <code class="inlineCode">root</code> access, but you may not see all the information available. In the screenshot, you can see several log entries for <a id="_idIndexMarker399"/>the <code class="inlineCode">ssh</code> service, but some units do not show those entries without <code class="inlineCode">sudo</code>. With the <code class="inlineCode">ssh</code> unit in particular, we see the log entries when checking the status with or without <code class="inlineCode">sudo</code>.</p>
<p class="normal">Another thing you may notice in the screenshot is that the name of the <code class="inlineCode">ssh</code> unit is actually <code class="inlineCode">ssh.service</code>, but you don’t need to include the <code class="inlineCode">.service</code> part of the name, since that is implied by default. Sometimes, while viewing the status of a process with <code class="inlineCode">systemctl</code>, the output may be condensed to save space on the screen. To avoid this and see the full log entries, add the <code class="inlineCode">-l</code> option:</p>
<pre class="programlisting con"><code class="hljs-con">systemctl status -l ssh 
</code></pre>
<p class="normal">Another thing to pay attention to is the <code class="inlineCode">vendor preset</code> of the unit. Most packages in Ubuntu that include a service file for <code class="inlineCode">systemd</code> will enable it automatically, but other distributions typically don’t start and enable units by default (such as CentOS). In the case of the <code class="inlineCode">ssh</code> example, you can see that the <code class="inlineCode">vendor preset</code> is set to <code class="inlineCode">enabled</code>. This means that once you install the <code class="inlineCode">openssh-server</code> package, the <code class="inlineCode">ssh.service</code> unit will automatically be enabled. You can confirm this by checking the <code class="inlineCode">Active</code> line (where the example output says <code class="inlineCode">active (running)</code>), which tells us that the unit is running. The <code class="inlineCode">Loaded</code> line clarifies that the unit is <code class="inlineCode">enabled</code>, so we know that the next time we start the server, <code class="inlineCode">ssh</code> will be loaded automatically. Although <code class="inlineCode">systemd</code> units are typically enabled and started automatically in Ubuntu when installing their package, this can still vary. When you install a new package, make sure you check the status of the unit, so you’ll be aware of its settings.</p>
<p class="normal">Starting and stopping a unit is just as easy; all you have to do is change the keyword you use with <code class="inlineCode">systemctl</code> to <code class="inlineCode">start</code> or <code class="inlineCode">stop</code> in order to have the desired effect:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl stop ssh 
sudo systemctl start ssh 
</code></pre>
<p class="normal">There are additional keywords, such as <code class="inlineCode">restart</code> (which takes care of the previous two command examples at the same time), and some units even feature <code class="inlineCode">reload</code>, which allows you to activate new configuration settings without needing to bring down the entire application. An example of why this is useful is with Apache, which serves web pages to local or external users. If you stop Apache, all users will be disconnected from the website you’re serving. If you add a new site, you can use <code class="inlineCode">reload</code> rather than <code class="inlineCode">restart</code>, which will activate any new configuration you may have added without disturbing the existing connections. We’ll take a look at Apache in <em class="chapterRef">Chapter 14</em>, <em class="italic">Serving Web Content</em>, so don’t worry too much about Apache right now. It’s just a good example of a unit with additional functionality. Not all units feature a <code class="inlineCode">reload</code> option, so you should check the documentation of the<a id="_idIndexMarker400"/> application that provides the unit to be sure.</p>
<p class="normal">Since I mentioned starting and stopping the unit for OpenSSH in the previous examples, an interesting aside is that doing so will not disconnect a current SSH session to the server, should you have one open. If you stop the <code class="inlineCode">ssh</code> service, it won’t drop your connection. Open connections are maintained, and stopping SSH only prevents new connections from happening. Therefore, SSH is different when compared to other units (such as Apache) in that existing connections aren’t dropped when restarting the unit.</p>
<p class="normal">As I mentioned before, if you want a unit to automatically start when the server boots, the unit will need to be enabled. Units are automatically enabled most of the time, but in case you find one that isn’t enabled, you can enable it with the <code class="inlineCode">enable</code> keyword:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl enable ssh 
</code></pre>
<p class="normal">It’s just as easy to disable a unit as well:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl disable ssh 
</code></pre>
<p class="normal">You can combine the process of not only enabling a unit, but also starting it at the same time:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl enable --now ssh
</code></pre>
<p class="normal">The <code class="inlineCode">--now</code> argument tells <code class="inlineCode">systemctl</code> to start the unit immediately after enabling it, rather than waiting for the next boot to do so or having you also run the <code class="inlineCode">start</code> argument in a separate command.</p>
<p class="normal">Even though <code class="inlineCode">systemd</code> is primarily used for managing units, it’s actually an entire platform that manages multiple things on a Linux system, including DNS resolving, networking, and more. <code class="inlineCode">systemd</code> even handles logging as well, and it provides us with the <code class="inlineCode">journalctl</code> command, which we can use to view logging info (this is also why the output of <code class="inlineCode">systemctl status ssh</code> was able to show us log entries). </p>
<p class="normal">We’ve discussed logging a bit in <em class="chapterRef">Chapter 4</em>, <em class="italic">Navigating and Essential Commands</em>, and we’ll do so in more detail during <em class="chapterRef">Chapter 22</em>, <em class="italic">Troubleshooting Ubuntu Servers</em> (which will also include further discussion of the <code class="inlineCode">journalctl</code> command). </p>
<p class="normal">For now, just understand that <code class="inlineCode">systemd</code> is quite extensive when it comes to the number of things it helps us manage. For the purposes of this chapter, however, if <a id="_idIndexMarker401"/>you understand how to start, stop, enable, disable, and check the status of a unit, you’re good to go for now.</p>
<h1 class="heading-1" id="_idParaDest-109">Scheduling tasks with cron</h1>
<p class="normal">Earlier in this chapter, we <a id="_idIndexMarker402"/>worked through starting processes and enabling them to run in the background, and ensuring they start as soon as the server boots. In some cases, you may need an application to perform a job at a specific time, rather than to have it always running in the background. This is where <code class="inlineCode">cron</code> comes in. With <code class="inlineCode">cron</code>, you can set a process, program, or script to run at a specific time, down to the minute. Each user is able to have their own set of <code class="inlineCode">cron</code> configurations (known as a <code class="inlineCode">crontab</code>), which can perform any function that a user would be able to do normally. The <code class="inlineCode">root</code> user has a <code class="inlineCode">crontab</code> as well, which allows system-wide administrative tasks to be performed. Each <code class="inlineCode">crontab</code> includes a list of <code class="inlineCode">cron</code> jobs (one per line), which we’ll get into shortly. To view a <code class="inlineCode">crontab</code> for a user, we can use the <code class="inlineCode">crontab</code> command:</p>
<pre class="programlisting con"><code class="hljs-con">crontab -l 
</code></pre>
<p class="normal">With the <code class="inlineCode">-l</code> option, the <code class="inlineCode">crontab</code> command will show you a list of jobs for the user who executed the command. If you execute it as <code class="inlineCode">root</code>, you’ll see the root account’s <code class="inlineCode">crontab</code>. If you execute it as user <code class="inlineCode">jdoe</code>, you’ll see the <code class="inlineCode">crontab</code> for <code class="inlineCode">jdoe</code>, and so on. If you want to view a <code class="inlineCode">crontab</code> for a user other than yourself, you can use the <code class="inlineCode">-u</code> option and specify a user, but you’ll need to execute it as <code class="inlineCode">root</code> or with <code class="inlineCode">sudo</code> to view the <code class="inlineCode">crontab</code> for someone other than the user you’re logged in as:</p>
<pre class="programlisting con"><code class="hljs-con">sudo crontab -u jdoe -l 
</code></pre>
<p class="normal">By default, no user has a <code class="inlineCode">crontab</code> until you create one or more jobs. Therefore, you’ll probably see output such as the following when you check for your current users:</p>
<pre class="programlisting con"><code class="hljs-con">no crontab for jdoe 
</code></pre>
<p class="normal">To create a <code class="inlineCode">cron</code> job, first log in as the user account you want the task to run under. Then, issue the following command:</p>
<pre class="programlisting con"><code class="hljs-con">crontab -e 
</code></pre>
<p class="normal">If you have more than <a id="_idIndexMarker403"/>one text editor on your system, you may see output similar to the following:</p>
<figure class="mediaobject"><img alt="" height="291" src="../Images/B18425_07_10.png" width="595"/></figure>
<p class="packt_figref">Figure 7.10: Selecting an editor for use with the crontab command</p>
<p class="normal">In this case, you’ll simply press the number corresponding to the text editor you’d like to use when creating your <code class="inlineCode">cron</code> job. To set an environment variable that specifies a specific editor and edit your <code class="inlineCode">crontab</code> with a single command, the following command will do exactly that:</p>
<pre class="programlisting con"><code class="hljs-con">EDITOR=vim crontab -e 
</code></pre>
<p class="normal">In this example, you can replace <code class="inlineCode">vim</code> with whatever text editor you prefer. At this point, you should be placed in a text editor with your <code class="inlineCode">crontab</code> file open. The default <code class="inlineCode">crontab</code> file for each user features some helpful comments that give you some useful information regarding how <code class="inlineCode">cron</code> works. To add a new job, you would scroll to the bottom of the file (after all the comments) and insert a new line. Formatting is very particular here, and the example comments in the file give you some clue as to how each line is laid out. Specifically, this part:</p>
<pre class="programlisting code"><code class="hljs-code">m h dom mon dow command 
</code></pre>
<p class="normal">Each <code class="inlineCode">cron</code> job has six fields, each separated by at least one space or tab spaces. If you use more than one space, or tab, <code class="inlineCode">cron</code> is smart enough to parse the file properly. In the first field, we have the minute in which we would like the job to occur. In the second field, we place the hour in the 24-hour format, from 0-23. The third field represents the day of the month. In this<a id="_idIndexMarker404"/> field, you can place a 5 (5th of the month), 23 (23rd of the month), and so on. The fourth field corresponds to the month, such as 3 for March or 12 for December. The fifth field is the day of the week, numbered from 0 to 6 to represent Sunday through Saturday. Finally, in the last field, we have the command to be executed. A few example <code class="inlineCode">crontab</code> lines are as follows:</p>
<pre class="programlisting code"><code class="hljs-code">3 0 * * 4 /usr/local/bin/cleanup.sh 
* 0 * * * /usr/bin/apt update 
0 1 1 * * /usr/local/bin/run_report.sh 
</code></pre>
<p class="normal">With the first example, the <code class="inlineCode">cleanup.sh</code> script, located in <code class="inlineCode">/usr/local/bin</code>, will be run at 12:03 a.m. every Thursday. We know this because the minute column is set to <code class="inlineCode">3</code>, the hour column is set to <code class="inlineCode">0</code> (midnight), the day column is <code class="inlineCode">4</code> (Thursday), and the command column shows a fully qualified command of <code class="inlineCode">/usr/local/bin/cleanup.sh</code>.</p>
<p class="normal">What does it mean for a command to be <em class="italic">fully qualified</em>? Basically, a command being fully qualified means that the entire path to the binary responsible for the command is completely typed out. In the second example, we could have simply typed <code class="inlineCode">apt update</code> for the command and that would’ve probably worked just fine. However, not including the full path to the program is considered bad <code class="inlineCode">cron</code> etiquette. While the command may have worked without being fully qualified, its success would depend on the application being found in the path of the user who is calling it. Not all servers are set up the same, so this might not work depending on how the shell is set up. If you include the full path, the job should run regardless of how the underlying shell is configured.</p>
<p class="normal">If you don’t know what the fully qualified command is, all you have to do is use the <code class="inlineCode">which</code> command. This command, when used with the name of a command you’d like to run, will give you the fully qualified command if the command is located on your system.</p>
<p class="normal">Continuing with the second example, we’re running <code class="inlineCode">/usr/bin/apt update</code> to update our server’s repository index every morning at midnight. The asterisks on each line refer to <em class="italic">any</em>, so with the minute column being simply <code class="inlineCode">*</code>, that means that this task is eligible for any minute. Basically, the only field we clarified was the hour field, which we set to <code class="inlineCode">0</code> in order to represent 12:00 a.m.</p>
<p class="normal">With the third example, we’re running the <code class="inlineCode">/usr/local/bin/run_report.sh</code> script on the first day of every month at 01:00 a.m. If you notice, we set the third column (<strong class="keyWord">day of month</strong>) to <code class="inlineCode">1</code>, which is the same as February 1st, March 1st, and so on. This job will be run if it’s the first day of the month, but only if the current time is also 01:00 a.m., since we filled in the first and second columns, which represent the minute and hour, respectively.</p>
<p class="normal">Once you finish editing a user’s <code class="inlineCode">crontab</code> and save it, <code class="inlineCode">cron</code> is updated and, from that point forward, will execute the task at the time you select. The <code class="inlineCode">crontab</code> will be executed according to the current time and date on your server, so you want to make sure that that is correct as well, otherwise you’ll have your jobs execute at unexpected times. You can view the current date and time on your server by simply issuing the <code class="inlineCode">date</code> command.</p>
<p class="normal">To get the hang of <a id="_idIndexMarker405"/>creating jobs with <code class="inlineCode">cron</code>, the best way (as always) is to practice. The second example <code class="inlineCode">cron</code> job is probably a good one to experiment with, as updating your repository index isn’t going to hurt anything.</p>
<h1 class="heading-1" id="_idParaDest-110">Summary</h1>
<p class="normal">In this chapter, we learned how to manage processes. We began with a look at the <code class="inlineCode">ps</code> command, which we can use to view a list of processes that are currently running. We also took a look at managing jobs, as well as killing processes that, for one reason or another, are misbehaving. We also discussed methods of changing the priority of a process, to ensure we have full control over which processes are given more processing time, and we also learned how we can schedule things to run at a later time and date with <code class="inlineCode">cron</code>.</p>
<p class="normal">In <em class="chapterRef">Chapter 8</em>, <em class="italic">Monitoring System Resources</em>, we’ll take a look at some ways we can keep an eye on the resources that are available on our server, where we will learn how to check disk usage and understand memory usage and swap space, as well as a looking at some utilities that can make resource management a breeze.</p>
<h1 class="heading-1" id="_idParaDest-111">Relevant videos</h1>
<ul>
<li class="bulletList">Getting started with tmux (LearnLinuxTV): <a href="https://linux.video/tmux-guide"><span class="url">https://linux.video/tmux-guide</span></a></li>
<li class="bulletList">Backgrounding and foregrounding processes in Linux (LearnLinuxTV): <a href="https://linux.video/bg-fg"><span class="url">https://linux.video/bg-fg</span></a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-112">Further reading</h1>
<ul>
<li class="bulletList">Ham Vocke, <em class="italic">A Quick and Easy Guide to tmux</em>: <a href="https://learnlinux.link/tmux-article"><span class="url">https://learnlinux.link/tmux-article</span></a></li>
<li class="bulletList">Tmux cheat sheet and quick reference: <a href="https://learnlinux.link/tcs"><span class="url">https://learnlinux.link/tcs</span></a></li>
<li class="bulletList">crontab guru: <a href="https://learnlinux.link/ctg"><span class="url">https://learnlinux.link/ctg</span></a></li>
</ul>
<h1 class="heading-1">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers: </p>
<p class="normal"><a href="https://packt.link/LWaZ0"><span class="url">https://packt.link/LWaZ0</span></a></p>
<p class="normal"><img alt="" height="177" src="../Images/QR_Code50046724-1955875156.png" width="177"/></p>
</div>
</div></body></html>