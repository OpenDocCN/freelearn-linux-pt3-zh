- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigating and Essential Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point in our journey, we’ve already covered a lot of ground—we’ve learned
    how to deploy an Ubuntu server, how to manage users, and most recently, how to
    manage software packages. Before we go too far, we should take a moment to learn
    some important concepts and commands that will allow us to build more of the foundational
    knowledge that will serve us well for the remainder of the book and beyond. These
    foundational concepts include core Linux commands for navigating the shell, the
    Linux filesystem layout, viewing the contents of files, and even checking on log
    files. Specifically, this discussion will include:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning essential Linux commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Linux filesystem layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing the contents of files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing application log files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take some time to learn some essential Linux commands that will help strengthen
    our command-line skills.
  prefs: []
  type: TYPE_NORMAL
- en: Learning essential Linux commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a solid competency on the command line is essential and effectively
    gives any system administrator or engineer superpowers. Our new abilities won’t
    allow us to leap tall buildings in a single bound but will definitely enable us
    to execute terminal commands as if we’re command-line ninjas. While we won’t completely
    master the art of using the command line in this section (that can only come with
    years and experience), we will definitely become more confident.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s talk about moving from one place to another within the Linux filesystem.
    Specifically, by “Linux filesystem,” I’m referring to the default structure of
    the various folders (also referred to as “directories”) contained within your
    Ubuntu installation. The Linux filesystem contains many important directories,
    each with its own designated purpose, which we’ll talk about in more detail later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can explore that further, we’ll need to learn how to navigate from
    one directory to another. The first command we’ll cover in this section relative
    to navigating the filesystem will clarify the directory you’re currently working
    from. For that, we have the `pwd` command. This stands for **print working directory**
    and shows you where you currently are in the filesystem. If you run it, you may
    see output such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Viewing the current working directory'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, when I ran `pwd`, the output informed me that my current working
    directory is `/home/jay`. This is known as your home directory and, by default,
    every user has one (as we discussed in *Chapter 2*, *Managing Users and Permissions*).
    This is where all the files for your user account will reside by default. Sure,
    you can create files anywhere you’d like, even outside your home directory if
    you have permission to do so or you use `sudo`. But just because you *can* doesn’t
    mean you *should*. As you’ll learn in this chapter, the Linux filesystem has a
    designated place for just about everything. But your home directory, located at
    `/home/<username>`, is yours. You own it, you control it—it’s your home on the
    server. In the early 2000s, Linux installations with a graphical user interface
    even depicted your home directory with an icon of a house.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, files that you create in your home directory will have permission
    strings similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We’ve discussed permissions and gone over how to read a permission string in
    *Chapter 2*, *Managing Users and Permissions*, but you can see that by default,
    files you create in your home directory are owned by your user, your group, and
    are readable by all three categories (user, group, and other).
  prefs: []
  type: TYPE_NORMAL
- en: 'To change our current directory and navigate to another, we can use the `cd`
    command along with a path we’d like to move to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I haven’t gone over the file and directory layout yet, so I just randomly
    picked the `/etc` directory. The forward slash at the beginning designates the
    beginning of the filesystem. More on that later. Now, we’re in the `/etc` directory,
    and our command prompt has even changed as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Command prompt and pwd command after changing a directory'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you could probably guess, the `cd` command stands for *change directory*,
    and it’s how you move your working directory from one to another while navigating
    around. You can use the following command, for example, to return back to the
    home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, there are several ways to return home, a few of which are demonstrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Other ways of navigating to the home directory'
  prefs: []
  type: TYPE_NORMAL
- en: The first command, `cd -`, doesn’t actually have anything to do with your home
    directory specifically. It’s a neat trick to return you to whatever directory
    you were in most recently. For me, the `cd –` command took me to the previous
    directory I was in, which just so happened to be `/home/jay`. The second command,
    `cd /home/jay`, took me directly to my home directory since I called out the entire
    path. The last command, `cd ~`, also took me to my home directory. This is because
    `~` is shorthand for the full path to your home directory, so you don’t really
    ever have to type out the entire path to `/home/<user>`. You can just refer to
    that path simply as `~`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another essential command is `ls`. The `ls` command lists the contents of the
    current working directory. We probably don’t have any content in our home directory
    yet. But if we navigate to `/etc` by running `cd /etc`, as we did earlier, and
    then execute `ls`, we’ll see that the `/etc` directory has a number of files in
    it. Go ahead and try it yourself and see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We didn’t actually have to change our working directory to `/etc` just to list
    the contents. We could’ve just executed the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Even better, we can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This gives us the contents in a long list, which I think is much easier to understand.
    It will show each directory or file entry on its own line, along with the permission
    string. But, you probably already remember `ls` as well as `ls -l` from back in
    *Chapter 2*, *Managing Users and Permissions*, so I won’t go into too much more
    detail here. The `-l` portion of the `ls` command in that example is known as
    an **argument**. I’m not referring to an argument such as the ever-ensuing debate
    in the Linux community over which command-line text editor is the best between
    Vim and Emacs (it’s clearly Vim). Instead, I’m referring to the concept of an
    argument in shell commands that allow you to override the defaults, or feed options
    to the command in some way, such as in this example, where we format the output
    of `ls` to be in a long list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rm` command is another one that we touched on in *Chapter 2*, *Managing
    Users and Permissions*, when we were discussing manually removing the home directory
    of a user that was removed from the system. So, at this point, you’re probably
    well aware of that command and what it does (it removes files and directories).
    It’s a potentially dangerous command, as you could use it to accidentally remove
    something that you shouldn’t have. In that chapter, we used the following command
    to remove the home directory of user `dscully`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we’re using the `-r` argument to alter the behavior of the `rm`
    command, which, by default, doesn’t remove directories but only files. The `-r`
    argument instructs `rm` to remove everything recursively, even if it’s a directory.
    The `-r` argument will also remove subdirectories of the path as well, so you’ll
    definitely want to be careful with this command. As I’ve mentioned earlier in
    the book, if you use `sudo` with `rm`, you can hypothetically delete your entire
    Ubuntu installation!
  prefs: []
  type: TYPE_NORMAL
- en: Another option offered by `rm` is the `-f` argument, which is short for *force*,
    and it tells `rm` not to prompt before removing things. This argument won’t be
    needed as often, and use cases for it are outside the scope of this chapter. But
    keep in mind that it exists, should you need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another foundational command that’s good to know is `touch`, which actually
    serves two purposes. First, assuming you have permission to do so in your current
    working directory, the `touch` command will create an empty file if it doesn’t
    already exist. Second, the `touch` command will update the modification time of
    a file or directory if it does already exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Experimenting with the touch command'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, in the related screenshot, I ran several commands. First,
    I ran the following command to create an empty file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That file didn’t exist before, so when I ran `ls -l` afterward, it showed the
    newly created file with a size of 0 bytes. Next, I ran the `touch testfile.txt`
    command again a minute later, and you can see in the screenshot that the modification
    time went from `15:12` to `15:13`.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to viewing the contents of a file, we’ll get to that later on
    in this chapter. And there are definitely more commands that we’ll need to learn
    to build the basis of our foundation. But for now, let’s take a break from the
    foundational concepts to understand the Linux filesystem layout better, which
    is pretty much mandatory for some of the commands we’ll learn later.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Linux filesystem layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned earlier, every directory in a Linux installation has a designated
    purpose. It isn’t a hard rule that you have to follow, more of a strong recommendation
    for where certain things are supposed to go.
  prefs: []
  type: TYPE_NORMAL
- en: You can certainly go against the recommendations; ultimately, you have full
    control over your installation. But, if you make it a habit to place files in
    strange locations, you may annoy your colleagues. In this section, we’ll go over
    the most common directories and talk about their purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The term *filesystem* itself can be somewhat confusing in the Linux world because
    it can refer to two different things—the default directory structure, as well
    as the actual filesystem we choose when formatting a volume such as a hard drive
    or flash drive (ext4, XFS, and so on). Specific to this section, we’re going to
    take a quick look at the Linux filesystem in the context of the default directory
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux (Ubuntu uses the Linux kernel and related utilities, so therefore it
    is a *distribution* of Linux), the filesystem begins with a single forward slash,
    `/`. This is considered the beginning of the filesystem, and directories and sub-directories
    branch out from there. For example, consider the `/home` directory. This directory
    exists at the root level of the filesystem, which you can see from the fact that
    it begins with a forward slash. The home directory on my system is `/home/jay`,
    which means that it’s the `jay` directory, which is inside the `home` directory,
    and that directory is at the beginning of the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: This is confusing at first but becomes very logical once you become accustomed
    to it. If you’re familiar with Microsoft Windows, then you can technically think
    of `/` as the `C:` drive. It’s actually a bit more complex than that, but if we
    forego some of the quirks, that comparison works. To really bring this home, use
    the `ls` command against several directories on your server. If you execute `ls
    /`, you will see all of the directories at the root of the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see the `home` directory among the results, among many others. For those
    of you who prefer a more visual representation, the following screenshot shows
    an example filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18425_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Diagram of a portion of a typical Linux filesystem'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Linux filesystem resembles a tree, with a main branch that
    extends outward and directories branch out from one another. This default directory
    structure is part of the **Filesystem Hierarchy Standard** (**FHS**), which is
    a set of guidelines that defines how the directory structure is laid out. This
    specification defines the names of the directories, where they are located, and
    what they are for. Distributions will sometimes go against some of the definitions
    here, but for the most part, follow it fairly closely. This is why you may see
    a very similar (if not the same) directory structure on distributions of Linux
    other than Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: So, why is this important? As I mentioned, each directory generally has a purpose.
    There are some debates about the default layout from time to time, and some changes
    are made every now and then. But in regard to Linux, the filesystem layout tends
    to change less frequently than other things do.
  prefs: []
  type: TYPE_NORMAL
- en: A full walkthrough of the FHS would be astronomical, but I have included a link
    to this specification at the end of the chapter should you decide to read more
    about it. There are some directories you definitely should know, however. Here
    are some of the more important ones.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Directory** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | The beginning of the filesystem; all directories are underneath this
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/etc` | System-wide application configuration |'
  prefs: []
  type: TYPE_TB
- en: '| `/home` | User home directories |'
  prefs: []
  type: TYPE_TB
- en: '| `/root` | The home directory for root (root doesn’t have a directory under
    /home) |'
  prefs: []
  type: TYPE_TB
- en: '| `/media` | For removable media, such as flash drives |'
  prefs: []
  type: TYPE_TB
- en: '| `/mnt` | For volumes that are intended to stay mounted for a while |'
  prefs: []
  type: TYPE_TB
- en: '| `/opt` | Additional software packages (some programs are installed here,
    not as common) |'
  prefs: []
  type: TYPE_TB
- en: '| `/bin` | Essential user binaries (ls, cp, and so on) |'
  prefs: []
  type: TYPE_TB
- en: '| `/proc` | Virtual filesystem for OS-level components |'
  prefs: []
  type: TYPE_TB
- en: '| `/usr/bin` | A majority of user commands |'
  prefs: []
  type: TYPE_TB
- en: '| `/usr/lib` | Libraries |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log` | Log files |'
  prefs: []
  type: TYPE_TB
- en: The `/etc` directory deserves some additional discussion, as you’ll no doubt
    be working with it a lot. This directory, as mentioned in the preceding table,
    holds configuration files for applications that are intended to be respected system-wide.
    For example, if you’re running the OpenSSH daemon on your server, you’re listening
    for connections via port 22 by default. (Don’t worry, we’ll discuss these individual
    concepts in further chapters.) The configuration file for the OpenSSH server is
    located in the `/etc/ssh` directory. Since OpenSSH is a service that runs on the
    system as a background process, its configuration is stored in the `sshd_config`
    file inside that directory. If you remove the package responsible for providing
    OpenSSH, the configuration is retained in that file (removing packages doesn’t
    also remove config files by default), so if you go to reinstall OpenSSH later,
    you’ll have the same configuration the next time. If we want to wipe out the configuration
    while uninstalling a package, we can use the `--purge` option with the `apt remove`
    command to do so, as we saw in *Chapter 3*, *Managing Software Packages*.
  prefs: []
  type: TYPE_NORMAL
- en: Other directories of importance will be discussed as we progress through the
    topics in this book. Don’t worry if some of this doesn’t make sense right now;
    it will come with time. The main point here is that there are many directories,
    each having its own purpose. If you want to know the purpose of a particular directory,
    consult the FHS. If you’re curious where you should place something on a server,
    also consult the FHS. But again, don’t worry too much about doing research outside
    of this book, as we’ll cover the necessary topics as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a better understanding of the default filesystem layout and the
    purpose of some common directories. In the next section, we’ll explore how we
    can view the contents of files stored in those directories.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the contents of files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux filesystem contains many directories and files. In the case of files,
    we need to learn how to read and manipulate them to round out our knowledge. We’ll
    cover more topics surrounding file management in the next chapter. For now, we
    can benefit by taking a look at how to view the content of existing files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can print the contents of a file to the screen with the `cat` command, along
    with a filename as an argument. The following command, for example, can be used
    to view the contents of `testfile.txt` in our current working directory, which
    we created earlier in the chapter when we discussed the `touch` command. Sure,
    this exercise is rather pointless since that file is empty, but it offers a good
    first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s no output, since again, the file is empty. So, let’s instead take a
    look at a more practical example. Here’s a file we can use `cat` against that
    actually does have content inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_04_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Viewing the contents of /etc/os-release'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/etc/os-release` file is one that exists on many distributions. It’s a
    special file that gives you some information about the distribution of Linux that’s
    currently installed. If you were to connect to a Linux server and wanted to know
    which distribution it was running, viewing the contents of this file is one way
    to find out. You can also view some of the same info in abbreviated form via the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'That command also works on various distributions, but I prefer the `/etc/os-release`
    file because it contains more information. Regardless, the entire point of this
    exercise is to demonstrate that the `cat` command allows you to view the contents
    of a file. More or less, there are other commands that also let you do the same
    thing. And I mean that literally—you can also try viewing the contents of `/etc/os-release`
    with `more` or `less`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `more` command allows you to more easily view larger files, so the benefit
    won’t be as immediately apparent with a file as short as `/etc/os-release`. If
    you use `more` to view a longer file, it will stop the output when it fills the
    screen, and allow you to press *Enter* to advance to the next line.
  prefs: []
  type: TYPE_NORMAL
- en: The `less` command allows you to do the same thing, but also allows you to not
    only use your arrow keys in addition to *Enter* to view more output; it also allows
    you to advance forward or backward as well. So essentially, the `less` command
    gives you more features than the `more` command does.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we also have the `grep` command at our disposal. It’s not typically
    used to simply view the contents of a file, but it’s definitely a great command
    to know that can help you view specifically what you want to view, rather than
    the entire file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you chose to install the OpenSSH server when you first installed Ubuntu
    Server, you should have the config file for it in your installation, and you can
    view the contents of that file with `cat` as we normally would:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, that’s going to dump the contents of that file onto our screen,
    and the file is many more lines than what the typical monitor is able to display
    all at once. We might be interested in a particular line or word, so we’ll need
    to be able to narrow down the file to what we actually care about. We’ll talk
    about the OpenSSH server in more detail in *Chapter 10*, *Connecting to Networks*,
    so don’t worry about what this configuration file means yet. Let’s just say, hypothetically,
    we’re only interested in the port that OpenSSH is listening on. We can use the
    `grep` command to try and print only the lines of the `/etc/ssh/sshd_config` file
    that pertain to that specific configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_04_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Viewing the contents of the /etc/ssh/sshd_config file with grep
    to find lines containing “Port”'
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, what we’re doing is instructing `grep` to print only the lines
    of the `/etc/ssh/sshd_config` file that contain the string `Port`. In the screenshot,
    a single line contained a match for that string, so it displayed. That output
    is certainly better than scrolling through the 123 lines of text in the file,
    when we’re only interested in lines pertaining to the port.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `grep` is case-sensitive. This means that if we were to use `grep`
    to find lines matching “port” (with a lowercase P), we would get no output at
    all. We can simply add the `-i` argument to make the search case-insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s very common to see the `grep` command paired with another command, such
    as `cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That’s a perfectly valid command and will do the same thing. However, it’s fairly
    redundant. We’ll get into the concept of redirecting output in the next chapter,
    but essentially this command takes the output of the `cat` command and redirects
    it as input to the `grep` command. Using `cat` to first print out the file and
    then have `grep` grab the contents of that file and search it for a string is
    a two-step process where only one step is required. But again, it’s still a valid
    command.
  prefs: []
  type: TYPE_NORMAL
- en: To this day, I’ll personally use the `cat` command with `grep` to do the same
    thing out of habit, as this was how all new Linux users were taught back when
    I started. You’ll even see me do this in my YouTube videos—old habits are hard
    to break!
  prefs: []
  type: TYPE_NORMAL
- en: Log files are a great source of information about what’s going on in the background
    of your server, and are especially useful for troubleshooting. We’ll now transition
    into a discussion on viewing these files and some relevant commands pertaining
    to logging.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing application log files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section of this chapter, let’s explore log files a bit, as they
    bring several concepts that we’ve discussed full circle. We went through an overview
    of the default directory layout, practiced viewing files, and we learned how to
    search files for strings. We’ll discuss log files in greater detail later on in
    the book, but we can use all of these concepts to take an initial look at viewing
    log files now.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, during the discussion of the Linux filesystem layout earlier
    in this chapter, there was a table showing some of the most common directories
    that exist. Among the items in that table, I called out the `/var/log` directory.
    While logging is transitioning to a different style (more on that in *Chapter
    22*, *Troubleshooting Ubuntu Servers*), we’ll have a series of logs in the `/var/log`
    directory. Go ahead and use the `ls` command yourself, and you’ll see there are
    quite a few files there. While I won’t go through all of them in this chapter,
    let’s take a look at `/var/log/syslog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of this file is going to have quite a few lines. This is the system
    log, which is used to view informational messages about what’s going on in the
    background as Ubuntu runs on your server, and will show warnings and errors as
    well. If you run into a problem where something isn’t working quite right, you
    may see output in the system log that will provide you with some sort of error
    you can look up in a search engine so you can try and find a resolution. For example,
    you can use `grep` to view any lines that contain the search term *Network* if
    you’re having issues with your connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That’s just a hypothetical example, but it may show lines that are relevant.
    Adjust your search term to whatever you’re interested in finding.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also a good time to introduce you to the `head` and `tail` commands.
    These commands will show the first ten or last ten lines of a file, respectively.
    This is useful for the `/var/log/syslog` file because again, that file is quite
    large, and you may only be interested in certain lines. You can also adjust the
    number of lines the `head` and `tail` commands show with the `-n` option with
    a desired number of lines. For example, to view the last `100` lines of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Perhaps even more useful is the `-f` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to follow (watch) a file in (almost) real time. With the `-f`
    option, the terminal will continue to display new lines in this file as they’re
    appended, so you can monitor the log file as someone attempts to reproduce a problem,
    for example. You can press *Ctrl* + *c* on your keyboard to break out of the follow
    mode and return back to the command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are many more foundational commands and concepts that we can
    go over, but I think that this is enough for now. In the next chapter, we’ll expand
    on this further. But for now, I recommend you practice all of the concepts in
    this chapter until you’re familiar with them before we go on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are more Linux commands than you’ll ever be able to memorize. Most of
    us just memorize our favorite commands and variations of commands, and you’ll
    develop your own menu of these commands as you learn and expand your knowledge.
    In this chapter, we covered many of the foundational commands that are, for the
    most part, essential. Commands such as `grep`, `cat`, `cd`, `ls`, and others were
    explored this time around. The next chapter is essentially a continuation of this
    one, but I wanted to split the foundational concepts into two chapters rather
    than one enormous one.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll expand our foundational knowledge with a deeper look
    at file management, including editing files, input/output streams, and symbolic
    links, and we’ll even reveal the secret to life itself. Well, maybe not the latter,
    but the next chapter will still be great. See you there!
  prefs: []
  type: TYPE_NORMAL
- en: Relevant video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux Crash Course – Navigating the Linux Filesystem (LearnLinuxTV): [https://linux.video/lcc-navigating](https://linux.video/lcc-navigating)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Filesystem Hierarchy Standard: [https://learnlinux.link/fhs-doc](https://learnlinux.link/fhs-doc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UsingTheTerminal: [https://learnlinux.link/using-term](https://learnlinux.link/using-term)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code50046724-1955875156.png)'
  prefs: []
  type: TYPE_IMG
