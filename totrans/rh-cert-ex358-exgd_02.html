<html><head></head><body>
		<div id="_idContainer039">
			<h1 id="_idParaDest-27" class="chapter-number"><a id="_idTextAnchor027"/>2</h1>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor028"/>Network File Storage – Expanding Your Knowledge of How to Share Data </h1>
			<p>In this chapter, we’re <a id="_idIndexMarker061"/>going to cover the topics of <strong class="bold">Network File Storage</strong> (<strong class="bold">NFS</strong>) and Samba using <strong class="bold">Server Message Block</strong> (<strong class="bold">SMB</strong>) storage. These <a id="_idIndexMarker062"/>are two network-based file-sharing options. One (NFS) is heavily used in Linux, while the other is the mainstay of Windows, which is SMB (in our case, Samba). We are going to learn how to set up both of these target folders and share them with the world. We will go over making sure they are only available to those we are attempting to share access with. We will show how we can ensure that unauthorized access does not occur – well, to the best of our abilities; people <span class="No-Break">are sneaky.</span></p>
			<p>After we set those up manually, we will work on setting them up through automation using Ansible. This can make it extremely easy to set up new servers to access file shares that are needed for every new server in an automated fashion. This ensures that each new server has the required access without worrying whether you forgot to add one of the folders. Automation helps take the headache out of system admin work and with Ansible, it is even easier. Let’s get started in the world of NFS; it only makes our <span class="No-Break">lives easier.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>NFS and SMB network storage – the way they work and when to choose one over <span class="No-Break">the other</span></li>
				<li>NFS manual provisioning <span class="No-Break">and deployment</span></li>
				<li>NFS Ansible Automation playbook creation <span class="No-Break">and usage</span></li>
				<li>SMB storage manual provisioning <span class="No-Break">and deployment</span></li>
				<li>SMB storage Ansible Automation playbook creation <span class="No-Break">and usage</span></li>
			</ul>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor029"/>Technical requirements</h1>
			<p>This section covers the technical requirements for <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor030"/>Setting up GitHub access</h2>
			<p>Please refer to <a href="B18607_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise Linux</em>, for gaining access to GitHub. You will find the Ansible Automation playbooks <a id="_idIndexMarker063"/>for this chapter at the following link: <a href="https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter02">https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter02</a>. Remember, these are suggested playbooks and are not the only way you can write them to make the playbooks work <span class="No-Break">for you.</span></p>
			<p>You can always change them up using <strong class="source-inline">raw</strong>, <strong class="source-inline">shell</strong>, or <strong class="source-inline">cmd</strong> to achieve the same results, but we are demonstrating the best way to accomplish the goals. Also, keep in mind that we are <a id="_idIndexMarker064"/>not using the <strong class="bold">Fully Qaulified Collection Name</strong> (<strong class="bold">FQCN</strong>) that is needed in the future version of Ansible, as that will not be supported in the exam as it is testing against <span class="No-Break">Ansible 2.9.</span></p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/>Setting up your lab environment for NFS and SMB</h2>
			<p>Please <a id="_idIndexMarker065"/>refer to the setup of the lab environment <a id="_idIndexMarker066"/>from <a href="B18607_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise Linux</em>, if not <a id="_idIndexMarker067"/>already completed. You <a id="_idIndexMarker068"/>can also use this opportunity to create snapshots of your environment so that you can revert to them and do the hands-on exercises over and over again. This can be accomplished <span class="No-Break">as follows.</span></p>
			<p>Snapshots are easy to create in VirtualBox: you simply need to click on the following button that is selected with the mouse cursor to create <span class="No-Break">a snapshot:</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_2.01_B18607.jpg" alt="Figure 2.1 – VirtualBox options button to open snapshot ﻿creation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – VirtualBox options button to open snapshot creation</p>
			<p>Click <a id="_idIndexMarker069"/>to take one at the top and then name your <a id="_idIndexMarker070"/>snapshot. This will allow you to determine <a id="_idIndexMarker071"/>the state of the <a id="_idIndexMarker072"/>machine image when the snapshot was taken. This can be seen in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_2.02_B18607.jpg" alt="Figure 2.2 – VirtualBox snapshot save feature"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – VirtualBox snapshot save feature</p>
			<p>This will wrap up taking a snapshot in order to revert to previous states for repeated hands-on rework. Now, let’s get into the <span class="No-Break">storage wars.</span></p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor032"/>NFS and SMB network storage – the way they work and when to choose one over the other</h1>
			<p>NFS is a great way to share files across Linux systems. It is machine-based authentication <a id="_idIndexMarker073"/>so the system can have access to the files for all users. This is great for Linux when sharing small files as the speed is increased and the system shares are retrieved more efficiently. SMB, on the other hand, is user authentication-based and better suited for interactions with Windows computers. So, if you have a <a id="_idIndexMarker074"/>multivendor environment, it might be worthwhile to set up SMB as it has the ability to share printers as well. This allows for file sharing as well as printer sharing, thus giving a slight multi-functional edge to the system to make up for the slight <span class="No-Break">speed loss.</span></p>
			<p>The differences in authentication make for some differences in setup and can lead to some headaches when it comes to making sure you are locking down the right permissions. SMB using user-based authentication is a bit better because, with NFS, anyone with access to the allowed machine can gain access to the files being shared. So, in reality, it is more of a toss-up of what you need, such as security or multivendor support in your environment, when it comes to choosing to implement either of the two. In most cases, both are actually implemented for different <span class="No-Break">system uses.</span></p>
			<p>Let’s go into a little more depth on NFS and what it can do for RHEL 8.1 users and Linux overall through setting it up hands-on. This will show you how to set up NFS manually and through automation. RHEL 8.1 supports NFSv3 and NFSv4. NFSv3 can use UDP and TCP, whereas NFSv4 uses TCP. Older versions are no longer supported. Let’s set up NFS on <span class="No-Break">our systems.</span></p>
			<p>Initially, we are going to install the package needed if it is not already installed. This package is the <strong class="source-inline">nfs-utils</strong> package and is needed for the client and the target machines. It provides all the tooling to access folders and mount the needed folders. By installing it on both the server and client, you ensure that you are able to enable all of the dependencies that are needed in order to run <span class="No-Break">the service.</span></p>
			<p>Let’s install <strong class="source-inline">nfs-utils</strong> as shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_2.03_B18607.jpg" alt="Figure 2.3 – Installing the nfs-utils package"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Installing the nfs-utils package</p>
			<p>Now, there is <a id="_idIndexMarker075"/>a small caveat that can lead to frustration – trust me, when <a id="_idIndexMarker076"/>writing this and running into the issue, I was boiling! After a large amount of troubleshooting, the current <strong class="source-inline">2.3.3-51.el8</strong> has a bug that will not allow the exports to share out correctly and the proper permissions to connect. So, after installing NFS, we need to downgrade it one step to <strong class="source-inline">2.3.3-46.el8</strong>, where the bug is not present. In the following figure, it is shown <span class="No-Break">being downgraded:</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_2.04_B18607.jpg" alt="Figure 2.4 – Downgrading nfs-utils"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Downgrading nfs-utils</p>
			<p>This allows <a id="_idIndexMarker077"/>us to do our hands-on exercises without issue. Before, if you <a id="_idIndexMarker078"/>tried to do them, you would be banging your head on your keyboard much like <span class="No-Break">I was.</span></p>
			<p>After the correct version is installed, we are going to enable <span class="No-Break">the daemon:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo systemctl enable --now nfs-server
Created symlink /etc/systemd/system/multi-user.target.wants/nfs-server.service → /usr/lib/systemd/system/nfs-server.service.</pre>
			<p>Then, we have to open the firewall to ensure that connectivity <span class="No-Break">is allowed:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo firewall-cmd --permanent --add-service=nfs
success
[emcleroy@rhel1 ~]$ sudo firewall-cmd --reload
Success</pre>
			<p>Next up, we will be configuring the exports, which are what tell the NFS server what to allow out to the world. The settings are granular and allow for thorough control. The exports allow you to tell the system what can be read and by what machines. You can allow specific machines via DNS, IP, IP range, and <span class="No-Break">so on.</span></p>
			<p>First, let’s make a shared directory <span class="No-Break">as root:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo su -
[root@rhel1 ~]# cd
[root@rhel1 ~]# mkdir -p /share/folder</pre>
			<p>This will be <a id="_idIndexMarker079"/>the folder we share out to the world. Others will access <a id="_idIndexMarker080"/>this to read and write files. We will be editing the <strong class="source-inline">/etc/exports</strong> file to share out <span class="No-Break">this folder.</span></p>
			<p>Here are some examples of a correctly formatted <strong class="source-inline">exports</strong> file. We will talk more about the settings shown in the following screenshot, such <span class="No-Break">as (</span><span class="No-Break"><strong class="source-inline">rw</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_2.05_B18607.jpg" alt="Figure 2.5 – /etc/exports example file for NFS share folder"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – /etc/exports example file for NFS share folder</p>
			<p>As you can see, you can export NFS shares via DNS as noted. You can export via IP and IP range. You can <a id="_idIndexMarker081"/>use space delimited for multiple shared locations if you <a id="_idIndexMarker082"/>do not wish to stack them. You can also put restraints such as read-only or read-write. The <strong class="source-inline">no_root_squash</strong> function allows for root access to the directory instead of the <strong class="source-inline">nobody</strong> user being selected. By default, if a root client creates a file, the <strong class="source-inline">nobody</strong> user owns that file. This can cause issues with access to the file, so it is a good idea to use <strong class="source-inline">no_root_squash</strong>. This gives full root access to the files. Please be aware that the preceding is an example, and duplicates such as the ones shown will be ignored <span class="No-Break">by NFS.</span></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_2.06_B18607.jpg" alt="Figure 2.6 – Correct NFS /etc/exports file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Correct NFS /etc/exports file</p>
			<p>You then <a id="_idIndexMarker083"/>need to run <strong class="source-inline">exportfs -r</strong> in order to update the exports <a id="_idIndexMarker084"/>so that they are served to <span class="No-Break">the endpoints:</span></p>
			<pre class="source-code">
[root@rhel1 ~]# exportfs -r
[root@rhel1 ~]#</pre>
			<p>You can then check your exports to ensure they are being served with the <span class="No-Break"><strong class="source-inline">exportfs</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
[root@rhel1 ~]# exportfs
/share/folder   rhel2
/share/folder   rhel3
/share/folder   192.168.1.0/24
/share/folder   *example.com</pre>
			<p>Next, we are going to mount the folder on another system so that it can <span class="No-Break">share files.</span></p>
			<p>On RHEL3, we are going to run the <strong class="source-inline">mount</strong> command to mount the filesystem. You can also add <a id="_idIndexMarker085"/>this to <strong class="source-inline">fstab</strong> to make <span class="No-Break">this permanent:</span></p>
			<pre class="source-code">
[root@rhel3 ~]# mkdir –p /share
[root@rhel3 ~]# mount -t nfs 192.168.1.198:/share/folder /share</pre>
			<p>Here is <a id="_idIndexMarker086"/>an example of <strong class="source-inline">fstab</strong> for NFS <span class="No-Break">as well:</span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_2.07_B18607.jpg" alt="Figure 2.7 – Example of what fstab would look like"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Example of what fstab would look like</p>
			<p>After that, you should be able to go to the folder and add files to share. The other systems with access can also see <span class="No-Break">these files.</span></p>
			<p>This concludes the walk-through of NFS and how to export it to systems manually. This is what you will be tested on in the exam. The bonus mounting of the system is for your understanding, and I hope that helps you in the future. Now we are going to talk about the automation of the process of NFS <span class="No-Break">server provisioning.</span></p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor033"/>NFS Ansible Automation playbook creation and usage</h1>
			<p>We are <a id="_idIndexMarker087"/>going to delve deeper into the Ansible Automation playbook. We will fully break it down for the NFS exports. We are going <a id="_idIndexMarker088"/>to show each step of the playbook and what each item does. By <em class="italic">item</em>, we are referring to the variables and commands set within an <span class="No-Break">Ansible playbook:</span></p>
			<pre class="source-code">
---
- hosts: exports
  become: true
  become_method: sudo</pre>
			<p>Here, we have the beginning of the playbook. The hosts are the targets of the playbook. These are normally the servers you want to make changes to. These are listed in the inventory file. In this case, we are targeting the <strong class="source-inline">exports</strong> group. In this case, <strong class="source-inline">become</strong> tells Ansible that you want to elevate the user, and <strong class="source-inline">become_method</strong> tells it that you want to use <strong class="source-inline">sudo</strong> to elevate <span class="No-Break">the permissions:</span></p>
			<pre class="source-code">
  tasks:
  - name: Make sure Directory exists
    file:
      path: /share/folder
      owner: root
      state: directory</pre>
			<p>We are now going to move to tasks. These are the actions we want Ansible to take. The first task we see here is to create a directory using the file module. The <strong class="source-inline">name</strong> field is like a comment for a better understanding of the code by other engineers. From there, we see the other items we set, and then there are assumed defaults. As mentioned in <a href="B18607_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise Linux</em>, you can use the <strong class="source-inline">ansible-doc</strong> file to see the usage <span class="No-Break">and examples:</span></p>
			<pre class="source-code">
  - name: Install nfs utilities
    package:
      name: nfs-utils
      state: "2.3.3-46.el8"</pre>
			<p>Normally, you would use the latest state; however, in our case, that would cause the system to encounter the bug that fails connectivity. It should work fine with the latest on the <span class="No-Break">exam though.</span></p>
			<p>In this task, we installed the <strong class="source-inline">nfs-utilities</strong> package using the generic package installer <a id="_idIndexMarker089"/>for Ansible. This uses the facts <a id="_idIndexMarker090"/>gathered by Ansible. By using those facts, it knows to use <strong class="source-inline">dnf</strong> to install <span class="No-Break">the software:</span></p>
			<pre class="source-code">
  - name: the directory is shared
    copy:
      content: "/share/folder *(rw,no_root_squash)\n"
      dest: /etc/exports</pre>
			<p>Using the <strong class="source-inline">copy</strong> module, we are replacing the current <strong class="source-inline">exports</strong> file. If this was a multiline exports file, it would need to be a template, <strong class="source-inline">lineinfile</strong>, or all lines would need to be in the task. Here, we are using the <strong class="source-inline">service</strong> module to enable and start the <strong class="source-inline">nfs-server</strong> service. This will ensure that the service is started. The service is enabled upon boot. The service also loads the exports, as <strong class="source-inline">nfs-server</strong> is started after the <strong class="source-inline">exports</strong> file <span class="No-Break">was updated:</span></p>
			<pre class="source-code">
  - name: Enable and Start NFS Service
    service:
      name: nfs-server
      state: started
      enabled: yes</pre>
			<p>Using the <strong class="source-inline">firewalld</strong> module, we are going to allow a permanent opening for the NFS file service. This will allow connectivity to the resources we opt to share. Once that is complete, the <strong class="source-inline">exports</strong> playbook is completed, and up next is the <span class="No-Break"><strong class="source-inline">clients</strong></span><span class="No-Break"> playbook:</span></p>
			<pre class="source-code">
  - name: Open firewall for NFS-Server
    firewalld:
      service: nfs
      immediate: yes
      permanent: yes
      state: enabled</pre>
			<p>After we <a id="_idIndexMarker091"/>have finished creating the playbook, we will <a id="_idIndexMarker092"/>use the <strong class="source-inline">ansible-playbook -i inventory nfs_server.yml -u emcleroy -k --ask-become –v</strong> command to execute the playbook. The flag of <strong class="source-inline">-i</strong> indicates the name of the inventory to use. The <strong class="source-inline">-u</strong> flag indicates the username to use when executing the playbook. The <strong class="source-inline">–k</strong> flag indicates to ask for the user password. The <strong class="source-inline">--ask-become</strong> flag specifies that you want to provide the <strong class="source-inline">sudo</strong> password for the playbook run. Finally, <strong class="source-inline">–v</strong> shows additional verbosity so you can see more logs of what is happening when the playbook <span class="No-Break">is running.</span></p>
			<p>Here, we will show a quick view of the playbook used to support the client setup of utilizing a share that has been set up <span class="No-Break">for us:</span></p>
			<pre class="source-code">
---
- hosts: clients
  become: true
  become_method: sudo
  tasks:
  - name: Install nfs utilities
    package:
      name: nfs-utils
      state: present
  - name: Add the NFS share and mount it with fstab
    mount:
      path: /share
      src: 192.168.1.198:/share/folder
      state: mounted
      fstype: nfs</pre>
			<p>This will <a id="_idIndexMarker093"/>install <strong class="source-inline">nfs-utilities</strong> and then <a id="_idIndexMarker094"/>mount the file to the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">share folder</strong></span><span class="No-Break">.</span></p>
			<p>To run the playbook, we will use the following command: <strong class="source-inline">ansible-playbook -i inventory nfs_client.yml -u emcleroy -k --ask-become –v</strong>. That wraps up our foray into NFS. We will now be moving on to some more network-based file storage. We will be discussing SMB, which is most commonly used for Windows systems. We will go through setting it up manually and <span class="No-Break">with automation.</span></p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor034"/>SMB storage manual provisioning and deployment</h1>
			<p>The major <a id="_idIndexMarker095"/>difference when it comes to SMB is that it is the sharing standard for Windows-based systems from Linux systems. The best way to <a id="_idIndexMarker096"/>learn about Samba (another name for SMB) is to get your hands dirty, and that is what we are going to do today. We will be going step by step into how to install and <span class="No-Break">provision SMB.</span></p>
			<p>To start, we are going to install SMB <span class="No-Break">via </span><span class="No-Break"><strong class="source-inline">dnf</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo dnf install samba -y</pre>
			<p>Then, create the share for SMB <span class="No-Break">to serve:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo mkdir -p /share/smbfolder</pre>
			<p>Next, we are going to start and enable the <span class="No-Break"><strong class="source-inline">smb</strong></span><span class="No-Break"> service:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo systemctl enable --now smb
Created symlink /etc/systemd/system/multi-user.target.wants/smb.service → /usr/lib/systemd/system/smb.service.</pre>
			<p>After that, we are going to open the firewall service <span class="No-Break">for Samba:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo firewall-cmd --permanent --add-service=samba
success
[emcleroy@rhel1 ~]$ sudo firewall-cmd  --reload
success</pre>
			<p>With SMB <a id="_idIndexMarker097"/>now installed and the firewall opened, we can <a id="_idIndexMarker098"/>move on to setting up the folder we created. This will allow us to set the SELinux permissions needed. We are going to give access <span class="No-Break">to administrators:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo groupadd admins
[emcleroy@rhel1 ~]$ sudo chgrp admins /share/smbfolder/</pre>
			<p>This will allow us to restrict access to the folder to the <strong class="source-inline">admins</strong> <span class="No-Break">group only.</span></p>
			<p>With SELinux in the enforcing mode, it needs the correct context. As shown in these commands, the correct context is added back to <span class="No-Break">the folder:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo semanage fcontext -a -t samba_share_t "/share/smbfolder(/.*)?"
[emcleroy@rhel1 ~]$ sudo restorecon -Rv /share/smbfolder</pre>
			<p>This allows for the label to stay, even during relabeling events within SELinux. SELinux context is outside the scope of this class and can be researched further online or through other <span class="No-Break">Packt books.</span></p>
			<p>Next, we will work on setting up the <strong class="source-inline">smb.conf</strong> file with the correct information to allow access to the <span class="No-Break"><strong class="source-inline">share</strong></span><span class="No-Break"> folder:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$sudo vi /etc/samba/smb.conf</pre>
			<p>From there, you can see an example of a global Samba config portion and Samba share config portion in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_2.08_B18607.jpg" alt="Figure 2.8 – Global config for SMB with guests allowed"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Global config for SMB with guests allowed</p>
			<p>Next, we have <a id="_idIndexMarker099"/>the guests allowed setting for our <a id="_idIndexMarker100"/>share, <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_2.09_B18607.jpg" alt="Figure 2.9 – Guests are allowed as noted in the guest only statement"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Guests are allowed as noted in the guest only statement</p>
			<p>Finally, here is <a id="_idIndexMarker101"/>an example of having to have a password <a id="_idIndexMarker102"/>to access <span class="No-Break">the folder:</span></p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_2.10_B18607.jpg" alt="Figure 2.10 – As shown here, guest only is set to no so you need to have a user and password"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – As shown here, guest only is set to no so you need to have a user and password</p>
			<p>These <a id="_idIndexMarker103"/>settings allow for control over your <span class="No-Break"><strong class="source-inline">smb</strong></span><span class="No-Break"> share.</span></p>
			<p>Next, we are <a id="_idIndexMarker104"/>going to start the service and create some users. These users and passwords will only be good for the <strong class="source-inline">smb</strong> share. They will not affect the <span class="No-Break">login information:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo adduser -M sambauser -s /sbin/nologin
[emcleroy@rhel1 ~]$ sudo smbpasswd -a sambauser
New SMB password:
Retype new SMB password:
Added user sambauser.</pre>
			<p>Finally, we are going to start up <strong class="source-inline">smb</strong> so that we can use it for our newly <span class="No-Break">created </span><span class="No-Break"><strong class="source-inline">sambauser</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ sudo systemctl start smb</pre>
			<p>In the <a id="_idIndexMarker105"/>following <a id="_idIndexMarker106"/>screenshot, we can see that <strong class="source-inline">smb</strong> <span class="No-Break">is running:</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_2.11_B18607.jpg" alt="Figure 2.11 – SMB successfully running on the system"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – SMB successfully running on the system</p>
			<p>To mount the system, we will have to install <strong class="source-inline">samba-client</strong> on the client machine. As shown in the following screenshot, we are installing <strong class="source-inline">samba-client</strong> <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">rhel2</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_2.12_B18607.jpg" alt="Figure 2.12 – samba-client being installed on rhel2"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – samba-client being installed on rhel2</p>
			<p>This will <a id="_idIndexMarker107"/>allow us to mount the share on <strong class="source-inline">rhel2</strong>. We need <strong class="source-inline">cifs-utils</strong> installed, and <a id="_idIndexMarker108"/>then we can mount using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
[root@rhel2 ~]# dnf install cifs-utils
[root@rhel2 ~]# mkdir –p /share/folder
[root@rhel2 ~]# mount -t cifs -o username=sambauser //192.168.1.198/smbshareconfig /share/folder</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">This code <a id="_idIndexMarker109"/>and the process will all be available via the <strong class="bold">Code in Action</strong> (<strong class="bold">CiA</strong>) videos that are provided <span class="No-Break">by Packt.</span></p>
			<p>Next, we will go over setting up a restricted share to a client on a particular domain. Then we will show how to define which users/groups have read-only or write access. Finally, we will show how to mount permanently using specific <span class="No-Break">user credentials.</span></p>
			<p>Let’s start with how to set up a restricted share to a client on a particular domain. This can be accomplished by setting the security to the <strong class="source-inline">domain</strong> level instead of the <strong class="source-inline">user</strong> level. This can be seen in the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
[global]
workgroup = SAMBA
security = domain</pre>
			<p>Next, to set up <a id="_idIndexMarker110"/>a specific group to have read-write and also allow <a id="_idIndexMarker111"/>other users to have read-only, you would set up the <strong class="source-inline">smb</strong> file for the share to look something like the following when <strong class="source-inline">security</strong> is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">user</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
[smbshareconfig]
path = /smb/smbfolder
valid users = systemadmin1, @engineers
write list = @engineers</pre>
			<p>The preceding file settings will allow <strong class="source-inline">systemadmin1</strong> to have read-only privileges and allow <a id="_idTextAnchor035"/>the <strong class="source-inline">engineers</strong> group to have read-write privileges, and all others will be unable to view <span class="No-Break">the share.</span></p>
			<p>Next, we are going to look at how to set up a permanent mount using CIFS credentials and <strong class="source-inline">fstab</strong> in order to mount the share <span class="No-Break">at startup.</span></p>
			<p>We will start by creating a CIFS credential file, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
[emcleroy@rhel1 ~]$ vi /tmp/creds.txt</pre>
			<p>This will have the following body <span class="No-Break">of text:</span></p>
			<pre class="source-code">
username=smbuser
password=redhat</pre>
			<p>After the file is created, we will use it for login credentials for the mount and add the following to <strong class="source-inline">fstab</strong> to mount the share with <span class="No-Break">these credentials:</span></p>
			<pre class="source-code">
//rhel1.example.com/smbshareconfig /mnt/shared cifs credentials=/tmp/creds.txt,multiuser 0 0</pre>
			<p>That wraps <a id="_idIndexMarker112"/>up the manual portion of SMB storage. We will now <a id="_idIndexMarker113"/>work through the templates and other things needed for the automated approach of setting up SMB storage. Stay tuned for more great information about this and what we need to do to get it working through automation. This will help you with completing the EX358 exam <span class="No-Break">as well.</span></p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor036"/>SMB storage Ansible Automation playbook creation and usage</h1>
			<p>In this section, we will be looking at what is needed in order to set up SMB shares through <a id="_idIndexMarker114"/>Ansible Automation. This will <a id="_idIndexMarker115"/>allow for quicker setup across multiple servers. This will, in turn, also allow you to spend less time on the keyboard and more time focused on what you really want to learn. We have covered the different areas of Ansible in depth, from comments to names to modules. We are going to go through all of this again for SMB storage and show you how to set it up. This again is one way of doing it; there are others with Ansible that will <span class="No-Break">be successful.</span></p>
			<p>Let’s get started as we have with all of the other playbooks we have created. First, we will choose the inventory hosts and escalation points that we want to use. I showed you how to set up the inventory in previous sections so we will skip that. However, here is a snapshot of the inventory for <span class="No-Break">your reference:</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_2.13_B18607.jpg" alt="Figure 2.13 – smb_playbook inventory snapshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – smb_playbook inventory snapshot</p>
			<p>To <a id="_idIndexMarker116"/>start, let’s set up a new directory <a id="_idIndexMarker117"/>for <span class="No-Break">the playbook:</span></p>
			<pre class="source-code">
[emcleroy@rhel3 ~]$ mkdir smb_playbook
[emcleroy@rhel3 ~]$ cd smb_playbook/
[emcleroy@rhel3 smb_playbook]$ vi smb_playbook.yml
---
- hosts: sambashare
  become: true
  become_method: sudo</pre>
			<p>Next, we are going to start the tasks to set up everything needed for samba. First, let’s install it and the client to <span class="No-Break">be thorough:</span></p>
			<pre class="source-code">
  tasks:
    - name: Install Samba and Samba-Client
      package:
        name:
          - samba
          - samba-client
          - cifs-utils
        state: latest</pre>
			<p>This <a id="_idIndexMarker118"/>portion of the code creates <a id="_idIndexMarker119"/>the groups that we will use to set allow functions <span class="No-Break">on SMB:</span></p>
			<pre class="source-code">
    - name: Create groups that are allowed
      group:
        name: "admins"
        system: yes</pre>
			<p>This portion of the code creates the user with a password for SMB. We will have different ways of doing this with loops in the final review, which will allow you to vault passwords and lists of users. This is not recommended as everything is in plain text. This playbook is an example of one way to accomplish <span class="No-Break">the change:</span></p>
			<pre class="source-code">
    - name: Add SMB user
      user:
        name: "smbuser"
        shell: "/sbin/nologin"
        create_home: no
        system: yes
    - name: Set SMB password for user
      command: smbpasswd -s -a smbuser
      args:
        stdin: "redhat\nredhat"</pre>
			<p>This <a id="_idIndexMarker120"/>portion of the code adds the <a id="_idIndexMarker121"/>group that we are using for SMB to <span class="No-Break">the user:</span></p>
			<pre class="source-code">
    - name: Add SMB users to the groups that are allowed
      user:
        name: "smbuser"
        group: "admins"
        append: "true"</pre>
			<p>Here we have created the directory and given the correct <span class="No-Break">SELinux context:</span></p>
			<pre class="source-code">
    - name: Create the directory to share
      file:
        path: "/shared/smbfolder"
        owner: "root"
        group: "admins"
        mode: "2775"
        state: "directory"
        setype: "samba_share_t"</pre>
			<p>Here, we have added the information for our <strong class="source-inline">share</strong> folder to the <span class="No-Break"><strong class="source-inline">smb.conf</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
    - name: Add the directory to the smb.conf file
      blockinfile:
        path: /etc/samba/smb.conf
        block: |
          [sambasharefolder]
                    path = /shared/smbfolder
                    writeable = yes
                    valid users = sambauser, @admins
                    write list = @admins</pre>
			<p>This <a id="_idIndexMarker122"/>portion of the code enables <a id="_idIndexMarker123"/>the SMB service as well as <span class="No-Break">restarting it:</span></p>
			<pre class="source-code">
    - name: Start or restart SMB for changes and enable it
      service:
        name: "smb"
        state: "restarted"
        enabled: "true"</pre>
			<p>This portion of the code opens up the necessary <span class="No-Break">firewall rules:</span></p>
			<pre class="source-code">
    - name: Add firewall rules to allow connectivity out
      firewalld:
        service: "samba"
        state: "enabled"
        immediate: "true"
        permanent: "true"</pre>
			<p>You can then run the playbook on the system using <span class="No-Break">this command:</span></p>
			<pre class="source-code">
[emcleroy@rhel3 smb_playbook]$ ansible-playbook -i inventory smb_playbook.yml -u emcleroy -k --ask-become-pass</pre>
			<p>This will ask you for your <strong class="source-inline">ssh</strong> password and your <strong class="source-inline">become</strong> password for the system. Please ensure that on the Ansible Control node (in our case, <strong class="source-inline">rhel3</strong>), <strong class="source-inline">sshpass</strong> is installed in order to avoid password failures. These can be handled through Ansible Vault as well or through other password credential systems that are out of the scope of <span class="No-Break">this exam.</span></p>
			<p>Next, we <a id="_idIndexMarker124"/>are going to show the <a id="_idIndexMarker125"/>playbook from the client side so that we can mount the new SMB share we created. We are going to create a new playbook <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
---
- hosts: sambaclient
  become: true
  become_method: sudo
  tasks:
    - name: Install Samba and Samba-Client
      package:
        name:
          - samba
          - samba-client
          - cifs-utils
        state: latest
    - name: Create a credential txt file
      copy:
        content: "username=smbuser\npassword=redhat\n"
        dest: /tmp/creds.txt
        owner: "root"
        group: "root"
        mode: "0600"</pre>
			<p>This creates a file with your credentials. You can also vault this file for encryption and <span class="No-Break">use variables:</span></p>
			<pre class="source-code">
    - name: mount directory created
      file:
        path: "/mnt/shared"
        state: directory
        owner: "root"
        group: "root"
    - name: Mount the SMB share.
      shell: "mount -t cifs //192.168.1.198/smbfolder/mnt/shared -o credentials=/tmp/creds.txt"</pre>
			<p>Please <a id="_idIndexMarker126"/>note that the IP address <a id="_idIndexMarker127"/>of the server may be different for your <span class="No-Break">lab setup.</span></p>
			<p>This will mount the SMB share with the credentials you passed to the file. We will explore other ways of doing all of this in the final review with the full video in the CiA videos. The CiA videos will display the manual and automated code being run and will be placed on <span class="No-Break">Packt’s website.</span></p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor037"/>Summary</h1>
			<p>This brings us to the end of this chapter and network file sharing. We have talked about many types of storage up until this point, from iSCSI to SMB. They all have one thing in common and that is networking. We will be moving on to introduce you to the networking aspect of how these things interconnect in our next chapter. We want to ensure that everyone is aware of how RHEL networking is handled, how it is different from traditional networking such as Cisco and others, and how it can help you. We will go over exam objectives and ensure you know how to connect these servers to pass the storage we <span class="No-Break">talked about.</span></p>
		</div>
	

		<div id="_idContainer040" class="Content">
			<h1 id="_idParaDest-37"><a id="_idTextAnchor038"/>Part 2: Red Hat Linux 8 – Configuring and Maintaining Networking with Automation</h1>
			<p>In this part, you will learn to set up and maintain Linux networking functions manually and automatically. This will meet the objectives set to pass the Red Hat <span class="No-Break">EX358 exam.</span></p>
			<p>This part contains the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18607_03.xhtml#_idTextAnchor039"><em class="italic">Chapter 3</em></a>, <em class="italic">Network Services with Automation – Introduction to Red Hat Linux Networking </em></li>
				<li><a href="B18607_03.xhtml#_idTextAnchor039"><em class="italic">Chapter 3</em></a>, <em class="italic">Link Aggregation Creation – Creating Your Own Link and Mastering the Networking Domain </em></li>
				<li><a href="B18607_05.xhtml#_idTextAnchor060"><em class="italic">Chapter 5</em></a>, <em class="italic">DNS, DHCP, and IP Addressing – Gaining Deeper Knowledge of Red Hat Linux Networking </em></li>
			</ul>
		</div>
	</body></html>