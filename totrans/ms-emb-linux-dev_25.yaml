- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: Profiling and Tracing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析与追踪
- en: Interactive debugging using a source-level debugger, as described in the previous
    chapter, can give you an insight into the way a program works, but it constrains
    your view to a small body of code. In this chapter, we will look at the larger
    picture to see whether the system is performing as intended.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用源代码级调试器进行交互式调试，如上一章所述，可以帮助你深入了解程序的工作原理，但它将你的视野限制在一小部分代码上。在本章中，我们将从更宏观的角度来看，是否系统按预期执行。
- en: Programmers and system designers are notoriously bad at guessing where bottlenecks
    are. So, if your system has performance issues, it is wise to start by looking
    at the full system and then work down, using more sophisticated tools as you go.
    In this chapter, I’ll begin with the well-known `top` command as a means of getting
    an overview. Often, the problem can be localized to a single program, which you
    can analyze using the Linux profiler, `perf`. If the problem is not so localized
    and you want to get a broader picture, `perf` can do that as well. To diagnose
    problems associated with the kernel, I will describe some trace tools—Ftrace,
    LTTng, and eBPF—as a means of gathering detailed information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员和系统设计师通常不擅长猜测瓶颈在哪里。因此，如果你的系统存在性能问题，明智的做法是从整体系统开始分析，然后逐步深入，随着进展使用更复杂的工具。本章中，我将从广为人知的
    `top` 命令开始，作为了解概况的手段。通常，问题可能局限于某个程序，你可以使用 Linux 性能分析工具 `perf` 进行分析。如果问题没有那么局限，并且你想获得更广泛的视角，`perf`
    也能做到。为了诊断与内核相关的问题，我将介绍一些追踪工具——Ftrace、LTTng 和 eBPF——作为获取详细信息的手段。
- en: I will also cover Valgrind, which, because of its sandboxed execution environment,
    can monitor a program and report on code as it runs. I will complete the chapter
    with a description of a simple trace tool, `strace`, which reveals the execution
    of a program by tracing the system calls it makes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将介绍 Valgrind，它因其沙盒执行环境，可以监控程序并报告程序运行时的代码。我将通过描述一个简单的追踪工具`strace`来完成本章，它通过追踪程序发出的系统调用，揭示程序的执行过程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Observer effect
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者效应
- en: Beginning to profile
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始进行性能分析
- en: Profiling with `top`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `top` 进行性能分析
- en: Profiling with GDB
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GDB 进行性能分析
- en: Introducing `perf`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 `perf`
- en: Tracing events
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追踪事件
- en: Introducing Ftrace
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Ftrace
- en: Using LTTng
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LTTng
- en: Using eBPF
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 eBPF
- en: Using Valgrind
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Valgrind
- en: Using `strace`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `strace`
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随示例进行操作，请确保你拥有以下内容：
- en: An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行 Ubuntu 24.04 或更高版本 LTS 的主机系统，至少有 90 GB 的空闲磁盘空间
- en: Buildroot 2024.02.6 LTS release
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buildroot 2024.02.6 LTS 版本
- en: A microSD card reader and card
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 microSD 卡读卡器和卡
- en: balenaEtcher for Linux
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于 Linux 的 balenaEtcher
- en: An Ethernet cable and router with an available port for network connectivity
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根以太网线和一个可用端口的路由器，用于网络连接
- en: Raspberry Pi 4
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 4
- en: A 5 V USB-C power supply capable of delivering 3 A
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台能够提供 3A 电流的 5V USB-C 电源
- en: You should have already installed the 2024.02.6 LTS release of Buildroot in
    [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110). If you have not, then refer
    to the *System requirements* section of *The Buildroot user manual* ([https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html))
    before installing Buildroot on your Linux host according to the instructions from
    [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经在 [*第6章*](Chapter_04.xhtml#_idTextAnchor110) 中安装了 Buildroot 2024.02.6 LTS
    版本。如果没有，请参考 *Buildroot 用户手册* 中的 *系统要求* 部分 ([https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html))，然后按照
    [*第6章*](Chapter_04.xhtml#_idTextAnchor110) 中的说明在你的 Linux 主机上安装 Buildroot。
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter20/buildroot](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter20/buildroot).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在本书 GitHub 仓库中的章节文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter20/buildroot](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter20/buildroot)。
- en: Observer effect
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者效应
- en: 'Before diving into the tools, let’s talk about what the tools will show you.
    As is the case in many fields, measuring a certain property affects the observation
    itself. Measuring the electric current in a power supply line requires measuring
    the voltage drop over a small resistor. However, the resistor itself affects the
    current. The same is true for profiling: every system observation has a cost in
    CPU cycles, and that resource is no longer spent on the application. Measurement
    tools also mess up caching behavior, eat memory space, and write to disk, which
    all make it worse. There is no measurement without overhead.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解工具之前，先让我们谈谈这些工具会向你展示什么。就像许多领域一样，测量某个特性会影响到观察本身。测量电源线中的电流需要测量小电阻上的电压降。然而，电阻本身会影响电流。分析也是如此：每一次系统观察都会消耗CPU周期，这些资源就不再用在应用程序上。测量工具还会干扰缓存行为，占用内存空间，写入磁盘，这一切都会使情况变得更糟。没有开销就没有测量。
- en: I’ve often heard engineers say that the results of a profiling job were totally
    misleading. That is usually because they were performing the measurements on something
    not approaching a real situation. Always try to measure on the target, running
    release builds of the software, with a valid dataset preferably obtained from
    the field, using as few extra services as possible.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常听到工程师说，他们做的分析工作完全误导。这通常是因为他们在某些非真实的情况下进行测量。始终尽量在目标系统上进行测量，运行发布版本的软件，并使用有效的数据集，最好是从实际环境中获得，尽量减少额外的服务。
- en: A release build usually implies building fully optimized binaries without debug
    symbols. These production requirements severely limit the functionality of most
    profiling tools.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 发布构建通常意味着构建完全优化过的二进制文件，而没有调试符号。这些生产要求会严重限制大多数分析工具的功能。
- en: Once our system is up and running, we will hit a problem right away. While it
    is important to observe the system in its natural state, the tools often need
    additional information to make sense of the events.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的系统启动并运行起来，我们会立刻遇到一个问题。虽然观察系统的自然状态很重要，但工具往往需要额外的信息才能理解事件。
- en: Some tools require special kernel options. For the tools we are examining in
    this chapter, this applies to `perf`, Ftrace, LTTng, and eBPF. Therefore, you
    will probably have to build and deploy a new kernel for these tests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工具需要特殊的内核选项。对于我们在本章中讨论的工具，这适用于`perf`、Ftrace、LTTng和eBPF。因此，你可能需要为这些测试构建并部署一个新的内核。
- en: 'Debug symbols are very helpful in translating raw program addresses into function
    names and line numbers in source code. Deploying executables with debug symbols
    does not change the execution of the code, but it does require that you have copies
    of the binaries, and a kernel compiled with debug information, at least for the
    components you want to profile. Some tools work best if you have these installed
    on the target system: `perf`, for example. The techniques are the same as for
    general debugging, as I discussed in [*Chapter 19*](Chapter_19.xhtml#_idTextAnchor611).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 调试符号在将原始程序地址转换为函数名和源代码行号时非常有用。部署带有调试符号的可执行文件不会改变代码的执行，但确实要求你拥有二进制文件副本，并且至少对你想要分析的组件，内核需要带有调试信息。一些工具在目标系统上安装这些内容会更有效，比如`perf`。这些技巧与一般调试相同，正如我在[*第19章*](Chapter_19.xhtml#_idTextAnchor611)中讨论的那样。
- en: If you want a tool to generate call graphs, you may have to compile with stack
    frames enabled. If you want the tool to attribute addresses with line numbers
    in source code accurately, you may need to compile with lower levels of optimization.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望工具生成调用图，你可能需要编译时启用堆栈帧。如果你希望工具能准确地将地址与源代码中的行号匹配，你可能需要使用较低级别的优化进行编译。
- en: Finally, some tools require instrumentation to be inserted into the program
    to capture samples, so you will have to recompile those components. This applies
    to Ftrace and LTTng for the kernel.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些工具需要将仪器插入程序中以捕获样本，因此你需要重新编译这些组件。这适用于内核的Ftrace和LTTng。
- en: Be aware that the more you change the system you are observing, the harder it
    is to relate the measurements you make to the production system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你改变被观察系统的程度越大，你所做的测量与生产系统之间的关系就越难以建立。
- en: '**TIP**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: It is best to adopt a wait-and-see approach, making changes only when the need
    is clear, and being mindful that each time you do so, you will change what you
    are measuring.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最好采取等待观察的方法，只有在需要时才进行更改，并时刻注意，每次更改时，你都会改变你正在测量的内容。
- en: Because the results of profiling can be so ambiguous, start with simple, easy-to-use
    tools that are readily available before reaching for more complex and invasive
    instruments.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分析结果可能非常模糊，建议在使用更复杂和入侵性较强的工具之前，先从一些简单、易用且 readily available 的工具入手。
- en: Beginning to profile
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始分析
- en: When looking at the entire system, a good place to start is with a simple tool
    such as `top`, which gives you an overview very quickly. It shows you how much
    memory is being used, which processes are eating CPU cycles, and how this is spread
    across different cores and times.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看整个系统时，一个好的起点是使用像`top`这样简单的工具，它能快速提供概览。它显示了正在使用的内存量、哪些进程消耗了CPU周期，以及这些消耗如何分布在不同的核心和时间上。
- en: If `top` shows that a single application is using up all the CPU cycles in user
    space, then you can profile that application using `perf`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`top`显示单个应用程序占用了所有的用户空间CPU周期，那么你可以使用`perf`对该应用程序进行分析。
- en: If two or more processes have a high CPU usage, there is probably something
    that is coupling them together, perhaps data communication. If a lot of cycles
    are spent on system calls or handling interrupts, then there may be an issue with
    the kernel configuration or with a device driver. In either case, you need to
    start by taking a profile of the whole system, again using `perf`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个或更多进程的CPU使用率很高，可能是它们之间有某种关联，可能是数据通信。如果大量时间花费在系统调用或处理中断上，那么可能是内核配置或设备驱动程序出现问题。在任何情况下，你需要首先使用`perf`对整个系统进行分析。
- en: If you want to find out more about the kernel and the sequencing of events there,
    use Ftrace, LTTng, or eBPF.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于内核和事件顺序的内容，可以使用Ftrace、LTTng或eBPF。
- en: There could be other problems that `top` will not help you with. If you have
    multi-threaded code and there are problems with lockups, or if you have random
    data corruption, then `pidstat` (part of `sysstat`) or Valgrind plus the Helgrind
    plugin might be helpful. Memory leaks also fit into this category; I covered memory-related
    diagnosis in [*Chapter 18*](Chapter_18.xhtml#_idTextAnchor581).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有其他`top`无法帮助你发现的问题。如果你有多线程代码，并且遇到锁死问题，或者数据出现随机性损坏，那么`pidstat`（`sysstat`的一部分）或Valgrind加上Helgrind插件可能会有所帮助。内存泄漏也属于这一类别；我在[*第18章*](Chapter_18.xhtml#_idTextAnchor581)中介绍了与内存相关的诊断。
- en: Before we get into these more advanced profiling tools, let’s start with the
    most rudimentary one that is found on most systems, including those in production.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨这些更高级的分析工具之前，我们先从大多数系统中都能找到的最基本的工具开始，包括生产环境中的系统。
- en: Profiling with top
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用top进行分析
- en: The **top** program is a simple tool that doesn’t require any special kernel
    options or symbol tables. There is a basic version in BusyBox and a more functional
    version in the `procps` package, which is available in The Yocto Project and Buildroot.
    You may also want to consider using `htop`, which has functionally similar to
    `top` but a much nicer user interface.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**top**程序是一个简单的工具，不需要任何特殊的内核选项或符号表。BusyBox中有一个基本版本，而`procps`包中有一个功能更全的版本，后者在Yocto项目和Buildroot中都可以找到。你可能还想考虑使用`htop`，它与`top`功能相似，但界面更加友好。'
- en: 'To begin with, focus on the summary line of `top`, which is the second line
    if you are using BusyBox and the third line if you are using `top` from `procps`.
    Here is an example, using BusyBox’s `top`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，关注`top`的概要行，如果你使用的是BusyBox，则它是第二行；如果你使用的是`procps`中的`top`，则是第三行。下面是一个例子，使用BusyBox的`top`：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The summary line shows the percentage of time spent running in various states,
    as shown in this table:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 概要行显示了在不同状态下运行的时间百分比，如下表所示：
- en: '| **procps** | **BusyBox** | **Description** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **procps** | **BusyBox** | **描述** |'
- en: '| `us` | `usr` | User-space programs with a default nice value |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `us` | `usr` | 默认优先级值的用户空间程序 |'
- en: '| `sy` | `sys` | Kernel code |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `sy` | `sys` | 内核代码 |'
- en: '| `ni` | `nic` | User-space programs with a non-default nice value |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `ni` | `nic` | 优先级非默认值的用户空间程序 |'
- en: '| `id` | `idle` | Idle |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `id` | `idle` | 空闲 |'
- en: '| `wa` | `io` | I/O wait |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `wa` | `io` | I/O等待 |'
- en: '| `hi` | `irq` | Hardware interrupts |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `hi` | `irq` | 硬件中断 |'
- en: '| `si` | `sirq` | Software interrupts |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `si` | `sirq` | 软件中断 |'
- en: '| `st` | `-` | Steal time: only relevant in virtual environments |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `st` | `-` | Steal时间：仅在虚拟环境中相关 |'
- en: Table 20.1 – procps top vs. BusyBox top
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表20.1 – procps top与BusyBox top的对比
- en: 'In the preceding example, almost all of the time (58%) is spent in user mode,
    with a small amount (4%) in system mode, so this is a system that is CPU-bound
    in user space. The first line after the summary shows that just one application
    is responsible: `ffmpeg`. Any efforts toward reducing CPU usage should be directed
    there.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，几乎所有时间（58%）都花费在用户模式下，系统模式下的时间较少（4%），所以这是一个在用户空间中受 CPU 限制的系统。总结后的第一行显示，只有一个应用程序负责：`ffmpeg`。任何减少
    CPU 使用的努力都应集中在这里。
- en: 'Here is another example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个示例：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This system is spending almost all of the time in kernel space (99% `sys`),
    as a result of `cat` reading from `/dev/urandom`. In this artificial case, profiling
    `cat` by itself would not help, but profiling the kernel functions that `cat`
    calls might.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统几乎将所有时间都花费在内核空间（99% `sys`），这是由于 `cat` 从 `/dev/urandom` 读取数据所导致。在这个人工案例中，仅仅对
    `cat` 进行分析并不会帮助，但分析 `cat` 调用的内核函数可能会有所帮助。
- en: The default view of `top` shows only processes, so the CPU usage is the total
    of all the threads in the process. Press *H* to see information for each thread.
    Likewise, it aggregates the time across all CPUs. If you are using the `procps`
    version of `top`, you can see a summary per CPU by pressing the *1* key.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`的默认视图只显示进程，因此 CPU 使用率是进程中所有线程的总和。按 *H* 键可以查看每个线程的详细信息。同样，它会汇总所有 CPU 的时间。如果你使用的是
    `procps` 版本的 `top`，可以按 *1* 键查看每个 CPU 的摘要信息。'
- en: Once we have singled out the problem process using `top`, we can attach GDB
    to it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过 `top` 确定了问题进程，我们就可以将 GDB 附加到它上面。
- en: Profiling with GDB
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GDB 进行分析
- en: You can profile an application just by using **GDB** to stop it at arbitrary
    intervals to see what it is doing. This is the **poor man’s profiler**. It is
    easy to set up and is one way of gathering profile data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以仅通过使用**GDB**在任意间隔停止应用程序，查看它的状态。这就是**穷人分析器**。它易于设置，是收集分析数据的一种方式。
- en: 'The procedure is simple:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 过程很简单：
- en: Attach to the process using `gdbserver` (for a remote debug) or GDB (for a native
    debug). The process stops.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `gdbserver`（用于远程调试）或 GDB（用于本地调试）附加到进程。进程会停止。
- en: Observe the function it stopped in. You can use the `backtrace` GDB command
    to see the call stack.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看程序停止时所在的函数。你可以使用 `backtrace` GDB 命令查看调用栈。
- en: Type `continue` so that the program resumes.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `continue`，让程序继续执行。
- en: After a while, press *Ctrl + C* to stop it again, and go back to *step 2*.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一段时间后，按 *Ctrl + C* 停止程序，然后返回到 *步骤 2*。
- en: If you repeat *steps 2* to *4* several times, you will quickly get an idea of
    whether it is looping or making progress, and if you repeat them often enough,
    you will get an idea of where the hotspots in the code are.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重复执行*步骤 2* 到 *4* 多次，你很快就能了解程序是否在循环或进展，如果你足够频繁地重复这些步骤，你就能了解代码中的热点所在。
- en: There is a whole web page dedicated to this idea at [https://poormansprofiler.org/](https://poormansprofiler.org/),
    together with scripts that make it a little easier. I have used this technique
    many times over the years with various operating systems and debuggers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个完整的网页专门讲解这个方法，地址是[https://poormansprofiler.org/](https://poormansprofiler.org/)，并且提供了一些脚本，让这个过程变得更简单。多年来，我在各种操作系统和调试器中多次使用过这个技巧。
- en: This is an example of **statistical profiling**, in which you sample the program
    state at intervals. After a number of samples, you begin to learn the statistical
    likelihood of the functions being executed. It is surprising how few you really
    need. Other statistical profilers are `perf record`, OProfile, and `gprof`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**统计分析**的一个示例，其中你在一定间隔内对程序状态进行采样。经过一段时间的采样后，你可以开始了解函数执行的统计概率。令人惊讶的是，实际上你所需要的样本数非常少。其他统计分析工具包括
    `perf record`、OProfile 和 `gprof`。
- en: Sampling using a debugger is intrusive because the program is stopped for a
    significant period while you collect the sample. Other tools can sample with less
    overhead. One such tool is `perf`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器进行采样具有侵入性，因为程序在采样期间会停止很长时间。其他工具可以以更低的开销进行采样。一个这样的工具是 `perf`。
- en: Introducing perf
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 perf
- en: '**perf** is an abbreviation of the Linux **performance event counter subsystem**,
    `perf_events`, and also the name of the command-line tool for interacting with
    `perf_events`. Both have been part of the kernel since Linux 2.6.31\. There is
    plenty of useful information in the Linux source tree in `tools/perf/Documentation`
    as well as at [https://perfwiki.github.io](https://perfwiki.github.io).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**perf** 是 Linux **性能事件计数子系统** `perf_events` 的缩写，也是与 `perf_events` 交互的命令行工具的名称。自
    Linux 2.6.31 以来，它们已成为内核的一部分。在 Linux 源代码树中的 `tools/perf/Documentation` 以及 [https://perfwiki.github.io](https://perfwiki.github.io)
    上有大量有用的信息。'
- en: The initial impetus for developing `perf` was to provide a unified way to access
    the registers of the **performance measurement unit** (**PMU**), which is part
    of most modern processor cores. Once the API was defined and integrated into Linux,
    it became logical to extend it to cover other types of performance counters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 开发 `perf` 的初衷是提供一种统一的方式来访问 **性能测量单元** (**PMU**) 的寄存器，PMU 是大多数现代处理器核心的一部分。一旦
    API 被定义并集成到 Linux 中，扩展它以涵盖其他类型的性能计数器便变得合乎逻辑。
- en: At its heart, `perf` is a collection of event counters with rules about when
    they actively collect data. By setting the rules, you can capture data from the
    whole system, just the kernel, or just one process and its children, and do it
    across all CPUs or just one CPU. It is very flexible. With this one tool, you
    can start by looking at the whole system, then zero in on a device driver that
    seems to be causing problems, an application that is running slowly, or a library
    function that seems to be taking longer to execute than you thought.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，`perf` 是一个事件计数器集合，具有关于何时主动收集数据的规则。通过设置规则，您可以从整个系统、仅内核、仅一个进程及其子进程中捕获数据，并且可以跨所有
    CPU 或仅一个 CPU 进行操作。它非常灵活。使用这个工具，您可以从查看整个系统开始，然后集中关注可能导致问题的设备驱动程序、运行缓慢的应用程序，或执行时间似乎比预期更长的库函数。
- en: The code for the `perf` command-line tool is part of the kernel, in the `tools/perf`
    directory. The tool and the kernel subsystem are developed hand in hand, meaning
    that they must be from the same version of the kernel. `perf` can do a lot. In
    this chapter, I will examine it only as a profiler. For a description of its other
    capabilities, read the `perf` man pages and refer to the documentation mentioned
    at the start of this section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf` 命令行工具的代码是内核的一部分，位于 `tools/perf` 目录下。该工具和内核子系统是同步开发的，这意味着它们必须来自同一个版本的内核。`perf`
    功能强大。在本章中，我将仅作为分析器来探讨它。关于其其他功能的描述，请阅读 `perf` 手册并参考本节开头提到的文档。'
- en: In addition to debug symbols, there are two configuration options we need to
    set to fully enable `perf` in the kernel.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调试符号之外，我们还需要设置两个配置选项，以完全启用内核中的 `perf`。
- en: Configuring the kernel for perf
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 perf 配置内核
- en: You need a kernel that is configured for `perf_events`, and you need the `perf`
    command cross-compiled to run on the target. The relevant kernel configuration
    is `CONFIG_PERF_EVENTS`, present in the **General setup** | **Kernel Performance
    Events and Counters** menu.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个已配置 `perf_events` 的内核，并且需要将 `perf` 命令交叉编译，以便在目标上运行。相关的内核配置是 `CONFIG_PERF_EVENTS`，位于
    **General setup** | **Kernel Performance Events and Counters** 菜单中。
- en: If you want to profile using tracepoints—more on this subject later—also enable
    the options described in the section about Ftrace. While you are there, it is
    worthwhile enabling `CONFIG_DEBUG_INFO` as well.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用 tracepoints 进行分析——稍后会详细讲解——还需要启用有关 Ftrace 部分中描述的选项。同时，在这里启用 `CONFIG_DEBUG_INFO`
    也是值得的。
- en: The `perf` command has many dependencies, which makes cross-compiling it quite
    messy. However, both The Yocto Project and Buildroot have target packages for
    it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf` 命令有许多依赖项，这使得交叉编译变得相当复杂。然而，Yocto 项目和 Buildroot 都有针对它的目标包。'
- en: You will also need debug symbols on the target for the binaries that you are
    interested in profiling; otherwise, `perf` will not be able to resolve addresses
    to meaningful symbols. Ideally, you want debug symbols for the whole system, including
    the kernel. For the latter, remember that the debug symbols for the kernel are
    in the `vmlinux` file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要为您感兴趣的二进制文件启用目标的调试符号；否则，`perf` 将无法解析地址到有意义的符号。理想情况下，您希望为整个系统（包括内核）启用调试符号。对于后者，请记住，内核的调试符号位于
    `vmlinux` 文件中。
- en: Building perf with The Yocto Project
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Yocto 项目构建 perf
- en: If you are using the standard `linux-yocto` kernel, `perf_events` is enabled
    already, so there is nothing more to do.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是标准的 `linux-yocto` 内核，`perf_events` 已经启用，因此无需进行更多操作。
- en: 'To build the `perf` tool, you can add it explicitly to the target image dependencies,
    or you can add the `tools-profile` feature. You also want debug symbols on the
    target image as well as the kernel `vmlinux` image. In total, this is what you
    will need in `conf/local.conf`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 `perf` 工具，您可以将其显式添加到目标镜像的依赖项中，或者您可以添加 `tools-profile` 特性。您还需要在目标镜像以及内核 `vmlinux`
    镜像中启用调试符号。总的来说，您在 `conf/local.conf` 中需要配置以下内容：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adding `perf` to a Buildroot image is more involved for several reasons.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `perf` 添加到 Buildroot 镜像中涉及多个步骤。
- en: Building perf with Buildroot
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Buildroot 构建 perf
- en: Many Buildroot kernel configurations do not include `perf_events`, so you should
    begin by checking that your kernel includes the options mentioned in the preceding
    section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Buildroot内核配置不包括`perf_events`，因此你应该首先检查内核是否包括前面章节提到的选项。
- en: 'To cross-compile `perf`, run the Buildroot `menuconfig` and select the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要交叉编译`perf`，运行Buildroot的`menuconfig`并选择以下选项：
- en: '`BR2_PACKAGE_LINUX_TOOLS_PERF` in **Kernel** | **Linux Kernel Tools** | **perf**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**内核** | **Linux内核工具** | **perf**中选择`BR2_PACKAGE_LINUX_TOOLS_PERF`
- en: '`BR2_PACKAGE_LINUX_TOOLS_PERF_TUI` in **Kernel** | **Linux Kernel Tools** |
    **perf** | **Enable perf TUI**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**内核** | **Linux内核工具** | **perf**中选择`BR2_PACKAGE_LINUX_TOOLS_PERF_TUI` | **启用perf
    TUI**
- en: 'To build binaries with debug information and install them onto the target without
    stripping, enable the first and disable the second of these two options:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建带有调试信息的二进制文件并将它们安装到目标上而不剥离，启用这两个选项中的第一个并禁用第二个：
- en: '`BR2_ENABLE_DEBUG` in **Build options** | **Build packages with debugging symbols**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**构建选项**中选择`BR2_ENABLE_DEBUG` | **构建带调试符号的包**
- en: '`BR2_STRIP_strip` in **Build options** | **Strip target binaries**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**构建选项**中选择`BR2_STRIP_strip` | **剥离目标二进制文件**
- en: 'To copy the unstripped `vmlinux` file to the target image, select the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要将未剥离的`vmlinux`文件复制到目标映像中，选择以下选项：
- en: '`BR2_LINUX_KERNEL_VMLINUX` in **Kernel** | **Kernel binary format** | **vmlinux**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**内核** | **内核二进制格式** | **vmlinux**中选择`BR2_LINUX_KERNEL_VMLINUX`
- en: '`BR2_LINUX_KERNEL_INSTALL_TARGET` in **Kernel** | **Install kernel image to
    /boot in target**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**内核** | **将内核映像安装到目标的/boot目录**中选择`BR2_LINUX_KERNEL_INSTALL_TARGET`
- en: 'To increase the size of the root filesystem to accommodate the unstripped binaries
    and the `vmlinux` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加根文件系统的大小以适应未剥离的二进制文件和`vmlinux`文件：
- en: Select **Filesystem images** | **ext2/3/4 root filesystem** | **Exact size**
    and enter `960M` in the text field.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择**文件系统映像** | **ext2/3/4根文件系统** | **精确大小**，然后在文本框中输入`960M`。
- en: Then run `make clean` followed by `make`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行`make clean`，接着运行`make`。
- en: Once you have built everything, you will have to copy `vmlinux` to the target
    image manually.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了所有构建，你将需要手动将`vmlinux`复制到目标映像中。
- en: Profiling with perf
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用perf进行性能分析
- en: You can use `perf` to sample the state of a program using one of the event counters
    and accumulate samples over a period of time to create a profile. This is another
    example of statistical profiling. The default event counter is called `cycles`,
    which is a generic hardware counter that is mapped to a PMU register representing
    a count of cycles at the core clock frequency.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`perf`通过事件计数器采样程序状态，并在一段时间内累积样本来创建性能分析报告。这是另一种统计性能分析的方法。默认事件计数器叫做`cycles`，它是一个通用硬件计数器，映射到一个PMU寄存器，表示在核心时钟频率下的周期计数。
- en: 'Creating a profile using `perf` is a two-stage process: the `perf record` command
    captures samples and writes them to a file named `perf.data`, then `perf report`
    analyzes the results. Both commands are run on the target. The samples being collected
    are filtered for the process and any of its children. Here is an example of profiling
    a shell script that searches for the `linux` string:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`perf`创建分析报告是一个两阶段的过程：`perf record`命令捕获样本并将其写入名为`perf.data`的文件，然后`perf report`命令分析结果。两个命令都在目标上运行。收集的样本会过滤出特定进程及其所有子进程的相关数据。以下是对一个查找`linux`字符串的shell脚本进行分析的示例：
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now you can display the results from `perf.data` using the `perf report` command.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用`perf report`命令显示`perf.data`中的结果。
- en: 'There are three user interfaces to choose from:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种用户界面可供选择：
- en: '`--stdio`: This is a pure-text interface with no user interaction. You will
    have to launch `perf report` and `annotate` for each view of the trace.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--stdio`：这是一个纯文本界面，没有用户交互。你需要分别启动`perf report`和`annotate`来查看每个跟踪视图。'
- en: '`--tui`: This is a simple text-based menu interface with traversal between
    screens.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--tui`：这是一个基于文本的简单菜单界面，可以在屏幕之间进行导航。'
- en: '`--gtk`: This is a graphical interface that otherwise acts in the same way
    as `--tui`.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--gtk`：这是一个图形界面，功能与`--tui`相同。'
- en: 'The default is TUI, as shown in this example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下是TUI，如本示例所示：
- en: '![Figure 20.1 – perf report TUI](img/B18466_20_1.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 20.1 – perf报告TUI](img/B18466_20_1.png)'
- en: Figure 20.1 – perf report TUI
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.1 – perf报告TUI
- en: '`perf` is able to record the kernel functions executed on behalf of the processes
    because it collects samples in kernel space.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf`能够记录由进程执行的内核函数，因为它在内核空间收集样本。'
- en: The list is ordered with the most active functions first. In this example, all
    but one are captured while `grep` is running. Some are in a library, `libc-2.20`,
    some are in a program, `busybox.nosuid`, and some are in the kernel. We have symbol
    names for program and library functions because all the binaries have been installed
    on the target with debug information, and kernel symbols are being read from `/boot/vmlinux`.
    If you have `vmlinux` in a different location, add `-k <path>` to the `perf report`
    command. Rather than storing samples in `perf.data`, you can save them to a different
    file using `perf record -o <file name>` and analyze them using `perf report` `-i
    <file name>`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: By default, `perf record` samples at a frequency of 1,000 Hz using the `cycles`
    counter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: A sampling frequency of 1,000 Hz may be higher than you really need and may
    be the cause of the observer effect. Try lower rates; 100 Hz is enough for most
    cases. You can set the sample frequency using the `-F` option.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: This is still not really making life easy; the functions at the top of the list
    are mostly low-level memory operations, and you can be fairly sure that they have
    already been optimized. Fortunately, `perf record` also gives us the ability to
    crawl up the call stack and see where these functions are being invoked.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Call graphs
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It would be nice to step back and see the surrounding context of these costly
    functions. You can do that by passing the `-g` option to `perf record` to capture
    the backtrace from each sample.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `perf report` shows a plus sign (`+`) where the function is part of a
    call chain. You can expand the trace to see the functions lower down in the chain:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.2 – perf report (call graphs)](img/B18466_20_2.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Figure 20.2 – perf report (call graphs)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Generating call graphs relies on the ability to extract call frames from the
    stack, just like backtraces in GDB. The debug information needed to unwind stacks
    is encoded in the executables. Call graphs cannot be produced for some combinations
    of architecture and toolchains because the binaries lack the necessary debug information.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Backtraces are nice, but where is the assembler, or better yet, the source code,
    for these functions?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: perf annotate
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know which functions to look at, it would be nice to step inside
    and see the code and to have hit counts for each instruction. That is what `perf
    annotate` does, by calling down to a copy of `objdump` installed on the target.
    You just need to use `perf annotate` in place of `perf report`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '`perf annotate` requires symbol tables for the executables and `vmlinux`. Here
    is an example of an annotated function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.3 – perf annotate (assembler)](img/B18466_20_3.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: Figure 20.3 – perf annotate (assembler)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see the source code interleaved with the assembler, you can
    copy the relevant source files to the target device. If you are using The Yocto
    Project and build with the `src-pkgs` extra image feature or have installed the
    individual `<package>-src` packages, then the source will have been installed
    for you in `/usr/src/debug`. Otherwise, you can examine the debug information
    to see the location of the source code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到与汇编代码交织在一起的源代码，可以将相关源文件复制到目标设备。如果你使用的是 The Yocto Project 并且通过 `src-pkgs`
    附加镜像特性构建，或者已经安装了单独的 `<package>-src` 包，那么源代码将已经安装在 `/usr/src/debug` 中。否则，你可以查看调试信息，查找源代码的位置：
- en: '[PRE4]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The path on the target should be *exactly the same* as the path you can see
    in `DW_AT_comp_dir`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 目标路径必须与 `DW_AT_comp_dir` 中看到的路径*完全相同*。
- en: 'Here is an example of annotation with the source and assembler code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是源代码与汇编代码的注释示例：
- en: '![Figure 20.4 – perf annotate (source code)](img/B18466_20_4.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 20.4 – perf annotate（源代码）](img/B18466_20_4.png)'
- en: Figure 20.4 – perf annotate (source code)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.4 – perf annotate（源代码）
- en: 'Now we can see the corresponding C source code above `cmp r0` and below the
    `str r3, [fp, #-40]` instruction.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们可以看到 `cmp r0` 上方和 `str r3, [fp, #-40]` 指令下方的相应 C 源代码。'
- en: This concludes our coverage of `perf`. While there are other statistical sampling
    profilers that predate `perf`, like OProfile and `gprof`, these tools have fallen
    out of favor in recent years, so I chose to omit them. Next, we will look at event
    tracers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对`perf`的介绍。虽然在`perf`之前还有其他统计采样分析器，比如 OProfile 和 `gprof`，但这些工具近年来已经不再被广泛使用，因此我选择将它们省略。接下来，我们将讨论事件跟踪工具。
- en: Tracing events
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪事件
- en: 'The tools we have seen so far all use statistical sampling. You often want
    to know more about the ordering of events so that you can see them and relate
    them to each other. Function tracing involves instrumenting the code with tracepoints
    that capture information about the event, and may include some or all of the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们看到的所有工具都使用统计采样。你通常希望了解更多关于事件顺序的信息，以便你能查看它们并将它们相互关联。函数跟踪涉及通过在代码中加入跟踪点来捕捉事件信息，可能包括以下一些或全部内容：
- en: A timestamp
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳
- en: Context, such as the current PID
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文信息，例如当前的PID
- en: Function parameters and return values
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数和返回值
- en: A call stack
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用栈
- en: It is more intrusive than statistical profiling and it can generate a large
    amount of data. The latter problem can be mitigated by applying filters when the
    sample is captured and, later on, when viewing the trace.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 它比统计分析更具侵入性，并且可能会生成大量数据。后者的问题可以通过在采样时应用过滤器以及稍后查看跟踪时应用过滤器来减轻。
- en: 'I will cover three trace tools here: the kernel function tracers Ftrace, LTTng,
    and eBPF.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里介绍三种跟踪工具：内核函数跟踪器 Ftrace、LTTng 和 eBPF。
- en: Introducing Ftrace
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 Ftrace
- en: The kernel function tracer **Ftrace** evolved from work done by Steven Rostedt
    and many others as they were tracking down the causes of high scheduling latency
    in real-time applications. Ftrace appeared in Linux 2.6.27 and has been actively
    developed since then. There are a number of documents describing kernel tracing
    in the kernel source in `Documentation/trace`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 内核函数跟踪器 **Ftrace** 起源于 Steven Rostedt 等人为了追踪实时应用中高调度延迟的原因而开展的工作。Ftrace 出现在 Linux
    2.6.27 中，并且自那时以来一直在积极开发。内核源代码中的 `Documentation/trace` 目录包含了许多关于内核跟踪的文档。
- en: Ftrace consists of a number of tracers that can log various types of activity
    in the kernel. Here, I am going to talk about the `function` and `function_graph`
    tracers and the event tracepoints. In [*Chapter 21*](Chapter_19.xhtml#_idTextAnchor654),
    I will revisit Ftrace when I talk about real-time latencies.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Ftrace由多个跟踪器组成，可以记录内核中的各种活动。在这里，我将讨论 `function` 和 `function_graph` 跟踪器以及事件跟踪点。在[*第21章*](Chapter_19.xhtml#_idTextAnchor654)中，我将再次提到
    Ftrace，并讨论实时延迟。
- en: The `function` tracer instruments each kernel function so that calls can be
    recorded and timestamped. It compiles the kernel with the `-pg` switch to inject
    the instrumentation. The `function_graph` tracer goes further and records both
    the entry and exit of functions so that it can create a call graph. The event
    tracepoints feature records parameters associated with the call.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`function` 跟踪器为每个内核函数添加了跟踪点，以便记录和时间戳化调用。它通过 `-pg` 选项编译内核，以注入这些跟踪代码。`function_graph`
    跟踪器更进一步，记录了函数的入口和出口，从而生成调用图。事件跟踪点功能记录与调用相关的参数。'
- en: 'Ftrace has a very embedded-friendly user interface that is entirely implemented
    through virtual files in the `debugfs` filesystem, meaning that you do not have
    to install any tools on the target to make it work. Nevertheless, there are other
    user interfaces if you prefer: `trace-cmd` is a command-line tool that records
    and views traces and is available in Buildroot (`BR2_PACKAGE_TRACE_CMD`) and The
    Yocto Project (`trace-cmd`). There is a graphical trace viewer named **KernelShark**
    that is available as a package for The Yocto Project.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Like `perf`, enabling Ftrace requires setting certain kernel configuration options.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Preparing to use Ftrace
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ftrace and its various options are configured in the kernel configuration menu.
    You will need the following at a minimum:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '`CONFIG_FUNCTION_TRACER` from the **Kernel hacking** | **Tracers** | **Kernel
    Function Tracer** menu.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You would be well advised to turn on these options as well:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '`CONFIG_FUNCTION_GRAPH_TRACER` in the **Kernel hacking** | **Tracers** | **Kernel
    Function Tracer** | **Kernel Function Graph Tracer** menu'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_DYNAMIC_FTRACE` in the **Kernel hacking** | **Tracers** | **Kernel
    Function Tracer** | **Enable/disable function tracing dynamically** menu'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_FUNCTION_PROFILER` in the **Kernel hacking** | **Tracers** | **Kernel
    Function Tracer** | **Kernel function profiler** menu'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the whole thing is hosted in the kernel, there is no user-space configuration
    to be done.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Using Ftrace
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you can use Ftrace, you have to mount the `debugfs` filesystem, which
    goes in the `/sys/kernel/debug` directory:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All the controls for Ftrace are in the `/sys/kernel/debug/tracing` directory;
    there is even a mini `HOWTO` in the `README` file there.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the list of tracers available in the kernel:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The active tracer is shown by `current_tracer`. Initially, it will be the null
    tracer, `nop`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture a trace, select the tracer by writing the name of one of the `available_tracers`
    to `current_tracer`. Then, enable tracing for a short while:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In that one second, the trace buffer will have been filled with the details
    of every function called by the kernel. The format of the trace buffer is plain
    text, as described in `Documentation/trace/ftrace.txt`. You can read the trace
    buffer from the `trace` file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can capture a large number of data points in just one second—in this case,
    over 40,000.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'As with profilers, it is difficult to make sense of a flat function list like
    this. If you select the `function_graph` tracer, Ftrace captures call graphs like
    this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now you can see the nesting of the function calls, delimited by braces, `{`
    and `}`. At the terminating brace, there is a measurement of the time taken in
    the function, annotated with a plus sign (`+`) if it takes more than 10 µs and
    an exclamation mark (`!`) if it takes more than 100 µs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: You are often only interested in the kernel activity caused by a single process
    or thread, in which case you can restrict the trace to one thread by writing the
    thread ID to `set_ftrace_pid`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Ftrace and trace filters
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enabling `CONFIG_DYNAMIC_FTRACE` allows Ftrace to modify the function trace
    sites at runtime, which has a couple of benefits. Firstly, it triggers additional
    build-time processing of the trace function probes, which allows the Ftrace subsystem
    to locate them at boot time and overwrite them with `nop` instructions, thus reducing
    the overhead of the function trace code to almost nothing. You can then enable
    Ftrace in production or near-production kernels with no impact on performance.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'The second advantage is that you can selectively enable function trace sites
    rather than tracing everything. The list of functions is put into `available_filter_functions`.
    You can selectively enable function traces as needed by copying the name from
    `available_filter_functions` to `set_ftrace_filter.` To stop tracing that function,
    write its name to `set_ftrace_notrace`. You can also use wildcards and append
    names to the list. For example, suppose you are interested in `tcp` handling:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run some tests and then look at `trace`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `set_ftrace_filter` function can also contain commands to start and stop
    tracing when certain functions are executed. There isn’t space to go into these
    details here, but if you want to find out more, read the *Filter commands* section
    in `Documentation/trace/ftrace.txt`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Trace events
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `function` and `function_graph` tracers only record the time at which the
    function was executed. The trace events feature also records parameters associated
    with the call, making the trace more readable and informative. For example, instead
    of just recording that the `kmalloc` function has been called, a trace event will
    record the number of bytes requested and the returned pointer. Trace events are
    used in `perf` and LTTng as well as Ftrace, but the development of the trace events
    subsystem was prompted by the LTTng project.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes effort from kernel developers to create trace events. They are defined
    in the source code using the `TRACE_EVENT` macro; there are over a thousand of
    them now. You can see the list of events available at runtime in `/sys/kernel/debug/tracing/available_events`.
    They are named <`subsystem>:<function>` (e.g., `kmem:kmalloc`). Each event is
    also represented by a subdirectory in `tracing/events/<subsystem>/<function>`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The files are:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '`enable`: You write a `1` to this file to enable the event.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter`: This is an expression that must evaluate to `true` for the event
    to be traced.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format`: This is the format of the event and parameters.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`: This is a numeric identifier.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trigger`: This is a command that is executed when the event occurs using the
    syntax defined in the *Filter commands* section of `Documentation/trace/ftrace.txt`.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I will show you a simple example involving `kmalloc` and `kfree`. Event tracing
    does not depend on the function tracers, so begin by selecting the `nop` tracer:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, select the events to trace by enabling each one individually:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also write the event names to `set_event`, as shown here:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, when you read the trace, you can see the functions and their parameters:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Exactly the same trace events are visible in `perf` as tracepoint events.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Since there is no bloated user-space component to build, Ftrace is well suited
    for deploying to most embedded targets. Next, we will look at another popular
    event tracer whose origins predate those of Ftrace.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Using LTTng
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Linux Trace Toolkit** (**LTT**) project was started by Karim Yaghmour
    as a means of tracing kernel activity and was one of the first trace tools generally
    available for the Linux kernel. Later, Mathieu Desnoyers took up the idea and
    re-implemented it as a next-generation trace tool, **LTTng**. It was then expanded
    to cover user-space traces as well as the kernel. The project website is at [https://lttng.org/](https://lttng.org/)
    and contains a comprehensive user manual.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'LTTng consists of three components:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: A core session manager
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A kernel tracer implemented as a group of kernel modules
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user-space tracer implemented as a library
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to those, you will need a trace viewer such as **Babeltrace** ([https://babeltrace.org/](https://babeltrace.org/))
    or the **Eclipse Trace Compass** plugin to display and filter the raw trace data
    on the host or target.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: LTTng requires a kernel configured with `CONFIG_TRACEPOINTS`, which is enabled
    when you select **Kernel hacking** | **Tracers** | **Kernel Function Tracer**.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The description that follows refers to LTTng version 2.13\. Other versions may
    be different.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: LTTng and The Yocto Project
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to add these packages to the target dependencies in `conf/local.conf`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you want to run Babeltrace on the target, also append the `babeltrace2` package.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: LTTng and Buildroot
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to enable the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '`BR2_PACKAGE_LTTNG_MODULES` in the **Target packages** | **Debugging, profiling
    and benchmark** | **lttng-modules** menu'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BR2_PACKAGE_LTTNG_TOOLS` in the **Target packages** | **Debugging, profiling
    and benchmark** | **lttng-tools** menu'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For user-space trace tracing, enable these:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '`BR2_PACKAGE_UTIL_LINUX_UUIDD` in the **Target packages** | **System tools**
    | **util-linux** | **uuidd** menu'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BR2_PACKAGE_LTTNG_LIBUST` in the **Target packages** | **Libraries** | **Other**
    | **lttng-libust** menu'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BR2_PACKAGE_HOST_BABELTRACE2` in the **Host utilities** | **host babeltrace2**
    menu'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a package called `babletrace2` for the target. Buildroot installs `babeltrace2`
    for the host in `output/host/usr/bin/babeltrace2`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Using LTTng for kernel tracing
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LTTng can use the set of Ftrace events described previously as potential tracepoints.
    Initially, they are disabled.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'The control interface for LTTng is the `lttng` command. You can list the kernel
    probes using the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Traces are captured in the context of a session, which, in this example, is
    called `test`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now enable a few events in the current session. You can enable all kernel tracepoints
    using the `--all` option, but remember the warning about generating too much trace
    data. Let’s start with a couple of scheduler-related trace events:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check that everything is set up:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now start tracing:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the test load, and then stop tracing:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Traces for the session are written to the session directory, `lttng-traces/<session>/kernel`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the Babeltrace viewer to dump the raw trace data in text format. In this
    case, I ran it on the host computer:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The output is too verbose to fit on this page, so I will leave it as an exercise
    for you to capture and display a trace in this way. The text output from Babeltrace
    has the advantage that it is easy to search for strings using `grep` and similar
    commands.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'A good choice for a graphical trace viewer is the **Trace Compass** plugin
    for Eclipse, which is now part of the Eclipse IDE for the C/C++ developer bundle.
    Importing the trace data into Eclipse is characteristically fiddly. Follow these
    steps:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Tracing** perspective.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new project by selecting **File** | **New** | **Tracing project**.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a project name and click on **Finish**.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **New Project** option in the **Project Explorer** menu and
    select **Import**.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand **Tracing**, and then select **Trace Import**.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to the directory containing the traces (e.g., `test-20150824-140942`),
    tick the box to indicate which subdirectories you want (might be **kernel**),
    and click on **Finish**.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the project, expand **Traces[1]**, and then double-click on **kernel**.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s switch gears away from LTTng and jump headfirst into the latest and
    greatest event tracer for Linux.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Using eBPF
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Berkeley Packet Filter** (**BPF**) is a technology that was first introduced
    in 1992 to capture, filter, and analyze network traffic. In 2013, Alexi Starovoitov
    undertook a rewrite of BPF with help from Daniel Borkmann. Their work, then known
    as **eBPF** (**extended BPF**), was merged into the kernel in 2014, where it has
    been available since Linux 3.15\. eBPF provides a sandboxed execution environment
    for running programs inside the Linux kernel. eBPF programs are written in C and
    are **just-in-time** (**JIT**) compiled to native code. Before that happens, the
    intermediate eBPF bytecode must first pass through a series of safety checks so
    that a program cannot crash the kernel.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Despite its networking origins, eBPF is now a general-purpose virtual machine
    running inside the Linux kernel. By making it easy to run small programs on specific
    kernel and application events, eBPF has quickly emerged as the most powerful tracer
    for Linux. Like what cgroups did for containerized deployments, eBPF has the potential
    to revolutionize observability by enabling users to fully instrument production
    systems. Netflix and Facebook make extensive use of eBPF across their microservices
    and cloud infrastructure for performance analysis and thwarting **distributed
    denial-of-service** (**DDoS**) attacks.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'The tooling around eBPF is evolving, with **BPF Compiler Collection** (**BCC**)
    and **bpftrace** establishing themselves as the two most prominent frontends.
    Brendan Gregg was deeply involved in both projects and has written about eBPF
    extensively in his book *BPF Performance Tools: Linux System and Application Observability*.
    With so many possibilities covering such a vast scope, new technology such as
    eBPF can seem overwhelming. But much like cgroups, we don’t need to understand
    how eBPF works to start making use of it. BCC comes with several ready-made tools
    and examples that we can simply run from the command line.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the kernel for eBPF
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A package named **ply** ([https://github.com/iovisor/ply](https://github.com/iovisor/ply))
    was merged into Buildroot on January 23, 2021, for inclusion in the 2021.02 LTS
    release of Buildroot. **ply** is a lightweight, dynamic tracer for Linux that
    leverages eBPF so that probes can be attached to arbitrary points in the kernel.
    Unlike `bpftrace`, which depends on BCC, `ply` does not rely on LLVM and has no
    required external dependencies aside from `libc`. This makes it much easier to
    port to embedded CPU architectures such as `arm` and `powerpc`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by configuring an eBPF-enabled kernel for Raspberry Pi 4:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `make linux-configure` command will download and build some host tools
    before fetching, extracting, and configuring the kernel source code. The `raspberrypi4_64_defconfig`
    from the 2024.02.6 LTS release of Buildroot points to a custom 6.1 kernel source
    tarball from the Raspberry Pi Foundation’s GitHub fork. Inspect the contents of
    your `raspberrypi4_64_defconfig` to verify what version of the kernel you are
    on. Once `make linux-configure` has configured the kernel, we can reconfigure
    it for eBPF:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To search for a specific kernel configuration option from the interactive menu,
    hit */* and enter a search string. The search should return a numbered list of
    matches. Entering a given number takes you directly to that configuration option.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'At a minimum, we need to select the following to enable kernel support for
    eBPF:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following are intended for BCC but there is no harm in adding them:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add these so that users can compile and attach eBPF programs to `kprobe`, `uprobe`,
    and `tracepoint` events:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'These need to be selected for `ply` to work:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Make sure to save your changes when exiting `make` `linux-menuconfig` so that
    they get applied to `output/build/linux-custom/.config` before building your eBPF-enabled
    kernel.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Building ply with Buildroot
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s build `ply` and install the tool along with some example scripts. The
    `ply` scripts are bundled together inside an `ebpf` package under the `MELD/Chapter20/`
    directory for easy installation. To copy them over to your 2024.02.06 LTS installation
    of Buildroot:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now build the `ply` image for Raspberry Pi 4:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If your version of Buildroot is 2024.02.06 LTS and you copied the `buildroot`
    overlay from `MELD/Chapter20` correctly, then the `ply` image should build successfully.
    The kernel built for this image is already configured for eBPF so there is no
    need to perform the previous `linux-menuconfig` steps. The `ply` image also automounts
    `debugfs` at `/sys/kernel/debug` so `ply` is ready to run on boot up.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Insert the finished microSD into your Raspberry Pi 4, plug it into your local
    network with an Ethernet cable, and power the device up. Use `arp-scan` to locate
    your Raspberry Pi 4’s IP address and SSH into it as `root` with the password you
    set in the previous section. I used `temppwd` for the `root` password in the `configs/rpi4_64_ply_defconfig`
    that I included with my `MELD/Chapter20/buildroot` overlay. Now, we are ready
    to gain some firsthand experience in experimenting with eBPF.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Using ply
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Doing almost anything with eBPF, including running the `ply` tool and examples,
    requires `root` privileges, which is why we enabled `root` login via SSH. Another
    prerequisite is mounting `debugfs`. If there is no `debugfs` entry in your `/etc/fstab`,
    then mount `debugfs` from the command line:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s start by counting `syscalls` system-wide by function:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that the `ply` session terminates, and the trace results are displayed
    when the user enters *Ctrl + C*. You may need to enter *Ctrl + C* repeatedly until
    the `ply` session finally terminates.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'The directory where the `ply` scripts are located is not in the `PATH` environment
    variable, so navigate there for easier execution:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s start with a system-wide script that displays read sizes as a histogram:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `tcp-send-recv.ply` script counts TCP I/O by executable and direction:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this instance, I am tracing all calls to `tcp_sendmsg` and `tcp_recvmsg`
    while I run a Redis client/server latency test. I performed the test from an SSH
    terminal so there is TCP I/O reported for `dropbear` as well. The number of samples
    displayed increased from `0` to `1033` over the course of the latency test, which
    explains the `1048` sends made by `dropbear`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'The `heap-allocs.ply` script displays heap allocation counts. I ran an LRU
    cache simulation of 100,000 keys on Redis:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Notice that an instance of `redis-cli` with PID `215` performed `1027` heap
    allocations. This concludes our coverage of Linux event tracing tools: Ftrace,
    LTTng, and eBPF. All of them require at least some kernel configuration to work.
    Valgrind offers more profiling tools that operate entirely from the comfort of
    user space.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Using Valgrind
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I introduced **Valgrind** in [*Chapter 18*](Chapter_18.xhtml#_idTextAnchor581)
    as a tool for identifying memory problems using the `memcheck` tool. Valgrind
    has other useful tools for application profiling. The two I am going to look at
    here are Callgrind and Helgrind. Since Valgrind works by running the code in a
    sandbox, it can check the code as it runs and report certain behaviors, which
    native tracers and profilers cannot do.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Callgrind
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Callgrind** is a call graph-generating profiler that also collects information
    about processor cache hit rate and branch prediction. Callgrind is only useful
    if your bottleneck is CPU-bound. It’s not useful if heavy I/O or multiple processes
    are involved.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Valgrind does not require kernel configuration, but it does need debug symbols.
    It is available as a target package in both The Yocto Project and Buildroot (`BR2_PACKAGE_VALGRIND`).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'You run Callgrind in Valgrind on the target like so:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This produces a file called `callgrind.out.<PID>`, which you can copy to the
    host and analyze with `callgrind_annotate`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: The default is to capture data for all the threads together in a single file.
    If you add the `--separate-threads=yes` option when capturing, there will be profiles
    for each of the threads in files named `callgrind.out.<PID>-<thread id>`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Callgrind can simulate the processor L1/L2 cache and report on cache misses.
    Capture the trace with the `--simulate-cache=yes` option. L2 misses are much more
    expensive than L1 misses, so pay attention to code with high `D2mr` or `D2mw`
    counts.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: The raw output from Callgrind can be overwhelming and difficult to untangle.
    A visualizer such as **KCachegrind** ([https://kcachegrind.github.io/html/Home.html](https://kcachegrind.github.io/html/Home.html))
    can help you navigate the mountains of data Callgrind collects.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Helgrind
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Helgrind** is a thread-error detector for detecting synchronization errors
    in C, C++, and Fortran programs that include POSIX threads.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Helgrind can detect three classes of errors. Firstly, it can detect the incorrect
    use of the API. Some examples are unlocking a mutex that is already unlocked,
    unlocking a mutex that was locked by a different thread, or not checking the return
    value of certain `pthread` functions. Secondly, it monitors the order in which
    threads acquire locks to detect cycles that may result in deadlocks (also known
    as the deadly embrace). Finally, it detects data races, which can happen when
    two threads access a shared memory location without using suitable locks or other
    synchronization to ensure single-threaded access.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Helgrind is simple; you just need this command:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It prints problems and potential problems as it finds them. You can direct these
    messages to a file by adding `--log-file=<filename>`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Callgrind and Helgrind rely on Valgrind’s virtualization for their profiling
    and deadlock detection. This heavyweight approach slows down the execution of
    your programs, increasing the likelihood of the observer effect.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the bugs in our programs are so reproducible and easy to isolate that
    a simpler, less invasive tool is enough to quickly debug them. That tool more
    often than not is `strace`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Using strace
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I started the chapter with a simple and ubiquitous tool, `top`, and I will
    finish with another: **strace**. It is a very simple tracer that captures system
    calls made by a program and, optionally, its children. You can use it to do the
    following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Learn which system calls a program makes.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find those system calls that fail, together with the error code. I find this
    useful if a program fails to start but doesn’t print an error message or if the
    message is too general.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find which files a program opens.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find out which `syscalls` a running program is making, for example, to see whether
    it is stuck in a loop.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more examples online. Just search for `strace` tips and tricks.
    Everybody has a favorite `strace` story, for example, [https://alexbilson.dev/plants/technology/debug-a-program-with-strace/](https://alexbilson.dev/plants/technology/debug-a-program-with-strace/).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '`strace` uses the `ptrace(2)` function to hook calls as they are made from
    user space to the kernel. If you want to know more about how `ptrace` works, the
    manual page is detailed and surprisingly readable.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to get a trace is to run the command as a parameter to `strace`
    (the listing has been edited for clarity):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Most of the trace shows how the runtime environment is created. In particular,
    you can see how the library loader hunts for `libc.so.6`, eventually finding it
    in `/lib`. Finally, it gets to running the `main()` function of the program, which
    prints its message and exits.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: If you want `strace` to follow any child processes or threads created by the
    original process, add the `-f` option.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: If you are using `strace` to trace a program that creates threads, you almost
    certainly want to use the `-f` option. Better still, use `-ff` and -`o <file name>`
    so that the output for each child process or thread is written to a separate file
    named `<filename>.<PID | TID>`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use of `strace` is to discover which files a program tries to open
    at startup. You can restrict the system calls that are traced through the `-e`
    option, and you can write the trace to a file instead of `stdout` using the `-o`
    option:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This shows the libraries and configuration files `ssh` opens when it is setting
    up a connection.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even use `strace` as a basic profile tool. If you use the `-c` option,
    it accumulates the time spent in system calls and prints out a summary like this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`strace` is extremely versatile. We have only scratched the surface of what
    the tool can do.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: I recommend downloading *Spying on your programs with strace*, a free zine by
    Julia Evans available at [https://wizardzines.com/zines/strace/](https://wizardzines.com/zines/strace/).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nobody can complain that Linux lacks options for profiling and tracing. This
    chapter has given you an overview of some of the most common ones.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: When faced with a system that is not performing as well as you would like, start
    with `top` and try to identify the problem. If it proves to be a single application,
    then you can use `perf record`/`report` to profile it. Bear in mind that you will
    have to configure the kernel to enable `perf` and you will need debug symbols
    for both the binaries and kernel. If the problem is not so well localized, use
    `perf` or `ply` to get a system-wide view.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Ftrace comes into its own when you have specific questions about the behavior
    of the kernel. The `function` and `function_graph` tracers provide a detailed
    view of the relationship and sequence of function calls. The event tracers allow
    you to extract more information about functions, including the parameters and
    return values.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: LTTng performs a similar role, making use of the event trace mechanism, and
    adds high-speed ring buffers to extract large quantities of data from the kernel.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Valgrind has the advantage of running code in a sandbox and can report on errors
    that are hard to track down in other ways. Using Callgrind, it can generate call
    graphs and report on processor cache usage, and with Helgrind, it can report on
    thread-related problems.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Finally, don’t forget `strace`. It is a good standby for finding out which system
    calls a program is making, from tracking file open calls to finding file pathnames
    and checking for system wake-ups and incoming signals.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: All the while, be aware of, and try to avoid, the observer effect by making
    sure that your measurements are valid for a production system. In the next chapter,
    we will delve into the latency tracers that help us quantify the real-time performance
    of a target system.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Further study
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Profiling and tracing with perf,* by Julia Evans'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Systems Performance: Enterprise and the Cloud, Second Edition*, by Brendan
    Gregg'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*BPF Performance Tools: Linux System and Application Observability*, by Brendan
    Gregg'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ply: lightweight eBPF tracing*, by Frank Vasquez: [https://www.youtube.com/watch?v=GuEEJlU9Mr8](https://www.youtube.com/watch?v=GuEEJlU9Mr8)'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Spying on your programs with strace,* by Julia Evans'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
