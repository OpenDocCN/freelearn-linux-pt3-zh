- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filtering Text with grep, sed, and Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve looked at how to perform file searches with `find`, and at how
    to use text-stream filter utilities to extract and present data from text files
    and program output streams. In this chapter we’ll be looking at two other utilities,
    `sed` and `grep`, that will allow you to supercharge both your searches and your
    text manipulations. Before that though, you need to understand about Regular Expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Regular Expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding `sed`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding `grep`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RegEx Buddy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RegEx101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at some real-world examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re ready, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use any of your Linux virtual machines or your Linux host machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, as always, you can grab the scripts and text files from Github, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Understanding Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you worked with the text-stream filters in *Chapter 6, Text Stream Filters
    Part 1* and *Chapter 7, Text Stream Filters Part 2*, you were manipulating simple
    text strings. That is, you were working with alphabetic characters, numbers, and
    the control characters that allow you to place tabs, spaces, and newlines into
    your text files. **Regular Expressions**, which you’ll sometimes see shortened
    to either **regexp** or **regex**, can include text strings, or even be a text
    string. They can also include special characters, collectively called **metacharacters**,
    which give such awesome power to the tools that understand them. In fact, you
    can think of Regular Expressions as a sort of programming language, with text
    strings as the words and metacharacters as the punctuation. Rather than just enabling
    you to search for simple text strings, regular expressions allow you to search
    for patterns. For example, if you need to search through a file for all telephone
    numbers or all credit card numbers, you can create a regular expression that searches
    for text strings that match those patterns.
  prefs: []
  type: TYPE_NORMAL
- en: I need to clarify something that’s a bit confusing. *Regular Expressions*, always
    written in the plural form and with upper-case letters beginning each word, is
    the name of the pattern-matching language. That’s different from a *regular expression*,
    which is a pattern-matching construct that you would build with the *Regular Expressions*
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Understand, though, that the topic of Regular Expressionsis a huge one, and
    is a topic about which whole books are written. For now, I’ll just give you the
    basics that you need to understand how to use them with `grep` and `sed`. Let’s
    begin by looking at the two general types of characters that you would use in
    a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: Literals and Metacharacters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two types of characters that you’ll use in regular expressions. **Literals**
    are any character which is to be taken literally. In other words, literals are
    anything that you want to treat as just plain text. **Metacharacters** give you
    the ability to modify your pattern-matching according to your needs. You can,
    for example, use metacharacters to find a text pattern that occurs at either the
    beginning or end of a line, while leaving the pattern alone if it occurs somewhere
    else in the line. You can also use metacharacters to perform different types of
    wild-card pattern-matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of metacharacters, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Positional anchors**: These define where in either a file or a line that
    you would want to find a match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Character sets**: These define either a range or a specific type of literal
    character that you want to match. In other words, if you want to find a text string
    that contains nothing but lower-case letters, you don’t have to list each lower-case
    letter in your regular expression. Instead, just use the lower-case letter character
    set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modifiers**: Mainly, these metacharacters allow you to define how many of
    any literal character or string of literal characters that you want to match at
    a time. The other modifiers are the or operator and the grouping operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **positional anchors**, are as you see in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Positional anchor** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | This allows you to match a pattern that occurs at the beginning of
    a line. You would always place it to the left of the pattern that you want to
    match, like this: `^pattern` |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | This allows you to match a pattern that occurs at the end of a line.
    You would always place it to the right of the pattern that you want to match,
    like this: `pattern$` |'
  prefs: []
  type: TYPE_TB
- en: '| `\<pattern\>` | This pair of symbols marks word boundaries. For example,
    if you were to search for the pattern *and*, use of this metacharacter would only
    match with the whole word *and*, instead of with any word that contains the text
    string *and*. |'
  prefs: []
  type: TYPE_TB
- en: The following table explains the about the various **character sets**.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Character set examples** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `[abc]``[a-z]``[:lower:]``[:digit:]` | This should already be familiar to
    you. This defines either a set of characters or a range of characters to match
    in a pattern. You can also use the same character classes that you used with the
    text-stream filters. |'
  prefs: []
  type: TYPE_TB
- en: '| `[^abc]``[^a-z]` | In the previous table, I showed you how the `^` can be
    used as a positional anchor. But, when used as the first character of a character
    set, the `^` acts as a negation operator. So, while `[abc]` matches everything
    with an a, b, or c in it, `[^abc]` matches everything without an a, b, or c in
    it. |'
  prefs: []
  type: TYPE_TB
- en: 'The final type of metacharacters consists of the **modifiers**, as you see
    in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Basic modifier** | **Extended modifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | `*` | Wild-card to match zero or more of the single character or single-character
    regular expression that precedes it. Note that this behavior is different from
    what you’re used to seeing with `*` in normal command-line operations, in commands
    such as `ls -l *.txt`. |'
  prefs: []
  type: TYPE_TB
- en: '| `\?` | `?` | Wild-card to match zero or one instance of the preceding single
    character or regular expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `\+` | `+` | A wild-card that must have a match. Matches one or more instances
    of the preceding single character or regular expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `\{n\}` | `{n}` | Matches *n* occurrences of the preceding single character
    or regular expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `\{n,\}` | `{n,}` | Matches at least *n* occurrences of the preceding single
    character or regular expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `\&#124;` | `&#124;` | It’s called an **alternation**, but think of it as
    an `or` operator. |'
  prefs: []
  type: TYPE_TB
- en: '| `\(regex\)` | `(regex)` | This symbolizes grouping. It matches the regex
    that’s within the parentheses, but it can be modified as a whole. It can also
    be used in back-references. |'
  prefs: []
  type: TYPE_TB
- en: Don’t worry about the difference between the **Basic Modifiers** and **Extended
    Modifiers** just yet. I’ll cover that when we get to the *Understanding grep*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: As I said before, the topic of Regular Expressions is quite vast and complex.
    I don’t have space to give a complete tutorial on the subject, so I’ll instead
    just provide examples of using various regular expressions in the `sed` and `grep`
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find some more information on regular expressions by looking at the
    `regex` man page, which is in section 7 of the man pages. (Just don’t expect to
    become a regex expert by reading it.) View the proper man page by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`man 7 regex`'
  prefs: []
  type: TYPE_NORMAL
- en: Now that I’ve introduced you to Regular Expressions and regular expressions,
    allow me to introduce you to a utility that uses them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding sed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`sed`, short for **Stream Editor**, is an extremely powerful utility, and is
    another subject on which whole books are written. The goal here is to help you
    learn the basics for now, and to whet your appetite to learn more later.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever had to error-check or edit large text documents, you’ll appreciate
    the power of `sed`. For simple jobs, a one-line command, known as a **sed script**,
    might be all you need. For more complex jobs, such as when you might need to make
    multiple changes at a time to one or more documents, you can write lengthy program
    files and execute them with `sed`. The only limitation is your own imagination.
    But, before we can talk about the cool things you can do with `sed`, we need to
    take a brief intermission to talk about `sed` portability issues.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding sed Portability Issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to work with non-Linux operating systems, you’ll encounter two different
    implementations of `sed`. Linux operating systems use the GNU implementation,
    and the BSD implementation is used on macOS, the BSD distros, and OpenIndiana.
  prefs: []
  type: TYPE_NORMAL
- en: BSD stands for **Berkeley Software Distribution**, and GNU is a recursive acronym
    that stands for **GNU is not Unix**.
  prefs: []
  type: TYPE_NORMAL
- en: The difference is that the GNU implementation has really cool, advanced features
    that the BSD implementation lacks. So, many of the examples that I’m about to
    show you in this section—specifically the append (`a)`, insert (`i)`, and change
    (`c)` commands, as well as any command that uses a regular expression—won’t work
    on the BSD implementation. Fortunately though, there’s an easy fix for all of
    these operating systems. Just install the `gsed` package, and then create a `sed`
    alias that points to the `gsed` executable. Here are the directions for the various
    operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Installing gsed on FreeBSD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On FreeBSD, install `gsed` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, edit the `.shrc` file that’s in your home directory, adding the following
    line to the alias section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Log out of the terminal and then log back in again. Verify that the alias has
    taken effect by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Installing gsed on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Installing `gsed` on macOS is just as easy, but you’ll first need to install
    the Homebrew system.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll find directions on how to install Homebrew at: [https://brew.sh/](https://brew.sh/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, install `gsed` by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the alias to the `.zprofile` file that’s in your home directory, by adding
    this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Close your terminal window and then open it again. Then, verify that the alias
    has taken effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Installing gsed on OpenIndiana
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OpenIndiana doesn’t have `gsed` in its normal software repository. So, you’ll
    need to install a third-party repository to get it. First, open Firefox on your
    OpenIndiana machine and navigate to: [http://buildfarm.opencsw.org/opencsw/official/](http://buildfarm.opencsw.org/opencsw/official/)'
  prefs: []
  type: TYPE_NORMAL
- en: Download the the `pkgutil.pkg` file that you’ll see there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the package by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install `pkgutil` into the `/opt/csw/bin`/ directory, as you see
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This directory isn’t in your `PATH`, so you’ll need to fix that. The easiest
    way is to create a symbolic link in the `/usr/sbin/` directory, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install the `gsed` package, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you’re ready to create the alias. On OpenIndiana, you’ll need to create
    it in two different files. To enable the alias when you open a terminal on the
    local machine, you’ll need to add it to the `.bashrc` file in your home directory,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To enable the alias when you login remotely via `ssh`, you’ll need to create
    the `.bash_profile` file in your home directory, and add the same alias line to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve installed `gsed` and created an alias on your non-Linux system,
    you’ll be able to run any `sed` command you want from the command-line. Unfortunately,
    this won’t work if you place any `sed` commands into your shell scripts, because
    shell scripts don’t read the `.bashrc`, `.shrc`, `.bash_profile`, or `.zprofile`
    files that contain the alias. That’s okay for now, because I’ll show you how to
    deal with that later. First though, I need to show you how to use the various
    `sed` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Now that that’s done, let’s look at how to actually use `sed`. There are several
    different `sed` functions that you need to know. Let’s start with the substitute
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Substitution with sed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the diagram below, you see the breakdown of a typical `sed` substitution
    script.
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_9_1](img/B21693_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: A typical sed substitution script'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at some specific examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Modifying an Office Memo'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s begin with a simple office memo. Create the `tom.txt` file, as you see
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the document has a few problems. The most obvious is that proper
    names aren’t always capitalized. We need a way to automate the process of making
    these corrections.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to make all corrections at once, but first, let’s just look at
    how to replace *tom* with *Tom*. Do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you see within the single quotes is the letter `s`. That’s what
    tells `sed` to perform a substitution. Next, you see the two patterns that you’re
    working with. The first is the pattern that you’re replacing, and the second is
    what you’re using as the replacement. After you close the expression with another
    single quote, list the text file that you want to modify. (Note that you don’t
    need a `stdin` redirector.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this did work for the most part, but we still have one lower-case *tom*
    in the last line of the body. That’s because by default, the `s` command for `sed`
    will only replace the first occurrence of a pattern in a given line. To fix this,
    use the `s` command with its global (`g`) option. That way, every occurrence of
    a pattern in any given line will be replaced. Here is what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This works much better. But, we still have lower-case surnames to replace.
    Let’s combine two commands to replace both the first and last names at once, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All you have to do is create two separate `sed` scripts, and combine them with
    a semi-colon. You can place both scripts within only one set of single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `sed` will read in the text file that you want to modify, and send
    the entire modified file to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: What if you only want to see the lines that actually got modified?
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, you would use the `-n` switch as the `sed` option, and the `p` switch
    as the `s` command option. First, let’s look at what happens when you use only
    one of these switches at a time. Here’s what happens if you use `-n` without the
    `p`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Without the `p` switch for the `s` command, the `-n` switch will suppress all
    output, which isn’t what we want. This is because the `-n` switch is the *quiet*
    switch, which negates `sed`'s default behavior of passing the processed file to
    `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s try it with just the `p` and without the `-n`, which will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Without the `-n` option, the `p` option for the `s` command will cause `sed`
    to print its default output, in addition to printing the modified lines a second
    time. (Actually, we see here that two lines were printed a third time, since more
    than one replacement was done in each.) This is because without the quiet switch
    (`-n`), `sed` once again defaults to printing out the processed file. Then, the
    `p` option for the `s` command causes all modified lines to print out again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to see only the modified lines, let’s combine the options, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So the lesson here is that you must use `-n` and `p` together, because using
    just one of them won’t give you what you want.
  prefs: []
  type: TYPE_NORMAL
- en: Wait though, you’re not through yet. It seems that your boss is a bit of a practical
    joker. So, he tells you to replace the last *Tinker* with *Stinker*. As he turns
    to leave, he winks and says, “Yeah, that’ll get him”. Here’s where the addressing
    option comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you know that the last *Tinker* is the last word in the last line of
    the file, you can direct `sed` to only replace that occurrence by placing the
    *end-of* metacharacter (`$`), in the address. Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Okay, let’s move on to our next example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: Modifying a List of Hollywood Actors'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are still plenty of other ways to perform substitutions with `sed`. To
    demonstrate, create the `actorsfile_11.txt` file with the following list of Hollywood
    actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ve decided that you want to replace Groucho Marx with his brother Zeppo.
    Search for all lines that begin with Marx, and make the replacement only on those
    lines, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you used a regular expression for an address. That is, you
    placed the literal string *Marx* within the default `sed` delimiters (the forward
    slashes), then preceded it with the `^` metacharacter. That causes the substitute
    command to look for only the occurrence of *Marx* at the beginning of a line.
    Note again how this address immediately precedes the `s` command. You don’t need
    to use the global option for the `s` command, because you already know that there’s
    only one occurrence of a given word in each line.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve now decided that you need to replace Joe Besser with Joe DeRita. (That’s
    appropriate, because in real life the Three Stooges really did replace Joe Besser
    with Joe DeRita, after Joe Besser left to care for his ailing wife.) This time,
    you want to search for lines that end with *Joe*, and make the replacement only
    on those lines, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This time, you used the `$` metacharacter in the address to tell `s` to look
    at the end of the lines. Note how you had to place this metacharacter at the end
    of the literal string.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, enough of actors. Let’s look at some classic cars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3: Modifying Lists of Cars'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also replace individual characters. Create the `cars_2.txt` file with
    the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In thisfile, you see that you need to capitalize the names of some of the listed
    cars. For now, let’s just concentrate on capitalizing *Desoto*. If you tell `sed`
    to replace every *d* with a *D*, you’ll get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s not what you want. But, you know that there is a lower-case *desoto*
    only in lines four and five. So, you can tell `sed` to replace the lower-case
    *d* in only those two lines, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that the comma between the two line numbers means *lines four through five*,
    not *lines four and five*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can tell `sed` to search for *desoto* at the beginning of a line, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert the `-n` and `p` switches if you only want to see the lines that changed,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three ways to save your modifications. You can use the `stdout` redirector
    to create a new file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `w` switch with the `s` command to save to a new file, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The only catch with this is that even though the `w` switch shows the entire
    contents of the modified file on screen, it only saves the modified lines to a
    new file, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The final way to save your modifications is to use the `-i` switch to modify
    the original file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike when you use the `w` switch, the `-i` saves the entire modified file,
    as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to create a backup of the original file before it gets modified,
    just put the suffix that you want to append to the backup filename after the `-i`
    switch, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you can’t have a blank space between the `-i` and the `.bak`. Verify
    that the operation worked, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s do some whole-word substitutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 4: Performing a Whole-Word Substitution'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What if you have a pattern that can be part of other words, but you only want
    to perform substitutions on the pattern if it’s a whole word unto itself? To illustrate,
    create the `ing.txt` file with this somewhat corny story:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s say that you want to replace the word *ing* with the word *ING*.
    Try this command to see what you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You really only wanted to replace the whole word *ing* with *ING*, but ended
    up replacing the *ing*’s that show up in other words, also. Here’s where you need
    to use word boundaries, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: All you had to do was to place the string that you wanted to replace inside
    of a of `\< \>` construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you look at the metacharacter chart that I presented a few pages back, you
    may think, “Hey, I’ve discovered another way to do this. I can just use a wild-card
    character”. Indeed, in this case, it would work, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you used the `\+` metacharacter to replace all *ing*’s that are preceded
    by one or more blank spaces. (Note that I left a space between the first forward
    slash and the `\+` metacharacter in the `s` command. I also had to leave a blank
    space before the *ING* in order to also leave a space in the output.) However,
    in this case, this isn’t the most elegant solution, since it won’t work in all
    cases. To illustrate, create the `ing_2.txt` file, and make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform the previous command again, and you should get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The *ing* in the last line didn’t get replaced, because it’s at the beginning
    of a line. Therefore, no blank spaces can precede it. Wild-card metacharacters
    are handy devices, and do have legitimate uses. But here, we find that they’re
    not the best solution.
  prefs: []
  type: TYPE_NORMAL
- en: That covers it for substitution. Let’s now do some deletions.
  prefs: []
  type: TYPE_NORMAL
- en: Deletion with sed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the `d` command to perform deletions. This is simpler than the substitution
    process, since all you really need is an address and the `d` command. We’ll begin
    by deleting some items from a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Deleting Items from a List'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take another look at our `cars_2.txt` file, and try to delete all references
    to Edsel. (We want to forget that the Edsel was ever made, as Ford Motor Company
    has tried to do ever since 1960.) First, as a reminder, here’s what the original
    file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, it’s not exactly original, because I forgot that I had modified it to
    capitalize all of the *desoto*’s. But, that doesn’t matter. To delete all references
    to the Edsel, try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This command only deleted the lower-case *edsel*. But, I need a way to delete
    all references to Edsel. Fortunately, you can use a regular expression to specify
    multiple characters in the address, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: All you had to do was to put both *e* and *E* within brackets, and use that
    for the first character of the address.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to delete everything except for references to *Edsel*, use an `!`
    to invert the command. Now, you’d think that you’d want to put the inversion character
    in front of the address that you’re searching for, but that isn’t the case. Instead,
    place the inversion character in front of the command character itself. So, in
    this case, you would place the exclamation point in front of the `d`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You’ve just seen an example of how things aren’t always implemented consistently
    across the various shell scripting tools. A while ago, you saw that the `^` is
    the inversion operator for Regular Expressions. Here, you see that the `!` is
    the inversion operator for `sed` commands. You’ve also seen that the `^` can also
    be used to indicate the beginning of a line. So yeah, things can get a bit confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also choose a range of line numbers for the address. This time, let’s
    delete all references to Nash, which happen to be in lines eight through ten,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Place an exclamation point in front of the `d` to delete everything except
    for lines eight through ten, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: That does it for the classic cars. Next, I’ll show you what to do if your file
    has too many blank lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: Deleting Blank Lines'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our last deletion trick, here’s how you can delete blank lines from a file.
    Just make an address with the start-of-line metacharacter (`^`) right next to
    the end-of-line metacharacter (`$`). Start by creating the `blank_lines.txt` file,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, perform the deletion, with `^$` as the regular expression, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note the difference between this and the way we previously used the *end-of*
    metacharacter in the substitution script. Since we’re using two metacharacters
    together to form a regular expression, we have to place them between two forward
    slashes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, for the next trick.
  prefs: []
  type: TYPE_NORMAL
- en: Appending and Inserting with sed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `a` command for the Linux implementation of `sed` is used to append a line
    of text after another line of text. Let’s see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Appending Lines of Text'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use that feature to add some model names to the cars list. Add the
    *Ambassador* model for the Nash line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s good, but you can make it better. Start by indenting the model names.
    Do that by adding a preceding tab, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note that I can only show a partial output here, due to book formatting constraints.
  prefs: []
  type: TYPE_NORMAL
- en: The control character for a tab is `\t`. Note though, that you had to add another
    backslash so that `sed` would properly recognize it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do the same thing by using a line address. Let’s append a model name
    to line six, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'But, that doesn’t cover all of the *Desoto*’s. Let’s append the model name
    to lines four through seven, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s combine some operations. Start by editing the `cars_2.txt` file
    so that it once again has some lower-case *desoto*’s. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: But, you’re not limited to just performing one operation at a time. So, let’s
    see how we can combine operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: Performing Multiple Operations at Once'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll add a model to both the Edsel and Desoto lines, and delete every make
    that isn’t capitalized. Note that you can’t just place everything within one set
    of quotes, or use a semi-colon to separate the operations. For this, you have
    to give every operation its own set of quotes, and precede every operation with
    the `-e` switch. That’s because these operations are sequential, which means that
    the first operation must run to completion before the second one can begin. Here’s
    how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve looked at appending text, let’s see how to insert text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3: Inserting Lines of Text'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `i` command works the same way, except that it will insert a line of text
    before another line of text, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As a bonus, I’ve also shown you another way to get rid of all car names that
    begin with a lower-case letter.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for this trick. Let’s move on to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Changing with sed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You would use the `c` command to change a string of text. (You can also change
    text with the `s` command, but this is a bit shorter to type.) Let’s see how it’s
    done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Changing Edsel to Studebaker'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As before, you’ll work with the `cars_2.txt` file. Begin by changing *Edsel*
    and *edsel* to *Studebaker*, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify the change to make by line numbers. Here’s what happens
    when you use the *edsel* and *Edsel* line numbers as the address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You see that this worked a bit differently than before. Instead of making the
    change to each line separately, as happened with the other commands, here the
    command tells `sed` to replace the range of lines as a group.
  prefs: []
  type: TYPE_NORMAL
- en: I know this looks amazing, but you haven’t seen anything yet. Check out this
    next amazing trick.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: Changing Entire Lines of Text'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For an even better example, create the `cars_4.txt` file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, prepare to be amazed when you run this `sed` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: So now, you see the biggest difference between the `s` and the `c` `sed` commands.
    Instead of just replacing the text string or pattern that you specify, the `c`
    command replaces the entire line in which the text string or pattern is found.
    In this case, every entire line that contains the text string *Edsel* was replaced
    with *1963 Studebaker Avanti*. Cool, right?
  prefs: []
  type: TYPE_NORMAL
- en: Other Miscellaneous sed tricks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re not done yet. Here are a few more cool tricks that you can do with `sed`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Using the q Command'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `q` command causes `sed` to behave just like the `head` utility. It tells
    `sed` to read in the designated number of lines, and then quit. If you want to
    show the first ten lines of our public domain e-book, enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to view selected lines from somewhere in the middle of a large
    file, you may find that `sed` is easier to use than the `head`/`tail` combination.
    Here’s how you can look at lines 1,005 through 1,010 of our e-book file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `p` that I used here isn’t quite the same as the `p` option for
    the *substitute* command. This `print` command is a separate command unto itself.
    Still though, it has to be used together with the `-n` option for `sed` to get
    the results that you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: Using the w Command'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the `w` command to write selected lines of text to a new file. You can
    use a regular expression as an address, as you did above for the `p` command,
    or you can use line numbers, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If the preceding command looks a bit confusing, you can insert some spaces
    to make it more clear, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Although you see the the contents of the entire file on screen, only the selected
    content gets saved in your new file, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The output will be the same as it was before. And, this demonstrates something
    that can be a bit confusing about `sed`. In some places of a `sed` script, blank
    spaces are optional. In other places, such as in a previous example when I showed
    you how to use the `-i` option with a filename suffix for the backup file, you
    can’t use a blank space. As I said before, there’s not always a lot of consistency
    with this stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3: Using the r Command'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `r` command will read a selected file and append it to the specified place
    in the file you’re working with. To see this, create the `cars_3.txt` file, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, insert the `cars_3.txt` file after the second line of the `cars_2.txt`
    file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, if this is confusing to read, then use the optional spaces, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Either way works equally well.
  prefs: []
  type: TYPE_NORMAL
- en: Using sed program files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have complex jobs that you perform on a regular basis, such as having
    to make multiple edits to either one or more documents at a time, you can create
    program files. Then, invoke `sed` with the `-f` switch to read the scripts from
    the file. Let’s look at a few examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Appending Lines in a Text File'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To see how this works, create the `myfile_3.txt` file, which will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `demo_append.txt` file, which will serve as the `sed` program
    file. Make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the program file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Note how I broke the single script in the program file into two lines. To make
    that work, I had to place a backslash at the end of the first line to let `sed`
    know that the script would continue on the next line. I’ll show you in a few moments
    why that is important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try a program file that will insert some lines. This time, I’ll
    use a text string for the address. Create the `demo_insert.txt` program file,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the program, and you’ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Example 2: Changing Lines in a Text File'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s change lines four through six to something else. Create the `demo_change.txt`
    file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that I again have to use backslashes to show that the script continues
    on the next line. Run the program, and you’ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Example 3: Substituting Text'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let’s create the `demo_sub.txt` program file that will substitute *sentence*
    for *line*, and that will only send the modified lines to `stdout`. Make it look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the program file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Note that I had to invoke the program with the `-n` option of `sed`, because
    I used the `p` option inside the program file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try this again, except this time, use the write option to send the changed
    output to a new file. Create the `demo_write.txt` program file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the program and view the new file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Example 4: Copying Lines from One File to Another'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, create the `demo_write_2.txt` program file, which will copy selected
    lines from one file to another file. Make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke it, and view the results, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: That’s it for the simple program files. Let’s now compound things a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Compound Scripts in sed Program Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, I’ve only shown you program files with one single `sed` script. You
    can also have program files with two or more scripts. Begin by creating the `demo_compound.txt`
    program file, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the `riding.txt` file, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the program file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: This program first had `sed` replace *Edsel* with *Packard* in lines one through
    three.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In lines two through four, it had `sed` replace *Packard* with *Lasalle*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the last script deleted line three. Note that you didn’t have to use
    backslashes here, since none of the scripts carried over on to the next line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see a second example, create the `demo_compound_2.txt` program file, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the program, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This time, you have one script that appends two additional lines after line
    two, and a second script that causes line three to print a second time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for fun, do the same thing again, except this time delete the second line.
    Create the `demo_compound_3.txt` program file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Even though you deleted the second line, you were still able to append the new
    lines to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s wrap up the `sed` discussion with something really fancy. Create the
    `tab.txt` program file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll be amazed when you run this program. Here’s what you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The first script adds a tab to the beginning of every non-blank line. (The `^.`
    combination means to look for every line that begins with a non-blank character.
    The `&` after the tab character prevents `sed` from replacing the first character
    of each line with the tab. Instead, it just inserts the tab before the first character.)
    The second script changes the text in line eight. Finally, the third script deletes
    line one.
  prefs: []
  type: TYPE_NORMAL
- en: Using sed in Shell Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `sed` in shell scripts is easy, if you only intend to run your scripts
    on Linux systems. For example, you can do something like this `sed_test_0.sh`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how it looks when I run it on my Fedora workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'But, this won’t work with the default implementation of `sed` that comes with
    FreeBSD, OpenIndiana, or macOS. In fact, here’s what the above script gives me
    on a FreeBSD machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: According to the error message, I should be able to make this work by preceding
    *1958* with a backslash. But, I tried it, and it still doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned in the *Understanding sed Portability Issues* section a few
    pages back, the implementation of `sed` that comes with most non-Linux systems
    lacks the capabilities of the Linux implementation. Specifically, the non-Linux
    implementation of `sed` lacks the ability to use the append (`a`), insert (`i`),
    and change (`c`) commands, as well as the ability to deal with regular expressions.
    So, you’ll need to install `gsed` on your non-Linux systems and create an alias
    in your shell configuration files if you want to experience the full power of
    `sed` on your non-Linux machines. The second problem is that your shell scripts
    won’t read the shell configuration files that are in your home directory. That
    in turn means that they won’t find the `sed` alias that you created in those configuration
    files. Here’s one solution for fixing that, in the `sed_test_1.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we want to invoke `sed` on our Linux machines, but we want to invoke `gsed`
    on everything else. To accomplish that, I’m using `$(uname)` to obtain the name
    of the operating system. In the first `if` statement, I’m using the `||` construct
    as an `or` operator. That way, I can test for Darwin, FreeBSD, or SunOS with just
    this one `if` statement. Then, I’m creating the `gsed` variable, and assigning
    either `gsed` or `sed`, as appropriate, as its value. Finally, in the `$gsed`
    line at the bottom, I’m calling back the value of the `gsed` variable to invoke
    either the `gsed` or the `sed` command. Does it work? Let’s see what it does on
    FreeBSD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Oh, yeah. It works like a champ. I’ve also tested this on macOS, Linux, and
    OpenIndiana, and it works properly on all of them.
  prefs: []
  type: TYPE_NORMAL
- en: I know, I’ve never before shown you that you can use a variable with a command
    as its assigned value. But, you see here that it’s a handy little trick that you
    might find very useful.
  prefs: []
  type: TYPE_NORMAL
- en: And, this pretty much covers our discussion of `sed`. But, there’s still a lot
    to learn about `sed`. As I’ve said before, it’s another one of those topics about
    which whole books have been written. This will give you a good start, and will
    give you more than enough to pass the `sed` section of an introductory Linux certification
    exam.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s talk about `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding grep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve already shown you some fancy ways to search for files on your system. But,
    what if you need to search for something that’s *in* a file? What if you don’t
    know exactly what you’re looking for? Worse yet, what if you don’t even know which
    file to look in? Not to worry, `grep` is here to help.
  prefs: []
  type: TYPE_NORMAL
- en: '`grep`, short for *Global Regular Expression Print*, is a powerful command-line
    utility that comes packaged with just about every Unix or Unix-derived operating
    system. (This includes Linux and macOS.) There’s also an available version for
    Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: You can direct `grep` to search through one file or many. You can also pipe
    in output from some other utility so that you’ll see only the information that
    you want to see. And, the fact that `grep` can use regular expressions allows
    you to perform searches even when you only have an approximate idea of what you’re
    searching for.
  prefs: []
  type: TYPE_NORMAL
- en: '`grep` isn’t hard, but is does require a bit of practice. If you’re ready,
    let’s get started.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic Searches with grep
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve already shown you some examples of using `grep` in *Chapter 7, Text Stream
    Filters Part 2* and *Chapter 8, Basic Shell Script Construction*, but that’s okay.
    I’d still like to start with the basics and provide an explanation of how to use
    it. I’ll begin the demos with some text files that you’ve already created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic way to use grep is to search for a text string within a single
    file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Here, I listed the text string that I want to find, and then listed the name
    of the file that contains the text string. I surrounded the search term with a
    pair of single quotes, but I didn’t need to in this case. I only need the quotes
    if the search term contains characters that the shell will interpret incorrectly.
    (I most always use the single quotes, due to force-of-habit.)
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `grep` is case-sensitive. Use the `-i` switch to make it case-insensitive,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to see which lines of the file contain the search term, use the
    `-n` switch, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use a wild-card to search through multiple files at once, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Note how the filenames are now included in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-v` switch means inverse. Use it to show all lines that *don’t* have the
    specified search term, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-c` switch shows a count of how many times a search pattern is in a file,
    but it doesn’t show the lines where the search pattern was found. It looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, I’ve been showing you how to combine the `grep` option switches
    with just a single `-`. Of course, you can just use one option at a time, if that
    fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so these were fairly simple examples, and you’re saying, “Hey, when do
    we get to the good stuff?” Well, hang on, it’s coming.
  prefs: []
  type: TYPE_NORMAL
- en: More Advanced Searches with grep
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are a few more cool grep optons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Searching for Whole Words'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, `grep` doesn’t search for whole words. So, if you search for the
    text string *and*, it will display lines that contain the words *land*, *hand*,
    *sand*, along with the word *and*. Let’s look at that by searching through our
    public-domain e-book for the text string *noun*. (It’s a very long output, so
    I’ll only show part of it.) I’ll make it a case-sensitive search, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'This search returned not only lines that contain the word *noun*, but also
    lines that contain *nouns*, *pronouns*, *Pronouns*, and *Pronoun*. One line has
    the word *pronouncing*. If you want to search for the word *noun*, and only the
    word *noun*, then you’ll have to add the `-w` switch, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: You’ve narrowed the search considerably. (You’ll still see some *Pronouns* in
    here, but only because they were on the same line as a *noun*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: Making Searches Case-Insensitive'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now, add the `-i` switch to make the search case-insensitive, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `^` metacharacter to the left of the search pattern, and `grep` will
    only display the lines where the search pattern appears at the beginning, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Just for curiosity, count how many times the whole word *noun* shows up in
    this document by using the `-c` switch, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, will it make a difference if I omit the -i switch to make this case-sensitive?
    Let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: So, we have a total of 33 case-insensitive *noun* strings, and 29 that are case-sensitive.
    This tells me that there are four *noun* strings with at least one upper-case
    letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3: Dealing with Carriage Returns'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here’s a realistic scenario that you just might encounter at some point in your
    Linux career. It’s one that could cause you a good bit of consternation until
    you finally figure it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve just seen how to perform a case-insensitive search for every occurrence
    of the word *noun* at the start of a line. You found one *NOUN* on a line by itself.
    It would make sense then that you would also find that line by performing a case-insensitive
    search for *noun* at the end of lines. So now, give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Wait a minute. Why didn’t it find anything? We know that there’s one to be found.
    Well, here’s a clue.
  prefs: []
  type: TYPE_NORMAL
- en: A few chapters back, I told you that I downloaded this file from the Project
    Gutenberg web site. So, there’s a good possibility that the file was created with
    either a DOS or Windows text editor.
  prefs: []
  type: TYPE_NORMAL
- en: That’s significant because DOS and Windows text editors place a carriage return
    character at the end of each line in text files, where Unix and Linux text editors
    just use newline characters. If `grep` sees a newline character during a search,
    it will just ignore it. However, it won’t ignore a carriage return. Now, let’s
    test our theory. I’ll start by showing you how to use another Regular Expressions
    metacharacter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you place a dot in a search pattern, it means that you’ll accept the presence
    of any single character in that position, as long as the rest of the pattern can
    make a proper match. So, place a dot at the end of your search pattern. Then,
    pipe the output into the `od -c` command, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Yeah, there’s the problem. The `\r` is the carriage return control character.
    Not to worry, though. Just use `tr` with the `-d` option to get rid of those pesky
    rascals. Save the converted output to a new file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the carriage returns are gone and that the `grep` search now works
    correctly, by performing the searches without the dot in the pattern. It should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Now when you feed the search output through `od`, you’ll see that the carriage
    return character is gone. Then, when you try the original search, you get just
    what you’re supposed to get.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, you’re not done yet. What if there’s a *noun* at the end of a line that’s
    also the end of a sentence? Then, the *noun* would be followed by a period, and
    the search as you’ve just performed it wouldn’t pick it up. Let’s go back a few
    steps, and perform the search with our dot metacharacter again, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the carriage return character is gone, this search now finds *noun.*
    and *nouns.* But, you don’t want to find *nouns*. You only want to find the singular
    *noun*. I’ll show you how by introducing another metacharacter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: By placing a backslash in front of the dot, you’ve turned the dot metacharacter
    into a common period. The `\?` tells `grep` to try to find a match for the character
    that precedes it, but that it’s okay if it doesn’t find a match. So here, you’re
    telling `grep` to perform a case-insensitive search for the whole word *noun*
    at the ends of lines, with or without the period. (Are you beginning to see how
    much fun that Regular Expressions can be?)
  prefs: []
  type: TYPE_NORMAL
- en: Okay, you’ve seen some cool stuff, but you’re still not done. So, let’s move
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Even More Advanced Searches with grep
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can combine `grep` with other utilities for even more advanced searches.
    Here’s how.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Auditing Source Code Files'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demo this, use either your Fedora Server or your Debian virtual machine,
    so that you can install a package that you might not want to install on your Linux
    workstation, if that’s what you’re using. On Fedora Server, install the `cairo-devel`
    package, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’d rather use the Debian virtual machine, install the `libghc-cairo-dev`
    package, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, look through the source code files in the `/usr/include/cairo/` directory,
    looking for lines that have the string `#include`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t want to show the filenames where the text strings are found, use
    the `-h` switch. Then feed the lines through `sort`, which in turn will feed the
    lines through `uniq`. That way, you’ll end up with sorted output, and all duplicate
    lines will be eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: Also, by using the `-c` switch with `uniq`, we’ll find out how many times each
    particular line was duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: Searching for Social Security Numbers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s a more complex example of how to use a regular expression for your search.
    First, create the `ssn.txt` file with a list of names, birth dates, and US Social
    Security numbers, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Note that these are all fictitious, so we’re not violating anyone’s privacy
    here. Also, I have no idea why I chose German foods for the surnames. Perhaps
    I was hungry?
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, construct a `grep` command that will only show lines that contain Social
    Security numbers, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Here, each instance of `[0-9]` means that you’re searching for any digit. The
    numbers that are surrounded by the backslashes and curly braces mean that you
    want to find a certain number of consecutive digits. So, the `[0-9]\{3\}` construct
    means that you’re hunting for three consecutive digits. There are three of those
    groupings in this regular expression, all separated by a hyphen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3: Using the ^ Metacharacter'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s one more example before we move on to the next topic. This is an example
    of how the `^` metacharacter can have two different meanings, depending on its
    placement in the regular expression. See how that works in the following `grep`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: In this command, the `'^[^a-zA-Z]'` regular expression means to look for all
    lines that do *not* begin with a letter. That’s because outside of the square
    bracket, the `^` means to only look for a match at the beginning of a line. Inside
    the square brackets, in front of the designated search term, it means to display
    everything that *doesn’t* match that term.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you’ll also see a lot of consecutive blank lines, since blank lines
    don’t start with a letter. If you don’t need to see all of those blank lines,
    just feed the grep output into `uniq`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to scroll through the output of both of these two commands, and note
    the difference.
  prefs: []
  type: TYPE_NORMAL
- en: All right, let’s move on to see if we can extend things a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Using Extended Regular Expressions with grep
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you saw on the regular expressions metacharacter charts a few pages back
    in the *Understanding Regular Expressions* section, there are two forms of command
    syntax for `grep`. What I’ve shown you so far is the *basic* syntax. The other
    form is the *extended* syntax. Here are two differences between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic syntax requires the use of a backslash in front of certain metacharacters,
    but extended syntax doesn’t.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended syntax requires that you either use `egrep` instead of `grep`, or `grep`
    with the `-E` option switch. (Be aware that although `egrep` still works for now,
    it’s considered as obsolete and might cease to work in the future. So, you should
    always use `grep -E`, instead.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Okay, here are some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Basic Search with Extended Syntax'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take another look at a previous example. Here’s the command with normal,
    basic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the exact same command with extended syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Okay, it’s not a big deal here, because using the extended syntax only eliminated
    one backslash that I had to type. But, if you have a `grep` command that requires
    you to escape lots of characters with basic syntax, the extended syntax could
    considerably cut down on the typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: Searching for Consecutive Duplicate Words'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next example is just a bit more complex. You’re looking through the `/etc/services`
    file for all lines that contain consecutive duplicate words, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: The `\<. . .\>` construct represents a word boundary. The pattern that’s inside
    this construct will match a single word, and only a single word.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `[a-z]` means that we’re looking for a single alphabetic character. Of course,
    you see nothing but lower-case letters here, which would normally mean that this
    would only match lower-case letters. But, the `i` in the `grep -Ei` command makes
    this case-insensitive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` at the end of `[a-z]` is called a **repeat character**. This means that
    we want to match one or more of whatever character or set of characters precedes
    it. In this case, we want to match a pattern that contains only the set of characters
    that’s between the two square brackets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing the `[a-z]+` within a pair of parentheses indicates that we want to
    evaluate this part of the regular expression before we evaluate the second part.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `+\1` in the second part of the regular expression means that we
    want to find an additional second match to the pattern that’s described in the
    first part. In other words, we want to find all lines in the `/etc/services` file
    that contain two consecutive identical words.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, make the search case-sensitive by leaving out the `-i` option, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Example 3: Searching for Words that Begin with a Certain Letter'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, look through the `/etc/` directory for all files and directories with
    names that begin with either a *p* or a *q*, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Try that again, except this time look for files and directories that have *p*
    or *q* as the first letter, and that also have *p* as the second letter, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, list all files and directories in the `/etc/` directory with names that
    begin with *se* and have the optional third letter of *r*, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Try this again, but this time *require* that the file and directory names have
    *r* as the third letter. (I’m not going to show you how this time, but I will
    give you a hint. Just look at the previous example.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next example, I’m going to show you a bit of shorthand. List all files
    and directories in the `/etc/` directory that use non-alphanumeric characters
    in their names, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: You see the file and directory names that contain characters such as dots, underscores,
    and hyphens. Any file or directory name that doesn’t have any of these non-alphanumeric
    characters won’t show up. The `\W` in this example is just shorthand for `[^_[:alnum:]]`.
    The `^` indicates an inversion, which causes `grep` to search for the non-alphanumeric
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: Using a lower-case *w* (`\w`) would replace `[_[:alnum:]]`, which would cause
    `grep` to search for all alpha-numeric characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 4: Searching for Words with Digits'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, search through `/etc/` for all files and directories with a numeric digit
    in their names, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'For the final example, use the alternator operator to create an either/or type
    of regular expression, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The `|` in the `(cron|yum)` construct acts as an `or` operator, which allows
    `grep` to search for directories and filenames that contain either *cron* or *yum*.
    (By the way, if you’re doing this on a Debian machine instead of a Fedora machine,
    just replace *yum* with *apt*.)
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for extended `grep`. Let’s turn our attention to fixed-strings.
  prefs: []
  type: TYPE_NORMAL
- en: Using Fixed-strings Regular Expressions with grep
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Either `fgrep` or `grep -F` will interpret any patterns you feed it as literal
    expressions. So, if you follow either `grep -F` or `fgrep` with a regular expression,
    you’ll actually be searching for that regular expression, instead of the parsed
    pattern. For example, let’s copy the `ssn.txt` file that we used earlier to `ssn_2.txt`,
    and add a line. The new file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'This new last line is the regular expression that you’ll use to search through
    the file. Using `grep` with no options, as you saw before, will yield a list of
    lines that contain Social Security numbers, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'But, look what happens if you use either `fgrep` or `grep` `-F`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: With either `fgrep` or `grep -F`, the regular expression is interpreted as just
    another text string.
  prefs: []
  type: TYPE_NORMAL
- en: As is the case with `egrep`, `fgrep` is considered as obsolete and might cease
    to work in the somewhat near future. So, your best bet is to get used to using
    `grep -E` and `grep -F`, instead of `egrep` and `fgrep`. (The main reason I mention
    them at all is because you might find other tutorials that mention them.)
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen some regular expressions in use, let’s look at how to simplify
    the process of creating them.
  prefs: []
  type: TYPE_NORMAL
- en: Using RegEx Helper Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, now that you’ve seen so many examples, you can now create regular expressions
    to do whatever you need to be done.
  prefs: []
  type: TYPE_NORMAL
- en: What?! *No*, you say?
  prefs: []
  type: TYPE_NORMAL
- en: Don’t feel bad. I’ve told you already that Regular Expressions is quite complex,
    and is something about which entire books have been written. That’s where a helper
    program can come in handy. Let’s look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: RegexBuddy and RegexMagic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RegexBuddy and RegexMagic are a pair of helper programs that are published by
    the *Just Great Software* company. The difference between them is that RegexBuddy
    is mainly a point-and-click interface for building your own regular expressions.
    There is a library of pre-built regular expressions that you can use, but to build
    anything else you’ll still need to know something about the Regular Expressions
    language.
  prefs: []
  type: TYPE_NORMAL
- en: RegexMagic is great for Regular Expressions beginners, because all you need
    to do is to enter some sample text and mark the areas that you want to convert
    to a regular expression. RegexMagic then generates the regular expression for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: There are really only two slight drawbacks to RegexBuddy and RegexMagic. First,
    they’re both closed-source, commercial programs, so you’ll need to pay for them.
    But, the price is quite reasonable, at only US $39.95 each. (You can get a discount
    if you buy them both in a bundle.)
  prefs: []
  type: TYPE_NORMAL
- en: The second slight drawback is that they’re only written for the Windows operating
    system. However, you’ll be glad to know that they both run fine under WINE on
    Linux machines. (In fact, I have them both installed here on this Fedora workstation.)
    The RegexBuddy and RegexMagic websites even give you directions on how to install
    these programs under WINE.
  prefs: []
  type: TYPE_NORMAL
- en: WINE is a recursive acronym that stands for *WINE is Not an Emulator*. It’s
    a translation layer that converts Windows executable code to Linux executable
    code, and is included in the repositories for pretty much every Linux distro.
  prefs: []
  type: TYPE_NORMAL
- en: Also, please know that I have no financial arrangements with the folk at Just
    Great Software, so I don’t receive any compensation for telling you about their
    products.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out these cool products, just visit their websites. You can find RegexBuddy
    here: [https://www.regexbuddy.com/index.html](https://www.regexbuddy.com/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, you can find RegexMagic here: [https://www.regexmagic.com/](https://www.regexmagic.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s check out a free tool.
  prefs: []
  type: TYPE_NORMAL
- en: Regex101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you prefer to use a free-of-charge tool, you might want to check out Regex101\.
    It’s web-based, so there’s nothing to download or to install. It doesn’t have
    the bells and whistles that RegexBuddy and RegexMagic have, but there’s enough
    there to get you started. Signing in to an account is optional, but there are
    benefits to doing so. Note that you won’t be creating an account, but will instead
    be signing in via either your Google or Github account.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check out Regex101 here: [https://regex101.com/](https://regex101.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: I think that we’ve covered enough theory. Let’s move on to the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at Some Real-World Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have some cool case studies on how to use `sed`, `grep`, and regular expressions
    in real life. So, read on and enjoy!
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Multiple Files at Once
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have more than one file that you need to modify in the same manner, you
    can have `sed` do them all in one command, just by using a `*` wildcard in the
    filename. Quite a few years ago I assisted a website maintainer in migrating a
    set of PHP-based websites from a CentOS 5 server to a CentOS 6 server. To make
    the sites work with the newer PHP version, she needed to add a line of new code
    to each `.php` file. That could have been a bit problematic, because she had about
    2,000 files to modify, which is more than you’d want to edit manually. I suggested
    that she use `sed` to modify all files at once, and she knew immediately what
    I was talking about. (I jogged her memory by making the suggestion.)
  prefs: []
  type: TYPE_NORMAL
- en: Searching Through Apache Webserver Logs for Cross-site Scripting Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: About 15 years ago, a security worker buddy of mine called me with an urgent
    plea for help. His boss at the credit union where he worked had handed him a USB
    memory stick with four Gigabyes--Yes, four *Gigabytes*!--worth of compressed Apache
    access logs, and told him to look through them for signs of **cross-site scripting
    attacks**. What’s a poor security admin to do in a case like this?
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site scripting, often abbreviated as **XSS**, is used by malicious hackers
    to steal information or to manipulate websites. I know that this name is confusing,
    and that it doesn’t give you an accurate picture of what XSS attacks really do.
    It would be more accurate to call this type of attack a **Javascript injection
    attack**, because that’s how it really works.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an attacker finds a website that’s vulnerable to this type of attack,
    he or she can use an attack tool, such as ones that are part of Kali Linux, to
    perform his or her dirty deeds. Or at least, that’s how it is nowadays. When my
    buddy called me up 15 years ago, it was still possible to perform an XSS attack
    with a simple web browser. All an attacker had to do was to append some special
    Javascript code to the end of a website’s URL, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: It’s no longer possible to perform an XSS attack with a web browser, because
    modern versions of all web browsers now sanitize their input. So now, the Javascript
    in the URL no longer has any effect.
  prefs: []
  type: TYPE_NORMAL
- en: But, I digress.
  prefs: []
  type: TYPE_NORMAL
- en: 'After my buddy called me, I set up a machine with an Apache webserver, and
    then performed some XSS attacks against it from another machine. I discovered
    that log file entries that were the result of an XSS attack had a `%` pattern
    in the `GET` portion, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The `GET /%27%27` part is what tells us that this is from an XSS attack. No
    log file entries that were the result of normal website access had this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'There were also a couple of other variations on this pattern, and the first
    thing I had to do was to create the regular expressions that I needed to match
    all of them. The regular expressions that I created were `GET /%`, `GET /.%`,
    and `GET /.=%`. (The dot is a wildcard, which tells the script to search for any
    character in that position.) Next, I created the script, using the `find` utility
    to find and read all of the Apache log files. Here’s the script that I created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing you see is that I’m using positional parameter `$1` to designate
    the mount point of the USB memory stick, and positional parameter `$2` to designate
    the filename of the report file. The `if..then` construct is a safety feature
    that prevents the user from overwriting an existing file. The command to invoke
    the script would have looked something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Linux system log files are normally always compressed with `gzip`, and the filenames
    will end with a `.gz`. So, I had `find` search for all `.gz` files on the memory
    stick, read them with `zcat`, and pipe the output into `grep`. Finally, I had
    the report automatically open in `less`.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, my buddy was able to verify that this script actually does work.
    The previous autumn, the credit union had hired a penetration testing outfit to
    test security, with XSS attacks being part of the test. The script found all instances
    of the pen tester’s attack, so everyone was happy.
  prefs: []
  type: TYPE_NORMAL
- en: Automating Third-party Repository Installations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next real-world script that I’ll show you is, sadly, one that you won’t
    be able to run. That’s because I created it sometime in either 2010 or 2011, when
    I was creating training documentation and plug-ins for the Nagios monitoring system.
    My client and I were doing everything with CentOS 5 and CentOS 6 at the time,
    which are now both obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: This scenario is part of a larger scenario that involved automatically downloading
    and compiling Nagios Core source code on a CentOS server. One of the prerequisites
    was to install the RPMForge and EPEL third-party software repositories. At that
    time, installing a third-party repository on CentOS also required you to configure
    the priorities of each of the repositories, in order to prevent having one repository
    overwrite packages that had been installed from another repository. Since my client
    and I were constantly having to perform new Nagios installations, I wrote a script
    to help automate the process. The script is too large to reproduce here, so I’ll
    invite you to download the `add-repos.sh` script from Github. However, I will
    reproduce a few snippets here to explain things.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the script, you see this `if..then..else` construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: At that time, the computer industry was still transitioning from 32-bit to 64-bit
    CPUs. So, the maintainer of the now defunct RPMForge repository offered separate
    installation packages for each. (I wanted to completely make the break to 64-bit,
    but my client insisted on still supporting 32-bit.) This construct automatically
    detects which flavor of CentOS is installed, and then downloads and installs the
    appropriate RPMForge package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the line that installs the packages for the EPEL repository and for
    setting the repository priorities. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to use `sed` to automatically set the priorities for each
    section of the various repository configuration files. Here’s a snippet from one
    of those files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Other sections of the file were named `[updates]`, `[extras]`, `[centosplus]`,
    and `[contrib]`. (To see the whole file, download the `CentOS-Base.repo` file
    from GitHub.) The other configuration files were also divided into sections with
    different names. The goal was to use `sed` to automatically append a `priority=`
    line just under the `[section_name]` line of every section of every file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what those `sed` scripts look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'You see that each `sed` script appends the proper priorities settings to their
    proper places. The result would have looked something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: And now, let’s look at one final real-life scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Filling Empty Fields in a .csv File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you ever have to work with columnar data, you might find yourself having
    to work with **Comma Separated Value** (`.csv`) files. As the name suggests, these
    are files with rows of data, with the same number of fields in each row. The fields
    are all separated by commas, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The beauty of `.csv` files is that you can use a normal plain-text editor to
    create them. Then, you can open them up in any spreadsheet program, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_9_2](img/B21693_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Opening a .csv file as a spreadsheet'
  prefs: []
  type: TYPE_NORMAL
- en: 'At times, you might encounter a `.csv` file that contains empty fields, like
    this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'You see that the commas are there, but there are no values in the fields between
    them. Opening this file in a spreadsheet program would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_9_3](img/B21693_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Opening a .csv file with empty fields'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, that doesn’t look like a complete disaster, but you want something that
    looks better. So, you need to find an easy way to place values in all of the empty
    fields. You might want to insert some value as just a placeholder, or you might
    want to insert some text that explains why the fields are empty. Either way, `sed`
    makes that easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, I have to confess that someone else has already created a solution for
    this, and I can’t really improve upon it. So, rather than try to explain the solution
    myself, I’ll invite you to visit the author’s original article that contains the
    solution, which is here: [https://linuxconfig.org/how-to-fill-all-empty-valued-cells-within-a-csv-file-with-sed-and-bash-shell](https://linuxconfig.org/how-to-fill-all-empty-valued-cells-within-a-csv-file-with-sed-and-bash-shell)'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, that covers it for this chapter. Let’s wrap this baby up and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, we’ve covered lots of ground in this chapter. I first gave you a
    basic explanation of Regular Expressions, regular expressions, `sed`, and `grep`.
    Then, I showed you how to use regular expressions with both `sed` and `grep`.
    I also showed you some cool tools that can help simplify the process of creating
    regular expressions. Finally, I showed you some real-live scenarios in which I
    actually used these concepts for my own scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be about functions. I’ll see you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following is the preferred method for using grep with extended
    syntax?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Egrep`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`egrep`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`grep -e`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`grep -E`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following are the two general types of characters that are used
    in regular expressions? (Choose two.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: digits
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: alphabetic
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: literals
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: numbers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: metacharacters
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When creating a regular expression, which of the following would you use as
    an `or` operator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`or`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-o`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-or`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`|`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`?`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three types of metacharaters in Regular Expressions? (Choose three.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Literals
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Positional anchors
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Character sets
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Modifiers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which option switch would you use with sed to save changes to the source file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-o`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-i`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-s`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-n`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regex Tutorial—How to write regular expressions?: [https://www.geeksforgeeks.org/write-regular-expressions/](https://www.geeksforgeeks.org/write-regular-expressions/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regular Expressions.info: [https://www.regular-expressions.info/](https://www.regular-expressions.info/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learn Regex: A Beginner’s Guide: [https://www.sitepoint.com/learn-regex/](https://www.sitepoint.com/learn-regex/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Practical Guide to Regular Expressions: [https://www.freecodecamp.org/news/practical-regex-guide-with-real-life-examples/](https://www.freecodecamp.org/news/practical-regex-guide-with-real-life-examples/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regex Cheat Sheet and Quick Reference: [https://quickref.me/regex.html](https://quickref.me/regex.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Use the sed Command on Linux: [https://www.howtogeek.com/666395/how-to-use-the-sed-command-on-linux/](https://www.howtogeek.com/666395/how-to-use-the-sed-command-on-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Use sed to Find and Replace String in Files: [https://linuxize.com/post/how-to-use-sed-to-find-and-replace-string-in-files/](https://linuxize.com/post/how-to-use-sed-to-find-and-replace-string-in-files/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Use the grep Command on Linux: [https://www.howtogeek.com/496056/how-to-use-the-grep-command-on-linux/](https://www.howtogeek.com/496056/how-to-use-the-grep-command-on-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to use the Linux grep command: [https://opensource.com/article/21/3/grep-cheat-sheet](https://opensource.com/article/21/3/grep-cheat-sheet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c and e
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b, d, and e
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Linux experts, and the author himself.
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10596186092701843.png)'
  prefs: []
  type: TYPE_IMG
- en: Leave a Review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoy it!
    Your feedback is invaluable and helps us improve and grow. Once you've completed
    reading it, please take a moment to leave an Amazon review; it will only take
    a minute, but it makes a big difference for readers like you.
  prefs: []
  type: TYPE_NORMAL
- en: Scan the QR code below to receive a free ebook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/review.png)'
  prefs: []
  type: TYPE_IMG
