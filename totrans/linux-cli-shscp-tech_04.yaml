- en: '*Chapter 4*: Using Shell to Configure and Troubleshoot a Network'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing processes is an important job of a Linux system administrator. That
    can be for a variety of reasons – maybe some processes got stuck and we need to
    finish them, or we want to put some process(es) to work in the background, or
    even to be started periodically or at a later date. Whatever the scenario is,
    it's important to know how to administer processes and make them do the work that
    needs to be done efficiently and with regards to other processes running on the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn about the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `nmcli` and `netplan`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `firewall-cmd` and `ufw`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with open ports and connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring `/etc/hosts` and DNS resolving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using network diagnostic tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For these recipes, we''re going to use two Linux machines. We can use the client1
    virtual machine from our previous recipes. We''ll also use another two virtual
    machines running `nmcli` and `firewall-cmd`). Let''s call them `server1` and client2\.
    All in all, we need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A virtual machine running Ubuntu 20.10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two virtual machines with CentOS 8 2105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's start our virtual machines and let's get cracking!
  prefs: []
  type: TYPE_NORMAL
- en: Using nmcli and netplan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network configuration has changed significantly in the past couple of releases
    – for all Linux distributions. It doesn't really matter whether we are discussing
    Red Hat and its clones or Debian and its clones – these changes happened across
    all of them. For example, Red Hat and its clones went from a network service to
    a mixture of network and NetworkManager services to a fully NetworkManager-based
    configuration. Ubuntu was using a networking service until recently when it switched
    to netplan. Let's explain all of these concepts so that we can have a full overview
    of these configuration methods and cover any situations you might end up in. We
    will also cover a scenario in which someone might want to turn off netplan and
    go back to using the networking service on Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just need one Ubuntu and one CentOS machine for this recipe. Let''s say
    we are going to use `server1` and client1 to master `nmcli` and `netplan`. Furthermore,
    on CentOS, we need to deploy the `net-tools` package to get access to some of
    the commands used in this recipe (for example, the `ifconfig` command). Let''s
    do that by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After that, we're ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first work with the two most common CentOS scenarios – implementing
    network configuration via `nmcli` for both `ens39` to create a network connection
    called `static` (for the static IP address, for example, `192.168.2.2/24` with
    gateway `192.168.2.254` and DNS servers `8.8.8.8` and `8.8.4.4`) and, later on,
    a network connection called `dynamic` (for DHCP configuration). We just need to
    run a few commands as root per scenario for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Adding a static IP configuration via nmcli'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.1_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Adding a static IP configuration via nmcli
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now remove that connection and define a DHCP-based configuration. For
    that, we need to have a DHCP server available on our network, so that it can assign
    the necessary network configuration information to client2 (IP address, netmask,
    gateway, DNS server addresses, and so on). We need to type in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Adding a DHCP configuration via nmcli'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.2_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Adding a DHCP configuration via nmcli
  prefs: []
  type: TYPE_NORMAL
- en: If everything is configured correctly on our network, we should've gotten an
    IP address and other networking information and have internet access.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of `netplan` on Ubuntu, this configuration method is more in line with
    the currently popular *infrastructure as code* paradigm, so it's all about configuration
    files. So, we will again implement two of the most common scenarios – a static
    IP address and DHCP, but we will also cover a scenario with multiple network interfaces
    so that we can see what the syntax looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s start with the `netplan` static networking configuration. Let''s
    say that we need to assign IP address `192.168.1.1/24` to network interface `ens33`,
    with the default gateway being `192.168.1.254` and DNS servers `8.8.8.8`, and
    `8.8.4.4`. We can just change the existing YAML configuration file that''s already
    there, called `00-installer-config.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Adding a static configuration via netplan'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.3_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Adding a static configuration via netplan
  prefs: []
  type: TYPE_NORMAL
- en: 'That covers our static IP address scenario. It''s relatively obvious what we
    need to do in terms of a `netplan` DHCP scenario, so the configuration file needs
    to look like this for that specific scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Adding a dynamic configuration via netplan'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.4_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Adding a dynamic configuration via netplan
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of our recipe, as we mentioned, is about having multiple network
    interfaces and configuring them properly. Let''s say that we have a network interface
    called `ens33` that needs to be DHCP-configured, and an interface called `ens38`
    that needs to be assigned an IP address, `192.168.1.1/24`, with the same config
    data for gateway and DNS servers as before. The configuration file would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Configuring multiple network interfaces via netplan'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.5_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Configuring multiple network interfaces via netplan
  prefs: []
  type: TYPE_NORMAL
- en: For some of the latest versions of Ubuntu, this `yes`/`no` configuration will
    be changed to `true`/`false`, so if you get an error here, you just need to make
    that change. Basically, it looks like a merge of the previous two files, with
    a couple of lines stripped so that we don't have unnecessary repetitions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see how these two concepts work. It's simple enough, but still, it
    requires a bit of background knowledge, so let's dive in.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've done a brief primer on how processes and signals work, let's
    continue our quest for knowledge about processes by learning about the management
    of background processes. As we've already explained the basics of background processes,
    that shouldn't be a difficult task.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of NetworkManager and its command-line configuration interface (`nmcli`),
    NetworkManager does its configuration via configuration files in the `/etc/sysconfig/network-scripts`
    directory. Let''s show an example from our previous CentOS session – where we
    created an interface called `dynamic`. In that directory, there''s a file called
    `ifcfg-dynamic`, with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Regular NetworkManager configuration file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.6_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Regular NetworkManager configuration file
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s quite a big configuration file for a simple configuration. Actually,
    if we were to polish this file a bit, we could make it at least two thirds shorter,
    and it would still work, for example, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Shortened configuration file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.7_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Shortened configuration file
  prefs: []
  type: TYPE_NORMAL
- en: These configuration options aren't all that difficult to understand, as well
    as some other configuration options that are needed for static IP configuration
    (`IPADDR`, `PREFIX` or `NETMASK`, `GATEWAY` – these are all pretty self-explanatory).
    But the fact remains that – at least in part – NetworkManager still uses this
    bulky syntax as a history leftover, as we've been using this `/etc/sysconfig/network-scripts`
    directory and files in that directory to configure network interfaces for years
    and years now.
  prefs: []
  type: TYPE_NORMAL
- en: When comparing that to netplan, we can clearly see that netplan puts much more
    importance on declarative syntax with all of the structured code and indentation
    that it needs to have, which is what YAML is known for. It will frustrate you
    at the beginning, at least until you learn how to use the vim editor for editing
    YAML files, as it then becomes much easier. Check out the link in the *There's
    more* section to learn how to set up vim to help you with YAML syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these services – when the system gets booted up – read the aforementioned
    configuration files and set the network interfaces in accordance to the settings
    in them. A pretty straightforward process, as long as we understand the syntax.
    But we'd still recommend using `nmcli` for NetworkManager configuration as its
    syntax gets under your fingers quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The next stop is firewalling, by using `firewalld` and `ufw`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need more information about networking in CentOS and Ubuntu, make sure
    that you check the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring and managing networking: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/configuring_and_managing_networking/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/configuring_and_managing_networking/index%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Netplan reference: [https://netplan.io/reference/](https://netplan.io/reference/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nmcli`: [https://developer-old.gnome.org/NetworkManager/stable/nmcli.html](https://developer-old.gnome.org/NetworkManager/stable/nmcli.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting up vim for YAML editing: [https://www.arthurkoziel.com/setting-up-vim-for-yaml/](https://www.arthurkoziel.com/setting-up-vim-for-yaml/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using firewall-cmd and ufw
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using built-in firewalls has been a de facto standard in Linux for more than
    two decades now. Ever since the *invention* of `ipfwadm` (kernel v2.0), Linux
    kernel developers have been piling up functionality and a firewall has been one
    of those things. `ipfwadm` was followed by `ipchains` (kernel v2.2), `iptables`
    (kernel v2.4), and today it's all about `firewalld` (CentOS) and `ufw` (Ubuntu).
    Let's go through both of these concepts so that we can use them when we need them
    regardless of the Linux distribution we're working on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a part of this recipe, we are going to go through a list of dozens of different
    scenarios covering `firewalld` and `ufw`. In other words, we are going to introduce
    the necessary commands to do configuration changes for some of the most commonly
    used scenarios. First, let''s install the necessary packages for CentOS (on our
    client2 machine) and Ubuntu (client1 machine). So, for CentOS, we need to type
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, use this command for Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of services, for CentOS, we have these – just in case we used `iptables`
    previously, as `iptables` firewall is supported in CentOS 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For Ubuntu, it''s the same idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that the services are configured, let's start!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For `firewalld`, we are going to use its default command, which is `firewall-cmd`.
    For `ufw`, the command has the same name – `ufw`. First, let''s take care of some
    basic commands. Let''s first list all the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on how many rules we added previously, we should get an output similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – firewall-cmd --list-all output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.8_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – firewall-cmd --list-all output
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add and delete a couple of rules. This is what we are going to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a rule that allows `192.168.2.254/24` to access everything on our `client2`
    machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a rule that allows network subnet `192.168.1.0/24` to access the `SSH` service
    on our `client2` machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block the `192.168.3.0/24` network from accessing HTTP/HTTPS services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the same subnet to access the DNS service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forward port `900` to port `9090`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure `masquerade` so that `client1` can be used as a router/gateway.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the last step, we are going to delete every single one of these rules, one
    by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re clear on what we are trying to do, let''s punch in all of the
    necessary commands to make this happen. First, let''s start by using the default
    configuration and default zone, which means that we need to check which zone it
    is. We can see in the previous screenshot that the public zone is active, so –
    for the time being – we are going to add all of the rules to that zone and explain
    zones and rich rules a bit later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Echo commands are used to enable IP forwarding right now (first echo), and
    to enable it permanently (second echo), by using a `sysctl` configuration file
    that''s going to be loaded as our system boots up. The last command is to apply
    these settings to the current running state of `firewalld`. When we now type in
    the `firewall-cmd --list-all` command, we should get output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – End result of our configuration in firewalld'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.9_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – End result of our configuration in firewalld
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s very important to learn how to remove these rules, as well. So, let''s
    now remove these rules, one by one, going in the opposite direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'That should remove all of the rules and apply the starting state as the current
    state. Let''s check:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – The firewalld rule set after rule removal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.10_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – The firewalld rule set after rule removal
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything is back to its original state, so we can call this a success. Let''s
    now apply the same ruleset to the Ubuntu virtual machine called client1 by using
    `ufw`. Let''s first check the status by using the `ufw status verbose` command.
    We should get a result like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – ufw configuration starting point'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.11_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – ufw configuration starting point
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add the same set of rules that we added in `firewalld`, to see how
    it''s done via `ufw` and to be able to check the syntax differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For port forwarding, we need to edit the `/etc/ufw/before.rules` file and add
    the following configuration options before the `*filter` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now check the status of our work by using the `ufw` and `iptables` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – ufw status verbose after all the added rules'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.12_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – ufw status verbose after all the added rules
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add two configuration options to `ufw` configuration for masquerading
    to work. First, we need to change the default policy for forwarding in the `/etc/default/ufw`
    file. It''s set to `DROP` by default. We just need to change it to `ACCEPT`. It''s
    at the beginning of this file, so the end result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is rather than looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next configuration option is actually in the same file that we previously
    edited, `/etc/ufw/before.rules`. We need to add one additional part to the `*nat`
    section called the `POSTROUTING` subsection, to the same place that we used before.
    So, similar to the previous example, we need to add the following configuration
    options, again before the `*filter` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the `ufw` configuration is making sure that the kernel knows
    that it needs to turn on `ip` forwarding. For that to happen, we need to edit
    a file called `/etc/ufw/sysctl.conf` and uncomment the following configuration
    option by removing the comment mark (`#`) before it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes a value in the `/proc` filesystem, in a file called `/proc/sys/net/ipv4/ip_forward`.
    If we want to make sure that it works even without rebooting the machine, we need
    to issue the following command, as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'That will enable IP forwarding on the kernel level and enable us to use masquerading
    in `ufw`. Let''s now check the end result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – ufw ruleset after configuring masquerading'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.13_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – ufw ruleset after configuring masquerading
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to remove any of these configuration options, it''s going to be
    done in two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration options that we added to files directly via the editor will need
    to be removed via the editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration options that we added by using the `ufw` command can be easily
    reversed by using ufw's rule indexing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s type in the command `ufw status numbered`. This is the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – ufw ruleset indexed by number'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.14_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – ufw ruleset indexed by number
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that every rule that we punched in has a number attached to it.
    Rules 8 and 9 are rules for ports `900` and `9090` that were automatically added
    for the IPv4 and IPv6 stack. We can remove all of these rules easily by using
    the numbers attached to them. The thing is, `ufw` doesn''t have a mechanism for
    deleting multiple rules one by one, so we would need to delete them one by one,
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, we could''ve simplified this with a `for` loop, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: But shell scripting and using loops is yet to come in this book so... let's
    treat this as an *example in advance*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now explain how all of this works – firewalld zones, rich rules, `ufw`
    syntax – so that we can get an understanding of the background services and capabilities
    making it happen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`Firewalld` is available on Ubuntu, as well. It just needs to be installed,
    enabled, started, and configured, and the opposite needs to be done to `ufw`.
    If you''re more prone to using `firewalld`, we suggest that you try doing that
    as it''s easy and won''t take much of your time.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a fundamental difference between `ufw` and `firewalld`, with `ufw` basically
    being just a frontend to `iptables`, while `firewalld` is much more dynamic, having
    the capability to work with zones to which we can assign various trust levels.
    The syntax is also different, `ufw` being a bit more namespace-based while `firewalld`
    requires a bit more effort in terms of rule typing. But, at the same time, `firewalld`
    has a D-Bus interface, which makes configuration easier in terms of applications,
    services, and users making configuration changes, on top of the fact that we don't
    have to restart the firewall for every change to take effect. It also interacts
    well with NetworkManager and `nmcli`, `libvirt`, Docker, and Podman, and other
    utilities such as fail2ban (although fail2ban works with `iptables` just as well).
    Sometimes it's a matter of preference; sometimes it's habits. Generally speaking,
    if you're more of an Ubuntu/Debian user, you're probably going to be more inclined
    to use `ufw`. By the same token, if you're more of a CentOS/Red Hat/Fedora/*SuSe
    user, you'll definitely be more inclined to use `firewalld`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firewalld''s concept of using zones, to which we can assign network interfaces
    or IP addresses, is certainly useful, as it gives us much more freedom in terms
    of configuration. If we type in the `firewall-cmd --get-zones command`, we''ll
    see the list of available zones at that point in time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Default firewalld zones'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.15_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – Default firewalld zones
  prefs: []
  type: TYPE_NORMAL
- en: By default, `firewalld` is configured in the *deny everything, add exceptions*
    manner, again, for ease of use. We can use it to allow or deny connections based
    on ports, IP addresses, subnets, and services, which enables us to do everything
    we need to do, in terms of host-based firewall functionality. It also has a concept
    called rich rules (as shown in our examples in this recipe), that enables us to
    create complex rules with intricate levels of granularity. These rules can be
    based on source address, destination address, ports, protocols, services, port
    forwarding, and masquerade per subnet. They can be used for rate limiting, which
    allows us to set the number of accepted SSH connections to 5 or 10 per minute
    to make it much harder to do SSH brute force attacks on our Linux servers. All
    in all, it's a very well-thought-out and feature-rich firewall that's free for
    us to use. We just need to configure it.
  prefs: []
  type: TYPE_NORMAL
- en: '`ufw`, being just a frontend of `iptables` – or, as people usually describe
    it, a command-line interface for `iptables` – is less feature-packed, but is definitely
    easier to configure, at least for the most commonly used scenarios. Its command-line
    interface is more human-readable (less complex) and easier to learn. Seeing that
    it''s just a frontend for `iptables`, it''s basically a user-space utility that
    manages Linux kernel filtering rules provided by the netfilter module stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed some key concepts in Linux firewalling, it's time
    to move on to our next recipe, which is about checking open ports and connections.
    Let's see what that's all about.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to learn more about `firewalld` and `ufw`, we recommend the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`firewall-cmd`: [https://firewalld.org/documentation/man-pages/firewall-cmd.html](https://firewalld.org/documentation/man-pages/firewall-cmd.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A beginner''s guide to `firewalld` in Linux: [https://www.redhat.com/sysadmin/beginners-guide-firewalld](https://www.redhat.com/sysadmin/beginners-guide-firewalld%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firewalld` rich language: [https://firewalld.org/documentation/man-pages/firewalld.richlanguage.html](https://firewalld.org/documentation/man-pages/firewalld.richlanguage.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ufw`: [https://help.ubuntu.com/community/UFW](https://help.ubuntu.com/community/UFW%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with open ports and connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checking open ports on our local and/or remote machine is often part of security
    and configuration auditing processes. It's something that we use to check if we
    can connect to some remote ports to verify that a service works, whether a firewall
    is configured properly, or whether routing works – just regular, everyday tasks.
    Of course, it can also be a part of some hacking processes, which often start
    by using `nmap` and similar utilities to check for open ports and OS fingerprints.
    But, let's check how we can use utilities such as `netstat`, `lsof`, `ss`, and
    `nmap` to do good for our network and security.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Keep the client1 virtual machine powered on and let''s continue using our shell.
    Generally speaking, if we''re doing this on Ubuntu, we need to install some packages
    such as `traceroute` and `nmap` using `apt-get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If, however, we are using CentOS, we need to use `yum` or `dnf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After that, we are ready for our recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first learn the usual ways of checking which ports and sockets are opened
    on our local Linux machine, starting with the `netstat` command. Yes, it''s a
    common thing to check the routing table with `netstat` (the `netstat -rn` command),
    but we can also learn many more interesting details about our local Linux machine
    by using it in a different way. First, let''s check all opened connections and
    ports by using the `netstat -a` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – A part of the netstat -a output – the result is much longer
    so we stripped it a bit for formatting reasons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.16_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 – A part of the netstat -a output – the result is much longer so
    we stripped it a bit for formatting reasons
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of details are here. Let''s see if we can format that a bit better. First,
    let''s show all opened TCP ports by using the `netstat -atp` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – netstat with the TCP port list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.17_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.17 – netstat with the TCP port list
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let''s show the same thing, but for opened UDP ports, by using the `netstat
    -aup` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – netstat with the UDP port list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.18_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.18 – netstat with the UDP port list
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also show a subset of the information above in terms of listening ports
    (a port that an application or process is listening on). That''s what the `netstat
    -l` command is all about:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Checking listening ports via netstat'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.19_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.19 – Checking listening ports via netstat
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do similar things with `ss` and `lsof`. Let''s first use `ss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Checking active connections via ss'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.20_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.20 – Checking active connections via ss
  prefs: []
  type: TYPE_NORMAL
- en: 'Next on our list is `lsof`, a command that can be used to determine which files
    are being opened by their corresponding processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21 – The same idea as ss, but with more details about actual commands/services
    using ports'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.21_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.21 – The same idea as ss, but with more details about actual commands/services
    using ports
  prefs: []
  type: TYPE_NORMAL
- en: 'The options that we used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-n` for using port numbers, not port names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-P` for using numerical addresses, without DNS resolving'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-iTCP` `-sTCP:LISTEN` to show only files that have an opened port in the TCP
    state `LISTEN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, if we wanted to narrow that down to a specific TCP port – for example,
    port `22` – we could use a command such as `lsof -nP -iTCP:22 -sTCP:LISTEN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – Narrowing the lsof output to TCP port 22 only'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.22_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.22 – Narrowing the lsof output to TCP port 22 only
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to check opened ports specified by port range, `lsof` allows that,
    by using the `lsof -i` option. For example, let''s use that on port range `22`
    to `1000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23 – lsof by port range'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.23_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.23 – lsof by port range
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've used some commands on our local machine, let's turn our attention
    to remote machines and discuss how to find open ports on them, as well as other
    information that might be necessary. For that, we are going to use the `nmap`
    command. Let's first use client1 (IP address `192.168.1.1`) to scan `server1`
    (IP address `192.168.1.254`). `server1` is just a vanilla CentOS 8 installation,
    as explained in the last recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s do a general scan, by using the `nmap 192.168.1.254` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24 – Using nmap on a single IP address'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.24_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.24 – Using nmap on a single IP address
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted a bit more verbosity, we could''ve added the `-v` option before
    or after the IP address, as well. Still, we can see that the remote IP address
    has a couple of open TCP ports. Let''s try to find some more information, by initiating
    `nmap` with the `-A` option (OS information scan):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25 – More detailed version of the previous nmap session'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.25_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.25 – More detailed version of the previous nmap session
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see even more details on this output. If we just wanted to do OS fingerprinting,
    we could''ve used the `-O` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.26 – nmap OS fingerprinting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.26_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.26 – nmap OS fingerprinting
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also scan for various other things, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Specific TCP ports – `nmap -p T:9090,22 192.168.1.254`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific UDP ports – `nmap -sU 53 192.168.1.254`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scan port range – `nmap -p 22-2000 192.168.1.254`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find remote host service versions – `nmap -sV 192.168.1.254`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scan a subnet – `nmap 192.168.1.*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scan multiple hosts – `nmap 192.168.1.252,253,254`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scan a complete IP range – `nmap 192.168.1.1-254`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now discuss how these four utilities work and wrap this recipe up.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`netstat`, `ss`, and `lsof` are kind of similar, yet have their differences.
    The usual way in which people use `netstat` is just to check their routing table.
    But, having said that, by default, `netstat` is a tool that gives us a list of
    opened TCP sockets/UDP connections on the network layer. `lsof`, on the other
    hand, lists open files (kernel-level functionality), but it''s also capable of
    determining which processes are using those opened files. Keep in mind that, in
    Unix operating systems, almost everything is a file, which also includes objects
    such as network sockets. As such, `lsof` is often used when dealing with security
    aspects of our Linux systems, as it obviously gives many more technical details
    when compared to `netstat`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ss`, as an alternative to `netstat`, can be used to work with network information
    and statistics, which makes it kind of similar to `netstat`. It can be used to
    get details about network connections, sockets, statistical data, TCP state filtering,
    connections to and from specific IP addresses, and so on. And, not to be forgotten,
    `ss` is quite a bit simpler to use, and when you compare man page sizes of `netstat`
    and `ss`, you''ll see the difference there as well.'
  prefs: []
  type: TYPE_NORMAL
- en: '`nmap`, on the other hand, is completely different from all of these commands.
    It''s a tool that''s aimed much more broadly in terms of functionality – it can
    scan both local and remote hosts, domains, IP ranges, and ports. It''s a regular
    network scanner, with all the good and the bad that comes with it, as people both
    love and dislike it – love using it, dislike being the target of it. It works
    by establishing connections to remote IP addresses and ports, sending them information
    and gathering output from them to get information. Therefore, it''s a perfect
    tool to do security scanning and auditing as it''s able to find open ports and
    report the fact that there are open ports. It''s also heavily used to search for
    certain security issues.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to learn more about `netstat`, `lsof`, `ss`, and `nmap`, make sure
    that you check the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nmap` documentation: [https://nmap.org/docs.html](https://nmap.org/docs.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`netstat` man page: [https://man7.org/linux/man-pages/man8/netstat.8.html](https://man7.org/linux/man-pages/man8/netstat.8.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lsof` man page: [https://man7.org/linux/man-pages/man8/lsof.8.html](https://man7.org/linux/man-pages/man8/lsof.8.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ss` man page: [https://man7.org/linux/man-pages/man8/ss.8.html](https://man7.org/linux/man-pages/man8/ss.8.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring /etc/hosts and DNS resolving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name resolution is an essential part of any operating system, specifically its
    networking stack. Generally speaking, operating systems have multiple different
    ways of making DNS queries – usually, it involves some kind of `hosts` file, caches,
    and – of course – network interface configuration. Let's go through the configuration
    capabilities of `/etc/hosts` and see how that fits in the grand scheme of name
    resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep the CLI1 virtual machine powered on and let's discuss how to work with
    name resolution in general, using `/etc/hosts` (a file that we can fill with hostnames
    and IP addresses for local resolving) and `/etc/resolv.conf` (a file that determines
    which DNS servers are being used for network resolving, and which domain is the
    Linux server a part of) as integral parts of that process. When editing `/etc/hosts`
    or `/etc/resolv.conf`, we have to be logged in as root or use `sudo`, as this
    is a system-wide operation that's only allowed to administrative users. The way
    in which the name resolution process works changed years ago as `systemd` took
    over from `init` and `upstart`, and introduced a service called `systemd-resolved`.
    On top of this, the configuration is different on Ubuntu when compared to CentOS.
    So, let's dig into all of that and explain what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first take care of Ubuntu, then we''ll switch to CentOS. This is the
    default `/etc/resolv.conf` file from our Ubuntu CLI1 machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.27 – Default /etc/resolv.conf file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.27_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.27 – Default /etc/resolv.conf file
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, this file is mostly commented out (the `#` sign in config files
    equals a Unix shell-style comment, so these lines are omitted in terms of configuration).
    We only have two configuration lines, which are a by-product of running the systemd-resolved
    service (a local service that provides resolving capabilities for DNS, DNS over
    TLS, DNSSEC, mDNS, and so on), as well as using the netplan service by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two approaches to `resolv.conf` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: We say that we want to stick with systemd-resolved and configure our system
    that way (and `127.0.0.53` is actually the loopback IP address that systemd-resolved
    binds to).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We say that we don't want systemd-resolved and we want to go back to the *old
    way* of configuring our system, which means installing a package called `resolvconf`.
    That will give us the capability to configure `/etc/resolv.conf` and `/etc/hosts`
    as they were always configured and not rely on systemd-resolved making changes
    to `/etc/resolv.conf` on the fly (most of us usually don't want this).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the first approach and then move to the second approach as
    a lot of us Linux administrators are more prone to using our old-school ways and
    we find it easier for things to be configured the way they have always been configured
    since the dawn of Unix time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are using systemd-resolved, we need to mention a couple of files. The
    first file that we need to mention is `/run/systemd/resolve/stub-resolv.conf`
    – this is a file that''s actually linked to `/etc/resolv.conf` when systemd-resolved
    is being used. This file is used for maintaining compatibility with old Linux
    programs that were exclusively using the old way (`/etc/resolv.conf`, `/etc/hosts`)
    to get access to name resolution information. If we want to permanently set DNS
    servers to be used, we need to do it via `systemd`. So, let''s go to the second
    file that we need to discuss. It''s located in the `/etc/systemd` directory, and
    it''s called `resolved.conf`. At the beginning of this file, there''s a `[Resolve]`
    section that''s completely commented out. Let''s change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first and second lines set the main and fallback DNS addresses, while the
    third line sets the default domain that we're querying.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we do this change, we need to restart the `systemd-resolved` service,
    which we can do with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check if our changes have been applied by using `systemd-resolve --status`,
    which should, in accordance with our changes, give us output similar to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.28 – Checking the systemd-resolved status'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.28_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.28 – Checking the systemd-resolved status
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now check how the DNS cache works – for example, we type in the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We did this so that we can check the DNS cache, as the DNS cache first needs
    to be filled with some data at least. If we want to check the state of the `systemd-resolved`
    cache, we can do it with two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command doesn''t kill `systemd-resolved` but tells it to write available
    entries in the DNS cache. The second command exports entries to a file called
    `cache.txt` (it can be called whatever we want). When we check the content of
    that file for the string `CACHE`, we''re going to see entries similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.29 – Checking the DNS cache'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.29_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.29 – Checking the DNS cache
  prefs: []
  type: TYPE_NORMAL
- en: 'This is correct – on our testing system, those are two entries that we searched
    for by using `nslookup`. If we want to flush the DNS cache, we can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you notice errors with DNS violations in the file, there was a problem during
    the system installation or upgrade – one that didn''t set a symbolic link to `resolv.conf`
    properly. As a result of that problem, the symbolic link was created to the wrong
    file (`stub-resolv.conf`) instead of the actual file `(/run/systemd/resolve/resolv.conf`).
    We can mitigate that issue by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try the second approach, which is quite a bit more simple. So,
    if we wanted to get rid of all of this `systemd-resolved` configuration and just
    use a good old administration process via `resolv.conf` without all of this additional
    hassle, we could do that easily. So, let''s first install the necessary package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s do a bit of configuration. Let''s open the `/etc/resolv.conf`
    file and make it look like this (the commented part is not important, start with
    the `nameserver` part):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.30 – The resolv.conf configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.30_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.30 – The resolv.conf configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check if this configuration works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.31 – Checking if DNS resolution works'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.31_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.31 – Checking if DNS resolution works
  prefs: []
  type: TYPE_NORMAL
- en: No problem whatsoever, right? Of course, we used `8.8.8.8`, `8.8.4.4`, and `1.1.1.1`
    as examples for DNS servers here – this needs to be configured so that it's valid
    for the environment where our Linux server is actually running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with the DNS cache requires a bit of extra effort. First, we need to
    deploy two additional packages – `nscd` (the service that does the caching), and
    `binutils` (this package contains a command called `strings`, which we''ll use
    to check string content in a binary file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the second command should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.32 – Checking the nscd cache'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.32_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.32 – Checking the nscd cache
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to clear the `nscd` `hosts` cache, we can use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first one just clears the hosts table, while the second one restarts the
    `nscd` service and, as a part of the process, clears the `hosts` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that brings us to the hosts table, and – luckily – it works the same on
    all Linux distributions. If we''re in a situation where we just need to add some
    resolving capabilities without actually building up a DNS server via `BIND`, `dnsmasq`,
    or anything similar to that, using the `hosts` table seems like a reasonably simple
    thing to do. Let''s say that we need to use temporary resolution for the following
    two hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`server1.domain.local`'
  prefs: []
  type: TYPE_NORMAL
- en: '`server2.domain.local`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that these two servers'' IP addresses are `192.168.0.101` and
    `192.168.0.102`. We''d add these entries to the `/etc/hosts` file by editing it
    and adding these entries to the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`192.168.0.101 server1.domain.local`'
  prefs: []
  type: TYPE_NORMAL
- en: '`192.168.0.102 server2.domain.local`'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our `/etc/hosts` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.33 – /etc/hosts file with additions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.33_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.33 – /etc/hosts file with additions
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now use a command such as `ping` to check if these hosts are alive, we
    will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.34 – ping not working'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.34_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.34 – ping not working
  prefs: []
  type: TYPE_NORMAL
- en: The `^C` character visible in this output is due to the fact that we used *Ctrl*
    + *C* to stop the ping process as these hosts don't actually exist on our network.
    But that's beside the point – the point of this was to test whether the name resolution
    works. In other words, does `server1` and `server2.domain.local` resolution work?
    And it does – we can clearly see that the `ping` command is trying to ping their
    IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: We need to briefly discuss the way in which CentOS does these things, as it's
    a bit different from what Ubuntu does. By default, the latest couple of generations
    of CentOS use NetworkManager as the default service to configure a network. As
    a result, `/etc/resolv.conf` gets configured by NetworkManager by default, which
    is very important to note, especially in the most common use case – when our CentOS
    machine gets its IP address from the DHCP server. What happens if we need to configure
    custom DNS servers and we don't want to use the DNS servers that we got from our
    DHCP server?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic ways to make sure that everything''s configured correctly
    in CentOS:'
  prefs: []
  type: TYPE_NORMAL
- en: To configure everything via interface files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To configure everything after the fact, by using the `nmcli` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using configuration files is a hassle here, so let''s just do the second thing
    – configure our DNS entries by using the `nmcli` command. Let''s say that we want
    to assign `8.8.8.8`, `8.8.4.4`, and `1.1.1.1` as DNS servers for our CentOS server.
    Let''s check our network interface name first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Our system tells us that it''s using the `ens33` network interface. Let''s
    modify its settings by typing in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The key aspect of this configuration is the first line – we're basically telling
    NetworkManager to quit automatically using the DNS server that it gets from the
    DHCP server. If we didn't want that, we could've just omitted that specific line.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we check the contents of our `/etc/resolv.conf` file, it should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.35 – /etc/resolv.conf configured correctly'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.35_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.35 – /etc/resolv.conf configured correctly
  prefs: []
  type: TYPE_NORMAL
- en: And that's a wrap in terms of configuration – using both Ubuntu and CentOS.
    Let's now focus on how all of this works *under the hood*.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two concepts that we need to dig into and explain. We need to understand
    how `systemd-resolved` works, and, of course, the opposite – how everything works
    when we remove `systemd-resolved` from the administrative equation, if you will.
    Having in mind that there was Linux before systemd and name resolution before
    `systemd-resolved`, let's start by explaining how the *old method* (pre-systemd-resolved)
    worked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core concept was called the `/etc/passwd`, `/etc/shadow`, and `/etc/group`),
    network configuration, and, of course, services such as name resolution (`/etc/hosts`
    and so on). Our focus will be solely on name resolution, which is why we need
    to discuss a configuration file, `/etc/nsswitch.conf`. Specifically, we will ignore
    all of the configuration options in that file and focus on one configuration line,
    which is usually similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This configuration line tells our name resolution system *how* to do its job.
    The `files` option means *check file /etc/hosts*, while the `dns` option means
    just that – use other network name resolution methods. But the important thing
    about this line is the *order*, which clearly states *files first, dns second*.
    This is the reason why – by default – Linux first checks the contents of the `/etc/hosts`
    file, and then starts issuing network name resolution calls (for example, `nslookup`)
    to get to the IP address of some server that we're trying to communicate with.
    We also have capabilities to store these entries in a database, and we can force
    NSS to access it to read the necessary data. For example, 20 years ago, when Active
    Directory and other LDAP-based directories weren't used so often, we used to use
    NIS/NIS+ a lot – to store user and similar data. We were also able to store host
    data in NIS/NIS+ databases (`hosts.byname` and `hosts.byaddr`). These maps were
    basically forward and reverse DNS tables, stored within an external service. That's
    why we can use the configuration option `db` in `nsswitch.conf`, although pretty
    much nobody uses that nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: When systemd took over name resolution (`systemd-resolved`), things changed,
    as we described in our last recipe. The whole point of `systemd-resolved` is to
    be able to better integrate with systemd and to offer support for some use cases
    that were – realistically – complicated without it. Stuff such as VPN connections,
    especially corporate ones, were a constant source of problems when using the old-style
    configuration. `systemd-resolved` tries to get around that stack of problems (and
    others) by introducing the capability to do split DNS, which is implemented by
    using DNS routing domains as a way of determining which DNS requests we're actually
    making. Please don't mistake this for IP-based ideas of subnet routing, VLAN routing,
    or anything of the sort – those are completely different concepts, based on completely
    different ideas. We're specifically talking about the DNS routing domain, which
    is nothing more than a term saying *let's determine which DNS server should be
    contacted for correct information about your DNS query*. This has nothing to do
    with the IP aspect of it, which is handled by using standard routing methods.
  prefs: []
  type: TYPE_NORMAL
- en: Having split DNS is nothing new – it's something that a lot of us have been
    using for a decade or two. In short, split DNS means having some DNS servers assigned
    to internal connections and other DNS servers assigned to external connections.
    From an enterprise standpoint, if we connect via VPN connection to our workplace,
    a part of our DNS queries is aimed at internal infrastructure, while the other
    part should be headed to the external DNS servers hosted on the internet. Being
    able to implement this scenario in Linux also isn't something new – we could've
    easily done this with `BIND` more than a decade ago. But a way to do this as tightly
    integrated and as automatically as possible, especially on the client side – which
    is what `systemd-resolved` does – is actually something new.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine for a second that we have a Linux VPN server that we're connecting
    to by using a Linux machine as a VPN client. Let's say that these two systems
    both have multiple network interfaces in different subnets (a couple of physical
    network cards and a wireless network adapter for the VPN client). When we connect
    from our VPN client to the VPN server, how is the VPN client going to determine
    where to send DNS queries? Yes, it's going to use `resolv.conf`, but still, `resolv.conf`
    and `systemd-resolved` need to be configured correctly so that a name resolution
    request gets sent to the correct DNS server. If we have multiple subnets, and
    multiple domains (a larger enterprise, for example), things can get messy very
    quickly. This situation gets taken care of via NetworkManager/netplan's interaction
    with `systemd-resolved`. By using this interaction, we can have different DNS
    servers assigned to different network interfaces, that are assigned to multiple
    different domains. And that's a pretty smart way of dealing with potential VPN
    client problems.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we need to learn more about network name resolution, we can check the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'What is DNS?: [https://www.cloudflare.com/learning/dns/what-is-dns/](https://www.cloudflare.com/learning/dns/what-is-dns/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is DNS?: [https://aws.amazon.com/route53/what-is-dns/](https://aws.amazon.com/route53/what-is-dns/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NSCD man page, chapter 8: [https://linux.die.net/man/8/nscd](https://linux.die.net/man/8/nscd%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`systemd-resolved` man page: [http://manpages.ubuntu.com/manpages/bionic/man8/systemd-resolved.service.8.html](http://manpages.ubuntu.com/manpages/bionic/man8/systemd-resolved.service.8.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resolved.conf` man page: [https://www.freedesktop.org/software/systemd/man/resolved.conf.html](https://www.freedesktop.org/software/systemd/man/resolved.conf.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using network diagnostic tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Diagnosing problems with network connections is an everyday job for a seasoned
    system engineer. It doesn't necessarily happen because we have problems in our
    own network, it can be other factors. For example, sometimes our local network
    works, while the internet connection doesn't. Or, even worse, customers report
    that some of them are able to access the internet, while some others can't. How
    do we approach these situations and which tools should we use? That's what we
    will talk about in this recipe. So, get ready to talk about `ping`, `route`, `netstat`,
    `tracepath`, and similar commands – that's what they're there for!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's install a CentOS virtual machine called `server1` and use our existing
    clients (an Ubuntu virtual machine called client1 and a CentOS virtual machine
    called client2) to work on this recipe. We are going to use client1 to simulate
    a situation where the server on our local network wants to access internal resources
    and/or the internet by using `server1` as a default gateway. We are going to use
    client2 to simulate a situation where our local client or wireless client wants
    to access internal resources and/or the internet by using `server1` as a default
    gateway. In order for us to be able to do that, we'll temporarily add another
    network interface to client2, so that we can have two network interfaces in two
    different subnets to simulate problems in our scenario. The `server1` virtual
    machine is just going to be a standard CentOS installation, but with four network
    interfaces. In our scenario, `server1`'s `ens33` network interface is going to
    be an external network interface, while network interfaces `ens37`, `ens38`, and
    `ens39` are going to be internal network interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a scenario here so that we can go through the whole process.
    For example, our colleagues from the company that we work for are reporting that
    they have problems accessing both internal resources (the company network) and
    external resources (the internet). The company that we''re discussing has multiple
    network subnets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`192.168.1.0/24` – This one is used for all of the server machines; we''ll
    call this connection profile `network1` when we configure it via `nmcli`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.2.0/24` – This one is used for all of the client machines; we''ll
    call this connection profile `network2` when we configure it via `nmcli`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.3.0/24` – This one is used for company wireless; we''ll call this
    connection profile `network3` when we configure it via `nmcli`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth network interface of our machine is going to act as our internet
    connection. As we mentioned in our second recipe in this chapter (*Using firewalld
    and ufw*), let's configure that virtual machine so that it allows connectivity
    for all three of these subnets to the internet and work from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step will obviously be to allow internet access for these three subnets.
    Let''s do that in the simplest fashion, by using `firewalld`. Specifically, we''ll
    do that by adding these interfaces to the public zone. So, we need a couple of
    standard commands and configuration steps on `server1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If our configuration is correct, when we type in the `nmcli con show` command,
    we should have something like this (depending on how we configured our external
    network on `ens33` – and in our virtual machine, it''s using the `192.168.159.0/24`
    network):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.36 – Checking our NM connection setup'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.36_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.36 – Checking our NM connection setup
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, if we check routing information by using the `ip route` command, we should
    get something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.37 – Checking our routes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.37_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.37 – Checking our routes
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have our three subnets, the routes are configured accordingly, now we
    need to configure `server1` to act as a router. Let''s type in the following commands
    to set our interfaces to specific zones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When we type in the last command, we should get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.38 – The firewall-cmd --list-all output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.38_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.38 – The firewall-cmd --list-all output
  prefs: []
  type: TYPE_NORMAL
- en: 'On client1, we need to do a bit of reconfiguration as well, as it was initially
    set up to use DHCP to get the IP address. First, let''s install the `traceroute`
    package by typing in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, let''s configure this Linux virtual machine so that its IP address
    is `192.168.1.1/24` and apply that configuration. First, we need to edit netplan''s
    configuration file. For simplicity reasons, let''s just use the default configuration
    file, `/etc/netplan/00-installer-config.yaml`. It needs to have the following
    content applied via the `netplan apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '``'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.39 – The netplan configuration file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.39_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.39 – The netplan configuration file
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now test if internet access from this machine works. As noted on the
    screenshot shown previously, we''re using `server1` as the default gateway (`192.168.1.254`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.40 – Checking the configuration works'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.40_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.40 – Checking the configuration works
  prefs: []
  type: TYPE_NORMAL
- en: 'So, connectivity works. Let''s now configure client2\. Our CentOS virtual machine
    called `client2` has a network interface called `ens39`. Let''s set it up so that
    it''s a part of the `network2` subnet (we defined that subnet on `server1`). Let''s
    say client2 is going to temporarily use `192.168.2.2/24` as its IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We previously configured `server1` to act as a default gateway, and, as a result,
    `client1` and `client2` can happily use it as a default gateway and access the
    external network. We can easily test that by using `ping`. Let''s use `client2`
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.41 – Checking the configuration works after configuration changes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.41_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.41 – Checking the configuration works after configuration changes
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have verified that everything is configured correctly, let''s now
    check a few different scenarios that might require additional network troubleshooting:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ping` to an external host is not working, but external network access works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External network access is not working.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can't route between two subnets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name resolution not working properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the first scenario. Usually, this is a firewall configuration
    setting (we''re not calling it a problem on purpose). Let''s first ping a site
    that we want to access:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.42 – Scenario start – ping doesn''t work'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.42_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.42 – Scenario start – ping doesn't work
  prefs: []
  type: TYPE_NORMAL
- en: 'At the same time, if we try to browse `packtpub.com` from our web browser,
    that works without any problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.43 – It works in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.43_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.43 – It works in the browser
  prefs: []
  type: TYPE_NORMAL
- en: This type of problem is common – and from the output of `ping`, we can see that
    the firewall that we're passing on the way from our client2 to `packtpub.com`
    is filtering `ping` (**ICMP**, or **Internet Control Message Protocol**) traffic.
    This is nothing to be worried about, although it might be confusing. We need to
    keep in mind that ping/ICMP traffic has nothing to do with HTTP(S)/TCP traffic
    and that these protocols can be filtered separately. This is exactly what was
    done here – ping/ICMP traffic was filtered, while HTTP(S)/TCP traffic wasn't.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s pile up additional complexity now and go through a scenario where external
    network access isn''t available. Let''s try pinging one of Google''s DNSes from
    client2 and `server1`, just to see the symptoms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.44 – External network access doesn''t work'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.44_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.44 – External network access doesn't work
  prefs: []
  type: TYPE_NORMAL
- en: It's one thing if the network client (client2) can't get to the external network.
    It's a completely different thing if the default gateway (in our case, `server1`)
    can't get to the external network. That points to a bigger problem, and if we
    didn't touch the firewall configuration and other network devices, it's probably
    some kind of a problem either with connectivity to the **Internet Service Provider**
    (**ISP**), or something on the ISP's end.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could do a bit more detective work by using additional tools, such as **traceroute**
    or **tracepath**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.45 – Further verification that external network access doesn''t
    work'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.45_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.45 – Further verification that external network access doesn't work
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are using external DNS servers, we could even use the `nslookup`, `host`,
    or `dig` commands to almost conclusively determine that the problem lies with
    internet access, not our client or server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.46 – resolv.conf is configured correctly; DNS name resolution doesn''t
    work'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.46_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.46 – resolv.conf is configured correctly; DNS name resolution doesn't
    work
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that the problem was that a cable connecting from our `server1`
    to the ISP router broke down. When we change that cable, `ping` should work perfectly,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.47 – The connection works again'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.47_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.47 – The connection works again
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now check a scenario where we can''t go from one subnet to another subnet.
    We''re going to use network1 and network2 as an example – so, we''re going to
    use client2 (`192.168.2.2/24`) to try to access client1 (`192.168.1.1/24`). As
    these two hosts are *not* a part of the same Layer 2 network, we have to have
    some kind of mechanism to *route* traffic between them. Let''s check if that routing
    configuration works properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.48 – Routing across subnets working'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.48_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.48 – Routing across subnets working
  prefs: []
  type: TYPE_NORMAL
- en: 'As previously configured, we allowed the forwarding of traffic between all
    of the networks on `server1`. We achieved that by allowing masquerading and putting
    all interfaces in the public `firewalld` zone. Sometimes when we configure our
    routing devices, we make mistakes. The results of our mistakes might be that two
    networks can''t communicate with each other anymore (usually two VLANs, as we
    are discussing an internal networking scenario here). Let''s see the symptoms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.49 – Routing doesn''t work anymore'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.49_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.49 – Routing doesn't work anymore
  prefs: []
  type: TYPE_NORMAL
- en: 'If we check our routing table by using the `netstat -rn` command, we can see
    the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.50 – Checking that routing on our Linux machine is set up properly,
    which it is'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.50_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.50 – Checking that routing on our Linux machine is set up properly,
    which it is
  prefs: []
  type: TYPE_NORMAL
- en: So, our gateway works (we can ping it), but it doesn't forward us correctly
    to the `192.168.1.0/24` network. Seeing that we configured the `192.168.1.0/24`
    network to be a local network for `server1`, it's clear that we have some kind
    of routing problem here. It could be a `firewalld` misconfiguration, stopping
    `firewalld` as a service, a routing table misconfiguration, or maybe someone played
    with the `/proc` filesystem and set the `ip_forward` flag back to `0`. Whatever
    the case may be, the source of our problem is our default gateway. In larger enterprises,
    we usually have a networking team taking care of these things, so showing them
    output from `ping`, `traceroute`, and `netstat` should tell them where the problem
    is (in their own backyard). We'd usually tell them that they have a VLAN routing
    problem between VLAN X (subnet 1) and VLAN Y (subnet 2), send them outputs of
    these previously mentioned commands, and let them work from there.
  prefs: []
  type: TYPE_NORMAL
- en: Let's finish this recipe by talking about a few name resolution issues. These
    issues can happen because of a service misconfiguration (`systemd-resolved`, for
    example), a wrong `/etc/resolv.conf` configuration, and even an `/etc/hosts` configuration
    that we did ourselves. Let's go through a couple of common problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to edit `/etc/resolv.conf` on client1 and put some custom
    DNS servers there. Then, we are going to reboot our client1 Linux virtual machine
    and see what happens when we check the content of `/etc/resolv.conf`. This screenshot
    is pre-reboot (we added two name servers, `8.8.8.8` and `8.8.4.4`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.51 – Editing /etc/resolv.conf manually'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.51_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.51 – Editing /etc/resolv.conf manually
  prefs: []
  type: TYPE_NORMAL
- en: 'This next screenshot was taken post-reboot. We can clearly see that the content
    of this file has been changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.52 – /etc/resolv.conf after reboot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.52_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.52 – /etc/resolv.conf after reboot
  prefs: []
  type: TYPE_NORMAL
- en: This was to be expected – as we described in our previous recipe, changing `/etc/resolv.conf`
    on a Linux machine that's running `systemd-resolved` is always going to end like
    this. If we want to change DNS settings, we need to do it properly. That means
    using `nmcli` in CentOS and, in this case, using netplan configuration on Ubuntu.
    This might only be a *local* issue, but it can still have a big impact in various
    scenarios where `split-dns` is involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next problem is going to be about the opposite – let''s say that we installed
    the `resolvconf` package on our Ubuntu machine, disabled `systemd-resolved`, and
    configured `/etc/resolv.conf` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.53 – Putting a wrong config option in /etc/resolv.conf'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.53_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.53 – Putting a wrong config option in /etc/resolv.conf
  prefs: []
  type: TYPE_NORMAL
- en: 'And when we try to resolve something by using the `nslookup`, `host`, or `dig`
    commands, it ends up nowhere, although our internet connection works, as shown
    with our manual DNS server configuration in `nslookup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.54 – The network obviously works, but DNS name resolution doesn''t,'
  prefs: []
  type: TYPE_NORMAL
- en: which points us in the right direction
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.54_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.54 – The network obviously works, but DNS name resolution doesn't,
    which points us in the right direction
  prefs: []
  type: TYPE_NORMAL
- en: 'This clearly points to a wrong DNS server configuration as the internet access
    works, but we can''t resolve a host. It''s obvious that the option that we used
    (`namserver`) is wrong – it has to be `nameserver`. This brings us to the point:
    we always have to make sure that the syntax of our configuration files – in this
    case, `resolv.conf` – is correct. Mistakes are easily made if we are making changes
    by using a text editor, especially when we, for example, ignore red, highlighted
    fields in vi. If we were using commands to configure this and made an error in
    the syntax (`nmcli` or `netplan`), we would have an error somewhere, which would
    be easy to debug.'
  prefs: []
  type: TYPE_NORMAL
- en: The last scenario that we are going to work on is a common one for those of
    us dealing with a public website migration from one provider to another, thus
    changing the public IP address. When we are configuring these scenarios, oftentimes
    we need to have the old website running while we test the new website. We could
    have two IP address entries in our public DNS servers pointing to two different
    web servers, but that's not what we're after, ever. It would confuse our website
    visitors and us as well. So, we want to have a quick way of testing the new website
    until it's fully debugged while offering the general public access to the old
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the simplest thing to do would be to add an entry to `/etc/hosts`,
    so that it points to the new website. Then, on the same machine where we made
    that change, we can debug our new website as much as we need – the public DNS
    entry still points to the old website, while our local machine goes to the new
    one.
  prefs: []
  type: TYPE_NORMAL
- en: After the debugging process is done, we need to do a switchover – we need to
    change the public DNS entries and remove the `/etc/hosts` entry on our debugging
    machine. That's an ideal scenario where we can make some mistakes. So, we go to
    our public DNS provider, change the IP address of our website so that it points
    to the new IP, and save the configuration. Then, we go to our local debugging
    machine and remove the `/etc/hosts` entry pointing to the new website, start a
    web browser, point it to our website URL, and – lo and behold – we are still being
    presented with the old website. What is going on here?
  prefs: []
  type: TYPE_NORMAL
- en: The simple fact is public DNS records need a bit of time to become active. It
    could be a minute, 15 minutes, an hour, a day – depending on how it's configured,
    but still, it needs time. Also, from various parts of the world – if our website
    is for an international audience – it could take different amounts of time to
    synchronize, which is why we have to be armed with patience when dealing with
    scenarios like these as we are probably going to get some emails about this scenario.
    We just need to do these types of configuration changes over the weekend when
    the amount of website visitors is at its lowest, and then sit and wait it out
    for all of the DNS entries to sync. From the time when we changed the DNS entry
    until everything is working, it's out of our hands. It's just the way it works.
  prefs: []
  type: TYPE_NORMAL
- en: As you can clearly see from these examples, there are quite a few different
    scenarios that might come into play as you're administering your Linux servers,
    clients, and networks.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the commands that we covered in this recipe work on the same idea – we
    have a networking stack that is either configured correctly or not. If it is,
    we mostly don't need them, but if something is misconfigured and/or not working
    properly, which can happen for a variety of external reasons as well, then we
    need to know how these commands work.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are discussing networking generally, there are a few well-known concepts:
    the configured IP address, netmask, gateway, DNS server(s), and a fully qualified
    domain name of any given Linux server. Keeping in mind that networks are isolated
    into multiple subnets and that DNS is a hierarchical structure, if any of these
    concepts aren''t configured correctly, we will have issues with network communication.
    That''s why most of us system engineers take extra care to configure all of these
    settings correctly, as it''s a basis for us to not get permanent headaches, if
    you will.'
  prefs: []
  type: TYPE_NORMAL
- en: When we do `ping`, `traceroute`, and `tracepath`, all of the traffic that we
    generate by using those utilities either goes to our local network or to non-local
    networks, which requires routing. On top of routing, firewalls might get in the
    way – sometimes people configure firewalls with ICMP traffic denied.
  prefs: []
  type: TYPE_NORMAL
- en: Then, even if all of that works as it should, there's the DNS, sitting on top
    of it like a Jedi master trying to balance the Force. And sometimes, it just seems
    a bit evil and as if it's bugging us for no reason whatsoever. That's where utilities
    such as `nslookup`, `host`, and `dig` come in handy – so that we can find out
    if it's something *lower* in the networking stack, or if it's the DNS. As we discussed
    in our previous recipe, using `systemd-resolved` changed quite a few things in
    terms of DNS configuration. We must be extra careful to configure things properly
    when we're using it – so, using `nmcli` and netplan's config files. We shouldn't
    just go and start editing files more often than not. That's just going to make
    more problems.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, when we configure everything correctly and some other device
    on the network (our network or an external network) is at fault, things can get
    complicated very quickly. If a device doing network routing (a switch, router,
    Linux server, firewall, or whatever it might be) isn't configured correctly, we
    won't be able to communicate between multiple subnets. Imagine trying to go from
    Paris to Barcelona without knowing the way. There are so many possible ways of
    going from Paris to Barcelona (which we can equate to routing) that we wouldn't
    know which way to go. Usually, we start our debugging process by pinging some
    addresses on our networks (to check that the local network is working properly),
    then the default gateway, and checking if DNS is available as a service. On a
    more personal note, over the years, I have seen students and course attendees
    becoming painfully aware of just how complex DNS is as a system, especially at
    scale. We have a saying here at our college that students repeat over and over
    again – *It's always DNS*. So, we need to make sure that we have strong foundations
    in terms of DNS knowledge and understanding of how routing works. Then everything
    becomes much, much easier, as combining these two concepts can get insanely complicated.
    Especially when there are dynamic routing protocols such as BGP, EIGRP, and OSPF
    involved with split DNS and multiple locations.
  prefs: []
  type: TYPE_NORMAL
- en: And that's a wrap for this chapter. The next chapter is going to be all about
    using the shell to manage software packages on our Linux systems. We are going
    to discuss how to use `apt` and `apt-get`, `yum`, and `dnf`, software repositories,
    and other subjects related to software management. Until then, we bid you adieu!
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to learn more about network debugging, you can check the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A beginner''s guide to network troubleshooting in Linux: [https://www.redhat.com/sysadmin/beginners-guide-network-troubleshooting-linux](https://www.redhat.com/sysadmin/beginners-guide-network-troubleshooting-linux%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Five Linux network troubleshooting commands: [https://www.redhat.com/sysadmin/five-network-commands](https://www.redhat.com/sysadmin/five-network-commands%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
