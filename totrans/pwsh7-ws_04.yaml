- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell Variables and Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s time to really understand what we mean when we talk about variables. Variables
    are a common concept in computer science and mathematics, so it’s important to
    have a good grasp of what they are and how they are used in PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by exploring what a variable is, both literally and metaphorically.
    We will look at how we can use them in PowerShell and contrast the way PowerShell
    works with other languages. We will explore the concept of primitives, the basic
    building blocks of data, before moving on to the common data structures that PowerShell
    uses. Finally, we’ll have some fun with splatting, an important and useful technique
    for simplifying cmdlets.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to cover the following main topics.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PowerShell variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring object types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering value types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typing explained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splatting – using hashtables for fun and profit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding PowerShell variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A variable is like a box. We can put stuff in it. We can take that stuff out
    and put something else in it. The box may contain one thing, or it may contain
    many things. It may contain multiple things of the same type, for instance, 30
    pairs of socks, or it can be like my kitchen drawer, and contain all sorts of
    different things, including string. We can organize the things it contains in
    different ways or not organize them, like my kitchen drawer. It may contain nothing
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: A variable is really a label for a region of memory. That’s all it is – a name
    and an address in memory. When you tell PowerShell to use the contents of a variable,
    you’re telling it to go to that area of memory and use what it finds there. Using
    a label gives us two advantages; firstly, it saves a lot of typing, especially
    if the variable contains many objects. Secondly, it allows us to assign meaning,
    something that tells us, and other people reading our code, what the purpose of
    the variable is, and a clue as to what it likely contains. This is far more important
    and useful than it may appear right now.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Ceci n’est pas une variable. With apologies to Magritte](img/B17600_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Ceci n’est pas une variable. With apologies to Magritte
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerShell is intended to be easy to use, so variables can be created dynamically,
    unlike some languages, such as Java, where we must declare the variable before
    we can put something in it. What do I mean? Consider this line of code; don’t
    type it, just think about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What am I doing there? I’m dynamically creating a variable with `some stuff`
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I were to do that in a more Java-like style, I would write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Which creates a variable, gives it a name, and then we put a value in it. In
    practice, this is very rare. Most people, in most situations, create variables
    on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: If you read those lines of code closely, you will see that the first example
    contains `$MyVariable`, and in the second one, it’s `MyVariable`, without the
    `$` sign. Let’s talk about why.
  prefs: []
  type: TYPE_NORMAL
- en: Variables are not their contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We very rarely want to manipulate a variable. Going back to the box metaphor,
    unless we are five years old, we’re usually more interested in the contents of
    the box, not the box itself. `MyVariable` is the name assigned to the variable,
    the label that we can use to refer to it. `$MyVariable` refers to the contents
    of the variable. This is the stuff we are interested in. Let’s demonstrate.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – MyVariable is not $MyVariable](img/B17600_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – MyVariable is not $MyVariable
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first line in *Figure 4**.2*, we’re dynamically creating a variable
    called `MyVariable` and putting `some stuff` into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the second line, we ask PowerShell for the contents of `MyVariable` by typing
    `$MyVariable`, and we get `some` `stuff` back.
  prefs: []
  type: TYPE_NORMAL
- en: In the third line, we’ve just typed the name of the variable, `MyVariable`,
    and PowerShell has not understood what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the fourth line, we explicitly ask for `MyVariable` with the `Get-Variable`
    cmdlet, and again we get the `some stuff` string, but we also get some other stuff
    that isn’t part of the string; the `Get-Variable` cmdlet has returned a `PSVariable`
    object, not the contents of the variable, which is the `some stuff` string. We
    can confirm what sort of variable it is by using `Get-Member`. Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the fifth line, PowerShell quite reasonably tells us we don’t have a variable
    called `some stuff` – we’re passing the contents of `MyVariable` to `Get-Variable`
    here, not the name of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: In the sixth line, it may look like we’re passing a variable to `Write-Output`,
    but we’re not. We’re passing a string with the value `MyVariable`, not the contents
    of `MyVariable`.
  prefs: []
  type: TYPE_NORMAL
- en: The seventh line passes the contents of `MyVariable` to `Write-Output` correctly
    by referring to `$MyVariable`.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, if we always preface our variable names with a `$` sign, we’ll
    almost always be right. This brings us to names; what is a good variable name,
    and what is not?
  prefs: []
  type: TYPE_NORMAL
- en: Naming variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two things we should consider when naming a variable. Firstly, names
    we can use, and secondly, names we *should* use.
  prefs: []
  type: TYPE_NORMAL
- en: Names we can (and can’t) use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Variable names can contain any combination of letters, numbers, question marks,
    and the underscore symbol, `_`. They are not case sensitive. We can use other
    characters as well if we enclose the variable name in curly braces `{}`, but we
    don’t do this. Really – it makes life difficult, and there’s almost never any
    need for it. Examples of good and bad names are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Possible** **Variable Name** | **Impossible** **Variable Name** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Z54` | `z54!` |'
  prefs: []
  type: TYPE_TB
- en: '| `ComputerName` | `$``ComputerName` |'
  prefs: []
  type: TYPE_TB
- en: '| `Computer_Name` | `Computer-Name` |'
  prefs: []
  type: TYPE_TB
- en: '| `{``Computer Name}` | `Computer Name` |'
  prefs: []
  type: TYPE_TB
- en: '| `ComputerName?` | `{``Computer Name{}}` |'
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – Names we can and can’t use
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what sort of names we *can* use, what sort of names *should*
    we use?
  prefs: []
  type: TYPE_NORMAL
- en: Names we should (and shouldn’t) use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the purposes of using variables is to assign meaning. We do this by making
    the names meaningful; a variable name should give some clue as to the variable’s
    contents or purpose. While `MyVariable` is a perfectly legal and suitable name
    when we’re typing one or two lines of code, when we write a script, it doesn’t
    give us any clue as to what it contains or how we wanted it to be used; it just
    tells us that it’s a variable and that it’s *mine*.
  prefs: []
  type: TYPE_NORMAL
- en: My day job often involves debugging code written by other people. I have nightmares
    caused by scripts with 20 or 30 variables called `a`, `I`, `x`, `y`, `ii`, `x3`,
    `agtd`, and so on. I don’t know what they mean, and I bet the original author
    doesn’t remember, either. When naming variables, we should understand that our
    code will be read many more times than it is written, often by us, sometimes years
    after we wrote it. Let’s do ourselves a favor and write meaningful variable names.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also use consistent names, such as `ComputerName1`, `ComputerName2`,
    and `ComputerName3`, not `ComputerName1`, `computer_name2`, and `ComputerNameThree`.
    The PowerShell best practice guidelines suggest using Pascal case widely, where
    each word is capitalized, as this is easy to read and works well with screen readers.
    Other languages, such as Python, suggest variable names should be all lowercase
    and the words separated with underscores: `computer_name`. Whichever we choose,
    being consistent will make our lives easier.'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t use question marks, either. It’s scruffy, and it can cause complications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we should avoid trying to use the names of automatic or preference
    variables. Wait, what?
  prefs: []
  type: TYPE_NORMAL
- en: The three common types of PowerShell variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we’ve been talking about a particular type of PowerShell variable –
    **user-created variables**. There are two other types: **automatic variables**
    and **preference variables**. User-created variables only exist for as long as
    the session or script that generated them is running; once we close our PowerShell
    window, those variables are destroyed. This is called **scope**, and we’ll cover
    it in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *Writing Our First Script
    – Turning Simple Cmdlets into Reusable Code*. Automatic and preference variables
    exist for every session or script.'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are used internally by PowerShell. We’ve already used one: `$PSItem`
    , or `$_`, which refers to the current object in the pipeline. We can assign a
    value to it if we like, but PowerShell will clear it when the current running
    pipeline completes, as in *Figure 4**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Don’t use the names of automatic variables](img/B17600_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Don’t use the names of automatic variables
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting `$PSItem` to `"some stuff"`, the pipeline completes, and the
    variable is cleared, losing the information we were trying to store. Happily,
    most automatic variables are protected, as in *Figure 4**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – You can’t overwrite some automatic variables](img/B17600_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – You can’t overwrite some automatic variables
  prefs: []
  type: TYPE_NORMAL
- en: You can see a list of the automatic variables in the help topic `about_Automatic_Variables`,
    or you can see them online at [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables).
  prefs: []
  type: TYPE_NORMAL
- en: Preference variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Preference variables store information about how PowerShell works, enabling
    us to customize how PowerShell behaves. For instance, we could use a preference
    variable to ensure the `-WhatIf` parameter is applied by default to all cmdlets
    we run (that support it). Let’s see how that works in *Figure 4**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Using preference variables](img/B17600_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Using preference variables
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, we check the value of the `WhatIfPreference` variable; it’s
    `False`, the default. That makes sense because we’ve just started the PowerShell
    session. In the second line, we assign the value `True` by setting `$whatIfPreference
    = $``true`.
  prefs: []
  type: TYPE_NORMAL
- en: Then we check the value again. Sure enough, it’s now `True`. Let’s see how things
    work now. We run `Get-Process` to get the `Id` parameter of a suitable process;
    in this case, I’m going to get the ID of the `pwsh` process, `407`. Now, when
    we run `Stop-Process -Id 407`, we would normally expect the `pwsh` session to
    end; it doesn’t because, by default, now all processes run with the `-WhatIf`
    parameter set to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Changing preference variables this way only persists while the current session
    or script is running. If you stop and restart PowerShell, they’re all set back
    to the defaults. If you need to persist a preference, you can change your PowerShell
    profile, a PowerShell script that can be found by querying the `PROFILE` variable
    by typing `$PROFILE`. You’ll learn about editing scripts in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162),
    *Writing Our First Script – Turning Simple Cmdlets into* *Reusable Code*.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a full explanation of each of the preference variables in the help topic
    `About_Preference_Variables`, or you can read more about them online at [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can see the current values held in all variables by typing `Get-Variable`
    with no parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand a bit about the variable – the box – we can start looking
    at what we can put in there. Let’s have a look at object types.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring object types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last section, we talked about types of variables. Now, we’re going to
    talk about **object types** – the things that go in the box. The type of the object
    in the variable tells the computer what to do with it – what properties it has
    and what we can do with it. Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see something like the output in *Figure 4**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – It’s a string](img/B17600_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – It’s a string
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve put a string in there, and we know this because we’re told it – `TypeName`
    is `System.String`. At the moment, `MyVariable` contains a string. We can change
    what the type is by assigning something else to it. Try typing the following without
    quotation marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then, use `Get-Member` to check the contents. Now we’ve got a `System.Double`
    object type in there, a floating-point number.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do even better things. Type the following, and check the contents of
    the variable with `Get-Member`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the output of `Get-Process` held in our variable, and the contents
    have a type of `System.Diagnostics.Process`.
  prefs: []
  type: TYPE_NORMAL
- en: Variables can hold any type of object. Remember, everything in PowerShell is
    an object. We covered some of the specifics of PowerShell objects in [*Chapter
    3*](B17600_03.xhtml#_idTextAnchor049), *The PowerShell Pipeline – How to String
    Cmdlets Together*, but it is a good idea to review them from a more generic programming
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: What is an object? – redux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Picture a bicycle. What color is it? What sort of handlebars does it have? What
    is the wheel diameter? My bike has ape hanger handlebars, 15” wheels, and is a
    scuffed red glitter. Your bike may be a more sensible item altogether, with riser
    handlebars, 20” wheels, and in a serviceable black. My son Tom’s bike has pursuit
    handlebars, 22” wheels, and is white.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s three objects, there, of the (non-existent) `TypeName Imaginary.Bike`.
    We can list the objects in *Table 4.2*. All the objects have the same set of **properties**:
    Name, Handlebar, Wheel (inch), and Color properties. In each instance, they have
    different values for the properties. Other properties may include a basket, lights,
    and so on. Some of those properties may be optional, but some are not; a bicycle
    will always have two wheels of a fixed diameter, and a color.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **MyBike** | **YourBike** | **TomsBike** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Handlebar** | Ape hanger | Riser | Pursuit |'
  prefs: []
  type: TYPE_TB
- en: '| **Wheel (inch)** | 15 | 20 | 22 |'
  prefs: []
  type: TYPE_TB
- en: '| **Color** | Red | Black | White |'
  prefs: []
  type: TYPE_TB
- en: Table 4.2 – Our bikes
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create those bikes in PowerShell, list out the properties of each, and
    we can see that they are objects of the `Imaginary.Bike` type by using `Get-Member`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Three imaginary bikes](img/B17600_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Three imaginary bikes
  prefs: []
  type: TYPE_NORMAL
- en: Our bikes also have a common set of things we can do with them. We can pedal
    them to make them speed up. We can use the brakes to make them slow down. These
    are `Get-Member` in [*Chapter 1*](B17600_01.xhtml#_idTextAnchor013), *Introduction
    to PowerShell 7 – What It Is and How to Get It*. We would expect objects of the
    same type to have the same methods as each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept of an object is common to most modern programming languages, and
    most programming languages handle them in similar ways. The imaginary exercise
    we have just gone through is as relevant in Python as it is in PowerShell. Here
    are the same three imaginary bikes in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Three imaginary bikes in another language](img/B17600_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Three imaginary bikes in another language
  prefs: []
  type: TYPE_NORMAL
- en: The difference in PowerShell is everything is an object. With that in mind,
    let’s explore some common types of objects that we will want to put in variables.
    Let’s start with value types.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering value types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`System.Object` class in .NET. In general, value types in PowerShell are analogous
    to (but not exactly the same as) primitives. The memory location that holds a
    value-type object holds the actual data. There are also reference types, which
    we’ll look at later, that hold a reference to the actual data; the data is held
    elsewhere, possibly in multiple locations. Value-type data is a fixed size, in
    bits. Value types have a single value. To illustrate, let’s look at some value
    types. We’ll start with the simplest value type, the **Boolean** type.'
  prefs: []
  type: TYPE_NORMAL
- en: Memory locations – CompSci101 alert!
  prefs: []
  type: TYPE_NORMAL
- en: Data is stored in two different places in memory, the **stack,** and the **heap**.
    The stack is for static allocations (things that don’t change), and the heap is
    dynamic. The heap stores global information and is exactly like it sounds; it’s
    just a heap of data with a tree-like structure. It’s not of fixed size and allows
    random access. Access to the data can be quite slow, and the heap becomes fragmented
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: The stack is an orderly memory space of fixed size. It has a linear structure,
    where the last bit of data to be put on the stack is the first bit to be removed.
    Access to information is much quicker than in the heap. However, because space
    is limited, we occasionally get a stack overflow where we try to put more data
    into a stack than it can hold – the computer science equivalent of crossing the
    streams (Ghostbusters reference). Each thread of a running application has its
    own stack, but they all share the application heap.
  prefs: []
  type: TYPE_NORMAL
- en: When we create a variable, it goes in the stack. The data the variable refers
    to may be in the stack (for a value-type variable), or it may be in the heap (for
    a reference-type variable), but the variable is always in the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Boolean-type variable can hold one of two values; true or false. That’s it.
    It’s called a `System.Boolean` or `[bool]`. `[bool]` is an accelerator and saves
    us from having to type a much longer class name; it’s an alias for the type `System.Boolean`.
    Booleans are easy to assign; we use the automatic variables `$True` and `$False`.
    Try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the type is `System.Boolean`. Variables with this type are useful
    in scripting, as we will see in [*Chapter 5*](B17600_05.xhtml#_idTextAnchor096),
    *PowerShell Control Flow – Conditionals and Loops*. In that chapter, we’ll also
    see a similar but subtly different value type, the `[switch]` type – that can
    also only be true or false but has a different set of members.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Integers are whole numbers, that is, numbers without a decimal point. There
    are three main integer types, `[int32]`, `[int64]`, and `[byte]`. `[int32]` is
    the default type and is a signed value 32 bits long, meaning it can hold decimal
    values between -2,147,483,648 and +2,147,483,647\. If we create a variable that
    holds a whole number between those values, then PowerShell will give it the type
    `[int32]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If we try and assign a number outside that range, then PowerShell will give
    it the `[int64]` type, which is 64 bits long and can hold numbers between -9,
    223, 372, 036, 854, 775, 808 and +9, 223, 372, 036, 854, 775, 807.
  prefs: []
  type: TYPE_NORMAL
- en: We will sometimes see `[int]` and `[long]` in books and on web pages instead
    of `[int32]` and `[int64]` – the terms are interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: '`[byte]` is a special type of integer; it has no sign and is a whole number
    between 0 and 255, making it 8 bits long – 1 byte.'
  prefs: []
  type: TYPE_NORMAL
- en: Activity one
  prefs: []
  type: TYPE_NORMAL
- en: Why not have a single integer type – `[int64]`? Why bother complicating things?
  prefs: []
  type: TYPE_NORMAL
- en: Real numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In mathematics, real numbers are numbers that exist – they can be whole numbers
    (42), decimals (3.1), fractions (1/3), or irrational numbers (pi, the square root
    of two). Imaginary numbers like the square root of -1 are not real numbers, although
    they are incredibly useful. In PowerShell, whole numbers are expressed using the
    integer types we’ve just discussed, and common irrational numbers are served by
    the `[math]` type. We mostly use real number types to express floating point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three common variable types for working with real numbers, `[single]`
    (or `[float]`), `[double]` (or `[long]`), and `[decimal]`. The `[single]` variable
    type is 32 bits and has seven digits of precision (the numbers to the right of
    the decimal point). The `[double]` variable type is 64 bits and has 15 or 16 digits
    of precision. By default, PowerShell creates variables of the type `[double]`
    when you use a decimal number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `[Decimal]` type is 128 bits long and has a sliding scale of precision up
    to 28 digits. This is used in scientific and financial calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Char
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `[char]` type describes a single character, a member of the UTF-16 character
    set that we’re currently using. It’s a 16-bit value that corresponds to a symbol
    in the current character map. Try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: On my machine, I see an up-arrow `↑`. You may see something different. What
    you won’t see is `24`. We did something new there; we preceded the variable with
    a type accelerator. To understand why, we need to talk about typing.
  prefs: []
  type: TYPE_NORMAL
- en: Typing explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we understand some basic types, we need to cover typing and how languages,
    particularly PowerShell, manipulate the type of the object in the variable. How
    does a computer know what type of object it is? Languages can be divided into
    those that only support **static typing**, where the object type the variable
    can hold is declared when the variable is created and doesn’t change, and those
    that support **dynamic typing**, where the contents of the variable determine
    what the type is. In dynamically typed languages, the type of the variable can
    change. Try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the object type of `$MyVariable` changes depending on what is
    inside it, making PowerShell a dynamically typed language. In fact, PowerShell
    is described as **Type-Promiscuous** by Bruce Payette in *PowerShell in Action*,
    because it will try to make the thing that we put in a variable do whatever we
    want. So long as the object in the variable has the right sort of property, PowerShell
    doesn’t care what type it is. Let’s play around.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic versus static typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we type `$x = '4'`, we get `[string]`. If we type `$x = 4` without the quotes,
    we get `[int32]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see what happens if we type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Try it, and pipe `$x` to `Get-Member` just to confirm the type. PowerShell
    has tried its best to interpret what you want. It’s chosen to treat the second
    `4` as a string and added the two strings together, giving `44`. Amazing, right?
    Try it the other way around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it’s treating the second `''4''` as an integer and returns `8`. This does
    not work in most languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Python is not promiscuous](img/B17600_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Python is not promiscuous
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we can add strings together, called **concatenating**, and we can
    add integers together (called **adding**), and Python will happily dynamically
    type the variable contents as either a string or an integer. We cannot, however,
    mix strings and integers together; Python throws an error.
  prefs: []
  type: TYPE_NORMAL
- en: This is mostly a blessing, but sometimes it’s a mixed blessing. Because PowerShell
    works so hard trying to do what we want, it will sometimes do things we don’t
    want. It may be that we always want the contents to be a string, but some data
    entry error or an ill-defined operation puts an integer in there. This affects
    what we can do with that variable afterward because it has changed the object
    type to an integer. In a less-accommodating language, we get an error that tells
    us exactly what has gone wrong, but PowerShell may give us unexpected results,
    which take an age to debug if we’re lucky or cause a disaster if we’re not.
  prefs: []
  type: TYPE_NORMAL
- en: Casting variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Luckily, we can make PowerShell act more like a statically typed language by
    defining the contents of the variable when we create it by using an accelerator,
    `[int32]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And it’s an `[int32]` type, even though we gave it a string. Note this won’t
    work if we give it something that is less easy to interpret as an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This throws an error. Importantly, it will throw an error even if we just type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Because when we created `MyNewVariable` a few lines previously, we defined it
    as the `[Int32]` type, and so now that is all it can ever hold. This can also
    lead to some confusing results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might expect this cmdlet to throw an error as we try to put a floating-point
    number into `MyNewVariable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'But no. PowerShell just picks the closest integer and uses that instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – PowerShell doing as it’s told](img/B17600_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – PowerShell doing as it’s told
  prefs: []
  type: TYPE_NORMAL
- en: 'We can cast the variable, though, to a new type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: And we now have the correct value in there. Casting is an incredibly useful
    technique that we’ll be using a lot later, especially in [*Chapter 7*](B17600_07.xhtml#_idTextAnchor140),
    *PowerShell and the Web – HTTP, REST, and JSON*. It allows us to take a collection
    of strings and turn them into XML and JSON objects that can be used to interact
    with web-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of common ways of using casting to change the type of a
    variable’s contents. Firstly, we can create a new variable by copying the contents
    as a defined type. Let’s create a variable we know contains an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can cast that to a new variable as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do it the other way around, as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Activity two
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between `$myString` and `$MyOtherString`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: what types of objects can we subsequently put in each variable?'
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we can do it without creating a new variable; we can just use `[string]$MyVariable`
    in our code, and PowerShell will treat the contents as an object of the correct
    type if it can.
  prefs: []
  type: TYPE_NORMAL
- en: That’s as much as we need to do on simple value types, and how PowerShell uses
    dynamic and static typing. It’s time to look at the more complex compound variable
    types – reference types.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating reference types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we understand a bit about typing, and how value types work, we can talk
    about the other main type of object – **reference types**. We compared value type
    objects to primitives in other languages in the previous section, *Discovering
    value types*. Reference-type objects are the equivalent of data structures. Reference-type
    objects only hold a reference in the stack to more data in the heap; this is important
    because reference-type objects do not have a defined size. In general, a reference
    type may hold up to 2 GB of data. To prove it, I turned the Shakespeare play Hamlet
    into a string, by downloading it as a text file from Project Gutenberg:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Stringifying Hamlet](img/B17600_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Stringifying Hamlet
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are around 197,000 characters in the whole string.
  prefs: []
  type: TYPE_NORMAL
- en: I did two interesting things there; I used the `length` property of the string
    type to see how long my string was, in characters, but I also used the `GetType()`
    method to check the object type rather than using the pipeline to pass it to `Get-Member`.
    Before we talk more about properties and methods and the other exciting things
    we can do with strings, I want to start with a simple reference-type object, the
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An array is a data structure of fixed length that contains a collection of
    objects. They don’t have to be the same type of object, and they are not necessarily
    sorted or ordered. An array can contain zero or more objects. We can tell PowerShell
    we want to create an array by either casting the variable as an array implicitly
    using the comma character `,` or explicitly with `[array]`. Try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Did you try it? You do need to. As we go through this section, I’ll be calling
    back to the arrays we create here. It would be awful if you got to the end of
    the section and had to come back and start again because you didn’t create the
    array the first time around.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a single-item array, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Two single-element arrays](img/B17600_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Two single-element arrays
  prefs: []
  type: TYPE_NORMAL
- en: We can see that we create `Object[]` of `BaseType` as `System.Array` each time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create arrays using the range operator (`..`). Try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We should get an array containing all the numbers from 1 to 10, inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can use the array operator `@()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note we have to use a semicolon, not a comma, when separating different types
    of objects and using expressions. This is useful when we start scripting and using
    the splatting technique, which we’ll cover in the last section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Array basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each object in the array is called an element. We can list the elements by
    calling the whole array (`$NewArray`), like any other variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Listing the elements of an array](img/B17600_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Listing the elements of an array
  prefs: []
  type: TYPE_NORMAL
- en: 'We can choose to call a single element in an array by passing its index. This
    gets the first element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will get the second-to-last element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call multiple elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can call a range of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change the values of elements of an array by assigning them directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add elements to an array by using the `+=` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: But it’s tricky to delete an element from an array; instead, create a new array
    that only holds the elements you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, an array can hold objects of multiple types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can constrain the type of the objects in an array so that it can only hold
    objects of one type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops. We get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – You can’t leave that in there](img/B17600_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – You can’t leave that in there
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a look, we can see that the type of the `IntArray` object is `[int32[]]`
    with a base type of `System.Array`, and the type of the elements is `[Int32]`.
    We saw this syntax in [*Chapter 2*](B17600_02.xhtml#_idTextAnchor034), *Exploring
    PowerShell Cmdlets and Syntax*, when we were looking at the `Get-Help` cmdlet.
    An empty pair of square brackets denotes a parameter that can take multiple values;
    in other words, an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – System.String accepts an array](img/B17600_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – System.String accepts an array
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can add arrays together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: That’s the basics covered. Let’s look at the properties and methods we can use
    with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Properties and methods of arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is difficult to use `Get-Member` to see the properties and methods available
    on an array. PowerShell does not pass the array into the pipeline; it passes each
    element in the array in order. Try it by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: All we get back are the properties and methods for the `[``Int32]` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the properties and methods of the array type, you’ll need to either
    go to the help topic `about_Arrays` or look online here: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a brief look at some of the more important ones.
  prefs: []
  type: TYPE_NORMAL
- en: Count, Length, and Rank
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: These are common properties of arrays. `Count` is an alias for `Length`. They
    both tell us how many elements are in the array. `$NewArray.Count` and `$NewArray.Length`
    are the same. This is back to the muscle memory thing of old admins, again. You’ll
    see both in the PowerShell literature.
  prefs: []
  type: TYPE_NORMAL
- en: '`Rank` is interesting if you’re working with datasets. All the arrays we have
    been working with are `$ScruffyArray`, which contains the output of `Get-Process`.
    Most arrays you are likely to work with in PowerShell are one-dimensional. In
    data science, however, we quite often need to use multidimensional arrays; they’re
    complicated, and I haven’t seen a good PowerShell module for manipulating them.
    If you are really interested, have a look at the `about_Arrays` help topic. Just
    know it’s possible if you need to do a little bit with multidimensional arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: Clear, ForEach, and Where
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: These are common methods of arrays. Where the element of an array supports the
    `Clear` method, you can use it on the array to clear all the elements. If the
    element doesn’t support it, though, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Some methods are more useful than others](img/B17600_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – Some methods are more useful than others
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ForEach` method allows us to iterate through each element in an array
    and perform an operation on it. Type the following in to get the squares of the
    numbers in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Personally, I find this type of code golf willfully complicated and it goes
    against PowerShell’s best practices. It’s fine if we’re doing a couple of lines,
    but I wouldn’t put it in a script. We’ll cover how to do this in a more readable
    way in [*Chapter 5*](B17600_05.xhtml#_idTextAnchor096), *PowerShell Control Flow
    – Conditionals* *and Loops*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Where` method is similar, although more useful in one-liners. To get the
    elements of `$NewArray` greater than 5, we could type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s functionally the same as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And arguably less readable. We covered `Where-Object` in [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049),
    *The PowerShell Pipeline – How to String Cmdlets Together*. Remember, PowerShell
    will output each member of an array into the pipeline in turn. So, why have these
    as methods at all? If we are working with very large arrays, then using the method
    on the array rather than using the pipeline is faster. The following cmdlet takes
    about 300 ms to complete on my laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following cmdlet takes about 400 ms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So, it depends on where we want to save time. If the fastest possible code is
    our aim, then use the method on the array. If we want our code to be quickly understood
    when we return to it, then use the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Array performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One place where it is worth saving time, however, is in our manipulation of
    arrays. While it looks like we can change arrays by adding elements, this is not
    actually the case. Arrays are a fixed size. Every time we add an element, we create
    a new array. Let’s say we see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re actually creating and discarding 10,000 arrays. A lot of the documentation
    will tell us that the alternative is to use a .NET type instead of arrays – `[System.Collections.ArrayList]`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here we have the same sort of programming style, where we create the array variable
    and then add to it, but we have to call a non-PowerShell type and then use the
    `Add()` method. It works, but it’s quite complicated, especially when we’re just
    starting out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another alternative is to be clever about how we create our array and construct
    it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the same array as the other two with the speed of the `ArrayList`
    object type, but with the simplicity of using all PowerShell code. I ran these
    three cmdlets inside `Measure-Command`, so you can see the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Three ways of creating the same array](img/B17600_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – Three ways of creating the same array
  prefs: []
  type: TYPE_NORMAL
- en: I first came across this observation on Tobias Weltner’s excellent blog, [https://PowerShell.one](https://PowerShell.one).
    I thoroughly recommend reading his articles.
  prefs: []
  type: TYPE_NORMAL
- en: Copying arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we have a pretty good idea of what an array is, we can look at one of the
    key differences between value types and reference types: how copying variables
    works. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Without typing any more – what is in `$b`? If you said `42`, you would be right.
    Of course it is. The value of `$a` is held in the stack, so when we create `$b`,
    we copy the value `42` to the top of the stack and call it `$b` (if you got an
    error saying `'socks' isn't of type [Int32]`, close your PowerShell session and
    start a new one).
  prefs: []
  type: TYPE_NORMAL
- en: 'Copying arrays doesn’t work like that. Try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Argh! What happened there? `Array2` contains the updated value! That’s because
    all we did when we copied `Array1` to `Array2` was copy the reference to the data
    in the heap, the process storage area. When we then changed the element, we didn’t
    create a new array; we just changed the data in the old location. The references
    remain the same, so all copies of `Array1` will also reference the new data.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we get around this? Easy. At least, easyish. Have a go by doing the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And, voilà, we can now make changes to `Array1` without it affecting `Array2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We made PowerShell put each element in `Array1` into the pipeline and pipe it
    into `Array2`, creating a separate array of data. It’s a bit slow and clunky,
    but it works, and it’s simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s enough about arrays for now. We’ll be doing lots more with them throughout
    the book. Let’s look at the second reference type we’re going to cover: strings.'
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A string is a sequenced collection of `[char]` type objects – it’s text. As
    we saw at the start of this section on reference types, strings are a reference
    type, and they are immutable – read-only. If you want to change a string, you
    need to create a new string and destroy the old one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings have two properties, `Chars` and `Length`. `Chars` returns the `[char]`
    object at the given index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`Chars` is a parameterized property – we must give it a value, known as an
    `[int32]`; anything else will throw an error. We can pass it a variable that contains
    a single `[int32]`, however. The `Length` property returns the length of the string
    object in characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'See the following screenshot for how this all looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Properties of strings](img/B17600_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – Properties of strings
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings have a lot of methods. Where most of the methods on value types involve
    changing the object type, there are a lot of methods on strings to change the
    formatting. Have a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: And we’ll see there are 52 methods available on strings. We’ll not cover them
    all here, but let’s try a few of the common ones. Remember, each time we use these
    methods, we’re manipulating the output of the string, not the contents of the
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the string all in uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To get it all in lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To output the string as an array of single characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To replace a character in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'After all that, type and see that the actual content of the variable is unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`Replace()`, along with `Join()` and `Split()`, are also available as PowerShell
    string operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be written as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Two ways to split](img/B17600_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – Two ways to split
  prefs: []
  type: TYPE_NORMAL
- en: 'Quite often we find we have a date, but it’s in text format and ends up as
    a string. The `ToDateTime` method allows us to capture that string as a `[DateTime]`
    type, but we need to supply the culture we want as part of the method. We can
    do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see in the following screenshot that `$ImportantDate` is a `[``DateTime]`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Converting a string to a DateTime object](img/B17600_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 – Converting a string to a DateTime object
  prefs: []
  type: TYPE_NORMAL
- en: 'Even easier, though, if we have the chance, is to use the `[DateTime]` value
    type accelerator and cast the variable as the right type of object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Single and double quote marks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In PowerShell, single and double quote marks behave differently. They can both
    be used to define a string, but they have different purposes. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see in the following screenshot that the output is very different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21 – Single and double quotes](img/B17600_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 – Single and double quotes
  prefs: []
  type: TYPE_NORMAL
- en: Double quotes tell PowerShell to expand the variables it finds before processing.
    The shell alerts us to what it is going to do by coloring the variable green when
    we use double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the contents of a variable when it’s going to be immediately followed
    by another character, enclose the variable name in curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To print the variable, and not the contents of the variable, use the backtick
    character `` ` ``:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We’ll be doing plenty with strings as we go through the book, but now we should
    look at another important reference type, the hashtable.
  prefs: []
  type: TYPE_NORMAL
- en: Hashtables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A hashtable is a PowerShell implementation of a type of data structure called
    a dictionary. They consist of a list of **key-value** pairs. We use hashtables
    to look up values for a given key or check which key holds a given value; they
    are basically lookup tables. Let’s create a hashtable and play around with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re using `@{}` to create a hashtable there. We shouldn’t confuse it with
    `@()`, which will create an array. Now we’ve got our hashtable, we should put
    something in it. We can do this when we create the hashtable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we use a semicolon to separate the pairs, not a comma as we do in
    arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – Creating and populating hashtables](img/B17600_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22 – Creating and populating hashtables
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add key-value pairs to the hashtable using the `add` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add` method requires two parameters separated by a comma; the first is
    the key and must be in quotes, and the second is the value. If this is a string,
    it must also be in quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, unlike an array, PowerShell treats a hashtable as a single object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare this with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can use the `Count` property to return the number of key-value
    pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our hashtable, what can we do with it? The obvious use is
    to look up values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'And it returns the value `poor`. We can also use the key like we would use
    an index in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this method to add key-value pairs as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The big advantage of using the square brackets is it allows us to pass an array
    of keys and get the values back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can use a variable to hold the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We can list out all the key-value pairs in the hashtable one at a time with
    the `GetEnumerator()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Hold on. Can’t we do that just by typing `$MyBike`? No. If we try to do that,
    we get the whole hashtable as a single object. It will look like key-value pairs,
    but it won’t behave like a set of separate ones. Try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We can see there that only one object passed through the pipeline in the first
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can remove key-value pairs as well with the `remove` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test for the presence of a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can test for the presence of a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Ordered hashtables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, hashtables are not ordered, and this doesn’t really matter because
    we’re only ever looking for the values they contain in the key-value pairs. Sometimes,
    however, we want our hashtable to be arranged in a particular way. We can use
    the `[ordered]` keyword to do this. Note this doesn’t go before the variable;
    it goes on the right-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can see the difference in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23 – Ordered hashtable](img/B17600_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.23 – Ordered hashtable
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that it’s now a different type – `OrderedDictionary`. We can still get
    values by passing the key, but because it is ordered, we can also now just pass
    the index of the key pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you may have noticed that we’re back to bikes again. That’s because
    there’s another cool thing we can do with hashtables – we can turn them into objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following screenshot, we now have a `PSCustomObject`
    called `$MyImaginaryBike` with a set of properties matching the original hashtable
    key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24 – Turning a hashtable into an object](img/B17600_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.24 – Turning a hashtable into an object
  prefs: []
  type: TYPE_NORMAL
- en: Cool, eh? We’ll be using hashtables a lot in the rest of the book because they’re
    such a useful type.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other reference types as well that cover other types of data structures,
    such as queues and stacks, but we don’t tend to use them as much, certainly not
    in everyday PowerShell. Before we finish this chapter, we’ll cover one final use
    for hashtables: splatting.'
  prefs: []
  type: TYPE_NORMAL
- en: Splatting – a cool use for hashtables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some PowerShell cmdlets take a lot of parameters, and it can be confusing to
    feed them all into the cmdlet one at a time, all on the same line. Hashtables
    to the rescue. Try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we don’t use `$Colors`; we use `@Colors`. Also, notice it doesn’t
    matter which way round we use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This will work as well, because we’ve explicitly named the parameters in the
    hashtable:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.25 – \uFEFFA basic example of splatting](img/B17600_04_25.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.25 – A basic example of splatting
  prefs: []
  type: TYPE_NORMAL
- en: We could use an array, but that will only work for positional parameters; the
    first value in the array will be the first positional parameter, the second value
    will be the second, and so on. Because most cmdlets don’t have more than one or
    two positional parameters, this is nothing like as useful as a hashtable.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be using splatting a lot as we go on, but for this chapter, that’s it.
    Time to summarize what we’ve covered.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has been a long chapter, but we’ve learned a lot. We started by looking
    at variables and how they are used in PowerShell. After that, we took another
    look at objects from a computer science perspective and learned about their properties
    and methods. This gave us a grounding to start exploring object types, and we
    looked at some of the value types, which are equivalent to the computer science
    concept of primitives. From there, we saw how value types can be grouped together
    into data structures or reference types. Finally, for a bit of fun, we looked
    at how splatting can save us time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to be looking at flow control in PowerShell,
    conditional statements such as `if` and `else`, and loops using `ForEach` and
    `While`. We’ll also be installing more software because that’s the fun stuff,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What’s wrong with the variable `My Variable`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without trying the code, what `TypeName` will this cmdlet return?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How can we change the view of the errors PowerShell shows us?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What automatic variable can we use to clear the contents of an array or hashtable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How might we compare two integers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the object type of `MyVariable` here?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How would we get each character in a string into an array?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s going to go wrong here, and why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How can we create an object of type `OrderedDictionary`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a lot of reading for this chapter because we’ve only really brushed
    the surface of the subject. We really should read the help topics associated with
    what we’ve been doing in this chapter, and some of the official PowerShell language
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`about_Variables`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_variables)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`about_Automatic_Variables`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`about_Preference_Variables`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`about_Objects`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_objects](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_objects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell types: [https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-04](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-04)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell Variables: [https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-05](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-05)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`about_Booleans`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_booleans](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_booleans)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`about_Arrays`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_arrays)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell Arrays: [https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-09](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-09)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`about_HashTables`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_hash_tables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_hash_tables)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell hashtables: [https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-10](https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-10)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`about_Splatting`: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_splatting](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_splatting)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
