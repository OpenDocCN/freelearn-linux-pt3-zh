- en: '*Chapter 5*: Using Commands for File, Directory, and Service Management'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：使用命令进行文件、目录和服务管理'
- en: 'When working with files and folders, `systemctl` command. This is exactly what
    we''re going to cover in this chapter, by covering the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文件和文件夹时，使用`systemctl`命令。这正是我们将在本章中覆盖的内容，通过以下操作步骤：
- en: Basic file and directory-based commands
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的文件和目录命令
- en: Additional commands for manipulating file/directory security aspects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于操作文件/目录安全性方面的附加命令
- en: Finding files and folders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找文件和文件夹
- en: Manipulating text files by using commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令操作文本文件
- en: Archiving and compressing files and folders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归档和压缩文件及文件夹
- en: Managing services and targets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理服务和目标
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For these recipes, we're going to use one Linux machine – in our case, let's
    use `cli1`. We just need to make sure that it's powered on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些操作，我们将使用一台 Linux 机器——在我们的例子中，使用`cli1`。我们只需要确保它已开机。
- en: Basic file and directory-based commands
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的文件和目录命令
- en: 'Let''s discuss various shell commands that can be used to work with files and
    directories. In a nutshell, what we''re interested in are these commands:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些常用的 shell 命令，用于操作文件和目录。简而言之，我们关注的命令有：
- en: '`ls` – for listing folder contents'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls`——用于列出文件夹内容'
- en: '`touch` – for creating an empty text file'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touch`——用于创建一个空的文本文件'
- en: '`cd` – for changing directories, both in absolute and relative terms'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cd`——用于切换目录，可以使用绝对路径或相对路径'
- en: '`pwd` – for showing the current directory'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwd`——用于显示当前目录'
- en: '`mkdir` and `rm` – for creating and deleting a file or directory'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mkdir`和`rm`——用于创建和删除文件或目录'
- en: '`cp` and `mv` – for copying or moving a file or a directory'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp`和`mv`——用于复制或移动文件或目录'
- en: '`ln` – for working with soft and hard links'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ln`——用于操作软链接和硬链接'
- en: These commands are some of the most frequently used commands in the everyday
    life of a system administrator/engineer. Let's see what they are all about.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令是系统管理员/工程师日常工作中最常用的命令之一。让我们看看它们的具体用法。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: We need to go through these commands to really understand what happens on the
    filesystem as we execute them. So, let's make sure that our `cli1` machine is
    running and let's do it!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过这些命令来真正理解它们在执行时对文件系统的影响。所以，确保我们的`cli1`机器正在运行，让我们开始吧！
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行……
- en: 'Starting with the simplest command of them all, `ls`, it''s all about checking
    the content of a folder. So, if we want to check the content of a directory in
    a nice, readable format, we can do it like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从最简单的命令`ls`开始，它的作用是查看文件夹内容。因此，如果我们希望以清晰易读的格式查看某个目录的内容，可以这样操作：
- en: '![Figure 5.1 – Using ls with the most common options'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 使用最常见选项的 ls'
- en: '](img/Figure_5.1_B16269.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B16269.jpg)'
- en: Figure 5.1 – Using ls with the most common options
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 使用最常见选项的 ls
- en: 'The *nice, readable* part is achieved by using `-la` options, where the `l`
    option stands for *long listing*, and the `a` option stands for *all files (including
    the ones starting with a dot)*. We can also see that, by default, the `ls` command
    colors its output. For example, folders are colored blue, while files marked in
    red are archive files (in this case, the `tar.gz` file). We will go into more
    detail regarding archive files a bit later, when we start dealing with archiving
    and compressing files and folders later in this chapter. There are other colors
    that `ls` uses in its default output. Here are a couple of examples:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*清晰易读*的效果是通过使用`-la`选项实现的，其中`l`选项代表*长格式列出*，`a`选项代表*所有文件（包括以点开头的文件）*。我们还可以看到，默认情况下，`ls`命令会对输出内容进行颜色标记。例如，文件夹以蓝色显示，而以红色标记的文件是归档文件（在此案例中为`tar.gz`文件）。稍后，当我们开始处理归档和压缩文件及文件夹时，我们将深入探讨归档文件。`ls`命令在默认输出中使用了其他颜色。以下是一些示例：'
- en: Green – executable file
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色——可执行文件
- en: Cyan – symbolic link
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 青色——符号链接
- en: Red with black background – broken link
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑底红字——损坏的链接
- en: 'The `ls` command can be used in a `/etc/network`, and its recursive option
    (capital letter `R`):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls`命令可以用于`/etc/network`，并且可以使用其递归选项（大写字母`R`）：'
- en: '![Figure 5.2 – Using ls in recursive mode'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – 在递归模式下使用 ls'
- en: '](img/Figure_5.2_B16269.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.2_B16269.jpg)'
- en: Figure 5.2 – Using ls in recursive mode
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 在递归模式下使用 ls
- en: By using the `R` option, we instructed the `ls` command to do its job in recursive
    mode.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`R`选项，我们指示`ls`命令在递归模式下执行。
- en: 'We can also use `ls` to display the content of the folder and sort the output
    by using the last modified time:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`ls`来显示文件夹内容，并通过最后修改时间对输出进行排序：
- en: '![Figure 5.3 – Sorting the ls output according to the last modification time'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – 按最后修改时间对`ls`输出进行排序'
- en: '](img/Figure_5.3_B16269.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.3_B16269.jpg)'
- en: Figure 5.3 – Sorting the ls output according to the last modification time
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 按最后修改时间对`ls`输出进行排序
- en: 'The next command on our list is `touch`, and it''s a simple one. We use the
    `touch` command to create an empty file, like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要介绍的命令是`touch`，这是一个简单的命令。我们使用`touch`命令来创建一个空文件，如下所示：
- en: '![Figure 5.4 – Touching a file in Linux means creating an empty file'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – 在Linux中使用`touch`创建空文件'
- en: '](img/Figure_5.4_B16269.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.4_B16269.jpg)'
- en: Figure 5.4 – Touching a file in Linux means creating an empty file
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 在Linux中使用`touch`创建空文件
- en: 'Following that, it''s time to explain two commands that are closely related
    – `cd` and `pwd. cd`, or the *change directory* command, is there so that we can
    leave one directory in the shell and go to another. In contrast, `pwd` is a command
    that tells us what our current directory is. Let''s try that out by again using
    `/etc/network` as an example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要解释两个紧密相关的命令——`cd`和`pwd`。`cd`，即*更改目录*命令，帮助我们离开一个目录并进入另一个目录。而`pwd`命令则告诉我们当前所在的目录。让我们用`/etc/network`作为示例，来实际操作一下：
- en: '![Figure 5.5 – Using cd and pwd to get our bearings in terms of directories'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – 使用`cd`和`pwd`来定位我们的目录'
- en: '](img/Figure_5.5_B16269.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.5_B16269.jpg)'
- en: Figure 5.5 – Using cd and pwd to get our bearings in terms of directories
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 使用`cd`和`pwd`来定位我们的目录
- en: 'The next two commands that we''re going to deal with are `mkdir` and `rm`.
    We use `mkdir` to create a directory, while we use the `rm` command to remove
    a file or a folder. So, let''s show how these commands are used by means of an
    example. First, we are going to create a directory called `temporary`. Then, we''re
    going to create two files in that directory called `tempfile` and `tempfile2`.
    After that, we''re going to remove `tempfile2`, and then remove the entire temporary
    directory with all its contents, recursively. Let''s do that now:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要处理的两个命令是`mkdir`和`rm`。我们使用`mkdir`来创建目录，而`rm`命令用来删除文件或文件夹。接下来，我们通过一个示例来演示这两个命令的使用。首先，我们将创建一个名为`temporary`的目录。然后，在该目录中创建两个文件，分别命名为`tempfile`和`tempfile2`。之后，我们将删除`tempfile2`，然后递归地删除整个`temporary`目录及其所有内容。让我们现在来做这个操作：
- en: '![Figure 5.6 – Working with mkdir and rm'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – 使用`mkdir`和`rm`命令'
- en: '](img/Figure_5.6_B16269.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.6_B16269.jpg)'
- en: Figure 5.6 – Working with mkdir and rm
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 使用`mkdir`和`rm`命令
- en: 'The next topic of our discussion is the `cp` and `mv` commands – they enable
    us to copy or move files and/or folders where we want to move them. So, let''s
    copy a file and folder (recursively), and then let''s move them someplace else.
    We''re going to use the same example as with `mkdir` and `rm`, but we''re going
    to adjust the example slightly to fit the purpose. Specifically, we''re going
    to create a directory with two files, but this time these files are going to be
    in a subdirectory. Then, we''re going to add additional files to the first folder,
    after which we''re going to copy and move a single file to a new location, and
    then a folder to another location. Let''s see how that''s going to work:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的话题是`cp`和`mv`命令——它们使我们能够在想要的地方复制或移动文件和/或文件夹。接下来，我们将复制一个文件和一个文件夹（递归地），然后将它们移动到其他地方。我们将使用与`mkdir`和`rm`相同的示例，但会稍作调整以适应本次操作。具体来说，我们将创建一个包含两个文件的目录，但这次这些文件将位于一个子目录中。然后，我们将向第一个文件夹添加更多文件，之后将单个文件复制并移动到新位置，再将整个文件夹移动到另一个位置。让我们看看如何实现：
- en: '![Figure 5.7 – Copying and moving files and folders'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – 复制和移动文件与文件夹'
- en: '](img/Figure_5.7_B16269.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.7_B16269.jpg)'
- en: Figure 5.7 – Copying and moving files and folders
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 复制和移动文件与文件夹
- en: The first two commands can be aggregated into one by executing `mkdir -p temporary/tempdir2`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个命令可以通过执行`mkdir -p temporary/tempdir2`合并成一个命令。
- en: This will create both of these directories in one command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过一个命令创建这两个目录。
- en: 'And finally, let''s discuss the `ln` command, which can be used to create hard
    links (pointers to the file content) and soft links (pointers to the file/directory
    name, usually referred to as shortcuts). For hard links, we just use the `ln`
    command without any additional options, while soft links require us to use the
    `ln` command with the `-s` option. Let''s create an example to drive the point
    of this home, and we''ll explain how it works as soon as we''re done with this
    example. The scenario is going to include the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来讨论一下 `ln` 命令，它可以用来创建硬链接（指向文件内容的指针）和软链接（指向文件/文件夹名称的指针，通常被称为快捷方式）。对于硬链接，我们只需使用不带任何附加选项的
    `ln` 命令，而软链接则需要使用带有 `-s` 选项的 `ln` 命令。让我们创建一个示例来解释这个概念，完成这个示例后，我们将解释它是如何工作的。这个场景将包括以下内容：
- en: Copying a file with a bit of content to a new location so that we have a source
    file that's going to be used for hard and soft links
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个有一些内容的文件复制到新位置，这样我们就有了一个源文件，用于创建硬链接和软链接
- en: Creating a hard link
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建硬链接
- en: Creating a soft link
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建软链接
- en: Deleting the original file, and then checking what happens with the soft link
    and the hard link
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除原始文件，然后检查软链接和硬链接发生了什么变化
- en: Copying the hard link to the original file, then checking what happens with
    soft link and hard link
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制原始文件的硬链接，然后检查软链接和硬链接发生了什么变化
- en: 'This is how it''s done:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: '![Figure 5.8 – Hard link and soft link operations'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8 – 硬链接和软链接操作](img/Figure_5.8_B16269.jpg)'
- en: '](img/Figure_5.8_B16269.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.8_B16269.jpg)'
- en: Figure 5.8 – Hard link and soft link operations
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 硬链接和软链接操作
- en: Now that we have gone through all the predetermined scenarios, let's explain
    some of the concepts behind these commands so that we can understand what happens
    on the filesystem as we execute them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经经历了所有预定的场景，接下来让我们解释这些命令背后的一些概念，以便理解在执行它们时文件系统发生了什么。
- en: How it works…
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Some of these commands are very straightforward and don't necessarily require
    further explanation, such as `ls`, `touch`, `cd`, `mkdir`, and `pwd`. But others
    do require a bit of background and technical explanation, especially `ln`. So,
    let's build on that premise and go through how `rm`, `cp`, `mv`, and `ln` work.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令中有些非常直接，不一定需要进一步解释，比如 `ls`、`touch`、`cd`、`mkdir` 和 `pwd`。但其他一些命令则需要一点背景和技术解释，特别是
    `ln`。因此，让我们以此为基础，逐步讲解 `rm`、`cp`、`mv` 和 `ln` 是如何工作的。
- en: First, to cover basic file-related commands that we use the most often – `rm`,
    `cp`, and `mv`. These commands are straightforward, as we use them to remove files
    or folders (`rm`), copy files or folders (`cp`), or move files or folders (`mv`).
    Please note *remove* and *move* in our description of `rm` and `mv`, as those
    two things are different – removing is about deleting, while moving is about placing
    something someplace else. This sometimes confuses novice users, although it shouldn't.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，介绍我们最常用的一些基本文件操作命令——`rm`、`cp` 和 `mv`。这些命令非常直接，我们用它们来删除文件或文件夹（`rm`）、复制文件或文件夹（`cp`）或移动文件或文件夹（`mv`）。请注意，我们在描述
    `rm` 和 `mv` 时使用了*删除*和*移动*这两个词，因为它们是不同的——删除指的是删除文件，而移动指的是将文件放到其他地方。虽然这有时会让新手用户感到困惑，但其实不应该这样。
- en: However, the most technically demanding command from the bunch is `ln`, which
    requires us to explain what soft links are, and what hard links are. So, let's
    do that first.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从技术上讲，最具挑战性的命令是 `ln`，它要求我们先解释什么是软链接，什么是硬链接。所以，让我们先从这部分开始。
- en: Soft links are what we usually refer to as *shortcuts*, similarly to what we
    can do in Windows – create a shortcut to a file or a folder. As it's obvious from
    the picture of our scenario, when we removed the original file, the soft link
    stopped working. The reason for this is simple – soft links point to a *file or
    folder name*. If we delete a file or folder to which a soft link is pointing,
    that effectively means that the soft link points to nothing. And that's the reason
    why, in our scenario, we had a soft link turning red in color.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 软链接通常指我们在 Windows 中所说的*快捷方式*，也就是说我们可以为文件或文件夹创建一个快捷方式。正如我们场景中的图片所示，当我们删除原始文件时，软链接停止工作。原因很简单——软链接指向的是*文件或文件夹的名称*。如果我们删除一个软链接指向的文件或文件夹，这就意味着软链接指向了不存在的内容。这就是为什么在我们的场景中，软链接会变成红色的原因。
- en: Hard links are a completely different concept. They don't point to a filename
    – they point to *file content*. When using hard links, try to think of them as
    two files pointing to the same content. If we delete the original file, the file
    content is still there, as that's the way modern filesystems work – they don't
    waste time deleting content, especially if another file is pointing to the same
    content. That would introduce a lot of latency into the process of deleting files
    if the files are big. A file delete operation therefore just deletes a pointer
    (filename) to the file content from a filesystem table. The filesystem takes care
    of the rest – when the time comes, if that file content is no longer used, the
    filesystem is going to use it to write new content over it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 硬链接是一个完全不同的概念。它们不指向文件名 – 它们指向*文件内容*。当使用硬链接时，试着将它们看作是指向相同内容的两个文件。如果我们删除了原始文件，文件内容仍然存在，因为这是现代文件系统的工作方式
    – 它们不会浪费时间删除内容，特别是如果另一个文件仍然指向相同的内容。因此，文件删除操作只是从文件系统表中删除指针（文件名）到文件内容。文件系统会处理剩下的事情
    – 当时间到来时，如果那个文件内容不再被使用，文件系统会用新内容覆盖它。
- en: We could've deduced this much from checking the original scenario, where we
    can clearly see the *difference in size* between soft and hard links – the soft
    link points to a filename and is therefore related to the size of a filename (the
    number of characters in the filename). As we explained, the hard link points to
    the file content, which is why the hard link has the same size as the file that
    it's pointing to.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查原始情景，我们可以得出这么多结论，我们可以清楚地看到软链接和硬链接之间的*大小差异* – 软链接指向文件名，因此与文件名的大小有关（文件名中字符的数量）。正如我们所解释的，硬链接指向文件内容，这就是为什么硬链接的大小与其指向的文件相同的原因。
- en: There are two fundamental differences between these two concepts. Having in
    mind that the hard links point to *file content*, it's logical that they have
    two limitations – they can't point to a directory (just a file), and they can't
    go across partitions. So, if we have a disk partition mounted to `/directory`
    and another disk partition mounted to `/home directory`. We can't go to `/home
    directory` and create a hard link that points to a file that's located in `/partition`.
    One partition can't see the content of another partition, which is an important
    security concept. It also precludes any chance that hard links across partitions
    are going to work.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个概念之间有两个基本差异。考虑到硬链接指向*文件内容*，它们不能指向目录（只能指向文件），并且不能跨分区。因此，如果我们将一个磁盘分区挂载到`/directory`，另一个磁盘分区挂载到`/home
    directory`。我们不能去`/home directory`并创建一个指向位于`/partition`中的文件的硬链接。一个分区无法看到另一个分区的内容，这是一个重要的安全概念。这也排除了跨分区的硬链接能够正常工作的可能性。
- en: The next recipe is going to go much deeper into file-directory security concepts,
    as we're going to discuss permissions, special permissions, and **Access Control
    Lists** (**ACLs**). These concepts are core concepts of IT security and something
    that we deal with daily. So, let's go through a scenario related to that next.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例将更深入地探讨文件目录安全概念，我们将讨论权限、特殊权限以及**访问控制列表**（**ACLs**）。这些概念是IT安全的核心概念，也是我们日常处理的内容。所以，让我们接下来通过一个相关的场景来了解一下。
- en: See also
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'If you need more information about these commands, we suggest that you visit
    these links:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多关于这些命令的信息，建议您访问这些链接：
- en: '`ls` man page: `https://man7.org/linux/man-pages/man1/ls.1.html`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls` 手册页面：`https://man7.org/linux/man-pages/man1/ls.1.html`'
- en: '`touch` man page: `https://man7.org/linux/man-pages/man1/touch.1.html`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touch` 手册页面：`https://man7.org/linux/man-pages/man1/touch.1.html`'
- en: '`cd` man page: `https://linuxcommand.org/lc3_man_pages/cdh.html`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cd` 手册页面：`https://linuxcommand.org/lc3_man_pages/cdh.html`'
- en: '`pwd` man page: `https://man7.org/linux/man-pages/man1/pwd.1.html`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwd` 手册页面：`https://man7.org/linux/man-pages/man1/pwd.1.html`'
- en: '`mkdir` man page: `https://man7.org/linux/man-pages/man1/mkdir.1.html`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mkdir` 手册页面：`https://man7.org/linux/man-pages/man1/mkdir.1.html`'
- en: '`rm` man page: `https://man7.org/linux/man-pages/man1/rm.1.html`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm` 手册页面：`https://man7.org/linux/man-pages/man1/rm.1.html`'
- en: '`cp` man page: `https://man7.org/linux/man-pages/man1/cp.1.html`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp` 手册页面：`https://man7.org/linux/man-pages/man1/cp.1.html`'
- en: '`mv` man page: `https://linux.die.net/man/1/mv`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mv` 手册页面：`https://linux.die.net/man/1/mv`'
- en: '`ln` man page: `https://man7.org/linux/man-pages/man1/ln.1.html`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ln` 手册页面：`https://man7.org/linux/man-pages/man1/ln.1.html`'
- en: Additional commands for manipulating file/directory security aspects
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加命令以操作文件/目录安全方面
- en: 'In this recipe, we''re going to use our users – Jack, Joe, Jill, and Sarah
    – to create a specific scenario to explain permissions, ACLs, and umask usage.
    A short explanation of these concepts is as follows: permissions are used to control
    access to files and folders in read, write, and execute mode. As they''re limited
    in granularity, a concept of ACL was developed, to be able to manage permissions
    on a more finely grained level. Umask is a variable that pre-determines which
    permissions are going to be assigned to a newly created file or directory.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用我们的用户——Jack、Joe、Jill和Sarah——来创建一个特定的场景，解释权限、ACL和umask的使用。以下是这些概念的简要解释：权限用于控制对文件和文件夹的访问，包括读取、写入和执行模式。由于权限的粒度有限，开发了ACL概念，以便能够在更细粒度的级别上管理权限。Umask是一个变量，预先决定了将分配给新创建的文件或目录的权限。
- en: 'The recipe will go like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该方案将如下进行：
- en: We need to create a collaborative directory for our students located at `/share/students`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要为我们的学生创建一个共享目录，位于`/share/students`
- en: We need to create a collaborative directory for our professors located at `/share/professors`
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要为我们的教授创建一个共享目录，位于`/share/professors`
- en: Members of the student group need to have access to `/share/students` to collaborate
    on project files
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学生组的成员需要能够访问`/share/students`文件夹，以便共同协作项目文件
- en: Members of the student group can create new files, which need to be group-owned
    by group students, in their `/share/students` folder
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学生组的成员可以在`/share/students`文件夹中创建新的文件，这些文件需要由学生组拥有
- en: One member of the student group can't use the `rm` command to delete other members'
    files in their `/share/students` folder
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学生组的一个成员不能使用`rm`命令删除`/share/students`文件夹中其他成员的文件
- en: One member of the student group must have permission to edit other members'
    files in their `/share/students` folder
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学生组的一个成员必须有权限编辑`/share/students`文件夹中其他成员的文件
- en: Professors need to have read-write access to all the student files, and all
    of the newly created student files
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教授需要对所有学生文件以及所有新创建的学生文件具有读写权限
- en: Only professors have access to their shared folder, `/share/professors`, where
    they can delete each other's files, read them, and edit them.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有教授才能访问他们的共享文件夹`/share/professors`，在该文件夹中，他们可以删除彼此的文件、读取文件并编辑文件。
- en: Let's make this recipe happen.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始这个实例吧。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's use our `cli2` machine (CentOS) for this recipe, so make sure that it's
    powered on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`cli2`机器（CentOS）进行本例，因此请确保该机器已开启。
- en: How to do it…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We''re going to first create our users and groups by using the `useradd` and
    `groupadd` commands by using a scenario. Let''s say that our task is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过使用`useradd`和`groupadd`命令来创建用户和组，基于一个场景。假设我们的任务如下：
- en: Create four users called `jack`, `joe`, `jill`, and `sarah`
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建四个用户，分别为`jack`、`joe`、`jill`和`sarah`
- en: Create two user groups called `profs` and `pupils`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两个用户组，分别为`profs`和`pupils`
- en: Reconfigure the `jack` and `jill` user accounts to be members of the `profs`
    group
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新配置`jack`和`jill`用户账户，使其成为`profs`组的成员
- en: Reconfigure the `joe` and `sarah` user accounts to be members of the `students`
    group
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新配置`joe`和`sarah`用户账户，使其成为`students`组的成员
- en: Assign a standard password to all the accounts (we're going to use `P@ckT2021`
    for this purpose)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有账户分配一个标准密码（我们将使用`P@ckT2021`作为密码）
- en: Configure user accounts so that they must change their password when next logging
    in
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置用户账户，以便他们在下次登录时必须更改密码
- en: Set specific expiry data for the professors' user group – the minimum days before
    the password change should be set to `15`, the maximum days before a forced password
    change should be set to `30`, the warning regarding a password change needs to
    start a week before it expires, and the expiry date for accounts should be set
    to 2023/01/01 (January 1, 2023)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为教授用户组设置特定的过期数据——密码更改前的最短天数应设置为`15`，强制密码更改前的最大天数应设置为`30`，密码更改警告需要在密码过期前一周开始，账户的过期日期应设置为2023年1月1日（2023/01/01）
- en: Set specific expiry data for the students' user group – the minimum days before
    the password change should be set to `7`, the maximum days before a forced password
    change should be set to `30`, the warning regarding a password change needs to
    start 10 days before it expires, and the expiry date for accounts should be set
    to 2022/09/01 (September 1, 2022)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为学生用户组设置特定的过期数据——密码更改前的最短天数应设置为`7`，强制密码更改前的最大天数应设置为`30`，密码更改警告需要在密码过期前10天开始，账户的过期日期应设置为2022年9月1日（2022/09/01）
- en: Modify the `profs` group to be called `professors`, and the `pupils` group to
    be called `students`
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`profs`组修改为`professors`，并将`pupils`组修改为`students`。
- en: Note
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: There are a lot of commands in this recipe, so make sure that you refer to the
    *How it works…* section of the recipe to understand everything about the new commands
    that we haven't used before.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这篇食谱中有很多命令，所以确保参考食谱中的*如何工作…*部分，以了解我们之前没有使用过的命令的相关内容。
- en: 'The first task is to create user accounts, with their unique home directories
    and the Bash shell as the default shell:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是创建用户账户，为其分配唯一的主目录，并将Bash shell设置为默认Shell：
- en: '[PRE0]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create entries for these four users in the `/etc/passwd` file (where
    most of the users' information is stored – username, user ID, group ID, default
    home directory, and default shell), and the `/etc/shadow` file (where users' passwords
    and aging information are stored).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为这四个用户在`/etc/passwd`文件中创建条目（该文件存储了大多数用户信息——用户名、用户ID、组ID、默认主目录和默认Shell），以及在`/etc/shadow`文件中创建条目（该文件存储了用户的密码和过期信息）。
- en: 'Then, we need to create groups:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建组：
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will create entries for these groups in the`/etc/group` file, where the
    system keeps all of the system groups.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为这些组在`/etc/group`文件中创建条目，系统会在该文件中保留所有的系统组。
- en: 'The next step is to manage the membership of the user groups, for both the
    professors and student user groups. Before we do that, we need to be aware of
    one fact. There are two distinctive local group types – *primary group* and *supplementary
    group*. The *primary group* is important in terms of being the key parameter used
    when creating new files and directories, as the users'' primary group will be
    used by default for that (there are exceptions, as we''ll mention in recipe #4
    in this chapter, about umask, permissions, and ACLs).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '下一步是管理用户组的成员资格，包括教授组和学生组。在我们开始之前，需要了解一个事实。存在两种不同的本地组类型——*主组*和*附加组*。*主组*在创建新文件和目录时至关重要，因为默认情况下，用户的主组将用于这些操作（当然也有例外，我们将在本章的食谱
    #4 中提到，关于umask、权限和ACLs的内容）。'
- en: 'The *supplementary group* is important when dealing with sharing files and
    folders and related scenarios and exceptions. This is what''s usually used for
    some additional settings for more advanced scenarios. These scenarios are going
    to be explained partially in the aforementioned recipe #4 in this chapter, as
    well as in recipes regarding NFS and Samba in [*Chapter 9*](B16269_09_Final_PD_ePub.xhtml#_idTextAnchor206)*,
    An Introduction to Shell Scripting*.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*附加组*在处理文件和文件夹共享以及相关的场景和异常时非常重要。这通常用于一些更高级场景的附加设置。将在本章前面提到的食谱 #4 中部分解释这些场景，以及在[*第9章*](B16269_09_Final_PD_ePub.xhtml#_idTextAnchor206)《Shell脚本介绍》中的NFS和Samba相关食谱中进一步说明。'
- en: Primary and supplementary groups are stored in `/etc/group` file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 主组和附加组存储在`/etc/group`文件中。
- en: 'Now that we''ve gotten that out of the way, let''s modify our users'' settings
    so that they belong to the *supplementary* groups as assigned by the scenario:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经搞定了这一点，让我们修改用户的设置，使其属于场景中指定的*附加组*：
- en: '[PRE2]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s now check how that changes the `/etc/group` file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查一下这如何改变`/etc/group`文件：
- en: '![Figure 5.9 – Entries in the /etc/group file'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.9 – `/etc/group` 文件中的条目'
- en: '](img/Figure_5.9_B16269.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.9_B16269.jpg)'
- en: Figure 5.9 – Entries in the /etc/group file
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – `/etc/group` 文件中的条目
- en: The first four entries in the `/etc/group` file were actually created when we
    used the `useradd` command to create these user accounts. The next two entries
    (except for the last part, after the `:` sign), were created by `groupadd` commands,
    while entries after the `:` sign were created after the `usermod` commands.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/group` 文件中的前四个条目实际上是在我们使用`useradd`命令创建这些用户账户时生成的。接下来的两个条目（除了`:`符号后面的部分）是由`groupadd`命令创建的，而`:`符号后的条目是在`usermod`命令之后创建的。'
- en: 'Let''s now set their initial password and set a forced password change when
    next logging in. We can do it in a couple of different ways, but let''s learn
    the more *programmatic* approach to doing this by echoing a string and using it
    as the plaintext password for a user account:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们设置他们的初始密码，并在下次登录时强制要求更改密码。我们可以通过几种不同的方式来做到这一点，但我们先通过回显一个字符串并将其作为用户账户的明文密码来学习一种更*程序化*的方式：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is not necessarily something that we should recommend doing as it would
    leave these commands in the command history. We're just using this as an example.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这不一定是我们推荐的做法，因为它会将这些命令留在命令历史记录中。我们只是将其作为一个示例。
- en: 'The `echo` part – without the rest of the command – would just type `P@ckT2021`
    to a terminal, like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`部分——没有其他命令——只会将`P@ckT2021`输入到终端中，如下所示：'
- en: '[PRE4]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In CentOS and similar distributions, we could use the `passwd` command with
    the `--stdin` parameter, which would mean that we want to add a password for the
    user account via standard input (keyboard, variable, ...). In Ubuntu, this is
    not available. So, we can echo the `username:P@ckT2021` string to `shell` and
    pipe that to the `chpasswd` command, which achieves just that purpose – instead
    of outputting the string to our terminal, the `chpasswd` command uses it as standard
    input into itself.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 和类似的发行版中，我们可以使用带有`--stdin`参数的`passwd`命令，这意味着我们希望通过标准输入（键盘、变量等）为用户账户添加密码。而在
    Ubuntu 中，这个功能不可用。因此，我们可以将`username:P@ckT2021`字符串回显到`shell`，并通过管道传递给`chpasswd`命令，这样就能达到目的——`chpasswd`命令不会将该字符串输出到终端，而是将其作为标准输入处理。
- en: 'Let''s set the expiry data for professors and students. For this purpose, we
    need to learn how to use the `chage` command and some of its parameters (`-m`,
    `-M`, `-W`, `-E`):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们设置教授和学生的过期日期。为此，我们需要学习如何使用`chage`命令以及它的一些参数（`-m`、`-M`、`-W`、`-E`）：
- en: If we use the `-m` parameter, this means that we want to assign the minimum
    number of days before a password change is allowed
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用`-m`参数，这意味着我们希望指定密码更改前的最小天数。
- en: If we use the `-M` parameter, this means that we want to assign the maximum
    number of days before a password change is forced
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用`-M`参数，这意味着我们希望在强制密码更改之前指定最大天数。
- en: If we use the `-W` parameter, this means that we want to set the number of warning
    days prior to password expiration, which, in turn, means that the shell is going
    to start throwing us messages about needing to change our password before it expires
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用`-W`参数，这意味着我们希望设置密码过期前的警告天数，这反过来意味着 shell 将开始向我们抛出关于密码即将过期的消息，提醒我们需要更改密码。
- en: If we use the `-E` parameter, this means that we want to set account expiration
    to a certain date (in YYYY-MM-DD format)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用`-E`参数，这意味着我们希望将账户过期设置为某个特定日期（格式为YYYY-MM-DD）。
- en: 'Let''s now translate that into commands:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将其转换为命令：
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And finally, let''s modify the groups to their final settings by modifying
    the group name from `professors` to `profs` and from `students` to `pupils`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过将组名从`professors`修改为`profs`，并将`students`修改为`pupils`，来调整组的最终设置：
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These commands will only change group names, not their other data (such as
    group ID), which is going to be reflected in our users'' information as well:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令只会更改组名，而不会更改其他数据（如组 ID），这也会反映在我们的用户信息中：
- en: '![Figure 5.10 – Checking created users'' settings'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10 – 检查已创建用户的设置'
- en: '](img/Figure_5.10_B16269.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.10_B16269.jpg)'
- en: Figure 5.10 – Checking created users' settings
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 检查已创建用户的设置
- en: As we can see, `jack` and `jill` are members of a group that's now called `professors`,
    while `joe` and `sarah` are now members of a group called `students`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`jack`和`jill`是现在被称为`professors`的组的成员，而`joe`和`sarah`现在是`students`组的成员。
- en: 'We deliberately left the `userdel` and `groupdel` commands for last, as they
    come with some caveats and shouldn''t be used lightly. Let''s create a user called
    `temp` and a group called `temporary`, and then let''s delete them:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意将`userdel`和`groupdel`命令放在最后，因为它们有一些注意事项，不应该轻易使用。让我们创建一个名为`temp`的用户和一个名为`temporary`的组，然后删除它们：
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will work just fine. The thing is, because we used the `userdel` command
    without any parameters, it will leave the user's home directory intact. Since
    users' home directories are usually stored in the `/home` directory, by default,
    this means that the `/home/temp` directory is still going to be there. When deleting
    users, this is sometimes something we want – to delete a user, but not to delete
    their files. If you specifically want to delete a user account and all the data
    from that user account, use the `userdel -r username` command. But think twice
    before doing it!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这样是完全可行的。问题是，由于我们使用了没有任何参数的`userdel`命令，它将保留用户的主目录不变。由于用户的主目录通常存储在`/home`目录中，默认情况下，这意味着`/home/temp`目录仍然存在。当删除用户时，有时我们希望这样做——删除用户，但不删除他们的文件。如果你特别想删除用户账户以及该用户账户的所有数据，请使用`userdel
    -r username`命令。但在这样做之前请三思！
- en: 'Furthermore, we obviously need to create a bunch of directories and files and
    change a whole stack of permissions and ACLs. As a general note, the `chmod` command
    changes permissions, while the `setfacl` command modifies ACLs. This is the correct
    way to do it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们显然需要创建一堆目录和文件，并且更改一大堆权限和访问控制列表（ACL）。作为一般说明，`chmod`命令用来更改权限，而`setfacl`命令则用来修改ACL。这是正确的操作方法：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's now test this to check whether it works. First, we're going to log in
    as our two students from the first recipe (`joe` and `sarah`) and create a couple
    of files. Then we're going to use joe's account to try to delete Sarah's files,
    and vice versa, so we should first use `su` to log in as `joe`, `su - joe`, and
    type in the root password.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来测试一下是否有效。首先，我们将以两名学生账户（`joe`和`sarah`）登录并创建一些文件。然后我们将使用Joe的账户尝试删除Sarah的文件，反之亦然，所以我们首先应该使用`su`命令登录为`joe`，`su
    - joe`，并输入root密码。
- en: 'Let''s see how that works out:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个如何工作：
- en: '![Figure 5.11 – The scenario works flawlessly from the students'' perspective'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.11 – 从学生的角度来看，场景完美无缺'
- en: '](img/Figure_5.11_B16269.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.11_B16269.jpg)'
- en: Figure 5.11 – The scenario works flawlessly from the students' perspective
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 5.11 – 从学生的角度来看，场景完美无缺
- en: 'Part of our scenario required us to be able to edit each other''s files, while
    not being able to delete them outright. Let''s test that now:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的场景要求我们能够编辑彼此的文件，同时又不能完全删除它们。现在让我们来测试一下：
- en: '![Figure 5.12 – Changing the content of the file works, while removing the
    file doesn''t'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.12 – 修改文件内容有效，而删除文件无效'
- en: '](img/Figure_5.12_B16269.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.12_B16269.jpg)'
- en: Figure 5.12 – Changing the content of the file works, while removing the file
    doesn't
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 5.12 – 修改文件内容有效，而删除文件无效
- en: There's a reason why we picked this type of scenario – this is a real-life scenario
    that file server administrators often encounter. It's basically the best of both
    worlds – collaboration works, but users can't delete each other's files by accident.
    Therefore, this recipe covers some of the most common things that happen on a
    file server, such as one user deleting another user's file by accident (the key
    point here being the *lack of intention* to delete a file). It has happened to
    all of us. On the other hand, changing a file's content is something that we can
    only do *intentionally*, *consciously*. This is also something that we can easily
    track by using filesystem auditing and file attributes, if we set up our system
    that way.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以选择这种场景，是有原因的——这是文件服务器管理员常常遇到的现实场景。它基本上是“两个世界的最佳结合”——协作有效，但用户不能意外删除彼此的文件。因此，这个方案涵盖了文件服务器上最常见的一些问题，例如某个用户不小心删除了另一个用户的文件（这里的关键点是*没有删除文件的意图*）。这种情况我们每个人都遇到过。另一方面，改变文件的内容是我们只能*有意*、*自觉*地做到的。这也是我们可以通过文件系统审计和文件属性轻松跟踪的事情，前提是我们设置了这样的系统。
- en: 'Let''s now review things from the professor''s perspective. We''ll use the
    `jill` account for this purpose:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从教授的角度来回顾一下。我们将使用`jill`账户来进行此操作：
- en: '![Figure 5.13 – Checking whether our configuration works for Jill'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.13 – 检查我们的配置是否对Jill有效'
- en: '](img/Figure_5.13_B16269.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.13_B16269.jpg)'
- en: Figure 5.13 – Checking whether our configuration works for Jill
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 5.13 – 检查我们的配置是否对Jill有效
- en: 'We also need to check whether the professors'' share works. Let''s test it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要检查教授的共享文件夹是否正常工作。让我们来测试一下：
- en: '![Figure 5.14 – From the professors'' standpoint, their share works as requested'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.14 – 从教授的角度来看，他们的共享文件夹按预期工作'
- en: '](img/Figure_5.14_B16269.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.14_B16269.jpg)'
- en: Figure 5.14 – From the professors' standpoint, their share works as requested
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 5.14 – 从教授的角度来看，他们的共享文件夹按预期工作
- en: 'Let''s try to use a student''s account to get into the professors'' shared
    folder:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用学生账户访问教授的共享文件夹：
- en: '![Figure 5.15 – A student tries to get to the professors'' share and is denied
    access'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.15 – 一名学生尝试访问教授的共享文件夹，但被拒绝访问'
- en: '](img/Figure_5.15_B16269.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.15_B16269.jpg)'
- en: Figure 5.15 – A student tries to get to the professors' share and is denied
    access
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 5.15 – 一名学生尝试访问教授的共享文件夹，但被拒绝访问
- en: We can also see that these files created by users get the `664` default permission.
    That's what umask is all about. Check how umask works in the *How it works…* section
    of this recipe.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到，用户创建的这些文件得到了`664`的默认权限。这就是umask的作用。请查看本方案的*它是如何工作的……*部分，了解umask的工作原理。
- en: So, the whole scenario works, but how exactly does it work? Let's check that
    out now.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，整个场景是有效的，但它到底是怎么工作的呢？让我们来查看一下。
- en: How it works…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Before we get to the detailed explanations of these commands, let''s just cover
    the basics and describe the commands that we have used:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细解释这些命令之前，我们先了解一些基础知识，并描述我们已使用过的命令：
- en: '`useradd` – the command that''s used to create a local user account'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useradd` – 用于创建本地用户账户的命令'
- en: '`usermod` – the command that''s used to modify a local user account'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usermod` – 用于修改本地用户账户的命令'
- en: '`userdel` – the command that''s used to delete a local user account'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userdel` – 用于删除本地用户账户的命令'
- en: '`groupadd` – the command that''s used to create a local group'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupadd` – 用于创建本地用户组的命令'
- en: '`groupmod` – the command that''s used to modify a local group'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupmod` – 用于修改本地用户组的命令'
- en: '`groupdel` – the command that''s used to delete a local group'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupdel` – 用于删除本地用户组的命令'
- en: '`passwd` – the command that''s most often used to assign passwords to user
    accounts, but it can be used for some other scenarios (for example, locking user
    accounts)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`passwd` – 最常用来为用户账户分配密码的命令，但它也可以用于其他一些场景（例如，锁定用户账户）'
- en: '`chage` – the command that''s used to manage user password expiry'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chage` – 用于管理用户密码过期的命令'
- en: '`chgrp` – the command that changes the group ownership of a file or folder'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chgrp` – 用于更改文件或文件夹的组所有权的命令'
- en: '`chmod` – the command that changes the permission of a file or folder'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod` – 改变文件或文件夹权限的命令'
- en: '`setfacl` – the command that changes the ACL of a file or folder'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setfacl` – 改变文件或文件夹ACL的命令'
- en: Now that we have discussed these commands, let's explain the details.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论过这些命令，让我们来解释一些细节。
- en: 'Every file or directory on a Linux filesystem has a number of attributes:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Linux文件系统中的每个文件或目录都有一组属性：
- en: Permissions
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权限
- en: Ownership
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有权
- en: File size
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件大小
- en: Date of creation
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建日期
- en: File/directory name
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件/目录名称
- en: 'We will focus on permissions and ownership in this recipe as that''s the core
    of this specific recipe. When we issue a command such as `ls -al` in the `/share/students`
    directory, this is what we get:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将重点讨论权限和所有权，因为这是本教程的核心内容。当我们在`/share/students`目录下执行命令`ls -al`时，得到的结果如下：
- en: '[PRE9]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's now use the `myfile1` output as an example. Reading from left to right,
    the `-rw-rw-r--+` part is related to permissions on that specific file. The second
    part (`joe`, followed by `students`) is related to ownership of that specific
    file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们以`myfile1`的输出作为例子。从左到右读取，`-rw-rw-r--+`部分与该文件的权限相关。第二部分（`joe`，后接`students`）与该文件的所有权相关。
- en: 'Let''s parse through this a bit, going with permissions first:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从权限部分开始解析一下：
- en: The first `–` means that this is a file – this field is used for the type of
    content.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个`-`表示这是一个文件——这个字段用于表示内容的类型。
- en: The first `rw-` means that we have read and write permission for the file owner
    (`joe`) – which we refer to as the user class (u).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个`rw-`表示文件所有者（`joe`）对该文件具有读写权限——我们称之为用户类（u）。
- en: The second `rw-` means that we have read and write permission for the group
    owner (`students`) – which we refer to as the group class (g).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个`rw-`表示我们对组所有者（`students`）具有读写权限——我们称之为组类（g）。
- en: '`R—`means that all the other users have just read permissions – we refer to
    this class as `others` (o).'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R—`表示其他用户只有读权限——我们称之为`others`（o）类。'
- en: '`+` at the end means that we have an active ACL on this specific file (to be
    discussed |a bit later in this explanation).'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 末尾的`+`表示该文件上有一个活跃的ACL（稍后将在此解释）。
- en: We can assign numerical values (weights) to these permissions. The read permission
    has a weight of 4 (22), the write permission has a weight of 2 (21), and the execute
    permission has a weight of 1 (20).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以给这些权限分配数字值（权重）。读权限的权重是4（22），写权限的权重是2（21），执行权限的权重是1（20）。
- en: 'So, if we wanted to assign all permissions to all classes of users (user owner,
    group owner, others), we''d use the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们想给所有用户类（用户所有者、组所有者、其他用户）分配所有权限，我们会使用如下命令：
- en: '[PRE10]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Why? If we add 4+2+1, that equals 7\. That means read + write + execute. And
    we can use that on all three classes – u, g, and o – so that gives us 777\. The
    first `7` refers to `u` (user owner), the second one to `g` (group owner), and
    the third one to everyone else (others). That simplifies the management of permissions
    significantly.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为如果我们加上4+2+1，结果是7。那意味着读+写+执行。而我们可以将这个值应用于所有三类用户——u、g和o——所以这给我们带来了777。第一个`7`代表`u`（用户所有者），第二个代表`g`（组所有者），第三个代表其他用户（others）。这大大简化了权限管理。
- en: If we're talking about files, the meaning of these permissions is straightforward
    – read means read, write means write, delete, and modify, and execute means the
    ability to start the file.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们谈论的是文件，这些权限的含义是直接的——读取意味着读取，写入意味着写入、删除和修改，执行意味着能够启动文件。
- en: With directories, it gets a bit trickier. Default permissions that we need in
    order to be able to read directory content and pass through it (folder traverse)
    are read and execute permissions. Write permission on a directory and read permission
    is needed to list the contents of the directory, while x permission is needed
    to traverse the directory (being able to go into subfolders of that directory).
    Write permission means write, delete, and modify on the folder level for the files
    in that folder (unless there are explicit denies, for example, set by ACL).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目录来说，情况变得有些复杂。为了能够读取目录内容并通过目录（目录遍历），我们需要的默认权限是读取权限和执行权限。对目录进行写权限和读取权限是列出目录内容所需要的，而执行权限是用于遍历目录（能够进入该目录的子文件夹）。写权限意味着在文件夹层级上对该文件夹中的文件进行写入、删除和修改（除非有明确的拒绝设置，例如，通过
    ACL 设置）。
- en: 'As you can clearly see in the command output, files have two types of ownership:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在命令输出中清晰看到，文件有两种所有权类型：
- en: '`joe`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`joe`'
- en: '`students`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`students`'
- en: What does that mean?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 那这意味着什么？
- en: It means that a *user called Joe* owns that file. At the same time, it means
    that a *group called students* own that file from the group perspective.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 它意味着一个名为 *Joe* 的用户拥有该文件。同时，它也意味着一个名为 *students* 的组从组的角度拥有该文件。
- en: 'Let''s now add to that discussion by talking about the second line of this
    output, specifically:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讨论输出的第二行，具体来说：
- en: '[PRE11]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The same principles apply, it's just that we need to discuss a couple of new
    settings. We can clearly see a couple of letters that we didn't mention previously
    – `s` in the group ownership class, and `t` in the others class. What is that
    all about?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的原则适用，只不过我们需要讨论一些新的设置。我们可以清楚地看到一些我们之前没有提到的字母——组所有权类中的 `s`，以及其他类中的 `t`。这是什么意思？
- en: 'The thing is, there are additional, special permissions on top of r(ead), w(rite),
    and (e)x(ecute). These are used for special use cases:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，在读取（r）、写入（w）和执行（x）之外，还有一些额外的特殊权限。这些是用于特殊用例的：
- en: '`sticky bit` – we set this special permission on a folder level. When enabled
    on a folder level, it''s there to protect from accidental file deletion from our
    scenario. For example, `myfile1` is owned by the user `joe`. Although `sarah`
    is the member of the same group (students), which group-owns the file, she still
    can''t delete that file. That''s what the sticky bit is all about.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`粘性位` – 我们在文件夹级别设置这个特殊权限。当在文件夹级别启用时，它可以防止我们场景中的文件被意外删除。例如，`myfile1` 是由用户 `joe`
    所拥有的。尽管 `sarah` 是同一组（学生组）的成员，并且该组拥有文件，但她仍然无法删除该文件。这就是粘性位的作用。'
- en: '`setgid` – we set this special permission on the folder level as well. When
    set on the folder level, this special permission means that all of the newly created
    files (after `setgid` was set) are going to take their group ownership from the
    parent folder. In our scenario, that means that all of the newly created files
    are group-owned by the student group, as requested by the scenario. This is why
    we used the `chgrp` command on the folder level to set folder ownership to students.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setgid` – 我们也在文件夹级别设置这个特殊权限。当在文件夹级别设置时，这个特殊权限意味着所有新创建的文件（在设置了 `setgid` 后）将继承父文件夹的组所有权。在我们的场景中，这意味着所有新创建的文件将由学生组作为组所有者，这符合场景的要求。这就是为什么我们在文件夹级别使用
    `chgrp` 命令来将文件夹所有权设置为学生组。'
- en: '`setuid` – almost never used now, as it''s a security risk. It used to be used
    on files a bit, specifically, so that when files are started by a non-owner user,
    it seems that the user owning the file started it (similar to Run As IDEA in Windows).'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setuid` – 现在几乎不再使用，因为它是一个安全隐患。它曾经在文件上使用，特别是为了让当文件由非拥有者用户启动时，看起来是拥有该文件的用户启动的（类似于
    Windows 中的“以管理员身份运行”功能）。'
- en: These permissions are also set by the `chmod` command, like the first number.
    That's why our `chmod` command had four numbers instead of three – the first number
    is all about special permissions. In general, when we use a three-digit number
    with `chmod`, it expands that to include a zero from the left side.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些权限也是通过 `chmod` 命令设置的，像第一个数字一样。这就是为什么我们的 `chmod` 命令有四个数字而不是三个——第一个数字完全是关于特殊权限的。一般来说，当我们使用三位数与
    `chmod` 时，它会自动扩展，将左侧补充为零。
- en: 'Going back to our recipe, we issued the following command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的案例，我们执行了以下命令：
- en: '[PRE12]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That means that we used `chmod` to set the sticky bit and `setgid` (1+2 equals
    3 on the first digit) on the folder, as well as `rwx` for user and group owners
    (77) and `rx` for others (5).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们使用`chmod`设置了粘滞位和`setgid`（首位数字1+2等于3），以及为用户和组所有者设置了`rwx`（77）权限，为其他用户设置了`rx`（5）权限。
- en: 'The next, more complicated part relates to ACLs. ACLs are most commonly used
    to take care of *exceptions* (regular ACLs) or *permission inheritance* (default
    ACLs). Let''s describe them in a bit more detail. We used the following command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更复杂的部分涉及ACL。ACL通常用于处理*例外情况*（常规ACL）或*权限继承*（默认ACL）。让我们更详细地描述它们。我们使用了以下命令：
- en: '[PRE13]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This means that we want to modify (the `-m` parameter) the ACL on the directory
    called `/share/students`. And we want to modify it so that the group called `professors`
    gets `rwx` (read-write-execute) permissions on that directory. You can clearly
    see why we said that ACLs are most commonly used to treat exceptions. Our scenario
    required that the `/share/students` folder has group ownership of students. We
    can't assign two users to be owners of a directory (there can be only one, (c)
    according to the Highlander movie). So, there's no direct way for us to do that,
    which means we have to use something else to create an exception. That's where
    ACL comes in.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们要修改（`-m`参数）名为`/share/students`的目录上的ACL。我们希望修改它，使得名为`professors`的组对该目录获得`rwx`（读-写-执行）权限。您可以清楚地看到，为什么我们说ACL通常用于处理例外情况。我们的场景要求`/share/students`文件夹具有学生组的所有权。我们不能将两个用户设置为目录的所有者（根据电影《独闯天涯》，只能有一个所有者）。因此，我们无法直接做到这一点，这意味着我们必须使用其他方法来创建一个例外。这就是ACL的作用所在。
- en: 'We could''ve done this differently (not that we should have). We could have
    issued two user-based ACLs for both members of our professors'' group. Those two
    commands would be as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以以不同的方式做到这一点（并不是说我们应该这样做）。我们本可以为我们教授组中的两个成员发布两个基于用户的ACL。这两个命令如下：
- en: '[PRE14]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The trouble with that approach is really simple to understand. Let's say that
    we add five more professors to our system. We then need to issue five more `setfacl`
    commands to set the same ACLs to them. It's just easier to use a group and add
    users to a group. It's a well-known concept that everyone uses on all of the operating
    systems used today.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的问题其实很容易理解。假设我们向系统中添加了五个教授。然后我们需要发布五个`setfacl`命令，为他们设置相同的ACL。使用组并将用户添加到组中显然更简单。这是一个众所周知的概念，所有操作系统今天都在使用。
- en: 'If we wanted to set explicit deny ACL for `others`, we could have used this
    command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为`others`设置显式拒绝的ACL，我们可以使用以下命令：
- en: '[PRE15]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This way, we make sure that all of the members of that `others` class don't
    get access to the folder.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们确保所有属于`others`类的成员都无法访问该文件夹。
- en: 'The second `setfacl` command that we used was as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的第二个`setfacl`命令如下：
- en: '[PRE16]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This command sets a *default ACL*, which is a completely different concept to
    regular ACL we described just before this. Default ACLs are used so that every
    newly created file or folder under a directory (in this case, `/share/students`)
    automatically inherits permissions from the parent folder as set by the default
    ACL. In our scenario, this command means that every single file or folder that
    gets created after we set this default ACL is going to have an ACL set to `g:professors:rwx`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令设置了一个*默认ACL*，这是与我们刚才描述的常规ACL完全不同的概念。默认ACL用于确保每个新创建的文件或文件夹在目录下（在本例中是`/share/students`）自动继承父文件夹的权限，这些权限是由默认ACL设置的。在我们的场景中，这个命令意味着每个在我们设置默认ACL之后创建的文件或文件夹都会被设置为`g:professors:rwx`的ACL。
- en: Clearly, you can see how ACLs and default ACLs are useful, as without them,
    we'd have way less scope to configure more advanced, finely-grained scenarios
    for data access.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，您可以看到ACL和默认ACL是如何有用的，因为没有它们，我们就无法配置更多更复杂、更细粒度的数据访问场景。
- en: Let's now discuss the last important aspect of this scenario – default file
    permissions. We mentioned in the recipe that we need to cover the subject of `umask`.
    Let's do that now.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论这个场景中的最后一个重要方面——默认文件权限。我们在教程中提到，我们需要讨论`umask`的问题。现在我们来讲解这个。
- en: 'If we check the output from one of the previous screenshots, we can see this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查其中一个之前截图的输出，我们可以看到：
- en: '[PRE17]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The question is, why are default permissions `rw-rw-r--`?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，为什么默认权限是`rw-rw-r--`？
- en: The answer to this question is called `umask` (user mask).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案叫做`umask`（用户掩码）。
- en: 'As a concept, `umask` is used specifically for that – to set default permissions
    for newly created files and directories. It can be set by shell configuration
    files, by a user profile, or by a command. Let''s use the `umask` command to explain
    how it does what it does:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`umask`作为一个概念，专门用于此——设置新创建的文件和目录的默认权限。它可以通过Shell配置文件、用户配置文件或命令进行设置。让我们使用`umask`命令来解释它是如何实现这一点的：'
- en: '[PRE18]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can clearly see that as we change the `umask` variable for a user, the default
    permissions for newly created files change. When we used an `umask` value of `0002`,
    the `prof4` file was created with permission `664`. When we used an `umask` value
    of `0022`, the `prof5` file was created with permission `644`. Lastly, when we
    used an `umask` value of `0222`, the `prof6` file was created with permission
    `444`. We could also ignore the leading zero when assigning `umask` in accordance
    with the same principle we used for the `chmod` command.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到，当我们为用户更改`umask`变量时，新创建的文件的默认权限会发生变化。当我们使用`umask`值为`0002`时，`prof4`文件的权限被设置为`664`。当我们使用`umask`值为`0022`时，`prof5`文件的权限被设置为`644`。最后，当我们使用`umask`值为`0222`时，`prof6`文件的权限被设置为`444`。我们还可以按照与`chmod`命令相同的原则，在设置`umask`时忽略前导零。
- en: Mask for files is set to `666`, and for directories, it's set to `777`. So,
    if we want to calculate default permissions for newly created files or folders,
    we just need to subtract the `umask` value from these values (`666` or `777`)
    and get default permissions for files (or folders).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的掩码设置为`666`，目录的掩码设置为`777`。因此，如果我们想计算新创建的文件或文件夹的默认权限，只需从这些值（`666`或`777`）中减去`umask`值，就能得到文件（或文件夹）的默认权限。
- en: 'If we don''t resort to manual configuration, all users'' umask values are set
    by the `/etc/profile` file, which is loaded by default when a user logs in. In
    that file, there''s an `if` statement that looks like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不手动配置，所有用户的`umask`值由`/etc/profile`文件设置，默认情况下在用户登录时加载该文件。该文件中有一个`if`语句，类似于这样：
- en: '[PRE19]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Basically, what this `if`-`then`-`else` structure does is, for all the UIDs
    that are greater than `199`, `umask` is set to `002`, otherwise, it's set to `022`.
    That's why regular users have `umask 002`, while the root user has `umask 022`
    (the root's UID is 0).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这个`if`-`then`-`else`结构的作用是，对于所有大于`199`的UID，`umask`被设置为`002`，否则，`umask`被设置为`022`。这就是为什么普通用户的`umask`是`002`，而root用户的`umask`是`022`（root的UID是0）。
- en: Let's now move to our next recipe, which is all about using commands to manipulate
    text files – commands including `cat`, `cut`, `more`, `less`, `head`, and `tail`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入下一个示例，这一部分完全是关于使用命令操作文本文件——包括`cat`、`cut`、`more`、`less`、`head`和`tail`等命令。
- en: See also
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'If you need more information about file permissions, special permissions, or
    ACLs, we suggest that you visit these links:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于文件权限、特殊权限或ACL的信息，我们建议你访问以下链接：
- en: 'Managing file permissions: `https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/assembly_managing-file-permissions_configuring-basic-system-settings`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理文件权限：`https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/assembly_managing-file-permissions_configuring-basic-system-settings`
- en: 'Linux permissions – SUID, SGID, and sticky bit: `https://www.redhat.com/sysadmin/suid-sgid-sticky-bit`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 权限 – SUID、SGID 和粘滞位：`https://www.redhat.com/sysadmin/suid-sgid-sticky-bit`
- en: 'An introduction to Linux ACLs: `https://www.redhat.com/sysadmin/linux-access-control-lists`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux ACLs 介绍：`https://www.redhat.com/sysadmin/linux-access-control-lists`
- en: Manipulating text files by using commands
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令操作文本文件
- en: Let's now switch our attention to learning about commands that enable us to
    manipulate text files – just for output reasons `head`, `tail`, `more`, `less`,
    `cat`. Some other commands related to the same concepts are going to be covered
    in later chapters, such as [*Chapter 8*](B16269_08_Final_PD_ePub.xhtml#_idTextAnchor178),
    *Using the Command Line to Find, Extract, and Manipulate Text Content*, where
    we discuss more advanced scenarios with text files, such as merging, cutting,
    and using regular expressions with `grep` and `sed` to manipulate text content.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将注意力转向学习操作文本文件的命令——仅为了输出的原因，包括`head`、`tail`、`more`、`less`、`cat`。一些与这些概念相关的其他命令将在后续章节中介绍，例如[*第8章*](B16269_08_Final_PD_ePub.xhtml#_idTextAnchor178)，*使用命令行查找、提取和操作文本内容*，在该章节中我们将讨论与文本文件相关的更高级的场景，如合并、切割，并使用`grep`和`sed`等工具的正则表达式来操作文本内容。
- en: Getting ready
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We still need the same virtual machines as with our previous recipes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要和之前的示例一样的虚拟机。
- en: How to do it…
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s start by using `head` and `tail` command, commands that can be used
    to show the beginning and end of a text file. For example, let''s use the `/root/.bashrc`
    file:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s now check the tail end of the same file:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Unlike `that`, `more` and `less` are used to just display output, but in a
    page-by-page formatted fashion, making a long output much more humanly readable.
    So, when we execute the following command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Or we can execute this command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The expected output from these commands is something like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Using the more and less commands looks very similar'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: to this – page-by-page viewing of text content
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.16_B16269.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.16 – Using the more and less commands looks very similar to this –
    page-by-page viewing of text content
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '`Cat` (the command, not a feline) is completely opposite to the *discipline*
    of `more` or `less` – it just displays the whole file content, without any stoppages.
    This is cool when a text file is short, but mostly useless if that file is long,
    and is one of the most common reasons why we use `more` or `less` commands. So,
    let''s pick a short file and `cat` it, for example, the `/root/.profile` file:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Using the cat command on an appropriate file – a text file'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: that's not too big to fit on one terminal page
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.17_B16269.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.17 – Using the cat command on an appropriate file – a text file that's
    not too big to fit on one terminal page
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '`Cat` can be used for one more thing, which is to combine multiple text files
    into one. This operation is often used when combining multiple log files into
    one to concatenate them. We''re going to discuss this scenario later in this book,
    in [*Chapter 8*](B16269_08_Final_PD_ePub.xhtml#_idTextAnchor178), *Using the Command
    Line to Find, Extract, and Manipulate Text Content*.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`more` and `less` are page viewers – they enable us to display content page
    by page. As we can see in the last line of our example, using these commands didn''t
    *finish* – the command stopped showing the file content after displaying one page
    of that file. Now it''s interactively waiting for us to either continue listing
    file content page by page, do something else (for example, searching by using
    the `/` sign), or quit by using the `q` key.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'The `head` and `tail` commands are named appropriately – they show the head
    (beginning) and the tail (end) of a text file. They can also be used with a variety
    of options to further parametrize the output that we want. For example, if we
    execute the following command:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We're going to get the last 15 lines of that file. The same can be done with
    the `head` command.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Our next topic of discussion is using the `find` command to find files and folders.
    Let's deal with that first and then move on to the next recipes, which are going
    to involve archiving, compression, and dealing with services via `systemctl`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we need to learn more about these commands, we can check the following links:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '`head` man page: [https://man7.org/linux/man-pages/man1/head.1.html](https://man7.org/linux/man-pages/man1/head.1.html)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tail` man page: [https://man7.org/linux/man-pages/man1/tail.1.html](https://man7.org/linux/man-pages/man1/tail.1.html)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`more` man page: [https://man7.org/linux/man-pages/man1/more.1.html](https://man7.org/linux/man-pages/man1/more.1.html)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`less` man page: [https://man7.org/linux/man-pages/man1/less.1.html](https://man7.org/linux/man-pages/man1/less.1.html)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cat` man page: [https://man7.org/linux/man-pages/man1/cat.1.html](https://man7.org/linux/man-pages/man1/cat.1.html)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files and folders
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next topic of the day is to learn to use the `find` command, an incredibly
    useful command. It can be used in a variety of different ways – to find files
    and folders according to specific criteria (permissions, ownership, modified date,
    and others), but also to *prepare data* to be further manipulated *after* the
    `find` command. We'll go through some examples of both principles in this recipe.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to leave our `cli1` virtual machine running. If it's not powered on,
    we need to power it back on.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s use a couple of examples to explain how the `find` command works. Here
    are some examples that we''re going to use:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Finding files in the `/` directory that have permission `2755`
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files in the `/` directory owned by the user `jill`
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files in the `/` directory owned by a group student
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files in the `/` directory with a specific name (for example, `network`)
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files of a specific type (for example, all files with the `php` extension)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding all empty directories
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files that have been modified in the past two hours (120 minutes)
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files that are 100-200 MB in size
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s make these scenarios happen:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To further drive home the importance of this command, let''s use it, as we
    mentioned previously, to *prepare* data to do something *after* we find the necessary
    content. For example, let''s find all files that have the `.avi` extension on
    the whole filesystem and remove them:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command finds all files with the `.avi` extension, puts them in an array,
    and removes them, one by one, by using the `rm -f` command. This is very useful
    if you have users who are abusing corporate resources for unnecessary content.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding files and folders by name is something that we often do. For example,
    let's say that we have a rudimentary shell script that performs a backup and that
    it uses specific criteria to create a list of files that it's going to copy to
    a pre-determined backup folder. If we're doing this kind of operation on a large
    production server with hundreds of users, chances are that there will be a lot
    of new files daily. Using the `find` command makes a lot of sense in these sorts
    of scenarios.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Most commonly, we use the `find` command to locate files (`-type f` option)
    or folders (`-type d` option), and then we narrow our search by using more criteria.
    Criteria such as modification date, user or group ownership, permissions – there
    are a lot of options available. If we look at the `find` command man page, we'll
    quickly become painfully aware of how many options and advanced scenarios can
    be covered by using the `find` command. This is why there's a common way of using
    `find`, which is to start with something such as a file type or extension, and
    then narrow it down further by using other options that we mentioned. If we start
    with that in mind, we'll get to our results quickly.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The next recipe on our plate is related to archiving and compressing files and
    folders. So, let's learn how to use `tar` and its sidekicks, `gzip`, `bzip`, `xzip`,
    and commands alike.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to learn more about Bash reserved variables and PS variables, refer
    to the `Find` command man page: `https://man7.org/linux/man-pages/man1/find.1.html.`'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Archiving and compressing files and folders
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being efficient in terms of how we use disk space is nothing new – it's always
    been around. Yes, we're at a point in history where large capacity hard drives
    and other media is available, but that doesn't mean we can be reckless about it.
    This is the reason why we've been using archiving and compressing for decades,
    and it's a topic that we're going to cover now as well.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to make sure that our `cli1` machine is ready to be used, which will
    make our work on this recipe easy.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go through another scenario-based example to cover all the necessary
    topics. So, this is what we''re going to do in the first part of our recipe:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Create a `tar` archive with the current folder content
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `tar.gz` compressed archive with the current folder content
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `tar.bz2` compressed archive with the current folder content
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `tar.xz` compressed archive with the current folder content
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the second part of our recipe, we''re going to extract these archives:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Extract a `tar`, `tar.gz`, `tar.bz2`, or `tar.xz` archive
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract a `tar`, `tar.gz`, `tar.bz2`, or `tar.xz` archive to a specific folder
    (let's say `/tmp/extract`)
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s say that we''re located in the `/root` directory, and that we want to
    save all of our archives to the `/tmp` directory. This is how we''d do the first
    part of our scenario:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we were creating the `tar.gz` archive, we''d do this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we were creating the `tar.bz2` archive, we''d do this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we were creating the `tar.xz` archive, we''d do this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The second part of our scenario begins by opening an archive. We just need
    to change one `tar` parameter when compared to the first set of examples in our
    scenario and ditch the last part of our command (`.` for the current directory).
    So, we''d need to do this (don''t do this in the real world; this is merely for
    illustration purposes):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Alternatively, we could need to do this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Or we could do this:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Or we could do this:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The problem with this is the location of the output – where''s the output of
    this extraction process going to go? So, the correct way to do this would be as
    follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Alternatively, we could do this:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Or we could do this:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Or we could do this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Again, this depends on the archive type.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '`Tar` has a myriad of other available options, for example, for manipulating
    ACLs and SELinux contexts such as the following:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '`--acls` – Use ACLs when creating an archive'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-acls` – Ignore ACLs when creating an archive'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--selinux` – Use SELinux contexts when creating an archive'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--noselinux` – Ignore SELinux contexts when creating an archive'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot stress how important it is to check the corresponding man page if
    we're looking for something specific. So, we need to make sure that we do.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`tar`, or `Tape ARchiver`, has been around for decades now. Its original use
    case included archiving content on tape, which is how it got its name. Archiving,
    as the manual states, means storing multiple files in a single file. All the other
    options that we use are additional options that have been added over the past
    40+ years, given that it was introduced way back in 1979.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of the parameters used in our examples, we have the following:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '`c` – Create an archive'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` – Extract an archive'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` – Or `--file`, to select an output archive filename'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p` – Option to preserve permissions'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C` – Select an output folder'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`z` – Use `gzip` to compress the `tar` archive'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`j` – Use `bzip2` to compress the `tar` archive'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`J` – Use `xzip` to compress the `tar` archive'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the most frequently used `tar` parameters, which is why we specifically
    selected those for our recipe.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our `tar` recipe, and we're ready to move on to the final recipe
    in this chapter, which is all about managing services by using the `systemctl`
    command. Let's work on that for a bit.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to learn more about the `tar` command, make sure that you refer
    to the `tar` command man page: [https://man7.org/linux/man-pages/man1/tar.1.html](https://man7.org/linux/man-pages/man1/tar.1.html).'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Managing services and targets
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing services tends to be something that we need to do at times. For example,
    when we install a new piece of software that comes bundled as a service, we need
    to be able to manage it so that it can work properly. This is what we're going
    to work on as we go through this recipe. We're also going to give a short description
    of how `systemctl` configuration files work, but without going on a 100 mile-long
    journey, as it's the recipe that's the focus. However, we will make sure that
    we provide you with additional links where you can learn a whole lot more about
    `systemd` as it's a big topic and an important one.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to use our `cli2` CentOS for this recipe, just so that it doesn't
    feel left out.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic idea behind managing services in practical terms is to have services
    start either at the point in time when we want them to be started, or to have
    them available after we boot our Linux server.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'The management of services and targets became quite a bit easier over the past
    couple of releases of any Linux distribution. If you''ve been using CentOS for
    an extended period, you will probably remember upstart, init, and all those beautiful
    things that will remain buried deep in our not-so-fond memories. In terms of the
    management of services, both from the administrative and *development* perspective
    (we''ll get to that in a sec), things became much easier with CentOS 7\. CentOS
    8 follows the same path. There are, and always will be, differing opinions regarding
    the whole idea of `systemd`, but that''s not the subject at hand here. So, let''s
    focus on services and targets. First, we''ll log in as root and type some commands,
    starting with the following:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is going to switch our default boot target to multi-user, which means
    that our CentOS machine is going to be booted to text mode by default. So, after
    we reboot the machine, it''s going to be started in text mode. Then, we''re going
    to switch to using text mode instantly:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is going to kill all the GUI processes, check the service delta between
    `graphical.target` and `multi-user.target`, and do its magic.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing that we''re going to do is, we''re going to pick a service (for
    example, `sshd`), and use the `systemctl` command to manage it – both momentarily
    (manage its state at the time of command execution) and permanently (manage what
    happens with the `sshd` service during system boot). Let''s type in these commands:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The result of these two commands is going to be as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Using systemctl to manage a service – in this case, the SSH
    service'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.18_B16269.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.18 – Using systemctl to manage a service – in this case, the SSH service
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s telling us that `sshd.service` is disabled – Active: inactive (dead).
    We will enable it and check its state by typing the following command:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s check the result of these last two commands:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Checking the state of the SSH service following a configuration
    change'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.19_B16269.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.19 – Checking the state of the SSH service following a configuration
    change
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: We can see that `sshd.service` is now active and ready to accept network connections.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another aspect of this, which is to configure a service so that it''s
    enabled on system boot. If we use `sshd.service` as an example:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Also, if we don''t want `sshd.service` to be enabled on system boot, we can
    do the opposite:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When we deploy a new service, we can start and enable it at the same time.
    For example, let''s say that we just installed the `sshd` service from a package.
    Let''s enable and start it by using one command:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Of course, that pre-supposes that we know the name of any given service, which
    isn't always the case. Let's learn how to overcome this problem in a text mode-driven
    way before we wrap this scenario up with a summary table to make things easier.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to list all of the available services, we can use the following
    command, as `systemd` and `systemctl` *know* more objects than just services (not
    the topic of this scenario):'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When we were going through one of our previous recipes, we discussed `vdo`.
    We can clearly see the `vdo` service listed here. Remember that we started it
    by using the `systemctl` command?
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to check the list of all enabled services, we can use the following
    command:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we need a list of services running currently, execute the following command:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `systemctl` command – because of how it works and the related config files
    (covered in the *How it works…* section a bit later) – can also list service dependencies.
    For example, the `sshd` service needs some other services to be started so that
    it can work. Let''s list the `sshd` dependencies:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Therefore, let''s just create a table with some of the most common service
    names so that we can manage this problem more efficiently:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.1 – A table with details about services and systemd service names'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16269_05_Table1.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.1 – A table with details about services and systemd service names
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the short names of these services (without `.service`) as well as
    the *Tab* key to use Bash shell completion to scroll through options and service
    names in `systemctl`. We can also mask `systemd` services, and therefore make
    them invisible to the system, by linking them from the service start up perspective
    to `/dev/null`:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we can get an idea of how all of this works. The `systemctl` command obviously
    uses some configuration files to do its job. Let's now discuss how and what's
    done.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: We could write books about systemd, but having this specific scenario in mind,
    we need to stick to the job at hand. We used the `systemctl` command to manage
    a service – right now (start/stop/restart), and permanently (enable/disable).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the perspective of purely managing services, the `systemctl` command looks
    by checking into its configuration files. So, let''s check the anatomy of a service
    file for `systemd`, again, using `sshd` as an example:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Systemd configuration file – in this example, SSHD'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.20_B16269.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.20 – Systemd configuration file – in this example, SSHD
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: It's almost readable without a lot of explanation, which is one of the big differences
    between these service files and what was used in the past.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: The first part, which starts with the `[Unit]` section, is related to the general
    settings of the service – with a description and man pages for documentation being
    the first part of that. Then a statement tells us the order; that is, after which
    services should this specific service be started. `Wants` is related to dependencies
    – in this case, which targets need to be enabled for this service to be successfully
    started.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: The `[Service]` section is a bit trickier, as it tells us basic configuration
    details and start up options (the `EnvironmentFile` option), which commands should
    be used for starting and reloading the service, how to kill the service, and details
    related to restarting. Restarting is for selecting if the service will be restarted
    when there's a timeout, kill, or exit from the process service. `RestartSec` is
    about sleep time before the service restart.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: The `[Install]` section is a bit more global and related to how `systemd` works
    with this unit. `WantedBy` is used in the sense of creating additional dependencies
    between this specific service and other services, completely opposite to what
    `[Unit]` statements do.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: This is why, when we change or create new systemd unit/service/whatever files,
    we have to use the `systemctl daemon-reload` command. That command specifies that
    `systemctl` goes through all the config files and treats them as *yes, the administrator
    might have changed something in any of these files, but this is on purpose and
    OK*.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bearing in mind the importance of systemd and its internals, as promised, let''s
    provide our readers with some additional content related to systemd:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'Introduction to systemd: `https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/introduction-to-systemd_configuring-basic-system-settings`'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Managing system services with systemctl: `https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/managing-system-services-with-systemctl_configuring-basic-system-settings`'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with systemd targets: `https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/working-with-systemd-targets_configuring-basic-system-settings`'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with systemd unit files: `https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/assembly_working-with-systemd-unit-files_configuring-basic-system-settings`'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optimizing systemd to shorten the boot time: `https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/optimizing-systemd-to-shorten-the-boot-time_configuring-basic-system-settings`'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Demystifying systemd: `https://www.youtube.com/watch?v=tY9GYsoxeLg`'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
