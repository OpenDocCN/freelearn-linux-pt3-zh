["```\nuser:role:type:level (optional)\n```", "```\n$ sestatus\nSELinux status:                 enabled\nSELinuxfs mount:                /sys/fs/selinux\nSELinux root directory:         /etc/selinux\nLoaded policy name:             targeted\nCurrent mode:                   enforcing\nMode from config file:          enforcing\nPolicy MLS status:              enabled\nPolicy deny_unknown status:     allowed\nMemory protection checking:     actual (secure)\nMax kernel policy version:      33\n```", "```\n    # dnf install httpd\n    # httpd service runs a binary file to start. This file launches from /usr/sbin/.\n    ```", "```\n    # ls -Z /usr/sbin/httpd\n    system_u:object_r:httpd_exec_t.\n    ```", "```\n    # ls -dZ /etc/httpd/\n    system_u:object_r:httpd_config_t.\n    ```", "```\n    # ls -dZ /var/log/httpd\n    system_u:object_r:httpd_log_t.\n    ```", "```\n    # ls -dZ /var/www/html\n    system_u:object_r:httpd_sys_content_t.\n    ```", "```\n    # ls -Z /usr/lib/systemd/system/httpd.service\n    system_u:object_r:httpd_unit_file_t.\n    ```", "```\n    # ps auxfZ | grep httpd\n    ```", "```\n    # netstat -tulpnZ | grep httpd\n    ```", "```\n# ls -Z /etc/shadow\nsystem_u:object_r:/etc/shadow file is shadow_t.\nFrom a basic functional perspective, the web server (`httpd`) *reads and publishes* documents that live within it. Besides the file’s proprietary permissions, security could enhance this through the SELinux policy. With proper proprietary permissions, there would be nothing to prevent the `httpd` service from publishing the file with user passwords.\nWith SELinux policies enabled, no matter what permission level the file has, the policy would *prevent* it from doing so.\nFiles with the `httpd_t` context type can only interact with files *under the same context type*. The password file belongs to a different context type than `httpd_t`; its context is `shadow_t`, thus their *interaction* *is denied*.\nThis is the most basic way SELinux works, and the way the policy works. It is not free of issues, but these are also limited by its nature.\nLet’s see how to determine SELinux errors.\nHow to troubleshoot SELinux issues\nThe popular belief is that it is very difficult to determine and fix SELinux issues. This stems from the fact that the *logs* get logged with the system audit. This log reading is not intuitive and, in fact, to the human eye is quite complex; but it isn’t.\nCarrying on with the example of the `httpd` web server, consider the following sequence of commands:\n\n1.  As the **root** user, create the **myfile** file:\n\n    ```", "```\n\n     2.  Move the **myfile** file to the *web* *content directory*:\n\n    ```", "```\n\n     3.  Use the **curl** command to get the contents of the **myfile** file published by the web server:\n\n    ```", "```\n\n     4.  Observe the output:\n\n![Figure 12.7 – Creating the myfile web file](img/12.7.jpg)\n\nFigure 12.7 – Creating the myfile web file\n\n1.  Use the **grep** command to search for the **myfile** string in the *system* *audit log*:\n\n    ```", "```\n\nAt first glance, it is not very easy to read, but let’s analyze it in parts:\n\n*   **type=AVC**: **AVC Audit Events** generated by the *AVC subsystem* (**AVC** means **Access Vector Cache**) as a result of access denials, or where specific events have requested an **audit** message.\n*   **msg=audit(1689045662.823:264)**: The *timestamp* of the message in **Unix format** (epoch); use the **date** command to determine the time:\n\n    ```", "```\n\n     *   **avc:  denied  { getattr } for  pid=1035**: The result of the **avc** audit event called **denied for** **pid 1035**\n*   **comm=\"httpd\"**: The **httpd** command\n*   **path=\"/var/www/html/myfile\"**: The **var/www/html/myfile** file path\n*   **dev=\"vda3\"**: The **vda3** device\n*   **ino=769948**: Inode identifier\n*   **scontext=system_u:system_r:****httpd_t****:s0**: *Source* context\n*   **tcontext=unconfined_u:object_r:****admin_home_t****:s0**: Target context\n*   **tclass=file**: Target class is a file\n*   **permissive=0**: SELinux permissive mode disabled\n\nThen, the audit message reads as follows:\n*At the described timestamp, an* AVC *event resulted as denied for pid* `1035` *of the* `httpd` *command on the* `/var/www/html/myfile` *file, located on the device and the described inode. The source context type is* `httpd_t` *and the target context type is* `admin_home_t`*. The permissive mode is set* *as disabled.*\nThis indicates that it is an error of the SELinux contexts since they do not correspond and cannot interact with each other. That is, the web server is not allowed to read that file, as indicated by the output of the `curl` command.\nAt first, it looked very complicated, but when analyzing the log, the error stands out at a glance.\nThis is the most common error with SELinux, about contexts that *cannot interact* and whose access is *denied*.\n*What is SELinux trying to* *tell me?*\nLet’s analyze each of them and their solutions or workarounds.\nLabeling\nAs we observed, every process and object in the system has a *label* associated with it. If files are not labeled in the right context, access may be denied. Or, if *alternate or custom paths* get used for confined domains, SELinux needs to know about it.\nLet’s use the following illustrative example.\n`/srv/myweb` are not labeled correctly and the web server cannot access them.\nIn this particular case, a *custom path* to the web server’s content directory appears to be used. To assign the correct label, there are two ways:\n\n*   If you know the correct label, use the **semanage** command to assign it to the policy:\n\n    ```", "```\n\n     *   If you don’t know the correct label, but know a file with the correct label, use the **semanage** command to assign it:\n\n    ```", "```\n\nIn both cases, to restore the context from the policy, use the `restorecon` command:\n\n```", "```\n\n Using the example from the previous section, let’s solve the issue.\n**Labeling issue**: If a file moves, instead of copying it, it keeps its original context.\nTo fix this, use the `chcon` command to change the context:\n\n*   Change the context to the correct label:\n\n    ```", "```\n\n     *   Change the context with a reference label:\n\n    ```", "```\n\nIn the same way as before, for both cases, to restore the context from the policy, use the `restorecon` command:\n\n```", "```\n# semanage port --list | grep -w 80\nhttpd port is httpd_port_t.\nThen, use the `semanage` command to add the `8585` port to the `httpd` policy:\n\n```", "```\n\n Besides these custom configurations, SELinux also offers to change pre-loaded configurations in the policy, turning them on and off.\nThese configurations, known as *Booleans*, allow parts of SELinux policies to get modified at runtime without the need to rewrite the policy.\nFor example, if we want to allow the web server to send mail with the `sendmail` service, *turn on* the Boolean with the `setsebool` command:\n\n```", "```\n# getsebool -a\n```", "```\n# semanage boolean -l\n```", "```\n\n```", "```\n\n```"]