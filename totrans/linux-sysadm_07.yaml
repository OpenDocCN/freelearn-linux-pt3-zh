- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User and Group Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you administer Linux servers, the users of such servers can be both your
    greatest asset and your greatest headache. Throughout the course of your career,
    you will be responsible for the addition of a large number of new users, the management
    of their passwords, the deletion of their accounts when they leave the organization,
    and the provision and revocation of access to resources located across the network.
    Even on servers where you are the sole user, you will still be responsible for
    managing user accounts. This is because even system processes run under the guise
    of a user. If you want to be effective at managing Linux servers, you will also
    need to know how to manage rights, implement password policies, and limit the
    number of people who can execute administrative commands on the computer. In this
    chapter, we’ll go over these topics in detail so that you have a solid understanding
    of how to manage users and the resources they consume.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create users and groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify users and groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete users and groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List all users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a user to a group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove a user from a group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of managing accounts/groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a multi-user operating system, Linux allows for multiple users to be logged
    in and work simultaneously on a single machine. Be aware that it is never a good
    idea to let users share login information for the same account. It is preferable
    to have as many accounts as users who require machine access.
  prefs: []
  type: TYPE_NORMAL
- en: Access to specific system resources, such as directories and files, may need
    to be shared by two or more users. We can achieve both goals using Linux’s user
    and group administration features.
  prefs: []
  type: TYPE_NORMAL
- en: General/normal users and root/superusers are the two categories of users in
    Linux systems.
  prefs: []
  type: TYPE_NORMAL
- en: One of the fundamental components of the Linux operating system is the management
    of user and group accounts. The custom rights of user and group accounts are maintained
    by each user logging in to the operating system using a different set of credentials.
    Adding new users requires specific permissions (superuser); the same holds true
    for other user or group administration operations, including account deletion,
    account update, and group addition and deletion.
  prefs: []
  type: TYPE_NORMAL
- en: 'These operations are performed using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`adduser`: Add a user to the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userdel`: Delete a user account and related files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addgroup`: Add a group to the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delgroup`: Remove a group from the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usermod`: Modify a user account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chage`: This command is used to change the password expiration time and see
    user password expiry information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`passwd`: This command is used to create or change a user account’s password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo`: Run one or more commands as another user (typically with superuser
    permissions by running the `sudo su <``username>` command)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files relevant to these operations include `/etc/passwd` (user information),
    `/etc/shadow` (encrypted passwords), `/etc/group` (group information), and `/etc/sudoers`
    (configuration for `sudo`).
  prefs: []
  type: TYPE_NORMAL
- en: Superuser access is granted by using either the `su` command to become the root
    user or the `sudo su` command to get root privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the default locations for user account information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'User account properties: `/etc/passwd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'User password properties: `/etc/shadow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A group with the same username is also created when a user is created. Every
    user has a home directory; for the root user, it is placed in `/root`; for all
    other users, it is in `/home/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/etc/passwd` file contains all of the account details. This file has the
    following structure and includes a record for each system user account (fields
    are delimited by colons):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s carefully examine the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `<username>` and `<Comment>` fields are self-explanatory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shadowed password (in `/etc/shadow`), which is required to log on as `<username>`,
    is indicated by the `x` in the second field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<UID>` and `<GID>` entries include integers that, respectively, reflect
    the `<usernameprimary>` Group ID and User ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Home directory>` displays the full path to the home directory of the current
    user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user logs in to the system, `<Default shell>` is the shell that is made
    available to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have an overview of the commands used to manage accounts/groups,
    let’s start to play with them.
  prefs: []
  type: TYPE_NORMAL
- en: How to add a new account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two commands, `adduser` and `useradd`, that can be utilized in Linux
    for the purpose of generating new users. The fact that these two commands achieve
    the same thing (albeit in different ways) and have names that are extremely similar
    to one another can make this a bit difficult to understand at first. I’ll begin
    by walking you through the `useradd` command, and then I’ll describe how `adduser`
    works differently. It’s possible that you will prefer the latter option, but we’ll
    discuss that in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Using useradd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need `sudo` capabilities in order to add an account if you don’t have root
    access. This must be defined in `/etc/sudoers`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, here is a working example of the `useradd` command that you can put
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: I set up a new user with the name `packt` by using this command. I am confirming
    that I want a home directory to be established for this user by using the `-d`
    option, and after that, I specified `/home/packt` as the user’s home directory
    in the following command. If I hadn’t used the `-m` parameter, the system would
    not have known that I wanted my home directory to be created while the process
    was running; in that case, I would have had to manually create the directory.
    At the end, I announced the username that will be used for my new user (in this
    case, `packt`). As we progress through this book, we will come across commands
    that, in order to be executed, need root privileges. This was demonstrated in
    the preceding command. I’ll prefix commands that need certain permissions with
    `sudo`, as that is the standard way to accomplish it. When you see this, it simply
    indicates that the command can only be executed with the root user’s rights. You
    can also execute these commands by logging in as root (if root access is enabled)
    or switching to root mode. Both of these options are available to you. However,
    rather than logging in with the root account, it is strongly recommended that
    you use `sudo` instead. I explained this earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command can be used to set a password for the newly created `packt`
    account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Another command is `adduser`, which will create everything automatically for
    you, including the home directory and group, and will ask you to set the password.
  prefs: []
  type: TYPE_NORMAL
- en: Using adduser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `adduser` command is yet another option for establishing a user account,
    as mentioned earlier. When you first use this command, the difference it makes
    (as well as the convenience it provides) should become instantly evident. Execute
    the `adduser` command while providing the username of the new user you want to
    create. Go ahead and give it a shot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is clear from the results that the `adduser` command did a significant amount
    of work for us. The command copied files from `/etc/skel` into our new user’s
    home directory and set the user’s home directory to `/home/packt2` by default.
    The user account was also assigned the next available `1004`. In point of fact,
    the `adduser` and `useradd` commands both copy files from the `/etc/skel` directory;
    however, the `adduser` command is somewhat more detailed in the tasks that it
    executes.
  prefs: []
  type: TYPE_NORMAL
- en: How to delete an account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a user no longer needs access to a system, it is highly necessary to remove
    or disable their account because unmanaged accounts frequently become a security
    concern. This can be done by logging in to the system’s administration panel and
    selecting the `userdel` command in order to delete a user account. However, before
    you go and delete an account, there is one crucial question that you should consult
    with yourself about. Do you (or someone else) anticipate needing access to the
    user’s files in some capacity? The vast majority of businesses have retention
    policies that outline what ought to take place with regard to a user’s data in
    the event that they depart the organization. These files are occasionally duplicated
    and saved in an archive for long-term preservation. It’s not uncommon for a manager,
    a coworker, or a new employee to require access to a previous user’s files, possibly
    so that they can pick up where the previous user left off on a project. Before
    beginning to manage users, it is critical to have a solid understanding of this
    policy. If you do not already have a policy that describes the retention requirements
    for files when users depart the company, it is highly recommended that you collaborate
    with the management team to develop such a policy. The user’s home directory’s
    contents are not deleted when the `userdel` command is used since this behavior
    is not the default. In this section, we will delete `packt2` from the system by
    executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the home folder of the `packt2` user remains.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to remove the home folder once with the account, we need to use
    the `–``r` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Before deleting users’ accounts, remember to check whether the files in their
    home folders are needed. Once deleted, they cannot be recovered if there is no
    backup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In conclusion, deleting a user account in Linux involves backing up data, terminating
    processes, removing the user from groups, deleting the home directory, updating
    system files, and performing a final cleanup. By following these steps, you can
    securely delete an account while managing the associated files and permissions
    effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the/etc/sudoers file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let’s see how to use the ordinary user account we created earlier
    to carry out user administration operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must make a special permissions entry for `packt` in `/etc/sudoers` in order
    to allow it special access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down this line’s syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we state to which user this rule applies (`packt`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All hosts that use the same `/etc/sudoers` file are covered by the rule if the
    first `ALL` is present. Since the same file is no longer shared among different
    machines, this term now refers to the current host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, `(ALL) ALL` informs us that any user may execute any command as the `packt`
    user. In terms of functionality, this is similar to `(``root) ALL`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to manage permissions using groups as it makes life much easier.
    Imagine how simple it would be to just remove a user from a `sudo` group rather
    than removing the user from 100 different places.
  prefs: []
  type: TYPE_NORMAL
- en: Switching users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now prepared to begin using the `packt` account to carry out user administration
    duties. Use the `su` command to switch to that account to accomplish this. Notably,
    if you’re using CentOS or a comparable operating system, you don’t need to use
    the root account moving forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We are able to check the permissions for our newly formed `packt` account by
    using the `sudo` command. Let’s create another account called `packtdemo`, shall
    we?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Changes to the user’s home folder, default shell, and the ability to add a description
    to the user account can all be made with the `usermod` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, the `/etc/passwd` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try to add a description and change the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Changing to an alternate user account is frequently quite beneficial when working
    with support (especially while troubleshooting permissions). Take, for instance,
    the scenario in which a user complains to you that they are unable to access the
    files contained in a particular directory or that they are unable to execute a
    certain command. In such a scenario, you can try to duplicate the issue by logging
    in to the server, switching to the user account of the person having the issue,
    and then attempting to access the given files. In this way, you will not only
    be able to view their issue for yourself; you will also be able to test whether
    your solution resolves their problem before you report back to them.
  prefs: []
  type: TYPE_NORMAL
- en: You can switch to root user by running the `sudo su` or `su –` command, or just
    simply `su`.
  prefs: []
  type: TYPE_NORMAL
- en: '`su` alone switches to another user while maintaining the current environment,
    while `su –` simulates a complete login environment for the target user, including
    setting up their home directory and environment variables and starting a new login
    shell. The choice between the two commands depends on the specific requirements
    or tasks you need to accomplish as the user switched to.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing account passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you remember correctly, the `passwd` command enables us to alter the password
    for the user who is now logged in to the system. In addition, we are able to change
    the password for any user account on our system by running the `passwd` command
    while logged in as root and providing the username. However, that is only one
    of the capabilities of this command.
  prefs: []
  type: TYPE_NORMAL
- en: Locking/unlocking user accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to lock and unlock a user account is one feature of the `passwd`
    command that we have not yet discussed. You can use this command to do either
    of these things. There are lots of different use cases where you need to accomplish
    something like this. For example, if a person is going to be gone for a lengthy
    period of time, you might want to lock their account so that it is inaccessible
    to other users during that time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `-l` option when you want to lock an account. For example, to lock
    the account for the `packt` user, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlock it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Setting password expiration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we will discuss the process of actually carrying out the steps to set
    up password expiration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be more specific, the `chage` command is what enables us to do this. We
    may use `chage` to change the length of time for which a user’s password is valid,
    and it also provides a more user-friendly alternative to reading the `/etc/shadow`
    file in order to view the current password expiration information. By giving a
    username and using the `-l` option of the `chage` command, we are able to view
    the pertinent information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not necessary to run `chage` as `root` or with the `sudo` command. There
    is no need to raise your permission level to be able to view the expiration information
    for your own login. To access information using `chage` for any user account other
    than your own, however, you will need to utilize `sudo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 7.1 – Display the password-related information and aging policies
    for a user account](img/Figure_7.1_B18575.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Display the password-related information and aging policies for
    a user account
  prefs: []
  type: TYPE_NORMAL
- en: 'In the output, we are able to view values such as the date that the password
    will expire, the maximum number of days that can pass before it needs to be changed,
    and so on. It’s basically the same information that’s saved in `/etc/shadow`,
    but it’s formatted in a way that makes it much simpler to understand. If you would
    like to make any modifications to this information, the `chage` tool is once again
    your best option. The first illustration that I’ll give you is a fairly typical
    one. You should absolutely require new users to reset their passwords the first
    time they log in after creating their user accounts for them. Unfortunately, not
    everyone will be interested in doing what has to be done. Using the `chage` command,
    you can require a user to change their password upon their first successful login
    to the system. This is done by changing their total number of days before password
    expiration to `0` in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And the results compared with the previous output look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 7.2 – Display the password-related information and aging policies
    for a user account](img/Figure_7.2_B18575.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Display the password-related information and aging policies for
    a user account
  prefs: []
  type: TYPE_NORMAL
- en: 'The following instructions allow you to configure a user account so that it
    will demand a new password after a particular number of days have passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, I am configuring the user account to become invalid
    after 90 days and to demand a new password at that time. When the user logs in,
    they will be presented with a warning notice seven days before the password has
    to be changed. This is the message that will appear seven days before the password
    expires:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Display the password-related information and aging policies
    for a user account](img/Figure_7.3_B18575.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Display the password-related information and aging policies for
    a user account
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice to set a password expiration policy for security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Group management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how to make new user accounts, manage existing user accounts,
    and switch between user accounts, we need to learn how to manage groups. Linux’s
    implementation of the concept of groups is not all that dissimilar to that of
    other operating systems, and it essentially performs the same function. Controlling
    a user’s access to the resources on your server can be done more effectively with
    the help of groups. You can grant access to users or deny access to users by simply
    adding them to or removing them from a group that has been assigned to a resource
    (such as a file or directory). This is made possible by assigning a group to the
    resource in question. The way that this is handled in Linux is such that each
    and every file and directory has both a user and a group that claims ownership
    of it. When using Linux, ownership is assigned on a one-to-one basis, meaning
    that each file or directory has just one user and just one group associated with
    it. You can verify this for yourself on a Linux system by listing the items included
    within a directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 7.4 – Listing the contents of a folder](img/Figure_7.4_B18575.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Listing the contents of a folder
  prefs: []
  type: TYPE_NORMAL
- en: 'You only need to use the `cat` command to read the contents of the `/etc/group`
    file if you are interested in discovering which groups are currently active on
    your server. The `/etc/group` file, much like the `/etc/passwd` file that we went
    over before, stores information regarding the groups that have been created on
    your system. Feel free to take a look at this file, which is located on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a group, use the `sudo addgroup <``groupname>` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the content of the file, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure of each line is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Examining the previous syntax, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the group is `<``Group name>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group passwords are not used if there is an `x` next to `<``Group password>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Group members>` is a list, separated by commas, of users who are members
    of `<``Group name>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `sudo delgroup <groupname>` command to remove a group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line in the `/etc/group` file containing group information contains the
    group name and the user accounts connected to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we’ll have a look at the `usermod` command, which is what actually allows
    you to associate users with groups and is the next topic on our agenda. The `usermod`
    command can be used for a variety of purposes and has a wide range of applications
    (adding a user to a group is just one of its abilities). In the event that we
    want to include a user (`packt`) in our `packtgroup` group, we would issue the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `-aG` option is used to add a user to a specific group. The `-a` flag means
    *append*, which means that the user will be added to the group without removing
    them from any other groups they may already be a member of. The `G` flag specifies
    the group name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to modify the primary group that a user belonged to, you would
    use the `-g` option instead (note that it is written with a lowercase `g` rather
    than an uppercase `G`, as we did earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Groups are the easiest way to manage security permissions. Imagine removing
    one user from a group assigned to 100 resources rather than removing the user
    100 times.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Linux, each file, directory, and other system object has a designated owner
    and group. This is the most fundamental aspect of system security that safeguards
    users from one another. Different sorts of access to read from, write to, or execute
    files can be given to owners, group members, and everyone else. In Linux, these
    are commonly referred to as file permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands are used to manage ownership and set permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: Change file permissions with `chmod`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the file owner with `chown`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change group ownership with `chgrp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print the user and group IDs with `id`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Typically, the user who created a file is its owner, and the group attached
    to that owner is its primary group (at least initially). Let’s create a `testfile`
    file in the `/tmp` directory as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first character of the output shows that `testfile` is a normal file (that
    is, not a directory or other type of system object). The next nine characters
    (split into three sets of three characters each) show the read (`r`), write (`w`),
    and execute (`x`) permissions for the system’s owner, group owner, and other users.
  prefs: []
  type: TYPE_NORMAL
- en: The first three characters (`rw-`) show that the file’s owner (user `packt`)
    can read and write to it. The next three characters show the same thing concerning
    the group owner. The last set of characters (`r—`) mean that other users can only
    read that file; they can’t write to it or run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use `chmod` to modify a file’s permissions. A symbolic representation
    indicating to whom the new permissions will applied must come after this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`u` means user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g` means group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`o` means all other users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a` means all users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The types of permission are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+r` adds read permission'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r` removes read permission'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+w` adds write permission'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-w` removes write permission'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+x` adds execute permission'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-x` removes execute permission'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+rw` adds read and write permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+rwx` adds read, write, and execute permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these permissions can be expressed numerically as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read – `4` : Write – `2` : Execute – `1`'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `chmod 754 testfile` will be translated as `rwx` permissions on
    `testfile` for the owner, `rx` for the group, and only `r` for everyone else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To sum up, giving correct permissions is critical for security reasons and
    to avoid causing any unwanted damage. Following is an example of viewing the permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Listing the contents of a folder and their permissions](img/Figure_7.5_B18575.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Listing the contents of a folder and their permissions
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, giving correct permissions is critical for security reasons to prevent
    any unwanted activity on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Changing groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `chgrp` command will be discussed now in the context of making `packtgroup`
    the new owner of `testfile`. After the command, we specify the name of the group
    and the name of the file whose ownership is to be changed (in this case, `testfile`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s check the ability of user `packtdemo` to write to this file now. A permission
    refused error should appear for the user. We can set the relevant permissions
    for the group to allow `packtdemo` to write to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use `usermod` once more to add the account to `packtgroup`, this time
    using the `-aG` combined option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The abbreviation for *append to group* is `-aG`.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, `packtgroup` is referred to as a subsidiary or auxiliary group for
    user `packtdemo`. When `packtdemo` next logs in, the updated access permissions
    will be active.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `chown` followed by the usernames and filenames, in that order,
    to make `packtdemo` the owner of `testfile` rather than just adding the user to
    the `packtgroup` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the aforementioned command will prevent the `packt` user from
    accessing `testfile` because such an account is no longer the file’s owner or
    a member of the `packtgroup` group.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the typical `rwx` file permissions, `setuid`, `setgid`, and the sticky
    bit are three additional permissions that merit addressing. Let’s look at them
    one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Any user may run an executable file if the `setuid` bit is set on the file,
    utilizing the owner’s permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Any user may run an executable file when the `setgid` bit is set on the file,
    using the group’s rights.
  prefs: []
  type: TYPE_NORMAL
- en: 'When misused, these specific rights present a security risk. For instance,
    if any user is permitted to run a command with superuser capabilities, that user
    will be able to access files that belong to root as well as to other users. It
    is simple to understand how this might quickly wreak havoc on a system: crucial
    files may be deleted, individual directories could be completely erased, and even
    hardware could end up acting erratically. All of this can be brought about by
    a single wicked or careless person. The `setuid` and `setgid` bits must therefore
    be used with extreme caution.'
  prefs: []
  type: TYPE_NORMAL
- en: In `/usr/bin/passwd`, the `setuid` bit is required and is an acceptable use
    case. Although root owns this file, any user can change their own password by
    using it (but not that of other users).
  prefs: []
  type: TYPE_NORMAL
- en: When the sticky bit is set on a directory, no one other than the owner, the
    directory’s owner, or root can delete files from that directory. This is commonly
    used to prevent a user from erasing the files of other users in a shared directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setuid` bit is set for `testfile` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setgid` bit is set for `testfile` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a directory named `packtdir` and set the sticky bit on it, use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to `/etc/sudoers`, we can also grant superuser access to every user
    in a group by using the `/etc/sudoers` file. For instance, the following command
    specifies that users who belong to `packtgroup` are permitted to run `updatedb`
    (or more specifically, `/usr/bin/updatedb`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The group name must be preceded by the `%` sign, which is the only distinction
    between group members and individual users. In this situation, command aliases
    are also applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Simply type `sudo -l` in the command line and hit *Enter* to display the calling
    user’s permitted commands in `/etc/sudoers`.
  prefs: []
  type: TYPE_NORMAL
- en: Using groups can save a lot of time. Imagine assigning one group permissions
    to run some commands, rather than 100 users one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing users and permissions is something that will be required of you very
    frequently in sectors related to Linux administration, such as system administration
    and network security. This is something that will become embedded in your mental
    toolkit as new users join your organization while others depart. However, even
    if you are the only person who uses your servers, you will still need to manage
    permissions. This is due to the fact that processes are unable to run properly
    if they are denied access to the resources that they require in order to do their
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we dove deep into the process of managing users, groups, and
    permissions and covered a lot of ground. We proceeded through the process of creating
    new users, removing existing users, assigning rights, and managing administrative
    access with the `sudo` command. Put these ideas into practice on your own server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about software installation and package repositories.
  prefs: []
  type: TYPE_NORMAL
