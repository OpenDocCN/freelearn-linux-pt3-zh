- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DevOps Automation Tools – Terraform, Ansible, Packer, and More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What good is an operating system if it doesn’t cater to developers? After all,
    an operating system that’s easy to develop on tends to enjoy a much stronger ecosystem
    than one that does not. You’ll be happy to learn that Oracle Linux plays very
    nicely with developers, and this chapter is all about common development tools
    that will make your life easier when setting out to work on your next project.
  prefs: []
  type: TYPE_NORMAL
- en: There are countless development tools that work well on Oracle Linux, but the
    ones we’re focusing on in this chapter are all about automation. We’ll be talking
    about automating cloud infrastructure, automating the operating system build cycle,
    automating system administrators’ tasks, and automating the launching of virtual
    machines for development purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Do it once manually – rinse and repeat with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating portable roles for Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing secrets with Ansible Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cooking up the perfect lab environment with Vagrant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Packer to modify source images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pack it up, pack it in, let me begin, err, umm… build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re covering a lot of technologies in this chapter. Let’s prepare your machine
    so that you can conveniently follow along with the recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Oracle Linux 8, we can install Ansible by leveraging the **Oracle Linux
    Automation Manager** repository, so let’s install the repository first, and then
    we’ll install Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Packer, Vagrant, and Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Packer is a tool used for automating the creation of machine images, Vagrant
    is used for managing the lifecycle of virtual machines, and Terraform is an infrastructure-as-code
    tool. Packer, Vagrant, and Terraform are all products of HashiCorp, but they work
    well on Oracle Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to install Packer, Vagrant, and Terraform directly from HashiCorp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that’s finished, let’s go ahead and install **Oracle VM VirtualBox**,
    as we’ll be using VirtualBox with **Packer** and **Vagrant**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Finally, along with Terraform, we’ll also want to create an **Oracle Cloud Infrastructure**
    (**OCI**) account. If you prefer, you may opt to use a different cloud, but use
    OCI if you want to follow this tutorial directly.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to remember your Cloud Account Name as this is an important detail required
    in order to access your OCI account.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The source code for the recipes in this chapter can be found at [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8).
  prefs: []
  type: TYPE_NORMAL
- en: Do it once manually – rinse and repeat with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terraform is an **infrastructure-as-code** (**IaC**) tool that lets you build,
    change, and version infrastructure safely and efficiently. This recipe will provide
    a general overview of a good technique for automating the *ugly* with **Terraform**.
    What do I mean by *ugly*? Well, it’s anything that’s being done manually. We want
    to cut out the manual steps and automate as much as possible. In the case of Terraform
    specifically, this means we’re going to automate the deployment of cloud infrastructure.
    Thanks to Terraform, we no longer need to click around through a hundred different
    menu settings. Instead, we’re going to define our **infrastructure as code**.
    This results in faster and more consistent deployments. Additionally, it’s also
    much easier to make changes to your infrastructure since it can all be edited
    via code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the following for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Technical requirements* section at the beginning of this chapter
    if you need help installing Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any time you set out to automate something, it’s always a good idea to have
    a solid grasp on what needs to be done under the hood. Can you guess what that
    means? Yep, you’ve got to perform all the manual steps at least once before trying
    to automate it.
  prefs: []
  type: TYPE_NORMAL
- en: First, do it once manually…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The goal for this recipe is to use Terraform to deploy a simple VM in the cloud.
    It’s an easy enough task, but before we jump into how this can be done using code,
    it’s generally best to do it manually first. So, with that being said, let’s go
    ahead and deploy a virtual machine using the OCI web GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the Oracle Cloud Infrastructure Console ([https://cloud.oracle.com/](https://cloud.oracle.com/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.1 – OCI Console Login Page](img/B18349_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – OCI Console Login Page
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the hamburger menu icon at the top left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.2 – OCI Console main screen](img/B18349_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – OCI Console main screen
  prefs: []
  type: TYPE_NORMAL
- en: 'Then click on **Compute** | **Instances**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – OCI Cloud Compute menu](img/B18349_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – OCI Cloud Compute menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify you are in the desired **Compartment**, and finally, click on **Create
    instance**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – OCI Cloud Compute Instances](img/B18349_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – OCI Cloud Compute Instances
  prefs: []
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: For brevity, when multiple menu items need to be clicked, the pipe symbol (|)
    indicates the sequence in which to click buttons/links.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to use the default Oracle Linux image, but if you want to change
    this, you can go to **Image and shape** and click on **Edit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – OCI Console Compute Image and shape](img/B18349_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – OCI Console Compute Image and shape
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There’s no cost as long as you stick to all **Always Free-eligible** resources;
    however, at the time of writing, there is a bug that falsely shows a $2.00 per
    month charge for the boot volume. This is a bug as the boot volume uses block
    storage and OCI gives you up to 200 GB of block storage for free.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the latest version is *Oracle Linux 8* (image build:
    2023.06.30-0).'
  prefs: []
  type: TYPE_NORMAL
- en: Under **Add SSH Keys**, select **Generate a key pair for me** and then click
    on **Save Private Key** and **Save** **Public Key**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Choose a place that is easy for you to remember, as you’ll need this later when
    you seek to SSH into your VM.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, click on **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to grab a coffee while waiting for the image to build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use SSH to connect to the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: On the **Instance information** tab, click on **Copy** next to the **Public
    IP** **address** entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up a terminal application and use the `ssh` command to connect. We’ll
    use `-i` (where `i` stands for identify file) to reference the private key we
    saved in the previous steps. The default username for official Oracle Linux instances
    hosted in the OCI is `opc`, so we’ll instruct `ssh` to connect as `opc`. Finally,
    input the **Public IP address** you obtained in the previous step. Your command
    should look a bit like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.6 – SSH into compute instance (failure)](img/B18349_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – SSH into compute instance (failure)
  prefs: []
  type: TYPE_NORMAL
- en: 'Uh oh! Did you notice the big warning, as well as that last message? We were
    denied access because of bad permissions. Let’s fix that using `chmod` to give
    only the owner permission to access the key file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18349_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – SSH into compute instance (success)
  prefs: []
  type: TYPE_NORMAL
- en: Great! We’ve connected to the machine via SSH.
  prefs: []
  type: TYPE_NORMAL
- en: Now I do realize that this wasn’t all that difficult, but imagine if you had
    to do this a hundred times? Why not automate the process with Terraform?
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to rinse and repeat with Terraform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This time around, we’re going to accomplish the exact same thing that was described
    earlier – that is, we’re going to create another virtual machine in OCI. However,
    this time around, we’re going to define our IaC using Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create three new files within the root of your project directory
    (I’m naming this one `terraform`) using your favorite code editor, and name them
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`main.tf`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`variables.tf`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`terraform.tfvars`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let’s head to the Terraform Registry ([https://registry.terraform.io/](https://registry.terraform.io/))
    to find the provider for **Oracle Cloud** **Infrastructure** (**OCI**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Terraform Registry, search for either `oci` or `oracle cloud infrastructure`
    and select **oracle/oci**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can click on **Browse Providers** and then click on the **Oracle
    Cloud** **Infrastructure** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on `main.tf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Terraform OCI provider](img/B18349_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Terraform OCI provider
  prefs: []
  type: TYPE_NORMAL
- en: Notice the comment for `# Configuration options` under the `provider "oci"`.
    This tells us we may need to supply some configuration options in order to use
    the provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s take a look at how to do this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Documentation** tab (it’s right next to **USE PROVIDER**), then
    find the link on **How to configure** **the provider**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You’ll find that the OCI Terraform provider supports four authentication methods:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**API Key** **Authentication** (default)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance** **Principal Authorization**'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource** **Principal Authentication**'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security** **Token Authentication**'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For this recipe, I’ll be using the default authentication method; that is, **API
    Key Authentication**. This method has the fewest limitations, but depending on
    your use case, you can choose the one that best meets your needs.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: There’s no shortcut to providing the authentication details; however, for some
    helpful guidance, you may want to reference the `oci-provider-conf.md` file in
    the GitHub repository associated with this recipe. If you want greater details,
    I recommend working through the documentation described in the **How to configure
    the provider** section referenced earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decided to use `provider "oci"` in the `main.tf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.9 – API key authentication details](img/B18349_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – API key authentication details
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep things clean, we’re going to reference variables for these
    values. I will provide more details on how to define/declare variables later in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate that we’re adding to a file, I am using three series of three
    dots. This is meant to represent a continuation of what we did in the previous
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`...`'
  prefs: []
  type: TYPE_NORMAL
- en: '`...`'
  prefs: []
  type: TYPE_NORMAL
- en: '`...`'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve got our provider set up, it’s not going to do much unless we
    add a resource. In this case, we want to add an `oci_core_instance`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you recall when we generated an SSH key pair during the manual process? Well,
    now we need to figure out a way to do this dynamically using code. The following
    instruction is how we can do this using Terraform. We’ll create a `tls_private_key`
    resource, and reference that as our `ssh_authorized_keys` under the metadata for
    the `oci_core_instance` resource.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s start with the SSH key pair, which is created with the `tls_private_key`
    resource. Details on this resource can be found under the `hashicorp/tls` provider
    on the Terraform registry. Continue to edit the `main.tf` file, and add the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Defining SSH key pair with Terraform](img/B18349_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Defining SSH key pair with Terraform
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need to define a valid availability domain. One way to do this is by
    using Terraform to query a list of availability domains and reference one of the
    items from that list, so let’s add the following code to the `main.tf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Getting a list of availability domains using Terraform](img/B18349_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Getting a list of availability domains using Terraform
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’re going to add a resource for `oci_core_instance`. If you review
    the `oci_core_instance` resource from the `oracle/oci` provider on the Terraform
    registry, you’ll see a long list of parameters that can be used to define the
    `oci_core_instance` resource; however, not everything from this list is required
    as many of the parameters are preceded with `#Optional`. For this recipe, we’re
    going to use the bare minimum that is required for this resource – so that should
    look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – OCI Core instance resource details](img/B18349_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – OCI Core instance resource details
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are finished with the `oci_core_instance` resource, your entire `main.tf`
    file should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Contents of main.tf file](img/B18349_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Contents of main.tf file
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to declare all of those variables we referenced throughout the `main.tf`
    file. In order to keep things organized, let’s put them in the `variables.tf`
    file. Each variable should, at a minimum, contain a type; however, we’ll also
    add a description to explain the purpose of the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Input the following into your `variables.tf` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Declaration of variables in the variables.tf file](img/B18349_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – Declaration of variables in the variables.tf file
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we would want to assign values to the variables. For this, you can
    use the `terraform.tfvars` file. It should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Content of terraform.tfvars file](img/B18349_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – Content of terraform.tfvars file
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Reference the following guide to find the *ocid* for `tenancy_ocid`, `compartment_ocid`,
    `user_ocid`, `fingerprint`, `subnet_ocid`, and `private_key_path`: [https://docs.oracle.com/en-us/iaas/Content/API/SDKDocs/terraformproviderconfiguration.htm](https://docs.oracle.com/en-us/iaas/Content/API/SDKDocs/terraformproviderconfiguration.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the OCID for Oracle Linux 8, visit the following link: [https://docs.oracle.com/en-us/iaas/images/oracle-linux-8x/](https://docs.oracle.com/en-us/iaas/images/oracle-linux-8x/)
    is region specific as well as architecture specific, so you’ll want to find the
    latest Oracle Linux 8 image for x86 (or in other words, look for one without the
    `aarch64` text in the image name).'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Just be sure to add the `terraform.tfvars` file to your `.gitignore` list to
    avoid checking any sensitive information into version control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s run Terraform to see if we did everything correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you get a `401-NotAuthenticated` error, make sure you’ve added your public
    key to the OCI console. This is the public key that pairs with `private_key_path`
    under the *API Key* *Authentication* method.
  prefs: []
  type: TYPE_NORMAL
- en: For help with adding your public key to the OCI console, visit [https://docs.oracle.com/en-us/iaas/Content/API/Concepts/apisigningkey.htm#three](https://docs.oracle.com/en-us/iaas/Content/API/Concepts/apisigningkey.htm#three).
  prefs: []
  type: TYPE_NORMAL
- en: 'If all goes well, you should be able to watch as your resources are created.
    Once this is complete, you’ll see a message like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 8.16 – Terraform code that outputs connection details](img/B18349_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – Terraform code that outputs connection details
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have that in place, save your file and run `terraform apply` once
    more to see what this does:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Terraform will do its thing, and at the end, you’ll see output that provides
    instructions on how to SSH into the newly created instance. That should look a
    bit like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Output of “terraform apply”](img/B18349_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 – Output of “terraform apply”
  prefs: []
  type: TYPE_NORMAL
- en: I realize that what we have just covered seems like a lot of information, but
    let’s consider what we’ve done here. We automated the deployment of an instance
    into the cloud. Every parameter is easily configurable within our `terraform.tfvars`
    file. Finally, trivial steps including generating SSH keys are also automated,
    and we even print a statement at the end that clearly instructs how to connect
    to the newly deployed instance. I hope you enjoyed this recipe and are starting
    to see the true value of **IaC**!
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this recipe can be found at [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/terraform](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/terraform).
  prefs: []
  type: TYPE_NORMAL
- en: Creating portable roles for Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before attempting to follow this recipe, I recommend having some basic knowledge
    of Ansible and how to write an Ansible playbook. If you’ve never written an Ansible
    playbook, I recommend following the *Creating a playbook* guide from the official
    Ansible documentation. That can be found here: [https://docs.ansible.com/ansible/latest/getting_started/get_started_playbook.html](https://docs.ansible.com/ansible/latest/getting_started/get_started_playbook.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how easy it is to move things around when using
    **Ansible roles**. When I first started using Ansible, I wrote my playbooks using
    *tasks* only. This to me seemed like a logical approach at the time and was more
    akin to traditional scripting since everything happened in chronological order.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with writing playbooks in this way is there are no clear dependencies,
    and the tasks are defined along with the hosts, all in the same file. If you wanted
    to move things to another playbook, you’d have to be careful to grab the correct
    dependencies with each task, and you may be repeating yourself unnecessarily since
    tasks on their own are not reusable. As your playbooks become more complex and/or
    increase in size, you’ll eventually want something more portable for the sake
    of manageability.
  prefs: []
  type: TYPE_NORMAL
- en: According to Red Hat, roles are designed to be *self-contained portable units*
    *of automation.*
  prefs: []
  type: TYPE_NORMAL
- en: Organizing your tasks into roles will allow you to easily reuse them and share
    them with others. In fact, if you visit Ansible Galaxy ([https://galaxy.ansible.com/](https://galaxy.ansible.com/))
    you will find plenty of content in the form of *pre-packaged units of work referred
    to in Ansible as roles and collections.* It’s much easier to reuse and share Ansible
    roles as organized units of automation because they are decoupled from the rest
    of the Ansible playbook framework.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a programmer, you can think of roles as functions or methods. Easy
    enough? Let’s get cooking!
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Technical requirements* section at the beginning of this chapter
    if you need help installing Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s not difficult to convert a series of tasks into roles. It’s really just
    a matter of stripping out the tasks and organizing them into categories that represent
    a role. This recipe aims to describe that process, and hopefully by the end, you
    will have a good understanding of how to do the same with your playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Original playbook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To kick things off, let’s first take a look at a playbook that doesn’t leverage
    roles so we can dive into what needs to be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical playbook that does not leverage roles looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Long playbook without roles](img/B18349_08_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.18 – Long playbook without roles
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The screenshot fades out at the end because it’s a long playbook and the entire
    contents of the playbook are not important.
  prefs: []
  type: TYPE_NORMAL
- en: This playbook automates several tasks. First, it creates a standard user if
    they do not already exist, then it installs Podman via the container-tools AppStream
    module, after which it launches an NGINX container, and then eventually it proceeds
    to upgrading all the packages on the system and checking whether the system needs
    to be rebooted.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from this example, if you write all your tasks directly into
    a playbook, it doesn’t take long for that file to become massive and unwieldy.
    Before long, you will find yourself repeating preparatory tasks throughout, and
    you’ll most likely add hash marks at the beginning of each line for unnecessary
    tasks, which will make the automation engine see it as a comment rather than code
    – you might even find yourself toggling between disabling and enabling tasks in
    order to target a specific task when running the playbook. This can become overwhelming,
    and if you’re not careful, you might end up removing bits of code when you don’t
    need them (even though sometimes, you might need them). Roles offer a better way
    to organize your playbooks. In fact, you can write as many roles as you want,
    and neatly call them in the playbook – this makes the playbook far easier to read
    and maintain over time.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Ansible, roles are organized under the `roles` directory. You create a folder
    under `roles`, and whatever you name the folder will become the name of the role.
    Then within that folder, you create a minimum of one folder called `tasks`, which
    should contain a `main.yml` file defining the primary tasks that the role will
    perform:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break things up and create a role for our users by creating a `users`
    folder in the `roles` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your directory structure should look a bit like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, create a `main.yml` file in the `tasks` directory, and let’s port our user-related
    tasks over into that file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Ansible role for provisioning users](img/B18349_08_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.19 – Ansible role for provisioning users
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have the beginnings of a role. We can take advantage of other features
    to facilitate pre-configuration operations. Here are two features that I tend
    to use most often – `files` and `meta`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, you’ll notice we are referencing a `files` directory. That is a special
    directory that belongs to a role, and contains files related to that role.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The other is a `meta` directory that acts as a way to declare dependencies.
    For example, since the `users` role depends on certain groups to exist, it may
    be a good idea to make this role dependent on the `groups` role first. To do this,
    we can simply create a role for `groups` and then call this role from the `meta`
    directory.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `groups` role may look like the following. Notice the directory structure,
    along with the accompanying files – all of which are elements that make up a role.
    Your directory structure should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The actual task should be written in the `main.yml` file with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Ansible role for user groups](img/B18349_08_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.20 – Ansible role for user groups
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `meta/main.yml` file for the `users` role, we just need to call
    the `groups` role as a dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, run the playbook with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have successfully created a role within Ansible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, repeat this process until you have everything organized into roles. For
    me, I ended up with the following directory structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New and improved playbook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As for the actual playbook itself, it can now be simplified to just the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Ansible playbook leveraging roles](img/B18349_08_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.21 – Ansible playbook leveraging roles
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are not listing out the `base_software` and `groups` roles in
    the playbook as these are dependencies we have defined under the `meta` directories.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, instead of `tasks`, we are now simply referencing `roles`. It
    is very neat and organized, and much easier to understand what the playbook is
    set out to do. If you want to understand what a specific role does, all you need
    to do is look into the `roles` directory for the name of the respective role and
    examine the `main.yml` file in the role’s `tasks` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re ready, run the playbook just as you normally would:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If all went well, it should have accomplished everything that was being done
    in our original playbook; however, this time around we are using Ansible roles,
    and thus our playbook will be far easier to maintain going forward.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this recipe can be found at [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/ansible-roles](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/ansible-roles).
  prefs: []
  type: TYPE_NORMAL
- en: Managing secrets with Ansible Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe aims to provide guidance on leveraging **Ansible Vault** for *secrets
    management*.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways to store secrets in Ansible. When starting out, you
    may be inclined to encrypt the entire `hosts` file. This works and keeps everything
    secure in the context of using a version control system without compromising your
    secrets/passwords; however, it is not manageable, nor does it provide any useful
    information in version control systems because all you’re left with is a long
    nonsensical string of encrypted characters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the following for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Technical requirements* section at the beginning of this chapter
    if you need help installing Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s take a look at whole-file encryption. To begin, we’ll first need
    to define our Ansible host file in plain text.
  prefs: []
  type: TYPE_NORMAL
- en: Whole-file encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Typically, an Ansible hosts file will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can encrypt the file by running the following into the terminal/console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: I am using a randomly generated string as my vault password.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to encrypt the file is to use a `vault_password` and paste only
    the vault password into it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It’s a good idea to set the permissions to `0600` on the `vault_password` file
    (this can be done by running `chmod 0600 ./vault_password`) so it’s protected
    from other users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, instead of using `--ask-vault-pass`, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Cool! Just be sure to add the `vault_password` file to your `.gitignore` list
    to avoid checking that into version control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if you `cat` your `hosts` file, you will see the contents are encrypted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – Contents of encrypted “hosts” file](img/B18349_08_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.22 – Contents of encrypted “hosts” file
  prefs: []
  type: TYPE_NORMAL
- en: 'This is great, but anytime you need to make changes to the `hosts` file, you
    are faced with two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Decrypt the `hosts` file, make your changes, then encrypt it again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `ansible-vault edit hosts` to leverage ansible-vault’s *vim* mode to edit
    the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These aren’t terrible options, but in practice this can become cumbersome. I
    propose a better way, which is to use the `encrypt_string` method within Ansible
    Vault to encrypt only the sensitive data, and use variables in place of passwords/secrets
    to reference those encrypted strings.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding passwords in plain sight
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hiding passwords in plain sight is in direct contrast to the whole-file encryption
    we described previously. We’re still going to encrypt our sensitive data, but
    this time around we’ll encrypt *only* the sensitive data, and leave everything
    else in plain, unencrypted text:'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `encrypt_string` method. In this example, the password we want
    to encrypt is `B@by-Y0dA` and we will name the variable that identifies this password
    as `admin_password`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 8.23 – Encrypting secrets](img/B18349_08_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.23 – Encrypting secrets
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to copy the output of that into a `secrets.yml` file (you could
    just append `>> secrets.yml` to the command entered previously to automatically
    copy the output to the file). Here''s an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 8.24 – Contents of secrets.yml file](img/B18349_08_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.24 – Contents of secrets.yml file
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You may notice the encrypted value is different every time you run the command,
    even when you encrypt the same value using the same password. The random salt
    changes each time you encrypt it; this is by design, and the intent is to ensure
    that the final encrypted output is never the same (even when using the same content).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have it encrypted, you can replace the `ansible_password` value
    in your host file with the name of the variable that references the password (in
    this case, `admin_password`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of **variable-level encryption** is that files can still easily
    be read and understood because there will be a mixture of plaintext alongside
    the encrypted variables.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this recipe can be found at [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/ansible-vault](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/ansible-vault).
  prefs: []
  type: TYPE_NORMAL
- en: Cooking up the perfect lab environment with Vagrant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recently at work, I was tasked with preparing a demo of **Oracle Linux Manager**
    and showcasing several features of the software. This is an easy enough thing
    to do, but there are several barriers to entry that stand in the way before you
    can access the web GUI for Oracle Linux Manager.
  prefs: []
  type: TYPE_NORMAL
- en: For starters, Oracle Linux Manager requires Oracle Linux 7; it’s not yet certified
    on Oracle Linux 8\. So, I set out to download the ISO for Oracle Linux 7 and proceeded
    to create a VM in VirtualBox and installed the OS. I then wanted to SSH into the
    box, so I had to go into the settings menu for that VM and configure port forwarding
    from the host to the guest. At this point, I was able to SSH in, and then followed
    the installation instructions for Oracle Linux Manager. It’s not that bad setting
    things up, but there were several speed-bumps along the way. For instance, I needed
    to decide on a database to use. Oracle supports only Oracle Database for use with
    Oracle Linux Manager, but for the sake of brevity (and since this was only ever
    intended as a lab demonstration of Oracle Linux Manager), I decided to use **PostgreSQL**.
  prefs: []
  type: TYPE_NORMAL
- en: With so many manual steps, I’d be inclined to keep my newly created virtual
    machine and take care of it like a pet. They say containers are like cattle, and
    virtual machines are like pets. That is, until you’ve started using tools like
    Vagrant. Vagrant does a good job making your virtual machines blend in with the
    cattle – thanks to how easy it is to recreate your virtual machines using Vagrant,
    you no longer need to care for them the way you had to previously if you weren’t
    using Vagrant.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will walk you through the process of creating a lab environment
    using **Vagrant**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the following for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle VM VirtualBox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vagrant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Technical requirements* section at the beginning of this chapter
    if you need help installing Oracle VM VirtualBox and Vagrant.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vagrant is a tool used for managing the lifecycle of virtual machines. In this
    recipe, we’re going to create a Vagrant box that automatically installs and configures
    Oracle Linux Manager. Oracle Linux Manager requires Oracle Linux 7\. In this case,
    we can use the official **Oracle Linux 7 Vagrant Box** as our base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, that has pulled in a nice base file for us to start with. Let’s look
    at the `Vagrantfile` file to see what’s inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The actual `Vagrantfile` generated by the `init` command contains 69 lines of
    code, but 65 of those lines are comments, hence I removed them to help make this
    recipe more easily comprehensible.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from this `Vagrantfile`, all we need is those four lines to launch
    an Oracle Linux 7 instance in `vagrant up` command and when it’s up and running,
    you can simply enter the `vagrant ssh` command to access the VM and see how it
    works. Once finished, type `vagrant destroy` to bring down the VM. Now, let’s
    dive into ways to make this more useful; because I want to be able to type `vagrant
    up` and have not only an Oracle Linux VM, but also want that same command to result
    in a working copy of Oracle Linux Manager.
  prefs: []
  type: TYPE_NORMAL
- en: First things first, let’s review the installation and configuration instructions
    for Oracle Linux Manager – this can be found at [https://docs.oracle.com/en/operating-systems/oracle-linux-manager/2.10/install/#Oracle-Linux-Manager](https://docs.oracle.com/en/operating-systems/oracle-linux-manager/2.10/install/#Oracle-Linux-Manager).
    Since we aren’t using an Oracle database, we will divert slightly from the instructions
    outlined – this means we’ll skip anything related to Oracle databases (for example,
    we won’t need the Oracle Instant Client and *SQL*Plus* packages).
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate what we’re going to do, I’ll list all the steps from the guide,
    applying **bold** style to the steps we want to keep. The ones that are not bold
    will be skipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo yum install` `oracle-instantclient18.5-basic-18.5.0.0.0-3.x86_64.rpm
    oracle-instantclient18.5-sqlplus-18.5.0.0.0-3.x86_64.rpm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`echo "/usr/lib/oracle/18.5/client64/lib" | sudo` `tee /etc/ld.so.conf.d/oracle-instantclient18.5.conf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo ldconfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sudo yum list installed |** **grep jta**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sudo yum** **remove jta**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**echo «exclude=jta*» >> /****etc/yum.conf**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sudo yum-config-manager –****disable ol7_addons**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo firewall-cmd --``permanent --add-port=69/udp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo firewall-cmd --``permanent --add-port=80/tcp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo firewall-cmd --``permanent --add-port=443/tcp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo firewall-cmd --``permanent --add-port=5222/tcp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo firewall-cmd --``permanent --add-port=5269/tcp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo systemctl` `reload firewalld`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sudo yum** **install oracle-release-el7**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sudo yum** **install oracle-linux-manager-server-release-el7**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sudo yum-config-manager --****enable ol7_optional_latest**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spacewalk-oracle` **spacecmd spacewalk-utils**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo` `spacewalk-setup --external-oracle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And that’s basically it. The following is for additional changes that we need
    to make to use Oracle Linux Manager with PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll need to provide an answer file since the automation we’re doing
    in Vagrant cannot be interactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file named `answer-file.txt` and place the following content into
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This summarizes the bulk of the installation and configuration steps. Next,
    in order to make all of this work so that we can deploy and provision Oracle Linux
    Manager automatically using Vagrant, we need to make some very simple changes.
    All we really need to do is paste those steps into a *Bash shell script* file
    and tell Vagrant to use a provisioner to run these commands on the box. Also,
    again, since automation cannot be interactive, we just need to add `-y` to all
    the `yum` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, to clean things up and prepare them for Vagrant, our Bash script
    will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At some point while authoring this recipe, an update was made to the spacewalk-schema
    package making it no longer compatible with PostgreSQL. This can be fixed by pinning
    the spacewalk-schema package to `spacewalk-schema-2.10.14-1.el7` as shown in the
    preceding snippet.
  prefs: []
  type: TYPE_NORMAL
- en: I removed the call to `sudo` for each step since everything runs as root during
    the provisioning phase of Vagrant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the `Vagrantfile`, add a few lines so that Vagrant can copy the `answer-file.txt`
    file to the guest machine, then tell Vagrant to execute the script we just wrote.
    We’ll also create a private network, which allows host-only access to the machine
    using a specific IP (this will allow us to easily access Oracle Linux Manager
    via our web browser):'
  prefs: []
  type: TYPE_NORMAL
- en: "![F\uFEFFigure 8.25 – Vagrant file for deploying OLM](img/B18349_08_25.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.25 – Vagrant file for deploying OLM
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: On Linux/Unix-based systems, VirtualBox will only allow IP addresses in `192.168.56.0/21`
    range to be assigned to host-only adapters. This allows for IP addresses starting
    at `192.168.56.1` and ending at `192.168.63.254`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can review what our directory should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re ready to fire things up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You’ll watch as the provisioning script installs and configures Oracle Linux
    Manager, and within a matter of minutes, you’ll be able to point your browser
    to the IP address defined for the virtual machine to access Oracle Linux Manager.
    The best part about this is everything is **defined as code**. Everything we created
    in this recipe amounts to just 6 KB in size! Vagrant does an amazing job at solving
    the classic “*it works on my machine*” problem. You can take these 6 KB of code
    and deploy your work on any machine (Mac, Windows, Linux, etc.) – all you need
    is Vagrant and Oracle VM VirtualBox.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could take this automation a few steps further to make it even more useful.
    For example, we could automate the creation of the first user for Oracle Linux
    Manager, automatically create the channels, repositories, and activation keys,
    then create clients for OLM and connect to them automatically. Getting into the
    details for all that is beyond the scope of this recipe, but if you’re interested
    in seeing how this is done, I’ve got the solution published on GitHub – you can
    find that here: [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/vagrant](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/vagrant).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Packer to modify source images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packer is a tool used for automating the creation of machine images. In this
    recipe, we’re going to use Packer to reference an **Oracle Linux 8** platform
    image as its source, install something using a provisioner, and push up a new
    OCID image with these changes onto OCI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Although OCI features a free tier that contains “Always Free” resources, this
    does not include the ability to store images. If you wish to follow along with
    this recipe, you will need to use a paid account.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Technical requirements* section at the beginning of this chapter
    if you need help installing Packer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Packer is often overlooked because it seems so simple on the surface; however,
    don’t let this simplicity fool you – Packer is incredibly powerful and useful.
    In this recipe, we’re going to use Packer to reference some release of Oracle
    Linux 8 as its base image, install something using a provisioner, and push up
    a new OCID image with these changes onto the OCI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will specify a Packer plugin that provides a builder called `oracle-oci`,
    which enables Packer to create machine images for OCI. We can do that in a file
    named `oracle-oci.pkr.hcl`. Input the following at the beginning of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.26 – Packer OCI builder plugin](img/B18349_08_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.26 – Packer OCI builder plugin
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will configure our authentication to OCI using the configuration options
    specified by the `oracle-oci` builder. Details on configuring the `oracle-oci`
    builder can be reviewed at [https://developer.hashicorp.com/packer/plugins/builders/oracle/oci](https://developer.hashicorp.com/packer/plugins/builders/oracle/oci):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are numerous ways to do this. One way is to reference variables for the
    authentication details directly in your `*.pkr.hcl` file, like this:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.27 – Referencing variables in Packer](img/B18349_08_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.27 – Referencing variables in Packer
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to declare all of those variables in a file named `variables.pkr.hcl`.
    In this file, we declare the variable and specify the type, as well as providing
    a description to explain the purpose of the variable. Input the following into
    your `variables.pkr.hcl` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.28 – Declaration of variables in Packer](img/B18349_08_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.28 – Declaration of variables in Packer
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we want to assign values to the variables. We place them in a file
    named `variables.auto.pkrvars.hcl`. It should look something like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.29 – Assigning variables in Packer](img/B18349_08_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.29 – Assigning variables in Packer
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way is to configure your OCI CLI in `~/.oci/config`. That would look
    something like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Full details on configuring your OCI CLI can be found here: [https://docs.oracle.com/en-us/iaas/Content/API/Concepts/sdkconfig.htm](https://docs.oracle.com/en-us/iaas/Content/API/Concepts/sdkconfig.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the authentication configured, you can start by defining the
    base image. This should look something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.30 –  Defining the base image in Packer](img/B18349_08_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.30 – Defining the base image in Packer
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the OCID for Oracle Linux 8, visit the following URL: [https://docs.oracle.com/en-us/iaas/images/oracle-linux-8x/](https://docs.oracle.com/en-us/iaas/images/oracle-linux-8x/).
    This is region specific as well as architecture specific, so you’ll want to find
    the latest Oracle Linux 8 image for x86 (or in other words, look for one without
    `aarch64` mentioned in the image name).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve defined the source, you can move on to instructing Packer on what
    to do during the build process. In this case, we’ll call a provisioner so we can
    run a shell command to install Git:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.31 – Packer provisioners](img/B18349_08_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.31 – Packer provisioners
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’ve told Packer about what we want to use for our source and
    described what we want to do for our build. Your entire file should look something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.32 – Complete Packer file for modifying base images](img/B18349_08_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.32 – Complete Packer file for modifying base images
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the final file, I replaced the word `example` with `ol8u8` throughout to
    be a bit more descriptive about what I’m working with. This is simply a good form
    of self-documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’re going to run `packer init` to download the external plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s go ahead and build the OCID image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 8.33 – Initial output after running packer build](img/B18349_08_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.33 – Initial output after running packer build
  prefs: []
  type: TYPE_NORMAL
- en: Once Git is installed, it will take a snapshot of the instance and export this
    as a new OCID image, giving us a new starting point for all future instances.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.34 – Output as Packer completes the build process](img/B18349_08_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.34 – Output as Packer completes the build process
  prefs: []
  type: TYPE_NORMAL
- en: 'When Packer is finished, you can view the newly published image by navigating
    to the **Compute** | **Custom Images** on the OCI Console. Here’s an example of
    what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.35 – Viewing the recently published custom image on OCI](img/B18349_08_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.35 – Viewing the recently published custom image on OCI
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this recipe can be found at [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/packer-cloud](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/packer-cloud).
  prefs: []
  type: TYPE_NORMAL
- en: Pack it up, pack it in, let me begin, err, umm… build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we’re going to use Packer to start from source media (such as
    an ISO) to create our very own Vagrant box from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the following for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle VM VirtualBox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Technical requirements* section at the beginning of this chapter
    if you need help installing Oracle VM VirtualBox and Packer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More often than not, you can search the Vagrant catalog and find pre-made **Vagrantfiles**
    containing the operating system you’re looking for. But what happens if what you
    need is not there? Or maybe you don’t trust the author of the Vagrantfile and/or
    you simply prefer to create your own. You can do this manually, or you can do
    this entirely with code, by leveraging Packer. In this recipe, we’ll use Packer
    to bake up a fresh Vagrant box from the Oracle Linux 8.8 source ISO. At a high
    level, Packer will download the ISO image for the operating system we wish to
    use, it will then spin up a VM using Oracle VM VirtualBox and install the VM.
    Afterward, it will export the VM in **Open Virtualization Format** (**OVF**).
    Finally, it will compress this file and convert it into a Vagrant box file.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Linux 8 kickstart file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this magic to work, you’ll need to provide a kickstart file to automate
    the installation of the ISO. You can create your own, or use one from the Oracle
    Linux Image Tools found in the official Oracle Linux repository on GitHub. For
    this recipe, I’ll be using one from the Oracle Linux Image Tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: https://github.com/oracle/oracle-linux/blob/main/oracle-linux-image-tools/distr/ol8-slim/ol8-ks.cfg
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, to get started with this recipe, we’ll create a new directory called `ol8-vagrant`.
    In this directory, create a Packer file and name it `vagrant-ol8.pkr.hcl`, and
    go ahead and create a folder called `http` and place the kickstart file there.
    Once this is done, your file structure should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our kickstart file, we just need to set the password for the root user. So,
    in this case, we’ll change the line that reads `rootpw --lock` to `rootpw --``plaintext
    vagrant`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we’ll go ahead and work on the `vagrant-ol8.pkr.hcl` file. The first
    thing we’ll need to do here is specify the plugins we’ll need. Let’s use the VirtualBox
    Builder since we want to create a VM from an ISO image, and the Vagrant Builder
    since we’re going to convert our OVF file into a Vagrant box file. These can be
    added by placing the following code into your Packer configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 8.36 – Packer VirtualBox and Vagrant builder plu\uFEFFgins](img/B18349_08_36.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.36 – Packer VirtualBox and Vagrant builder plugins
  prefs: []
  type: TYPE_NORMAL
- en: 'Info:'
  prefs: []
  type: TYPE_NORMAL
- en: 'More info on the Packer VirtualBox plugin can be found here: [https://www.packer.io/plugins/builders/virtualbox](https://www.packer.io/plugins/builders/virtualbox).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to define a source. In this case, we want to use the Oracle Linux
    8.8 ISO. Add the following to your `vagrant-ol8.pkr.hcl` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.37 – Packer file for building Vagrant boxes](img/B18349_08_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.37 – Packer file for building Vagrant boxes
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `modifyvm` command, which sets `--nat-localhostreachable1` to `on`.
    This is a new setting that is `off` by default in Oracle VM VirtualBox 7\. Setting
    this value to `on` fixes a networking issue that prevents Packer from sending
    the kickstart file to the VM. In other words, it’s important to include this if
    you’re using VirtualBox 7 to build your VM, but if you’re on VirtualBox 6, you’ll
    need to remove this line or your build will fail.
  prefs: []
  type: TYPE_NORMAL
- en: So, in the preceding code, we specified the `guest_os_type` as `"Oracle_64"`
    because we’re building from an Oracle Linux ISO. Next, we input the URL for the
    ISO as well as the checksum. For `ssh_username`, we’ll use `"root"` and for `ssh_password`,
    we’ll use `"vagrant"` because these are the defaults that Vagrant expects in order
    to make things easy – especially if you plan to distribute your box publicly.
    If you intend to keep your box for private use only, it is best to use different
    values, as this will keep the box more secure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Vagrant usernames and passwords, visit [https://www.vagrantup.com/docs/boxes/base#vagrant-user](https://www.vagrantup.com/docs/boxes/base#vagrant-user).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll set `headless` to `"true"` in order to prevent the virtual machine from
    starting the VirtualBox GUI. We increase the time for `ssh_wait_timeout` to give
    the operating system sufficient time to install and to get up and running. All
    of this is self-explanatory; that is, until we get to the `http_directory` setting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All you really need to know is that we’ll leverage the `http_directory` option
    as a convenient way to serve a directory using an HTTP server. It does this so
    that the boot command can point to a kickstart file – which we’ve placed in the
    `http` directory. `http://{{ .HTTPIP }}:{{ .HTTPPort }}/ol8-ks.cfg` tells the
    operating system exactly what it needs to reach the kickstart file. You don’t
    really need to worry about the syntax of `{{ .HTTPIP }}` and `{{ .HTTPPort }}`;
    these are just template variables that are processed by the Packer templating
    engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `nic_type`, the default value is `82540EM`, which equates to Intel PRO/1000
    MT Desktop. That’s a safe choice and is great when running old operating systems,
    but Oracle Linux 8 is a modern operating system so we’re setting this to `virtio`.
    VirtIO is a para-virtualized driver and will give us better networking performance
    in the VM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, on to the `boot_command`. Basically, we need to figure out what sequence
    of key presses are required in order to send a boot command to the operating system
    at boot time. In the case of Oracle Linux 8, we send key presses of *up* and *Tab*,
    and then we send instructions on where to find the kickstart file, and finally
    we tell it to press *Enter* to begin installing the OS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `vboxmanage`, I found that, by default, Packer tried to launch my VM with
    only 512 MB of memory, and that resulted in an error during the installation of
    the OS. In order to resolve this issue, I increased the memory to `2048`. I also
    gave it two CPUs just for good measure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, with the `shutdown_command`, we simply tell Packer how to shut down
    the system gracefully once all the provisioning is done. If we leave this blank
    Packer would forcefully shut down the machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: For a complete overview of available configuration options, see [https://www.packer.io/plugins/builders/virtualbox/iso](https://www.packer.io/plugins/builders/virtualbox/iso).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have enough to install the OS automatically, but we need to
    do a few more things to prepare the virtual machine for Vagrant. To be specific,
    we need to add a user called `vagrant`, populate that user’s authorized keys with
    a known public key for that user, and finally we’ll want to install VirtualBox
    Guest Additions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For these tasks, we’ll leverage a provisioner to execute a shell script. This
    task takes place after the operating system is installed and while the virtual
    machine is still running. It’s the last thing we’ll do before we shut down the
    system and convert it to a Vagrant box.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go ahead and add the following to the `vagrant-ol8.pkr.hcl` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.38 – Packer file for building Vagrant boxes (continued)](img/B18349_08_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.38 – Packer file for building Vagrant boxes (continued)
  prefs: []
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: 'More info on post-processors can be found here: [https://www.packer.io/plugins/post-processors/vagrant/vagrant#virtualbox](https://www.packer.io/plugins/post-processors/vagrant/vagrant#virtualbox).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the preceding screenshot, we’re going to create a new folder
    called `scripts` and place the shell script in there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `vagrant-base-box.sh` script, we’ll add this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.39 – Contents of the vagrant-base-box.sh script](img/B18349_08_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.39 – Contents of the vagrant-base-box.sh script
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’re going to run `packer init` to download the external plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we’re ready to build the Vagrant box. This part is simple, just run the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After entering the command, you will see something like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.40 – Output of the “packer build” command](img/B18349_08_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.40 – Output of the “packer build” command
  prefs: []
  type: TYPE_NORMAL
- en: 'This will take a while, because it’s actually doing quite a bit here. Remember
    what we talked about from a high level: Packer is going to download the ISO, create
    a VM, and install the OS, and afterward it will run everything in the script you
    just defined, but once all of this is done, you will be left with a nice neat
    `.box` file (which is exactly what we need to for use with Vagrant).'
  prefs: []
  type: TYPE_NORMAL
- en: If you switch over to VirtualBox, you’ll eventually see a new VM that was created
    by Packer. You can just leave it be and let Packer do its thing, but knowing this
    detail gives you the ability to know what’s going on behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.41 – Screenshot of VM being built and configured with Packer](img/B18349_08_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.41 – Screenshot of VM being built and configured with Packer
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the build is complete, you should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.42 – Screenshot of completed build of Vagrant box](img/B18349_08_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.42 – Screenshot of completed build of Vagrant box
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Oracle Linux ISO file is several gigabytes, so this really could take a
    while. Now may be the perfect time to take a break and have a coffee. 😉
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to prepare our box for use with Vagrant. We’ll just run `vagrant
    init` to build our Vagrantfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.43 – Initializing Vagrant box](img/B18349_08_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.43 – Initializing Vagrant box
  prefs: []
  type: TYPE_NORMAL
- en: Helpful tip
  prefs: []
  type: TYPE_NORMAL
- en: You could run `vagrant init` and `vagrant init .` , but it’s best to specify
    the filename of the box. This way, Vagrant will automatically specify the proper
    value of the box inside the Vagrantfile. That’s why for this recipe, we are running
    `vagrant` `init ol8-x64-virtualbox.box`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it’s time to test out our new Vagrant box by running `vagrant up`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of this command is shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.44 – Output of the “vagrant up” command](img/B18349_08_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.44 – Output of the “vagrant up” command
  prefs: []
  type: TYPE_NORMAL
- en: And there you have it. After a few short moments, your virtual machine will
    be up and running, and you can interact with it using the convenient commands
    made possible by Vagrant.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this recipe can be found at [https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/packer-vagrant](https://github.com/PacktPublishing/Oracle-Linux-Cookbook/tree/main/ch8/packer-vagrant).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you’re still developing your Vagrant box and need to test after each build,
    you’ll want to make sure you’re testing the latest box that you’ve built. I actually
    ran into an issue thinking that my changes weren’t persisting until I realized
    Vagrant was using a cached box from a previous build. You can remove old boxes
    with `vagrant box` `remove ol8-x64-virtualbox.box`.
  prefs: []
  type: TYPE_NORMAL
