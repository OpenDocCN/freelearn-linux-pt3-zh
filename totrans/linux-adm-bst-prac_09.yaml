- en: '*Chapter 6*: Databases'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：数据库'
- en: Technically database systems are applications that run on top of the operating
    system and should not be of direct concern to us as system administrators. That
    is an excellent theory. In the real-world, databases are tightly tied to the operating
    system, tend to be general knowledge items, require deep technical knowledge,
    and relatively little overall time. Because of this it almost universally makes
    sense that database management duties fall to system administrators; this is especially
    true on Linux distributions today because most databases that we are likely to
    use are bundled with the operating system itself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，数据库系统是运行在操作系统之上的应用程序，对于我们作为系统管理员来说不应直接关注。这是一个很好的理论。然而在现实世界中，数据库与操作系统密切相关，往往是通用的知识项目，需要深入的技术知识，而总体上需要的时间相对较少。因此，普遍来说数据库管理的责任落在系统管理员身上；特别是在当今的Linux发行版上，因为我们可能使用的大多数数据库已经与操作系统捆绑在一起。
- en: 'In this chapter we are going to learn about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Separating a Database from a DBMS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据库与DBMS分离
- en: Comparing Relational and NoSQL Databases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较关系型数据库和NoSQL数据库
- en: Discovering Common Databases on Linux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux上发现常见的数据库
- en: Understanding Database Replication and Data Protection Concepts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数据库复制和数据保护概念
- en: In the good ol' days system administration and database administration were
    almost always two discrete tasks. The SA and DBA roles would work closely with
    each other, but the specialized skills and large time requirements of each role
    meant that they were typically discrete, dedicated staff. Typically, only one
    DBA was needed for every five to twenty system administrators, so teams were smaller,
    and the career field was always much smaller as the system administrator role
    exists even in companies that have no databases to administer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧日的好时光，系统管理和数据库管理几乎总是两个独立的任务。系统管理员（SA）和数据库管理员（DBA）角色会密切合作，但是由于各自角色的专业技能和大量时间需求，它们通常是独立的、专门的工作人员。通常情况下，每五到二十名系统管理员只需要一个数据库管理员，因此团队规模较小，职业领域也总是较小，因为即使在没有数据库需要管理的公司中，系统管理员角色仍然存在。
- en: As both operating systems and database management systems have become simpler
    and more robust, the need for an extensive amount of database platform tweaking
    has been reduced to the point that the DBA career path is all but gone. The need
    to build a career around a single database platform just does not exist today.
    Those that manage databases generally do so for a wide variety of different databases,
    possibly on multiple operating systems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随着操作系统和数据库管理系统变得更简单、更健壮，需要对数据库平台进行大量调整的需求已经减少到几乎可以忽略的程度，因此DBA职业道路几乎已经消失。今天已经不存在建立在单一数据库平台周围的职业需要。管理数据库的人通常会管理各种不同的数据库，可能在多个操作系统上。
- en: Over time most critical workloads become commoditized. By that we mean that
    they move from being specialist knowledge to being generalist knowledge. Good
    examples of these would be email servers (MTA) and web servers. Twenty years ago
    (around 2001) running either one of these was highly specialized knowledge and
    only a very rare system administrator would understand the workings of either
    one. You would typically have a system administrator just for the operating system
    and then a specialized email administrator or web administrator dedicated to managing
    just the single application that they specialized in. It would not be *all email
    servers* or anything like that. It was often a specialized skill to just a single
    email server such as Postfix or Exchange. Your knowledge would be completely centered
    on this one product and its unique quirks and needs. This was so extreme that
    products like Postfix, Exchange, Apache, MS SQL Server, Oracle Databases, IBM
    DB2, and so forth would have entire certification and professional development
    paths for each of them. Today, we just assume that any experienced system administrator
    will be more than capable of managing any email, web, or database server that
    is thrown at them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，大多数关键工作负载变得商品化。我们的意思是，它们从专门知识转变为通用知识。这些的典型例子包括电子邮件服务器（MTA）和网页服务器。二十年前（大约在2001年），运行这些服务器是高度专业化的知识，只有非常少的系统管理员才会理解其中的工作原理。通常你会有一个专门的操作系统管理员，然后有一个专门的电子邮件管理员或网页管理员，专门管理他们所擅长的单一应用程序。那时不会是*所有电子邮件服务器*之类的情况。管理一个单一的邮件服务器，比如Postfix或Exchange，往往是一项专业技能。你的知识将完全集中在这个单一产品及其独特的特点和需求上。这种情况非常极端，以至于像Postfix、Exchange、Apache、MS
    SQL Server、Oracle数据库、IBM DB2等产品，都有专门的认证和职业发展路径。如今，我们只是默认任何有经验的系统管理员都能够管理任何电子邮件、网页或数据库服务器。
- en: Because databases are highly complex and have evolved to be far more than they
    were in past decades, there are many concepts that we, as system administrators,
    should universally understand about them. They are highly stateful and represent
    a secondary storage layer to the file system and general storage subsystem. They
    do not represent a special case, but the broad application of a general case that
    we need to understand deeply. Web servers, email servers, and other applications
    are still important, but they represent common examples of the standard, expected
    situation in application design and so do not require special consideration in
    this manner. To be blunt, databases store things and are extremely fragile. Other
    applications use databases or the filesystem to store things and so are simple
    from an administration perspective. It is because a database represents a second-tier
    data storage layer that it is seen as special.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库非常复杂，并且在过去几十年中已经发展成为远超其过去的形态，因此作为系统管理员，我们应该普遍理解其中的许多概念。数据库是高度状态化的，代表着文件系统和一般存储子系统的二级存储层。它们并不代表特殊情况，而是需要我们深入理解的通用情况的广泛应用。网页服务器、电子邮件服务器和其他应用程序仍然很重要，但它们代表的是应用设计中的标准预期情境，因此在这种情况下不需要特别的考虑。直白地说，数据库用于存储数据，并且极其脆弱。其他应用程序使用数据库或文件系统来存储数据，因此从管理的角度来看，它们比较简单。正因为数据库代表了第二层数据存储层，它才被视为特殊。
- en: 'To tackle this in a system administration way, we are going to start by delving
    into what a database really is and how it works and why it becomes a form of storage.
    Then we can look at database types and specifics common to Linux distributions.
    And then finally we will wrap up by looking at the most important aspect of databases:
    how to protect them.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以系统管理员的方式处理这一问题，我们将从深入了解数据库是什么、它是如何工作的以及为什么它成为一种存储形式开始。然后，我们可以研究常见的数据库类型及其在Linux发行版中的具体情况。最后，我们将通过探讨数据库的最重要方面——如何保护它们，来结束本篇内容。
- en: Let's get started and find out exactly what a database is and why we care so
    much about them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，弄清楚数据库究竟是什么，以及为什么我们如此关心它们。
- en: Separating a Database from a DBMS
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据库与数据库管理系统（DBMS）分开
- en: As with most things in life, the terminology used casually around databases
    is often inaccurate with highly technical and specific terms being used to primarily
    refer to something different than what the term is meant to describe. But by digging
    into what a database truly is and how they almost universally work, and by building
    up correct semantics around the topic, we are going to build a nearly intrinsic
    understanding of database needs from a system administration perspective. This
    is often true, simply finding an accurate way to describe a thing allows us to
    understand it. Databases are not magic, but too often are treated as such.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像生活中大多数事情一样，关于数据库的术语往往不准确，许多高度技术化且具体的术语被用来主要指代与其原本含义不同的东西。但通过深入了解数据库到底是什么，以及它们如何几乎普遍地工作，并在这个话题上建立正确的语义，我们将从系统管理员的角度，建立起对数据库需求的几乎内在理解。通常来说，找到准确的描述方式本身就能帮助我们理解。数据库并非魔法，但往往被当作魔法来看待。
- en: The Database
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库
- en: 'We have to begin by asking what a database is. A database is defined by the
    Oxford Dictionary as *a structured set of data held in a computer, especially
    one that is accessible in various ways*. Well that does not tell us very much.
    But, in a way, it kind of does. Databases cannot be unstructured; this is the
    most important piece and computers store things such as files. So, databases are
    structured data on a computer either stored on disk as a file or set of files,
    or they live in the computer''s memory and never get written to disk. In the latter
    case the database is ephemeral and of little importance to a system administrator.
    But in the former case, which represents far more than ninety-nine percent of
    use cases, this matters a lot. Let''s make a definition that we can use effectively
    as system administrators: a database is a file or a set of files that contain
    structured data.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须首先问一下，什么是数据库？《牛津词典》对数据库的定义是*在计算机中保存的一组结构化数据，特别是可以通过多种方式访问的数据*。嗯，这样的定义并没有告诉我们太多。不过，从某种程度上说，它其实说了些东西。数据库不能是无结构的；这是最重要的一点，计算机存储的东西，比如文件，也都是结构化的。所以，数据库是计算机中存储的结构化数据，可以是存储在磁盘上的文件或文件集，或者它们存在于计算机内存中，永远不写入磁盘。在后一种情况下，数据库是短暂的，对系统管理员来说并不重要。但在前一种情况下，代表了百分之九十九以上的使用案例，这个问题就非常重要了。让我们给出一个作为系统管理员可以有效使用的定义：数据库是包含结构化数据的文件或文件集。
- en: You might immediately jump to statements like, *but I have run a database and
    it is a service, not a file - I can interact with it!* We will address that shortly.
    Stick with me. Databases are just file(s).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会立刻跳出来说，*但是我运行的是一个数据库，它是一个服务，而不是文件——我可以与它互动！* 我们会很快解决这个问题。跟我走，数据库其实就是文件。
- en: We should start with some examples because this helps to quickly understand
    what we mean. Let's take a standard text file, perhaps one in which we just write
    down some notes. This is a file, but is it a database? No, it is not. Sure, the
    file is encoded in some ANSII character standard, but the data is ad hoc, not
    structured. We *could* add structure manually to the file and that is okay to
    do, but the file and the tools that read that file are unaware of the structure.
    Any structure is purely accessible or visible only to the human using it, not
    the system itself. This is unstructured.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该从一些例子开始，因为这有助于快速理解我们的意思。假设我们有一个标准的文本文件，也许是我们写下的一些笔记。这是一个文件，但它是数据库吗？不是的，它不是。没错，文件是用某种
    ANSI 字符标准编码的，但数据是临时的，没有结构。我们*可以*手动给文件添加结构，这样做是可以的，但文件和读取该文件的工具并不知道这些结构。任何结构对于使用它的人来说是可访问或可见的，但对系统本身不可见。这是无结构的。
- en: Okay then, text files are not databases. What about a Word file? Same thing.
    It might have a strong format that a text file does not, but what is stored in
    the Word file is completely unstructured. We could put anything in the file, anywhere.
    It is unstructured.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么文本文件不是数据库。那么 Word 文件呢？一样的道理。它可能有比文本文件更强的格式，但 Word 文件中存储的内容完全没有结构。我们可以在文件中随意放入任何内容，放在任何地方。它是无结构的。
- en: Now what about a spreadsheet file? Like we would get with Excel or a CSV? This
    is a tough one. This gets us into a grey area. Under normal conditions these files
    are not considered databases, but nominally they are. I would refer to them as
    *semi-structured*. They contain some structure (which you visibly see as cells)
    and they have a way to designate what is contained within that structure, and
    certain groups of data (namely what is represented as columns or rows) that are
    expected to relate to each other. But none of the structure within the cells or
    even between them is suggested or enforced. So, there is structure, but we generally
    assume that it is not as much structure as a database would require. We will call
    it a maybe. Do not break out a `CSV` file and try to defend it as the new database
    format at the next IT cocktail party, it is not defensible. It is only useful
    as a thought experiment. But we can see that a spreadsheet format has very easily
    the potential for acting like a database should.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，电子表格文件呢？就像我们用Excel或CSV时得到的那样？这是一个棘手的问题。我们进入了一个灰色区域。在正常情况下，这些文件并不被视为数据库，但名义上它们是。我会把它们称为*半结构化的*。它们包含一些结构（你可以看到的是单元格），并且有一种方法来指定该结构中包含的内容，以及某些数据组（即表现为列或行的数据），这些数据被期望相互关联。但单元格内或单元格之间的任何结构都没有被建议或强制执行。因此，虽然有结构，但我们通常认为它没有数据库所需的结构那么多。我们称之为“也许”。不要在下一个IT鸡尾酒会上拿出`CSV`文件，并试图为它辩护是新的数据库格式，因为这是站不住脚的。它仅仅是作为一个思维实验有意义。但我们可以看到，电子表格格式很容易有潜力像数据库一样发挥作用。
- en: With a little more structure, we start to see real database-lite files emerge.
    XML makes a great example. XML is a little more structured than a spreadsheet
    format, like CSV, and can be used as a full-fledged database. There are some database
    formats that are based on XML. XML is still just ANSII text, but with enough specific
    structure to take us all the way to *very simple database*. XML maybe does not
    make for the most robust of databases, nor the fastest to use, but it is very
    simple and can be effective for the right purpose.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过稍微增加一些结构化，我们开始看到真正的轻量级数据库文件的出现。XML就是一个很好的例子。XML比CSV这样的电子表格格式更有结构，可以作为一个完整的数据库使用。有些数据库格式就是基于XML的。XML仍然只是ANSI文本，但具有足够的特定结构，可以让我们走向*非常简单的数据库*。XML可能不是最强大的数据库，也不是使用最快的数据库，但它非常简单，并且在合适的用途下可以非常有效。
- en: Purpose built databases tend to avoid the unnecessary bloat of ANSII or similar
    text formats as this slows the system down when used by software, and databases
    really are not generally intended to be human readable on their own. Generally,
    some form of binary format or even compression is used to reduce read and write
    time from storage and minimize storage space needed today. A great example is
    *SQLite*, a free, open-source database that uses a highly optimized, but openly
    publicized, format that you can study if interested. It remains simply a file,
    like any other, but with even more structure than XML provides.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 专门构建的数据库通常避免使用ANSI或类似的文本格式的多余膨胀，因为这会在软件使用时减慢系统速度，而且数据库本身通常并不是为了让人类直接阅读的。通常，会使用某种形式的二进制格式或甚至压缩来减少存储的读写时间，并尽量减少今天所需的存储空间。一个很好的例子是*SQLite*，这是一个免费的开源数据库，它使用高度优化、但公开的格式，如果有兴趣，你可以研究它。它仍然只是一个文件，就像其他任何文件一样，但比XML提供的结构更加丰富。
- en: All these examples use just one file per database. But there is no reason that
    a database might not use many files. A common purpose for this might be to simply
    break up data so that it is not all stored in a single file that is too large
    to easily manipulate or data might be broken up by purpose. Imagine a database
    that stores a list of user addresses and also user telephone numbers. One file
    that holds only the addresses and one that holds only the phone numbers would
    be a sensible *on disk* storage design.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例使用的都是每个数据库一个文件。但数据库使用多个文件并不是没有理由的。这样做的一个常见目的可能只是将数据拆分开来，以避免将所有数据存储在一个过大、无法轻松操作的单一文件中，或者数据可以按用途拆分。想象一下一个存储用户地址和用户电话号码的数据库。一个只包含地址的文件和一个只包含电话号码的文件会是一个合理的*磁盘存储*设计。
- en: The Database engine
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库引擎
- en: We now know what a database is. It is just a file (or files, of course) that
    we store that contain our structured data. We *assume* that in production circumstances,
    we will be using a database format that is highly efficient and not meant for
    a human to open it and read it directly, that would just be silly. So, the computer
    is going to read, write, and manipulate this file or these files.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道什么是数据库。它其实就是我们存储的一个文件（或者多个文件），这些文件包含我们的结构化数据。我们*假设*在生产环境中，我们将使用一种高效的数据库格式，这种格式不是为了让人类直接打开和读取，这样做显然是不明智的。所以，计算机会读取、写入并操作这个文件或这些文件。
- en: But how will the computer know how to work with the database file that is in
    such a specific structured format? Before we answer that, we should make a comparison
    to storage.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，计算机如何知道如何处理那个格式如此具体的数据库文件呢？在回答这个问题之前，我们应该先来比较一下存储。
- en: In storage we have a standard raw format that we refer to as block storage.
    On top of that we implement filesystems. These filesystems interface with their
    operating system by providing a standard file access format that the operating
    system can use to store and retrieve data. Each filesystem can do this in quite
    different ways from each other. For the operating system to work with a filesystem
    it has to have a filesystem driver.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储中，我们有一个标准的原始格式，称为块存储。在此基础上，我们实现了文件系统。这些文件系统通过提供操作系统可以用来存储和检索数据的标准文件访问格式，与操作系统进行交互。每个文件系统可以以不同的方式执行此操作。为了让操作系统能够与文件系统交互，它必须有一个文件系统驱动程序。
- en: Databases work the same way, but they generally do so one layer higher up the
    stack. To a database, the filesystem is the generic storage. The highly structured
    data goes on top of the filesystem, contained in a file, or files. But in the
    same way as we need a driver for the operating system to know how to talk to the
    filesystem, we need a driver for applications to know how to talk to databases!
    It is legitimate to refer to this as a database driver, but it is generally known
    as a database engine or a database library.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的工作方式相同，但通常是在更高一层的堆栈中进行的。对数据库来说，文件系统是通用存储。高度结构化的数据位于文件系统之上，包含在一个文件或多个文件中。但就像我们需要操作系统驱动程序来知道如何与文件系统进行交互一样，我们也需要一个驱动程序来让应用程序知道如何与数据库进行交互！我们可以将其称为数据库驱动程序，但它通常被称为数据库引擎或数据库库。
- en: Filesystems are actually databases
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统实际上是数据库
- en: Here is one of those weird things that those of us working in IT should understand
    and that you can never whip out at that proverbial cocktail party because you
    will never be able to convince anyone that this is true, and yet it is. Filesystems
    themselves are actually a form of database. They are an on-disk format of highly
    structured data that can contain other specifically formatted data, in the form
    of files, contain structured data about those files, and generally contains complex
    mechanisms for searching through the data structure. A filesystem is a database
    in every sense. Even down to how it is commonly used. They are simply databases
    with a unique, but extremely common, purpose that is so important that we have
    forgotten what it really is under the hood.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是那些我们在IT领域工作的人应该理解的奇怪事情，而你永远不能在那个所谓的鸡尾酒派对上提出来，因为你永远无法说服任何人相信这是真的，但它确实如此。文件系统本身实际上是一种数据库形式。它们是磁盘上的高结构化数据格式，可以包含其他特定格式的数据，以文件的形式存储，包含关于这些文件的结构化数据，并且通常包含复杂的机制来搜索数据结构。文件系统在各个方面都是数据库。甚至包括它通常的使用方式。它们只是具有独特但极为常见的目的的数据库，这个目的重要到我们已经忘记了它在背后究竟是什么。
- en: This is similar to how web servers are actually file servers but are such a
    special case that no one ever talks about how that is what they really are. It
    is useful to understand that that is how they work because it helps us to understand
    them better and keeps our brains from getting confused when it realizes that the
    two overlap and you cannot figure out how they are separate - because they are
    not.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这与网络服务器实际上是文件服务器的情况类似，但它们是如此特殊的案例，以至于没人谈论它们本质上就是这样。理解它们是如何工作的非常有用，因为这有助于我们更好地理解它们，并且避免大脑在意识到它们之间有重叠时感到困惑，进而搞不清楚它们是如何分开的——因为它们根本就不是分开的。
- en: This is so true that it used to be common for some high-performance databases
    to forego using files to store their data and would store directly on the block
    devices themselves so that they were in the same position that a filesystem would
    normally be. But because there were no files, they were not actually filesystems.
    But for all intents and purposes, they were.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点非常正确，过去有些高性能数据库甚至会放弃使用文件来存储数据，而直接存储在块设备上，这样它们的位置和文件系统通常一样。但因为没有文件，它们实际上并不是文件系统。但在所有实际用途上，它们却是。
- en: This filesystem replacement process was popular as a means of improving system
    performance because filesystems used to represent noticeable overhead to the servers.
    Today, filesystem overhead is completely trivial and attempting to replace the
    filesystem today presents so much complexity and so many problems that it is all
    but avoided.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替代文件系统的过程曾经很流行，是为了提升系统性能，因为文件系统曾经会给服务器带来显著的开销。今天，文件系统的开销已经微不足道，而试图替代文件系统带来的复杂性和问题已经变得如此庞大，以至于几乎被完全避免。
- en: Once you think of a database as a sort of filesystem for your data, it all starts
    to make a lot more sense.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将数据库看作是数据的某种文件系统，一切就都变得更有意义了。
- en: The database engine is where all the real magic happens. The database itself
    is just the data sitting on the disk (or in memory.) Sure, it has a structure,
    but the structure is already there. The database does not create or enforce the
    structure or maintain it in anyway - all of that comes from the database engine.
    The database engine is the workhorse of the database stack. This is where the
    processing power goes, this is what we have to install, this is where the magic
    sauce gets applied.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库引擎才是真正的魔法所在。数据库本身仅仅是存放在磁盘上（或内存中的）数据。没错，它有结构，但这个结构已经存在。数据库并不创建、强制或以任何方式维护这个结构——所有这些工作都由数据库引擎完成。数据库引擎是数据库栈的主力军。这里是处理能力的来源，这就是我们需要安装的地方，也是魔法酱料被应用的地方。
- en: In some cases, we talk about database engines heavily. In some cases, we use
    them directly, like **SQLite** or **Berkeley DB**, where we just install the library
    (database engine) and access a file using it and voila, a working database system
    that we can use. Or in other cases, like if you use **MongoDB** or **MariaDB**
    products, you will often talk about the database engines that are being chosen
    under the hood (**WiredTiger**, **InnoDB**, **MyISAM**, and others) as key factors
    in database features and performance.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们会大量讨论数据库引擎。在一些情况下，我们直接使用它们，比如**SQLite**或**Berkeley DB**，我们只需安装库（数据库引擎），然后使用它访问一个文件，哇，系统就能工作了，可以用作数据库。或者在其他情况下，比如使用**MongoDB**或**MariaDB**产品时，我们常常会讨论在背后选择的数据库引擎（**WiredTiger**、**InnoDB**、**MyISAM**等），它们是影响数据库特性和性能的关键因素。
- en: Database engines get the raw deal in many cases with most people totally ignoring
    this all-important layer of the database services stack as it is hard to understand
    and generally hidden from view. Out of sight, out of mind applies heavily here.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库引擎在许多情况下得不到应有的关注，大多数人完全忽视了这一数据库服务栈中至关重要的一层，因为它很难理解，而且通常是隐藏在背后的。眼不见，心不烦，这里完全适用。
- en: In some cases, like BDB and SQlite that I mentioned previously, we, as the system
    administrator, would be responsible for installing these libraries onto our servers
    to make them available for software to access. But, of course, these are often
    listed simply as dependencies and get installed and maintained by the package
    management systems on our servers that come from our Linux distribution making
    this simple and potentially even transparent to us. Because of these, system administrators
    are often nearly oblivious to what database engines are deployed or in use on
    the systems that they maintain.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，比如我之前提到的BDB和SQLite，我们作为系统管理员，需要负责将这些库安装到服务器上，以便软件可以访问它们。当然，这些库通常仅作为依赖列出，并由我们服务器上的包管理系统自动安装和维护，这些包管理系统来自我们的Linux发行版，使得这一过程变得简单，甚至对我们来说可能是透明的。正因为如此，系统管理员往往几乎对他们所维护的系统上部署或使用的数据库引擎一无所知。
- en: It may seem obvious, but it is worth noting, that database engines are code
    libraries (aka drivers) and are not programs that run or services that we find
    running. So, detecting a specific database engine on a system might be rather
    difficult. Sure, if SQlite is installed by APT or DNF we can query the system
    and find it easily enough. It is a library that sits on disk, has a directory,
    and is in the package configuration logs. We do not get to see it running in a
    process list or find it in the services directory, but we can find it one way
    or another.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来显而易见，但值得注意的是，数据库引擎是代码库（即驱动程序），而不是运行的程序或服务。因此，在系统上检测特定的数据库引擎可能会相当困难。当然，如果通过APT或DNF安装了SQLite，我们可以查询系统并轻松找到它。它是一个存储在磁盘上的库，拥有一个目录，并且在包配置日志中有所记录。我们无法在进程列表中看到它的运行，也找不到它在服务目录中，但我们总能以某种方式找到它。
- en: But there is every possibility that the code of a database engine library will
    get included into and compiled into a software project making it all but impossible
    to detect as it is simply binary data on disk somewhere inside another application.
    Sure, a block level tool could scan through every piece of data on disk to look
    for on disk patterns but that is getting into an extreme level that is more for
    forensics or law enforcement and not very useful in system administration. From
    a practical perspective, a compiled-in database engine is completely invisible
    to anyone using the system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但完全有可能，数据库引擎库的代码会被包含到并编译到某个软件项目中，使其几乎不可能被检测到，因为它只是某个应用程序内部磁盘上的二进制数据。当然，块级工具可以扫描磁盘上的每一部分数据，查找磁盘上的模式，但这属于极端级别，更适用于取证或执法，而在系统管理中并不太有用。从实际角度来看，一个编译进软件中的数据库引擎对使用该系统的任何人来说都是完全不可见的。
- en: When we are discussing the performance or features of one database or another,
    nearly always these features or performance characteristics are coming from the
    database engine in use. In most cases the database engine will also implement
    either a query language or an application programming interface API for querying
    the data on disk.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论某个数据库的性能或特性时，几乎总是这些特性或性能特征来自正在使用的数据库引擎。在大多数情况下，数据库引擎还会实现查询语言或应用程序编程接口（API），用于查询磁盘上的数据。
- en: For those following along you have probably noticed that since a database engine
    does not *run* that you cannot access it remotely. In order to interact with a
    database engine, you have to use the driver in a program to interact with the
    database.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些跟随学习的人，你可能已经注意到，由于数据库引擎本身并不*运行*，因此你无法远程访问它。为了与数据库引擎进行交互，你必须在程序中使用驱动程序与数据库进行交互。
- en: The Database management system
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库管理系统
- en: The most visible component of the database stack, and the only piece that is
    totally optional, is the database management system, often shortened to DBMS.
    For most people, even very technical people with a lot of database experience,
    the only part of the database system of which they are aware is the database management
    system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库技术栈中最显眼的组件，也是唯一完全可选的部分，是数据库管理系统，通常缩写为DBMS。对于大多数人来说，甚至是那些具有丰富数据库经验的技术人员，唯一了解的数据库系统部分就是数据库管理系统。
- en: 'Before we dig into what exactly the database management system is, we should
    give some examples of real-world DBMS: **MySQL**, **MariaDB**, **PostgreSQL**,
    **Oracle DB**, **Microsoft SQL Server**, **IBM DB2**, **MongoDB**, **Redis**,
    **Firebase**, and so many more. These names should be much better known to most
    of you compared to database engine names.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解数据库管理系统究竟是什么之前，我们应该先举一些实际的DBMS例子：**MySQL**、**MariaDB**、**PostgreSQL**、**Oracle
    DB**、**Microsoft SQL Server**、**IBM DB2**、**MongoDB**、**Redis**、**Firebase**，以及更多其他的。这些名字对你们中的大多数人来说，比数据库引擎的名字更为熟悉。
- en: A DBMS does surprisingly little on its own. A DBMS is a program that uses one
    or more database engines to interact with the physical database on the disk and
    then provides access controls to that database. A DBMS might have a single database
    engine that is always associated with it, or like MySQL might provide access to
    a range of database engines while providing them a common interface to make it
    easy for developers to work with them. Those familiar with MySQL will be aware
    that when creating a new database inside of MySQL you must tell it which engine
    you want to use. Sure, there is a default in case you do not choose, but not choosing
    is very much a choice in that case.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: DBMS本身做的事情其实非常有限。DBMS是一个程序，它使用一个或多个数据库引擎与磁盘上的物理数据库进行交互，然后提供对该数据库的访问控制。DBMS可能有一个始终与之关联的单一数据库引擎，或者像MySQL一样，提供对一系列数据库引擎的访问，并为它们提供一个通用接口，使开发人员能够方便地使用它们。熟悉MySQL的人会知道，在MySQL中创建一个新数据库时，你必须告诉它你希望使用哪种引擎。确实，如果你不选择，它会有一个默认选项，但在这种情况下，不选择实际上也是一种选择。
- en: When working with a database engine you must specify the file or files that
    you are working with. So, any interaction with a database engine is only to a
    single database, whatever database is in that file. A DBMS does not typically
    work in this way. It is standard for a DBMS to have many databases connected to
    many *instances* of database engines which may be the same library instantiated
    multiple times or possibly different engines for different databases, all accessible
    at the same time. So much of what we picture as a database comes from the DBMS.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用数据库引擎时，你必须指定你正在操作的文件或文件集。因此，任何与数据库引擎的交互都仅限于单一的数据库，不管那个文件中存储的是哪个数据库。DBMS通常不是这样工作的。标准的DBMS会连接到多个数据库，这些数据库可能连接到多个*实例*的数据库引擎，这些引擎可能是相同的库被多次实例化，或者可能是不同的引擎用于不同的数据库，所有这些都可以同时访问。因此，我们所设想的数据库大部分来自DBMS。
- en: It is the DBMS that provides, optionally of course, a way to connect to a database
    over a network or even over the Internet. Any networking capability comes from
    the DBMS. Moreover, it is the DBMS that *runs*, generally as a service, on your
    computer. This is where you see memory consumption, CPU usage, and other database
    usage details. The DBMS often provides extended features that cannot exist in
    the engine itself, such as in-memory caching.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正是DBMS提供了（当然是可选的）通过网络或甚至通过互联网连接数据库的方式。任何网络功能都来自DBMS。此外，DBMS*运行*，通常作为服务，在你的计算机上运行。这就是你看到内存消耗、CPU使用情况以及其他数据库使用详情的地方。DBMS通常提供一些引擎本身无法提供的扩展功能，例如内存缓存。
- en: It should be obvious that in a pure database engine scenario that access control
    to the data in the database comes entirely from file system permissions. No different
    than opening a Word file with Microsoft Word. If you have read and write permissions
    on the file, and you can run the application that reads it, then you can read
    the file and write changes back to it. The same is tried with a database engine
    like SQLite. To allow a user to use the database you simply give them the filesystem
    permissions to do so. Very simple, and very limiting.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在纯数据库引擎的场景中，数据库中数据的访问控制完全来自于文件系统的权限。这就像用Microsoft Word打开一个Word文件一样。如果你对文件有读写权限，并且能够运行读取文件的应用程序，那么你就可以读取文件并将更改写回文件。对于像SQLite这样的数据库引擎，也可以尝试同样的方式。要允许用户使用数据库，你只需给他们相应的文件系统权限即可。这非常简单，但也非常有限。
- en: With a DBMS we have more options. Most DBMS add networking and with this we
    can use the database's own tools to control access on a granular level, plus we
    can use operating system and networking tools to control access additionally.
    This becomes much more complex, but from this complexity we get power and flexibility.
    It is common to the point of assumption that the DBMS will offer user level controls
    and machine level controls and often very granular control within the sets of
    data that are managed under it such as row, table, or document level controls
    depending on the type of database engine in use.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DBMS我们有更多的选择。大多数DBMS添加了网络功能，通过这些功能我们可以使用数据库自身的工具在粒度级别上控制访问权限，同时我们还可以使用操作系统和网络工具进一步控制访问。这变得更加复杂，但正是从这种复杂性中，我们获得了强大和灵活性。DBMS通常会提供用户级别的控制和机器级别的控制，并且通常在其管理的数据库集合中提供非常精细的控制，例如行、表或文档级别的控制，具体取决于使用的数据库引擎类型。
- en: A DBMS adds power and flexibility, along with some ease of use in most cases,
    to the database ecosystem. In production environments there is no reason that
    you cannot use a database engine directly and many people do. But by and large
    it is DBMS that rules enterprise data storage. When people use the term *database
    server* it is the host containing the DBMS that they mean, by definition. It is
    the networking capability of a DBMS that allows for databases to be stored on
    and served out of a dedicated server (or set of servers) rather than requiring
    the database to always be local to the application that is using it. This is a
    very important flexibility as applications grow and need more resources. For small
    applications where there are plenty of resources to host an entire application
    and its entire database on a single server you will normally get the best performance
    out of using a database engine directly. But once you scale beyond that a DBMS
    is what allows databases to get so much bigger.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库管理系统（DBMS）为数据库生态系统增加了强大的功能和灵活性，在大多数情况下也提高了易用性。在生产环境中，完全可以直接使用数据库引擎，很多人也确实这样做。但总体来说，DBMS主导着企业的数据存储。当人们使用*数据库服务器*这一术语时，按照定义，他们指的是包含DBMS的主机。正是DBMS的网络能力使得数据库能够存储在专用服务器（或服务器集群）上并从中提供服务，而不需要数据库始终与使用它的应用程序本地化。这种灵活性在应用程序增长并需要更多资源时非常重要。对于小型应用程序，在资源充足的情况下，可以将整个应用程序及其数据库托管在单个服务器上，通常直接使用数据库引擎能获得最佳性能。但一旦超出这种规模，DBMS则是支持数据库变得更大的关键。
- en: A database engine on its own is not strictly a single connection limited system,
    but it is effectively so. It is possible for multiple people to connect to the
    same file on the filesystem at the same time, but this presents obvious problems.
    What if two people attempt to write changes at roughly the same time, do they
    overwrite each other, how do you update others to changes being made, and so forth.
    It presents the same problems that are seen when you have a SAN and connect multiple
    servers to the same filesystem. It solves them using the same clustered filesystem
    mechanics inside the database file. (See, I told you that databases acted like
    filesystems!)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库引擎本身并不严格是一个单连接受限的系统，但它实际上是这样。虽然多个用户可以同时连接到文件系统中的同一个文件，但这会带来明显的问题。如果两个人试图在差不多相同的时间进行修改，是否会互相覆盖？如何通知其他人正在进行的更改？等等。这些问题与在SAN中连接多个服务器到同一文件系统时遇到的问题类似。它通过数据库文件内部使用相同的集群文件系统机制来解决这些问题。（看吧，我告诉过你，数据库就像文件系统！）
- en: File level locking and access control can work for light usage up to about five
    users before it starts to exhibit real performance problems. For heavy use it
    will be problematic for even just two connections. Microsoft Access is famous
    for encouraging the use of the JetDB database engine (often just called the Access
    Database) and having horribly performing file locking that makes it untenable
    to try to use the system with more than a handful of users. That same system can
    switch to using **MS SQL Server DBMS** and handle thousands of users without a
    problem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 文件级锁定和访问控制可以应对轻量级使用，最多支持大约五个用户，之后会开始出现明显的性能问题。对于重度使用，即便是两个连接也会变得有问题。微软Access以鼓励使用JetDB数据库引擎（通常称为Access数据库）而著称，且其文件锁定性能极差，导致系统无法承载超过少量用户的使用。相同的系统可以切换到使用**MS
    SQL Server DBMS**，并且能够处理数千个用户，毫无问题。
- en: So, for any real serious multiple connection situation (which can be caused
    by individual users or by many instances of a running service that needs to pull
    data from the database) a DBMS is required. There are so many more caching, locking,
    and permission control mechanics possible with a DBMS.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于任何真正需要多重连接的情况（这可能由单个用户或多个运行中的服务实例引起，它们需要从数据库中拉取数据），都需要使用DBMS。DBMS提供了更多的缓存、锁定和权限控制机制。
- en: Identifying a shared database engine versus DBMS
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别共享数据库引擎与DBMS的区别
- en: If you are new to databases, you may not be aware of common ways to identify
    the use of one approach or another. Some situations are extremely easy, like if
    you must configure networking connection details for the database with hostnames
    and ports then you know that a DBMS has to be involved. But not all situations
    are so obvious.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是数据库新手，可能不了解常见的识别方法来判断使用的是哪种方式。有些情况非常简单，比如如果你必须配置数据库的网络连接详细信息，包括主机名和端口，那么你就知道必须涉及DBMS。但并非所有情况都那么明显。
- en: Many applications handle a lot of their own connection details, and you may
    have little way to know how they are working under the hood. So other than looking
    for open ports or something similar you might be left in the dark.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 很多应用程序处理自己的连接细节，而你可能很难了解它们在背后是如何工作的。所以，除了寻找开放端口或类似的东西外，你可能会一无所知。
- en: One common mechanism, however, is requiring shared mapped drive access to a
    file or files. This is not needed by a DBMS in all but the rarest of cases and
    if it is, you have some serious performance issues. Sharing a database file directly
    to users or applications to access it is a sign of direct database engine use.
    This comes up with many legacy or poorly built applications and so you are likely
    to have come across it or to come across it in the future and know how database
    engines have to work helps to explain access, locking, performance, or even corruption
    problems with these deployments.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个常见的机制是要求共享映射驱动器访问文件或文件。这在除了极少数情况下的数据库管理系统（DBMS）中是不需要的，如果确实需要，那么你就遇到了严重的性能问题。将数据库文件直接共享给用户或应用程序进行访问是直接使用数据库引擎的标志。这种情况常见于许多遗留或构建不当的应用程序，因此你可能已经遇到过，或者将来会遇到，并且了解数据库引擎的工作方式有助于解释这些部署中访问、锁定、性能或甚至是数据损坏的问题。
- en: As system administrators, and potentially as database administrators, the assumption
    is that other than installing a database engine library, that our interaction
    with running databases will all be in the form of the DBMS. This is where we will
    have to manage and monitor services, resource utilization, security, patching,
    access controls, and the like.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统管理员，甚至可能作为数据库管理员，假设是除了安装数据库引擎库之外，我们与运行中的数据库的互动将全部通过数据库管理系统（DBMS）进行。在这里，我们需要管理和监控服务、资源利用、安
    全、补丁、访问控制等。
- en: We now have the knowledge of what databases are and how they work and what their
    components are so we can think critically about security and performance implications.
    Lacking this understanding of databases makes it very difficult to be able to
    deal with more complicated issues like performance tuning or effective backup
    measures. In the next section, we are going to talk about types of databases at
    a very high level to give us some insight into how system administrators may work
    with these different forms of data storage.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了数据库是什么、它们是如何工作的，以及它们的组成部分，这样我们就可以批判性地思考安全性和性能的影响。缺乏对数据库的理解，会使得解决更复杂的问题，如性能调优或有效的备份措施变得非常困难。在下一节中，我们将非常高层次地讨论数据库的类型，给我们一些关于系统管理员如何处理这些不同数据存储形式的见解。
- en: Comparing relational and NoSQL databases
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较关系型和 NoSQL 数据库
- en: 'Databases come in two major categories: *Relational* and *NoSQL*. These are
    terrible categories, but sadly it is how the world sees databases. These terms
    are truly awful for several reasons. First because NoSQL is a reference to being
    *not-relational*. Which means that databases are either relational or not relational.
    That''s pretty bad taxonomy right there. But it gets worse. SQL is the *structured
    query language* commonly associated with relational databases; it was a language
    written for querying relational databases. So, the term NoSQL refers to non-relational
    databases, but that''s like trying to refer to people who aren''t from England
    by calling them non-English speakers. The two can overlap, but often do not.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库分为两大类：*关系型* 和 *NoSQL*。这些分类非常糟糕，但不幸的是，它们就是世界上看待数据库的方式。这些术语非常糟糕，原因有几个。首先，NoSQL
    是指 *非关系型*。这意味着数据库要么是关系型，要么是非关系型。这本身就是一个很糟糕的分类法。更糟糕的是，SQL 是与关系型数据库常关联的 *结构化查询语言*；它是为查询关系型数据库而编写的语言。因此，NoSQL
    这个术语指的是非关系型数据库，但这就像试图通过称人们为非英语使用者来指代那些不是来自英格兰的人。两者有时会重叠，但通常不会。
- en: SQL is not some intrinsic language of relations; it is just a common convention
    used to query them. You can make a relational database that cannot use SQL language
    queries and just as easily you can make a non-relational database that does! Not
    only can you, but this is very common. So just to be clear, you can use SQL with
    a NoSQL database, and people do it all the time! What madness is this?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 不是关系的内在语言；它只是用于查询关系的常见约定。你可以创建一个不能使用 SQL 查询的关系型数据库，同样，你也可以创建一个可以使用 SQL 的非关系型数据库！不仅可以，事实上，这非常常见。所以，为了明确一点，你可以在
    NoSQL 数据库中使用 SQL，而且人们经常这么做！这是什么疯狂的事情？
- en: In the NoSQL world there are generally one or more query languages used by any
    given database. These tend to be unique to the individual database, but without
    some form of query language it is all but impossible to get data into or out of
    a data. It is these languages that form the basics of database communications
    with the applications that they support. As an example, MongoDB implements their
    own MongoDB Query Language.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NoSQL 世界中，通常每个数据库都会使用一种或多种查询语言。这些查询语言通常是特定于每个数据库的，但没有某种查询语言，就几乎不可能将数据导入或导出数据库。正是这些语言构成了数据库与应用程序之间通信的基础。例如，MongoDB
    实现了他们自己的 MongoDB 查询语言。
- en: So we have to accept that these terms are ridiculous from the beginning and
    just realize that we are talking about relational databases on one hand and all
    other non-relational databases on the other which is a collection of many different
    database technologies. This weird situation simply exists because most popular,
    well-known databases are relational and for a great many years it was assumed
    that only relational databases were *good enough* for production use. Something
    that has proven to not be in any way true but it has lingering effects in the
    industry.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们必须接受这些术语从一开始就很荒谬，并意识到我们所讨论的，一方面是关系型数据库，另一方面是所有其他非关系型数据库，这是一种包含许多不同数据库技术的集合。这种奇怪的情况之所以存在，仅仅是因为大多数流行且知名的数据库都是关系型的，且很多年里人们一直认为只有关系型数据库才是*足够好的*，适合生产使用。事实证明这一观点完全不正确，但它在行业中仍然产生着影响。
- en: NoSQL is therefore daunting on its own because it encompasses so many things,
    so many types of data structures. That said, we really do not have to understand
    them all. What we really need to understand is just that a NoSQL database can
    use any kind of on disk data structure (except, of course, to be relational) and
    may or may not use SQL or any other query language to be queried. This leaves
    more questions than answers. As a system administrator we will often simply be
    tasked with learning whatever database the applications that we support need.
    This may end up being something very common about which there is a broad amount
    of knowledge, or it might be something very obscure.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，NoSQL 本身就让人感到望而生畏，因为它包含了这么多的内容和数据结构类型。话虽如此，我们并不需要了解所有的内容。我们真正需要理解的只是，NoSQL
    数据库可以使用任何类型的磁盘上的数据结构（当然，除了关系型数据库），并且可能会使用 SQL 或其他查询语言，也可能不使用。这就留下了更多的问题而不是答案。作为系统管理员，我们通常只是被要求学习应用程序所需要的数据库。这可能是一些非常常见的数据库，关于它有大量的知识，或者它可能是一些非常冷门的数据库。
- en: The first databases were, by today's standards, NoSQL. This makes it odd that
    the earliest databases are thought of today in relation to not being something
    that came later. Early databases were extremely limited in capability. In the
    1970s relational theory came along and the first truly modern databases came with
    it. Relational databases were born and proved to be so safe and effective that
    other database forms all but fell by the wayside in short order. The relational
    database was the king and was here to stay.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一代数据库按今天的标准来看，实际上是 NoSQL 的。这就让人觉得很奇怪，为什么早期的数据库现在被认为与后来的数据库不同。早期的数据库功能非常有限。在
    1970 年代，关系型理论出现，随之而来的是第一批真正的现代数据库。关系型数据库诞生了，并且证明它们既安全又高效，以至于其他类型的数据库几乎在短时间内都被淘汰了。关系型数据库成为了王者，且永远存在。
- en: For nearly four decades, relational databases represented nearly all business
    class databases with all other database types existing as little more than historical
    footnotes. When used in applications they were often implemented uniquely by an
    application rather than being provided by a large database vendor. Because of
    this, even when used they were relatively unknown. A database engine implemented
    inside of an application is essentially invisible to a systems administrator so
    even if these were being deployed with some regularity only the original developers
    would have known. In fact, I got my start in my career writing a NoSQL database
    engine and a GUI data retrieval system for it at the end of the 1980s. I saw this
    artefact of developers using NoSQL and the information technology department having
    no visibility firsthand from the other side at the height of the relational database
    dominance time period.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，关系型数据库几乎代表了所有商业级数据库，其他类型的数据库几乎只存在于历史注脚中。当它们应用于实际系统时，通常是由应用程序独立实现的，而不是由大型数据库供应商提供。因此，即使它们被使用，它们也相对不为人知。一个嵌入在应用程序中的数据库引擎对系统管理员来说基本是不可见的，因此即使这些数据库引擎被定期部署，只有原始开发者才会知道。事实上，我的职业生涯开始于20世纪80年代末期，当时我为一个NoSQL数据库引擎编写了代码，并为其开发了一个图形化数据检索系统。我亲眼见证了开发者使用NoSQL数据库，而信息技术部门对其毫无了解的现象，这正是在关系型数据库占主导地位的时期。
- en: The strength of a relational database comes from how efficiently it can store
    data, something that was extraordinarily important in the early decades of databases
    when finding storage systems large enough to hold them was continuously a challenge;
    and from how well relational databases can handle things like transactions and
    data integrity. This makes relational databases extremely good for any kind of
    system that deals with financial or other critical transactions where we need
    a high level of assurance that a transaction is completed entirely or not at all.
    Early databases were naturally very strongly focused on financial transactions
    because these were the data storage operations that were so critical that they
    could justify the use of expensive computers to make sure that they were done
    accurately. When a database costs a few millions dollars to implement it is easy
    to see why it would be useful to a bank, but very hard to justify running a blog
    from it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库的优势来自于其存储数据的高效性，这在数据库早期几十年尤其重要，那时找到足够大的存储系统来容纳数据一直是一个挑战；同时，它还能很好地处理诸如事务和数据完整性等问题。这使得关系型数据库非常适合任何处理金融或其他关键事务的系统，这些系统需要高水平的保证，确保事务要么完全完成，要么根本不发生。早期的数据库自然非常注重金融事务，因为这些数据存储操作极为关键，足以证明使用昂贵计算机来确保数据准确无误的必要性。当数据库的实现成本达到几百万美元时，可以轻松理解为什么银行会使用它，但要为其运行一个博客就显得非常难以合理化了。
- en: Relational databases get their name because they are built to specify actual
    relationships between pieces of data. For example, if you create a piece of user
    data, you might create a piece of telephone number data, and create a relationship
    between them. Then you might make more data, an address, for example. The address
    will also relate to the user. The basic idea behind a relational database is that
    the database engine will actively control these relationships. Maybe it automatically
    deletes the phone and address if the user is deleted, maybe it guarantees that
    a phone number can only belong to one person, or it can show when multiple people
    live at the same address. It can even stop you from creating a phone number that
    does not match a certain format or might block you from filling in complete fields.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库得名于它们用于指定数据之间实际关系的方式。例如，如果你创建了一个用户数据，你可能会创建一个电话号码数据，并在它们之间建立关系。接着你可能会创建更多数据，比如地址。这个地址也会与用户有关联。关系型数据库背后的基本理念是数据库引擎会主动控制这些关系。比如，如果删除用户，它可能会自动删除电话和地址；它可能会确保一个电话号码只能属于一个人，或者可以显示多个人住在同一个地址。它甚至可以阻止你创建不符合某种格式的电话号码，或者阻止你填写不完整的字段。
- en: Relations might sound simple and superficial, but when put into well designed
    use they offer a lot of power to protect data integrity. They take a large load
    off of software developers and put data integrity into a position where the constraints
    used to protect the data remain even when the application that uses them is bypassed.
    Relational databases are a powerful mechanism. But that power comes at a cost
    to complexity.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库听起来可能简单且表面化，但当它们被精心设计并加以应用时，能够为数据完整性提供强大的保护。它们大大减轻了软件开发人员的负担，并且将数据完整性置于一个能确保保护数据的约束条件下，即使使用这些数据的应用程序被绕过了。关系型数据库是一种强大的机制，但这种强大是以复杂性为代价的。
- en: 'NoSQL databases, being free from the rules that govern relational databases
    and the assumed necessity of speaking a SQL dialect, can explore any number of
    data storage and integrity approaches. Some approach data with a *joie de vivre*
    carelessness that is downright shocking to traditional database administrators.
    Data can be just stored anywhere, without any controls. Sure, there might be structure,
    but the structure feels more like a suggestion than anything else. Coming from
    the hard and fast rules of relational theory, a document database, for example,
    feels like the wild west: throwing data willy nilly all over the place. One document''s
    structure might not even match the next document. It is datalogical mayhem.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库由于不受关系型数据库规则的约束，也不必使用SQL方言，因此可以探索各种数据存储和完整性方法。一些方法以一种*享乐主义*的随意态度处理数据，这对传统的数据库管理员来说简直是震惊。数据可以随意存储在任何地方，几乎没有任何控制。虽然可能存在某种结构，但这种结构更像是一种建议，而不是强制要求。从关系型理论的严格规则出发，例如，文档数据库就像是“荒野西部”：数据随意乱丢。一个文档的结构可能根本与下一个文档不匹配。这简直是数据逻辑的混乱。
- en: The real power of NoSQL comes from this flexibility. Instead of having to work
    in a single, strongly predefined way or with heavy constraints, we are free to
    use data as it makes the most sense for our specific needs. We can use blogging
    as a great example of something that is generally the polar opposite of financial
    data in terms of our concerns.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL的真正优势来自于这种灵活性。我们不再需要在一个强预定义的、严格约束的模式下工作，而是可以根据特定需求自由使用数据，选择最合适的方式。我们可以用博客作为一个极好的例子，它与财务数据在关注点上几乎是完全相反的。
- en: With financial data we are generally concerned heavily with accuracy and consistency
    and transactional completeness. With a blog we tend to care about speed and little
    else. If we have a popular website and need to make our blog available all over
    the world with lightning speed, we will likely want to have nodes serving out
    that content from locations all over the world so that most people can pull a
    relatively local copy of the blog rather than using a distant, centralized blog
    that might be hosted on another continent.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于财务数据，我们通常非常关注准确性、一致性和事务完整性。而对于博客，我们更多关注的是速度，其他的则不太重要。如果我们有一个受欢迎的网站，并希望让我们的博客在全球范围内快速访问，我们很可能会希望通过全球各地的节点来提供该内容，从而让大多数人能够从相对本地的副本中获取博客内容，而不是使用一个可能托管在其他大陆上的远程集中式博客。
- en: A database that serves out the content via replication to many regions and does
    so with speed being the top priority can do things like miss the latest updates
    or get them out of order temporarily while data is updated, something that a relational
    database would be designed to avoid. Being able to replicate data as time allows
    while still serving out whatever data is available locally can make for very noticeable
    performance improvements. For many workloads, this performance tradeoff is ideal.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通过复制到多个地区来提供内容的数据库，并且将速度作为首要优先级，可能会错过最新的更新，或在数据更新过程中短暂地出现顺序错乱，而这正是关系型数据库设计时会避免的情况。能够在时间允许的情况下复制数据，同时仍然提供本地可用的数据，可以带来显著的性能提升。对于许多工作负载而言，这种性能权衡是理想的选择。
- en: As we move to a world where more and more systems become computerized, more
    and more of those workloads use databases and this means that the ways in which
    databases need to be used are getting broader. Databases are often *free* or incredibly
    low cost to implement today and that means that nearly everything is utilizing
    them at some point. It is no longer a world where they are exclusively for highly
    demanding workloads.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的系统被计算机化，越来越多的工作负载使用数据库，这意味着数据库的使用方式正在变得更加广泛。如今，数据库的实现往往*免费*或成本极低，这意味着几乎所有事情都将在某个阶段使用数据库。如今，数据库不再是仅仅为高需求工作负载所专用的工具。
- en: Databases that provide only very simple lookups, session caches, and similar
    are not common. Or databases that replace text files for logging allowing for
    faster access to log data and, more importantly, robust searches of those logs
    can now be found almost everywhere. NoSQL is making the world of databases more
    powerful and flexible.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 仅提供非常简单的查找、会话缓存等功能的数据库并不常见。或者是替代文本文件用于日志记录的数据库，能够更快速地访问日志数据，并且更重要的是，可以对这些日志进行强大的搜索，现在几乎随处可见。NoSQL
    正在让数据库世界变得更加强大和灵活。
- en: As system administrators it will be very rare, if ever, that we are able to
    choose which database type will be used for a task. Even knowing which database
    types are most useful in different situations is likely to be unnecessary, while
    potentially very interesting. Far more importantly, we need to understand that
    databases now come with wonderous variety, share certain common factors as they
    relate to systems administration, no longer have the built-in assumptions such
    as SQL being a universal language, and that our applications will determine what
    database types and products that we need to learn and support.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统管理员，我们很少，甚至几乎不可能，有机会选择在任务中使用哪种数据库类型。即使了解哪些数据库类型在不同情况下最为有用，这通常也是不必要的，尽管这可能非常有趣。更重要的是，我们需要理解，数据库现在呈现出丰富的多样性，尽管它们之间有许多共同的系统管理特点，但不再有诸如
    SQL 是通用语言的内建假设，而我们的应用程序将决定我们需要学习和支持哪些数据库类型和产品。
- en: Understanding that relational and NoSQL represents our *two camps* of database
    products we will next take a brief survey of actual products most likely to be
    found in your Linux ecosystem today.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 理解关系型和 NoSQL 数据库代表着我们*两大阵营*的数据库产品后，我们将简要概述目前在你的 Linux 生态系统中最有可能出现的实际产品。
- en: Discovering common databases on Linux
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 上发现常见的数据库
- en: Most operating systems have one or two really popular, key database products
    associated with them. On Windows this is Microsoft SQL Server, for example. Linux
    is very different in this regard. Not only is one singular database product not
    closely ideologically associated with the operating system, but there is typically
    a plethora of database options available already included in nearly every Linux
    distribution. This makes it so much more challenging to be prepared to be a Linux
    system administrator because the expectation that you are knowledgeable of and
    ready to manage any number of various database products exists. Your theoretical
    Windows system administrator counterpart would, culturally, need only have knowledge
    of one very predictable product to claim base knowledge of the entire field. Many
    databases *can run* on Windows, but anything other than MS SQL Server is considered
    an oddity and specialized knowledge. There would never be an expectation that
    you had any experience or knowledge of them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统都有一两个非常流行的关键数据库产品与之相关。例如，Windows 上的数据库产品是 Microsoft SQL Server。Linux
    在这方面则完全不同。Linux 不仅没有一个特定的数据库产品与操作系统紧密地在意识形态上相关，而且通常有大量的数据库选项已经包含在几乎每个 Linux 发行版中。这使得成为一名
    Linux 系统管理员变得更加具有挑战性，因为人们期望你不仅要了解各种不同的数据库产品，还要能够管理它们。与此相对的 Windows 系统管理员通常只需要了解一个非常固定的产品，就可以声称自己具备了该领域的基础知识。尽管许多数据库*可以运行*在
    Windows 上，但除了 MS SQL Server 之外的其他任何数据库都被视为特例和专业知识，通常不会期望你有任何相关经验或知识。
- en: On Linux there may not be an expectation in most cases that you have truly deep
    knowledge of every possible database option, but that you know many of them and
    are prepared to administer nearly any is quite common. It is common for single
    servers to deploy multiple database management systems because they are built
    in and tend to be more purpose-built compared to say MS SQL Server and so using
    one database management system for one specific set of tasks and another for something
    with a very different data storage need is common and can be quite effective.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，大多数情况下不会期望你对每个可能的数据库选项都具备非常深入的知识，但期望你了解其中的许多并能够准备好管理几乎任何数据库系统是相当普遍的。单个服务器上部署多个数据库管理系统是很常见的，因为它们是内建的，并且相比
    MS SQL Server 更加针对特定目的，因此一个数据库管理系统负责某一特定任务，另一个负责处理数据存储需求截然不同的任务是常见的，并且非常有效。
- en: We will maintain the natural assumed division in database categories and look
    at common relational database products as well as non-relational or NoSQL database
    products.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持数据库类别的自然划分，考察常见的关系型数据库产品以及非关系型或 NoSQL 数据库产品。
- en: Common relational databases on Linux
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux 上常见的关系型数据库
- en: Probably the four best known databases on Linux, and some might be the best-known
    databases anywhere, are the relational databases. The big four are **MySQL**,
    **MariaDB**, **PostgreSQL**, and **SQLite**. Easily in fifth and sixth place,
    in no particular order, are **Firebird** and **MS SQL Server**. Yes, you read
    that right, the key Windows ecosystem database product is available on Linux.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 可能在 Linux 上最著名的四个数据库，甚至可能是全球最著名的数据库，是关系型数据库。这四个大牌是**MySQL**、**MariaDB**、**PostgreSQL**
    和 **SQLite**。排名第五和第六的数据库（不分先后）是 **Firebird** 和 **MS SQL Server**。没错，你没看错，那个 Windows
    生态系统中的关键数据库产品也可以在 Linux 上使用。
- en: MySQL
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MySQL
- en: More than any other database, MySQL is synonymous with Linux systems. MySQL
    might be best known on Linux, but it is officially available on Windows as well
    and gets a reasonable amount of use there. MySQL is powerful and very fast and
    extremely well known. Nearly every Linux system administrator has worked with
    it at some point. MySQL is a full database management system that includes multiple
    database engines within it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他数据库相比，MySQL 与 Linux 系统几乎是同义词。MySQL 可能在 Linux 上最为人知，但它也正式提供 Windows 版本，并在
    Windows 上有一定的使用量。MySQL 功能强大、速度极快且极其知名。几乎每个 Linux 系统管理员都曾经使用过它。MySQL 是一个完整的数据库管理系统，包含多个数据库引擎。
- en: MySQL gained its first real popularity by being the database used to power early
    dynamic websites. It was free, fast, and its lack of more advanced features often
    required for financial transactions did not matter to content management engines
    for blogging and similar dynamically generated site content. MySQL became known
    as the *go to* product for website needs but was often eschewed for other needs
    because of that stigma.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 首次真正流行是作为早期动态网站的数据库。它免费、速度快，且缺乏更高级的金融交易所需的功能对于内容管理引擎（如博客和类似的动态生成内容的站点）来说并不重要。MySQL
    被称为*首选*产品，用于网站需求，但由于这种刻板印象，它常常被其他需求排除在外。
- en: Today MySQL is mature, advanced, and loaded with nearly any feature that you
    are likely to need for any type of workload. If you are going to learn only one
    database management, MySQL is certainly going to be it (or MariaDB, which I will
    explain shortly.) MySQL enjoys the broadest deployed user base, and by far the
    best overall industry knowledge penetration with almost any system administrator
    with Linux experience and a good number without being able to administer it with
    confidence. A large number of standard tools also exist for it, such as phpMyAdmin,
    which can make working with it even easier when you want to avoid, or move beyond,
    the command line. MySQL is used by nearly every major application project, at
    least optionally, that is made for Linux. It may not be the database most often
    deployed, but it is the database (when combined with MariaDB) most often deployed
    *intentionally* on not just Linux, but all operating systems combined.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的 MySQL 已经成熟、先进，具备几乎所有你可能需要的功能，适用于任何类型的工作负载。如果你只打算学习一个数据库管理系统，MySQL 肯定是最好的选择（或者是
    MariaDB，我稍后会解释）。MySQL 拥有最广泛的用户基础，几乎所有具备 Linux 经验的系统管理员，以及很多没有 Linux 经验的管理员，都能自信地管理它。针对它也有大量标准工具，比如
    phpMyAdmin，当你想避免或超越命令行时，它能让你更轻松地使用 MySQL。几乎所有为 Linux 开发的主要应用项目都在某种程度上使用 MySQL，尽管它可能不是最常部署的数据库，但与
    MariaDB 结合使用时，它是最常被*有意*部署的数据库，不仅在 Linux 上，在所有操作系统上都是如此。
- en: MariaDB
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MariaDB
- en: There is really no way to talk about MySQL without mentioning MariaDB. MySQL's
    community and direction was divided a number of years ago and many of the original
    MySQL team left the product and took the open-source base with them and created
    MariaDB to be what they felt would be the spiritual successor to MySQL. To many,
    MariaDB is the *real* MySQL, given that it is ideologically aligned with the original
    product, is equally built from the same code base, and is built by the original
    team. Many, and probably the majority, of Linux distributions dropped MySQL and
    switched to using MariaDB instead. So much so, that most people who say that they
    use MySQL today actually use MariaDB - often without even knowing it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很难谈论 MySQL 而不提到 MariaDB。MySQL 的社区和方向在多年前分裂，许多原 MySQL 团队成员离开了这个项目，将开源基础带走，创建了
    MariaDB，旨在成为他们认为的 MySQL 的精神继任者。对许多人来说，MariaDB 才是*真正的* MySQL，因为它在理念上与原始产品一致，完全基于相同的代码库构建，而且由原始团队开发。许多
    Linux 发行版，可能大多数，放弃了 MySQL，改用 MariaDB。甚至现在，大多数声称使用 MySQL 的人实际上是在使用 MariaDB——往往连他们自己都不知道。
- en: Drop In replacements
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 即插即用替代品
- en: MariaDB's real claim to fame is that it is a full *drop-in replacement* for
    MySQL. That means that it is designed to be able to be used, completely transparently,
    anywhere that MySQL would be used. It uses the exact same protocols, interfaces,
    tools, names, ports, conventions, and others. Everything, in theory, is the same.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: MariaDB 的真正亮点是它是 MySQL 的完整 *即插即用替代品*。这意味着它被设计成能够完全透明地在任何使用 MySQL 的地方使用。它使用完全相同的协议、接口、工具、名称、端口、约定等。理论上，所有的东西都是一样的。
- en: MariaDB does this so well that many people say that they are using MySQL, when
    in fact they are using MariaDB. Some say it is kind of like a code. Others say
    it because management expects one thing, and it is not worth trying to explain
    why MariaDB is used instead of MySQL. Still others just have no idea that that
    is not what they installed. The most common tool for managing MariaDB is the `mysql`
    command line tool and that is quite often the closest thing to an actual view
    of the system that many people get. A database designer or a developer working
    on a system would only need to know that the system is MySQL compatible. There
    is no real artefact to lead them to suspect that it is one product or the other.
    They truly do look and act the same.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: MariaDB 做得如此出色，以至于许多人在说自己使用 MySQL 时，实际上他们使用的是 MariaDB。有些人说这有点像是一种代码；还有人说是因为管理层期望这样做，而解释为什么使用
    MariaDB 而非 MySQL 是不值得的；还有一些人根本不知道自己安装的不是 MySQL。管理 MariaDB 最常用的工具是 `mysql` 命令行工具，这也是许多人接触系统时最接近实际系统的工具。一个数据库设计师或开发人员只需要知道该系统与
    MySQL 兼容。没有真正的迹象让他们怀疑这到底是某个产品或另一个产品。它们看起来和运行起来的方式完全一样。
- en: It is common for people to now refer to the famous LAMP stack, which used to
    be Linux + Apache + MySQL + PHP, as being Linux + Apache + MariaDB + PHP. It seems
    that MariaDB has truly taken over MySQL's former position in the market. But it
    is extremely difficult to gauge this accurately as an indeterminately large percentage
    of the MariaDB market reports itself to be using MySQL either because they do
    not realize that they are different, they casually report inaccurately, or they
    truly have no idea what they are using.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在人们常常提到著名的 LAMP 堆栈，曾经是 Linux + Apache + MySQL + PHP，现在变成了 Linux + Apache +
    MariaDB + PHP。看起来 MariaDB 确实已经完全取代了 MySQL 在市场中的位置。但很难准确评估这一点，因为在 MariaDB 市场中，有一个不确定的大比例部分报告自己使用
    MySQL，要么是因为他们没有意识到它们是不同的，要么是因为他们随意报告不准确，要么是他们根本不知道自己在使用什么。
- en: Drop in compatibility gives the additional benefit that learning MySQL means
    learning MariaDB and vice versa. You do not need to learn one or the other, since
    everything you do with one is identical on the other.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 即插即用的兼容性带来了额外的好处，即学习 MySQL 就意味着学习 MariaDB，反之亦然。你无需学习一个或另一个，因为你在一个系统上做的所有事情，在另一个系统上也完全一样。
- en: PostgreSQL
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: Pronounced *post gress* no matter how unlike that it looks, PostgreSQL is arguably
    the most mature and advanced database available on Linux systems today. PostgreSQL
    (originally written POSTGRES) was started in the 1980s as a successor to the successful
    Ingress database product (**Postgres** meaning **POST inGRESs**.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无论看起来多么不相似，*post gress* 的发音使得 PostgreSQL 可以说是今天在 Linux 系统上最成熟和先进的数据库。PostgreSQL（最初写作
    POSTGRES）始于 1980 年代，作为成功的 Ingress 数据库产品的继任者（**Postgres** 意味着 **POST inGRESs**）。
- en: Today, PostgreSQL is often considered the fastest, most stable, and most feature
    rich database product available on Linux and possibly at all. Database distinctions
    of this nature are typically more opinion than anything else as performance measurements
    are rarely directly comparable and variances in features often outweigh straight
    query performance, but PostgreSQL's reputation is one of unmitigated excellence,
    but at a cost of being more complex and less well known compared to its competition
    which are generally perceived as being simpler systems.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，PostgreSQL 常被认为是 Linux 系统上最快速、最稳定、功能最丰富的数据库产品，甚至可能是所有数据库中最优秀的。像这样的数据库区别通常更多的是个人意见，因为性能测量很少可以直接比较，并且功能差异往往比直接的查询性能更为重要，但
    PostgreSQL 的声誉无疑是无可匹敌的卓越，代价是相比于其竞争对手，它更复杂且不太为人所知，而后者通常被认为是更简单的系统。
- en: In recent years, PostgreSQL has seen a major resurgence in popularity. More
    and more today you will find that software that you deploy supports and even recommends
    it as the database of choice, a major change in the database winds since the heyday
    of MySQL a decade or more ago.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，PostgreSQL 在流行度上经历了重大复兴。今天，你会发现越来越多的部署软件支持并甚至推荐它作为首选数据库，这是自十多年前 MySQL 的全盛时期以来，数据库界的一大变化。
- en: As a Linux system administrator, the PostgreSQL database ecosystem is a solid
    second, if not first choice, alongside MySQL (and MariaDB which are identical)
    to learn as most Linux system administrators will need to manage PostgreSQL at
    some point.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名 Linux 系统管理员，PostgreSQL 数据库生态系统是一个稳固的第二选择，甚至可能是首选，与 MySQL（以及与 MySQL 相同的
    MariaDB）一起学习，因为大多数 Linux 系统管理员在某个时刻都需要管理 PostgreSQL。
- en: SQLite
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLite
- en: Far more commonly used than most system administrators realize is `sqlite` client
    utility that you can use to read and alter a SQLite database file, but this is
    nothing like a database server.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 比大多数系统管理员意识到的更常用的是 `sqlite` 客户端工具，你可以用它来读取和修改 SQLite 数据库文件，但这与数据库服务器完全不同。
- en: SQLite's power is in how simple and subtle it is. Outside of having its access
    library installed, a system administrator typically needs no knowledge of SQLite
    existing on the system. It does not get tuned or configured. It just exists. And
    because of the magic of software repositories and automated dependency management,
    SQLite tends to get deployed simply as a dependency to another piece of software
    and we might not even be aware that we have installed it or that it is available.
    It just appears automagically and does its job. It is possible that it is even
    built into an application that uses it and it may not even appear in a form that
    we can search for on the system!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 的强大之处在于它的简单与微妙。除了安装其访问库外，系统管理员通常不需要了解系统中是否存在 SQLite。它不需要调优或配置。它就存在在那里。由于软件仓库和自动依赖管理的魔力，SQLite
    通常会作为其他软件的依赖项被部署，我们甚至可能没有意识到它已被安装或可用。它自动出现并完成它的工作。甚至它可能被内建在使用它的应用程序中，且可能以我们无法在系统中搜索到的形式存在！
- en: 'Because of how it exists and gets deployed most of the time, the average deployment
    of SQLite is unknown to everyone that uses the system. A normal installation does
    not hide the driver: a system administrator looking to discover it or patch it
    or to just find out where it exists would have little problem in doing so. But
    unless you are looking for it specifically, a typical server will have hundreds
    or even thousands of packages of this nature and we cannot generally invest the
    time into knowing which libraries exist on every system, let alone know which
    software depends on which packages. It just is not practical.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SQLite 的存在和部署方式大多数时候是这样，普通用户对 SQLite 的部署情况一无所知。正常的安装并不会隐藏驱动程序：系统管理员如果想要发现它、修补它或仅仅是查找它在哪里，通常都不会遇到什么困难。但是除非你特别在寻找它，典型的服务器上可能会有数百甚至上千个类似的软件包，我们通常无法花时间去了解每个系统上存在哪些库，更不用说知道哪些软件依赖于哪些包了。这实在是不切实际的。
- en: Firebird
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Firebird
- en: Dramatically less well known than MySQL, PostgreSQL, SQLite, and MariaDB is
    **Firebird**. Firebird is a complete and mature database management system based
    on Interbase 6 but split off from that project in 2000\. While considered relatively
    minor software in the Linux world, Firebird is nevertheless a capable and mature
    database management system whose primary claim to fame is around the overall small
    amount of system resources necessary to run it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 相比 MySQL、PostgreSQL、SQLite 和 MariaDB，**Firebird** 的知名度要低得多。Firebird 是一个完整且成熟的数据库管理系统，基于
    Interbase 6，但在 2000 年与该项目分离。尽管在 Linux 世界中被视为相对次要的软件，但 Firebird 依然是一个功能强大且成熟的数据库管理系统，其主要的特点是所需的系统资源非常少。
- en: Firebird is far more likely to come up in conversation than to actually end
    up being deployed on one of your servers. It simply is not very common. Linux
    has no shortage of database options and that makes it difficult to get any traction,
    even when you have a mature and serious database option like Firebird.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Firebird 在对话中出现的概率远高于实际部署到你的服务器上。它实在是不太常见。Linux 上有很多数据库选项，这使得即便像 Firebird 这样成熟且严肃的数据库选项也很难获得关注。
- en: Microsoft SQL Server
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Microsoft SQL Server
- en: This entrant on the list is always very shocking to those not aware of its availability.
    Long considered one of the best database products on the market, MS SQL Server
    was always limited only to Microsoft Windows operating systems. But in recent
    years Microsoft, in an attempt to gain traction in the more lucrative database
    licensing space (when compared to operating system licensing) has been releasing
    MS SQL Server to Linux as well as to Windows. Today, MS SQL Server is a completely
    rational and viable option for Linux system administrators to see.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这份榜单上的参与者总是让那些不了解其可用性的人感到震惊。长期以来，微软SQL Server被认为是市场上最好的数据库产品之一，但始终仅限于微软Windows操作系统。但近年来，微软试图在数据库许可空间（与操作系统许可相比更具吸引力）获得更多市场份额，开始将MS
    SQL Server发布到Linux以及Windows上。如今，MS SQL Server对Linux系统管理员来说已经是一个完全合理且可行的选择。
- en: Like most of the more traditional options on this list, MS SQL Server is a complete
    database management system with multiple database engines under the hood. It is
    a big product with a lot of bells and whistles.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 像这份榜单上大多数传统选项一样，MS SQL Server是一个完整的数据库管理系统，其内部有多个数据库引擎。它是一个功能强大的产品，具备许多高级功能和特性。
- en: MS SQL Server remains uncommon on Linux, and likely will for quite some time.
    But it is already far more common than Firebird, for example. Database departments
    are often focused very heavily on Linux, or at least UNIX in general, and so it
    has been problematic if applications require MS SQL Server and that a team that
    otherwise typically does not use Windows Server is required to manage a wholly
    different platform just for one database product.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: MS SQL Server在Linux上仍然不常见，并且可能会在相当长的时间内保持这种状态。但它已经比例如Firebird要普遍得多。数据库部门通常非常专注于Linux，或者至少是UNIX系统，因此如果应用程序需要MS
    SQL Server，而团队通常不使用Windows Server，则必须管理一个完全不同的平台，这是一个问题。
- en: Common NoSQL Database Products on Linux
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux上常见的NoSQL数据库产品
- en: If the list of relational database products seems long, that is nothing compared
    to the potential list of NoSQL or non-relational database products that we can
    potentially discuss. Unlike the relational list where all of the products work
    in similar ways and would make sense for use by similar software tasks, the NoSQL
    list varies widely. What is an amazing product for one task might be completely
    useless for another.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关系数据库产品的列表看起来很长，那与我们可以讨论的NoSQL或非关系数据库产品的潜在列表相比根本不算什么。与关系数据库列表不同，其中所有产品都以类似的方式工作，并且适合由类似的软件任务使用，NoSQL列表变化多端。对于一个任务来说是一个了不起的产品，对于另一个任务来说可能完全没用。
- en: We cannot possibly go into all of the details of each of these database products,
    or even just all of the different types of databases that are lumped into this
    catchall of a category. We could easily fill a book this size with NoSQL database
    examples alone. We will do our best to race through and give enough highlights
    to make you appreciate what products are out there, why you care, and where to
    start your own investigations into products that you may want to learn about on
    your own.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不可能详尽介绍这些数据库产品的所有细节，甚至只是涵盖这个类别的各种数据库类型。仅仅是NoSQL数据库的例子就可以轻松填满一本这样大小的书。我们将尽力快速概述并提供足够的亮点，让您了解存在哪些产品、为何重视以及如何开始自己的产品调研。
- en: MongoDB
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MongoDB
- en: Definitely the mind-space leader of the NoSQL field is MongoDB. MongoDB is what
    is known as a document database management system. Like many of the database management
    systems that we have mentioned, MongoDB can use multiple database engines, but
    nearly everyone who uses it today uses its **WiredTiger** database engine. Document
    databases are one of the closest NoSQL database types to a relational database
    with many situations where both would be capable of doing the job. A document
    database is almost as if we took a relational database and a traditional filesystem,
    and they met in the middle.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无疑，在NoSQL领域的头号领导者是MongoDB。MongoDB被称为文档数据库管理系统。像许多我们提到的数据库管理系统一样，MongoDB可以使用多个数据库引擎，但如今几乎所有使用它的人都使用其**WiredTiger**数据库引擎。文档数据库是最接近关系数据库的NoSQL数据库类型之一，许多情况下两者都能胜任。文档数据库几乎就像我们把关系数据库和传统文件系统放在一起，它们在中间相遇。
- en: Document databases
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档数据库
- en: Document databases store structured documents. While every document database
    can use its own format and approach, the concept is universal. A good example
    could be XML. XML could be the format of an individual document inside of a document
    database. The database may dictate the structure of the XML, or it might be freeform.
    The database might contain millions of these XML documents.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 文档数据库存储结构化文档。尽管每个文档数据库可以使用自己的格式和方法，但这一概念是通用的。一个好的例子是 XML。XML 可以是文档数据库中单个文档的格式。数据库可能会规定
    XML 的结构，或者它可能是自由格式的。数据库可能包含数百万个这样的 XML 文档。
- en: Since the database knows the intended use of the documents that it contains,
    it is able to use common fields throughout the documents to generate indexes and
    other artefacts to empower the database to do so much more that you could do if
    you were to simply save many XML documents to your hard drive.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库知道其包含文档的预期用途，因此它能够使用文档中的共同字段生成索引和其他工件，使数据库能够执行更多操作，远超过你将这些 XML 文档简单保存到硬盘上所能做到的。
- en: But it only takes a simple example like this before it begins to be obvious
    why a file system is truly not just a database, but a document database specifically!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但只需要像这样的一个简单例子，你就会开始明显地意识到文件系统不仅仅是一个数据库，而是一个专门的文档数据库！
- en: Document databases tend to be easy to use and very straightforward making life
    easy for developers and system administrators alike. They have proven to be a
    highly desired and effective alternative to relational databases for many common
    workloads.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 文档数据库通常易于使用，非常直观，使开发人员和系统管理员的工作变得轻松。它们已被证明是关系型数据库在许多常见工作负载中非常理想且有效的替代品。
- en: MongoDB is broadly deployed and used in a large variety of situations. Like
    most of the relational database examples that we mentioned initially, MongoDB
    can be found commonly with third party software packages, with Linux distribution
    vendor packages, while also remaining popular with internal software teams for
    bespoke development. If you are going to start experimenting with a NoSQL database
    on Linux, I would generally start with MongoDB as this is almost certainly going
    to be the most useful experience to have, even if MongoDB itself never ends up
    being a database management system that you support in production.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 在各种不同的场景中得到了广泛部署和使用。像我们最初提到的大多数关系型数据库示例一样，MongoDB 通常与第三方软件包一起使用，也会在
    Linux 发行版供应商的软件包中出现，同时它也在内部软件团队进行定制开发时仍然很受欢迎。如果你打算在 Linux 上开始尝试 NoSQL 数据库，我通常会建议你从
    MongoDB 开始，因为即使 MongoDB 最终没有成为你在生产环境中支持的数据库管理系统，它几乎肯定会提供最有价值的经验。
- en: MongoDB is a great way to explore many alternative database approaches, many
    of which have become somewhat standard in the *post relational* world.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是探索许多替代数据库方法的绝佳途径，其中许多方法在 *关系型之后* 的世界中已经成为某种标准。
- en: While document databases have proven to be the most common alternative to relational
    databases for common software usage, not many document databases have risen to
    prominence. MongoDB is the only really large, well-known example. Other examples
    are **Apache CouchDB** and **OrientDB** as a database management system and **NeDB**,
    a database engine with nearly identical data structures to MongoDB.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然文档数据库已被证明是关系型数据库在常见软件使用中的最常见替代方案，但并不是很多文档数据库都崭露头角。MongoDB 是唯一一个真正的大型、知名的例子。其他例子包括
    **Apache CouchDB** 和 **OrientDB** 作为数据库管理系统，以及 **NeDB**，它是一个数据库引擎，数据结构几乎与 MongoDB
    完全相同。
- en: Redis
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redis
- en: A completely different approach to storing data is Redis, which is what is known
    as a key-value store database management system. This type of database is much
    more popular as an assistant datastore rather than a primary one. The idea behind
    a key-value store is that the application using the database supplies a key and
    the database returns the data associated with that key. It is an extremely simple
    mechanism compared to the types of databases that we have already encountered,
    but it is a very useful one.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 存储数据的另一种完全不同的方法是 Redis，它是一种所谓的键值存储数据库管理系统。这种类型的数据库作为辅助存储而非主要存储更加流行。键值存储的思想是，使用该数据库的应用程序提供一个键，数据库返回与该键关联的数据。与我们已经遇到的数据库类型相比，它是一种极其简单的机制，但却是非常有用的。
- en: Key-value stores (sometimes called dictionary lookups) are commonly used for
    high-speed online caches and can be a great way to manage such data as we might
    store when managing sessions. It would be rare, but not impossible, for an application
    to use a key-value database as the only data storage mechanism. It is almost always
    just one piece of a multi-part database strategy.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 键值存储（有时称为字典查找）常用于高速在线缓存，是管理如会话数据等数据的一种极好方式。虽然应用程序仅使用键值数据库作为唯一数据存储机制的情况很少，但也不是不可能。几乎总是作为多部分数据库策略中的一部分。
- en: Redis brings many of the advanced features needed for giant online applications
    to the key-value space, such as the ability to cluster across nodes and convenient
    access methods that make it very popular in large applications. It's performance
    and simplicity make it popular in web hosting realms.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 为巨型在线应用提供了许多所需的高级功能，例如跨节点集群的能力和方便的访问方法，这使得它在大型应用中非常受欢迎。它的性能和简便性使其在网页托管领域广受青睐。
- en: Other key-value stores remain popular such as **memcached** which is extremely
    popular on Linux for web hosting, **LevelDB** and even a key-value database engine
    under **MS SQL Server**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 其他的键值存储仍然很受欢迎，例如**memcached**，它在 Linux 上用于网页托管非常流行，**LevelDB**，甚至是**MS SQL Server**下的一个键值数据库引擎。
- en: Cassandra
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cassandra
- en: A key (pun intended) competitor with relational and document databases for the
    *general purpose application* space is the wide column database and the big name
    here is Cassandra. Wide column databases deserve more attention and description
    than we can afford here, but needless to say they primarily tackle the same workloads
    as relational databases with an eye towards greater flexibility and scalability
    in most cases.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与关系型数据库和文档数据库在*通用应用*领域的主要竞争对手是宽列数据库，最著名的就是 Cassandra。宽列数据库比我们在这里能涵盖的要更值得关注和描述，但无需多言，它们主要处理与关系型数据库相同的工作负载，并且在大多数情况下关注于更大的灵活性和可扩展性。
- en: Along with Cassandra, **Apache HBase** and **ScyllaDB** are major wide column
    databases common to Linux. You will not find this kind of database as frequently
    as you will see key-value and document, but it has some traction and is easy to
    acquire and experiment with if you are looking to expand your knowledge of database
    specifics or types.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Cassandra 一起，**Apache HBase**和**ScyllaDB**是常见的 Linux 下的主要宽列数据库。你不会像看到键值和文档数据库那样频繁遇到这种类型的数据库，但它有一定的市场份额，且易于获取和实验，如果你希望扩展自己对数据库特性或类型的了解，它是个不错的选择。
- en: 'And beyond: NoSQL is not constrained by definitions and special purpose databases
    and database types keep arising. I would recommend also investigating **Amazon
    OpenSearch**, a search database, and **InfluxDB** and **Prometheus**, time series
    databases. All three of these databases, and both types of databases, are typically
    used in storing log or log-like data at high speed and great volume.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步：NoSQL 并不局限于定义，专用数据库和数据库类型不断涌现。我还建议你调查一下**Amazon OpenSearch**，这是一个搜索数据库，以及**InfluxDB**和**Prometheus**，它们是时间序列数据库。这三种数据库，以及这两类数据库，通常用于以高速和大容量存储日志或类似日志的数据。
- en: Do not be afraid to search for new or interesting database approaches and products
    on your own. This is a fast-moving area of the industry and one where a book will
    become outdated quickly. Linux is the leader in database platforms in every sense,
    from market share to stability to performance to variety. You should have some
    familiarity with the major products, what is included in your distribution, and
    what is likely to be used by your applications. And a general sense of what involvement
    will be necessary from you. Remember that some organizations will continue to
    use dedicated database administrators to handle database tasks separate from the
    system administration team, but nearly all companies will combine these roles
    leaving the need to understand many database platforms often on your shoulders.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕自己去搜索新的或有趣的数据库方法和产品。这个领域发展迅速，书本的内容很快就会过时。Linux 在数据库平台方面在市场份额、稳定性、性能和多样性等各个方面都是领先的。你应该对主要的产品有所了解，知道自己发行版中包含哪些内容，以及你的应用程序可能使用哪些数据库。同时要对你需要投入的工作有一个大致的了解。记住，一些组织会继续使用专职的数据库管理员来处理与系统管理团队分离的数据库任务，但几乎所有公司都会将这些角色合并，导致你需要理解多个数据库平台的情况通常会落在你身上。
- en: We now have a great understanding of what products we are likely to see in the
    real world of Linux system administration. All these database concepts are fun
    and interesting, and it is always exciting to be able to get our hands on many
    different products, but what really matters is how we protect these systems and
    that is what we will address in our next section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对在Linux系统管理的实际环境中可能遇到的产品有了很好的理解。所有这些数据库概念都很有趣，并且很激动人心，能够接触到许多不同的产品总是令人兴奋，但真正重要的是我们如何保护这些系统，这也是我们在下一部分将要讨论的内容。
- en: Understanding database replication and data protection concepts
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数据库复制和数据保护概念
- en: From the perspective of the Linux system administrator, nothing is going to
    be as important as database protection which includes, just as it does with systems
    in general, both disaster avoidance and disaster recovery. Because databases are
    so critical, and because they are so common, and additionally because their needs
    are so different from what we typically encounter otherwise in our systems, we
    are breaking them out here so that we can tackle the nearly unique needs of the
    database world with respect to data protection.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux系统管理员的角度来看，数据库保护将是最重要的事情，这包括，正如它对系统整体所做的那样，灾难避免和灾难恢复。因为数据库至关重要，而且非常普遍，此外它们的需求与我们通常在系统中遇到的需求截然不同，所以我们在这里单独讨论，以便能够处理与数据保护相关的数据库世界几乎独特的需求。
- en: Because databases store structured data, they come with all of the challenges
    to protect what we face with heavily used storage systems, which they effectively
    are. Because databases are highly stateful we must be very careful that we do
    not break state when looking at data protection.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数据库存储的是结构化数据，所以它们面临着保护那些高频使用的存储系统的所有挑战，实际上它们就是这样的存储系统。由于数据库高度有状态，我们必须非常小心，以免在进行数据保护时破坏状态。
- en: What does all of this mean in the simplest of terms? Basically, databases are
    all about storing data and to do what they do with any effectiveness at all they
    need to both hold open the files that represent their data on disk as well as
    keeping generally a large amount of that data in memory at any given time. This
    presents several challenges to us for when it comes to data protection.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在最简单的术语中是什么意思？基本上，数据库就是用来存储数据的，为了有效地进行数据存储，它们需要同时保持代表其数据的文件在磁盘上打开，并且通常在任何给定的时间都要在内存中保持大量的数据。这给我们带来了在数据保护方面的几个挑战。
- en: Open files are always a problem for backups. There is no good way to take a
    backup of a file that is currently being held open by an application because we
    have no way to know what the state of writing to the file is. Perhaps the file
    is perfectly fine as it is, or perhaps it has been half modified and the data
    is gibberish until more data that is current in memory or possibly has not been
    calculated yet has been added to the file, or perhaps the format of the file is
    not corrupt but the data that is in the file is no longer accurate. From outside
    of the application using the file we cannot know what the actual state of an open
    file is other that it cannot be trusted.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 打开中的文件始终是备份的难题。没有好的方法来备份当前被应用程序打开的文件，因为我们无法知道文件写入时的状态。也许文件目前是完全正常的，或者可能它已经被部分修改，数据是乱码，直到更多的当前内存数据或可能尚未计算的数据被添加到文件中，或者文件的格式没有损坏，但文件中的数据已经不再准确。从使用该文件的应用程序外部，我们无法知道一个打开文件的实际状态，除了它无法被信任以外。
- en: Because of this, most file-based backups will simply ignore the file as they
    cannot lock the file to take a backup. For most files this is no problem because
    files only get locked occasionally and if you take backups on a regular basis
    you are expected to eventually get a good backup of any given file. It may not
    be deterministically safe, but it is statistically safe. And if you need determinism,
    you can always use a log to see if files that are critical have been safely backed
    up or not.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大多数基于文件的备份将会忽略该文件，因为它们无法锁定文件进行备份。对于大多数文件来说，这并不是问题，因为文件只偶尔被锁定，如果你定期进行备份，通常会最终获得某个文件的有效备份。这可能不是确定性安全的，但它是统计学上安全的。如果你需要确定性，你可以使用日志查看关键文件是否已经安全备份。
- en: Block based backups, that is backups that work from the block device layer instead
    of the file layer and are not aware of individual files or filesystem mechanics,
    can easily take a backup of an open file, but they cannot know if the file is
    in a safe or accurate state or not. So, in the first case, we assume that an open
    file will simply be skipped. In the second case, we assume that a backup of it
    will be taken but that the accuracy of that backup can only be determined at the
    time of restore. Neither option is ideal, of course. Both are better than nothing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 基于块的备份，也就是从块设备层而不是文件层进行备份，并且不关注单个文件或文件系统的机制，能够轻松地备份打开的文件，但它们无法判断文件是否处于安全或准确的状态。所以，在第一种情况下，我们假设打开的文件会被简单跳过。在第二种情况下，我们假设会备份它，但该备份的准确性只能在恢复时确定。当然，这两种选择都不是理想的。两者都比什么都没有要好。
- en: The traditional method to move from *maybe we got a good backup* or *we almost
    always get a good backup* to fully knowing that a backup is good is to use an
    agent that informs applications to complete transactions and puts all data onto
    the disk and to close the file for the duration of a backup operation. Some applications
    have mechanisms for doing this, API calls to be made that tell them to prepare
    for a backup, and for others you do this via brute force by closing the application
    completely prior to taking a backup and restarting it when the backup is complete.
    The problem here being that only very few applications support this kind of communications,
    and any backup software agents have to support each unique piece of software individually
    to be able to do this. So, it requires both parties to work together, something
    that does not happen frequently given the large number of applications and backup
    tools on the market. It is impractical.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的将*也许我们有一个好的备份*或*我们几乎总是有一个好的备份*转变为完全知道备份是好的方法是使用一个代理，该代理通知应用程序完成事务，将所有数据写入磁盘并在备份操作期间关闭文件。有些应用程序具有执行此操作的机制，API调用会通知它们准备进行备份，而对于其他应用程序，你需要通过暴力方式，在备份之前完全关闭应用程序，并在备份完成后重新启动它。这里的问题是，只有极少数应用程序支持这种通信方式，而任何备份软件代理必须分别支持每个独特的软件才能做到这一点。所以，这需要双方的合作，考虑到市场上应用程序和备份工具的数量，这种合作并不常见。因此，这种方法是不切实际的。
- en: What many applications resort to doing is taking their own *backups* of a sort
    by executing an internal data dump process and saving the data in a safe way to
    another storage location. This file, a complete copy of all of the data that is
    in the application, is kept closed and is only used for the backup software to
    read and use instead of the live data. This provides a universal mechanism for
    working around data corruption problems caused by open files. It is easy for the
    application writers to implement and works universally with all backup software.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序采取的做法是通过执行内部数据转储过程来获取它们自己的*备份*，并以安全的方式将数据保存到另一个存储位置。这些文件是应用程序中所有数据的完整副本，并且保持关闭状态，仅供备份软件读取和使用，而不是使用实时数据。这为绕过因打开文件导致的数据损坏问题提供了一种通用机制。它易于应用程序开发人员实现，并且与所有备份软件通用。
- en: 'This method is totally effective but has a major caveat: we have to shut down
    the application in order to have it work. That means we must have a way to consistently
    bring the application down at the right time, and a way to bring it up at the
    right time. That part is generally feasible without too much work, although it
    is generally quite manual outside of a few common applications. But the real problem
    is getting organizations to agree to regular downtime for applications to allow
    for the backup process. Unlike a system reboot which we generally only look to
    do weekly or possibly monthly, we typically want to run backups daily at a minimum
    and sometimes hourly or even nearly continuously. This is not always something
    that we can do.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法完全有效，但有一个重大警告：我们必须关闭应用程序才能使其工作。这意味着我们必须有一种方法，能够在正确的时间关闭应用程序，并在正确的时间重新启动它。这个部分通常是可行的，并且不需要太多工作，尽管除了少数常见的应用程序外，通常都是手动操作。但真正的问题是让组织同意定期关闭应用程序，以便进行备份操作。不同于系统重启，我们通常只希望每周或每月进行一次重启，我们通常至少希望每天进行备份，有时是每小时一次，甚至几乎是持续备份。这并不是我们总能做到的事情。
- en: Beyond scheduled backup frequency, it is generally desired that we be able to
    take *ad hoc* backups at a moment's notice, as well. If an *ad hoc* backup is
    going to trigger application downtime that is rarely going to be acceptable. Something
    else is needed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了预定备份频率之外，通常我们还希望能够随时进行*临时*备份。如果*临时*备份会导致应用程序停机，这通常是不可接受的。因此，需要其他方法来处理。
- en: This all comes together to make database backups a dramatic problem. Databases
    are almost always the most critical *under the hood* workload components in your
    IT infrastructure, the least able to withstand any extended period of or unplanned
    downtime, the only ones that typically hold their files open indefinitely, and
    the ones for which backups are most critical.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些因素共同作用，使得数据库备份成为一个严重的问题。数据库几乎总是你 IT 基础设施中最关键的*幕后*工作负载组件，最无法承受任何长时间或意外停机的影响，通常也是唯一需要无限期保持文件打开的组件，并且备份对它们来说至关重要。
- en: This challenge extends far beyond just backups. If we were dealing with a stateless
    application, rather than a database, such as a typical website, we have replication
    options that can be as simple as just copying the application directory between
    servers. Load balancing options can be as simple as directing some traffic to
    one application server or to another. In most cases, non-database application
    replication, backup, and even load balancing is easy.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战远远超出了备份问题。如果我们处理的是无状态的应用程序，而不是数据库，例如典型的网站，我们有许多复制选项，可以简单到仅仅是将应用程序目录在服务器之间复制。负载均衡选项可以简单到将部分流量引导到一个应用服务器或另一个应用服务器。在大多数情况下，非数据库应用程序的复制、备份甚至负载均衡都很简单。
- en: With a database we do not have the option of simply copying files between systems.
    For the data to be consistent and updated, the database management systems running
    on each host would need to coordinate with each other and ensure concepts such
    as locks, caches, and flushes to disks were done consistently and communicated
    around the cluster. Replication, if it is even an option for the database management
    system that you are using, is generally quite complex and comes with many caveats.
    There is no simple way to make databases have replication or clustering without
    introducing significant performance challenges.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据库，我们没有简单地在系统之间复制文件的选项。为了确保数据一致性和更新，运行在每个主机上的数据库管理系统需要相互协调，确保诸如锁定、缓存和磁盘刷新等概念能够一致地执行，并在集群中进行通信。如果复制功能对你所使用的数据库管理系统来说是可选的，它通常相当复杂，并且有很多限制。没有简单的方法能够在不引入显著性能挑战的情况下实现数据库的复制或集群。
- en: So, both protecting databases from failure, and making them easy and reliable
    to recover should they fail, is challenging. And while the techniques to do so,
    at the highest level, may be somewhat common, it is really configured and applied
    at the specific tool level every time. So, learning how it is handled in one ecosystem
    may not reflect in another.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既要保护数据库免受故障影响，又要确保在出现故障时能够轻松可靠地恢复，这是一个挑战。尽管实现这一目标的技术在最高层次上可能有些共性，但它每次都需要在特定工具层面上进行配置和应用。所以，了解一个生态系统如何处理这些问题，并不一定能反映到另一个生态系统中。
- en: In all cases, backups or replication and clustering, is going to be handled
    by the database management system itself or a dedicated tool to that database.
    The capabilities of the system will be unique to that database. Some database
    management systems, for example, are limited to very simple clustering, perhaps
    on to a pair of mirrored servers or they might be limited to only a single node
    that is able to make changes to disk, but other nodes in the cluster maintain
    a cached copy of part or all of the data and serve out requests to read the data.
    Others have massive scalability and may allow hundreds of independent nodes, each
    of which is allowed to fully read and write data!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，备份、复制和集群将由数据库管理系统本身或专门为该数据库设计的工具来处理。系统的功能将是该数据库独有的。例如，一些数据库管理系统仅支持非常简单的集群，可能只是通过一对镜像服务器，或者仅支持单个节点能够进行磁盘修改，而集群中的其他节点则保持部分或全部数据的缓存副本，并负责提供读取请求。另一些系统具有巨大的可扩展性，可能允许数百个独立节点，每个节点都能完全读取和写入数据！
- en: So, because of this complexity we must learn each product completely individually.
    There is a strong *tendency* for NoSQL databases to have been replication and
    redundancy options. This generally comes from having fewer controls and constraints.
    As well as from the fact that most NoSQL databases are built in recent years and
    most relational databases are decades old so the considerations at the time of
    design were vastly different. Most relational databases that you know today had
    to adapt first to networking and then to the Internet over a period of many years.
    Nearly all NoSQL that you will encounter were made decades after the Internet
    was a part of everyday life.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于这种复杂性，我们必须完全单独学习每个产品。NoSQL数据库有一种强烈的*tendency*，即具备复制和冗余选项。这通常源于缺乏控制和约束。此外，大多数NoSQL数据库是在近年来构建的，而大多数关系型数据库则已有几十年历史，因此它们设计时的考虑因素截然不同。今天你所了解的大多数关系型数据库首先必须适应网络，然后是互联网，这一过程持续了许多年。几乎所有你将遇到的NoSQL数据库都是在互联网成为日常生活的一部分之后几十年才创建的。
- en: In many cases, databases being put into a cluster will work by locking some
    combination of file, record, document, row or other discrete portion of the database
    and signaling other cluster members of the lock. Then the original system waits
    for all members to communicate back with an acknowledgement of the lock. Once
    locked the system cannot write new data to at least a portion of the system and
    must unlock it before it can continue fulfilling data storage requests. This locking
    can be quite fast in some cases or can have storage impacts large enough to impact
    application usability in others. Doing this on a single server database can have
    noticeable impact. Doing this on a cluster where cluster nodes need to wait for
    each other to complete their locked tasks and report back to each other can magnify
    that effect by many times. If we then need to do the same thing while waiting
    for Internet latencies and possible outages happening during a locked operation
    the scale of potential impact can magnify many times again. Locks ensure consistency
    but always come at the cost of performance and complexity. The bigger our database
    system grows, the larger the potential impact of locking even a portion of that
    system.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，将数据库放入集群中时，会通过锁定数据库的某些文件、记录、文档、行或其他离散部分来工作，并向其他集群成员发出锁定信号。然后，原始系统等待所有成员以确认锁定的方式进行通信。一旦被锁定，系统就无法写入新数据到系统的至少某个部分，必须在解锁后才能继续执行数据存储请求。在某些情况下，这种锁定可能非常快速，或者可能对存储产生足够大的影响，从而影响应用程序的可用性。在单服务器数据库上执行此操作可能会产生显著影响。在集群中，由于集群节点需要相互等待以完成其锁定任务并相互报告，这种影响可能会放大很多倍。如果我们还需要在等待互联网延迟和可能发生的故障时进行相同的操作，锁定操作的潜在影响规模可能会再次放大很多倍。锁定可以确保一致性，但总是以性能和复杂性为代价。我们的数据库系统越大，即使是锁定系统的一部分，其潜在影响也越大。
- en: Traditionally, and mostly with relational databases, we have assumed that increasing
    performance was done by *scaling up* - that is adding more CPUs or faster CPUs,
    and more memory, and more or faster storage. This is really effective as long
    as we need to access the data more or less centrally and only until we are able
    to keep squeezing more and faster CPUs into a single box. After that, we hit a
    performance wall and we are stuck.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，尤其是在关系型数据库中，我们假设通过*纵向扩展*来提高性能——即增加更多的CPU、更快的CPU、更多的内存以及更多或更快的存储。这种方式在我们需要中心化地访问数据时非常有效，直到我们能够不断将更多、更快的CPU压入一个单一的盒子中为止。之后，我们就会遇到性能瓶颈，卡住了。
- en: Today more and more we see *scale out* designs where more, smaller nodes are
    added to a cluster like we have discussed in earlier chapters. Relational designs
    are not completely unable to use this model, but they tend to struggle to do so
    efficiently, especially if we expect write, as well as read, operations to scale
    with the system. It is NoSQL that has taken this need for data access and really
    run with it. New databases designed from the ground up to do this with amazing
    efficiency have emerged and are tackling data problems in whole new ways. Some
    are even using NoSQL *under the hood* while presenting common relational interfaces
    on top (via SQL language queries, for example) to add new performance options
    to otherwise old designs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，我们越来越多地看到*分布式*设计，即向集群添加更多的较小节点，就像我们在早期章节中讨论的那样。关系型设计并不完全无法使用这种模型，但在期望写入和读取操作与系统扩展时，它们往往难以高效运行。NoSQL已经采用了这种数据访问需求，并以非常高效的方式进行了处理。新的数据库从头开始设计，以此为基础，通过在顶层（例如通过SQL语言查询）提供通用关系接口，为旧设计增加了新的性能选项。
- en: Clusters of databases introduce new potential complications to our data protection
    plans. Depending on the database and the data integrity design a backup or replication
    operation may require something dramatic such as temporarily *freezing* the entire
    database cluster while the backup is taking place. Or it may require collecting
    data from individual nodes, when each contains unique data, to assemble a complete
    backup of data that does not exist in its entirely in any one location until the
    time of the backup operation. This approach, generally called a sharded database,
    can be logistically challenging as it is possible to have a scale of data that
    no node is well prepared to handle and restoration can be complicated as the data
    has to be fed back into the cluster and distributed out to the nodes. Reassembling
    the data may be a large task. Other databases might simply *take their chances*
    and provide backup of what they have without checking in with other cluster nodes.
    It all depends on the database and the setup of it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库集群引入了新的潜在数据保护计划复杂性。根据数据库和数据完整性设计，备份或复制操作可能需要一些戏剧性的措施，例如在备份过程中暂时*冻结*整个数据库集群。或者可能需要从各个节点收集数据，每个节点都包含独特的数据，以组装完整的备份数据，这些数据在备份操作之前在任何一个位置都不存在完整。这种方法通常称为分片数据库，从逻辑上讲很有挑战性，因为可能存在一定规模的数据，没有节点能够很好地处理，而且数据恢复也可能很复杂，因为数据必须重新输入到集群中并分发到节点上。重新组装数据可能是一项艰巨的任务。其他数据库可能只是*随机应变*，提供它们所拥有的备份，而不与其他集群节点进行检查。这一切取决于数据库及其设置。
- en: When working with database clusters there are many considerations and while
    we can talk about high level approaches here, in the real world each database
    and sometimes even the database deployments are unique. We will need to investigate
    the documentation for the unique setup and be mindful that we need to have a way
    to ensure consistency end to end through the process of collecting and storing
    the data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理数据库集群时，有许多考虑因素。虽然我们可以在这里讨论高层次的方法，但在现实世界中，每个数据库甚至数据库部署都是独特的。我们需要查阅有关独特设置的文档，并注意确保整个收集和存储数据过程的一致性。
- en: We also have to consider the case of straight database engines that do not include
    a database management system. In this case, there is no database management system
    to create consistent backup files to disk or to handle replication. Any data protection
    features will need to be handled by the application that uses the database rather
    than having a database product do the work. This situation is extra difficult
    for system administrators because every application is potentially very unique
    and challenging. Of course, we can *always* resort to shutting down the application
    or even the entire server in order to make a backup, but it is not a desirable
    process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须考虑直接数据库引擎的情况，这些引擎不包括数据库管理系统。在这种情况下，没有数据库管理系统来创建一致的备份文件到磁盘或处理复制。任何数据保护功能都需要由使用数据库的应用程序处理，而不是由数据库产品来完成工作。对系统管理员来说，这种情况非常困难，因为每个应用程序都可能非常独特和具有挑战性。当然，我们可以*随时*通过关闭应用程序甚至整个服务器来进行备份，但这不是一个理想的过程。
- en: With a database engine if we want any functionality around data protection without
    shutting down the system ourselves, we need to rely on the application in question
    to provide it. This *can* provide for the best possible options (along with applications
    doing this same thing on top of a database management system, of course) for data
    protection because the application itself will generally have exclusive access
    to the database as well as total knowledge of the current use case of the entire
    application stack. In theory the application layer, with its additional knowledge
    of the state of the system and intended use cases, can take backups that are more
    meaningful, at times that are more useful, and store them in more dynamic ways.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库引擎时，如果我们希望在不关闭系统的情况下实现任何数据保护功能，我们需要依赖相关应用程序提供这些功能。*这*可能提供最佳的数据保护选项（当然，也包括在数据库管理系统上运行的应用程序提供类似功能），因为应用程序本身通常会拥有对数据库的独占访问权限，并且对整个应用栈的当前使用案例有全面了解。理论上，应用层凭借其对系统状态和预期使用案例的额外了解，可以在更有意义的时间进行备份，并以更动态的方式存储备份。
- en: For example, the application layer can replicate partial data, only data that
    is deemed truly critical, in near real time to an arbitrary data storage location,
    perhaps offsite. Maybe it records data in a log-like structure so that it can
    be recreated. Or maybe it knows when there is going to be downtime on writes and
    can lock the database and replicate it with greater intelligence than the database
    management system itself could do or the application layer could replicate a transaction
    across application nodes to ensure consistency before ever sending data down to
    the database for storage. There are many ways that the application layer, with
    its greater insight and flexibility can make the data storage layer better.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，应用层可以实时复制部分数据，只有那些被认为至关重要的数据，复制到一个任意的数据存储位置，可能是异地。也许它将数据记录在类似日志的结构中，以便重新创建。或者它知道何时会出现写操作的停机时间，并且可以锁定数据库，并用比数据库管理系统本身更智能的方式进行复制，或者应用层可以在将数据写入数据库存储之前，跨应用节点复制事务以确保一致性。应用层凭借其更深的洞察力和灵活性，可以使数据存储层变得更好。
- en: An application layer backup has the potential to do interesting things such
    as take backups based on slow times of day and to be able to automate both backups
    and restores. Automating the setup of a new node can be an incredible benefit
    if the application allows for it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层备份有可能做出一些有趣的事情，比如基于一天中的空闲时间进行备份，并能够自动化备份和恢复。如果应用程序允许，自动化新节点的设置将是一个巨大的好处。
- en: As was said about the database cluster situation, each scenario may be unique
    and will require knowing the application, knowing what accommodations it provides
    for data integrity, and adding our own knowledge to ensure that we are able to
    accomplish a consistent and integral data set. An application that is clustered
    may present the same challenges and opportunities that a clustered database does
    on its own.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在数据库集群的情况中所说，每种情况可能是独特的，并且需要了解应用程序，了解它为数据完整性提供的支持，并结合我们自己的知识，确保能够实现一致且完整的数据集。一个集群化的应用程序可能会呈现与集群化数据库相同的挑战和机会。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Databases are pretty much the most important thing that we will need to work
    with as system administrators. Whether we run the database ourselves, or only
    administer the operating system on which they run, they will require more of our
    attention and will cause us more stress than pretty much anything else that we
    will do. Our skills and expertise will matter most when working with databases
    and it is here that the greatest range of our skills will likely be tested.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库几乎是我们作为系统管理员需要处理的最重要的事情。无论是我们自己运行数据库，还是仅仅管理运行数据库的操作系统，它们都将需要我们更多的关注，并且比我们做的任何事情都更容易给我们带来压力。在处理数据库时，我们的技能和专业知识将变得尤为重要，且我们的技能范围在这里将会受到最严峻的考验。
- en: Wherever we have databases running or in use we need to evaluate how the data
    is stored on disk, how we can ensure consistency, and how that consistent data
    can be moved to a backup location whether tape, online, or other. This is probably
    the single most important task that we will do in system administration, Linux
    or otherwise.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 无论数据库在哪里运行或使用，我们都需要评估数据如何存储在磁盘上，如何确保一致性，以及如何将这些一致的数据移动到备份位置，无论是磁带、在线存储还是其他。这可能是我们在系统管理中做的最重要的任务，无论是在
    Linux 还是其他系统上。
- en: Our best practices around databases really focus on data protection. We would
    love to talk about how we should choose the right database type for the job that
    we will be performing, but in all but the rarest cases these decisions are made
    long before anything gets to the system administration team.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于数据库的最佳实践真正集中在数据保护上。我们很想讨论如何选择适合我们执行的任务的正确数据库类型，但除了最少数几种情况外，这些决策通常在任何事情到达系统管理团队之前就已经做出了。
- en: Database best practices for backups are to ensure that a full consistent, fully
    safe, closed set of data is used as the source for a backup to ensure data protection
    is predictable. Whether this is handled by the database, by the application using
    the database, or manually, there must be a mechanism that ensures that data is
    not in flight at the time of the data acquisition.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库备份的最佳实践是确保使用完整、一致、完全安全的、封闭的数据集作为备份源，以确保数据保护是可预测的。无论是由数据库、使用数据库的应用程序，还是手动处理，都必须有一个机制，确保在数据获取时数据不会处于传输中。
- en: In clustering scenarios, the same logic applies. But now we must ensure that
    the data accessible to our node is accurate and complete in the context of the
    entire cluster.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群场景中，同样的逻辑适用。但现在我们必须确保，在整个集群的上下文中，节点可以访问的数据是准确且完整的。
- en: In our next chapter, we are going to start digging into the less glamorous,
    but super important world of documentation, monitoring, and logging.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始深入探讨那些不那么引人注目但极其重要的领域——文档、监控和日志记录。
