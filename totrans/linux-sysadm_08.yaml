- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Software Installation and Package Repositories
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件安装与软件包仓库
- en: Most Linux distributions only install the bare minimum set of software by default
    and assume that the user will install additional software later. These days, installing
    software on Linux is very easy, thanks to package repositories and high-level
    package managers that can search, download, and install packages over the network.
    However, it’s important to understand how package files are organized internally
    and how package managers work since it helps administrators inspect packages,
    diagnose problems, and fix installation issues if they occur.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Linux 发行版默认只安装最基本的系统软件，并假设用户会稍后安装额外的软件。如今，在 Linux 上安装软件非常简单，得益于软件包仓库和高级软件包管理工具，这些工具可以通过网络搜索、下载和安装软件包。然而，了解软件包文件的内部组织结构以及软件包管理器的工作原理非常重要，因为这有助于管理员检查软件包、诊断问题，并在发生安装问题时进行修复。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Software installation, packages, and dependencies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件安装、软件包和依赖关系
- en: Package files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件包文件
- en: Package repositories and high-level package managers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件包仓库和高级软件包管理工具
- en: System upgrade
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统升级
- en: Software installation, packages, and dependencies
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件安装、软件包和依赖关系
- en: The definition of a software package is quite broad. In the early days of computing,
    when computers were exclusively used to solve mathematical problems, most programs
    were written completely from scratch to run on a specific computer, so there was
    no need for installation and thus no need for the concept of software packaging.
    For a long time afterward, software was still synonymous with executable files.
    Installing a software product that consists of a single executable file is trivial
    —just copy it to the target computer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包的定义相当广泛。在计算机早期，计算机专门用于解决数学问题，大多数程序都是从头编写的，并且仅在特定计算机上运行，因此没有安装的需求，也就没有软件包的概念。在那之后的很长一段时间里，软件仍然与可执行文件同义。安装由单个可执行文件组成的软件产品非常简单——只需将其复制到目标计算机上。
- en: Such software certainly exists today. For example, the maintainers of **jq**
    (a popular tool for extracting data from JSON files) provide standalone, statically
    linked executables that combine the program and all libraries it needs into a
    monolithic file and can run on any Linux system, so any user can just download
    it from its website ([https://stedolan.github.io/jq/download/](https://stedolan.github.io/jq/download/))
    and start using it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种软件今天仍然存在。例如，**jq**（一个用于从 JSON 文件中提取数据的流行工具）的维护者提供了独立的、静态链接的可执行文件，将程序和它所需的所有库合并成一个单一文件，可以在任何
    Linux 系统上运行，因此任何用户都可以从其网站 ([https://stedolan.github.io/jq/download/](https://stedolan.github.io/jq/download/))
    下载并开始使用。
- en: However, many software projects consist of multiple executable files and often
    require data files as well. A spell checker program, such as **Aspell**, requires
    dictionary files to work. In video games, the executable is often just a small
    part, often the smallest one compared to game assets such as models, textures,
    and sound files. To make the software product work as intended, all those files
    need to be distributed and installed together as a software package.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多软件项目由多个可执行文件组成，并且通常还需要数据文件。例如，一个拼写检查程序，如**Aspell**，需要字典文件才能工作。在视频游戏中，可执行文件通常只是一个很小的部分，相比于游戏资产（如模型、纹理和声音文件）来说，它往往是最小的。为了使软件产品按预期工作，所有这些文件需要作为软件包一起分发和安装。
- en: In early operating systems, the installation often just consisted of copying
    all files of a software product to a directory. That’s the purpose of the `/opt`
    directory still found in many Linux systems. To install a hypothetical software
    package, Foo 1.0, an administrator may unpack its release archive (say, `foo_1.0.tar.gz`)
    to `/opt/foo/` (usually, with `tar --xf foo_1.0.tar.gz --directory /opt/foo/`),
    and the directory structure inside `/opt/foo` will be completely defined by the
    application developers of Foo rather than by the operating system itself.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的操作系统中，安装通常只是将软件产品的所有文件复制到一个目录中。这也是许多 Linux 系统中仍然存在的 `/opt` 目录的目的。为了安装一个假设的软件包
    Foo 1.0，管理员可能会将其发布包（例如 `foo_1.0.tar.gz`）解压到 `/opt/foo/` 目录（通常使用 `tar --xf foo_1.0.tar.gz
    --directory /opt/foo/`），并且 `/opt/foo` 目录中的结构将完全由 Foo 的应用开发人员定义，而不是由操作系统本身定义。
- en: In modern operating systems, simply copying files is rarely enough because it
    will not properly integrate the newly installed software into the operating system.
    Even a package that provides a single console command needs to place it in a directory
    that is already in `$PATH`, or modify the `$PATH` environment variable accordingly.
    Software with a graphical user interface also needs to correctly register itself
    in the desktop environment application menus and optionally create desktop icons.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代操作系统中，仅仅复制文件通常是不够的，因为它不能将新安装的软件正确地集成到操作系统中。即使是提供单一控制台命令的软件包，也需要将其放置在一个已经在`$PATH`中的目录下，或者相应地修改`$PATH`环境变量。带有图形用户界面的软件还需要正确地将自己注册到桌面环境的应用菜单中，并可以选择性地创建桌面图标。
- en: For this reason, operating systems started demanding a certain structure from
    software packages. In Microsoft Windows and many other systems, they would still
    usually come as custom executable programs that would unpack and copy the files
    and also execute scripts to register the package with the operating system. Developers
    of Linux software also practice this approach sometimes, and there are frameworks
    for creating executable installers, such as **makeself** ([https://makeself.io/](https://makeself.io/)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，操作系统开始要求软件包具有特定的结构。在Microsoft Windows和许多其他系统中，软件包通常仍然作为定制的可执行程序提供，这些程序会解压并复制文件，还会执行脚本将软件包注册到操作系统中。Linux软件的开发者有时也会采用这种方法，并且有一些用于创建可执行安装程序的框架，例如**makeself**
    ([https://makeself.io/](https://makeself.io/))。
- en: That approach gives software package authors complete control over the installation
    process, but it also has many disadvantages. First, uninstalling software that
    was installed that way isn’t always reliable. If installer developers aren’t careful
    to make it clean up all files created at installation time, users may be left
    with leftover files they will have to delete by hand.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使软件包作者可以完全控制安装过程，但也有许多缺点。首先，通过这种方式安装的软件卸载并不总是可靠的。如果安装程序的开发者没有小心清理所有在安装时创建的文件，用户可能会留下需要手动删除的残余文件。
- en: Second, each package needs to implement its own update checking and installation
    mechanism. Before the widespread availability of broadband internet access, when
    software updates were usually distributed on physical media such as floppy disks
    or CDs, that wasn’t a big concern; but these days, when most users have regular
    internet access, they benefit from online updates, and many software products
    such as web browsers must be kept up to date to keep them protected from security
    threats.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，每个软件包需要实现自己的更新检查和安装机制。在宽带互联网普及之前，软件更新通常通过软盘或CD等物理介质分发，这并不是一个大问题；但如今，大多数用户都有常规的互联网接入，他们能够受益于在线更新，许多软件产品，如网页浏览器，必须保持最新，以防止安全威胁。
- en: Third, few programs are written from scratch anymore and most make extensive
    use of third-party libraries, so they have dependencies. One way to make sure
    the library code is available for the program to call is to make it a part of
    the executable itself. That approach is known as static linking. It’s foolproof
    in that there is no way to install such an executable incorrectly, but it leads
    to greatly increased memory and drive space consumption. For this reason, most
    programs are dynamically linked with external library files, but for them to work,
    they need to make sure that files of the correct versions of all required libraries
    exist on the system. If every software package is standalone and responsible for
    its own installation, the only way to do that is to bundle all libraries with
    the package (which is only marginally better than linking them statically, in
    terms of drive space usage) or require the user to find and install all libraries
    manually (which is very inconvenient for the user).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，很少有程序是从零开始编写的，大多数程序都会大量使用第三方库，因此它们有依赖关系。确保库代码可供程序调用的一种方法是将其作为可执行文件的一部分。这种方法称为静态链接。它的优点是不会出现错误安装此类可执行文件的情况，但缺点是会大大增加内存和磁盘空间的消耗。由于这个原因，大多数程序都是与外部库文件动态链接的，但为了使它们正常工作，程序需要确保系统中存在所有所需库的正确版本的文件。如果每个软件包都是独立的并且负责自己的安装，那么唯一的方法就是将所有库文件与软件包捆绑在一起（在磁盘空间使用方面，这比静态链接仅略有改善），或者要求用户手动查找并安装所有库文件（这对用户来说非常不方便）。
- en: With proprietary software that isn’t redistributable and usually isn’t available
    in source code form, bundling all dependencies is usually the only option since
    executables need to be recompiled for use with different library versions. Different
    Linux distributions may include different versions of libraries due to different
    release cycles and software inclusion policies (some distributions are focused
    on stability and will only include older but proven versions, while others may
    choose to include the latest libraries even if they aren’t well tested).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不可重新分发且通常没有源代码形式的专有软件，通常唯一的选择是将所有依赖项捆绑在一起，因为可执行文件需要针对不同的库版本重新编译。不同的 Linux
    发行版可能由于不同的发布周期和软件包含策略而包括不同版本的库（一些发行版专注于稳定性，只会包含较旧但经过验证的版本，而其他发行版则可能选择包含最新的库，即使它们没有经过充分测试）。
- en: However, with open source software that is available in source code form and
    can be modified and redistributed, there are many more possibilities to reuse
    library files and create a cohesive system. To make that possible, distribution
    maintainers developed modern package managers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于那些可以修改并重新分发的源代码形式的开源软件，有更多的可能性可以重用库文件并创建一个统一的系统。为了使这一点成为可能，发行版维护者开发了现代包管理器。
- en: Package managers
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包管理器
- en: A package manager is a program that is responsible for the installation, upgrade,
    and removal of software packages. In the older approach where software developers
    are responsible for the installation procedure, they are free to choose whether
    to distribute their software as an executable that unpacks and installs files
    or as an archive that the user must unpack manually, and the choice of archive
    and compression algorithms is also on the developers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器是负责安装、升级和卸载软件包的程序。在旧有方法中，软件开发人员负责安装过程，他们可以自由选择是将软件分发为解压并安装文件的可执行文件，还是分发为用户必须手动解压的归档文件，归档和压缩算法的选择也由开发人员决定。
- en: By contrast, package managers usually use a very precise definition of a software
    package. To make a software project installable with a package manager, its maintainer
    must create a package file that follows a set of guidelines for its internal structure.
    Apart from the files needed for a software product to work, package files also
    contain metadata in a specific format. Metadata files contain information about
    the package, such as its name, version, license, and lists of other packages that
    it depends on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，包管理器通常对软件包有非常精确的定义。为了使一个软件项目能够通过包管理器进行安装，其维护者必须创建一个包文件，遵循一组关于内部结构的指南。除了软件产品正常运行所需的文件，包文件还包含以特定格式存储的元数据。元数据文件包含有关包的信息，例如名称、版本、许可证和它所依赖的其他包列表。
- en: Package managers limit what software product authors can do at installation
    time. For example, there is no way to let the user specify a custom installation
    directory or choose not to install certain files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器限制了软件产品作者在安装时可以做的事情。例如，用户无法指定自定义的安装目录或选择不安装某些文件。
- en: But since they completely control the installation process and every file inside
    the package is accounted for, they can install and uninstall software reliably
    and ensure that there are no files left after uninstallation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于包管理器完全控制安装过程且包内的每个文件都被记录，因此它们可以可靠地安装和卸载软件，并确保卸载后没有遗留文件。
- en: An even bigger advantage is that package managers can automatically track package
    dependencies and either prevent the user from installing a package until all dependencies
    are installed or automatically install those dependencies.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更大的优势是，包管理器可以自动跟踪包的依赖关系，防止用户在所有依赖项安装之前安装某个包，或自动安装这些依赖项。
- en: 'Different Linux distributions use different package managers. Some of them
    use two different utilities for managing software installations and upgrades:
    a low-level package manager that is responsible for working with package files
    and a high-level tool for automatically downloading packages over the network
    and managing upgrades.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 Linux 发行版使用不同的包管理器。其中一些使用两个不同的工具来管理软件的安装和升级：一个低级包管理器，负责处理包文件，和一个高级工具，用于自动下载包并管理升级。
- en: 'Historically, that was the dominant approach: before the widespread availability
    of broadband Internet access, automatic download wasn’t feasible, so the first
    package managers developed in the 1990s were only developed to work with local
    package files. The two most popular projects in this category are **rpm** (developed
    by Red Hat) and **dpkg** (developed by the Debian project). For the automated
    installation of packages over the network and automated system upgrades, they
    need to be combined with high-level tools such as YUM, DNF, Zypper, or **Advanced
    Packaging** **Tool** (**APT**).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，这曾是主流做法：在宽带互联网普及之前，自动下载是不可行的，因此在 1990 年代开发的第一个软件包管理器只支持处理本地软件包文件。这个类别中最流行的两个项目是
    **rpm**（由 Red Hat 开发）和 **dpkg**（由 Debian 项目开发）。为了实现网络上的自动安装和自动系统升级，它们需要与高级工具如
    YUM、DNF、Zypper 或 **高级软件包工具**（**APT**）结合使用。
- en: Some Linux distributions developed in the 2000s and later use package managers
    that combine both functions and can work with local package files and remote sources
    alike.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一些在 2000 年代及以后的 Linux 发行版使用的是结合了两者功能的软件包管理器，能够同时处理本地软件包文件和远程源。
- en: 'We can represent current situations with low-level and high-level package managers
    in different distributions as in the following table:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下表格展示不同发行版中低级和高级软件包管理器的现状：
- en: '| **Distribution** | **High-level** **package manager** | **Low-level** **package
    manager** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **发行版** | **高级** **软件包管理器** | **低级** **软件包管理器** |'
- en: '| Debian | APT | `dpkg` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| Debian | APT | `dpkg` |'
- en: '| Ubuntu |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| Ubuntu |'
- en: '| Linux Mint |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Linux Mint |'
- en: '| Fedora | DNF | `rpm` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| Fedora | DNF | `rpm` |'
- en: '| Red Hat Enterprise Linux | DNF, YUM |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| Red Hat Enterprise Linux | DNF, YUM |'
- en: '| openSUSE, SUSE Linux Enterprise Server | Zypper |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| openSUSE, SUSE Linux Enterprise Server | Zypper |'
- en: '| Mageia | DNF, urpmi |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| Mageia | DNF, urpmi |'
- en: '| Arch Linux | pacman |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| Arch Linux | pacman |'
- en: '| NixOS | Nix |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| NixOS | Nix |'
- en: '| Guix | Guix |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| Guix | Guix |'
- en: Table 8.1 – Package managers used in different Linux distributions
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1 – 不同 Linux 发行版使用的软件包管理器
- en: 'We will focus on the most popular low-level package managers: `rpm` and `dpkg`.
    Neither of them is inherently superior to the other, but their package file format
    and package management tool interface design choices are quite different. We will
    examine both to compare and contrast them.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于最流行的低级软件包管理器：`rpm` 和 `dpkg`。它们各自并没有本质上优于对方，但它们的软件包文件格式和软件包管理工具界面的设计选择是非常不同的。我们将对两者进行比较和对比。
- en: Package files
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件包文件
- en: Conventionally, packages come as files in a special format that includes both
    files from the software project that must be installed in the system and metadata
    for the package manager, such as file checksums, lists of dependencies, and system
    requirements for the package (such as CPU architecture). We will look inside `.rpm`
    and `.deb` package files and compare their implementation details.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，软件包作为一种特殊格式的文件出现，文件中包含需要安装到系统中的软件项目文件以及软件包管理器的元数据，如文件校验和、依赖列表和软件包的系统要求（如
    CPU 架构）。我们将查看 `.rpm` 和 `.deb` 软件包文件，并比较它们的实现细节。
- en: Inspecting package files
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查软件包文件
- en: First, we will examine package files to see what’s inside them and learn how
    to examine and unpack them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将检查软件包文件，了解其中的内容，并学习如何检查和解压它们。
- en: Please note that normally, you will not need to manually download and unpack
    package files! We are doing it only for educational purposes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通常情况下，您不需要手动下载和解压软件包文件！我们这么做只是为了教学目的。
- en: Inspecting a Debian package
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查 Debian 软件包
- en: We will use the GNU `hello` package for our experiments. GNU hello is a demo
    program that simply prints `hello world`—its real purpose is to serve as an example
    of development and packaging practices and show new developers how to write build
    scripts, implement internationalization, and so on.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 GNU `hello` 软件包进行实验。GNU hello 是一个简单的示例程序，只会打印 `hello world` —— 它的真正目的是作为开发和打包实践的示例，向新开发者展示如何编写构建脚本、实现国际化等。
- en: You can find the GNU `hello` package from the latest unstable Debian version
    at [https://packages.debian.org/sid/hello](https://packages.debian.org/sid/hello).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在最新的不稳定版 Debian 中找到 GNU `hello` 软件包，链接：[https://packages.debian.org/sid/hello](https://packages.debian.org/sid/hello)。
- en: '![Figure 8.1 – The hello package information page on the Debian package repository
    website](img/B18575_08_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – Debian 软件包仓库网站上的 hello 软件包信息页面](img/B18575_08_01.jpg)'
- en: Figure 8.1 – The hello package information page on the Debian package repository
    website
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – Debian 软件包仓库网站上的 hello 软件包信息页面
- en: 'Follow an architecture-specific download link such as [https://packages.debian.org/sid/amd64/hello/download](https://packages.debian.org/sid/amd64/hello/download)
    and download the package file from any mirror from the list shown in the following
    screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问架构特定的下载链接，如 [https://packages.debian.org/sid/amd64/hello/download](https://packages.debian.org/sid/amd64/hello/download)，并从显示的截图中任何镜像站点下载包文件：
- en: '![Figure 8.2 – The download page for the hello package for Debian Sid on x86_64
    machines](img/B18575_08_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – Debian Sid 上 x86_64 机器的 hello 包下载页面](img/B18575_08_02.jpg)'
- en: Figure 8.2 – The download page for the hello package for Debian Sid on x86_64
    machines
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – Debian Sid 上 x86_64 机器的 hello 包下载页面
- en: 'At the time of writing, the latest version is 2.10, so I used this link, but
    it’s not guaranteed to work for future versions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作时，最新版本是 2.10，因此我使用了这个链接，但不能保证未来版本能继续使用该链接：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using the `dpkg --info` command, we can view information about the package
    we have just downloaded:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dpkg --info` 命令，我们可以查看我们刚下载的包的信息：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Where does `dpkg` get that information from? Notice the `control archive=1868
    bytes` part of the output. A Debian package file is an `ar` archive that consists
    of two compressed `tar` archives glued together. We could certainly extract them
    using the `ar` utility, or even with `dd` (thanks to the simplicity of its format
    and the fact that `dpkg` tells us each archive length in bytes), and unpack them
    by hand, but luckily, `dpkg` has built-in functionality for that. Using `dpkg
    --control` (`dpkg -e`), we can extract the control archive—the part that contains
    package metadata:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`dpkg` 从哪里获取这些信息？注意输出中的 `control archive=1868 bytes` 部分。一个 Debian 包文件是一个 `ar`
    压缩包，它由两个连接在一起的 `tar` 压缩包组成。我们当然可以使用 `ar` 工具提取它们，或者甚至用 `dd`（因为其格式简单，并且 `dpkg` 会告诉我们每个归档文件的字节长度），手动解压它们，但幸运的是，`dpkg`
    提供了内建的功能来处理这些。使用 `dpkg --control`（`dpkg -e`），我们可以提取控制归档——即包含包元数据的部分：'
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we don’t specify a custom output directory, `dpkg` will unpack it into a
    subdirectory named `DEBIAN`. It will contain two files: `control` and `md5sums`.
    The control file is where `dpkg --info` (`dpkg -l`) took those fields and their
    values from:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有指定自定义输出目录，`dpkg` 会将其解压到一个名为 `DEBIAN` 的子目录中。它将包含两个文件：`control` 和 `md5sums`。`control`
    文件就是 `dpkg --info`（`dpkg -l`）获取字段及其值的来源：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `md5sums` file contains hash sums of all files inside the package:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`md5sums` 文件包含包内所有文件的哈希值：'
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The MD5 hash sum algorithm is no longer cryptographically secure and must not
    be used to protect files and messages from malicious modification. However, in
    Debian packages, it is used only for protection against accidental file corruption,
    so it’s not a security issue. Protection against malicious modification is provided
    by GnuPG digital signatures, which are checked by the high-level tool—APT.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: MD5 哈希算法已不再具备密码学安全性，不能用于保护文件和消息免受恶意修改。然而，在 Debian 包中，它仅用于防止意外的文件损坏，因此不构成安全问题。防止恶意修改是通过
    GnuPG 数字签名来提供的，这些签名会被高级工具 APT 检查。
- en: 'If you only want to list files inside the data archive, you can do it with
    `dpkg --contents` (`dpkg -c`):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想列出数据归档中的文件，可以使用 `dpkg --contents`（`dpkg -c`）：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It’s also possible to unpack the data archive part of a package file with `dpkg
    --extract` (`dpkg -x`), but in that case, you need to specify where to unpack
    it. To unpack into the current directory, we can use the dot shortcut:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用 `dpkg --extract`（`dpkg -x`）解压包文件的数据归档部分，但在这种情况下，你需要指定解压的位置。要解压到当前目录，可以使用点（`.`）快捷方式：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let’s move on to inspecting an RPM package file and comparing it with what
    we have seen in a Debian package.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续检查 RPM 包文件，并将其与我们在 Debian 包中看到的内容进行比较。
- en: Inspecting an RPM package
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查 RPM 包
- en: We’ll use Fedora as an example of a distribution that uses RPM packages. The
    place to search Fedora repositories on the web is [https://packages.fedoraproject.org/](https://packages.fedoraproject.org/).
    Enter the name of the package (`hello`, in our case) in the search field and you’ll
    see the package information page.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以 Fedora 为例，展示使用 RPM 包的分发版。要在网上查找 Fedora 存储库，可以访问 [https://packages.fedoraproject.org/](https://packages.fedoraproject.org/)。在搜索框中输入包的名称（在本例中是
    `hello`），即可看到包的信息页面。
- en: '![Figure 8.3 – The hello package information page on the Fedora package repository
    website](img/B18575_08_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – Fedora 包存储库网站上的 hello 包信息页面](img/B18575_08_03.jpg)'
- en: Figure 8.3 – The hello package information page on the Fedora package repository
    website
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – Fedora 包存储库网站上的 hello 包信息页面
- en: 'Fedora uses Rawhide as a code name for the latest unstable version. At the
    time of writing, the version in development is 37\. To find a package download
    link, go to the **Builds** tab, then find a link to the latest build there. We
    can download that package for inspection using the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Fedora 使用 Rawhide 作为最新不稳定版本的代号。在撰写本文时，正在开发的版本是 37。要查找软件包下载链接，请转到 **Builds**
    标签页，然后在那里找到最新构建的链接。我们可以使用以下命令下载该软件包以进行检查：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We have provided a sample direct link to the package from Fedora 37, but since
    all URLs and package versions are subject to change, the following command is
    not guaranteed to remain working forever—if you want to download the package,
    visit the [packages.fedoraproject.org](http://packages.fedoraproject.org) website
    instead.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了从 Fedora 37 直接链接到软件包的示例，但由于所有网址和软件包版本都可能发生变化，所以下面的命令不保证永远有效——如果你想下载软件包，请改为访问[packages.fedoraproject.org](http://packages.fedoraproject.org)
    网站。
- en: All RPM queries are available through the `--query` option. A good thing about
    RPM is that all query options can be used to inspect either package files or already
    installed packages, depending on the argument. If you give it just a package name,
    it will look for an installed package, but if you specify a package file path,
    it will inspect that file instead.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 RPM 查询都可以通过 `--query` 选项来执行。RPM 的一个优点是，所有查询选项都可以用于检查软件包文件或已安装的软件包，具体取决于参数。如果你只给出软件包名称，它将查找已安装的软件包，但如果指定软件包文件路径，它将检查该文件。
- en: 'For example, with `rpm --query --info`, we can read package metadata. Alternatively,
    that command can be shortened to `rpm -qi`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 `rpm --query --info`，我们可以读取软件包的元数据。或者，该命令可以缩写为 `rpm -qi`：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using `rpm --query --list` (or `rpm -ql` for short), we can get a list of files
    inside the package:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `rpm --query --list`（简写为 `rpm -ql`），我们可以获取软件包中包含的文件列表：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Compare and contrast this with the output of `dpkg --contents`, which listed
    MD5 sums for every file. Unlike Debian packages, RPM packages do not contain hash
    sums for every file, but rather a single hash sum of the package archive.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与 `dpkg --contents` 的输出进行比较，后者列出了每个文件的 MD5 校验和。与 Debian 软件包不同，RPM 软件包不会为每个文件包含哈希值，而是为软件包归档文件包含一个单一的哈希值。
- en: 'The `rpm` command also does not provide options for unpacking RPM packages.
    Instead, it provides two utilities for extracting its data part: `rpm2cpio` and
    `rpm2archive`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`rpm` 命令本身并未提供解包 RPM 软件包的选项。相反，它提供了两个工具来提取数据部分：`rpm2cpio` 和 `rpm2archive`。'
- en: Unlike Debian packages, RPM packages do not store metadata as files inside an
    archive, but rather use a custom RPM file header to store it. The archive that
    follows that header only contains files that must be installed. Moreover, while
    `dpkg` uses a familiar `tar` archive format to pack multiple files into one, RPM
    uses a much less common CPIO format.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Debian 软件包不同，RPM 软件包不会将元数据作为归档内的文件存储，而是使用自定义的 RPM 文件头来存储这些信息。该头之后的归档仅包含必须安装的文件。此外，虽然
    `dpkg` 使用熟悉的 `tar` 归档格式将多个文件打包成一个，但 RPM 使用的是一个较不常见的 CPIO 格式。
- en: The `cpio` command is difficult to use. In particular, it needs the user to
    enter the path to every file that must be included in the archive, so it’s impractical
    to use by hand and can only be reasonably used in conjunction with another tool,
    such as `find`. For this reason, `tar` is far more popular because the TAR archiving
    tool can easily pack entire directories in one command, such as `tar cvf file.tar
    /path/to/directory`. However, the CPIO archive file format is simpler to implement,
    doesn’t vary between implementations from different vendors, and has better support
    for special files, such as links and device files, which is why some projects
    have chosen to use it internally. Among those projects are the Linux kernel, which
    uses it for the initial RAM disk, and RPM, which uses it for package files.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpio` 命令较难使用。特别是，它需要用户输入每个必须包含在归档中的文件路径，因此不适合手动使用，并且只能合理地与其他工具（如 `find`）结合使用。由于这个原因，`tar`
    更受欢迎，因为 TAR 归档工具可以通过一条命令轻松地打包整个目录，例如 `tar cvf file.tar /path/to/directory`。然而，CPIO
    归档文件格式更容易实现，不同厂商的实现之间没有差异，而且对特殊文件（如链接和设备文件）有更好的支持，这也是一些项目选择在内部使用它的原因。那些项目包括 Linux
    内核，它使用 CPIO 格式来处理初始 RAM 磁盘，以及 RPM，它使用 CPIO 格式来处理软件包文件。'
- en: 'Luckily, the `rpm2archive` utility can convert an RPM package into a compressed
    `tar` archive, so you don’t need to learn how to use `cpio` just to extract files
    from RPM packages:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`rpm2archive` 工具可以将 RPM 软件包转换为压缩的 `tar` 归档文件，因此你无需学习如何使用 `cpio` 来从 RPM
    软件包中提取文件：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now let’s move on to inspecting packages installed in the system.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续学习如何检查系统中已安装的软件包。
- en: Inspecting installed packages
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查已安装的软件包
- en: Both software project files and the metadata that we have seen inside package
    files are retained in the system when the package is installed. Let’s learn how
    to access information about installed packages and compare it with what we have
    seen inside package files.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 软件项目文件和我们在软件包文件中看到的元数据都会在软件包安装时保留在系统中。让我们学习如何访问已安装软件包的信息，并与我们在软件包文件中看到的内容进行比较。
- en: Listing all installed packages
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出所有已安装的软件包
- en: Both `dpkg` and `rpm` provide an option to list all packages installed on the
    system. Since those lists are going to be rather long even for small installations,
    you may want to use them with a pager command such as `less` or a filter such
    as `head`, `tail`, or `grep`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`dpkg`和`rpm`都提供了列出系统中所有已安装软件包的选项。由于这些列表即使在小型安装中也会非常长，因此你可能希望将它们与分页命令（如`less`）或过滤器（如`head`、`tail`或`grep`）一起使用。'
- en: 'For Debian-based systems, the command to list all installed packages is `dpkg
    --list`, or `dpkg -l` for short. The list is sorted alphabetically by default:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Debian 系统，列出所有已安装软件包的命令是`dpkg --list`，或者简写为`dpkg -l`。默认情况下，列表按字母顺序排序：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For RPM-based distributions, that command is `rpm --query --all`, or `rpm -qa`.
    Note that RPM does not sort that output alphabetically by default:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于 RPM 的发行版，命令是`rpm --query --all`，或者`rpm -qa`。请注意，RPM 默认不按字母顺序排序该输出：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you simply want to check whether a package is installed, RPM provides an
    option to check just that, without outputting any other information, that is,
    `rpm --query` (`rpm -q`):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仅想检查某个软件包是否已安装，RPM 提供了一个选项，仅检查这一点，而不输出其他任何信息，即`rpm --query`（`rpm -q`）：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The equivalent for Debian-based systems is `dpkg --status` (`dpkg -s`), which
    also prints information about a package if it’s installed:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Debian 系统上的等效命令是`dpkg --status`（`dpkg -s`），如果软件包已安装，它也会打印该软件包的信息：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If a package is not installed, that command prints an error:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个软件包未安装，该命令会打印一个错误：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you want to retrieve information about an installed package in an RPM-based
    system, you can use the same `rpm -qi` command as we used for inspecting a package
    file; just give it the name of the package rather than a file path:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取 RPM 系统中已安装软件包的信息，可以使用与我们检查软件包文件时相同的`rpm -qi`命令；只需给出软件包的名称，而不是文件路径：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you need to find out what package a file comes from (or whether it belongs
    to any package at all), there are commands for that task as well. For RPM, it’s
    `rpm --query --file` (`rpm -qf`):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要找出某个文件来自哪个软件包（或者它是否根本不属于任何软件包），也有相应的命令。对于 RPM，命令是`rpm --query --file`（`rpm
    -qf`）：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For `dpkg`, it’s `dpkg --search` (`dpkg -S`):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`dpkg`，命令是`dpkg --search`（`dpkg -S`）：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With RPM, it’s also easy to list all files that belong to a certain package,
    and the command is the same as we have already used to list the contents of a
    package file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RPM，同样可以轻松列出属于某个软件包的所有文件，命令与我们之前列出软件包内容的命令相同：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For `dpkg`, the equivalent is `dpkg --listfiles` (`dpkg -L`). However, `dpkg`
    also lists all directories where files or subdirectories from that package can
    be found, even top-level directories such as `/etc`, while RPM only shows files
    and directories that were created as a result of installing a package:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`dpkg`，等效命令是`dpkg --listfiles`（`dpkg -L`）。然而，`dpkg`还会列出该软件包文件或子目录所在的所有目录，甚至包括像`/etc`这样的顶层目录，而
    RPM 只会显示因安装软件包而创建的文件和目录：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, installing packages and removing them is a much more frequent task
    than inspecting installed ones—let’s learn how to do it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，安装和移除软件包是比检查已安装软件包更为频繁的任务——让我们来学习如何执行这些操作。
- en: Installing and removing package files
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和移除软件包文件
- en: Even the man page of `dpkg` warns that unpacking a package to the root directory
    is not the correct way to install it. There are multiple reasons why the installation
    of a package is not as simple as just copying the files from it to the right places.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是`dpkg`的手册页也警告说，解压软件包到根目录并不是正确的安装方法。软件包的安装之所以不简单，仅仅将文件从软件包复制到正确的位置是远远不够的，原因有很多。
- en: Apart from copying files, package managers record the package and its files
    in an internal database—that is why commands such as `dpkg --listfiles` and `rpm
    --query --files` can work, and why package managers can reliably delete packages
    without leaving any unused files behind.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了复制文件之外，包管理器还会在内部数据库中记录软件包及其文件——这就是为什么像`dpkg --listfiles`和`rpm --query --files`这样的命令能够正常工作，也解释了为什么包管理器可以可靠地删除软件包而不会留下任何未使用的文件。
- en: 'However, package managers also include safeguards against trying to install
    a package that is guaranteed not to work on the system. For example, this is what
    will happen if you try to install a package built for ARM64 on an x86_64 (Intel
    or AMD64) machine:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，包管理器也会包括一些保护机制，防止用户安装在系统上无法正常工作的包。例如，如果你尝试在 x86_64（Intel 或 AMD64）机器上安装一个为
    ARM64 架构构建的软件包，会发生以下情况：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: They will also protect the system from attempts to delete packages that should
    not be deleted, or at least warn the user about the consequences. Since they track
    all dependencies between packages, they can force the removal of packages that
    will become broken if a package they depend on is removed, but by default, they
    will refuse to delete any package if other packages depend on it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还会保护系统免受删除不应删除的软件包的尝试，或者至少会警告用户删除的后果。由于它们跟踪包之间的所有依赖关系，它们可以强制删除那些在依赖的包被删除后会损坏的包，但默认情况下，如果其他包依赖于某个包，它们将拒绝删除该包。
- en: 'In Debian-based Linux distributions, there’s a concept of essential packages
    that are protected from removal attempts. For example, you will get an error if
    you try to delete Bash since it’s the default system shell:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Debian 的 Linux 发行版中，有一个概念叫做“基本软件包”，这些软件包会被保护，无法被删除。例如，如果你尝试删除 Bash，系统会报错，因为它是默认的系统
    shell：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If a package is not essential, you will get a list of dependent packages that
    prevent its removal:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个包不是基本包，你将看到一份依赖包列表，显示哪些包阻止它被删除：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: RPM has a similar functionality and will not allow the user to install packages
    with unsatisfied (or unsatisfiable, in case of a different architecture) dependencies
    or remove essential packages.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: RPM 也有类似的功能，它不会允许用户安装有未满足（或者在不同架构下是无法满足的）依赖关系的软件包，或者删除基本软件包。
- en: 'This is what an attempt to install a package for a different architecture may
    look like:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如果你尝试安装一个为不同架构构建的软件包时可能发生的情况：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And this is what you will get if you try to remove `rpm` itself:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试删除 `rpm` 本身，这就是你将得到的结果：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, in modern systems, both the installation and removal of packages with
    `rpm` and `dpkg` are an exception rather than a rule. While they prevent the installation
    of packages that have missing dependencies, they do not automate the installation
    of those dependencies, so trying to install a package with a lot of dependencies
    is a very tedious task. If you were to upgrade your system, you’d also have to
    upgrade all packages and their dependencies one by one. That’s the main reason
    why package repositories and high-level package managers were invented.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现代系统中，无论是使用 `rpm` 还是 `dpkg` 安装或删除包，已经不再是常规操作，而是例外。虽然它们防止安装缺少依赖关系的软件包，但它们并不会自动安装这些依赖关系，因此尝试安装依赖关系很多的软件包是一项非常繁琐的任务。如果你要升级系统，你还必须逐一升级所有软件包及其依赖项。这也是包仓库和高级包管理器发明的主要原因。
- en: Package repositories and high-level package managers
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包仓库和高级包管理器
- en: Online collections of packages for Linux distributions have existed for almost
    as long as the distributions themselves. They saved users’ time searching for
    compiled packages or building software from source, but if a package had dependencies,
    the user would still need to download them all one by one.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 发行版的在线包集合几乎与发行版本身一样存在了很久。它们节省了用户搜索编译包或从源代码构建软件的时间，但如果某个包有依赖关系，用户仍然需要逐一下载它们。
- en: The next step for distribution maintainers was to create a format for machine-readable
    metadata from the entire package collection and a tool that would automate that
    process. Since every package contains information about its dependencies, in the
    simplest case, you just need to download them all.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 发行版维护者的下一步是为整个包集合创建一种机器可读的元数据格式，并提供一个工具来自动化该过程。由于每个包都包含关于其依赖关系的信息，在最简单的情况下，你只需下载所有依赖包。
- en: In reality, it’s more complicated. Packages may conflict (for example, because
    they provide an executable with the same name) and there must be a safeguard against
    attempts to install conflicting packages. If a user tries to install a package
    from outside the repository, the repository may not have the right versions of
    its dependencies. Modern high-level package managers check for these and many
    other possible issues, so most of the time the user can just say “*I want a certain
    package installed*” and the tool will do everything that needs to be done to install
    it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Package repositories
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A package repository in the modern sense is a collection of packages that comes
    with a machine-readable index. The repository index contains information about
    every package. Essentially, an index aggregates the package metadata files we
    have seen when inspecting packages with `dpkg --info` and `rpm --``query --info`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Websites with information about distribution packages such as [https://www.debian.org/distrib/packages](https://www.debian.org/distrib/packages)
    and [https://packages.fedoraproject.org/](https://packages.fedoraproject.org/)
    are in fact generated from their package repository indices. When we used them
    to look up and download packages, we essentially did by hand what high-level package
    managers can do automatically.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Every distribution has its official repositories, and community- or vendor-supported
    repositories exist for popular distributions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Debian-based distribution repositories
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Repository configuration in Debian-based distributions can be found in the `/etc/apt/`
    directory. The main file is `/etc/apt/sources.list` but there may be additional
    files in `/etc/apt/sources.list.d`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of a `sources.list` file from a Debian 10 (Buster) system.
    Notice that apart from remote repositories, it’s also possible to specify paths
    to repositories on local media such as optical drives. If you install a Debian
    system from a CD or DVD, the installer will add that as a repository entry so
    that you can install additional packages from that disk later on:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Debian also uses different repository components that you can enable or disable.
    In this example, only the `main` repository is enabled. The `main` repository
    includes essential packages. Apart from them, there are `contrib` and `non-free`
    repositories. The `contrib` repository includes a broad selection of additional
    packages that aren’t as actively maintained as those from `main`. The non-free
    repository contains packages whose licenses don’t qualify as free software—they
    are redistributable, but may have restrictions on modifications or distribution
    of modified versions, or come without source code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: For better or worse, many firmware files required for devices to work are under
    non-free licenses, so in practice, you may always use `main contrib non-free`
    rather than just `main` in Debian repository configuration lines.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the distribution version (`buster`, in this case) is explicitly
    hardcoded in the configuration file and you will need to change it yourself to
    upgrade to a new distribution version.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The repository URL is also set explicitly, usually to the mirror site you chose
    at installation time.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: RPM package repositories
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fedora and Red Hat Enterprise Linux (and its derivatives such as CentOS and
    Rocky Linux) keep repository files in `/etc/yum.repos.d/`. Most often, there is
    one file per repository. This is an example of the base Fedora repository file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that there is no explicit reference to the Fedora version anywhere; instead,
    there are placeholder variables such as `$releasever` and `$basearch`. The high-level
    management tools automatically substitute those variables with data from the installed
    system.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: There is also an option to make the system use mirror lists instead of single
    mirrors for reliability and load balancing. You can specify either a specific
    mirror in the `baseurl` option or a link to the Metalink protocol to automatically
    get a mirror list instead.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: High-level package managers
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we already discussed, both `rpm` and `dpkg` were developed at a time when
    automatically downloading packages over a network was not feasible for most users
    because most computers only had a slow and intermittent connection to the Internet
    over a dial-up modem. By the end of the 90s, Internet connections had become significantly
    faster, so online package repositories became a logical possibility.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The Debian project developed its high-level package manager named APT in 1998
    and most Debian-based distributions have been using it since then.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: RPM-based distributions developed multiple high-level package managers independently.
    One reason for that is that many of the RPM-based distributions were created independently
    in the 90s, while most Debian-based ones are forks of Debian itself that were
    created after the introduction of APT.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Linux distributions maintained by Red Hat Inc. itself went through multiple
    high-level package managers, starting from `up2date`, which was mainly meant for
    their paying customers. That tool was later replaced by YUM, which came from a
    now-defunct distribution named Yellow Dog Linux. Its name originally meant Yellow
    dog Updater, Modified. Later, it was replaced by DNF—since the mid-2010s in Fedora
    and since the eighth release of Red Hat Enterprise Linux in 2019\. Older but still
    supported versions of Red Hat Enterprise Linux and its derivatives continue to
    use YUM. Luckily for users, while YUM and DNF mostly differ in their internal
    implementation, their user interface is almost the same—except for the new features
    of DNF, of course. The name DNF doesn’t officially stand for anything, but originally
    came from **DaNdiFied YUM**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The design choices of APT and YUM/DNF are very different, and you need to be
    aware of those differences when you switch between them. Let’s learn how to use
    them to install packages.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Installing and removing packages with YUM or DNF
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The command to install a package is `dnf install`. Installing a package requires
    administrative privileges, so you need to remember to run all such commands with
    `sudo`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: When you run an installation command, YUM and DNF will automatically download
    package index files from the repository, so you don’t need to take any action
    to ensure that you have up-to-date repository metadata. A disadvantage of that
    approach is that sometimes you may have to wait for it to download that metadata,
    which may take a few minutes or more on very slow connections.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the installation process is completely automated. YUM and DNF will
    show you a list of packages that would be downloaded and installed and how much
    space they would need. If you say `yes`, it will proceed with the download and
    installation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Removing a package is also straightforward. Just run `dnf` `remove hello`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike RPM, DNF and YUM do have a concept of protected packages, so they will
    outright refuse to delete essential packages such as `bash` or `rpm`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This protection from erroneous user actions is a significant reason to use YUM
    or DNF to remove packages despite the fact that RPM is technically sufficient
    for that task.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Installing and removing packages with APT
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'APT uses a different approach to metadata download: it leaves that operation
    to the user. Unlike YUM and DNF, APT will never automatically download repository
    indices, so on a freshly deployed Debian-based system, trying to search for or
    install packages will give you a *package not* *found* error.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'APT consists of sub-tools for different purposes: `apt-get` for repository
    index updates and package actions (such as installing, removing, or listing package
    files), and `apt-cache` for package search. In modern Debian versions, you will
    find a combined tool named `apt`. You may also want to use an alternative frontend
    named `aptitude`, which we will discuss later.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can install anything, you need to force the repository index download
    with `apt-get update` or `apt update`. `update` in its name refers only to a metadata
    update, not to a package update:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After that, you can search for packages with `apt-cache search` or `apt search`
    and install them with `apt install` or `apt-get install`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with the following command, you can install the `hello` package
    automatically from the repositories, without having to download it by hand:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'APT also includes protection against the removal of essential packages. Trying
    to remove `bash`, for example, will require a special confirmation:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Needless to say, you should not do this unless you are absolutely certain that
    what you are doing is safe—for example, if you have made sure that every user
    uses a shell other than Bash and there are no scripts in the system that require
    Bash rather than a POSIX Bourne shell.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing a non-essential package, such as `hello`, will not raise any such
    errors:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There is also the `apt-get purge` command, which removes not only executables
    and data files but also all configuration files associated with the package. Most
    of the time, `apt-get remove` is sufficient, but to remove a package such as a
    web server, you may prefer `apt-get` `purge` instead.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Searching for packages
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both APT and YUM/DNF provide a search command, so if you don’t know the exact
    name of a package, you can search for it. However, they search for a pattern in
    every field but only display the name and the short description by default, so
    search results may look odd and include entries that seem to have nothing to do
    with your request.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s try to search for the `hello` package on a Debian system:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Sometimes, you may want to search for a package that provides a certain command
    or a library file (for example, if you are getting a script error that complains
    that it wasn’t found).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'In YUM and DNF, there is a built-in option for that: `whatprovides`. It supports
    both exact file paths and wildcard matches. Suppose you want to install a package
    that provides a `hello` command. Executable files of commands are always in some
    `bin/` directory, but we don’t know whether it’s going to be `/bin`, `/usr/bin`,
    `/usr/sbin`, or something else. However, we can search for `*/bin/hello` to find
    any executable with that name in any package. It will include some irrelevant
    results, but it will tell us what we want to know:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In Debian-based systems, it’s not that simple. You will need to install an optional
    `apt-file` tool (`apt-get install apt-file`) and run `apt-file update` to download
    additional indices.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'It also doesn’t support wildcard matching, so if you don’t know the exact path,
    you will need to supply a Perl-compatible regular expression for your search:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, YUM and DNF provide more functionality out of the box, while
    APT may require installing additional packages. Nonetheless, it should be possible
    to execute the same search operations with all of those tools.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: System upgrade
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another advantage of high-level package managers is that they automate the upgrade
    of the entire system (or at least packages installed from repositories).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading a system with YUM or DNF
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The command to upgrade all packages is `dnf upgrade` or `yum upgrade`. To force
    a repository index download, you can add `--refresh`. In some cases, you will
    also want to remove conflicting or outdated packages to complete an upgrade; in
    that case, you may need `dnf` `upgrade --allowerasing`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you say `yes`, it will automatically download new package versions and overwrite
    old packages with them.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Upgrading a Fedora system to a new distribution version requires a different
    procedure, however. This is only possible with DNF and needs a plugin available
    from Fedora repositories. The command sequence to upgrade an older system to Fedora
    36 (the current version in 2022) would be as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `dnf system-upgrade download --releasever=36` command will download all
    packages required to upgrade to a new version and run a transaction check. On
    rare occasions, you will need to remove certain packages if they are no longer
    available in a new Fedora version. If the check is successful, you can start the
    upgrade procedure with `dnf system-upgrade reboot`—your system will boot into
    a minimal environment to perform the upgrade, then boot to the new Fedora version
    as normal.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading a system with APT
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'APT includes upgrade commands with different functionality instead of using
    modifier options as YUM and DNF do:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '`apt upgrade` and `apt-get upgrade` will only upgrade installed packages to
    newer versions if they are available, but never perform any other actions'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apt full-upgrade` or `apt-get dist-upgrade` may remove packages if it’s required
    to upgrade the system as a whole'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the time, you should use `apt-get dist-upgrade` because when you update
    packages within the same distribution version, package removal events are incredibly
    rare, while if you upgrade to a new distribution version, there will not be a
    way around it—you will need to have them removed one way or another before you
    can upgrade.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a typical package update will look like:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Upgrading a Debian-based system to a new distribution version is more involved.
    You will need to look up the codename of the new version and replace the old one
    in your repository configuration files. For example, if you are upgrading from
    Debian 10 to 11, you need to replace every occurrence of `buster` (the codename
    of Debian 10) with `bullseye` (the codename of Debian 11), then run `apt-get dist-upgrade`
    and reboot your system.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, system-wide upgrade procedures are conceptually similar in Red
    Hat and Debian-based distributions, even if the exact commands and implementation
    details differ.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about low-level and high-level package managers
    used by popular Linux distributions. We learned how to install and remove packages
    using DNF and APT and how to perform a system upgrade. We also learned how to
    inspect package files by hand and interpret their internal structure—while that
    task is much less frequent, it’s important to know to have a deeper understanding
    of software packaging and the package management process. However, package managers
    offer a lot of additional options and capabilities, so make sure to read their
    documentation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about network configuration and debugging
    in Linux systems.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'RPM documentation: [http://rpm.org/documentation.xhtml](http://rpm.org/documentation.xhtml)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'dpkg: [https://www.dpkg.org/](https://www.dpkg.org/)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DNF documentation: [https://dnf.readthedocs.io/en/latest/](https://dnf.readthedocs.io/en/latest/)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'APT documentation: [https://wiki.debian.org/PackageManagement](https://wiki.debian.org/PackageManagement)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
