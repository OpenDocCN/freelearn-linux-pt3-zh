<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer264">
			<h1 id="_idParaDest-338"><em class="italic"><a id="_idTextAnchor345"/>Chapter 15</em>: Troubleshooting Shell Scripts</h1>
			<p>If you have come this far, you must have a lot of ideas about how to write a shell script, and even more questions about the ways you can make particular things in scripts work. This is completely normal. Your scripting journey has just started. No amount of reading can make up for time spent writing scripts, trying out different solutions, and understanding how different commands work.</p>
			<p>We have some good news and some bad news for you. Being good at scripting takes a long time and, in scripting, most of that time is going to be spent trying to understand what your script should be doing and, usually, why it is doing it wrong. The good news is that scripting is never boring.</p>
			<p>In this chapter, we will try to give you the tools needed to debug and troubleshoot scripts quickly and without a lot of confusion. The tools are going to be in the form of different methods you can use to maximize your ability to find logical and, sometimes, syntactical errors in scripts. We are going to start with the basic recipes and go on to more complex ways to work on scripts.</p>
			<p>We will cover the following recipes in this chapter: </p>
			<ul>
				<li>Common scripting mistakes</li>
				<li>Simple debugging approach – echoing values during script execution</li>
				<li>Using the <strong class="source-inline">bash</strong> <strong class="source-inline">-x</strong> and <strong class="source-inline">-v</strong> options</li>
				<li>Using <strong class="source-inline">set</strong> to debug a part of the script</li>
			</ul>
			<h1 id="_idParaDest-339"><a id="_idTextAnchor346"/>Technical requirements </h1>
			<p>In this chapter, we are going to use the same machine as in all the previous chapters on scripting in this book. Do not be alarmed that there are a couple of screenshots that are made in Windows. They are there just to illustrate a point; you don't need Windows to do anything. Just like earlier, we are using the following:</p>
			<ul>
				<li>A virtual machine with Linux installed, any distribution (in our case, it's going to be <em class="italic">Ubuntu 20.10</em>)</li>
			</ul>
			<p>Now, let's dive into troubleshooting.</p>
			<h1 id="_idParaDest-340"><a id="_idTextAnchor347"/>Common scripting mistakes</h1>
			<p>Writing a script will present many problems, including how to design it, how to find the right solutions to different problems, and how to make all of this usable in the target environment. These can <a id="_idIndexMarker1031"/>be things you can easily solve in a couple of minutes, or things you will spend days or even weeks trying to solve. All this time will probably just be a small percentage of the total time you will spend debugging and troubleshooting scripts. Writing and troubleshooting scripts are two wholly different things – while you usually write your own scripts from scratch, you will not only debug and troubleshoot your own code.</p>
			<p>Writing requires skill and deep knowledge of your environment, but it can be argued that to debug and troubleshoot, you need even more understanding of both your task and the way your script is trying to accomplish it. In this recipe, we are going to work on the skills you need to understand not only how to troubleshoot scripts you have written, but also any scripting code you run into, whether it's a part of something you've created or a separate system created by someone else that you are responsible for getting running.</p>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor348"/>Getting ready</h2>
			<p>Troubleshooting and debugging sound and look like the same task, but they are subtly different. In general, when we are debugging, we are concentrating on finding logical and other errors in our scripts. When troubleshooting, we are not only debugging but also trying gain more understanding of what should be done and how your application is trying to accomplish it. In the recipes in this chapter, we are going to use both these expressions for one thing – trying to make something that is not working correctly work as it should, or at least better.</p>
			<p>There are a few things you can do to make this as easy as possible, and one of them is to get as much knowledge as possible about scripting under your belt. Being able to understand scripts and the specific ways things are done to solve them will enable you to quickly understand not only what the problem is but also how to solve it.</p>
			<p>Sometimes the solution may be to simplify a part of code using a standard solution, or break code into different, more standardized modules.</p>
			<p>When faced with a more complex script, this method of breaking code down into more manageable and understandable <a id="_idIndexMarker1032"/>modules can be amazingly successful since even the greatest script-writers sometimes completely miss the point of what they are doing and complicate even the simplest tasks.</p>
			<p>When talking about debugging, we need to talk about errors. Broadly, we can have four different outcomes from our script:</p>
			<ul>
				<li>The script works as desired.</li>
				<li>The script throws an error.</li>
				<li>The script works but not completely, making errors.</li>
				<li>The script works but sometimes silently breaks something either in the input or output data.</li>
			</ul>
			<p>When we have the time, we can work on any of these possible outcomes and make a script behave better, even one that works correctly. Sometimes it pays to spend some time to make your script more beautiful, more commented, and more readable, even if it works alright.</p>
			<p>Another case is scripts throwing an error. Bash has a reputation for having cryptic and generic error messages. Some of them are too vague to be of much assistance, and sometimes they make no sense at all and don't help us to understand what is actually wrong.</p>
			<p>One common example that you will notice from time to time is not understanding ends of lines correctly. Windows and Linux treat ends of lines differently. While Windows terminate text files using both the carriage return and new line characters, Linux only uses new line characters for line termination. Bash can have a problem with that, and scripts written on Windows will sometimes break for no apparent reason. This is the same script on Windows and Linux, with an editor that shows all the characters in a file: </p>
			<div>
				<div id="_idContainer248" class="IMG---Figure">
					<img src="Images/Figure_15.1_B16269.jpg" alt="Figure 15.1 – In Linux, lines are terminated by a single character&#13;&#10;" width="1213" height="796"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.1 – In Linux, lines are terminated by a single character</p>
			<p>In Windows, it looks <a id="_idIndexMarker1033"/>similar, but we can see that line ends have two characters:</p>
			<div>
				<div id="_idContainer249" class="IMG---Figure">
					<img src="Images/Figure_15.2_B16269.jpg" alt="Figure 15.2 – In Windows, two characters are used to terminate a line&#13;&#10;" width="1650" height="929"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.2 – In Windows, two characters are used to terminate a line</p>
			<p>In Linux, if we do not <a id="_idIndexMarker1034"/>edit the file correctly and forget to strip out extra characters, we will end up with characters that will be invisible in a normal editor and break the code at the same time:</p>
			<div>
				<div id="_idContainer250" class="IMG---Figure">
					<img src="Images/Figure_15.3_B16269.jpg" alt="Figure 15.3 – In vim, you need to turn on a couple of options to see special characters&#13;&#10;" width="1207" height="795"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.3 – In vim, you need to turn on a couple of options to see special characters</p>
			<p>Note that there is a utility called <strong class="source-inline">dos2unix</strong> (and <strong class="source-inline">unix2dos</strong> if you need conversion the other way around) that fixes ends of lines when transferring files. This problem is system wide and more than <a id="_idIndexMarker1035"/>a couple of programs will behave strangely when they encounter text files from Windows.</p>
			<p>If we do not deal with characters at the ends of lines, the script will break. For example, we tried running the file that came from Windows in Linux, we get completely cryptic errors mentioning commands that look like they are not even in the script. We are using <strong class="source-inline">dos.sh</strong> as the name of the script that we saved in Linux: </p>
			<p class="source-code">demo@ubuntu:~/Desktop/allscripts$ bash dos.sh </p>
			<p class="source-code">dos.sh: line 2: $'\r': command not found</p>
			<p class="source-code">dos.sh: line 4: $'\r': command not found</p>
			<p class="source-code">dos.sh: line 26: syntax error near unexpected token 'else'</p>
			<p class="source-code">'os.sh: line 26: '    else</p>
			<p>Also, we need to make it clear that if you use copy and paste to move files between your environments, this will fix the problem directly. When you paste a line in a particular operating system, it will <a id="_idIndexMarker1036"/>automatically create the right line endings. This does not cover copying and pasting the entire file; if you do that, you are transferring the entire file's content.</p>
			<p>Another common syntax error that can be difficult to find is using the wrong quote, either by mixing them up or using a quote instead of a backtick character when executing commands inside scripts:</p>
			<div>
				<div id="_idContainer251" class="IMG---Figure">
					<img src="Images/Figure_15.4_B16269.jpg" alt="Figure 15.4 – Completely normal script, highlighted by syntax in vim&#13;&#10;" width="1216" height="794"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.4 – Completely normal script, highlighted by syntax in vim</p>
			<p>If we change one backtick to a quote, this will turn into the following: </p>
			<div>
				<div id="_idContainer252" class="IMG---Figure">
					<img src="Images/Figure_15.5_B16269.jpg" alt="Figure 15.5 – Without proper highlighting, an error like this can cause serious problems&#13;&#10;" width="1216" height="796"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.5 – Without proper highlighting, an error like this can cause serious problems</p>
			<p>We are using vim here, and you will notice the change right away. The editor understands syntax and <a id="_idIndexMarker1037"/>highlights the appropriate code block in a different color. </p>
			<p>If we try to run this script, it will throw an error: </p>
			<p class="source-code">demo@ubuntu:~/Desktop/allscripts$ bash backupexample.sh </p>
			<p class="source-code">backupexample.sh: line 4: unexpected EOF while looking for matching '''</p>
			<p class="source-code">backupexample.sh: line 8: syntax error: unexpected end of file</p>
			<p>This error is a little confusing. Bash is telling us that it got to the end of the file while trying to find the closing quote.</p>
			<p>One thing all of these errors have in common is using different fonts in different editors. Sometimes, the difference between characters is so minor that it is extremely hard to spot. Bash makes it even harder by reporting errors that are sometimes pointing to a completely different part of the code.</p>
			<p>The solution to this is using a font you know is legible and using an editor that is able to pair characters such as parentheses. Quotes and backticks will probably remain a problem since most <a id="_idIndexMarker1038"/>applications are unable to match them. Editors such as vim will, however, highlight comments and, as we saw in the previous example, this will make errors such as this visible.</p>
			<p>This is an example of highlighted brackets in Notepad++ on Windows, since we mentioned the multi-platform approach:</p>
			<div>
				<div id="_idContainer253" class="IMG---Figure">
					<img src="Images/Figure_15.6_B16269.jpg" alt="Figure 15.6 – Highlighting brackets in Notepad&#13;&#10;" width="1571" height="1082"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.6 – Highlighting brackets in Notepad</p>
			<p>Of course, we also have our standard run-of-the-mill syntax errors that are inevitable. A good editor will also help with these:</p>
			<div>
				<div id="_idContainer254" class="IMG---Figure">
					<img src="Images/Figure_15.7_B16269.jpg" alt="Figure 15.7 – Having an editor that's capable of highlighting braces and parentheses will save you&#13;&#10;" width="1263" height="856"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.7 – Having an editor that's capable of highlighting braces and parentheses will save you</p>
			<p>The error is in the <strong class="source-inline">then</strong> keyword, and vim highlights that by making the keyword white instead of the yellow that it <a id="_idIndexMarker1039"/>uses for regular keywords. </p>
			<p>After dealing with syntax, it is time to see how to avoid arguably more complicated and tougher-to-spot errors in logic.</p>
			<h2 id="_idParaDest-342"><a id="_idTextAnchor349"/>How to do it…</h2>
			<p>Mentioning logic in scripting can be deceiving. Logic can, in the very strict definition of the term, be formal logic in clauses that require logic expressions to work, or can more broadly mean any decision-making inside the script. When we say <em class="italic">error in logic</em>, we usually think of the latter; problems that are created when our script behaves like we told it to, not like we thought we told it to. Every unexpected behavior that is not a result of a syntax error falls into this category.</p>
			<p>For example, let's presume that we want to sort a couple of numbers using the <strong class="source-inline">sort</strong> command. This may look easy but has a small flaw. <strong class="source-inline">sort</strong>, by default, sorts alphabetically, and not numerically:</p>
			<p class="source-code">demo@ubuntu:~/Desktop/allscripts$ du -a | sort</p>
			<p class="source-code">0           ./errorfile</p>
			<p class="source-code">0           ./settings</p>
			<p class="source-code">264      .</p>
			<p class="source-code">4           ./arrayops.sh</p>
			<p class="source-code">4           ./array.sh</p>
			<p class="source-code">4           ./associative.sh</p>
			<p class="source-code">4           ./auxscript.sh</p>
			<p class="source-code">4           ./backupexample.sh</p>
			<p class="source-code">4           ./dialogdate.sh</p>
			<p class="source-code">4           ./dos.sh</p>
			<p class="source-code">4           ./doublevar.sh</p>
			<p class="source-code">4           ./echoline1.sh</p>
			<p class="source-code">4           ./echoline.sh</p>
			<p>We end up having value of <strong class="source-inline">264</strong> being larger than <strong class="source-inline">0</strong> but smaller than <strong class="source-inline">4</strong>, which is wrong. If we want to sort <a id="_idIndexMarker1040"/>something as we intended to, we should be using the appropriate switch:</p>
			<p class="source-code">demo@ubuntu:~/Desktop/allscripts$ du -a | sort -n</p>
			<p class="source-code">0           ./errorfile</p>
			<p class="source-code">0           ./settings</p>
			<p class="source-code">4           ./arrayops.sh</p>
			<p class="source-code">4           ./array.sh</p>
			<p class="source-code">4           ./associative.sh</p>
			<p class="source-code">4           ./auxscript.sh</p>
			<p class="source-code">.</p>
			<p class="source-code">.</p>
			<p class="source-code">.</p>
			<p class="source-code">264       .</p>
			<p>This is much better. Errors like this are not strictly a problem with Bash but instead happen when we are unsure of how a command is used, the result of which is that our script will misbehave.</p>
			<p>Another thing you are going <a id="_idIndexMarker1041"/>to see frequently is invalid index referencing. In arrays, indices start from <strong class="source-inline">0</strong>, but people usually count from <strong class="source-inline">1</strong>: </p>
			<div>
				<div id="_idContainer255" class="IMG---Figure">
					<img src="Images/Figure_15.8_B16269.jpg" alt="Figure 15.8 – Misnumbering indices is common when programming in any language&#13;&#10;" width="1309" height="982"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.8 – Misnumbering indices is common when programming in any language</p>
			<p>When we try and run this, we <a id="_idIndexMarker1042"/>are going to lose one pair of variables in our output since we missed the first element in the array:</p>
			<p class="source-code">demo@ubuntu:~/Desktop/allscripts$ bash errpairs.sh </p>
			<p class="source-code">Name:Luke number:12344</p>
			<p class="source-code">Name:Ivan from work number:113312</p>
			<p class="source-code">Name:Ida number:11111</p>
			<p class="source-code">Name:That guy number:122222</p>
			<p class="source-code">Name: number:</p>
			<p>The errors that doing this creates are sometimes easy to spot when the script is run, but some use cases, especially those that deal with only a part of an array, may create strange problems. The same <a id="_idIndexMarker1043"/>problem can and will happen in loops using arguments, like in this example, and if we do not print the values straight away, we may not notice that we are processing only part of the array.</p>
			<p>Fundamentally, the problem is that definition of the number we are counting from is pretty arbitrary. Usually, we use 0 as the first index, but there are some exceptions to this. If you're not completely sure, check.</p>
			<p>All of these problems are mentioned here very broadly. You need to know them, but the way you are going to deal with them in your scripts is going to be different for every script you create. Our intention here is to make you aware that the problem exists, so you can spot it before it becomes dangerous.</p>
			<p>The last big problem we mentioned was with scripts that work correctly most of the time, failing only in some cases and then failing only partially. This is the worst kind of problem, one that is dangerous since you cannot fully trust the output of the script, and hard to find since the output will be completely fine most of the time. The only way to deal with these problems is to carefully go through all the edge cases of your problem and test them on the script itself.</p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor350"/>How it works…</h2>
			<p>In this recipe, we were annoyingly vague when describing possible problems, and we did it on purpose. As with all things that are directly connected with making errors while working on some problem, we would like to avoid all of them, but it is impossible to define what to avoid until we make an error. Most problems we see will be the result of a poor presumption or a false understanding of a fact. Sometimes, it is going to be a simple typing error that will go unnoticed.</p>
			<p>There is also one more thing you can do to make things better when writing scripts. In order to avoid the most common problems with syntax and logic, primarily syntax, you can use automated tools.</p>
			<p>There are two types of tools you can use. We have already mentioned one, although we didn't explicitly mention that it is an actual tool. We instead said that your editor is going to take care of most of your problems. Editors that are currently available usually include functionality that enables them to understand the syntax of the language you are using and to offer help if they notice something wrong. Support of this kind in editors is usually rudimentary and limits itself to being able to understand keywords and the lexical structure of a particular language. It is not uncommon for an editor to switch this functionality on as soon as it is able to identify the file and to autodetect the language you are trying to use. We have already seen examples of this. For more, please review <a href="B16269_02_Final_PD_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Using Text Editors</em>. </p>
			<p>There is, however, another set of tools you can use. We are talking about completely automated tools that are not only able to find errors in your scripts but are also able to find potential problems in your commands, and to even advise you how to improve your code.</p>
			<p>You may wonder if it makes any sense to run an application on a script that will report the same errors as Bash would, and your question is valid. Bash is by itself completely capable of reporting any s<a id="_idIndexMarker1044"/>yntax errors, but it includes only a minimal set of messages to help you solve the problem. In essence, Bash reports only those errors that stop your code from working.</p>
			<p>A good tool for <em class="italic">code analysis</em>, and this is the term used when talking about these applications, will find problems in your code and will give you suggestions to improve the code you have written. Things that are going to be reported may be obvious at first glance, but some of them are also errors that can lead to problems, such as missing quotes or misplaced variable assignment.</p>
			<p>One such tool is <strong class="bold">ShellCheck</strong>, which is available both online and offline in the form of a package. In order to use it offline, you must install it using this command:</p>
			<p class="source-code">sudo apt install shellcheck</p>
			<p>After that, it's only a matter of running it on your script. We will do that later when we touch upon how you can also run this tool online in a browser, and it will give you the same results as the offline version. The only difference is the interface and the simplicity of clicking on a link inside a browser. Both versions report exactly the same errors and behave the same when it comes to recommendations.</p>
			<p>We are going to run this tool on a couple of our scripts to see what it has to say about the quality of our code. First, we are going to see what happens when we make a simple syntax error. We are using the script we used when we introduced the <strong class="source-inline">if</strong> statement. The script is named <strong class="source-inline">testif3.sh</strong>, and we have simply removed one line containing the <strong class="source-inline">then</strong> keyword:</p>
			<div>
				<div id="_idContainer256" class="IMG---Figure">
					<img src="Images/Figure_15.9_B16269.jpg" alt="Figure 15.9 – ShellCheck provides much better warnings about syntax errors than Bash does&#13;&#10;" width="1261" height="665"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.9 – ShellCheck provides much better warnings about syntax errors than Bash does</p>
			<p>We can see that the tool has found the problem immediately and has not only reported it, but has also given us a <a id="_idIndexMarker1045"/>suggestion about what to do next. The interesting thing is that it has marked the <strong class="source-inline">if</strong> statement that has the error in it, while Bash gave us an error that was comparatively misdirected, pointing to a piece of code that comes in much later in the script.</p>
			<p>If we fix the error, we can rerun the tool, as shown here: </p>
			<p class="source-code">demo@ubuntu:~/Desktop/allscripts$ shellcheck testif3.sh </p>
			<p class="source-code">demo@ubuntu:~/Desktop/allscripts$</p>
			<p>If there is no output from the tool, this means that no errors were detected. </p>
			<p>Now, let's do it on a more complex script. In this case, we are working with a script named <strong class="source-inline">funcglobal.sh</strong> from <a href="B16269_12_Final_PD_ePub.xhtml#_idTextAnchor283"><em class="italic">Chapter 12</em></a><em class="italic">, Using Arguments and Functions</em>: </p>
			<div>
				<div id="_idContainer257" class="IMG---Figure">
					<img src="Images/Figure_15.10_B16269.jpg" alt="Figure 15.10 – Using variables in this way is not an error as such but it can lead to problems&#13;&#10;" width="1308" height="984"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.10 – Using variables in this way is not an error as such but it can lead to problems</p>
			<p>The output does not look pretty because of the large font size in the terminal, but it gives us an idea of what to <a id="_idIndexMarker1046"/>do better in our script. As we mentioned earlier, spaces are a big problem and so by using double quotes, we will prevent a space character completely messing up our script.</p>
			<p>We are going to do one more example, a modified version of a script we used earlier and saved under the name <strong class="source-inline">functions.sh</strong>: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#shell script that automates common tasks</p>
			<p class="source-code">function rsyn {</p>
			<p class="source-code">    rsync -avzh $1 $2 </p>
			<p class="source-code">}</p>
			<p class="source-code">function usage {</p>
			<p class="source-code">echo In order to use this script you can:</p>
			<p class="source-code">echo "$0 copy &lt;source&gt; &lt;destination&gt; to copy files from source\ to destination"</p>
			<p class="source-code">echo "$0 newuser &lt;name&gt; to createuser with the username\ &lt;username&gt;"</p>
			<p class="source-code">echo "$0 group &lt;username&gt; &lt;group&gt; to add user to a group"</p>
			<p class="source-code">echo "$0 weather to check local weather"</p>
			<p class="source-code">echo "$0 weather &lt;city&gt; to check weather in some city on earth"</p>
			<p class="source-code">echo "$0 help for this help"</p>
			<p class="source-code">}</p>
			<p class="source-code">if [ "$1" != "" ] </p>
			<p class="source-code">             then</p>
			<p class="source-code">    case $1 in</p>
			<p class="source-code">         help)</p>
			<p class="source-code">            usage</p>
			<p class="source-code">            exit</p>
			<p class="source-code">            ;;</p>
			<p class="source-code">        copy)</p>
			<p class="source-code">            if [ "$2" != "" &amp;&amp; "$3" != "" ]</p>
			<p class="source-code">            then </p>
			<p class="source-code">            rsyn $2 $3</p>
			<p class="source-code">            fi</p>
			<p class="source-code">            ;;</p>
			<p class="source-code">    </p>
			<p class="source-code">        group)</p>
			<p class="source-code">            if [ "$2" != "" &amp;&amp; "$3" != "" ]</p>
			<p class="source-code">                  then </p>
			<p class="source-code">                       usermod -a -G $3 $2</p>
			<p class="source-code">            fi              </p>
			<p class="source-code">                       ;;</p>
			<p class="source-code">               newuser) </p>
			<p class="source-code">                          if [ "$2" != "" ]</p>
			<p class="source-code">                          then</p>
			<p class="source-code">                                       useradd $2</p>
			<p class="source-code">                          fi</p>
			<p class="source-code">                          ;;</p>
			<p class="source-code">              weather)</p>
			<p class="source-code">                          if [ "$2" != "" ]</p>
			<p class="source-code">                                     then </p>
			<p class="source-code">                                               curl wttr.in/$2</p>
			<p class="source-code">                                     else </p>
			<p class="source-code">                                                  curl wttr.in</p>
			<p class="source-code">                          fi</p>
			<p class="source-code">                          ;;</p>
			<p class="source-code">             </p>
			<p class="source-code">             </p>
			<p class="source-code">        *)</p>
			<p class="source-code">            echo "ERROR: unknown parameter $1\""</p>
			<p class="source-code">            usage</p>
			<p class="source-code">            exit 1</p>
			<p class="source-code">            ;;</p>
			<p class="source-code">    esac</p>
			<p class="source-code">             else</p>
			<p class="source-code">             usage</p>
			<p class="source-code">fi</p>
			<p>If we run ShellCheck on this, we are <a id="_idIndexMarker1047"/>going to end up with a long output, part of which looks like the following:</p>
			<div>
				<div id="_idContainer258" class="IMG---Figure">
					<img src="Images/Figure_15.11_B16269.jpg" alt="Figure 15.11 – Output of ShellCheck is going to warn you if it sees logical errors&#13;&#10;" width="1307" height="952"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.11 – Output of ShellCheck is going to warn you if it sees logical errors</p>
			<p>If we click on the link that ShellCheck provides as the last line of the output, we are taken to a detailed <a id="_idIndexMarker1048"/>explanation of why this is a problem, as can be seen in this screenshot:</p>
			<div>
				<div id="_idContainer259" class="IMG---Figure">
					<img src="Images/Figure_15.12_B16269.jpg" alt="Figure 15.12 – Links that ShellCheck provides give you detailed information about the error&#13;&#10;" width="1649" height="1341"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.12 – Links that ShellCheck provides give you detailed information about the error</p>
			<p>This explanation is not only useful, but it also contains more links for when we want to understand what actually went wrong, why it went wrong, and what is the reason for this being an issue to look <a id="_idIndexMarker1049"/>at in the first place. Sometimes, the problems that the tool detects are going to have limited scope and will be solved in some versions of the Bash interpreter yet misbehave in another.</p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor351"/>See also…</h2>
			<p>Troubleshooting is complicated since we are unable to anticipate all the possible problems. Some of them as follows are, however, common: </p>
			<ul>
				<li><a href="https://mywiki.wooledge.org/BashPitfalls">https://mywiki.wooledge.org/BashPitfalls</a></li>
				<li><a href="https://mywiki.wooledge.org/BashGuide">https://mywiki.wooledge.org/BashGuide</a></li>
				<li><a href="https://www.shellcheck.net/">https://www.shellcheck.net/</a></li>
			</ul>
			<h1 id="_idParaDest-345"><a id="_idTextAnchor352"/>Simple debugging approach – echoing values during script execution</h1>
			<p>The first thing you will learn when using Bash is how to regularly use the <strong class="source-inline">echo</strong> command when running any script. This approach is simple as it gives us an opportunity to follow the <a id="_idIndexMarker1050"/>workflow of the script and to print the values <a id="_idIndexMarker1051"/>of the variables as they are in different points of the script. Being able to understand both those things is going to help us to follow all the inputs to our script and to see how they transform into outputs that we expect.</p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor353"/>Getting ready</h2>
			<p>In this recipe, we are going to deal with simple ways we can make our script help us understand what is happening during its run. There are three ways we can use this simple method.</p>
			<p>The first thing we can do is use the <strong class="source-inline">echo</strong> command in every place in the script that we think is helpful. As an example, take a look at one of the scripts from previous chapters (<strong class="source-inline">funcglobal.sh</strong>) that is already pretty verbose: </p>
			<div>
				<div id="_idContainer260" class="IMG---Figure">
					<img src="Images/Figure_15.13_B16269.jpg" alt="Figure 15.13 – Using echo to debug program flow is useful when dealing with functions&#13;&#10;" width="1306" height="984"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.13 – Using echo to debug program flow is useful when dealing with functions</p>
			<p>We are going to add <a id="_idIndexMarker1052"/>even more <strong class="source-inline">echo</strong> statements here to <a id="_idIndexMarker1053"/>enable us to see exactly what is happening and in what order:</p>
			<div>
				<div id="_idContainer261" class="IMG---Figure">
					<img src="Images/Figure_15.14_B16269.jpg" alt="Figure 15.14 – There are never enough echo commands when debugging&#13;&#10;" width="1302" height="1107"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.14 – There are never enough echo commands when debugging</p>
			<p>If we now run our <a id="_idIndexMarker1054"/>modified script, we will be able to <a id="_idIndexMarker1055"/>precisely follow the flow of the script:</p>
			<p class="source-code">demo@ubuntu:~/Desktop/allscripts$ bash funcglobal.sh </p>
			<p class="source-code">Declaring global variable as Global Variable</p>
			<p class="source-code">In the main script before function is executed variable has the value of: Global variable</p>
			<p class="source-code">Now calling the function</p>
			<p class="source-code">Entered Function</p>
			<p class="source-code">declaring local variable as Local Variable</p>
			<p class="source-code">Inside the function variable has the value of: Local variable</p>
			<p class="source-code">leaving function</p>
			<p class="source-code">returned from function</p>
			<p class="source-code">In the main script after function is executed value is: Global variable</p>
			<p class="source-code">script end</p>
			<p>This is particularly useful when we're dealing with a lot of code blocks, functions, and conditional statements. The rough idea here is that we can use <strong class="source-inline">echo</strong> to announce entering and leaving each code block so that we can see if our script ran correctly. </p>
			<p>Another thing we are going to do is to print the values of variables during the script execution. While doing <a id="_idIndexMarker1056"/>this, we suggest you always mention <a id="_idIndexMarker1057"/>the place this particular command is printing variables from in the code of the script. When debugging this way, the values of the variables are going to be printed to the output in the order they are assigned, helping us follow the flow of the script. Our previous example already does that.</p>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor354"/>How to do it…</h2>
			<p>There is one more thing you can do to make your scripts provide more information when you are debugging them. There is a command built into bash called <strong class="source-inline">trap</strong>. The main reason it is there is to help you react to interrupts and to ensure that your script works even if something unexpected happens. The syntax it uses is simple – we need to tell it what to do and under what circumstances to do it. By circumstances, we mean any interrupt signal possible under Linux. The most common ones are <strong class="source-inline">SIGHUP</strong>, <strong class="source-inline">SIGKILL</strong>, and <strong class="source-inline">SIGQUIT</strong>, but a lot of others are used.</p>
			<p>For example, we can create a script like this: </p>
			<div>
				<div id="_idContainer262" class="IMG---Figure">
					<img src="Images/Figure_15.15_B16269.jpg" alt="Figure 15.15 – Using trap inside the script to stop Ctrl + C&#13;&#10;" width="1166" height="890"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.15 – Using trap inside the script to stop Ctrl + C</p>
			<p>What this first line does is that it establishes something considered to be an interrupt routine. If at any <a id="_idIndexMarker1058"/>point in our script someone uses <em class="italic">Ctrl + C</em> to <a id="_idIndexMarker1059"/>interrupt it, our script will detect that and execute two commands inside quotes:</p>
			<p class="source-code">demo@ubuntu:~/Desktop/allscripts$ bash echoline.sh </p>
			<p class="source-code">Can you please input a word?: dsasd^CScript was interrupted</p>
			<p class="source-code">demo@ubuntu:~/Desktop/allscripts$ bash echoline.sh </p>
			<p class="source-code">Can you please input a word?: nointerrupt</p>
			<p class="source-code">I got: nointerrupt</p>
			<p class="source-code">Script cleanly finished executing</p>
			<p>When we first tried, we pressed the interrupt key and our <em class="italic">routine</em> did what we told it to, which was to exit the script right away and give us a warning about it. This command can also be very useful to block attempts to stop the script since it will execute whatever we tell it to and then just continue running the script.</p>
			<p>Another thing that you can do is to use <strong class="source-inline">EXIT</strong> as the keyword in the <strong class="source-inline">trap</strong> command like this: </p>
			<p class="source-code">trap "some command" EXIT</p>
			<p>This keyword covers any possible way to exit from a script, meaning that this <strong class="source-inline">trap</strong> is going to be <a id="_idIndexMarker1060"/>executed no matter what happens to the <a id="_idIndexMarker1061"/>script, and it will run right before the control returns to whatever process ran our script.</p>
			<p>When used this way, <strong class="source-inline">trap</strong> is useful not only for debugging but also for cleaning up after your script, since it will run as the last command, enabling you to do whatever needs to be done to close the files and clean things up after your script.</p>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor355"/>How it works…</h2>
			<p>No matter which way you choose to debug your scripts, it all boils down to heavily modifying it. Using <strong class="source-inline">echo</strong> is useful but at the same time requires adding a lot of commands to the script we are debugging. Having said that, this is probably going to be the first thing you will try when debugging any script since it enables you not only to understand how the values inside the scripts change but also how the entire script works because you have the exact information of where your command is executed from, enabling you to understand both the variables and the workflow of the script. </p>
			<p>Using <strong class="source-inline">trap</strong> is a slightly more nuanced way of debugging and can be very useful to gain knowledge of what is happening when we go outside of the program flow we imagined. If a script breaks or gets interrupted in any other way, <strong class="source-inline">trap</strong> will give you information on what happened and where.</p>
			<p>There isn't a particular way of debugging to recommend here as all of them work in a particular scenario. What we can say is that you should try using all of them and see which fits a particular scenario.</p>
			<h2 id="_idParaDest-349"><a id="_idTextAnchor356"/>See also</h2>
			<ul>
				<li><a href="https://www.linuxjournal.com/content/bash-trap-command">https://www.linuxjournal.com/content/bash-trap-command</a></li>
				<li><a href="https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_02.html">https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_02.html</a></li>
			</ul>
			<h1 id="_idParaDest-350"><a id="_idTextAnchor357"/>Using the bash -x and -v options</h1>
			<p>Up to this point, we have tried debugging using different methods that involved commands inserted into <a id="_idIndexMarker1062"/>our scripts. Regardless of the command we used, this <a id="_idIndexMarker1063"/>approach has one drawback – whatever we do, using commands inside the script is either very localized to a particular part of a given script or too global since it has to cover a good chunk of code. We are not saying that this is not a valid way of solving problems in scripts, but we still need more ways to debug. </p>
			<h2 id="_idParaDest-351"><a id="_idTextAnchor358"/>Getting ready</h2>
			<p>The only thing we need to know before we start using this is that we will be running scripts by invoking them as parameters of the interpreter, so something like this:</p>
			<p class="source-code">bash -options &lt;scriptname&gt;</p>
			<p>This is important since we can not use any of these options if we invoke scripts in any other way.</p>
			<h2 id="_idParaDest-352"><a id="_idTextAnchor359"/>How to do it…</h2>
			<p>Bash is in this respect pretty complicated since it offers little, in fact almost nothing, in terms of support for any reasonable systematic debugging, and we have already mentioned that. There is a glimmer of hope, however, and that comes in the form of two switches, <strong class="source-inline">-x</strong> and <strong class="source-inline">-v</strong>. The first one turns on the printing of every command that is run in the script and it also prints all the command arguments used. This makes understanding the workflow of commands easy.</p>
			<p>Using <strong class="source-inline">-v</strong> is arguably less useful. It simply prints all the script lines as they are read. </p>
			<p>In order to understand these options, we are going to create a small example using one of the scripts we used in <a id="_idIndexMarker1064"/>a different recipe, but this time we are going to use different <a id="_idIndexMarker1065"/>switches when running it.</p>
			<p>First, we are going to use <strong class="source-inline">-v</strong>:</p>
			<p class="source-code">demo@ubuntu:~/Desktop/allscripts$ bash -v testif3.sh </p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># testing premissions and paths </p>
			<p class="source-code">if [ -d root ]</p>
			<p class="source-code">               then</p>
			<p class="source-code">                     echo root directory exists!</p>
			<p class="source-code">                     if [ -r root ]</p>
			<p class="source-code">                                   then</p>
			<p class="source-code">                       echo Script can read from the directory!</p>
			<p class="source-code">                                   else</p>
			<p class="source-code">                   echo Script can NOT read from the directory!    </p>
			<p class="source-code">                          fi</p>
			<p class="source-code">                          if [ -w root ]</p>
			<p class="source-code">                          then</p>
			<p class="source-code">                       echo Script can write to the directory!</p>
			<p class="source-code">                          else</p>
			<p class="source-code">                                       echo Script can not write to the directory!    </p>
			<p class="source-code">                          fi</p>
			<p class="source-code">                   else </p>
			<p class="source-code">                          echo root directory does NOT exists!</p>
			<p class="source-code">fi          </p>
			<p class="source-code">root directory exists!</p>
			<p class="source-code">Script can read from the directory!</p>
			<p class="source-code">Script can write to the directory!</p>
			<p>Now, we are going to use <strong class="source-inline">-x</strong> to run the script: </p>
			<p class="source-code">demo@ubuntu:~/Desktop/allscripts$ bash -x testif3.sh </p>
			<p class="source-code">+ '[' -d root ']'</p>
			<p class="source-code">+ echo root directory 'exists!'</p>
			<p class="source-code">root directory exists!</p>
			<p class="source-code">+ '[' -r root ']'</p>
			<p class="source-code">+ echo Script can read from the 'directory!'</p>
			<p class="source-code">Script can read from the directory!</p>
			<p class="source-code">+ '[' -w root ']'</p>
			<p class="source-code">+ echo Script can write to the 'directory!'</p>
			<p class="source-code">Script can write to the directory!</p>
			<p>Both switches have their <a id="_idIndexMarker1066"/>place in debugging. When we said that <strong class="source-inline">-v</strong> is less useful <a id="_idIndexMarker1067"/>than <strong class="source-inline">-x</strong>, we meant that it only gives us an insight into how Bash interpreted your script, but nothing more than that.</p>
			<p>Using <strong class="source-inline">-x</strong> shows us how Bash executed the script and what commands it ran during the execution. What you must understand is that this is not going to be the list of all commands in the script but only those that actually ran. If a particular part of the script was not used, for example, if it belonged to a block of commands that are in the code only for a specific condition, this way of running a script will not show that.</p>
			<h2 id="_idParaDest-353"><a id="_idTextAnchor360"/>How it works…</h2>
			<p>The most common thing is using both switches together, since it enables us to quickly understand what the script looks like and what Bash does when executing it. In a large script, this is going to generate a lot of output, but this is usually what we actually want to do. Then, we can go through the script step by step and understand the logic it implements.</p>
			<p>On the other hand, we cannot consider this as a universal solution to anything. Although it gives us a lot of information <a id="_idIndexMarker1068"/>about the command it runs, it is very limited by what the <a id="_idIndexMarker1069"/>variable values are and what is actually going on when processing data. Take, for example, this loop included in the file <strong class="source-inline">forloop1.sh</strong>, available as part of the files included with the book:</p>
			<p class="source-code">demo@ubuntu:~/Desktop/allscripts$ bash -x forloop1.sh </p>
			<p class="source-code">+ for name in {user1,user2,user3,user4}</p>
			<p class="source-code">+ for server in {srv1,srv2,srv3,srv4}</p>
			<p class="source-code">+ echo 'Trying to ssh user1@srv1'</p>
			<p class="source-code">Trying to ssh user1@srv1</p>
			<p class="source-code">+ for server in {srv1,srv2,srv3,srv4}</p>
			<p class="source-code">+ echo 'Trying to ssh user1@srv2'</p>
			<p class="source-code">Trying to ssh user1@srv2</p>
			<p class="source-code">+ for server in {srv1,srv2,srv3,srv4}</p>
			<p class="source-code">+ echo 'Trying to ssh user1@srv3'</p>
			<p class="source-code">Trying to ssh user1@srv3</p>
			<p class="source-code">+ for server in {srv1,srv2,srv3,srv4}</p>
			<p class="source-code">+ echo 'Trying to ssh user1@srv4'</p>
			<p>We are not going to copy the entire output since it has no other useful information. Here, we can see that we are looping in a <strong class="source-inline">for</strong> loop, and we can see possible values but the actual value of a particular variable is not seen unless we print it. This means that we will have to combine this way of debugging with the other ways we presented in this chapter.</p>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor361"/>See also…</h2>
			<ul>
				<li><a href="https://linux.die.net/man/1/bash">https://linux.die.net/man/1/bash</a></li>
				<li><a href="https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html">https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html</a></li>
			</ul>
			<h1 id="_idParaDest-355"><a id="_idTextAnchor362"/>Using set to debug a part of the script</h1>
			<p>In the previous recipe, we dealt with globally using two options to tell Bash to include a lot of useful <a id="_idIndexMarker1070"/>information in its output. We mentioned that this <a id="_idIndexMarker1071"/>offers another way to deal with debugging and troubleshooting how your scripts work. At the same time, we mentioned that this approach is in stark contrast with using commands in the script itself since we can deal with things globally without too many changes to the scripts when debugging.</p>
			<p>In this recipe, we are going to cover another way to debug, one that shares a lot of similarities with the ones we introduced before, while also being different.</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor363"/>Getting ready</h2>
			<p>One very interesting built-in command in Bash is <strong class="source-inline">set</strong>. What it does is give us the ability to change the options Bash uses. A lot of things can be changed by using <strong class="source-inline">set</strong>, and by a lot we mean almost every option Bash has. In this recipe, we are using only two of them, but you can turn all of them on or off.</p>
			<p><strong class="source-inline">set</strong> enables us to set a particular option on in just a small block of code, instead of using it globally. You also need to know that <strong class="source-inline">set</strong> can turn an option both on and off. If we use <strong class="source-inline">set</strong> with a <strong class="source-inline">–</strong> sign, we turn the option on. For example, we could use this:</p>
			<p class="source-code">set -x </p>
			<p>This is telling Bash to start showing us commands as they are executed.</p>
			<p>A slightly confusing way is if we turn off any option that is currently used. To do that, we have to use the <strong class="source-inline">+</strong> sign, something that is a little bit counterintuitive since <em class="italic">adding</em> is usually used to turn something on, not off. For example, look at this command: </p>
			<p class="source-code">set +x </p>
			<p>This will turn off the output of commands in Bash. </p>
			<p>We are going to see a couple of examples of this just to make you comfortable.</p>
			<h2 id="_idParaDest-357"><a id="_idTextAnchor364"/>How to do it…</h2>
			<p>Using <strong class="source-inline">set</strong> is simple. In any script we wish to debug, we are going to insert the <strong class="source-inline">set</strong> statement right before <a id="_idIndexMarker1072"/>the place we are starting our trace from. After <a id="_idIndexMarker1073"/>we no longer need to trace our script, we simply unset the option and we are done. We can do this as many times as we need to.</p>
			<p>Here's an example:</p>
			<div>
				<div id="_idContainer263" class="IMG---Figure">
					<img src="Images/Figure_15.16_B16269.jpg" alt="Figure 15.16 – How to set and unset options while running the script&#13;&#10;" width="1170" height="889"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.16 – How to set and unset options while running the script</p>
			<p>In this example, we are starting our trace just before we do the test of our variable. This means that we <a id="_idIndexMarker1074"/>are going to start tracing right before we do a <a id="_idIndexMarker1075"/>test and stop tracing right before we continue the loop. The result is this: </p>
			<p class="source-code">demo@ubuntu:~/Desktop/allscripts$ bash forbreak.sh </p>
			<p class="source-code">running command1, number is 1</p>
			<p class="source-code">running command2, number is 1</p>
			<p class="source-code">+ '[' 1 -eq 4 ']'</p>
			<p class="source-code">+ set +xv</p>
			<p class="source-code">running command3, number is 1</p>
			<p class="source-code">running command1, number is 2</p>
			<p class="source-code">running command2, number is 2</p>
			<p class="source-code">+ '[' 2 -eq 4 ']'</p>
			<p class="source-code">+ set +xv</p>
			<p class="source-code">running command3, number is 2</p>
			<p class="source-code">running command1, number is 3</p>
			<p class="source-code">running command2, number is 3</p>
			<p class="source-code">+ '[' 3 -eq 4 ']'</p>
			<p class="source-code">+ set +xv</p>
			<p class="source-code">running command3, number is 3</p>
			<p class="source-code">running command1, number is 4</p>
			<p class="source-code">running command2, number is 4</p>
			<p class="source-code">+ '[' 4 -eq 4 ']'</p>
			<p class="source-code">+ echo breaking out of loop, number is 4</p>
			<p class="source-code">breaking out of loop, number is 4</p>
			<p class="source-code">+ break</p>
			<p>We can even consider this way of debugging as a special case of using options globally. We are basically doing the same thing as in previous examples where we used <strong class="source-inline">set</strong> globally, but this time we are limiting the scope to make the output more readable. Sometimes that can make working a lot easier since we are not creating much irrelevant output.</p>
			<h2 id="_idParaDest-358"><a id="_idTextAnchor365"/>How it works…</h2>
			<p>The <strong class="source-inline">set</strong> command can be used for one more thing, and that is to force Bash to do some things differently than are usually done. For example, we can make scripts fail if any command <a id="_idIndexMarker1076"/>inside them fails, we can make scripts fail if they reference <a id="_idIndexMarker1077"/>a value of a variable that is not set, or we can even change the way Bash expands characters in the command line.</p>
			<p>All these things can be useful when working but at the same time, can be a little too much to grasp all at once when you first begin scripting, so we decided to not include them in these recipes.</p>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor366"/>See also…</h2>
			<ul>
				<li><a href="https://linuxhint.com/debug-bash-script/">https://linuxhint.com/debug-bash-script/</a></li>
				<li><a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html">https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html</a></li>
			</ul>
		</div>
	</div></body></html>