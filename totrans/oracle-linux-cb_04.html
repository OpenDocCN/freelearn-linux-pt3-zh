<html><head></head><body>
<div id="_idContainer115">
<h1 class="chapter-number" id="_idParaDest-90"><a id="_idTextAnchor104"/><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-91"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.2.1">Creating and Managing Single-Instance Filesystems</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Without data, there is no reason for a system to exist, and with that thought, the data has to live somewhere. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will cover the two most popular filesystems used to manage </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.4.1">data that is local to the server: </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">B-Tree File System</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.7.1">Btrfs</span></strong><span class="koboSpan" id="kobo.8.1">, pronounced </span><em class="italic"><span class="koboSpan" id="kobo.9.1">Butter F S</span></em><span class="koboSpan" id="kobo.10.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">eXtended File System</span></strong><span class="koboSpan" id="kobo.12.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.13.1">XFS</span></strong><span class="koboSpan" id="kobo.14.1">, pronounced </span><em class="italic"><span class="koboSpan" id="kobo.15.1">X </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.16.1">F S</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">These are </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.19.1">single-instance filesystems, which are basically filesystems that are only mounted on a single server at any one time. </span><span class="koboSpan" id="kobo.19.2">There are also multi-instance filesystems that are mounted on multiple systems at the same time. </span><span class="koboSpan" id="kobo.19.3">Common </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.20.1">examples are </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">Oracle Clustered File System version 2</span></strong><span class="koboSpan" id="kobo.22.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.23.1">OCFS2</span></strong><span class="koboSpan" id="kobo.24.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.25.1">Global File System 2</span></strong><span class="koboSpan" id="kobo.26.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.27.1">GFS2</span></strong><span class="koboSpan" id="kobo.28.1">). </span><span class="koboSpan" id="kobo.28.2">All of these </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.29.1">examples use shared block storage for the </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">underlying storage.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">Additionally, there is </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">Ceph</span></strong><span class="koboSpan" id="kobo.33.1">, which is </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.34.1">not an acronym, but instead a reference to </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">cephalopod</span></strong><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">This is </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.37.1">because Ceph is a distributed architecture that stores data on all nodes of a Ceph cluster. </span><span class="koboSpan" id="kobo.37.2">This allows Ceph to offer scalable storage with some </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.38.1">additional complexity. </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">Gluster</span></strong><span class="koboSpan" id="kobo.40.1"> is another example of a </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">distributed filesystem.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.42.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.43.1">Why not </span><strong class="bold"><span class="koboSpan" id="kobo.44.1">ZFS</span></strong><span class="koboSpan" id="kobo.45.1">? </span><span class="koboSpan" id="kobo.45.2">Because Btrfs </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.46.1">and XFS are built into the Oracle Linux </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">Unbreakable Enterprise Kernel</span></strong><span class="koboSpan" id="kobo.48.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.49.1">UEK</span></strong><span class="koboSpan" id="kobo.50.1">), and ZFS is not available outside of </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">third-party repositories.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">We will cover the following recipes that will help you understand and manage </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">local filesystems:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.54.1">What you need to know about </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">local filesystems</span></span></li>
<li><span class="koboSpan" id="kobo.56.1">Btrfs – creating, resizing, </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">and mon</span><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.58.1">itoring</span></span></li>
<li><span class="koboSpan" id="kobo.59.1">Btrfs – subvolumes, snapshots, quotas, </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">a</span><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.61.1">nd more</span></span></li>
<li><span class="koboSpan" id="kobo.62.1">Protecting data with mdadm – a software </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">RAID s</span><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.64.1">olution</span></span></li>
<li><span class="koboSpan" id="kobo.65.1">Playing with logical </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">volume management</span></span></li>
<li><span class="koboSpan" id="kobo.67.1">XFS – creating, modifying, </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">and more</span></span></li>
</ul>
<h1 id="_idParaDest-92"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.69.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.70.1">For this recipe, you will </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.71.1">need an </span><strong class="bold"><span class="koboSpan" id="kobo.72.1">Oracle Linux 8</span></strong><span class="koboSpan" id="kobo.73.1"> system. </span><span class="koboSpan" id="kobo.73.2">As with most of these recipes, a VM on your desktop using a desktop virtualization product </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.74.1">such as </span><strong class="bold"><span class="koboSpan" id="kobo.75.1">Oracle VirtualBox</span></strong><span class="koboSpan" id="kobo.76.1"> is recommended. </span><span class="koboSpan" id="kobo.76.2">A small VM with two cores, 2 GB RAM, and a few free gigabytes of disk space is fine. </span><span class="koboSpan" id="kobo.76.3">You will also need some additional disks assigned to the VM, ideally at least five equally sized disks. </span><span class="koboSpan" id="kobo.76.4">Ideally, before you start, patch your system to the latest packages available. </span><span class="koboSpan" id="kobo.76.5">This only takes a few minutes and can save a ton of time when troubleshooting issues caused by </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">a bug.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">Many of the recipes in this book have their related configuration files available on GitHub, located </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">at </span></span><a href="https://github.com/PacktPublishing/Oracle-Linux-Cookbook"><span class="No-Break"><span class="koboSpan" id="kobo.80.1">https://github.com/PacktPublishing/Oracle-Linux-Cookbook</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.81.1">.</span></span></p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.82.1">What you need to know about local filesystems</span></h1>
<p><span class="koboSpan" id="kobo.83.1">This recipe will discuss the differences between local and remote filesystems, as well as the core </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.84.1">differences between Btrfs </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">and ZFS.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">The backbone of an </span><strong class="bold"><span class="koboSpan" id="kobo.87.1">operating system</span></strong><span class="koboSpan" id="kobo.88.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.89.1">OS</span></strong><span class="koboSpan" id="kobo.90.1">) is the local filesystem. </span><span class="koboSpan" id="kobo.90.2">It enables efficient storage and management of files and directories on a computer or server using a hierarchical structure. </span><span class="koboSpan" id="kobo.90.3">This structure allows users and programs to easily create, modify, and access </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.91.1">files on local storage devices such as hard disks, solid-state </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.92.1">drives, and storage </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">logical unit numbers</span></strong><span class="koboSpan" id="kobo.94.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.95.1">LUNs</span></strong><span class="koboSpan" id="kobo.96.1">) from a local </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">storage area network</span></strong><span class="koboSpan" id="kobo.98.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.99.1">SAN</span></strong><span class="koboSpan" id="kobo.100.1">) or cloud provider. </span><span class="koboSpan" id="kobo.100.2">These filesystems are designed specifically for file and folder management efficiency, protecting files from accidental deletion or corruption. </span><span class="koboSpan" id="kobo.100.3">They come equipped with features such as file permissions, ownership, and access control, which provide users with utmost security and privacy. </span><span class="koboSpan" id="kobo.100.4">In comparison to remote filesystems, local filesystems offer superior performance, though files are not available on other systems unless paired with a remote filesystem technology. </span><span class="koboSpan" id="kobo.100.5">Notable examples of local Linux filesystems include Btrfs, XFS, ext4, fat32, and </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">even ZFS.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.102.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.103.1">While ZFS is a local filesystem, it is not included in the kernel and needs to be added using software </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">from </span></span><a href="https://zfsonlinux.org"><span class="No-Break"><span class="koboSpan" id="kobo.105.1">https://zfsonlinux.org</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.106.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">A remote filesystem allows you to access files and directories on a remote server through a network. </span><span class="koboSpan" id="kobo.107.2">This system provides the convenience of accessing and manipulating files on a remote </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.108.1">machine as if they were stored locally, eliminating the need to transfer them physically. </span><span class="koboSpan" id="kobo.108.2">Remote filesystems are widely used in distributed computing environments where multiple computers or servers need to share data and resources. </span><span class="koboSpan" id="kobo.108.3">They are also valuable in cloud computing and web hosting environments where data is stored remotely and accessed over the internet. </span><span class="koboSpan" id="kobo.108.4">However, it’s important to note that using remote filesystems can impact performance when sharing files between multiple servers over </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">a network.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">Examples of </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.111.1">remote filesystems include </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">Network File System</span></strong><span class="koboSpan" id="kobo.113.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.114.1">NFS</span></strong><span class="koboSpan" id="kobo.115.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">Server Message Block</span></strong><span class="koboSpan" id="kobo.117.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.118.1">SMB</span></strong><span class="koboSpan" id="kobo.119.1">), and </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">Common Internet File System</span></strong><span class="koboSpan" id="kobo.121.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.122.1">CIFS</span></strong><span class="koboSpan" id="kobo.123.1">), which </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.124.1">are widely used in Unix, Linux, and </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.125.1">Windows environments, respectively. </span><span class="koboSpan" id="kobo.125.2">Other popular remote filesystems include </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">s3fs</span></strong><span class="koboSpan" id="kobo.127.1">, which allows users to access files securely over cloud-based </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">object storage.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">For optimal performance when managing MySQL, Postgres, and Oracle databases, it’s highly recommended to utilize local filesystems instead of network filesystems. </span><span class="koboSpan" id="kobo.129.2">This strategy can also be effectively applied to </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">the OS.</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.131.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.132.1">You need to understand the core differences between the two filesystems. </span><span class="koboSpan" id="kobo.132.2">The XFS filesystem is </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.133.1">surprisingly much older than many admins realize. </span><span class="koboSpan" id="kobo.133.2">It started back in 1993, as the filesystem for the </span><strong class="bold"><span class="koboSpan" id="kobo.134.1">Silicon Graphics IRIX</span></strong><span class="koboSpan" id="kobo.135.1"> OS, and was ported over to Linux in 2001. </span><span class="koboSpan" id="kobo.135.2">Btrfs is much newer, being developed in 2007 by Oracle (as an open source project) for Linux. </span><span class="koboSpan" id="kobo.135.3">Btrfs is also more than a filesystem, as it includes the volume manager, data redundancy, and filesystem functionality in </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">one technology.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">With XFS, you need </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.138.1">to combine it with a logical volume manager for dynamic volumes and also </span><strong class="bold"><span class="koboSpan" id="kobo.139.1">redundant array of inexpensive disks</span></strong><span class="koboSpan" id="kobo.140.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.141.1">RAID</span></strong><span class="koboSpan" id="kobo.142.1">) technology (most commonly configured with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">mdadm</span></strong><span class="koboSpan" id="kobo.144.1"> command) to provide for </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">fault tolerance.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">With Btrfs, you have the choice of five types of RAID volumes. </span><span class="koboSpan" id="kobo.146.2">What you pick is based on your use case as it’s </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.147.1">a balance between performance, disk space required, and the usable capacity of the volume. </span><span class="koboSpan" id="kobo.147.2">The details are in the </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">following table:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-4">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.149.1">Type</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.150.1">Description</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.151.1">Performance</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.152.1">Redundance</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.153.1">Capacity</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.154.1">RAID 0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.155.1">Striping </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">across disks</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.157.1">Best</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.158.1">None</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.159.1">100%</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.160.1">RAID 1</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.161.1">Mirror </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">two disks</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.163.1">Good</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.164.1">1 </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">drive failure</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.166.1">50%</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.167.1">RAID 10</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.168.1">Mirrored then striped, min of </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">4 disks</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.170.1">Almost </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">the best</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.172.1">1 </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">drive failure</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.174.1">50%</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.175.1">RAID1C3</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.176.1">3 copies of the metadata, min of </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">3 disks</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.178.1">Average</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.179.1">2 </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">drive failures</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.181.1">66%</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.182.1">RAID1C4</span></span></p>
</td>
<td class="No-Table-Style">
<p><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.183.1">4 copies of the metadata, min of </span></span><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.184.1">4 disks</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.185.1">Lowest</span></span></p>
</td>
<td class="No-Table-Style">
<p><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.186.1">3 </span></span><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.187.1">drive failures</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.188.1">75%</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.189.1">Table 4.1 – Btrfs RAID options</span></p>
<p><span class="koboSpan" id="kobo.190.1">Both systems have the same limitation for the maximum filesystem size of 8 exabytes! </span><span class="koboSpan" id="kobo.190.2">But Btrfs also adds features such as snapshots, transparent compression, integrated checksum-based data integrity, and rollback capabilities. </span><span class="koboSpan" id="kobo.190.3">XFS is not left out though, with higher performance through I/O threads and more bandwidth, though these advantages may not be realized once you integrate XFS with an LVM and RAID technology. </span><span class="koboSpan" id="kobo.190.4">One other major difference is that Btrfs requires that you use the UEK, though XFS works well with </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.191.1">both UEKs and </span><strong class="bold"><span class="koboSpan" id="kobo.192.1">Red Hat Compatible </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.193.1">Kernels</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.194.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.195.1">RHCKs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">).</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.197.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.198.1">Oracle Linux by default uses the XFS filesystem, but when doing the installation, you can use Btrfs as the </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.199.1">root filesystem. </span><span class="koboSpan" id="kobo.199.2">If you want to use XFS as the boot filesystem, install it as you normally would. </span><span class="koboSpan" id="kobo.199.3">If you want to use Btrfs, then you </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">should continue.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.201.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.202.1">Your boot filesystem can be different from the data filesystems on the server. </span><span class="koboSpan" id="kobo.202.2">You can easily have the root use XFS and the data filesystem use Btrfs, or </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">vice versa.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">The easiest way to run Btrfs is to pick it when doing an installation using the UEK boot disk. </span><span class="koboSpan" id="kobo.204.2">This will let you choose Btrfs as the destination filesystem. </span><span class="koboSpan" id="kobo.204.3">When running the install, select </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">Install Destination</span></strong><span class="koboSpan" id="kobo.206.1">, and then select a custom storage configuration. </span><span class="koboSpan" id="kobo.206.2">This will then give you the manual partitioning option where you can use the dropdown and select </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">Btrfs</span></strong><span class="koboSpan" id="kobo.208.1">, as seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.210.1"><img alt="Figure 4.1 – Btrfs selection" src="image/B18349_04_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.211.1">Figure 4.1 – Btrfs selection</span></p>
<p><span class="koboSpan" id="kobo.212.1">When setting </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.213.1">up the custom configuration, you can add additional </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.214.1">directories for </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">/var</span></strong><span class="koboSpan" id="kobo.216.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">/var/tmp</span></strong><span class="koboSpan" id="kobo.218.1"> (a </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">secure technical implementation guide</span></strong><span class="koboSpan" id="kobo.220.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.221.1">STIG</span></strong><span class="koboSpan" id="kobo.222.1">) requirement). </span><span class="koboSpan" id="kobo.222.2">These are actually not just directories, but subvolumes of the main volume. </span><span class="koboSpan" id="kobo.222.3">This is why they show the same </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">available space:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.224.1"><img alt="Figure 4.2 – Btrfs mountpoints" src="image/B18349_04_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.225.1">Figure 4.2 – Btrfs mountpoints</span></p>
<p><span class="koboSpan" id="kobo.226.1">This is because with Btrfs, they all use the same volume and have the same usable disk space. </span><span class="koboSpan" id="kobo.226.2">We can limit this later </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">using quotas.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">Finish the install </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.229.1">using your normal settings for network and software source, though as a note, you will likely need to set </span><strong class="bold"><span class="koboSpan" id="kobo.230.1">Installation Source</span></strong><span class="koboSpan" id="kobo.231.1"> as a URL or local network share. </span><span class="koboSpan" id="kobo.231.2">You will also need to add the UEK repository if running 8.7 </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">or earlier.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">Once the system is booted, you will see that it is now using Btrfs. </span><span class="koboSpan" id="kobo.233.2">This can be checked once the system </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">is up.</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.235.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.236.1">You can check </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.237.1">the filesystem in several ways, the easiest being by checking </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">/etc/fstab</span></strong><span class="koboSpan" id="kobo.239.1"> to see how the filesystem was mounted. </span><span class="koboSpan" id="kobo.239.2">This is seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer086">
<span class="koboSpan" id="kobo.241.1"><img alt="Figure 4.3 – Btrfs fstab example" src="image/B18349_04_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.242.1">Figure 4.3 – Btrfs fstab example</span></p>
<p><span class="koboSpan" id="kobo.243.1">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">df</span></strong><span class="koboSpan" id="kobo.245.1"> command with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">T</span></strong><span class="koboSpan" id="kobo.247.1"> option to show the filesystem type. </span><span class="koboSpan" id="kobo.247.2">Running the following command will show you </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">this info:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.249.1">
df -T</span></pre> <p><span class="koboSpan" id="kobo.250.1">This will show the filesystem type for each mounted file, as seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.252.1"><img alt="Figure 4.4 – df -T with Btrfs filesystems" src="image/B18349_04_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.253.1">Figure 4.4 – df -T with Btrfs filesystems</span></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.254.1">Btrfs – creating, resizing, and monitoring</span></h1>
<p><span class="koboSpan" id="kobo.255.1">In this </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.256.1">recipe, we will create a new RAIDed Btrfs volume </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.257.1">and filesystem, using multiple disks for fault-tolerant </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.258.1">storage. </span><span class="koboSpan" id="kobo.258.2">We will then add a new LUN, growing the filesystem. </span><span class="koboSpan" id="kobo.258.3">We will wrap up by modifying the filesystem to compress </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">the data!</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.260.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.261.1">To get started, I added five 10 GB drives to the OS. </span><span class="koboSpan" id="kobo.261.2">These will be used to build a new RAID1C4 volume. </span><span class="koboSpan" id="kobo.261.3">I can see these new devices by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">fdisk -l</span></strong><span class="koboSpan" id="kobo.263.1"> command, grepping for </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">GiB</span></strong><span class="koboSpan" id="kobo.265.1"> using the </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.267.1">
fdisk -l | grep GiB</span></pre> <p><span class="koboSpan" id="kobo.268.1">The output is seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.270.1"><img alt="Figure 4.5 – fdisk output" src="image/B18349_04_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.271.1">Figure 4.5 – fdisk output</span></p>
<p><span class="koboSpan" id="kobo.272.1">Here, we can see that the 10 GB devices are </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">sdb</span></strong><span class="koboSpan" id="kobo.274.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">sdc</span></strong><span class="koboSpan" id="kobo.276.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">sbd</span></strong><span class="koboSpan" id="kobo.278.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">sbe</span></strong><span class="koboSpan" id="kobo.280.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">sbf</span></strong><span class="koboSpan" id="kobo.282.1">. </span><span class="koboSpan" id="kobo.282.2">We will need this info to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">Btrfs volume.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.284.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.285.1">Now that we know the devices, let’s manually create a RAID1C3 volume. </span><span class="koboSpan" id="kobo.285.2">We will use all five devices in a RAID1C3 configuration and name the </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">volume </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.289.1">We will then use the following command to make </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">the volume:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.291.1">
mkfs.btrfs -L data -d raid1c3 -m raid1c3 /dev/sd[bcdef]</span></pre> <p><span class="koboSpan" id="kobo.292.1">Please refer to the following figure to view </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">the output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.294.1"><img alt="Figure 4.6 – mkfs.btrfs output" src="image/B18349_04_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.295.1">Figure 4.6 – mkfs.btrfs output</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.296.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.297.1">When mounting a Btrfs volume, you normally use the first device in the volume or the UUID. </span><span class="koboSpan" id="kobo.297.2">The UUID is reported by </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">mkfs.btrfs</span></strong><span class="koboSpan" id="kobo.299.1"> when the volume </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">is created.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">Next, let’s </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.302.1">mount this in </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">/data</span></strong><span class="koboSpan" id="kobo.304.1">. </span><span class="koboSpan" id="kobo.304.2">Make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">/data</span></strong><span class="koboSpan" id="kobo.306.1"> directory, then </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.307.1">mount it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">following commands:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.309.1">
mkdir /data
mount /dev/sdb /data</span></pre> <p><span class="koboSpan" id="kobo.310.1">Optional, though </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.311.1">highly recommended, is to add this to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">fstab</span></strong><span class="koboSpan" id="kobo.313.1"> file. </span><span class="koboSpan" id="kobo.313.2">With this example, we are using the UUID of the volume, and since data has no subvolume, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">subvol</span></strong><span class="koboSpan" id="kobo.315.1"> parameter is defined but </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">left blank:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<span class="koboSpan" id="kobo.317.1"><img alt="Figure 4.7 – Sample fstab using UUID" src="image/B18349_04_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.318.1">Figure 4.7 – Sample fstab using UUID</span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.319.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.320.1">Now that </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.321.1">we have a mounted volume, let’s do a few things </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.322.1">with it! </span><span class="koboSpan" id="kobo.322.2">First, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">btrfs</span></strong><span class="koboSpan" id="kobo.324.1"> command to check several things. </span><span class="koboSpan" id="kobo.324.2">The first is to check the device’s health, which is useful </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.325.1">to see whether the RAID has any failing devices. </span><span class="koboSpan" id="kobo.325.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">btrfs stats /$DEVICE</span></strong><span class="koboSpan" id="kobo.327.1"> command is used to show the status. </span><span class="koboSpan" id="kobo.327.2">Don’t forget to replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">$DEVICE</span></strong><span class="koboSpan" id="kobo.329.1"> with the actual Btrfs device you </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">are checking:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.331.1"><img alt="Figure 4.8 – Healthy devices" src="image/B18349_04_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.332.1">Figure 4.8 – Healthy devices</span></p>
<p><span class="koboSpan" id="kobo.333.1">When a device starts to fail, you should start to see errors in </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">this report.</span></span></p>
<p><span class="koboSpan" id="kobo.335.1">Next up, we will add a few more devices to the volume. </span><span class="koboSpan" id="kobo.335.2">Four more 10 GB disks were added: </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">sdg</span></strong><span class="koboSpan" id="kobo.337.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">sdh</span></strong><span class="koboSpan" id="kobo.339.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">sdi</span></strong><span class="koboSpan" id="kobo.341.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">sdj</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">Before we </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.346.1">add the device, we can see that </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">/data</span></strong><span class="koboSpan" id="kobo.348.1"> has 50 GB of </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.349.1">usable raw space. </span><span class="koboSpan" id="kobo.349.2">This is seen using </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.350.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.352.1">
btrfs filesystem usage /data</span></pre> <p><span class="koboSpan" id="kobo.353.1">The output from the command is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.355.1"><img alt="Figure 4.9 – Btrfs filesystem usage" src="image/B18349_04_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.356.1">Figure 4.9 – Btrfs filesystem usage</span></p>
<p><span class="koboSpan" id="kobo.357.1">Here we </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.358.1">can see the stats, mainly the 50 GB of free raw space, as </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.359.1">well as the other metrics, including </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.360.1">the space allocated to each device in the volume and which devices have </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">the metadata.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">Next, let’s add the four new devices. </span><span class="koboSpan" id="kobo.362.2">This is done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">btrfs device </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">add</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.365.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.366.1">
btrfs device add /dev/sdg /data</span></pre> <p><span class="koboSpan" id="kobo.367.1">Do this for each device being added to the volume, or bulk add them with </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">/dev/sd[a-z]</span></strong><span class="koboSpan" id="kobo.369.1">, replacing </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">a</span></strong><span class="koboSpan" id="kobo.371.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">z</span></strong><span class="koboSpan" id="kobo.373.1"> with the appropriate range. </span><span class="koboSpan" id="kobo.373.2">When done, you can check using </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.374.1">the usage option, as seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">following </span></span><span class="No-Break"><a id="_idIndexMarker297"/></span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">sample:</span></span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.377.1"><img alt="Figure 4.10 – Btrfs devices added" src="image/B18349_04_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.378.1">Figure 4.10 – Btrfs devices added</span></p>
<p><span class="koboSpan" id="kobo.379.1">You will </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.380.1">now see the device at 90 GB. </span><span class="koboSpan" id="kobo.380.2">Now, as space in </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">/data</span></strong><span class="koboSpan" id="kobo.382.1"> gets consumed, you should start to see the available space go down, as well as the distribution of data against the </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">individual disks:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.384.1"><img alt="Figure 4.11 – Btrfs space used" src="image/B18349_04_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.385.1">Figure 4.11 – Btrfs space used</span></p>
<p><span class="koboSpan" id="kobo.386.1">For the </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.387.1">last example, we will be removing a device to free </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.388.1">up space, and then rebalancing the data. </span><span class="koboSpan" id="kobo.388.2">To delete </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.389.1">a physical device, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">btrfs device delete</span></strong><span class="koboSpan" id="kobo.391.1"> command, passing the </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">device mountpoint:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.393.1">
btrfs device delete /dev/sdj /data</span></pre> <p><span class="koboSpan" id="kobo.394.1">This will remove </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">the device:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<span class="koboSpan" id="kobo.396.1"><img alt="Figure 4.12 – Device removal" src="image/B18349_04_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.397.1">Figure 4.12 – Device removal</span></p>
<p><span class="koboSpan" id="kobo.398.1">Once the </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.399.1">device is removed, rerun the usage report. </span><span class="koboSpan" id="kobo.399.2">What </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.400.1">you will now see is the remaining devices, and which </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.401.1">data is on </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">which device:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<span class="koboSpan" id="kobo.403.1"><img alt="Figure 4.13 – Unbalanced usage" src="image/B18349_04_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.404.1">Figure 4.13 – Unbalanced usage</span></p>
<p><span class="koboSpan" id="kobo.405.1">While it may appear to be a minor issue, it has the potential to cause complications down the line. </span><span class="koboSpan" id="kobo.405.2">Fortunately, the solution is simple – a system rebalance. </span><span class="koboSpan" id="kobo.405.3">This is done using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">balance</span></strong><span class="koboSpan" id="kobo.407.1"> option in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">btrfs</span></strong><span class="koboSpan" id="kobo.409.1"> command. </span><span class="koboSpan" id="kobo.409.2">The following command will be used to balance the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.412.1"> filesystem:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.413.1">
btrfs filesystem balance /data</span></pre> <p><span class="koboSpan" id="kobo.414.1">This </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.415.1">command will then rebalance the data chunks, and </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.416.1">when done, the usage will show the </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.417.1">data balanced across </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">the disks:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<span class="koboSpan" id="kobo.419.1"><img alt="Figure 4.14 – Balanced usage" src="image/B18349_04_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.420.1">Figure 4.14 – Balanced usage</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.421.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.422.1">To ensure a well-balanced distribution of data, it is recommended to always balance your system when adding or removing devices, even though there may be slight variations. </span><span class="koboSpan" id="kobo.422.2">This practice is essential for maintaining an optimally performing filesystem. </span><span class="koboSpan" id="kobo.422.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">btrfsmaintenance</span></strong><span class="koboSpan" id="kobo.424.1"> package in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">ol8_developer</span></strong><span class="koboSpan" id="kobo.426.1"> repo is a great tool for automating all the required Btrfs </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">maintenance tasks.</span></span></p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.428.1">Btrfs – subvolumes, snapshots, quotas, and more</span></h1>
<p><span class="koboSpan" id="kobo.429.1">Btrfs can do so much more than the older XFS technology. </span><span class="koboSpan" id="kobo.429.2">This includes subvolumes, snapshots, and quotas. </span><span class="koboSpan" id="kobo.429.3">Btrfs subvolumes are an exceptional tool that allows users to create </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.430.1">multiple snapshots or subfilesystems within a single Btrfs filesystem. </span><span class="koboSpan" id="kobo.430.2">These subvolumes are displayed as distinct directories in the filesystem hierarchy, but they utilize the same storage space and can be </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">managed independently.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">The flexibility </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.433.1">and versatility of subvolumes make them ideal for various purposes, such as creating backups or isolating different parts of the filesystem for easier management. </span><span class="koboSpan" id="kobo.433.2">Snapshots are particularly useful since they offer read-only copies of the filesystem at a specific point in time. </span><span class="koboSpan" id="kobo.433.3">With snapshots, users can restore files or entire subvolumes to a previous state or easily create replicable backups that can be moved to </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">another system.</span></span></p>
<p><span class="koboSpan" id="kobo.435.1">Subvolumes also </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.436.1">enable users to manage disk space more efficiently. </span><span class="koboSpan" id="kobo.436.2">For example, users can create a subvolume for a specific application or project and restrict its disk usage to a certain amount to prevent it from using up too much space on the filesystem. </span><span class="koboSpan" id="kobo.436.3">Additionally, subvolumes can be used to implement access controls by assigning different permissions to different subvolumes or creating separate subvolumes for different users or groups. </span><span class="koboSpan" id="kobo.436.4">This recipe will go over how to do all </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">of this.</span></span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.438.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.439.1">This recipe will require a Btrfs filesystem, and will use the data filesystem created in the previous recipe for </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">the examples.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.441.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.442.1">In this recipe, we will do </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.444.1">Create a subvolume in </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">/data</span></strong><span class="koboSpan" id="kobo.446.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">mount it.</span></span></li>
<li><span class="koboSpan" id="kobo.448.1">Set a quota on </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">the subvolume.</span></span></li>
<li><span class="koboSpan" id="kobo.450.1">Create </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">a snapshot.</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.452.1">Enable compression.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.453.1">Creating a </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.454.1">subvolume is straightforward and is done by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">btrfs</span></strong><span class="koboSpan" id="kobo.456.1"> command </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.457.1">and specifying the full path to </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">the subvolume:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.459.1">
btrfs subvolume create /data/vol1</span></pre> <p><span class="koboSpan" id="kobo.460.1">Once created, simply </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.461.1">add it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">fstab</span></strong><span class="koboSpan" id="kobo.463.1">, this time declaring the subvolume name in the fourth column. </span><span class="koboSpan" id="kobo.463.2">This is seen in the following screenshot, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">/data/vol1</span></strong><span class="koboSpan" id="kobo.465.1"> is mounted using </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">subvolume </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">vol1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<span class="koboSpan" id="kobo.469.1"><img alt="Figure 4.15 – Subvolume in fstab" src="image/B18349_04_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.470.1">Figure 4.15 – Subvolume in fstab</span></p>
<p><span class="koboSpan" id="kobo.471.1">Now that we have the subvolume mounted, let’s add a quota to limit it to 5 GB. </span><span class="koboSpan" id="kobo.471.2">To do this, we first need to enable quotas for the volume. </span><span class="koboSpan" id="kobo.471.3">This is done with the </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.473.1">
btrfs quota enable /data</span></pre> <p><span class="koboSpan" id="kobo.474.1">Next, we need to assign a quota-group limit to the subvolume. </span><span class="koboSpan" id="kobo.474.2">This will restrict the subvolume to the size defined. </span><span class="koboSpan" id="kobo.474.3">This is done using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">limit</span></strong><span class="koboSpan" id="kobo.476.1"> option, as seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.478.1">
btrfs qgroup limit 5g /data/vol1</span></pre> <p><span class="koboSpan" id="kobo.479.1">You can see </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.480.1">what quotas are defined in a volume using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">btrfs qgroup show</span></strong><span class="koboSpan" id="kobo.482.1"> command with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">-</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">reF</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.485.1"> option:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.486.1">
btrfs qgroup show -reF /data/vol1</span></pre> <p><span class="koboSpan" id="kobo.487.1">The command </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.488.1">and its output are shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<span class="koboSpan" id="kobo.490.1"><img alt="Figure 4.16 – Set quotas" src="image/B18349_04_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.491.1">Figure 4.16 – Set quotas</span></p>
<p><span class="koboSpan" id="kobo.492.1">Now that we </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.493.1">have a quota set, let’s create a snapshot for backups. </span><span class="koboSpan" id="kobo.493.2">We do need a place for the backups, so let’s create a subvolume for the backups with the </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.495.1">
btrfs subvolume create /data/backup</span></pre> <p><span class="koboSpan" id="kobo.496.1">Btrfs snapshots are highly useful copies of a Btrfs filesystem, capturing a specific point in time. </span><span class="koboSpan" id="kobo.496.2">Through a seamless copy-on-write process, these snapshots separate any changes made to the filesystem from the snapshot itself. </span><span class="koboSpan" id="kobo.496.3">This makes them ideal for different purposes, such as creating backups, testing software configurations, and providing an effortless way to undo system updates. </span><span class="koboSpan" id="kobo.496.4">Additionally, backups can be created rapidly and with minimal storage space, as the snapshots only store the differences between the current state of the filesystem and the state at the moment the snapshot was taken. </span><span class="koboSpan" id="kobo.496.5">To create a Btrfs snapshot, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">btrfs subvolume snapshot</span></strong><span class="koboSpan" id="kobo.498.1"> command, specifying the subvolume you want to snapshot and the name and location of </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">the snapshot:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.500.1">
btrfs subvolume snapshot /data/vol1 /data/backup/vol1_backup1</span></pre> <p><span class="koboSpan" id="kobo.501.1">This command creates a read-only snapshot of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">/data/vol1</span></strong><span class="koboSpan" id="kobo.503.1"> subvolume and saves it as a separate subvolume in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">data/backup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.506.1"> directory.</span></span></p>
<p><span class="koboSpan" id="kobo.507.1">Don’t worry if you’ve already taken a snapshot – you can easily revert the filesystem to its exact state at that time using the powerful Btrfs rollback feature. </span><span class="koboSpan" id="kobo.507.2">With Btrfs snapshot rollback, you can restore your Btrfs filesystem to a previous state by simply selecting a snapshot. </span><span class="koboSpan" id="kobo.507.3">Rolling back to a snapshot discards all changes made to the filesystem since the snapshot was taken and restores the filesystem to the exact state it was in when the snapshot </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">was created.</span></span></p>
<p><span class="koboSpan" id="kobo.509.1">To roll back </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.510.1">a Btrfs snapshot, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">btrfs subvolume snapshot</span></strong><span class="koboSpan" id="kobo.512.1"> command with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">-r</span></strong><span class="koboSpan" id="kobo.514.1"> option, which specifies that the snapshot </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.515.1">should be used for </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">a rollback:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.517.1">
btrfs subvolume snapshot -r /data/backups/vol1_backup1 /data/vol1</span></pre> <p><span class="koboSpan" id="kobo.518.1">This command </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.519.1">rolls back </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">/data/vol1</span></strong><span class="koboSpan" id="kobo.521.1"> to the state it was in when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">/data/backup/vol1_backlup1</span></strong><span class="koboSpan" id="kobo.523.1"> snapshot </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">was created.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">It is important to note that rolling back a snapshot will discard any changes made to the filesystem since the snapshot was taken. </span><span class="koboSpan" id="kobo.525.2">However, this feature is extremely useful when you want to fully revert the filesystem to a previous state. </span><span class="koboSpan" id="kobo.525.3">Btrfs snapshots provide a simple and effective solution for data management and protection, allowing for effortless backup creation and easy restoration of prior </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">filesystem versions.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.527.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.528.1">Automatic snapshots can be enabled so a </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">dnf</span></strong><span class="koboSpan" id="kobo.530.1"> transaction will create a snapshot. </span><span class="koboSpan" id="kobo.530.2">This is done by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">dnf-plugin-snapper</span></strong><span class="koboSpan" id="kobo.532.1"> tool. </span><span class="koboSpan" id="kobo.532.2">More information can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">here: </span></span><a href="https://docs.oracle.com/en/operating-systems/oracle-linux/8/fsadmin/fsadmin-ManagingtheBtrfsFileSystem.html#snapper-btrfs"><span class="No-Break"><span class="koboSpan" id="kobo.534.1">https://docs.oracle.com/en/operating-systems/oracle-linux/8/fsadmin/fsadmin-ManagingtheBtrfsFileSystem.html#snapper-btrfs</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.535.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">This section will cover how to enable compression using the Btrfs filesystem. </span><span class="koboSpan" id="kobo.536.2">Btrfs compression is a powerful feature that allows you to compress data in real time while writing it to the filesystem. </span><span class="koboSpan" id="kobo.536.3">This feature can significantly reduce storage space, making it ideal for filesystems that store vast amounts of data, such as media archives and backup systems. </span><span class="koboSpan" id="kobo.536.4">Additionally, it’s beneficial for systems with limited storage space, such as mobile devices and </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">embedded systems.</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">Btrfs compression uses various compression algorithms to compress data while writing it to the filesystem. </span><span class="koboSpan" id="kobo.538.2">The compressed data is then stored on the disk and automatically decompressed on the fly when accessed. </span><span class="koboSpan" id="kobo.538.3">This process is seamless to the applications accessing the data, so there’s no need for them to be aware of the compression process as Btrfs handles it. </span><span class="koboSpan" id="kobo.538.4">Btrfs supports three compression algorithms, </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">zlib</span></strong><span class="koboSpan" id="kobo.540.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">lzo</span></strong><span class="koboSpan" id="kobo.542.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">zstd</span></strong><span class="koboSpan" id="kobo.544.1">, each with its own strengths </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">and weaknesses:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">zlib</span></strong><span class="koboSpan" id="kobo.547.1">: This is a </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.548.1">widely used general-purpose compression algorithm that provides good compression ratios but can be relatively slow, especially at higher compression levels. </span><span class="koboSpan" id="kobo.548.2">It is suitable for compressing general-purpose data and </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">text files.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">lzo</span></strong><span class="koboSpan" id="kobo.551.1">: This is a </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.552.1">lightweight compression algorithm that provides good compression ratios and is relatively fast. </span><span class="koboSpan" id="kobo.552.2">It is suitable for compressing data that is already compressed, such as media files </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">and archives.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">zstd</span></strong><span class="koboSpan" id="kobo.555.1">: This is a </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.556.1">newer compression algorithm that provides a good balance between compression ratio and speed. </span><span class="koboSpan" id="kobo.556.2">It is suitable for compressing a wide range of data types, including text, media files, </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">and archives.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.558.1">The choice </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.559.1">of compression algorithm depends on the specific use case </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.560.1">and </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">performance requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">To enable </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.563.1">compression on a filesystem, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">btrfs property</span></strong><span class="koboSpan" id="kobo.565.1"> command to set the compression for </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">the filesystem:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.567.1">
btrfs property set /data/vol1 compression zstd</span></pre> <p><span class="koboSpan" id="kobo.568.1">When compression is enabled, only new data being written to the filesystem is compressed. </span><span class="koboSpan" id="kobo.568.2">However, you can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">defragment</span></strong><span class="koboSpan" id="kobo.570.1"> command to compress the data that was on the filesystem before compression was enabled. </span><span class="koboSpan" id="kobo.570.2">To do this on a subvolume, you will also need to recursively run the command using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">-r</span></strong><span class="koboSpan" id="kobo.572.1"> option along with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">-c</span></strong><span class="koboSpan" id="kobo.574.1"> option to </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">compress data:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.576.1">
btrfs filesystem defragment -rc /data/vol1</span></pre> <h2 id="_idParaDest-104"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.577.1">There’s more…</span></h2>
<p><span class="koboSpan" id="kobo.578.1">Compression efficiency will vary, depending on the data and algorithm used. </span><span class="koboSpan" id="kobo.578.2">Let’s first check how much space we have, using the </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.580.1">
[root@btrfs vol1]# btrfs filesystem usage /data/vol1 | grep Data | grep Used
Data,RAID1C3: Size:1.00GiB, Used:0.00B (0.00%)</span></pre> <p><span class="koboSpan" id="kobo.581.1">Now, let’s create a 2 GB file with </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">random data:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.583.1">
head -c 2G &lt;/dev/urandom &gt; /data/vol1/test1</span></pre> <p><span class="koboSpan" id="kobo.584.1">Next, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">df</span></strong><span class="koboSpan" id="kobo.586.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">du</span></strong><span class="koboSpan" id="kobo.588.1"> commands to compare the space consumed and the </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">space used:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.590.1">
df -h /data/vol1
du -hd0 /data/vol</span></pre> <p><span class="koboSpan" id="kobo.591.1">The sample </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.592.1">outputs for these commands are </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.594.1">
[root@btrfs vol1]# df -h /data/vol1
Filesystem      Size  Used Avail Use% Mounted on
/dev/sdb         30G  2G   28G   1% /data/vol1
[root@brtfs vol1]# du -hd0 /data/vol1
2.0G    /data/vol1
[root@brtfs vol1]#</span></pre> <p><span class="koboSpan" id="kobo.595.1">Here, we can </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.596.1">see 2 GB is used (via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">du</span></strong><span class="koboSpan" id="kobo.598.1"> command), and also 2 GB (via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">df</span></strong><span class="koboSpan" id="kobo.600.1"> command) is actually consumed. </span><span class="koboSpan" id="kobo.600.2">So, for this random data file, we can see no benefit </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.601.1">from </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">the compression.</span></span></p>
<p><span class="koboSpan" id="kobo.603.1">Let’s delete the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">test1</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.605.1">file now:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.606.1">
rm /data/vol1/test1</span></pre> <p><span class="koboSpan" id="kobo.607.1">To speed things up, let’s defrag and rebalance the volume. </span><span class="koboSpan" id="kobo.607.2">This is needed to actually free up the space from the deleted file now, instead </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">of waiting:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.609.1">
[root@btrfs vol1]# btrfs filesystem defragment -rc /data/vol1
[root@brtfs vol1]# btrfs filesystem balance /data
Done, had to relocate 4 out of 4 chunks
[root@btrfs vol1]#</span></pre> <p><span class="koboSpan" id="kobo.610.1">Now, with a </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.611.1">file with lots of repeating data, we will see more compression. </span><span class="koboSpan" id="kobo.611.2">To create a 2 GB file with repeating data, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.613.1">
yes "repeating text" | head -c 2G &gt;test2</span></pre> <p><span class="koboSpan" id="kobo.614.1">Now, we repeat </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.615.1">the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">du</span></strong><span class="koboSpan" id="kobo.617.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">df</span></strong><span class="koboSpan" id="kobo.619.1"> commands as before, but we will see </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.620.1">very </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">different results:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.622.1">
[root@brtfs vol1]# df -h /data/vol1
Filesystem      Size  Used Avail Use% Mounted on
/dev/sdb         30G   62M   29G   1% /data/vol1
[root@brtfs vol1]# du -hd0 /data/vol1
2.0G    /data/vol1
[root@brtfs vol1]#</span></pre> <p><span class="koboSpan" id="kobo.623.1">Here, we see 4 GB is allocated, but only 62 MB is actually used! </span><span class="koboSpan" id="kobo.623.2">That’s a huge benefit from </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">the compression.</span></span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.625.1">Protecting data with mdadm – a software RAID solution</span></h1>
<p><span class="koboSpan" id="kobo.626.1">Modern computing systems rely on RAID technology to ensure data integrity, availability, and performance. </span><span class="koboSpan" id="kobo.626.2">By distributing data across multiple disks in various configurations, RAID provides fault tolerance, allowing systems to continue functioning even if </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.627.1">one or more </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.628.1">disks fail. </span><span class="koboSpan" id="kobo.628.2">This redundancy is critical to prevent data loss and </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">minimize downtime.</span></span></p>
<p><span class="koboSpan" id="kobo.630.1">Moreover, RAID configurations such as striping and mirroring can significantly improve read and write performance by allowing data to be accessed in parallel from multiple disks. </span><span class="koboSpan" id="kobo.630.2">As data volume and importance continue to increase in today’s digital world, RAID plays a vital role in protecting, optimizing, and maintaining storage system reliability. </span><span class="koboSpan" id="kobo.630.3">The easiest way to do this when not using Btrfs with Oracle Linux 8 is to use a tool </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">called </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.632.1">mdadm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.634.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.635.1">mdadm is </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.636.1">a software </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.637.1">utility for managing and </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.638.1">configuring software RAID arrays in Linux systems. </span><span class="koboSpan" id="kobo.638.2">It stands for </span><strong class="bold"><span class="koboSpan" id="kobo.639.1">multiple device administration</span></strong><span class="koboSpan" id="kobo.640.1"> and is commonly used to create, manage, monitor, and maintain RAID arrays. </span><span class="koboSpan" id="kobo.640.2">These arrays leverage a </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.641.1">kernel driver called </span><strong class="bold"><span class="koboSpan" id="kobo.642.1">multiple device</span></strong><span class="koboSpan" id="kobo.643.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.644.1">MD</span></strong><span class="koboSpan" id="kobo.645.1">). </span><span class="koboSpan" id="kobo.645.2">mdadm allows users to create various RAID levels, including RAID, RAID 0, RAID 1, RAID 5, RAID 6, RAID 0+1, and RAID 10, using a combination of multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">physical disks:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-2">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.647.1">Type</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.648.1">Description</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.649.1">Notes</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.650.1">RAID</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.651.1">Spanning</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.652.1">No redundancy or </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">performance advantages.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.654.1">RAID-0</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.655.1">Striping</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.656.1">No redundancy, but better performance </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">versus RAID.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.658.1">RAID-1</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.659.1">Mirroring</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.660.1">Mirrored redundancy, but no performance advantage in write workloads. </span><span class="koboSpan" id="kobo.660.2">Read workloads </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">may improve.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.662.1">RAID-5</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.663.1">Striping with double  </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">parity</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.665.1">Redundancy and good performance. </span><span class="koboSpan" id="kobo.665.2">Can lose one disk without data loss. </span><span class="koboSpan" id="kobo.665.3">Recommended to use at least </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">four disks.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.667.1">RAID-6</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.668.1">Striping with </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">tripple parity</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.670.1">Redundancy and good performance. </span><span class="koboSpan" id="kobo.670.2">Can lose two disks without data loss. </span><span class="koboSpan" id="kobo.670.3">Recommended to use at least </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">five disks.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.672.1">RAID 0+1</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.673.1">Mirroring of </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">striped disks</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.675.1">Great performance, but recovering a lost disk takes a long time. </span><span class="koboSpan" id="kobo.675.2">This requires at least </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">four disks.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.677.1">RAID 10</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.678.1">Striping of </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">mirrored disks</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.680.1">Most expensive option, but generally considered the best for redundancy, performance, and rebuild time. </span><span class="koboSpan" id="kobo.680.2">This requires at least </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">four disks.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.682.1">Table 4.2 – MD RAID options</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.683.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.684.1">It’s not uncommon </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.685.1">to confuse a </span><strong class="bold"><span class="koboSpan" id="kobo.686.1">JBOD</span></strong><span class="koboSpan" id="kobo.687.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.688.1">just a box of disks</span></strong><span class="koboSpan" id="kobo.689.1">) enclosure with a RAID enclosure. </span><span class="koboSpan" id="kobo.689.2">JBOD is a simple disk enclosure with no hardware RAID. </span><span class="koboSpan" id="kobo.689.3">A RAID disk enclosure has a hardware controller that offloads all the RAID logic for the disks within the enclosure. </span><span class="koboSpan" id="kobo.689.4">For this example, hardware RAID is not being used, only JBOD. </span><span class="koboSpan" id="kobo.689.5">All the RAID logic is being performed by </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">Oracle Linux.</span></span></p>
<p><span class="koboSpan" id="kobo.691.1">mdadm is </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.692.1">an essential tool </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.693.1">for administrators to create, modify, and monitor RAID arrays. </span><span class="koboSpan" id="kobo.693.2">It allows users to add or remove disks from an existing array, perform data recovery operations, and configure various parameters such as RAID level and spare disks. </span><span class="koboSpan" id="kobo.693.3">With its command-line interface, mdadm provides flexibility in managing and maintaining disk redundancy and performance. </span><span class="koboSpan" id="kobo.693.4">It is a reliable and robust solution that optimizes storage performance, ensures data redundancy, and maintains high availability of data. </span><span class="koboSpan" id="kobo.693.5">mdadm is normally installed when Oracle Linux </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">is installed.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.695.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.696.1">Creating an MD device is fairly simple. </span><span class="koboSpan" id="kobo.696.2">But before you create the device, you need to plan a few things </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">in advance:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.698.1">What type of RAID will you be using? </span><span class="koboSpan" id="kobo.698.2">As mentioned previously, the MD kernel driver supports many types of RAID algorithms. </span><span class="koboSpan" id="kobo.698.3">You need to pick one before running the command. </span><span class="koboSpan" id="kobo.698.4">This maps to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">–</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">level</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.701.1"> option.</span></span></li>
<li><span class="koboSpan" id="kobo.702.1">How many drives will you be using in the device? </span><span class="koboSpan" id="kobo.702.2">Most RAID types use even numbers of disks, but you still need to know how many disks will be used for data. </span><span class="koboSpan" id="kobo.702.3">This maps to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">–</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">raid-devices</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.705.1"> option.</span></span></li>
<li><span class="koboSpan" id="kobo.706.1">Will you configure a hot spare device? </span><span class="koboSpan" id="kobo.706.2">Hot spares are a great option when systems </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.707.1">need to automatically rebuild the data if a device fails. </span><span class="koboSpan" id="kobo.707.2">It’s not uncommon in remote </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.708.1">locations to have many hot spares. </span><span class="koboSpan" id="kobo.708.2">When picking hot spares, balance the required space versus how long it will take for a replacement to be installed. </span><span class="koboSpan" id="kobo.708.3">This maps to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">–</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">spare-devices</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.711.1"> option.</span></span></li>
<li><span class="koboSpan" id="kobo.712.1">What is the number of the MD device? </span><span class="koboSpan" id="kobo.712.2">Traditionally, you start with 0 and work your way up, but track the numbers so you do not accidentally use the wrong device. </span><span class="koboSpan" id="kobo.712.3">This maps </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">/dev/md#</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.716.1">What are the paths to the drives that you are going to use? </span><span class="koboSpan" id="kobo.716.2">They are normally </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">/dev/sd#</span></strong><span class="koboSpan" id="kobo.718.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">/dev/nvme#</span></strong><span class="koboSpan" id="kobo.720.1">, or </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">even </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">/dev/vd#</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.724.1">In the following example, we will create a RAID-5 array with one hot spare. </span><span class="koboSpan" id="kobo.724.2">The device being used is </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">/dev/sd[bcdef]</span></strong><span class="koboSpan" id="kobo.726.1"> and this will be the </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">dev/md0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.729.1"> device:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.730.1">
mdadm --create /dev/md0 --level=5 --raid-devices=4 --spare-devices=1 /dev/sd[bcdef]</span></pre> <p><span class="koboSpan" id="kobo.731.1">You can quickly check the status by cating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">proc/mdstat</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.734.1"> file:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer100">
<span class="koboSpan" id="kobo.735.1"><img alt="Figure 4.17 – /proc/mdstat" src="image/B18349_04_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.736.1">Figure 4.17 – /proc/mdstat</span></p>
<p><span class="koboSpan" id="kobo.737.1">The last step, while optional, is highly recommended. </span><span class="koboSpan" id="kobo.737.2">This will save the current config to the </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.738.1">mdadm configuration </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.739.1">file. </span><span class="koboSpan" id="kobo.739.2">This helps the kernel assemble the array at boot. </span><span class="koboSpan" id="kobo.739.3">This is done with the </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.741.1">
mdadm --examine --scan &gt;&gt; /etc/mdadm.conf</span></pre> <h2 id="_idParaDest-108"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.742.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.743.1">Now, let’s look at a few things about the MD device. </span><span class="koboSpan" id="kobo.743.2">First, if we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">lsblk</span></strong><span class="koboSpan" id="kobo.745.1"> command, we will see that the disks used by </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">md0</span></strong><span class="koboSpan" id="kobo.747.1"> are now identified as having </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">md0</span></strong><span class="koboSpan" id="kobo.749.1"> as children. </span><span class="koboSpan" id="kobo.749.2">This is because </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">md0</span></strong><span class="koboSpan" id="kobo.751.1"> is a child of the </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">actual disk:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer101">
<span class="koboSpan" id="kobo.753.1"><img alt="Figure 4.18 – lsblk command output" src="image/B18349_04_18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.754.1">Figure 4.18 – lsblk command output</span></p>
<p><span class="koboSpan" id="kobo.755.1">We can also check the device with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">-Q</span></strong><span class="koboSpan" id="kobo.757.1"> option to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">mdamd</span></strong><span class="koboSpan" id="kobo.759.1"> command. </span><span class="koboSpan" id="kobo.759.2">Simply pass the device as a parameter, and the command will give you a </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">short summary:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.761.1">
mdadm -Q /dev/md0</span></pre> <p><span class="koboSpan" id="kobo.762.1">The output is </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer102">
<span class="koboSpan" id="kobo.764.1"><img alt="Figure 4.19 – mdadm -Q" src="image/B18349_04_19.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.765.1">Figure 4.19 – mdadm -Q</span></p>
<p><span class="koboSpan" id="kobo.766.1">Optionally, you </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.767.1">can pass </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.768.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">–-detail</span></strong><span class="koboSpan" id="kobo.770.1"> option to get significantly more information about </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">the array:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer103">
<span class="koboSpan" id="kobo.772.1"><img alt="Figure 4.20 – mdadm --detail" src="image/B18349_04_20.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.773.1">Figure 4.20 – mdadm --detail</span></p>
<p><span class="koboSpan" id="kobo.774.1">Here, we can see not only the health of the array but also its creation date and lower-level metrics such as block size </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">and layout.</span></span></p>
<p><span class="koboSpan" id="kobo.776.1">Once the volume is created, you can now use it for filesystems or as storage for a logical </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">volume manager.</span></span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.778.1">Playing with logical volume management</span></h1>
<p><span class="koboSpan" id="kobo.779.1">When it comes to filesystems, one of the biggest issues is their inflexibility when it comes to </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.780.1">storage. </span><span class="koboSpan" id="kobo.780.2">Creating a volume on a disk means the space is locked in for the volume, which also locks in the size of the filesystem. </span><span class="koboSpan" id="kobo.780.3">However, </span><strong class="bold"><span class="koboSpan" id="kobo.781.1">Logical Volume Manager</span></strong><span class="koboSpan" id="kobo.782.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.783.1">LVM</span></strong><span class="koboSpan" id="kobo.784.1">) provides a solution to this problem. </span><span class="koboSpan" id="kobo.784.2">LVM is a widely used tool in the field of computer storage management that acts as a layer of abstraction between physical storage devices, such as hard drives or SSDs, and the OS. </span><span class="koboSpan" id="kobo.784.3">This enables the flexible and efficient management of storage resources. </span><span class="koboSpan" id="kobo.784.4">LVM is especially valuable for Linux systems, as it offers a flexible and scalable storage </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">management solution.</span></span></p>
<p><span class="koboSpan" id="kobo.786.1">With LVM, administrators can dynamically allocate and resize storage volumes without the need to repartition disks or disrupt the system. </span><span class="koboSpan" id="kobo.786.2">This flexibility is particularly useful in environments where storage requirements change frequently or where efficient resource allocation is needed. </span><span class="koboSpan" id="kobo.786.3">Additionally, LVM introduces the concept of volume groups, which act as logical containers for physical storage devices. </span><span class="koboSpan" id="kobo.786.4">By creating logical volumes within volume groups, administrators can easily allocate and manage storage space, simplifying the management of storage resources in Linux systems and making it easier to organize and utilize storage </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">resources effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.788.1">With LVM, there are three core components of </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">the storage:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.790.1">Physical volumes</span></strong><span class="koboSpan" id="kobo.791.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.792.1">PVs</span></strong><span class="koboSpan" id="kobo.793.1">): These are the block-level disk devices that are used for </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.794.1">storage. </span><span class="koboSpan" id="kobo.794.2">They can be physical disks, virtual disks (such as the MD devices created in the mdadm recipe), or other </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">block-level devices.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.796.1">Volume groups</span></strong><span class="koboSpan" id="kobo.797.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.798.1">VGs</span></strong><span class="koboSpan" id="kobo.799.1">): These are groups of PVs that are combined into a single </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.800.1">logical device. </span><span class="koboSpan" id="kobo.800.2">They can be a single device to start with, with new devices added later to </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">add capacity.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.802.1">Logical volumes</span></strong><span class="koboSpan" id="kobo.803.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.804.1">LVs</span></strong><span class="koboSpan" id="kobo.805.1">): These are logical disks built into the VG. </span><span class="koboSpan" id="kobo.805.2">They are used </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.806.1">to create filesystems and can be dynamically resized </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">as needed.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.808.1">LVM, a VG, is a central component that acts as a logical container for one or more PVs. </span><span class="koboSpan" id="kobo.808.2">A VG is created by combining physical storage devices, such as hard drives or SSDs, into a single </span><span class="No-Break"><span class="koboSpan" id="kobo.809.1">storage pool.</span></span></p>
<p><span class="koboSpan" id="kobo.810.1">In this recipe, we will show you how to initialize PVs, create a VG, and then add LVs for future use by a filesystem. </span><span class="koboSpan" id="kobo.810.2">We will also show some of the basic </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">management commands.</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.812.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.813.1">The examples </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.814.1">in this recipe will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">/dev/md0</span></strong><span class="koboSpan" id="kobo.816.1"> virtual disk created in the mdadm recipe, in addition to a few extra LUNs. </span><span class="koboSpan" id="kobo.816.2">The LVM RPMs are normally installed by default with a </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">normal installation.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.818.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.819.1">The first step is to identify what disks we can use. </span><span class="koboSpan" id="kobo.819.2">This is done with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">lvmdiskscan</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.821.1"> command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer104">
<span class="koboSpan" id="kobo.822.1"><img alt="Figure 4.21 – lvmdiskscan" src="image/B18349_04_21.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.823.1">Figure 4.21 – lvmdiskscan</span></p>
<p><span class="koboSpan" id="kobo.824.1">Here, we can see three devices, </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">md0</span></strong><span class="koboSpan" id="kobo.826.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">sda1</span></strong><span class="koboSpan" id="kobo.828.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">sda2</span></strong><span class="koboSpan" id="kobo.830.1">. </span><span class="koboSpan" id="kobo.830.2">We can also see that </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">sda2</span></strong><span class="koboSpan" id="kobo.832.1"> is already initialized as a PV. </span><span class="koboSpan" id="kobo.832.2">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">pvs</span></strong><span class="koboSpan" id="kobo.834.1"> command to display the PVs on </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">the system:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer105">
<span class="koboSpan" id="kobo.836.1"><img alt="Figure 4.22 – pvs" src="image/B18349_04_22.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.837.1">Figure 4.22 – pvs</span></p>
<p><span class="koboSpan" id="kobo.838.1">Here, we can see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">/dev/sda2</span></strong><span class="koboSpan" id="kobo.840.1"> device is used by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">ol</span></strong><span class="koboSpan" id="kobo.842.1"> VG. </span><span class="koboSpan" id="kobo.842.2">Let’s go ahead and use </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">pvcreat</span></strong><span class="koboSpan" id="kobo.844.1"> to initialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">/dev/md0</span></strong><span class="koboSpan" id="kobo.846.1">. </span><span class="koboSpan" id="kobo.846.2">This is done with the </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.848.1">
pvcreate /dev/md0</span></pre> <p><span class="koboSpan" id="kobo.849.1">Now that the device is initialized, we can create a VG. </span><span class="koboSpan" id="kobo.849.2">This is done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">vgcreate</span></strong><span class="koboSpan" id="kobo.851.1"> command. </span><span class="koboSpan" id="kobo.851.2">The command uses the first parameter as the name of the VG and then a list of devices. </span><span class="koboSpan" id="kobo.851.3">In this case, we will only use </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">/dev/md0</span></strong><span class="koboSpan" id="kobo.853.1"> to create the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">DATA</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.855.1"> VG:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.856.1">
vgcreate DATA /dev/md0</span></pre> <h2 id="_idParaDest-112"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.857.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.858.1">We can see </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.859.1">the list of VGs on a system using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">vgs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.861.1"> command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer106">
<span class="koboSpan" id="kobo.862.1"><img alt="Figure 4.23 – vgs" src="image/B18349_04_23.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.863.1">Figure 4.23 – vgs</span></p>
<p><span class="koboSpan" id="kobo.864.1">Here, we can see two VGs: the freshly created </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">DATA</span></strong><span class="koboSpan" id="kobo.866.1"> VG and the existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">ol</span></strong><span class="koboSpan" id="kobo.868.1"> VG where the OS is installed. </span><span class="koboSpan" id="kobo.868.2">We will then use the VG to create an LV. </span><span class="koboSpan" id="kobo.868.3">This is done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">lvcreate</span></strong><span class="koboSpan" id="kobo.870.1"> command. </span><span class="koboSpan" id="kobo.870.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">lvcreate</span></strong><span class="koboSpan" id="kobo.872.1"> command takes a few parameters: </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">-L</span></strong><span class="koboSpan" id="kobo.874.1"> to set the size of the volume, </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">-n</span></strong><span class="koboSpan" id="kobo.876.1"> for the name, and then at the end, the VG where the volume will exist. </span><span class="koboSpan" id="kobo.876.2">Let’s create a 3 GB volume named </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">xfs1</span></strong><span class="koboSpan" id="kobo.878.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">DATA</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.880.1"> VG:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.881.1">
lvcreate -L 2G -n xfs1 DATA</span></pre> <p><span class="koboSpan" id="kobo.882.1">We can also tell </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">lvcreate</span></strong><span class="koboSpan" id="kobo.884.1"> to use all available space. </span><span class="koboSpan" id="kobo.884.2">This is done using a lowercase </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">l</span></strong><span class="koboSpan" id="kobo.886.1"> and the special </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">100%FREE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.888.1"> option:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.889.1">
lvcreate -l 100%FREE -n xfs2 DATA</span></pre> <p><span class="koboSpan" id="kobo.890.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">lvs</span></strong><span class="koboSpan" id="kobo.892.1"> command will show all the LVs on </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">a server:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer107">
<span class="koboSpan" id="kobo.894.1"><img alt="Figure 4.24 – lvs" src="image/B18349_04_24.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.895.1">Figure 4.24 – lvs</span></p>
<p><span class="koboSpan" id="kobo.896.1">Here, we can see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">xfs1</span></strong><span class="koboSpan" id="kobo.898.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">xfs2</span></strong><span class="koboSpan" id="kobo.900.1"> volumes and their size. </span><span class="koboSpan" id="kobo.900.2">Additionally, we can see all the volumes in </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">ol</span></strong><span class="koboSpan" id="kobo.902.1">, where Linux </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">was installed.</span></span></p>
<p><span class="koboSpan" id="kobo.904.1">Let’s go </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.905.1">ahead and free up some space by deleting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">xfs2</span></strong><span class="koboSpan" id="kobo.907.1"> LV. </span><span class="koboSpan" id="kobo.907.2">This is done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">lvremove</span></strong><span class="koboSpan" id="kobo.909.1"> command. </span><span class="koboSpan" id="kobo.909.2">When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">lvremove</span></strong><span class="koboSpan" id="kobo.911.1">, use the VG/LV to identify the LV being deleted. </span><span class="koboSpan" id="kobo.911.2">The following command will remove the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">xfs2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.913.1"> LV:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.914.1">
lvremove DATA/xfs2</span></pre> <p><span class="koboSpan" id="kobo.915.1">You will also need to acknowledge </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">the removal:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer108">
<span class="koboSpan" id="kobo.917.1"><img alt="Figure 4.25 – lvremove" src="image/B18349_04_25.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.918.1">Figure 4.25 – lvremove</span></p>
<p><span class="koboSpan" id="kobo.919.1">The last trick is to see the details of a specific LV. </span><span class="koboSpan" id="kobo.919.2">This is done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">lvdisplay</span></strong><span class="koboSpan" id="kobo.921.1"> command. </span><span class="koboSpan" id="kobo.921.2">You can run the command by itself, and this will show the details for all LVs on the server. </span><span class="koboSpan" id="kobo.921.3">Optionally, you can use the command to report on a single LV, in this case the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">xfs1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.923.1"> LV:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.924.1">
lvdisplay /dev/DATA/xfs1</span></pre> <p><span class="koboSpan" id="kobo.925.1">The output is </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer109">
<span class="koboSpan" id="kobo.927.1"><img alt="Figure 4.26 – lvdisplay" src="image/B18349_04_26.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.928.1">Figure 4.26 – lvdisplay</span></p>
<p><span class="koboSpan" id="kobo.929.1">Here, you can see the volume creation date, the UUID, and the size of </span><span class="No-Break"><span class="koboSpan" id="kobo.930.1">the volume.</span></span></p>
<p><span class="koboSpan" id="kobo.931.1">Once created, there are various ways to access LVs, but the most common method is by using their </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.932.1">mapper addresses. </span><span class="koboSpan" id="kobo.932.2">In Linux, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">/dev/mapper</span></strong><span class="koboSpan" id="kobo.934.1"> directory is utilized to access device mapper devices, which is a kernel-level framework that allows for the creation and management of virtual block devices. </span><span class="koboSpan" id="kobo.934.2">With a device mapper, advanced storage functionalities such as software RAID, encryption, and LVM can be achieved. </span><span class="koboSpan" id="kobo.934.3">By using LVM, a device mapper creates virtual devices that are represented as device mapper devices under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">/dev/mapper</span></strong><span class="koboSpan" id="kobo.936.1"> directory, which act as abstractions and provide an interface for accessing and managing the underlying </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">storage features.</span></span></p>
<p><span class="koboSpan" id="kobo.938.1">For instance, logical volumes set up using LVM are mapped to device mapper devices located in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">/dev/mapper</span></strong><span class="koboSpan" id="kobo.940.1"> directory. </span><span class="koboSpan" id="kobo.940.2">Each logical volume has a corresponding device mapper device entry that can be used to interact with the logical volume as if it were a regular block device. </span><span class="koboSpan" id="kobo.940.3">The path for accessing it is </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">/dev/mapper</span></strong><span class="koboSpan" id="kobo.942.1"> followed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">VG-LV</span></strong><span class="koboSpan" id="kobo.944.1"> name. </span><span class="koboSpan" id="kobo.944.2">Thus, </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">DATA/xfs1</span></strong><span class="koboSpan" id="kobo.946.1"> would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">/dev/mapper/DATA-xfs1</span></strong><span class="koboSpan" id="kobo.948.1">. </span><span class="koboSpan" id="kobo.948.2">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">dmsetup ls</span></strong><span class="koboSpan" id="kobo.950.1"> command to show all of the </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">mapped devices:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer110">
<span class="koboSpan" id="kobo.952.1"><img alt="Figure 4.27 – dmsetup ls" src="image/B18349_04_27.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.953.1">Figure 4.27 – dmsetup ls</span></p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.954.1">XFS – creating, modifying, and more</span></h1>
<p><span class="koboSpan" id="kobo.955.1">XFS is a highly advanced and established filesystem that boasts an array of benefits and features, making it an ideal option for a wide range of use cases. </span><span class="koboSpan" id="kobo.955.2">XFS is designed to handle vast </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.956.1">storage capacities, making it suitable for </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.957.1">environments with heavy data demands. </span><span class="koboSpan" id="kobo.957.2">It can support filesystems and files up to 8 exabytes in size, allowing for the management of vast amounts of data. </span><span class="koboSpan" id="kobo.957.3">This scalability makes XFS highly suitable for big data applications, enterprise storage systems, and large-scale storage deployments. </span><span class="koboSpan" id="kobo.957.4">XFS has exceptional performance capabilities. </span><span class="koboSpan" id="kobo.957.5">It employs advanced techniques such as allocation-group-based block mapping, delayed allocation, and asynchronous I/O, which optimize disk I/O operations and improve overall throughput. </span><span class="koboSpan" id="kobo.957.6">XFS is particularly effective at handling large files and performing tasks that involve intensive read and </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">write operations.</span></span></p>
<p><span class="koboSpan" id="kobo.959.1">XFS incorporates data protection features to safeguard against data corruption. </span><span class="koboSpan" id="kobo.959.2">It employs checksumming for both metadata and data, allowing the filesystem to detect and address </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.960.1">potential data integrity issues. </span><span class="koboSpan" id="kobo.960.2">Additionally, XFS supports </span><strong class="bold"><span class="koboSpan" id="kobo.961.1">copy-on-write</span></strong><span class="koboSpan" id="kobo.962.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.963.1">COW</span></strong><span class="koboSpan" id="kobo.964.1">) snapshots, enabling efficient point-in-time backups and data recovery options. </span><span class="koboSpan" id="kobo.964.2">XFS also uses a journaling mechanism that provides fast recovery in case of system crashes or power failures. </span><span class="koboSpan" id="kobo.964.3">The journaling feature records modifications to the filesystem metadata, ensuring the consistency and integrity of data. </span><span class="koboSpan" id="kobo.964.4">This results in faster boot times and improved reliability, as well as the reduction of time required for filesystem checks during </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">system startup.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.966.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.967.1">Oracle actively contributes to many Linux technologies. </span><span class="koboSpan" id="kobo.967.2">The COW XFS feature was one example of an Oracle contribution to the community, keeping Linux free and open source. </span><span class="koboSpan" id="kobo.967.3">For more info, refer </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">to </span></span><a href="https://blogs.oracle.com/linux/post/xfs-data-block-sharing-reflink"><span class="No-Break"><span class="koboSpan" id="kobo.969.1">https://blogs.oracle.com/linux/post/xfs-data-block-sharing-reflink</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.970.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.971.1">With XFS, administrators can perform a broad range of filesystem operations while the filesystem is mounted and in use. </span><span class="koboSpan" id="kobo.971.2">This includes online resizing, enabling seamless expansion or contraction of filesystems without requiring unmounting or disruption of services. </span><span class="koboSpan" id="kobo.971.3">These online administration capabilities make XFS highly suitable for environments </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.972.1">that demand continuous availability </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.973.1">and minimal downtime. </span><span class="koboSpan" id="kobo.973.2">XFS also offers </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.974.1">extensive support for extended attributes, </span><strong class="bold"><span class="koboSpan" id="kobo.975.1">access-control lists</span></strong><span class="koboSpan" id="kobo.976.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.977.1">ACLs</span></strong><span class="koboSpan" id="kobo.978.1">), and timestamps with nanosecond precision. </span><span class="koboSpan" id="kobo.978.2">These features provide flexibility in managing file metadata and enable the implementation of complex permission structures and custom </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">metadata schemes.</span></span></p>
<p><span class="koboSpan" id="kobo.980.1">XFS is natively supported by the Linux kernel, making it a well-integrated and widely adopted choice for Linux distributions. </span><span class="koboSpan" id="kobo.980.2">It is the default filesystem in Oracle Linux and continues to benefit from ongoing development and improvement by Oracle and the Linux community. </span><span class="koboSpan" id="kobo.980.3">Additionally, XFS comes with a comprehensive set of tools for filesystem management and administration, making it an all-around </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">top-notch option.</span></span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.982.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.983.1">The examples in this recipe will use the previously created </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">xfs1</span></strong><span class="koboSpan" id="kobo.985.1"> LV. </span><span class="koboSpan" id="kobo.985.2">XFS filesystems can be created on any </span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">block device.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.987.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.988.1">The most common way to create an XFS filesystem is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">mkfs.xfs</span></strong><span class="koboSpan" id="kobo.990.1"> command with a single block device. </span><span class="koboSpan" id="kobo.990.2">This will place both the data and the journal on the </span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">same device:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.992.1">
mkfs.xfs /dev/mapper/DATA-xfs1</span></pre> <p><span class="koboSpan" id="kobo.993.1">Additionally, you can get more control using </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">additional parameters:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.995.1">Option</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.996.1">Description</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.997.1">Samples</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">-L</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.999.1">This adds a label to </span><span class="No-Break"><span class="koboSpan" id="kobo.1000.1">the filesystem.</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">-</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">L Test</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">-b</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1004.1">This sets the </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">block size.</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">-</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">b 8192</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">-f</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1009.1">This is the </span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">force option.</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">-f</span></strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">-l</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1013.1">This sets the location and size for the journal. </span><span class="koboSpan" id="kobo.1013.2">This is commonly used to tune the  performance by enabling the journal to be on a fast device while the data is on a </span><span class="No-Break"><span class="koboSpan" id="kobo.1014.1">slower device.</span></span></p>
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">Size=20m /dev/$DEVICE</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">-l </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">20m /dev/mapper/journal1</span></strong></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1018.1">Table 4.3 – XFS options</span></p>
<p><span class="koboSpan" id="kobo.1019.1">Next, add in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">/etc/fstab</span></strong><span class="koboSpan" id="kobo.1021.1"> entry info. </span><span class="koboSpan" id="kobo.1021.2">Make sure to verify whether the mountpoint exists, and that </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.1022.1">you’re using the correct </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">/dev/mapper</span></strong><span class="koboSpan" id="kobo.1024.1"> path. </span><span class="koboSpan" id="kobo.1024.2">The </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.1025.1">updated files are seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer111">
<span class="koboSpan" id="kobo.1027.1"><img alt="Figure 4.28 – /etc/fstab" src="image/B18349_04_28.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1028.1">Figure 4.28 – /etc/fstab</span></p>
<p><span class="koboSpan" id="kobo.1029.1">We can now mount the filesystem with the following </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">mount</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1032.1">
mount /xfs1</span></pre> <p><span class="koboSpan" id="kobo.1033.1">We can clearly see the filesystem is mounted now, as seen in the output from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">df</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1"> command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer112">
<span class="koboSpan" id="kobo.1036.1"><img alt="Figure 4.29 – df -h" src="image/B18349_04_29.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1037.1">Figure 4.29 – df -h</span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.1038.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.1039.1">Now that the filesystem is mounted, we can do a few things to it. </span><span class="koboSpan" id="kobo.1039.2">The first task is to grow the </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.1040.1">filesystem as 2 GB was a tad small for the </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.1041.1">application. </span><span class="koboSpan" id="kobo.1041.2">This is done in a few steps. </span><span class="koboSpan" id="kobo.1041.3">First, we grow the LV that holds the filesystem, and then we can grow the filesystem. </span><span class="koboSpan" id="kobo.1041.4">Let’s grow this to </span><span class="No-Break"><span class="koboSpan" id="kobo.1042.1">10 GB.</span></span></p>
<p><span class="koboSpan" id="kobo.1043.1">To grow the volume, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">lvextend</span></strong><span class="koboSpan" id="kobo.1045.1"> command, passing to it the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">+</span></strong><span class="koboSpan" id="kobo.1047.1"> option to add an additional </span><span class="No-Break"><span class="koboSpan" id="kobo.1048.1">8 GB:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1049.1">
lvextend -L +8G /dev/mapper/DATA-xfs1</span></pre> <p><span class="koboSpan" id="kobo.1050.1">The output is seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer113">
<span class="koboSpan" id="kobo.1052.1"><img alt="Figure 4.30 – lvextend" src="image/B18349_04_30.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1053.1">Figure 4.30 – lvextend</span></p>
<p><span class="koboSpan" id="kobo.1054.1">Once the LV is grown, we need to extend the actual filesystem. </span><span class="koboSpan" id="kobo.1054.2">This is done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">xfs_growfs</span></strong><span class="koboSpan" id="kobo.1056.1"> command, passing the </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">mapper path:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1058.1">
xfs_growfs /dev/mapper/DATA-xfs1</span></pre> <p><span class="koboSpan" id="kobo.1059.1">Depending on how much activity is on the filesystem, the growth can take a few minutes. </span><span class="koboSpan" id="kobo.1059.2">The output from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">xfs_growfs</span></strong><span class="koboSpan" id="kobo.1061.1"> command will show the details of the filesystem when </span><span class="No-Break"><span class="koboSpan" id="kobo.1062.1">it completes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer114">
<span class="koboSpan" id="kobo.1063.1"><img alt="Figure 4.31 – xfs_growfs" src="image/B18349_04_31.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1064.1">Figure 4.31 – xfs_growfs</span></p>
<p><span class="koboSpan" id="kobo.1065.1">You can also see these details by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">xfs_info</span></strong><span class="koboSpan" id="kobo.1067.1"> command, passing the mountpoint of the filesystem or the </span><span class="No-Break"><span class="koboSpan" id="kobo.1068.1">mapper path.</span></span></p>
<p><span class="koboSpan" id="kobo.1069.1">If you </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.1070.1">encounter problems mounting an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">xfs</span></strong><span class="koboSpan" id="kobo.1072.1"> filesystem, you can </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.1073.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">xfs_repair</span></strong><span class="koboSpan" id="kobo.1075.1"> command-line utility to repair and recover it. </span><span class="koboSpan" id="kobo.1075.2">However, keep in mind that the command must be run on an unmounted filesystem. </span><span class="koboSpan" id="kobo.1075.3">The main purpose of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">xfs_repair</span></strong><span class="koboSpan" id="kobo.1077.1"> is to fix inconsistencies and repair filesystem corruption in XFS partitions caused by power failures, system crashes, or hardware issues. </span><span class="koboSpan" id="kobo.1077.2">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">-n</span></strong><span class="koboSpan" id="kobo.1079.1"> option to check a filesystem without repairing it. </span><span class="koboSpan" id="kobo.1079.2">For example, you can check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">xfs1</span></strong><span class="koboSpan" id="kobo.1081.1"> filesystem without repairing it by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1082.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1083.1">
xfs_repair -n /dev/mapper/DATA-xfs1</span></pre> </div>
</body></html>