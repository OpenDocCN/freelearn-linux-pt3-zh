["```\n# ls -l /dev/ttyAMA*\ncrw-rw---- 1 root root 204, 64    Jan  1 1970 /dev/ttyAMA0\ncrw-rw---- 1 root root 204, 65    Jan  1 1970 /dev/ttyAMA1\ncrw-rw---- 1 root root 204, 66    Jan  1 1970 /dev/ttyAMA2\ncrw-rw---- 1 root root 204, 67    Jan  1 1970 /dev/ttyAMA3 \n```", "```\n#define SERIAL_AMBA_MAJOR 204\n#define SERIAL_AMBA_MINOR 64 \n```", "```\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\nint main(void)\n{\n    int f;\n    unsigned int rnd;\n    int n;\nf = open(\"/dev/urandom\", O_RDONLY);\n    if (f < 0) {\n        perror(\"Failed to open urandom\");\n        return 1;\n    }\n    n = read(f, &rnd, sizeof(rnd));\n    if (n != sizeof(rnd)) {\n        perror(\"Problem reading urandom\");\n        return 1;\n    }\n    printf(\"Random number = 0x%x\\n\", rnd);\n    close(f);\n    return 0;\n} \n```", "```\n# ls -l /dev/mmcblk*\nbrw-rw---- 1 root disk 179,   0 Aug  7 13:25 /dev/mmcblk0\nbrw-rw---- 1 root disk 179, 256 Aug  7 13:25 /dev/mmcblk0boot0\nbrw-rw---- 1 root disk 179, 512 Aug  7 13:25 /dev/mmcblk0boot1\nbrw-rw---- 1 root disk 179,   1 Aug  7 13:25 /dev/mmcblk0p1\nbrw-rw---- 1 root disk 179,   2 Aug  7 13:25 /dev/mmcblk0p2\nbrw-rw---- 1 root disk 236,   0 Aug  7 13:25 /dev/mmcblk0rpmb\nbrw-rw---- 1 root disk 179, 768 Feb  4 09:42 /dev/mmcblk1\nbrw-rw---- 1 root disk 179, 769 Feb  4 09:42 /dev/mmcblk1p1\nbrw-rw---- 1 root disk 179, 770 Feb  4 09:42 /dev/mmcblk1p2 \n```", "```\nmy_netdev = alloc_netdev(0, \"net%d\", NET_NAME_UNKNOWN, netdev_setup);\nret = register_netdev(my_netdev); \n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <linux/sockios.h>\n#include <net/if.h>\nint main(int argc, char *argv[])\n{\n    int s;\n    int ret;\n    struct ifreq ifr;\n    if (argc != 2) {\n        printf(\"Usage %s [network interface]\\n\", argv[0]);\n        return 1;\n    }\n    s = socket(PF_INET, SOCK_DGRAM, 0);\n    if (s < 0) {\n        perror(\"socket\");\n        return 1;\n    }\n    strcpy(ifr.ifr_name, argv[1]);\n    ret = ioctl(s, SIOCGIFHWADDR, &ifr);\n    if (ret < 0) {\n        perror(\"ioctl\");\n        return 1;\n    }\n  for (int i = 0; i < 6; i++) {\n        printf(\"%02x:\", (unsigned char)ifr.ifr_hwaddr.sa_data[i]);\n    }\n    printf(\"\\n\");\n    close(s);\n    return 0;\n} \n```", "```\n$ cat /proc/devices\nCharacter devices:\n  1 mem\n  4 /dev/vc/0\n  4 tty\n  4 ttyS\n  5 /dev/tty\n  5 /dev/console\n<…> \n```", "```\n# ip link show\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq qlen 1000\n    link/ether 34:08:e1:85:07:d9 brd ff:ff:ff:ff:ff:ff\n3: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc noop qlen 1000\n    link/ether 7a:1f:d8:46:36:b1 brd ff:ff:ff:ff:ff:ff \n```", "```\n# ls /sys\nblock     class     devices   fs        module\nbus       dev       firmware  kernel    power \n```", "```\n# ls /sys/devices\nplatform  software  system   tracepoint virtual \n```", "```\n# ls -d /sys/class/tty/ttyAMA*\n/sys/class/tty/ttyAMA0    /sys/class/tty/ttyAMA2\n/sys/class/tty/ttyAMA1    /sys/class/tty/ttyAMA3 \n```", "```\n# ls /sys/class/tty/ttyAMA0\nclose_delay       flags             line            uartclk\nclosing_wait      io_type           port            uevent\ncustom_divisor    iomem_base        power           xmit_fifo_size\ndev               iomem_reg_shift   subsystem\ndevice            irq               type \n```", "```\n# cat /sys/class/tty/ttyAMA0/dev\n204:64 \n```", "```\n# ls /sys/block\nloop0   loop4   mmcblk0        ram0    ram12   ram2   ram6\nloop1   loop5   mmcblk1        ram1    ram13   ram3   ram7\nloop2   loop6   mmcblk0boot0   ram10   ram14   ram4   ram8\nloop3   loop7   mmcblk0boot1   ram11   ram15   ram5   ram9 \n```", "```\n# ls /sys/block/mmcblk0\nalignment_offset   events             holders       mmcblk0p2  ro\nbdi                events_async       inflight      mq         size\ncapability         events_poll_msecs  integrity     power      slaves\ndev                ext_range          mmcblk0boot0  queue      stat\ndevice             force_ro           mmcblk0boot1  range      subsystem\ndiscard_alignment  hidden             mmcblk0p1     removable  uevent \n```", "```\n    $ cd ~ \n    ```", "```\n    $ cp -a MELD/Chapter11/meta-device-drivers . \n    ```", "```\n    $ source poky/oe-init-build-env build-beagleplay \n    ```", "```\n    $ bitbake-layers remove-layer ../meta-nova \n    ```", "```\n    $ bitbake-layers add-layer ../meta-device-drivers \n    ```", "```\n    $ bitbake-layers show-layers\n    NOTE: Starting bitbake server...\n    layer                 path                                       priority\n    =========================================================================\n    core                /home/frank/poky/meta                        5\n    yocto               /home/frank/poky/meta-poky                   5\n    yoctobsp            /home/frank/poky/meta-yocto-bsp              5\n    arm-toolchain       /home/frank/meta-arm/meta-arm-toolchain      5\n    meta-arm            /home/frank/meta-arm/meta-arm                5\n    meta-ti-bsp         /home/frank/meta-ti/meta-ti-bsp              6\n    device-drivers      /home/frank/meta-device-drivers              6 \n    ```", "```\n    IMAGE_INSTALL:append = \" read-urandom show-mac-address gpio-int i2c-eeprom-read dummy-driver\" \n    ```", "```\n    $ bitbake -c menuconfig virtual/kernel \n    ```", "```\n    $ bitbake core-image-minimal \n    ```", "```\n# ls /sys/class/gpio\nexport       gpiochip512  gpiochip515  gpiochip539  gpiochip631  unexport \n```", "```\n# ls /sys/class/gpio/gpiochip512\nbase       device     label      ngpio      power      subsystem  uevent \n```", "```\n# echo 640 > /sys/class/gpio/export\n# ls /sys/class/gpio\nexport       gpiochip512  gpiochip539  unexport\ngpio640      gpiochip515  gpiochip631 \n```", "```\n# echo 640 > /sys/class/gpio/export\nbash: echo: write error: Device or resource busy \n```", "```\n# ls /sys/class/gpio/gpio640\nactive_low  direction   power       uevent\ndevice      edge        subsystem   value \n```", "```\n# cat /sys/kernel/debug/gpio | grep USR_BUTTON\n gpio-557 (USR_BUTTON          |sysfs               ) in  hi IRQ \n```", "```\n# echo 557 > /sys/class/gpio/export\n# echo falling > /sys/class/gpio/gpio557/edge \n```", "```\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/epoll.h>\n#include <sys/types.h>\nint main(int argc, char *argv[])\n{\n    int ep;\n    int f;\n    struct epoll_event ev, events;\n    char value[4];\n    int ret;\n    int n;\n    ep = epoll_create(1);\n    if (ep == -1) {\n        perror(\"Can't create epoll\");\n        return 1;\n    }\n    f = open(\"/sys/class/gpio/gpio557/value\", O_RDONLY | O_NONBLOCK);\n    if (f == -1) {\n        perror(\"Can't open gpio557\");\n        return 1;\n    }\n    n = read(f, &value, sizeof(value));\n    if (n > 0) {\n        printf(\"Initial value value=%c\\n\", value[0]);\n        lseek(f, 0, SEEK_SET);\n    }\n    ev.events = EPOLLPRI;\n    ev.data.fd = f;\n    ret = epoll_ctl(ep, EPOLL_CTL_ADD, f, &ev);\n    while (1) {\n        printf(\"Waiting\\n\");\n        ret = epoll_wait(ep, &events, 1, -1);\n        if (ret > 0) {\n            n = read(f, &value, sizeof(value));\n            printf(\"Button pressed: value=%c\\n\", value[0]);\n            lseek(f, 0, SEEK_SET);\n        }\n    }\n    return 0;\n} \n```", "```\n# ls /sys/class/leds\n:cpu            :heartbeat      :wlan           mmc1::\n:disk-activity  :lan            mmc0::          mmc2:: \n```", "```\n# cd /sys/class/leds/\\:heartbeat\n# ls\nbrightness      invert          power           trigger\ndevice          max_brightness  subsystem       uevent \n```", "```\n# cat trigger\nnone kbd-scrolllock kbd-numlock <…> disk-write [heartbeat] cpu <…> \n```", "```\n# echo timer > trigger\n# ls\nbrightness      delay_on        max_brightness  subsystem       uevent\ndelay_off       device          power           trigger\n# cat delay_on\n500\n# cat delay_off\n500 \n```", "```\n# ls -l /dev/i2c*\ncrw-rw---- 1 root gpio 89, 0  Aug  7 13:25 /dev/i2c-0\ncrw-rw---- 1 root gpio 89, 1  Aug  7 13:25 /dev/i2c-1\ncrw-rw---- 1 root gpio 89, 2  Aug  7 13:25 /dev/i2c-2\ncrw-rw---- 1 root gpio 89, 3  Aug  7 13:25 /dev/i2c-3\ncrw-rw---- 1 root gpio 89, 5  Aug  7 13:25 /dev/i2c-5 \n```", "```\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <linux/i2c-dev.h>\n#define I2C_ADDRESS 0x50\nint main(void)\n{\n    int f;\n    int n;\n    char buf[10];\n    /* Open the adapter and set the address of the I2C device */\n    f = open(\"/dev/i2c-0\", O_RDWR);\n    /* Set the address of the i2c slave device */\n    ioctl(f, I2C_SLAVE, I2C_ADDRESS);\n    /* Set the 16-bit address to read from to 0 */\n    buf[0] = 0; /* address byte 1 */\n    buf[1] = 0; /* address byte 2 */\n    n = write(f, buf, 2);\n/* Now read 4 bytes from that address */\n    n = read(f, buf, 4);\n    printf(\"0x%x 0x%x 0x%x 0x%x\\n\", buf[0], buf[1], buf[2], buf[3]);\n    close(f);\n    return 0;\n} \n```", "```\n# ls -l /dev/spi*\ncrw-rw---- 1 root root 153, 0  Jan  1 00:29 /dev/spidev1.0 \n```", "```\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#define DEVICE_NAME \"dummy\"\n#define MAJOR_NUM 42\n#define NUM_DEVICES 4\nstatic struct class *dummy_class; \n```", "```\nstatic int dummy_open(struct inode *inode, struct file *file)\n{\n    pr_info(\"%s\\n\", __func__);\n    return 0;\n}\nstatic int dummy_release(struct inode *inode, struct file *file)\n{\n    pr_info(\"%s\\n\", __func__);\n    return 0;\n}\nstatic ssize_t dummy_read(struct file *file, char *buffer, size_t length, loff_t * offset)\n{\n    pr_info(\"%s %u\\n\", __func__, length);\n    return 0;\n}\nstatic ssize_t dummy_write(struct file *file, const char *buffer, size_t length, loff_t * offset)\n{\n    pr_info(\"%s %u\\n\", __func__, length);\n    return length;\n} \n```", "```\nstruct file_operations dummy_fops = {\n    .open = dummy_open,\n    .release = dummy_release,\n    .read = dummy_read,\n    .write = dummy_write,\n};\nint __init dummy_init(void)\n{\n    int ret;\n    int i;\n    printk(\"Dummy loaded\\n\");\n    ret = register_chrdev(MAJOR_NUM, DEVICE_NAME, &dummy_fops);\n    if (ret != 0){\n        return ret;\n    }\n    dummy_class = class_create(DEVICE_NAME);\n    for (int i = 0; i < NUM_DEVICES; i++) {\n        device_create(dummy_class, NULL, MKDEV(MAJOR_NUM, i), NULL, \"dummy%d\", i);\n    }\n    return 0;\n}\nvoid __exit dummy_exit(void)\n{\n    int i;\n    for (int i = 0; i < NUM_DEVICES; i++) {\n        device_destroy(dummy_class, MKDEV(MAJOR_NUM, i));\n    }\n    class_destroy(dummy_class);\n    unregister_chrdev(MAJOR_NUM, DEVICE_NAME);\n    printk(\"Dummy unloaded\\n\");\n} \n```", "```\nmodule_init(dummy_init);\nmodule_exit(dummy_exit); \n```", "```\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Chris Simmonds\");\nMODULE_DESCRIPTION(\"A dummy driver\"); \n```", "```\n# echo hello > /dev/dummy0\ndummy_open\ndummy_write 6\ndummy_release \n```", "```\nobj-m := dummy.o\nSRC := $(shell pwd)\nall:\n        $(MAKE) -C $(KERNEL_SRC) M=$(SRC)\nmodules_install:\n        $(MAKE) -C $(KERNEL_SRC) M=$(SRC) modules_install\nclean:\n        rm -f *.o *~ core .depend .*.cmd *.ko *.mod.c\n        rm -f Module.markers Module.symvers modules.order\n        rm -rf .tmp_versions Modules.symvers \n```", "```\nobj-m += dummy.o \n```", "```\nobj-y += dummy.o \n```", "```\n# modprobe dummy\n# lsmod\nModule                  Size  Used by\ndummy                  12288  0\n# rmmod dummy \n```", "```\n# depmod -a\n# ls /lib/modules/6.12.9-ti-g8906665ace32\nmodules.alias              modules.builtin.modinfo    modules.softdep\nmodules.alias.bin          modules.dep                modules.symbols\nmodules.builtin            modules.dep.bin            modules.symbols.bin\nmodules.builtin.alias.bin  modules.devname            updates\nmodules.builtin.bin        modules.order \n```", "```\nnet@10010000 {\n   compatible = \"smsc,lan91c111\";\n   reg = <0x10010000 0x10000>;\n   interrupts = <25>;\n}; \n```", "```\n#define VERSATILE_ETH_BASE 0x10010000\n#define IRQ_ETH 25\nstatic struct resource smc91x_resources[] = {\n[0] = {\n   .start = VERSATILE_ETH_BASE,\n   .end = VERSATILE_ETH_BASE + SZ_64K - 1,\n   .flags = IORESOURCE_MEM,\n },\n [1] = {\n   .start = IRQ_ETH,\n   .end = IRQ_ETH,\n   .flags = IORESOURCE_IRQ,\n },\n};\nstatic struct platform_device smc91x_device = {\n  .name = \"smc91x\",\n  .id = 0,\n  .num_resources = ARRAY_SIZE(smc91x_resources),\n  .resource = smc91x_resources,\n}; \n```", "```\nvoid __init versatile_init(void)\n{\n   platform_device_register(&versatile_flash_device);\n   platform_device_register(&versatile_i2c_device);\n   platform_device_register(&smc91x_device);\n<…> \n```", "```\nstatic const struct of_device_id smc91x_match[] = {\n   { .compatible = \"smsc,lan91c94\", },\n   { .compatible = \"smsc,lan91c111\", },\n   {},\n};\nMODULE_DEVICE_TABLE(of, smc91x_match);\nstatic struct platform_driver smc_driver = {\n    .probe = smc_drv_probe,\n    .remove = smc_drv_remove,\n    .driver = {\n        .name = \"smc91x\",\n        .of_match_table = of_match_ptr(smc91x_match),\n},\n};\nstatic int __init smc_driver_init(void)\n{\n    return platform_driver_register(&smc_driver);\n}\nstatic void __exit smc_driver_exit(void)\n{\n    platform_driver_unregister(&smc_driver);\n}\nmodule_init(smc_driver_init);\nmodule_exit(smc_driver_exit); \n```", "```\nstatic int smc_drv_probe(struct platform_device *pdev)\n{\n   struct smc91x_platdata *pd = dev_get_platdata(&pdev->dev);\n   const struct of_device_id *match = NULL;\n   struct resource *res, *ires;\n   int irq;\n   res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n   ires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n   <…>\n   addr = ioremap(res->start, SMC_IO_EXTENT);\n   irq = ires->start;\n   <…>\n} \n```", "```\nregister-io-width property:\n```", "```\nmatch = of_match_device(of_match_ptr(smc91x_match), &pdev->dev);\nif (match) {\n   struct device_node *np = pdev->dev.of_node;\n   u32 val;\n   <…>\n   of_property_read_u32(np, \"reg-io-width\", &val);\n   <…>\n} \n```"]