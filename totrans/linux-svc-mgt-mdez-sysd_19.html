<html><head></head><body>
		<div id="_idContainer067">
			<h1 id="_idParaDest-217"><em class="italic"><a id="_idTextAnchor228"/>Chapter 16</em>: Understanding Timekeeping with systemd</h1>
			<p>On modern computer systems, it's vitally important to maintain accurate time. To do that, our computers obtain the current time from a time server while using some implementation of the <strong class="bold">Network Time Protocol</strong> (<strong class="bold">NTP</strong>). In this chapter, we'll look at these various implementations and discuss the pros and cons of each.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding the importance of accurate time</li>
				<li>Comparing NTP implementations</li>
				<li>Understanding chrony</li>
				<li>Understanding <strong class="source-inline">systemd-timesyncd</strong></li>
				<li>Understanding the <strong class="bold">Precision Time Protocol</strong> (<strong class="bold">PTP</strong>)</li>
			</ul>
			<p>All right, it's time to get started!</p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor229"/>Technical requirements</h1>
			<p>Timekeeping is done differently in the Ubuntu and RHEL worlds. So, we'll be using both Ubuntu Server and <em class="italic">two</em> AlmaLinux virtual machines to look at both of these.</p>
			<p>Check out the following link to see the Code in Action video: <a href="https://bit.ly/3Dh4byf">https://bit.ly/3Dh4byf</a></p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor230"/>Understanding the importance of accurate time</h1>
			<p>Accurate timekeeping on computers wasn't always real important. My very first computer job involved working<a id="_idIndexMarker612"/> with a pair of transistorized computers that were each the size of a refrigerator, and that had orders of magnitude less processing power than a modern smartphone. There was no hardware clock, and there was no NTP. Every time we rebooted these beasts, we just looked at our notoriously inaccurate wall clock and manually entered the time from it. Things didn't change much with the early personal computers. I mean, you still had to set the time manually, but they did eventually come with battery-powered hardware clocks that would still keep time when you shut the computers down.</p>
			<p>Nowadays, it's critically important<a id="_idIndexMarker613"/> for computers to maintain accurate time. Scientific computing, log keeping, database updating, and financial transactions all require it. Certain security protocols, such as Kerberos, DNSSEC, and <strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>) also require it. Modern stock exchanges use automated trading bots that<a id="_idIndexMarker614"/> require it. For these reasons and others besides, mankind invented the NTP.</p>
			<p>The basic concept of NTP is easy to understand. Every modern operating system includes an NTP client. Every time you boot your computer, the NTP client obtains the correct time from a highly accurate NTP server that's someplace on the internet. To ensure even greater time accuracy, some organizations might use a local time source, which could be either a local server or something such as a GPS clock.</p>
			<p>There are several software implementations of NTP. Let's do a quick comparison of them.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor231"/>Comparing NTP implementations</h1>
			<p>The <strong class="bold">Original Guy</strong> (<strong class="bold">OG</strong>), or <em class="italic">reference implementation</em>, of the NTP world is <strong class="source-inline">ntpd</strong>. It was created way back<a id="_idIndexMarker615"/> in the 1980s and served us well for a long time. You can use it on client machines to keep<a id="_idIndexMarker616"/> their time synchronized, or you can set it up as a time server. However, it does have several<a id="_idIndexMarker617"/> shortcomings, including numerous security problems that were found during a code audit in 2017.</p>
			<p>The <strong class="source-inline">chrony</strong> implementation, which can also be used as either a client or a server, was created from scratch to fix the shortcomings of <strong class="source-inline">ntpd</strong>. Unlike <strong class="source-inline">ntpd</strong>, <strong class="source-inline">chrony</strong> has the following<a id="_idIndexMarker618"/> features:</p>
			<ul>
				<li>It works well on computers that have unstable network connections or that get turned off for long periods.</li>
				<li>It works better with virtual machines.</li>
				<li>It can adjust itself better when the speed of the hardware clock oscillator fluctuates due to a temperature change.</li>
				<li>It can achieve sub-microsecond accuracy by using hardware timestamping and a hardware<a id="_idIndexMarker619"/> reference clock.</li>
			</ul>
			<p>RHEL 7 and its clones were the first Linux distros to ship with <strong class="source-inline">chrony</strong> instead of <strong class="source-inline">ntpd</strong>. The RHEL 8 and SUSE distros also use <strong class="source-inline">chrony</strong> by default.</p>
			<p>Another alternative is <strong class="source-inline">systemd-timesyncd</strong>, which is part of the systemd ecosystem. Unlike <strong class="source-inline">ntpd</strong> and <strong class="source-inline">chrony</strong>, <strong class="source-inline">systemd-timesyncd</strong> is an implementation of the lighter-weight <strong class="bold">Simple Network Time Protocol</strong> (<strong class="bold">SNTP</strong>), instead of the full-blown NTP. SNTP requires less processing<a id="_idIndexMarker620"/> power, which makes it better for low-resource computers. The downside is that SNTP and <strong class="source-inline">systemd-timesyncd</strong> lack some of the bells and whistles that NTP has. For example, you can't use them to set up a time server, and you can't use them with<a id="_idIndexMarker621"/> either hardware timestamping or hardware reference clocks. So, you can forget about getting that good sub-microsecond accuracy with <strong class="source-inline">systemd-timesyncd</strong>. On the other hand, SNTP and <strong class="source-inline">systemd-timesyncd</strong> might be all you need for most situations. Ubuntu uses <strong class="source-inline">systemd-timesyncd</strong> by default, and it will work fine for you most of the time. If it doesn't, it's easy to switch your machine over to <strong class="source-inline">chrony</strong>.</p>
			<p>The <strong class="bold">Precision Time Protocol</strong> (<strong class="bold">PTP</strong>) isn't an implementation of NTP. Rather, it's an entirely different protocol<a id="_idIndexMarker622"/> that's designed for extreme – and I do mean extreme – timekeeping accuracy. To use it, you must have a precision time source on the local network, and you must have switches and routers that can work with it. It uses hardware timestamping and hardware reference clocks to achieve picosecond accuracy. </p>
			<p>Okay, that does it for our overview. Now, let's talk a bit about <strong class="source-inline">chrony</strong>. We'll look at it on the AlmaLinux machine since Alma uses it by default.</p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor232"/>Understanding chrony on the AlmaLinux machine</h1>
			<p>There are two components<a id="_idIndexMarker623"/> in the <strong class="source-inline">chrony</strong> system. We have <strong class="source-inline">chronyd</strong> as the<a id="_idIndexMarker624"/> daemon and <strong class="source-inline">chronyc</strong> as the user interface. The <strong class="source-inline">chronyd</strong> component can run in either client or server mode. First, let's look at the unit file for <strong class="source-inline">chonyd</strong>.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor233"/>The chronyd.service file</h2>
			<p>There are a few interesting<a id="_idIndexMarker625"/> things to look at in the <strong class="source-inline">/lib/systemd/system/chronyd.service</strong> file. In the <strong class="source-inline">[Unit]</strong> section, we have this:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=NTP client/server</p>
			<p class="source-code">Documentation=man:chronyd(8) man:chrony.conf(5)</p>
			<p class="source-code">After=ntpdate.service sntp.service ntpd.service</p>
			<p class="source-code">Conflicts=ntpd.service systemd-timesyncd.service</p>
			<p class="source-code">ConditionCapability=CAP_SYS_TIME</p>
			<p>The <strong class="source-inline">Conflicts=</strong> line indicates that we can't run multiple NTP implementations together on the same machine. If systemd detects that either <strong class="source-inline">ntpd</strong> or <strong class="source-inline">systemd-timesyncd</strong> is running, then <strong class="source-inline">chronyd</strong> will fail to start. The <strong class="source-inline">ConditionCapability=</strong> line indicates that this service runs under a non-privileged account, even though no non-privileged user account is configured in either this unit file or in the <strong class="source-inline">/etc/chrony.conf</strong> file. Instead, <strong class="source-inline">chronyd</strong> is hardcoded to run under the non-privileged <strong class="source-inline">chrony</strong> account. We can confirm this with a simple <strong class="source-inline">ps aux</strong> command, like so:</p>
			<p class="source-code">[donnie@localhost ~]$ ps aux | grep chrony</p>
			<p class="source-code">chrony       727  0.0  0.1 128912  3588 ?        S    15:23   0:00 /usr/sbin/chronyd</p>
			<p class="source-code">donnie      1901  0.0  0.0  12112  1092 pts/0    R+   16:44   0:00 grep --color=auto chrony</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>Because <strong class="source-inline">chronyd</strong> does run under a non-privileged user account, we need to set the <strong class="source-inline">CAP_SYS_TIME</strong> capability for that non-privileged user account so that it can set the system time.</p>
			<p>Next, let's look at the <strong class="source-inline">[Service]</strong> section<a id="_idIndexMarker626"/> of the <strong class="source-inline">chronyd.service</strong> file:</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">Type=forking</p>
			<p class="source-code">PIDFile=/run/chrony/chronyd.pid</p>
			<p class="source-code">EnvironmentFile=-/etc/sysconfig/chronyd</p>
			<p class="source-code">ExecStart=/usr/sbin/chronyd $OPTIONS</p>
			<p class="source-code">ExecStartPost=/usr/libexec/chrony-helper update-daemon</p>
			<p class="source-code">PrivateTmp=yes</p>
			<p class="source-code">ProtectHome=yes</p>
			<p class="source-code">ProtectSystem=full</p>
			<p>The <strong class="source-inline">ExecStart=</strong> line starts <strong class="source-inline">chronyd</strong> with options that it obtained from the file that's referenced in the <strong class="source-inline">EnvironmentFile=</strong> line. If we go there, we'll see that no options have been configured:</p>
			<p class="source-code">[donnie@localhost system]$ cd /etc/sysconfig/</p>
			<p class="source-code">[donnie@localhost sysconfig]$ cat chronyd </p>
			<p class="source-code"># Command-line options for chronyd</p>
			<p class="source-code">OPTIONS=""</p>
			<p class="source-code">[donnie@localhost sysconfig]$</p>
			<p>The <strong class="source-inline">chrony-helper</strong> program that's referenced in the <strong class="source-inline">ExecStartPost=</strong> line is a shell script that obtains the addresses of NTP servers from either a DHCP or a DNS server. At the moment, this line doesn't do anything for us. This is because <strong class="source-inline">chronyd</strong> is currently configured to contact a pool of NTP servers that is listed in the <strong class="source-inline">/etc/chrony.conf</strong> file, as shown here:</p>
			<p class="source-code">[donnie@localhost sysconfig]$ cd /etc/</p>
			<p class="source-code">[donnie@localhost etc]$ cat chrony.conf </p>
			<p class="source-code"># Use public servers from the pool.ntp.org project.</p>
			<p class="source-code"># Please consider joining the pool (http://www.pool.ntp.org/join.html).</p>
			<p class="source-code">pool 2.cloudlinux.pool.ntp.org iburst</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p>At the bottom of the <strong class="source-inline">[Service]</strong> section, we can see the <strong class="source-inline">PrivateTmp=yes</strong>, <strong class="source-inline">ProtectHome=yes</strong>, and <strong class="source-inline">ProtectSystem=full</strong> lines, which add a measure of security.</p>
			<p>Finally, there's the <strong class="source-inline">[Install]</strong> section<a id="_idIndexMarker627"/> of the <strong class="source-inline">chronyd.service</strong> file:</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">WantedBy=multi-user.target</p>
			<p>Okay, there's nothing exciting here. It's just the standard <strong class="source-inline">WantedBy=</strong> line that makes this service run in multi-user mode.</p>
			<p>Next, let's look at the <strong class="source-inline">chrony.conf</strong> file.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor234"/>The chrony.conf file</h2>
			<p>Most <strong class="source-inline">chronyd</strong> configuration<a id="_idIndexMarker628"/> is done in the <strong class="source-inline">/etc/chrony.conf</strong> file. (The only exception would be on those rare occasions where you might want to configure some options in the <strong class="source-inline">/etc/sysconfig/chronyd</strong> file.) I'm not going to cover every option in the file because you can read about them by going to the <strong class="source-inline">chrony.conf</strong> man page. However, I will point out a couple of things that you might need to reconfigure.</p>
			<p>By default, <strong class="source-inline">chrony.conf</strong> is configured to obtain the current time from a pool of time servers that are out on the internet, as we see here:</p>
			<p class="source-code">pool 2.cloudlinux.pool.ntp.org iburst</p>
			<p>The <strong class="source-inline">iburst</strong> option at the end allows <strong class="source-inline">chronyd</strong> to update the clock a bit faster when you first boot up the machine. Large organizations might have local timeservers to prevent all machines on their network from going out to the internet to obtain the time. In those cases, you would need to configure this line with the IP address of the local timeserver. (We'll look at this a bit later when we set up a time server.)</p>
			<p>For increased timekeeping accuracy, you can enable hardware timestamping by removing the <strong class="source-inline">#</strong> symbol from the beginning of the following line:</p>
			<p class="source-code">#hwtimestamp *</p>
			<p>The only catch is that the network interface adapters in your computer must support hardware<a id="_idIndexMarker629"/> timestamping. To verify that, use the <strong class="source-inline">ethtool -T</strong> command, followed by the name of your network interface adapter. Here's what that looks like on one of my old 2009-model Hewlett-Packard machines:</p>
			<p class="source-code">donnie@localhost:~&gt; sudo ethtool -T eth1</p>
			<p class="source-code">Time stamping parameters for eth1:</p>
			<p class="source-code">Capabilities:</p>
			<p class="source-code"> software-transmit     (SOF_TIMESTAMPING_TX_SOFTWARE)</p>
			<p class="source-code"> software-receive      (SOF_TIMESTAMPING_RX_SOFTWARE)</p>
			<p class="source-code"> software-system-clock (SOF_TIMESTAMPING_SOFTWARE)</p>
			<p class="source-code">PTP Hardware Clock: none</p>
			<p class="source-code">Hardware Transmit Timestamp Modes: none</p>
			<p class="source-code">Hardware Receive Filter Modes: none</p>
			<p class="source-code">donnie@localhost:~&gt;</p>
			<p>Well, that's not good. There's no PTP hardware clock, and there's no hardware timestamping. Let's see if things look any better on my Dell Precision workstation, which is several years newer:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/Figure_16.1_B17491.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.1 – Hardware timestamping on my Dell Precision T3610 workstation</p>
			<p>Yes, this does look better. We see a PTP hardware clock and hardware timestamping. The bad<a id="_idIndexMarker630"/> part is that at the moment, I can't take advantage of this, because this machine is running Lubuntu Linux. Lubuntu, just like Ubuntu, runs <strong class="source-inline">systemd-timesyncd</strong>, which can't take advantage of hardware timestamping. But that's okay for now. If I were to ever feel the need to, I could easily switch this machine over to <strong class="source-inline">chrony</strong>. (I'll show you how to do that in just a bit.)</p>
			<p>Now, let's skip to the bottom of the <strong class="source-inline">chrony.conf</strong> file, where we see these lines:</p>
			<p class="source-code"># Specify directory for log files.</p>
			<p class="source-code">logdir /var/log/chrony</p>
			<p class="source-code"># Select which information is logged.</p>
			<p class="source-code">#log measurements statistics tracking</p>
			<p>Here, we can see that it's configured to store <strong class="source-inline">chronyd</strong> logs in the <strong class="source-inline">/var/log/chrony/</strong> directory. But if we were to go there now, we'd see nothing but an empty directory. That's because the line at the bottom, which tells <strong class="source-inline">chronyd</strong> what information to log, is commented<a id="_idIndexMarker631"/> out. To change that, just remove the <strong class="source-inline">#</strong> symbol from the beginning of the line so that it now looks like this:</p>
			<p class="source-code">log measurements statistics tracking</p>
			<p>Then, restart <strong class="source-inline">chronyd</strong>:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo systemctl restart chronyd</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>You should now see log files in the <strong class="source-inline">/var/log/chrony/</strong> directory:</p>
			<p class="source-code">[donnie@localhost ~]$ cd /var/log/chrony/</p>
			<p class="source-code">[donnie@localhost chrony]$ ls -l</p>
			<p class="source-code">total 12</p>
			<p class="source-code">-rw-r--r--. 1 chrony chrony 2603 Aug 24 14:29 measurements.log</p>
			<p class="source-code">-rw-r--r--. 1 chrony chrony 1287 Aug 24 14:29 statistics.log</p>
			<p class="source-code">-rw-r--r--. 1 chrony chrony  792 Aug 24 14:29 tracking.log</p>
			<p class="source-code">[donnie@localhost chrony]$</p>
			<p>This pretty much covers the basics. Let's get a bit fancier by setting up a <strong class="source-inline">chronyd</strong> time server.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor235"/>Setting up a chronyd time server</h2>
			<p>For this demo, you'll need two Alma virtual machines. We'll set up one as the time server and the other<a id="_idIndexMarker632"/> to use the time server. (Ideally, we'd want the time server to have a static IP address, but we won't worry about that for now.)</p>
			<p>On the time server machine, edit the <strong class="source-inline">/etc/chrony.conf</strong> file. Here's the line that you'll change:</p>
			<p class="source-code">#allow 192.168.0.0/16</p>
			<p>Remove <strong class="source-inline">#</strong> from the beginning of the line and change the network address so that it matches your own. For me, the network address is correct, but the netmask is wrong. So, I'll change the line so that it looks like this:</p>
			<p class="source-code">allow 192.168.0.0/24</p>
			<p>Next, restart <strong class="source-inline">chronyd</strong>:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo systemctl restart chronyd</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>The final step for setting up the time server is to open the appropriate firewall ports:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo firewall-cmd --permanent --add-service=ntp</p>
			<p class="source-code">success</p>
			<p class="source-code">[donnie@localhost ~]$ sudo firewall-cmd --reload</p>
			<p class="source-code">success</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>Now, switch over to the other Alma virtual machine and edit the <strong class="source-inline">/etc/chrony.conf</strong> file on it. Comment out the <strong class="source-inline">pool</strong> line and add a line that points to the IP address of the time server virtual machine. The two lines should now look something like this:</p>
			<p class="source-code">#pool 2.cloudlinux.pool.ntp.org iburst</p>
			<p class="source-code">server 192.168.0.14 iburst</p>
			<p>Save the file and restart the <strong class="source-inline">chronyd</strong> service. When you look at the status of <strong class="source-inline">chronyd</strong>, you should<a id="_idIndexMarker633"/> see that this machine now obtains its time from your time server. It should look something like this:</p>
			<p class="source-code">[donnie@logserver ~]$ systemctl status chronyd</p>
			<p class="source-code">● chronyd.service - NTP client/server</p>
			<p class="source-code">   Loaded: loaded (/usr/lib/systemd/system/chronyd.service; enabled; vendor preset: enabled)</p>
			<p class="source-code">   Active: active (running) since Tue 2021-08-24 14:59:43 EDT; 55s ago</p>
			<p class="source-code"> . . .</p>
			<p class="source-code">. . .</p>
			<p class="source-code">Aug 24 14:59:48 logserver chronyd[15558]: Selected source 192.168.0.14</p>
			<p class="source-code">Aug 24 14:59:48 logserver chronyd[15558]: System clock TAI offset set to 37 seconds</p>
			<p class="source-code">[donnie@logserver ~]$</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Sometimes need to preface this command with sudo in order to see information about the network time sources.</p>
			<p>That's all there is to it. Let's change gears now and look at the <strong class="source-inline">chronyc</strong> client utility.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor236"/>Using chronyc</h2>
			<p>You can use the <strong class="source-inline">chronyc</strong> utility to either look at information about the <strong class="source-inline">chronyd</strong> service or to dynamically<a id="_idIndexMarker634"/> configure certain aspects of the <strong class="source-inline">chronyd</strong> service. Let's start by looking at tracking information on our time server:</p>
			<p class="source-code">[donnie@localhost ~]$ chronyc tracking</p>
			<p class="source-code">Reference ID    : 32CDF46C (50-205-244-108-static.hfc.comcastbusiness.net)</p>
			<p class="source-code">Stratum         : 3</p>
			<p class="source-code">Ref time (UTC)  : Tue Aug 24 19:16:00 2021</p>
			<p class="source-code">System time     : 0.000093940 seconds fast of NTP time</p>
			<p class="source-code">Last offset     : -0.000033931 seconds</p>
			<p class="source-code">RMS offset      : 0.000185221 seconds</p>
			<p class="source-code">Frequency       : 10909.050 ppm fast</p>
			<p class="source-code">Residual freq   : +0.002 ppm</p>
			<p class="source-code">Skew            : 0.344 ppm</p>
			<p class="source-code">Root delay      : 0.016927114 seconds</p>
			<p class="source-code">Root dispersion : 0.018588312 seconds</p>
			<p class="source-code">Update interval : 128.6 seconds</p>
			<p class="source-code">Leap status     : Normal</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>Rather than go over everything here, I'm going to let you read about it by going to the <strong class="source-inline">chronyc</strong> man page. However, I do want to talk about the <strong class="source-inline">Reference ID</strong> line at the top.</p>
			<p>The <strong class="source-inline">Reference ID</strong> line just tells us the hostname or the IP address of the remote time server that this local<a id="_idIndexMarker635"/> timeserver is synchronized to. We see that this local time server is synchronized to a remote time server that's operated either by Comcast or by an organization that uses Comcast hosting. Note that this remote time server is a member of the pool that's configured in the <strong class="source-inline">chrony.conf</strong> file.</p>
			<p>Now, let's look at the Alma machine that we set up as a client of this local time server:</p>
			<p class="source-code">[donnie@logserver ~]$ chronyc tracking</p>
			<p class="source-code">Reference ID    : C0A8000E (192.168.0.14)</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p class="source-code">[donnie@logserver ~]$</p>
			<p>As expected, we see the IP address of the local time server.</p>
			<p>The <strong class="source-inline">sources</strong> command will show you all of the time servers that our machine can access. Here are the time servers that are in the default pool for the Alma machines:</p>
			<p class="source-code">[donnie@localhost ~]$ chronyc sources</p>
			<p class="source-code">210 Number of sources = 4</p>
			<p class="source-code">MS Name/IP address                 Stratum Poll Reach LastRx Last sample               </p>
			<p class="source-code">===============================================================================</p>
			<p class="source-code">^* 50-205-244-108-static.hf&gt;    2   9   377   349   -551us[ -384us] +/-   43ms</p>
			<p class="source-code">^+ clock.nyc.he.net                    2   8   377    13  +1084us[+1084us] +/-   51ms</p>
			<p class="source-code">^+ t2.time.gq1.yahoo.com         2   9   377    92   +576us[ +576us] +/-   49ms</p>
			<p class="source-code">^+ linode.appus.org                   2   8   377    23   +895us[ +895us] +/-   70ms</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>As before, I'll let you look at the <strong class="source-inline">chronyc</strong> man page to see what all the fields are.</p>
			<p>So far, we've been able to look at everything with normal user privileges. Looking at other types of information<a id="_idIndexMarker636"/> might require <strong class="source-inline">sudo</strong> privileges, as we see here on the time server:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo chronyc clients</p>
			<p class="source-code">[sudo] password for donnie: </p>
			<p class="source-code">Hostname                      NTP   Drop Int IntL Last     Cmd   Drop Int  Last</p>
			<p class="source-code">===============================================================================</p>
			<p class="source-code">192.168.0.7                    29      0   8   -   129        0      0   -     -</p>
			<p class="source-code">localhost                       0      0   -   -     -       8      0   8   287</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>Very cool. We see the IP address of the virtual machine that we set up as a client of this local time server.</p>
			<p>Just for fun, let's see how<a id="_idIndexMarker637"/> much work our local time server has been doing:</p>
			<p class="source-code">[donnie@localhost ~]$ sudo chronyc serverstats</p>
			<p class="source-code">NTP packets received       : 84</p>
			<p class="source-code">NTP packets dropped        : 0</p>
			<p class="source-code">Command packets received   : 20</p>
			<p class="source-code">Command packets dropped    : 0</p>
			<p class="source-code">Client log records dropped : 0</p>
			<p class="source-code">[donnie@localhost ~]$</p>
			<p>This shows the number of NTP packets and command packets that were received from the clients.</p>
			<p>There's a whole lot more to this command than what I can show you here. Your best bet is to read all about it by going to the <strong class="source-inline">chronyc</strong> man page.</p>
			<p>That's about it for <strong class="source-inline">chronyd</strong> and <strong class="source-inline">chronyc</strong>. So, let's shift over to the Ubuntu machine and look at <strong class="source-inline">systemd-timesyncd</strong>.</p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor237"/>Understanding systemd-timesyncd</h1>
			<p>Ubuntu uses <strong class="source-inline">systemd-timesyncd</strong> by default. It's a simple, lightweight<a id="_idIndexMarker638"/> system that's easy to configure. Before we get to that, let's take a quick look at the <strong class="source-inline">systemd-timesyncd.service</strong> file.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor238"/>The systemd-timesyncd.service file</h2>
			<p>The <strong class="source-inline">[Unit]</strong> section<a id="_idIndexMarker639"/> of the <strong class="source-inline">/lib/systemd/system/systemd-timesyncd.service</strong> file looks like this:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=Network Time Synchronization</p>
			<p class="source-code">Documentation=man:systemd-timesyncd.service(8)</p>
			<p class="source-code">ConditionCapability=CAP_SYS_TIME</p>
			<p class="source-code">ConditionVirtualization=!container</p>
			<p class="source-code">DefaultDependencies=no</p>
			<p class="source-code">After=systemd-sysusers.service</p>
			<p class="source-code">Before=time-set.target sysinit.target shutdown.target</p>
			<p class="source-code">Conflicts=shutdown.target</p>
			<p class="source-code">Wants=time-set.target time-sync.target</p>
			<p>Note the <strong class="source-inline">ConditionVirtualization=!container</strong> line. The <strong class="source-inline">ConditionVirtualization=</strong> part checks to see if the operating system is running in a virtualized environment. In this case, it wants to see whether it's running in a container. The <strong class="source-inline">!</strong> in front of <strong class="source-inline">container</strong> denotes a negation. In other words, if systemd detects that this operating<a id="_idIndexMarker640"/> system is running in a container, then the <strong class="source-inline">systemd-timesyncd</strong> service won't start.</p>
			<p>In the <strong class="source-inline">[Service]</strong> section, you'll see a lot more security-related parameters than you saw in the <strong class="source-inline">chronyd.service</strong> file on the Alma machine. There are so many that I can only show you some of them here:</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">AmbientCapabilities=CAP_SYS_TIME</p>
			<p class="source-code">CapabilityBoundingSet=CAP_SYS_TIME</p>
			<p class="source-code">ExecStart=!!/lib/systemd/systemd-timesyncd</p>
			<p class="source-code">LockPersonality=yes</p>
			<p class="source-code">MemoryDenyWriteExecute=yes</p>
			<p class="source-code">NoNewPrivileges=yes</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p class="source-code">SystemCallFilter=@system-service @clock</p>
			<p class="source-code">Type=notify</p>
			<p class="source-code">User=systemd-timesync</p>
			<p class="source-code">WatchdogSec=3min</p>
			<p>This makes sense, considering that Ubuntu uses AppArmor as its mandatory access control system instead of SELinux, which is what the Alma machine uses. A default configuration of AppArmor doesn't provide near as much protection as a default configuration of SELinux, so it makes sense to include more security directives in this service file. Also, note the <strong class="source-inline">User=systemd-timesync</strong> line, which configures the non-privileged user account for this service.</p>
			<p>The <strong class="source-inline">[Install]</strong> section is a bit<a id="_idIndexMarker641"/> different from what we're used to:</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">WantedBy=sysinit.target</p>
			<p class="source-code">Alias=dbus-org.freedesktop.timesync1.service</p>
			<p>Instead of getting started as part of <strong class="source-inline">multi-user.target</strong>, <strong class="source-inline">systemd-timesyncd</strong> gets started as part of <strong class="source-inline">sysinit.target</strong>. So, it gets started much earlier in the boot process.</p>
			<p>Next, let's briefly look at how to configure <strong class="source-inline">systemd-timesyncd</strong>.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor239"/>The timesyncd.conf file</h2>
			<p>When I said that we'll <em class="italic">briefly</em> cover<a id="_idIndexMarker642"/> this, I really did mean <em class="italic">briefly</em>. That's because there's not a whole lot to configure. Here's the entirety of the <strong class="source-inline">/etc/systemd/timesyncd.conf</strong> file:</p>
			<p class="source-code">[Time]</p>
			<p class="source-code">#NTP=</p>
			<p class="source-code">#FallbackNTP=ntp.ubuntu.com</p>
			<p class="source-code">#RootDistanceMaxSec=5</p>
			<p class="source-code">#PollIntervalMinSec=32</p>
			<p class="source-code">#PollIntervalMaxSec=2048</p>
			<p>Everything is commented out, which means that everything is set with its default values. The first thing to notice is that there's nothing set for the <strong class="source-inline">NTP=</strong> line and that the <strong class="source-inline">FallbackNTP=</strong> line points to a pool of time servers at <a href="http://ntp.ubuntu.com">ntp.ubuntu.com</a>. So, this machine will only obtain its time from one of the time servers that's in that pool. The remaining three parameters<a id="_idIndexMarker643"/> are set with sane values that you'll likely never have to change. (I'll let you read about them in the <strong class="source-inline">timesyncd.conf</strong> man page.)</p>
			<p>That's enough about this file for now. Now, let's look at a couple of <strong class="source-inline">timedatectl</strong> options.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor240"/>Using timedatectl</h2>
			<p>Two <strong class="source-inline">timedatectl</strong> viewing options<a id="_idIndexMarker644"/> are specific to <strong class="source-inline">systemd-timesyncd</strong>. The <strong class="source-inline">timesync-status</strong> option looks like this:</p>
			<p class="source-code">donnie@ubuntu2004-staticip:/etc/systemd$ timedatectl timesync-status</p>
			<p class="source-code">       Server: 91.189.94.4 (ntp.ubuntu.com)</p>
			<p class="source-code">Poll interval: 32s (min: 32s; max 34min 8s)</p>
			<p class="source-code">         Leap: normal                      </p>
			<p class="source-code">      Version: 4                           </p>
			<p class="source-code">      Stratum: 2                           </p>
			<p class="source-code">    Reference: 8CCBCC4D                    </p>
			<p class="source-code">    Precision: 1us (-23)                   </p>
			<p class="source-code">Root distance: 45.074ms (max: 5s)          </p>
			<p class="source-code">       Offset: -336.094ms                  </p>
			<p class="source-code">        Delay: 101.668ms                   </p>
			<p class="source-code">       Jitter: 1.560ms                     </p>
			<p class="source-code"> Packet count: 214                         </p>
			<p class="source-code">    Frequency: -500.000ppm                 </p>
			<p class="source-code">donnie@ubuntu2004-staticip:/etc/systemd$</p>
			<p>At the top, we see the remote time server that this machine accesses, and we see that it's a member of the <a href="http://ntp.ubunutu.com">ntp.ubunutu.com</a> pool. Further down, we see that <strong class="source-inline">Rootdistance</strong> from the time<a id="_idIndexMarker645"/> servers comes in at 45.07 milliseconds, which is well within the five seconds that's set in the <strong class="source-inline">timesyncd.conf</strong> file.</p>
			<p>The other <strong class="source-inline">timedatectl</strong> option is <strong class="source-inline">show-timesync</strong>, which looks something like this:</p>
			<p class="source-code">donnie@ubuntu2004-staticip:~$ timedatectl show-timesync</p>
			<p class="source-code">FallbackNTPServers=ntp.ubuntu.com</p>
			<p class="source-code">ServerName=ntp.ubuntu.com</p>
			<p class="source-code">ServerAddress=91.189.89.198</p>
			<p class="source-code">RootDistanceMaxUSec=5s</p>
			<p class="source-code">PollIntervalMinUSec=32s</p>
			<p class="source-code">PollIntervalMaxUSec=34min 8s</p>
			<p class="source-code">PollIntervalUSec=32s</p>
			<p class="source-code">NTPMessage={ Leap=0, Version=4, Mode=4, Stratum=2, Precision=-23, RootDelay=1.129ms, RootDispersion=30.349ms, Reference=11FD227B, OriginateTimestamp=Tue 2021-08-24 17:16:48 EDT, ReceiveTimestamp=Tue 2021-08-24 17:16:48 EDT, TransmitTimestamp=Tue 2021-08-24 17:16:48 EDT, DestinationTimestamp=Tue 2021-08-24 17:16:48 EDT, Ignored=no PacketCount=1, Jitter=0 }</p>
			<p class="source-code">Frequency=-32768000</p>
			<p class="source-code">donnie@ubuntu2004-staticip:~$</p>
			<p>This shows the same information that's in the <strong class="source-inline">timesync-status</strong> option, except that it's now in a machine-readable format.</p>
			<p>Next, let's edit the <strong class="source-inline">/etc/systemd/timesyncd.conf</strong> file so that this machine will obtain its time from our local AlmaLinux time server. We'll just uncomment the <strong class="source-inline">#NTP=</strong> line and add the IP address of the Alma machine. It should now look something like this:</p>
			<p class="source-code">NTP=192.168.0.14</p>
			<p>After restarting the <strong class="source-inline">systemd-timesyncd</strong> service, we should see that this machine now obtains its time<a id="_idIndexMarker646"/> from our local time server, as we see here:</p>
			<p class="source-code">donnie@ubuntu2004-staticip:~$ timedatectl timesync-status</p>
			<p class="source-code">       Server: 192.168.0.14 (192.168.0.14) </p>
			<p class="source-code">Poll interval: 32s (min: 32s; max 34min 8s)</p>
			<p class="source-code">         Leap: normal                      </p>
			<p class="source-code">      Version: 4                           </p>
			<p class="source-code">      Stratum: 3                           </p>
			<p class="source-code">    Reference: 32CDF46C                    </p>
			<p class="source-code">    Precision: 1us (-25)                   </p>
			<p class="source-code">Root distance: 27.884ms (max: 5s)          </p>
			<p class="source-code">       Offset: -279.517ms                  </p>
			<p class="source-code">        Delay: 470us                       </p>
			<p class="source-code">       Jitter: 0                           </p>
			<p class="source-code"> Packet count: 1                           </p>
			<p class="source-code">    Frequency: -500.000ppm                 </p>
			<p class="source-code">donnie@ubuntu2004-staticip:~$</p>
			<p>There's an excellent chance that <strong class="source-inline">systemd-timedatectl</strong> is all you'll ever need. But what if you really need the extra features and precision that come with <strong class="source-inline">chrony</strong>? Well, let's see if we can switch our Ubuntu machine over to <strong class="source-inline">chrony</strong>.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor241"/>Configuring Ubuntu to use chrony</h2>
			<p>The first step<a id="_idIndexMarker647"/> is to stop and<a id="_idIndexMarker648"/> disable <strong class="source-inline">systemd-timesyncd</strong>, like this:</p>
			<p class="source-code">donnie@ubuntu2004-staticip:~$ sudo systemctl disable --now systemd-timesyncd</p>
			<p class="source-code">Removed /etc/systemd/system/dbus-org.freedesktop.timesync1.service.</p>
			<p class="source-code">Removed /etc/systemd/system/sysinit.target.wants/systemd-timesyncd.service.</p>
			<p class="source-code">donnie@ubuntu2004-staticip:~$</p>
			<p>Now, install the <strong class="source-inline">chrony</strong> package, like this:</p>
			<p class="source-code">donnie@ubuntu2004-staticip:~$ sudo apt install chrony</p>
			<p>Since this is Ubuntu, the <strong class="source-inline">chronyd</strong> service will be enabled and started automatically when the<a id="_idIndexMarker649"/> installation completes. The only difference<a id="_idIndexMarker650"/> from what you saw on the Alma machine is that the <strong class="source-inline">chrony.conf</strong> file on Ubuntu is in the <strong class="source-inline">/etc/chrony/</strong> directory.</p>
			<p>Sometimes, you just need to be precise. So, let's talk a bit about PTP.</p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor242"/>Understanding the Precision Time Protocol</h1>
			<p>For many financial, scientific, and<a id="_idIndexMarker651"/> enterprise applications, you've just got to have the most accurate time possible. In these instances, getting the time from a remote time server on the Internet just doesn't meet your needs. So, you need something better. With proper hardware, <strong class="bold">PTP</strong> can keep your network time synchronized to picosecond accuracy. The whole explanation of PTP is rather complex, so allow me to simplify things a bit.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor243"/>An overview of PTP</h2>
			<p>Unlike NTP, PTP cannot obtain its time from a remote time server that's out on the internet. Instead, PTP<a id="_idIndexMarker652"/> can only be used within a <strong class="bold">Local Area Network</strong> (<strong class="bold">LAN</strong>) and will obtain its time from a local source. This local time<a id="_idIndexMarker653"/> source, which is usually called the <em class="italic">Grandmaster Clock</em>, will most likely obtain its time from a <strong class="bold">Global Positioning System</strong> (<strong class="bold">GPS</strong>) satellite, and will then synchronize the clocks on the other<a id="_idIndexMarker654"/> network devices to the GPS time. To do this, the Grandmaster<a id="_idIndexMarker655"/> Clock sends <strong class="source-inline">sync</strong> messages out to the network. The client devices will respond by sending back <strong class="source-inline">delay request</strong> messages, and the Grandmaster Clock will respond with <strong class="source-inline">delay response</strong> messages. The network packets that carry these messages all have timestamps that will be used in the calculations for figuring out how to adjust the time on the network devices. To make this all work, your network must be set up with switches and routers that can transfer these messages.</p>
			<p>In addition to the Grandmaster Clock, there are three other types of clocks that can be found on a PTP network:</p>
			<ul>
				<li><strong class="bold">Ordinary clocks</strong>: These clocks<a id="_idIndexMarker656"/> are on the end user devices such as servers, desktop clients, IoT devices, and so forth.</li>
				<li><strong class="bold">Transparent clocks</strong>: These are the network switches that transfer the messages between<a id="_idIndexMarker657"/> the Grandmaster Clock and the ordinary clocks. Transparent clocks can't send messages beyond their VLAN boundaries.</li>
				<li><strong class="bold">Boundary clocks</strong>: These are optional and are only needed if you need to divide your network into different VLANs. Instead of just transferring messages between the Grandmaster<a id="_idIndexMarker658"/> and the ordinary clocks, a boundary clock synchronizes with the Grandmaster, and then sends out sync messages to the ordinary clocks on its VLAN. The advantage of using boundary clocks is that it helps prevent the Grandmaster from getting overwhelmed with <strong class="source-inline">delay request</strong> messages.</li>
			</ul>
			<p>It is possible to set up a Linux server as a boundary clock, but you probably won't. Most likely, your organization will obtain its transparent clocks and boundary clocks from its preferred network equipment vendor, such as Cisco or Juniper. So, how would you use PTP with Linux? Mostly, you'd just set up PTP on your servers, desktop machines, and IoT devices so that they would obtain their time from a PTP server rather than from an NTP server. Let's check it out.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor244"/>Installing PTP</h2>
			<p>To set up either<a id="_idIndexMarker659"/> a Linux server, a Linux desktop, or a Linux IoT device to obtain its time from a PTP source, you'll have to install the <strong class="source-inline">linuxptp</strong> package. On the Alma machine, you'd do:</p>
			<p class="source-code">[donnie@logserver ~]$ sudo dnf install linuxptp</p>
			<p>On the Ubuntu machine, you'd do:</p>
			<p class="source-code">donnie@ubuntu2004:~$ sudo apt install linuxptp</p>
			<p>Next, stop and disable whichever timekeeping service your machine is running. If your machine is running <strong class="source-inline">chroynd</strong>, the command would be:</p>
			<p class="source-code">[donnie@logserver ~]$ sudo systemctl disable --now chronyd</p>
			<p>If your machine<a id="_idIndexMarker660"/> is running <strong class="source-inline">systemd-timesyncd</strong>, the command would be:</p>
			<p class="source-code">donnie@ubuntu2004:~$ sudo systemctl disable --now systemd-timesyncd</p>
			<p>Installing the <strong class="source-inline">linuxptp</strong> package installs two different services, which are the <strong class="source-inline">ptp4l</strong> service and the <strong class="source-inline">phc2sys</strong> service. Before we can enable or start the PTP services, we'll need to configure them. Let's look at how to do this on the Alma machine.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor245"/>Configuring PTP with software timestamping on AlmaLinux</h2>
			<p>The first step is to edit the <strong class="source-inline">/etc/sysconfig/ptp4l</strong> file. When you first open the file, you'll see this:</p>
			<p class="source-code">OPTIONS="-f /etc/ptp4l.conf -i eth0"</p>
			<p>This default configuration is for a master server, and it has the wrong network adapter name. We'll add the <strong class="source-inline">-s</strong> option to make this run in client mode and change the network adapter's name. You won't have<a id="_idIndexMarker661"/> hardware timestamping available on your virtual machines, even if it is available on the network adapter of your host computer. To deal with that, we'll also<a id="_idIndexMarker662"/> add the <strong class="source-inline">-S</strong> option to make it use software timestamping. The edited line should look something like this:</p>
			<p class="source-code">OPTIONS="-f /etc/ptp4l.conf -S -s -i enp0s3"</p>
			<p>(Of course, use your own network adapter's name in place of mine.)</p>
			<p>Now, enable and start the <strong class="source-inline">ptp4l</strong> service:</p>
			<p class="source-code">[donnie@logserver ~]$ sudo systemctl enable --now ptp4l</p>
			<p>The service does run, even though there's no PTP time source on my network. Regardless, the last line of the <strong class="source-inline">systemctl status</strong> output shows that the <strong class="source-inline">ptp4l</strong> service has selected the best<a id="_idIndexMarker663"/> master clock. I have no idea where that clock is, but it doesn't matter. In a real-life scenario, you would<a id="_idIndexMarker664"/> know because you'd be dealing with a real clock:</p>
			<p class="source-code">[donnie@logserver ~]$ systemctl status ptp4l</p>
			<p class="source-code">● ptp4l.service - Precision Time Protocol (PTP) service</p>
			<p class="source-code">   Loaded: loaded (/usr/lib/systemd/system/ptp4l.service; enabled; vendor preset: disabled)</p>
			<p class="source-code">   Active: active (running) since Wed 2021-08-25 18:16:26 EDT; 8s ago</p>
			<p class="source-code"> Main PID: 1841 (ptp4l)</p>
			<p class="source-code">    Tasks: 1 (limit: 4938)</p>
			<p class="source-code">   Memory: 276.0K</p>
			<p class="source-code">   CGroup: /system.slice/ptp4l.service</p>
			<p class="source-code">           └─1841 /usr/sbin/ptp4l -f /etc/ptp4l.conf -S -s -i enp0s3</p>
			<p class="source-code">. . .</p>
			<p class="source-code">. . .</p>
			<p class="source-code">Aug 25 18:16:33 logserver ptp4l[1841]: [5697.998] selected local clock 080027.fffe.94a66f as best master</p>
			<p class="source-code">[donnie@logserver ~]$</p>
			<p>Okay, we're good with the software timestamping. Now, let's look at hardware timestamping.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor246"/>Configuring PTP with hardware timestamping on AlmaLinux</h2>
			<p>Using hardware timestamping gives you the most precise timekeeping that you can get. The only catch is that<a id="_idIndexMarker665"/> the network interface adapters on your machine have to be capable of doing<a id="_idIndexMarker666"/> hardware timestamping. Fortunately, that shouldn't be a problem with newer computers. (In the <em class="italic">Understanding chrony</em> section, I showed you how to verify whether your network adapter does support hardware timestamping.)</p>
			<p>The first step is to edit the <strong class="source-inline">/etc/sysconfig/ptp4l</strong> file, as you did previously. This time, leave out the <strong class="source-inline">-S</strong> option so that the edited line looks like this:</p>
			<p class="source-code">OPTIONS="-f /etc/ptp4l.conf -s -i enp0s3"</p>
			<p>Next, you'll need to configure and enable the <strong class="source-inline">phc2sys</strong> service so that the computer clock can synchronize with the PTP hardware clock that's in the network adapter. The first step is to configure the <strong class="source-inline">/etc/sysconfig/phc2sys</strong> file. By default, the file looks like this:</p>
			<p class="source-code">OPTIONS="-a -r"</p>
			<p>Change that line so that it looks something like this:</p>
			<p class="source-code">OPTIONS="-c CLOCK_REALTIME -s enp0s3 -w"</p>
			<p>Here's the breakdown:</p>
			<ul>
				<li><strong class="source-inline">-c CLOCK_REALTIME</strong>: The <strong class="source-inline">-c</strong> option specifies the clock that is to be synchronized. <strong class="source-inline">CLOCK_REALTIME</strong> is the normal computer clock.</li>
				<li><strong class="source-inline">-s enp0s3</strong>: In this file, <strong class="source-inline">-s</strong> specifies the device that will be used for synchronization. In this case, we're using the PTP hardware clock that's in the <strong class="source-inline">enp0s3</strong> network adapter to synchronize the normal system clock.</li>
				<li><strong class="source-inline">-w</strong>: This tells the <strong class="source-inline">phc2sys</strong> service to wait until the <strong class="source-inline">ptp4l</strong> service is in a synchronized state before attempting to synchronize the system clock.</li>
			</ul>
			<p>The final step is to restart the <strong class="source-inline">ptp4l</strong> service and to enable and start the <strong class="source-inline">phc2sys</strong> service. Note that this will fail on your virtual machine because the VirtualBox network adapter doesn't have a PTP hardware clock. When you've seen what you need to see, disable the <strong class="source-inline">ptp4l</strong> and <strong class="source-inline">phc2sys</strong> services and re-enable the <strong class="source-inline">chronyd</strong> service.</p>
			<p>Next, let's look at how to do all of this on Ubuntu.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor247"/>Configuring PTP with software timestamping on Ubuntu</h2>
			<p>There are no supplementary PTP configuration<a id="_idIndexMarker667"/> files on Ubuntu, so you'll need to edit the <strong class="source-inline">ptp4l.service</strong> file. Start<a id="_idIndexMarker668"/> by doing:</p>
			<p class="source-code">donnie@ubuntu2004:~$ sudo systemctl edit --full ptp4l</p>
			<p>In the <strong class="source-inline">[Service]</strong> section, you'll need to change the <strong class="source-inline">ExecStart</strong> line, which looks like this:</p>
			<p class="source-code">ExecStart=/usr/sbin/ptp4l -f /etc/linuxptp/ptp4l.conf -i eth0</p>
			<p>Change it so that it looks something like this:</p>
			<p class="source-code">ExecStart=/usr/sbin/ptp4l -f /etc/linuxptp/ptp4l.conf -S -s -i enp0s3</p>
			<p>Finally, enable and start the <strong class="source-inline">ptp4l</strong> service, as you did previously on the Alma machine.</p>
			<p>Now, let's wrap this up by configuring hardware timestamping on Ubuntu.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor248"/>Configuring PTP with hardware timestamping on Ubuntu</h2>
			<p>Again, start by editing the <strong class="source-inline">ptp4l.service</strong> file. This time, enable hardware timestamping<a id="_idIndexMarker669"/> by leaving out the <strong class="source-inline">-S</strong> option<a id="_idIndexMarker670"/> so that the <strong class="source-inline">ExecStart</strong> line will look like this:</p>
			<p class="source-code">ExecStart=/usr/sbin/ptp4l -f /etc/linuxptp/ptp4l.conf -s -i enp0s3</p>
			<p>Next, edit the <strong class="source-inline">phc2sys.service</strong> file by doing:</p>
			<p class="source-code">donnie@ubuntu2004:~$ sudo systemctl edit --full phc2sys</p>
			<p>In the <strong class="source-inline">[Service]</strong> section, make the <strong class="source-inline">ExecStart</strong> line look something like this:</p>
			<p class="source-code">ExecStart=/usr/sbin/phc2sys -c CLOCK_REALTIME -s enp0s3 -w</p>
			<p>The final step is to restart the <strong class="source-inline">ptp4l</strong> service and to enable and start the <strong class="source-inline">phc2sys</strong> service. Alas, that will also fail this time, due to not having the PTP hardware clock in the VirtualBox network<a id="_idIndexMarker671"/> adapter. When you've seen what you want to see, change the virtual machine back to whichever<a id="_idIndexMarker672"/> timekeeping service that you were using before.</p>
			<p>All right, that's it for timekeeping. I think it's time to wrap this baby up.</p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor249"/>Summary</h1>
			<p>As always, we've covered a lot of ground and had a bit of fun in the process. We started by discussing why accurate timekeeping is so important and then did a quick overview of the various implementations of timekeeping software. We then took a detailed look at <strong class="source-inline">chrony</strong> and <strong class="source-inline">systemd-timesyncd</strong>. We wrapped up with a quick look at PTP.</p>
			<p>In the next chapter, we'll look at systemd's relationship with boot managers and bootloaders. I'll see you there.</p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor250"/>Questions</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li value="1">In the <strong class="source-inline">chrony.conf</strong> file, which of the following lines will allow <strong class="source-inline">chronyd</strong> to function as a time server?<p>A. <strong class="source-inline">network 192.168.0.0/24</strong></p><p>B. <strong class="source-inline">allow 192.168.0.0/24</strong></p><p>C. <strong class="source-inline">permit 192.168.0.0/24</strong></p><p>D. <strong class="source-inline">listen 192.168.0.0/24</strong></p></li>
				<li>How would you set up <strong class="source-inline">systemd-timesyncd</strong> to function as a time server? (We will assume that we're on the <strong class="source-inline">192.168.0.0/24</strong> network.)<p>A. Add a <strong class="source-inline">network 192.168.0.0/24</strong> line to the <strong class="source-inline">timesyncd.conf</strong> file.</p><p>B. Add a <strong class="source-inline">permit</strong> <strong class="source-inline">192.168.0.0/24</strong> line to the <strong class="source-inline">timesyncd.conf</strong> file.</p><p>C. Add an <strong class="source-inline">allow</strong> <strong class="source-inline">192.168.0.0/24</strong> line to the <strong class="source-inline">timesyncd.conf</strong> file.</p><p>D. You can't.</p></li>
				<li>For dealing with PTP, which of the following clock types allows messages to flow between the PTP master clock and the client machines on the same VLAN?<p>A. Boundary clocks</p><p>B. Grandmaster clocks</p><p>C. Router clocks</p><p>D. Transparent clocks</p></li>
				<li>When dealing with PTP, which service causes a machine's system clock to synchronize with the PTP hardware clock in the network adapter?<p>A. phc2sys</p><p>B. ptp4l</p><p>C. ptp</p><p>D. clock</p></li>
			</ol>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor251"/>Answers</h1>
			<ol>
				<li value="1">B</li>
				<li>D</li>
				<li>D</li>
				<li>A</li>
			</ol>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor252"/>Further reading</h1>
			<p>To learn more about the topics covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li>GPS clocks: <a href="https://timetoolsltd.com/category/gps-clocks/">https://timetoolsltd.com/category/gps-clocks/</a></li>
				<li><strong class="source-inline">chrony</strong> versus <strong class="source-inline">systemd-timesyncd</strong>: <a href="https://unix.stackexchange.com/questions/504381/chrony-vs-systemd-timesyncd-what-are-the-differences-and-use-cases-as-ntp-cli">https://unix.stackexchange.com/questions/504381/chrony-vs-systemd-timesyncd-what-are-the-differences-and-use-cases-as-ntp-cli</a></li>
				<li><strong class="source-inline">chrony</strong> versus <strong class="source-inline">ntp</strong>: <a href="https://chrony.tuxfamily.org/comparison.html">https://chrony.tuxfamily.org/comparison.html</a></li>
				<li>PTP versus NTP: <a href="https://www.masterclock.com/support/library/network-timing-ntp-vs-ptp">https://www.masterclock.com/support/library/network-timing-ntp-vs-ptp</a></li>
				<li>Red Hat's official <strong class="source-inline">chrony</strong> documentation: <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/using-chrony-to-configure-ntp">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_basic_system_settings/using-chrony-to-configure-ntp</a></li>
				<li>Introduction to the Precision Time Protocol: <a href="https://youtu.be/ovzt3IUFbyo">https://youtu.be/ovzt3IUFbyo</a></li>
				<li>Precision Time Protocol Clock Types: <a href="https://youtu.be/rbb9DcIGLKY">https://youtu.be/rbb9DcIGLKY</a></li>
			</ul>
		</div>
	</body></html>