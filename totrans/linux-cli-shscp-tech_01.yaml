- en: '*Chapter 1*: Basics of Shell and Text Terminal'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An ancient Chinese proverb states that *A journey of a thousand miles begins
    with a single step*. This chapter is going to be that single, first step on our
    journey to mastering the Linux **command-line interface** (**CLI**) and **shell
    scripting**. Specifically, we're going to learn how to use Terminal, the shell,
    some basic commands, and one very handy utility to work on many things at once,
    called **screen**.
  prefs: []
  type: TYPE_NORMAL
- en: As you progress further through the book, you'll notice that we will be using
    these concepts a lot, as they're the basis for what we're going to do in the later
    chapters. When dealing with systems administration, we can usually do a lot more
    in some kind of CLI than in any kind of **graphical user interface** (**GUI**).
    This stems from the idea of the programmability of a *CLI* versus the *static*
    nature of most GUIs in IT. Furthermore, a utility such as screen will make our
    life in the CLI a lot easier, as we're going to be able to deal with multiple
    virtual screens at the same time, thus enhancing our productivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in short, we''re going to deal with the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the user shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Bash shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the most common shell commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `screen`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For these recipes, we''re going to use two Linux machines – in our case, it''s
    going to be two VMware virtual machines with *Ubuntu* (*20.04 Focal Fossa*). Let''s
    call them `cli1` and `gui1`, and as the book progresses, we''re going to add some
    more, as our topics grow in complexity. So, all in all, we need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: VMware Player, Workstation, Fusion, or ESXi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu 20.04 Focal Fossa installation ISO file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bit of time to install these two virtual machines without the GUI (the `cli1`
    machine) and with the GUI (`gui1`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the installation process is finished, we're going to start with shell
    basics – our very next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's briefly discuss various **shell** access methods. It can be as
    simple as just installing a virtual machine with Linux that's running text mode
    only, but it could also be a virtual machine with the GUI. That would require
    us doing something to have access to text mode; so, let's learn about these different
    ways of getting access to the shell.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to understand *why* accessing the shell is so important.
    The reasoning behind this is simple, which is that we can do a lot more in the
    shell than in the GUI. In the second part of this book, we're going to dig deeper
    into the concept of shell scripting, and then it's going to become obvious how
    that applies to our statement about being able to do a lot more in the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For starters, we need to deploy our two virtual machines. We can actually install
    both of these machines as text-mode machines with the OpenSSH server (the installation
    process asks about OpenSSH at one point). Then, we could add the GUI to the `gui1`
    machine so that we can work with that, too. We do that by typing a couple of commands
    into the `gui1` machine after logging in as `student` (which is the username we
    came up with for this example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`sudo` is going to ask us for the `student` user password (it can be any user
    that you created during the installation process; `student` is just something
    that we used in our example). When the **tasksel TUI** interface starts, we will
    select the **Ubuntu desktop** package set, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Ubuntu desktop package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.1_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – Ubuntu desktop package
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from *Figure 1.1*, you need to select **Ubuntu desktop** by using
    the arrow keys and spacebar to select from the menu, then use *Tab* or the arrow
    keys to select **Ok** and press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now discuss how to access the shell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we deployed our Ubuntu machine with default options, we''re going to be
    faced with text mode by default. To access the shell and have the capability to
    do something with our Linux virtual machine, we need to type in our *username*
    and *password*. It needs to be the username or password that we typed in during
    the installation process. In our virtual machine, the user named `student` was
    created, with the preassigned `student` password. When we successfully log in,
    we''re faced with the regular text mode and associated shell, as in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Accessing the CLI from text mode after logging in'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.2_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – Accessing the CLI from text mode after logging in
  prefs: []
  type: TYPE_NORMAL
- en: 'If, however, we did a GUI installation, there are three different ways of accessing
    the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could start a text Terminal in **GNOME** (**GNOME Terminal**) and use the
    shell from there. On the plus side, it gives us a GUI-like look and feel that
    might be a bit more user-friendly to a lot of people. On the downside, we''re
    rarely going to find a GUI on Linux servers in production environments, so it
    might be a case of *learning bad habits*. To start GNOME Terminal, we can either
    use the built-in GNOME search function (by pressing the *WIN* key) or just right-click
    on the desktop and open **Terminal**. The result will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Finding Terminal in the GNOME GUI by using'
  prefs: []
  type: TYPE_NORMAL
- en: the WIN key to search for the Terminal keyword
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.3_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – Finding Terminal in the GNOME GUI by using the WIN key to search
    for the Terminal keyword
  prefs: []
  type: TYPE_NORMAL
- en: We could just switch to a text-based text console, as Linux doesn't stop us
    from using text consoles when we deploy the GUI. For that, we need to press a
    dedicated key combination that is going to get us to one of those text consoles.
    For example, we can press the *Ctrl* + *Alt* + *F3* key combination. That is going
    to take us to text mode, specifically, to the text console number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There, we can log in and start typing our commands. The result will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Switching to the text Terminal from the GUI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.4_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4 – Switching to the text Terminal from the GUI
  prefs: []
  type: TYPE_NORMAL
- en: We're in the shell again. We can now start using any commands we want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use the `systemctl` command to switch to text mode as a default mode
    for the current session (until the next reboot). We could even use it to make
    the text mode permanent, regardless of the fact that we have full GUI installation.
    To achieve that, in our GUI, we need to log in and then type the following sequence
    of commands into GNOME Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can use the first command if we want to set our Linux virtual machine to
    boot to text mode *by default*. We can use the second command to re-configure
    our Linux machine to switch to text mode *immediately*.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of sets of commands that we used in the previous recipe,
    so let's explain what these commands do so that we can have a clear picture of
    what we were doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first set of commands is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'These three commands are going to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo -i` is going to ask us for the current user''s password. If that user
    has been added to the `sudoers` system (`/etc/sudoers`), that means that we can
    use the current user''s password to log in as root and use administrative privileges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apt-get -y install tasksel` will install the `tasksel` application. The main
    purpose of this application is to simplify package deployment. Specifically, we
    are going to use it in the next step to deploy an *Ubuntu desktop* set of packages
    (multiple hundreds of packages). Imagine typing all the `apt-get` commands for
    that deployment procedure manually!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tasksel` command is going to start the tasksel application, which will
    be used to deploy the necessary packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second set of commands do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: '`systemctl set-default multi-user.target` will set text mode as the default
    boot target. The translation of this is that our Linux machine will boot in text
    mode by default only when it becomes valid after the next reboot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`systemctl isolate multi-user.target` will switch us to text mode immediately.
    It''s completely different from the `set-default` procedure, as it has nothing
    to do with the state of our Linux machine post-reboot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need more information about `apt-get`, `tasksel`, or `systemctl`, we
    suggest that you visit these links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apt-get`: [https://help.ubuntu.com/community/AptGet/Howto](https://help.ubuntu.com/community/AptGet/Howto)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tasksel`: [https://help.ubuntu.com/community/Tasksel](https://help.ubuntu.com/community/Tasksel)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`systemctl`: [https://www.liquidweb.com/kb/what-is-systemctl-an-in-depth-overview/](https://www.liquidweb.com/kb/what-is-systemctl-an-in-depth-overview/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the user shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned about how to access the shell, let's configure it for
    our comfortable use. We're going to see a couple of examples so that we can understand
    how customizable the Linux shell is. Specifically, we're going to customize the
    look and feel of our prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just need to keep our virtual machines up and running.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to edit a file called `/home/student/.bashrc`. Before we do that,
    let''s create a backup copy of the `.bashrc` file, just in case we make some mistakes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we edit this file, make sure that you take note of how the prompt looks
    at this point. If you''re logged in as `student` to the `cli1` machine, your prompt
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s edit the `.bashrc` file by using `nano`. Type in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we type in this command, we''re going to open `.bashrc` in the nano editor.
    Let''s scroll all the way to the end of this file, which should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – .bashrc default content'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.5_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5 – .bashrc default content
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go all the way below the last `fi` and add the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use *Ctrl* + *X* to save the file. Then, when we''re back in the shell,
    let''s type in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we did everything correctly, our prompt should look like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be further customized by using PS1 parameters. Let''s locate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `\u@\H` part represents the `username@host` part of the prompt. The `\A`
    part is for 24-hour time. So, when we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we should get the following state of our prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`19:30` represents time. We could also customize things such as the type of
    font (underlined, normal, dim, bold) and color (black, red, green, and so on).
    Let''s do that now. For example, let''s edit `.bashrc` again and set `PS1` like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Our prompt should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this particular example, `\e[` tells the `PS1` variable that we want to change
    the color of our prompt. `0;31m` means red (`30` is black, `34` is blue, and so
    on). The `[]` enclosed part is our regular prompt, as previously discussed. The
    last bit, `\e[0m`, tells the `PS1` variable that we're done with color modification
    for our `PS1` output.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, touching just one shell variable (`PS1`) can drastically change
    the way we consume text mode in our Linux virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a shell variable, `PS1` can be used to customize the look and feel of our
    shell. Think of it in the way that most users customize their GUI using different
    wallpapers, text sizes, colors, and so on, and it's a natural thing that we do
    because we like what we like. `PS1` is often called a **primary prompt display
    variable**, as described in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The `source` command that we used *executes* `.bashrc`, in the sense that it
    will apply the settings from `.bashrc`. That's why we didn't need to log off and
    log in again, as it would be a waste of time, and the `source` command can help
    us with that.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now add some more settings to our `.bashrc` file, as there are many more
    things that we can customize.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Bash shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We played with the `PS1` variable and configured it so that it's more to our
    liking. Let's now use more `.bashrc` settings to configure our Bash shell even
    further.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to leave our virtual machines running. If they are not powered on, we
    need to power them back on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s discuss how to change the following shell parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Add some custom aliases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we open the `.bashrc` file again, we can do some additional magic with it.
    First, let''s add a couple of aliases. Close to the end of the `.bashrc` file,
    there''s a section with a couple of aliases (`ll`, `la`, and `l`). Let''s add
    the following lines to that part of the `.bashrc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will introduce five new aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: To see a list of processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To filter processes according to the keyword to be typed in after `pfilter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start the service; service name to be typed after `start`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To stop the service; service name to be typed after `stop`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To enable the service; service name to be typed after `ena`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, using aliases can make our typing shorter and the administration
    process simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Adjust the size of the Bash history.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `.bashrc` file, there''s a section similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we want the Bash shell to remember more than the last 1,000 typed commands
    in the current session (`HISTSIZE`), and to save more than 1,000 commands in the
    history file (called `.bash_history`), we can change the values of these variables,
    let's say to `2000` and `2000`.
  prefs: []
  type: TYPE_NORMAL
- en: Adjust the `PATH` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's say that we want to add a custom path to our existing `PATH` variable.
    For example, we installed our custom application in the `/opt/bin` directory,
    and we don't want to call that application by using the full path every single
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to edit the `.profile` file for this, as the `PATH` variable for our
    current user is set there. So, open the `.profile` file in the editor and add
    the following line to the end of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Set our default editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s add the following two lines to the `.bashrc` file, at the end of the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This would set nano as our preferred default editor.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Bash shell has a set of reserved variables that we can use solely for Bash
    purposes. Some of these reserved variables include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PS1`, `PS2`, `PS3`, and `PS4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HISTFILESIZE` and `HISTSIZE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VISUAL` and `EDITOR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OLDPWD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PWD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are reserved for specific Bash functions, so we shouldn't create custom
    variables with these names. You can learn more about these reserved variables
    from the link provided in the *There's more…* section.
  prefs: []
  type: TYPE_NORMAL
- en: As far as PS variables are concerned, we can consider them to be our entry into
    customization of the Bash shell. That especially goes for the PS1 variable, as
    it's the variable that's most commonly used. We can use all of these variables
    to set Bash to suit our own needs as we don't have to use predefined global configuration
    only. As time goes by, more and more Linux system administrators create their
    own, customized configurations for Bash as it increases the convenience of using
    the Bash shell and their own productivity.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we need to learn more about Bash reserved variables and PS variables, we
    can check the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://access.redhat.com/solutions/505983`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the most common shell commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now switch our attention to learning a basic set of **Linux shell commands**.
    We're going to discuss commands to manipulate files and folders, processes, archives,
    and links. We'll do that via a scenario that is going to involve many steps.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We still need the same virtual machines as with our previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order for us to be able to use shell commands, we have to start the shell.
    If we''re using the CLI, we just need to log in and we''re going to enter the
    shell session. If we''re using a GUI approach, we have to find a GUI Terminal
    in our application menu. After that, we can start typing commands:'
  prefs: []
  type: TYPE_NORMAL
- en: For starters, let's use a basic set of commands to work with files and directories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s list the content of the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Standard output for the ls -al command with all the pertinent
    information'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.6_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.6 – Standard output for the ls -al command with all the pertinent information
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a directory called `directory1` and a stack of five files
    called `test1` to `test5`. That''s what the `touch` command does – it creates
    empty files. Then, let''s copy these files to that directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, let''s create a directory called `directory2` and move files 1-5
    to `directory2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s check the amount of used disk space in `directory1` and `directory2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s check the capacity of our current disk (the `-h` switch provides us
    with a nice, human-readable output):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next stack of commands is related to links known as **hard links** and **soft
    links**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For creating hard and soft links, let''s log in to our `cli1` virtual machine
    and log in as `root`. The overall concept of hard and soft links will be explained
    a bit later in this chapter. So, create a temporary directory and use some files.
    We''ll just use an existing file as it''s more than enough for this scenario (the
    `.bashrc` file):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s now check the beginning and end of one of these files. For example,
    let''s use `/tmp/.bashrc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s now check the tail end of the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The next step is going to involve checking running processes and the system
    state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's now use commands to check the load our system currently has, find some
    processes, and kill some of them for fun.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s check the load (uptime command) and find the top 20 most time-consuming
    processes (the `ps` command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s find a specific process by name and kill it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We're done with this part of the recipe. Let's now discuss the next part of
    this recipe, which is about administering users and groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using shell commands for user and group administration, let''s first go through
    the list of commands that we''re going to use in this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`useradd`: Command that''s used to *create* a local user account'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usermod`: Command that''s used to *modify* a local user account'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userdel`: Command that''s used to *delete* a local user account'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupadd`: Command that''s used to *create* a local group'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupmod`: Command that''s used to *modify* a local group'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupdel`: Command that''s used to *delete* a local group'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`passwd`: Command that''s most often used to assign passwords to user accounts,
    but it can be used for some other scenarios (for example, locking user accounts)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chage`: Command that''s used to manage user password expiry.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let''s create our first users and groups by using the `useradd` and `groupadd`
    commands with a scenario. Let''s say that our task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create four users called `jack`, `joe`, `jill`, and `sarah`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create two user groups called `profs` and `pupils`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-configure the `jack` and `jill` user accounts to be members of the `profs`
    group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-configure the `joe` and `sarah` user accounts to be members of the `pupils`
    group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign a standard password to all the accounts (we're going to use `P@ckT2021`
    for this purpose).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure user accounts so that they have to change their password on the next
    login.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set a specific expiry data for the `profs` users group – the minimum number
    of days before password change set to `15`, the maximum number of days before
    forced password change set to `30`, the warning for password change needs to start
    a week before it expires, and set the expiry date for accounts to 2022/01/01 (January
    1st, 2022).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set a specific expiry data for the `pupils` users group – the minimum number
    of days before password change set to `7`, the maximum number of days before forced
    password change set to `30`, the warning for password change needs to start 10
    days before it expires, and set the expiry date for accounts to 2021/09/01 (September
    1st, 2021).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the `profs` group to be called `professors` and the `pupils` group to
    be called `students`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first task is to create the user accounts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create entries for these four users in the `/etc/passwd` file (where
    most of the users' information is stored – username, user ID, group ID, default
    home directory, and default shell) and the `/etc/shadow` file (where users' passwords
    and aging information are stored).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to create the groups:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create entries for these groups in the `/etc/group` file, where the
    system keeps all the system groups.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to manage users' group membership, for both the `professors`
    and `students` user groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we do that, we need to be aware of one fact. There are two distinctive
    local group types, a **primary group** and a **supplementary group**. A primary
    group is important in terms of being the key parameter used when creating new
    files and directories, as the users primary group will be used by default for
    that (there are exceptions, as we'll mention in *the Setting up the Bash shell
    recipe* in this chapter, about umask, permissions, and ACLs). A supplementary
    group is important when dealing with sharing files and folders and related scenarios
    and exceptions. This is what's usually used for some additional settings for more
    advanced scenarios. These scenarios are going to be explained partially in the
    aforementioned *Setting up the Bash shell recipe* in this chapter, as well as
    in recipes about NFS and Samba in [*Chapter 9*](B16269_09_Final_PD_ePub.xhtml#_idTextAnchor206)*,
    An Introduction to Shell Scripting.*
  prefs: []
  type: TYPE_NORMAL
- en: Primary and supplementary groups are stored in the `/etc/group` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve gotten that out of the way, let''s modify our users'' settings
    so that they belong to *supplementary* groups as assigned by the scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s now check how that changes the `/etc/group` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Entries in the /etc/group file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.7_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.7 – Entries in the /etc/group file
  prefs: []
  type: TYPE_NORMAL
- en: The first four entries in the `/etc/group` file were actually created when we
    used the `useradd` command to create these user accounts. The next two entries
    (except for the last part, after the `:` sign) were created by the `groupadd`
    commands. Entries after the `:` sign were created after the `usermod` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now set their initial password and set a forced password change on the
    next login. We can do this in a couple of different ways, but let''s learn the
    more *programmatic* approach to doing this, by echoing a string and using it as
    the plain-text password for a user account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The echo part, without the rest of the command, would just mean typing `P@ckT2021`
    in to a Terminal, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In CentOS and similar distributions, we could use the `passwd` command with
    the `--stdin` parameter, which would mean that we want to add a password for the
    user account via standard input (keyboard, variables, and so on). In Ubuntu, this
    is not available. So, we can echo the `username:P@ckT2021` string to the shell
    and pipe that to the `chpasswd` command, which achieves just that purpose; instead
    of outputting the string to our Terminal, the `chpasswd` command uses it as standard
    input into itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set the expiry date for professors and students. For this purpose, we
    need to learn how to use the `chage` command and some of its parameters (`-m`,
    `-M`, `-W`, and `-E`). In short, they mean the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we use the `-m` parameter, that means that we want to assign the minimum
    number of days before the password change is *allowed*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use the `-M` parameter, that means that we want to assign the maximum
    number of days before the password change is *forced*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use the `-W` parameter, that means that we want to set the number of warning
    days before password expiration, which in turn means that the shell is going to
    start throwing us messages about needing to change our password before it expires.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use the `-E` parameter, that means that we want to set account expiration
    to a certain date (YYYY-MM-DD format).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now translate that into commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s modify the groups to their final settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These commands will only change group names, not their other data (such as
    group ID), which is going to be reflected in our users'' information, as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Checking created users'' settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.8_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.8 – Checking created users' settings
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, `jack` and `jill` are members of a group that's now called `professors`,
    while `joe` and `sarah` are now members of a group called `students`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We deliberately left the `userdel` and `groupdel` commands for last, as these
    come with some caveats and shouldn''t be used lightly. Let''s create a user called
    `temp` and a group called `temporary`, and then let''s delete them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This will work just fine. The thing is, because we used the `userdel` command
    without any parameters, it will leave the user's home directory intact. Since
    users' home directories are usually stored in the `/home` directory, by default
    that means that the `/home/temp` directory is still going to be there. When deleting
    users, we sometimes want to delete a user but not their files. If you specifically
    want to delete a user account and all the data from that user account, then use
    the `userdel -r username` command. But think twice before doing it!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's now discuss the more complex part of the previous recipe, which is **symbolic
    links** and **hard links**.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `ln` command without extra parameters tries to create a hard link.
    Using `ln` with the `-s` parameter tries to create a soft link. We can clearly
    see that there are some errors in that part of our recipe. Let's discuss them
    now by going back from the top.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we''ve finished typing in the first six commands from the recipe (ending
    with `ls -al`), which we''re using to list the folder contents, the end result
    should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Original file, hard link and soft link'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.9_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.9 – Original file, hard link and soft link
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some conclusions that can be reached just by interpreting this previous
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: The `content` file and the `hardlink` file have the same size (1,349 bytes,
    in our case).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `content` file and the `softlink` file don't have the same file size (1,349
    bytes versus 11 bytes here).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soft links are marked differently by default (usually, a different color in
    the Terminal).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, for the purposes of building up this explanation, let''s delete the original
    `content` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The end result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10 – Removing the original file leaves interesting consequences'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.10_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.10 – Removing the original file leaves interesting consequences
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the original file is gone, while the hard link is still here
    and has the same size. On the other hand, the soft link changed color (from green
    to red), indicating that there's some kind of problem. Interesting, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the `hardlink.cfg` file in the **vi editor**, the content is definitely
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11 – The hardlink.cfg file still has the original content'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.11_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.11 – The hardlink.cfg file still has the original content
  prefs: []
  type: TYPE_NORMAL
- en: The reason why this happens comes from the way in which filesystems work. When
    we delete a file, we don't delete the content of the file, we just delete an entry
    in the filesystem table (filename) that points to the content of the file. The
    reason for this is simple in that it's about speed and convenience. If the operating
    system actually removed the file content, it would need to free its blocks and
    write zeros to them. That would take a lot of time. Furthermore, it would complicate
    file recovery.
  prefs: []
  type: TYPE_NORMAL
- en: This is where hard links and soft links come into play. The main difference
    between them is something that we can easily deduce from the scenario. It's the
    fact that hard links point to the actual file content, while soft links point
    to the original filename. That also explains the size difference. Hard links must
    be the same size as the original file (as the original file and hard link point
    to the content of the same content, therefore the same size). The reason why `softlink.cfg`
    only consumes 11 bytes on the filesystem is simple; it's that the `content.cfg`
    string needs 11 bytes to be saved to the filesystem table.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also the reason why there are two other major differences between hard
    links and soft links:'
  prefs: []
  type: TYPE_NORMAL
- en: Hard links cannot point to a directory and they have to point to a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hard links cannot go across partitions. We can't reference/see data from the
    first mounted partition if we look from the perspective of the second partition.
    The second partition has its own filesystem table (which contains entries pointing
    to the actual content on that partition) that's completely independent of the
    filesystem table of the first partition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cool thing, going back to our recipe, is that we can easily recover the
    original file. If we go back to the `/root/links` directory, we can just copy
    the `hardlink.cfg` file to `content.cfg` and our original file and the corresponding
    symbolic link are back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The end result will be just like earlier, when we created the `content.cfg`
    file and the hard link and soft link pointing to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12 – Our original file and soft link are back'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.12_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.12 – Our original file and soft link are back
  prefs: []
  type: TYPE_NORMAL
- en: We will use these commands throughout this book, so we need to make sure that
    we master using them before we move on to the next chapters. But for the time
    being, we'll add just one more command to the stack. It's the subject of our next
    recipe, known as **screen**.
  prefs: []
  type: TYPE_NORMAL
- en: Using screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**screen** is one of those text utilities that was incredibly popular in the
    1990s and 2000s, with its popularity shrinking after that. System administrators
    often have to open multiple consoles on the same machine or use any of those multiple
    consoles to connect to external machines. Let''s see how screen fits into this
    scenario.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before starting with this recipe, we need to make sure that we have screen
    on our Linux machine. So, we need to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: After that, we're ready to follow our recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to start a regular text Terminal (this can be done in the GUI as well,
    but it can be considered as a bit of a less-effective way to use screen real estate).
    Then, we just need to type in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When we start screen, it is going to throw us a long piece of text about licensing
    and other less-than-interesting subjects, with a couple of important pieces of
    information at the bottom of the screen. It will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – Basic screen information'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.13_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.13 – Basic screen information
  prefs: []
  type: TYPE_NORMAL
- en: The only part of this output that's really interesting to us is **Capabilities**.
    It tells us that with screen, we can do some cool stuff, such as copy, detach,
    and work with fonts. But even without most of these advanced features, screen
    enables us to open multiple virtual text Terminals, within the limits of one text
    Terminal. Then, it enables us to detach (something like putting the screen process
    in the background), log off, come back later, log in, and re-attach our session
    to screen. That enables some cool things, such as leaving a permanent set of virtual
    text consoles open for the most common, mostly used use cases.
  prefs: []
  type: TYPE_NORMAL
- en: After we press the *Enter* key on the screen shown in the previous screenshot,
    we're going to be thrown into the text mode again. This is screen's first virtual
    text console. If we want to use additional virtual text consoles, we can create
    them by using the *Ctrl* + *A* + *C* key combination. Every one of these virtual
    text consoles is numbered from 0 onward. If we create five virtual text consoles
    in screen (numbered 0-4) and we're in screen 4 and want to jump to screen 0, we
    can easily do that in two ways. The first one involves *absolute* addressing,
    in other words, we can tell screen that we want to go specifically to screen 0
    (by using *Ctrl* + *A* + *0*). The second way to go from screen 4 to 0 is to use
    a *circular* approach. When we use the *Ctrl* + *A* + spacebar key combination,
    we're circling through screens in a subsequent fashion – 0, then 1, then 2, and
    so on. If we're on screen 4 and we want to go to 0, because we don't have a screen
    5, we can just circle from 4 to 0 by using *Ctrl* + *A* + spacebar.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to log off, we can detach our screen. The key combination for that
    is *Ctrl* + *A* + *D* (detach screen). If sometime later we want to go back to
    our screens, we need to type in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We can also copy-paste in screen by using the *Ctrl* + *A* + *]* key combination,
    then scroll and find the bit of text that we want to start copying, use the spacebar
    to start copying and to end the copying process, and then the *Ctrl* + *A* + *]*
    combination if we want to paste text somewhere. It takes a bit of practice, but
    it's also very usable. *Just imagine doing stuff like that in 1996!*
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: When working with screen, we suggest that you first press *Ctrl* + *A*, let
    those keys go, and then press whichever key you need to go wherever you want to
    go on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: screen works by creating multiple detachable virtual text consoles. These consoles
    remain active until there's a process that kills screen, or until the system reboots.
    Keeping in mind that most production environments based on Linux servers don't
    have a GUI, having the capability to connect to a server once and then open multiple
    screens comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'screen requires a bit of trial and error and getting used to. We recommend
    that you check the following link to learn more:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://www.howtogeek.com/662422/how-to-use-linuxs-screen-command/`'
  prefs: []
  type: TYPE_NORMAL
