- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software Installation and Package Repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most Linux distributions only install the bare minimum set of software by default
    and assume that the user will install additional software later. These days, installing
    software on Linux is very easy, thanks to package repositories and high-level
    package managers that can search, download, and install packages over the network.
    However, it’s important to understand how package files are organized internally
    and how package managers work since it helps administrators inspect packages,
    diagnose problems, and fix installation issues if they occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Software installation, packages, and dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package repositories and high-level package managers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System upgrade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software installation, packages, and dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The definition of a software package is quite broad. In the early days of computing,
    when computers were exclusively used to solve mathematical problems, most programs
    were written completely from scratch to run on a specific computer, so there was
    no need for installation and thus no need for the concept of software packaging.
    For a long time afterward, software was still synonymous with executable files.
    Installing a software product that consists of a single executable file is trivial
    —just copy it to the target computer.
  prefs: []
  type: TYPE_NORMAL
- en: Such software certainly exists today. For example, the maintainers of **jq**
    (a popular tool for extracting data from JSON files) provide standalone, statically
    linked executables that combine the program and all libraries it needs into a
    monolithic file and can run on any Linux system, so any user can just download
    it from its website ([https://stedolan.github.io/jq/download/](https://stedolan.github.io/jq/download/))
    and start using it.
  prefs: []
  type: TYPE_NORMAL
- en: However, many software projects consist of multiple executable files and often
    require data files as well. A spell checker program, such as **Aspell**, requires
    dictionary files to work. In video games, the executable is often just a small
    part, often the smallest one compared to game assets such as models, textures,
    and sound files. To make the software product work as intended, all those files
    need to be distributed and installed together as a software package.
  prefs: []
  type: TYPE_NORMAL
- en: In early operating systems, the installation often just consisted of copying
    all files of a software product to a directory. That’s the purpose of the `/opt`
    directory still found in many Linux systems. To install a hypothetical software
    package, Foo 1.0, an administrator may unpack its release archive (say, `foo_1.0.tar.gz`)
    to `/opt/foo/` (usually, with `tar --xf foo_1.0.tar.gz --directory /opt/foo/`),
    and the directory structure inside `/opt/foo` will be completely defined by the
    application developers of Foo rather than by the operating system itself.
  prefs: []
  type: TYPE_NORMAL
- en: In modern operating systems, simply copying files is rarely enough because it
    will not properly integrate the newly installed software into the operating system.
    Even a package that provides a single console command needs to place it in a directory
    that is already in `$PATH`, or modify the `$PATH` environment variable accordingly.
    Software with a graphical user interface also needs to correctly register itself
    in the desktop environment application menus and optionally create desktop icons.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, operating systems started demanding a certain structure from
    software packages. In Microsoft Windows and many other systems, they would still
    usually come as custom executable programs that would unpack and copy the files
    and also execute scripts to register the package with the operating system. Developers
    of Linux software also practice this approach sometimes, and there are frameworks
    for creating executable installers, such as **makeself** ([https://makeself.io/](https://makeself.io/)).
  prefs: []
  type: TYPE_NORMAL
- en: That approach gives software package authors complete control over the installation
    process, but it also has many disadvantages. First, uninstalling software that
    was installed that way isn’t always reliable. If installer developers aren’t careful
    to make it clean up all files created at installation time, users may be left
    with leftover files they will have to delete by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Second, each package needs to implement its own update checking and installation
    mechanism. Before the widespread availability of broadband internet access, when
    software updates were usually distributed on physical media such as floppy disks
    or CDs, that wasn’t a big concern; but these days, when most users have regular
    internet access, they benefit from online updates, and many software products
    such as web browsers must be kept up to date to keep them protected from security
    threats.
  prefs: []
  type: TYPE_NORMAL
- en: Third, few programs are written from scratch anymore and most make extensive
    use of third-party libraries, so they have dependencies. One way to make sure
    the library code is available for the program to call is to make it a part of
    the executable itself. That approach is known as static linking. It’s foolproof
    in that there is no way to install such an executable incorrectly, but it leads
    to greatly increased memory and drive space consumption. For this reason, most
    programs are dynamically linked with external library files, but for them to work,
    they need to make sure that files of the correct versions of all required libraries
    exist on the system. If every software package is standalone and responsible for
    its own installation, the only way to do that is to bundle all libraries with
    the package (which is only marginally better than linking them statically, in
    terms of drive space usage) or require the user to find and install all libraries
    manually (which is very inconvenient for the user).
  prefs: []
  type: TYPE_NORMAL
- en: With proprietary software that isn’t redistributable and usually isn’t available
    in source code form, bundling all dependencies is usually the only option since
    executables need to be recompiled for use with different library versions. Different
    Linux distributions may include different versions of libraries due to different
    release cycles and software inclusion policies (some distributions are focused
    on stability and will only include older but proven versions, while others may
    choose to include the latest libraries even if they aren’t well tested).
  prefs: []
  type: TYPE_NORMAL
- en: However, with open source software that is available in source code form and
    can be modified and redistributed, there are many more possibilities to reuse
    library files and create a cohesive system. To make that possible, distribution
    maintainers developed modern package managers.
  prefs: []
  type: TYPE_NORMAL
- en: Package managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A package manager is a program that is responsible for the installation, upgrade,
    and removal of software packages. In the older approach where software developers
    are responsible for the installation procedure, they are free to choose whether
    to distribute their software as an executable that unpacks and installs files
    or as an archive that the user must unpack manually, and the choice of archive
    and compression algorithms is also on the developers.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, package managers usually use a very precise definition of a software
    package. To make a software project installable with a package manager, its maintainer
    must create a package file that follows a set of guidelines for its internal structure.
    Apart from the files needed for a software product to work, package files also
    contain metadata in a specific format. Metadata files contain information about
    the package, such as its name, version, license, and lists of other packages that
    it depends on.
  prefs: []
  type: TYPE_NORMAL
- en: Package managers limit what software product authors can do at installation
    time. For example, there is no way to let the user specify a custom installation
    directory or choose not to install certain files.
  prefs: []
  type: TYPE_NORMAL
- en: But since they completely control the installation process and every file inside
    the package is accounted for, they can install and uninstall software reliably
    and ensure that there are no files left after uninstallation.
  prefs: []
  type: TYPE_NORMAL
- en: An even bigger advantage is that package managers can automatically track package
    dependencies and either prevent the user from installing a package until all dependencies
    are installed or automatically install those dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different Linux distributions use different package managers. Some of them
    use two different utilities for managing software installations and upgrades:
    a low-level package manager that is responsible for working with package files
    and a high-level tool for automatically downloading packages over the network
    and managing upgrades.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Historically, that was the dominant approach: before the widespread availability
    of broadband Internet access, automatic download wasn’t feasible, so the first
    package managers developed in the 1990s were only developed to work with local
    package files. The two most popular projects in this category are **rpm** (developed
    by Red Hat) and **dpkg** (developed by the Debian project). For the automated
    installation of packages over the network and automated system upgrades, they
    need to be combined with high-level tools such as YUM, DNF, Zypper, or **Advanced
    Packaging** **Tool** (**APT**).'
  prefs: []
  type: TYPE_NORMAL
- en: Some Linux distributions developed in the 2000s and later use package managers
    that combine both functions and can work with local package files and remote sources
    alike.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can represent current situations with low-level and high-level package managers
    in different distributions as in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Distribution** | **High-level** **package manager** | **Low-level** **package
    manager** |'
  prefs: []
  type: TYPE_TB
- en: '| Debian | APT | `dpkg` |'
  prefs: []
  type: TYPE_TB
- en: '| Ubuntu |'
  prefs: []
  type: TYPE_TB
- en: '| Linux Mint |'
  prefs: []
  type: TYPE_TB
- en: '| Fedora | DNF | `rpm` |'
  prefs: []
  type: TYPE_TB
- en: '| Red Hat Enterprise Linux | DNF, YUM |'
  prefs: []
  type: TYPE_TB
- en: '| openSUSE, SUSE Linux Enterprise Server | Zypper |'
  prefs: []
  type: TYPE_TB
- en: '| Mageia | DNF, urpmi |'
  prefs: []
  type: TYPE_TB
- en: '| Arch Linux | pacman |'
  prefs: []
  type: TYPE_TB
- en: '| NixOS | Nix |'
  prefs: []
  type: TYPE_TB
- en: '| Guix | Guix |'
  prefs: []
  type: TYPE_TB
- en: Table 8.1 – Package managers used in different Linux distributions
  prefs: []
  type: TYPE_NORMAL
- en: 'We will focus on the most popular low-level package managers: `rpm` and `dpkg`.
    Neither of them is inherently superior to the other, but their package file format
    and package management tool interface design choices are quite different. We will
    examine both to compare and contrast them.'
  prefs: []
  type: TYPE_NORMAL
- en: Package files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conventionally, packages come as files in a special format that includes both
    files from the software project that must be installed in the system and metadata
    for the package manager, such as file checksums, lists of dependencies, and system
    requirements for the package (such as CPU architecture). We will look inside `.rpm`
    and `.deb` package files and compare their implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting package files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will examine package files to see what’s inside them and learn how
    to examine and unpack them.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that normally, you will not need to manually download and unpack
    package files! We are doing it only for educational purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting a Debian package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use the GNU `hello` package for our experiments. GNU hello is a demo
    program that simply prints `hello world`—its real purpose is to serve as an example
    of development and packaging practices and show new developers how to write build
    scripts, implement internationalization, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the GNU `hello` package from the latest unstable Debian version
    at [https://packages.debian.org/sid/hello](https://packages.debian.org/sid/hello).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – The hello package information page on the Debian package repository
    website](img/B18575_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – The hello package information page on the Debian package repository
    website
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow an architecture-specific download link such as [https://packages.debian.org/sid/amd64/hello/download](https://packages.debian.org/sid/amd64/hello/download)
    and download the package file from any mirror from the list shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The download page for the hello package for Debian Sid on x86_64
    machines](img/B18575_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The download page for the hello package for Debian Sid on x86_64
    machines
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the latest version is 2.10, so I used this link, but
    it’s not guaranteed to work for future versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `dpkg --info` command, we can view information about the package
    we have just downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Where does `dpkg` get that information from? Notice the `control archive=1868
    bytes` part of the output. A Debian package file is an `ar` archive that consists
    of two compressed `tar` archives glued together. We could certainly extract them
    using the `ar` utility, or even with `dd` (thanks to the simplicity of its format
    and the fact that `dpkg` tells us each archive length in bytes), and unpack them
    by hand, but luckily, `dpkg` has built-in functionality for that. Using `dpkg
    --control` (`dpkg -e`), we can extract the control archive—the part that contains
    package metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don’t specify a custom output directory, `dpkg` will unpack it into a
    subdirectory named `DEBIAN`. It will contain two files: `control` and `md5sums`.
    The control file is where `dpkg --info` (`dpkg -l`) took those fields and their
    values from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `md5sums` file contains hash sums of all files inside the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The MD5 hash sum algorithm is no longer cryptographically secure and must not
    be used to protect files and messages from malicious modification. However, in
    Debian packages, it is used only for protection against accidental file corruption,
    so it’s not a security issue. Protection against malicious modification is provided
    by GnuPG digital signatures, which are checked by the high-level tool—APT.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you only want to list files inside the data archive, you can do it with
    `dpkg --contents` (`dpkg -c`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s also possible to unpack the data archive part of a package file with `dpkg
    --extract` (`dpkg -x`), but in that case, you need to specify where to unpack
    it. To unpack into the current directory, we can use the dot shortcut:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s move on to inspecting an RPM package file and comparing it with what
    we have seen in a Debian package.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting an RPM package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll use Fedora as an example of a distribution that uses RPM packages. The
    place to search Fedora repositories on the web is [https://packages.fedoraproject.org/](https://packages.fedoraproject.org/).
    Enter the name of the package (`hello`, in our case) in the search field and you’ll
    see the package information page.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The hello package information page on the Fedora package repository
    website](img/B18575_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – The hello package information page on the Fedora package repository
    website
  prefs: []
  type: TYPE_NORMAL
- en: 'Fedora uses Rawhide as a code name for the latest unstable version. At the
    time of writing, the version in development is 37\. To find a package download
    link, go to the **Builds** tab, then find a link to the latest build there. We
    can download that package for inspection using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We have provided a sample direct link to the package from Fedora 37, but since
    all URLs and package versions are subject to change, the following command is
    not guaranteed to remain working forever—if you want to download the package,
    visit the [packages.fedoraproject.org](http://packages.fedoraproject.org) website
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: All RPM queries are available through the `--query` option. A good thing about
    RPM is that all query options can be used to inspect either package files or already
    installed packages, depending on the argument. If you give it just a package name,
    it will look for an installed package, but if you specify a package file path,
    it will inspect that file instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with `rpm --query --info`, we can read package metadata. Alternatively,
    that command can be shortened to `rpm -qi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `rpm --query --list` (or `rpm -ql` for short), we can get a list of files
    inside the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Compare and contrast this with the output of `dpkg --contents`, which listed
    MD5 sums for every file. Unlike Debian packages, RPM packages do not contain hash
    sums for every file, but rather a single hash sum of the package archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rpm` command also does not provide options for unpacking RPM packages.
    Instead, it provides two utilities for extracting its data part: `rpm2cpio` and
    `rpm2archive`.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Debian packages, RPM packages do not store metadata as files inside an
    archive, but rather use a custom RPM file header to store it. The archive that
    follows that header only contains files that must be installed. Moreover, while
    `dpkg` uses a familiar `tar` archive format to pack multiple files into one, RPM
    uses a much less common CPIO format.
  prefs: []
  type: TYPE_NORMAL
- en: The `cpio` command is difficult to use. In particular, it needs the user to
    enter the path to every file that must be included in the archive, so it’s impractical
    to use by hand and can only be reasonably used in conjunction with another tool,
    such as `find`. For this reason, `tar` is far more popular because the TAR archiving
    tool can easily pack entire directories in one command, such as `tar cvf file.tar
    /path/to/directory`. However, the CPIO archive file format is simpler to implement,
    doesn’t vary between implementations from different vendors, and has better support
    for special files, such as links and device files, which is why some projects
    have chosen to use it internally. Among those projects are the Linux kernel, which
    uses it for the initial RAM disk, and RPM, which uses it for package files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, the `rpm2archive` utility can convert an RPM package into a compressed
    `tar` archive, so you don’t need to learn how to use `cpio` just to extract files
    from RPM packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s move on to inspecting packages installed in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting installed packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both software project files and the metadata that we have seen inside package
    files are retained in the system when the package is installed. Let’s learn how
    to access information about installed packages and compare it with what we have
    seen inside package files.
  prefs: []
  type: TYPE_NORMAL
- en: Listing all installed packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both `dpkg` and `rpm` provide an option to list all packages installed on the
    system. Since those lists are going to be rather long even for small installations,
    you may want to use them with a pager command such as `less` or a filter such
    as `head`, `tail`, or `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Debian-based systems, the command to list all installed packages is `dpkg
    --list`, or `dpkg -l` for short. The list is sorted alphabetically by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For RPM-based distributions, that command is `rpm --query --all`, or `rpm -qa`.
    Note that RPM does not sort that output alphabetically by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you simply want to check whether a package is installed, RPM provides an
    option to check just that, without outputting any other information, that is,
    `rpm --query` (`rpm -q`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent for Debian-based systems is `dpkg --status` (`dpkg -s`), which
    also prints information about a package if it’s installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If a package is not installed, that command prints an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to retrieve information about an installed package in an RPM-based
    system, you can use the same `rpm -qi` command as we used for inspecting a package
    file; just give it the name of the package rather than a file path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to find out what package a file comes from (or whether it belongs
    to any package at all), there are commands for that task as well. For RPM, it’s
    `rpm --query --file` (`rpm -qf`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For `dpkg`, it’s `dpkg --search` (`dpkg -S`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With RPM, it’s also easy to list all files that belong to a certain package,
    and the command is the same as we have already used to list the contents of a
    package file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For `dpkg`, the equivalent is `dpkg --listfiles` (`dpkg -L`). However, `dpkg`
    also lists all directories where files or subdirectories from that package can
    be found, even top-level directories such as `/etc`, while RPM only shows files
    and directories that were created as a result of installing a package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: However, installing packages and removing them is a much more frequent task
    than inspecting installed ones—let’s learn how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and removing package files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even the man page of `dpkg` warns that unpacking a package to the root directory
    is not the correct way to install it. There are multiple reasons why the installation
    of a package is not as simple as just copying the files from it to the right places.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from copying files, package managers record the package and its files
    in an internal database—that is why commands such as `dpkg --listfiles` and `rpm
    --query --files` can work, and why package managers can reliably delete packages
    without leaving any unused files behind.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, package managers also include safeguards against trying to install
    a package that is guaranteed not to work on the system. For example, this is what
    will happen if you try to install a package built for ARM64 on an x86_64 (Intel
    or AMD64) machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: They will also protect the system from attempts to delete packages that should
    not be deleted, or at least warn the user about the consequences. Since they track
    all dependencies between packages, they can force the removal of packages that
    will become broken if a package they depend on is removed, but by default, they
    will refuse to delete any package if other packages depend on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Debian-based Linux distributions, there’s a concept of essential packages
    that are protected from removal attempts. For example, you will get an error if
    you try to delete Bash since it’s the default system shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If a package is not essential, you will get a list of dependent packages that
    prevent its removal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: RPM has a similar functionality and will not allow the user to install packages
    with unsatisfied (or unsatisfiable, in case of a different architecture) dependencies
    or remove essential packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what an attempt to install a package for a different architecture may
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is what you will get if you try to remove `rpm` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: However, in modern systems, both the installation and removal of packages with
    `rpm` and `dpkg` are an exception rather than a rule. While they prevent the installation
    of packages that have missing dependencies, they do not automate the installation
    of those dependencies, so trying to install a package with a lot of dependencies
    is a very tedious task. If you were to upgrade your system, you’d also have to
    upgrade all packages and their dependencies one by one. That’s the main reason
    why package repositories and high-level package managers were invented.
  prefs: []
  type: TYPE_NORMAL
- en: Package repositories and high-level package managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Online collections of packages for Linux distributions have existed for almost
    as long as the distributions themselves. They saved users’ time searching for
    compiled packages or building software from source, but if a package had dependencies,
    the user would still need to download them all one by one.
  prefs: []
  type: TYPE_NORMAL
- en: The next step for distribution maintainers was to create a format for machine-readable
    metadata from the entire package collection and a tool that would automate that
    process. Since every package contains information about its dependencies, in the
    simplest case, you just need to download them all.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, it’s more complicated. Packages may conflict (for example, because
    they provide an executable with the same name) and there must be a safeguard against
    attempts to install conflicting packages. If a user tries to install a package
    from outside the repository, the repository may not have the right versions of
    its dependencies. Modern high-level package managers check for these and many
    other possible issues, so most of the time the user can just say “*I want a certain
    package installed*” and the tool will do everything that needs to be done to install
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Package repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A package repository in the modern sense is a collection of packages that comes
    with a machine-readable index. The repository index contains information about
    every package. Essentially, an index aggregates the package metadata files we
    have seen when inspecting packages with `dpkg --info` and `rpm --``query --info`.
  prefs: []
  type: TYPE_NORMAL
- en: Websites with information about distribution packages such as [https://www.debian.org/distrib/packages](https://www.debian.org/distrib/packages)
    and [https://packages.fedoraproject.org/](https://packages.fedoraproject.org/)
    are in fact generated from their package repository indices. When we used them
    to look up and download packages, we essentially did by hand what high-level package
    managers can do automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Every distribution has its official repositories, and community- or vendor-supported
    repositories exist for popular distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Debian-based distribution repositories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Repository configuration in Debian-based distributions can be found in the `/etc/apt/`
    directory. The main file is `/etc/apt/sources.list` but there may be additional
    files in `/etc/apt/sources.list.d`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of a `sources.list` file from a Debian 10 (Buster) system.
    Notice that apart from remote repositories, it’s also possible to specify paths
    to repositories on local media such as optical drives. If you install a Debian
    system from a CD or DVD, the installer will add that as a repository entry so
    that you can install additional packages from that disk later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Debian also uses different repository components that you can enable or disable.
    In this example, only the `main` repository is enabled. The `main` repository
    includes essential packages. Apart from them, there are `contrib` and `non-free`
    repositories. The `contrib` repository includes a broad selection of additional
    packages that aren’t as actively maintained as those from `main`. The non-free
    repository contains packages whose licenses don’t qualify as free software—they
    are redistributable, but may have restrictions on modifications or distribution
    of modified versions, or come without source code.
  prefs: []
  type: TYPE_NORMAL
- en: For better or worse, many firmware files required for devices to work are under
    non-free licenses, so in practice, you may always use `main contrib non-free`
    rather than just `main` in Debian repository configuration lines.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the distribution version (`buster`, in this case) is explicitly
    hardcoded in the configuration file and you will need to change it yourself to
    upgrade to a new distribution version.
  prefs: []
  type: TYPE_NORMAL
- en: The repository URL is also set explicitly, usually to the mirror site you chose
    at installation time.
  prefs: []
  type: TYPE_NORMAL
- en: RPM package repositories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fedora and Red Hat Enterprise Linux (and its derivatives such as CentOS and
    Rocky Linux) keep repository files in `/etc/yum.repos.d/`. Most often, there is
    one file per repository. This is an example of the base Fedora repository file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice that there is no explicit reference to the Fedora version anywhere; instead,
    there are placeholder variables such as `$releasever` and `$basearch`. The high-level
    management tools automatically substitute those variables with data from the installed
    system.
  prefs: []
  type: TYPE_NORMAL
- en: There is also an option to make the system use mirror lists instead of single
    mirrors for reliability and load balancing. You can specify either a specific
    mirror in the `baseurl` option or a link to the Metalink protocol to automatically
    get a mirror list instead.
  prefs: []
  type: TYPE_NORMAL
- en: High-level package managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we already discussed, both `rpm` and `dpkg` were developed at a time when
    automatically downloading packages over a network was not feasible for most users
    because most computers only had a slow and intermittent connection to the Internet
    over a dial-up modem. By the end of the 90s, Internet connections had become significantly
    faster, so online package repositories became a logical possibility.
  prefs: []
  type: TYPE_NORMAL
- en: The Debian project developed its high-level package manager named APT in 1998
    and most Debian-based distributions have been using it since then.
  prefs: []
  type: TYPE_NORMAL
- en: RPM-based distributions developed multiple high-level package managers independently.
    One reason for that is that many of the RPM-based distributions were created independently
    in the 90s, while most Debian-based ones are forks of Debian itself that were
    created after the introduction of APT.
  prefs: []
  type: TYPE_NORMAL
- en: Linux distributions maintained by Red Hat Inc. itself went through multiple
    high-level package managers, starting from `up2date`, which was mainly meant for
    their paying customers. That tool was later replaced by YUM, which came from a
    now-defunct distribution named Yellow Dog Linux. Its name originally meant Yellow
    dog Updater, Modified. Later, it was replaced by DNF—since the mid-2010s in Fedora
    and since the eighth release of Red Hat Enterprise Linux in 2019\. Older but still
    supported versions of Red Hat Enterprise Linux and its derivatives continue to
    use YUM. Luckily for users, while YUM and DNF mostly differ in their internal
    implementation, their user interface is almost the same—except for the new features
    of DNF, of course. The name DNF doesn’t officially stand for anything, but originally
    came from **DaNdiFied YUM**.
  prefs: []
  type: TYPE_NORMAL
- en: The design choices of APT and YUM/DNF are very different, and you need to be
    aware of those differences when you switch between them. Let’s learn how to use
    them to install packages.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and removing packages with YUM or DNF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The command to install a package is `dnf install`. Installing a package requires
    administrative privileges, so you need to remember to run all such commands with
    `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: When you run an installation command, YUM and DNF will automatically download
    package index files from the repository, so you don’t need to take any action
    to ensure that you have up-to-date repository metadata. A disadvantage of that
    approach is that sometimes you may have to wait for it to download that metadata,
    which may take a few minutes or more on very slow connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the installation process is completely automated. YUM and DNF will
    show you a list of packages that would be downloaded and installed and how much
    space they would need. If you say `yes`, it will proceed with the download and
    installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Removing a package is also straightforward. Just run `dnf` `remove hello`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike RPM, DNF and YUM do have a concept of protected packages, so they will
    outright refuse to delete essential packages such as `bash` or `rpm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This protection from erroneous user actions is a significant reason to use YUM
    or DNF to remove packages despite the fact that RPM is technically sufficient
    for that task.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and removing packages with APT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'APT uses a different approach to metadata download: it leaves that operation
    to the user. Unlike YUM and DNF, APT will never automatically download repository
    indices, so on a freshly deployed Debian-based system, trying to search for or
    install packages will give you a *package not* *found* error.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'APT consists of sub-tools for different purposes: `apt-get` for repository
    index updates and package actions (such as installing, removing, or listing package
    files), and `apt-cache` for package search. In modern Debian versions, you will
    find a combined tool named `apt`. You may also want to use an alternative frontend
    named `aptitude`, which we will discuss later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can install anything, you need to force the repository index download
    with `apt-get update` or `apt update`. `update` in its name refers only to a metadata
    update, not to a package update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After that, you can search for packages with `apt-cache search` or `apt search`
    and install them with `apt install` or `apt-get install`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with the following command, you can install the `hello` package
    automatically from the repositories, without having to download it by hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'APT also includes protection against the removal of essential packages. Trying
    to remove `bash`, for example, will require a special confirmation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Needless to say, you should not do this unless you are absolutely certain that
    what you are doing is safe—for example, if you have made sure that every user
    uses a shell other than Bash and there are no scripts in the system that require
    Bash rather than a POSIX Bourne shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing a non-essential package, such as `hello`, will not raise any such
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There is also the `apt-get purge` command, which removes not only executables
    and data files but also all configuration files associated with the package. Most
    of the time, `apt-get remove` is sufficient, but to remove a package such as a
    web server, you may prefer `apt-get` `purge` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both APT and YUM/DNF provide a search command, so if you don’t know the exact
    name of a package, you can search for it. However, they search for a pattern in
    every field but only display the name and the short description by default, so
    search results may look odd and include entries that seem to have nothing to do
    with your request.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s try to search for the `hello` package on a Debian system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, you may want to search for a package that provides a certain command
    or a library file (for example, if you are getting a script error that complains
    that it wasn’t found).
  prefs: []
  type: TYPE_NORMAL
- en: 'In YUM and DNF, there is a built-in option for that: `whatprovides`. It supports
    both exact file paths and wildcard matches. Suppose you want to install a package
    that provides a `hello` command. Executable files of commands are always in some
    `bin/` directory, but we don’t know whether it’s going to be `/bin`, `/usr/bin`,
    `/usr/sbin`, or something else. However, we can search for `*/bin/hello` to find
    any executable with that name in any package. It will include some irrelevant
    results, but it will tell us what we want to know:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In Debian-based systems, it’s not that simple. You will need to install an optional
    `apt-file` tool (`apt-get install apt-file`) and run `apt-file update` to download
    additional indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also doesn’t support wildcard matching, so if you don’t know the exact path,
    you will need to supply a Perl-compatible regular expression for your search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, YUM and DNF provide more functionality out of the box, while
    APT may require installing additional packages. Nonetheless, it should be possible
    to execute the same search operations with all of those tools.
  prefs: []
  type: TYPE_NORMAL
- en: System upgrade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another advantage of high-level package managers is that they automate the upgrade
    of the entire system (or at least packages installed from repositories).
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading a system with YUM or DNF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The command to upgrade all packages is `dnf upgrade` or `yum upgrade`. To force
    a repository index download, you can add `--refresh`. In some cases, you will
    also want to remove conflicting or outdated packages to complete an upgrade; in
    that case, you may need `dnf` `upgrade --allowerasing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you say `yes`, it will automatically download new package versions and overwrite
    old packages with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upgrading a Fedora system to a new distribution version requires a different
    procedure, however. This is only possible with DNF and needs a plugin available
    from Fedora repositories. The command sequence to upgrade an older system to Fedora
    36 (the current version in 2022) would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `dnf system-upgrade download --releasever=36` command will download all
    packages required to upgrade to a new version and run a transaction check. On
    rare occasions, you will need to remove certain packages if they are no longer
    available in a new Fedora version. If the check is successful, you can start the
    upgrade procedure with `dnf system-upgrade reboot`—your system will boot into
    a minimal environment to perform the upgrade, then boot to the new Fedora version
    as normal.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading a system with APT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'APT includes upgrade commands with different functionality instead of using
    modifier options as YUM and DNF do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apt upgrade` and `apt-get upgrade` will only upgrade installed packages to
    newer versions if they are available, but never perform any other actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apt full-upgrade` or `apt-get dist-upgrade` may remove packages if it’s required
    to upgrade the system as a whole'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the time, you should use `apt-get dist-upgrade` because when you update
    packages within the same distribution version, package removal events are incredibly
    rare, while if you upgrade to a new distribution version, there will not be a
    way around it—you will need to have them removed one way or another before you
    can upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a typical package update will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Upgrading a Debian-based system to a new distribution version is more involved.
    You will need to look up the codename of the new version and replace the old one
    in your repository configuration files. For example, if you are upgrading from
    Debian 10 to 11, you need to replace every occurrence of `buster` (the codename
    of Debian 10) with `bullseye` (the codename of Debian 11), then run `apt-get dist-upgrade`
    and reboot your system.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, system-wide upgrade procedures are conceptually similar in Red
    Hat and Debian-based distributions, even if the exact commands and implementation
    details differ.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about low-level and high-level package managers
    used by popular Linux distributions. We learned how to install and remove packages
    using DNF and APT and how to perform a system upgrade. We also learned how to
    inspect package files by hand and interpret their internal structure—while that
    task is much less frequent, it’s important to know to have a deeper understanding
    of software packaging and the package management process. However, package managers
    offer a lot of additional options and capabilities, so make sure to read their
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about network configuration and debugging
    in Linux systems.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'RPM documentation: [http://rpm.org/documentation.xhtml](http://rpm.org/documentation.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'dpkg: [https://www.dpkg.org/](https://www.dpkg.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DNF documentation: [https://dnf.readthedocs.io/en/latest/](https://dnf.readthedocs.io/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'APT documentation: [https://wiki.debian.org/PackageManagement](https://wiki.debian.org/PackageManagement)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
