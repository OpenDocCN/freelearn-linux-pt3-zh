<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer068">
			<h1 id="_idParaDest-54"><em class="italic"><a id="_idTextAnchor053"/>Chapter 3</em>: Using Commands and Services for Process Management</h1>
			<p>Managing processes is an important job of a Linux system administrator. That can be for a variety of reasons – maybe some processes got stuck and we need to finish them, or we want to set some process(es) to work in the background or even to be started periodically or at a later date. Whatever the scenario is, it's important to know how to administer processes and make them do the work that needs to be done efficiently and with regard to other processes running on the system.</p>
			<p>In this chapter, we are going to learn about the following recipes:</p>
			<ul>
				<li><a id="_idTextAnchor054"/>Process management tools</li>
				<li>Managing background jobs</li>
				<li>Managing process priorities</li>
				<li>Configuring <strong class="source-inline">crond</strong></li>
			</ul>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor055"/>Technical requirements </h1>
			<p>For these recipes, we're going to use a Linux machine – we can use any virtual machine from our previous recipes. Again, we can just continue using the <strong class="source-inline">cli1</strong> machine that we used in the previous chapter. So, to sum this up, we need the following:</p>
			<ul>
				<li>A virtual machine with Linux installed, any distribution (in our case, it's going to be Ubuntu 20.10)</li>
			</ul>
			<p>So, start your virtual machine and let's get cracking!</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor056"/>Process management tools</h1>
			<p>Managing processes<a id="_idIndexMarker106"/> means learning about the ways in which processes work and the specific text-mode tools that we can use to manage them. We are going to start by introducing some simple concepts – explain what processes are and which states they can be in – and then we're going to move on to commands and how to use them to manage processes from an administrative standpoint. That means that we are going to learn 10+ new commands/concepts that are necessary to understand how all of this works.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>Getting ready</h2>
			<p>The vast majority of commands and utilities that we are going to use in this recipe come pre-installed with our Linux distribution. That being said, there are a couple of cool additional tools we can use to further drive the point of managing processes and system resources home. So, let's install one more utility as it's capable of being used as a tool to monitor system resources along with low-level stuff, such as working with processes. It's called <strong class="source-inline">glances</strong>; let's install it by typing the following:</p>
			<p class="source-code">apt-get -y install glances</p>
			<p>That should cover everything that we need in this recipe, so let's get cracking!</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/>How to do it…</h2>
			<p>The first two commands that we must cover are <strong class="source-inline">ps</strong> and <strong class="source-inline">top</strong>. These are commands that Linux system administrators use dozens of times on a daily basis if they're managing a Linux server. Both of these commands are very valuable, as we can get a lot of information about our system if we know how to use them properly, especially <strong class="source-inline">ps</strong>. </p>
			<p>So, let's first use <strong class="source-inline">ps</strong> as a command without any additional options (of which there are many):</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="Images/Figure_3.1_B16269.jpg" alt="Figure 3.1 – Default ps command output&#13;&#10;" width="689" height="206"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 <a id="_idTextAnchor059"/>– Default ps command output</p>
			<p>By default, <strong class="source-inline">ps</strong> gives us <a id="_idIndexMarker107"/>a report about currently running processes. By starting it in a shell without any additional options, we can get a list of processes running in our current shell. We can already see some interesting information in this output. For starters, we can see five processes and their IDs (the <strong class="source-inline">PID</strong> field on the left side). Then, we can see where they're running, which is what the <strong class="source-inline">TTY</strong> field is all about. The <strong class="source-inline">TIME</strong> field tells us how much accumulated CPU time the process has used so far. Furthest to the right, we can see the <strong class="source-inline">CMD</strong> field, which tells us the name of an actual process that was started.</p>
			<p>To fully appreciate the power of the <strong class="source-inline">ps</strong> command, we really need to look to its man page. There's a really nice <strong class="source-inline">EXAMPLES</strong> section in it. Here's an excerpt from that section:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="Images/Figure_3.2_B16269.jpg" alt="Figure 3.2 – Example for using the ps command&#13;&#10;" width="946" height="679"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Example for using the ps command</p>
			<p>Let's use an <a id="_idIndexMarker108"/>extreme derivative of one of these examples. Let's type the following command:</p>
			<p class="source-code">ps auwwx | less</p>
			<p>We used the <strong class="source-inline">| less</strong> part of this command to output just the first page of the <strong class="source-inline">ps</strong> command output. The output should look something like this:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="Images/Figure_3.3_B16269.jpg" alt="Figure 3.3 – ps auwwx command output (much more verbose)&#13;&#10;" width="1344" height="726"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – ps auwwx command output (much more verbose)</p>
			<p>As we can<a id="_idIndexMarker109"/> clearly see, there's a lot more detail in this output sorted by <strong class="source-inline">PID</strong>. Some of the newly added fields include the following:</p>
			<ul>
				<li><strong class="source-inline">USER</strong>: This field tells us the name of the user who started the process.</li>
				<li><strong class="source-inline">%CPU</strong>: This field tells us how much CPU time the process uses.</li>
				<li><strong class="source-inline">%MEM</strong>: This field tells us how much memory the process uses.</li>
				<li><strong class="source-inline">VSZ</strong>: This field tells us how much virtual memory the process uses.</li>
				<li><strong class="source-inline">RSS</strong>: Resident Set Size, the amount of non-swapped memory used by the process.</li>
				<li><strong class="source-inline">STAT</strong>: Process status code.</li>
				<li><strong class="source-inline">START</strong>: Time when the process was started.</li>
			</ul>
			<p>Just as an example, a lot of system administrators use the <strong class="source-inline">%CPU</strong> and <strong class="source-inline">%MEM</strong> fields to find processes that are using too much CPU or memory.</p>
			<p>Let's say that we need to find a process by name. There are multiple ways of doing this, the most common two being using either the <strong class="source-inline">ps</strong> command or the <strong class="source-inline">pgrep</strong> command. Let's see how that would work:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="Images/Figure_3.4_B16269.jpg" alt="Figure 3.4 – Using pgrep or ps to find a process by name&#13;&#10;" width="1057" height="201"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Using pgrep or ps to find a process by name</p>
			<p>As a command, we<a id="_idIndexMarker110"/> tend to use <strong class="source-inline">grep</strong> to create a filter that will find a text sample by going through text output. We can see that both commands gave us the result that we needed – it's just formatted differently and with a different level of detail. We can also use the <strong class="source-inline">pidof</strong> command to find a PID for any given process, similar to <strong class="source-inline">pgrep</strong>:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="Images/Figure_3.5_B16269.jpg" alt="Figure 3.5 – Using the pidof command&#13;&#10;" width="697" height="92"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Using the pidof command</p>
			<p>Let's now explain the idea of the <strong class="source-inline">top</strong> command. After we start the <strong class="source-inline">top</strong> command, we should get something similar to this:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="Images/Figure_3.6_B16269.jpg" alt="Figure 3.6 – Using the top command&#13;&#10;" width="1439" height="787"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Using the top command</p>
			<p>There are multiple<a id="_idIndexMarker111"/> things happening in this interactive output at the same time:</p>
			<ol>
				<li>The <strong class="source-inline">top</strong> line is actually output from the <strong class="source-inline">uptime</strong> command. If we add the next four lines (beginning with <strong class="source-inline">Tasks</strong>, <strong class="source-inline">%Cpu(s)</strong>, <strong class="source-inline">Mib Mem</strong>, and <strong class="source-inline">MiB Swap</strong>), that is what we call the top <em class="italic">summary area</em>.</li>
				<li>After that, we can clearly see that <strong class="source-inline">top</strong> acts as a frontend to the <strong class="source-inline">ps</strong> command but is implemented in an interactive sense.</li>
			</ol>
			<p>The interactive part of the <strong class="source-inline">top</strong> command stems from the fact that it actually refreshes regularly – by default, every 3 seconds. We can change that default refresh interval by pressing the <em class="italic">S</em> key, which will make <strong class="source-inline">top</strong> ask us to change the delay from <strong class="source-inline">3.0</strong> to any number. If we want to change the refresh interval to <strong class="source-inline">1</strong> second, we just press <strong class="source-inline">1</strong> and <em class="italic">Enter</em>. </p>
			<p>We can ask <strong class="source-inline">top</strong> to show us processes by a single user (by pressing <em class="italic">U</em> and typing in the user's login name) and to kill processes (by pressing <em class="italic">K</em> and typing in the PID and the signal we want to send to that PID). We can also manipulate process priority, which we will cover in our <em class="italic">third</em> recipe of this chapter. All in all, <strong class="source-inline">top</strong> is a very useful and often-used command to do process management. It acts as a frontend to many different commands, such as <strong class="source-inline">nice</strong>, <strong class="source-inline">renice</strong>, and <strong class="source-inline">kill</strong>.</p>
			<p>The next set of commands that we need to learn about is <strong class="source-inline">kill</strong> and <strong class="source-inline">killall</strong>. We shouldn't use the literal translation of these utilities to try to instinctively understand what they do as we'll be surprised that that translation doesn't apply. Specifically, the <strong class="source-inline">kill</strong> command is used when we want to kill a process by its corresponding PID. <strong class="source-inline">killall</strong>, in contrast, is used to kill processes by name. There are – of course – viable use cases for both. To<a id="_idIndexMarker112"/> show an example for both of these commands, we are going to use the following <strong class="source-inline">top</strong> output:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="Images/Figure_3.7_B16269.jpg" alt="Figure 3.7 – top output – notice the top command being started twice by the student user&#13;&#10;" width="1158" height="537"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – top output – notice the top command being started twice by the student user</p>
			<p>Let's kill both of these <strong class="source-inline">top</strong> processes in a separate shell. If we want to kill the first one by using the <strong class="source-inline">kill</strong> command, we need to type the following:</p>
			<p class="source-code">kill 41246</p>
			<p>If we want to kill all of the started <strong class="source-inline">top</strong> commands by name, we can type the following:</p>
			<p class="source-code">killall top</p>
			<p>When using the <strong class="source-inline">kill</strong> command, we're killing a single PID. When using the <strong class="source-inline">killall</strong> command, we are killing all the started <strong class="source-inline">top</strong> processes. Of course, in order for us to be able to kill a process by using either of these commands, we have to log in as either root or <strong class="source-inline">student</strong>. Only the user that started the process and root can kill a user process. We need to remember that the default signal of both of these commands is the <strong class="source-inline">SIGTERM</strong> signal (signal number <strong class="source-inline">15</strong>). If we want to kill a process by using a custom signal, we can achieve that by adding that number to any of these two commands preceded by a minus sign. Here's an example:</p>
			<p class="source-code">kill -9 41246</p>
			<p>This will <a id="_idIndexMarker113"/>send the <strong class="source-inline">SIGKILL</strong> signal to the process. Both of these signals are explained in the <em class="italic">How it works…</em> section of this recipe.</p>
			<p>It's also good to note the fact that sometimes we need to find the PID of a currently running shell or a parent PID of a shell. We can do that by using the following two commands:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="Images/Figure_3.8_B16269.jpg" alt="Figure 3.8 – PID of our current shell process, the parent process &#13;&#10;" width="920" height="116"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – PID of our current shell process, the parent process </p>
			<p>Let's now check how <strong class="source-inline">glances</strong> can help us check what's happening with our system. If we just start the command, we're going to get the following output:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="Images/Figure_3.9_B16269.jpg" alt="Figure 3.9 – glances default output&#13;&#10;" width="1281" height="937"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – glances default output</p>
			<p>It's easy to<a id="_idIndexMarker114"/> see the level of detail, as well as the different formats, that <strong class="source-inline">glances</strong> uses. Furthermore, we really appreciate the fact that it uses color output as default, which makes the information a bit easier to read. We can go into different methods of displaying data. For example, we can type <strong class="source-inline">1</strong> to switch between per-CPU core versus aggregated statistics. We can also use it in server mode (by starting it with the <strong class="source-inline">-s</strong> switch) so that we can monitor remote hosts. So, from the server perspective, we would start it with the following:</p>
			<p class="source-code">glances -s</p>
			<p>From the client perspective, we would start <strong class="source-inline">glances</strong> with the following:</p>
			<p class="source-code">glances -c @servermachine</p>
			<p><strong class="source-inline">glances</strong> is cross-platform (it's Python-based), as it supports Linux, OS X, Windows, and FreeBSD. It also has a built-in web UI that can be used via a web browser if we're more into using the GUI than the CLI. But one of the most convenient features that it has is the ability to export data in various different formats – CSV, Elasticsearch, RabbitMQ, Cassandra, and others.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/>How it works…</h2>
			<p>A process is a unit of command execution that an operating system initializes so that it can be managed both from the operating system standpoint and from our standpoint as system administrators. That means that a process acts like an instance of any given program, and it has some common properties (state, PID, and many others that we will describe in this chapter), as well as some tasks that it needs to do. For example, after we start a command (<strong class="source-inline">process</strong>), that command can open and read from the file, user input, or other programs, do something with that input, and then terminate after the work is done. </p>
			<p>It is important to note that processes aren't <em class="italic">paused</em> if we reboot a machine – they get stopped and then start as our Linux machine boots or we start it manually after the reboot. So, <em class="italic">there's no process persistence across reboots</em>. Most of the time (except for most of the processes that are a part of the operating system startup procedure), they don't even <a id="_idIndexMarker115"/>keep the same PID across a reboot. </p>
			<p>In terms of process types, we have five different types:</p>
			<ul>
				<li><strong class="bold">Parent and child processes</strong>: In<a id="_idIndexMarker116"/> simple terms, a parent process is a process that creates additional processes that we call child processes. Child processes exit when the parent process exits. A parent process doesn't exit if a child process exits.</li>
				<li><strong class="bold">Zombie and orphan processes</strong>: There are situations where the parent process gets killed before the child process exits. The remaining child process is called an orphan process. On the other hand, a zombie process is a situation where a process is killed but still exists in the process table.</li>
				<li><strong class="bold">Daemons</strong>: Daemons are usually related to some system tasks that usually involve working with other processes and servicing them. They also don't use a terminal as they run in the background.</li>
			</ul>
			<p>In terms of states, we have these:</p>
			<ul>
				<li><strong class="bold">Running/runnable</strong>: Running state refers to a state where a process is being executed by a CPU. Runnable state, on the other hand, means that a process is ready to be executed but is currently not consuming CPU or queued to be executed by a CPU.</li>
				<li><strong class="bold">Interruptible/uninterruptible sleep</strong>: In an interruptible sleep state, a process can be awakened and it can accept <strong class="bold">signals</strong> aimed at it. In an uninterruptible sleep state, that doesn't happen, and the process remains asleep. This scenario often includes a <strong class="bold">system call</strong> – a process can't do a system call and can't be paused or killed until it finishes its job.</li>
				<li><strong class="bold">Stopped</strong>: A process<a id="_idIndexMarker117"/> is often stopped when it receives a signal and when we're debugging a process.</li>
				<li><strong class="bold">Zombie</strong>: A dead process that's been halted but still exists in the process table is in a zombie state.</li>
			</ul>
			<p>From the operating <a id="_idIndexMarker118"/>system perspective, processes are units of execution – for a program or service. Processes get scheduled by the operating system and that means assigning them resources so that they can run from a programmatic perspective (context), and some basic attributes so that they can be managed from the system administrative perspective. That includes creating an entry in a process table with a PID (number of the process) and other types of attribute data. We are going to explain these attributes and how to notice process states a bit later in this chapter, when we start discussing practical aspects of working with commands such as <strong class="source-inline">top</strong> and <strong class="source-inline">ps</strong>.</p>
			<p>We mentioned the concept of a signal. When we're dealing with different ways of establishing communication between a kernel and userspace program, there are two ways of achieving that – via either a system call or a signal. Usually, we use commands such as <strong class="source-inline">kill</strong> or <strong class="source-inline">killall</strong> if we want to send a signal to a process by assigning a signal number or name along with the command. Let's take a look at an excerpt from the signal list:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="Images/Figure_3.10_B16269.jpg" alt="Figure 3.10 – Excerpt from the signal man page&#13;&#10;" width="1161" height="1009"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Excerpt from the signal man page</p>
			<p>As we can see, there<a id="_idIndexMarker119"/> are many of them, and approximately 30 of these signals have been implemented by the Linux kernel. Also, there are two types of signals from the process perspective:</p>
			<ul>
				<li><strong class="bold">Signals that can be handled by processes</strong>: For example, the <strong class="source-inline">SIGHUP</strong> signal (number 1)</li>
				<li><strong class="bold">Signals that cannot be handled by processes, but directly by the kernel</strong>: For example, the <strong class="source-inline">SIGKILL</strong> signal (number 9)</li>
			</ul>
			<p>The word <em class="italic">handled</em> is used in a programmatic sense here – handling something means using some kind of <em class="italic">handler</em> to write a piece of code that's going to intercept the signal message and redirect it to something, such as a function or subroutine.</p>
			<p>There are major differences between these two types. Let's use an example of a daemon process such as an <em class="italic">Apache web server</em>. If a daemon process receives the <strong class="source-inline">SIGHUP</strong> signal and it supports it (it has a routine in its source code handling the <strong class="source-inline">SIGHUP</strong> signal, like Apache does), the most common thing that it will do after receiving <strong class="source-inline">SIGHUP</strong> is to refresh<a id="_idIndexMarker120"/> its state by re-reading its configuration. To quote the Apache manual:</p>
			<p><em class="italic">Sending the HUP or restart signal to the parent causes it to kill off its children like in TERM, but the parent doesn't exit. It re-reads its configuration files, and re-opens any log files. Then it spawns a new set of children and continues serving hits</em>.</p>
			<p>Unlike this scenario, when you send the <strong class="source-inline">SIGKILL</strong> signal to Apache, it will be terminated without giving any regard to refreshing its configuration, content, or anything of the sort. We can't write a handle to redirect this signal to anything other than the process being killed. We can think of it as a <em class="italic">kernel sucking the life out of a process</em> type of scenario, as the process can't get access to resources to run and is effectively eradicated by the system (kernel).</p>
			<p>The third commonly used signal is <strong class="source-inline">SIGTERM</strong> (number 15). It's also used to terminate the process (such as <strong class="source-inline">SIGKILL</strong>), but it does it in a graceful way. We can think of it as a <em class="italic">Hello, Mr. Process, would you please be so kind as to terminate yourself gracefully? Thank you very much!</em> message from the kernel. Then the process does what it needs to do and shuts itself down.</p>
			<p>Now that we've had a brief primer on how processes and signals work, let's continue our quest for knowledge about processes by learning about the management of background processes. As we already explained the basics of background processes, that shouldn't be a difficult task.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/>See also</h2>
			<p>If you need more information about processes, signals, and similar concepts, make sure that you check out the following:</p>
			<ul>
				<li><strong class="bold">Basics of Linux processes</strong>: <a href="http://www.science.unitn.it/~fiorella/guidelinux/tlk/node45.html%0D">http://www.science.unitn.it/~fiorella/guidelinux/tlk/node45.html</a></li>
				<li><strong class="bold">Linux command basics</strong> – Seven commands for process management: <a href="https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management%0D">https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management</a></li>
				<li><strong class="bold">Signal man page</strong>: <a href="https://man7.org/linux/man-pages/man7/signal.7.html%0D">https://man7.org/linux/man-pages/man7/signal.7.html</a></li>
				<li><strong class="bold">Basics of glances</strong>: <a href="https://www.tecmint.com/glances-an-advanced-real-time-system-monitoring-tool-for-linux/%0D">https://www.tecmint.com/glances-an-advanced-real-time-system-monitoring-tool-for-linux/</a></li>
				<li><strong class="bold">TLDP Chapter 4: Processes</strong>: <a href="https://tldp.org/LDP/tlk/kernel/processes.html%0D">https://tldp.org/LDP/tlk/kernel/processes.html</a></li>
			</ul>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor062"/>Managing background jobs</h1>
			<p>There are various<a id="_idIndexMarker121"/> types of situations where we would like to start a process and run it in the background. For example, let's say that we want to start a process, log off, and then come back tomorrow and check the result of that process. Let's learn how this works by using an example.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor063"/>Getting ready</h2>
			<p>Keep the <strong class="source-inline">cli1</strong> virtual machine powered on and let's use the shell to explain how the idea of a background process works, as opposed to a foreground process. We will make sure that we also explain the concept in the <em class="italic">How it works…</em> section.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor064"/>How to do it…</h2>
			<p>Let's imagine a scenario in which we want to download a large file by using shell tools. The <em class="italic">usual suspect</em> that we'd use for this kind of task in Linux is a program called <strong class="source-inline">wget</strong>. We want to start a <strong class="source-inline">wget</strong> session (<strong class="source-inline">wget</strong> is a <strong class="source-inline">shell</strong> command that enables us to download files from the <strong class="source-inline">http</strong> and <strong class="source-inline">ftp</strong> URIs) to download a large ISO file, but we want to log off (or do something else) while the download is taking place. This is achieved by putting the <strong class="source-inline">wget</strong> process in the background. This is just one common example of using a background process to our advantage.</p>
			<p>First, we need to install <strong class="source-inline">wget</strong>. Let's do that by using the following command:</p>
			<p class="source-code">apt-get -y install wget</p>
			<p><strong class="source-inline">wget</strong> is a common utility, and it's mostly installed by default. But either way, by using this command, we'll make sure that it's installed.</p>
			<p>Let's use the <strong class="source-inline">Ubuntu 20.04 ISO</strong> file as the file that we want to download by using two examples. The first one is going to be running <strong class="source-inline">wget</strong> as a <em class="italic">foreground</em> process, and the second one is going to be running <strong class="source-inline">wget</strong> as a <em class="italic">background</em> process. The second example can <a id="_idIndexMarker122"/>actually be done in two different ways as <strong class="source-inline">wget</strong> has a built-in option that can be used to put it in the background. Of course, as we're trying to explain the <em class="italic">system-wide</em> concept, not a specific utility, let's make sure that we do both.</p>
			<p>At the time of writing, the <strong class="source-inline">Ubuntu 20.04 ISO</strong> file can be found here:</p>
			<p><a href="https://releases.ubuntu.com/20.04/ubuntu-20.04.3-live-server-amd64.iso%0D">https://releases.ubuntu.com/20.04/ubuntu-20.04.3-live-server-amd64.iso</a></p>
			<p>Let's use <strong class="source-inline">wget</strong> to download it as a foreground process, by typing in the following command:</p>
			<p class="source-code">wget https://releases.ubuntu.com/20.04/ubuntu-20.04.3-live-server-amd64.iso</p>
			<p>The result should look something like this:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="Images/Figure_3.11_B16269.jpg" alt="Figure 3.11 – Foreground process – exclusively locks the shell access&#13;&#10;" width="1469" height="335"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – Foreground process – exclusively locks the shell access</p>
			<p>As we can clearly see, the download is working, but the problem is the fact that for the next 12+ minutes, we can't do anything in this shell, as the underlying shell session is being exclusively used by <strong class="source-inline">wget</strong>. We can't write commands, get command results – nothing. The only thing that we could do to prevent that would be to use a <em class="italic">Ctrl</em> + <em class="italic">C</em> sequence to quit the download and be thrown into the shell. But that's not what we want to do. What we want to do is the following:</p>
			<ol>
				<li value="1">Start the download.</li>
				<li>Be thrown back into the shell with the download still working.</li>
			</ol>
			<p>This is a situation in which running a process as a background task can be very helpful. So, let's add one additional parameter to the previous command:</p>
			<p class="source-code">wget https://releases.ubuntu.com/20.04/ubuntu-20.04.2-live-server-amd64.iso&amp;</p>
			<p>The <strong class="source-inline">&amp;</strong> sign at the <a id="_idIndexMarker123"/>end of this command tells the kernel to put this process in the background. Let's see what the end result is:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="Images/Figure_3.12_B16269.jpg" alt="Figure 3.12 – Starting the process in the background&#13;&#10;" width="1318" height="145"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – Starting the process in the background</p>
			<p>We can clearly see that we've been thrown back into the shell (<strong class="source-inline">root@cli1</strong> prompt) and that we can keep writing additional commands. We can also see that a <strong class="source-inline">wget</strong> process was started with PID <strong class="source-inline">43787</strong>, which we could use to issue a <strong class="source-inline">kill</strong> command if we so choose. </p>
			<p>Obviously, we can issue multiple commands with <strong class="source-inline">&amp;</strong> at the end, and then we'd have multiple processes running in the background. This is where the <strong class="source-inline">[1]</strong> part of the previous output comes in handy. This number represents an index number assigned to the background process. In other words, the <strong class="source-inline">wget</strong> that we started with PID <strong class="source-inline">43787</strong> is the first background process. If we were to start multiple background processes, each new background process would get the next number – <strong class="source-inline">2</strong>, <strong class="source-inline">3</strong>, and so on. </p>
			<p>Obviously, we need to learn how to manage multiple background jobs. This is what the <strong class="source-inline">jobs</strong> command is all about. Let's see how that works. First, we are going to start multiple background jobs:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="Images/Figure_3.13_B16269.jpg" alt="Figure 3.13 – Starting multiple background processes&#13;&#10;" width="1307" height="413"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – Starting multiple background processes</p>
			<p>Then, let's use<a id="_idIndexMarker124"/> the <strong class="source-inline">jobs</strong> and <strong class="source-inline">kill</strong> commands to work out which background jobs we have and kill them by index (not by using their PID). This is the way to do it:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="Images/Figure_3.14_B16269.jpg" alt="Figure 3.14 – Checking and killing multiple background processes&#13;&#10;" width="1377" height="510"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Checking and killing multiple background processes</p>
			<p>By using the <strong class="source-inline">kill %index_number</strong> syntax, we were able to kill background jobs by their index number, instead of their PIDs. This syntax is shorter and shouldn't be discounted in everyday life as it makes a lot of things easier – as long as we don't log off. If we log off, the whole idea changes a bit as we can't access these processes by using their index numbers, but we can definitely manage them by using PIDs. So, let's imagine for a second that we started two <strong class="source-inline">wget</strong> sessions as background processes, and then logged off and logged back on. Let's try to list these processes as background processes, then as just regular, general processes, and kill them by PID. This is what happens after that:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="Images/Figure_3.15_B16269.jpg" alt="Figure 3.15 – jobs provides no output, but the ps command does&#13;&#10;" width="1454" height="297"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – jobs provides no output, but the ps command does</p>
			<p>We can clearly see<a id="_idIndexMarker125"/> that the <strong class="source-inline">jobs</strong> command provides no output (can't find index numbers of background jobs), but our processes are still running. Why? Well, background processes that we started were created in the shell that's no longer active. After we logged off, we started a new shell, and, because of the way in which the <strong class="source-inline">jobs</strong> command works, we can't see those background jobs anymore. But we can definitely see them as processes running on the system, and, if we want to do so, we can kill them successfully by using their PIDs, as we did with the <strong class="source-inline">kill</strong> command. We used the <strong class="source-inline">ps</strong> command here and filtered its output by using <strong class="source-inline">grep</strong> – a command that is able to search specific pieces of text from a text-based output (in our case, we were searching through the whole table of processes by using <strong class="source-inline">ps</strong> <strong class="source-inline">auwwx</strong>, created a serial pipeline by using the pipe sign (<strong class="source-inline"> | </strong>), and then threw the output from the <strong class="source-inline">ps</strong> command in the <strong class="source-inline">grep</strong> command.</p>
			<p>We mentioned that the <strong class="source-inline">wget</strong> command has the capability to start itself in the background by using a command-line option (<strong class="source-inline">-b</strong>). This is not all that common, but it's definitely useful. So, say we were to use the following command:</p>
			<p class="source-code">wget -b https://releases.ubuntu.com/20.04/ubuntu-20.04.2-live-server-amd64.iso</p>
			<p>This should be the end result:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="Images/Figure_3.16_B16269.jpg" alt="Figure 3.16 – wget can be started in the background by using the -b switch&#13;&#10;" width="1461" height="330"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.16 – wget can be started in the background by using the -b switch</p>
			<p>What's really interesting about this procedure is the following:</p>
			<ul>
				<li><strong class="source-inline">wget</strong> clearly states that it's starting itself in the background, but it doesn't give us an index number.</li>
				<li>If we use the <strong class="source-inline">jobs</strong> command, we can't see it as a background process.</li>
				<li>We can kill it by using regular means, a <strong class="source-inline">kill</strong> command.</li>
			</ul>
			<p>This is a bit of a<a id="_idIndexMarker126"/> different concept, as <strong class="source-inline">wget</strong> effectively achieves this <strong class="source-inline">jobs</strong> <em class="italic">command invisibility</em> by creating a <strong class="source-inline">wget</strong> child process and terminating the parent process. Since the parent process is no longer there, it's no longer associated with a specific shell, and therefore not indexed. The result is that it's not visible in the jobs table for the current shell. We can achieve something similar by using the <strong class="source-inline">disown</strong> command. Let's start a process in the current shell, and then do the thing that <strong class="source-inline">wget</strong> basically does:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="Images/Figure_3.17_B16269.jpg" alt="Figure 3.17 – Disowning a background process&#13;&#10;" width="1461" height="441"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.17 – Disowning a background process</p>
			<p>There are other ways of making sure that a process goes to the background. The most common scenario is we want to start a process in the background, we forget to put the <strong class="source-inline">&amp;</strong> sign at the end of our command, and we're stuck with the foreground process. What to do then?</p>
			<p>The answer is simple – we press <em class="italic">Ctrl</em> + <em class="italic">Z</em> (to put the process in the suspended state), and then type in the <strong class="source-inline">bg</strong> command. It's going to put the process in the background, as if we started it with the <strong class="source-inline">&amp;</strong> sign from the start. Combining all of that with <strong class="source-inline">jobs</strong>, <strong class="source-inline">disown</strong> and <strong class="source-inline">kill</strong> would<a id="_idIndexMarker127"/> look like this:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="Images/Figure_3.18_B16269.jpg" alt="Figure 3.18 – Using Ctrl + Z and bg to put a process in the background&#13;&#10;" width="1465" height="755"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.18 – Using Ctrl + Z and bg to put a process in the background</p>
			<p>We started <strong class="source-inline">wget</strong> in the foreground and put it in a suspended state by typing <em class="italic">Ctrl</em> + <em class="italic">Z</em>. Then, we moved that process to the background by using the <strong class="source-inline">bg</strong> command. Since it's job number <strong class="source-inline">1</strong> in our shell, we disowned it, used <strong class="source-inline">ps</strong> to find its PID, and killed it.</p>
			<p>If, for some reason, we wanted to go from the background to the foreground with a process (providing that it has an index number and was started in the current shell), we can do that by using the <strong class="source-inline">fg</strong> command. So, if we use the previous procedure as an example, it would look like this:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="Images/Figure_3.19_B16269.jpg" alt="Figure 3.19 – Using Ctrl + Z, bg, and fg to move a process to the background and back to the foreground&#13;&#10;" width="1375" height="846"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.19 – Using Ctrl + Z, bg, and fg to move a process to the background and back to the foreground</p>
			<p>We can clearly see that the <strong class="source-inline">wget</strong> process went to the background (<em class="italic">Ctrl</em> + <em class="italic">Z</em> and <strong class="source-inline">bg</strong> commands), then <a id="_idIndexMarker128"/>went to the foreground (the <strong class="source-inline">fg</strong> command), and was terminated at the end by using <em class="italic">Ctrl</em> + <em class="italic">C</em>. If we have multiple background processes in our current shell, we can also use indexing with the <strong class="source-inline">fg</strong> command (<strong class="source-inline">fg index_number</strong>). </p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor065"/>How it works…</h2>
			<p>Processes can run in two different ways:</p>
			<ul>
				<li><strong class="bold">Foreground</strong>: If we <a id="_idIndexMarker129"/>start a <a id="_idIndexMarker130"/>process from the shell, that process is going to occupy our current shell and will not allow us to type in additional commands. A kind of exception to that rule is a scenario in which the started process requires additional user input, but that input needs to be baked into the core of the process that we're executing (a part of the programming code). In this scenario, the shell is exclusively used by the started process until either the process finishes, we put it in the background, or it gets killed by other external factors (such as other processes or the <a id="_idIndexMarker131"/>kernel, or if it crashes for some reason).</li>
				<li><strong class="bold">Background</strong>: If we start a <a id="_idIndexMarker132"/>process in the background, it runs and frees up our shell so that we <a id="_idIndexMarker133"/>can continue using it to type other commands.</li>
			</ul>
			<p>When a process goes to the background in the current shell, it gets an index number so that we have the capability to manage it by using its index number. We can use <strong class="source-inline">fg</strong>, <strong class="source-inline">kill</strong>, and similar commands by using this index number (for example, <strong class="source-inline">kill %1</strong> would kill the first job in the job index table).</p>
			<p>As we saw in our practical demonstration, there are multiple ways of making sure that processes are started in the background – either when they are started or after they are started. What makes this concept plausible is the fact that we can easily put processes in the background, to be handled by the operating system, while we're away from it, which sometimes <a id="_idIndexMarker134"/>means freeing our precious time.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor066"/>There's more…</h2>
			<p>If we need to learn<a id="_idIndexMarker135"/> more about foreground and background processes, we can check the following links:</p>
			<ul>
				<li><strong class="bold">Linux commands</strong> – <strong class="source-inline">jobs</strong>, <strong class="source-inline">bg</strong>, and <strong class="source-inline">fg</strong>: <a href="https://www.redhat.com/sysadmin/jobs-bg-fg%0D">https://www.redhat.com/sysadmin/jobs-bg-fg</a></li>
				<li><strong class="bold">Linux command basics</strong> – seven commands for process management: <a href="https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management">https://www.redhat.com/sysadmin/linux-command-basics-7-commands-process-management</a></li>
			</ul>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor067"/>Managing process priorities</h1>
			<p>When we <a id="_idIndexMarker136"/>were explaining how to work with the <strong class="source-inline">top</strong> command, we intentionally omitted some details to give them their own time and place to discuss them later on in this chapter. We'll discuss one of these details here: the difference between the <strong class="source-inline">PR</strong> and <strong class="source-inline">NI</strong> fields in the <strong class="source-inline">top</strong> output. Let's do that now.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor068"/>Getting ready</h2>
			<p>Keep the <strong class="source-inline">cli1</strong> virtual machine powered on and let's continue using our shell.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor069"/>How to do it…</h2>
			<p>We are going to learn how to use the <strong class="source-inline">top</strong>, <strong class="source-inline">nice</strong>, and <strong class="source-inline">renice</strong> commands to manage process scheduling in accordance with our wishes. First, let's use the <strong class="source-inline">top</strong> command. Let's <strong class="source-inline">renice</strong> a running process to a more negative value and a more positive value. Let's use the following <strong class="source-inline">top</strong> output for that:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="Images/Figure_3.20_B16269.jpg" alt="Figure 3.20 – Starting point – processes started by the student user&#13;&#10;" width="1151" height="327"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.20 – Starting point – processes started by the student user</p>
			<p>Let's now change the priority of the process with PID <strong class="source-inline">47160</strong> (<strong class="source-inline">top</strong>). Press the <em class="italic">R</em> key and the <strong class="source-inline">top</strong> output will change this output to something such as the following:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="Images/Figure_3.21_B16269.jpg" alt="Figure 3.21 – Let's renice a PID&#13;&#10;" width="545" height="27"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.21 – Let's renice a PID</p>
			<p>Then, again, type in the number <strong class="source-inline">47160</strong> and press <em class="italic">Enter</em>, followed by the niceness level – let's say, <strong class="source-inline">-10</strong>. We should get something like this as a result:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="Images/Figure_3.22_B16269.jpg" alt="Figure 3.22 – End result – more negative niceness level, higher priority&#13;&#10;" width="1162" height="297"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.22 – End result – more negative niceness level, higher priority</p>
			<p>We can clearly see that the <strong class="source-inline">NI</strong> field of our PID changed from <strong class="source-inline">0</strong> to <strong class="source-inline">-10</strong>. Since we gave it a more negative niceness level, that means higher priority.</p>
			<p>This example explains how to <strong class="source-inline">renice</strong> an already running process. But clearly, we can't use that to set <a id="_idIndexMarker137"/>the niceness level before we start the process. That's why we have the <strong class="source-inline">nice</strong> command. Here's an example of using the <strong class="source-inline">nice</strong> command:</p>
			<p class="source-code">nice -n -10 top</p>
			<p>If we start this command as root and check the output, after we give it a bit of time, we should see something like this: </p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="Images/Figure_3.23_B16269.jpg" alt="Figure 3.23 – Using nice to pre-assign priority to a process at process start&#13;&#10;" width="1257" height="101"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.23 – Using nice to pre-assign priority to a process at process start</p>
			<p>Obviously, there's a caveat here – if we tried to start this command as a regular user, that wouldn't work. Regular users don't have a right to use the <strong class="source-inline">nice</strong> command – imagine how many different possibilities of abusing the system and/or crashing it would be given to any user if they did have that right. There are ways around this if we want to give the right to use the <strong class="source-inline">nice</strong> command to some users – we can do it via PAM modules or the <strong class="source-inline">sudo</strong> system. But for the time being, let's agree that this is not something that needs to be <em class="italic">urbi et orbi</em>, just as an exception.</p>
			<p>Let's now explain how these concepts work.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/>How it works…</h2>
			<p>Let's start by <a id="_idIndexMarker138"/>executing the <strong class="source-inline">top</strong> command and checking the important part of its output:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="Images/Figure_3.24_B16269.jpg" alt="Figure 3.24 – top output related to process priority&#13;&#10;" width="370" height="498"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.24 – top output related to process priority</p>
			<p>Let's briefly explain the difference between these two fields:</p>
			<ul>
				<li><strong class="source-inline">PR</strong> (priority field): Real, kernel-scheduled priority at the moment of looking, assigned by the kernel. The <strong class="source-inline">rt</strong> mark means real time; it ranges between <strong class="source-inline">0</strong> and <strong class="source-inline">139</strong>, although it can have negative static values for real-time processes.</li>
				<li><strong class="source-inline">NI</strong> (niceness field): The process priority that it should have, assigned in user space (not kernel space) by default or by additional commands (<strong class="source-inline">nice</strong> and <strong class="source-inline">renice</strong>). The lower the number, the higher the priority, on a scale from <strong class="source-inline">-20</strong> to <strong class="source-inline">+19</strong>. </li>
			</ul>
			<p>Obviously, there's a big difference between these two numbers, seeing that one of them is <em class="italic">the real deal</em> (<strong class="source-inline">PR</strong>) and the other one is like <em class="italic">advice</em> (<strong class="source-inline">NI</strong>). Explaining process priorities is relatively easy in theory, but it becomes a bit more challenging to put into practice because of some<a id="_idIndexMarker139"/> architectural reasons. So, we'll try to explain this with an example that used to be possible but is not anymore as the speed of modern CPUs and memory is many times over what it used to be 10 years ago. So, let's first discuss the theoretical concept and then use an example.</p>
			<p>Theoretically speaking, when we use the <strong class="source-inline">nice</strong> and <strong class="source-inline">renice</strong> commands, what we're doing is assigning a specific amount of CPU context to a process – a running one (<strong class="source-inline">renice</strong>) or a soon-to-be-running one (<strong class="source-inline">nice</strong>). We use the word <em class="italic">context</em> here in a programmatic sense from a CPU perspective. Translation – if we want to run a process, the kernel needs to assign it some CPU. If we have a running process and we <strong class="source-inline">renice</strong> it to a more negative value, that is going to tell the kernel and its scheduler to pay more attention to that specific process, therefore giving it more access to the CPU. If we <strong class="source-inline">renice</strong> it to a more positive value, that's going to tell the kernel to pay less attention to giving CPU resources to that process. By assigning more CPU to a process, there's a chance that that process is going to work faster and do its job faster as a result. </p>
			<p>Obviously, this is a bit of a simplification as there are other factors at play here. For example, every process needs some memory to work, and the busier the memory is with other processes, the less speed the process has to access memory content, therefore lowering the memory bandwidth and increasing the latency of memory access. So, assigning a more negative value to niceness doesn't always directly translate to more performance out of a process. Also, what if the process doesn't need more CPU as it's currently idling <a id="_idIndexMarker140"/>and not doing anything of significance? There can be many more factors here – <strong class="bold">Non-Unified Memory Access</strong> (<strong class="bold">NUMA</strong>) operating system/application compatibility, effective usage of multiple threads/cores, locking mechanisms, and others. So, this is more of a general, academic discussion that can have exceptions that can happen for a variety of reasons, the state of the system being one of the most common ones.</p>
			<p>Now that we've taken care of the theoretical background, let's use an example that used to be very easy to demonstrate as a lot of people had these sorts of experiences in the past, when CPU and memory were much, much less capable than they are today.</p>
			<p>10 years ago, if we were to use an average computer of the day to display a high-resolution Flash video from YouTube, we had a problem. CPUs were kind of strong enough to do that, but only just. So, in order for us to be able to watch them in Linux by using a web browser (for example, Firefox), we had to tune the system to do it. So, we started the web browser, found a video that we wanted to watch, and pressed the <em class="italic">play</em> button, and it would work for a couple of seconds and then stutter. Then, it would work again, then stutter again. This was a frustrating experience. In those days, we didn't have GPU acceleration for Flash, so the CPU was the only device that could be of any assistance in these scenarios.</p>
			<p>But if we knew how <a id="_idIndexMarker141"/>to set process priority, we could've solved that problem in most cases, depending on the CPU speed. We could go to the shell, find the PID of the Firefox process, and <strong class="source-inline">renice</strong> it to a much more negative value. All of a sudden, the kernel would instruct its scheduler to pay more attention to Firefox as a process, and lo and behold – our video would stop stuttering. Why? Because the kernel – by virtue of us using the <strong class="source-inline">renice</strong> command – realized that we wanted to give that process more priority and therefore ordered the CPU scheduler to make it happen.</p>
			<p>There are many more aspects of tuning CPU performance. Modern Linux distributions have many options for this as the kernel gets more and more programmatic in terms of its approach to CPU scheduling. That's why various Linux distributions introduced concepts such as <strong class="bold">tuned</strong>, a<a id="_idIndexMarker142"/> profile-driven system that's able to tune our system performance based on pre-assigned or manually created profiles, and <strong class="bold">tuna</strong>, a utility that enables deep application-specific tuning. We always need to have the capability to go deep with tuning so that our system can have optimized performance for any specific use case. </p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor071"/>There's more…</h2>
			<p>If we need to learn more about these concepts, we can check the following links:</p>
			<ul>
				<li><strong class="bold">A guide to the Linux top command</strong>: <a href="https://www.booleanworld.com/guide-linux-top-command/">https://www.booleanworld.com/guide-linux-top-command/</a></li>
				<li><strong class="bold">CPU scheduling</strong>: <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-cpu-scheduler">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-cpu-scheduler</a></li>
				<li><strong class="bold">top man page</strong>: <a href="https://man7.org/linux/man-pages/man1/top.1.html">https://man7.org/linux/man-pages/man1/top.1.html</a></li>
				<li><strong class="bold">nice man page</strong>: <a href="https://man7.org/linux/man-pages/man1/nice.1.html">https://man7.org/linux/man-pages/man1/nice.1.html</a></li>
				<li><strong class="bold">renice man page</strong>: <a href="https://man7.org/linux/man-pages/man1/renice.1.html">https://man7.org/linux/man-pages/man1/renice.1.html</a></li>
				<li><strong class="bold">Getting started with tuned</strong>: <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/getting-started-with-tuned_monitoring-and-managing-system-status-and-performance">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/getting-started-with-tuned_monitoring-and-managing-system-status-and-performance</a></li>
				<li><strong class="bold">Reviewing a system using the tuna interface</strong>: <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/reviewing-a-system-using-tuna-interface_monitoring-and-managing-system-status-and-performance">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/reviewing-a-system-using-tuna-interface_monitoring-and-managing-system-status-and-performance</a></li>
			</ul>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor072"/>Configuring crond</h1>
			<p>Having the<a id="_idIndexMarker143"/> capability to run jobs on a schedule is very important for everyday system administration. We schedule backups, run cleanup procedures, send reports, do antivirus checks, and do other tasks that business procedures need. Scheduling them means a certain level of automation and getting rid of the manual approach to things, which in turn again gives us more time to focus on more important tasks. Generally speaking, we use either commands or scripts as a way to do these scheduled tasks, and to execute them, we use <strong class="source-inline">cron daemon</strong> (<strong class="source-inline">crond</strong>). Let's learn how to use <strong class="source-inline">crond</strong> to schedule jobs in accordance with our needs.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor073"/>Getting ready</h2>
			<p>Keep the <strong class="source-inline">cli1</strong> virtual machine powered on and let's create some scheduled jobs via <strong class="source-inline">crond</strong>.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/>How to do it…</h2>
			<p>Let's start by using root to create a cron job. We are going to achieve that by typing in the following command as root:</p>
			<p class="source-code">crontab -e</p>
			<p>In Ubuntu, we are going to be asked to select which editor we want to use. For continuity reasons, let's say that we choose the vi editor (<strong class="source-inline">vi.basic</strong>). Let's add the following entry to the end of the file that we're editing in vi:</p>
			<p class="source-code">* * * * * ls -al /root &gt; /tmp/root.txt</p>
			<p>If we save the file<a id="_idIndexMarker144"/> as is, we just created the first root cron job – the one that's going to execute every minute. The <strong class="source-inline">*</strong> signs are actually <em class="italic">frequency fields</em> in these crontab files. Look at the following:</p>
			<p class="source-code">man 5 crontab</p>
			<p>Now scroll a bit lower on the man page; we're going to find the following examples:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="Images/Figure_3.25_B16269.jpg" alt="Figure 3.25 – Excerpt from man 5 crontab page&#13;&#10;" width="1327" height="972"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.25 – Excerpt from man 5 crontab page</p>
			<p>The first part <a id="_idIndexMarker145"/>explains the fields, as there are six of them. The first five are related to the frequency of executing the six fields. We can use space or <em class="italic">Tab</em> as delimiters between these fields. </p>
			<p>The first five fields are as follows:</p>
			<ul>
				<li>The <strong class="source-inline">minute</strong> field: At which minute the job should be executed</li>
				<li>The <strong class="source-inline">hour</strong> field: At which hour the job should be executed</li>
				<li>The <strong class="source-inline">day of month</strong> field: On which day of the month the job should be executed</li>
				<li>The <strong class="source-inline">month</strong> field: On which month the job should be executed</li>
				<li>The <strong class="source-inline">day of week</strong> field: On which day of the week the job should be executed</li>
			</ul>
			<p>All of these fields support various types of syntax:</p>
			<ul>
				<li><strong class="bold">Number</strong>: We can<a id="_idIndexMarker146"/> type any number that makes sense for a given field. For example, if we type the number <strong class="source-inline">75</strong> in the <strong class="source-inline">minute</strong> field, that doesn't make any sense as single numbers in the <strong class="source-inline">minute</strong> field go from <strong class="source-inline">0</strong> to <strong class="source-inline">59</strong>.</li>
				<li><strong class="bold">Range</strong>: We can type any range that makes sense for a given field. For example, if we type a range of <strong class="source-inline">3-47</strong> in the <strong class="source-inline">hour</strong> field, that won't work as the number range for hours is <strong class="source-inline">0-23</strong>.</li>
				<li><strong class="bold">Step values</strong>: We can type things such as <strong class="source-inline">0-10/2</strong> in the first field, which <strong class="source-inline">cron</strong> translates to <em class="italic">from the 0th to 10th minute, every second minute</em>.</li>
				<li><strong class="bold">Lists</strong>: If we use the previous example, we could've configured that so that we type <strong class="source-inline">0</strong>,<strong class="source-inline">2</strong>,<strong class="source-inline">4</strong>,<strong class="source-inline">6</strong>,<strong class="source-inline">8</strong>,<strong class="source-inline">10</strong>.</li>
				<li><strong class="bold">Combination thereof</strong>: Any combination of previously mentioned syntaxes.</li>
			</ul>
			<p>All of these syntaxes<a id="_idIndexMarker147"/> give us many different options to configure which jobs we want to execute and when, down to the minute. We also need to remember that <strong class="source-inline">cron</strong> doesn't allow frequency smaller than a minute. If we need to do something like that, we need to work <em class="italic">around</em> that fact (using the <strong class="source-inline">sleep</strong> function, the <strong class="source-inline">at</strong> command, and others).</p>
			<p>If we are logged in as root, that gives us the capability to manage a user's cron jobs as well. For example, say we type in the following command:</p>
			<p class="source-code">crontab -e -u student</p>
			<p>We are going to be editing <strong class="source-inline">crontab</strong> for the <strong class="source-inline">student</strong> user.</p>
			<p>Furthermore, if we want to remove <strong class="source-inline">student</strong>'s cron jobs, we can do it like this:</p>
			<p class="source-code">crontab -r -u student</p>
			<p>If we just need to list cron jobs from the <strong class="source-inline">student</strong> user, we can use the following command:</p>
			<p class="source-code">crontab -l -u student</p>
			<p>Let's go back to system cron jobs, the second most common type of cron jobs. These are configured in system folders under the <strong class="source-inline">/etc</strong> directory, such as <strong class="source-inline">/etc/cron.daily</strong> and <strong class="source-inline">/etc/cron.hourly</strong>. The keyword that follows <strong class="source-inline">cron.</strong> in the directory name tells us the frequency for all of the jobs configured in that folder. For example, let's take a look at the <strong class="source-inline">cron.daily</strong> folder:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="Images/Figure_3.26_B16269.jpg" alt="Figure 3.26 – Daily system cron jobs&#13;&#10;" width="834" height="355"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.26 – Daily system cron jobs</p>
			<p>Some of these<a id="_idIndexMarker148"/> filenames probably sound familiar. <strong class="source-inline">logrotate</strong> does log rotation, the <strong class="source-inline">mlocate</strong> job updates the file/folder database used by the <strong class="source-inline">updatedb</strong> command, and so on. At any given moment, there can be dozens of these system-wide cron jobs in those directories, depending on which packages we installed on our Linux server and how many additional system jobs we created ourselves. Let's use the <strong class="source-inline">logrotate</strong> file as an example:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="Images/Figure_3.27_B16269.jpg" alt="Figure 3.27 – logrotate cron.daily job, which actually executes a simple shell script&#13;&#10;" width="1106" height="555"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.27 – logrotate cron.daily job, which actually executes a simple shell script</p>
			<p>As we can see, this <a id="_idIndexMarker149"/>cron job actually executes a shell script, and its configuration is the polar opposite of what we saw in user cron jobs where <strong class="source-inline">crontab</strong> files have a very strict syntax. Here, we have much more freedom and the fact that we can just write outright shell script code in these files makes our job easier. We have a lot of additional content about shell scripting coming up later in this book, from <a href="B16269_09_Final_PD_ePub.xhtml#_idTextAnchor206"><em class="italic">Chapter 9</em></a>, <em class="italic">An Introduction to Shell Scripting</em>, all the way to the end of the book. So, let's table that discussion for a later time when we introduce all the necessary concepts – variables, loops, functions, arrays, and so on. It is going to be a lot of fun indeed.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/>How it works…</h2>
			<p><strong class="source-inline">crond</strong> is a spooling type of service – it creates queues of tasks that it needs to do and then executes them in accordance with specified criteria. In larger enterprises, we might consider <strong class="source-inline">crond</strong> criteria to be a part of a bigger picture that we usually call policy. Businesses rely on IT-related policies to implement standards and levels of service, and in that sense, IT policies are nothing more than objects describing a certain need. A need to do scheduled, daily<a id="_idIndexMarker150"/> backups, a need to run regular security checks by using an <strong class="bold">intrusion detection system</strong> (<strong class="bold">IDS</strong>) or antivirus, you name it. It doesn't really matter if we're talking about some general policies or security-related policies – policies are a standardized way of bringing IT chaos to order in a streamlined, compliance-oriented fashion. When we take a look at <strong class="source-inline">crond</strong>, it's one of those essential tools to deliver those policies.</p>
			<p><strong class="source-inline">crond</strong> takes care of<a id="_idIndexMarker151"/> different types of scheduled jobs:</p>
			<ul>
				<li><strong class="bold">System-related scheduled jobs</strong>: Daily, hourly, weekly, and other jobs that are executed in order for the system to work properly.</li>
				<li><strong class="bold">Delayed or deferred jobs</strong>: If a server has been turned off at the time when scheduled jobs should've been started, then it's up to <strong class="source-inline">crond</strong> to make sure to execute them later if we install the <strong class="source-inline">anacron</strong> package, which takes care of scenarios such as constant server shutdowns that would lead to periodic tasks not being executed regularly.</li>
				<li><strong class="bold">User-based crond jobs</strong>: These are per-user jobs that regular system users can create so that they can execute a job at a given moment.</li>
			</ul>
			<p>First and<a id="_idIndexMarker152"/> foremost, we need to learn how user-based cron jobs work, as these are the most common jobs on multi-user servers.</p>
			<p>When we use the <strong class="source-inline">crontab -e</strong> command for any given user, a <strong class="source-inline">crontab</strong> file gets created in one of the <strong class="source-inline">crond</strong> directories. These files are nothing special in terms of complexity – there's obviously a bit of syntax involved, but they're really well documented even when starting from scratch so that most users won't have problems with figuring this out. In Ubuntu, <strong class="source-inline">crontab</strong> files are created in the <strong class="source-inline">/var/spool/cron/crontabs</strong> directory, where all user cron jobs get saved as a text file per user. If a file in that directory is named as root, that means that the root user has a cron job. If there's a file named <strong class="source-inline">student</strong>, that means that the user called <strong class="source-inline">student</strong> has a cron job scheduled. This makes it easier to debug if it ever comes to that. Also, we need to take note of the fact that there are people who prefer to edit those files rather than using the <strong class="source-inline">crontab</strong> command. At the end of the day, whichever way we solve the IT problem that we need to solve is good, as long as it works properly. Let's take a look at one of those files – in this case, it's going to be an excerpt from the root user's <strong class="source-inline">crontab</strong> file:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="Images/Figure_3.28_B16269.jpg" alt="Figure 3.28 – Root's crontab file&#13;&#10;" width="996" height="248"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.28 – Root's crontab file</p>
			<p>We can clearly see that root scheduled a job to be executed every minute here. That job lists the content of the <strong class="source-inline">/root</strong> directory and saves it to a file in the <strong class="source-inline">/tmp</strong> directory called <strong class="source-inline">root.txt</strong>. It's simple enough, but it clearly shows the way in which <strong class="source-inline">crontab</strong> configuration files are created. </p>
			<p><strong class="source-inline">crond</strong> regularly <a id="_idIndexMarker153"/>checks these files and executes configuration stored in them at the scheduled time. This is the reason why it's very important to be careful what we put in these files. We really shouldn't put plain-text passwords, login information, or anything similar to these concepts in <strong class="source-inline">crontab</strong> files. By using the first five fields in the user's <strong class="source-inline">crontab</strong> file, <strong class="source-inline">crond</strong> determines the frequency for any given scheduled job. It parses these files line by line, which means that we can easily schedule multiple cron jobs as users, without any problems.</p>
			<p>If we run into problems with users scheduling too many cron jobs eating away at the performance of our server, we can always ban them from using <strong class="source-inline">crontab</strong>. For example, if we want to deny the <strong class="source-inline">student</strong> user the capability of creating user cron jobs, we just need to edit the <strong class="source-inline">/etc/cron.deny</strong> file and add a user name per line, like this:</p>
			<p class="source-code">student</p>
			<p>If we do that, and the user called <strong class="source-inline">student</strong> tries to create a cron job by using <strong class="source-inline">crontab -e</strong>, this is the expected result:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="Images/Figure_3.29_B16269.jpg" alt="Figure 3.29 – Using cron.deny to disable a user's right to use crontab&#13;&#10;" width="901" height="132"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.29 – Using cron.deny to disable a user's right to use crontab</p>
			<p>That's a wrap for this chapter. The next chapter is going to be all about using the shell to configure network <a id="_idIndexMarker154"/>settings, which includes both network interfaces and firewalls. Stay tuned!</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor076"/>There's more…</h2>
			<p>If we need to learn more about these concepts, we can check the following links:</p>
			<ul>
				<li><strong class="bold">Automating system tasks</strong>: <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-automating_system_tasks">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-automating_system_tasks</a></li>
				<li><strong class="bold">Crontab man page, chapter 5</strong>: <a href="https://man7.org/linux/man-pages/man5/crontab.5.html">https://man7.org/linux/man-pages/man5/crontab.5.html</a></li>
				<li><strong class="bold">How I use cron in Linux</strong>: <a href="https://opensource.com/article/17/11/how-use-cron-linux">https://opensource.com/article/17/11/how-use-cron-linux</a></li>
				<li><strong class="bold">Use anacron for a better crontab</strong>: <a href="https://opensource.com/article/21/2/linux-automation">https://opensource.com/article/21/2/linux-automation</a></li>
			</ul>
		</div>
	</div></body></html>