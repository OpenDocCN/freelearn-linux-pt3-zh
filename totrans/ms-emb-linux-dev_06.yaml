- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Building a Root Filesystem
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建根文件系统
- en: The root filesystem is the fourth element of embedded Linux. Once you have read
    this chapter, you will be able to build, boot, and run a simple embedded Linux
    system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统是嵌入式 Linux 的第四个要素。阅读完本章后，你将能够构建、启动并运行一个简单的嵌入式 Linux 系统。
- en: The techniques described here are broadly known as **roll your own**, or **RYO**.
    Back in the early days of embedded Linux, this was the only way to create a root
    filesystem. There are still some use cases where an RYO root filesystem is applicable
    – for example, when the amount of RAM or storage is very limited, for quick demonstrations,
    or for any case in which your requirements are not easily covered by the standard
    build system tools. However, these cases are quite rare.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的技术通常被称为 **自己动手做**，或 **RYO**。在嵌入式 Linux 的早期，这是一种创建根文件系统的唯一方式。至今，仍然有一些使用场景适用
    RYO 根文件系统——例如，当内存或存储非常有限时，用于快速演示，或在某些需求无法轻松通过标准构建系统工具覆盖的情况下。然而，这些场景相当罕见。
- en: The purpose of this chapter is educational. It is not meant to be a recipe for
    building everyday embedded systems. Use the tools described in the next chapter
    for this.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的在于教育性展示，并非构建日常嵌入式系统的配方。对于此类构建，请使用下一章中描述的工具。
- en: Our first objective is to create a minimal root filesystem that will give us
    a shell prompt. Then, using this as a base, we will add scripts to start up other
    programs and configure a network interface and user permissions. There are examples
    for both the BeaglePlay and QEMU targets. Knowing how to build the root filesystem
    from scratch is a useful skill. It will help you to understand what is going on
    when we look at more complex examples in later chapters.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个目标是创建一个最小的根文件系统，使其能提供一个 shell 提示符。然后，基于此，我们将添加脚本来启动其他程序并配置网络接口和用户权限。对于
    BeaglePlay 和 QEMU 目标都有示例。知道如何从头开始构建根文件系统是一个有用的技能。它将帮助你理解在后续章节中我们查看更复杂示例时发生了什么。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What should be in the root filesystem?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件系统中应该包含什么？
- en: Transferring the root filesystem to the target
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将根文件系统传输到目标设备
- en: Creating a boot `initramfs`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建引导 `initramfs`
- en: '`init` program'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init` 程序'
- en: Configuring user accounts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置用户账户
- en: A better way of managing device nodes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的设备节点管理方式
- en: Configuring the network
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置网络
- en: Creating filesystem images with device tables
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用设备表创建文件系统镜像
- en: Mounting the root filesystem using NFS
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NFS 挂载根文件系统
- en: Using TFTP to load the kernel
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TFTP 加载内核
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随示例，确保你拥有以下内容：
- en: An Ubuntu 24.04 or later LTS host system
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Ubuntu 24.04 或更高版本的 LTS 主机系统
- en: A microSD card reader and card
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台 microSD 卡读卡器和卡
- en: A microSD card prepared for the BeaglePlay from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 BeaglePlay 准备的 microSD 卡，来自[*第 4 章*](Chapter_04.xhtml#_idTextAnchor096)
- en: An `Image` file for QEMU from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[*第 4 章*](Chapter_04.xhtml#_idTextAnchor096)的 QEMU `Image` 文件
- en: A USB to TTL serial cable with a 3.3V logic level
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条带有 3.3V 逻辑电平的 USB 到 TTL 串行电缆
- en: A BeaglePlay
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台 BeaglePlay
- en: A 5V USB-C power supply capable of delivering 3A
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款能够提供 3A 电流的 5V USB-C 电源
- en: 'The code used in this chapter can be found in the `Chapter05` folder in the
    book’s GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter05](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter05).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在书籍 GitHub 仓库的 `Chapter05` 文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter05](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter05)。
- en: What should be in the root filesystem?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根文件系统中应该包含什么？
- en: The kernel gets a root filesystem either as an `initramfs` passed as a pointer
    from the bootloader, or by mounting the block device given on the kernel command
    line with the `root=` parameter. Once it has a root filesystem, the kernel executes
    the first program – by default, named `init`, as described in the *Early user
    space* section from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096). Then, as
    far as the kernel is concerned, its job is complete. It is up to the `init` program
    to start other programs and bring the system to life.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 内核通过引导加载程序传递的指针获得一个根文件系统，通常是一个`initramfs`，或者通过挂载内核命令行中给出的块设备（使用`root=`参数）。一旦它有了根文件系统，内核就会执行第一个程序——默认名为`init`，正如在[《第4章》](Chapter_04.xhtml#_idTextAnchor096)中*早期用户空间*部分所描述的那样。然后，就内核而言，它的工作已经完成。由`init`程序来启动其他程序并让系统运行起来。
- en: 'To make a minimal root filesystem, you need these components:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个最小化的根文件系统，你需要以下组件：
- en: '**init**: This is the program that starts everything off, usually by running
    a series of scripts. I will describe how `init` works in much more detail in [*Chapter
    13*](Chapter_13.xhtml#_idTextAnchor431).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**init**：这是启动一切的程序，通常通过运行一系列脚本来实现。我将在[《第13章》](Chapter_13.xhtml#_idTextAnchor431)中更详细地描述`init`的工作原理。'
- en: '**shell**: Gives you a command prompt and (more importantly) runs the shell
    scripts called by `init` and other programs.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**shell**：为你提供命令提示符，并（更重要的是）运行`init`和其他程序调用的Shell脚本。'
- en: '**daemons**: These are background programs that provide services to others.
    Good examples are the system log daemon (`syslogd`) and the secure shell daemon
    (`sshd`). The `init` program must start the initial population of daemons to support
    the main system applications. In fact, `init` is itself a daemon. It is the daemon
    that provides the service of launching other daemons.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**守护进程**：这些是后台程序，为其他程序提供服务。典型的例子包括系统日志守护进程（`syslogd`）和安全外壳守护进程（`sshd`）。`init`程序必须启动守护进程的初始集合，以支持主系统应用程序。实际上，`init`本身就是一个守护进程。它是提供启动其他守护进程服务的守护进程。'
- en: '**shared libraries**: Most programs are linked with shared libraries, so they
    must be present in the root filesystem.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享库**：大多数程序都与共享库链接，因此它们必须存在于根文件系统中。'
- en: '**configuration files**: These are a series of text files, usually stored in
    the `/etc` directory, that configure `init` and other daemons.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**：这些是一些文本文件，通常存储在`/etc`目录中，用于配置`init`和其他守护进程。'
- en: '**device nodes**: These are the special files that give access to various device
    drivers.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备节点**：这些是特殊文件，用于访问各种设备驱动程序。'
- en: '**proc and sys**: These are two pseudo filesystems that represent kernel data
    structures as a hierarchy of directories and files. Many programs and library
    functions depend on `/proc` and `/sys`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**proc 和 sys**：这两个伪文件系统将内核数据结构表示为一系列目录和文件。许多程序和库函数依赖于`/proc`和`/sys`。'
- en: '**kernel modules**: Need to be installed in the root filesystem, usually in
    `/lib/modules/<kernel version>`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核模块**：需要安装在根文件系统中，通常位于`/lib/modules/<kernel version>`目录下。'
- en: Additionally, there are the device-specific applications that make the device
    do the job it is intended for and the runtime data files that they generate.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些设备特定的应用程序，使设备能够完成其预定的工作，以及它们生成的运行时数据文件。
- en: '**IMPORTANT NOTE**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'In some cases, you could condense most of the above programs into a single
    statically linked program and start that program instead of `init`. For example,
    if your program was named `/myprog`, you would add the following command to the
    kernel command line: `init=/myprog`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可以将上述大多数程序合并为一个静态链接的程序，并启动该程序而不是`init`。例如，如果你的程序名为`/myprog`，你可以将以下命令添加到内核命令行：`init=/myprog`。
- en: I have come across such a configuration only once in a secure system in which
    the fork system call had been disabled, thus making it impossible for any other
    program to be started. The downside of this approach is that you can’t make use
    of the many tools that normally go into an embedded system. You have to do everything
    yourself.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一个安全系统中只遇到过一次这样的配置，其中禁用了`fork`系统调用，从而使得无法启动任何其他程序。这种方法的缺点是你无法使用通常嵌入式系统中的许多工具。你必须自己做所有事情。
- en: Directory layout
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录布局
- en: The Linux kernel does not care about the layout of files and directories beyond
    the existence of the program named by `init=` or `rdinit=`, so you are free to
    put things wherever you like. For example, compare the file layout of a device
    running Android to that of a desktop Linux distribution. They are almost completely
    different.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核并不关心文件和目录的布局，除非是存在名为`init=`或`rdinit=`的程序，因此你可以随意安排文件的存放位置。例如，比较运行 Android
    的设备与桌面 Linux 发行版的文件布局，它们几乎完全不同。
- en: 'However, many programs expect certain files to be in certain places, and it
    helps us developers if devices use a similar layout. The basic layout of most
    Linux systems is defined in the **Filesystem Hierarchy Standard** (**FHS**), which
    is available at [https://refspecs.linuxfoundation.org/fhs.shtml](https://refspecs.linuxfoundation.org/fhs.shtml).
    The FHS covers all implementations of Linux operating systems, from the largest
    to the smallest. Embedded devices tend to use a subset based on their needs, but
    each usually includes the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多程序期望某些文件位于特定的位置，若设备使用类似的布局对开发人员有帮助。大多数 Linux 系统的基本布局在**文件系统层次标准**（**FHS**）中有所定义，详情请见[https://refspecs.linuxfoundation.org/fhs.shtml](https://refspecs.linuxfoundation.org/fhs.shtml)。FHS涵盖了所有
    Linux 操作系统的实现，从最大到最小。嵌入式设备通常根据其需求使用一个子集，但每个设备通常都包括以下内容：
- en: '`/bin`: Programs essential for all users'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin`：所有用户都需要的程序'
- en: '`/dev`: Device nodes and other special files'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev`：设备节点和其他特殊文件'
- en: '`/etc`: System configuration files'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc`：系统配置文件'
- en: '`/lib`: Essential shared libraries, including those that make up the C library'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/lib`：基本的共享库，包括构成 C 库的库文件'
- en: '`/proc`: Information about processes represented as virtual files'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc`：以虚拟文件形式呈现的进程信息'
- en: '`/sbin`: Programs essential to the system administrator'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sbin`：系统管理员必需的程序'
- en: '`/sys`: Information about devices and their drivers, represented as virtual
    files'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys`：以虚拟文件形式呈现的设备及其驱动信息'
- en: '`/tmp`: A place to put temporary or volatile files'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tmp`：用于存放临时或易失性文件的地方'
- en: '`/usr`: Additional programs, libraries, and system administrator utilities
    stored in the directories `/usr/bin`, `/usr/lib`, and `/usr/sbin`, respectively'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr`：附加程序、库文件和系统管理员工具，分别存放在`/usr/bin`、`/usr/lib`和`/usr/sbin`目录中'
- en: '**IMPORTANT NOTE**'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The `/usr` directory contains all system-wide, read-only files that are installed
    or provided by the operating system. In the distant past, `/bin` , `/sbin`, and
    `/lib` only contained executables and libraries required for booting, while `/usr/bin`,
    `/usr/sbin`, and `/usr/lib` contained all the other executables and binaries.
    That distinction has since blurred, culminating in a modern movement that merges
    `/bin`, `/sbin`, and `/lib` into `/usr/bin`, `/usr/sbin`, and `/usr/lib`. Nowadays,
    the files in `/bin`, `/sbin`, and `/lib` are just symbolic links to their `/usr`
    counterparts. The `/usr/sbin` directory, like the `/sbin` directory, is for commands
    that can only be executed by the `root` user.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`/usr`目录包含所有系统范围内的只读文件，这些文件是由操作系统安装或提供的。过去，`/bin`、`/sbin`和`/lib`仅包含启动所需的可执行文件和库文件，而`/usr/bin`、`/usr/sbin`和`/usr/lib`包含所有其他可执行文件和二进制文件。这一区别后来模糊了，最终出现了将`/bin`、`/sbin`和`/lib`合并到`/usr/bin`、`/usr/sbin`和`/usr/lib`的现代趋势。如今，`/bin`、`/sbin`和`/lib`中的文件仅仅是指向它们在`/usr`中的对应文件的符号链接。`/usr/sbin`目录像`/sbin`目录一样，存放只能由`root`用户执行的命令。'
- en: '`/var`: a hierarchy of files and directories that can be modified at runtime,
    like log messages, some of which must be retained after boot'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var`：在运行时可以修改的文件和目录层次结构，例如日志信息，其中一些必须在启动后保留'
- en: There are some subtle distinctions here. The difference between `/bin` and `/sbin`
    is simply that the latter need not be included in the search path for non-root
    users. Users of Red Hat-derived distributions will be familiar with this.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些微妙的区别。`/bin`和`/sbin`的区别仅仅在于后者不需要包含在非 root 用户的搜索路径中。Red Hat 衍生的发行版用户对此应该比较熟悉。
- en: Staging directory
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时目录
- en: 'You should begin by creating a **staging** directory on your host computer
    where you can assemble the files that will eventually be transferred to the target.
    In the following examples, I have used `~/rootfs`. You need to create a skeleton
    directory structure in it. Look at the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该首先在主机计算机上创建一个**临时**目录，用于汇总最终会被传输到目标设备的文件。在以下示例中，我使用了`~/rootfs`。你需要在其中创建一个骨架目录结构。请看下面：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To see the directory hierarchy more clearly, you can use the handy `tree` command
    with the `-d` option to show only the directories:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要更清晰地查看目录层次结构，可以使用便捷的`tree`命令，带上`-d`选项仅显示目录：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Not all directories have the same file permissions, and the individual files
    inside a directory can have stricter permissions than the directory itself.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有目录具有相同的文件权限，目录中的个别文件可以比目录本身有更严格的权限。
- en: POSIX file access permissions
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POSIX文件访问权限
- en: Every process or running program belongs to a user and one or more groups. The
    user is represented by a 32-bit number called the **user ID** or **UID**. Information
    about users, including the mapping from a UID to a name, is kept in `/etc/passwd`.
    Likewise, groups are represented by a **group ID** or **GID**, with information
    kept in `/etc/group`. There is always a `root` user with a UID of 0 and a `root`
    group with a GID of 0\. The `root` user is also called the **superuser** because,
    in a default configuration, it bypasses most permission checks and can access
    all the resources in the system. Security in Linux-based systems is mainly about
    restricting access to the root account.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程或运行程序都属于一个用户和一个或多个组。用户由一个称为**用户ID**或**UID**的32位数字表示。关于用户的信息，包括从UID到名称的映射，保存在`/etc/passwd`中。同样，组由一个称为**组ID**或**GID**的数字表示，信息保存在`/etc/group`中。始终存在一个`root`用户，其UID为0，并且一个`root`组，其GID为0。`root`用户也称为**超级用户**，因为在默认配置下，它可以绕过大部分权限检查并访问系统中的所有资源。Linux系统中的安全性主要是关于限制对root账户的访问。
- en: 'Each file and directory also has an owner and belongs to exactly one group.
    The level of access a process has to a file or directory is controlled by a set
    of access permission flags called the **mode** of the file. There are three collections
    of three bits: the first collection applies to the *owner* of the file, the second
    to the *members* of the same group as the file, and the last to *everyone else*
    – the rest of the world. The bits are for **read** (`r`), **write** (`w`), and
    **execute** (`x`) permissions on the file. Three bits result in 2³ = 8 possible
    values, represented as octal digits from 0 to 7:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件和目录还有一个所有者，并且属于恰好一个组。进程对文件或目录的访问级别由一组称为文件的**模式**的访问权限标志控制。有三组三位数：第一组适用于文件的*所有者*，第二组适用于与文件相同组的*成员*，最后一组适用于*其他所有人*
    - 世界上的其余人。这些位用于文件的**读**（`r`）、**写**（`w`）和**执行**（`x`）权限。三位数的组合产生2³ = 8个可能的值，表示为从0到7的八进制数字：
- en: '0: No permissions'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: 没有权限'
- en: '1: Execute only (--x)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1: 仅执行 (--x)'
- en: '2: Write only (-w-)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '2: 只写 (-w-)'
- en: '3: Write and execute (-wx)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '3: 写和执行 (-wx)'
- en: '4: Read only (r--)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '4: 只读 (r--)'
- en: '5: Read and execute (r-x)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '5: 读和执行 (r-x)'
- en: '6: Read and write (rw-)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '6: 读和写 (rw-)'
- en: '7: Read, write, and execute (rwx)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '7: 读、写和执行 (rwx)'
- en: Since three bits fit neatly into an octal digit, file access permissions are
    usually represented in octal.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于三位数可以完美地放入八进制数字中，文件访问权限通常用八进制表示。
- en: 'Here are some common file modes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些常见的文件模式：
- en: '600: Owner - rw-, Group - ---, and Others - ---'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '600: 所有者 - rw-, 组 - ---, 和其他人 - ---'
- en: '644: Owner - rw-, Group - r--, and Others - r--'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '644: 所有者 - rw-, 组 - r--, 和其他人 - r--'
- en: '666: Owner - rw-, Group - rw-, and Others - rw-'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '666: 所有者 - rw-, 组 - rw-, 和其他人 - rw-'
- en: '700: Owner - rwx, Group - ---, and Others - ---'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '700: 所有者 - rwx, 组 - ---, 和其他人 - ---'
- en: '755: Owner - rwx, Group - r-x, and Others - r-x'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '755: 所有者 - rwx, 组 - r-x, 和其他人 - r-x'
- en: '775: Owner - rwx, Group - rwx, and Others - r-x'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '775: 所有者 - rwx, 组 - rwx, 和其他人 - r-x'
- en: '777: Owner - rwx, Group - rwx, and Others - rwx'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '777: 所有者 - rwx, 组 - rwx, 和其他人 - rwx'
- en: 'The first (leftmost) bit of an octal digit is a value of 4, the second (center)
    bit is a value of 2, and the third (rightmost) bit is a value of 1, as shown below:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 八进制数字的第一个（最左边的）位是值为4，第二个（中间的）位是值为2，第三个（最右边的）位是值为1，如下所示：
- en: '![Figure 5.1 – File access permissions](img/B18466_05_01.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 文件访问权限](img/B18466_05_01.png)'
- en: Figure 5.1 – File access permissions
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 文件访问权限
- en: If all three bits in a collection are set, then the octal value of that collection
    is 4 + 2 + 1 = 7\. Each row in the above diagram comprises 3 collections for a
    total of 9 bits.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合中的三位数都设置了，则该集合的八进制值为4 + 2 + 1 = 7。上述图表中的每一行包含3个集合，总共有9位。
- en: 'There is a fourth preceding octal digit whose value has special significance:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个第四个前导的八进制数字，其值具有特殊意义：
- en: '**SUID (4)**: If the file is executable, it changes the effective UID of the
    process to that of the file owner when the program is run.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SUID (4)**: 如果文件是可执行的，它会在程序运行时将进程的有效UID更改为文件所有者的UID。'
- en: '**SGID (2)**: Like SUID, this changes the effective GID of the process to that
    of the group of the file.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SGID (2)**：与SUID类似，这会将进程的有效GID更改为文件所属组的GID。'
- en: '**Sticky (1)**: In a directory, this restricts deletion so that one user cannot
    delete files that are owned by another user. This is usually set on `/tmp` and
    `/var/tmp`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sticky (1)**：在一个目录中，它限制删除操作，使得一个用户不能删除另一个用户拥有的文件。通常这会设置在`/tmp`和`/var/tmp`目录下。'
- en: 'The SUID bit is probably used most often. It gives non-root users a temporary
    privilege escalation to superuser to perform a task. The `ping` program is a good
    example: `ping` opens a raw socket, which is a privileged operation. The `ping`
    executable is owned by user `root` and has the SUID bit set so that when you run
    `ping`, it executes with UID 0 regardless of your UID.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: SUID位可能是最常用的。它赋予非root用户临时提升到超级用户的权限来执行任务。`ping`程序是一个很好的例子：`ping`打开一个原始套接字，这是一个特权操作。`ping`可执行文件由`root`用户拥有，并且设置了SUID位，这样当你运行`ping`时，无论你的UID是什么，它都会以UID
    0执行。
- en: 'To set this leading octal digit, use values of either `4`, `2`, and `1` with
    the `chmod` command. For example, to set SUID on `/bin/ping` in your staging root
    directory, you would prepend `4` to a mode of `755` like so:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置这个前导八进制数字，可以使用`chmod`命令的`4`、`2`和`1`值。例如，要在暂存根目录中的`/bin/ping`上设置SUID，可以将`4`加到模式`755`前面，如下所示：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the second `ls` command shows the first three bits of the mode to
    be `rws`, whereas previously, they had been `rwx`. That `s` indicates that the
    SUID bit is set.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第二个`ls`命令显示模式的前三个位为`rws`，而之前是`rwx`。那个`s`表示SUID位已设置。
- en: File ownership permissions in the staging directory
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂存目录中的文件所有权权限
- en: For security and stability reasons, it is important to pay attention to the
    ownership and permissions of the files that will be placed on the target device.
    In general, you want to restrict sensitive resources to be accessible only by
    the `root` user and run as few programs using non-root users as possible. It is
    best to run programs using non-root users so that if they are compromised by an
    outside attack, they offer as few system resources to the attacker as possible.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全性和稳定性的考虑，必须注意将要放置在目标设备上的文件的所有权和权限。通常，你需要将敏感资源的访问限制为只有`root`用户才能访问，并尽可能减少非root用户运行程序的数量。最好是使用非root用户来运行程序，这样如果它们被外部攻击者攻破，它们提供给攻击者的系统资源将尽可能少。
- en: For example, the device node called `/dev/mem` gives access to system memory,
    which is necessary in some programs. But if it is readable and writeable by everyone,
    then there is no security because everyone can access everything in memory. So
    `/dev/mem` should be owned by `root`, belong to the `root` group, and have a mode
    of `600` that denies read and write access to all but the owner.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，名为`/dev/mem`的设备节点提供对系统内存的访问，这是某些程序所必需的。但是，如果它对所有人都可读写，那么就没有安全性，因为任何人都可以访问内存中的所有内容。所以，`/dev/mem`应该由`root`所有，属于`root`组，并且设置模式为`600`，以拒绝除所有者外的所有人读写访问。
- en: 'However, there is a problem with the staging directory. The files you create
    there will be owned by you. But when they are installed on the device, they should
    belong to specific owners and groups, mostly the `root` user. An obvious fix is
    to change the ownership to `root` at this stage, with the commands shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，暂存目录存在一个问题。你在那里创建的文件将属于你。但是，当它们被安装到设备上时，它们应该属于特定的所有者和组，通常是`root`用户。一个明显的解决方法是在此阶段将所有权更改为`root`，可以使用下面的命令：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**IMPORTANT NOTE**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Do not run the preceding `sudo chown -R root:root *` command. You could damage
    your filesystem irreparably.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不要运行前面的`sudo chown -R root:root *`命令。你可能会不可逆转地损坏你的文件系统。
- en: The problem is that you need `root` privileges to run the `chown` command. And
    from that point onward, you will need to be `root` to modify any files in the
    staging directory. Before you know it, you are doing all your development logged
    in as `root`, which is not a good idea. This is a problem that we will revisit
    when creating a standalone `initramfs`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，你需要`root`权限来运行`chown`命令。从那时起，你将需要`root`权限来修改暂存目录中的任何文件。不知不觉中，你可能就以`root`身份登录进行开发，这并不是一个好主意。我们将在创建独立的`initramfs`时重新审视这个问题。
- en: Programs for the root filesystem
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根文件系统程序
- en: Now, it is time to start populating the root filesystem with the essential programs
    and the supporting libraries, configuration, and data files they need to operate.
    I will begin with an overview of the types of programs you will need.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始为根文件系统填充必要的程序以及它们运行所需的支持库、配置文件和数据文件了。我将首先概述你需要的程序类型。
- en: init program
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: init程序
- en: '`init` is the first program to be run, so it is an essential part of the root
    filesystem. In this chapter, we will use the simple `init` program provided by
    BusyBox.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`是第一个运行的程序，因此它是根文件系统的重要组成部分。在本章中，我们将使用BusyBox提供的简单`init`程序。'
- en: Shell
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shell
- en: 'We need a shell to run scripts and to give us a command prompt so that we can
    interact with the system. An interactive shell is probably not necessary in a
    production device, but it is useful for development, debugging, and maintenance.
    There are various shells in common use on embedded systems:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个Shell来运行脚本并提供命令提示符，以便我们与系统进行交互。在生产设备中可能不需要交互式Shell，但在开发、调试和维护中非常有用。嵌入式系统上常用的Shell有几种：
- en: '`bash`: This is the big beast that we all know and love from desktop Linux.
    It is a superset of the Unix Bourne shell with many extensions or bashisms.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bash`：这是我们在桌面Linux中都熟知并喜爱的“大怪兽”。它是Unix Bourne shell的超集，具有许多扩展或bash特性。'
- en: '`ash`: This is also based on the Bourne shell and has a long history with the
    BSD variants of Unix. BusyBox has a version of `ash` that has been extended to
    make it more compatible with `bash`. It is much smaller than `bash`, and hence,
    it is a very popular choice for embedded systems.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ash`：这也是基于Bourne shell的，并且在Unix的BSD变种中有着悠久的历史。BusyBox有一个版本的`ash`，它经过扩展，使其更加兼容`bash`。它比`bash`小得多，因此它是嵌入式系统中非常流行的选择。'
- en: '`hush`: This is a very small shell that we briefly looked at in [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061).
    It is useful on devices with very little memory. There is a version of `hush`
    in BusyBox.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hush`：这是一款非常小的shell，我们在[*第3章*](Chapter_03.xhtml#_idTextAnchor061)中简要地看过它。它在内存非常有限的设备上非常有用。BusyBox中有一个版本的`hush`。'
- en: '**TIP**'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**提示**'
- en: If you are using `ash` or `hush` as the shell on the target, make sure that
    you test your shell scripts on the target. It is very tempting to test them only
    on the host using `bash` and then be surprised that they don’t work when you copy
    them to the target.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在目标设备上使用`ash`或`hush`作为shell，确保在目标设备上测试你的脚本。仅仅在主机上使用`bash`测试它们，而在将它们复制到目标设备后却发现它们无法正常工作，这是很容易犯的错误。
- en: Utilities
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实用工具
- en: The shell is just a way of launching other programs. A shell script is little
    more than a list of programs to run with some flow control and a means of passing
    information between them. To make a shell useful, you need the utility programs
    that the Unix command line is based on. Even a basic root filesystem needs approximately
    50 utilities. This presents two problems. Firstly, tracking down the source code
    for each one and cross-compiling all of it is a big job. Secondly, the resulting
    collection of programs takes up several tens of megabytes. This was a real problem
    in the early days of embedded Linux when a few megabytes were all you had. BusyBox
    was created expressly to solve this problem.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Shell仅仅是启动其他程序的一种方式。Shell脚本不过是一个程序列表，包含一些流程控制和在程序之间传递信息的方式。为了使一个Shell有用，你需要一些Unix命令行所依赖的实用程序。即使是一个基本的根文件系统，也需要大约50个实用程序。这带来了两个问题。首先，找到每个程序的源代码并交叉编译所有这些程序是一项大工程。其次，最终的程序集合会占用几十兆字节的存储空间。这在嵌入式Linux的早期是一个真正的问题，当时设备的存储容量只有几兆字节。BusyBox正是为了应对这个问题而创建的。
- en: BusyBox to the rescue!
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BusyBox来拯救我们了！
- en: The genesis of BusyBox had nothing to do with embedded Linux. Bruce Perens started
    the project in 1996 for the Debian installer so that he could boot Linux from
    a 1.44 MB floppy disk. Coincidentally, this was about the size of the storage
    on contemporary devices so the embedded Linux community quickly took it up. BusyBox
    has been at the heart of embedded Linux ever since.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox的诞生与嵌入式Linux无关。Bruce Perens在1996年启动了这个项目，为了使Debian安装程序能够从1.44 MB的软盘启动Linux。巧合的是，这个存储大小与当时设备的存储容量差不多，因此嵌入式Linux社区迅速接受了它。从那时起，BusyBox就一直是嵌入式Linux的核心。
- en: 'BusyBox was written from scratch to perform the essential functions of those
    essential Linux utilities. The developers took advantage of the 80/20 rule: the
    most useful 80% of a program is implemented in 20% of the code. Hence, BusyBox
    tools implement a subset of the functionality of their desktop equivalents, but
    they do enough to be useful in most cases.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox 从零开始编写，旨在执行那些基本 Linux 工具的基本功能。开发者运用了 80/20 原则：一个程序最有用的 80% 功能是由 20%
    的代码实现的。因此，BusyBox 工具实现了桌面版工具功能的一个子集，但足以在大多数情况下满足需求。
- en: 'Another trick BusyBox employs is to combine all the tools together into a single
    binary, making it easy to share code between them. It works like this: BusyBox
    is a collection of applets, each of which exports its `main` function in the form
    `<applet>_main`. For example, the `cat` command is implemented in `coreutils/cat.c`
    and exports `cat_main`. The `main` function of BusyBox dispatches the call to
    the correct applet, based on the command-line arguments.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 BusyBox 使用的技巧是将所有工具合并到一个单一的二进制文件中，从而方便它们之间共享代码。具体操作如下：BusyBox 是一系列小工具的集合，每个小工具都以
    `<applet>_main` 的形式导出其 `main` 函数。例如，`cat` 命令在 `coreutils/cat.c` 中实现，并导出 `cat_main`。BusyBox
    的 `main` 函数根据命令行参数将调用调度到正确的小工具。
- en: 'To read a file, you can launch BusyBox with the name of the applet you want
    to run, followed by any arguments that the applet expects:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取文件，你可以通过启动 BusyBox 并指定你要运行的小工具的名称，后跟小工具需要的任何参数：
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can also run BusyBox with no arguments to get a list of all the applets
    that have been compiled.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以运行 BusyBox 而不带任何参数，以获取已编译的所有小工具的列表。
- en: 'Using BusyBox in this way is rather clumsy. A better way to get BusyBox to
    run the `cat` applet is to create a symbolic link from `/bin/cat` to `/bin/busybox`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这样使用 BusyBox 有点笨拙。让 BusyBox 运行 `cat` 小工具的更好方法是从 `/bin/cat` 创建一个符号链接到 `/bin/busybox`：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you type `cat` at the command line, BusyBox is the program that actually
    runs. BusyBox only has to check the path to the executable (`/bin/cat`) passed
    in via `argv[0]`, extract the application name (`cat`), and do a table lookup
    to match `cat` with `cat_main`. All this is expressed in this slightly simplified
    section of code from `libbb/appletlib.c`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在命令行输入`cat`时，实际运行的程序是 BusyBox。BusyBox 只需要检查传入的可执行文件路径（`/bin/cat`），提取应用程序名称（`cat`），然后进行表格查找，将`cat`与`cat_main`匹配。所有这些在
    `libbb/appletlib.c` 中的这一段简化代码中有体现：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: BusyBox has over 300 applets, including an `init` program, several shells with
    varying levels of complexity, and utilities for most admin tasks. There is even
    a simple version of the `vi` editor so that you can change text files on your
    device. A typical BusyBox binary will only enable several dozen applets.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox 包含超过 300 个小工具，包括一个 `init` 程序、几个具有不同复杂度的 shell 以及用于大多数管理任务的工具。甚至还有一个简单版本的
    `vi` 编辑器，方便你在设备上修改文本文件。一个典型的 BusyBox 二进制文件将只启用几十个小工具。
- en: In summary, a typical installation of BusyBox consists of a single program,
    with a symbolic link for each applet but which behaves exactly as if it were a
    collection of individual applications.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，典型的 BusyBox 安装由一个单一程序组成，每个小工具都有一个符号链接，但其行为与多个独立应用程序完全一致。
- en: Building BusyBox
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 BusyBox
- en: 'BusyBox uses the same `Kconfig` and `Kbuild` system as the kernel, so cross-compiling
    is straightforward. Get the source by cloning the BusyBox Git repo and checking
    out the version you want (`1_36_1` was the latest in August 2024):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox 使用与内核相同的 `Kconfig` 和 `Kbuild` 系统，因此交叉编译非常简单。通过克隆 BusyBox Git 仓库并检查你想要的版本（2024
    年 8 月时最新版本是 `1_36_1`）来获取源码：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can also download the corresponding TAR file from [https://busybox.net/downloads/](https://busybox.net/downloads/).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从 [https://busybox.net/downloads/](https://busybox.net/downloads/) 下载相应的
    TAR 文件。
- en: 'Configure BusyBox with the default configuration, which enables pretty much
    all of the features:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认配置来配置 BusyBox，这将启用几乎所有功能：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At this point, you probably want to run `make menuconfig` to fine-tune the
    configuration. For example, you almost certainly want to set the install path
    in **Settings | Installation Options (“make install” behavior) | Destination path
    for ‘make install’** to point to the staging directory. Then, you can cross-compile
    in the usual way. If your intended target is the BeaglePlay, use these commands:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你可能需要运行 `make menuconfig` 来微调配置。例如，你几乎肯定需要在 **设置 | 安装选项（“make install”行为）|
    ‘make install’ 的目标路径** 中设置安装路径，指向暂存目录。然后，你就可以按常规方式进行交叉编译。如果你的目标平台是 BeaglePlay，可以使用以下命令：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can cross-compile BusyBox for the 64-bit Arm generic virtual platform emulated
    by QEMU in the same way.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以相同的方式为QEMU模拟的64位Arm通用虚拟平台交叉编译BusyBox。
- en: In either case, the result is the `busybox` executable. For a default configuration
    build like this, the size is about 1,100 KB. If this is too big for you, then
    you can slim it down by changing the configuration to leave out the utilities
    you don’t need.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，结果都是`busybox`可执行文件。对于像这样的默认配置构建，大小约为1,100KB。如果这个文件太大，你可以通过更改配置来删除不需要的工具，从而减小它的体积。
- en: 'To install BusyBox in the staging area, use the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要将BusyBox安装到暂存区，请使用以下命令：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will copy the binary to the directory configured in **Destination path
    for ‘make install’** and create all the symbolic links to it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把二进制文件复制到**“make install”目标路径**中，并为其创建所有的符号链接。
- en: Now, let’s look at an alternative to Busybox, known as ToyBox.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看另一个替代品，ToyBox。
- en: ToyBox – an alternative to BusyBox
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ToyBox——BusyBox的替代品
- en: BusyBox is not the only game in town. There is also ToyBox, which you can find
    at [https://landley.net/toybox/](https://landley.net/toybox/). The project was
    started by Rob Landley, who was previously a maintainer of BusyBox. ToyBox has
    the same aim as BusyBox but with more emphasis on complying with standards (especially
    POSIX-2008 and LSB 4.1) and less on compatibility with GNU extensions to those
    standards. ToyBox is smaller than BusyBox, partly because it implements fewer
    applets.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox并不是唯一的选择。还有ToyBox，你可以在[https://landley.net/toybox/](https://landley.net/toybox/)找到它。该项目由Rob
    Landley发起，他曾是BusyBox的维护者。ToyBox的目标与BusyBox相同，但更加注重遵守标准（尤其是POSIX-2008和LSB 4.1），而不太关注与GNU扩展兼容性。ToyBox比BusyBox小，部分原因是它实现了更少的工具。
- en: The license for ToyBox is BSD rather than GPL v2, making it compatible with
    operating systems that have a BSD-licensed user space such as Android. Hence,
    ToyBox ships with all new Android devices. As of the 0.8.3 release, Toybox’s `Makefile`
    can build a full Linux system that boots to a shell prompt when given just the
    Linux and ToyBox sources.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ToyBox的许可证是BSD，而不是GPL v2，这使得它与那些采用BSD许可证用户空间的操作系统兼容，比如Android。因此，ToyBox与所有新的Android设备一起发布。从0.8.3版本开始，ToyBox的`Makefile`可以构建一个完整的Linux系统，当只提供Linux和ToyBox的源代码时，它可以启动并进入Shell提示符。
- en: Libraries for the root filesystem
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根文件系统的库
- en: Programs are linked with libraries. You can link them all statically so that
    no libraries reside on the target device. This takes up an unnecessarily large
    amount of storage if you have more than two or three programs. To reduce the size
    of your programs, you need to copy shared libraries from the toolchain to the
    staging directory. But how do you know which libraries to copy?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 程序是与库链接的。你可以将它们全部静态链接，这样就不会在目标设备上驻留任何库。如果你有超过两到三个程序，这会占用不必要的大量存储空间。为了减小程序的大小，你需要将共享库从工具链复制到暂存目录。但是，你怎么知道该复制哪些库呢？
- en: One option is to copy all the `.so` files from the `sysroot` directory of your
    toolchain. Instead of trying to predict which libraries to include, just assume
    that your image will eventually need them all. This is certainly logical, and
    if you are creating a platform to be used by others for a range of applications,
    it would be the correct approach. However, be aware that a full glibc is quite
    large. In the case of Buildroot’s build of glibc, the libraries, locales, and
    other supporting files come to 22 MB. You can cut that down considerably by using
    musl or uClibc-ng.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是从你的工具链的`sysroot`目录复制所有的`.so`文件。与其试图预测要包含哪些库，不如假设你的镜像最终会需要它们所有。这种做法无疑是合理的，如果你正在创建一个供他人使用的多种应用平台，那么这种方法是正确的。然而，要注意，完整的glibc是相当庞大的。在Buildroot构建的glibc的情况下，库、区域设置和其他支持文件总共达到了22MB。通过使用musl或uClibc-ng，你可以大大减少这个大小。
- en: 'Another option is to cherry-pick only those libraries that you require. To
    do that, you need a means of discovering library dependencies. Let’s use the `readelf`
    command from [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028) for this task:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是只挑选你需要的那些库。为此，你需要一种发现库依赖关系的方法。让我们使用来自[*第2章*](Chapter_01.xhtml#_idTextAnchor028)的`readelf`命令来完成这项任务：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first `readelf` command searches the `busybox` binary for lines containing
    `program interpreter`. The second `readelf` command searches the `busybox` binary
    for lines containing `Shared library`. Now, you need to find these files in the
    toolchain `sysroot` directory and copy them to the staging directory. Remember
    that you can find `sysroot` like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`readelf`命令搜索`busybox`二进制文件中包含`program interpreter`的行。第二个`readelf`命令搜索`busybox`二进制文件中包含`Shared
    library`的行。现在，你需要在工具链的`sysroot`目录中找到这些文件，并将它们复制到暂存目录。记住，你可以这样找到`sysroot`：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To reduce typing, keep a copy of the `sysroot` path in a shell variable:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少输入，可以将`sysroot`路径保存在一个shell变量中：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s look at `/lib/ld-linux-aarch64.so.1` in `sysroot`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一下`sysroot`中的`/lib/ld-linux-aarch64.so.1`：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Repeat the exercise for `libc.so.6`, `libm.so.6` and `libresolv.so.2` so that
    you end up with a list of four files. Now, copy each one to your `rootfs` directory:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对`libc.so.6`、`libm.so.6`和`libresolv.so.2`进行相同的操作，这样你就会得到四个文件的列表。现在，将每个文件复制到`rootfs`目录中：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These are just the shared libraries needed by `busybox`. Repeat this procedure
    for each program you wish to add to your `rootfs` directory.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是`busybox`所需的共享库。对于每个你希望添加到`rootfs`目录中的程序，重复此过程。
- en: '**TIP**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: It is only worth doing this to get the very smallest embedded footprint possible.
    There is a danger that you will miss libraries that are loaded through `dlopen(3)`
    calls–plugins mostly. We will look at an example with the **name service switch**
    (**NSS**) libraries when we come to configure network interfaces later on in this
    chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在需要最小化嵌入式系统占用空间时，做这个操作才有意义。这样做的风险是，你可能会错过通过`dlopen(3)`调用加载的库，主要是插件。我们将在本章稍后讨论配置网络接口时，探讨与**名称服务切换**（**NSS**）库的例子。
- en: Reducing size by stripping
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过去除符号表减少文件大小
- en: 'Libraries and programs are often compiled with some information stored in symbol
    tables to aid with debugging and tracing. You seldom need these in a production
    system. A quick and easy way to save space is to strip the binaries of symbol
    tables. This example shows `libc` before stripping:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 库和程序通常会在符号表中存储一些信息，用于调试和追踪。在生产系统中，你很少需要这些信息。节省空间的一种快速简便的方法是去除二进制文件中的符号表。这个例子展示了去除前的`libc`：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let’s see the result of stripping debug information:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看一下去除调试信息后的结果：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, we saved 532,616 bytes, or about 28% of the size of the file,
    before stripping.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在去除调试信息之前节省了532,616字节，即文件大小的约28%。
- en: '**TIP**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: 'Be careful about stripping kernel modules. Some symbols are required by the
    module loader to relocate the module code, so the module will fail to load if
    they are stripped out. Use this command to remove debug symbols while keeping
    those used for relocation: `strip --strip-unneeded <module name>`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要去除内核模块的调试符号。某些符号是模块加载器在重新定位模块代码时所必需的，如果这些符号被去除，模块将无法加载。使用此命令移除调试符号，同时保留用于重定位的符号：`strip
    --strip-unneeded <模块名>`。
- en: Device nodes
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备节点
- en: Most devices in Linux are represented by device nodes in accordance with the
    Unix philosophy that *everything is a file* (except network interfaces, which
    are sockets). A device node may refer to a block device or a character device.
    Block devices are mass storage devices such as SD cards or hard drives. A character
    device is pretty much anything else (again, except for network interfaces).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，大多数设备通过设备节点来表示，符合Unix哲学中的*一切皆文件*（网络接口除外，网络接口是套接字）。设备节点可以指代块设备或字符设备。块设备是大容量存储设备，如SD卡或硬盘。字符设备几乎包括所有其他设备（同样，网络接口除外）。
- en: The conventional place for device nodes is the `/dev` directory. For example,
    a serial port can be represented by a device node called `/dev/ttyS0`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 设备节点的常规位置是`/dev`目录。例如，串口可以通过名为`/dev/ttyS0`的设备节点来表示。
- en: 'Device nodes are created using the program named `mknod` (short for make node):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 设备节点是通过名为`mknod`（即“创建节点”）的程序创建的：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The parameters for `mknod` are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`mknod`的参数如下：'
- en: '**name** is the name of the device node that you want to create.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**是你要创建的设备节点的名称。'
- en: '**type** is either c for character devices or b for a block device.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**是字符设备（c）或块设备（b）。'
- en: '**major** and **minor** are a pair of numbers that are used by the kernel to
    route file requests to the appropriate device driver code. There is a list of
    standard major and minor numbers in the kernel source file: `Documentation/admin-guide/devices.txt`.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主设备号**和**次设备号**是一对数字，内核通过它们将文件请求路由到相应的设备驱动代码。内核源文件中有一个标准主设备号和次设备号的列表：`Documentation/admin-guide/devices.txt`。'
- en: You will need to create device nodes for all the devices that you want to access
    on your system. You can do so manually using the `mknod` command illustrated here,
    or you can create them automatically at runtime using one of the device managers
    mentioned later.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为系统中要访问的所有设备创建设备节点。你可以手动使用下面示范的 `mknod` 命令来创建，或者可以使用稍后提到的设备管理器在运行时自动创建它们。
- en: 'In a minimal root filesystem, you need just two nodes to boot with BusyBox:
    `console` and `null`. The `console` only needs to be accessible to `root`, the
    owner of the device node, so the access permissions are `600` (`rw-------`). The
    `null` device should be readable and writable by everyone, so the mode is `666`
    (`rw-rw-rw-`). Use the `-m` option for `mknod` to set the `mode` when creating
    the node. You need to be `root` to create device nodes:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小化根文件系统中，你只需要两个节点来使用 BusyBox 启动：`console` 和 `null`。`console` 只需要对设备节点的所有者
    `root` 可访问，因此其访问权限为 `600`（`rw-------`）。`null` 设备应该对所有人都可读可写，所以它的模式为 `666`（`rw-rw-rw-`）。使用
    `-m` 选项设置 `mknod` 创建节点时的 `mode`。你需要是 `root` 用户才能创建设备节点：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can delete device nodes using the standard `rm` command. There is no `rmnod`
    command because, once created, they are just files.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准的 `rm` 命令删除设备节点。没有 `rmnod` 命令，因为一旦创建，它们就只是文件。
- en: Proc and sysfs filesystems
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Proc 和 sysfs 文件系统
- en: '`proc` and `sysfs` are two pseudo filesystems that offer a window into the
    inner workings of the kernel. They both represent kernel data as files in a hierarchy
    of directories. When you read one of these files, the contents you see do not
    come from disk storage. Instead, it is formatted on the fly by a function in the
    kernel. Some files are also writable, meaning that a kernel function is called
    with the new data you have written. If the data is formatted correctly and you
    have sufficient permissions, then the function modifies the value stored in the
    kernel’s memory. In other words, `proc` and `sysfs` provide another way to interact
    with device drivers and other kernel code.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`proc` 和 `sysfs` 是两个伪文件系统，它们提供了一个观察内核内部工作原理的窗口。它们都将内核数据以文件的形式表示在一个目录层次结构中。当你读取这些文件时，看到的内容并不是来自磁盘存储。相反，它是由内核中的一个函数即时格式化的。有些文件也可以写入，这意味着当你写入新的数据时，内核函数会被调用。如果数据格式正确，并且你具有足够的权限，那么该函数将修改内核内存中存储的值。换句话说，`proc`
    和 `sysfs` 提供了与设备驱动程序和其他内核代码交互的另一种方式。'
- en: '**IMPORTANT NOTE**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The following `mount` commands are meant to be run on an embedded target device,
    like the BeaglePlay or Versatile Express (QEMU). Do not run them on your host
    machine.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的 `mount` 命令适用于嵌入式目标设备，如 BeaglePlay 或 Versatile Express（QEMU）。请勿在主机机器上运行这些命令。
- en: 'The `proc` and `sysfs` filesystems should be mounted on the `/proc` and `/sys`
    directories:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`proc` 和 `sysfs` 文件系统应该挂载在 `/proc` 和 `/sys` 目录下：'
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Although very similar in concept, the two perform different functions. `proc`
    has been part of Linux since the early days. Its original purpose was to expose
    information about processes to user space, hence the name. To this end, there
    is a directory for each process named `/proc/<PID>`, which contains information
    about its state. The process list command (`ps`) reads these files to generate
    its output.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个文件系统的概念非常相似，但它们执行的是不同的功能。`proc` 从 Linux 初期就已经存在。它的最初目的是将关于进程的信息暴露给用户空间，因此得名。为了这个目的，系统为每个进程创建了一个名为
    `/proc/<PID>` 的目录，目录中包含该进程的状态信息。进程列表命令（`ps`）通过读取这些文件来生成输出。
- en: There are also files that give information about other parts of the kernel.
    For example, `/proc/cpuinfo` tells you about the CPU, `/proc/interrupts` has information
    about interrupts, and so on. Lastly, `/proc/sys` contains files that display and
    control the state and behavior of kernel subsystems, especially scheduling, memory
    management, and networking. The manual page is the best reference for the files
    found in the `proc` directory. You can see this information by typing `man 5 proc`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些文件提供了关于内核其他部分的信息。例如，`/proc/cpuinfo` 提供关于 CPU 的信息，`/proc/interrupts` 包含中断信息，等等。最后，`/proc/sys`
    目录包含显示和控制内核子系统状态和行为的文件，特别是调度、内存管理和网络。手册页是查看 `proc` 目录中文件的最佳参考。你可以通过输入 `man 5 proc`
    查看这些信息。
- en: The role of `sysfs` is to present the kernel **driver model** to user space.
    It exports a hierarchy of files relating to devices and how they are connected
    to each other. I will go into more detail on the Linux driver model when I describe
    the interaction with device drivers in [*Chapter 11*](Chapter_11.xhtml#_idTextAnchor373).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`sysfs` 的作用是将内核 **驱动模型** 显示给用户空间。它导出一个与设备相关的文件层次结构，表示设备及其连接关系。关于 Linux 驱动模型的更多细节，我将在描述与设备驱动交互时讲解，在
    [*第 11 章*](Chapter_11.xhtml#_idTextAnchor373) 中详细说明。'
- en: Mounting filesystems
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂载文件系统
- en: 'The `mount` command allows us to attach one filesystem to a directory within
    another, forming a hierarchy of filesystems. The one at the top, which was mounted
    by the kernel when it booted, is called the **root filesystem**. The format of
    the `mount` command is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount` 命令允许我们将一个文件系统附加到另一个目录，从而形成文件系统的层次结构。最上层的文件系统是由内核在启动时挂载的，称为 **根文件系统**。`mount`
    命令的格式如下：'
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The parameters to `mount` are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount` 的参数如下：'
- en: '**vfstype** is the type of filesystem.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vfstype** 是文件系统的类型。'
- en: '**options** is a comma-separated list of mount options.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**options** 是以逗号分隔的挂载选项列表。'
- en: '**device** is the block device node that the filesystem resides on.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**device** 是文件系统所在的块设备节点。'
- en: '**directory** is the directory that you want to mount the filesystem to.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**directory** 是你希望将文件系统挂载到的目录。'
- en: There are various options you can give after `-o`. Have a look at the manual
    page `mount(8)` for more information. Type the following if you want to mount
    an SD card containing an ext4 filesystem in the first partition onto the directory
    named `/mnt:`
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `-o` 后有多种选项可供选择。查看 `mount(8)` 的手册页以获取更多信息。如果你想将包含 ext4 文件系统的 SD 卡的第一个分区挂载到名为
    `/mnt` 的目录，请输入以下命令：
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Assuming that the mount succeeds, you will see the files stored on the SD card
    in the `/mnt` directory. In some cases, you can leave out the filesystem type
    and let the kernel probe the device to find out what is stored there. If mounting
    fails, you may first need to unmount the partition if your Linux distro is configured
    to automount all the partitions on an SD card when it is inserted.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 假设挂载成功，你将会在 `/mnt` 目录下看到存储在 SD 卡上的文件。在某些情况下，你可以省略文件系统类型，让内核探测设备，找出存储的内容。如果挂载失败，你可能需要先卸载分区，如果你的
    Linux 发行版配置为在插入 SD 卡时自动挂载所有分区。
- en: 'Notice something odd in the following examples of mounting the `proc` filesystem?
    There is no device node such as `/dev/proc`, since it is a pseudo filesystem and
    not a real one. But the `mount` command requires a device parameter. Consequently,
    we have to provide a string where a device would go, but it does not matter much
    what that string is. These two commands achieve exactly the same result:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到以下挂载 `proc` 文件系统的例子有什么奇怪的吗？没有像 `/dev/proc` 这样的设备节点，因为它是一个伪文件系统，而非真实的文件系统。但
    `mount` 命令需要一个设备参数。因此，我们必须提供一个字符串来代替设备的位置，但这个字符串的内容其实不重要。这两个命令的效果完全相同：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `procfs` and `nodevice` strings are ignored by the `mount` command. It is
    common to use the filesystem type in the place of the device when mounting pseudo
    filesystems.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`procfs` 和 `nodevice` 字符串会被 `mount` 命令忽略。挂载伪文件系统时，通常会使用文件系统类型代替设备。'
- en: Kernel modules
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核模块
- en: If you have kernel modules, they need to be installed into the root filesystem
    using the `modules_install` kernel make target, as we saw in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096).
    This will copy them into the `/lib/modules/<kernel version>` directory, together
    with the configuration files needed by the `modprobe` command.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有内核模块，它们需要使用 `modules_install` 内核构建目标安装到根文件系统中，正如我们在 [*第 4 章*](Chapter_04.xhtml#_idTextAnchor096)
    中所看到的。这会将它们复制到 `/lib/modules/<kernel version>` 目录，并将 `modprobe` 命令所需的配置文件一并复制过去。
- en: Be aware that you have just created a dependency between the kernel and the
    root filesystem. If you update one, then you will have to update the other.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你刚刚在内核和根文件系统之间创建了一个依赖关系。如果你更新其中之一，你将需要更新另一个。
- en: Now that we know how to mount a filesystem from an SD card, let’s look at the
    different options for mounting a root filesystem. The alternatives (a ramdisk
    and NFS) may surprise you, especially if you are new to embedded Linux. A ramdisk
    protects the original source image from corruption and wear. We’ll learn more
    about flash wear in [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor293). A network
    filesystem allows for more rapid development because file changes propagate instantly
    to the target(s).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何从SD卡挂载文件系统，接下来我们来看看挂载根文件系统的不同选项。替代方案（如ramdisk和NFS）可能会让你感到惊讶，尤其是如果你对嵌入式Linux不熟悉的话。Ramdisk可以保护原始源镜像不被损坏或磨损。我们将在[*第9章*](Chapter_09.xhtml#_idTextAnchor293)中了解更多关于闪存磨损的内容。网络文件系统允许更快速的开发，因为文件的更改会立即传播到目标设备。
- en: Transferring the root filesystem to the target
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将根文件系统传输到目标设备
- en: 'After creating a skeleton root filesystem in your staging directory, the next
    step is to transfer it to the target. There are three possibilities:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的暂存目录中创建一个骨架根文件系统后，下一步是将其传输到目标设备。这里有三种可能性：
- en: '**initramfs**: This is a filesystem image that is loaded into RAM by the bootloader.
    Ramdisks are easy to create and have no dependencies on mass storage drivers.
    They can be used in fallback maintenance mode when the main root filesystem needs
    updating. They can even be used as the main root filesystem in smaller embedded
    devices. Ramdisks are also commonly used as the early user space in mainstream
    Linux distributions. Remember that the contents of a root filesystem on ramdisk
    are volatile, so any changes made to the root filesystem at runtime are lost when
    the system reboots. You need another storage type to store permanent data such
    as configuration parameters.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**initramfs**：这是一种由引导加载程序加载到RAM中的文件系统镜像。Ramdisks容易创建，并且不依赖于大容量存储驱动程序。它们可以在主根文件系统需要更新时用作后备维护模式，甚至可以在较小的嵌入式设备中作为主根文件系统。Ramdisks还常常作为主流Linux发行版中的早期用户空间使用。请记住，存储在ramdisk中的根文件系统内容是易失性的，因此在运行时对根文件系统所做的任何更改都会在系统重启时丢失。你需要其他存储类型来存储像配置参数这样的永久数据。'
- en: '**disk image**: A copy of the root filesystem that is formatted and ready to
    be loaded onto a mass storage device on the target. It can be an image in the
    ext4 format, ready to be copied onto an SD card, or it can be in jffs2 format,
    ready to be loaded into flash memory via the bootloader. Creating a disk image
    is probably the most common option. There is more information about the different
    types of mass storage in [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor293).'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘镜像**：这是根文件系统的一个副本，已格式化并准备好加载到目标的存储设备上。它可以是一个ext4格式的镜像，准备复制到SD卡上，或者是jffs2格式，准备通过引导加载程序加载到闪存中。创建磁盘镜像可能是最常见的选择。关于不同类型的大容量存储，有更多的信息可以参考[*第9章*](Chapter_09.xhtml#_idTextAnchor293)。'
- en: '**network filesystem**: This is when the staging directory is exported to the
    network via an NFS server and mounted by the target at boot time. This is often
    done during development as opposed to repeated cycles of creating a disk image
    and reloading it onto the mass storage device, which gets tedious quickly.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络文件系统**：当暂存目录通过NFS服务器导出到网络，并在启动时由目标设备挂载时，就形成了网络文件系统。这通常在开发过程中使用，而不是通过反复创建磁盘镜像并将其重新加载到大容量存储设备上，因为后者会迅速变得繁琐。'
- en: I will start with `intiramfs` and use it to illustrate a few refinements to
    the root filesystem, like adding usernames and a device manager to create device
    nodes automatically. Then, I will show you how to create a disk image and how
    to use NFS to mount the root filesystem over a network.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从`intiramfs`开始，利用它来说明如何对根文件系统进行一些细微调整，比如添加用户名和设备管理器，以便自动创建设备节点。然后，我会展示如何创建磁盘镜像，以及如何使用NFS通过网络挂载根文件系统。
- en: Creating a boot initramfs
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个启动initramfs
- en: An initial RAM filesystem or `initramfs` is a compressed cpio archive. cpio
    is an old Unix archive format like TAR and ZIP, but it is easier to decode and
    so requires less code in the kernel. You need to configure your kernel with `CONFIG_BLK_DEV_INITRD`
    to support `initramfs`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 初始RAM文件系统或`initramfs`是一个压缩的cpio归档文件。cpio是一种古老的Unix归档格式，类似于TAR和ZIP，但它更容易解码，因此内核需要的代码较少。你需要在内核中配置`CONFIG_BLK_DEV_INITRD`以支持`initramfs`。
- en: 'There are three different ways to create a boot ramdisk: as a standalone cpio
    archive, as a cpio archive embedded in the kernel image, and as a device table
    that the kernel build system processes as part of the build. The first option
    gives the most flexibility because we can mix and match kernels and ramdisks to
    our heart’s content. However, it means having to deal with two files instead of
    one, and not all bootloaders have the facility to load a separate ramdisk.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Standalone initramfs
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following sequence of instructions creates the archive, compresses it,
    and adds a U-Boot header to load onto the target:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that we run `cpio` with the option `--owner root:root`. This is a quick
    fix for the file ownership problem mentioned earlier in the *File ownership permissions
    in the staging directory* section. It makes everything in the cpio archive have
    a UID and GID of 0.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The final size of the uRamdisk file is about 1.9 MB, with no kernel modules.
    Add to that 9.8 MB for the kernel Image.gz file and 1,061 KB for U-Boot. This
    gives us a total of 13 MB of storage needed to boot this board. We are way off
    from the 1.44 MB floppy that started it all. If size is a real problem, then you
    can use one of these options:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Make the kernel smaller by leaving out drivers and functions you don’t need.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make BusyBox smaller by leaving out utilities you don’t need.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use musl libc or uClibc-ng in place of glibc.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile BusyBox statically.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booting an initramfs
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest thing we can do is to run a shell on the console so that we can
    interact with the target. We can do that by adding `rdinit=/bin/sh` to the kernel
    command line. The next two sections demonstrate how to do that for both QEMU and
    the BeaglePlay.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Booting with QEMU
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'QEMU has a `-initrd` option to load an `initramfs` into memory. You should
    already have an `Image` file compiled with the `aarch64-buildroot-linux-gnu` toolchain
    from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096). From this chapter, you
    should have created an `initramfs`, which includes BusyBox compiled with the same
    toolchain. Now, you can launch QEMU using the script in `MELD/Chapter05/run-qemu-initramfs.sh`
    or this command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You should get a `root` shell with a `#` prompt.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Booting the BeaglePlay
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the BeaglePlay, we need the microSD card prepared in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096),
    plus a root filesystem built using the `aarch64-buildroot-linux-gnu` toolchain.
    Copy the `uRamdisk` you created earlier in this section to the boot partition
    on the microSD card. Boot the BeaglePlay to the point where you get a U-Boot prompt.
    Then, enter these commands:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If all goes well, you will get a `root` shell with a `#` prompt on the serial
    console. After this is done, we will need to mount `proc` on both platforms.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Mounting proc
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will find that the `ps` command does not work on either platform. This
    is because the `proc` filesystem has not been mounted yet. Try mounting it:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run `ps` again, and you will see the process listing.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'As an improvement, let’s write a shell script that mounts `proc` and anything
    else that needs to be done at bootup. Then, you can run this script instead of
    `/bin/sh` at boot. The following snippet illustrates how this works:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `/bin/sh` on the last line launches a new shell that gives you an interactive
    `root` shell prompt. Using a shell as `init` in this way is very handy for quick
    hacks – for example, when you want to rescue a system with a broken `init` program.
    However, in most cases, you would use an `init` program, which we will cover in
    the next section of this chapter. Before that, I want to look at two other ways
    to load `initramfs`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Building an initramfs into the kernel image
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have created a compressed `initramfs` as a separate file and used
    the bootloader to load it into memory. Some bootloaders do not have the ability
    to load an `initramfs` file in this way. To cope with these situations, Linux
    can be configured to incorporate `initramfs` into the kernel image. To do this,
    change the kernel configuration and set `CONFIG_INITRAMFS_SOURCE` to the full
    path of the compressed `initramfs.cpio.gz` archive file you created earlier for
    your standalone `initramfs`. If you are using `menuconfig`, that field can be
    found in **General setup | Initramfs source file(s)**.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Once these changes have been made, build the kernel. Booting is the same as
    before, except there is no `-initrd` option and ramdisk file to pass in.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter this command for QEMU:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For the BeaglePlay, enter these commands at the U-Boot prompt:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Remember to regenerate the `initramfs.cpio` archive, and recompress the `initramfs.cpio.gz`
    file each time you change the contents of your staging directory and then rebuild
    the kernel:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'If you experience the following kernel panic on boot:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Make sure that the `dev/null` and `dev/console` device nodes exist in your staging
    directory.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Building an initramfs using a device table
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **device table** is a text file that lists the files, directories, device
    nodes, and links that go into an archive or filesystem image. The overwhelming
    advantage is that it allows you to create entries in the archive file that are
    owned by the `root` user, or any other UID, without having `root` privileges yourself.
    You can even create device nodes without needing to have `root` privileges. All
    this is possible because the archive is just a data file. It is only when it is
    expanded by Linux at boot time that real files and directories get created using
    the attributes you specified.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The kernel has a feature that allows us to use a device table when creating
    an `initramfs`. You write the device table file and then point `CONFIG_INITRAMFS_SOURCE`
    at it. Then, when you build the kernel, it creates the cpio archive from the instructions
    in the device table. At no point do you need `root` access.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a device table for our simple root filesystem. To make it manageable,
    it is missing most of the symbolic links to BusyBox:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The syntax is fairly obvious:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '`dir <name> <mode> <uid> <gid>`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir <name> <mode> <uid> <gid>`'
- en: '`file <name> <location> <mode> <uid> <gid>`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file <name> <location> <mode> <uid> <gid>`'
- en: '`nod <name> <mode> <uid> <gid> <dev_type> <maj> <min>`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nod <name> <mode> <uid> <gid> <dev_type> <maj> <min>`'
- en: '`slink <name> <target> <mode> <uid> <gid>`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slink <name> <target> <mode> <uid> <gid>`'
- en: The commands `dir`, `nod`, and `slink` create a filesystem object in the cpio
    archive with the name, mode, user ID, and group ID given. The `file` command copies
    the file from the source location into the archive and sets the mode, user ID,
    and group ID.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`dir`、`nod`和`slink`在cpio归档中创建一个文件系统对象，包含给定的名称、模式、用户ID和组ID。`file`命令将文件从源位置复制到归档中，并设置模式、用户ID和组ID。
- en: The task of creating an `initramfs`.`cpio` archive from scratch is made easier
    by a script found in the kernel source code, named `gen_initramfs.sh`. First,
    this script generates a device table from the contents of the input directory.
    Then, it translates this device table into the finished cpio archive.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 从头创建`initramfs.cpio`归档的任务，通过内核源代码中的一个脚本`gen_initramfs.sh`变得更加简单。首先，这个脚本从输入目录的内容生成一个设备表。然后，它将这个设备表转换成最终的cpio归档。
- en: 'To generate an `initramfs.cpio` archive from your `rootfs` directory and change
    the ownership of all files owned by user ID `1000` and group ID `1000` to user
    ID `0` and group ID `0`, enter these commands:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`rootfs`目录生成`initramfs.cpio`归档，并将所有由用户ID`1000`和组ID`1000`拥有的文件的所有权更改为用户ID`0`和组ID`0`，请输入以下命令：
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Old initrd format
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧版initrd格式
- en: There is an older format for a Linux ramdisk known as `initrd`. It was the only
    format available before Linux 2.6 and is still needed if you are using uClinux,
    the MMU-less variant of Linux. It is pretty obscure, so I will not cover it here.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种较旧的Linux ramdisk格式，称为`initrd`。它是Linux 2.6之前唯一可用的格式，如果你使用的是uClinux（没有MMU的Linux变种），仍然需要这种格式。它相当晦涩，因此我不会在这里介绍。
- en: Once our `initramfs` boots, the system then needs to start running programs.
    The first program that runs is the `init` program.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的`initramfs`启动，系统需要开始运行程序。首先运行的程序是`init`程序。
- en: init program
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: init程序
- en: Running a shell or even a shell script at boot time is fine for simple cases,
    but really, you need something more flexible. Normally, Unix systems run a program
    called `init` that starts up and monitors other programs. Over the years, there
    have been many `init` programs, some of which I will describe in [*Chapter 13*](Chapter_13.xhtml#_idTextAnchor431).
    For now, I will briefly introduce BusyBox `init`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时运行一个shell或甚至是一个shell脚本对于简单的情况是可以的，但实际上，你需要更灵活的东西。通常，Unix系统运行一个叫做`init`的程序，它负责启动和监控其他程序。多年来，有许多`init`程序，其中一些我将在[*第13章*](Chapter_13.xhtml#_idTextAnchor431)中描述。目前，我将简要介绍BusyBox的`init`。
- en: 'The `init` program begins by reading the `/etc/inittab` configuration file.
    Here is a simple example, which is adequate for our needs:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`程序首先读取`/etc/inittab`配置文件。这里是一个简单的例子，足以满足我们的需求：'
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first line runs a shell script named `rcS` when `init` is started. The second
    line prints the message **Please press Enter to activate this console** to the
    console and starts a shell when you press *Enter*. The leading `-` before `/bin/ash`
    means that it will become a login shell, which sources `/etc/profile` and `$HOME/.profile`
    before displaying the shell prompt.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行在`init`启动时运行一个名为`rcS`的shell脚本。第二行将消息**Please press Enter to activate this
    console**打印到控制台，并在按下*Enter*后启动一个shell。`/bin/ash`前的连字符`-`意味着它将成为一个登录shell，在显示shell提示符之前，首先会读取`/etc/profile`和`$HOME/.profile`。
- en: One of the advantages of launching the shell like this is that job control is
    enabled. The most immediate effect is that you can use *Ctrl + C* to terminate
    the current program. Maybe you didn’t notice it before, but wait until you run
    the `ping` program and find you can’t stop it!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式启动shell的一个优势是启用了作业控制。最直接的效果是，你可以使用*Ctrl + C*终止当前程序。也许你之前没注意到这一点，但等你运行`ping`程序时，你会发现你无法停止它！
- en: BusyBox `init` provides a default `inittab` if none is present in the root filesystem.
    It is a little more extensive than the preceding one.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果根文件系统中没有`inittab`，BusyBox的`init`会提供一个默认的`inittab`。它比前面的那个稍微复杂一些。
- en: 'The script called `/etc/init.d/rcS` is the place to put initialization commands
    that need to be performed at boot, like mounting the `proc` and `sysfs` filesystems:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本`/etc/init.d/rcS`是放置需要在启动时执行的初始化命令的地方，例如挂载`proc`和`sysfs`文件系统：
- en: '[PRE35]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Make sure that you make the preceding `rcS` script executable like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你像这样使前面的`rcS`脚本可执行：
- en: '[PRE36]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can try `init` out on QEMU by changing the `-append` parameter like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过更改`-append`参数来尝试在QEMU上运行`init`，像这样：
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For the BeaglePlay, you need to set the `bootargs` variable in U-Boot as shown
    here:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, let’s take a closer look at the `inittab` read by `init` during startup.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Starting a daemon process
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically, you want to run certain background processes at startup. Take `syslogd`
    (the log daemon), for example. The purpose of `syslogd` is to accumulate log messages
    from other programs, mostly other daemons. Naturally, BusyBox has an applet for
    that!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting the daemon is as simple as adding a line like this to `etc/inittab`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`respawn` means that if the program terminates, it will be automatically restarted.
    `-n` means that it should run as a foreground process. The log is written to `/var/log/messages`.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: You may also want to start `klogd` in the same way. `klogd` sends kernel log
    messages to `syslogd` so that they can be logged to permanent storage.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: So far, all the processes I have mentioned run as `root`, but that is less than
    ideal.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Configuring user accounts
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I already said, it is bad practice to run all programs as `root` because
    if one program is compromised by an outside attack then the whole system is at
    risk. It is better to create unprivileged user accounts and use them where full
    `root` is not necessary.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Usernames are configured in `/etc/passwd`. There is one line per user with
    seven fields of information separated by colons. These are, in order:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The login name
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hash code used to verify the password or, more usually, an `x` to indicate
    that the password is stored in `/etc/shadow`
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UID or user ID
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GID or group ID
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The comment field (often left blank)
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user’s home directory
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shell this user will use (optional)
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a simple example in which we have the user `root` with UID 0 and the
    user `daemon` with UID 1:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Setting the shell for the user `daemon` as `/bin/false` ensures that any attempt
    to log on with that name will fail.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Various programs have to read `/etc/passwd` to look up usernames and UIDs, so
    the file has to be world-readable. This is a problem if the password hashes are
    stored in there as well because a malicious program can take a copy and discover
    the actual passwords, using a variety of cracker programs. To reduce the exposure
    of this sensitive information, the passwords are stored in `/etc/shadow`, and
    `x` is placed in the password field to indicate that this is the case. The `/etc/shadow`
    file only needs to be accessed by `root`, so as long as the `root` user is not
    compromised, the passwords are safe.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'The shadow password file consists of one entry per user, made up of nine fields.
    Here is an example that mirrors the password file shown in the preceding paragraph:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first two fields are the username and the password hash. The remaining seven
    fields are related to password aging, which is usually not a concern on embedded
    devices. If you are curious about the full details, refer to the manual page for
    `shadow(5)`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: In the example, the password for `root` is empty meaning that `root` can log
    on without providing a password. Having an empty password for `root` is useful
    during development but not for production. You can generate or change a password
    hash by running the `passwd` command on the target, which will write a new hash
    to `/etc/shadow`. If you want all subsequent root filesystems to have this same
    password, you could copy this file back to the staging directory.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Group names are stored similarly in `/etc/group`. There is one line per group,
    consisting of four fields separated by colons. The fields are:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The name of the group
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The group password or, more usually, an `x` to indicate that there is no group
    password
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GID or group ID
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comma-separated list of users who belong to this group (optional)
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Adding user accounts to the root filesystem
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, add the files `etc/passwd`, `etc/shadow`, and `etc/group` to your staging
    directory, as shown in the preceding section. Make sure that the permissions of
    `etc/shadow` are `0600`. Next, initiate the login procedure by starting a program
    called `getty`. There is a version of `getty` in BusyBox. You launch it from your
    `inittab` using the keyword `respawn`, which restarts `getty` when a login shell
    is terminated. Your `inittab` should read like this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Then, rebuild the ramdisk, and try it out using QEMU or the BeaglePlay, as before.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, we learned how to create device nodes using the `mknod`
    command. Now, let’s look at some easier ways to create device nodes.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: A better way of managing device nodes
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating device nodes statically with `mknod` is hard work and inflexible.
    However, there are other ways to create device nodes automatically on demand:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '`devtmpfs`: This is a pseudo filesystem that you mount over `/dev` at boot
    time. The kernel populates it with device nodes for all the devices that the kernel
    currently knows about. The kernel also creates nodes for new devices as they are
    detected at runtime. The nodes are owned by `root` and have default permissions
    of `0600`. Some well-known device nodes, such as `/dev/null` and `/dev/random`,
    override the default to `0666`. To see exactly how this is done, look at the `drivers/char/mem.c`
    file in the Linux source tree and observe how `struct memdev` is initialized.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mdev`: This is a BusyBox applet that is used to populate a directory with
    device nodes and create new nodes as needed. There is an `/etc/mdev.conf` configuration
    file that contains rules for the ownership and mode of the nodes.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`udev`: This is the mainstream equivalent of `mdev`. You will find it on desktop
    Linux and in some embedded devices. It is very flexible and a good choice for
    higher-end embedded devices. It is now part of `systemd`.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Although both `mdev` and `udev` create the device nodes themselves, it is easier
    to just let `devtmpfs` do the job and use `mdev/udev` as a layer on top to implement
    the policy for setting ownership and permissions. The `devtmpfs` approach is the
    only maintainable way to generate device nodes prior to user space startup.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After introducing `devtmpfs`, I will describe how `mdev` is used to assign ownership
    and permissions to device nodes on startup.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Using devtmpfs
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Support for the `devtmpfs` filesystem is controlled by the `CONFIG_DEVTMPFS`
    kernel configuration variable. It is not enabled in the default configuration
    of the 64-bit Arm generic virtual platform, so if you want to try `devtmpfs` out
    on QEMU, you will have to go back to your kernel configuration and enable this
    option.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter this command to mount `devtmpfs`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You will notice that there are many more device nodes in `/dev` afterward.
    To mount `devtmpfs` on startup, add the preceding command to `/etc/init.d/rcS`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you enable `CONFIG_DEVTMPFS_MOUNT` in your kernel configuration, the kernel
    will automatically mount `devtmpfs` just after mounting the root filesystem. However,
    this option has no effect when booting `initramfs`, as we are doing here.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Using mdev
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `mdev` is a bit more complex to set up, it does allow you to modify the
    permissions of device nodes as they are created. You begin by running `mdev` with
    the `-s` option, which causes it to scan the `/sys` directory looking for information
    about current devices. From this information, it populates the `/dev` directory
    with the corresponding nodes.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to keep track of new devices coming online and create nodes for
    them as well, you need to make `mdev` a hot plug client by writing to `/proc/sys/kernel/hotplug`.
    Add two more lines to `/etc/init.d/rcS`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The default mode is `660` and the ownership is `root:root`. You can change
    this by adding rules in `/etc/mdev.conf`. For example, to give the `null`, `random`,
    and `urandom` devices their correct modes, you would add this to `/etc/mdev.conf`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The format is documented in the BusyBox source code in `docs/mdev.txt`, and
    there are more examples in the directory named `examples`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Are static device nodes so bad after all?
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Statically created device nodes have one advantage over running a device manager:
    they don’t take any time to create during boot. If minimizing boot time is a priority,
    then using statically created device nodes will save a measurable amount of time.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the network
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let’s look at some basic network configurations so that we can communicate
    with the outside world. I assume that there is an Ethernet interface (`eth0`)
    and that we only need a simple IPv4 configuration.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'These examples use the network utilities that are part of BusyBox, which are
    sufficient for our simple use case. All we need are the old-but-reliable `ifup`
    and `ifdown` programs. You can read the manual pages for both to get the details.
    The main network configuration is stored in `/etc/network/interfaces`. You will
    need to create these directories in the staging directory:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here is `/etc/network/interfaces` for a static IP address:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here is `/etc/network/interfaces` for a dynamic IP address, allocated using
    DHCP:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You also need to configure a DHCP client program. BusyBox has one named `udchpcd`.
    It requires a shell script that goes in `/usr/share/udhcpc/default.script`. There
    is a suitable default at `examples/udhcp/simple.script` within the BusyBox source
    code.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Network components for glibc
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'glibc uses a mechanism known as the **name service switch** (**NSS**) to control
    the way that names are resolved to numbers for networking and users. Usernames
    can be resolved to UIDs via the `/etc/passwd` file, and network services such
    as HTTP can be resolved to service port numbers via `/etc/services`. All this
    is configured by `/etc/nsswitch.conf`; see the `nss(5)` manual page for full details.
    Here is a simple example that will suffice for most embedded Linux implementations:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Everything is resolved by the correspondingly named file in `/etc`, except for
    host names, which can be resolved by a DNS lookup if they are not in `/etc/hosts`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this work, you need to populate `/etc` with those files. Networks,
    protocols, and services are the same across all Linux systems, so they can be
    copied from `/etc` on your development machine. At the very least, `/etc/hosts`
    should contain the loopback address:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The other files (`passwd`, `group`, and `shadow`) were described in the *Configuring
    user accounts* section earlier.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of the puzzle is the libraries that perform the name resolution.
    They are plugins that are loaded as needed, based on the contents of `nsswitch.conf`.
    That means they do not show up as dependencies when you use `readelf` or `ldd`.
    You will simply have to copy them from the toolchain’s `sysroot`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: At last, our staging directory is complete. Let’s generate a filesystem from
    it.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Creating filesystem images with device tables
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw in the earlier *Creating a boot initramfs* section that the kernel has
    the option to create `initramfs`, using a device table. Device tables are really
    useful because they allow a non-root user to create device nodes and allocate
    arbitrary UID and GID values to any file or directory. The same concept has been
    applied to tools that create other filesystem image formats, as shown in this
    mapping from the filesystem format to tool:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '**jffs2**: `mkfs.jffs2`'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ubifs**: `mkfs:ubifs`'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ext2**: `genext2fs`'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover jffs2 and ubifs in [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor293),
    when we look at filesystems for flash memory. ext2 is a format commonly used for
    managed flash memory, including SD cards. The example that follows uses ext2 to
    create a disk image that can be copied to an SD card.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, you need to install the `genext2fs` tool on your host. On Ubuntu,
    the package to install is named `genext2fs`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`genext2fs` takes a device table file with the format `<name> <type> <mode>
    <uid> <gid> <major> <minor> <start> <inc> <count>`. The meanings of the fields
    are as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '**name**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**type**: one of the following:'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f`: regular file'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: directory'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c`: character device file'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b`: block device file'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p`: FIFO (named pipe)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**uid**: UID of the file'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gid**: GID of the file'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**major** and **minor**: device numbers (device nodes only)'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**start**, **inc**, and **count**: allows you to create a group of device nodes
    starting from the minor number in start (device nodes only)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You do not have to specify these for every file as you do with the kernel `initramfs`
    table. You just need to point at a directory—the staging directory—and list the
    changes and exceptions you need to make in the final filesystem image.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example that populates static device nodes for us:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, you can use `genext2fs` to generate a filesystem image of 8 MB (8,192
    blocks of the default size, 1,024 bytes):'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, you can copy the resulting `rootfs.ext2` image to an SD card or similar,
    as we will do next.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Booting the BeaglePlay
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script named `MELD/format-sdcard.sh` creates two partitions on the microSD
    card: one for the boot files and one for the root filesystem. Assuming you have
    created the root filesystem image, as shown in the previous section, you can use
    the `dd` command to write it to the second partition.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: As always, when copying files directly to storage devices like this, make absolutely
    sure that you know which device is the microSD card.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, I am using a built-in card reader, which is the device called
    `/dev/mmcblk0`, so the command is:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that the card reader on your host system may have a different name.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the microSD card into the BeaglePlay and set the kernel command line
    to `root=/dev/mmcblk1p2`. Unlike previous Beagles, the eMMC is the `mmcblk0` device
    and the microSD is the `mmcblk1` device on the BeaglePlay. Here is the complete
    sequence of U-Boot commands:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is an example of mounting an ext2 filesystem from a normal block device,
    such as an SD card. The same principles apply to other filesystem types. We will
    look at these in more detail when we get to [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor293).
    Now, let’s switch gears and look at how to mount a filesystem over a network.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Mounting the root filesystem using NFS
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your device has a network interface, you can mount the root filesystem over
    the network for rapid development using **Network File System** (**NFS**). This
    gives you access to almost unlimited storage on your host machine, so you can
    add debug tools and executables with large symbol tables. As a bonus, updates
    made to the root filesystem on your development machine are available on the target
    instantly. You can also access all the target’s log files from the host.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, you need to install and configure an NFS server on your host machine.
    The package to install on Ubuntu is named `nfs-kernel-server`:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The NFS server needs to be told which directories are being exported to the
    network. This is controlled by `/etc/exports`. There is one line for each export.
    The format is described in the `exports(5)` manual page. To export the root filesystem,
    the `exports` file on my host contains this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`*` exports the directory to any address on my local network. If you wish,
    you can specify a single IP address or a range at this point. A list of options
    enclosed in parentheses follows. There must not be any spaces between `*` and
    the opening parenthesis. The options are:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '`rw`: Exports the directory as read-write.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sync`: Selects the synchronous version of the NFS protocol, which is more
    robust but a little slower than the async option.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_subtree_check`: Disables subtree checking, which has mild security implications
    but can improve reliability in some circumstances.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_root_squash`: Allows requests from user ID 0 to be processed without squashing
    to a different user ID. It is necessary for the target to correctly access the
    files owned by `root`.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having made changes to `/etc/exports`, restart the NFS server to pick them
    up:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, set up the target to mount the root filesystem over NFS. For this to work,
    configure your kernel with `CONFIG_ROOT_NFS`. Then, configure Linux to do the
    mount at boot time by adding the following to the kernel command line:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The options are:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '`rw`: Mounts the root filesystem read-write.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nfsroot`: Specifies the IP address of the host, followed by the path to the
    exported root filesystem.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ip`: This is the IP address to be assigned to the target. Usually, network
    addresses are assigned at runtime, as we saw in the *Configuring the network*
    section. However, in this case, the interface has to be configured before the
    root filesystem is mounted and `init` has started. Hence, it is configured on
    the kernel command line.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There is more information about NFS root mounts in the kernel source in `Documentation/admin-guide/nfs/nfsroot.rst`.
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Testing with the BeaglePlay
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boot your BeaglePlay from the microSD card and enter these commands at the
    U-Boot prompt:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Replace `<path to staging directory>` with the full path to your staging directory,
    and change the `serverip` and `ipaddr` values to match the IP addresses of your
    Linux host and BeaglePlay. Make sure that the BeaglePlay can ping the `serverip`
    before attempting this exercise.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Problems with file permissions
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The files that you copied into the staging directory will be owned by the UID
    of the user you are logged on as (typically `1000`). However, the target has no
    knowledge of this user. What’s more, any files created by the target will be owned
    by users configured by the target (often the root user). The whole thing is a
    mess. Unfortunately, there is no simple way out.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: The best solution is to make a copy of the staging directory and change ownership
    to UID and GID to `0`, using the command `sudo chown -R 0:0 *`. Then, export this
    directory as the NFS mount. This removes the convenience of having just one copy
    of the root filesystem shared between development and target systems, but at least
    the file ownership will be correct.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: It’s not uncommon in embedded Linux to link device drivers statically to the
    kernel, rather than load them dynamically from the root filesystem as modules
    at runtime. So how do we reap the same benefits of rapid iteration provided by
    NFS when modifying kernel source code or DTBs? The answer is TFTP.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Using TFTP to load the kernel
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to mount the root filesystem over a network using NFS,
    you may be wondering if there is a way to load the kernel, device tree, and `initramfs`
    over the network as well. If we can do this, then the only component that needs
    to be written to storage on the target is the bootloader. Everything else could
    be loaded from the host machine. This would save time, since you would not need
    to keep reflashing the target. You could even get work done while the flash storage
    drivers are still being developed (it happens).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: The **Trivial File Transfer Protocol** (**TFTP**) is the answer. TFTP is a very
    simple file transfer protocol that is designed for easy implementation with bootloaders
    such as U-Boot.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, you need to install a TFTP daemon on your host machine. The package
    to install on Ubuntu is named `tftpd-hpa`:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Modify the contents of `/etc/default/tftpd-hpa` as shown:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create the `/var/lib/tftpboot` directory with the necessary ownership and permissions:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Having made changes to `/etc/default/tftpd-hpa`, restart the TFTP server to
    pick them up:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'With `tftpd-hpa` installed and running, copy the files you want loaded on the
    target to `/var/lib/tftpboot`. For the BeaglePlay, these would be `Image` and
    `k3-am625-beagleplay.dtb`:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, enter these commands at the U-Boot prompt:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Replace `<path to staging directory>` with the full path to your staging directory,
    and change the `serverip` and `ipaddr` values to match the IP addresses of your
    Linux host and BeaglePlay. You may find that the `tftp` command hangs endlessly,
    printing out the letter `T`, which means that the TFTP requests time out. There
    are a number of reasons why this happens. The most common ones are:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: An incorrect IP address for `serverip`
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TFTP daemon is not running on the server.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The firewall on the server is blocking the TFTP protocol. Most firewalls block
    TFTP port 69 by default.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have resolved the connectivity problem, U-Boot loads the files from
    the host machine and boots in the usual way.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the strengths of Linux is that it supports a variety of root filesystems,
    so it can be tailored for a wide range of needs. We have seen how it is possible
    to construct a simple root filesystem manually with just a small number of components.
    BusyBox is especially useful in this regard.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: By going through the process one step at a time, we gained insight into some
    of the basic workings of Linux systems, including network configuration and user
    accounts. However, the task rapidly becomes unmanageable as devices get more complex.
    Plus, there is the ever-present worry that there may be a security hole in the
    implementation that we did not notice.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I will show you how using an embedded build system can
    make the process of creating an embedded Linux system much easier and more reliable.
    I will start by looking at Buildroot and then go on to look at the more complex,
    yet powerful, Yocto Project.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Further study
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Filesystem Hierarchy Standard, Version 3.0*: [https://refspecs.linuxfoundation.org/fhs.shtml](https://refspecs.linuxfoundation.org/fhs.shtml)'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ramfs, rootfs and initramfs*, by Rob Landley, part of the Linux source at
    [Documentation/filesystems/ramfs-rootfs-initramfs.rst](https://Documentation/filesystems/ramfs-rootfs-initramfs.rst)'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers: https://packt.link/embeddedsystems'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code12308107448340296.png)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
