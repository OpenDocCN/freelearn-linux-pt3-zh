- en: '*Chapter 12*: Using Arguments and Functions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we are trying to program any kind of application or a script in any
    programming language, we should always try to make our code modular and easily
    maintainable. The thing that is going to help us a lot in this aspect of creating
    scripts is a concept known as a **function**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using custom functions in shell script code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing arguments to a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local and global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with returns from a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading an external function to a shell script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing commonly used procedures via functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For these recipes, we''re going to use a Linux machine. We can use any `cli1`
    VM as it''s the most convenient to use, seeing that it''s a **command-line interface**
    (**CLI**)-only machine. So, all in all, we need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A VM with Linux installed—any distribution (in our case, it's going to be **Ubuntu
    20.02**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bit of time to digest the complexities of using the VI(m) editor. Nano is
    less complex, therefore it's going to be easier to learn about that one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, start your VM, and let's get cracking!
  prefs: []
  type: TYPE_NORMAL
- en: Using custom functions in shell script code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, all we did was create very simple scripts that had a few commands
    at most. This is going to be most of your scripts since a lot of work that is
    solved by scripting is the simple elimination of repetitive tasks. In this chapter,
    we are going to work with functions as a way of creating modules of code in your
    script. Their main purpose is going to be to avoid repetitive blocks of code in
    your scripts, further simplifying the scripts themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to functions, Bash is a little bit strange. Things you may know
    about functions from other languages will look similar in `bash` but at the same
    time, completely different. We are going to start with how a function is defined.
    To make matters confusing from the very start, `bash` uses two very similar notations,
    one that looks more like something you would find in other languages, and another
    that is more in line with the rest of the `bash` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Before we even mention them, have in mind that there is no difference in functionality
    or anything else in the way functions are defined—we can use either of them with
    the exact same results.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of the first definition looks like something you would see in any
    programming language. There are no keywords—we simply specify the name of the
    function followed by two normal brackets, and then define a command block that
    makes up the function in curly brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a big difference between `bash` and almost every programming language
    out there, though. Usually, brackets in any language serve to pass arguments or
    parameters to the function. In `bash`, they are always empty—their only purpose
    is to define a function. Parameters are passed in a completely different way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to define a function is more in line with the way `bash` usually
    works. There is a reserved word, `function`; so, in order to define a function,
    we simply do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This version is more likely to remind you that arguments are provided in a different
    way, but that is probably the only difference between the two.
  prefs: []
  type: TYPE_NORMAL
- en: A function must be defined before we can use it. This is completely logical
    since the shell runs every line one by one and, to understand a command, has to
    have it defined as either an internal command, an external command, or a function.
    Unlike some other languages, arguments and return values are not defined in advance—or,
    to be more precise, are not defined at all.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As always, we are going to start with a `hello world` script, but with a little
    twist. We are going to use our `echo` command inside a function, and the main
    part of the script is going to run this function. We are also going to create
    an alternative version of our function just to show that both ways to define a
    function work the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of things to notice in this script—when we define a function,
    there is no *right* way to do it; both ways work, but they work differently. We
    prefer using the format that explicitly mentions the `function` keyword since
    it immediately draws attention to this being a definition of a function, but this
    is just our preference—you can use whichever format you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the script, we can see that both our functions behave exactly the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to create an example that makes much more sense. There are
    going to be a lot of scripts that will require you to output things to the screen
    or into a file. Some parts of the output are going to be repeated over and over—a
    task that is exactly designed for a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What our function did is create a header for our output. When we learn to pass
    arguments to functions, we are going to use this trick a lot, especially when
    we need to output formatted text into logs or when we have a large block of text
    with a few variables that we need to fill in.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions are parts of the code that `bash` reproduces whenever we reference
    our function inside a script. Their purpose is primarily geared toward creating
    scripts that are easier to read and debug. There is another reason to use functions:
    avoiding errors in code. If we need to reuse parts of the code in different parts
    of the script, we can always copy and paste it, but that creates a large possibility
    that we will introduce bugs into the script.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://www.shell-tips.com/bash/functions/](https://www.shell-tips.com/bash/functions/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://tldp.org/LDP/abs/html/complexfunct.html](https://tldp.org/LDP/abs/html/complexfunct.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing arguments to a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started demonstrating what a function looks like by showing you a simple
    script, the simplest we could create. We still haven't defined how to *talk* to
    your function, and we still don't know how to give a function some parameters
    or arguments and get something in return. In this recipe, we are going to fix
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we mentioned arguments, we need to talk a little about them. `bash` treats
    arguments in functions the same as it does in the script itself—arguments become
    local variables inside the function block. To return a value, we also do almost
    exactly the same as when we need to deal with the whole script—we simply return
    a value from our function block and then read it inside the main script body.
  prefs: []
  type: TYPE_NORMAL
- en: Remember when we said you can reference arguments that were given to your script
    when it was initially called, and that we used variables called `$1`, `$2`, `$3`,
    and so on to get the first, second, third, and other parameters that were in the
    command line? The exact same thing applies to functions. In this case, we use
    the same variable names as when referencing arguments given to our function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to send two parameters to a simple function that will display them,
    we would use something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens when we try to run this script is that our arguments get passed
    in a way that we expect, one after the other, and then our function outputs them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You may wonder how our scripts are going to handle arguments that are given
    to the script, compared to arguments we pass to the function. The short answer
    is that variables named `$1` and so on have a value that is local to the function
    and is defined by arguments we passed to the function. Outside of the function
    code block, these variables have the value of the arguments passed to the script.
    The long version of the answer is going to be in the next recipe and is called
    local and global variables. Using arguments is nothing but a special case of declaring
    a local variable; arguments that we pass simply become a local variable in the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason we are changing the order of the arguments is to show the order
    in which arguments are passed to the function and to make sure that we are not
    using the arguments we passed to the script in the function since they have the
    same name. What this script will do is get two arguments from the command line,
    reverse them, and then give them in reversed order as arguments to our function.
    The function is simply going to output them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened here is also what we expected. Now, we are going to check one
    more thing that can be confusing to some people. Is the function even aware that
    some arguments are passed to the script or are the arguments strictly local? In
    order to check that, we are going to ignore whatever was in the script command
    line, and we are going to pass a pair of hardcoded strings to the function. If
    `bash` is behaving like we think it is, our script will output the hardcoded values.
    If the variables named `$1` and `$2` are set to values from the command line and
    they persist in the function, we should see that value in our `echo` statement.
    What we are going to do is create a `functionarg3.sh` file containing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to run it and check what happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see that our assumption was correct and that the arguments given to the
    function always take precedence.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing that we are going to do is show you how to handle simple operations
    using functions. Operations that can be done on variables is something we covered
    elsewhere in this book, but here, we are going to use an example we haven't used
    yet. We are simply going to add two arguments from the command line together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do that, we are passing arguments from the command line into our
    function and then using `echo` to output the result of the calculation. Part of
    the function used to get the result is also very interesting since it reminds
    us that we have to explicitly use a function to add two numbers in order to do
    that. If we try to add variables together, we are going to end up creating a string—something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the final version incorporated into our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this example, we are using a new variable inside a function to
    add the numbers and then outputting the value of this variable as the result.
    This is a better way to do this than directly doing the operation in the output
    itself—code that uses these temporary variables is always easier to read and understand
    than trying to find and understand variables embedded into output strings.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next thing we want to show is a nifty little feature that is not so common
    in most programming languages. Since `bash` treats arguments in the function the
    same way as it treats arguments to the script and uses the same logic to turn
    these arguments into variables inside the function, we can actually send multiple
    arguments to the function without defining their number in advance. Of course,
    our function needs to be able to understand something such as this.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://linuxize.com/post/bash-functions/](https://linuxize.com/post/bash-functions/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://linuxhint.com/create-bash-functions-arguments/](https://linuxhint.com/create-bash-functions-arguments/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local and global variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to declaring any variable in a script—or for that matter, anywhere
    at all—one crucial attribute for that variable is its scope. By scope, we mean
    *where the variable has the value we declared*. Scope is very important since
    not understanding how it works means that we can get unexpected results in some
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining a global scope to our variables is something `bash` does by default,
    without any interaction with us. All variables that are defined are global variables;
    their value is the same in the entire script. If we change the variable value
    by reassigning it (remember that operations on the value do not change the value
    itself), this value changes globally, and the old value is lost.
  prefs: []
  type: TYPE_NORMAL
- en: There is another thing we can do when declaring variables, and that is to declare
    them locally. In simple terms, this means that we are explicitly telling `bash`
    that we will use this variable in some limited part of the code and that it needs
    to keep the value just there, not globally in the entire script.
  prefs: []
  type: TYPE_NORMAL
- en: What are the reasons to declare a local variable? There are a couple of them,
    the most important one being to make sure that we don't change the value of any
    global variable. If a variable is declared locally with the same name as a global
    one, `bash` will create another instance of the variable with the same name and
    will keep track of both values, the global and the local one.
  prefs: []
  type: TYPE_NORMAL
- en: Global and local variables and how they work are something that is best explained
    by using an example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script that we are going to use to show you how this works is something
    that you will find in almost every example on the internet and in any book covering
    the subject. The idea is to create a global variable and then create a local variable
    in the function that is going to have the same name as the global one. The value
    that the global variable has should be different than the local value, and once
    we display that value, we should see that the value changes depending on if we
    are referencing a global or local variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute this script, we are going to see exactly how variables interact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is completely expected—if there are a global variable and a local variable
    with the same name, the local variable will have its own values in the block it
    is defined in; otherwise, a global value will be used.
  prefs: []
  type: TYPE_NORMAL
- en: We said scripts such as this are common as an example, but what happens if we
    define just the local value? `bash` is different from most other languages since,
    by default, it will not show an error if we mistakenly try to reference a variable
    that is undefined. When debugging scripts, this can be a big problem since an
    undefined variable and a defined variable with no value will, at first, look exactly
    the same when we try to reference them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show this, we are going to make a small modification to our script and just
    remove the first variable definition. This will make our global value undefined—only
    the local value will have an actual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In any strict programming language, something such as this would create an
    error. In `bash`, things are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can see that instead of errors, the script just ignores the variable value
    and replaces it with nothing. As we mentioned, even though we are expecting this
    behavior, keep in mind that this can lead to unexpected consequences. Another
    important thing in this script is the local value. We can see that the local variable
    *exists* only in the block of code in which it is defined; defining it will not
    create a global variable, and the value will be lost as soon as the function or
    block of code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using global variables in scripts can be useful for one more thing—forwarding
    values between functions. This feature of variables is something that can be useful,
    but at the same time, it is something that is dependent on your personal style
    of programming. Using global variables this way is easy—what you do is just declare
    a variable at the start of the script and then change its value whenever you need
    to. Usually, you assign a value before executing a particular function and then
    read the same variable after the function is done. This way, your function only
    needs to change the variable to give you the value that you expect.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a big problem in this otherwise perfectly logical way of using
    global variables. Since you have no way of knowing if the function behaved correctly
    and got to the point where it had to change the value of the variable, you do
    not have any idea if the value itself is what you are expecting. If a function
    fails for any reason, your variable will have the same value you sent to the function,
    leaving you with something that could be wrong.
  prefs: []
  type: TYPE_NORMAL
- en: What we are trying to say is that using global variables in this way is to be
    avoided, even though you can do it—the right way to work with functions and passing
    values is by using arguments and returning values by a mechanism we will look
    at in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://www.thegeekstuff.com/2010/05/bash-variables/](https://www.thegeekstuff.com/2010/05/bash-variables/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://tldp.org/LDP/abs/html/localvar.html](https://tldp.org/LDP/abs/html/localvar.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with returns from a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We mentioned that it is possible to use global variables to pass values to the
    functions inside a script and to get results back. This is the worst possible
    way to do it. If we need to pass some value to a function, using arguments is
    the way it should be done. The problem that we still have is how to get the results
    back when the function finishes. We are going to solve that in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If nothing else, `bash` is logical and consistent in the syntax it uses. The
    reason we are mentioning this is that when functions return a value, they use
    the exact same mechanism that scripts use when returning a variable—the `return`
    command. Using this command, it is possible for a function to return a value when
    called, but the value can be in the range of numbers between `0` and `255`. There
    is also a possibility to set a global variable just to return a function value—for
    example, if we need to return a string—but try to avoid that since it creates
    code that is difficult to debug. When you are browsing the internet for function
    `return` statements, you may also run into a third solution that uses something
    called *reference passing* or `nameref`. This is a more complex solution that
    you should be aware of, but we are deliberately avoiding it in this recipe since
    it works only on the most recent versions of `bash` (from `4.3` up), and that
    breaks the compatibility and usability of our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll show you both ways to return a function, starting with the one we consider
    wrong. The reason that we are even showing you a wrong solution is that you will
    often run into this in different scripts downloaded from the internet, and if
    you are unaware of this method, you will probably be a little bit puzzled at first
    because the variable is usually first defined in the function itself and does
    not exist before the function is first called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What we did is just pass two strings to a function that returned them concatenated.
    Of course, this is silly—we could do that by simply using the expression we used
    in the function. This example is so basic that it doesn't even use any operators.
  prefs: []
  type: TYPE_NORMAL
- en: What's important is the way we returned our value. By just assigning a new value
    and therefore creating a global variable named `RESULT`, we got our string, and
    we were able to use `echo` to write it to the screen. Why is this a problem?
  prefs: []
  type: TYPE_NORMAL
- en: We have already explained this. What we are doing here is dangerous since we
    have no way of knowing if the function has done what it had to do. The only thing
    we have is the variable called `RESULT` that probably contains the value we expect.
    In this trivial example, we could check the outcome, but that would defeat the
    purpose of having a dedicated function. In order to reduce the uncertainty a little
    bit, there is a small trick that we can do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this change to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What we did is create a conditional output. The format of the condition itself
    should be familiar to you by now—we are using logical functions to either print
    out the result of the function or to print out that the function did not work
    correctly. As a reminder to when we introduced logical operators, what our script
    does in the last line is check for the value of a variable called `$?`. If the
    variable value equals `0`, we print out the result of the function. If the value
    is not zero, we output the error message since we know that our function had an
    error somewhere inside its command block.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we can do this is simple—we already said that functions have the
    same way of communicating to the script as the script itself does to the rest
    of the operating system. This includes passing arguments and being able to use
    a `return` statement to return values, but also it means that `bash` sets a variable
    named `?` when the function is finished. When we use it to understand what happened
    to the script (which we already explained), if we check this variable and it has
    a value of `0`, this means that the function finished correctly, or at least that
    the last command in it finished correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple solution to a problem that we shouldn''t create in the first
    place; whenever possible, we should use `return` to get our values. Here''s an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is a much better way if we are sure that our numbers fit into the range
    from `0` to `255`. We are outputting the result of the function, and this is as
    easy as referencing the right variable. We could also check if the value of the
    variable after the execution of the function is `0`, meaning that the function
    behaved correctly, and then output the result.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing you should know is that a function can use the `exit` command.
    By using it, you are telling `bash` to immediately stop what the function is doing
    and exit the function command block. The value that is going to be returned in
    this instance is going to be the error level of the last command that was executed
    before the `exit` command was invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'What is going to get printed is just the first line of output; since we used
    the `exit` statement, the second part of the output will never run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main reason why all of this even exists is to enable you to more tightly
    control how functions and, more generally, the order of command execution works
    in your script. `bash` is very basic in the way it approaches this topic, and
    that at the same time makes it versatile. In order to use functions, you only
    need to know how arguments work in scripting—all the variable names and logic
    behind it are the same when applied to functions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://www.assertnotmagic.com/2020/06/19/bash-return-multiple/](https://www.assertnotmagic.com/2020/06/19/bash-return-multiple/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.linuxjournal.com/content/return-values-bash-functions](https://www.linuxjournal.com/content/return-values-bash-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading an external function to a shell script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A problem that will often pop up when you need to create more complex shell
    scripts is going to be how to include other code into your script. Once you start
    scripting, you will often create a couple of common functions that you always
    use—things such as opening connections to servers, getting some operations done,
    and other things like that.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, your scripts will have to use a lot of preset variables that are
    defined by the user before they even run the script in order to avoid having to
    type them in each time a script is called.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the solution to both of these problems can be to simply copy and
    paste the relevant code into your script and to make the user edit the script
    before running it. The reason we should never do this is that each time we copy
    and paste something, we are creating a new version of our code. If we notice an
    error in the code, we need to fix it in all the scripts that reuse it. Luckily,
    there is a better way to solve this problem, and that is to split the script into
    different files and then include them when we need them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is going to be useful in two scenarios that are not necessarily
    mutually exclusive. We already mentioned both of them briefly.
  prefs: []
  type: TYPE_NORMAL
- en: The first one is when using external functions. Normally, when creating a script,
    everything is going to be in one file. All the functions, definitions, variables,
    and commands are going to be in one place. This is usually completely fine if
    we are creating something that is specially written to accomplish a particular
    task.
  prefs: []
  type: TYPE_NORMAL
- en: More often than not, we will need to solve something that we already worked
    on before in some other solution. In this case, we usually already have some functions
    ready that can be considered part of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: In complex scripting solutions, you might even use some common things such as
    menus, interfaces, headers, footers, logs, and other things that are exactly the
    same across every script that you make.
  prefs: []
  type: TYPE_NORMAL
- en: Another very common problem is settings that require some setup by the user.
    Large scripts can have server names, ports, filenames, users, and many different
    things that are required for the script to function. You can always put this information
    as arguments into the command line, but that will look bad and will make your
    script prone to errors since the user will have to type a lot of things by hand
    each time scripts are executed.
  prefs: []
  type: TYPE_NORMAL
- en: A common practice in these circumstances is to put everything in one file as
    variables, and then have the user edit this file as part of the installation process
    for the script. Of course, you can put everything together with the script itself,
    but that will almost certainly mean some user will change something they shouldn't
    have.
  prefs: []
  type: TYPE_NORMAL
- en: As always, there is a solution for that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`bash` has built-in functionality that enables including different files into
    a script. The idea is pretty simple—there is a *master script file* that gets
    executed as the script itself. In that file are commands that tell `bash` to include
    different files and scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with everything else, even though this is a pretty easy thing to do, there
    are some things you need to know. The command we are going to use first is `source`.
    Before we explain everything, we are going to create two scripts. The first one
    is going to be the script that the user is going to run, and it is going to look
    like this. Name the file `main.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to run it just to see how the script behaves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The results are what we expected—our current directory is the same as the one
    we ran the script in, and `$SHLVL` is `2` since we ran our script in a separate
    shell (`lvl2`) from the command line (`lvl1`). Our variable is defined as `main`
    and it hasn't changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to create our second script and name it `auxscript.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The biggest thing here is that we are not using the usual `#!/bin/bash` notation
    at the start of the script. This is intentional, as this file is meant to be included
    in other scripts, not run by itself.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we are doing more or less the same things as in the main script,
    outputting some text and values, and working with variables.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we are changing the variable is to show what actually happens inside
    this included part of the file and how it interacts with the main script body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to change the `main.sh` script and add just one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The main thing now is to run the `main.sh` script again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Some interesting things happened here. What we can see is that our environment
    variables haven't changed but the test variable did.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to explain that, but we are going to do one more thing before that—we
    are going to use another command instead of `source`. A lot of people new to scripting
    tend to confuse the `source` command that we just showed you with executing a
    script. After all, we are including a script inside a script, so those things
    do look similar. We are going to try to do it in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to change a single line inside the main script, but our `aux`
    script is going to stay the same. There are multiple ways in which we can do it,
    but we intentionally chose to run `bash` and run our second script explicitly.
    The reason is simple—other methods require our script to have the executive bit
    set (something we haven''t done) or depend on less readable versions of the same
    thing as just running a command called `exec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing we have changed is that we are not including the script—we are
    executing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can see, however, that this small change created a huge difference in the
    way our script works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last example we did requires quite a lot of explaining, and we need to start
    with how `bash` works.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `source` command tells `bash` to go find a file and use its contents
    at the place where we sourced the file. What `bash` does is straightforward—it
    just replaces this line with the entire file we pointed to. All the lines are
    inserted and then executed as if we copy-pasted the entire file into our original
    script.
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason why in our first example nothing changed. Our script started
    running from the main file, continued running commands from the auxiliary file,
    and then returned to the main file to finish the commands that followed.
  prefs: []
  type: TYPE_NORMAL
- en: When we changed our `source` for `bash`, we created a completely different scenario.
    By using the `bash` command inside the script, we are telling the shell to start
    another instance and execute the script we are referring to. This means that the
    entire environment is created, and unless we explicitly specify that we need some
    variables in the new environment, they are not going to get exported.
  prefs: []
  type: TYPE_NORMAL
- en: This is also the reason that our `$SHLVL` variable incremented—since we called
    another shell inside, the shell level had to go up.
  prefs: []
  type: TYPE_NORMAL
- en: Our test variable vanished because we didn't export it, so it had no value before
    being set, and since our environment was created just to run these couple of lines,
    the same variable simply disappeared when the script we called ended.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that executing a script and sourcing it are completely different things,
    and when in doubt, think about what you are trying to do. If you want to execute
    something inside a script such as a regular command, use `bash` or `exec`. If
    you would otherwise copy-paste code from another script, use `source`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we finish with this recipe, we also need to mention functions. Including
    functions is exactly the same as including any other part of any other script,
    with one important difference. In order for your code to work, you *must* include
    functions at the start of the script or immediately before you try to use said
    functions. If you don't do that, the resulting error is going to be the same as
    if you hadn't defined your function at all.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://bash.cyberciti.biz/guide/Source_command](https://bash.cyberciti.biz/guide/Source_command)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_01.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_01.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing commonly used procedures via functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By this point, we have created a lot of different and very simple scripts that
    more or less used `echo` and a few commands just to show how a particular thing
    in `bash` works. In this recipe, we are going to give you a couple of ideas on
    how to use what we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to create a small script that is going to show you how to easily
    automate the most mundane tasks on any system. The idea here is not to show you
    every task possible, but instead to show you how to tackle the most common problems.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we even start with the script, we need to go back to the recipes where
    we were explaining how to start writing scripts. What we are talking about are
    the prerequisites and presumptions we are going to make when we create and run
    this script.
  prefs: []
  type: TYPE_NORMAL
- en: Every script will have its own prerequisites. These are usually a list of things
    that your script needs to run—either it requires different packages or it needs
    some other condition that has to be met in order for the script to work, such
    as a working database or a working web server.
  prefs: []
  type: TYPE_NORMAL
- en: For this one, we are presuming that you have installed a package called `curl`
    and that you are connected to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Now, for the presumptions that we are depending on, this script has some commands
    that affect users and groups on the system. This means that in order for that
    part of the script to work, we absolutely need the script to be run either by
    the `root` user or another user who has administrative privileges.
  prefs: []
  type: TYPE_NORMAL
- en: The script also presumes a lot about users and checks only if we have enough
    parameters, not the quality of arguments that were provided. This means that a
    user can give the script a number instead of a string, and the script will happily
    use this as a valid parameter. We will explain how to deal with that when we start
    dissecting the script.
  prefs: []
  type: TYPE_NORMAL
- en: As a person responsible for writing scripts, part of your job is to be aware
    of these preconditions and to make sure to address them. There are two ways you
    can do that—the first is by stating what your script expects in some form of document
    that will follow your script.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing you can do (and we highly recommend this) is to check for every
    possible condition that you can think of, and if something is wrong, either print
    an error message and stop your script or, if you know what the problem is, try
    to rectify it.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of things you can solve inside the script are administrator privileges—your
    script can test if it can run, and ask the user to elevate privileges if the permissions
    are too low. You can also test if a particular package is present on the system
    if you see that some command that is not standard fails.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, how you solve problems in your script is going to be up to you and
    your skill level, but before you do anything, remember that when it comes to scripting,
    you need to test everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, here''s the actual script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script requires some explaining, and we intentionally did not comment on
    any of it for two reasons. One was that comments would make the script so long
    it would require too many print pages, and the other one was to be able to go
    through it block by block in this explanation without breaking your flow with
    short comments. Having said that, always comment on your scripts!
  prefs: []
  type: TYPE_NORMAL
- en: So, our script starts with a function. Considering this function has only one
    line, you may be surprised that we decided to break it into function, but we had
    a point to make.
  prefs: []
  type: TYPE_NORMAL
- en: Some commands, such as `rsync` or `tar`, for example, have a complicated list
    of switches that are often used. When creating a script, it is sometimes easier
    to put some of those commands into a function to be able to call the function
    without having to remember all the switches every time. This also goes for commands
    that need a lot of parameters that are predetermined when the script is configured.
    Put all of them into a function and then call the function with only the bare
    minimum of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we put into a function is *usage*, a block of text that helps
    the user to run the script, giving them enough information so they don't need
    any other type of help.
  prefs: []
  type: TYPE_NORMAL
- en: If you can, please write more verbose help pages for your script. You can even
    create a `read the help page for more information`.
  prefs: []
  type: TYPE_NORMAL
- en: In this function, we are using the `$0` positional argument in order to output
    the name of the script. Use this way of giving the user help when you are giving
    examples on script usage. Avoid hardcoding the script name because you don't know
    if the user changed the filename of the script, and hardcoded names can then completely
    puzzle them.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you are using any special character in your text, use quotation marks;
    otherwise, you may run into errors or, worse, completely unexplainable errors.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of our script deals with each individual command. When creating
    a command-line utility such as this, decide in advance whether you are going to
    create a tool that will use *commands* such as this one, *switches* such as -`h`
    or `—something`, or some sort of simple textual interface. There are pros and
    cons for all of these, but in essence, the format that we chose is mostly used
    for scripts that can do multiple tasks one at a time. Switches enable you to introduce
    many parameters to a task, and **user interfaces** (**UIs**) are targeted toward
    inexperienced users. Also, remember that your script may be used from inside other
    scripts, so avoid interfaces that will block that.
  prefs: []
  type: TYPE_NORMAL
- en: In the `case` statement, we are checking for a couple of things. First, we are
    testing if the first argument is a valid command. After that, we are checking
    if there are enough arguments for a given command to make sure that we can run
    it without errors. Even with this, we are not doing nearly enough testing for
    the validity of arguments. When reading this, try to add a few more sanity checks
    such as *are the parameters actually valid*, *did the user input a valid parameter
    containing spaces that got divided into multiple strings*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not going into too much detail for individual commands; we are only
    going to mention the one that, in all fairness, looks completely out of place.
    We are, of course, talking about the `weather` command that gives you a weather
    report for your city:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – wttr.in is one of many interesting services available online'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.1_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – wttr.in is one of many interesting services available online
  prefs: []
  type: TYPE_NORMAL
- en: Internet is full of useful services, and [wttr.in](http://wttr.in) is definitely
    one of those. If you go to [wttr.in](http://wttr.in) or run `curl wttr.in`, you
    are going to get a weather report for the city that the system thinks you are
    living in. There is some deep magic involved here—the system is going to try to
    guess where you are based on your **Internet Protocol** (**IP**) address, and
    even while having to do that, it is going to give you a pretty accurate forecast
    almost immediately.
  prefs: []
  type: TYPE_NORMAL
- en: We chose to show you this example on purpose—if you add a city name to the [wttr.in](http://wttr.in)
    link, the system is going to show you the weather in that city, while even trying
    to guess the exact city name. There are a couple of really useful online services
    such as this accessible from the command line, and using some of them means you
    can extend your script in the most unusual ways.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the recipe, note that we are checking for different errors in
    how the script is invoked in three different ways. Always try to anticipate errors
    such as this.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following web page is a must-see if you do anything in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://stackify.com/top-command-line-tools/](https://stackify.com/top-command-line-tools/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
