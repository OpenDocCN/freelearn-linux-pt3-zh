- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pipes and Redirection
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you’re going to learn how to harness one of the most powerful
    computing concepts in existence: pipes! Pipes can be used to connect commands,
    building up complex, customized flows that accomplish a specific task. By the
    end of the chapter, you’ll be able to understand (or compose) something like this:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In case you’re curious, this prints out a top-10 list of your most commonly
    used shell commands; on my machine, it produces this output:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To really understand pipes, you need to first understand file descriptors and
    input/output redirection, so that’s where we’ll start. Some of the information
    in this chapter is quite dense; just take your time and try out all the examples
    to make sure you understand everything. The time you invest in learning these
    concepts now will save you many hours throughout your career.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: File descriptors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting commands together with pipes (`|`)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CLI tools you need to know
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical pipe patterns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting file descriptors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File descriptors
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’re probably familiar with file handles (also known as *file descriptors*)
    from your software engineering experience. If not, we recommend you check out
    *Chapter 5**, Introducing Files*. In short, if your program needs to read or write
    a file on the operating system, opening that file gives you a “file handle” to
    it – a pointer, or reference, to that file object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Because the operating system mediates all access to system resources like files,
    it tracks which file handles, or descriptors, your program is actively referencing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'But even if a process doesn’t touch a single file on the operating system,
    it’s got some file handles open. In Unix-like operating systems, every process
    has at least three file descriptors:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '`stdin`: standard input - or, `fd 0` (“file descriptor zero”)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stdout`: standard output - or, `fd 1` (“file descriptor one”)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stderr`: standard error - or, `fd 2` (“file descriptor two”)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These first three file descriptors function as standard communication channels
    to (and from) a process. As a result, they exist in the same order for every process
    created on the system. The first always points to a file which will be used to
    read in input. The second points to a file that will be used for writing output.
    And the third references a file that will receive error output.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, after those first three standard file descriptors, there can be
    any number of other file descriptors/handles, based on what the program is doing.
    Your process could have:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Files it’s working with
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sockets it’s reading from or writing to (think Unix or TCP sockets being written
    to for networking)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Devices like keyboards or disks it needs to use
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do these file descriptors reference?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You now know, from the perspective of a process, what these file descriptors
    are used for:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '`0` (`STDIN`): get input from here'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` (`STDOUT`): put regular output here'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` (`STDERR`): put error output here'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But if we zoom outside of a single process, which files are these file descriptors
    actually pointing to? Where does input come from, and where do output and errors
    get written to?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们跳出单个进程来看，这些文件描述符到底指向哪些文件呢？输入来自哪里，输出和错误又写入哪里？
- en: 'Let’s use a Bash shell process as an example: by default, it takes input (STDIN)
    from your terminal (which is represented by a file on the filesystem). Bash prints
    output and errors to the same terminal. In essence, your entire shell session
    is happening via read and write operations to a single file. You’ll learn much
    more about Bash in the next chapter, *Automating Tasks with Shell Scripts*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Bash shell进程为例：默认情况下，它从你的终端（在文件系统中表示为一个文件）获取输入（STDIN）。Bash将输出和错误打印到相同的终端。实际上，你的整个shell会话都是通过对一个文件进行读写操作来进行的。在下一章*使用Shell脚本自动化任务*中，你将学到更多关于Bash的知识。
- en: Let’s look at this kind of input and output redirection in more detail.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这种输入和输出重定向。
- en: Input and output redirection (or, playing with file descriptors for fun and
    profit)
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入输出重定向（或者说，玩转文件描述符以获得乐趣和收益）
- en: 'This knowledge comes in handy quite often during real-life development tasks:
    every time you want to avoid typing lots of input and take it from a file instead,
    or when you want to log the output of a program, and many more situations. When
    you create a process, you can control where its three standard file descriptors
    point, with powerful results.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些知识在实际开发任务中非常有用：每当你想避免输入大量内容而改为从文件中获取，或者当你想记录程序输出时，都会用到这种技巧，还有许多其他情况。当你创建一个进程时，可以控制它的三个标准文件描述符指向哪里，从而产生强大的效果。
- en: 'Input redirection: <'
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入重定向：<
- en: The `<` (less-than) symbol lets you control where a process gets its input from.
    For example, you’re used to giving input to Bash with your keyboard, one command
    at a time. Let’s try giving Bash input from a file, instead!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`<`（小于）符号让你控制一个进程的输入来源。例如，你通常是通过键盘逐个命令给Bash提供输入。让我们尝试从文件给Bash提供输入吧！'
- en: 'Assume I have a file named `commands.txt` with the following content (I’m using
    `cat` here to print out my example file):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有一个名为`commands.txt`的文件，内容如下（我在这里用`cat`来打印我的示例文件）：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These are valid shell commands, as far as Bash is concerned, so I’m going to
    launch a new Bash process and use this file as standard input:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是Bash认为有效的Shell命令，所以我要启动一个新的Bash进程，并将此文件作为标准输入使用：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instead of prompting me for input and waiting until I give it, Bash reads and
    executes one line at a time: it reads input from the file until it comes across
    a newline (`\n`) character, and just as if you’d hit the *RETURN* key, it executes
    the command.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Bash不会提示我输入并等待我输入，而是一次读取并执行一行：它从文件中读取输入，直到遇到换行符（`\n`）为止，就像你按下*RETURN*键一样，它执行命令。
- en: In this example, the program’s standard output is still going back to our terminal,
    where we can read it. Let’s change that now.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，程序的标准输出仍然回到我们的终端，我们可以读取它。现在让我们来改变它。
- en: 'Output redirection: >'
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出重定向：>
- en: 'We want to redirect `STDOUT` (file descriptor `1`) to a file instead of a terminal,
    logging the output of each command instead of printing it out to the terminal
    in real time:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想将`STDOUT`（文件描述符`1`）重定向到一个文件，而不是终端，将每个命令的输出记录下来，而不是实时地打印到终端：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice that there is no visible output in the terminal now – because the `>`
    character has redirected output to `output.log`. Use `cat` to print out the log
    file and confirm that it contains the expected output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在终端中没有可见的输出——因为`>`字符将输出重定向到了`output.log`。使用`cat`打印出日志文件，确认它包含了预期的输出：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Interestingly, you’ll notice that because file descriptor `1` is standard output,
    writing `>` is the same as writing `1>`. You’ll rarely see a `1` used, because
    it’s assumed that standard output is being redirected. In other words:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，你会注意到，由于文件描述符`1`是标准输出，写`>`和写`1>`是一样的。你很少看到使用`1`，因为通常会假设标准输出被重定向了。换句话说：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Use >> to append output without overwriting
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`>>`追加输出而不覆盖
- en: In the previous example, we created a log file by redirecting command output
    with `>`. If you run the example a few times, you’ll notice that the log file
    doesn’t grow at all. Each time you redirect output to a file with `> filename`,
    anything in that file will be overwritten.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们通过重定向命令输出到`>`创建了一个日志文件。如果你多次运行这个例子，你会注意到日志文件一点也没有增长。每次用`> filename`重定向输出到文件时，文件中的任何内容都会被覆盖。
- en: To avoid that – as in the case of a long-lived log file that collects output
    from more than a single process or command – use `>>` (append). This will simply
    append to your output file, instead of overwriting its entire contents each time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover Bash scripts in more detail in a later chapter, but for now, here’s
    a quick script that writes a timestamp of the current time to a log file once
    per second:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example script, we create an infinite loop (while true; do [ ... ] done)
    which runs the date command. It redirects the output of this command to the `/tmp/date.log`
    file using `>>`, which appends the output to the file (`>` would overwrite the
    file each time). Then, the script sleeps for one second, and starts again from
    the beginning.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `date` command once produces the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running this script, on the other hand, does nothing visible at first, because
    the output is being redirected to a file. Here’s what it looks like when I paste
    this little script into my terminal, let it run for a bit, kill it with *Ctrl*
    + *C*, and then print out the contents of the file it created:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You’ll use this kind of simple output redirection in all kinds of everyday situations,
    like creating an ad hoc log file for a quick debug script you throw together.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Error redirection with 2>
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many command-line programs that have a lot of expected output will also output
    occasional errors – think of a `find` command that encounters occasional “permission
    denied” errors for directories you’re not allowed to peek inside.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Although these kinds of errors are minor and expected, you don’t want them mixed
    in with everything else, polluting your output. This becomes especially important
    when you’re not using command-line tools interactively, but rather writing small
    scripts or larger programs that process the output of the commands you’re running.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve seen how to redirect Standard Input (`fd 0`) and Standard Output (`fd
    1`). Let’s look at how to redirect Standard Error (`fd 2`) using the `2>` (redirect
    file descriptor 2) syntax:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command searches for any files named `php.ini` inside the `/etc` directory
    tree. The files it finds (`find`'s `STDOUT`) are written to `/tmp/phpinis.log`,
    and any errors it encounters are ignored by sending them to a special file called
    `/dev/null`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '`/dev/null` is a special file-like object that returns zeros when you try to
    read from it and ignores anything written to it – it’s used as a kind of garbage
    dump for output that engineers want to silence or ignore. You’ll see it used quite
    often in scripts.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve seen input and output redirection, let’s look at pipes, which
    put both of those concepts together: they redirect the output of one command to
    the input of another.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Connecting commands together with pipes (|)
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve learned how to redirect each of the three standard file descriptors to
    various locations and seen why that’s often useful. But what if, instead of just
    redirecting input and output to and from various files, you wanted to connect
    *multiple programs* together?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何将三个标准文件描述符重定向到不同的位置，并了解了为什么这样做通常很有用。但如果你不仅仅是将输入输出重定向到不同的文件，而是想将 *多个程序*
    连接在一起怎么办？
- en: 'On the command line, you can use the pipe character (`|`) to connect the output
    of one program to the input of another program. This is an extremely powerful
    paradigm that is heavily used in Unix and Linux to create custom sorting, filtering,
    and processing commands:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，你可以使用管道符（`|`）将一个程序的输出连接到另一个程序的输入。这是一个非常强大的范式，在 Unix 和 Linux 中被广泛使用来创建自定义的排序、过滤和处理命令：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you paste this into your shell, you’ll see `treasure found` printed out.
    Here’s what happened:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这段代码粘贴到你的 shell 中，你会看到打印出 `treasure found`。下面是发生了什么：
- en: The first command, `echo`, runs and produces the output you see between double
    quotes (the newline characters make this a 3-line string).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个命令 `echo` 执行并生成你看到的输出（这些输出被双引号包围，换行符使其成为一个三行字符串）。
- en: The pipe character streams that output (file descriptor 1) to the input of the
    next command (file descriptor 0), `grep`. `grep`'s input is now hooked up to the
    output of the previous command.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道符将该输出（文件描述符 1）流向下一个命令（文件描述符 0）的输入，即 `grep`。`grep` 的输入现在与前一个命令的输出连接在一起。
- en: The `grep` command looks at each newline-delimited line in turn and finds a
    match for `treasure` on the second line. `grep` prints that second line to its
    standard output.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`grep` 命令依次查看每一行以换行符分隔的内容，并在第二行找到 `treasure` 的匹配项。`grep` 将第二行打印到其标准输出中。'
- en: Multi-pipe commands
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多重管道命令
- en: 'Here’s the – fairly extreme – example you saw at the beginning of the chapter:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在本章开头看到的—相当极端—示例：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each pipe in this complex command simply takes the output of the previous command
    (`STDOUT`) and uses it as the input (`STDIN`) for the next command.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个复杂的命令中，每个管道只是将前一个命令的输出（`STDOUT`）作为输入（`STDIN`）传递给下一个命令。
- en: Piping the output of one command into the input of another is what enables these
    kinds of flows, filtering and sorting the data streaming between these commands
    without actually having to write any custom software. Just because there’s no
    program called `top10commands` doesn’t mean you can’t quickly cobble one together
    with existing, standard commands like this.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个命令的输出传递到另一个命令的输入中，就是实现这些流程的方式，它能在不编写任何自定义软件的情况下，过滤和排序这些命令之间流动的数据。仅仅因为没有名为
    `top10commands` 的程序，并不意味着你不能快速利用现有的标准命令来拼凑一个类似的程序。
- en: Reading (and building) complex multi-pipe commands
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读（并构建）复杂的多管道命令
- en: 'No matter how complex or magical some of the piped-together commands you encounter
    will seem, they were all built the same way: one command at a time. Whether you’re
    trying to read a complex series of commands like this or creating one of your
    own, the process is the same:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你遇到的管道连接命令看起来多么复杂或神奇，它们都是通过相同的方式构建的：一次一个命令。无论你是在尝试理解像这样的复杂命令序列，还是自己创建一个，过程都是一样的：
- en: Take the first command and make sure you understand what it does, at a basic
    level. Scan the man page or other documentation if you aren’t familiar with it.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 先看第一个命令，确保你基本理解它的作用。如果你不熟悉它，可以查看 man 页面或其他文档。
- en: Run the command and inspect its output.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行命令并检查其输出。
- en: Add the pipe and the command following it.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加管道符及其后面的命令。
- en: Repeat from *step 1* until you’ve made it all the way through the commands.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *步骤 1* 开始重复，直到你完成所有命令。
- en: You’ll see that even the scariest shell/pipe monstrosities become manageable
    when you apply this process. Always remember that you’re just dealing with a data
    stream, which flows through the pipes from command to command, being shaped, modified,
    filtered, redirected, and transformed along the way.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，即使是最复杂的 shell/pipe 命令怪物，当你应用这个过程时也变得可以管理。始终记住，你所处理的只是一个数据流，它通过命令之间的管道流动，在这个过程中被塑形、修改、过滤、重定向和转换。
- en: 'We’ll discuss this more in *Chapter 12*, *Automating Tasks with Shell Scripts*,
    but try to be respectful of other programmers who must read your code: limit your
    statements to two or three pipes, and use well-named variables to store intermediate
    results for easy reading if your memory constraints allow it.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *第12章*，《使用 Shell 脚本自动化任务》中进一步讨论这个话题，但请尽量尊重其他需要阅读你代码的程序员：将你的语句限制为两到三个管道，并使用有意义的变量来存储中间结果，以便于阅读，如果你的内存限制允许的话。
- en: Now that you’ve seen how the primitives of file descriptors are exposed as easy-to-use
    input and output redirection, let’s look at some real-world examples of useful
    program combinations that rely on this composability that’s built into Unix.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The CLI tools you need to know
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into the kinds of wild combinations that you saw at the beginning
    of the chapter, let’s look at some of the most common Unix helper tools that are
    used to filter, sort, and glue together these data streams you’ll be creating
    on the command line.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: cut
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`cut` takes a delimiter (`-d`) and splits input on that delimiter, like `String.Split()`
    or `String.Fields()` in many programming languages. You then select which field
    (list element) you want to output with `-f`, for example, `f1` for the first field.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'If you feed `cut` more than one line of input, it will repeat that same operation
    on all lines:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can see how using different delimiters for cut would work, too; in the
    following example, we cut on the hyphen character instead of a space:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see that this changes the number of fields available as well – two in
    this case, since there’s only one hyphen in the text. Trying to print the fourth
    field with `–f4`, as in the previous example, will just give you an empty line.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'To get friendly names for all users with root in their names on an macOS machine,
    you can use the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: sort
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`sort` does a per-line sorting, alphabetical or numeric.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Reverse-sorting with `-r` is often useful when dealing with numeric data (`-n`).
    You’ll often want `-rn` together (see Top X in the Practical pipe patterns section
    of this chapter).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-h` flag can be very useful for sorting by human-readable output of many
    other commands, like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: uniq
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Removes duplicate lines. This command needs sorted data to work the way you
    expect, otherwise it only checks whether each line is a duplicate of the previous
    line:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Default behavior; probably not what you want:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`uniq` skips occurrences when they follow each other but leaves them when they’re
    separated by other text. Now the same thing, with sorted data:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Counting
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`uniq` also has a useful “count” option, accessible with `–c`. The same caveat
    about sorted input is worth restating here – for example, a file with the following
    content:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Will produce the following output when run through `uniq -c`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is not what most users expect: there are 3 occurrences of `arch` in the
    file, but `uniq` shows two separate counts for the same word. To get the behavior
    you expect (`uniq` should return output that doesn’t contain any duplicate lines),
    your input must be sorted.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'This is annoying for beginners, but very much in line with the Unix philosophy:
    tools should be small and sharp and shouldn’t duplicate functionality from each
    other. If you write a sorting tool, it should only sort, and if you write a uniquifying
    tool, it is allowed to depend on sorting from another tool to ensure extremely
    conservative (and consistent) memory usage.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we sort before using `uniq`, which gets us the output we expect:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You’ll notice that this sorts in ascending order, which isn’t what you want
    for the top-X list of commands you saw at the beginning of the chapter. To solve
    this, we do a “reverse numeric” sort (`-rn`) of this numbered list (since each
    line now starts with a number, thanks to `uniq –c`, this is easy to do). Here’s
    an example of this in action, on a file with many more duplicates:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: wc
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With this command you can measure the word, line, character, and byte input
    counts. You can also count space-delimited words with `-w`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Line-counting is extremely common in the following format:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: head
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Head` returns the first lines of a stream or file – 10 lines by default. Specify
    how many lines you want with `-n`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: tail
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the opposite of `head`: it returns lines from the end of the file or
    stream. It takes `-n` just like `head`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '`tail` can also be used interactively for following along with a log file,
    even as that file has new data streamed/written to it. You’ll see it used a lot
    like this during troubleshooting:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: tee
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, one copy of the data from standard input just isn’t enough. `tee`
    copies standard input to standard output, while also making a copy in a file.
    As a software developer, I really like `tee` for two specific cases.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'First, for debugging and logging: when I’m running scripts or programs that
    generate output, `tee` can be used to both display the output on the screen and
    log it to a file for later analysis. We’re using the `echo` command here, but
    you’d likely be calling your own program before the first pipe here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The second use case where `tee` comes in handy is for copying data from a pipeline
    like the ones we’re learning to construct in this chapter. You can use `tee` to
    intercept this flow at any point in the pipe, and save/inspect the intermediate
    results without disrupting the pipeline.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the “top 10 commands” example from earlier, but with `tee` inserted
    before limiting the results to just 10\. This saves the full results in a temp
    file before we truncate them:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now if you want to see all of the commands, not just the top 10, you can just
    use `cat` or `less` to inspect the `/tmp/all_commands.txt` file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: awk
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`awk` is often just used for dealing with columns of data, but it’s actually
    a whole language.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can grab the second column from each line in the following
    way:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: sed
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`sed` is a stream editor with tons of options. Most commonly, it’s used for
    character replacement in streams or files.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we have a file like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we want to redact ONLY the line that has `password`, and nothing else, on
    it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This example uses a file rather than an input stream coming from another command.
    By default, this will not modify the original file. If you *do* want to modify
    the input file, use the `-i` (in-place) option.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve been introduced to pipes and have seen some of the most common
    command-line tools, let’s put those building blocks together and learn several
    practical patterns that you can use to make your daily command-line life a bit
    easier.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Practical pipe patterns
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, longer multi-pipe commands are built iteratively – one
    command at a time. However, there are some useful patterns that you’ll see re-used
    frequently.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: “Top X”, with count
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern sorts the input by the number of occurrences, in descending order.
    You saw this in the original example from this chapter, which displayed the most
    frequently used shell commands from Bash’s history file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the pattern:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can note the following details about this pattern:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The input is sorted alphabetically, and then run through `uniq -c`, which needs
    sorted input to work on.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uniq -c` eliminates duplicates, but adds a count (`-c`) of how many duplicates
    it found for each entry.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort` is run again, this time as a reverse-numeric (`-r` and `-n`) sort which
    sorts the unique counts from the input and outputs the lines in reverse (highest
    number first) sorted order.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`head` takes that top ranking and cuts it down to three lines (`-n 3`), giving
    you the top three strings from the original input, along with how often they occurred.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern can come in handy when you need to know the most common browser
    user-agents hitting your website, the IP addresses of the worst offenders who
    are trying to probe and exploit your website, or any other situation where a sorted,
    ranked list is useful.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: curl | bash
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `curl | bash` pattern is a common shortcut used in Linux to download and
    execute scripts directly from the internet. This method combines two powerful
    command-line tools: `curl`, which fetches the content from a URL, and `bash`,
    the shell interpreter, which executes the downloaded script. This pattern is a
    significant time-saver, allowing developers to quickly deploy applications or
    run scripts without manually downloading and then executing them.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s install the Pi-hole adblocking DNS server using this pattern:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let’s break this down, step by step:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '`curl -sSL https://install.pi-hole.net`: This fetches the Pi-hole installation
    script, which is hosted at this URL. We pass two options:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-sS`: Silent mode gives you the raw response from the server, but shows errors
    should they occur.'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-L`: Follow redirects.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`|`: The pipe symbol passes the output of the previous command (`curl`) as
    input to the next command (`bash`).'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bash`: Executes the script fetched by `curl`.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a tremendously useful pattern for automating things like code deployments
    or local environment installation/configuration. However, take special care that
    the script you download and execute is not malicious. Blindly running scripts
    from the internet is extremely bad practice.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Security considerations for curl | sudo | bash
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Anytime you trust a third party to run code on your machine, you’re trading
    some security for convenience. In that sense, using `curl | sudo | bash` to install
    something via a script hosted on a trusted server is not much different from using
    a package manager. Most package managers (except for `nix`) don’t have a particularly
    impressive security design either, but they generally give you a reasonable set
    of security features. You’re giving all of these security features up when you
    `curl | sudo | bash` an install script:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你信任第三方在你的机器上运行代码时，你就已经在安全性和便利性之间做出了权衡。从这个角度来看，使用`curl | sudo | bash`通过托管在受信任服务器上的脚本安装软件，与使用包管理器并没有太大区别。大多数包管理器（除了`nix`）的安全设计也不算特别出色，但它们通常会提供合理的安全功能。你在执行`curl
    | sudo | bash`安装脚本时，实际上放弃了所有这些安全特性：
- en: There’s no package that can be checksummed and cryptographically signed to make
    sure you got the correct and official version.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有可以进行校验和和加密签名的包来确保你获得了正确和官方的版本。
- en: 'There’s no restriction on – or enforcement of – which servers you download
    from, and you don’t know how secure those servers are: you have no way to identify
    a compromised server hosting malicious install scripts.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载文件时没有任何限制或强制措施，你也无法知道这些服务器的安全性：你无法识别是否有被破坏的服务器托管恶意安装脚本。
- en: The scripts themselves are just code being run as the root user on your machine,
    so they can do anything *you* can on your machine, for better or worse. To be
    fair, many popular package managers also have this problem.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些脚本本身就是在你的机器上以root用户身份运行的代码，因此它们可以做任何*你*能在机器上做的事情，无论好坏。公平地说，许多流行的包管理器也存在这个问题。
- en: 'For all of these reasons, please heed our warning to split `curl` into its
    own step and read through the downloaded install script before running `sudo`
    `bash` to execute it. The main things to look out for are:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 基于以上所有原因，请注意我们的警告：将`curl`命令拆分成单独的步骤，并在运行`sudo` `bash`执行之前仔细阅读下载的安装脚本。需要注意的主要事项有：
- en: Ensure the server/domain you’re downloading the script from is trustworthy;
    this should be a reputable developer’s website or a trusted third-party code hosting
    platform.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你下载脚本的服务器/域名是值得信赖的；它应该是一个有声誉的开发者网站或受信任的第三方代码托管平台。
- en: Ensure you use HTTPS for the `curl` download (i.e., the URL should start with
    `https://`).
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保使用HTTPS下载`curl`（即URL应该以`https://`开头）。
- en: Read through the script carefully, to see which commands it runs and where it
    pulls additional code or executables from. If it downloads additional scripts
    or executables, have a look at those too.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细阅读脚本，查看它运行了哪些命令，以及从哪里拉取了额外的代码或可执行文件。如果它下载了额外的脚本或可执行文件，也要查看这些内容。
- en: I think we’ve established that `curl | sudo | bash` is not a particularly secure
    method of installing software. Following these guidelines can help you be a bit
    safer if you – like most of us – give into temptation one day and follow this
    installation method for a specific piece of software (for example, `homebrew`
    on macOS).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定，`curl | sudo | bash`并不是一种特别安全的软件安装方法。如果你像大多数人一样，某一天禁不住诱惑，使用这种安装方法来安装某个特定的软件（例如macOS上的`homebrew`），遵循这些指南可以帮助你在一定程度上提高安全性。
- en: 'Let’s look at another common pattern now: filtering and searching with `grep`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个常见的操作模式：使用`grep`进行过滤和搜索。
- en: Filtering and searching with grep
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`grep`进行过滤和搜索
- en: When you run commands that produce a lot of output, it’s generally best practice
    to filter the output down to just what you need. The most common tool for this
    is called `grep`, and you can think of it as a highly configurable text search
    or string-matching function. Here’s an example of what filtering might look like.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行产生大量输出的命令时，通常最好将输出过滤到仅需要的内容。最常见的工具是`grep`，你可以将其视为一个高度可配置的文本搜索或字符串匹配功能。以下是过滤操作可能的示例。
- en: 'Imagine that you need to find a Linux process’s working directory. The `lsof`
    tool can accomplish this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要找到一个Linux进程的工作目录。`lsof`工具可以实现这个功能：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s a quick description of what’s happening:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是发生情况的简要说明：
- en: I’m getting a listing of open file handles for a specific process (PID 3243),
    using `lsof`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我正在使用`lsof`获取一个特定进程（PID 3243）的打开文件句柄列表。
- en: I’m then passing the results (`|`) to the `grep` utility and using that to search
    the results for the string `cwd`. There’s only one line of results that contains
    the string `cwd`, so that’s the only line that `grep` prints to the terminal.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This pattern is useful anytime you have a *lot* of data as input, but you only
    need a subset of that data that can be identified by a specific string. `grep`
    operates on lines of input text, so it’s hugely helpful for picking out data like:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Loglines containing the IP address you are following
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occurrences of a username in a piped data stream
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lines that match a pattern (`grep` is regular-expression aware and can take
    string patterns in addition to literal search strings)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep` is a large and powerful tool that you’ll have occasion to use almost
    every day. For more information, check out the manpage for grep by typing `man
    grep`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: You’ve already seen `grep` used on files in this book (for example, `grep searchstring
    hello.txt`), but it’s also an invaluable filtering component in piped commands.
    Let’s look at a practical example now.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: grep and tail for log monitoring
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you’re looking at production logs to try to figure out what’s wrong, you’ll
    often only want to see loglines containing certain keywords or search strings.
    To do that, you’d run something like:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This pattern continuously monitors the log file for new entries whose content
    matches “yourSearchRegex”, so you can see only the logs you need for the task
    at hand.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: find and xargs for bulk file operations
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`xargs` is a powerful utility that gives you the power of iteration (in other
    words, a “for” loop) inside of a single command. By default, `xargs` takes each
    (space, tab, newline, and end-of-file delimited) chunk of input it receives and
    executes the specified program using that chunk as input. For example, if you
    need to search for specific file content across `ONLY` the files returned by a
    certain `find` query, you can run this command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This command finds all files whose names end with `.txt` and then uses `xargs`
    to apply the `grep` command to each file individually. This pattern is handy for
    searching or modifying multiple files at once. Please be forewarned that `xargs`
    is a powerful – and *large* –program, capable of doing many things (including
    string interpolation into the command it executes). We can’t cover it all here,
    so please read the manpage and scour the internet for examples if you’re in a
    situation where this kind of functionality would save the day.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: sort, uniq, and reverse numerical sort for data analysis
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a useful pattern that you saw applied at the beginning of the chapter,
    where I used it to filter a large command history to get a list of the “top X
    most popular commands run on this system.” The core pattern is this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Useful for analyzing data, this pattern sorts the data from the input stream,
    deduplicates it while counting unique occurrences, and then performs a reverse
    numerical sort to give you the deduplicated data, with the most common lines first.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'This is commonly truncated with `| head -n $NUMBER` to get only the top `$NUMBER`
    of results:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we use history to fetch the entire shell command history. This gives
    us a series of lines like:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We’re only interested in the top-level command (in this case, `brew`), so we
    use `awk` to fetch the second column.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Then we sort so that duplicates of the same command occur next to each other
    in the stream. Then we remove those duplicates with `uniq`, adding a count of
    occurrences to each remaining one. Now we sort again – this time using `-rn` for
    a reverse numerical sort, which gives us the “top X” effect. Finally, we take
    the first 10 lines with head.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'This prints out the aforementioned top-10 list of your most-used shell commands;
    on my machine, it produces this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: awk and sort for reformatting data and field-based processing
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`awk` is more than a program; it’s a stream-processing language. If you work
    with data streams on Unix system, then spending a few days learning the basics
    can save you weeks of time over your career. That said, just using `$#` syntax
    to reference whitespace-delimited columns in each line of the data stream is a
    good start.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example given a data stream like the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When the awk interpreter sees `$1`, it interprets this to mean “the first column”
    or in this case `Foo` in line 1 and `Some` in line 2\. `$2` is the second column
    (`bar`, `data`), and so on. This is an incredibly common feature to use when working
    with data that’s just a bit too complex for simple `cut` commands:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This would produce output like:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this case, it prints out column 2 before column 1 for each file, and ignores
    all other data in each line. This is often used for reformatting and organizing
    data based on specific fields.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: sed and tee for editing and backup
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**sed** stands for **Stream EDitor** and is used when you want to transform
    a data stream. You do this ten times a day in your text editor when you find/replace
    a symbol. The following command is essentially the command-line version of that
    functionality: it transforms all occurrences of `old` in `file.txt` into the string
    `new` and writes the resulting stream to a new file, `file.txt.changed`. It does
    this without making changes to the original `file.txt` `file`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Although editing file content is an easy demonstration of this concept, `sed`
    is tremendously useful for transforming stream data as it zips from the output
    of one command to the input of the next:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ps, grep, awk, xargs, and kill for process management
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although `pgrep` is a good utility for sending signals to all processes whose
    name matches a pattern, sometimes it’s just not available on your system. You
    can cobble together similar functionality (and get much more specific with what
    you want to target, not just the name) by using this set of piped-together commands:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`ps` starts you off with a list of running processes, which `grep` filters
    to just those containing the pattern you’re searching for. `awk` gets the second
    column (the process ID) for each matching line, and then feeds all matched lines
    to `xargs` (our quasi for loop), which executes `kill` on each PID. This sends
    a `SIGTERM` to each matching process and (hopefully) halts it.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: tar and gzip for backup and compression
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although many utilities have flags that let you do both, chaining together
    archiving and compression is another use case that makes sense. This gives you
    the added flexibility of adding additional chained commands. For example, if you
    want to add encryption, that’s just a single additional piped command away:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This creates a compressed archive of a directory, commonly used for file backup
    and storage. You can see larger commands using this kind of pattern:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is an especially fun example that logs into a database server using SSH,
    dumps out a database, compresses that data stream, shuttles it back to the local
    machine over SSH, decompresses it again, and finally dumps it into the local MySQL
    server.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Your aim shouldn’t necessarily be to write commands as complex as this one (or
    some of the others you’ve seen here), but if you know how to put something like
    this together in a pinch, it can get you out of some extremely tight spots as
    a developer. We hope this section has demonstrated that understanding the input
    and output redirection primitives that Unix systems expose to you – via `<`, `>`,
    `>>`, `|`, and file descriptors in general – is basically a superpower. Use it
    wisely.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Advanced: inspecting file descriptors'
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On Linux, you can easily *see* where a process’s file descriptors are pointing.
    We’re going to use the slightly magical `/proc` virtual filesystem to do just
    that.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Procfs (the `proc` virtual filesystem) is a Linux-only abstraction that represents
    kernel and process state as files. The data inside of these files comes straight
    from the operating system kernel, and only exists while you’re reading them. Just
    listing the `/proc` directory will show you many files; here’s a selection of
    some of the more important ones, taken from the Arch Linux wiki:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'What’s most interesting to us with regard to file descriptors is something
    not shown in the listing above: `/proc` contains a directory for every single
    process running on the machine, named after each **process ID** (**PID**).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: In a process’s `/proc` directory, that process’s file descriptors are represented
    as symbolic links in a directory called `fd`. When you do a long listing on this
    `/proc/$PID/fd` directory, you’ll see that `l` is the first character in the long
    listing, which denotes a special `link` file, as you’ll recall from *Chapter 5*,
    *Introducing Files*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Practically speaking, `/proc/1/` is the `init` process’s proc directory, and
    you can view init’s file descriptors by doing a long listing on `/proc/1/fd`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the file descriptors for an interactive Bash shell process running
    on my machine, which `ps aux | grep bash` tells me is PID 9:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You’ll notice that it’s an interactive shell session: its standard input is
    coming from a virtual terminal (`/dev/pts/1`), and its standard error and output
    are going back to that same terminal. That checks out.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a text editor like vim, which behaves a lot like a terminal –
    input and output happen via a terminal. However, there’s an added complication,
    which is that text editors usually keep one or more files open for writing. What
    does that look like?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, I’m running the vim text editor, and editing a file in the
    `/tmp` directory. Let’s find the process ID for vim, so we know which `/proc`
    directory to look inside:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'There it is; process 453\. Don’t be misled by the `grep` command which also
    includes `vim` in its command arguments. Now that we have the PID, let’s look
    at vim’s file descriptors:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We can see that stdin (`0`), stdout (`1`), and stderr (`2`) are all pointing
    to a terminal device, just like a shell. And we also see that the editor has a
    file open, with file descriptor `3` linked to the file that vim is editing. When
    a process opens additional files, new file descriptors are created, and you can
    view them here.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond being interesting for its own sake, this can come in handy when programs
    are behaving erratically due to bugs, or when you’re trying to trace what a potentially
    malicious program is doing. `procfs` is quite interesting and useful if you invest
    a bit of time in learning it: just type `man proc` to get started, or read the
    Arch Linux Wiki page for a gentler introduction at [https://wiki.archlinux.org/title/Procfs](https://wiki.archlinux.org/title/Procfs).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we put together all of the previous skills and theory we’ve
    covered to unlock one of the most powerful features of Unix and Linux systems:
    streaming data through multiple commands using pipes and input/output redirection.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: We started by showing you how the operating system exposes primitives like file
    descriptors, and then started looking at practical uses of input and output redirection.
    Then, we covered pipes, which are arguably one of the most useful features of
    Linux and other Unix operating systems. After covering the necessary theory and
    showing you some useful examples, we dove deep into the most common helper tools
    that people use to slice and dice the data streams that they build up using pipes.
    Finally, we showed you some of the most common and useful patterns and program-combinations
    that people use in the real world.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: What’s in this chapter is the foundation for much of the advanced command-line
    usage you’ll encounter and use in your day-to-day work. You’ve now been exposed
    to some of the basic theory, tools, and patterns that you’ll see in the wild,
    which will make it easy to dive in and start building custom commands for common
    development, troubleshooting, and automation use cases.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: To grow your skills, use what you’ve seen in this chapter in your day-to-day
    work! Use it as a reference for patterns to try, and keep learning new tools and
    commands that you can add to your own custom recipes and use to filter or otherwise
    manipulate data on the command line. You’ll feel like a wizard in no time.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1768422420210094187.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
