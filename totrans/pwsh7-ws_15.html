<html><head></head><body>
		<div id="_idContainer287">
			<h1 id="_idParaDest-297" class="chapter-number"><a id="_idTextAnchor302"/>15</h1>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor303"/>PowerShell 7 and the Raspberry Pi</h1>
			<p>This is one of the chapters I’ve looked forward to writing the most. I’ve got a house full of Raspberry Pis (and Arduinos, micro:bits, and ESP32s…). I use them to teach coding to school kids (and adults), as well as to run adblockers, media centers, wildlife cameras, and horticultural systems. I’ve got one with buttons that randomly selects episodes of my favorite radio shows<a id="_idIndexMarker1052"/> and plays them (called the Shendomizer). Mostly, I program them with Python, but PowerShell is also an option. We can even install a stripped-down version of Windows 10 on them, but we won’t cover that in this book. Instead, we’ll look at how to install PowerShell 7 and <strong class="bold">Visual Studio</strong> (<strong class="bold">VS</strong>) Code, how to connect remotely to a headless Pi over Wi-Fi using SSH with both PowerShell and VS Code, the default module for working with PowerShell on the Raspberry Pi, and finish up by creating a script to accomplish the first steps in physical computing: getting an LED to blink on <span class="No-Break">and off.</span></p>
			<p> The main topics we’ll cover in this chapter are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Introduction to the <span class="No-Break">Raspberry Pi</span></li>
				<li>Installing PowerShell and <span class="No-Break">VS Code</span></li>
				<li>Connecting remotely to <span class="No-Break">the Pi</span></li>
				<li>Running PowerShell on Raspberry <span class="No-Break">Pi OS</span></li>
				<li>Simple <span class="No-Break">physical computing</span></li>
			</ul>
			<h1 id="_idParaDest-299"><a id="_idTextAnchor304"/>Technical requirements</h1>
			<p>For this chapter, we will need a Raspberry Pi with a power supply, screen, keyboard and mouse, and the requisite cables. Some of this chapter has been written on the Pi 400, which is a handy version of the Pi that’s installed on a keyboard with everything we need except a monitor. Other parts have been written using a Raspberry Pi 3 <span class="No-Break">single-board computer.</span></p>
			<p>Note that a Pi Zero or Pi Pico will not work. They use a different ARM chip version, so the architecture won’t work <span class="No-Break">with .NET.</span></p>
			<p>For simple automation, we’ll need <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">A breadboard</span></li>
				<li><span class="No-Break">An LED</span></li>
				<li>A 300-400 Ohm resistor (but 250-500 <span class="No-Break">will work)</span></li>
				<li>Two male-to-female <span class="No-Break">jumper cables</span></li>
			</ul>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor305"/>Introduction to the Raspberry Pi</h1>
			<p>The Raspberry Pi is a small, affordable, and versatile<a id="_idIndexMarker1053"/> single-board computer developed by the Raspberry Pi Foundation in the UK. Its primary goal was to promote the teaching of basic computer science in schools and developing countries. However, its accessibility, low cost, and ease of use have made it incredibly popular among hobbyists, educators, and professionals for various applications, from learning programming to building <span class="No-Break">complex projects.</span></p>
			<p>It’s designed to be a blank slate, allowing users to understand the basics of hardware and software interactions. This computer is essentially a tiny, self-contained PC that can be used for many of the same tasks we might use a desktop or laptop PC for, such as browsing the internet, word<a id="_idIndexMarker1054"/> processing, and playing games. Moreover, its <strong class="bold">general-purpose input/output</strong> (<strong class="bold">GPIO</strong>) pins enable it to interact with external hardware, making<a id="_idIndexMarker1055"/> it ideal for electronics projects and <strong class="bold">Internet of Things</strong> (<span class="No-Break"><strong class="bold">IoT</strong></span><span class="No-Break">) applications.</span></p>
			<p>Over the years, several models of the Raspberry Pi have been released, each improving on its predecessor. The latest model is the Raspberry Pi 4 Model B. This model has a 64-bit quad-core ARM Cortex-A72 CPU, offering processing speeds of up to 1.5 GHz. It comes in variants that have 2 GB, 4 GB, or 8 GB of LPDDR4-3200 SDRAM. For connectivity, it includes Gigabit Ethernet, Bluetooth 5.0, and dual-band Wi-Fi (2.4G Hz and 5.0 GHz). It also has two USB 3.0 ports, two USB 2.0 ports, two micro HDMI ports supporting up to 4K resolution, and a USB-C port <span class="No-Break">for power.</span></p>
			<p>The Raspberry Pi can run various <strong class="bold">operating systems</strong> (<strong class="bold">OSs</strong>), with Raspberry Pi OS<a id="_idIndexMarker1056"/> (formerly Raspbian) being the most popular. This Debian-based OS is optimized for the Raspberry Pi hardware and comes pre-loaded with essential tools, programming languages, and applications. Users can also install different flavors of Linux and even a version of Windows 10 IoT Core. The OS can be installed by flashing an image to a <span class="No-Break">MicroSD card.</span></p>
			<p>For programming, Python is the most commonly used language due to its simplicity and power. However, the Raspberry Pi supports numerous other languages, such as JavaScript, PHP, C++, Java, and, most importantly for us, PowerShell 7. Its versatility makes it a valuable tool for software development, especially in IoT and <span class="No-Break">embedded systems.</span></p>
			<p>The Raspberry Pi’s range of use cases is vast. In education, it’s used to teach programming, computer science fundamentals, and even hardware design. Hobbyists use it for projects such as retro gaming consoles, media centers, and home automation systems. In professional settings, it serves as a cost-effective tool for prototyping, data collection, and automation. We can also use it for parallel computing; an example of this is the OctaPi project run by GCHQ in the UK. Some institutions even use it as a supercomputer; the Los Alamos National Laboratory built a 750-node high-performance computer out <span class="No-Break">of Pis.</span></p>
			<p>The Raspberry Pi ecosystem has expanded over the years since its release in 2012. There are three separate series: the Pi, the Pi Zero, developed as a lightweight and even cheaper alternative that can be dedicated to a single project and left to run (I have several Pi Zero wildlife cameras running on rechargeable batteries), and the Pi Pico, an alternative to the popular Arduino single chipboard. PowerShell 7 will only run on the full-fat Pi, not the Pi Zero or Pico. These smaller alternatives run on ARMv6 chip designs; .NET, and therefore PowerShell 7, requires an ARMv7 or ARMv8 chip, as found in the Pi 2, 3, and 4. This is partly because the ARMv6 is lower-powered, but also because nobody wants to be designing<a id="_idIndexMarker1057"/> for old hardware, <span class="No-Break">do they?</span></p>
			<p>Right. Shall we get on and install PowerShell on <span class="No-Break">a Pi?</span></p>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor306"/>Installing PowerShell 7 and VS Code</h1>
			<p>Raspberry Pi OS is a Linux distro based on Debian, the same as Ubuntu, so the Ubuntu instructions we followed in <a href="B17600_14.xhtml#_idTextAnchor280"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, <em class="italic">PowerShell 7 for Linux and macOS</em>, will work, but there’s an even easier way to <span class="No-Break">do it.</span></p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor307"/>Installing PowerShell</h2>
			<p>If we go to the <em class="italic">Community support for PowerShell on Linux</em> page at <a href="https://learn.microsoft.com/en-us/powershell/scripting/install/community-support">https://learn.microsoft.com/en-us/powershell/scripting/install/community-support</a>, we’ll find<a id="_idIndexMarker1058"/> a very handy<a id="_idIndexMarker1059"/> script that will install PowerShell for us, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer269" class="IMG---Figure">
					<img src="image/B17600_15_1.jpg" alt="Figure 15.1 – The Raspberry Pi OS install script"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – The Raspberry Pi OS install script</p>
			<p>If we click the <strong class="bold">Copy</strong> button in the top-right corner of the script box, then we can simply open a terminal window on the Raspberry Pi and right-click to paste it into the terminal, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer270" class="IMG---Figure">
					<img src="image/B17600_15_2.jpg" alt="Figure 15.2 – Installing PowerShell by pasting the script into the terminal"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 – Installing PowerShell by pasting the script into the terminal</p>
			<p>Once we’ve pasted it, all we have<a id="_idIndexMarker1060"/> to do is press <em class="italic">Enter</em> on the line highlighted in the preceding screenshot, at which point the script will work through, install, and then <span class="No-Break">start PowerShell.</span></p>
			<p>Of course, that may be prone to errors, so we might want to actually create a script, check that it’s right, and then execute it. To do this, from the terminal prompt, type <span class="No-Break">the following:</span></p>
			<pre class="console">
nano</pre>			<p>This will open the nano text editor. Paste the script into nano, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer271" class="IMG---Figure">
					<img src="image/B17600_15_3.jpg" alt="Figure 15.3 – Creating a PowerShell install script in nano"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 – Creating a PowerShell install script in nano</p>
			<p>Check that you’ve pasted<a id="_idIndexMarker1061"/> it correctly, and then save it by pressing <em class="italic">Ctrl</em> + <em class="italic">X</em>, typing <em class="italic">Y</em> when asked to save it, and then typing a suitable filename – I’ve called mine <strong class="source-inline">installPosh.sh</strong>. Once we’ve returned to the terminal prompt, we can run the script by typing <span class="No-Break">the following:</span></p>
			<pre class="console">
sudo bash ./installPosh.sh</pre>			<p>Again, we’ll be taken straight to PowerShell. Now, let’s look at installing <span class="No-Break">VS Code.</span></p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor308"/>Installing VS Code</h2>
			<p>Getting VS Code onto our Pi is even<a id="_idIndexMarker1062"/> easier. VS Code is included in the official repositories for Raspberry Pi OS, so we don’t need to manually download files or set up alternative repositories – we can just open the terminal and type <span class="No-Break">the following:</span></p>
			<pre class="console">
sudo apt-get update
sudo apt install code</pre>			<p>Once we’ve done this, after a few minutes, VS Code will appear on our machine alongside a lot <span class="No-Break">of chatter:</span></p>
			<div>
				<div id="_idContainer272" class="IMG---Figure">
					<img src="image/B17600_15_4.jpg" alt="Figure 15.4 – Installing and starting VS Code on the Raspberry Pi"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4 – Installing and starting VS Code on the Raspberry Pi</p>
			<p>We can either type <strong class="source-inline">code</strong> in the terminal, or we can find it in the <strong class="bold">Programming</strong> subsection of the applications menu by clicking on the raspberry icon in the <span class="No-Break">top-left corner.</span></p>
			<p>Now, let’s look at the most common way I use the Raspberry <span class="No-Break">Pi: remotely.</span></p>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor309"/>Connecting remotely to the Pi</h1>
			<p>While it’s quite common to see the Raspberry Pi<a id="_idIndexMarker1063"/> used as a PC in educational settings, it’s more likely that we’ll want to use it as a server of some sort, and therefore connect to it remotely, rather than set it up with its own monitor, mouse and<a id="_idIndexMarker1064"/> keyboard. This is called <strong class="bold">headless</strong> mode, and it’s what we’re going to look <span class="No-Break">at next.</span></p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor310"/>Working with a headless Pi</h2>
			<p>To use a headless Pi, we’ll need<a id="_idIndexMarker1065"/> to set it up so that we have a way of connecting it to the network and accessing it remotely. We’re going to configure a new Pi (or just rebuild the old one) to access a wireless network, and we’re going to use SSH for access, which we saw in <a href="B17600_14.xhtml#_idTextAnchor280"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, <em class="italic">PowerShell 7 for Linux and macOS</em>. We can set up both of these things with the Raspberry Pi Imager tool on the Pi website at <a href="https://www.raspberrypi.com/software/">https://www.raspberrypi.com/software/</a>. Note that a lot of documentation on the internet suggests that we might want to create and edit a file called <strong class="source-inline">wpa_supplicant.conf</strong>. This is true for older versions of Raspberry Pi OS and Raspbian, but recent versions won’t <span class="No-Break">use it.</span></p>
			<p>Download the appropriate version of the installer for the OS we are going to run it from – in my case, Windows – and <span class="No-Break">install it.</span></p>
			<p>When we run it, we may experience an OpenGL error if we haven’t kept our graphics drivers up to date, so make sure that the latest drivers <span class="No-Break">are installed.</span></p>
			<p>We will also need a microSD card ready to <span class="No-Break">be imaged.</span></p>
			<p>When we open the imager tool, we’ll be asked what device we want to install on, what OS we want, and what storage we are going to use, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer273" class="IMG---Figure">
					<img src="image/B17600_15_5.jpg" alt="Figure 15.5 – The Raspberry Pi Imager tool"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.5 – The Raspberry Pi Imager tool</p>
			<p>In my case, I’m installing<a id="_idIndexMarker1066"/> on a Raspberry Pi 4, I want the latest 64-bit OS, and I would like the image to be written to the SDHC card in my laptop. When we click <strong class="bold">NEXT</strong>, we’ll be asked if we’d like to apply OS customization settings. Yes. Yes, we would. Click <strong class="bold">Edit Settings</strong>; we’ll see the <strong class="bold">OS Customisation</strong> dialog box open on the <strong class="bold">GENERAL</strong> tab, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer274" class="IMG---Figure">
					<img src="image/B17600_15_6.jpg" alt="Figure 15.6 – Customizing our Raspberry Pi OS"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.6 – Customizing our Raspberry Pi OS</p>
			<p>In the preceding screenshot, I have set<a id="_idIndexMarker1067"/> my hostname, the username and password I want to use on the Pi, and, most importantly, I’ve configured the wireless LAN settings to automatically connect to the Wi-Fi network I want to use, <strong class="source-inline">ShedWifi</strong>, which is the Wi-Fi network in my shed. Now, we need to switch to the <strong class="bold">SERVICES</strong> tab to enable SSH. By default, when we click on <strong class="bold">Enable SSH</strong>, it will select <strong class="bold">Use password authentication</strong>. I’m sticking with that, but we could configure it to <strong class="bold">Allow public-key authentication only</strong>. If we click <strong class="bold">Save</strong>, we will be warned that all the data on our destination SDHC card will be overwritten and asked to confirm this. Once we do, after a few minutes, we’ll get a <strong class="bold">Write Successful</strong> popup telling us that we can remove the SDHC card. Let’s do just that – put it in the Pi and power it up. The <strong class="bold">SERVICES</strong> tab is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer275" class="IMG---Figure">
					<img src="image/B17600_15_7.jpg" alt="Figure 15.7 – The Raspberry Pi Imager SERVICES tab"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.7 – The Raspberry Pi Imager SERVICES tab</p>
			<p>Once the Pi has booted up, we should<a id="_idIndexMarker1068"/> be able to see it on the network if our client is on the same subnet. To test this, in a PowerShell session on our client, type <span class="No-Break">the following:</span></p>
			<pre class="console">
Test-NetConnection &lt;pi hostname&gt; -InformationLevel Detailed</pre>			<p>We should see the IPv6 and IPv4 addresses, as well as a lot of <span class="No-Break">other information:</span></p>
			<div>
				<div id="_idContainer276" class="IMG---Figure">
					<img src="image/B17600_15_8.jpg" alt="Figure 15.8 – Confirming the presence of my Pi"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.8 – Confirming the presence of my Pi</p>
			<p>As we can see, my Pi has got its IP<a id="_idIndexMarker1069"/> addresses, as expected, and I can now connect <span class="No-Break">to it.</span></p>
			<p>Let’s try <span class="No-Break">it out.</span></p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor311"/>Connecting to the Pi with PowerShell</h2>
			<p>In the PowerShell session<a id="_idIndexMarker1070"/> on the client, type<a id="_idIndexMarker1071"/> <span class="No-Break">the following:</span></p>
			<pre class="console">
ssh &lt;pi hostname&gt;</pre>			<p>Alternatively, you can type the following if your usernames are different on the client and <span class="No-Break">the host:</span></p>
			<pre class="console">
Ssh &lt;username&gt;@&lt;hostname&gt;</pre>			<p>The following screenshot shows what the process <span class="No-Break">looks like:</span></p>
			<div>
				<div id="_idContainer277" class="IMG---Figure">
					<img src="image/B17600_15_9.jpg" alt="Figure 15.9 – Using SSH to connect to the Pi"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.9 – Using SSH to connect to the Pi</p>
			<p>On line 1, we started an SSH session to the Pi with the <strong class="source-inline">ssh </strong><span class="No-Break"><strong class="source-inline">poshpi</strong></span><span class="No-Break"> command.</span></p>
			<p>On line 2, we were prompted to agree to connect since the authenticity of the Pi can’t be determined. We’re probably OK to type <strong class="source-inline">yes</strong> here; note that typing <strong class="source-inline">Y</strong> on its own <span class="No-Break">won’t work.</span></p>
			<p>On line 3, we’re asked to input the password for the user – in my case, this <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">nickp</strong></span><span class="No-Break">.</span></p>
			<p>On line 4, we’re presented with the bash prompt from the Pi – that is, <span class="No-Break"><strong class="source-inline">nickp@poshpi.local:~ $</strong></span><span class="No-Break">.</span></p>
			<p>Now, we need to install PowerShell. We can<a id="_idIndexMarker1072"/> do that in the same way<a id="_idIndexMarker1073"/> we did it earlier – that is, by copying the contents of the Microsoft script into the command line or creating a bash script with it in nano. Once it’s finished, we can start PowerShell with the <span class="No-Break">following command:</span></p>
			<pre class="console">
~/powershell/pwsh</pre>			<p>Alternatively, we<a id="_idIndexMarker1074"/> can create a <strong class="bold">symbolic link</strong> (<strong class="bold">symlink</strong>), <span class="No-Break">like this:</span></p>
			<pre class="console">
sudo ln -s ~/powershell/pwsh /usr/bin/pwsh</pre>			<p>Then, all we need to type in the future is <strong class="source-inline">pwsh</strong>, <span class="No-Break">like so:</span></p>
			<div>
				<div id="_idContainer278" class="IMG---Figure">
					<img src="image/B17600_15_10.jpg" alt="Figure 15.10 – Setting up a symlink to run PowerShell"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.10 – Setting up a symlink to run PowerShell</p>
			<p>On line 1, we created a symlink, while on line 2, we <span class="No-Break">started PowerShell.</span></p>
			<p>On line 3, we’re running PowerShell on Linux via the <strong class="source-inline">PS /home/nickp&gt;</strong> prompt; we can call the <strong class="source-inline">$PSVersionTable</strong> variable to see what version of PowerShell <span class="No-Break">we’re running.</span></p>
			<p>Finally, on line 4, we used <em class="italic">Ctrl</em> + <em class="italic">Break</em> to drop out of the SSH session and go back to the PowerShell session running on the Windows client – <strong class="source-inline">PS C:\users\nickp&gt;</strong> – on line 5. We can also use <em class="italic">Ctrl </em>+ <em class="italic">D</em> to log out of <span class="No-Break">the session.</span></p>
			<p>Great! Let’s look at another<a id="_idIndexMarker1075"/> way to connect<a id="_idIndexMarker1076"/> to our headless Pi: with <span class="No-Break">VS Code.</span></p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor312"/>Connecting to the Pi with VS Code</h2>
			<p>This method will work with any machine<a id="_idIndexMarker1077"/> we want to connect<a id="_idIndexMarker1078"/> to with SSH, including Linux. We’re going to<a id="_idIndexMarker1079"/> use a VS Code extension called <strong class="bold">Remote - SSH</strong>. Open VS Code on the client, click the extensions icon on the left sidebar (this looks like a stack of boxes), then type <strong class="source-inline">Remote-SSH</strong> in the search bar, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer279" class="IMG---Figure">
					<img src="image/B17600_15_11.jpg" alt="Figure 15.11 – Installing the Remote – SSH extension"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.11 – Installing the Remote – SSH extension</p>
			<p>Once you’ve found the extension, click on it, then click <strong class="bold">Install</strong> in the center pane, as shown in the <span class="No-Break">preceding screenshot.</span></p>
			<p>Once we’ve done this, we’ve have a desktop icon in the left-hand sidebar. We can click on that to open the <strong class="bold">Remote Explorer</strong> window and set up an SSH connection to the Pi. We’ll be asked to choose what sort of remote we want – a remote machine or a WSL target. We want a remote<a id="_idIndexMarker1080"/> machine, so select that, and then<a id="_idIndexMarker1081"/> click <span class="No-Break">on </span><span class="No-Break"><strong class="bold">SSH</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer280" class="IMG---Figure">
					<img src="image/B17600_15_12.jpg" alt="Figure 15.12 – Selecting SSH"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.12 – Selecting SSH</p>
			<p>Click on the <strong class="bold">+</strong> icon on the right-hand side, then enter <strong class="source-inline">ssh &lt;username&gt;@&lt;hostname&gt;</strong>. In my case, I typed the following and <span class="No-Break">pressed </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">:</span></p>
			<pre class="console">
ssh nickp@poshpi</pre>			<p>Next, we’ll be asked to choose an SSH config file to update. I’m updating my personal file, <strong class="source-inline">C:\Users\nickp\.ssh\config</strong>. Then, we’ll see a message box telling us <strong class="bold">Host added!</strong>. In the <strong class="bold">REMOTE EXPLORER</strong> area, click the refresh icon next to <strong class="bold">REMOTES (TUNNELS/SSH)</strong>, as highlighted in green in <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.13</em>; we should see our new host appear in the <strong class="bold">SSH</strong> subsection with two icons next to it – one to open the host in the existing window, which is depicted with an arrow, and another to open in a new window, as highlighted in red. Click the <em class="italic">Connect in a New </em><span class="No-Break"><em class="italic">Window</em></span><span class="No-Break"> icon:</span></p>
			<div>
				<div id="_idContainer281" class="IMG---Figure">
					<img src="image/B17600_15_13.jpg" alt="Figure 15.13 – Opening a connection to the Pi"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.13 – Opening a connection to the Pi</p>
			<p>Next, we’ll be asked to select the platform of the remote host; it’s Linux. We’ll also need to enter the password. Once we’ve done that, we’ll need to wait a minute or two while everything gets set up and dismiss a message window or two. Finally, we’ll have a new window connected to our Pi; we know this because in the bottom-left corner is a box saying <strong class="bold">SSH: &lt;hostname&gt;</strong>. Everything we do in this window is happening on the Pi. Cool, eh? This means that instead of writing our scripts on our client and transferring them to the Pi, we can write them directly to the Pi from <span class="No-Break">VS Code.</span></p>
			<p>So, that’s us ready to go. We can<a id="_idIndexMarker1082"/> use PowerShell<a id="_idIndexMarker1083"/> in the same way we’ve been doing throughout this book on the Pi, but that’s not really what I use the Raspberry Pi for. Next, we’ll look at how we can use PowerShell on <span class="No-Break">the Pi.</span></p>
			<h1 id="_idParaDest-308"><a id="_idTextAnchor313"/>Running PowerShell on Raspberry Pi OS</h1>
			<p>The beauty of the Raspberry Pi<a id="_idIndexMarker1084"/> is just how many ways you can connect <a id="_idIndexMarker1085"/>it to the outside world, from joystick controllers to cameras to sensors to motors to… ooh… <em class="italic">everything</em>. In this chapter, we’re going to look at using GPIO pins to make an LED blink, but first, we need to learn how we can interact with the GPIO. There are two options, neither of them particularly well supported. The better option is to install a new OS: Windows 10 IoT Core. That would take a chapter or two in itself, and it doesn’t really address the topic of running PowerShell on Raspberry Pi OS. The other way is to use the PowerShell IoT module. This hasn’t been updated since about 2020 and doesn’t appear to work with later versions of the Pi 4B, but it works reasonably well on older ones, and we can live in hope<a id="_idIndexMarker1086"/> that it will be updated<a id="_idIndexMarker1087"/> at some point. I’m going to take advantage of a Pi 3B I’ve got in <span class="No-Break">my drawer.</span></p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor314"/>Installing the IoT module</h2>
			<p>We’re working with hardware<a id="_idIndexMarker1088"/> here, so we need to start PowerShell with root privileges by typing <span class="No-Break">the following:</span></p>
			<pre class="console">
sudo pwsh</pre>			<p>Once we’re in PowerShell, we can install the module as we <span class="No-Break">usually do:</span></p>
			<pre class="console">
Install-Module Microsoft.powershell.iot</pre>			<p>Finally, we’ll probably want to clone the repository from GitHub so that we have access to the examples. We can do this with the <span class="No-Break">following command:</span></p>
			<pre class="console">
git clone https://github.com/PowerShell/PowerShell-IoT.git</pre>			<p>This will install all the code in the GitHub repository into a new folder below our <span class="No-Break">chosen folder:</span></p>
			<div>
				<div id="_idContainer282" class="IMG---Figure">
					<img src="image/B17600_15_14.jpg" alt="Figure 15.14 – Installing the PowerShell IoT module and cloning the GitHub repository"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.14 – Installing the PowerShell IoT module and cloning the GitHub repository</p>
			<p>This gives us access to all the example modules in the <strong class="source-inline">Examples</strong> folder. This includes some interesting tools that we can use with various sensors, such as the BME280 <span class="No-Break">environmental sensor.</span></p>
			<p>The next step is to import the module and check that <span class="No-Break">it’s working:</span></p>
			<pre class="console">
Import-Module Microsoft.PowerShell.IoT
Get-GpioPin 15</pre>			<p>And with a bit of luck, we’ll see something<a id="_idIndexMarker1089"/> similar to <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer283" class="IMG---Figure">
					<img src="image/B17600_15_15.jpg" alt="Figure 15.15 – Importing the module and checking the voltage on a given GPIO pin"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.15 – Importing the module and checking the voltage on a given GPIO pin</p>
			<p>Shall we explore the cmdlets we get in <span class="No-Break">this module?</span></p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor315"/>Exploring the IoT module</h2>
			<p>Inside the IoT module, there are six cmdlets<a id="_idIndexMarker1090"/> for working with the three I/O interfaces<a id="_idIndexMarker1091"/> on the Pi: simple GPIO, I2C, and <strong class="bold">Synchronous Peripheral Interface</strong> (<strong class="bold">SPI</strong>). Confusingly, all three interfaces use the GPIO pins. This can sometimes make it difficult to choose which pins we wish to use for <span class="No-Break">what purpose:</span></p>
			<ul>
				<li>Simple GPIO reads or sets the voltage on a specific GPIO pin with a pair of cmdlets called <strong class="source-inline">Get-GpioPin</strong> and <strong class="source-inline">Set-GpioPin</strong>. We’ll be using <span class="No-Break">this shortly.</span></li>
				<li>I2C uses the <strong class="bold">Inter-Integrated Circuit</strong> (<strong class="bold">I2C</strong>) protocol developed by Philips, which allows<a id="_idIndexMarker1092"/> our Pi (the controller) to communicate with multiple peripheral devices. Because we can have multiple devices, as well as <strong class="source-inline">Get-I2CRegister</strong> and <strong class="source-inline">Set-I2CRegister</strong>, there is also a <span class="No-Break"><strong class="source-inline">Get-I2CDevice</strong></span><span class="No-Break"> cmdlet.</span></li>
				<li>Finally, there is the SPI. This is quite complex, and we’re not going to cover it in this book. There is only one <span class="No-Break">cmdlet: </span><span class="No-Break"><strong class="source-inline">Send-SPIData</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Let’s take a closer look at the five cmdlets we’re going to use the most. The helpfiles for these cmdlets can be found in the <strong class="source-inline">/home/&lt;username&gt;/PowerShell-IoT/docs/help/</strong> folder, but let’s cover their basic <span class="No-Break">uses</span><span class="No-Break"> here:</span></p>
			<ul>
				<li><strong class="source-inline">Get-GpioPin</strong>: This cmdlet gets the voltage from a specified GPIO pin. There are <span class="No-Break">three parameters:</span><ul><li><strong class="source-inline">-Id</strong>, which takes an Int32 value and specifies which GPIO pin we want to <span class="No-Break">look at.</span></li><li><strong class="source-inline">-PullMode</strong>, which may be set to <strong class="source-inline">Off</strong>, <strong class="source-inline">PullDown</strong>, or <strong class="source-inline">PullUp</strong>, and may be needed with some chipsets, but not the Pi. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Null</strong></span><span class="No-Break">.</span></li><li>A <strong class="source-inline">-Raw</strong> switch, which returns a value of <strong class="source-inline">High</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">Low</strong></span><span class="No-Break">.</span></li></ul></li>
				<li><strong class="source-inline">Set-GpioPin</strong>: This cmdlet sets the voltage<a id="_idIndexMarker1093"/> on a specified pin to <strong class="source-inline">High</strong> or <strong class="source-inline">Low</strong>. It has <span class="No-Break">three parameters:</span><ul><li><strong class="source-inline">-Id</strong>, which takes an <strong class="source-inline">Int32</strong> value and specifies <span class="No-Break">the pin.</span></li><li><strong class="source-inline">-Value</strong>, which takes either <strong class="source-inline">High</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">Low</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">-PassThru</strong>, which, by default, results in the cmdlet returning nothing. If we want it to return a PowerShell object confirming that the value was set, then we can use <span class="No-Break">this parameter.</span></li></ul></li>
				<li><strong class="source-inline">Get-I2CDevice</strong>: This cmdlet creates an I2C device object with a friendly name that we can then use with the <strong class="source-inline">*-I2Cregister</strong> cmdlets. It has <span class="No-Break">two parameters:</span><ul><li><strong class="source-inline">-Id</strong>, which takes an <strong class="source-inline">Int32</strong> value and specifies the address of <span class="No-Break">the device</span></li><li><strong class="source-inline">-FriendlyName</strong>, which we use to assign a string to <span class="No-Break">the device</span></li></ul></li>
				<li><strong class="source-inline">Get-I2Cregister</strong>: This cmdlet gets the value held in a register on a particular device. There are <span class="No-Break">four parameters:</span><ul><li><strong class="source-inline">-Device</strong>, which takes an I2C <span class="No-Break">device object</span></li><li><strong class="source-inline">-Register</strong>, which takes a <strong class="source-inline">Uint16</strong> value that specifies the register on the device we want <span class="No-Break">to read</span></li><li><strong class="source-inline">-Raw</strong>, which returns the value stored in the register, rather than an <span class="No-Break"><strong class="source-inline">I2CdeviceRegisterData</strong></span><span class="No-Break"> object</span></li><li><strong class="source-inline">-Bytecount</strong>, which takes a byte value and specifies the number of bytes expected in <span class="No-Break">the data</span></li></ul></li>
				<li><strong class="source-inline">Set-I2Cregister</strong>: This cmdlet sets the register value on a device. There are <span class="No-Break">four parameters:</span><ul><li><strong class="source-inline">-Device</strong>, which takes an I2C <span class="No-Break">device object.</span></li><li><strong class="source-inline">-Register</strong>, which takes a <strong class="source-inline">Uint16</strong> value that specifies the register on the device we want <span class="No-Break">to set.</span></li><li><strong class="source-inline">-Data</strong>, a value in bytes to be written to <span class="No-Break">the register.</span></li><li><strong class="source-inline">-PassThru</strong>, which, by default, results in the cmdlet returning nothing. If we want it to return a PowerShell object confirming that the value was set, then we can use <span class="No-Break">this parameter.</span></li></ul></li>
			</ul>
			<p>And that’s it. The best way to see how they work<a id="_idIndexMarker1094"/> is to get on and play <span class="No-Break">with them.</span></p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor316"/>Simple physical computing</h1>
			<p>Physical computing on the Raspberry Pi<a id="_idIndexMarker1095"/> uses the GPIO pins on the right of the board, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer284" class="IMG---Figure">
					<img src="image/B17600_15_16.jpg" alt="Figure 15.16 – The GPIO pins of the Raspberry Pi"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.16 – The GPIO pins of the Raspberry Pi</p>
			<p>The important things to remember<a id="_idIndexMarker1096"/> are that the ground pins are negative and the voltage pins, 3V3 and 5V, are positive and always on. While the GPIO pins may have secondary specialist purposes, they are the ones we can turn on and off – they will deliver a <span class="No-Break">positive current.</span></p>
			<p>When we’re learning a new programming language, we start with the simplest possible program – <span class="No-Break"><em class="italic">Hello World</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Write-Output "Hello World"</pre>			<p>In Python, we can write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
print("Hello World")</pre>			<p>Physical computing is slightly different – we write a program to make an LED blink on and off. It doesn’t seem to matter what the platform is; this is where we start. For instance, the program to get an Arduino to blink an LED is written in C and looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
void setup() {
    pinMode(LED_BUILTIN, OUTPUT);
}
void loop() {
  digitalWrite(LED_BUILTIN, HIGH);
  delay(1000);
  digitalWrite(LED_BUILTIN, LOW);
  delay(1000);
}</pre>			<p><strong class="source-inline">v</strong><strong class="source-inline">oid setup()</strong> initializes the onboard LED<a id="_idIndexMarker1097"/> as an output and runs once each time the Arduino is reset. The <strong class="source-inline">void loop()</strong> command sets up a loop that runs continuously while the Arduino is switched on (<strong class="source-inline">void</strong> just tells the Arduino not to produce an output). The <strong class="source-inline">digitalwrite()</strong> commands set the voltage to the output as <strong class="source-inline">HIGH</strong> (on) or <strong class="source-inline">LOW</strong> (off). This looks pretty similar on the Raspberry Pi <span class="No-Break">in Python:</span></p>
			<pre class="source-code">
From RPi.gpio import LED
Red_led = LED(17)
Red_led.blink(on_time=1, off_time=1)</pre>			<p>Let’s try it in PowerShell. First, we’ll need to set up our hardware according to the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer285" class="IMG---Figure">
					<img src="image/B17600_15_17.jpg" alt="Figure 15.17 – How to set up the components"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.17 – How to set up the components</p>
			<p>The LED will have two legs on it, one longer than the other. The longer leg needs to be connected to the positive side of the circuit, and the shorter leg needs to be on the negative or ground side. The current the Pi <a id="_idIndexMarker1098"/>sends is too high for the LED, so we need to use a resistor of around 300-400 Ohms to drop it slightly. More than 1K Ohms will possibly stop the LED from lighting, and less than 200 risks burning it out, if it’s cheap. The breadboard sockets are connected in columns of five, so the resistor spans two <span class="No-Break">columns here.</span></p>
			<p>Now, we need to write some PowerShell code to turn the LED on and off. Let’s connect to the Pi using VS Code SSH remoting and open a new document. Call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">blink.ps1</strong></span><span class="No-Break">.</span></p>
			<p>Let’s start by importing the <span class="No-Break">IoT module:</span></p>
			<pre class="console">
Import-Module Microsoft.PowerShell.IoT</pre>			<p>Now, we’re going to need a loop that <span class="No-Break">always runs:</span></p>
			<pre class="source-code">
While ($true) {
}</pre>			<p>In this loop, we’re going to need<a id="_idIndexMarker1099"/> to turn the LED on and off using <strong class="source-inline">Set-GpioPin</strong>. If you followed the preceding diagram, you should be using <span class="No-Break">pin 17.</span></p>
			<p>We’ll also need to use <strong class="source-inline">Start-Sleep</strong> to wait between each command; otherwise, we’ll blow the <span class="No-Break">LED up:</span></p>
			<pre class="source-code">
Import-Module Microsoft.PowerShell.IoT
while ($true) {
    Set-GpioPin -Id 17 -Value "High"
    Write-Host "LED on"
    Start-Sleep 1
    Set-GpioPin -Id 17 -Value "Low"
    Write-Host "LED off"
    Start-Sleep 1
}</pre>			<p>I’ve added a couple of output lines here so that I can reasonably demonstrate this without using a YouTube link. Running it looks like this in <span class="No-Break">VS Code:</span></p>
			<div>
				<div id="_idContainer286" class="IMG---Figure">
					<img src="image/B17600_15_18.jpg" alt="Figure 15.18 – Blinkin’ LEDs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.18 – Blinkin’ LEDs</p>
			<p>As we can see, the LED’s state changes once a second; this will continue until the script is stopped manually. We can see how it compares to the programs we saw for the Arduino, in C, and the <span class="No-Break">Python program.</span></p>
			<p>There’s also an example LED module in the <strong class="source-inline">Examples</strong> folder – it’s well worth taking a look to see how they’ve done<a id="_idIndexMarker1100"/> it <span class="No-Break">in there.</span></p>
			<p>That about wraps it up for this chapter. Let’s summarize what <span class="No-Break">we’ve learned.</span></p>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor317"/>Summary</h1>
			<p>We started this chapter by taking a quick look at the Raspberry Pi, including what it does, what it was designed to do, and how people use it. We looked at the different series; the main B series single board computers, the Zero mini version, and the Pico single chip board. We learned that we can only install PowerShell on the B series since the architecture of the chip is wrong on the Zero and <span class="No-Break">Pico series.</span></p>
			<p>Next, we looked at different ways of installing PowerShell on the Pi using a script provided by Microsoft. Then, we saw how easy it is to install VS Code on the Pi since it is included in the official Raspberry <span class="No-Break">Pi repositories.</span></p>
			<p>While there are Raspberry Pi models that are suitable as desktop PC replacements, most people will use the Raspberry Pi without a screen or mouse – that is, in headless mode. We looked at how to set up a Raspberry Pi in headless mode, and then how to connect to it from PowerShell with SSH, before going on to look at a convenient way to work directly on the Pi with <span class="No-Break">VS Code.</span></p>
			<p>Then, we discussed one of the most popular use cases for the Pi: physical computing. This is where we interact with sensors and objects in the physical world. We looked at the Microsoft module for interacting with the GPIO on the Raspberry Pi and finished up with a script that can be used to make an LED blink on <span class="No-Break">and off.</span></p>
			<p>That’s it for the environments we’re going to look at. In the next and final chapter, we’re going to look at how we can access the .NET system that PowerShell is built on and look at what our next steps <span class="No-Break">could be.</span></p>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor318"/>Questions</h1>
			<ol>
				<li>Why can’t we install PowerShell on the Raspberry Pi Zero <span class="No-Break">or Pico?</span></li>
				<li>Where is the SSH configuration stored for VS Code on a <span class="No-Break">Windows machine?</span></li>
				<li>What is the PowerShell cmdlet for testing network connectivity to another device from the <span class="No-Break">Raspberry Pi?</span></li>
				<li>How do you create an SSH connection to a headless Pi <span class="No-Break">from PowerShell?</span></li>
				<li>We’ve saved our install script as <strong class="source-inline">Install.sh</strong>. How do we <span class="No-Break">run it?</span></li>
				<li>Why might we want to create a symlink to the <span class="No-Break"><strong class="source-inline">pwsh</strong></span><span class="No-Break"> executable?</span></li>
				<li>How might we create a symlink <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">pwsh</strong></span><span class="No-Break">?</span></li>
				<li>How would we get a value of <strong class="source-inline">High</strong> or <strong class="source-inline">Low</strong> from a <span class="No-Break">GPIO pin?</span></li>
				<li>What sort of OS is Raspberry <span class="No-Break">Pi OS?</span></li>
			</ol>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor319"/>Further reading</h1>
			<ul>
				<li>OctaPi cluster <span class="No-Break">computer: </span><a href="https://projects.Raspberrypi.org/en/projects/build-an-octapi"><span class="No-Break">https://projects.Raspberrypi.org/en/projects/build-an-octapi</span></a></li>
				<li>Oracle’s 1050-node Pi <span class="No-Break">supercomputer: </span><a href="https://blogs.oracle.com/developers/post/building-the-worlds-largest-Raspberry-pi-cluster"><span class="No-Break">https://blogs.oracle.com/developers/post/building-the-worlds-largest-Raspberry-pi-cluster</span></a></li>
				<li>Community support for PowerShell on <span class="No-Break">Linux: </span><a href="https://learn.microsoft.com/en-us/powershell/scripting/install/community-support"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/install/community-support</span></a></li>
				<li>PowerShell on ARM <span class="No-Break">processors: </span><a href="https://learn.microsoft.com/en-us/powershell/scripting/install/powershell-on-arm"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/install/powershell-on-arm</span></a></li>
				<li>VS Code on the <span class="No-Break">Pi: </span><a href="https://code.visualstudio.com/docs/setup/raspberry-pi"><span class="No-Break">https://code.visualstudio.com/docs/setup/raspberry-pi</span></a></li>
				<li>VS Code remote <span class="No-Break">SSH: </span><a href="https://code.visualstudio.com/docs/remote/ssh-tutorial"><span class="No-Break">https://code.visualstudio.com/docs/remote/ssh-tutorial</span></a></li>
				<li>PowerShell IoT module on <span class="No-Break">GitHub: </span><a href="https://github.com/PowerShell/PowerShell-IoT"><span class="No-Break">https://github.com/PowerShell/PowerShell-IoT</span></a></li>
				<li>An overview of Windows for <span class="No-Break">IoT: </span><a href="https://learn.microsoft.com/en-us/windows/iot/product-family/windows-iot"><span class="No-Break">https://learn.microsoft.com/en-us/windows/iot/product-family/windows-iot</span></a></li>
				<li>Windows 10 IoT Core on <span class="No-Break">Raspberry Pi:</span><ul><li><a href="https://cdn-learn.adafruit.com/downloads/pdf/getting-started-with-windows-iot-on-raspberry-pi.pdf"><span class="No-Break">https://cdn-learn.adafruit.com/downloads/pdf/getting-started-with-windows-iot-on-raspberry-pi.pdf</span></a></li><li><a href="https://devblogs.microsoft.com/premier-developer/getting-started-with-windows-10-iot-core-raspberry-pi-3b/"><span class="No-Break">https://devblogs.microsoft.com/premier-developer/getting-started-with-windows-10-iot-core-raspberry-pi-3b/</span></a></li></ul></li>
				<li>Raspberry Pi Configuration <span class="No-Break">documentation: </span><a href="https://www.raspberrypi.com/documentation/computers/configuration.html"><span class="No-Break">https://www.raspberrypi.com/documentation/computers/configuration.html</span></a></li>
				<li><span class="No-Break">I2C overview:</span><ul><li><a href="https://en.wikipedia.org/wiki/I%C2%B2C"><span class="No-Break">https://en.wikipedia.org/wiki/I%C2%B2C</span></a></li><li><a href="https://learn.sparkfun.com/tutorials/i2c/all"><span class="No-Break">https://learn.sparkfun.com/tutorials/i2c/all</span></a></li></ul></li>
				<li>SPI <span class="No-Break">overview: </span><a href="https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all"><span class="No-Break">https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all</span></a></li>
			</ul>
		</div>
	</body></html>