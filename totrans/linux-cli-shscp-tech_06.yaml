- en: '*Chapter 6*: Shell-Based Software Management'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copying content over a network is usually done as a manual process – for example,
    we just use `scp` or `FTP` to transfer a file and that's that. But what happens
    if we need to make this process a permanent one? We then need to figure out a
    way to perform file/directory synchronization, which is what `rsync` is all about.
    That being said, with all of the security-related incidents in the past 5+ years,
    it's always a good idea to implement some kind of encryption, so using `ssh` and
    `scp` seems like a reasonable approach. And that's exactly what we are going to
    do.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `dnf` and `apt` for package management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using additional repositories, streams, and profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling third-party software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For these recipes, we're going to use two Linux machines – we can use the `cli1`
    and `cli2` virtual machines from our previous recipes. These recipes are doable
    both on CentOS and/or Ubuntu, so there is no reason to use separate virtual machines
    for these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's start our virtual machines, and let's get cracking!
  prefs: []
  type: TYPE_NORMAL
- en: Using dnf and apt for package management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packages and package groups are different ways of deploying software to our
    CentOS and Ubuntu virtual machines. A package is nothing more than a stack of
    files that can be installed on our machine in an automated fashion, without our
    manual input. Package groups are more of a RedHat/CentOS concept. Just like the
    term suggests, they are a way of grouping packages into larger groups so that
    we can use these groups to install multiple packages without manually specifying
    every single package from the group. Let's learn how to use them to our benefit,
    specifically, for deployment purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's continue using our `cli1` and `cli2` machines for this one, so make sure
    that they're powered on and ready to go. We are going to use `cli1` for the `apt`
    part of this recipe, and `cli2` for the `yum/dnf` part, as `cli1` is Ubuntu-based
    and `cli2` is CentOS-based.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the basics of `yum` and `dnf` for CentOS on cli2\. Let''s
    list all the available packages on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like this (abbreviated):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Shortened yum list output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.1_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Shortened yum list output
  prefs: []
  type: TYPE_NORMAL
- en: We've shortened this screenshot in *Figure 6.1* as it contains thousands of
    packages. There are three columns in this output. Going from left to right, the
    first column is the package name, the second column is the package version, and
    the third one is the package repository where that specific package is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to find out more details about a package, we can use `yum info`
    (or `dnf info`), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Getting information regarding a package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.2_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Getting information regarding a package
  prefs: []
  type: TYPE_NORMAL
- en: By using this command, we get much more information about the package. Also,
    please note that we didn't use `x86_64` in the package name, as it's not necessary.
    Bearing in mind the fact that we're using a 64-bit distribution, it becomes understandable
    that using *architecture* in the package name is almost always unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now install a package, for example, `mc` (Midnight Commander):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Installing a package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.3_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Installing a package
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of Linux package systems is evident here. It's not only about the
    fact that a package gets installed without hassle – dependencies get installed
    by default, as well, and that's really useful. Back in the days when we only had
    the `rpm` command to install packages in CentOS, it was much more difficult to
    resolve dependencies. We had to deploy them before deploying the package that
    we wanted to deploy, and in a specific order, which complicated the deployment
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can remove that package by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to find which package installed a specific file, we can use the
    `yum provides` or `dnf provides` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Checking which package installed a specific file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.4_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Checking which package installed a specific file
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to find package dependencies (which package depends on which package),
    we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Checking package dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.5_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Checking package dependencies
  prefs: []
  type: TYPE_NORMAL
- en: We used `bash` in this example, but we could have used any package name for
    this query.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `dnf` and `yum` to download and install packages locally. Let''s
    say that we want to download and install the `joe` editor locally. This is how
    we''d do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Downloading and installing a package manually from a local disk'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.6_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – Downloading and installing a package manually from a local disk
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, of course, search for packages by using the `yum search` or `dnf search`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Using the yum/dnf search command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.7_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Using the yum/dnf search command
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the list of these packages is going to be quite long, so additional
    filtering might be required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now talk a bit about package groups, starting with the `dnf grouplist`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Using dnf group list commands gives us a list of package groups'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.8_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – Using dnf group list commands gives us a list of package groups
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of that command is going to give us the names of **package groups**
    that we can use for much *larger* package deployments. For example, let''s check
    what''s going to happen if we install the **Development Tools** package group
    by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will ask us whether we want to download and deploy more than 100
    packages. If we answer *yes*, that''s exactly what''s going to happen (the screenshot
    is rendered smaller on purpose, just to show the end of the command output):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Installing a package group'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.9_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – Installing a package group
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, having the ability to deploy package groups greatly increases
    the speed of package deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step in our process is to cover everything that we''ve covered in
    this recipe, but to deliver it on Ubuntu. So, let''s switch to our `cli1` machine
    and start from scratch. First, let''s describe a couple of commands that we''re
    interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apt-get` or `apt`: Commands used to install, remove, upgrade, and update packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apt-cache`: Mostly used to search and find information about packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now learn to use them. First, we are going to discuss regular operations
    – installing, removing, purging, updating, and upgrading. Let''s install a package,
    for example, `mc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Using apt-get to install a package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.10_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – Using apt-get to install a package
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s remove it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Using apt-get to remove a package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.11_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – Using apt-get to remove a package
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that we have a standard situation – the package *was* removed, but
    some of its dependencies weren''t. We can do that, as well, by using the `apt-get
    autoremove` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Removing packages that are no longer needed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.12_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.12 – Removing packages that are no longer needed
  prefs: []
  type: TYPE_NORMAL
- en: This is very useful as we're reducing the attack surface of our server (for
    security breaches) by removing unnecessary software packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s check what happens if we use the `update` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Updating repository and package info'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.13_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.13 – Updating repository and package info
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, `apt` refreshed its package list before the upgrade process
    could happen – these steps are mostly used in sequence – `update` followed by
    `upgrade`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Upgrading available packages – this time, no upgrades are necessary'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.14_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.14 – Upgrading available packages – this time, no upgrades are necessary
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly enough, no packages were installed, which is a very rare situation,
    to be honest. Usually, we'd have at least a few packages to be upgraded.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the topic of doing dist-upgrade, we are absolutely *NOT*
    recommending this for a production server. Using `dist-upgrade` and `do-release-upgrade`
    is something that we *can* do, but shouldn't. Migration is always a better idea,
    however much time it might take.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now push this situation to the extreme by trying to do `dist-upgrade`,
    followed by `do-release-upgrade`. What the `dist-upgrade apt` option does is simple
    in theory – it tries to prepare our current distribution so that it''s possible
    to upgrade it to the latest one in the branch. At first, it might just be getting
    a couple of new packages. Usually, these packages contain new repositories and
    information about locations, from which `apt` will upgrade our distribution to
    the latest one. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Using dist-upgrade to get information about new distribution
    versions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.15_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – Using dist-upgrade to get information about new distribution versions
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step after that one is to use `do-release-upgrade`, a standalone command
    that''s not an `apt` subcommand. We need to remember that this is not an `apt`
    option (there''s no `apt do-release-upgrade`, it''s just `do-release-upgrade`).
    After executing it, our system is going to ask us whether we want to continue
    with the distribution release upgrade:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Using do-release-upgrade, not to be recommended in production
    environments'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.16_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.16 – Using do-release-upgrade, not to be recommended in production
    environments
  prefs: []
  type: TYPE_NORMAL
- en: 'If we confirm, the process is going to start, and it''s going to take a while.
    The end result should be an Ubuntu machine that''s fully updated to the latest
    version, with all of the latest package versions. Remember, we specifically mentioned
    that this shouldn''t be done in production – it''s just an extreme example of
    using `apt` capabilities to do a system-wide package upgrade. Hundreds, perhaps
    thousands of packages, will get updated if we do something like that, and the
    process isn''t reversible, so it carries a lot of risk. Try it out on some test
    virtual machine just for practice. If successful, this procedure will upgrade
    to the latest Ubuntu version. The end result, at the time of writing, looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – The end result of do-release-upgrade, and in our experience,
    we got lucky this time!'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.17_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.17 – The end result of do-release-upgrade, and in our experience, we
    got lucky this time!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our Ubuntu machine was upgraded to the latest (21.04) version.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few more important `apt` commands – for example, for a package
    search, we can use the `apt-cache showpkg package_name` command. Let''s use it,
    for example, on `mc`, a package we installed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Using apt-get to get package info'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.18_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.18 – Using apt-get to get package info
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a somewhat shorter version of the same thing if we use the `apt` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Using apt to get package info – somewhat shorter and more concise'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.19_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.19 – Using apt to get package info – somewhat shorter and more concise
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to add repositories, we can use the `add-apt-repository` command.
    Let''s say that we want to add an unofficial repository, such as **Personal Package
    Archives** (**PPA**), that is hosted on Launchpad. Generally speaking, we should
    only add *reputable* repositories, and not just *any* repository just because
    it has a certain package that we might need. We are going to use an example here
    – let''s say that we need to install the latest PHP 7.4 version on our Ubuntu
    machine. We can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be the result if we started `php` from the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20 – The end result of us using the ppa repository to deploy the
    latest release of PHP 7.4'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.20_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.20 – The end result of us using the ppa repository to deploy the latest
    release of PHP 7.4
  prefs: []
  type: TYPE_NORMAL
- en: This covers all the necessary commands we need for both Ubuntu and CentOS. Let's
    now explain some background information about where some of the more important
    information is stored – for both CentOS (`dnf`/`yum`) and Ubuntu (`apt`/`apt-get`).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`yum` and `dnf` work in tandem with files located in `/etc/yum.repos.d` repository
    files, as well as the `/etc/yum.conf` configuration file. We covered repository
    files, so let''s now discuss `/etc/yum.conf` and a couple of important configuration
    options that we can use from it. This is a global configuration file for `dnf`
    and `yum` commands.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of really useful configuration items that we can manage
    in it. Let''s just illustrate that point by using two commonly used examples.
    Let''s add these two options to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By using these two commands, we instructed `yum`/`dnf` to exclude all `kernel`
    and `open-vm` packages (by name) in any kind of operation, such as a `yum` update
    (which updates all packages on the machine). `gpgcheck=0` sets a global policy
    that tells `yum` and `dnf` *not* to use GPG key checking when working with packages.
    This can also be managed in `/etc/yum.repos.d`, as discussed in our recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ubuntu has a very similar principle; it''s just that directories are different
    as well as the file structure, somewhat. The most important information regarding
    the software repository location is kept in the /`etc/apt` directory, specifically,
    in the `/etc/apt/sources.list` file. Here''s an excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Main apt configuration file called sources.list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.21_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.21 – Main apt configuration file called sources.list
  prefs: []
  type: TYPE_NORMAL
- en: 'The general structure is simple enough. The second part of our `apt` equation
    is located in the `/etc/apt/sources.list.d` directory. A couple of steps ago,
    we added the PPA repository, and, sure enough, we have a configuration file for
    that repository configuration file there, called `ondrej-ubuntu-php-groovy.list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Additional apt configuration file located at /etc/apt/sources.list.d'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.22_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.22 – Additional apt configuration file located at /etc/apt/sources.list.d
  prefs: []
  type: TYPE_NORMAL
- en: That covers our package and package groups recipe. Let's now move on to the
    next recipe, which is about using modules and module streams.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need more information about networking in CentOS and Ubuntu, make sure
    that you check out the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://access.redhat.com/sites/default/files/attachments/rh_yum_cheatsheet_1214_jcs_print-1.pdf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://fedoraproject.org/wiki/Yum_to_DNF_Cheatsheet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://packagecloud.io/blog/apt-cheat-sheet/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using additional repositories, streams, and profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Repositories are the most important objects/locations to manage as they provide
    us with packages and package groups that we can install on our CentOS machine.
    Let's now learn how to manage repositories by using `yum-config-manager` and `dnf`.
    Also, let's get to know some configuration files that are key for this process.
  prefs: []
  type: TYPE_NORMAL
- en: Adding to the idea of package groups, which group packages into larger groups,
    `dnf` introduced the idea of additional modularity. It's all about package organization
    – we want to have simple ways of deploying software – runtimes, applications,
    bits and pieces of software. These concepts also enable us to have control over
    *versions of software* that we want to install, which is really handy. For example,
    let's say that you need to deploy PHP 7.2 and 7.3 on the machine. Doing that manually
    isn't going to be much fun. As we're going to demonstrate by using an example,
    this is much more easily done if we use a module stream.
  prefs: []
  type: TYPE_NORMAL
- en: Profiles act as quasi-repositories, without actually being repositories, within
    the `httpd` module has a couple of profiles (`minimal`, `devel`, `common`). The
    minimal profile means just the minimum number of packages that need to be installed
    for `httpd` to work. Unlike that, common is a default profile that's ready for
    production and additionally treated in terms of security (hardened).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start the `cli2` virtual machine created in the previous recipes. We're going
    to use it to work with streams and profiles on our CentOS machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To manage repositories, we have to learn to use two commands – `yum-config-manager`
    and `dnf`. Also, we need to look into the `/etc/yum.conf` file, as well as the
    `/etc/yum.repos.d` directory. `Yum.conf` gives us global `yum` command configuration
    options, and the `/etc/yum.repos.d` directory contains configuration files with
    repository locations.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at `yum-config-manager` first. This command was introduced in Red
    Hat Enterprise Linux/CentOS 7 to easily add additional repositories to your Red
    Hat Enterprise Linux or CentOS machine. And it does just that – it lets us skip
    the whole manual repository configuration and get straight to business. If we
    didn't have this command, we would need to learn the configuration file options
    for `/etc/yum.repos.d` directory files.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go to the first virtual machine that we installed (source), and list
    the content of the `/etc/yum.repos.d` directory, this is what we''ll get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – /etc/yum.repos.d directory content'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.23_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.23 – /etc/yum.repos.d directory content
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we want to add a custom repository, `url`, to our machine.
    We can do this in three different ways. The first approach involves using `yum-package-manager`,
    and that tool requires the `yum-utils` package (`url` is the location of the repository
    that we want to use):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also check the list of currently configured repositories by using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to find the list of currently disabled (unused) repositories, we
    can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to enable a disabled repository, we can use the following (`repository_id`
    is a parameter that you can get from the `yum repolist all` command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The most obvious problem with using `yum-config-manager` is the fact that there
    are some parameters that we can't assign via that command itself. This is where
    the manual editing of `/etc/yum.repos.d` configuration files comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command is being phased out little by little and redirected to its new
    `dnf` counterparts (`dnf config-manager`), just like `yum` is being used in parallel
    with the `dnf` command. If we want to do the same job by using `dnf` tools, we
    can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That will create a new configuration file in the `/etc/yum.repos.d` directory
    with the repository definition and enable it by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is going to be to learn a bit about these configuration files,
    as they''re really not all that difficult to understand. Let''s use a repository
    configuration file to explain their concept, for example, `/etc/yum.repos.d/CentOS-Sources.repo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24 – Part of the /etc/yum.repos.d/CentOS-Sources.repo file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.24_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.24 – Part of the /etc/yum.repos.d/CentOS-Sources.repo file
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain these configuration parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[BaseOS-Source]`is the repository ID. This is what we use in `yum-config-manager`
    or `dnf` to reference repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` parameter is a description of that repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `baseurl` parameter describes *where* the location of this repository is,
    and it can use a variety of different options – `http`, `https`, `ftp`, or `file`.
    If we create a *local* repository (mount it somewhere on our CentOS machine),
    then the `file` statement will be used to access it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `gpgcheck` parameter tells `yum/dnf` whether or not to check the `gpg` key
    against the package signatures. If it's `1`, that means that checking is mandatory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `enabled` parameter tells `yum/dnf` whether this repository is enabled,
    which means whether `dnf/yum` can use it to get packages. We can also use `yum
    --enablerepo` to enable a certain defined repository by name, or `yum --disablerepo`
    to do the opposite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `gpgkey` parameter tells `yum/dnf` where the `gpg` key for `gpgcheck` is
    located.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now move on to the idea of streams and profiles, the logical next step
    in our recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we log in to the source machine, let''s use an example to describe what
    streams and profiles are all about. So, let''s use a module stream and profile
    to remove and re-deploy `httpd`. In the first step, we''re going to use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After the process is complete, let''s do the opposite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now check the output of the second command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.25 – Using streams and profiles'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.25_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.25 – Using streams and profiles
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the deployment process automatically defaulted to using the
    `httpd/common` profile and the default stream (**AppStream**) repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do another example. We can check the list of all available modules by
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26 – dnf module list, with versions and profiles; abridged output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.26_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.26 – dnf module list, with versions and profiles; abridged output
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we want to install `container-tools` version 2.0\. We can do
    it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27 – Deploying a specific module version by using the dnf command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.27_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.27 – Deploying a specific module version by using the dnf command
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the result of this action is going to be quite extensive. Sometimes,
    when we deploy a set of packages from modules and streams, our machine is going
    to deploy hundreds of packages. So, be prepared to wait for a bit of time to see
    whether it happens.
  prefs: []
  type: TYPE_NORMAL
- en: In one of our examples, we deployed the `httpd` package by using the default
    profile and stream. Every one of these streams can have multiple profiles for
    our convenience. If the stream has multiple profiles, one of them can be used
    as the default one (and marked as such). This is not mandatory, but it's a good
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of modules, there are 60+ modules available already, with various versions
    of Python, PHP, PostgreSQL, nginx, and so on, to name a few commonly used services.
    We can use a module from that list to deploy it. Also, the output of the command
    gives us details about profiles, which we can then use to deploy a specific module
    profile.
  prefs: []
  type: TYPE_NORMAL
- en: By using these capabilities, we can modularize our approach to deploy specific
    packages. The overall idea of modularization via streams and profiles is a good
    one, although it's a bit clunky and unfinished in terms of upgrades. That being
    said, it's something that is going to be around in the future, so it's a worthwhile
    investment of our time to learn about it.
  prefs: []
  type: TYPE_NORMAL
- en: We're done with advanced repository management for the time being. Let's now
    learn how to create custom repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it's necessary to create your own private repository of packages.
    Whatever the reason might be – no internet access, low deployment speed – it's
    a completely normal usage model that's often used all over the world. We are going
    to show examples for both CentOS and Ubuntu so that we cover everything necessary
    for most Linux administrators. Let's roll up our sleeves and start!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Keep the `cli1` virtual machine powered on and let''s continue using our shell.
    Let''s make sure that the necessary packages are installed by using our standard
    commands. So, let''s use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That should be all in terms of preparation, so let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up a custom CentOS repository is actually quite a simple affair. The
    first step involves downloading some packages. We are going to download a few
    of them and place them in the same directory. Then, we are going to make that
    directory available via the network by using `vsftpd`. A more detailed explanation
    of `vsftpd` can be found in the next chapter of this book, which is about network-based
    file synchronization. Here, we are just going to do a *Formula 1* qualifying lap
    through `vsftpd` to create a repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we want to create a local repository (hosted on our `cli2`
    machine) that''s going to have two packages in it – the `joe` editor and `desktop-backgrounds-basic`.
    We need to put them in a directory, `/var/ftp/pub/repository`, so that they''re
    nice and handy inside the `vsftpd` folder structure. We could do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.28 – Downloading a few packages and getting ready for repository
    configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.28_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.28 – Downloading a few packages and getting ready for repository configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we already installed the `createrepo` package in the introduction to
    this recipe, we just need to use the `createrepo` command to create the necessary
    inventory information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.29 – Creating a repository out of a directory with RPM packages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.29_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.29 – Creating a repository out of a directory with RPM packages
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to allow this directory to be used via `vsftpd`. Again, we
    have already installed `vsftpd` and, by default, we just need to change one option
    in its configuration file to allow anonymous FTP. Let''s open the configuration
    file, `/etc/vsftpd/vsftpd.conf`, and locate the offending option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now start and enable the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s try to log in to it to verify whether everything is ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.30 – Checking whether the vsftpd configuration works'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.30_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.30 – Checking whether the vsftpd configuration works
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything is now ready from the service perspective. Now we just need to explain
    to `yum/dnf` that they need to use this as a repository. So, let''s head to the
    `/etc/yum.repos.d` directory and create a repository configuration file there.
    Let''s say we''ll call it `localrepo.repo`. The name is irrelevant, it''s just
    that it needs to have the `.repo` extension. Let''s add the following options
    to it and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s verify whether this repository definition now works. We need to use
    `yum` or `dnf` for that, with the `repolist` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.31 – Checking whether our repository is correctly configured via
    its repo config file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.31_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.31 – Checking whether our repository is correctly configured via its
    repo config file
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, `MyLocalRepo` is defined and ready to be used. Let''s test it
    by trying to install the `desktop-backgrounds-basic` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.32 – Installing a package from our custom repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.32_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.32 – Installing a package from our custom repository
  prefs: []
  type: TYPE_NORMAL
- en: We can clearly see the relevant information here – the repository used was called
    `MyLocalRepo`, so both `vsftpd` and our repository configuration file work without
    any problems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu tends to be much, much richer in terms of custom repositories; for example,
    repositories that are hosted on launchpad.net, and so on. It also tends to be
    a bit more internet-reliant than CentOS, but, that being said, it's easy enough
    to create repositories on either one of these distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive into a short explanation about how this all works in CentOS, and
    then it's time for another recipe!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two aspects to this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how creating a repository works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how using a *custom-created* repository works from the service
    and `yum/dnf` perspective
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always, we need to understand both of these concepts so that we can make
    them work for us. Let's start with the repository creation part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, when creating a repository, we have to have some packages for that
    repository. So, a logical first step would always be to either create some packages
    or download them. There''s just one key point to be made here – there *might*
    be problems if you download some packages *without* their dependencies. We deliberately
    chose two packages that don''t have any dependencies so that we can have something
    to start our work with. That problem can be solved in either of the following
    two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: We download all of the necessary dependencies for the packages that we're creating
    a repository for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set up our repositories so that some other repository has all of the necessary
    dependencies for the packages we're creating our repository for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generally speaking, we''ll go a long way in solving this problem by just enabling
    the EPEL repository for our CentOS version, so, generally speaking, we should
    install the EPEL `rpm` as it''s going to help us with dependencies for almost
    anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Then, it all just becomes a matter of creating a directory, placing packages
    there, and using `createrepo` to create the necessary XML files so that the directory
    with packages can be used as a repository. Without `createrepo`, we are going
    to get an error, so we should always install it and use it prior to using our
    custom repository.
  prefs: []
  type: TYPE_NORMAL
- en: The second aspect is related to a wider picture – that is, how to make this
    repository available to other machines on the network and how to configure those
    machines to use it. That's why we strategically selected `vsftpd` as a delivery
    service, as its configuration for this scenario is really easy. We could have
    used the Apache web server as well, but seeing that our next chapter is related
    to `vsftpd`, we thought it would be a fun way to get an introduction to `vsftpd`
    out of the way by seeing it in action.
  prefs: []
  type: TYPE_NORMAL
- en: A part of this process is to work on `repo` files from the repository client
    perspective – that is, all of the machines that are going to be using our custom
    repository. It's just a couple of configuration lines that cover the repository's
    unique name and description, location, and some general settings, such as whether
    that repository is enabled on a client and if we're using signed packages and
    verifying their signature. Usually, people tend to skip over this, although it's
    quite important. If we enable the `gpgcheck` option, we need to install a `gpg`
    key that a repository is using to sign its packages, as well. We can do that with
    the `gpg --import file_name.gpg` command, after we download the `gpg` file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now get ready for the last part of this chapter, which is all about compiling
    software from the source code. We're going to use some familiar, usual suspects
    to do that and learn how to do it along the way.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we need to learn more about `vsftpd`, make sure that you check the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**yum:** [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-yum](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-yum%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Install Anonymous FTP server on CentOS 8**: [https://www.centlinux.com/2020/02/install-anonymous-ftp-server-on-centos-8.html](https://www.centlinux.com/2020/02/install-anonymous-ftp-server-on-centos-8.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create Local Repos**: [https://wiki.centos.org/HowTos/CreateLocalRepos](https://wiki.centos.org/HowTos/CreateLocalRepos%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuring yum and yum repositories**: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/sec-configuring_yum_and_yum_repositories](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/sec-configuring_yum_and_yum_repositories%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling third-party software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, a package for a certain application is just not available – either
    nobody bothered to create it, or that application is so old that it's obsolete
    and nobody wants to do it. Either way, if an application is useful to us, there's
    no reason why we shouldn't try to find its source code and compile it.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling software from source code can sometimes be like dark magic, and we
    have a good example coming up very soon. Sometimes it works without any real effort,
    and we are going to show you an example of that, too. The main distinction between
    those two scenarios seems to be the all-important dependencies and their version.
    Also, there's a lot of software for Linux that needs to be compiled in a specific
    sequence. A perfect example of that is the LAMP stack. After installing Linux,
    if you want to compile Apache, MySQL, and PHP, you had better do it in the correct
    order. Otherwise, your keyboard might find its way to the garbage can sooner than
    you planned. Let's see what we can do about this so that it doesn't happen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use any machine for this recipe, but the most common scenario is a default
    installation of some Linux distribution with a lot of packages missing. So, let's
    install a fresh Ubuntu machine, and let's call it `compile1`, just for fun. So,
    this one is going to be just a Vanilla Ubuntu installation that will need all
    of the configurations in order for the compilation process to work.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start with an easy example of a package that''s very easy to compile
    and won''t give us a massive headache. Let''s compile the `joe` editor and show
    you what we''re talking about. We''ll start with the usual procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to be on the safe side, to get our machine ready for the compilation process,
    let''s use this command to install a large selection of packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, our Ubuntu machine should now be ready for any compilation effort.
    Let''s now download `joe` source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We prefer to keep things tidy in the root''s home directory, so let''s just
    create a folder for compilation purposes. Let''s call it `source` and move `joe`
    source there, and then open its `tar.gz` file with the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The last command (`tar`) is going to open another subfolder (`joe-4.6`) with
    all the necessary files for the compilation process located there. So, let''s
    change the directory to `joe-4.6` and start the configuration process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything goes well, we should have something like this as a result (shortened
    for formatting reasons):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.33 – Configuration step concluded successfully'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.33_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.33 – Configuration step concluded successfully
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration process has finished successfully. Let''s now continue with
    the actual compilation process, for which we need the `make` command (hence the
    reason why we installed all of those packages, `make` being one of them), and
    we can use some additional options to speed the process up. My Ubuntu machine
    has four processors, so we can use `make -j4` to speed the process up (so that
    the compilation process takes all of the available cores, not just one). After
    a couple of seconds, the compilation process should finish similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.34 – Compilation process also concluded successfully'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.34_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.34 – Compilation process also concluded successfully
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step in this process is to install our compiled application. We do
    that by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After this command finishes its job and installs `joe` system-wide, we should
    be able to start `joe` from the command line and edit our files. We can also create
    a `deb` package out of this installation by using the `checkinstall` package.
    When we run it, it's going to ask us for a package description. We can type in
    something like `Joe editor v4.6` and be done with it. At the end of this process,
    we're going to get a `deb` package with installation files that are required to
    deploy `joe` on other Ubuntu servers.
  prefs: []
  type: TYPE_NORMAL
- en: That wasn't so bad, was it? Yes, we had a couple of steps to do, but overall,
    it was a very simple process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s do another example that''s the complete opposite of what we''d call
    a *very simple process*. Let''s try to compile the Apache web server. We''re going
    to use the latest version at the time of writing (2.4.49), located at `https://dlcdn.apache.org//httpd/httpd-2.4.49.tar.gz`,
    by using the same procedure – download the source to our source directory, open
    the source archive, and start with the configuration process. Let''s see what
    happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.35 – configure script in action – Missing dependencies – Example
    1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.35_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.35 – configure script in action – Missing dependencies – Example 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Oops! Not going to happen. So then, we go to Dr. Google and check what to do
    if the message received is *APR is not found*. We''ll end up finding some articles
    that state that we should install some additional packages, so let''s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to run the `configure` script again, and check the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.36 – configure script in action – Missing dependencies – Example
    2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.36_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.36 – configure script in action – Missing dependencies – Example 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Another package seems to be missing. And when we – just as an example – try
    to find a package such as `libpcre` in the `apt` cache, this is what we''re going
    to get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.37 – Trying to figure out which package is missing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.37_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.37 – Trying to figure out which package is missing
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the question becomes how to know which packages to install from this list?
    What usually happens is that people lose patience and write a command such as
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And that''s going to install more than 200 packages on our machine. If we''re
    security-conscious, that''s really not the way to go. It''s easy for people like
    us as we''ve done this a thousand times, but for normal people, this gets really
    frustrating really quick. So, let''s now install the required package and its
    dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Before we do the actual configuration/compiling, we do have to mention one thing.
    Nowadays, a lot of the app code is shared via concepts such as Git. Most of these
    repositories are hosted by app coders, and usually have additional instructions
    for dependencies and how to deploy them. However, if we download a source code
    from a non-Git-like resource, we usually get more information about compiling
    that source code in files such as `INSTALL` after we extract the source archive.
    So, we need to make sure that we check these resources prior to trying to compile
    an app from some source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the rest of our procedure in a serial fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, there will be no more questions, as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.38 – Compilation and installation completed successfully'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.38_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.38 – Compilation and installation completed successfully
  prefs: []
  type: TYPE_NORMAL
- en: We deliberately chose a package that's *a bit* annoying, but not *over-the-top*
    annoying. There are applications out there that can make us spend hours and hours
    figuring out all of the dependencies so that we can compile a single package.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have got the step-by-step process out of the way, let's discuss
    the specifics of how all of this works and fits together. It's pretty obvious
    that there are multiple steps to the process and that each and every one of them
    is significant. And it is – one can't be done without the other. So, let's now
    discuss all of the commands that we used and describe how they work.
  prefs: []
  type: TYPE_NORMAL
- en: The first phase in our compilation process starts with the `./configure` command.
    It's actually not a command *per se*; it's a `shell` script that almost all source
    code packages have. This script is there to make sure that the environment is
    ready for the compilation process – check included files, libraries, dependencies,
    everything needed for the source code compilation process. It checks for the necessary
    compiler and its libraries to make sure that the stage is set up for the next
    part of the process. It also writes down some configuration files that are going
    to be used by `make` when the build process starts.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of the process involves using the `make` command. By using the
    configuration files created by the `configure` script and other files, it starts
    compiling source code. One of these files is called `Makefile`, and it contains
    a lot of information about what `make` needs to do – which files to compile and
    how, which compiler flags to use, how to link all of the compiled code into the
    resulting binaries, and more besides.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the process is not compiling a source code *per se* – it's
    about installing the compiled code on our Linux machine. By using relevant information
    in the configuration files, `make install` installs all of the files necessary
    for our command to work – libraries, binaries, man pages, documentation, and so
    on. If the compilation process from the previous part concludes successfully,
    installation is just about making sure that the compiled application is available
    to be used.
  prefs: []
  type: TYPE_NORMAL
- en: That was the last recipe in this chapter. The next chapter is about network-based
    file synchronization, and as part of those recipes, we are going to go much deeper
    into the inner workings of `vsftpd`, which we just kind of touched on in this
    chapter without giving it much time or space. Also, we are going to discuss `ssh`
    and `scp`, two ways of securely connecting to servers and transferring files between
    servers, and `rsync`, a file synchronization methodology. Stay tuned for the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to learn more about `vsftpd`, make sure that you check out the
    following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**How to compile and run C/C++ code in Linux**: [https://www.cyberciti.biz/faq/howto-compile-and-run-c-cplusplus-code-in-linux/](https://www.cyberciti.biz/faq/howto-compile-and-run-c-cplusplus-code-in-linux/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compiling things on Ubuntu the easy way**: [https://help.ubuntu.com/community/CompilingEasyHowTo](https://help.ubuntu.com/community/CompilingEasyHowTo%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
