

# 第八章：深入 BitBake 元数据

到目前为止，我们已经学会了如何生成镜像和包，并如何使用包源——基本上，掌握了使用 Poky 的基本知识。接下来，我们将学习如何控制 Poky 的行为，以实现我们的目标，并从整个 Yocto 项目中获得最大收益。

本章将帮助我们增强对 BitBake 元数据语法的理解。我们将学习如何使用 BitBake 操作符来修改变量的内容、变量扩展等。这些是我们可以用来制作配方的关键概念，接下来我们将学习如何进行定制。

# 理解 BitBake 的元数据

BitBake 使用的元数据量非常庞大。因此，为了最大限度地利用 Poky，我们必须掌握它。正如我们在 *第四章* 中学到的，*与 BitBake 工具相遇*，元数据覆盖了三个主要领域：

+   `.conf` 文件）：配置文件定义了配置类和配方工作方式的全局内容。

+   `.bbclass` 文件）：类可以继承，以便更容易维护、促进代码重用并避免代码重复。

+   `.bb` 或 `.bbappend` 文件）：这些配方描述了要执行的任务，并提供必要的信息，以便 BitBake 生成所需的任务链。它们是最常用的元数据，因为它们定义了配方的变量和任务。最常见的配方类型是生成包和镜像。

类和配方使用混合的 Python 和 Shell 脚本代码，由 BitBake 解析，生成大量的任务和本地状态，这些任务和状态在解析后仍需执行。

我们还将学习构建配方所需的操作符和基本概念。

## 使用元数据

BitBake 元数据使用的语法可能会误导人，有时很难追踪。然而，我们可以通过使用 `bitbake` 选项（`-e` 或 `--environment`）来检查 BitBake 生成的、预处理过的配方数据中每个变量的值，如下所示：

![图 8.1 – 如何显示 BitBake 环境](img/Figure_8.01_B19361.jpg)

图 8.1 – 如何显示 BitBake 环境

要了解 BitBake 的工作原理，请参考 *BitBake 用户手册*（[`docs.yoctoproject.org/bitbake/2.0`](https://docs.yoctoproject.org/bitbake/2.0)）。接下来的章节将展示配方中常用的大部分语法。

### 基本变量赋值

如下所示可以完成变量的赋值：

![图 8.2 – 变量赋值示例](img/Figure_8.02_B19361.jpg)

图 8.2 – 变量赋值示例

在前面的示例中，`FOO` 变量的值被赋给 `bar`。变量赋值是 BitBake 元数据语法的核心，因为大多数示例都使用变量。

### 变量展开

BitBake 支持变量引用。语法与 Shell 脚本非常相似，如下所示：

![图 8.3 – 一个示例，展示了变量展开](img/Figure_8.03_B19361.jpg)

图 8.3 – 一个示例，展示了变量展开

上述示例导致`A`包含`aValue`，`B`包含`before-aValue-after`。需要记住的是，变量只有在使用时才会展开，如下所示：

![图 8.4 – 变量仅在使用时展开](img/Figure_8.04_B19361.jpg)

图 8.4 – 变量仅在使用时展开

*图 8.4* 说明了 BitBake 评估中使用的*惰性评估*。`B`变量的值是`before-${A}-after`，直到任务需要该变量的值。`A`变量在第 3 行被赋值为`aNewValue`，因此`B`的值变为`before-aNewValue-after`。

### 如果变量未赋值，则使用`?=`进行赋值

当需要仅在变量尚未赋值时才赋值时，可以使用`?=`运算符。以下代码展示了其用法：

![图 8.5 – 一个值的示例](img/Figure_8.05_B19361.jpg)

图 8.5 – 一个值的示例

如果对同一变量进行多个`?=`赋值操作，也会发生相同的行为。第一次使用`?=`运算符负责赋值该变量。让我们来看以下示例：

![图 8.6 – 一个示例，展示了第二次赋值被忽略](img/Figure_8.06_B19361.jpg)

图 8.6 – 一个示例，展示了第二次赋值被忽略

`A`变量在第 1 行已被赋值为`value`，然后在第 2 行赋值给`ignoredAsAlreadyAssigned`，该赋值被忽略。

我们需要考虑到`=`运算符比`?=`运算符更强，因为它独立于之前的变量状态进行赋值，如下所示：

![图 8.7 – 一个示例，展示了`?=`运算符比`=`运算符弱](img/Figure_8.07_B19361.jpg)

图 8.7 – 一个示例，展示了`?=`运算符比`=`运算符弱

因此，`A`变量被赋值为`changeValue`。

### 使用`??=`进行默认值赋值

使用`??=`运算符旨在为变量提供默认值，它是`?=`运算符的弱版本。

请查看以下代码：

![图 8.8 – 一个示例，展示了如何分配默认值](img/Figure_8.08_B19361.jpg)

图 8.8 – 一个示例，展示了如何分配默认值

在第 1 行，`A`的默认值被赋值为`firstValue`，然后在第 2 行，`A`的默认值被更改为`secondValue`。由于没有对`A`变量进行其他赋值，最终的值是`secondValue`。

`?=`是赋值运算符，正如之前所见，它优先于`??=`运算符，以下例子可以证明：

![图 8.9 – 一个示例，展示了`??=`运算符比`?=`运算符弱](img/Figure_8.09_B19361.jpg)

图 8.9 – 一个示例，展示了`??=`运算符比`?=`运算符弱

`A`变量的最终值是`thirdValue`，因为直到第 3 行才有赋值。

### 立即变量展开

`:=` 操作符在需要强制立即扩展变量时使用。它会导致变量的内容立即扩展，而不是等到变量被使用时再扩展，如下所示：

![图 8.10 – 立即变量扩展的示例](img/Figure_8.10_B19361.jpg)

图 8.10 – 立即变量扩展的示例

`B` 的值在第 2 行立即赋值，并扩展为 `aValue-after`。然而，`C` 的值只有在使用时才会赋值，随后设为 `newValue`，因为 `A` 的值已在第 3 行设置。

### 列表追加和预添加

`+=` 操作符，称为 *列表追加*，将新值添加到原值之后，且与原值之间有空格，如下所示：

![图 8.11 – 列表追加的示例](img/Figure_8.11_B19361.jpg)

图 8.11 – 列表追加的示例

在这个示例中，`A` 的最终值是 `originalValue appendedValue`。

`=+` 操作符，称为 *列表预添加*，将新值添加到原值之前，且与原值之间有空格，如下所示：

![图 8.12 – 列表预添加的示例](img/Figure_8.12_B19361.jpg)

图 8.12 – 列表预添加的示例

在这个示例中，`A` 的最终值是 `prependedValue originalValue`。

### 字符串追加和预添加

`.=` 操作符，称为 *字符串追加*，将一个新值添加到原值之后，中间不留空格，如下所示：

![图 8.13 – 字符串追加的示例](img/Figure_8.13_B19361.jpg)

图 8.13 – 字符串追加的示例

在这个示例中，`A` 的最终值是 `originalValueAppendedValue`。

`=.` 操作符，称为 *字符串预添加*，将新值添加到原值之前，中间不留空格，如下所示：

![图 8.14 – 字符串预添加的示例](img/Figure_8.14_B19361.jpg)

图 8.14 – 字符串预添加的示例

在这个示例中，`A` 的最终值是 `prependedValueOriginalValue`。

### :append 和 :prepend 操作符

`:append` 操作符将新值添加到原值之后，中间不留空格，如下所示：

![图 8.15 – 使用 :append 操作符的示例](img/Figure_8.15_B19361.jpg)

图 8.15 – 使用 :append 操作符的示例

在这个示例中，`A` 的最终值是 `originalValueAppendedValue`。

`:prepend` 操作符将新值添加到原值之前，中间不留空格，如下所示：

![图 8.16 – 使用 :prepend 操作符的示例](img/Figure_8.16_B19361.jpg)

图 8.16 – 使用 :prepend 操作符的示例

在这个示例中，`A` 的最终值是 `prependedValueOriginalValue`。

你可能注意到，`:append` 和 `:prepend` 操作符与字符串追加（`.=`）和预添加（`=.`）操作符相似。但在解析 `:append` 和 `:prepend` 操作符与字符串追加和预添加操作符时，存在微妙的差别，如下所示：

![图 8.17 – :append 和 .= 操作符之间差异的示例](img/Figure_8.17_B19361.jpg)

图 8.17 – :append 和 .= 操作符之间差异的示例

使用 `:append` 操作符将操作排队等待执行，这将在 *第 2 行* 分配后发生，结果是 `A` 变成了 `valueAppendedValue`。而 `.=` 操作符是立即执行的，因此 *第 4 行* 的赋值会替代 *第 3 行* 中设置的值，导致 `B` 变为 `value`。

### 列表项移除

`:remove` 操作符从原始内容中删除一个列表项。例如，见下文：

![图 8.18 – 如何使用 :remove 操作符的示例](img/Figure_8.18_B19361.jpg)

图 8.18 – 如何使用 :remove 操作符的示例

在此示例中，`A` 现在是 `value1 value3`。`:remove` 操作符将变量值视为由空格分隔的字符串列表，因此该操作符可以从列表中删除一个或多个项目。请注意，每个追加和预加操作都已经完成，才会执行 `:remove`。

### 条件元数据设置

BitBake 提供了一种非常易于使用的方式，通过名为 **overrides** 的机制编写条件元数据。

`OVERRIDES` 变量包含由冒号（`:`）分隔的值，并从左到右进行评估。每个值都是我们希望具有条件元数据的项目。

让我们考虑下一个示例：

![图 8.19 – OVERRIDES 变量的示例](img/Figure_8.19_B19361.jpg)

图 8.19 – OVERRIDES 变量的示例

`linux` 覆盖比 `arm` 和 `mymachine` 更不具体。以下示例展示了如何使用 `OVERRIDES` 条件地设置 `A` 变量：

![图 8.20 – 使用 OVERRIDES 条件设置的示例](img/Figure_8.20_B19361.jpg)

图 8.20 – 使用 OVERRIDES 条件设置的示例

在此示例中，由于 `OVERRIDES` 中包含 `linux`，`A` 将是 `linuxSpecificValue`。

### 条件追加

BitBake 还支持基于是否在 `OVERRIDES` 中，进行变量追加和预加，如下所示：

![图 8.21 – 使用 OVERRIDES 条件追加的示例](img/Figure_8.21_B19361.jpg)

图 8.21 – 使用 OVERRIDES 条件追加的示例

在上面的示例中，`A` 被设置为 `value armValue`。

### 文件包含

BitBake 提供了两种文件包含指令 – `include` 和 `require`。

使用 `include` 关键字，BitBake 尝试在关键字位置插入文件，因此它是可选的。假设 `include` 行上指定的路径是相对路径；然后，BitBake 会在 `BBPATH` 中找到的第一个实例进行定位。相比之下，如果无法找到所需文件，`require` 关键字会引发 `ParseError`。

提示

Yocto 项目中通常采用的约定是使用 `.inc` 文件在两个或更多的配方文件之间共享公共代码。

### Python 变量扩展

BitBake 使得在变量扩展中使用 Python 代码变得简单，语法如下：

![图 8.22 – Python 扩展语法示例](img/Figure_8.22_B19361.jpg)

图 8.22 – Python 扩展语法示例

这为用户提供了极大的灵活性。我们可以在以下示例中看到 Python 函数的调用：

![图 8.23 – 打印当前日期的 Python 命令示例](img/Figure_8.23_B19361.jpg)

图 8.23 – 打印当前日期的 Python 命令示例

这导致 `A` 变量包含今天的日期。

### 定义可执行的元数据

元数据配方（`.bb`）和类文件（`.bbclass`）可以使用 Shell 脚本代码，如下所示：

![图 8.24 – 任务定义示例](img/Figure_8.24_B19361.jpg)

图 8.24 – 任务定义示例

任务定义与设置变量相同，不同之处在于此变量恰好是可执行的 Shell 脚本代码。在编写任务代码时，我们不应使用 Bash 或 Zsh 特有的功能，因为任务只能依赖于 POSIX 兼容的功能。如果有疑问，测试代码是否安全的一个好方法是使用 Dash shell 来尝试。

另一种注入代码的方式是使用 Python 代码，如此处所示：

![图 8.25 – Python 任务定义示例](img/Figure_8.25_B19361.jpg)

图 8.25 – Python 任务定义示例

任务定义类似，但它将任务标记为 Python 任务，这样 BitBake 就知道如何相应地运行它。

### 在全局命名空间中定义 Python 函数

当我们需要为变量或其他用途生成一个值时，可以通过以下类似的代码在配方（`.bb`）和类（`.bbclass`）中快速完成：

![图 8.26 – 处理 Python 代码中变量值的代码示例](img/Figure_8.26_B19361.jpg)

图 8.26 – 处理 Python 代码中变量值的代码示例

通常，在编写 Python 函数时，我们需要访问 BitBake 数据存储。因此，所有元数据之间的约定是使用一个名为 `d` 的参数来指向 BitBake 的数据存储。它通常是函数的最后一个参数。

在 *图 8.26* 中，我们在第 2 行向数据存储请求 `SOMECONDITION` 变量的值，并根据该值返回一个结果。

该示例导致 `DEPENDS` 变量的值包含 `dependencyWithCondition`。

### 继承系统

`inherit` 指令指定我们的配方（`.bb`）提供哪些功能类，提供了类似面向对象编程语言的基本继承机制。例如，我们可以抽象出使用 Autoconf 和 Automake 构建工具所涉及的任务，并将它们放入配方类中以供重用。给定的 `.bbclass` 文件通过在 `BBPATH` 中查找 `classes/filename.bbclass` 来定位。因此，在使用 Autoconf 或 Automake 的配方中，我们可以使用以下内容：

![图 8.27 – 继承类的示例](img/Figure_8.27_B19361.jpg)

图 8.27 – 如何继承一个类的示例

*图 8.27* 的第 1 行指示 BitBake 使用 `inherit autotools.bbclass`，为大多数基于 Autoconf 或 Automake 的项目提供默认任务。

# 总结

在这一章中，我们详细学习了 BitBake 元数据语法、用于操作变量内容的运算符，以及变量展开，包括一些使用示例。

在下一章中，我们将学习如何使用 Poky 创建外部编译工具，并生成适合目标开发的`root`文件系统。
