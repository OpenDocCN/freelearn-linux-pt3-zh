- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: PowerShell and the Web – HTTP, REST, and JSON
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell 与 Web——HTTP、REST 和 JSON
- en: Up until now, we’ve worked in a very small space – our client machine. It’s
    nice, but the world doesn’t work like that. Pretty much every device we use is
    connected to other machines and also, usually, the internet. Devices need to be
    able to interact with services provided over the web to download data, interact
    with cloud applications, and play games. In this, chapter we’re going to look
    at ways we can use PowerShell to work with objects in the world outside our box.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们一直在一个非常小的空间里工作——我们的客户端机器。虽然这样很方便，但世界并不是这样的。几乎我们使用的每个设备都与其他机器连接，并且通常连接到互联网。设备需要能够与通过网络提供的服务进行交互，以下载数据、与云应用程序互动并玩游戏。在本章中，我们将探讨如何使用
    PowerShell 与我们盒子外部的对象进行交互。
- en: We’ll start out with a brief chat about web services and then look at the basic
    PowerShell tool for interacting with them; `Invoke-WebRequest`. We’ll go on to
    look at `Invoke-RestMethod`, we’ll look at some of the ways of exchanging information
    with web services using **JavaScript Object Notation** (**JSON**), and the tools
    we use to convert JSON data into PowerShell objects, and vice versa. Finally,
    we’ll tackle a short exercise.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先简要讨论 Web 服务，然后介绍与之交互的基本 PowerShell 工具：`Invoke-WebRequest`。接下来，我们将介绍 `Invoke-RestMethod`，并探讨一些使用
    **JavaScript 对象表示法**（**JSON**）与 Web 服务交换信息的方法，以及我们用来将 JSON 数据转换为 PowerShell 对象的工具，反之亦然。最后，我们将进行一个简短的练习。
- en: This chapter will give us the basic techniques we’ll need for some of the work
    we’ll do in later chapters of the book and build on some of the work we did in
    the last chapter. We’ll see that those techniques apply to data on the web as
    well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为我们提供一些在后续章节中所需的基本技术，并建立在我们上一章所做工作的基础上。我们将看到，这些技术同样适用于网页上的数据。
- en: 'In this chapter we are going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: Working with HTTP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTTP
- en: Getting to grips with APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 API
- en: Working with REST
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 REST
- en: Working with JSON
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON
- en: Working with HTTP
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTTP
- en: The world we live in has a dominant philosophy, a set of concepts and practices
    that has largely defined information technology for the last 30 years; the client/server
    paradigm. There are alternatives; centralized computing with dumb terminals, such
    as mainframe computing, thin client computing with applications such as Citrix,
    or peer-to-peer computing such as we might see in BitTorrent or blockchain applications.
    Tim Berners-Lee envisaged the World Wide Web as a peer-to-peer network, but it
    hasn’t really stayed that way. The client/server model is prevalent. In general,
    the device on our desk or in our hands is the client, and it is connected to a
    remote server to receive or manipulate information. It differs from a dumb terminal
    in that some of the processing is carried out on the client, and some of it on
    the server.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所生活的世界有一个主导哲学，一套概念和实践，基本上定义了过去 30 年的信息技术；即客户端/服务器范式。也有其他选择；如通过傻终端进行的集中式计算（例如大型机计算），使用
    Citrix 等应用程序的瘦客户机计算，或者像 BitTorrent 或区块链应用程序中可能看到的点对点计算。蒂姆·伯纳斯-李（Tim Berners-Lee）设想的万维网是一个点对点网络，但它实际上并没有保持那样。客户端/服务器模型是普遍存在的。一般来说，我们桌面或手中使用的设备是客户端，它通过远程服务器接收或处理信息。与傻终端的区别在于，部分处理是在客户端完成的，部分处理则在服务器上进行。
- en: In this chapter, we’re going to look at how information is exchanged between
    clients and servers on the internet using the foundational protocol of the World
    Wide Web; **Hypertext Transfer Protocol** (**HTTP**). This is the protocol we
    use to browse websites.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何通过互联网使用万维网的基础协议——**超文本传输协议**（**HTTP**）——在客户端和服务器之间交换信息。这就是我们用来浏览网站的协议。
- en: The basic cmdlet for working with HTTP in PowerShell is `Invoke-WebRequest`,
    so let’s have a look at how we can use the `Invoke-WebRequest` cmdlet to work
    with data on the web.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，处理 HTTP 的基本 cmdlet 是 `Invoke-WebRequest`，让我们看看如何使用 `Invoke-WebRequest`
    cmdlet 来处理网页上的数据。
- en: 'The `Invoke-WebRequest` cmdlet is an incredibly versatile tool that allows
    us to create an HTTP request and submit it to a web service. Because the range
    of requests we might make is huge, the cmdlet is pretty complicated, with over
    thirty parameters. Let’s start with the simple stuff. Let’s get a list of hyperlinks
    to relevant news topics. In a web browser, go to this address: [https://neuters.de](https://neuters.de).
    This is a text-based website that aggregates the most recent Reuters news articles.
    It’s nice and simple.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoke-WebRequest` cmdlet 是一个功能极其强大的工具，允许我们创建 HTTP 请求并提交到 Web 服务。由于我们可能发出的请求范围非常广泛，这个
    cmdlet 相当复杂，有超过三十个参数。让我们从简单的开始，获取一个相关新闻主题的超链接列表。在 Web 浏览器中，访问此地址：[https://neuters.de](https://neuters.de)。这是一个基于文本的网站，聚合了最新的路透社新闻文章。它简单而清晰。'
- en: 'Now, open PowerShell and type the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 PowerShell 并输入以下内容：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will send a `GET` request to the address and store the response in the
    `$``News` variable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向该地址发送`GET`请求，并将响应存储在`$``News`变量中。
- en: 'Now let’s see what we’ve got by calling the contents of `$News`. Type this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过调用`$News`的内容来看我们得到了什么。输入以下内容：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should see something that looks like the following figure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到类似于以下图形的内容：
- en: '![Figure 7.1 – Invoke-WebRequest gets the HTTP response](img/B17600_07_001.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – `Invoke-WebRequest` 获取 HTTP 响应](img/B17600_07_001.jpg)'
- en: Figure 7.1 – Invoke-WebRequest gets the HTTP response
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – `Invoke-WebRequest`获取 HTTP 响应
- en: 'That’s great, but it’s not pretty. If we look a little closer at our output,
    we can see that one of the sections is called `Links`. We can use that to just
    get the hyperlinks from the page by calling it like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但不太美观。如果我们稍微仔细看一下输出，可以看到其中有一部分叫做`Links`。我们可以使用这个来仅通过调用它来获取页面上的超链接，方法如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Unfortunately, they are all relative links, but we should turn them into absolute
    links by adding the root location, which we can do quite easily. If we pipe the
    output of `$News.Links` to `Get-Member`, we can see that it has a property called
    `href`, which just contains the link, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，它们都是相对链接，但我们应该通过添加根位置将它们转换为绝对链接，这我们可以很容易做到。如果我们将`$News.Links`的输出管道到`Get-Member`，我们可以看到它有一个名为`href`的属性，其中包含链接，如下所示：
- en: '![Figure 7.2 – href property](img/B17600_07_002.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – href 属性](img/B17600_07_002.jpg)'
- en: Figure 7.2 – href property
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – href 属性
- en: 'We can concatenate that with the root domain. Type the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其与根域名连接。输入以下代码：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And you should see a list of absolute links, like in the following figure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一列绝对链接，如下图所示：
- en: '![Figure 7.3 – Scraping the neuters.de site for links](img/B17600_07_003.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 从 neuters.de 网站抓取链接](img/B17600_07_003.jpg)'
- en: Figure 7.3 – Scraping the neuters.de site for links
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 从 neuters.de 网站抓取链接
- en: If you got something like that, congratulations, you have just **scraped** your
    first website with PowerShell. Scraping is the process of automating the retrieval
    of data from a website.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到了类似的结果，恭喜你，你刚刚用 PowerShell **抓取**了你第一个网站。抓取是自动化从网站获取数据的过程。
- en: '`Invoke-WebRequest` has only one mandatory parameter; `-Uri`. It is positional,
    so any string following the cmdlet will be treated as an input for this parameter.
    The `–Uri` parameter accepts the URL of the source.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoke-WebRequest`只有一个必需的参数；`-Uri`。它是位置参数，因此紧跟在 cmdlet 后的任何字符串将被视为此参数的输入。`–Uri`参数接受源的
    URL。'
- en: URI versus URL
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: URI 与 URL
- en: We are probably all familiar with the acronym `http:` and `https:`, so an absolute
    URL would be [https://neuters.de](https://neuters.de), containing both the scheme
    (`https:`) and the address (`neuters.de`) separated by a double slash (`//`).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能都很熟悉缩写 `http:` 和 `https:`，所以绝对 URL 就是[https://neuters.de](https://neuters.de)，包含了方案（`https:`）和地址（`neuters.de`），并且两者之间由双斜杠（`//`）分隔。
- en: What about URNs, though? A URN consists of the scheme (`urn:`), one or more
    `urn:ietf:rfc:1149`, which identifies my favorite protocol definition.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 URN 呢？URN 由方案（`urn:`）和一个或多个标识符（例如 `urn:ietf:rfc:1149`）组成，标识了我最喜欢的协议定义。
- en: The twist is that the `-Uri` parameter only supports the `http:` and `https:`
    schemes, so can only accept URLs. However, according to the World Wide Web Consortium,
    the international standards authority for the web, URI is a more precise and technically
    correct term than URL.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 其中的关键是，`-Uri` 参数仅支持 `http:` 和 `https:` 方案，因此只能接受 URL。然而，根据万维网联盟（W3C），即国际网络标准化机构，URI
    是比 URL 更精确、更技术性正确的术语。
- en: 'Let’s take a closer look at some of the parameters that we can use with `Invoke-WebRequest`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下可以与`Invoke-WebRequest`一起使用的一些参数：
- en: '`-Method` will accept any of the standard HTTP methods: `GET`, `PUT`, `POST`,
    `DELETE`, and a few others. If we omit it, then the default method is `GET`. If
    we need to use a custom method, then we can use the `-CustomMethod` parameter.
    We can’t use both `-Method` and `-CustomMethod` in the same cmdlet. This parameter
    allows us to send information to a web address.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Method` 将接受任何标准的 HTTP 方法：`GET`、`PUT`、`POST`、`DELETE` 等。如果我们省略此项，则默认方法为 `GET`。如果我们需要使用自定义方法，则可以使用
    `-CustomMethod` 参数。我们不能在同一个 cmdlet 中同时使用 `-Method` 和 `-CustomMethod`。此参数允许我们将信息发送到
    Web 地址。'
- en: '`-OutFile` specifies a path and name to write the output to a file. Note this
    only writes the response HTML to the file, not things such as the response code.
    This parameter prevents the output from being placed in the pipeline. If we want
    the output to be available to the pipeline and to be written to a file, then we
    need to use the `-PassThru` parameter as well.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-OutFile` 指定一个路径和名称，将输出写入文件。请注意，这只会将响应 HTML 写入文件，而不会写入诸如响应代码之类的内容。此参数会阻止输出被放入管道中。如果我们希望输出既可以进入管道，又可以写入文件，则需要同时使用
    `-PassThru` 参数。'
- en: '`-Headers` can be used to submit specific header information as part of the
    web request. The information must take the form of a hashtable or dictionary.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Headers` 可以用于提交特定的头部信息作为 Web 请求的一部分。信息必须以哈希表或字典的形式提供。'
- en: '`-Body` can submit specific body content, such as a query. We can’t use `-Body`
    and `-Form` in the same cmdlet.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Body` 可以提交特定的主体内容，如查询。我们不能在同一个 cmdlet 中同时使用 `-Body` 和 `-Form`。'
- en: '`-Form`. The `-Form` parameter is used to submit information to an HTML form
    at the target address. We can find lots of information on the web about how to
    use the `-Form` parameter to quickly and easily log in to websites using Windows
    PowerShell. Unfortunately, most of them don’t work with PowerShell 7 because the
    HTML is parsed differently. We’ll discover why shortly.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Form`。`-Form` 参数用于向目标地址的 HTML 表单提交信息。我们可以在网上找到许多关于如何使用 `-Form` 参数快速且轻松地通过
    Windows PowerShell 登录网站的资料。不幸的是，由于 HTML 解析方式不同，大多数方法无法在 PowerShell 7 中工作。稍后我们将了解原因。'
- en: '`-Proxy` allows us to specify an alternative proxy server to the one set on
    our client. It is normally used with either the `-ProxyUseDefaultCredentials`
    parameter, which passes the current user credentials to the proxy, or with the
    `-ProxyCredentials` parameter, which allows us to specify alternative credentials.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Proxy` 允许我们指定一个替代的代理服务器，而不是客户端上设置的代理。通常与 `-ProxyUseDefaultCredentials` 参数一起使用，后者将当前用户凭据传递给代理，或者与
    `-ProxyCredentials` 参数一起使用，后者允许我们指定替代的凭据。'
- en: '`-NoProxy` lets us bypass the client proxy altogether. We can’t use it in the
    same cmdlet as `-Proxy`.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-NoProxy` 让我们完全绕过客户端代理。我们不能在与 `-Proxy` 的同一 cmdlet 中使用此项。'
- en: '`-SessionVariable` can be used when connecting to a stateful web service; we
    can use the `-SessionVariable` the first time we run `Invoke-WebRequest`, and
    then use the `-WebSession` parameter with the same value for each subsequent connection
    to ensure we persist the session state. This is useful if we need to log in to
    a web service before using it. Note that we supply a string to `-SessionVariable`,
    but then supply the string as a variable to `-Websession`, like so:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-SessionVariable` 可用于连接到有状态的 Web 服务；我们可以在第一次运行 `Invoke-WebRequest` 时使用 `-SessionVariable`，然后在每个后续连接中使用相同的值和
    `-WebSession` 参数，以确保会话状态的持续性。如果我们需要先登录 Web 服务再使用它，这个功能很有用。请注意，我们将字符串传递给 `-SessionVariable`，但之后将该字符串作为变量传递给
    `-WebSession`，如下所示：'
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`-SkipHttpErrorCheck`: By default, if `Invoke-WebRequest` gets a HTTP error
    code as a response, it will report it as an error, in red, rather than as an output.
    If we want to capture the error response and process it, then we can use this
    parameter. For an example, see the following figure:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-SkipHttpErrorCheck`：默认情况下，如果 `Invoke-WebRequest` 收到 HTTP 错误代码作为响应，它将把错误以红色报告出来，而不是作为输出。如果我们想捕捉错误响应并处理它，那么可以使用此参数。有关示例，请参见下图：'
- en: '![Figure 7.4 – Using -SkipHttpErrorCheck](img/B17600_07_004.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 使用 -SkipHttpErrorCheck](img/B17600_07_004.jpg)'
- en: Figure 7.4 – Using -SkipHttpErrorCheck
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 使用 -SkipHttpErrorCheck
- en: In the figure here, the first cmdlet, in the red box, doesn’t use the `-SkipHttpErrorCheck`
    parameter, so PowerShell treats the response as an error. In the second cmdlet,
    in the green box, we’ve used the parameter and we can see the actual HTTP response
    that the server sent.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的图示中，第一个 cmdlet（红框中的部分）没有使用 `-SkipHttpErrorCheck` 参数，因此 PowerShell 将响应视为错误。在第二个
    cmdlet（绿框中的部分）中，我们使用了该参数，可以看到服务器实际发送的 HTTP 响应。
- en: There are another thirty parameters we can use with `Invoke-WebRequest` but
    these are the most commonly used ones. Let’s take a look at why the `-Form` parameter
    isn’t as useful in PowerShell 7.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另外三十个可以与 `Invoke-WebRequest` 一起使用的参数，但这些是最常用的参数。让我们来看看为什么 `-Form` 参数在 PowerShell
    7 中不那么有用。
- en: Why don’t we see Forms information in PowerShell 7?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么在 PowerShell 7 中看不到 Forms 信息？
- en: 'As we mentioned, the `-Form` parameter doesn’t work as well in PowerShell 7
    as it does in Windows PowerShell. If we examine the objects returned by `Invoke-WebRequest`
    with `Get-Member`, we can’t see the `Forms` property in PowerShell 7 but we can
    in Windows PowerShell. It’s worth taking a closer look and understanding why.
    The `Invoke-WebRequest` cmdlet produces different types of objects in PowerShell
    7 and Windows PowerShell. We can see in the following figure the difference in
    output. In the upper blue frame, we can see that Windows PowerShell produces objects
    with a `TypeName` of `HtmlWebResponseObject`, and we can see the properties of
    this type include `Forms`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所提到的，`-Form` 参数在 PowerShell 7 中的效果不如在 Windows PowerShell 中那样好。如果我们使用 `Get-Member`
    查看 `Invoke-WebRequest` 返回的对象，我们在 PowerShell 7 中看不到 `Forms` 属性，而在 Windows PowerShell
    中可以看到。值得仔细研究并了解其中的原因。`Invoke-WebRequest` cmdlet 在 PowerShell 7 和 Windows PowerShell
    中返回的是不同类型的对象。我们可以在以下图示中看到输出的差异。在上方的蓝色框中，我们看到 Windows PowerShell 返回的对象 `TypeName`
    为 `HtmlWebResponseObject`，并且可以看到该类型的属性中包括 `Forms`：
- en: '![Figure 7.5 – Invoke-WebRequest in Windows PowerShell](img/B17600_07_005.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – Windows PowerShell 中的 Invoke-WebRequest](img/B17600_07_005.jpg)'
- en: Figure 7.5 – Invoke-WebRequest in Windows PowerShell
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – Windows PowerShell 中的 Invoke-WebRequest
- en: 'In PowerShell 7, next, we can see that we get a `BasicHtmlWebResponseObject`,
    which doesn’t have a `Forms` property:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 7 中，接下来我们看到的是 `BasicHtmlWebResponseObject`，它没有 `Forms` 属性：
- en: '![Figure 7.6 – Invoke-WebRequest in PowerShell 7](img/B17600_07_006.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – PowerShell 7 中的 Invoke-WebRequest](img/B17600_07_006.jpg)'
- en: Figure 7.6 – Invoke-WebRequest in PowerShell 7
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – PowerShell 7 中的 Invoke-WebRequest
- en: This is because PowerShell 7 uses basic parsing by default.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 PowerShell 7 默认使用基本解析。
- en: In Windows PowerShell, we can use the information held in the `Forms` property
    of the web page to create a variable with properties that match the fields on
    the form, and then submit the variable as part of our cmdlet, using the `-Form`
    parameter. Because the objects returned by `Invoke-WebRequest` don’t have a property
    called `Forms`, many of the instructions found on the internet for using the cmdlet
    this way won’t work in PowerShell 7.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows PowerShell 中，我们可以使用网页中 `Forms` 属性包含的信息来创建一个变量，该变量的属性与表单字段匹配，然后使用 `-Form`
    参数将该变量作为 cmdlet 的一部分提交。由于 `Invoke-WebRequest` 返回的对象没有名为 `Forms` 的属性，许多网上关于如何使用该
    cmdlet 的说明在 PowerShell 7 中将无法正常工作。
- en: That doesn’t mean we can’t use `Invoke-WebRequest` to fill in forms, however.
    We just need to understand what the form fields are beforehand; we will struggle
    to work it out with PowerShell 7 alone. We also need to be aware that many of
    the examples we see on the internet are written for the Windows PowerShell version
    of the `Invoke-WebRequest` cmdlet.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们不能使用 `Invoke-WebRequest` 来填写表单。我们只需要提前了解表单字段是什么；单靠 PowerShell 7，我们可能难以弄清楚。我们还需要注意，许多网上的示例是为
    Windows PowerShell 版本的 `Invoke-WebRequest` cmdlet 编写的。
- en: Authentication
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证
- en: 'Many websites use some form of authentication, so authentication is a big part
    of `Invoke-WebRequest`. The first thing to do is to set the type of authentication
    in use. We can use the `-UseDefaultCredentials` parameter to try and authenticate
    with the current environment login, but if we’re using an external address, rather
    than something inside our organization, then we will probably need to supply site-specific
    information. The `-Authentication` parameter accepts the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站使用某种形式的认证，因此认证是 `Invoke-WebRequest` 的一个重要部分。首先要做的是设置使用的认证类型。我们可以使用 `-UseDefaultCredentials`
    参数尝试使用当前环境的登录凭据进行认证，但如果我们访问的是外部地址而非我们组织内部的地址，那么我们可能需要提供特定于该站点的信息。`-Authentication`
    参数接受以下选项：
- en: '`None`: This is the default. If the `-Authentication` parameter is not filled,
    then `Invoke-WebRequest` will not use any authentication.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`：这是默认选项。如果没有填写 `-Authentication` 参数，则 `Invoke-WebRequest` 将不会使用任何认证。'
- en: '`Basic`: This will send a Base64-encoded set of credentials. Hopefully, we’re
    connecting to an HTTPS URL, because Base64 encoding is not the same as encryption.
    This is not a very secure way of sending credentials. We will also need to use
    the `-Credential` parameter to supply the username and password.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Basic`：这将发送一组Base64编码的凭证。希望我们连接的是HTTPS网址，因为Base64编码与加密不同。这不是一种非常安全的发送凭证的方式。我们还需要使用`-Credential`参数来提供用户名和密码。'
- en: '`Bearer`: This will require a Bearer token to be supplied as a secure string
    using the `-Token` parameter. A token is basically a long string that can be used
    to identify the sender of the request. Bearer authentication is an HTTP authentication
    scheme that was developed as part of OAuth 2.0 – the Open Authorization standard.
    Not all bearer authentication is OAuth, however. Because we are passing a token
    assigned by the remote server, it should only be used over HTTPS so that it is
    encrypted.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bearer`：这要求提供一个承载令牌，并通过`-Token`参数以安全字符串的形式传递。令牌基本上是一个长字符串，用于标识请求的发送者。承载身份验证是一种HTTP身份验证方案，是OAuth
    2.0（开放授权标准）的一部分。然而，并非所有承载身份验证都是OAuth。由于我们传递的是由远程服务器分配的令牌，它应该只在HTTPS上使用，以确保加密。'
- en: '`Oauth`: This is an open standard for access delegation. It’s used by many
    big internet companies such as Amazon, Google, and Microsoft to provide authorization
    and authentication. Usually, it takes a bearer token, as mentioned previously.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Oauth`：这是一个用于访问委托的开放标准。许多大互联网公司，如亚马逊、谷歌和微软，使用它来提供授权和身份验证。通常，它会使用一个承载令牌，正如之前提到的那样。'
- en: Let’s have a look at how this works. On my client, I’ve installed PowerShell
    Universal, a module from the good people at Ironman Software (https://blog.ironmansoftware.com/).
    This lets me run a lightweight server on my client and create endpoints.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的。在我的客户端，我安装了PowerShell Universal，这是Ironman Software的好心人提供的一个模块（https://blog.ironmansoftware.com/）。它允许我在客户端运行一个轻量级服务器并创建端点。
- en: Don’t try to do this on your client
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在你的客户端尝试这样做
- en: It takes quite a lot of configuration that we’re not going to cover in this
    book and requires a subscription to use the authentication functions. I’m including
    it here so that we can see how the process works.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要相当多的配置，这本书中不会涉及，且需要订阅才能使用身份验证功能。我在这里提及它是为了让我们了解整个过程是如何工作的。
- en: 'I’ve created an endpoint at `http://localhost:5000/me` that requires an authentication
    token to access. I’ve created the token on the server, and stored it as a secure
    string as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`http://localhost:5000/me`创建了一个端点，需要身份验证令牌才能访问。我已在服务器上创建了令牌，并将其存储为一个安全字符串，如下所示：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The token isn’t really `<mytoken>`; it’s a very much longer random string.
    Now I can access the endpoint by providing the token using the `$``apptoken` variable:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌并不是真的`<mytoken>`；它是一个更长的随机字符串。现在，我可以通过提供令牌并使用`$apptoken`变量来访问该端点：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see in the following figure, without supplying authentication, I
    get a `401` error; I’m unauthorized. When I supply authentication in the second
    cmdlet, I get the content of the page, `Hello World`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，在没有提供身份验证的情况下，我会收到一个`401`错误；我没有权限。当我在第二个命令中提供身份验证时，我得到了页面内容`Hello World`：
- en: '![Figure 7.7 – Providing authentication using the -Authentication and -Token
    parameters](img/B17600_07_007.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 使用 -Authentication 和 -Token 参数提供身份验证](img/B17600_07_007.jpg)'
- en: Figure 7.7 – Providing authentication using the -Authentication and -Token parameters
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 使用 -Authentication 和 -Token 参数提供身份验证
- en: 'Quite often, however, we will need to provide authentication via the `-Headers`
    parameter. This is a little more involved than using `-Authentication`. We need
    to provide the token as part of the web request but point it to the correct header.
    In the case of my local test endpoint, I can do it like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常情况下，我们需要通过`-Headers`参数提供身份验证。这比使用`-Authentication`稍微复杂一些。我们需要将令牌作为Web请求的一部分提供，但需要指向正确的头部。在我的本地测试端点的情况下，我可以像这样操作：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that if we supply the token in the header, we must *not* encode it using
    the `ConvertTo-SecureString` cmdlet. I’ve saved the unencoded token as `$admtoken`,
    (not `$apptoken`) as we can see here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们在头部提供令牌，我们必须*不*使用`ConvertTo-SecureString`命令进行编码。我已经将未编码的令牌保存为`$admtoken`，（而不是`$apptoken`），如下所示：
- en: '![Figure 7.8 – Passing authentication data using the -Headers parameter](img/B17600_07_008.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 使用 -Headers 参数传递身份验证数据](img/B17600_07_008.jpg)'
- en: Figure 7.8 – Passing authentication data using the -Headers parameter
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 使用 -Headers 参数传递身份验证数据
- en: In the first line, I’m trying to pass the encoded token, stored in the `$apptoken`
    variable. In the second line, I’m passing the unencoded token store in the `$``admtoken`
    variable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我试图传递存储在`$apptoken`变量中的编码令牌。在第二行，我传递存储在`$``admtoken`变量中的未编码令牌。
- en: 'Note that the `SecureString` object type provides a *measure of security*,
    according to Microsoft. It’s not truly secure. Read more here: [https://learn.microsoft.com/en-us/dotnet/api/system.security.securestring](https://learn.microsoft.com/en-us/dotnet/api/system.security.securestring).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据微软的说法，`SecureString`对象类型提供了一种*安全性措施*，但它并不是真正安全的。详细内容请参阅：[https://learn.microsoft.com/en-us/dotnet/api/system.security.securestring](https://learn.microsoft.com/en-us/dotnet/api/system.security.securestring)。
- en: Now we’ve covered making basic requests, let’s take a look at how we can interact
    with websites more programmatically.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何发起基本请求，接下来让我们看看如何更程序化地与网站互动。
- en: Getting to grips with APIs
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握API
- en: Most modern systems communicate between client and server using an API. This
    is a list of agreed requests and responses between the two components. This sounds
    complicated, but it is quite simple. If we put the [https://random.dog/woof.json](https://random.dog/woof.json)
    URL into a browser, we get back the URL of a random dog, from a database of dog
    images. We also get the size of the file, in bytes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现代大多数系统通过API在客户端和服务器之间进行通信。这是两者之间约定的请求和响应列表。这听起来很复杂，但其实很简单。如果我们将[https://random.dog/woof.json](https://random.dog/woof.json)网址放入浏览器，我们会得到来自狗狗图片数据库的随机狗狗的URL。我们还会得到文件的大小（以字节为单位）。
- en: Our browser is the client, and it sends an HTTP `GET` request to an API endpoint
    (`/woof.json`) on the server at the [https://random.dog](https://random.dog) URL.
    In response to this request, the server sends a message containing a URL back
    to us, in the first frame in the following figure. We can look at the headers
    in the second frame below and see that the content type is **JSON**. We can then
    display the URL in a browser to see a picture of an adorable dog, below. Note
    that I’m using Firefox, here, which allows us to see the headers as well as the
    content. Other browsers will only show the JSON content.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器是客户端，它向服务器上的API端点(`/woof.json`)发送HTTP `GET`请求，该端点位于[https://random.dog](https://random.dog)网址。作为对这个请求的响应，服务器发送包含URL的消息给我们，如下图中的第一个框架所示。我们可以查看下面第二个框架中的头信息，看到内容类型是**JSON**。然后我们可以在浏览器中显示该URL，查看一只可爱的狗狗的图片。请注意，我这里使用的是Firefox，它可以让我们查看头信息和内容。其他浏览器只会显示JSON内容。
- en: '![Figure 7.9 – Dog via API](img/B17600_07_009.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 通过API获取的狗狗](img/B17600_07_009.jpg)'
- en: Figure 7.9 – Dog via API
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 通过API获取的狗狗
- en: The server isn’t sending a web page for the browser to display; it’s just sending
    data that contains a URL, and every time we request the page, it sends a different
    URL. We’ll take a good look at this data in the later section of this chapter
    entitled *Working with JSON*, so don’t worry about it too much now.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器并没有发送一个网页供浏览器显示；它只是发送包含URL的数据，每次我们请求页面时，它都会发送不同的URL。我们将在本章稍后的“*处理 JSON*”部分详细介绍这些数据，所以现在不用太担心它。
- en: 'There are four common types of APIs in general use:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一般常用的API类型有四种：
- en: '**Remote Procedure Call** (**RPC**) APIs'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程过程调用**（**RPC**）API'
- en: SOAP APIs
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOAP API
- en: REST APIs
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST API
- en: WebSocket APIs
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket API
- en: They fall into two categories – **stateful**, where the connection between client
    and server is maintained over a number of requests, and **stateless**, where each
    request from a client is treated as a unique event and doesn’t persist any information
    over to the next request. Let’s take a closer look.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它们分为两类 —— **有状态**，客户端和服务器之间的连接在多个请求中保持不变；和**无状态**，客户端的每个请求都被视为一个独立事件，并不会将任何信息保留到下一个请求中。让我们深入看看。
- en: RPC APIs
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RPC API
- en: RPC APIs call a function in software on a server – they tell a server to do
    something using a specific piece of code, and the server will return an output
    that may or may not contain data. They may not do this over HTTP; there is a separate
    protocol called, appropriately enough, RPC, which is often used over local networks.
    We are not going to concern ourselves with RPC APIs in this chapter, but they
    are undergoing a bit of a resurgence on the internet, particularly for blockchain
    applications. RPC APIs were historically stateful, but more modern implementations
    of this model are usually not.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: RPC API 调用服务器上软件中的函数——它们通过特定的代码让服务器执行某个操作，服务器会返回一个可能包含数据的输出。它们可能不通过 HTTP 执行；有一个名为
    RPC 的独立协议，通常在局域网内使用。我们在本章中不讨论 RPC API，但它们在互联网上正经历着一些复兴，特别是在区块链应用中。RPC API 在历史上是有状态的，但这种模型的现代实现通常是无状态的。
- en: SOAP APIs
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOAP API
- en: '**SOAP** APIs use the **Simple Object Access Protocol** to exchange messages
    using XML. We see these APIs most usually when working with Windows servers running
    Microsoft **Internet Information Server** (**IIS**) rather than Linux servers,
    which usually run Apache or NGINX software. As we have seen in [*Chapter 6*](B17600_06.xhtml#_idTextAnchor117),
    *PowerShell and Files – Reading, Writing, and Manipulating Data*, XML is not the
    easiest language to work with and Windows is a less common operating system than
    Linux for web servers, so SOAP APIs are not the most popular. SOAP is most commonly
    stateless.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOAP** API 使用**简单对象访问协议（Simple Object Access Protocol）**通过 XML 交换消息。我们通常在使用运行
    Microsoft **Internet Information Server（IIS）**的 Windows 服务器时遇到这些 API，而不是在通常运行
    Apache 或 NGINX 软件的 Linux 服务器上。如我们在 [*第六章*](B17600_06.xhtml#_idTextAnchor117) 中所见，*PowerShell
    和文件——读取、写入及数据操作*，XML 语言并不是最容易使用的，而 Windows 作为 Web 服务器的操作系统不如 Linux 常见，因此 SOAP
    API 并不是最受欢迎的。SOAP 最常见的是无状态的。'
- en: REST APIs
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST API
- en: '**REST** is a style of software architecture for client-server, machine-to-machine
    communication. A REST API conforms to this style. They are flexible and lightweight,
    most often based on the HTTP protocol. REST APIs are stateless and can receive
    output in many forms, including HTML and XML. JSON is the most common form of
    output, however. REST APIs are generally the simplest APIs to work with and certainly
    the most common on the internet.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST** 是一种用于客户端-服务器、机器对机器通信的软件架构风格。REST API 符合这种风格。它们灵活且轻量，通常基于 HTTP 协议。REST
    API 是无状态的，能够以多种形式接收输出，包括 HTML 和 XML。然而，JSON 是最常见的输出形式。REST API 通常是最简单的 API，也无疑是互联网上最常见的
    API。'
- en: WebSocket APIs
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket API
- en: WebSocket APIs use JSON to move data between clients and servers. Like REST
    APIs, they are based on HTTP, but unlike REST APIs, WebSocket APIs also use their
    own protocol, called the WebSocket protocol, an extension of HTTP, which allows
    for a wider range of operations. They are stateful and bi-directional; the server
    may initiate communication with a connected client. This makes them extremely
    powerful, but also harder to use.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket API 使用 JSON 在客户端和服务器之间传输数据。与 REST API 类似，它们基于 HTTP，但与 REST API 不同的是，WebSocket
    API 还使用它们自己的协议，即 WebSocket 协议，这是 HTTP 的扩展，允许进行更多种类的操作。它们是有状态的和双向的；服务器可以主动与连接的客户端进行通信。这使得它们非常强大，但也更难使用。
- en: Let’s take a closer look at how we can work with the most common API type –
    the REST API.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解如何使用最常见的 API 类型——REST API。
- en: Working with REST
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 REST
- en: 'The most common API we will work with is the REST API. We most frequently encounter
    REST APIs when we use **web applications**. A web application is usually a tiered
    client/server application. A typical application would consist of three tiers
    or layers:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的最常见 API 是 REST API。当我们使用**Web 应用程序**时，通常会遇到 REST API。Web 应用程序通常是分层的客户端/服务器应用程序。一个典型的应用程序通常包括三个层级：
- en: '**A presentation layer** – the web browser or app on the client device'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**展示层** —— 客户端设备上的 Web 浏览器或应用程序'
- en: '**An application layer** – the web server'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层** —— Web 服务器'
- en: '**A storage layer** – usually a database running on the web server or a separate
    server'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储层** —— 通常是运行在 Web 服务器上或独立服务器上的数据库'
- en: We use REST APIs to communicate between the presentation layer (the browser)
    and the application layer (the web server); how the application layer communicates
    with the storage layer (the database) is up to the application developer, but
    it will often be Python or PHP.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 REST API 来在展示层（浏览器）和应用层（Web 服务器）之间进行通信；应用层如何与存储层（数据库）进行通信由应用开发者决定，但通常会使用
    Python 或 PHP。
- en: REST APIs are usually implemented using HTTP, which means they use a familiar
    set of HTTP commands such as `GET`, `PUT`, and `POST`. Because of the way web
    applications are usually designed, REST APIs are frequently associated with database
    operations; **Create, Read, Update, and Delete** (**CRUD**). The following table
    summarizes how the commands map to operations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 通常使用 HTTP 实现，这意味着它们使用一组熟悉的 HTTP 命令，如 `GET`、`PUT` 和 `POST`。由于 Web 应用程序的设计方式，REST
    API 通常与数据库操作相关联；**创建、读取、更新和删除**（**CRUD**）。下表总结了这些命令如何映射到操作。
- en: '| **Database operation** | **REST** **API request** | **Example** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **数据库操作** | **REST** **API 请求** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | `POST` | Create a new user |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | `POST` | 创建一个新用户 |'
- en: '| Read | `GET` | Get a picture of a dog |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 读取 | `GET` | 获取一张狗狗的图片 |'
- en: '| Update | `PUT` | Change an address |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 更新 | `PUT` | 修改一个地址 |'
- en: '| Delete | `DELETE` | Delete a chatroom post |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | `DELETE` | 删除一个聊天室帖子 |'
- en: Table 7.1 – How REST relates to CRUD
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1 – REST 与 CRUD 的关系
- en: The websites we’ve looked at so far utilize APIs, and we’ve worked with them
    using `Invoke-WebRequest`. Let’s take a look at a different cmdlet we can use.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前看到的网站都使用了 API，并且我们已经通过 `Invoke-WebRequest` 与它们进行过交互。现在让我们看看另一种可以使用的 cmdlet。
- en: Invoke-RestMethod
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Invoke-RestMethod
- en: 'The `Invoke-RestMethod` cmdlet can be used to query a REST API endpoint, such
    as `http://random.dog/woof.json`. How does `Invoke-RestMethod` differ from `Invoke-WebRequest`?
    Let’s look at the `random.dog/woof.json` API endpoint with both to compare the
    output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoke-RestMethod` cmdlet 可以用于查询一个 REST API 端点，例如 `http://random.dog/woof.json`。`Invoke-RestMethod`
    与 `Invoke-WebRequest` 有什么不同呢？让我们使用两者分别查看 `random.dog/woof.json` API 端点，以比较输出：'
- en: '![Figure 7.10 – Comparing Invoke-WebRequest and Invoke-RestMethod](img/B17600_07_010.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 比较 Invoke-WebRequest 和 Invoke-RestMethod](img/B17600_07_010.jpg)'
- en: Figure 7.10 – Comparing Invoke-WebRequest and Invoke-RestMethod
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 比较 Invoke-WebRequest 和 Invoke-RestMethod
- en: In the first example, in the red box, I’ve used `Invoke-WebRequest`. In the
    second example, in the green box, I’ve used `Invoke-RestMethod`. Both cmdlets
    parse the response correctly, but they are doing different things. `Invoke-WebRequest`
    is displaying the HTTP response from the endpoint, including the headers and content.
    `Invoke-RestMethod` is only looking at the content and is displaying it as a custom
    object with a set of properties corresponding to names in the dictionary included
    in the content. Wait, what? Where did the dictionary come from? Remember, `Invoke-RestMethod`
    works with REST API endpoints. A REST API provides output in JSON, or less frequently
    in XML. JSON and XML outputs usually consist of a collection of name-value pairs;
    a dictionary. If we use `Invoke-RestMethod` to interrogate an HTML page that doesn’t
    output in JSON or XML, then we get a single object, consisting of the raw HTML
    from the page. We will cover JSON in more detail in the next section of this chapter,
    *Working with JSON*. Let’s take a closer look at the output we get when we access
    an API endpoint.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，红框中的部分，我使用了 `Invoke-WebRequest`。在第二个示例中，绿框中的部分，我使用了 `Invoke-RestMethod`。这两个
    cmdlet 都能正确解析响应，但它们执行的操作不同。`Invoke-WebRequest` 显示了来自端点的 HTTP 响应，包括头部和内容。`Invoke-RestMethod`
    只关注内容，并将其显示为一个自定义对象，包含与内容中的字典中名称对应的属性。等等，什么？字典从哪里来？记住，`Invoke-RestMethod` 是与 REST
    API 端点交互的。REST API 提供的输出通常是 JSON，或者不常见的是 XML。JSON 和 XML 输出通常由一组名称-值对组成；也就是字典。如果我们使用
    `Invoke-RestMethod` 查询一个没有以 JSON 或 XML 输出的 HTML 页面，那么我们会得到一个单一对象，包含页面的原始 HTML。我们将在本章的下一节中更详细地介绍
    JSON，*与 JSON 一起工作*。让我们更仔细地看看访问 API 端点时获得的输出。
- en: 'If we pipe `Invoke-RestMethod` to `Get-Member`, we can see that we have a `System.Management.Automation.PSCustomObject`
    with two properties; `fileSizeBytes` and `url`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `Invoke-RestMethod` 传递给 `Get-Member`，可以看到我们得到了一个 `System.Management.Automation.PSCustomObject`
    对象，其中包含两个属性：`fileSizeBytes` 和 `url`：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The parameters for `Invoke-RestMethod` are quite similar to `Invoke-WebRequest`.
    We can summarize them in *Table 7.2*. As we can see, `Invoke-WebRequest` has the
    `-HttpVersion` parameter, which was introduced in PowerShell 7.3, while `Invoke-RestMethod`
    does not, and `Invoke-RestMethod` has parameters that deal with relative links
    (`-FollowRelLink` and `-MaximumFollowRelLink`) and `-StatusCodeVariable`, which
    can assign the HTTP response status code to a separate variable. This is useful
    when combined with the `-``SkipHttpErrorCheck` parameter:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoke-RestMethod` 的参数与 `Invoke-WebRequest` 相似。我们可以在 *表 7.2* 中总结它们。如我们所见，`Invoke-WebRequest`
    有 `-HttpVersion` 参数，该参数在 PowerShell 7.3 中引入，而 `Invoke-RestMethod` 没有；`Invoke-RestMethod`
    有一些处理相对链接的参数（`-FollowRelLink` 和 `-MaximumFollowRelLink`）以及 `-StatusCodeVariable`，该参数可以将
    HTTP 响应状态码分配给一个单独的变量。当与 `-SkipHttpErrorCheck` 参数结合使用时非常有用：'
- en: '![](img/Table_02_A.jpg)![](img/Table_02_B.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_02_A.jpg)![](img/Table_02_B.jpg)'
- en: Table 7.2 – The parameters of Invoke-WebRequest and Invoke-RestMethod, compared
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2 – 比较 Invoke-WebRequest 和 Invoke-RestMethod 的参数
- en: There are some minor differences in a couple of the parameters, for example,
    the `Invoke-RestMethod -Uri` parameter can also accept `file:` and `ftp:` schemes,
    as well as `http:` and `https:`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有些参数之间有一些小的差异，例如，`Invoke-RestMethod -Uri` 参数也可以接受 `file:` 和 `ftp:` 协议，以及 `http:`
    和 `https:` 协议。
- en: To really get to grips with `Invoke-RestMethod` though, we need to understand
    the content that we are retrieving when we use it. To do that, let’s take a closer
    look at the most common data format, JSON.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正掌握 `Invoke-RestMethod`，我们需要了解使用它时检索的内容。为了做到这一点，让我们仔细看看最常见的数据格式，JSON。
- en: Working with JSON
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 JSON
- en: 'What is JSON? First of all, it’s *not* a language; it’s a data format. While
    it has JavaScript in the name, it is used by many modern languages to generate,
    parse, and exchange data. It is also intended to be human-readable; we just have
    to know how to read it. JSON stores data in a dictionary-like format of key-value
    pairs. The first term is the key, and the second term is the value. The key is
    a string, and the value may be another string, a Boolean, a number, an array,
    or a JSON object. A JSON object consists of one or more key-value pairs, so because
    the value can be another object, JSON objects can be nested. Let’s type the cmdlet:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 JSON？首先，它*不是*一种语言；它是一种数据格式。虽然它的名字中有 JavaScript，但许多现代语言都使用它来生成、解析和交换数据。它还旨在便于人类阅读；我们只需要知道如何读取它。JSON
    以类似字典的格式存储数据，使用键值对。第一个术语是键，第二个术语是值。键是字符串，值可以是另一个字符串、布尔值、数字、数组或 JSON 对象。JSON 对象由一个或多个键值对组成，因此因为值可以是另一个对象，JSON
    对象可以是嵌套的。让我们输入 cmdlet：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then, we get something like the following JSON response.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将得到类似以下的 JSON 响应。
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This consists of two key-value pairs:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这由两个键值对组成：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the first pair, `fileSizeBytes` is the key, and the value is `176601`, which
    is fairly obviously the file size, in bytes. The second pair has a key of `url`,
    and the value is the URL that follows. The key and the value are separated by
    a colon (`:`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个键值对中，`fileSizeBytes` 是键，值是 `176601`，显然是文件的大小，单位是字节。第二个键值对的键是 `url`，值是随后的
    URL。键和值由冒号 (`:`) 分隔。
- en: 'Both pairs are enclosed in a single set of braces (`{}`). The braces tell us
    that this is a single object consisting of the enclosed pairs. The pairs in an
    object are separated by a comma (`,`). There is no comma after the last pair in
    an object. If we wanted to include an array, we would enclose it in square brackets.
    Let’s write one that describes a well-known television character. Open VS Code,
    create a new file, and save it as something appropriate, such as `C:\temp\poshbook\ch7\enterprise.json`.
    Then, type the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 两个键值对都被包围在一对大括号 (`{}`) 中。大括号告诉我们这是一个由所包含的键值对组成的单一对象。对象中的键值对由逗号 (`,`) 分隔。对象中的最后一对键值对后没有逗号。如果我们想包含一个数组，则需要将其用方括号括起来。接下来，让我们编写一个描述著名电视角色的
    JSON。打开 VS Code，创建一个新文件，并将其保存为适当的文件名，例如 `C:\temp\poshbook\ch7\enterprise.json`。然后，输入以下内容：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The following figure shows how it should look in VS Code. It’s a valid JSON
    file and demonstrates the valid JSON data types and syntax.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了在 VS Code 中的显示效果。这是一个有效的 JSON 文件，展示了有效的 JSON 数据类型和语法。
- en: '![Figure 7.11 – To boldly demonstrate JSON](img/B17600_07_011.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – 大胆展示 JSON](img/B17600_07_011.jpg)'
- en: Figure 7.11 – To boldly demonstrate JSON
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 大胆展示 JSON
- en: '`Name` and `Designation` contain string values, `Captain` contains another
    JSON object, and `BridgeCrew` contains an array of strings (but it could be an
    array of other valid data types, or even of more JSON objects). Obviously, it
    has no `JediName`, and it is definitely awesome.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Name` 和 `Designation` 包含字符串值，`Captain` 包含另一个 JSON 对象，而 `BridgeCrew` 包含一个字符串数组（但它也可以是其他有效数据类型的数组，甚至是更多
    JSON 对象的数组）。显然，它没有 `JediName`，并且它确实非常棒。'
- en: As we can see, VS Code can parse JSON and help us ensure our syntax is correct
    through color coding.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，VS Code 可以解析 JSON，并通过颜色编码帮助我们确保语法正确。
- en: 'There are a few other points to remember. First of all, whitespace between
    elements is ignored; `"Initial": "T"` is as valid as `"Initial": "T"`. Do everyone
    a favor by being consistent with how you use whitespace, though. Secondly, there
    is no particular number format. `240000000` is not an integer or a floating-point
    value; it’s just a number. Finally, there is no provision for comments within
    JSON; this should encourage us to write clear and descriptive code.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '还有一些其他要记住的事项。首先，元素之间的空白会被忽略；`"Initial": "T"` 和 `"Initial": "T"` 同样有效。不过，建议你保持一致地使用空白字符。其次，没有特定的数字格式。`240000000`
    既不是整数，也不是浮动点数，它只是一个数字。最后，JSON 中不允许有注释；这应该鼓励我们编写清晰和描述性的代码。'
- en: Now we have a reasonable understanding of what JSON is, how can we use it in
    PowerShell? PowerShell doesn’t work with JSON the way it does with XML, so we
    need to be able to convert our JSON data into a custom PowerShell object and convert
    PowerShell objects into JSON. There are a pair of cmdlets that can do this for
    us, `ConvertFrom-Json` and `ConvertTo-Json`. Let’s look at `ConvertFrom-Json`
    first.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 JSON 有了基本的理解，那么我们如何在 PowerShell 中使用它呢？PowerShell 处理 JSON 的方式不同于处理 XML，因此我们需要将
    JSON 数据转换为自定义 PowerShell 对象，并将 PowerShell 对象转换为 JSON。有一对 cmdlet 可以帮我们完成这项工作，`ConvertFrom-Json`
    和 `ConvertTo-Json`。让我们先看看 `ConvertFrom-Json`。
- en: ConvertFrom-Json
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ConvertFrom-Json
- en: '`ConvertFrom-Json` will parse JSON content from a location and turn it into
    a custom PSObject. Let’s see how it works.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConvertFrom-Json` 会解析来自某个位置的 JSON 内容，并将其转换为自定义 PSObject。让我们看看它是如何工作的。'
- en: 'Open a PowerShell console and try getting the content using the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 PowerShell 控制台并尝试使用以下命令获取内容：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see from the following figure, we can import the content fine, but
    if we use `Get-Member`, we can see we have imported that content as a string:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从下图中可以看到，我们可以正常导入内容，但如果使用 `Get-Member`，我们可以看到我们将内容作为字符串导入：
- en: '![Figure 7.12 – Importing JSON with Get-Content alone](img/B17600_07_012.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 使用 Get-Content 单独导入 JSON](img/B17600_07_012.jpg)'
- en: Figure 7.12 – Importing JSON with Get-Content alone
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 使用 Get-Content 单独导入 JSON
- en: 'Turning the data held in the JSON file into a string is going to make it difficult
    to use and manipulate. Now, let’s try using `ConvertFrom-Json`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JSON 文件中保存的数据转换为字符串会使得其使用和操作变得困难。现在，让我们尝试使用 `ConvertFrom-Json`：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This time, we’ve imported it as a custom PSObject, which is much more useful.
    Doing it this way creates an object with properties corresponding to the key-value
    pairs contained in the JSON, which we can then access the same way as we can with
    the properties of any other PowerShell object, as in the following figure:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们已经将其导入为一个自定义 PSObject，这样更有用。通过这种方式创建的对象具有与 JSON 中的键值对相对应的属性，我们可以像访问任何其他
    PowerShell 对象的属性一样访问它们，如下图所示：
- en: '![Figure 7.13 – Importing JSON with ConvertFrom-Json](img/B17600_07_013.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – 使用 ConvertFrom-Json 导入 JSON](img/B17600_07_013.jpg)'
- en: Figure 7.13 – Importing JSON with ConvertFrom-Json
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 使用 ConvertFrom-Json 导入 JSON
- en: Let’s take a closer look at the `ConvertFrom-Json` cmdlet.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看 `ConvertFrom-Json` cmdlet。
- en: '`ConvertFrom-Json` is a simple cmdlet that hides a lot of complicated work.
    As we’ve seen, we can use it to convert a JSON string into a custom PSObject.
    We can also use it to create an ordered hashtable from a JSON string; this is
    necessary because JSON allows duplicate key names, where only the case of the
    string may be different. Because PowerShell is case-insensitive, only the last
    key-value pair would be converted; instead, `ConvertFrom-Json` throws an error.
    The other reason is that JSON allows keys that are empty strings; this would lead
    to a PSObject with a property name that is an empty string, which isn’t allowed.
    See the following figure for examples of these errors:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConvertFrom-Json` 是一个简单的 cmdlet，它隐藏了许多复杂的工作。正如我们所看到的，我们可以使用它将 JSON 字符串转换为自定义
    PSObject。我们还可以使用它从 JSON 字符串创建有序的哈希表；这是必要的，因为 JSON 允许重复的键名，其中只有字符串的大小写可能不同。由于 PowerShell
    对大小写不敏感，因此只有最后一个键值对会被转换；否则，`ConvertFrom-Json` 会抛出一个错误。另一个原因是 JSON 允许键为空字符串；这将导致一个属性名为空字符串的
    PSObject，这是不允许的。请参见下图中的这些错误示例：'
- en: '![Figure 7.14 – Reasons to use the -AsHashtable parameter](img/B17600_07_014.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – 使用 `-AsHashtable` 参数的原因](img/B17600_07_014.jpg)'
- en: Figure 7.14 – Reasons to use the -AsHashtable parameter
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 使用 `-AsHashtable` 参数的原因
- en: 'Let’s look at the parameters:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一下这些参数：
- en: '`-AsHashtable` will convert the JSON string into an ordered hashtable, which
    preserves the ordering of the JSON keys. We looked at ordered hashtables in [*Chapter
    4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell Variables and Data Structures*.
    While not as useful as a PSObject, ordered hashtables are easier to work with
    than strings, and in some circumstances are faster to process than a PSObject.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-AsHashtable` 会将 JSON 字符串转换为有序哈希表，从而保留 JSON 键的顺序。我们在 [*第 4 章*](B17600_04.xhtml#_idTextAnchor071)，*PowerShell
    变量与数据结构* 中讨论了有序哈希表。尽管它不像 PSObject 那样有用，但有序哈希表比字符串更易于操作，在某些情况下，处理速度也比 PSObject
    更快。'
- en: '`-Depth` allows us to set the maximum depth of nesting that we will process;
    as we saw at the start of this section, JSON key-value pairs can contain JSON
    objects, which in turn can contain further JSON objects. The default value of
    `-Depth` is `1024`.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Depth` 允许我们设置要处理的最大嵌套深度；正如我们在本节开始时所看到的，JSON 的键值对可以包含 JSON 对象，而这些 JSON 对象又可以包含进一步的
    JSON 对象。`-Depth` 的默认值是 `1024`。'
- en: '`-InputObject` only accepts strings; either the string itself, a variable that
    contains a string, or an expression that generates a string, as we saw in the
    `enterprise.json` example previously. We can’t pass a file to it directly; we
    need to get the file content first using `Get-Content`. Obviously, it accepts
    pipeline input.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-InputObject` 只接受字符串；可以是字符串本身、包含字符串的变量，或者是生成字符串的表达式，正如我们之前在 `enterprise.json`
    示例中所看到的。我们不能直接将文件传递给它；我们需要先使用 `Get-Content` 获取文件内容。显然，它接受管道输入。'
- en: '`-NoEnumerate` will read an array of strings as a single string, resulting
    in a single output object. Consider the example in the following figure:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-NoEnumerate` 会将一个字符串数组读取为单个字符串，从而产生一个单一的输出对象。请看以下图示的示例：'
- en: '![Figure 7.15 – Using the -NoEnumerate parameter](img/B17600_07_015.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.15 – 使用 `-NoEnumerate` 参数](img/B17600_07_015.jpg)'
- en: Figure 7.15 – Using the -NoEnumerate parameter
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – 使用 `-NoEnumerate` 参数
- en: In the first cmdlet, we get three separate objects. When we include the `-NoEnumerate`
    parameter, we get a single object, `fish` `cat dog`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个 cmdlet 中，我们得到三个独立的对象。当我们包含 `-NoEnumerate` 参数时，我们得到一个单一对象，`fish` `cat dog`。
- en: Now we’ve seen how to convert JSON into a format that PowerShell can easily
    work with, let’s look at how we can convert PowerShell objects into JSON.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何将 JSON 转换为 PowerShell 容易处理的格式，让我们来看一下如何将 PowerShell 对象转换为 JSON。
- en: ConvertTo-Json
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ConvertTo-Json
- en: '`ConvertTo-Json` will take any PowerShell object and convert it into a JSON-formatted
    string. It does this by converting the properties of the object into key-value
    pairs, where the property name is the key, and discarding any methods the object
    has. Let’s see it working. If you didn’t create the `$starship` variable as a
    PSObject previously, do so now:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConvertTo-Json` 会将任何 PowerShell 对象转换为 JSON 格式的字符串。它通过将对象的属性转换为键值对来实现这一点，其中属性名是键，并且会丢弃对象的任何方法。我们来看看它是如何工作的。如果你之前没有将
    `$starship` 变量创建为 PSObject，请现在创建：'
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let’s say we’ve been in a battle, and need to update our photon torpedo
    count. We can type the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们经历了一场战斗，需要更新我们的光子鱼雷数量。我们可以输入以下命令：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will update it on the PSObject, and then we use `ConvertTo-Json` to produce
    a JSON-formatted object to replace the original that we imported:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新PSObject，然后我们使用`ConvertTo-Json`生成一个JSON格式的对象来替换我们导入的原始对象：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we open that in VS Code, we can see that it is a correctly formatted JSON
    file with the updated torpedo count:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在VS Code中打开它，我们可以看到它是一个格式正确的JSON文件，并且更新了鱼雷的数量：
- en: '![Figure 7.16 – After a Klingon attack](img/B17600_07_016.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图7.16 – 克林贡攻击后](img/B17600_07_016.jpg)'
- en: Figure 7.16 – After a Klingon attack
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 – 克林贡攻击后
- en: We can see in line 16 that the torpedo count has changed. VS Code still sees
    this as valid JSON with no errors. We can see the formatting has changed from
    the original file; each element of the `BridgeCrew` array is on its own line because
    of the formatting rules that `ConvertTo-Json` uses, but other than that it’s the
    same as the original `enterprise.json` file. We could then feed this JSON string
    to an API to update the information on a server.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在第16行，鱼雷的数量发生了变化。VS Code仍然认为这是有效的JSON，且没有任何错误。我们可以看到格式与原始文件有所不同；`BridgeCrew`数组的每个元素都被放在了各自的行上，这是因为`ConvertTo-Json`使用的格式化规则，但除此之外，它与原始的`enterprise.json`文件是一样的。然后我们可以将这个JSON字符串传递给API来更新服务器上的信息。
- en: 'Like `ConvertFrom-Json`, `ConvertTo-Json` is a deceptively simple cmdlet that
    hides a lot of work behind a short list of parameters. Let’s take a look at them:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ConvertFrom-Json`类似，`ConvertTo-Json`是一个看似简单的cmdlet，它背后隐藏了很多工作，虽然它的参数列表很短。让我们来看一下这些参数：
- en: '`-AsArray` will convert a PSObject into a JSON array unconditionally. Consider
    the following examples in the following figure.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-AsArray`会无条件地将PSObject转换为JSON数组。请参考下图中的以下示例。'
- en: '![Figure 7.17 – The -AsArray parameter](img/B17600_07_017.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图7.17 – -AsArray 参数](img/B17600_07_017.jpg)'
- en: Figure 7.17 – The -AsArray parameter
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17 – -AsArray 参数
- en: In the first line, I’m converting two strings into JSON. `ConvertTo-Json` automatically
    treats them as an array and puts them in square brackets because they are two
    separate objects. In the second line, I’m only feeding a single string into the
    pipeline, and `ConvertTo-Json` treats it as a single string. But what if I want
    it to be formatted as a single-member array? Then, I use the `-AsArray` parameter,
    and I get my square brackets.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一行，我将两个字符串转换为JSON。`ConvertTo-Json`会自动将它们当作数组处理，并将其放入方括号中，因为它们是两个独立的对象。在第二行，我仅传入一个字符串到管道中，`ConvertTo-Json`将其视为一个单独的字符串。但如果我想将它格式化为单一成员的数组呢？这时，我使用`-AsArray`参数，就可以得到我的方括号。
- en: '`-Compress` removes whitespace and indented formatting from the JSON output.
    The output will be on a single line.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Compress`会从JSON输出中移除空白字符和缩进格式。输出将呈现为单行。'
- en: '`-Depth` specifies how many levels of nested objects can be included in the
    JSON output. We can have between zero and one hundred levels of nesting, but the
    default is a miserly two levels, which can catch people out. We get a warning
    if our output has more than this level. Consider the JSON in the following figure:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Depth`指定JSON输出中可以包含的嵌套对象的级别。我们可以有零到一百级的嵌套，但默认情况下只有两个级别，这可能会让人困惑。如果输出的嵌套层级超过这个限制，我们将收到警告。请参考下图中的JSON：'
- en: '![Figure 7.18 – nesting.json](img/B17600_07_018.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图7.18 – nesting.json](img/B17600_07_018.jpg)'
- en: Figure 7.18 – nesting.json
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18 – nesting.json
- en: 'If we ingest it into a variable, then convert it back into JSON, and then we
    get the warning in the following figure. Notice that the third level of nesting,
    on the line beginning with `"really?"`, is not converted into a JSON object, but
    into a string representing a hashtable:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将其加载到一个变量中，然后再转换回JSON，接着会看到如下图所示的警告。请注意，第三层嵌套（从`"really?"`开始的那一行）没有被转换成JSON对象，而是转换成了一个表示哈希表的字符串：
- en: '![Figure 7.19 – We need to increase -Depth](img/B17600_07_019.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图7.19 – 我们需要增加 -Depth](img/B17600_07_019.jpg)'
- en: Figure 7.19 – We need to increase -Depth
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19 – 我们需要增加 -Depth
- en: '`-EnumsAsStrings` will convert all the values of the `DayOfWeek` property of
    a `DateTime` object. When we type `(Get-Date).DayOfWeek`, it returns a string,
    `Saturday`, but the value is actually held as an integer between 1 and 7\. Have
    a look at the example in the following figure:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-EnumsAsStrings`会转换`DateTime`对象的`DayOfWeek`属性的所有值。当我们输入`(Get-Date).DayOfWeek`时，它返回一个字符串`Saturday`，但实际值是作为介于1到7之间的整数存储的。请看下图中的示例：'
- en: '![Figure 7.20 - Using the -EnumAsStrings parameter](img/B17600_07_020.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图7.20 - 使用 -EnumAsStrings 参数](img/B17600_07_020.jpg)'
- en: Figure 7.20 - Using the -EnumAsStrings parameter
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20 - 使用 -EnumAsStrings 参数
- en: '`-EscapeHandling` controls how certain characters are escaped, such as the
    newline character (`` `n ``). There are three possible settings – `Default`, where
    only control characters are escaped, `EscapeNonAscii`, where all non-ASCII and
    control characters are escaped, and `EscapeHtml`, where special HTML characters
    such as `<`, `>`, `?`, `&`, `''`, and `"` are escaped.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-EscapeHandling` 控制某些字符的转义方式，如换行符（`` `n ``）。它有三种可能的设置：`Default`，只有控制字符被转义；`EscapeNonAscii`，所有非ASCII和控制字符都会被转义；`EscapeHtml`，特殊的HTML字符如`<`、`>`、`?`、`&`、`''`
    和 `"` 会被转义。'
- en: '`-InputObject` accepts any type of PowerShell object explicitly or via the
    pipeline, as an expression, or as a variable.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-InputObject` 接受任何类型的PowerShell对象，无论是显式传递、通过管道传递，作为表达式，还是作为变量。'
- en: Most of these parameters are formatting controls intended to make it easier
    to work with APIs, which may have different expectations of the input we give
    them. There is one more command that helps us get our data into a format that
    can be consumed by an API; `Test-Json`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些大多数参数都是格式控制，旨在让我们更容易地与API进行交互，因为API可能对我们提供的输入有不同的期望。还有一个命令可以帮助我们将数据转换为API能够处理的格式；`Test-Json`。
- en: Test-Json
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Test-Json
- en: 'The `Test-Json` cmdlet will test the validity of a string as a JSON object.
    This is extremely useful when writing scripts to work with APIs to make sure our
    data can be consumed correctly. It is especially useful when we consider that
    not everything we produce with `ConvertTo-Json` is necessarily good JSON. Consider
    the examples in the following figure:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Test-Json` cmdlet将测试一个字符串是否为有效的JSON对象。这在编写与API交互的脚本时非常有用，可以确保我们的数据可以被正确地处理。尤其当我们考虑到并非所有通过`ConvertTo-Json`生成的内容都是合格的JSON时，它就显得特别有用。请参阅下图中的示例：'
- en: '![Figure 7.21 – Getting things wrong with ConvertTo-Json](img/B17600_07_021.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.21 – 使用ConvertTo-Json时出现错误](img/B17600_07_021.jpg)'
- en: Figure 7.21 – Getting things wrong with ConvertTo-Json
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21 – 使用ConvertTo-Json时出现错误
- en: 'In the first line, we create a variable called `$date` and put the current
    date in it. This is an object of the `DateTime` type. Unsurprisingly, when we
    try the cmdlet in line 2, `Test-Json` is unhappy. In line 3, we convert the expression
    into JSON using `ConvertTo-Json`, and then test it again in line 4\. Horror! Although
    it has been converted successfully, it’s still not compliant JSON. In line 5,
    we can try testing just the string output from line 3, and we can see what the
    problem is. While `ConvertTo-Json` has taken the value from the `$date` variable,
    it hasn’t formatted it correctly as a string. When we correct the formatting in
    line 6, we can see that `Test-Json` is now happy. The clever way to do it, of
    course, is like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们创建了一个名为`$date`的变量，并将当前日期放入其中。它是一个`DateTime`类型的对象。毫不奇怪，当我们在第二行尝试使用cmdlet时，`Test-Json`不满意。第三行中，我们使用`ConvertTo-Json`将表达式转换为JSON，然后在第四行再次测试它。糟糕！虽然它已经成功转换，但仍然不是符合规范的JSON。在第五行，我们可以尝试仅测试第三行的字符串输出，这样我们就能看到问题所在。虽然`ConvertTo-Json`已经从`$date`变量中获取了值，但它并没有正确地将其格式化为字符串。当我们在第六行纠正格式后，我们可以看到`Test-Json`现在满意了。聪明的做法当然是这样的：
- en: '![Figure 7.22 – The right way to do it](img/B17600_07_022.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.22 – 正确的做法](img/B17600_07_022.jpg)'
- en: Figure 7.22 – The right way to do it
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22 – 正确的做法
- en: There are a couple of parameters with `Test-Json` that allow us to define custom
    JSON schemas if we need to produce specialized or custom JSON for particular systems,
    but we don’t need to go into them here. One interesting quirk of the cmdlet is
    that the `-InputObject` parameter found on almost all cmdlets is called `-Json`
    here, but functionally it is the same; it takes a string, either explicitly or
    via the pipeline.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Test-Json` 有几个参数允许我们定义自定义的JSON模式，如果我们需要为特定系统生成专门或定制的JSON，但这里不需要详细讨论它们。这个cmdlet有一个有趣的怪癖，即几乎所有cmdlet都有的`-InputObject`参数在这里叫做`-Json`，但功能上是一样的；它接受一个字符串，既可以显式传递，也可以通过管道传递。'
- en: Let’s have some fun – who is on the International Space Station?
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来点乐趣 – 谁在国际空间站上？
- en: Since I was small, I have been fascinated by space. One of my earliest memories
    is sitting up with my mam and dad to watch an Apollo moon landing on a creaky
    old black and white television. It wasn’t Apollo 11\. I’m not quite that old.
    As an exercise, let’s see whether we can find out who is on the ISS, and present
    that data on a web page. We’ll need to refer to some of the stuff we learned about
    in the last chapter to accomplish this; [*Chapter 6*](B17600_06.xhtml#_idTextAnchor117),
    *PowerShell and Files – Reading, Writing, and Manipulating Data*, as well as what
    we’ve learned in this chapter. We’re not going to walk through it – try and accomplish
    this on your own. There are lots of ways to do this, and I’ve put my solution
    in the answers. Here are some hints though.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从小到大，我一直对太空充满了兴趣。我的其中一个最早的记忆是和爸爸妈妈一起坐着看阿波罗月球登陆的画面，那时的电视是老旧的黑白电视。那不是阿波罗11号，我还没那么老。作为一个练习，看看我们能否找出当前在国际空间站上的宇航员，并将这些数据展示在一个网页上。为了完成这个任务，我们需要参考上一章的内容；[*第六章*](B17600_06.xhtml#_idTextAnchor117)，*PowerShell与文件——读取、写入和操作数据*，以及我们在本章中学到的内容。我们不会手把手讲解——试着自己完成这个任务。有很多种方法可以实现，我把我的解答放在了答案部分。不过这里有一些提示。
- en: Activity
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 活动
- en: 'We can break this down into two tasks:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任务分解为两个部分：
- en: Task 1 – use an API to find out who is on the ISS, right now
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 任务 1 – 使用API查看当前谁在国际空间站
- en: Task 2 – display this data in an HTML file
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 任务 2 – 在HTML文件中展示这些数据
- en: There is an API with the data we require at [http://api.open-notify.org/astros.json](http://api.open-notify.org/astros.json)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需的数据可以通过一个API获取，链接是[http://api.open-notify.org/astros.json](http://api.open-notify.org/astros.json)
- en: You could use `Invoke-WebRequest`, but it’s probably easier to use `Invoke-RestMethod`
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Invoke-WebRequest`，但使用`Invoke-RestMethod`可能会更简单
- en: You will probably want to use `ConvertTo-Html` to produce the web page. You
    may need to study the help file for this cmdlet to understand some of the formatting
    options.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会希望使用`ConvertTo-Html`来生成网页。你可能需要查阅这个cmdlet的帮助文件，了解一些格式化选项。
- en: 'Here’s my finished attempt:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的最终尝试：
- en: '![Figure 7.23 – Just beautiful](img/B17600_07_023.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.23 – 真是美丽](img/B17600_07_023.jpg)'
- en: Figure 7.23 – Just beautiful
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23 – 真是美丽
- en: This should stretch us a little bit, but we’ve got all the knowledge we need
    to get this done and have some fun along the way.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将稍微挑战我们，但我们拥有完成这个任务所需的所有知识，并且可以在这个过程中享受乐趣。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve come on a bit of a journey in this chapter and started to interact with
    the world outside our local machines. The techniques we covered will be used throughout
    the book, so we will get plenty of opportunity to become properly familiar with
    them.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经走了一段旅程，并开始与我们本地计算机之外的世界进行互动。我们所讨论的技巧将在全书中使用，因此我们将有充足的机会充分熟悉它们。
- en: We started out by looking at how we can work with HTML data over HTTP using
    the `Invoke-WebRequest` cmdlet. We saw that this is a complex cmdlet with many
    options, and we covered the parameters frequently used with it. We focused on
    authentication, as this will be a key technique required for retrieving and posting
    data. We also saw that it is difficult to manipulate the data we ingest using
    this cmdlet, as it is text-based.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看了如何使用`Invoke-WebRequest` cmdlet来处理通过HTTP传输的HTML数据。我们发现这个cmdlet非常复杂，有很多选项，我们讲解了常用的参数。我们特别关注了身份验证，因为这是获取和发布数据时必须掌握的关键技巧。我们还发现，通过这个cmdlet处理获取的数据非常困难，因为它是基于文本的。
- en: We then talked about an easier way to ingest data from servers over a network,
    using an API. We discussed the common types of API, in particular the most common,
    REST APIs.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们讨论了从服务器通过网络获取数据的一种更简单的方法——使用API。我们讨论了常见的API类型，尤其是最常见的REST API。
- en: We then looked at the PowerShell cmdlet for working with REST – `Invoke-RestMethod`.
    We saw how similar this cmdlet is to `Invoke-WebRequest`, but that instead of
    producing a page of HTML, it outputs data in a structured format.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们了解了用于处理REST的PowerShell cmdlet——`Invoke-RestMethod`。我们发现这个cmdlet与`Invoke-WebRequest`非常相似，但它输出的是结构化的数据，而不是HTML页面。
- en: We went on to explore the most common format for this data, JSON. We looked
    at the three cmdlets in PowerShell for working with JSON data; `ConvertFrom-Json`,
    `ConvertTo-Json`, and `Test-Json`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着探讨了这种数据最常见的格式——JSON。我们看了PowerShell中三个用于处理JSON数据的cmdlet：`ConvertFrom-Json`、`ConvertTo-Json`
    和 `Test-Json`。
- en: Finally, we used our new knowledge to produce an HTML web page displaying the
    names of the astronauts currently on board the ISS.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们利用新学的知识，制作了一个HTML网页，展示了当前在国际空间站上航天员的名字。
- en: This chapter marks the end of the coding fundamentals section of this book;
    we’ve covered data structures, flow control, file manipulation, and connecting
    to the internet. In the next chapter, we are going to start looking at turning
    our lines of scruffy code into scripts and tools that we can share with other
    people. It’ll be fun.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本章标志着本书编码基础部分的结束；我们已经涵盖了数据结构、流程控制、文件操作和连接互联网。在下一章中，我们将开始学习如何将我们杂乱无章的代码转化为脚本和工具，这些脚本和工具可以与他人共享。一定会很有趣。
- en: Exercises
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'How would we send a delete request to the following URL: `https://httpbin.org/delete`?'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何向以下 URL 发送删除请求：`https://httpbin.org/delete`？
- en: What parameters would we need to use `Invoke-WebRequest` with a stateful endpoint?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在有状态端点上使用`Invoke-WebRequest`时，我们需要哪些参数？
- en: 'We try to connect to a website and see the following error:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们尝试连接一个网站并看到以下错误：
- en: '[PRE18]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Which type of API is stateful? What does this mean?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种类型的 API 是有状态的？这是什么意思？
- en: 'We sign up to a web service and get an authentication token. We encode the
    token using `ConvertTo-SecureString`, store it in a variable called `$token`,
    and then use the variable to create a web request like this:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们注册一个 Web 服务并获得认证令牌。我们使用`ConvertTo-SecureString`对令牌进行编码，将其存储在名为`$token`的变量中，然后使用该变量创建一个
    Web 请求，如下所示：
- en: '[PRE19]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We get an authentication error. Have we done something wrong, or is the token
    bad?
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们遇到了认证错误。我们做错了什么，还是令牌有问题？
- en: Get the latitude and longitude of the ISS right now. You can use [http://api.open-notify.org/iss-now.json](http://api.open-notify.org/iss-now.json).
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取国际空间站（ISS）当前的纬度和经度。你可以使用[http://api.open-notify.org/iss-now.json](http://api.open-notify.org/iss-now.json)。
- en: How many universities in the UK have the letter ‘*x*’ in their name? Use the
    API at [http://universities.hipolabs.com/search?country=United+Kingdom](http://universities.hipolabs.com/search?country=United+Kingdom)
    to find out.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 英国有多少所大学的名字中含有字母‘*x*’？使用[http://universities.hipolabs.com/search?country=United+Kingdom](http://universities.hipolabs.com/search?country=United+Kingdom)的
    API 来查找答案。
- en: How can we use `Test-Json` to validate our generated JSON against a custom schema?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用`Test-Json`来验证我们生成的 JSON 是否符合自定义模式？
- en: Further reading
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'More on APIs here:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 API 的内容：
- en: '[https://www.packtpub.com/product/understanding-apis-and-restful-apis-crash-course-video/9781800564121](https://www.packtpub.com/product/understanding-apis-and-restful-apis-crash-course-video/9781800564121)'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/product/understanding-apis-and-restful-apis-crash-course-video/9781800564121](https://www.packtpub.com/product/understanding-apis-and-restful-apis-crash-course-video/9781800564121)'
- en: '[https://www.digitalfluency.guide/apis/introduction-to-apis](https://www.digitalfluency.guide/apis/introduction-to-apis)'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.digitalfluency.guide/apis/introduction-to-apis](https://www.digitalfluency.guide/apis/introduction-to-apis)'
- en: 'Lots more on REST here:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 REST 的内容：
- en: '[https://restfulapi.net/](https://restfulapi.net/)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://restfulapi.net/](https://restfulapi.net/)'
- en: 'A good JSON tutorial, but with some JavaScript:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一份不错的 JSON 教程，但包含了一些 JavaScript：
- en: '[https://www.w3schools.com/js/js_json_intro.asp](https://www.w3schools.com/js/js_json_intro.asp)'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.w3schools.com/js/js_json_intro.asp](https://www.w3schools.com/js/js_json_intro.asp)'
- en: 'How to use JSON schemas:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 JSON 模式：
- en: '[https://json-schema.org/understanding-json-schema](https://json-schema.org/understanding-json-schema)'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://json-schema.org/understanding-json-schema](https://json-schema.org/understanding-json-schema)'
- en: 'Part 2: Scripting and Toolmaking'
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：脚本编写与工具制作
- en: This part walks you through turning a set of cmdlets into a script, introduces
    functional programming, shows you how to turn scripts into modules, and how to
    share those modules with colleagues and others using GitHub and GitLab. It also
    includes a chapter on PowerShell security, so that you don’t inadvertently distribute
    code that is less secure than it could be.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分将引导你将一组 Cmdlet 转换为脚本，介绍函数式编程，展示如何将脚本转化为模块，以及如何使用 GitHub 和 GitLab 与同事和他人共享这些模块。它还包括一个关于
    PowerShell 安全性的章节，确保你不会无意中分发不够安全的代码。
- en: 'This part has the following chapters:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *Writing Our First Script
    – Turning Simple Cmdlets into Reusable Code*'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B17600_08.xhtml#_idTextAnchor162)，*编写我们的第一个脚本 – 将简单的 Cmdlet 转换为可重用的代码*'
- en: '[*Chapter 9*](B17600_09.xhtml#_idTextAnchor184), *Don’t Repeat Yourself – Functions
    and Scriptblocks*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B17600_09.xhtml#_idTextAnchor184)，*不要重复自己 – 函数和脚本块*'
- en: '[*Chapter 10*](B17600_10.xhtml#_idTextAnchor201), *Error Handling – Oh No!
    It’s Gone Wrong!*'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B17600_10.xhtml#_idTextAnchor201)，*错误处理 – 哎呀！出错了！*'
- en: '[*Chapter 11*](B17600_11.xhtml#_idTextAnchor218), *Creating Our First Module*'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B17600_11.xhtml#_idTextAnchor218)，*创建我们的第一个模块*'
- en: '[*Chapter 12*](B17600_12.xhtml#_idTextAnchor236), *Securing PowerShell*'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B17600_12.xhtml#_idTextAnchor236)，*确保 PowerShell 安全*'
