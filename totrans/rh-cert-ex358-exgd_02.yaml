- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network File Storage – Expanding Your Knowledge of How to Share Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’re going to cover the topics of **Network File Storage**
    (**NFS**) and Samba using **Server Message Block** (**SMB**) storage. These are
    two network-based file-sharing options. One (NFS) is heavily used in Linux, while
    the other is the mainstay of Windows, which is SMB (in our case, Samba). We are
    going to learn how to set up both of these target folders and share them with
    the world. We will go over making sure they are only available to those we are
    attempting to share access with. We will show how we can ensure that unauthorized
    access does not occur – well, to the best of our abilities; people are sneaky.
  prefs: []
  type: TYPE_NORMAL
- en: After we set those up manually, we will work on setting them up through automation
    using Ansible. This can make it extremely easy to set up new servers to access
    file shares that are needed for every new server in an automated fashion. This
    ensures that each new server has the required access without worrying whether
    you forgot to add one of the folders. Automation helps take the headache out of
    system admin work and with Ansible, it is even easier. Let’s get started in the
    world of NFS; it only makes our lives easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: NFS and SMB network storage – the way they work and when to choose one over
    the other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NFS manual provisioning and deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NFS Ansible Automation playbook creation and usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMB storage manual provisioning and deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMB storage Ansible Automation playbook creation and usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers the technical requirements for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GitHub access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please refer to [*Chapter 1*](B18607_01.xhtml#_idTextAnchor016), *Block Storage
    – Learning How to Provision Block Storage on Red Hat Enterprise Linux*, for gaining
    access to GitHub. You will find the Ansible Automation playbooks for this chapter
    at the following link: [https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter02](https://github.com/PacktPublishing/Red-Hat-Certified-Specialist-in-Services-Management-and-Automation-EX358-Exam-Guide/tree/main/Chapter02).
    Remember, these are suggested playbooks and are not the only way you can write
    them to make the playbooks work for you.'
  prefs: []
  type: TYPE_NORMAL
- en: You can always change them up using `raw`, `shell`, or `cmd` to achieve the
    same results, but we are demonstrating the best way to accomplish the goals. Also,
    keep in mind that we are not using the **Fully Qaulified Collection Name** (**FQCN**)
    that is needed in the future version of Ansible, as that will not be supported
    in the exam as it is testing against Ansible 2.9.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your lab environment for NFS and SMB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the setup of the lab environment from [*Chapter 1*](B18607_01.xhtml#_idTextAnchor016),
    *Block Storage – Learning How to Provision Block Storage on Red Hat Enterprise
    Linux*, if not already completed. You can also use this opportunity to create
    snapshots of your environment so that you can revert to them and do the hands-on
    exercises over and over again. This can be accomplished as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Snapshots are easy to create in VirtualBox: you simply need to click on the
    following button that is selected with the mouse cursor to create a snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.1 – VirtualBox options button to open snapshot \uFEFFcreation](img/Figure_2.01_B18607.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – VirtualBox options button to open snapshot creation
  prefs: []
  type: TYPE_NORMAL
- en: 'Click to take one at the top and then name your snapshot. This will allow you
    to determine the state of the machine image when the snapshot was taken. This
    can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – VirtualBox snapshot save feature](img/Figure_2.02_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – VirtualBox snapshot save feature
  prefs: []
  type: TYPE_NORMAL
- en: This will wrap up taking a snapshot in order to revert to previous states for
    repeated hands-on rework. Now, let’s get into the storage wars.
  prefs: []
  type: TYPE_NORMAL
- en: NFS and SMB network storage – the way they work and when to choose one over
    the other
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NFS is a great way to share files across Linux systems. It is machine-based
    authentication so the system can have access to the files for all users. This
    is great for Linux when sharing small files as the speed is increased and the
    system shares are retrieved more efficiently. SMB, on the other hand, is user
    authentication-based and better suited for interactions with Windows computers.
    So, if you have a multivendor environment, it might be worthwhile to set up SMB
    as it has the ability to share printers as well. This allows for file sharing
    as well as printer sharing, thus giving a slight multi-functional edge to the
    system to make up for the slight speed loss.
  prefs: []
  type: TYPE_NORMAL
- en: The differences in authentication make for some differences in setup and can
    lead to some headaches when it comes to making sure you are locking down the right
    permissions. SMB using user-based authentication is a bit better because, with
    NFS, anyone with access to the allowed machine can gain access to the files being
    shared. So, in reality, it is more of a toss-up of what you need, such as security
    or multivendor support in your environment, when it comes to choosing to implement
    either of the two. In most cases, both are actually implemented for different
    system uses.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go into a little more depth on NFS and what it can do for RHEL 8.1 users
    and Linux overall through setting it up hands-on. This will show you how to set
    up NFS manually and through automation. RHEL 8.1 supports NFSv3 and NFSv4\. NFSv3
    can use UDP and TCP, whereas NFSv4 uses TCP. Older versions are no longer supported.
    Let’s set up NFS on our systems.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we are going to install the package needed if it is not already installed.
    This package is the `nfs-utils` package and is needed for the client and the target
    machines. It provides all the tooling to access folders and mount the needed folders.
    By installing it on both the server and client, you ensure that you are able to
    enable all of the dependencies that are needed in order to run the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install `nfs-utils` as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Installing the nfs-utils package](img/Figure_2.03_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Installing the nfs-utils package
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, there is a small caveat that can lead to frustration – trust me, when
    writing this and running into the issue, I was boiling! After a large amount of
    troubleshooting, the current `2.3.3-51.el8` has a bug that will not allow the
    exports to share out correctly and the proper permissions to connect. So, after
    installing NFS, we need to downgrade it one step to `2.3.3-46.el8`, where the
    bug is not present. In the following figure, it is shown being downgraded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Downgrading nfs-utils](img/Figure_2.04_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Downgrading nfs-utils
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to do our hands-on exercises without issue. Before, if you tried
    to do them, you would be banging your head on your keyboard much like I was.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the correct version is installed, we are going to enable the daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to open the firewall to ensure that connectivity is allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we will be configuring the exports, which are what tell the NFS server
    what to allow out to the world. The settings are granular and allow for thorough
    control. The exports allow you to tell the system what can be read and by what
    machines. You can allow specific machines via DNS, IP, IP range, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s make a shared directory as root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will be the folder we share out to the world. Others will access this to
    read and write files. We will be editing the `/etc/exports` file to share out
    this folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of a correctly formatted `exports` file. We will talk
    more about the settings shown in the following screenshot, such as (`rw`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – /etc/exports example file for NFS share folder](img/Figure_2.05_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – /etc/exports example file for NFS share folder
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can export NFS shares via DNS as noted. You can export via
    IP and IP range. You can use space delimited for multiple shared locations if
    you do not wish to stack them. You can also put restraints such as read-only or
    read-write. The `no_root_squash` function allows for root access to the directory
    instead of the `nobody` user being selected. By default, if a root client creates
    a file, the `nobody` user owns that file. This can cause issues with access to
    the file, so it is a good idea to use `no_root_squash`. This gives full root access
    to the files. Please be aware that the preceding is an example, and duplicates
    such as the ones shown will be ignored by NFS.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Correct NFS /etc/exports file](img/Figure_2.06_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Correct NFS /etc/exports file
  prefs: []
  type: TYPE_NORMAL
- en: 'You then need to run `exportfs -r` in order to update the exports so that they
    are served to the endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then check your exports to ensure they are being served with the `exportfs`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Next, we are going to mount the folder on another system so that it can share
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'On RHEL3, we are going to run the `mount` command to mount the filesystem.
    You can also add this to `fstab` to make this permanent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of `fstab` for NFS as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Example of what fstab would look like](img/Figure_2.07_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Example of what fstab would look like
  prefs: []
  type: TYPE_NORMAL
- en: After that, you should be able to go to the folder and add files to share. The
    other systems with access can also see these files.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the walk-through of NFS and how to export it to systems manually.
    This is what you will be tested on in the exam. The bonus mounting of the system
    is for your understanding, and I hope that helps you in the future. Now we are
    going to talk about the automation of the process of NFS server provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: NFS Ansible Automation playbook creation and usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to delve deeper into the Ansible Automation playbook. We will
    fully break it down for the NFS exports. We are going to show each step of the
    playbook and what each item does. By *item*, we are referring to the variables
    and commands set within an Ansible playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the beginning of the playbook. The hosts are the targets of the
    playbook. These are normally the servers you want to make changes to. These are
    listed in the inventory file. In this case, we are targeting the `exports` group.
    In this case, `become` tells Ansible that you want to elevate the user, and `become_method`
    tells it that you want to use `sudo` to elevate the permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now going to move to tasks. These are the actions we want Ansible to
    take. The first task we see here is to create a directory using the file module.
    The `name` field is like a comment for a better understanding of the code by other
    engineers. From there, we see the other items we set, and then there are assumed
    defaults. As mentioned in [*Chapter 1*](B18607_01.xhtml#_idTextAnchor016), *Block
    Storage – Learning How to Provision Block Storage on Red Hat Enterprise Linux*,
    you can use the `ansible-doc` file to see the usage and examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Normally, you would use the latest state; however, in our case, that would cause
    the system to encounter the bug that fails connectivity. It should work fine with
    the latest on the exam though.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this task, we installed the `nfs-utilities` package using the generic package
    installer for Ansible. This uses the facts gathered by Ansible. By using those
    facts, it knows to use `dnf` to install the software:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `copy` module, we are replacing the current `exports` file. If this
    was a multiline exports file, it would need to be a template, `lineinfile`, or
    all lines would need to be in the task. Here, we are using the `service` module
    to enable and start the `nfs-server` service. This will ensure that the service
    is started. The service is enabled upon boot. The service also loads the exports,
    as `nfs-server` is started after the `exports` file was updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `firewalld` module, we are going to allow a permanent opening for
    the NFS file service. This will allow connectivity to the resources we opt to
    share. Once that is complete, the `exports` playbook is completed, and up next
    is the `clients` playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After we have finished creating the playbook, we will use the `ansible-playbook
    -i inventory nfs_server.yml -u emcleroy -k --ask-become –v` command to execute
    the playbook. The flag of `-i` indicates the name of the inventory to use. The
    `-u` flag indicates the username to use when executing the playbook. The `–k`
    flag indicates to ask for the user password. The `--ask-become` flag specifies
    that you want to provide the `sudo` password for the playbook run. Finally, `–v`
    shows additional verbosity so you can see more logs of what is happening when
    the playbook is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will show a quick view of the playbook used to support the client
    setup of utilizing a share that has been set up for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will install `nfs-utilities` and then mount the file to the `/``share folder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the playbook, we will use the following command: `ansible-playbook -i
    inventory nfs_client.yml -u emcleroy -k --ask-become –v`. That wraps up our foray
    into NFS. We will now be moving on to some more network-based file storage. We
    will be discussing SMB, which is most commonly used for Windows systems. We will
    go through setting it up manually and with automation.'
  prefs: []
  type: TYPE_NORMAL
- en: SMB storage manual provisioning and deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The major difference when it comes to SMB is that it is the sharing standard
    for Windows-based systems from Linux systems. The best way to learn about Samba
    (another name for SMB) is to get your hands dirty, and that is what we are going
    to do today. We will be going step by step into how to install and provision SMB.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we are going to install SMB via `dnf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the share for SMB to serve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to start and enable the `smb` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we are going to open the firewall service for Samba:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With SMB now installed and the firewall opened, we can move on to setting up
    the folder we created. This will allow us to set the SELinux permissions needed.
    We are going to give access to administrators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to restrict access to the folder to the `admins` group only.
  prefs: []
  type: TYPE_NORMAL
- en: 'With SELinux in the enforcing mode, it needs the correct context. As shown
    in these commands, the correct context is added back to the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This allows for the label to stay, even during relabeling events within SELinux.
    SELinux context is outside the scope of this class and can be researched further
    online or through other Packt books.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will work on setting up the `smb.conf` file with the correct information
    to allow access to the `share` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, you can see an example of a global Samba config portion and Samba
    share config portion in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Global config for SMB with guests allowed](img/Figure_2.08_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Global config for SMB with guests allowed
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the guests allowed setting for our share, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Guests are allowed as noted in the guest only statement](img/Figure_2.09_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Guests are allowed as noted in the guest only statement
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is an example of having to have a password to access the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – As shown here, guest only is set to no so you need to have
    a user and password](img/Figure_2.10_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – As shown here, guest only is set to no so you need to have a user
    and password
  prefs: []
  type: TYPE_NORMAL
- en: These settings allow for control over your `smb` share.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to start the service and create some users. These users
    and passwords will only be good for the `smb` share. They will not affect the
    login information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are going to start up `smb` so that we can use it for our newly
    created `sambauser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see that `smb` is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – SMB successfully running on the system](img/Figure_2.11_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – SMB successfully running on the system
  prefs: []
  type: TYPE_NORMAL
- en: 'To mount the system, we will have to install `samba-client` on the client machine.
    As shown in the following screenshot, we are installing `samba-client` on `rhel2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – samba-client being installed on rhel2](img/Figure_2.12_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – samba-client being installed on rhel2
  prefs: []
  type: TYPE_NORMAL
- en: 'This will allow us to mount the share on `rhel2`. We need `cifs-utils` installed,
    and then we can mount using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This code and the process will all be available via the **Code in Action** (**CiA**)
    videos that are provided by Packt.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go over setting up a restricted share to a client on a particular
    domain. Then we will show how to define which users/groups have read-only or write
    access. Finally, we will show how to mount permanently using specific user credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with how to set up a restricted share to a client on a particular
    domain. This can be accomplished by setting the security to the `domain` level
    instead of the `user` level. This can be seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to set up a specific group to have read-write and also allow other users
    to have read-only, you would set up the `smb` file for the share to look something
    like the following when `security` is set to `user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file settings will allow `systemadmin1` to have read-only privileges
    and allow the `engineers` group to have read-write privileges, and all others
    will be unable to view the share.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to look at how to set up a permanent mount using CIFS credentials
    and `fstab` in order to mount the share at startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating a CIFS credential file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will have the following body of text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After the file is created, we will use it for login credentials for the mount
    and add the following to `fstab` to mount the share with these credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That wraps up the manual portion of SMB storage. We will now work through the
    templates and other things needed for the automated approach of setting up SMB
    storage. Stay tuned for more great information about this and what we need to
    do to get it working through automation. This will help you with completing the
    EX358 exam as well.
  prefs: []
  type: TYPE_NORMAL
- en: SMB storage Ansible Automation playbook creation and usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be looking at what is needed in order to set up SMB
    shares through Ansible Automation. This will allow for quicker setup across multiple
    servers. This will, in turn, also allow you to spend less time on the keyboard
    and more time focused on what you really want to learn. We have covered the different
    areas of Ansible in depth, from comments to names to modules. We are going to
    go through all of this again for SMB storage and show you how to set it up. This
    again is one way of doing it; there are others with Ansible that will be successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started as we have with all of the other playbooks we have created.
    First, we will choose the inventory hosts and escalation points that we want to
    use. I showed you how to set up the inventory in previous sections so we will
    skip that. However, here is a snapshot of the inventory for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – smb_playbook inventory snapshot](img/Figure_2.13_B18607.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – smb_playbook inventory snapshot
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let’s set up a new directory for the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to start the tasks to set up everything needed for samba.
    First, let’s install it and the client to be thorough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This portion of the code creates the groups that we will use to set allow functions
    on SMB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This portion of the code creates the user with a password for SMB. We will
    have different ways of doing this with loops in the final review, which will allow
    you to vault passwords and lists of users. This is not recommended as everything
    is in plain text. This playbook is an example of one way to accomplish the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This portion of the code adds the group that we are using for SMB to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have created the directory and given the correct SELinux context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have added the information for our `share` folder to the `smb.conf`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This portion of the code enables the SMB service as well as restarting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This portion of the code opens up the necessary firewall rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then run the playbook on the system using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will ask you for your `ssh` password and your `become` password for the
    system. Please ensure that on the Ansible Control node (in our case, `rhel3`),
    `sshpass` is installed in order to avoid password failures. These can be handled
    through Ansible Vault as well or through other password credential systems that
    are out of the scope of this exam.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to show the playbook from the client side so that we can
    mount the new SMB share we created. We are going to create a new playbook as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a file with your credentials. You can also vault this file for
    encryption and use variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the IP address of the server may be different for your lab
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: This will mount the SMB share with the credentials you passed to the file. We
    will explore other ways of doing all of this in the final review with the full
    video in the CiA videos. The CiA videos will display the manual and automated
    code being run and will be placed on Packt’s website.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This brings us to the end of this chapter and network file sharing. We have
    talked about many types of storage up until this point, from iSCSI to SMB. They
    all have one thing in common and that is networking. We will be moving on to introduce
    you to the networking aspect of how these things interconnect in our next chapter.
    We want to ensure that everyone is aware of how RHEL networking is handled, how
    it is different from traditional networking such as Cisco and others, and how
    it can help you. We will go over exam objectives and ensure you know how to connect
    these servers to pass the storage we talked about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Red Hat Linux 8 – Configuring and Maintaining Networking with Automation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will learn to set up and maintain Linux networking functions
    manually and automatically. This will meet the objectives set to pass the Red
    Hat EX358 exam.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B18607_03.xhtml#_idTextAnchor039), *Network Services with Automation
    – Introduction to Red Hat Linux Networking*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B18607_03.xhtml#_idTextAnchor039), *Link Aggregation Creation
    – Creating Your Own Link and Mastering the Networking Domain*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18607_05.xhtml#_idTextAnchor060), *DNS, DHCP, and IP Addressing
    – Gaining Deeper Knowledge of Red Hat Linux Networking*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
