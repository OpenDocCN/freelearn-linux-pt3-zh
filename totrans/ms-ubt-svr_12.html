<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer146">
<h1 class="chapterNumber">12</h1>
<h1 class="chapterTitle" id="_idParaDest-169">Sharing and Transferring Files</h1>
<p class="normal">In the previous chapter, we looked at what’s involved in the process of setting up a few network services, such as DHCP and DNS. Those are two important components of a network, but there are quite a few different types of applications and resources you can make available on your network to further enhance it. A file server is one such example, which can give your users a central place to store critical files and can even enhance collaboration.</p>
<p class="normal">Perhaps you’ve used a file server before, or even set one up on a different platform. With Ubuntu Server, there are multiple methods to not only store files, but also to transfer files from one node to another over a network link. In this chapter, we’ll look into setting up a central file server using both Samba and NFS, as well as how to transfer files between nodes with utilities such as <code class="inlineCode">scp</code> and <code class="inlineCode">rsync</code>. We’ll also go over some situations in which one solution may work better for you than another. As we go through these concepts, we will cover the following topics:</p>
<ul>
<li class="bulletList">File server considerations</li>
<li class="bulletList">Sharing files with Windows users via Samba</li>
<li class="bulletList">Setting up NFS shares</li>
<li class="bulletList">Transferring files with <code class="inlineCode">rsync</code></li>
<li class="bulletList">Transferring files with <code class="inlineCode">scp</code></li>
</ul>
<p class="normal">Before we can get started with configuring our server to enable it to share files with other users, we should first understand what our available options are to enable us to choose the best technology for our use case.</p>
<h1 class="heading-1" id="_idParaDest-170">File server considerations</h1>
<p class="normal">When it comes to setting<a id="_idIndexMarker640"/> up a file server, the process is a matter of setting up some sort of daemon to accept connections and share specific directories, and ensure the appropriate users are able to access those directories. You’ll also implement permissions to determine who can access specific directories, and what type of access they will have (read/write, read-only, and so on). When deciding <em class="italic">how</em> to share<a id="_idIndexMarker641"/> the files, it’s generally a choice between two common technologies<a id="_idIndexMarker642"/><a id="_idIndexMarker643"/> that can facilitate the actual sharing, <strong class="keyWord">Samba</strong> and <strong class="keyWord">NFS</strong>.</p>
<p class="normal">All in all, there’s nothing stopping you from hosting both Samba and NFS shares on a single server. The two technologies can actually co-exist on the same device. However, each of the two popular solutions is more appropriate for particular use cases. Before we get started with setting up our file server, we should first understand the differences between Samba and NFS, so we can make an informed decision as to which one is more appropriate for our environment. As a general rule of thumb, Samba is great for mixed environments (where you have Windows as well as Linux clients), and NFS is more appropriate for use in Linux or Unix environments, but there’s a bit more to it than that.</p>
<p class="normal">Samba is a great solution for many environments, because it allows you to share files with Windows, Linux, and macOS machines. Basically, pretty much everyone will be able to access your shares, provided you give<a id="_idIndexMarker644"/> them permission to do so. The reason this works is because Samba is a re-implementation of the <strong class="keyWord">Server Message Block</strong> (<strong class="keyWord">SMB</strong>) protocol, which is primarily used by Windows systems. However, you don’t need to use the Windows platform in order to be able to access Samba shares, since many platforms offer support for this protocol.</p>
<p class="normal">You may be wondering why I am going to cover two different solutions in this chapter. After all, if Samba shares can be accessed by pretty much everything and everyone, why bother with anything else? Even with Samba’s many strengths, there are weaknesses as well. First of all, permissions are handled very differently, so you’ll need to configure your shares in specific ways in order to prevent access to users that shouldn’t be able to see confidential data. With NFS, full support for standard UNIX permissions is provided, so you’ll only need to configure your permissions once. If permissions and confidentiality are important to you, you may want to look closer at NFS.</p>
<p class="normal">It’s also not accurate to say that Windows systems cannot access NFS shares, because some versions actually can. By default, no version of Windows supports NFS outright, but some editions offer a plugin you can install that enables this support. If you install <strong class="keyWord">Services for NFS</strong>, your installation of Windows<a id="_idIndexMarker645"/> will be able to access NFS shares from that point forward.</p>
<p class="normal">Regarding an all-Linux environment<a id="_idIndexMarker646"/> or a situation where you only have Linux machines that need to access your shares, NFS is a great choice because it integrates much more tightly with the rest of the distribution. Permissions can be more easily enforced and, depending on your hardware, performance may be higher. The specifics of your environment will make your decision for you. Perhaps you’ll choose Samba for your mixed environment, or NFS for your all-Linux environment. Maybe you’ll even set up both NFS and Samba, having shares available for each platform. My recommendation is to learn and practice both, since you’ll use both solutions at one point or another during your career anyway.</p>
<p class="normal">Before you continue to the sections on setting up Samba and NFS, I recommend you first decide where in your filesystem you’d like to act as a parent directory for your file shares. This isn’t actually required, but I think it makes for better organization. There is no one right place to store your shares, but personally I like to create a <code class="inlineCode">/share</code> directory at the <code class="inlineCode">root</code> filesystem and create sub-directories for my network shares within it. For example, I can create <code class="inlineCode">/share/documents</code>, <code class="inlineCode">/share/public</code>, and so on for Samba shares. With regard to NFS, I usually create shared directories within <code class="inlineCode">/exports</code>. You can choose how to set up your directory structure. As you read the remainder of this chapter, make sure to change my example paths to match yours if you use a different style.</p>
<h1 class="heading-1" id="_idParaDest-171">Sharing files with Windows users via Samba</h1>
<p class="normal">In this section, I’ll walk you through<a id="_idIndexMarker647"/> setting up your very own <strong class="keyWord">Samba</strong> file server. I’ll also go<a id="_idIndexMarker648"/> over a sample configuration<a id="_idIndexMarker649"/> to get you started so that you can add your own shares. First, we’ll need to make sure that the <code class="inlineCode">samba</code> package is installed on our server:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install samba 
</code></pre>
<p class="normal">When you install the <code class="inlineCode">samba</code> package, you’ll have a new daemon installed on your server, <code class="inlineCode">smbd</code>. The <code class="inlineCode">smbd</code> daemon will be automatically started and enabled for you. You’ll also be provided with a default configuration file for Samba, located at <code class="inlineCode">/etc/samba/smb.conf</code>. For now, I recommend stopping <code class="inlineCode">samba</code> since we have yet to configure it:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl stop smbd 
</code></pre>
<p class="normal">Since we’re going to configure Samba from scratch, we should start with an empty configuration file. Let’s back up the original<a id="_idIndexMarker650"/> file, rather than overwrite<a id="_idIndexMarker651"/> it. The default file includes some useful notes<a id="_idIndexMarker652"/> and samples, so we should keep it around for future reference:</p>
<pre class="programlisting con"><code class="hljs-con">sudo mv /etc/samba/smb.conf /etc/samba/smb.conf.orig
</code></pre>
<p class="normal">Now, we can begin a fresh configuration. Although it’s not required, I like to split my Samba configuration up between two files, <code class="inlineCode">/etc/samba/smb.conf</code> and <code class="inlineCode">/etc/samba/smbshared.conf</code>. You don’t have to do this, but I think it makes the configuration cleaner and easier to read. First, here is a sample <code class="inlineCode">/etc/samba/smb.conf</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">[global] 
server string = File Server 
workgroup = WORKGROUP 
security = user 
map to guest = Bad User 
name resolve order = host bcast wins 
include = /etc/samba/smbshared.conf 
</code></pre>
<p class="normal">As you can see, this is a really short file. Basically, we’re including only the lines we absolutely need to in order to set up a file server with Samba. Next, I’ll explain each line and what it does.</p>
<pre class="programlisting con"><code class="hljs-con">[global] 
</code></pre>
<p class="normal">With the <code class="inlineCode">[global]</code> stanza, we’re declaring the global section of our configuration, which will consist of settings that will impact Samba as a whole. There will also be additional stanzas for individual shares, which we’ll get to later.</p>
<pre class="programlisting con"><code class="hljs-con">server string = File Server 
</code></pre>
<p class="normal">The <code class="inlineCode">server string</code> is somewhat of a description field for the <code class="inlineCode">File Server</code>. If you’ve browsed networks from Windows computers before, you may have seen this field. Whatever you type here will display underneath the server’s name in Windows Explorer. This isn’t required, but it’s nice to have.</p>
<pre class="programlisting con"><code class="hljs-con">workgroup = WORKGROUP 
</code></pre>
<p class="normal">Here, we’re setting the <code class="inlineCode">workgroup</code>, which is the exact same thing as a <code class="inlineCode">workgroup</code> on Windows PCs. In short, the workgroup<a id="_idIndexMarker653"/> is a namespace that describes<a id="_idIndexMarker654"/> a group of machines. When browsing network<a id="_idIndexMarker655"/> shares on Windows systems, you’ll see a list of workgroups, and then one or more computers within that workgroup. In short, this is a way to logically group your nodes. You can set this to whatever you like. If you already have a workgroup in your organization, you should set it here to match the workgroup names of your other machines. The default workgroup name is simply <code class="inlineCode">WORKGROUP</code> on Windows PCs, if you haven’t customized the workgroup name at all.</p>
<pre class="programlisting con"><code class="hljs-con">security = user 
</code></pre>
<p class="normal">This setting sets up Samba to utilize usernames and passwords for authentication to the server. Here, we’re setting the <code class="inlineCode">security</code> mode to <code class="inlineCode">user</code>, which means we’re using local users to authenticate, rather than other options such as <code class="inlineCode">ads</code> (Active Directory) or <code class="inlineCode">domain</code> (domain controller), which are both outside the scope of this book.</p>
<pre class="programlisting con"><code class="hljs-con">map to guest = Bad User 
</code></pre>
<p class="normal">This option configures Samba to treat unauthenticated users as guest users. Basically, unauthenticated users will still be able to access shares, but they will have guest permissions instead of full permissions. If that’s not something you want, then you can omit this line from your file. Note that if you do omit this, you’ll need to make sure that both your server and client PCs have the same user account names on either side. Ideally, we want to use directory-based authentication, but that’s beyond the scope of this book.</p>
<pre class="programlisting con"><code class="hljs-con">name resolve order = host bcast wins 
</code></pre>
<p class="normal">The <code class="inlineCode">name resolve order</code> setting configures how Samba resolves hostnames. In this case, we’re using the broadcast name first, followed by <code class="inlineCode">wins</code>. Since <code class="inlineCode">wins</code> has been pretty much abandoned (and replaced by DNS), we include it here solely for compatibility with legacy networks.</p>
<pre class="programlisting con"><code class="hljs-con">include = /etc/samba/smbshared.conf 
</code></pre>
<p class="normal">Remember how I mentioned that I usually split my Samba configurations into two different files? On this line, I’m calling that second <code class="inlineCode">/etc/samba/smbshared.conf</code> file. The contents of the <code class="inlineCode">smbshared.conf</code> file will be inserted right here, as if we only had one file. We haven’t created the <code class="inlineCode">smbshared.conf</code> file yet. Let’s take care of that next. Here’s a sample <code class="inlineCode">smbshared.conf</code> file:</p>
<pre class="programlisting con"><code class="hljs-con">[Documents] 
path = /share/documents 
force user = myuser 
force group = users 
public = yes 
writable = no 
 
[Public] 
path = /share/public 
force user = myuser 
force group = users 
create mask = 0664 
force create mode = 0664 
directory mask = 0777 
force directory mode = 0777 
public = yes 
writable = yes 
</code></pre>
<p class="normal">As you can see, I’m separating<a id="_idIndexMarker656"/> share declarations in their own file. We can<a id="_idIndexMarker657"/> see several interesting things within <code class="inlineCode">smbshared.conf</code>. First, we have two stanzas, <code class="inlineCode">[Documents]</code> and <code class="inlineCode">[Public]</code>. Each stanza<a id="_idIndexMarker658"/> is a share name, which will allow Windows users to access the share under <code class="inlineCode">//servername/share-name</code>. In this case, this file will give us two shares: <code class="inlineCode">//servername/Documents</code> and <code class="inlineCode">//servername/Public</code>. The <code class="inlineCode">Public</code> share is writable for everyone, though the <code class="inlineCode">Documents</code> share is restricted to read-only. The <code class="inlineCode">Documents</code> share has the following options:</p>
<pre class="programlisting con"><code class="hljs-con">path = /share/documents 
</code></pre>
<p class="normal">This is the path to the share, which must exist on the server’s filesystem. In this case, when a user reads files from <code class="inlineCode">//servername/Documents</code> on a Windows system, they will be reading data from <code class="inlineCode">/share/documents</code> on the Ubuntu server that’s housing the share.</p>
<pre class="programlisting con"><code class="hljs-con">force user = myuser 
force group = users 
</code></pre>
<p class="normal">These two lines are basically bypassing user ownership. When a user reads this share, they are treated as <code class="inlineCode">myuser</code> instead of their actual user account. Normally, you would want to set up LDAP or Active Directory to manage your user accounts and handle their mapping to Ubuntu Server, but a full discussion of directory-based user access isn’t covered in this book, so I provided the <code class="inlineCode">force</code> options as an easy starting point. The user account you set here must exist on the server.</p>
<pre class="programlisting con"><code class="hljs-con">public = yes 
writable = no 
</code></pre>
<p class="normal">With these two lines, we’re configuring<a id="_idIndexMarker659"/> what users are able to do once<a id="_idIndexMarker660"/> they connect to this share. In this <a id="_idIndexMarker661"/>case, <code class="inlineCode">public = yes</code> means that the share is publicly available, though <code class="inlineCode">writable = no</code> prevents anyone from making changes to the contents of this share. This is useful if you want to share files with others, but you want to restrict access and stop anyone from being able to modify the content.</p>
<p class="normal">The <code class="inlineCode">Public</code> share has some additional settings that weren’t found in the <code class="inlineCode">Documents</code> share:</p>
<pre class="programlisting con"><code class="hljs-con">create mask = 0664 
force create mode = 0664 
directory mask = 0777 
force directory mode = 0777 
</code></pre>
<p class="normal">With these options, I’m setting up how the permissions of files and directories will be handled when new content is added to the share. Directories will be given <code class="inlineCode">777</code> permissions and files will be given permissions of <code class="inlineCode">664</code>. Yes, these permissions are very open; note that the share is named <code class="inlineCode">Public</code>, which implies full access anyway, and its intended purpose is to house data that isn’t confidential or restricted:</p>
<pre class="programlisting con"><code class="hljs-con">public = yes 
writable = yes 
</code></pre>
<p class="normal">Just as I did with the previous share, I’m setting up the share to be publicly available, but this time I’m also configuring it to allow users to make changes.</p>
<p class="normal">To take advantage of this configuration, we need to start the Samba daemon. Before we do though, we want to double-check that the directories we entered into our <code class="inlineCode">smbshared.conf</code> file exist, so if you’re using my example, you’ll need to create <code class="inlineCode">/share/documents</code> and <code class="inlineCode">/share/public</code>:</p>
<pre class="programlisting con"><code class="hljs-con">sudo mkdir /share
sudo mkdir /share/documents
sudo mkdir /share/public 
</code></pre>
<p class="normal">Also, the user account that was referenced in the force user and the group referenced in the force group must both exist and have ownership over the shared directories:</p>
<pre class="programlisting con"><code class="hljs-con">sudo chown -R jay:users /share 
</code></pre>
<p class="normal">At this point, it’s a good<a id="_idIndexMarker662"/> idea to use the <code class="inlineCode">testparm</code> command, which<a id="_idIndexMarker663"/> will test the syntax of our Samba configuration<a id="_idIndexMarker664"/> files for us. It won’t necessarily catch every error we could have made, but it is a good command to run to quickly check the sanity. This command will first check the syntax, and then it will print the entire configuration to the terminal for you to have a chance to review it. If you see no errors here, then you can proceed to start the service:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl start smbd 
</code></pre>
<p class="normal">Then, check the status to ensure that the daemon is running:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl status smbd
</code></pre>
<p class="normal">This will produce output similar to the following:</p>
<figure class="mediaobject"><img alt="" height="331" src="../Images/B18425_12_01.png" width="881"/></figure>
<figure class="mediaobject">Figure 12.1: Checking the status of the smbd daemon</figure>
<p class="normal">That really should be all there <a id="_idIndexMarker665"/>is to it; you should now<a id="_idIndexMarker666"/> have <code class="inlineCode">Documents</code> and <code class="inlineCode">Public</code> shares on your file server<a id="_idIndexMarker667"/> that Windows users should be able to access. In fact, your Linux machines should be able to access these shares as well. On Windows, <strong class="keyWord">Windows Explorer</strong> has the ability to browse file shares on your network. If in doubt, try pressing the <em class="keystroke">Windows</em> key and the <em class="keystroke">r</em> key at the same <a id="_idIndexMarker668"/>time to open the <strong class="keyWord">Run</strong> dialog box, and then type the <strong class="keyWord">Universal Naming Convention</strong> (<strong class="keyWord">UNC</strong>) path to the share (<code class="inlineCode">\\servername\Documents</code> or <code class="inlineCode">\\servername\Public</code>). You should be able to see any files stored in either of those directories. In the case of the <code class="inlineCode">Public</code> share, you should be able to create new files there as well.</p>
<p class="normal">On Linux systems, if you have a desktop environment installed, most of them feature a file manager that supports browsing network shares. Since there are a handful of different desktop environments available, the method varies from one distribution or configuration to another. Typically, most Linux file managers will have a network link within the file manager, which will allow you to easily browse your local shares. In the case of Ubuntu itself, you may need to install <code class="inlineCode">smbclient</code> and <code class="inlineCode">cifs-utils</code> via <code class="inlineCode">apt</code>, so if you get an error you can try installing those packages. In the following screenshot, an Ubuntu 22.04 desktop client is browsing shares on a local Samba server: </p>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated with medium confidence" height="353" src="../Images/B18425_12_02.png" width="738"/></figure>
<p class="packt_figref">Figure 12.2: Browsing a Samba share from a Linux client</p>
<p class="normal">If your file manager doesn’t show<a id="_idIndexMarker669"/> you the available shares on your server, you<a id="_idIndexMarker670"/> can also access a Samba<a id="_idIndexMarker671"/> share by adding an entry for it in the <code class="inlineCode">/etc/fstab</code> file, such as the following:</p>
<pre class="programlisting con"><code class="hljs-con">//myserver/share/documents /mnt/documents cifs username=myuser,noauto 0 0 
</code></pre>
<p class="normal">Then, assuming the local directory exists (<code class="inlineCode">/mnt/documents</code> in the example <code class="inlineCode">fstab</code> line), you should be able to mount the share with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo mount /mnt/documents 
</code></pre>
<p class="normal">In the <code class="inlineCode">fstab</code> entry, I included the <code class="inlineCode">noauto</code> option so that your system won’t mount the Samba share at boot time (you’ll need to do so manually with the <code class="inlineCode">mount</code> command). If you do want the Samba share automatically mounted at boot time, change <code class="inlineCode">noauto</code> to <code class="inlineCode">auto</code>. However, you may receive errors during boot if for some reason the server hosting your Samba shares isn’t accessible, which is why I prefer the <code class="inlineCode">noauto</code> option.</p>
<p class="normal">If you’d prefer to mount the Samba share without adding an <code class="inlineCode">fstab</code> entry, the following example command should do the trick; just change the share name and mount point to match your local configuration:</p>
<pre class="programlisting con"><code class="hljs-con">sudo mount -t cifs //myserver/Documents -o username=myuser /mnt/documents
</code></pre>
<p class="normal">From here, feel free<a id="_idIndexMarker672"/> to experiment. You can add additional <a id="_idIndexMarker673"/>shares as appropriate, and customize your Samba<a id="_idIndexMarker674"/> implementation as you see fit. In the next section, we’ll explore NFS.</p>
<h1 class="heading-1" id="_idParaDest-172">Setting up NFS shares</h1>
<p class="normal">An alternative<a id="_idIndexMarker675"/> to Samba is<strong class="keyWord"> NFS</strong>. It’s a great method of sharing files from a Linux or Unix server to another Linux or Unix server. As I mentioned earlier in the chapter, Windows systems can access NFS shares as well, but that requires an add-on to be enabled. Therefore, NFS is preferred in a Linux or Unix environment, since it fully supports Linux and Unix-style permissions. As you can see from our dive into Samba earlier, we essentially forced all shares to be treated as being accessed by a particular user, which was messy, but was the easiest example of setting up a Samba server without also walking you through setting up a complicated Windows Active Directory deployment. Samba can certainly support per-user access restrictions and benefits greatly from a centralized directory server, though that would basically be a book of its own! NFS integrates better in a non-mixed environment.</p>
<p class="normal">Earlier, we set up a parent directory in our filesystem to house our Samba shares, and we should do the same thing with NFS. While it wasn’t mandatory to have a special parent directory with Samba (I had you do that in order to be neat, but you weren’t required to), NFS really does want its own directory to house all of its shares. It’s not strictly required with NFS either, but there’s an added benefit in doing so, which I’ll go over before the end of this section. In my case, I’ll use <code class="inlineCode">/exports</code> as an example, so you should make sure that that directory, or whatever you’ve chosen for NFS, exists:</p>
<pre class="programlisting con"><code class="hljs-con">sudo mkdir /exports 
</code></pre>
<p class="normal">Next, let’s install the required NFS packages on our server. The following command will install NFS and its dependencies:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install nfs-kernel-server 
</code></pre>
<p class="normal">Once you install the <code class="inlineCode">nfs-kernel-server</code> package, the <code class="inlineCode">nfs-kernel-server</code> daemon<a id="_idIndexMarker676"/> will start up automatically. It will also create a default <code class="inlineCode">/etc/exports</code> file (which is the main file that NFS reads its share information from), but it doesn’t contain any useful settings, just some commented lines. Let’s back up the <code class="inlineCode">/etc/exports</code> file, since we’ll be creating our own:</p>
<pre class="programlisting con"><code class="hljs-con">sudo mv /etc/exports /etc/exports.orig 
</code></pre>
<p class="normal">To set up NFS, let’s first create<a id="_idIndexMarker677"/> some directories that we will share with other users. Each share in NFS is known as an <strong class="keyWord">export</strong>. I’ll use the following directories as examples, but you can export any directory you like:</p>
<pre class="programlisting code"><code class="hljs-code">/exports/backup 
/exports/documents 
/exports/public 
</code></pre>
<p class="normal">In the <code class="inlineCode">/etc/exports</code> file (which we’re creating fresh), I’ll insert the following four lines:</p>
<pre class="programlisting code"><code class="hljs-code">/exports *(ro,fsid=0,no_subtree_check) 
/exports/backup 192.168.1.0/255.255.255.0(rw,no_subtree_check) 
/exports/documents 192.168.1.0/255.255.255.0(ro,no_subtree_check) 
/exports/public 192.168.1.0/255.255.255.0(rw,no_subtree_check) 
</code></pre>
<p class="normal">The first line is our <strong class="keyWord">export root</strong>, which I’ll go over a bit later. The next<a id="_idIndexMarker678"/> three lines are individual shares or exports. The <code class="inlineCode">/backup</code>, <code class="inlineCode">/documents</code>, and <code class="inlineCode">/public</code> directories are being shared from the <code class="inlineCode">/exports</code> parent directory. In this case, after the directory is called out in a line, we’re also setting which network is able to access them (<code class="inlineCode">192.168.1.0</code>/<code class="inlineCode">255.255.255.0</code> in our case). This means that if you’re connecting from a different network, your access will be denied. Each connecting machine must be a member of the <code class="inlineCode">192.168.1.0/24</code> network in order to proceed (so make sure you change this to match your IP scheme). Finally, we include some options for each export, for example, <code class="inlineCode">rw,no_subtree_check</code>.</p>
<p class="normal">As far as what these options do, the first (<code class="inlineCode">rw</code>) is rather self-explanatory. Here, we can set whether or not other nodes will be able to make changes to data within the export. In the examples I gave, the <code class="inlineCode">/documents</code> export is read-only (<code class="inlineCode">ro</code>), while the others allow read and write.</p>
<p class="normal">The next option in each example is <code class="inlineCode">no_subtree_check</code>. This option is known to increase reliability and is mainly implied<a id="_idIndexMarker679"/> by default. However, not including it may make NFS complain when it restarts, but nothing that will actually<a id="_idIndexMarker680"/> stop it from working. Particularly, this option disables what is known as <strong class="keyWord">subtree checking</strong>, which has had some stability issues in the past. Normally, when a directory is exported, NFS might scan parent directories as well, which is sometimes problematic, and can cause issues when it comes to open file handles.</p>
<p class="normal">There are several other options that can be included in an <code class="inlineCode">export</code>, and you can read more about them by checking the man page for <code class="inlineCode">export</code>:</p>
<pre class="programlisting con"><code class="hljs-con">man exports
</code></pre>
<p class="normal">One option you’ll see quite often in the wild is <code class="inlineCode">no_root_squash</code>. Normally, the <code class="inlineCode">root</code> user on one system is mapped to nobody on the other for security reasons. In most cases, one system having <code class="inlineCode">root</code> access to another is a bad idea. The <code class="inlineCode">no_root_squash</code> option disables this, and it allows the <code class="inlineCode">root</code> user on one end to be treated as the <code class="inlineCode">root</code> user on the other. I can’t think of a reason, personally, where this would be useful (or even recommended), but I have seen this option quite often in the wild, so I figured I would bring it up. Again, check the man pages for <code class="inlineCode">export</code> for more information on additional options you can pass to your exports.</p>
<p class="normal">Next, we have one more file to edit before we can actually seal the deal on our NFS setup. The <code class="inlineCode">/etc /idmapd.conf</code> file is necessary for mapping permissions on one node to another. In <em class="chapterRef">Chapter 2</em>, <em class="italic">Managing Users and ermissions</em>, we talked about the fact that each user has an ID (UID) assigned to them. The problem, though, is that from one system to another, a user will not typically have the same UID. For example, user <code class="inlineCode">jdoe</code> may be UID <code class="inlineCode">1001</code> on server A, but <code class="inlineCode">1007</code> on server B. When it comes to NFS, this greatly confuses the situation, because UIDs are used in order to reference permissions. Mapping IDs with <code class="inlineCode">idmapd</code> allows this to stay consistent and handles translating each user properly, though it must be configured correctly and consistently on each node. Basically, as long as you use the same domain name on each server and client and configure the <code class="inlineCode">/etc/idmapd.conf</code> file properly on each, you should be fine.</p>
<p class="normal">To configure this, open <code class="inlineCode">/etc/idmapd.conf</code> in your text editor. Look for an option that is similar to the following:</p>
<pre class="programlisting code"><code class="hljs-code"># Domain = localdomain 
</code></pre>
<p class="normal">First, remove the <code class="inlineCode">#</code> symbol from that line to uncomment it. Then, change the domain to match the one used within<a id="_idIndexMarker681"/> the rest of your network. You can leave this as it is as long as it’s the same on each node, but if you recall from <em class="chapterRef">Chapter 11</em>, <em class="italic">Setting Up Network Services</em>, we used a sample domain of <code class="inlineCode">local.lan</code> in our DHCP configuration, so it’s best to make sure you use the same domain name everywhere—even the domain provided by DHCP. Basically, just be as consistent as you can and you’ll have a much easier time overall. You’ll also want to edit the <code class="inlineCode">/etc/idmapd.conf</code> file on each node that will access your file server, to ensure they are configured the same as well.</p>
<p class="normal">With our <code class="inlineCode">/etc/exports</code> and <code class="inlineCode">/etc/idmapd.conf</code> files in place, and assuming you’ve already created the exported directories on your filesystem, we should be all set to restart NFS to activate our configuration:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl restart nfs-kernel-server 
</code></pre>
<p class="normal">After restarting NFS, you should check the daemon’s output via <code class="inlineCode">systemctl</code> to ensure that there are no errors:</p>
<pre class="programlisting con"><code class="hljs-con">systemctl status nfs-kernel-server 
</code></pre>
<p class="normal">As long as there are no errors, our NFS server should be working. Now, we just need to learn how to mount these shares on another system. Unlike Samba, using a Linux file manager and browsing the network will not show NFS exports by default; we’ll need to mount them manually. Client machines, assuming they are Debian-based (Ubuntu fits this description), will need the <code class="inlineCode">nfs-common</code> package installed in order to access these exports. </p>
<p class="normal">It may already be installed, but if it’s not, we can install it with <code class="inlineCode">apt</code> like any other package:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install nfs-common 
</code></pre>
<p class="normal">With the client installed, we can now use the <code class="inlineCode">mount</code> command to mount NFS exports on a client. For example, with regards to our <code class="inlineCode">documents</code> export, we can use the following variation of the <code class="inlineCode">mount</code> command to do the trick:</p>
<pre class="programlisting con"><code class="hljs-con">sudo mount myserver:/documents /mnt/documents 
</code></pre>
<p class="normal">Replace <code class="inlineCode">myserver</code> with either your server’s hostname or its IP address, <code class="inlineCode">documents</code> with the name of the actual share on the server, and <code class="inlineCode">/mnt/documents</code> with the path on your local server where you want to mount the share. From this point forward, you should be able to access the contents of the <code class="inlineCode">documents</code> export on your file server. Notice, however, that the exported directory <a id="_idIndexMarker682"/>on the server was <code class="inlineCode">/exports/documents</code>, but we only asked for <code class="inlineCode">/documents</code> instead of the full path with the example <code class="inlineCode">mount</code> command. The reason this works is because we identified an export root of <code class="inlineCode">/exports</code>. To save you from flipping back, here’s the first line from the <code class="inlineCode">/etc/exports</code> file, where we identified our export root:</p>
<pre class="programlisting code"><code class="hljs-code">/exports *(ro,fsid=0,no_subtree_check) 
</code></pre>
<p class="normal">With the export root, we basically set the base directory for our NFS exports. We set it as read-only (<code class="inlineCode">ro</code>), because we don’t want anyone making any changes to the <code class="inlineCode">/exports</code> directory itself. Other directories within <code class="inlineCode">/exports</code> have their own permissions and will thus override the <code class="inlineCode">ro</code> setting on a per-export basis, so there’s no real reason to set our export root as anything other than read-only. With our export root set, we don’t have to call out the entire path of the export when we mount it; we only need the directory name. This is why we can mount an NFS export from <code class="inlineCode">myserver:/documents</code> instead of having to type the entire path. While this does save us a bit of typing, it’s also useful because from the user’s perspective, they aren’t required to know anything about the underlying filesystem on the server. There’s simply no value in the user having to memorize the fact that the server is sharing a document’s directory from <code class="inlineCode">/exports</code>; all they’re interested in is getting to their data. Another benefit is if we ever need to move our export <code class="inlineCode">root</code> to a different directory (during a maintenance period), our users won’t have to change their configuration to reference the new place; they’ll only need to unmount and remount the exports.</p>
<p class="normal">So, at this point, you’ll have three directories being exported from your file server, and you can always add others as you go. However, whenever you add a new export, it won’t be automatically added and read by NFS. You can restart NFS to activate new exports, but that’s not really a good idea while users may be connected to them, since that will disrupt their access. Thankfully, the following command will cause NFS to reread the <code class="inlineCode">/etc/exports</code> file without disrupting existing connections. This will allow you to activate new exports immediately without having to wait for users to finish what they’re working on:</p>
<pre class="programlisting con"><code class="hljs-con">sudo exportfs -a 
</code></pre>
<p class="normal">With this section out of the way, you should be able to export a directory from your Ubuntu Server, and then mount that export on another Linux machine. Feel free to practice creating and mounting exports until you get the hang of it. In addition, you should familiarize yourself with a few additional options and settings that are allowable in the <code class="inlineCode">/etc/exports</code> file, after consulting the man page on exports.</p>
<div class="note">
<p class="normal">The <code class="inlineCode">/etc/exports</code> file, as you’ve seen in this section, is typically<a id="_idIndexMarker683"/> all you’ll need to set up a basic file server via NFS. However, you should also be aware that there’s another configuration file, <code class="inlineCode">/etc/nfs.conf</code>, and that file is new in Ubuntu 22.04. The purpose of this file is to tune the finer details of the NFS server. Although it’s out of scope to go over the <code class="inlineCode">/etc/nfs.conf</code> file, it’s worth having a look at this file in order to get a feel for which types of options are available. For more information, see the further reading section at the end of this chapter.</p>
</div>
<p class="normal">When you’ve had more NFS practice<a id="_idIndexMarker684"/> than you can tolerate, we’ll move on to a few ways in which you can copy files from one node to another without needing to set up an intermediary service or daemon.</p>
<h1 class="heading-1" id="_idParaDest-173">Transferring files with rsync</h1>
<p class="normal">Of all the countless tools and utilities<a id="_idIndexMarker685"/> available in the Linux and Unix world, few<a id="_idIndexMarker686"/> are as beloved as <code class="inlineCode">rsync</code>. This is a utility that you can use to copy data from one place to another very easily, and there are many options available to allow you to be very specific about how you want the data to be transferred. Examples of its many use cases include copying files while preserving permissions, copying files while backing up replaced files, and even setting up incremental backups. If you don’t already know how to use <code class="inlineCode">rsync</code>, you’ll probably want to get lots of practice with it, as it’s something you’ll soon see will be indispensable during your career as a Linux administrator, and it is also something that the Linux community generally assumes you already know. Thankfully, <code class="inlineCode">rsync</code> is not hard to learn. Most administrators can learn the basic usage in about an hour or less, but the countless options available will lead you to learn new tricks even years down the road.</p>
<p class="normal">Another aspect that makes <code class="inlineCode">rsync</code> flexible is the many ways you can manipulate the source and target directories. I mentioned earlier that <code class="inlineCode">rsync</code> is a tool you can use to copy data from one place to another. The beauty of this is that the source and target can literally be anywhere you’d like, assuming you have appropriate access. For example, the most common usage of <code class="inlineCode">rsync</code> is to copy data from a directory on one server to a directory on another server over the network. However, you don’t even have to use the network; you can even copy data from one directory to another on the same server. While this may not seem like a useful thing to do at first, consider that the target directory may be a mount point that leads to a backup disk, or an NFS share that actually exists on another server. This also works in reverse: you can copy data from a network location to a local directory if you desire.</p>
<p class="normal">To get started with practicing<a id="_idIndexMarker687"/> with <code class="inlineCode">rsync</code>, I recommend that you find some sample<a id="_idIndexMarker688"/> files to work with. Perhaps you have a collection of documents you can use, MP3 files, videos, text files, or basically any kind of data you have lying around. It’s important to make a copy of this data. If we make a mistake we could overwrite things, so it’s best to work with a copy of the data, or data you don’t care about, while you’re practicing. If you don’t have any files to work with, you can create some text files. The idea is to practice copying files from one place to another; it really doesn’t matter what you copy or where you send it to. I’ll walk you through some <code class="inlineCode">rsync</code> examples that will progressively increase in complexity. The first few examples will show you how to back up a <code class="inlineCode">home</code> directory, but later examples will be potentially destructive so you will probably want to work with sample files until you get the hang of it.</p>
<p class="normal">Here’s our first example:</p>
<pre class="programlisting con"><code class="hljs-con">sudo rsync -r /home/myuser /backup 
</code></pre>
<p class="normal">With that command, we’re using <code class="inlineCode">rsync</code> (as <code class="inlineCode">root</code>) to copy the contents of the <code class="inlineCode">home</code> directory for the <code class="inlineCode">myuser</code> directory to a backup directory, <code class="inlineCode">/backup</code> (make sure the target directory exists). In the example, I used the <code class="inlineCode">-r</code> option, which means <code class="inlineCode">rsync</code> will grab directories recursively as well. You should now see a copy of the <code class="inlineCode">/home/myuser</code> directory inside your <code class="inlineCode">/backup</code> directory.</p>
<p class="normal">However, we have a bit of a problem. If you look at the permissions in the <code class="inlineCode">/backup/myuser</code> directory, you can see that everything in the target is now owned by <code class="inlineCode">root</code>. This isn’t a good thing; when you back up a user’s <code class="inlineCode">home</code> directory, you’ll want to retain their permissions. In addition, you should retain as much metadata as you can, including things like timestamps. Let’s try another variation of <code class="inlineCode">rsync</code>. Don’t worry about the fact that <code class="inlineCode">/backup</code> already has a copy of the <code class="inlineCode">myuser</code> home directory from our previous backup. Let’s perform the backup again, but this time, we’ll use the <code class="inlineCode">-a</code> option:</p>
<pre class="programlisting con"><code class="hljs-con">sudo rsync -a /home/myuser /backup
</code></pre>
<p class="normal">This time, we replaced the <code class="inlineCode">-r</code> option with <code class="inlineCode">-a</code> (archive), which retains as much metadata as possible (in most cases, it should make everything an exact copy). What you should notice now is that the permissions within the backup match the permissions within the user’s <code class="inlineCode">home</code> directory we copied<a id="_idIndexMarker689"/> from. The timestamps of the files will now match as well. This works because<a id="_idIndexMarker690"/> whenever <code class="inlineCode">rsync</code> runs, it will copy what’s different from the last time it ran. The files from our first backup were already there, but the permissions were wrong. When we ran the second command, <code class="inlineCode">rsync</code> only needed to copy what was different, so it applied the correct permissions to the files. If any new files were added to the source directory since we last ran the command, the new or updated files would be copied over as well.</p>
<p class="normal">The <code class="inlineCode">archive</code> mode (the <code class="inlineCode">-a</code> option that we used with the previous command) is actually very popular; you’ll probably see it a lot during your travels. The <code class="inlineCode">-a</code> option is actually a wrapper option that includes the following options all at the same time:</p>
<pre class="programlisting con"><code class="hljs-con">-rlptgoD 
</code></pre>
<p class="normal">If you’re curious about what each of these options do, consult the man page for <code class="inlineCode">rsync</code> for more detailed information. In summary, the <code class="inlineCode">-r</code> option copies data recursively (which we already know), the <code class="inlineCode">-l</code> option copies symbolic links, <code class="inlineCode">-p</code> preserves permissions, <code class="inlineCode">-g</code> preserves group ownership, <code class="inlineCode">-o</code> preserves the owner, and <code class="inlineCode">-D</code> preserves device files. If you put those options together, we get <code class="inlineCode">-rlptgoD</code>. Therefore, <code class="inlineCode">-a</code> is actually equal to <code class="inlineCode">-rlptgoD</code>. I find <code class="inlineCode">-a</code> easier to remember.</p>
<p class="normal">The <code class="inlineCode">archive</code> mode is great and all, but wouldn’t it be nice to be able to watch what <code class="inlineCode">rsync</code> is up to when it runs? Add the <code class="inlineCode">-v</code> option and try the command again:</p>
<pre class="programlisting con"><code class="hljs-con">sudo rsync -av /home/myuser /backup 
</code></pre>
<p class="normal">This time, <code class="inlineCode">rsync</code> will display on your terminal what it’s doing as it runs (<code class="inlineCode">-v</code> activates <strong class="keyWord">verbose</strong> mode). This is actually one of my favorite variations of the <code class="inlineCode">rsync</code> command, as I like to copy everything and retain all the metadata, as well as watch what <code class="inlineCode">rsync</code> is doing as it works.</p>
<p class="normal">What if I told you that <code class="inlineCode">rsync</code> supports SSH by default? It’s true! Using <code class="inlineCode">rsync</code>, you can easily copy data from one node to another, even over SSH. The same options apply, so you don’t actually have to do anything different other than point <code class="inlineCode">rsync</code> to the other server, rather than to another directory on your local server:</p>
<pre class="programlisting con"><code class="hljs-con">sudo rsync -av /home/myuser admin@192.168.1.5:/backup 
</code></pre>
<p class="normal">With this example, I’m copying the <code class="inlineCode">home</code> directory for <code class="inlineCode">myuser</code> to the <code class="inlineCode">/backup</code> directory on server <code class="inlineCode">192.168.1.5</code>. I’m connecting<a id="_idIndexMarker691"/> to the other server as the <code class="inlineCode">admin</code> user. Make sure you change the user account<a id="_idIndexMarker692"/> and IP address accordingly, and also make sure the user account you use has access to the <code class="inlineCode">/backup</code> directory. When you run this command, you should get prompted for the SSH password as you would when using plain SSH to connect to the server. After the connection is established, the files will be copied to the target server and directory.</p>
<p class="normal">Now, we’ll get into some even cooler examples (some of which are potentially destructive), and we probably won’t want to work with an actual <code class="inlineCode">home</code> directory for these, unless it’s a test account and you don’t care about its contents. As I’ve mentioned before, you should have some test files to play with. When practicing, simply replace my directories with yours. Here’s another variation worth trying:</p>
<pre class="programlisting con"><code class="hljs-con">sudo rsync -av --delete /src /target 
</code></pre>
<p class="normal">Now I’m introducing you to the <code class="inlineCode">--delete</code> option. This option allows you to synchronize two directories. Let me explain why this is important. With every <code class="inlineCode">rsync</code> example up until now, we’ve been copying files from point A to point B, but we weren’t deleting anything. For example, let’s say you’ve already used <code class="inlineCode">rsync</code> to copy contents from point A to point B. Then, you delete some files from point A. When you use <code class="inlineCode">rsync</code> to copy files from point A to point B again, the files you deleted in point A won’t be deleted in point B. They’ll still be there. This is because by default, <code class="inlineCode">rsync</code> copies data between two locations, but it doesn’t remove anything. With the <code class="inlineCode">--delete</code> option, you’re effectively synchronizing the two points, thus you’re telling <code class="inlineCode">rsync</code> to make them the same by allowing it to delete files in the target that are no longer in the source.</p>
<p class="normal">Next, we’ll add the <code class="inlineCode">-b</code> (backup) option:</p>
<pre class="programlisting con"><code class="hljs-con">sudo rsync -avb --delete /src /target 
</code></pre>
<p class="normal">This one is particularly useful. Normally, when a file is updated on <code class="inlineCode">/src</code> and then copied over to <code class="inlineCode">/target</code>, the copy on <code class="inlineCode">/target</code> is overwritten with the new version. But what if you don’t want any files to be replaced? The <code class="inlineCode">-b</code> option renames files on the target that are being overwritten, so you’ll still have the original file. If you add the <code class="inlineCode">--backup-dir</code> option, things get really interesting:</p>
<pre class="programlisting con"><code class="hljs-con">sudo rsync -avb --delete --backup-dir=/backup/incremental /src /target 
</code></pre>
<p class="normal">Now, we’re copying files from <code class="inlineCode">/src</code> to <code class="inlineCode">/target</code> as we were before, but we’re now sending replaced files to the <code class="inlineCode">/backup/incremental</code> directory. This means<a id="_idIndexMarker693"/> that when a file is going to be replaced on the target, the original<a id="_idIndexMarker694"/> file will be copied to <code class="inlineCode">/backup/incremental</code>. This works because we used the <code class="inlineCode">-b</code> option (backup) but we also used the <code class="inlineCode">--backup-dir</code> option, which means that the replaced files won’t be renamed; they’ll simply be moved to the designated directory. This allows us to effectively perform incremental backups.</p>
<p class="normal">Building on our previous example, we can use the Bash shell itself to make incremental backups work even better. Consider these commands:</p>
<pre class="programlisting con"><code class="hljs-con">CURDATE=$(date +%m-%d-%Y) 
 
sudo rsync -avb --delete --backup-dir=/backup/incremental/$CURDATE /src /target 
</code></pre>
<p class="normal">With this example, we grab the current date and store it in a variable (<code class="inlineCode">CURDATE</code>). In the <code class="inlineCode">rsync</code> portion of the command, we use that variable for the <code class="inlineCode">--backup-dir</code> option. This will copy the replaced files to a <code class="inlineCode">backup</code> directory named after the <code class="inlineCode">date</code> the command was run. Basically, if today’s date was <code class="inlineCode">08-17-2022</code>, the resulting command would be the same as if we had run the following:</p>
<pre class="programlisting con"><code class="hljs-con">sudo rsync -avb --delete --backup-dir=/backup/incremental/08-17-2022 /src /target 
</code></pre>
<p class="normal">Hopefully, you can see how flexible <code class="inlineCode">rsync</code> is and how it can be used to not only copy files between directories and/or nodes, but also to serve as a backup solution as well (assuming you have a remote destination to copy files to). The best part is that this is only the beginning. If you consult the man page for <code class="inlineCode">rsync</code>, you’ll see that there are a lot of options you can use to customize<a id="_idIndexMarker695"/> it even further. Give it some practice, and you should<a id="_idIndexMarker696"/> get the hang of it in no time.</p>
<h1 class="heading-1" id="_idParaDest-174">Transferring files with SCP</h1>
<p class="normal">A useful alternative to <code class="inlineCode">rsync</code> is the <strong class="keyWord">Secure Copy</strong> (<strong class="keyWord">SCP</strong>) utility, which<a id="_idIndexMarker697"/> comes bundled with the OpenSSH client. It allows you<a id="_idIndexMarker698"/> to quickly copy files from one node to another. While <code class="inlineCode">rsync</code> also allows you to copy files to other network nodes via SSH, SCP is more practical for one-off tasks; <code class="inlineCode">rsync</code> is geared toward more complex jobs. If your goal<a id="_idIndexMarker699"/> is to send a single file or a small number<a id="_idIndexMarker700"/> of files to another machine, SCP is a great tool you can use to get the job done. If nothing else, it’s yet another item for your administration toolbox. To utilize SCP, we’ll use the <code class="inlineCode">scp</code> command. Since you most likely already have the OpenSSH client installed, you should already have the <code class="inlineCode">scp</code> command available. If you execute <code class="inlineCode">which scp</code>, you should receive the following output:</p>
<pre class="programlisting con"><code class="hljs-con">/usr/bin/scp 
</code></pre>
<p class="normal">If you don’t see any output, make sure that the <code class="inlineCode">openssh-client</code> package is installed.</p>
<p class="normal">Using SCP is very similar in nature to <code class="inlineCode">rsync</code>. The command requires a source, a target, and a filename. To transfer a single file from your local machine to another, the resulting command would look similar to the following:</p>
<pre class="programlisting con"><code class="hljs-con">scp myfile.txt jdoe@192.168.1.50:/home/jdoe 
</code></pre>
<p class="normal">With this example, we’re copying the <code class="inlineCode">myfile.txt</code> file (which is located in our current working directory) to a server located at <code class="inlineCode">192.168.1.50</code>. If the target server is recognized by DNS, we could’ve used the DNS name instead of the IP address. The command will connect to the server as user <code class="inlineCode">jdoe</code> and place the file into that user’s <code class="inlineCode">home</code> directory. Actually, we can shorten that command a bit:</p>
<pre class="programlisting con"><code class="hljs-con">scp myfile.txt jdoe@192.168.1.50:
</code></pre>
<p class="normal">Notice that I removed the target path, which was <code class="inlineCode">/home/jdoe</code>. I’m able to omit the path to the target, since the <code class="inlineCode">home</code> directory is assumed if you don’t give the <code class="inlineCode">scp</code> command a target path. Therefore, the <code class="inlineCode">myfile.txt</code> file will end up in <code class="inlineCode">/home/jdoe</code> whether or not I included the path to the <code class="inlineCode">home</code> directory explicitly. If I wanted to copy the file somewhere else, I would definitely need to call out the location. Make sure you always include at least the colon when copying a file, since if you don’t include it, you’ll end up copying the file to your current working directory instead of the target.</p>
<p class="normal">The <code class="inlineCode">scp</code> command also works in reverse:</p>
<pre class="programlisting con"><code class="hljs-con">scp jdoe@192.168.1.50:myfile.txt . 
</code></pre>
<p class="normal">With this example, we’re assuming that <code class="inlineCode">myfile.txt</code> is located in the <code class="inlineCode">home</code> directory for the user <code class="inlineCode">jdoe</code>. This command will copy that file to the current working directory of our local machine, since I designated the local path as a <em class="italic">single period</em> (which corresponds to our current working directory). Using <code class="inlineCode">scp</code> in reverse<a id="_idIndexMarker701"/> isn’t always practical, since<a id="_idIndexMarker702"/> you have to already know where the desired file is stored on the target before transferring it.</p>
<p class="normal">With our previous <code class="inlineCode">scp</code> examples, we’ve only been copying a single file. If we want to transfer or download an entire directory and its contents, we will need to use the <code class="inlineCode">-r</code> option, which allows us to do a recursive copy:</p>
<pre class="programlisting con"><code class="hljs-con">scp -r /home/jdoe/downloads/linux_iso jdoe@192.168.1.50:downloads 
</code></pre>
<p class="normal">With this example, we’re copying the local folder <code class="inlineCode">/home/jdoe/downloads/linux_iso</code> to remote machine <code class="inlineCode">192.168.1.50</code>. Since we used the <code class="inlineCode">-r</code> option, <code class="inlineCode">scp</code> will transfer the <code class="inlineCode">linux_iso</code> folder and all of its contents. At the remote end, we’re again connecting via the user <code class="inlineCode">jdoe</code>. Notice that the target path is simply <code class="inlineCode">downloads</code>. Since <code class="inlineCode">scp</code> defaults to the user’s <code class="inlineCode">home</code> directory, this will copy the <code class="inlineCode">linux_iso</code> directory from the source machine to the target machine under the <code class="inlineCode">/home/jdoe/downloads</code> directory. The following command would’ve had the exact same result:</p>
<pre class="programlisting con"><code class="hljs-con">scp -r /home/jdoe/downloads/linux_iso jdoe@192.168.1.50:/home/jdoe/downloads 
</code></pre>
<p class="normal">The <code class="inlineCode">home</code> directory is not the only assumption the <code class="inlineCode">scp</code> command makes. It also assumes that SSH is listening on port <code class="inlineCode">22</code> on the remote machine. Since it’s possible to change the SSH port on a server to something else, port <code class="inlineCode">22</code> may or may not be what’s in use. If you need to designate a different port for <code class="inlineCode">scp</code> to use, use the <code class="inlineCode">-P</code> option:</p>
<pre class="programlisting con"><code class="hljs-con">scp -P 2222 -r /home/jdoe/downloads/linux_iso jdoe@192.168.1.50:downloads 
</code></pre>
<p class="normal">With that example, we’re connecting to the remote machine via port <code class="inlineCode">2222</code>. If you’ve configured SSH to listen on a different port, change the number accordingly.</p>
<p class="normal">Although port <code class="inlineCode">22</code> is always the default for OpenSSH, it’s common for some administrators to change it to something else. While changing the SSH port doesn’t add a great deal of benefit in regard to security (an intensive port scan will still find your SSH daemon), it’s a relatively easy change to make, and making it even just a little bit harder to find is beneficial. We’ll discuss this further in <em class="chapterRef">Chapter 21</em>, <em class="italic">Securing Your Server</em>.</p>
<p class="normal">Like most commands in the Linux world, the <code class="inlineCode">scp</code> command supports verbose mode. If you want to see how the <code class="inlineCode">scp</code> command progresses as it copies multiple files, add the <code class="inlineCode">-v</code> option:</p>
<pre class="programlisting con"><code class="hljs-con">scp -rv /home/jdoe/downloads/linux_iso jdoe@192.168.1.50:downloads 
</code></pre>
<p class="normal">Well, there you have it. The <code class="inlineCode">scp</code> command<a id="_idIndexMarker703"/> isn’t overly complex or advanced, but<a id="_idIndexMarker704"/> it’s really great for situations in which you want to perform a one-time copy of a file from one node to another. Since it copies files over SSH, you benefit from its security, and it also integrates well with your existing SSH configuration. An example of this integration is the fact that <code class="inlineCode">scp</code> recognizes your <code class="inlineCode">~/.ssh/config</code> file (if you have one), so you can shorten the command even further. Go ahead and practice with it a bit, and in the next section, we’ll go over yet another trick that OpenSSH has up its sleeve.</p>
<h1 class="heading-1" id="_idParaDest-175">Summary</h1>
<p class="normal">In this chapter, we explored multiple ways of accessing remote resources. Just about every network has a central location for storing files, and we explored two ways of accomplishing this with NFS and Samba. Both NFS and Samba have their place in the data center and are very useful ways in which we can make resources on a server available to our users who need to access them. We also talked about <code class="inlineCode">rsync</code> and <code class="inlineCode">scp</code>, two great utilities for transferring data without needing to set up a permanent share. </p>
<p class="normal">Next up is <em class="chapterRef">Chapter 13</em>, <em class="italic">Managing Databases</em>. Now that we have all kinds of useful services running on our Ubuntu Server network, it’s only fitting that we take a look at serving databases as well. Specifically, we’ll look at MariaDB. See you there!</p>
<h1 class="heading-1" id="_idParaDest-176">Relevant videos</h1>
<ul>
<li class="bulletList">Tutorial for <code class="inlineCode">scp</code>: <a href="https://linux.video/scp"><span class="url">https://linux.video/scp</span></a></li>
<li class="bulletList">Backing up a Linux server with <code class="inlineCode">rsync</code>: <a href="https://linux.video/rsync-backup"><span class="url">https://linux.video/rsync-backup</span></a></li>
<li class="bulletList">Transferring files with <code class="inlineCode">rsync</code>: <a href="https://linux.video/rsync-transfer"><span class="url">https://linux.video/rsync-transfer</span></a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-177">Further reading</h1>
<ul>
<li class="bulletList">Ubuntu <code class="inlineCode">rsync</code> documentation: <a href="https://learnlinux.link/u-rsync"><span class="url">https://learnlinux.link/u-rsync</span></a></li>
<li class="bulletList">Ubuntu Samba documentation: <a href="https://learnlinux.link/u-smb"><span class="url">https://learnlinux.link/u-smb</span></a></li>
<li class="bulletList">Service – NFS (contains additional information on NFS changes in 22.04): <a href="https://learnlinux.link/u-nfs-1"><span class="url">https://learnlinux.link/u-nfs-1</span></a></li>
<li class="bulletList">Ubuntu NFS documentation: <a href="https://learnlinux.link/u-nfs-2"><span class="url">https://learnlinux.link/u-nfs-2</span></a></li>
<li class="bulletList">Active Directory Integration: <a href="https://learnlinux.link/u-ad"><span class="url">https://learnlinux.link/u-ad</span></a></li>
</ul>
<h1 class="heading-1">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers: </p>
<p class="normal"><a href="https://packt.link/LWaZ0"><span class="url">https://packt.link/LWaZ0</span></a></p>
<p class="normal"><img alt="" height="177" src="../Images/QR_Code50046724-1955875156.png" width="177"/></p>
</div>
</div></body></html>