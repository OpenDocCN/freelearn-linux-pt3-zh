- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Processes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a developer, you are already intuitively familiar with processes. They are
    the fruits of your labor: after writing and debugging code, your program finally
    executes, transforming into a beautiful operating system process!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: A process on Linux can be a long-running application, a quick shell command
    like `ls`, or anything that the kernel spawns to do some work on the system. If
    something is getting done in Linux, a process is doing it. Your web browser, text
    editor, vulnerability scanner, and even things like reading files and the commands
    you’ve learned so far all spawn a process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux’s process model is important to understand because the abstraction it
    gives you – the Linux process – is what all the commands and tools you’ll use
    to manage processes depend on. Gone are the details you’re used to seeing from
    a developer’s perspective: variables, functions, and threads have all been encapsulated
    as “a process.” You’re left with a different, external set of knobs to manipulate
    and gauges to check: process ID, status, resource usage, and all the other process
    attributes we’ll be covering in this chapter.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll take a close look at the process abstraction itself, and then we’ll
    dive into useful, practical things you can do with Linux processes. While we’re
    covering the practical aspects, we’ll pause to add detail to a few aspects that
    are a common source of problems, like permissions, and give you some heuristics
    for troubleshooting processes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn about the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: What a Linux process is, and how to see the processes currently running on your
    system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attributes a process has, so you know what information you can gather while
    troubleshooting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common commands for viewing and finding processes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More advanced topics that can come in handy for a developer actually writing
    programs that execute as Linux processes: Signals and inter-process communication,
    the `/proc` virtual filesystem, seeing open file handles with the `lsof` command,
    and how processes are created in Linux'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll also get a practical review of everything you’ve learned in an example
    troubleshooting session that uses the theory and commands we cover in this chapter.
    Now, let’s dive into what exactly a Linux process is.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Process basics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we refer to a “process” in Linux, we’re referring to the operating system’s
    internal model of what exactly a running program *is*. Linux needs a general abstraction
    that works for *all* programs, which can encapsulate the things the operating
    system cares about. A process is that abstraction, and it enables the OS to track
    some of the important context around programs that are executing; namely:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Memory usage
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processor time used
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other system resource usage (disk access, network usage)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between processes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Related processes that a program starts, for example, firing off a shell command
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can get a listing of all system processes (at least the ones your user
    is allowed to see) by running the `ps` program with the `aux` flags:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19251_02_01.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: List of system processes'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover the attributes most relevant to your work as a developer in this
    chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: What is a Linux process made of?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the perspective of the operating system, a “process” is simply a data
    structure that makes it easy to access information like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '**Process ID** (**PID** in the `ps` output above). PID 1 is the init system
    – the original parent of all other processes, which bootstraps the system. The
    kernel starts this as one of the first things it does after starting to execute.
    When a process is created, it gets the next available process ID, in sequential
    order. Because it is so important to the normal functioning of the operating system,
    init cannot be killed, even by the root user. Different Unix operating systems
    use different init systems – for example, most Linux distributions use `systemd`,
    while macOS uses `launchd`, and many other Unixes use SysV. Regardless of the
    specific implementation, we’ll refer to this process by the name of the role it
    fills: “init.”'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In containers, processes are namespaced – in the “real” environment, all container
    processes might be PID 3210, while that single PID maps to lots of processes (`1..n`,
    where `n` is the number of running processes in the container). You can see this
    from outside but not inside the container.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Parent Process PID** (**PPID**). Each process is spawned by a parent. If
    the parent process dies while the child is alive, the child becomes an “orphan.”
    Orphaned processes are re-parented to init (PID 1).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status** (**STAT** in the `ps` output above). `man ps` will show you an overview:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D – uninterruptible sleep (usually IO)
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: I – idle kernel thread
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: R – running or runnable (on run queue)
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S – interruptible sleep (waiting for an event to complete)
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: T – stopped by job control signal
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: t – stopped by debugger during tracing
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: X – dead (should never be seen)
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Z – defunct (“zombie”) process, terminated but not reaped by its parent
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Priority** status (“niceness” – does this process allow other processes to
    take priority over it?).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A process **Owner** (USER in the `ps` output above); the effective user ID.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective **Group ID** (EGID), which is used.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **address map** of the process’s memory space.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource usage – open files, network ports, and other resources the process
    is using (**VSZ** and **RSS** for memory usage in the `ps` output above).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Citation: from the *Unix and Linux System Administration Handbook*, *5th edition*,
    p.91.)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at a few of the process attributes that are most important
    for developers and occasional troubleshooters to understand.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Process ID (PID)
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each process is uniquely identifiable by its process ID, which is just a unique
    integer that is assigned to a process when it starts. Much like a relational database
    with IDs that uniquely identify each row of data, the Linux operating system keeps
    track of each process by its PID.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个唯一的进程 ID（PID），这是在进程启动时分配给它的唯一整数。就像关系型数据库中的 ID 唯一标识每一行数据一样，Linux 操作系统通过
    PID 来跟踪每个进程。
- en: A PID is by far the most useful label for you to use when interacting with processes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: PID 是你与进程交互时最有用的标签。
- en: Effective User ID (EUID) and Effective Group ID (EGID)
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效用户 ID（EUID）和有效组 ID（EGID）
- en: These determine which system user and group your process is running as. Together,
    user and group permissions determine what a process is allowed to do on the system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些决定了你的进程是以哪个系统用户和组身份运行的。用户和组权限共同决定了一个进程在系统上可以执行什么操作。
- en: As you’ll see in *Chapter 5*, *Introducing Files*, files have user and group
    ownership set on them, which determines who their permissions apply to. If a file’s
    ownership and permissions are essentially a lock, then a process with the right
    user/group permissions is like a key that opens the lock and allows access to
    the file. We’ll dive deeper into this later, when we talk about permissions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 *第五章*《文件介绍》中将看到的那样，文件有用户和组所有权，这决定了哪些权限适用于它们。如果文件的所有权和权限本质上是一个锁，那么具有正确用户/组权限的进程就像一把钥匙，打开锁并允许访问该文件。我们将在后面深入探讨权限部分时详细讨论这一点。
- en: Environment variables
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境变量
- en: You’ve probably used environment variables in your applications – they’re a
    way for the operating system environment that launches your process to pass in
    data that the process needs. This commonly includes things like configuration
    directives (`LOG_DEBUG=1`) and secret keys (`AWS_SECRET_KEY`), and every programming
    language has some way to read them out from the context of the program.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在应用程序中使用过环境变量 —— 它们是操作系统环境传递给进程的需要的数据。这通常包括配置指令（`LOG_DEBUG=1`）和密钥（`AWS_SECRET_KEY`），每种编程语言都有某种方式从程序的上下文中读取这些变量。
- en: 'For example, this Python script gets the user’s home directory from the `HOME`
    environment variable, and then prints it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个 Python 脚本从 `HOME` 环境变量获取用户的主目录，然后打印出来：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In my case, running this program in the `python3` REPL on a Linux machine results
    in the following output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的案例中，在 Linux 机器的 `python3` REPL 中运行这个程序，得到如下输出：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Working directory
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作目录
- en: A process has a “current working directory,” just like your shell (which is
    just a process, anyway). Typing `pwd` in your shell prints its current working
    directory, and every process has a working directory. The working directory for
    a process can change, so don’t rely on it too much.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 进程有一个“当前工作目录”，就像你的 shell（反正也是一个进程）一样。在 shell 中输入 `pwd` 会打印当前工作目录，每个进程也都有一个工作目录。进程的工作目录是可以变化的，所以不要过于依赖它。
- en: This concludes our overview of the process attributes that you should know about.
    In the next section, we’ll step away from theory and look at some commands you
    can use to start working with processes right away.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容概述了你应该了解的进程属性。接下来，我们将跳出理论部分，看看一些你可以立即使用的命令，帮助你开始处理进程。
- en: Practical commands for working with Linux processes
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于操作 Linux 进程的实用命令
- en: 'Here are some of the commands you’ll use most often:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些你最常使用的命令：
- en: '`ps` – Shows processes on the system; you saw an example of this command earlier
    in the chapter. Flags modify which process attributes are displayed as columns.
    This command is usually used with filters to control how much output you get,
    for example, (`ps aux | head –n 10`) to cut your output down to just the top 10
    lines. A few more useful tricks:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps` – 显示系统上的进程；你在本章前面已经看到过这个命令的示例。标志可以修改显示的进程属性列。这个命令通常与过滤器一起使用，以控制输出的内容，比如
    (`ps aux | head –n 10`) 只输出前 10 行。还有一些有用的小技巧：'
- en: '`ps –eLf` shows thread information for processes'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps –eLf` 显示进程的线程信息'
- en: '`ps -ejH` is useful for seeing the relationships between parent and child processes
    visually (children are indented under their parents)![](img/B19251_02_02.png)'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps -ejH` 对于直观地查看父子进程之间的关系非常有用（子进程会在父进程下缩进）![](img/B19251_02_02.png)'
- en: 'Figure 2.2: Examples of outputs of the ps command with flags'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.2：带有标志的 ps 命令输出示例
- en: '`pgrep` – Find process IDs by name. Can use regular expressions.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pgrep` – 根据名称查找进程 ID。可以使用正则表达式。'
- en: '![](img/B19251_02_03.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19251_02_03.png)'
- en: 'Figure 2.3: Examples of outputs of the pgrep command with flags'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '`top` – An interactive program that polls all processes (once a second, by
    default) and outputs a sorted list of resource usage (you can configure what it
    sorts by). Also displays total system resource usage. Press *Q* or use *Ctrl*
    + *C* to quit. You’ll see an example of this command’s output later in this chapter.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iotop` – Like `top`, but for disk IO. Extremely useful for finding IO-hungry
    processes. Not installed on all systems by default, but available via most package
    managers.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B19251_02_04.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Example of output of the iotop command'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`nethogs` – Like `top`, but for network IO. Groups network usage by process,
    which is incredibly convenient. Available via most package managers.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B19251_02_05.png)Figure 2.5: Example of output of the nethogs command'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '`kill` – Allows users to send signals to processes, usually to stop them or
    make them re-read their configuration files. We’ll explain signals and `kill`
    command usage later in this chapter.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced process concepts and tools
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This marks the beginning of the “advanced” section of this chapter. While you
    don’t need to master all the concepts in this section to work effectively with
    Linux processes, they can be extremely helpful. If you have a few extra minutes,
    we recommend at least familiarizing yourself with each one.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How does `systemctl` tell your web server to re-read its configuration files?
    How can you politely ask a process to shut down cleanly? And how can you kill
    a malfunctioning process immediately, because it’s bringing your production application
    to its knees?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: In Unix and Linux, all of this is done with signals. Signals are numerical messages
    that can be sent between programs. They’re a way for processes to communicate
    with each other and with the operating system, allowing processes to send and
    receive specific messages.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: These messages can be used to communicate a variety of things to a process,
    for example, indicating that a particular event has happened or that a specific
    action or response is required.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Practical uses of signals
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s look at a few examples of the practical value that the signal mechanism
    enables. Signals can be used to implement inter-process communication; for example,
    one process can send a signal to another process indicating that it’s finished
    with a particular task and that the other process can now start working. This
    allows processes to coordinate their actions and work together in a smooth and
    efficient manner, much like execution threads in programming languages (but without
    the associated memory sharing).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Another common application of process signals is to handle program errors. For
    example, a process can be designed to catch the `SIGSEGV` signal, which indicates
    a segmentation fault. When a process receives this signal, it can trap that signal
    and then take action to log the error, dump core for debugging purposes, or clean
    up any resources that were being used before shutting down gracefully.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Process signals can also be used to implement graceful shutdowns. For example,
    when a system is shutting down, a signal can be sent to all processes to give
    them a chance to save their state and clean up any resources they were using,
    via “trapping” signals.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Trapping
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many of the signals can be “trapped” by the processes that receive them: this
    is essentially the same idea as catching and handling an error in a programming
    language.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: If the receiving process has a handler function for the signal that’s being
    sent, then that handler function is run. That’s how programs re-read their configuration
    without restarting, and finish their database writes and close their file handles
    after receiving the shutdown signal.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The kill command
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'However, it’s not just processes that communicate via signals: the frighteningly
    named (and, technically speaking, incorrectly named) `kill` is a program that
    allows users to send signals to processes, too.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common uses of user-sent processes via the `kill` command is
    to interrupt a process that is no longer responding. For example, if a process
    is stuck in an infinite loop, a “kill” signal can be sent to force it to stop.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The `kill` command allows you to send a signal to a process by specifying its
    PID. If the process you’d like to terminate has PID `2600`, you’d run:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command would send signal 15 (`SIGTERM`, or “terminate”) to the process,
    which would then have a chance to trap the signal and shut down cleanly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the included table of standard signal numbers, the default
    signal that `kill` sends is “terminate” (signal 15), not “kill” (`SIGKILL` is
    9). The `kill` program is not just for killing processes but also for sending
    any kind of signal. It’s really confusingly named and I’m sorry about that – it’s
    just one of those idiosyncrasies of Unix and Linux that you’ll get used to.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want to send the default signal 15, you can specify the signal
    you’d like to send with a dash; to send a `SIGHUP` to the same process, you’d
    run:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running `man` `signal` will give you a list of signals that you can send:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19251_02_06.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Example of output of the man signal command'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'It pays – sometimes quite literally, in engineering interviews – to be familiar
    with a few of these:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGHUP` (1) – “hangup”: interpreted by many applications – for example, nginx
    – as “re-read your configuration because I’ve made changes to it.”'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGINT` (2) – “interrupt”: often interpreted the same as `SIGTERM` - “please
    shut down cleanly.”'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTERM` (15) – “terminate”: nicely asks a process to shut down.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGUSR1` (30) and `SIGUSR2` (31) are sometimes used for application-defined
    messaging For example, SIGUSR1 asks nginx to re-open the log files it’s writing
    to, which is useful if you’ve just rotated them.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGKILL` (9) – `SIGKILL` cannot be trapped and handled by processes. If this
    signal is sent to a program, the operating system will kill that program immediately.
    Any cleanup code, like flushing writes or safe shutdown, is not performed, so
    this is generally a last resort, since it could lead to data corruption.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to explore Linux a bit deeper, feel free to poke around the `/proc`
    directory. That’s definitely beyond the basics, but it’s a directory that contains
    a filesystem subtree for every process, where live information about the processes
    is looked up as you read those files.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In practice, this knowledge can come in handy during troubleshooting when you’ve
    identified a misbehaving (or mysterious) process and want to know exactly what
    it’s doing in real time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: You can learn a lot about a process by poking around in its `/proc` subdirectory
    and casually googling.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Many of the tools we show you in this chapter actually use `/proc` to gather
    process information, and only show you a subset of what’s there. If you want to
    see *everything* and do the filtering yourself, `/proc` is the place to look.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: lsof – show file handles that a process has open
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `lsof` command shows all files that a process has opened for reading and
    writing. This is useful because it only takes one small bug for a program to leak
    file handles (internal references to files that it has requested access to). This
    can lead to resource usage issues, file corruption, and a long list of strange
    behavior.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, getting a list of files that a process has open is easy. Just run
    `lsof` and pass the `–p` flag with a PID (you’ll usually have to run this as root).
    This will return the list of files that the process (in this case, with PID 1589)
    has open:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/B19251_02_07.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Example of list of files opened by the 1589 process using the lsof
    -p 1589 command'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'The above is the output for an nginx web server process. The first line shows
    you the current working directory for the process: in this case, the root directory
    (`/`). You can also see that it has file handles open on its own binary (`/usr/sbin/nginx`)
    and various libraries in `/usr/lib/`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Further down, you might notice a few more interesting filepaths:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19251_02_08.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Further opened files of the 1589 process'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: This listing includes the log files nginx is writing to, and socket files (Unix,
    IPv4, and IPv6) that it’s reading and writing to. In Unix and Linux, network sockets
    are just a special kind of file, which makes it easy to use the same core toolset
    across a wide variety of use cases – tools that work with files are extremely
    powerful in an environment where almost everything is represented as a file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Except for the very first process, `init` (`PID 1`), all processes are created
    by a parent process, which essentially makes a copy of itself and then “forks”
    (splits) that copy off. When a process is forked, it typically inherits its parent’s
    permissions, environment variables, and other attributes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this default behavior can be prevented and changed, it’s a bit of
    a security risk: software that you run manually receives the permissions of your
    current user (or even root privileges, if you use `sudo`). All child processes
    that might be created by that process – for example, during installation, compilation,
    and so on – inherit those permissions.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a web server process that was started with root privileges (so it could
    bind to a network port) and environment variables containing cloud authentication
    keys (so it could grab data from the cloud). When this main process forks off
    a child process that needs neither root privileges nor sensitive environment variables,
    it’s an unnecessary security risk to pass those along to the child. As a result,
    dropping privileges and clearing environment variables is a common pattern in
    services spawning child processes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: From a security perspective, it is important to keep this in mind to prevent
    situations where information such as passwords or access to sensitive files could
    be leaked. While it is outside the scope of this book to go into details of how
    to avoid this, it’s important to be aware of this if you’re writing software that’s
    going to run on Linux systems.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Review – example troubleshooting session
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s look at an example troubleshooting session. All we know is that one specific
    Linux server is running extremely slowly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we want to see what’s happening on the system. You just learned
    that you can see a live view of processes running on a system by running the interactive
    `top` command. Let’s try that now.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19251_02_09.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Example of output of the top command'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `top` command sorts processes by CPU usage, so we can simply
    look at the first listed process to find the offending one. Indeed, the top process
    is using 94% of one CPU’s available processing time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result of running `top`, we’ve gotten a few useful pieces of information:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The problem is CPU usage, as opposed to some other kind of resource contention.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The offending process is PID 1763, and the command being run (listed in the
    **COMMAND** column) is `bzip2`, which is a compression program.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We determine that this `bzip2` process doesn’t need to be running here, and
    we decide to stop it. Using the `kill` command, we ask the process to terminate:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After waiting a few seconds, we check to see if this (or any other) `bzip2`
    process is running:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Unfortunately, we see that the same PID is still running. It’s time to get
    serious:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This orders the operating system to kill the process without allowing the process
    to trap (and potentially ignore) the signal. A `SIGKILL` (signal #9) simply kills
    the process where it stands.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这会指示操作系统终止该进程，并且不会允许进程拦截（并可能忽略）信号。`SIGKILL`（信号#9）直接终止进程。
- en: Now that you’ve killed the offending process, the server is running smoothly
    again and you can start tracking down the developer who thought it was a good
    idea to compress large source directories on this machine.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经杀死了那个有问题的进程，服务器再次平稳运行，你可以开始追查那个认为在这台机器上压缩大型源目录是个好主意的开发者。
- en: 'In this example, we followed the most common systems troubleshooting pattern
    in existence:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们遵循了最常见的系统故障排除模式：
- en: We looked at resource usage (via `top` in this example). This can be any of
    the other tools we discussed, depending on which resource is the one being exhausted.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们查看了资源使用情况（通过`top`命令查看）。这可以是我们讨论的任何其他工具，具体取决于哪个资源被耗尽。
- en: We found a PID to investigate.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们找到了一个PID来进行调查。
- en: We acted on that process. In this example, no further investigation was necessary
    and we sent a signal, asking it to shut down (15, `SIGTERM`).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们按照这个流程操作。在这个例子中，无需进一步调查，我们发送了一个信号，要求它关闭（15, `SIGTERM`）。
- en: Conclusion
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we took a close look at the process abstraction that Linux
    wraps around executing programs. You’ve seen the common components that all processes
    have and learned the basic commands you need to find and inspect running processes.
    With these tools, you’ll be able to identify when a process is misbehaving, and
    more importantly, *which* process is misbehaving.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入了解了Linux对执行程序的进程抽象。你已经看到所有进程都有的共同组件，并学习了查找和检查正在运行的进程所需的基本命令。借助这些工具，你将能够识别进程何时出现问题，更重要的是，*哪个*进程出现了问题。
- en: Learn more on Discord
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 若要加入本书的Discord社区——在这里你可以分享反馈，向作者提问，了解新版本的发布——请扫描下面的二维码：
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code1768422420210094187.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1768422420210094187.png)'
