- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Storage Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储管理
- en: It feels like there’s never going to be enough space on our servers for everything
    that needs to be stored there. Despite the fact that the storage capacity of hard
    disks continues to increase and high-capacity disks are now more affordable than
    ever, our servers quickly fill up any available space. Our best efforts as server
    administrators have always been to order machines with as much storage as possible,
    but the reality is that even the most well-planned enterprises eventually run
    out of space. Additional storage space will certainly need to be added at some
    point in the course of administering your servers. Storage management, however,
    entails more than simply replacing full disks with empty ones. **Logical Volume
    Manager** (**LVM**) and other similar technologies can greatly simplify your work
    if you start using them as soon as possible, thus it’s crucial to plan ahead.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 感觉我们的服务器永远不会有足够的空间来存储所有需要存储的内容。尽管硬盘的存储容量不断增加，高容量硬盘如今比以往任何时候都更加实惠，但我们的服务器很快就会填满所有可用空间。作为服务器管理员，我们最好的努力一直是订购尽可能多存储的机器，但现实是，即使是最精心规划的企业，最终也会用完空间。到某个时候，肯定需要为你的服务器增加额外的存储空间。然而，存储管理不仅仅是将已满的硬盘替换为空硬盘。如果你尽早开始使用**逻辑卷管理器**（**LVM**）和其他类似技术，它们可以大大简化你的工作，因此提前规划非常重要。
- en: 'The concepts discussed in this chapter, including LVM itself, will allow you
    greater freedom in the management of servers. I will also explain some other ideas
    that will prove useful when you work with volumes and storage on your server.
    In particular, the following topics will be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中讨论的概念，包括LVM本身，将使你在管理服务器时拥有更大的自由。我还将解释一些在你处理服务器上的卷和存储时非常有用的其他概念。特别是，以下主题将会涵盖：
- en: Creating new volumes in a filesystem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件系统中创建新卷
- en: How to format and partition storage devices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何格式化和分区存储设备
- en: How to mount and unmount volumes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何挂载和卸载卷
- en: Learning how to use a `/``etc/fstab` file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用`/etc/fstab`文件
- en: Working with **Logical Volume** **Manager** (**LVM**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**逻辑卷** **管理器**（**LVM**）
- en: Adding additional storage volumes
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加额外的存储卷
- en: Additional server storage space will likely be required at some time. The capacity
    of a server can be expanded by installing more hard drives, either on a standalone
    machine or by using cloud computing. Whatever its name may be, we’ll need to find
    out how to format and mount the device before we can use the additional space.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，可能需要额外的服务器存储空间。通过安装更多的硬盘，可以扩展服务器的容量，这可以在独立机器上进行，或者通过使用云计算来实现。不管其名称是什么，在我们能够使用额外空间之前，我们需要弄清楚如何格式化和挂载设备。
- en: 'Using LVM (which we will cover later in this chapter), we can easily add space
    to an existing volume without restarting the server. However, there is an overarching
    procedure that must be followed when introducing a new device. The following are
    a few things to consider while upgrading your system’s storage capacity:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LVM（我们将在本章后面讲到），我们可以轻松地向现有卷中添加空间而不需要重新启动服务器。然而，在引入新设备时，必须遵循一套总体流程。以下是在升级系统存储容量时需要考虑的几个事项：
- en: '**Can you tell me how much space you’ll need?** If there is enough free space
    in your hypervisor’s storage pool, you can create a virtual disk of any size you
    like.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你能告诉我你需要多少空间吗？** 如果你的虚拟化环境的存储池中有足够的空闲空间，你可以创建任何大小的虚拟磁盘。'
- en: '`/``dev/sdb1`, `/dev/sdb2`).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev/sdb1`、`/dev/sdb2`）。'
- en: '**What format do you want for your device?** At present, ext4 is the most widely
    used filesystem. However, there are additional choices you might make for various
    tasks (such as XFS). Use ext4 if you’re unsure, but research the alternatives
    to see if any better suit your needs. ZFS is an additional possibility; however,
    it is more recent than many of the other filesystems out there. You may know this
    already, but new Linux users may be confused by the fact that the term *filesystem*
    has many meanings, depending on the situation. When discussing the file and directory
    structure of a normal Linux system, we Linux administrators will most often use
    the term *filesystem*. On the other hand, the phrase can also refer to the format
    of a disk that is compatible with the distribution (for example, the ext4 filesystem).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你希望为设备选择什么格式？** 目前，ext4 是最广泛使用的文件系统。然而，根据不同任务（例如 XFS），你可能会做出其他选择。如果不确定，请使用
    ext4，但也可以研究其他选择，看看是否有更适合你的需求的文件系统。ZFS 是一个额外的选择；然而，它比许多其他文件系统更新。你可能已经知道这一点，但新手
    Linux 用户可能会对 *文件系统* 这个术语感到困惑，因为它在不同的情境下有不同的含义。当讨论正常 Linux 系统的文件和目录结构时，我们 Linux
    管理员通常使用 *文件系统* 这个术语。另一方面，这个术语也可以指代与发行版兼容的磁盘格式（例如 ext4 文件系统）。'
- en: '**Where do you want it mounted?** Since the new disk must be reachable by the
    system and possibly users, you must mount (attach) it to a directory on your filesystem
    from which users or applications can access it. In this chapter, we also cover
    LVM, and in most cases, you’ll want to add it to an existing storage group. The
    new volume can be used with any directory you like, but I’ll go over some typical
    ones in the *Formatting and partitioning storage devices* section. In the *Mounting
    and unmounting volumes* section, we will discuss the mounting and unmounting processes
    in detail.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你希望将它挂载在哪里？** 由于新磁盘必须能够被系统以及可能的用户访问，因此你必须将它挂载（连接）到文件系统中的某个目录，用户或应用程序可以从该目录访问它。在本章中，我们还会介绍
    LVM，通常情况下，你会希望将它添加到现有的存储组中。新的卷可以与任何你喜欢的目录一起使用，但我将在 *格式化和分区存储设备* 章节中介绍一些典型的目录。在
    *挂载和卸载卷* 章节中，我们将详细讨论挂载和卸载过程。'
- en: Let’s think about the responses to the first two queries. To determine how much
    more room you should implement, you should analyze your program’s or company’s
    requirements. When it comes to actual disks, your options are limited to which
    disk to buy. With virtual drives, you can be more thrifty by adding a smaller
    disk to serve your needs (you can always add more later). The primary advantage
    of using LVM with virtual drives is the ability to increase a filesystem without
    restarting the server. If you have a 50 GB volume and want to make it larger,
    you can create two more 10 GB virtual disks and enlarge it that way.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下前两个问题的答案。为了确定你应该实施多少额外空间，你需要分析你的程序或公司的需求。对于实际的磁盘，你的选择仅限于购买哪种磁盘。使用虚拟磁盘时，你可以通过添加一个较小的磁盘来节省成本，以满足需求（你以后可以随时添加更多磁盘）。使用
    LVM 与虚拟磁盘的主要优势是能够在不重启服务器的情况下增加文件系统的大小。如果你有一个 50 GB 的卷，并且希望将它做大，你可以创建两个 10 GB 的虚拟磁盘，并通过这种方式扩展它。
- en: 'While LVM is not limited to virtual servers, it can be used on physical servers
    as well; however, doing so would likely necessitate a reboot due to the need to
    open the casing and physically attach a hard drive. The ability to add or remove
    physical hard disks from some servers is called `fdisk -l` into a terminal. We
    can find out what our new disk is called by using the `fdisk` command, which is
    more commonly used to create and erase partitions. If you run the `fdisk -l` command
    as `root` or with `sudo`, you’ll get the following details:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 LVM 并不限于虚拟服务器，但它也可以用于物理服务器；然而，这样做可能需要重启，因为你需要打开机箱并物理连接硬盘。某些服务器可以添加或移除物理硬盘的功能称为
    `fdisk -l`，你可以在终端中输入该命令。我们可以使用 `fdisk` 命令来查看新磁盘的名称，`fdisk` 更常用于创建和删除分区。如果你以 `root`
    用户身份或使用 `sudo` 运行 `fdisk -l` 命令，你将获得以下详细信息：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Figure 10.1 – Listing all disks](img/B18575_10_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 列出所有磁盘](img/B18575_10_01.jpg)'
- en: Figure 10.1 – Listing all disks
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 列出所有磁盘
- en: Now that we have learned how to list all the disks, we will next learn how to
    format and partition storage devices.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何列出所有磁盘，接下来我们将学习如何格式化和分区存储设备。
- en: Formatting and partitioning storage devices
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化和分区存储设备
- en: 'A disk must be formatted before it can be used. Finding the device’s given
    name is necessary to format the right disk. If you read the last section, you
    know that drives in Linux distributions follow a predetermined naming convention.
    Consequently, you should be familiar with the new disk’s device name. You can
    view information about the storage devices connected to your server using the
    `sudo fdisk -l` command, as previously mentioned:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘必须在使用前进行格式化。找到设备的名称对于格式化正确的磁盘是必要的。如果你阅读了上一节，你就会知道Linux发行版中的驱动器遵循预定的命名约定。因此，你应该熟悉新磁盘的设备名称。你可以使用`sudo
    fdisk -l`命令查看连接到服务器的存储设备信息，如前所述：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Figure 10.2 – Listing all disks](img/B18575_10_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 列出所有磁盘](img/B18575_10_02.jpg)'
- en: Figure 10.2 – Listing all disks
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 列出所有磁盘
- en: The `/dev/sdb` device is new to my server, as I just installed it (see *Figure
    10**.2*). I’m using it for the exercises in this chapter. Currently, it is not
    partitioned. At this point, it’s quite clear that the storage device referenced
    by `/dev/sdb` in the previous example is brand new. To avoid losing data, we must
    be careful never to format or repartition the wrong device. Since there are no
    partitions on `/dev/sdb` (as this volume wasn’t there before I added it), it’s
    evident that this is the disk we should work with. One or more partitions can
    be made on it at this point, bringing us one step closer to actually using it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/sdb`设备是我新安装到服务器上的（见*图 10.2*）。我将在本章的练习中使用它。目前，它尚未分区。此时，很明显，在前面的例子中提到的存储设备`/dev/sdb`是全新的。为了避免丢失数据，我们必须小心，绝对不能格式化或重新分区错误的设备。由于`/dev/sdb`上没有任何分区（因为在我添加它之前这个磁盘并不存在），显然这是我们应该操作的磁盘。在此时，可以在其上创建一个或多个分区，距离实际使用它又近了一步。'
- en: 'Using the `fdisk` command with `sudo` and the device’s name as an option, we
    can partition the drive. The following is the command I would use to access disk
    `/dev/sdb`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有`sudo`和设备名称选项的`fdisk`命令，我们可以对驱动器进行分区。以下是我用来访问磁盘`/dev/sdb`的命令：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ll see that I didn’t specify a partition number because `fdisk` deals with
    the disk directly (and we also have yet to create any partitions). In this section,
    I will assume that you have access to a drive that hasn’t been partitioned yet
    or is completely erasable. Upon successful execution, `fdisk` will display an
    introductory message and prompt.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到我没有指定分区号，因为`fdisk`直接操作磁盘（而且我们还没有创建任何分区）。在本节中，我将假设你可以访问一个尚未分区或完全可以擦除的驱动器。成功执行后，`fdisk`将显示一个介绍性消息并提示你操作。
- en: 'To see a list of available commands, use the `m` key on your keyboard, as shown
    in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用命令的列表，可以按键盘上的`m`键，如以下截图所示：
- en: '![Figure 10.3 – Help menu for fdisk](img/B18575_10_03.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – `fdisk`的帮助菜单](img/B18575_10_03.jpg)'
- en: Figure 10.3 – Help menu for fdisk
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – `fdisk`的帮助菜单
- en: 'Here, I will demonstrate the sequence of steps necessary to create a new disk.
    Understand that `fdisk` can do serious damage to your system. Using `fdisk` on
    the wrong drive can cause permanent data loss. It’s normal for administrators
    to internalize the use of tools such as`fdisk` to the point where it’s second
    nature; however, before executing any such instructions, double-check that you’re
    indeed accessing the correct disk. There are two types of partition tables – the
    `fdisk`. There are restrictions to think about when using MBR partition tables.
    To begin with, there is a limit of four primary partitions in MBR. It also restricts
    your disk use to about 2 TB. As long as your disk is under 2 TB in size, you should
    be fine, but disks greater than 2 TB are becoming increasingly prevalent. However,
    GPT doesn’t limit partition sizes, so if you have a disk that’s many TB in size,
    the choice between MBR and GPT is already made for you. In addition, `fdisk` with
    a GPT partition table allows you to construct up to 128 primary partitions. The
    following command gives options on what to do with the specific HDD, `/dev/sdb`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将演示创建新磁盘所需的步骤。需要了解的是，`fdisk`可能会对你的系统造成严重损害。在错误的硬盘上使用`fdisk`可能导致永久性数据丢失。管理员通常会熟练地使用像`fdisk`这样的工具，以至于使用它们变成了第二天性；然而，在执行任何此类指令之前，请再次检查你是否确实在操作正确的磁盘。分区表有两种类型
    —— `fdisk`。使用MBR分区表时有一些限制。首先，MBR限制最多只能有四个主分区。它还将磁盘使用限制为约2 TB。如果你的磁盘小于2 TB，应该没有问题，但大于2
    TB的磁盘越来越常见。然而，GPT并没有限制分区大小，因此，如果你有一个多TB大小的磁盘，那么MBR和GPT之间的选择已经为你决定了。此外，`fdisk`与GPT分区表一起使用时，允许你构建最多128个主分区。以下命令给出了如何操作特定硬盘`/dev/sdb`的选项：
- en: '![Figure 10.4 – Creating a new partition](img/B18575_10_04.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 创建新分区](img/B18575_10_04.jpg)'
- en: Figure 10.4 – Creating a new partition
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 创建新分区
- en: 'I used GPT, so I had to enter `g`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了GPT，因此我输入了`g`：
- en: '![Figure 10.5 – Creating a new GPT partition table](img/B18575_10_05.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 创建新的GPT分区表](img/B18575_10_05.jpg)'
- en: Figure 10.5 – Creating a new GPT partition table
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 创建新的GPT分区表
- en: Don’t forget to enter `w` to save changes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了输入`w`以保存更改。
- en: If you made any mistakes, you can run `fdisk` again. After entering the `fdisk`
    prompt again, you can construct a new GPT layout by hitting `g`, or a new MBR
    layout by typing `o` if you made a mistake or simply wish to start over. Partitioning
    your drive is a two-step process, so you’ll need to repeat the previous stages.
    You can try this out for yourself a few times until you get the hang of it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你犯了错误，可以再次运行`fdisk`。再次输入`fdisk`提示符后，如果你犯了错误或只是想重新开始，可以通过按`g`构建一个新的GPT布局，或者输入`o`来创建一个新的MBR布局。磁盘分区是一个两步过程，因此你需要重复之前的步骤。你可以自己多次尝试，直到掌握为止。
- en: 'Now, using `fdisk -l /dev/sdb`, we can see there is a new partition, `/dev/sdb2`,
    as shown in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`fdisk -l /dev/sdb`，我们可以看到有一个新分区`/dev/sdb2`，如下面的截图所示：
- en: '![Figure 10.6 – Listing the partitions for /dev/sdb HDD](img/B18575_10_06.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 列出`/dev/sdb`硬盘的分区](img/B18575_10_06.jpg)'
- en: Figure 10.6 – Listing the partitions for /dev/sdb HDD
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 列出`/dev/sdb`硬盘的分区
- en: Now that we have learned how to create a new partition, we will see how to format
    it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经学习了如何创建新分区，接下来我们将看到如何格式化它。
- en: Formatting a newly created partition
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化新创建的分区
- en: Your new partition can be formatted once you’ve finished designing the disk’s
    partition arrangement and are satisfied with it. The results of `sudo fdisk -l`
    will be different now that I have partitioned the new drive.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了磁盘分区的设计并对其满意，你的新分区就可以被格式化了。由于我已经分区了新硬盘，`sudo fdisk -l`的结果将会有所不同。
- en: 'A new partition, `/dev/sdb2`, has been created and is reflected in the output.
    We can proceed with the formatting at this time. The `mkfs` command is used to
    create the filesystem. In order to execute this operation, you must use the correct
    syntax, which consists of entering `mkfs`, followed by a period (`.`), and then
    the name of the filesystem you wish to create. Using this code as an example,
    we can format `/dev/sdb2` as `ext4` by running the `sudo mkfs.ext4 /``dev/sdb2`
    command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 新分区`/dev/sdb2`已经创建，并反映在输出中。此时我们可以继续进行格式化操作。`mkfs`命令用于创建文件系统。为了执行此操作，必须使用正确的语法，即输入`mkfs`，后跟一个句点（`.`），然后是你希望创建的文件系统的名称。以这个代码为例，我们可以通过运行`sudo
    mkfs.ext4 /dev/sdb2`命令将`/dev/sdb2`格式化为`ext4`：
- en: '![Figure 10.7 – Formatting a partition](img/B18575_10_07.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 格式化分区](img/B18575_10_07.jpg)'
- en: Figure 10.7 – Formatting a partition
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 格式化分区
- en: It is important to remember to format the partition; otherwise, it won’t be
    usable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 记得格式化分区，否则它将无法使用。
- en: Mounting and unmounting volumes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂载和卸载卷
- en: 'The next step after adding and formatting a new storage volume on your server
    is mounting the device. The `mount` command accomplishes this task. With this
    command, you can link a removable drive (or a network share) to a directory on
    the server’s hard drive. Mounting requires a clean directory. In order to mount
    a device, you must specify a directory to mount it to by using the `mount` command,
    which we will practice with an example shortly. Mounting additional storage is
    as simple as issuing the `mount` command and selecting a location that isn’t currently
    mounted or full of data. `mount` is a command that normally requires root privileges
    to execute. However, in most cases, only the root should mount volumes (although
    there is a workaround that involves allowing regular users to mount volumes; we
    won’t discuss that right now). Since you need a directory in which to mount these
    volumes, I’ll show you how to make one called `/usbpartition` using the following
    command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上添加和格式化新的存储卷之后的下一步是挂载设备。`mount` 命令完成了这个任务。通过这个命令，你可以将一个可移动驱动器（或网络共享）连接到服务器硬盘上的一个目录。挂载需要一个干净的目录。为了挂载设备，你必须使用
    `mount` 命令指定一个挂载目录，我们稍后将通过一个示例来实践这个过程。挂载额外存储非常简单，只需执行 `mount` 命令并选择一个当前未挂载或没有数据的目录。`mount`
    命令通常需要 root 权限才能执行。然而，在大多数情况下，只有 root 用户应该挂载卷（尽管也有一种解决方法可以允许普通用户挂载卷；我们暂时不讨论这个问题）。由于需要一个目录来挂载这些卷，接下来我将展示如何使用以下命令创建一个名为
    `/usbpartition` 的目录：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the preceding command, I mount the `/dev/sdb2` device to the `/usbpartition`
    directory as an example. Obviously, you’ll need to change the `/dev/sdb2` and
    `/usbpartition` references to reflect your own device and directory choices. A
    mount normally requires the `-t` option to specify the device type, but `fdisk
    -l` can be used as a handy reminder if you’ve forgotten what devices are installed
    on your server. The `mount` command that I should have used with the `-t` option,
    given that my disk is ext4-formatted, is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我将 `/dev/sdb2` 设备挂载到 `/usbpartition` 目录作为示例。显然，你需要将 `/dev/sdb2` 和 `/usbpartition`
    替换为你自己选择的设备和目录。挂载通常需要 `-t` 选项来指定设备类型，但如果你忘记了服务器上安装了哪些设备，可以使用 `fdisk -l` 命令作为一个方便的提醒。由于我的磁盘是
    ext4 格式化的，我应该使用以下带 `-t` 选项的 `mount` 命令：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To check whether this has been mounted properly, use this command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查是否正确挂载，可以使用以下命令：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you’re done working with a volume, you can unmount it with the `umount`
    command (the *n* in *unmount* is left out on purpose):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了与某个卷的操作，可以使用 `umount` 命令卸载它（`unmount` 中的 *n* 被故意省略）：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is possible to remove a storage device from your filesystem using the `umount`
    command, which also requires you to be logged in as root or with `sudo`. The volume
    must be turned off for this command to take effect. A device or resource busy
    error message may appear if this is the case. After unmounting, you can verify
    that the filesystem is no longer mounted by running `df -h` and noting that it
    does not return any results. When devices are manually mounted, they will unmount
    when the server reboots. I will show you how to update the `/etc/fstab` file so
    that the mount is available at server startup in the following section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `umount` 命令可以将存储设备从文件系统中移除，执行此命令也要求你以 root 用户身份登录或使用 `sudo`。为了让此命令生效，卷必须先关闭。如果出现设备或资源忙碌的错误消息，那就说明卷仍在使用中。卸载之后，你可以通过运行
    `df -h` 命令来验证文件系统是否已经不再挂载，并且可以注意到它不再返回任何结果。当设备是手动挂载时，服务器重启时它们会自动卸载。接下来的部分我将展示如何更新
    `/etc/fstab` 文件，以便在服务器启动时自动挂载该卷。
- en: Updating the /etc/fstab file
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 `/etc/fstab` 文件
- en: An essential Linux system file is the `/etc/fstab` file. You can manually mount
    additional volumes at boot time by editing this file. However, this file’s primary
    function is to mount your primary filesystem, thus any mistakes you make while
    modifying it will prevent your server from starting up (at all). Take extreme
    caution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的 Linux 系统文件是 `/etc/fstab` 文件。你可以通过编辑此文件在启动时手动挂载额外的卷。然而，这个文件的主要功能是挂载你的主文件系统，因此在修改它时，任何错误都会导致服务器无法启动（完全无法启动）。因此需要非常小心。
- en: The location of the root filesystem is determined by reading the `/etc/fstab`
    file, which is read during system boot. This file is also used to determine the
    swap partition’s location, and it is mounted at boot time. Each mount point in
    this file will be read and mounted sequentially by your system. This file can
    be used to automatically mount almost any type of storage device. You can even
    install Windows server network shares. In other words, it has no morals and won’t
    pass judgment (unless you make a typo).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统的位置是通过读取`/etc/fstab`文件来确定的，该文件在系统启动时被读取。此文件还用于确定交换分区的位置，并在启动时进行挂载。系统将按顺序读取并挂载该文件中的每个挂载点。该文件可以用于自动挂载几乎任何类型的存储设备。你甚至可以安装Windows服务器网络共享。换句话说，它没有道德观，不会做出判断（除非你打错了字）。
- en: 'This is what an `/etc/fstab` file looks like:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`/etc/fstab`文件的示例：
- en: '![Figure 10.8 – A sample of an /etc/fstab file](img/B18575_10_08.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – `/etc/fstab`文件示例](img/B18575_10_08.jpg)'
- en: Figure 10.8 – A sample of an /etc/fstab file
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – `/etc/fstab`文件示例
- en: It is important to be careful when editing this file, as incorrect settings
    can cause the system to fail to boot or cause data loss. It is recommended to
    make a backup of the file before making any changes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑此文件时需要小心，因为不正确的设置可能导致系统无法启动或造成数据丢失。建议在进行任何更改之前备份该文件。
- en: Editing /etc/fstab file
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑`/etc/fstab`文件
- en: As we mentioned earlier, any device mounted manually won’t be mounted automatically
    on reboot.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，任何手动挂载的设备在重启后不会自动挂载。
- en: In order to do it automatically, the device has to be added to the `/``etc/fstab`
    file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现自动挂载，必须将设备添加到`/etc/fstab`文件中。
- en: 'I added an entry in `/etc/fstab` to mount `/dev/sdb2` automatically in `/usbpartition/`
    on boot, as shown in the last line of the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`/etc/fstab`文件中添加了一条记录，以便在启动时自动挂载`/dev/sdb2`到`/usbpartition/`，如下图所示：
- en: '![Figure 10.9 – A sample of the /etc/fstab file](img/B18575_10_09.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – `/etc/fstab`文件示例](img/B18575_10_09.jpg)'
- en: Figure 10.9 – A sample of the /etc/fstab file
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – `/etc/fstab`文件示例
- en: On my machine, both the fifth and sixth columns read `0`, indicating a successful
    dump and a passing grade. Nearly invariably set to `0`, the dump partition can
    be checked by a backup program to see whether the filesystem needs to be backed
    up (`0` for no, and `1` for yes). Since almost nothing uses this anymore, you
    can usually just leave it at `0`. Filesystems will be checked in the order specified
    in the pass field. In the event of a system crash or as part of a routine maintenance
    procedure, the `fsck` utility checks drives for filesystem problems. Values can
    be either a `0` or a `1`. When set to `0`, `fsck` will never run to check on the
    partition. If this value is `1`, the partition is examined before anything else.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，第五列和第六列都为`0`，表示转储成功并且通过了检查。几乎总是设置为`0`，转储分区可以被备份程序检查，以查看文件系统是否需要备份（`0`表示不需要，`1`表示需要）。由于现在几乎没有人再使用这个功能，通常可以将其保留为`0`。文件系统会按照“通过”字段中指定的顺序进行检查。在系统崩溃或例行维护过程中，`fsck`工具会检查磁盘是否有文件系统问题。值可以是`0`或`1`。设置为`0`时，`fsck`将永远不会检查该分区。如果值为`1`，则会在其他任何操作之前检查该分区。
- en: By default, only the root user can modify the `/etc/fstab` file, so it’s important
    to be careful when editing it. Incorrectly modifying this file can cause serious
    problems with the system’s boot process and data integrity.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只有根用户可以修改`/etc/fstab`文件，因此在编辑时需要小心。错误修改此文件可能会导致系统启动过程或数据完整性出现严重问题。
- en: Utilizing LVM
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LVM
- en: Your organization’s requirements will evolve over time. As server administrators,
    we constantly strive to set up resources with future expansion in mind. Unfortunately,
    budgets and policy shifts frequently get in the way. You’ll find that LVM is invaluable
    in the long run. Linux’s superiority in scalability and cloud deployments is due
    in large part to technologies such as LVM. By using LVM, you can expand or contract
    your filesystems without having to restart the server. Consider the following
    scenario. Say you have a mission-critical app operating on a virtualized production
    server. It’s possible that when you initially set up the server, you allocated
    300 GB of space for the application’s data directory, thinking it would never
    grow to fill that much space. The expansion of your company has not only increased
    your space requirements but also created a crisis. So, tell me, what do you do?
    If the server was initially configured to use LVM, then adding a new storage volume,
    including it in the LVM pool, and expanding the partition would not require a
    reboot. However, without LVM, you’d have to schedule downtime for your server
    while you added more storage the old-fashioned way, which could take hours. Even
    if your server isn’t virtual, you can still profit from expanding your filesystem
    online by installing more hard drives and leaving them on standby without using
    them. In addition, you can add more volumes without having to shut down the server
    if your server supports hot-plugging. Because of this, I can’t stress enough how
    important it is to use LVM whenever possible on storage volumes in virtual servers.
    Again, LVM is essential to set up storage volumes on a virtual server. If you
    don’t, you’ll have to spend your weekends laboring to add disks, since you will
    have ran out of space during the week.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，您所在组织的需求将不断发展。作为服务器管理员，我们不断努力在设置资源时考虑未来的扩展需求。不幸的是，预算限制和政策变动经常成为障碍。从长远来看，您会发现LVM是不可或缺的。Linux在可扩展性和云部署方面的优势，归功于像LVM这样的技术。通过使用LVM，您可以在不重新启动服务器的情况下扩展或收缩文件系统。考虑以下情境：假设您有一个关键任务应用程序在虚拟化的生产服务器上运行。可能在最初设置服务器时，您为该应用程序的数据目录分配了300GB的空间，认为它永远不会扩展到这么大的空间。随着公司发展，您的空间需求不仅增加了，还带来了危机。那么，您该怎么办？如果服务器最初配置为使用LVM，那么添加一个新的存储卷，将其包含在LVM池中，并扩展分区，将无需重新启动。然而，如果没有LVM，您就得为服务器安排停机时间，以便用传统方式添加更多存储，这可能需要几个小时。即便您的服务器不是虚拟化的，您仍然可以通过安装更多硬盘并将其保持待机状态来在线扩展文件系统，而无需使用它们。此外，如果服务器支持热插拔，您可以添加更多卷而不必关闭服务器。正因如此，我无法过分强调，在虚拟服务器的存储卷上尽可能使用LVM的重要性。再说一次，LVM对于虚拟服务器上存储卷的设置至关重要。如果不使用，您将不得不花费周末的时间来添加磁盘，因为您在工作日已经耗尽了空间。
- en: Getting started with LVM
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LVM入门
- en: Linux’s server installer allows you to select LVM as a volume manager for a
    fresh server setup. However, LVM should be utilized extensively for storage volumes,
    especially those that will house user and application data. If you want the root
    filesystem on your Ubuntu server to take advantage of LVM’s functionality, LVM
    is a good option. We’ll need to have a firm grasp on volume groups, physical volumes,
    and logical volumes before we can begin using LVM. The logical and physical volumes
    you intend to use with an LVM solution are organized into volume groups. In a
    nutshell, a volume group is the umbrella term for your whole LVM infrastructure.
    You can think of it as a container that can hold disks. A `vg-accounting` volume
    group is an illustration of this type of group. The accounting department would
    use this volume group to store their records. It will include both the actual
    disk space and the virtual disk space that these users will access. It’s worth
    noting that you’re not restricted to a single volume group but can instead create
    multiple, each with its own set of disks and volumes. A physical volume is a disk,
    either real or virtual, that belongs to a volume group. A `vg-accounting` volume
    group might theoretically have three 500 GB hard drives, each of which would be
    treated as a physical volume. Keep in mind that, although these disks are virtual,
    in the context of LVM they are still referred to as physical volumes. A physical
    volume is a storage device that belongs to a volume group. Finally, the concept
    of logical volumes is comparable to that of partitions. In contrast to traditional
    partitions, logical volumes can span over numerous physical drives. A logical
    volume, for instance, may be set up with three 500 GB disks, giving you access
    to a total of 1,500 GB. When it’s mounted, it acts like a single partition on
    a regular hard drive, allowing users to save and access files with the same ease
    as they would with any other disk. When the space on the volume runs out, you
    can expand it by adding a new disk and then expanding the partition. Although
    it may actually be comprised of several hard drives, to your users it will appear
    as a single, unified space. Physical volumes can be subdivided in any way that
    makes sense to you. Users will interact with logical volumes, which are created
    from the underlying physical volumes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的服务器安装程序允许你选择LVM作为全新服务器设置的卷管理器。然而，LVM应该广泛用于存储卷，尤其是那些将容纳用户和应用程序数据的卷。如果你希望Ubuntu服务器的根文件系统能够利用LVM的功能，LVM是一个不错的选择。在开始使用LVM之前，我们需要牢牢掌握卷组、物理卷和逻辑卷的概念。你打算与LVM解决方案一起使用的逻辑卷和物理卷会被组织到卷组中。简而言之，卷组是整个LVM架构的总称。你可以将它视为一个容器，用于存放磁盘。例如，`vg-accounting`卷组就是这种类型的一个示例。会计部门会使用这个卷组来存储他们的记录。它将包括实际的磁盘空间和这些用户将访问的虚拟磁盘空间。值得注意的是，你不必局限于使用单一卷组，而可以创建多个卷组，每个卷组都有自己的磁盘和卷。物理卷是属于卷组的磁盘，可以是真实的，也可以是虚拟的。一个`vg-accounting`卷组理论上可以有三个500GB的硬盘，每个硬盘都会被视为物理卷。请记住，尽管这些磁盘是虚拟的，但在LVM的上下文中，它们仍然被称为物理卷。物理卷是属于卷组的存储设备。最后，逻辑卷的概念类似于分区。与传统的分区不同，逻辑卷可以跨越多个物理磁盘。例如，逻辑卷可以通过三个500GB的磁盘来设置，总共可以获得1500GB的存储空间。当它被挂载时，它就像一个普通硬盘上的分区一样工作，使用户能够像使用任何其他磁盘一样轻松地保存和访问文件。当卷的空间用尽时，你可以通过添加新磁盘并扩展分区来扩展它。尽管它实际上可能由多个硬盘组成，但对用户来说，它将显示为一个单一的统一空间。物理卷可以按照任何对你有意义的方式进行细分。用户将与逻辑卷进行交互，而这些逻辑卷是由底层的物理卷创建的。
- en: 'Installing LVM on a server that isn’t already utilizing it requires having
    at least one unused volume and the necessary packages, either of which may or
    may not already be present on the server. The following commands will tell you
    whether the necessary `lvm2` package is present on your server:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在尚未使用LVM的服务器上安装LVM需要至少一个未使用的卷和必要的软件包，而这些软件包可能已经或未安装在服务器上。以下命令将告诉你服务器上是否已安装所需的`lvm2`软件包：
- en: 'For Debian, use this command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Debian，请使用以下命令：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For Redhat, use this command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Redhat，请使用以下命令：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next step is to count all of the disks in our possession. Many times now,
    we have used the `fdisk -l` command to display a list of these drives. As an example,
    I have `/dev/sdc` on my server now. Disk names will vary by hardware or virtualization
    platform, so you’ll need to tweak the following commands to work with your setup.
    First, we must prepare each disk for usage with LVM by creating a physical volume.
    It is important to remember that setting up LVM does not include formatting a
    storage device or using `fdisk` to configure it. In this case, formatting occurs
    later. To begin setting up our drives for usage with LVM, we will use the `pvcreate`
    command. As a result, we must execute the `pvcreate` command on each of the drives
    we intend to employ. To set up LVM with my USB disks, I will execute the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是统计我们所有的磁盘。我们已经多次使用 `fdisk -l` 命令来显示这些磁盘的列表。例如，我的服务器现在有 `/dev/sdc`。磁盘名称会根据硬件或虚拟化平台的不同而有所不同，因此你需要调整以下命令，以适应你的配置。首先，我们必须通过创建物理卷来准备每个磁盘以供
    LVM 使用。需要记住的是，设置 LVM 并不包括格式化存储设备或使用 `fdisk` 配置它。在这种情况下，格式化会在稍后进行。为了开始将我们的磁盘配置为
    LVM 使用，我们将使用 `pvcreate` 命令。因此，我们必须对每个计划使用的磁盘执行 `pvcreate` 命令。为了用我的 USB 磁盘设置 LVM，我将执行以下操作：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you want to check that everything is set up properly, you can see a list
    of your server’s physical volumes by running the `pvdisplay` command as root or
    using `sudo`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查一切是否正确配置，可以通过以 root 身份或使用 `sudo` 运行 `pvdisplay` 命令查看服务器的物理卷列表：
- en: '![Figure 10.10 – The pvdisplay command output](img/B18575_10_10.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – pvdisplay 命令输出](img/B18575_10_10.jpg)'
- en: Figure 10.10 – The pvdisplay command output
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – pvdisplay 命令输出
- en: 'Only one volume could be displayed on this page, so only that one is shown
    in the screenshot. If you scroll up, more output from the `pvdisplay` command
    will be displayed. We have access to a number of physical volumes, but none of
    them have been placed in a volume group. Actually, we haven’t done something as
    simple as making a volume group yet. Using the `vgcreate` command, we can create
    a volume group, give it a name, and add our first disk to it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一页只能显示一个卷，因此截图中仅显示了这个卷。如果你向上滚动，将会看到更多来自 `pvdisplay` 命令的输出。我们有几个物理卷可用，但其中没有任何一个被放入卷组中。事实上，我们甚至还没有做一件简单的事情，那就是创建一个卷组。通过使用
    `vgcreate` 命令，我们可以创建一个卷组，给它命名，并将我们的第一个磁盘添加到其中：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At this point, I creating a volume group called `vg-packt` and allocate one
    of the created physical volumes (`/dev/sdc`) to it. With the `sudo vgdisplay`
    command, we can see the volume group’s configuration, including the number of
    disks it uses (which should be 1 at this point):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我正在创建一个名为 `vg-packt` 的卷组，并将创建的一个物理卷（`/dev/sdc`）分配给它。通过 `sudo vgdisplay` 命令，我们可以查看卷组的配置，包括它使用的磁盘数量（此时应该是
    1）：
- en: 'Right now, all that has to be done is for us to make a logical volume and format
    it. The disk space we allocate to our volume group may be used in its entirety,
    or in part. Here’s the command I’ll use to partition the newly added virtual disk
    within the volume group into a 5 GB logical volume:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，唯一需要做的就是创建一个逻辑卷并进行格式化。我们为卷组分配的磁盘空间可以全部使用，或者部分使用。以下是我将用于将新添加的虚拟磁盘在卷组中分区为一个
    5 GB 逻辑卷的命令：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Although the command looks difficult, it is actually quite simple. For clarity,
    I use the `-n` option to give my logical volume the name `packtvol1` in this example.
    I use the `-L` option followed by `5g` to specify that I only want to allocate
    5 GB of space. The volume group that this logical volume will be part of is listed
    as the final item. To view details about this volume, use the `sudo` `lvdisplay`
    command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然命令看起来很复杂，实际上它非常简单。为了清晰起见，我在这个示例中使用 `-n` 选项给我的逻辑卷命名为 `packtvol1`。我使用 `-L` 选项后跟
    `5g` 来指定只分配 5 GB 的空间。该逻辑卷所属的卷组作为最后一项列出。要查看该卷的详细信息，可以使用 `sudo` `lvdisplay` 命令：
- en: '![Figure 10.11 – The lvdisplay command output](img/B18575_10_11.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – lvdisplay 命令输出](img/B18575_10_11.jpg)'
- en: Figure 10.11 – The lvdisplay command output
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – lvdisplay 命令输出
- en: At this point, we have everything we need to set up LVM. Like with non-LVM disks,
    we must format a volume before using it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经拥有了设置 LVM 所需的一切。像非 LVM 磁盘一样，在使用之前，我们必须格式化卷。
- en: Creating a format for logical disks
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建逻辑磁盘的格式
- en: 'The next step is to utilize the correct format for our logical volume. However,
    for the formatting process to go smoothly, we must always know the device’s name.
    Since LVM exists, this is a breeze. You can see this in the output (it’s the third
    line down in *Figure 10**.11*, under `lvdisplay` command provided. Let’s use the
    `ext4` filesystem to set up the drive:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用正确的格式来设置我们的逻辑卷。但是，为了确保格式化过程顺利进行，我们必须始终知道设备的名称。由于 LVM 的存在，这变得非常简单。你可以在输出中看到这一点（它位于*图
    10.11*中的第三行，`lvdisplay`命令下提供）。让我们使用`ext4`文件系统来设置磁盘：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, this storage device can be used like any other hard drive. Mine will
    be mounted at `/mnt/lvm/packtvol1`, but you can use whatever you like:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个存储设备可以像任何其他硬盘一样使用。我的将被挂载在`/mnt/lvm/packtvol1`，但你可以使用任何你喜欢的路径：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can run `df -h` to verify that the volume is mounted and displays the right
    size. The single disk in our current LVM arrangement makes this useless. The 5
    GB I’ve allotted probably won’t last very long, but we have some unused space
    that we can put to good use:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行`df -h`来验证卷是否已挂载并显示正确的大小。在我们当前的 LVM 配置中，这没什么意义。我分配的 5 GB 可能不会持续太久，但我们有一些未使用的空间，可以好好利用：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following `lvextend` command allows me to expand my logical volume to fill
    the remaining space on the physical disk:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`lvextend`命令允许我扩展逻辑卷，以填充物理磁盘上的剩余空间：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Figure 10.12 – The lvextend command](img/B18575_10_12.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – lvextend 命令](img/B18575_10_12.jpg)'
- en: Figure 10.12 – The lvextend command
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – lvextend 命令
- en: To be more specific, the preceding `+100%FREE` option specifies that we wish
    to allocate the full remaining space to the logical volume. In my case, this is
    only 2.5 GB, as I used a USB stick for demo purposes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体来说，前面的`+100%FREE`选项指定了我们希望将所有剩余空间分配给逻辑卷。在我的例子中，这只有 2.5 GB，因为我使用了一个 USB 驱动器作为演示。
- en: 'All of the space on the physical drive I designated for my logical volume is
    being used up. However, tread carefully, because if I had more than one physical
    volume allocated, the command would have taken up all of that space as well, making
    the logical volume the size of all the space on all the disks. Even if you don’t
    want to do this all the time, it’s fine by me because I just have one physical
    volume. Feel free to use the `df -h` tool once again to verify your available
    storage space:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我为我的逻辑卷指定的物理驱动器上的所有空间都被用完了。然而，要小心，因为如果我分配了多个物理卷，命令也会占用所有的空间，使得逻辑卷的大小等于所有磁盘上的空间总和。即使你不打算一直这样做，对我来说也没关系，因为我只有一个物理卷。你可以再次使用`df
    -h`工具来验证可用的存储空间：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Unfortunately, the additional volume space we’ve added isn’t reflected. `df`
    still returns the old volume size in its output. The reason for this is that we
    did not resize the `ext4` filesystem that is located on this logical disk, despite
    the fact that we have a larger logical volume and it has all the space given to
    it. The `resize2fs` command is what we’ll utilize to do this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们添加的额外卷空间没有反映出来。`df`仍然返回其输出中的旧卷大小。原因是，我们没有调整位于这个逻辑磁盘上的`ext4`文件系统的大小，尽管我们有一个更大的逻辑卷，并且它已经获得了所有空间。我们将使用`resize2fs`命令来完成这个操作：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Figure 10.13 – The resize2fs command](img/B18575_10_13.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – resize2fs 命令](img/B18575_10_13.jpg)'
- en: Figure 10.13 – The resize2fs command
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – resize2fs 命令
- en: 'Now, using the `df -h` command again, we can see we have all the space allocated:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`df -h`命令，我们可以看到所有空间都已经分配完毕：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this section, we’ve learned how to use logical volumes and how to extend
    a filesystem.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用逻辑卷以及如何扩展文件系统。
- en: Deleting volumes with LVM
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 LVM 删除卷
- en: 'Last but not least, you probably want to know what happens when you delete
    a logical volume or volume group. The `lvremove` and `vgremove` commands are used
    for this reason. Destructive as they may be, these commands can be very helpful
    if you ever need to get rid of a logical volume or volume group. The following
    syntax will get rid of any logical volumes:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，你可能想知道删除逻辑卷或卷组时会发生什么。`lvremove`和`vgremove`命令正是为此而设计。尽管它们具有破坏性，但如果你需要删除逻辑卷或卷组时，这些命令会非常有用。以下语法将删除任何逻辑卷：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Giving the `lvremove` command the name of the volume group you want to remove
    the logical volume from, followed by a forward slash, is all that’s required.
    To remove the entire volume group, the following command should do the trick:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 给`lvremove`命令传递你想要删除逻辑卷的卷组名称，并加上一个斜杠，这就足够了。要删除整个卷组，以下命令应该可以完成：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Even though you probably won’t be removing logical volumes very often, there
    are commands available to help you do so if you ever find yourself in need of
    decommissioning an LVM component. Hopefully, you can see why LVM is so great now.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你可能不会经常移除逻辑卷，仍然有一些命令可以帮助你在需要退役LVM组件时进行操作。希望你现在能理解LVM为何如此出色。
- en: The `pvremove` command in Linux is used to remove a **physical volume** (**PV**)
    from the LVM. Before using this command, make sure that the PV you want to remove
    is not part of any volume group and does not contain any active logical volumes.
    Otherwise, data loss may occur.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中的`pvremove`命令用于从LVM中移除**物理卷**（**PV**）。在使用此命令之前，请确保要移除的PV不属于任何卷组，并且不包含任何活动的逻辑卷。否则，可能会发生数据丢失。
- en: This technology gives you unprecedented control over the data stored on your
    server. Linux’s versatility in the cloud is due in part to LVM’s adaptability.
    If you’re not familiar with LVM, these ideas may seem foreign at first. However,
    with virtualization, experimenting with LVM is straightforward. Until you feel
    comfortable making, editing, and erasing volume groups and logical volumes, I
    advise you to put in some practice time. Concepts that aren’t immediately evident
    will become so with repeated exposure.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这项技术为你提供了前所未有的对服务器上数据的控制。Linux在云端的多样性部分归功于LVM的适应性。如果你不熟悉LVM，这些概念最初可能会显得陌生。然而，借助虚拟化，试验LVM是非常简单的。在你感到能够熟练地创建、编辑和删除卷组及逻辑卷之前，我建议你进行一些实践。那些最初不明显的概念，通过反复接触会变得清晰。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Maintaining a smooth operation requires careful storage management, as a full
    filesystem will cause your server to cease. Fortunately, Linux servers come with
    a plethora of storage management capabilities, some of which are the envy of competing
    systems. It would not be possible to perform our jobs as Linux server administrators
    without innovations such as LVM. In this chapter, we dove into these resources
    and learned some storage management tricks. We went through a wide range of topics,
    including how to create and manage partitions, mount and unmount volumes, work
    with the `fstab` file, use LVM, and check disk use.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 保持平稳运行需要仔细的存储管理，因为文件系统满了会导致服务器停止工作。幸运的是，Linux服务器提供了丰富的存储管理功能，其中一些功能是竞争系统所羡慕的。如果没有像LVM这样的创新，作为Linux服务器管理员的工作是不可能完成的。在本章中，我们深入研究了这些资源并学习了一些存储管理技巧。我们涵盖了广泛的主题，包括如何创建和管理分区、挂载和卸载卷、使用`fstab`文件、使用LVM以及检查磁盘使用情况。
- en: In the next chapter, we will discuss logging configuration and remote logging.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论日志配置和远程日志。
- en: 'Part 3: Linux as a Part of a Larger System'
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：Linux作为更大系统的一部分
- en: All modern IT infrastructures consist of multiple machines with different roles,
    so all systems administrators need to know how to make their Linux-based systems
    work together. In this part of the book, you will learn how to collect log messages
    from all these systems on a central server, simplify user account and permission
    management by using centralized authentication mechanisms, create robust services
    with automatic failover and load balancing, and manage multiple systems at once
    with automation tools. You will also learn how to keep your systems secure.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代IT基础设施由多个具有不同角色的机器组成，因此所有系统管理员都需要知道如何使基于Linux的系统协同工作。在本书的这一部分，你将学习如何在中央服务器上收集所有这些系统的日志消息，如何通过使用集中认证机制简化用户帐户和权限管理，如何创建具有自动故障转移和负载均衡的强大服务，并使用自动化工具同时管理多个系统。你还将学习如何保持系统的安全。
- en: 'This part has the following chapters:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 11*](B18575_11.xhtml#_idTextAnchor189), *Logging Configuration and
    Remote Logging*'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18575_11.xhtml#_idTextAnchor189)，*日志配置和远程日志*'
- en: '[*Chapter 12*](B18575_12.xhtml#_idTextAnchor201), *Centralized Authentication*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18575_12.xhtml#_idTextAnchor201)，*集中认证*'
- en: '[*Chapter 13*](B18575_13.xhtml#_idTextAnchor216), *High Availability*'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18575_13.xhtml#_idTextAnchor216)，*高可用性*'
- en: '[*Chapter 14*](B18575_14.xhtml#_idTextAnchor235), *Automation with Chef*'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18575_14.xhtml#_idTextAnchor235)，*使用Chef自动化*'
- en: '[*Chapter 15*](B18575_15.xhtml#_idTextAnchor267), *Security Guidelines and
    Best Practices*'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B18575_15.xhtml#_idTextAnchor267)，*安全指南和最佳实践*'
