- en: '*Chapter 9*: Secure Virtualization'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More and more system tools have built-in support for SELinux or use SELinux's
    features to further harden their own service offering. When we look at virtualization,
    libvirt is the reigning champion as a virtualization management tool, using the
    **QEMU** and **Kernel-Based Virtual Machine** (**KVM**) hypervisors.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, administrators will learn what **secure Virtualization** (**sVirt**)
    is and how it is applied by the libvirt tool suite, which SELinux domains are
    put in place, and how sVirt uses SELinux categories to isolate guests from each
    other. We will study how SELinux can help reduce the risks of virtualization and
    understand how the SELinux policy is tuned to support virtualization services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SELinux-secured virtualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing libvirt with SELinux support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Vagrant with libvirt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2T805Ug](https://bit.ly/2T805Ug)'
  prefs: []
  type: TYPE_NORMAL
- en: While it is possible to run the examples in this chapter on an older system,
    we recommend using a more modern system that has hardware support for virtualization.
    This will ensure higher performance during the exercises, as full emulation can
    severely hamper the progress, especially on older systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify whether your system has hardware support for virtualization (and
    can therefore use the Linux KVM-based virtualization), the following command should
    have output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If no output is shown, then the system does not support hardware-assisted virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SELinux-secured virtualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtualization is a core concept that plays a part in many infrastructural service
    designs. Ever since its inception in the early 1970s as a means of isolating workloads
    and abstracting hardware dependencies, virtualization implementations have grown
    tremendously. When we look at infrastructure service offerings today, we quickly
    realize that many cloud providers would be out of service if they could not rely
    on the benefits and virtues of virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: One of the properties that virtualization offers is isolation, which SELinux
    can support and augment quite nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing virtualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we look at virtualization, we look at the abstraction layers it provides
    to hide certain resource views (such as hardware or processing power). Virtualization
    contributes to the development of more efficient hardware usage (which results
    in better cost control), centralized views on resources and systems, more flexibility
    in the number of operating systems that the company can deal with, standardization
    of resource allocation, and even improved security services.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several virtualization types around:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full-system emulation**: Where hardware is completely emulated through software.
    QEMU is an open source emulation software capable of handling full-system emulation,
    allowing administrators and developers to run virtual platforms with different
    processor architectures not otherwise compatible with their own systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Native virtualization**: Where main parts of the hardware are shared across
    instances, and guests can run unmodified on them. Linux''s **KVM**, which is also
    supported through QEMU, is an example of this type of virtualization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Paravirtualization**: Where the guest operating system uses specific APIs
    offered by the virtualization layer (on which unmodified operating systems cannot
    be hosted). Initial releases of Xen only supported paravirtualization. Using KVM
    with VirtIO drivers is another, more modular example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OS-level virtualization or containerization**: Where the guest uses the host
    operating system (kernel) but does not see the processes and other resources running
    on the host. Docker containers or LXC containers are examples of OS-level virtualization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application virtualization**: Where the application runs under a specialized
    software runtime. A popular example here is the support for Java applications,
    running on the **Java Virtual Machine** (**JVM**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many virtualization platforms support a few virtualization types. QEMU can range
    from full emulation to paravirtualization, depending on its configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we work with virtualization layers, the following terms come up frequently:'
  prefs: []
  type: TYPE_NORMAL
- en: The **host** is the (native) operating system or server on which the virtualization
    software is running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **guest** is the virtualized service (generally an operating system or container)
    that runs on the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **hypervisor** is the specialized virtualization software that manages the
    hardware abstraction and resource-sharing capabilities of the virtualization platform.
    It is responsible for creating and running the virtual machines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **image** is a file or set of files that represents the filesystem, disk,
    or other medium assigned to a guest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **virtual machine** is the abstracted hardware or resource set in which the
    guest runs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using these terms in this chapter, as well as in [*Chapter 10*](B16276_10_Final_VK.xhtml#_idTextAnchor279),
    *Using Xen Security Modules with FLASK*, and [*Chapter 11*](B16276_11_Final_VK.xhtml#_idTextAnchor293),
    *Enhancing the Security of Containerized Workloads*, as those chapters also cover
    specific virtualization implementations and how SELinux actively provides additional
    security controls in them.
  prefs: []
  type: TYPE_NORMAL
- en: Before we embark on configuring and tuning virtualization services, let's first
    see what SELinux has to offer for virtualized environments.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the risks of virtualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Virtualization comes with a number of risks though. If we ask architects or
    other risk-conscious people about the risks of virtualization, they will talk
    about virtual machine sprawl, challenges related to secure or insecure APIs, the
    higher complexity of virtualized services, and whatnot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going over the challenges of virtualization itself is beyond the scope of this
    chapter, but there are a few notable risks that play directly into SELinux''s
    field of interest. If we can integrate SELinux with a virtualization layer, then
    we can mitigate these risks more proactively:'
  prefs: []
  type: TYPE_NORMAL
- en: The first risk is **data sensitivity** within a virtual machine. Whenever multiple
    virtual machines are hosted together, you could have the risk that one guest is
    able (be it through a flaw in the virtualization software, the hypervisor's networking
    capabilities, or through side-channel attacks) to access sensitive data on another
    virtual machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With SELinux, data sensitivity can be controlled using sensitivity ranges. Guests
    can run with different sensitivity ranges, guaranteeing the data sensitivity even
    on the virtualization layer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Another risk is the **security of offline guest images**. Here, either administrators
    or misconfigured virtual machines might gain access to another guest image. SELinux
    can prevent this through properly labeled guest images and ensuring that images
    of offline virtual machines are typed differently from online virtual machines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual machines can also **exhaust the resources** on a system. On Linux systems,
    many resources can be controlled through the **control groups** (**cgroups**)
    subsystem. As this subsystem is governed through system calls and regular file
    APIs, SELinux can be used to further control access to this facility, ensuring
    that the cgroups maintained by libvirt, for instance, remain solely under the
    control of libvirt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Break-out attacks**, where vulnerabilities within the hypervisor are exploited
    to try to reach the host operating system, can be mitigated through SELinux''s
    type enforcement as even a hypervisor does not require full administrative access
    to everything on the host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux can also be used to **authorize access to the hypervisor**, ensuring
    that only the right teams (through the role-based access controls) are able to
    control the hypervisor and its definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, SELinux also offers improved **guest isolation**, which goes beyond
    just the guest image accesses. Thanks to SELinux's MCS implementation, guests
    can be separated from each other in a mandatory approach. With type enforcement,
    the allowed behavior of guests can be defined and controlled. This is a key capability
    used by hosting providers as they allow running (for them) untrusted guest virtual
    machines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux, however, is not a full security solution for virtualization providers.
    One main design constraint with SELinux is that it is not dynamic if the system
    itself is not SELinux-aware. When we assign a type to a virtual machine, this
    type is generally rigid and set in stone. Virtual machines will have different
    behavior characteristics depending on the software running on them.
  prefs: []
  type: TYPE_NORMAL
- en: A virtual machine running a web server has different behavior characteristics
    than one running a database or an email gateway. Although SELinux policy administrators
    would be capable of creating new domains for each virtual machine, this is not
    efficient. As a result, most SELinux policies will only offer a few domains usable
    by the virtual machine with broad characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: With libvirt, these domains are part of the sVirt solution.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing existing virtualization domains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Red Hat introduced its virtualization solution, it also added SELinux support,
    calling the resulting technology **sVirt**, derived from *secure virtualization*.
    As secure virtualization as a term is hardly unique in the market, we use the
    term sVirt predominantly to refer to the SELinux integration within virtualization
    management solutions such as libvirt.
  prefs: []
  type: TYPE_NORMAL
- en: 'With sVirt, the open source community has a reusable approach for augmenting
    the security posture of virtualization and containerization through SELinux. It
    does this through the following domains and types, which can be used regardless
    of the underlying virtualization platform:'
  prefs: []
  type: TYPE_NORMAL
- en: The hypervisor software itself, such as `libvirtd`, uses the `virtd_t` domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guests (virtual machines) that do not require any interaction with the host
    system and resources beyond those associated with a generic virtual machine generally
    use the `svirt_t` domain. This domain is the most isolated guest domain for full
    virtualization solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guests that require more interaction with the host, such as using the QEMU networking
    capabilities and sharing services, will use the `svirt_qemu_net_t` domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guests that use the KVM networking capabilities and sharing services will use
    the `svirt_kvm_net_t` domain. It is very similar in permissions to `svirt_qemu_net_t`
    but optimized for KVM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerized guests, as we will see in [*Chapter 11*](B16276_11_Final_VK.xhtml#_idTextAnchor293),
    *Enhancing the Security of Containerized Workloads*, will use the `svirt_lxc_net_t`
    domain, whose privileges are optimized for OS-level virtualization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guests that require more flexible memory accesses (such as executing writable
    memory segments and memory stacks) will use the `svirt_tcg_t` domain. This flexible
    memory access is common for full virtualization guests whose emulation/virtualization
    requires the use of a **Tiny Code Generator** (**TCG**), hence the name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image files that contain a guest's data will be labeled with the `svirt_image_t`
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image files that are not in use at the moment will use the default `virt_image_t`
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image files used in a read-only fashion will have the `virt_content_t` type
    assigned to them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To enable some flexibility in what the domains are allowed to do, additional
    SELinux booleans are put in effect, which we'll cover next.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuning virtualization-supporting SELinux policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use caution when toggling SELinux booleans to control the confinement of virtualization
    domains. Such booleans influence the SELinux policy on the host level, and cannot
    be used to change the access controls or privileges of individual guests. As such,
    when we change the value of an SELinux boolean, the change affects the permissions
    of all guests on that host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what the various SELinux booleans are for virtualized environments:'
  prefs: []
  type: TYPE_NORMAL
- en: The `staff_use_svirt` boolean, if enabled, allows the `staff_t` user domain
    to interact with and manage virtual machines, as by default this is only allowed
    for unconfined users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unprivuser_use_svirt` boolean, if enabled, allows unprivileged user domains
    (such as `user_t`) to interact with and manage virtual machines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `virt_read_qemu_ga_data` and `virt_rw_qemu_ga_data` booleans, the QEMU
    guest agent (which is an optional agent running inside the guests, facilitating
    operations such as freezing filesystems during backup routines) can read or even
    manage data labeled with the `virt_qemu_ga_data_t` type. This type, however, is
    not in use by default, and these SELinux booleans are disabled by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `virt_sandbox_share_apache_content` boolean allows the guest domains to
    share web content. This is most commonly used for containers but is possible on
    guests as well if the hypervisor supports mapping host filesystems into the guest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `virt_sandbox_use_audit` enabled, this boolean allows the guest domains
    to send audit messages to the host's audit service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `virt_sandbox_use_fusefs` boolean grants the guest domains the privilege
    to mount and interact with `virt_use_fusefs` boolean allows the guests to read
    files on these filesystems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `virt_sandbox_use_netlink` boolean is active, then guest domains can
    use Netlink system calls to manipulate the networking stack within the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `virt_transition_userdomain`, containers can transition to a user domain
    (including the unconfined user domain `unconfined_t`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we enable `virt_use_execmem`, guests can use executable memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `virt_use_glusterd`, `virt_use_nfs`, and `virt_use_samba` booleans allow
    guests to use network filesystems mounted on the host, offered through GlusterFS,
    NFS, and Samba respectively. Note that this does not involve mounts inside the
    guest itself, such as a guest that connects to an NFS server. The booleans handle
    interaction through filesystem mounts on the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device access is also governed through some SELinux booleans, such as the `virt_use_comm`
    boolean to interact with serial and parallel communication ports, `virt_use_pcscd`
    to allow guests to access smartcards, and `virt_use_usb` to grant access to USB
    devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `virt_use_rawip` boolean allows guests to use and interact with raw IP sockets,
    allowing network interaction that circumvents some of the processing logic within
    the regular network stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `virt_use_sanlock`, guests can interact with the sanlock service, a lock
    manager for shared storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `virt_use_xserver` is set to true, guests can use the X server on the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If security-sensitive operations need to be allowed for a single guest or a
    small set of guests, it is advisable to run those guests on an isolated host where
    these operations are then allowed while running the other guests on hosts where
    the policy does not allow these particular actions.
  prefs: []
  type: TYPE_NORMAL
- en: Administrators can also use different SELinux domains for specific guests, fine-tuning
    the access controls for an individual virtual machine. How we can assign specific
    domains depends on the underlying technology of course. In the *Enhancing libvirt
    with SELinux support* section, we will introduce this for libvirt-based virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding sVirt's use of MCS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SELinux domains and the mentioned types are not enough to implement proper
    confinement and isolation between guests. sVirt adds another layer of security
    by using SELinux's **Multi-Category Security** (**MCS**) extensively.
  prefs: []
  type: TYPE_NORMAL
- en: Within SELinux, some domains are marked as an MCS-constrained type. When this
    is the case, the domain will not be able to access resources that do not have
    the same set of categories (or more) assigned as the current context, as it will
    not be able to extend their own active category set—something we saw in [*Chapter
    8*](B16276_08_Final_VK.xhtml#_idTextAnchor237), *SEPostgreSQL – Extending PostgreSQL
    with SELinux*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sVirt implementation ensures that the virtualization domains mentioned
    earlier are all marked as MCS-constrained types. This can be confirmed by asking
    the system which types have the `mcs_constrained_type` attribute set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Through the MCS constraints, sVirt enables proper isolation between guests.
    Every running virtual machine (generally running as `svirt_t`) will be assigned
    two (random) SELinux categories. The images that virtual machine needs to use
    are assigned the same two SELinux categories.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a virtual machine wants to access the wrong image, the difference in
    MCS categories will result in SELinux denying the access. Similarly, if one virtual
    machine is trying to connect to or attack another virtual machine, the MCS protections
    will once again prevent these actions from happening.
  prefs: []
  type: TYPE_NORMAL
- en: sVirt selects two categories to allow a large number of guests to run even when
    there are only a few categories available. Assume that the hypervisor is running
    with the `c10.c99` category range. That means that the hypervisor can only select
    90 categories. If each guest only receives a single category, then the hypervisor
    can support 90 guests before allowing multiple guests to interact with each other
    (assuming a malicious actor found a vulnerability that allows that, of course,
    the hypervisor software will generally disallow such accesses as well). With two
    categories, however, the number of supported simultaneously running guests becomes
    4,005 (the number of unique pairs in a set of 90, obtained through the formula
    *n*(n-1)/2)*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what libvirt's SELinux support looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing libvirt with SELinux support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The libvirt project offers a virtualization abstraction layer, through which
    administrators can manage virtual machines without direct knowledge of or expertise
    in the underlying virtualization platform. As such, administrators can use the
    libvirt-offered tools to manage virtual machines running on QEMU, QEMU/KVM, Xen,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To use the sVirt approach, libvirt can be built with SELinux support. When this
    is the case and the guests are governed (security-wise) through SELinux, then
    the sVirt domains and types are used/enforced by libvirt. The libvirt code will
    also perform the category selection to enforce guest isolation and will ensure
    that the image files are assigned the right label (image files that are in use
    should get a different label than inactive images files).
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating between shared and dedicated resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The different labels for images allow for different use cases. The image used
    to host the main operating system (of the guest) will generally receive the `svirt_image_t`
    label and will be recategorized with the same pair of categories as the guest
    runtime itself (running as `svirt_t`). This image is writable by the guest.
  prefs: []
  type: TYPE_NORMAL
- en: When we consider an image that needs to be readable or writable by multiple
    guests, then libvirt can opt not to assign any categories to the file. Without
    categories, MCS constraints don't apply (well, they still apply, but any set of
    categories dominates an empty set, and as such, actions against those properly
    labeled files are allowed).
  prefs: []
  type: TYPE_NORMAL
- en: Images that need to be mounted read-only for a guest (such as bootable media)
    are assigned the `virt_content_t` type. If they are dedicated, then categories
    can be assigned as well. For shared read access, no categories need to be assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Note that these label differences apply mainly to virtualization technologies
    and not container technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Assessing the libvirt architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The libvirt project has several clients that interact with the `libvirtd` daemon.
    This daemon is responsible for managing the local hypervisor software (be it QEMU/KVM,
    Xen, or any other virtualization software) and is even able to manage remote hypervisors.
    This latter functionality is often used for proprietary hypervisors that offer
    the necessary APIs to manage the virtual resources on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – High-level libvirt architecture ](img/B16276_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – High-level libvirt architecture
  prefs: []
  type: TYPE_NORMAL
- en: Due to the cross-platform and cross-hypervisor nature of the libvirt project,
    sVirt is a good match. Instead of hypervisor-specific domains, generic (yet confined)
    domains are used to ensure the security of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring libvirt for sVirt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most systems that support libvirt on SELinux systems will have SELinux support
    automatically enabled. If this is not the case, but SELinux support is possible,
    then all it takes is to configure libvirt to allow the SELinux security model.
    We map the SELinux security model in libvirt on a per-hypervisor basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration parameters related to sVirt are generally defined on a per-hypervisor
    basis. For instance, for the QEMU-based virtualization driver, we need to edit
    the `/etc/libvirt/qemu.conf` file. Let''s look at the various parameters related
    to secure virtualization:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first parameter, which defines whether sVirt is active or not, is the `security_``driver`
    parameter. While libvirt will by default enable SELinux once it detects SELinux
    is active, we can explicitly mark sVirt support as enabled by setting the `selinux`
    value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A second sVirt-related setting in libvirt is `security_default_confined`. This
    variable defines whether guests are by default confined (and thus associated with
    the sVirt protections) or not. The default value is `1`, which means that the
    confinement is by default enabled. To disable it, you need to set it to `0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Users of the libvirt software can also ask to create an unconfined guest (and
    libvirt allows this by default). If we set `security_require_confined` to `1`,
    then no unconfined guests can be created:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can confirm that sVirt is running when we have a guest active on the platform,
    as we can then consult the label for its processes to verify that it indeed received
    two random categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create such a guest, using the regular QEMU hypervisor. We use an Alpine
    Linux ISO to boot the guest with, but that is merely an example—you can substitute
    it with any ISO you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The locations mentioned are important, as they will ensure that the files are
    properly labeled:'
  prefs: []
  type: TYPE_NORMAL
- en: In `/var/lib/libvirt/boot` (and `/var/lib/libvirt/isos`), read-only content
    should be placed, which will result in the files automatically being labeled with
    `virt_content_t`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `/var/lib/libvirt/images`, we create the actual guest images. When the guests
    are shut down, the images will be labeled with `virt_image_t`, but once started,
    the labels will be adjusted to match the categories associated with the domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command will create a guest called `test`, with 128 MB of memory and 1 vCPU.
    No specific graphics support will be enabled, meaning that the standard console
    or screen of the virtual machine will not be associated with any graphical service
    such as **Virtual Network Computing** (**VNC**) but will rely on a serial console
    definition inside the guest. Furthermore, we have the guest use a small, 1 GB
    disk that uses the **QEMU copy-on-write** (**QCOW2**) format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have created the guest and launched it, we can check its label easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To list the currently defined guests, use the `virsh` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `--all` argument will ensure that even guests that are defined but are not
    running currently are listed as well.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Within libvirt, guests are actually called **domains**. As SELinux (and thus
    this book) also uses the term *domain* frequently when referring to the context
    of a process, we will be using *guest* as terminology when referring to libvirt's
    domains to keep possible confusion to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: The `virsh` command is the main entry point for interacting with libvirt. For
    instance, to send a shutdown signal to a guest, you would use the `shutdown` argument,
    whereas the `destroy` argument will force the shutdown of the guest. Finally,
    to remove a definition, you would use `undefine`.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the previous example, the guest we defined is running with the `svirt_tcg_t`
    domain. Let's see how we can adjust the labels used by libvirt for guests.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a guest's SELinux labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once a guest has been defined, libvirt allows administrators to modify its parameters
    by editing an XML file representing the guest. Within this XML file, the SELinux
    labeling has a place as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the current definition, you can use the `dumpxml` argument to `virsh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the XML, the security labels are shown. For SELinux, this could
    look like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to modify these settings, we can use the `edit` argument to `virsh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will open the XML file in the local editor. However, once we accomplish
    that, we'll notice that the `seclabel` entries are nowhere to be found. That is
    because the default behavior is to use dynamic labels (hence `type='dynamic'`)
    with default labels, which does not require any default definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s instead use a static definition, and have the guest run with the `c123,c124`
    category pair. In the displayed XML, at the end (but still within the `<domain>...</domain>`
    definition), place the following XML snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To run a guest with a different type is of course done in a similar fashion,
    changing `svirt_tcg_t` to a different type. However, keep in mind that not all
    types can be used regardless. For instance, the default `svirt_t` domain cannot
    be used with QEMU's full-system virtualization (as QEMU uses TCG if it cannot
    use KVM).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The default types that libvirt uses are declared inside `/etc/selinux/targeted/contexts`,
    in the `virtual_domain_context` and `virtual_image_context` files. However, it
    is not recommended to change these files as they will be overwritten when SELinux
    policy updates are released by the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: The `relabel` statement requests libvirt to relabel all resources for the guest
    according to the guest's current assigned label (`relabel='yes'`) or not (`relabel='no'`).
    With dynamic category assignment, this will always be `yes`, while with static
    definitions both values are possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if we want to, we can use dynamic category assignment with custom
    type definitions as well. For that, we declare `type=''dynamic''` but explicitly
    define a label within a `<baselabel>` entity, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will have the guest run with a dynamically associated category pair, while
    using a custom label rather than the default selected one.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing resource labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the guest definition has relabeling active (either because it uses dynamic
    category assignment or on explicit request of the administrator), then the resources
    that the guest uses will be relabeled accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Administrators can customize the labeling behavior of libvirt through the same
    interface we used previously: guest definition files. For instance, if we would
    not want libvirt to relabel the `test.qcow2` file that represents the guest''s
    disk, we could add to the XML like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is useful when you want to allow the sharing of some resources across different
    guests, without making them readable by all guests. In such a situation, we could
    label the file itself with (say) `svirt_image_t:s0:c123` and have the guests with
    category pairs always contain the category `c123`.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling available categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When libvirt selects random categories, it does so based on its own category
    range. By default, MCS systems will have this range set to `c0.c1023`. To change
    the category range, we need to ensure that we launch the libvirt daemon (`libvirtd`)
    in the proper context.
  prefs: []
  type: TYPE_NORMAL
- en: 'With systemd, we saw in [*Chapter 7*](B16276_07_Final_VK.xhtml#_idTextAnchor216),
    *Configuring Application-Specific SELinux Controls*, that this can be accomplished
    by editing the service unit file and defining the right `SELinuxContext` variable.
    Let''s apply this to `libvirtd` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, copy over the system-provided `libvirtd.service` file to `/etc/systemd/system`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the `libvirtd.service` file and add the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reload the daemon definitions for systemd so that it picks up the new `libvirtd.service`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart the `libvirtd` daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now start our guests again and verify that each guest is now running
    with a category pair within the range defined for the `libvirtd` daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, the categories selected by libvirt are now within the defined
    range.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Systems that do not use systemd can edit the SysV-style `init` script and use
    `runcon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Every time we launch a new guest, the libvirt code will randomly select two
    categories. The service will then check whether these categories are part of its
    own range and whether the category pair is already used or not. If any of these
    checks fail, libvirt will randomly select a new pair of categories until a free
    pair matches the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the storage pool locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very common configuration change with libvirt is to reconfigure it to use
    a different storage pool location. This has a slight impact on SELinux as well,
    as we do not have proper file context definitions for the new location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to create a new pool location and change the SELinux configuration
    for it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'List the current storage pools to make sure the new pool name is not already
    taken:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the target location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the new storage pool with `pool-define-as`. In the following command,
    we name the pool `large_images`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure SELinux to label the pool properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Relabel the directory structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Have libvirt populate the directory structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the storage pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Turn on auto-start so that, when `libvirtd` starts, the pool is immediately
    usable as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can verify that everything is functioning properly with the `pool-info`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output will show the current and available capacity for the new location.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we host the storage pool on an NFS-mounted location, then we need to enable
    the `virt_use_nfs` SELinux boolean as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've fully grasped how to configure libvirt and SELinux for it, let's
    see how we can use the popular Vagrant tool with libvirt.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vagrant with libvirt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vagrant is a framework to quickly spin up and manage virtual machines and is
    very popular within development communities. While Vagrant uses Oracle VirtualBox
    as the hypervisor by default, we can install a libvirt plugin to use Vagrant with
    libvirt, benefiting from the sVirt security offered by SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Vagrant and the libvirt plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Vagrant application can be installed from a single RPM file. Find the latest
    version at [https://www.vagrantup.com/downloads.html](https://www.vagrantup.com/downloads.html)
    and install it. For instance, for CentOS systems, you can use `yum` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To install the libvirt plugin, we first need to make sure that the dependencies
    are installed as well. The documentation, online at [https://github.com/vagrant-libvirt/vagrant-libvirt](https://github.com/vagrant-libvirt/vagrant-libvirt),
    gives a good overview of which packages need to be installed. Do not forget this
    step, as dependency failures during the plugin installation are not always obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the dependencies are installed, use `vagrant` itself to download and install
    the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After installing the plugin, we can go forward with setting up a Vagrant box.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a libvirt-compatible box
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vagrant uses **boxes**: images prepared for quick installation using Vagrant.
    Not all Vagrant boxes are compatible with the libvirt provider. Luckily, the Vagrant
    Cloud website at [https://app.vagrantup.com/boxes/search?provider=libvirt](https://app.vagrantup.com/boxes/search?provider=libvirt)
    allows you to quickly find compatible boxes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to use a Fedora image called `fedora/32-cloud-base`, then we
    can configure it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory, which we will define the box configuration in, and
    enter this location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the Vagrant box, using the `fedora/32-cloud-base` box definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the `Vagrantfile`, and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will configure the libvirt provider to use the `images` directory as the
    default storage pool, and use the QEMU driver within libvirt.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Still inside the `Vagrantfile`, add the following code to give the box a proper
    name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The name chosen here is `test`, and will result in a virtual guest named `vagrant_test`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To launch the test guest, run the `vagrant up` command like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the guest is up and running, you can connect to it using `vagrant ssh`.
    While you can manipulate the guest with the `virsh` commands, you can also use
    `vagrant halt` to shut down, or `vagrant destroy` followed by `vagrant box remove`
    to remove the box from the system completely.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Vagrant boxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once a box is deployed, it is available through libvirt as a standard guest.
    That means that the operations we've seen before to modify its labels or tweak
    SELinux controls using the SELinux booleans still apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first verify that Vagrant is indeed using libvirt to launch its own
    boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Sure enough, the guest is available and titled `vagrant_test`. We can modify
    its configuration with `virsh edit` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As long as the Vagrant box is not destroyed, the settings in libvirt will persist.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtualization is a powerful technology whose security posture can be augmented
    thanks to SELinux. With sVirt, the open source community has a powerful approach
    to isolate guests and ensure virtual machines are only able to access the resources
    they should.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we looked at virtualization and the risks associated with it.
    We discussed how some of these risks can be mitigated through the same set of
    controls that SELinux offers, such as type enforcement (limiting what guests can
    do) and MCS confinement (isolating guests from each other).
  prefs: []
  type: TYPE_NORMAL
- en: We then covered how libvirt supports several virtualization technologies on
    Linux platforms and how it includes a technology called sVirt that enables SELinux
    integration, offering guest isolation and access controls. We saw how administrators
    can manipulate the sVirt logic within libvirt, such as through different domain
    labels or category sets. We finished the chapter with information on how to use
    Vagrant with libvirt.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at another virtualization solution, called Xen,
    which has adopted an SELinux-based technology for its hardening.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is unique about sVirt that cannot be done with regular SELinux configuration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two main risks that SELinux tackles with virtualization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `virt_image_t`, `svirt_image_t`, and `virt_content_t`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you change guest labels with libvirt?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we use Vagrant yet still benefit from sVirt?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
