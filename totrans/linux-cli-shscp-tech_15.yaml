- en: '*Chapter 15*: Troubleshooting Shell Scripts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have come this far, you must have a lot of ideas about how to write a
    shell script, and even more questions about the ways you can make particular things
    in scripts work. This is completely normal. Your scripting journey has just started.
    No amount of reading can make up for time spent writing scripts, trying out different
    solutions, and understanding how different commands work.
  prefs: []
  type: TYPE_NORMAL
- en: We have some good news and some bad news for you. Being good at scripting takes
    a long time and, in scripting, most of that time is going to be spent trying to
    understand what your script should be doing and, usually, why it is doing it wrong.
    The good news is that scripting is never boring.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will try to give you the tools needed to debug and troubleshoot
    scripts quickly and without a lot of confusion. The tools are going to be in the
    form of different methods you can use to maximize your ability to find logical
    and, sometimes, syntactical errors in scripts. We are going to start with the
    basic recipes and go on to more complex ways to work on scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Common scripting mistakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple debugging approach – echoing values during script execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `bash` `-x` and `-v` options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `set` to debug a part of the script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to use the same machine as in all the previous
    chapters on scripting in this book. Do not be alarmed that there are a couple
    of screenshots that are made in Windows. They are there just to illustrate a point;
    you don''t need Windows to do anything. Just like earlier, we are using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A virtual machine with Linux installed, any distribution (in our case, it's
    going to be *Ubuntu 20.10*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's dive into troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: Common scripting mistakes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a script will present many problems, including how to design it, how
    to find the right solutions to different problems, and how to make all of this
    usable in the target environment. These can be things you can easily solve in
    a couple of minutes, or things you will spend days or even weeks trying to solve.
    All this time will probably just be a small percentage of the total time you will
    spend debugging and troubleshooting scripts. Writing and troubleshooting scripts
    are two wholly different things – while you usually write your own scripts from
    scratch, you will not only debug and troubleshoot your own code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing requires skill and deep knowledge of your environment, but it can be
    argued that to debug and troubleshoot, you need even more understanding of both
    your task and the way your script is trying to accomplish it. In this recipe,
    we are going to work on the skills you need to understand not only how to troubleshoot
    scripts you have written, but also any scripting code you run into, whether it's
    a part of something you've created or a separate system created by someone else
    that you are responsible for getting running.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Troubleshooting and debugging sound and look like the same task, but they are
    subtly different. In general, when we are debugging, we are concentrating on finding
    logical and other errors in our scripts. When troubleshooting, we are not only
    debugging but also trying gain more understanding of what should be done and how
    your application is trying to accomplish it. In the recipes in this chapter, we
    are going to use both these expressions for one thing – trying to make something
    that is not working correctly work as it should, or at least better.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few things you can do to make this as easy as possible, and one
    of them is to get as much knowledge as possible about scripting under your belt.
    Being able to understand scripts and the specific ways things are done to solve
    them will enable you to quickly understand not only what the problem is but also
    how to solve it.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the solution may be to simplify a part of code using a standard solution,
    or break code into different, more standardized modules.
  prefs: []
  type: TYPE_NORMAL
- en: When faced with a more complex script, this method of breaking code down into
    more manageable and understandable modules can be amazingly successful since even
    the greatest script-writers sometimes completely miss the point of what they are
    doing and complicate even the simplest tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'When talking about debugging, we need to talk about errors. Broadly, we can
    have four different outcomes from our script:'
  prefs: []
  type: TYPE_NORMAL
- en: The script works as desired.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The script throws an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The script works but not completely, making errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The script works but sometimes silently breaks something either in the input
    or output data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have the time, we can work on any of these possible outcomes and make
    a script behave better, even one that works correctly. Sometimes it pays to spend
    some time to make your script more beautiful, more commented, and more readable,
    even if it works alright.
  prefs: []
  type: TYPE_NORMAL
- en: Another case is scripts throwing an error. Bash has a reputation for having
    cryptic and generic error messages. Some of them are too vague to be of much assistance,
    and sometimes they make no sense at all and don't help us to understand what is
    actually wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common example that you will notice from time to time is not understanding
    ends of lines correctly. Windows and Linux treat ends of lines differently. While
    Windows terminate text files using both the carriage return and new line characters,
    Linux only uses new line characters for line termination. Bash can have a problem
    with that, and scripts written on Windows will sometimes break for no apparent
    reason. This is the same script on Windows and Linux, with an editor that shows
    all the characters in a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – In Linux, lines are terminated by a single character'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.1_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.1 – In Linux, lines are terminated by a single character
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows, it looks similar, but we can see that line ends have two characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – In Windows, two characters are used to terminate a line'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.2_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.2 – In Windows, two characters are used to terminate a line
  prefs: []
  type: TYPE_NORMAL
- en: 'In Linux, if we do not edit the file correctly and forget to strip out extra
    characters, we will end up with characters that will be invisible in a normal
    editor and break the code at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – In vim, you need to turn on a couple of options to see special
    characters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.3_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.3 – In vim, you need to turn on a couple of options to see special
    characters
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is a utility called `dos2unix` (and `unix2dos` if you need conversion
    the other way around) that fixes ends of lines when transferring files. This problem
    is system wide and more than a couple of programs will behave strangely when they
    encounter text files from Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do not deal with characters at the ends of lines, the script will break.
    For example, we tried running the file that came from Windows in Linux, we get
    completely cryptic errors mentioning commands that look like they are not even
    in the script. We are using `dos.sh` as the name of the script that we saved in
    Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Also, we need to make it clear that if you use copy and paste to move files
    between your environments, this will fix the problem directly. When you paste
    a line in a particular operating system, it will automatically create the right
    line endings. This does not cover copying and pasting the entire file; if you
    do that, you are transferring the entire file's content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common syntax error that can be difficult to find is using the wrong
    quote, either by mixing them up or using a quote instead of a backtick character
    when executing commands inside scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – Completely normal script, highlighted by syntax in vim'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.4_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.4 – Completely normal script, highlighted by syntax in vim
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change one backtick to a quote, this will turn into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – Without proper highlighting, an error like this can cause serious
    problems'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.5_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.5 – Without proper highlighting, an error like this can cause serious
    problems
  prefs: []
  type: TYPE_NORMAL
- en: We are using vim here, and you will notice the change right away. The editor
    understands syntax and highlights the appropriate code block in a different color.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to run this script, it will throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This error is a little confusing. Bash is telling us that it got to the end
    of the file while trying to find the closing quote.
  prefs: []
  type: TYPE_NORMAL
- en: One thing all of these errors have in common is using different fonts in different
    editors. Sometimes, the difference between characters is so minor that it is extremely
    hard to spot. Bash makes it even harder by reporting errors that are sometimes
    pointing to a completely different part of the code.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this is using a font you know is legible and using an editor
    that is able to pair characters such as parentheses. Quotes and backticks will
    probably remain a problem since most applications are unable to match them. Editors
    such as vim will, however, highlight comments and, as we saw in the previous example,
    this will make errors such as this visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of highlighted brackets in Notepad++ on Windows, since we
    mentioned the multi-platform approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – Highlighting brackets in Notepad'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.6_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.6 – Highlighting brackets in Notepad
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we also have our standard run-of-the-mill syntax errors that are
    inevitable. A good editor will also help with these:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 – Having an editor that''s capable of highlighting braces and
    parentheses will save you'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.7_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.7 – Having an editor that's capable of highlighting braces and parentheses
    will save you
  prefs: []
  type: TYPE_NORMAL
- en: The error is in the `then` keyword, and vim highlights that by making the keyword
    white instead of the yellow that it uses for regular keywords.
  prefs: []
  type: TYPE_NORMAL
- en: After dealing with syntax, it is time to see how to avoid arguably more complicated
    and tougher-to-spot errors in logic.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mentioning logic in scripting can be deceiving. Logic can, in the very strict
    definition of the term, be formal logic in clauses that require logic expressions
    to work, or can more broadly mean any decision-making inside the script. When
    we say *error in logic*, we usually think of the latter; problems that are created
    when our script behaves like we told it to, not like we thought we told it to.
    Every unexpected behavior that is not a result of a syntax error falls into this
    category.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s presume that we want to sort a couple of numbers using
    the `sort` command. This may look easy but has a small flaw. `sort`, by default,
    sorts alphabetically, and not numerically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We end up having value of `264` being larger than `0` but smaller than `4`,
    which is wrong. If we want to sort something as we intended to, we should be using
    the appropriate switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is much better. Errors like this are not strictly a problem with Bash but
    instead happen when we are unsure of how a command is used, the result of which
    is that our script will misbehave.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing you are going to see frequently is invalid index referencing.
    In arrays, indices start from `0`, but people usually count from `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8 – Misnumbering indices is common when programming in any language'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.8_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.8 – Misnumbering indices is common when programming in any language
  prefs: []
  type: TYPE_NORMAL
- en: 'When we try and run this, we are going to lose one pair of variables in our
    output since we missed the first element in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The errors that doing this creates are sometimes easy to spot when the script
    is run, but some use cases, especially those that deal with only a part of an
    array, may create strange problems. The same problem can and will happen in loops
    using arguments, like in this example, and if we do not print the values straight
    away, we may not notice that we are processing only part of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, the problem is that definition of the number we are counting
    from is pretty arbitrary. Usually, we use 0 as the first index, but there are
    some exceptions to this. If you're not completely sure, check.
  prefs: []
  type: TYPE_NORMAL
- en: All of these problems are mentioned here very broadly. You need to know them,
    but the way you are going to deal with them in your scripts is going to be different
    for every script you create. Our intention here is to make you aware that the
    problem exists, so you can spot it before it becomes dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: The last big problem we mentioned was with scripts that work correctly most
    of the time, failing only in some cases and then failing only partially. This
    is the worst kind of problem, one that is dangerous since you cannot fully trust
    the output of the script, and hard to find since the output will be completely
    fine most of the time. The only way to deal with these problems is to carefully
    go through all the edge cases of your problem and test them on the script itself.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we were annoyingly vague when describing possible problems,
    and we did it on purpose. As with all things that are directly connected with
    making errors while working on some problem, we would like to avoid all of them,
    but it is impossible to define what to avoid until we make an error. Most problems
    we see will be the result of a poor presumption or a false understanding of a
    fact. Sometimes, it is going to be a simple typing error that will go unnoticed.
  prefs: []
  type: TYPE_NORMAL
- en: There is also one more thing you can do to make things better when writing scripts.
    In order to avoid the most common problems with syntax and logic, primarily syntax,
    you can use automated tools.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of tools you can use. We have already mentioned one, although
    we didn't explicitly mention that it is an actual tool. We instead said that your
    editor is going to take care of most of your problems. Editors that are currently
    available usually include functionality that enables them to understand the syntax
    of the language you are using and to offer help if they notice something wrong.
    Support of this kind in editors is usually rudimentary and limits itself to being
    able to understand keywords and the lexical structure of a particular language.
    It is not uncommon for an editor to switch this functionality on as soon as it
    is able to identify the file and to autodetect the language you are trying to
    use. We have already seen examples of this. For more, please review [*Chapter
    2*](B16269_02_Final_PD_ePub.xhtml#_idTextAnchor037), *Using Text Editors*.
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, another set of tools you can use. We are talking about completely
    automated tools that are not only able to find errors in your scripts but are
    also able to find potential problems in your commands, and to even advise you
    how to improve your code.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder if it makes any sense to run an application on a script that
    will report the same errors as Bash would, and your question is valid. Bash is
    by itself completely capable of reporting any syntax errors, but it includes only
    a minimal set of messages to help you solve the problem. In essence, Bash reports
    only those errors that stop your code from working.
  prefs: []
  type: TYPE_NORMAL
- en: A good tool for *code analysis*, and this is the term used when talking about
    these applications, will find problems in your code and will give you suggestions
    to improve the code you have written. Things that are going to be reported may
    be obvious at first glance, but some of them are also errors that can lead to
    problems, such as missing quotes or misplaced variable assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'One such tool is **ShellCheck**, which is available both online and offline
    in the form of a package. In order to use it offline, you must install it using
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After that, it's only a matter of running it on your script. We will do that
    later when we touch upon how you can also run this tool online in a browser, and
    it will give you the same results as the offline version. The only difference
    is the interface and the simplicity of clicking on a link inside a browser. Both
    versions report exactly the same errors and behave the same when it comes to recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to run this tool on a couple of our scripts to see what it has
    to say about the quality of our code. First, we are going to see what happens
    when we make a simple syntax error. We are using the script we used when we introduced
    the `if` statement. The script is named `testif3.sh`, and we have simply removed
    one line containing the `then` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9 – ShellCheck provides much better warnings about syntax errors
    than Bash does'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.9_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.9 – ShellCheck provides much better warnings about syntax errors than
    Bash does
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the tool has found the problem immediately and has not only
    reported it, but has also given us a suggestion about what to do next. The interesting
    thing is that it has marked the `if` statement that has the error in it, while
    Bash gave us an error that was comparatively misdirected, pointing to a piece
    of code that comes in much later in the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we fix the error, we can rerun the tool, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If there is no output from the tool, this means that no errors were detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s do it on a more complex script. In this case, we are working with
    a script named `funcglobal.sh` from [*Chapter 12*](B16269_12_Final_PD_ePub.xhtml#_idTextAnchor283)*,
    Using Arguments and Functions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10 – Using variables in this way is not an error as such but it
    can lead to problems'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.10_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.10 – Using variables in this way is not an error as such but it can
    lead to problems
  prefs: []
  type: TYPE_NORMAL
- en: The output does not look pretty because of the large font size in the terminal,
    but it gives us an idea of what to do better in our script. As we mentioned earlier,
    spaces are a big problem and so by using double quotes, we will prevent a space
    character completely messing up our script.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to do one more example, a modified version of a script we used
    earlier and saved under the name `functions.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run ShellCheck on this, we are going to end up with a long output, part
    of which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11 – Output of ShellCheck is going to warn you if it sees logical
    errors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.11_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.11 – Output of ShellCheck is going to warn you if it sees logical
    errors
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click on the link that ShellCheck provides as the last line of the output,
    we are taken to a detailed explanation of why this is a problem, as can be seen
    in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12 – Links that ShellCheck provides give you detailed information
    about the error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.12_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.12 – Links that ShellCheck provides give you detailed information
    about the error
  prefs: []
  type: TYPE_NORMAL
- en: This explanation is not only useful, but it also contains more links for when
    we want to understand what actually went wrong, why it went wrong, and what is
    the reason for this being an issue to look at in the first place. Sometimes, the
    problems that the tool detects are going to have limited scope and will be solved
    in some versions of the Bash interpreter yet misbehave in another.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Troubleshooting is complicated since we are unable to anticipate all the possible
    problems. Some of them as follows are, however, common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mywiki.wooledge.org/BashPitfalls](https://mywiki.wooledge.org/BashPitfalls)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://mywiki.wooledge.org/BashGuide](https://mywiki.wooledge.org/BashGuide)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.shellcheck.net/](https://www.shellcheck.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple debugging approach – echoing values during script execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you will learn when using Bash is how to regularly use the `echo`
    command when running any script. This approach is simple as it gives us an opportunity
    to follow the workflow of the script and to print the values of the variables
    as they are in different points of the script. Being able to understand both those
    things is going to help us to follow all the inputs to our script and to see how
    they transform into outputs that we expect.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are going to deal with simple ways we can make our script
    help us understand what is happening during its run. There are three ways we can
    use this simple method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we can do is use the `echo` command in every place in the script
    that we think is helpful. As an example, take a look at one of the scripts from
    previous chapters (`funcglobal.sh`) that is already pretty verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.13 – Using echo to debug program flow is useful when dealing with
    functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.13_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.13 – Using echo to debug program flow is useful when dealing with
    functions
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add even more `echo` statements here to enable us to see exactly
    what is happening and in what order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.14 – There are never enough echo commands when debugging'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.14_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.14 – There are never enough echo commands when debugging
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now run our modified script, we will be able to precisely follow the
    flow of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is particularly useful when we're dealing with a lot of code blocks, functions,
    and conditional statements. The rough idea here is that we can use `echo` to announce
    entering and leaving each code block so that we can see if our script ran correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we are going to do is to print the values of variables during
    the script execution. While doing this, we suggest you always mention the place
    this particular command is printing variables from in the code of the script.
    When debugging this way, the values of the variables are going to be printed to
    the output in the order they are assigned, helping us follow the flow of the script.
    Our previous example already does that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is one more thing you can do to make your scripts provide more information
    when you are debugging them. There is a command built into bash called `trap`.
    The main reason it is there is to help you react to interrupts and to ensure that
    your script works even if something unexpected happens. The syntax it uses is
    simple – we need to tell it what to do and under what circumstances to do it.
    By circumstances, we mean any interrupt signal possible under Linux. The most
    common ones are `SIGHUP`, `SIGKILL`, and `SIGQUIT`, but a lot of others are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can create a script like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15 – Using trap inside the script to stop Ctrl + C'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.15_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.15 – Using trap inside the script to stop Ctrl + C
  prefs: []
  type: TYPE_NORMAL
- en: 'What this first line does is that it establishes something considered to be
    an interrupt routine. If at any point in our script someone uses *Ctrl + C* to
    interrupt it, our script will detect that and execute two commands inside quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When we first tried, we pressed the interrupt key and our *routine* did what
    we told it to, which was to exit the script right away and give us a warning about
    it. This command can also be very useful to block attempts to stop the script
    since it will execute whatever we tell it to and then just continue running the
    script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing that you can do is to use `EXIT` as the keyword in the `trap`
    command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This keyword covers any possible way to exit from a script, meaning that this
    `trap` is going to be executed no matter what happens to the script, and it will
    run right before the control returns to whatever process ran our script.
  prefs: []
  type: TYPE_NORMAL
- en: When used this way, `trap` is useful not only for debugging but also for cleaning
    up after your script, since it will run as the last command, enabling you to do
    whatever needs to be done to close the files and clean things up after your script.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No matter which way you choose to debug your scripts, it all boils down to heavily
    modifying it. Using `echo` is useful but at the same time requires adding a lot
    of commands to the script we are debugging. Having said that, this is probably
    going to be the first thing you will try when debugging any script since it enables
    you not only to understand how the values inside the scripts change but also how
    the entire script works because you have the exact information of where your command
    is executed from, enabling you to understand both the variables and the workflow
    of the script.
  prefs: []
  type: TYPE_NORMAL
- en: Using `trap` is a slightly more nuanced way of debugging and can be very useful
    to gain knowledge of what is happening when we go outside of the program flow
    we imagined. If a script breaks or gets interrupted in any other way, `trap` will
    give you information on what happened and where.
  prefs: []
  type: TYPE_NORMAL
- en: There isn't a particular way of debugging to recommend here as all of them work
    in a particular scenario. What we can say is that you should try using all of
    them and see which fits a particular scenario.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://www.linuxjournal.com/content/bash-trap-command](https://www.linuxjournal.com/content/bash-trap-command)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_02.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_12_02.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the bash -x and -v options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have tried debugging using different methods that involved
    commands inserted into our scripts. Regardless of the command we used, this approach
    has one drawback – whatever we do, using commands inside the script is either
    very localized to a particular part of a given script or too global since it has
    to cover a good chunk of code. We are not saying that this is not a valid way
    of solving problems in scripts, but we still need more ways to debug.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only thing we need to know before we start using this is that we will be
    running scripts by invoking them as parameters of the interpreter, so something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is important since we can not use any of these options if we invoke scripts
    in any other way.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bash is in this respect pretty complicated since it offers little, in fact almost
    nothing, in terms of support for any reasonable systematic debugging, and we have
    already mentioned that. There is a glimmer of hope, however, and that comes in
    the form of two switches, `-x` and `-v`. The first one turns on the printing of
    every command that is run in the script and it also prints all the command arguments
    used. This makes understanding the workflow of commands easy.
  prefs: []
  type: TYPE_NORMAL
- en: Using `-v` is arguably less useful. It simply prints all the script lines as
    they are read.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand these options, we are going to create a small example
    using one of the scripts we used in a different recipe, but this time we are going
    to use different switches when running it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to use `-v`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to use `-x` to run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Both switches have their place in debugging. When we said that `-v` is less
    useful than `-x`, we meant that it only gives us an insight into how Bash interpreted
    your script, but nothing more than that.
  prefs: []
  type: TYPE_NORMAL
- en: Using `-x` shows us how Bash executed the script and what commands it ran during
    the execution. What you must understand is that this is not going to be the list
    of all commands in the script but only those that actually ran. If a particular
    part of the script was not used, for example, if it belonged to a block of commands
    that are in the code only for a specific condition, this way of running a script
    will not show that.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common thing is using both switches together, since it enables us to
    quickly understand what the script looks like and what Bash does when executing
    it. In a large script, this is going to generate a lot of output, but this is
    usually what we actually want to do. Then, we can go through the script step by
    step and understand the logic it implements.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we cannot consider this as a universal solution to anything.
    Although it gives us a lot of information about the command it runs, it is very
    limited by what the variable values are and what is actually going on when processing
    data. Take, for example, this loop included in the file `forloop1.sh`, available
    as part of the files included with the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are not going to copy the entire output since it has no other useful information.
    Here, we can see that we are looping in a `for` loop, and we can see possible
    values but the actual value of a particular variable is not seen unless we print
    it. This means that we will have to combine this way of debugging with the other
    ways we presented in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://linux.die.net/man/1/bash](https://linux.die.net/man/1/bash)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using set to debug a part of the script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we dealt with globally using two options to tell Bash
    to include a lot of useful information in its output. We mentioned that this offers
    another way to deal with debugging and troubleshooting how your scripts work.
    At the same time, we mentioned that this approach is in stark contrast with using
    commands in the script itself since we can deal with things globally without too
    many changes to the scripts when debugging.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to cover another way to debug, one that shares
    a lot of similarities with the ones we introduced before, while also being different.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One very interesting built-in command in Bash is `set`. What it does is give
    us the ability to change the options Bash uses. A lot of things can be changed
    by using `set`, and by a lot we mean almost every option Bash has. In this recipe,
    we are using only two of them, but you can turn all of them on or off.
  prefs: []
  type: TYPE_NORMAL
- en: '`set` enables us to set a particular option on in just a small block of code,
    instead of using it globally. You also need to know that `set` can turn an option
    both on and off. If we use `set` with a `–` sign, we turn the option on. For example,
    we could use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is telling Bash to start showing us commands as they are executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slightly confusing way is if we turn off any option that is currently used.
    To do that, we have to use the `+` sign, something that is a little bit counterintuitive
    since *adding* is usually used to turn something on, not off. For example, look
    at this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will turn off the output of commands in Bash.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to see a couple of examples of this just to make you comfortable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `set` is simple. In any script we wish to debug, we are going to insert
    the `set` statement right before the place we are starting our trace from. After
    we no longer need to trace our script, we simply unset the option and we are done.
    We can do this as many times as we need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.16 – How to set and unset options while running the script'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.16_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.16 – How to set and unset options while running the script
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are starting our trace just before we do the test of our
    variable. This means that we are going to start tracing right before we do a test
    and stop tracing right before we continue the loop. The result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can even consider this way of debugging as a special case of using options
    globally. We are basically doing the same thing as in previous examples where
    we used `set` globally, but this time we are limiting the scope to make the output
    more readable. Sometimes that can make working a lot easier since we are not creating
    much irrelevant output.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `set` command can be used for one more thing, and that is to force Bash
    to do some things differently than are usually done. For example, we can make
    scripts fail if any command inside them fails, we can make scripts fail if they
    reference a value of a variable that is not set, or we can even change the way
    Bash expands characters in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: All these things can be useful when working but at the same time, can be a little
    too much to grasp all at once when you first begin scripting, so we decided to
    not include them in these recipes.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://linuxhint.com/debug-bash-script/](https://linuxhint.com/debug-bash-script/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html](https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
