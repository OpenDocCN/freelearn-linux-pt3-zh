<html><head></head><body>
		<div id="_idContainer128">
			<h1 id="_idParaDest-115" class="chapter-number"><a id="_idTextAnchor117"/>6</h1>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor118"/>PowerShell and Files – Reading, Writing, and Manipulating Data</h1>
			<p>So far, our PowerShell journey has been on the screen. Wouldn’t it be neat to be able to write the output of our cmdlets to a file somewhere so that we could save it for later or send it to other people? That’s what we’re going to do in this chapter. First, we’re going to look at formatting output for the screen so that we can just focus on the things we’re interested in or present output in a more useful manner. Next, we’re going to look at writing the output to a text file using <strong class="source-inline">Out-File</strong>. I do this multiple times a day and it’s an incredibly useful technique, but it is very limited, so we’re also going to look at creating <strong class="bold">Comma-Separated Value</strong> (<strong class="bold">CSV</strong>) files for consumption by another program, such as Microsoft Excel, and HTML files so that we can display our output as a <span class="No-Break">web page.</span></p>
			<p>Once we’re comfortable with the output, we’re going to dive into a short section that will help us understand how PowerShell interacts with filesystems, before looking at how we can use PowerShell to read and manipulate data in common file types, such as text and CSV files. Finally, we’ll wrap the chapter up with a short walkthrough of a fun project and leave you with <span class="No-Break">a challenge.</span></p>
			<p>In this chapter, we are going to cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li><span class="No-Break">Understanding formatting</span></li>
				<li>Writing to a <span class="No-Break">text file</span></li>
				<li>Using <strong class="source-inline">ConvertTo-</strong> and <span class="No-Break"><strong class="source-inline">Export-</strong></span><span class="No-Break"> cmdlets</span></li>
				<li><span class="No-Break">Handling files</span></li>
				<li>Working <span class="No-Break">with file</span></li>
				<li>Let’s have <span class="No-Break">some fun!</span></li>
			</ul>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor119"/>Understanding formatting</h1>
			<p>Let’s think<a id="_idIndexMarker402"/> about our old friend, <strong class="source-inline">Get-Process</strong>. We know that when we run it, it displays a list of the running processes on our machine. For each process, it displays some of the properties. We know from running <strong class="source-inline">Get-Process | Get-Member</strong> that there are many more that it doesn’t display unless we ask for them explicitly. This is the case for pretty much every PowerShell cmdlet; the output we see is rarely the complete output of every property the objects in the pipeline possess. How does that happen? Welcome<a id="_idIndexMarker403"/> to the <span class="No-Break"><strong class="bold">default format</strong></span><span class="No-Break">.</span></p>
			<p>PowerShell decides on the format for displaying output based on the <strong class="source-inline">TypeName</strong> of the object in the pipeline. If the <strong class="source-inline">TypeName</strong> has an<a id="_idIndexMarker404"/> associated <strong class="bold">default formatting view</strong>, then PowerShell will use it. If there isn’t a default formatting view, for instance, if it is a <strong class="source-inline">PSCustomObject</strong>, then the shell will determine whether there <a id="_idIndexMarker405"/>is a <strong class="bold">default property set</strong> and, if so, display that. If there are fewer than five default properties, they will be displayed in a table; if there are more than five, then they will be displayed as a list. Finally, if the object has neither a default formatting view nor a default property set, then all the properties will <span class="No-Break">be displayed.</span></p>
			<p>We can see part of the default formatting view for <strong class="source-inline">Get-Process</strong> in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B17600_06_01.jpg" alt="Figure 6.1 – Part of the default formatting view for System.Diagnostics.Process objects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Part of the default formatting view for System.Diagnostics.Process objects</p>
			<p>It is possible to redefine the properties that are displayed by default, but I’ve never found it necessary to do so, so it’s beyond the scope of this book. If it’s something you think you might like to do, then have a look at the help files for the <strong class="source-inline">FormatData</strong> cmdlets by running <span class="No-Break">the following:</span></p>
			<pre class="console">
Get-Help *FormatData</pre>			<p>We don’t need to do anything as drastic as updating <strong class="source-inline">FormatData</strong> to change the way our output is formatted, though. In the rest of this section, we’re going to look at three common ways of <a id="_idIndexMarker406"/>changing the way our data is displayed using <strong class="source-inline">Format</strong> cmdlets. First, let’s look at my <span class="No-Break">favorite, </span><span class="No-Break"><strong class="source-inline">Format-List</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor120"/>Format-List</h2>
			<p>Most cmdlets we use <a id="_idIndexMarker407"/>will display output as a table with the object name and <a id="_idIndexMarker408"/>a few well-chosen properties. <strong class="source-inline">Format-List</strong> allows us to display the object properties and values as a list. Note that <strong class="source-inline">Format-List</strong> displays the properties in the default property set, not the ones in the default format view if a view exists. Have a look at the following screenshot to see what <span class="No-Break">we mean:</span></p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B17600_06_02.jpg" alt="Figure 6.2 – The default format and the list format"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The default format and the list format</p>
			<p>We can see that running <strong class="source-inline">Get-Process</strong> on its own produces some very different information from what we get when we pipe it into <strong class="source-inline">Format-List</strong>. In fact, <strong class="source-inline">Format-List</strong> doesn’t look very good at all, there – so why do I use it so much? Try getting the information for a single process and using <strong class="source-inline">Format-List</strong> with the wildcard operator, (<strong class="source-inline">*</strong>), <span class="No-Break">as follows:</span></p>
			<pre class="console">
Get-Process pwsh | Format-List *</pre>			<p>There! Lots of information. We can also just select certain properties to display by passing a comma-separated list to the <strong class="source-inline">-Property</strong> parameter of <strong class="source-inline">Format-List</strong>, <span class="No-Break">as follows:</span></p>
			<pre class="console">
Get-Process pwsh | Format-List -Property Name, Id, CPU, Responding</pre>			<p><strong class="source-inline">Format-List</strong> has the <strong class="source-inline">fl</strong> alias, so an awful lot of the stuff I ask people for when I’m troubleshooting<a id="_idIndexMarker409"/> their <a id="_idIndexMarker410"/>servers has <strong class="source-inline">|fl *</strong> somewhere near <span class="No-Break">the end.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor121"/>Format-Table</h2>
			<p>If we want a <a id="_idIndexMarker411"/>subset of data for a number of objects, then the table<a id="_idIndexMarker412"/> format is convenient. If we want different data to the default format view, then we can use <strong class="source-inline">Format-Table</strong>. <span class="No-Break">Try this:</span></p>
			<pre class="console">
Get-Process | Format-Table -Property Name, Id, CPU, Responding</pre>			<p>This will get us a subset of properties for each process in a convenient <span class="No-Break">table format.</span></p>
			<p>Quite often, when we run <strong class="source-inline">Format-Table</strong>, we don’t actually see all the data we’ve asked for; instead, the output is truncated with an ellipsis (<strong class="source-inline">…</strong>). Happily, there are two other parameters of <strong class="source-inline">Format-Table</strong> that can help us out. Firstly, we can use the <strong class="source-inline">-AutoSize</strong> parameter to remove white space between columns and set each column to the width of its largest entry. However, if that still doesn’t get everything, then we can use the <strong class="source-inline">-Wrap</strong> parameter to display each entry across multiple lines. Try this to see <span class="No-Break">the difference:</span></p>
			<pre class="console">
Get-Process | Format-Table -Property Name, Id, CPU, Path, Modules
Get-Process | Format-Table -Property Name, Id, CPU, Path, Modules -Wrap</pre>			<p>That’s quite<a id="_idIndexMarker413"/> handy. Let’s <a id="_idIndexMarker414"/>look at our last format <span class="No-Break">cmdlet, </span><span class="No-Break"><strong class="source-inline">Format-Wide</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor122"/>Format-Wide</h2>
			<p>The <strong class="source-inline">Format-Wide</strong> cmdlet<a id="_idIndexMarker415"/> allows us to show data in a wide list <a id="_idIndexMarker416"/>format, which makes it easier to read on a screen. It resembles the standard Linux list output (<strong class="source-inline">ls</strong>), but without the coloring rules that make the list command so useful. It will only display a single property of each object and defaults to a <strong class="source-inline">Name</strong> property unless we specify something else using the <strong class="source-inline">-Property</strong> parameter. It has two parameters that allow us to control the display – <strong class="source-inline">-Column</strong>, which specifies a set number of columns, and <strong class="source-inline">-AutoSize</strong>, which tries to fit in as many as possible without truncating the data. <span class="No-Break">Try this:</span></p>
			<pre class="console">
Get-ChildItem | Format-Wide
Get-ChildItem | Format-Wide -Column 5
Get-ChildItem | Format-Wide -AutoSize</pre>			<p>Personally, I don’t find I use the <strong class="source-inline">Format-Wide</strong> cmdlet anything as much as I should. It’s useful for concisely seeing a list of objects and saves scrolling up and down looking for <span class="No-Break">an item.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/>Formatting gotchas</h2>
			<p>In <a href="B17600_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">The PowerShell Pipeline – How to String Cmdlets Together</em>, we <a id="_idIndexMarker417"/>discussed a very important rule: <strong class="bold">Filter Left</strong>. Well, here <a id="_idIndexMarker418"/>we have<a id="_idIndexMarker419"/> another important rule: <strong class="bold">Format Right</strong>. Although the <strong class="source-inline">Format-</strong> cmdlets produce readable text on the screen, that’s because the formatting data objects they produce are processed by the shell. We really can’t use the output from a <strong class="source-inline">Format-</strong> cmdlet anywhere else in the pipeline, except to feed it into one of the specialized <strong class="source-inline">Out-</strong> cmdlets, such as the <strong class="source-inline">Out-Default | Out-Host</strong> pair that is implicit on the end of every <span class="No-Break">PowerShell pipeline.</span></p>
			<p>There is, however, a very useful <strong class="source-inline">Out-</strong> cmdlet that we haven’t looked at yet, and we’ll cover it in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor124"/>Writing a text file</h1>
			<p>We started this <a id="_idIndexMarker420"/>chapter by promising to cover writing PowerShell output to a file. Let’s do that. We have learned that we can feed the output of the <strong class="source-inline">Format-</strong> cmdlets into an <strong class="source-inline">Out-</strong> cmdlet and there is a specific cmdlet for writing data to a <span class="No-Break">file; </span><span class="No-Break"><strong class="source-inline">Out-File</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">Out-File</strong> will write the output from any cmdlet to a text file. We can format the output first using a <strong class="source-inline">Format-</strong> cmdlet if we want to, but we don’t have to; if we don’t, we get the default output of the cmdlet. Let’s <span class="No-Break">try it:</span></p>
			<pre class="console">
Get-Process | Out-File -FilePath C:\temp\poshbook\procsRaw.txt
Get-Process | Format-Table -Property Name, Id, CPU, Path, Modules | Out-File -FilePath C:\temp\poshbook\procsNoWrap.txt
Get-Process | Format-Table -Property Name, Id, CPU, Path, Modules -Wrap | Out-File -FilePath C:\temp\poshbook\procsWrap.txt</pre>			<p>As we can see, the content of the text files looks exactly the same as the screen outputs; all we’ve done is redirect the output to a file instead of <span class="No-Break">the screen.</span></p>
			<p>There are a few parameters we can use <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Out-File</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">-FilePath</strong> specifies the path and name of the file we want to create. By default, <strong class="source-inline">Out-File</strong> will overwrite any pre-existing file with the same name, unless that file <span class="No-Break">is read-only.</span></li>
				<li><strong class="source-inline">-Append</strong> will add the output to an existing file, again, if it is not set <span class="No-Break">to read-only.</span></li>
				<li><strong class="source-inline">-NoClobber</strong> will check whether a file already exists and prevent it from being overwritten. We’ll see an error message saying that the file <span class="No-Break">already exists.</span></li>
				<li><strong class="source-inline">-Force</strong> will allow us to ignore the read-only attribute on <span class="No-Break">existing files.</span></li>
				<li><strong class="source-inline">-Encoding</strong> can change the default encoding of the file from ASCII to a range of other formats; a popular one <span class="No-Break">is UTF-8.</span></li>
			</ul>
			<p><strong class="source-inline">Out-File</strong> also has a couple of aliases that we might see quite often. The greater-than symbol (<strong class="source-inline">&gt;</strong>) is an alias for <strong class="source-inline">Out-File -FilePath</strong>, and we just need to type a path and file name after it. A double greater-than symbol (<strong class="source-inline">&gt;&gt;</strong>) is an alias for <strong class="source-inline">Out-File -Append -FilePath</strong> and again, just needs a path and filename. We can’t use any other parameters with these aliases. For example, <strong class="source-inline">Get-Process &gt; C:\temp\processes.txt</strong> will take the output of <strong class="source-inline">Get-Process</strong> and save it to<strong class="source-inline"> C:\temp.txt</strong> – if we then run <strong class="source-inline">Get-Date &gt;&gt; C:\temp\processes.txt</strong>, it will append the output of <strong class="source-inline">Get-Date</strong> to the <span class="No-Break">same file.</span></p>
			<p><strong class="source-inline">Out-File</strong> only produces a file. It doesn’t put any object in the pipeline, so must be the last cmdlet in <span class="No-Break">a pipeline.</span></p>
			<p>The first important thing to remember is that what gets written to the file is <em class="italic">exactly</em> what we would see on <span class="No-Break">the screen.</span></p>
			<p>The other important thing to remember is that a file we create with <strong class="source-inline">Out-File</strong> is a text file. We can call it a CSV file if we want, but it won’t be. The data won’t be converted; no commas will be<a id="_idIndexMarker421"/> inserted. <span class="No-Break">Let’s demonstrate:</span></p>
			<pre class="console">
Get-Process | Format-Table -Property Name, Id, CPU, Path, Modules -Wrap | Out-File C:\temp\poshbook\procsWrap.csv</pre>			<p>As expected, the contents of the CSV file created in the last line look horrible. Here’s what it looks like if I try to open it in MS Excel, my usual app for manipulating <span class="No-Break">CSV files:</span></p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B17600_06_03.jpg" alt="Figure 6.3 – This is not a CSV file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – This is not a CSV file</p>
			<p>We’ll have a look at how we can produce different types of files in the next section, using<a id="_idIndexMarker422"/> the <strong class="source-inline">ConvertTo-</strong> and <span class="No-Break"><strong class="source-inline">Export-</strong></span><span class="No-Break"> cmdlets.</span></p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor125"/>Using ConvertTo- and Export- cmdlets</h1>
			<p>If we want our<a id="_idIndexMarker423"/> PowerShell objects in a format other than text, we’re going<a id="_idIndexMarker424"/> to need to process them somehow. There are two groups of cmdlets that let us do that. The <strong class="source-inline">ConvertTo-</strong> cmdlets convert the objects in our pipeline into data of a particular type, such as CSV or HTML data. The <strong class="source-inline">Export-</strong> cmdlets combine the equivalent <strong class="source-inline">ConvertTo-</strong> cmdlet with an <strong class="source-inline">Out-File</strong> function to produce a file of the relevant type. In this chapter, we’re going to cover three common file types; CSV, XML, <span class="No-Break">and HTML.</span></p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor126"/>CSV</h2>
			<p>Let’s look <a id="_idIndexMarker425"/>at the <strong class="source-inline">ConvertTo-CSV</strong> cmdlet first. With this cmdlet, we can take the output of another cmdlet and turn it into a CSV datastream. <span class="No-Break">Try this:</span></p>
			<pre class="console">
Get-Process | ConvertTo-Csv</pre>			<p>You’ll see something like the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B17600_06_04.jpg" alt="Figure 6.4 – Nasty"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Nasty</p>
			<p>Ugh. Horrible, right? However, we can then pipe that into <strong class="source-inline">Out-File</strong> <span class="No-Break">as follows:</span></p>
			<pre class="console">
Get-Process w* | ConvertTo-Csv | Out-File C:\temp\poshbook\ProcessesConvertTo.csv</pre>			<p>It will produce a real CSV file of all the processes starting with <strong class="source-inline">w</strong> that we can open in an application that reads CSV, such as MS Excel or Google Sheets. Not only that but it also ignores the default format information and just <span class="No-Break">dumps everything.</span></p>
			<p>Even better, there<a id="_idIndexMarker426"/> is a cmdlet that will do the whole thing in one operation – <span class="No-Break"><strong class="source-inline">Export-Csv</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
Get-Process | Export-Csv C:\temp\poshbook\ProcessesExport.csv</pre>			<p>Let’s take a <span class="No-Break">closer look.</span></p>
			<h3>ConvertTo-Csv</h3>
			<p>This cmdlet has a<a id="_idIndexMarker427"/> few<a id="_idIndexMarker428"/> parameters we will be <span class="No-Break">interested in:</span></p>
			<ul>
				<li><strong class="source-inline">-NoTypeInformation</strong>: A lot of the scripts we might see on the internet will include this parameter, but we don’t need it anymore. Prior to PowerShell 6.0, by default, the <strong class="source-inline">ConvertTo-Csv</strong> cmdlet included an introductory line that detailed the object type that had been converted, so any scripts that were written for earlier versions of PowerShell almost always included this parameter to remove that line. Since PowerShell 6.0, the default is to <em class="italic">not</em> include type information. Including the parameter won’t cause a problem, but we don’t need it in <span class="No-Break">PowerShell 7.x.</span></li>
				<li><strong class="source-inline">-IncludeTypeInformation</strong>: Use this if you <em class="italic">do</em> want to know the type of the object in the first line of the <span class="No-Break">CSV stream.</span></li>
				<li><strong class="source-inline">-Delimiter</strong>: We usually want our CSV file to use a comma as the field delimiter character, but sometimes we might need to produce a <strong class="bold">Tab-Separated Values</strong> (<strong class="bold">TSV</strong>) file<a id="_idIndexMarker429"/> using the tab delimiter, <strong class="source-inline">`t</strong>, or perhaps use a colon or semicolon. We can use this parameter to specify a different delimiter character – for example, in <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">Get-Process | ConvertTo-Csv -delimiter ';'| Out-File C:\temp\poshbook\ProcessesConvertTo.csv</strong></pre></li>				<li>This is handy when we are converting <strong class="source-inline">DateTime</strong> objects, which in some <strong class="bold">UI cultures</strong>, include <a id="_idIndexMarker430"/>a comma in the value for <strong class="source-inline">"DateTime"; "Monday, August 6, </strong><span class="No-Break"><strong class="source-inline">2022 17:55"</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-UseQuotes</strong>: This parameter controls how the cmdlet applies double-quote characters. By default, every value is double-quoted, turning it into a string, but sometimes we might want to keep the values as integers or floating point numbers. We can use this parameter to control the <span class="No-Break">quoting behavior.</span></li>
				<li><strong class="source-inline">-QuoteFields</strong>: If we need even finer control over quoting behavior, we can specify the fields in which we want the values to be double-quoted. The first line of the CSV file is the field names and it may take a bit of experimentation to get <span class="No-Break">this right.</span><a id="_idIndexMarker431"/></li>
			</ul>
			<p>Once we’ve converted <a id="_idIndexMarker432"/>our objects into a CSV datastream, we can either pipe it to <strong class="source-inline">Out-File</strong> or consume it in some other way; for instance, we might want to create a number of CSV objects and then aggregate and manipulate them before outputting a <span class="No-Break">single file.</span></p>
			<h3>Export-Csv</h3>
			<p>The <strong class="source-inline">Export-Csv</strong> cmdlet<a id="_idIndexMarker433"/> combines <strong class="source-inline">ConvertTo-Csv</strong> with <strong class="source-inline">Out-File</strong> in a single<a id="_idIndexMarker434"/> cmdlet. It has the same interesting parameters that we’ve already discussed for those cmdlets. Here are the matching <span class="No-Break"><strong class="source-inline">Out-File</strong></span><span class="No-Break"> parameters:</span></p>
			<ul>
				<li><strong class="source-inline">-Path (instead </strong><span class="No-Break"><strong class="source-inline">of -FilePath)</strong></span></li>
				<li><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Force</strong></span></li>
				<li><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">NoClobber</strong></span></li>
				<li><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Encoding</strong></span></li>
				<li><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Append</strong></span></li>
			</ul>
			<p>Here are the parameters <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">ConvertTo-Csv</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Delimiter</strong></span></li>
				<li><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">NoTypeInformation</strong></span></li>
				<li><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">IncludeTypeInformation</strong></span></li>
				<li><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">QuoteFields</strong></span></li>
				<li><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">UseQuotes</strong></span></li>
			</ul>
			<p>The parameters for <strong class="source-inline">Export-Csv</strong> work the same as the equivalent parameters in <strong class="source-inline">ConvertTo-Csv</strong> and <strong class="source-inline">Out-File</strong>. There<a id="_idIndexMarker435"/> are<a id="_idIndexMarker436"/> no aliases <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Export-Csv</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor127"/>XML</h2>
			<p><strong class="bold">eXtensible Markup Language</strong> (<strong class="bold">XML</strong>) is a <a id="_idIndexMarker437"/>specialized language intended to be both machine- and human-readable. It’s handy for transferring data structures across networks and between systems. <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.1</em> at the start of this chapter is an example of XML. We’ll be seeing more of it as we go through the book, but for now, all we need to know is that there are two cmdlets associated with writing objects as XML data – <strong class="source-inline">ConvertTo-Xml</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Export-Clixml</strong></span><span class="No-Break">.</span></p>
			<h3>ConvertTo-Xml</h3>
			<p>This cmdlet <a id="_idIndexMarker438"/>only has a handful <a id="_idIndexMarker439"/><span class="No-Break">of parameters:</span></p>
			<ul>
				<li><strong class="source-inline">-As</strong>: This parameter allows us to specify the output format; whether it’s a single string, an array of strings, or an <span class="No-Break"><strong class="source-inline">XmlDocument</strong></span><span class="No-Break"> object.</span></li>
				<li><strong class="source-inline">-Depth</strong>: We can use this to limit the number of levels and sublevels the document can contain. By default, this <span class="No-Break">isn’t specified.</span></li>
				<li><strong class="source-inline">-NoTypeInformation</strong>: This stops the object type information from <span class="No-Break">being written.</span></li>
			</ul>
			<h3>Export-Clixml</h3>
			<p><strong class="bold">Common Language Infrastructure XML</strong> <strong class="bold">(Clixml</strong>) can be used <a id="_idIndexMarker440"/>to store<a id="_idIndexMarker441"/> objects in a file and then recreate those objects from the file. The <strong class="source-inline">Export-Clixml</strong> cmdlet is pretty simple. It has one of the <strong class="source-inline">ConvertTo-Xml</strong> parameters, <strong class="source-inline">-Depth</strong>, and then the following <span class="No-Break"><strong class="source-inline">Out-File</strong></span><span class="No-Break"> parameters:</span></p>
			<ul>
				<li><strong class="source-inline">-Path (instead </strong><span class="No-Break"><strong class="source-inline">of -FilePath)</strong></span></li>
				<li><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Force</strong></span></li>
				<li><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">NoClobber</strong></span></li>
				<li><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Encoding</strong></span></li>
			</ul>
			<p>Let’s create an XML file we can <span class="No-Break">use later:</span></p>
			<pre class="console">
Get-Date |Export-Clixml -Path C:\temp\poshbook\date.xml</pre>			<p>Try opening that in an editor such as notepad or VS Code. You should see something like <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B17600_06_05.jpg" alt="Figure 6.5 – A date represented in XML"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – A date represented in XML</p>
			<p>The important bit <a id="_idIndexMarker442"/>is line 3. That’s the actual<a id="_idIndexMarker443"/> data; the rest is formatting information and information about the type of object. Keep this file and we’ll use it later in <span class="No-Break">the chapter.</span></p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor128"/>HTML</h2>
			<p>It is really <a id="_idIndexMarker444"/>useful to be able to convert our PowerShell output into HTML, as we can display it in a web browser. This is a popular technique for writing reports in system administration. We can use it to produce dashboards and other online reports. There are better techniques for creating data that can be consumed by web APIs and we’ll be looking at those in the next chapter. There is only one cmdlet for creating HTML code; <strong class="source-inline">ConvertTo-Html</strong>. If we want to write it to a file, we’ll need to use <strong class="source-inline">Out-File</strong>. <span class="No-Break">Try this:</span></p>
			<pre class="console">
Get-Date | ConvertTo-Html | Out-File -FilePath C:\temp\poshbook\date.html</pre>			<p>If you then open <strong class="source-inline">Date.html</strong> in your web browser, you should see something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B17600_06_06.jpg" alt="Figure 6.6 – A date as HTML"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – A date as HTML</p>
			<p>That’s not particularly <a id="_idIndexMarker445"/>inspiring. Let’s take a closer look at the cmdlet to see whether we can make it <span class="No-Break">more interesting</span></p>
			<h3>ConvertTo-Html</h3>
			<p>The <strong class="source-inline">ConvertTo-Html</strong> cmdlet <a id="_idIndexMarker446"/>has quite a few interesting parameters that <a id="_idIndexMarker447"/>we can use to format <span class="No-Break">our output:</span></p>
			<ul>
				<li><strong class="source-inline">-As</strong>: This parameter allows us to format the output as a table or as a list. By default, we get <span class="No-Break">a table.</span></li>
				<li><strong class="source-inline">-Body</strong>: This allows us to add text after the opening <strong class="source-inline">&lt;body&gt;</strong> tag. This is the main part of any web page. We’re not going to explain how HTML works here – if you would like a refresher on HTML, then <a href="https://www.w3schools.com/">https://www.w3schools.com/ </a>is an excellent and free <span class="No-Break">online resource.</span></li>
				<li><strong class="source-inline">-Head</strong>: This allows us to write text in the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">head&gt;</strong></span><span class="No-Break"> section.</span></li>
				<li><strong class="source-inline">-Title</strong>: This allows us to give the page a title. Unlike <strong class="source-inline">-Body</strong> and <strong class="source-inline">-Head</strong>, it only takes a <span class="No-Break">single string.</span></li>
				<li><strong class="source-inline">-PreContent</strong>: This allows us to write text before the table <span class="No-Break">we create.</span></li>
				<li><strong class="source-inline">-PostContent</strong>: This allows us to add text after <span class="No-Break">the table.</span></li>
				<li><strong class="source-inline">-Meta</strong>: This allows us to add metatags to <span class="No-Break">the head.</span></li>
				<li><strong class="source-inline">-Fragment</strong>: This omits the <strong class="source-inline">&lt;head&gt;</strong> and <strong class="source-inline">&lt;body &gt;</strong> tags and just writes the HTML to produce the table. This is handy if we are going to concatenate a bunch of fragments into one single <span class="No-Break">web page.</span></li>
				<li><strong class="source-inline">-CssUri</strong>: This allows us to specify a CSS file to provide additional formatting, such as different fonts, background colors, and so on. I encourage you to have a look at <a href="http://www.csszengarden.com/">http://www.csszengarden.com/</a> to see some of the amazing things we can do <span class="No-Break">with CSS.</span></li>
			</ul>
			<p>Let’s have a play. Open <a id="_idIndexMarker448"/>a new file in VS Code, select CSS as the<a id="_idIndexMarker449"/> language, and type the following exactly <span class="No-Break">as written:</span></p>
			<pre class="source-code">
Table {
    color: blue ;
    text-align: center;
    background-color: bisque;
}
Body {
    background-color: cadetblue;
    font-family: 'Trebuchet MS';
    color: yellow;
}</pre>			<p>Save it as <strong class="source-inline">style.css</strong> in your working <span class="No-Break">directory, </span><span class="No-Break"><strong class="source-inline">C:\temp\poshbook</strong></span><span class="No-Break">.</span></p>
			<p>Create a new PowerShell file in the same directory and <span class="No-Break">try this:</span></p>
			<pre class="source-code">
$params = @{
    As = 'List'
    Title = 'My Date Page'
    Body = 'Here is my Date'
    CssUri = 'Style.css'
}
Get-Date | ConvertTo-Html @params | Out-File C:\temp\poshbook\FancyDate.Html
C:\temp\poshbook\FancyDate.html</pre>			<p>If you select and <a id="_idIndexMarker450"/>run<a id="_idIndexMarker451"/> your code, you should see the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B17600_06_07.jpg" alt="Figure 6.7 – A date as fancy HTML"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – A date as fancy HTML</p>
			<p>There is a great article on how t<a id="_idTextAnchor129"/>o write HTML documents in PowerShell <span class="No-Break">here: </span><a href="https://leanpub.com/creatinghtmlreportsinwindowspowershell/read"><span class="No-Break">https://leanpub.com/creatinghtmlreportsinwindowspowershell/read</span></a><span class="No-Break">.</span></p>
			<p>That’s a good start on how to<a id="_idIndexMarker452"/> create files. Next, let’s briefly divert to <strong class="source-inline">PSProviders</strong>, <strong class="source-inline">PSDrives</strong>, and<a id="_idIndexMarker453"/> the <span class="No-Break"><strong class="source-inline">New-Item</strong></span><span class="No-Break"> cmdlet.</span></p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor130"/>Handling files</h1>
			<p>Before we can work<a id="_idIndexMarker454"/> with files, we need to be able to find them, and understand how PowerShell works with hierarchical data structures such <span class="No-Break">as filesystems.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor131"/>A brief note about PSProviders and PSDrives</h2>
			<p>PowerShell <a id="_idIndexMarker455"/>connects to<a id="_idIndexMarker456"/> data structures through software <a id="_idIndexMarker457"/>called <strong class="bold">providers</strong>. These allow PowerShell to present a data structure as a filesystem (including the filesystem). On Windows, this allows us to search for and manipulate objects in the Registry and the Certificate Store as if they were files. Arguably, it is less useful on Linux. Let’s have a look. <span class="No-Break">Run this:</span></p>
			<pre class="console">
Get-PSProvider</pre>			<p>You should see a list of providers and associated drives. We can connect to the associated drive with the <span class="No-Break"><strong class="source-inline">Set-Location</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="console">
Set-Location Env:</pre>			<p>Note we have to use the name of the drive, not the name of the provider, and we need to follow it with <span class="No-Break">a colon.</span></p>
			<p>Once in the data structure, we can use <strong class="source-inline">Get-ChildItem</strong> to search for objects, as in the following screenshot, which lists out the environment variables as if they were <span class="No-Break">filesystem objects:</span></p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B17600_06_08.jpg" alt="Figure 6.8 – The environment provider"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – The environment provider</p>
			<p>Providers are dynamic; that is, they don’t need to know what is in the store before connecting to it and so they are popular as a way of providing access to data structures. While there are only a few included in PowerShell by default, you will find that some modules will add new providers, especially in Windows. For instance, if we install the <strong class="source-inline">ActiveDirectory</strong> module, then we will have access to an <strong class="source-inline">AD:</strong> drive containing the Active <span class="No-Break">Directory data.</span></p>
			<p>Note that just installing the provider is not enough. We also need to have a drive object before we<a id="_idIndexMarker458"/> can <a id="_idIndexMarker459"/>browse it. The drive is the thing we work with; the provider is the software that lets us access it. Most modules will create the required drive as well as install the provider. We can create our own drives quite easily. In my home directory on my Ubuntu machine, I have a directory called <strong class="source-inline">MyFiles</strong>. I can make this a drive by running <span class="No-Break">the following:</span></p>
			<pre class="console">
New-PsDrive -Name MyFiles -Root /home/nickp -PSProvider FileSystem</pre>			<p>Then, I can<a id="_idIndexMarker460"/> browse<a id="_idIndexMarker461"/> the <strong class="source-inline">MyFiles:</strong> drive, <span class="No-Break">like so:</span></p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B17600_06_09.jpg" alt="Figure 6.9 – Creating a new drive"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Creating a new drive</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor132"/>Item- cmdlets</h2>
			<p>We use the <strong class="source-inline">-Item</strong> and <strong class="source-inline">-Childitem</strong> cmdlets <a id="_idIndexMarker462"/>to move around the filesystem and find items. We’re not going to cover them in detail here, as they are self-explanatory. Read the associated help files to understand their <span class="No-Break">simple syntax:</span></p>
			<ul>
				<li><strong class="source-inline">Get-ChildItem</strong> lists the items found in <span class="No-Break">a location:</span><pre class="source-code">
<strong class="bold">Get-ChildItem -Path C:\Windows</strong></pre></li>				<li><strong class="source-inline">Copy-Item</strong> lets us make a copy of an item in a <span class="No-Break">different location:</span><pre class="source-code">
<strong class="bold">Copy-Item -Path 'C:\Temp\File.txt'  -Destination 'C:\New'</strong></pre></li>				<li><strong class="source-inline">Move-Item</strong> lets us move an item to a <span class="No-Break">different location:</span><pre class="source-code">
<strong class="bold">Move-Item -Path 'C:\Temp\File.txt'  -Destination 'C:\New'</strong></pre></li>				<li><strong class="source-inline">Rename-Item</strong> lets us change the name of <span class="No-Break">an item:</span><pre class="source-code">
<strong class="bold">Rename-Item -Path 'C:\New\File.txt' -NewName 'NewFile.txt'</strong></pre></li>				<li><strong class="source-inline">Remove-Item</strong> lets us delete <span class="No-Break">an item:</span><pre class="source-code">
<strong class="bold">Remove-Item -Path 'C:\New\NewFile.txt'</strong></pre></li>				<li><strong class="source-inline">Get-Item</strong> lists the item and its value; it doesn’t get the contents. Most of the time, we want to use <strong class="source-inline">Get-ChildItem</strong> instead when we’re working in the filesystem, but if we wanted to know the value of an environment variable, then we would use this cmdlet. Try this. Type <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">Get-Item </strong><strong class="bold">-</strong><strong class="bold">Path C:\temp\poshbook</strong></pre><p class="list-inset">Then, try this and see <span class="No-Break">the difference:</span></p><pre class="source-code"><strong class="bold">Get-ChildItem </strong><strong class="bold">-</strong><strong class="bold">Path C:\temp\poshbook</strong></pre><p class="list-inset"><strong class="source-inline">Get-Item</strong> has returned the properties of the <strong class="source-inline">C:\temp\poshbook</strong> folder, whereas <strong class="source-inline">Get-ChildItem</strong> has returned the folder and <span class="No-Break">its contents.</span></p></li>				<li><strong class="source-inline">Set-Item</strong>: Again, this is not hugely useful in the filesystem. However, if we wanted to change <a id="_idIndexMarker463"/>the value of an environment variable or an alias, then we would use <span class="No-Break">this cmdlet.</span></li>
				<li><strong class="source-inline">New-Item</strong>: We can use this to create files and folders, as well as create new aliases <span class="No-Break">and variables:</span><pre class="source-code">
<strong class="bold">New-Item </strong><strong class="bold">-</strong><strong class="bold">Path C:\New\File.txt</strong></pre></li>				<li><strong class="source-inline">Invoke-Item</strong>: Performs the default action on an item. For instance, if it’s an executable file, it will run it. If it is a TXT file, it will open the file in the default <span class="No-Break">text editor:</span><pre class="source-code">
<strong class="bold">Invoke-Item </strong><strong class="bold">-</strong><strong class="bold">Path C:\temp\poshbook\FancyDate.html</strong></pre></li>			</ul>
			<p>There are also two cmdlets for moving around in and between drives; <strong class="source-inline">Get-Location</strong> and <strong class="source-inline">Set-Location</strong>. Many of these cmdlets have aliases associated with them that echo the equivalent bash and Windows commands – for instance, <strong class="source-inline">Get-ChildItem</strong> can be called by using <strong class="source-inline">ls</strong> or <strong class="source-inline">dir</strong>. Note, however, that the parameters are still those for PowerShell, not for the bash or Windows command. For example, <strong class="source-inline">Dir /p</strong> will not produce a paginated directory listing – it will produce <span class="No-Break">an error.</span></p>
			<p>Now that we <a id="_idIndexMarker464"/>know how to find our files and move them around, let’s look at what is <span class="No-Break">inside them.</span></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor133"/>Working with files</h1>
			<p>Using PowerShell to <a id="_idIndexMarker465"/>read the contents of files and manipulate that data is a common task. We’re going to look at three cmdlets in this section. First, let’s explore the generic <span class="No-Break"><strong class="source-inline">Get-Content</strong></span><span class="No-Break"> cmdlet.</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor134"/>Get-Content</h2>
			<p>The <strong class="source-inline">Get-Content</strong> cmdlet can<a id="_idIndexMarker466"/> get any type of data in a file and store it as<a id="_idIndexMarker467"/> an array of strings or bytes (as a bytestream). By default, each line in the file will be interpreted as a single string. We will only get meaningful content if the file can be interpreted as an array of strings; otherwise, we must fetch it as a bytestream. This is useful if we are getting the contents of an executable file, for example. It’s got a few parameters. Here are the more <span class="No-Break">interesting ones:</span></p>
			<ul>
				<li><strong class="source-inline">-Path</strong> specifies the item we want. This accepts an array of string values so that we can concatenate multiple files into a <span class="No-Break">single array.</span></li>
				<li><strong class="source-inline">-TotalCount</strong> is the total number of lines to read from the file. The default is <strong class="source-inline">-1</strong>, which will read to the last line, but we can check just the first few lines of a file to make sure that it is as we expect it to be without loading the <span class="No-Break">whole thing.</span></li>
				<li><strong class="source-inline">-ReadCount</strong> is the number of lines that can be sent through the pipeline at <span class="No-Break">a time.</span></li>
				<li><strong class="source-inline">-AsByteStream</strong> allows us to get the content as bytes rather than <span class="No-Break">as strings.</span></li>
				<li><strong class="source-inline">-Credential</strong> allows us to supply alternative credentials to open <span class="No-Break">the file.</span></li>
				<li><strong class="source-inline">-Delimiter</strong> allows us to specify the character that is used to separate strings. By default, it is the newline character (<strong class="source-inline">`n</strong>), but we can use anything <span class="No-Break">we like.</span></li>
				<li><strong class="source-inline">-Encoding</strong> can be used to specify that the contents are encoded in a different format to the<a id="_idIndexMarker468"/> default; <strong class="bold">UTF-8 with no Byte Order </strong><span class="No-Break"><strong class="bold">Mark</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">utf8NoBOM</strong></span><span class="No-Break">).</span></li>
				<li><strong class="source-inline">-Raw</strong> will return the entire contents as a <span class="No-Break">single string.</span></li>
				<li><strong class="source-inline">-Tail</strong> is like <strong class="source-inline">-TotalCount</strong>, but works backward and gets lines from the end. We can’t use it <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">-TotalCount</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p><strong class="source-inline">Get-Content</strong> is similar in function to the <strong class="source-inline">cat</strong> command in Linux and, unsurprisingly, <strong class="source-inline">cat</strong> is an alias <span class="No-Break">for it.</span></p>
			<p><strong class="source-inline">Get-content</strong> is one of the most common ways of bringing data into PowerShell so that we can work with it, but it’s not very flexible. For instance, if we try to get a CSV file, then it will<a id="_idIndexMarker469"/> interpret <a id="_idIndexMarker470"/>the file as text, rather than a specially formatted file. Let’s have a look at how we can import information in a <span class="No-Break">structured way.</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor135"/>Import- cmdlets</h2>
			<p>Like the <strong class="source-inline">Export-</strong> cmdlets, the <strong class="source-inline">Import-</strong> cmdlets <a id="_idIndexMarker471"/>perform two operations at<a id="_idIndexMarker472"/> once. They combine <strong class="source-inline">Get-Content</strong> with a specialist parser that will interpret the information and format it correctly for the original file type, allowing us to manipulate something that looks like the original objects. Let’s look at <span class="No-Break"><strong class="source-inline">Import-Csv</strong></span><span class="No-Break"> first.</span></p>
			<h3>Import-Csv</h3>
			<p>The <strong class="source-inline">Import-Csv</strong> cmdlet <a id="_idIndexMarker473"/>only has<a id="_idIndexMarker474"/> a <span class="No-Break">few parameters:</span></p>
			<ul>
				<li><strong class="source-inline">-Delimiter</strong>: Just in case the file is using something other than a comma to <span class="No-Break">separate values</span></li>
				<li><strong class="source-inline">-Path</strong>: To identify the file to <span class="No-Break">be imported</span></li>
				<li><strong class="source-inline">-Header</strong>: To specify manual column name information if your CSV file doesn’t <span class="No-Break">have it</span></li>
				<li><strong class="source-inline">-Encoding</strong>: If your file has come from a system that didn’t output it <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">utf8NoBOM</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>The cmdlet expects the file to contain string objects and outputs <strong class="source-inline">PSCustomObjects</strong> with note properties that match the column headers in the original file. Let’s have <span class="No-Break">a play:</span></p>
			<pre class="console">
Get-Process | Export-Csv processes.csv
$procs = Import-Csv processes.csv
$procs.name</pre>			<p>This will output the name values of each object in the array. The next command will show us that we haven’t recreated process objects, we’ve created <span class="No-Break">new </span><span class="No-Break"><strong class="source-inline">PSCustomObjects</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$procs | Get-Member</pre>			<p>The following command will retrieve the second element in the array. Because there is no default view or default properties list, all properties will <span class="No-Break">be displayed:</span></p>
			<pre class="console">
$procs[1]</pre>			<p>You should see something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B17600_06_10.jpg" alt="Figure 6.10 – Importing a CSV file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Importing a CSV file</p>
			<p>Importing CSVs<a id="_idIndexMarker475"/> into <a id="_idIndexMarker476"/>PowerShell is great if you have, for instance, a list of users and you need to pipe them through a loop to get their home drive size, or you want to create a <span class="No-Break">lookup table.</span></p>
			<h3>Import-Clixml</h3>
			<p>If you have an XML file<a id="_idIndexMarker477"/> that was generated by PowerShell, then <a id="_idIndexMarker478"/>you can use the <strong class="source-inline">Import-Clixml</strong> cmdlet to recreate something that looks much more like the original objects. There aren’t many parameters to this cmdlet. Here are the most <span class="No-Break">interesting ones:</span></p>
			<ul>
				<li><strong class="source-inline">-Path</strong> specifies the file to <span class="No-Break">be imported.</span></li>
				<li><strong class="source-inline">-Skip</strong> allows us to skip a specified number of objects in <span class="No-Break">the file.</span></li>
				<li><strong class="source-inline">-First</strong> gets only a specified number of objects from the start of the file. Clixml files can be huge, so this is handy if we want to check <span class="No-Break">what’s inside.</span></li>
				<li><strong class="source-inline">-IncludeTotalCount</strong> tells us how many objects are in the file. Interestingly, it has an accuracy property that tells us how reliable the <span class="No-Break">estimate is.</span></li>
			</ul>
			<p>Let’s have a play with it. <span class="No-Break">Try this:</span></p>
			<pre class="console">
Get-Date | Export-Clixml -Path date.xml
Notepad date.xml
$date = (Import-Clixml -Path date.xml)
$date | Get-Member
$date</pre>			<p>We can see that <a id="_idIndexMarker479"/>what we get back is a date object. Let’s try <span class="No-Break">another one:</span></p>
			<pre class="console">
Get-Process | Export-Clixml processes.xml
$XmlProcs =Import-Clixml processes.xml</pre>			<p>If we then call <strong class="source-inline">$XmlProcs</strong>, we can see that the output displays exactly as we’d expect for the <span class="No-Break"><strong class="source-inline">Get-Process</strong></span><span class="No-Break"> cmdlet:</span></p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B17600_06_11.jpg" alt="Figure 6.11 – Recreating objects with Import-Clixml"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – Recreating objects with Import-Clixml</p>
			<p>However, they’re not quite the objects we exported. Let’s run <span class="No-Break">the following:</span></p>
			<pre class="console">
$XmlProcs | Get-Member</pre>			<p>We can see that they are <strong class="source-inline">Deserialized.System.Diagnostics.Process</strong> objects. This tells us that they have been turned into a data object and then retrieved from a file, and they are not <span class="No-Break">live objects.</span></p>
			<p>One of the most common uses for this is to store credentials securely. <span class="No-Break">Try this:</span></p>
			<pre class="console">
$cred = Get-Credential</pre>			<p>We’re asked to <a id="_idIndexMarker480"/>enter a username <span class="No-Break">and password.</span></p>
			<p>We can pipe the <a id="_idIndexMarker481"/>credential variable into an <span class="No-Break">XML file:</span></p>
			<pre class="console">
$cred | Export-Clixml Credential.xml</pre>			<p>That file can now be stored on a disk somewhere. It is encrypted by the <span class="No-Break"><strong class="source-inline">Export-Clixml</strong></span><span class="No-Break"> cmdlet.</span></p>
			<p>We can then import it back <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Import-Clixml</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$newcred = Import-Clixml Credential.xml</pre>			<p>We get a credential object. You can see in the following screenshot what the XML file looks like. The password is the encrypted <span class="No-Break">hex string:</span></p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B17600_06_12.jpg" alt="Figure 6.12 – Storing encrypted credentials"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – Storing encrypted credentials</p>
			<p>Note that the<a id="_idIndexMarker482"/> encryption uses our login credentials for the machine we were<a id="_idIndexMarker483"/> using when we encrypted the file. No other user can decrypt that easily and we can’t then decrypt those credentials on <span class="No-Break">another machine.</span></p>
			<p>We can’t use just import any XML file with <strong class="source-inline">Import-Clixml</strong>. If we try it with something that hasn’t been correctly formatted for the cmdlet, we’ll get an error, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B17600_06_13.jpg" alt="Figure 6.13 – We can’t import just anything"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – We can’t import just anything</p>
			<p>In this case, the schema of the XML file is incorrect for the <strong class="source-inline">Import-Clixml</strong> cmdlet; there are important lines missing, as we can see from the error message. Don’t try running this code – you may well not have the DISM file referenced in <span class="No-Break">the cmdlet.</span></p>
			<p>That’s about it<a id="_idIndexMarker484"/> for this chapter. Before we summarize, though, let’s play <a id="_idIndexMarker485"/>around and consolidate some learning from this chapter and <span class="No-Break">earlier chapters.</span></p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor136"/>Let’s have some fun – measuring the most frequent words in a text file</h1>
			<p>One of my favorite <a id="_idIndexMarker486"/>programming books is <em class="italic">Exercises in Programming Style</em> by Cristina Videira Lopes. It is inspired by the 1947 book by Raymond Queneau, <em class="italic">Exercices de Style</em>, in which the author tells the same story in 99 different styles. Lopes’s book contains 41 Python programs that accomplish the same task with different programming styles. This book is truly mind-expanding and really changed the way I saw writing code; it is as much an art as any other form of creative writing. The book itself is not cheap, but all the programs are available on GitHub: <a href="https://github.com/crista/exercises-in-programming-style">https://github.com/crista/exercises-in-programming-style</a>. I’d encourage you to have a quick look, even if you don’t know <span class="No-Break">any Python.</span></p>
			<p>The problem each program solves is to determine the frequency of the words in a text file and sort them in descending order; this is an example<a id="_idIndexMarker487"/> of a <strong class="bold">term frequency</strong> problem, and it is a fairly common exercise given to computer science students. Let’s have a go <span class="No-Break">at it:</span></p>
			<ol>
				<li>First, create a new folder in VS Code, and then create a new PowerShell file in your new folder <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">wordcountBasic.ps1</strong></span><p class="list-inset">The file I’m going to use is an English translation of Franz Kafka’s classic, <em class="italic">The Trial</em>, but any large text file will do. I downloaded it from <span class="No-Break">here: </span><a href="https://www.gutenberg.org/ebooks/7849.txt.utf-8"><span class="No-Break">https://www.gutenberg.org/ebooks/7849.txt.utf-8</span></a></p><p class="list-inset">Go ahead and download it and save it in your new folder <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">thetrial.txt</strong></span><span class="No-Break">.</span></p></li>
				<li>Now that we have our data, the next thing to do is to putt the contents of the file into a variable. That’s easy. We’ll need to get it as a single huge string, rather than an array <span class="No-Break">of strings:</span><pre class="source-code">
$TheTrial  =  Get-Content -Path .\thetrial.txt -Raw$TheTrial = get-content -path .\thetrial.txt -Raw</pre></li>				<li>Now, we can use one of the methods available for string objects to split the text into an array of <span class="No-Break">single-word strings:</span><pre class="source-code">
$TrialWords = $TheTrial.Split(" ")</pre><p class="list-inset">Notice that<a id="_idIndexMarker488"/> there’s a space inside the pair of <span class="No-Break">double quotes.</span></p></li>				<li>Let’s see how many words <span class="No-Break">we’ve got:</span><pre class="source-code">
$TrialWords.Length</pre><p class="list-inset">I get 79,978 words. This code may take a while <span class="No-Break">to run.</span></p></li>				<li>Now… the next bit is tricky. We need to count how many times each word appears in the text. This is where the power of the shell really shines. Doing the next bit in Python would require a few lines of string manipulation, but PowerShell comes with a built-in <span class="No-Break">cmdlet, </span><span class="No-Break"><strong class="source-inline">Group-Object</strong></span><span class="No-Break">:</span><pre class="source-code">
$GroupedWords = $TrialWords | Group-Object</pre></li>				<li>The trouble with that line is it will group the objects alphabetically, which is not what we want. We want them grouped by frequency, so we need a <strong class="source-inline">Sort-Object</strong> cmdlet in the pipeline <span class="No-Break">as well:</span><pre class="source-code">
$GroupedWords = $TrialWords | Group-Object | Sort-Object Count</pre></li>				<li>We also don’t want to see all the words; we just want the most frequent words. Let’s get the most frequent 10. We can use a formula of <strong class="source-inline">[-1..-10]</strong> to get them from the array. We’re using <strong class="source-inline">[-1..-10]</strong> because by default, the sort order is ascending and we want it descending. We could <span class="No-Break">run </span><span class="No-Break"><strong class="source-inline">$GroupedWords[-1..-10]</strong></span><span class="No-Break">.</span></li>
				<li>And that’s it! Here’s<a id="_idIndexMarker489"/> my whole program and <span class="No-Break">the output:</span></li>
			</ol>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/B17600_06_14.jpg" alt="Figure 6.14 – The ten most frequent words in any English book (written by a man)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – The ten most frequent words in any English book (written by a man)</p>
			<p>We’ve achieved something here, although it’s probably not what we wanted to achieve. It looks to me like the list of the 10 most frequent words in any book in English, written by a man. What can we do <span class="No-Break">about that?</span></p>
			<p>The computer science discipline of <strong class="bold">Natural Language Processing</strong> involves the concept <a id="_idIndexMarker490"/>of <strong class="bold">stop words</strong>. These<a id="_idIndexMarker491"/> are common words in a language that shouldn’t be counted when analyzing the text. There are plenty of lists of stop words available on the internet for free. What we need to do is build a loop that compares each word in the array to a list of<a id="_idIndexMarker492"/> stop words and only adds them to a new array if they are <em class="italic">not</em> in <span class="No-Break">the list.</span></p>
			<p class="callout-heading">Activity</p>
			<p class="callout">Rewrite the program using a loop to compare each word in the <strong class="source-inline">$TrialWords</strong> array to the words in a list of stop words. Use the stop words file <span class="No-Break">at </span><a href="https://raw.githubusercontent.com/stopwords-iso/stopwords-en/master/stopwords-en.txt"><span class="No-Break">https://raw.githubusercontent.com/stopwords-iso/stopwords-en/master/stopwords-en.txt</span></a><span class="No-Break">.</span></p>
			<p class="callout"><span class="No-Break">Hint 1:</span></p>
			<p class="callout">You won’t want to use a PowerShell array for this – why? It’s probably best to use an array list. Construct it <span class="No-Break">like this:</span></p>
			<p class="callout"><strong class="bold">$Words = [</strong><span class="No-Break"><strong class="bold">System.Collections.ArrayList]@()</strong></span></p>
			<p class="callout"><span class="No-Break">Hint 2:</span></p>
			<p class="callout">You will need to split the array on more characters than just a space because of words that have full stops and other punctuation immediately after them. For some characters, you’ll need to use an escape character – the backtick (<strong class="source-inline">`</strong>) – for them to be interpreted properly. I found replacing the second line in the preceding code with this line to <span class="No-Break">be effective:</span></p>
			<p class="callout"><strong class="bold">$TestWords = $TheTrial.Split(“ “, “`t”, “`n”, “,”,”`””,”.”, [</strong><span class="No-Break"><strong class="bold">System.StringSplitOptions]::RemoveEmptyEntries)</strong></span></p>
			<p class="callout"><strong class="source-inline">RemoveEmptyEntries</strong> prevents null strings from <span class="No-Break">being counted.</span></p>
			<p class="callout"><strong class="source-inline">'t</strong> is the <span class="No-Break">tab character.</span></p>
			<p class="callout"><strong class="source-inline">`n</strong> is the <span class="No-Break">newline character.</span></p>
			<p class="callout"><strong class="source-inline">`"</strong> allows us to use a double quote mark as <span class="No-Break">a delimiter.</span></p>
			<p class="callout"><span class="No-Break">Hint 3:</span></p>
			<p class="callout">Is <strong class="source-inline">That</strong> the same word as <strong class="source-inline">that</strong>? You will want to make sure that all the characters in your words are in the <span class="No-Break">same case.</span></p>
			<p>Have fun! I’ve<a id="_idIndexMarker493"/> written one way to do it at <span class="No-Break">the end.</span></p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor137"/>Summary</h1>
			<p>This is quite a long chapter and it is really only an introduction. We will cover more ways of ingesting data with PowerShell as we go through the book. We’ve come a long <span class="No-Break">way, though.</span></p>
			<p>We started out by looking at how we can format output for the screen using three common formatting cmdlets: <strong class="source-inline">Format-List</strong>, <strong class="source-inline">Format-Table</strong>, and <strong class="source-inline">Format-Wide</strong>. We then looked at how we could output that formatted data to a text file with <strong class="source-inline">Out-File</strong>. We took some time to understand the limitations of this approach before we explored two families of cmdlets: <strong class="source-inline">ConvertTo-</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Export-</strong></span><span class="No-Break">.</span></p>
			<p>We took quite a deep look at the cmdlets for handling CSV files, <strong class="source-inline">ConvertTo-Csv</strong> and <strong class="source-inline">Export-Csv</strong>, and understood how the <strong class="source-inline">ExportTo-Csv</strong> cmdlet combines the <strong class="source-inline">ConvertTo-Csv</strong> and <strong class="source-inline">Out-File</strong> cmdlets. We then looked at <strong class="source-inline">ConvertTo-Xml</strong> and <strong class="source-inline">Export-Clixml</strong>. Finally, we looked at <strong class="source-inline">ConvertTo-Html</strong> and experimented with how we can use it to produce interestingly formatted documents by referencing a <span class="No-Break">CSS file.</span></p>
			<p>We then briefly discussed <strong class="source-inline">PSProviders</strong> and <strong class="source-inline">PSdrives</strong> and understood that these are more useful in a Windows environment, but are still relevant for Linux <span class="No-Break">and macOS.</span></p>
			<p>We looked at <strong class="source-inline">Get-Content</strong>, the most common way of bringing data into PowerShell, and learned that it produces either an array of strings or bytes – to import data in a more structured way, we would need to use something else: the <strong class="source-inline">Import-</strong> cmdlets. We looked at <strong class="source-inline">Import-Csv</strong> and <strong class="source-inline">Import-Clixml</strong> and saw how they can be used to construct PowerShell objects from <span class="No-Break">structured data.</span></p>
			<p>Finally, we did some programming and looked at how we can analyze text files <span class="No-Break">using PowerShell.</span></p>
			<p>In the next chapter, we will be looking at how we can use PowerShell to interact with systems on the internet and the common file formats we <span class="No-Break">will need.</span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor138"/>Exercises</h1>
			<ol>
				<li>How would you produce a wide list of the names of all the files in your temp directory, with <span class="No-Break">three columns?</span></li>
				<li>What will happen if we run <span class="No-Break">this code?</span><pre class="source-code">
<strong class="bold">Get-Process | Format-Wide -column 5 | Where-Object id -gt 100</strong></pre></li>				<li>Using PowerShell, write an <strong class="source-inline">"I love PowerShell"</strong> string to a new file in the directory you are <span class="No-Break">working in.</span></li>
				<li>Add a “<strong class="source-inline">Sooo much"</strong> string to the file from <span class="No-Break"><em class="italic">question 3</em></span><span class="No-Break">.</span></li>
				<li>Write a statement to create a file containing all the items in your working directory to a CSV file, but separated with semicolons rather <span class="No-Break">than commas.</span></li>
				<li>How many functions are defined in your <span class="No-Break">PowerShell session?</span></li>
				<li>How would you import the text file from <em class="italic">question 4</em> using a space as a <span class="No-Break">string separator?</span></li>
				<li>How would you import the file you created in <em class="italic">question 5</em> and what sort of objects would <span class="No-Break">you get?</span></li>
				<li>What does the following error <span class="No-Break">tell us?</span><pre class="source-code">
<strong class="bold">Import-Clixml: Element 'Objs' with namespace name 'http://schemas.microsoft.com/powershell/2004/04' was not found.</strong></pre></li>			</ol>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor139"/>Further reading</h1>
			<p>We really should read all the help files for the cmdlets we’ve used in this chapter. We know how to find them, so we’re not going to list <span class="No-Break">them here.</span></p>
			<ul>
				<li>To learn about HTML and CSS, go to the W3Schools <span class="No-Break">website: </span><a href="https://www.w3schools.com/"><span class="No-Break">https://www.w3schools.com/</span></a></li>
				<li>To learn more about Serialization, have a look <span class="No-Break">here: </span><a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/introducing-xml-serialization"><span class="No-Break">https://docs.microsoft.com/en-us/dotnet/standard/serialization/introducing-xml-serialization</span></a></li>
			</ul>
		</div>
	</body></html>