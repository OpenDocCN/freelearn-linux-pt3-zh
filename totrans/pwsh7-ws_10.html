<html><head></head><body>
		<div id="_idContainer197">
			<h1 id="_idParaDest-197" class="chapter-number"><a id="_idTextAnchor201"/>10</h1>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor202"/>Error Handling – Oh No! It’s Gone Wrong!</h1>
			<p>There are, broadly, two types of problems that we encounter when using PowerShell: problems that our code encounters and problems with our code. The first type may be as simple as a <strong class="source-inline">FileNotFound</strong> message in response to <strong class="source-inline">Get-ChildItem</strong>. The second type can be much harder to understand, as it may involve problems related to scope, which we saw in <a href="B17600_09.xhtml#_idTextAnchor184"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Don’t Repeat Yourself – Functions and Scriptblocks</em>, or an unexpected divide by zero error. We’ll deal with problems that our code encounters in the first half of this chapter, and then move on to problems we may find in our code in the <span class="No-Break">second half.</span></p>
			<p>We’ll start by defining what an error is and look at the two types of errors our code will encounter: terminating and non-terminating errors. We will explore how PowerShell deals with both types, how we can change that behavior, and why we might want to. We will then move on to how we can catch errors so that we can understand them and code <span class="No-Break">around them.</span></p>
			<p>In the second half of the chapter, we will look at how we can identify the causes of errors in our code through the process of debugging and look at some of the options available in VS Code to make the <span class="No-Break">process easier.</span></p>
			<p>These are the main topics we will cover in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>What is <span class="No-Break">an error?</span></li>
				<li>Understanding <span class="No-Break">error actions</span></li>
				<li><span class="No-Break">Catching errors</span></li>
				<li><span class="No-Break">Exploring debugging</span></li>
				<li>Debugging with <span class="No-Break">VS Code</span></li>
			</ul>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor203"/>What is an error?</h1>
			<p>As we’ve seen repeatedly, PowerShell, as with most<a id="_idIndexMarker736"/> languages, has its own terminology and definitions for common words. <strong class="bold">Error</strong> is no exception (except… sometimes it is, as we’ll see. That is an extremely funny joke. You’ll laugh later, I promise.). An error in PowerShell is, broadly, anything that might produce red text in the console. Let’s look at an example. In the console, type <span class="No-Break">the following:</span></p>
			<pre class="console">
Get-ChildItem -Name nosuchfile</pre>			<p>We will see a red message saying <strong class="source-inline">Get-ChildItem: cannot find path because it does </strong><span class="No-Break"><strong class="source-inline">not exist</strong></span><span class="No-Break">.</span></p>
			<p>PowerShell is an extremely friendly and helpful language. It will always try to recover from an error and continue with what it was asked to do. In the preceding instance, it was asked to do one thing, couldn’t do it, and delivered a helpful error message written in plain language describing why it was unable to do the thing we <span class="No-Break">asked for.</span></p>
			<p>There is a lot of work going on in the background here. The previous error we see is not just a text string; it is part of a complex error object that was generated when PowerShell couldn’t find the file. There is a lot more information available to understand what happened and help us get <span class="No-Break">it working.</span></p>
			<p>The amount of information we see is determined by an automatic variable called <strong class="source-inline">$ErrorView</strong>. By default, in PowerShell 7, this variable is set to <strong class="source-inline">ConciseView</strong>, and PowerShell displays a short friendly message. When we’re researching on the internet, we’ll see that PowerShell can display a lot more information by setting the <strong class="source-inline">$ErrorView</strong> variable to the <strong class="source-inline">NormalView</strong> value, as we can see in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer182" class="IMG---Figure">
					<img src="image/B17600_10_001.jpg" alt="Figure 10.1 – Changing the $ErrorView variable"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Changing the $ErrorView variable</p>
			<p>In the first example, <em class="italic">box 1</em>, <strong class="source-inline">$ErrorView</strong> was set to the default, <strong class="source-inline">ConciseView</strong>, and we only saw a friendly message. In the second example, <em class="italic">box 2</em>, we’ve changed the value of <strong class="source-inline">$errorView</strong> to <strong class="source-inline">NormalView</strong>, and we get additional information telling us where the error occurred (<strong class="source-inline">line:1</strong> and <strong class="source-inline">char:1</strong>) and what category of error it was (<strong class="source-inline">ObjectNotFound</strong>). <strong class="source-inline">ConciseView</strong> was introduced in PowerShell 7; Windows PowerShell continues to use <strong class="source-inline">NormalView</strong> as <span class="No-Break">the default.</span></p>
			<p>For the rest of this chapter, let’s set our <strong class="source-inline">$ErrorView</strong> variable to <strong class="source-inline">NormalView</strong> by typing <span class="No-Break">the following:</span></p>
			<pre class="console">
 $ErrorView = "NormalView"</pre>			<p><strong class="source-inline">NormalView</strong> still isn’t the whole story, though. To see the entire error object that was generated, <span class="No-Break">type this:</span></p>
			<pre class="console">
Get-Error</pre>			<p>And we should see something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer183" class="IMG---Figure">
					<img src="image/B17600_10_002.jpg" alt="Figure 10.2 – The error object"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – The error object</p>
			<p><strong class="source-inline">Get-Error</strong> is a PowerShell 7 cmdlet<a id="_idIndexMarker737"/> that allows us to access errors stored in the <strong class="source-inline">$Error</strong> variable; we won’t find this cmdlet in Windows PowerShell. Each error we encounter in a session is written to this variable. It consists of an array of error objects, up to a maximum set by the <strong class="source-inline">$MaximumErrorCount</strong> automatic variable. By default, this is 256 in PowerShell 7 – hopefully, that’ll be enough. We can use <strong class="source-inline">Get-Error</strong> with the <strong class="source-inline">-Newest</strong> parameter followed by an integer to get a specified number of errors, starting with the most recent. We can also access individual array members using the standard syntax, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
$Error[0]</pre>			<p>This will get the most recent error – this is how we have to do it in <span class="No-Break">Windows PowerShell.</span></p>
			<p>Not every error<a id="_idIndexMarker738"/> we encounter will have a friendly message associated with it. Sometimes we will just see the error code, which is highlighted in the box indicated in the previous screenshot. This code is usually either 10 decimal digits, as in the screenshot, starting with <strong class="source-inline">-2</strong>, or it may be hexadecimal, in which case it will start with <strong class="source-inline">0x</strong>, followed by 8 characters. This frequently happens with <span class="No-Break">networking errors.</span></p>
			<p>The code is quite cryptic, but luckily there is a tool we can use to decipher it, called <strong class="source-inline">err.exe</strong>. It is available as a free download on the Microsoft website; just do a search for <strong class="source-inline">err.exe</strong>. Once it is downloaded, we don’t need to install it; we can just run it as it is from the PowerShell console or from Command Prompt, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer184" class="IMG---Figure">
					<img src="image/B17600_10_003.jpg" alt="Figure 10.3 – Running err.exe"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Running err.exe</p>
			<p>As we can see, the output is only slightly less cryptic, and can be highly context-specific; in this case, if I received the code <strong class="source-inline">0x80010002</strong>, as seen in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.3</em>, while I was trying to open a file over a network, I would interpret that <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">ERROR_FILE_NOT_FOUND</strong></span><span class="No-Break">.</span></p>
			<p>Now we have a better understanding<a id="_idIndexMarker739"/> of what an error is, let’s look at the two types of errors we will encounter with PowerShell: terminating <span class="No-Break">and non-terminating.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor204"/>Terminating and non-terminating exceptions and errors</h2>
			<p>Programming languages have the concept of an <strong class="bold">exception</strong>: an anomalous condition requiring special<a id="_idIndexMarker740"/> handling. In general, when a piece of code encounters an exception, it stops<a id="_idIndexMarker741"/> what it is doing and switches to executing its exception handler: a function<a id="_idIndexMarker742"/> or subroutine<a id="_idIndexMarker743"/> that records what has <a id="_idIndexMarker744"/>gone wrong. For most languages, an error is an exception, and an exception results in <span class="No-Break">an error.</span></p>
			<p>PowerShell is unusual in that an error isn’t always an exception (although an exception is always an error). PowerShell will attempt to recover from errors; it will try to continue what it was doing rather than stop dead. It recognizes two types of error: terminating and non-terminating. Terminating errors are the same as exceptions. PowerShell will output the error and stop what it was doing. Non-terminating errors mean PowerShell will record the error and then carry on if possible (unless we tell <span class="No-Break">it otherwise).</span></p>
			<p class="callout-heading">PowerShell exceptions versus .NET exceptions</p>
			<p class="callout">So, this can be confusing, and much<a id="_idIndexMarker745"/> of the information available<a id="_idIndexMarker746"/> on this is more so (at least, it confuses me). For instance, Don Jones, in <em class="italic">Learn Windows PowerShell in a Month of Lunches</em>, explains it as I have here: non-terminating errors are not exceptions. However, Bruce Payette, in <em class="italic">Windows PowerShell in Action</em>, says that every PowerShell error is an exception, both terminating and non-terminating. Both authors (and their books) are brilliant. I’d hate to say one is right and the other wrong; luckily, I don’t have to. A careful reading of pages 532, 543, and 546 of <em class="italic">Windows PowerShell in Action</em> suggests <span class="No-Break">the following.</span></p>
			<p class="callout">Every time PowerShell records an error, there is an underlying .NET exception. Remember, though, that PowerShell sits on top of .NET, and for a .NET exception to be an exception for PowerShell, then it would have to stop PowerShell and start an exception handler function. Non-terminating errors do not stop PowerShell, and the exception handling functions aren’t run, so they’re not exceptions for PowerShell, even though they are exceptions for .NET. Clear <span class="No-Break">as mud.</span></p>
			<p>Let’s illustrate. In the previous section, we looked at the error we received when we tried to get information about a non-existent file, by running <strong class="source-inline">Get-ChildItem -Name nosuchfile</strong>. Let’s try it again, as part of a pipeline. In my <strong class="source-inline">ch10</strong> directory, I have two files: <strong class="source-inline">foo.txt</strong> and <strong class="source-inline">bar.txt</strong>. Let’s see what happens when I run <span class="No-Break">the following:</span></p>
			<pre class="console">
"foo.txt", "nosuchfile", "bar.txt" | Get-ChildItem</pre>			<p>We can see the results in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer185" class="IMG---Figure">
					<img src="image/B17600_10_004.jpg" alt="Figure 10.4 – A non-terminating error"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – A non-terminating error</p>
			<p>As we can see, PowerShell<a id="_idIndexMarker747"/> gets the details for the first item, <strong class="source-inline">foo.txt</strong>, reports<a id="_idIndexMarker748"/> an error for the second item, <strong class="source-inline">nosuchfile</strong>, and then continues to get information for the third item, <strong class="source-inline">bar.txt</strong>. This is an example of a <span class="No-Break">non-terminating error.</span></p>
			<p>So, what is a terminating error? This is an error <a id="_idIndexMarker749"/>that stops PowerShell altogether – an error that will stop a script or pipeline <a id="_idIndexMarker750"/>from running. A good example is a misspelled cmdlet, such <span class="No-Break">as this:</span></p>
			<div>
				<div id="_idContainer186" class="IMG---Figure">
					<img src="image/B17600_10_005.jpg" alt="Figure 10.5 – A terminating error"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – A terminating error</p>
			<p>Here, I’ve used a non-existent cmdlet, <strong class="source-inline">Get-ChildItems</strong> (remember – PowerShell cmdlets are always singular, never plural), and PowerShell has stopped dead in its tracks on the first attempt to run the cmdlet. If this were a non-terminating error, I would expect to see the error appear three times, once for each filename in the pipeline. Instead, we see it once because the pipeline has <span class="No-Break">terminated altogether.</span></p>
			<p>It’s great that PowerShell distinguishes<a id="_idIndexMarker751"/> between terminating and non-terminating errors; it’s extremely<a id="_idIndexMarker752"/> useful in the console environment, but<a id="_idIndexMarker753"/> when we’re running scripts, we’re unlikely to always be around<a id="_idIndexMarker754"/> to see the error flash up on the screen and then disappear. When we’re writing scripts, we are going to want to turn our non-terminating errors into terminating ones and turn all our errors into exceptions. This is so that we can set an exception handler that will do things such as log errors to a file. Before we look at how we can handle terminating errors, let’s look at how we can turn all our errors <span class="No-Break">into exceptions.</span></p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor205"/>Understanding error actions</h1>
			<p>There are two easy ways<a id="_idIndexMarker755"/> to change the way that PowerShell processes errors: <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">$ErrorAction</strong></span><strong class="source-inline">
Preference</strong> variable and the <strong class="source-inline">-ErrorAction</strong> parameter. Let’s look at the <span class="No-Break">variable first.</span></p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor206"/>The $ErrorActionPreference variable</h2>
			<p>The <strong class="source-inline">$ErrorActionPreference</strong> automatic variable can be used to alter how PowerShell processes<a id="_idIndexMarker756"/> errors. By default, it is set to <strong class="source-inline">Continue</strong>, which means<a id="_idIndexMarker757"/> it displays any error and carries on. These are the more important valid settings for <span class="No-Break">the variable:</span></p>
			<ul>
				<li><strong class="source-inline">Break</strong>: This causes PowerShell to enter debug mode when an error occurs. More on debug mode in the second half of <span class="No-Break">this chapter.</span></li>
				<li><strong class="source-inline">Continue</strong> (default): This displays the error message and <span class="No-Break">continues processing.</span></li>
				<li><strong class="source-inline">Inquire</strong>: This displays the error message and asks for permission to continue <span class="No-Break">or stop.</span></li>
				<li><strong class="source-inline">SilentlyContinue</strong>: The error message is not displayed but is added to the <strong class="source-inline">$Error</strong> variable. PowerShell <span class="No-Break">continues processing.</span></li>
				<li><strong class="source-inline">Stop</strong>: This displays the error message and stops processing. This generates <span class="No-Break">an </span><span class="No-Break"><strong class="source-inline">Action</strong></span><strong class="source-inline">
</strong><span class="No-Break"><strong class="source-inline">PreferenceStopException</strong></span><span class="No-Break"> exception.</span></li>
			</ul>
			<p>Note that the help document for preference variables (<strong class="source-inline">about_Preference_Variables</strong>) states that the variable is only effective for non-terminating errors; this is not the case. Changing the variable affects both terminating and non-terminating errors, although after a terminating error, <strong class="source-inline">Continue</strong> and <strong class="source-inline">SilentlyContinue</strong> will not force the cmdlet or script to continue; it’s still a <span class="No-Break">terminating error.</span></p>
			<p>The <strong class="source-inline">$ErrorActionPreference</strong> variable is scoped, as we would expect. So, while the value for the session may be <strong class="source-inline">Continue</strong>, we can set it differently inside our scripts. What we must not do, though, is write <strong class="source-inline">$ErrorActionPreference = 'SilentlyContinue'</strong> at the top of the script, no matter how tempting it is, or how many times we see people do it on the internet. This suppresses all errors in our script and makes it incredibly difficult to troubleshoot when things go wrong, as well as making Don Jones (the Don of PowerShell) sad. Instead, if there is a cmdlet in our script that we know is going to create<a id="_idIndexMarker758"/> a lot of non-terminating<a id="_idIndexMarker759"/> errors – for instance, a function that tests for active machines using <strong class="source-inline">Test-NetConnection</strong> – we can use the <strong class="source-inline">-ErrorAction</strong> <span class="No-Break">common parameter.</span></p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor207"/>The -ErrorAction parameter</h2>
			<p>The <strong class="source-inline">-ErrorAction</strong> parameter is part of the common parameters<a id="_idIndexMarker760"/> available to all cmdlets<a id="_idIndexMarker761"/> and advanced functions. Note this will only change the actions for non-terminating errors. In the following screenshot, I have set <strong class="source-inline">$ErrorActionPreference</strong> to <strong class="source-inline">Inquire</strong>, by typing <strong class="source-inline">$ErrorActionPreference = Inquire</strong>, and I’m then using the <strong class="source-inline">-ErrorAction</strong> parameter to try to change <span class="No-Break">the behavior:</span></p>
			<div>
				<div id="_idContainer187" class="IMG---Figure">
					<img src="image/B17600_10_006.jpg" alt="Figure 10.6 – The -ErrorAction parameter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – The -ErrorAction parameter</p>
			<p>In the first cmdlet, we’re generating a non-terminating error, and the error action <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Silently</strong></span><strong class="source-inline">
Continue</strong>. As we can see, there is no output; the default value of <strong class="source-inline">Continue</strong> would display the error in red. In the second cmdlet, we’re generating a terminating error by getting the cmdlet name wrong, and the <strong class="source-inline">-ErrorAction</strong> parameter is ignored; we get a prompt <span class="No-Break">for action.</span></p>
			<p>The <strong class="source-inline">-ErrorAction</strong> parameter has the same values as the <strong class="source-inline">$ErrorPreference</strong> variable. Let’s look at the <strong class="source-inline">Ignore</strong> value. This suppresses the error message, as with <strong class="source-inline">SilentlyContinue</strong>. Unlike <strong class="source-inline">SilentlyContinue</strong>, the error is not written<a id="_idIndexMarker762"/> to the <strong class="source-inline">$Error</strong> variable; it is <span class="No-Break">completely</span><span class="No-Break"><a id="_idIndexMarker763"/></span><span class="No-Break"> ignored.</span></p>
			<p class="callout-heading">Activity 1</p>
			<p class="callout">What is going to happen if we run the <span class="No-Break">following cmdlets?</span></p>
			<p class="callout"><strong class="bold">$ErrorActionPreference = “</strong><span class="No-Break"><strong class="bold">SilentlyContinue”</strong></span></p>
			<p class="callout"><strong class="bold">“foo.txt”, “nosuchfile”, “bar.txt” | Get-ChildItem -</strong><span class="No-Break"><strong class="bold">ErrorAction “Stop”</strong></span></p>
			<p>Now we know how to make all our errors terminating errors, let’s look at why we might want to <span class="No-Break">do that.</span></p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor208"/>Catching errors</h1>
			<p>As we’ve discovered, errors<a id="_idIndexMarker764"/> contain lots of useful information we can use to make our code run smoothly. While <strong class="source-inline">Get-Error</strong> and the <strong class="source-inline">$Error</strong> variable are useful for real-time troubleshooting, we need to have another way to deal with errors when we are<a id="_idIndexMarker765"/> <span class="No-Break">writing scripts.</span></p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor209"/>Try/Catch/Finally</h2>
			<p>The best way to handle terminating<a id="_idIndexMarker766"/> errors in PowerShell is with a <strong class="source-inline">Try</strong>/<strong class="source-inline">Catch</strong>/<strong class="source-inline">Finally</strong> statement. This statement allows us to set up alternate courses<a id="_idIndexMarker767"/> of action, depending on whether or not an error occurred. The statement consists of a mandatory <strong class="source-inline">Try</strong> block, which contains code that might generate an error, and then either a <strong class="source-inline">Catch</strong> block, a <strong class="source-inline">Finally</strong> block, or both. The <strong class="source-inline">Catch</strong> block will run if the code in the <strong class="source-inline">Try</strong> block generates a terminating error; this is our exception handler. The code in the <strong class="source-inline">Finally</strong> block will run regardless of whether an error is generated or not; this block is used for any code that may be required to clean up after the code in the <strong class="source-inline">Try</strong> block. We don’t see many instances of the <strong class="source-inline">Finally</strong> block – I never use it. We can write multiple <strong class="source-inline">Catch</strong> blocks to handle <span class="No-Break">different errors.</span></p>
			<p>Let’s try an example. In a new file in VS Code, <span class="No-Break">type this:</span></p>
			<pre class="source-code">
function Get-Files {
    PROCESS {
        try {
                $filename = $_
                Get-ChildItem -Path "$_" -ErrorAction "Stop"
        }
        catch {
            write-output "error! file not found: $filename"
        }
    }
}
'foo.txt', 'nosuchfile', 'bar.txt' | Get-Files</pre>			<p>So, here, we’re creating a function called <strong class="source-inline">Get-Files</strong>. We’re starting with a <strong class="source-inline">PROCESS</strong> block so that we can feed it input from the pipeline. We open a <strong class="source-inline">Try</strong> block on the third line and include the operating code for the function. Next, we create a variable called <strong class="source-inline">$filename</strong> and store the current contents of the pipeline in it; we might need that for the <span class="No-Break"><strong class="source-inline">Catch</strong></span><span class="No-Break"> block.</span></p>
			<p class="callout-heading">Activity 2</p>
			<p class="callout">Why can’t we just use the pipeline variable for the <strong class="source-inline">Catch</strong> block? Why do we need to store the current pipeline variable in a <span class="No-Break">different variable?</span></p>
			<p>Then, we write the cmdlet<a id="_idIndexMarker768"/> that actually does the processing: <strong class="source-inline">Get-ChildItem</strong>. We add <strong class="source-inline">-ErrorAction "Stop"</strong> to ensure that all errors are terminating<a id="_idIndexMarker769"/> errors; remember that the <strong class="source-inline">Catch</strong> block will only execute for <span class="No-Break">an exception.</span></p>
			<p>Next, we write the <strong class="source-inline">Catch</strong> block itself. We use this block to contain code we want to execute if a terminating error is caught; in this case, we just want an onscreen error message and the current string, which we wrote <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">$filename</strong></span><span class="No-Break">.</span></p>
			<p>Finally, on the last line, we put our three strings in the pipeline and feed them to <span class="No-Break">our function.</span></p>
			<p>This is how it all looks when we <span class="No-Break">run it:</span></p>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="image/B17600_10_007.jpg" alt="Figure 10.7 – Using Try/Catch"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Using Try/Catch</p>
			<p>As we can see in the preceding<a id="_idIndexMarker770"/> terminal, <strong class="source-inline">foo.txt</strong> and <strong class="source-inline">bar.txt</strong> are processed, but because <strong class="source-inline">nosuchfile</strong> can’t be found, the <strong class="source-inline">Catch</strong> block action<a id="_idIndexMarker771"/> is triggered – in this case, writing an error string to the screen with <span class="No-Break">the filename.</span></p>
			<p>Writing multiple <strong class="source-inline">Catch</strong> blocks is relatively easy, but we need to know what sort of errors we can expect; specifically, we need to know the full .NET name, including the namespace. We can see from <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.4</em> that the .NET exception name when we can’t find a file is <strong class="source-inline">ItemNotFoundException</strong>, but we also need the namespace; in this case, it’s <strong class="source-inline">System.Management.Automation</strong>. If we don’t know what the namespace for an error is, then this one is always worth a try before hunting around on <span class="No-Break">the internet.</span></p>
			<p>We put the error type in square brackets between <strong class="source-inline">Catch</strong> and the opening brace (<strong class="source-inline">{</strong>), as in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="image/B17600_10_008.jpg" alt="Figure 10.8 – Multiple catch blocks"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Multiple catch blocks</p>
			<p>Our first <strong class="source-inline">Catch</strong> block starts on <em class="italic">line 7</em> and will only trigger if an error of the <strong class="source-inline">System.Management.Automation.ItemNotFoundException</strong> type is thrown. All other errors will trigger the second <strong class="source-inline">Catch</strong> block. Try it; change the cmdlet to <strong class="source-inline">Get-ChildItems</strong> to trigger a <strong class="source-inline">CommandNotFound</strong> error. We should see <strong class="source-inline">an unspecified error. boo.</strong> written <span class="No-Break">three times.</span></p>
			<p>So, what can we do with <strong class="source-inline">Try</strong>/<strong class="source-inline">Catch</strong>? Well, instead of writing to the screen, we can combine it with the logging function we wrote in the last chapter and use the <strong class="source-inline">Catch</strong> block to write the error message to the <span class="No-Break">log file.</span></p>
			<p>We may see on the internet<a id="_idIndexMarker772"/> references to the <strong class="source-inline">Trap</strong> statement. This goes back<a id="_idIndexMarker773"/> all the way to PowerShell v1. It’s really fiddly to use and has issues with scope, and the advice is that we should use the newer <strong class="source-inline">Try</strong>/<strong class="source-inline">Catch</strong> statement instead. As with the <strong class="source-inline">Finally</strong> block, I never use the <span class="No-Break"><strong class="source-inline">Trap</strong></span><span class="No-Break"> statement.</span></p>
			<p>This almost wraps it up for errors that we might experience running our script; just one last scenario to consider. What about things that aren’t errors, but stop our script <span class="No-Break">from running?</span></p>
			<p>Consider <span class="No-Break">this code:</span></p>
			<pre class="console">
Get-ChildItem -path *.csv</pre>			<p>What happens if there are no <strong class="source-inline">.csv</strong> files in the directory? PowerShell won’t display an error; it won’t display anything<a id="_idIndexMarker774"/> at all. We might see this as an error<a id="_idIndexMarker775"/> for our script, though. Let’s look at how we can turn this into a <span class="No-Break">terminating error.</span></p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor210"/>Creating errors</h2>
			<p>A <strong class="source-inline">Throw</strong> statement is used to create<a id="_idIndexMarker776"/> a terminating error in a script so that the script stops at that point and an exception can be recorded – for instance, written to a log. Let’s look at an example. Try this in <span class="No-Break">VS Code:</span></p>
			<pre class="source-code">
try {
    $files = (Get-ChildItem -Path *.csv)
    if (!($files)) {
        Throw "There are no CSV files here!"
    }
    else {
        #do something with the files
    }
}
catch {
    Write-Output $_.tostring()
}</pre>			<p>This is a pair of <strong class="source-inline">Try</strong>/<strong class="source-inline">Catch</strong> blocks. In the <strong class="source-inline">Try</strong> block, we’re creating a variable, <strong class="source-inline">$files</strong>, that contains the results of <strong class="source-inline">Get-ChildItem -Path *.csv</strong>: all the <strong class="source-inline">.csv</strong> files in the <span class="No-Break">current directory.</span></p>
			<p>Next, we’re running an <strong class="source-inline">if</strong> statement with a condition of <strong class="source-inline">!($files)</strong> – that is, if <strong class="source-inline">$files</strong> is <strong class="source-inline">$null</strong>, then carry out the <strong class="source-inline">Throw</strong> statement, which throws a <strong class="source-inline">There are no CSV files here!</strong> message. This message is wrapped into an error object that is passed to the <strong class="source-inline">Catch</strong> block. We can then display just the message by using <strong class="source-inline">Write-Output $_.tostring()</strong>, just as with a real error. Let’s see how <span class="No-Break">it looks:</span></p>
			<div>
				<div id="_idContainer190" class="IMG---Figure">
					<img src="image/B17600_10_009.jpg" alt="Figure 10.9 – Throwing our own error"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Throwing our own error</p>
			<p>As we can see in the red box, the <strong class="source-inline">Throw</strong> statement has produced an error that we can handle in exactly the same way as any other terminating error. How we can write a non-terminating error is something<a id="_idIndexMarker777"/> for the next section of this <span class="No-Break">chapter: debugging.</span></p>
			<p>That’s enough about how we handle errors. In the next section, we’ll take a look at debugging <span class="No-Break">our code.</span></p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor211"/>Exploring debugging</h1>
			<p>My code has bugs in it. Your code<a id="_idIndexMarker778"/> has bugs in it. We’re not bad coders; all code has bugs – we just haven’t found them all yet. According to Coverity (a code-quality scanning company), quality-controlled professionally written software has around 1 defect (or bug) per 1,000 lines of code. Some of these bugs are never found because the particular set of rare circumstances where the code doesn’t behave<a id="_idIndexMarker779"/> as expected (an edge case, in the jargon) <span class="No-Break">hasn’t occurred.</span></p>
			<p>Bugs largely consist of <span class="No-Break">two types:</span></p>
			<ul>
				<li>Syntax errors, where we’ve misspelled a cmdlet<a id="_idIndexMarker780"/> or parameter name<a id="_idIndexMarker781"/> or missed out a closing bracket or quotation mark. Syntax errors are basically typing errors – just sometimes we’ve typed the wrong thing thinking it’s the right thing. We’ve seen already how using VS Code can help us enormously with this, by color coding, syntax checking, code hints, and <span class="No-Break">tab autocomplete.</span></li>
				<li>Logic errors, where our understanding of how PowerShell <a id="_idIndexMarker782"/>works is insufficient. For instance, the problems we might run into with scope<a id="_idIndexMarker783"/> would fall into this category. Arguably, many of the errors we have already encountered might do as well; a check to see whether a file exists before trying to use it would prevent an unexpected error from being thrown at all, as we’ve just seen when we discussed the <span class="No-Break"><strong class="source-inline">Throw</strong></span><span class="No-Break"> statement.</span></li>
			</ul>
			<p>In this section, we are going to have a whistlestop tour through the various features of PowerShell 7 that can help us find and understand the bugs in our code. Before we get into the fun stuff, though, we should remind ourselves of the cardinal rules <span class="No-Break">of troubleshooting:</span></p>
			<ul>
				<li><strong class="bold">Read the error message</strong>: For example, if the error message is <strong class="source-inline">FileNotFound</strong>, don’t start troubleshooting the network connection until we’ve gone and confirmed<a id="_idIndexMarker784"/> with our own eyes that the file is actually where we think <span class="No-Break">it is.</span></li>
				<li><strong class="bold">Read the help file</strong>: Have we got the names of the parameters correct? Does the cmdlet do what we think <span class="No-Break">it does?</span></li>
				<li><strong class="bold">Understand how expectation and reality differ</strong>: We need to read the script that we are troubleshooting and understand exactly what we expect it to do and what it is actually doing. An example – I have recently been working with a customer who was having trouble putting his servers into a quiescent state so that he could perform maintenance on them. He believed the script he was using would do that for him, but when we examined it, it did something slightly different. There was nothing wrong <a id="_idIndexMarker785"/>with the script; it was his expectation that <span class="No-Break">needed adjusting.</span></li>
			</ul>
			<p>That said, let’s look at how we can provide some <span class="No-Break">script instrumentation.</span></p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor212"/>Script instrumentation</h2>
			<p>Script instrumentation<a id="_idIndexMarker786"/> refers to pieces of code embedded within our scripts to give<a id="_idIndexMarker787"/> us information about what a script is doing and how well it is doing it. It can mean the progress bars we see when loading modules, messages to say how many times a loop has completed, how many objects were found, or simply how long a portion of the script took to run. In this section, we’re going to look at how we can use some of the <strong class="source-inline">write-*</strong> cmdlets to provide us with troubleshooting information. In <a href="B17600_08.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Writing Our First Script – Turning Simple Cmdlets into Reusable Code</em>, we looked in some detail at the <strong class="source-inline">Write-Verbose</strong> cmdlet, and in <a href="B17600_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">The PowerShell Pipeline – How to String Cmdlets Together</em>, we looked at standard streams and the <strong class="source-inline">Write-*</strong> cmdlets associated with each stream. Let’s remind ourselves of <span class="No-Break">them here:</span></p>
			<table id="table001-5" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Stream #</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Cmdlet</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Common Parameters</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p>1</p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Success</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">Write-Output</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>None – this is the <span class="No-Break">default output</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p>2</p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Error</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">Write-Error</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><strong class="source-inline">-ErrorAction</strong> and                      <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">ErrorVariable</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p>3</p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Warning</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">Write-Warning</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><strong class="source-inline">-WarningAction</strong> and                 <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">WarningPreference</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p>4</p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Verbose</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">Write-Verbose</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Verbose</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p>5</p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Debug</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">Write-Debug</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Debug</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p>6</p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">Information</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">Write-Information</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><strong class="source-inline">-InformationAction</strong> and <strong class="source-inline">  -</strong><span class="No-Break"><strong class="source-inline">InformationVariable</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.1 – PowerShell streams</p>
			<p>These streams are intended for different communities; <strong class="source-inline">Write-Output</strong>, <strong class="source-inline">Write-Warning</strong>, <strong class="source-inline">Write-Error</strong>, and <strong class="source-inline">Write-Verbose</strong> are intended<a id="_idIndexMarker788"/> for the end user of a script. <strong class="source-inline">Write-Information</strong> is for script <a id="_idIndexMarker789"/>operators, and <strong class="source-inline">Write-Debug</strong> is for developers; <span class="No-Break">that’s us.</span></p>
			<p>We’ve used <strong class="source-inline">Write-Output</strong> and <strong class="source-inline">Write-Verbose</strong> previously; we’ll not cover them again here. They provide different levels of information for the person running the script. <strong class="source-inline">Write-Error</strong>, however, is new. We can use the <strong class="source-inline">Write-Error</strong> cmdlet to produce a non-terminating error, much the same as we can use <strong class="source-inline">Throw</strong> to generate a terminating error. In the <strong class="source-inline">Write-Error.ps1</strong> script shown next, I’ve set <strong class="source-inline">$ErrorActionPreference</strong> to the default and replaced the <strong class="source-inline">Throw</strong> message we were using previously with a <span class="No-Break"><strong class="source-inline">Write-Error</strong></span><span class="No-Break"> cmdlet:</span></p>
			<div>
				<div id="_idContainer191" class="IMG---Figure">
					<img src="image/B17600_10_010.jpg" alt="Figure 10.10 – The Write-Error cmdlet"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – The Write-Error cmdlet</p>
			<p>On <em class="italic">line 4</em>, I’ve replaced the <strong class="source-inline">Throw</strong> statement with <strong class="source-inline">Write-Error "There are no CSV files here"</strong> and added a <strong class="source-inline">Write-Output</strong> cmdlet on <em class="italic">line 9</em>, inside the <strong class="source-inline">try</strong> statement that opens on <span class="No-Break"><em class="italic">line 1</em></span><span class="No-Break">.</span></p>
			<p>When we run it, we can see that the <strong class="source-inline">Write-Error</strong> cmdlet outputs a message in red to the console. We can see that it is a non-terminating error because the <strong class="source-inline">Write-Output</strong> cmdlet on <em class="italic">line 9</em> also runs and produces a <strong class="source-inline">the script continues</strong> string in the console. As we can see from the console window in the screenshot, the error is also written to the <strong class="source-inline">$Error</strong> variable. We control its display with the same <strong class="source-inline">$ErrorActionPreference</strong> variable we saw earlier in <span class="No-Break">the chapter.</span></p>
			<p>So, when do we use <strong class="source-inline">Write-Error</strong>, and when do we use <strong class="source-inline">Throw</strong>? <strong class="source-inline">Write-Error</strong> is when we want to tell the user that something is wrong but let the script continue with what it is doing. <strong class="source-inline">Throw</strong> is for when we want the script to stop what it’s doing and process <span class="No-Break">the error.</span></p>
			<p><strong class="source-inline">Write-Warning</strong> is a cmdlet that I almost<a id="_idIndexMarker790"/> never use. It writes text to the warning stream, which is output<a id="_idIndexMarker791"/> as yellow text. That’s it. It produces yellow text. We can use the <strong class="source-inline">$WarningActionPreference</strong> variable and the <strong class="source-inline">-WarningAction</strong> parameter to force the script to stop or silently continue when something is written to the warning stream, but it seems to me this is needless redundancy; better to use <strong class="source-inline">Write-Error</strong> and write the output to the <strong class="source-inline">$Error</strong> variable as well. Other opinions <span class="No-Break">are available.</span></p>
			<p><strong class="source-inline">Write-Information</strong> is generally used to provide details of what our script has done; it is useful when we’re working with log aggregators that target the information stream, for instance, but I generally don’t bother <span class="No-Break">with it.</span></p>
			<p><strong class="source-inline">Write-Debug</strong> is the cmdlet we’re interested in here. This writes to the debug stream and can be accessed by making sure our script is an advanced script, using the <strong class="source-inline">CmdletBinding</strong> attribute we saw in <a href="B17600_08.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Writing Our First Script – Turning Simple Cmdlets into Reusable Code</em>. If we’ve used that attribute, then we have access to the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Debug</strong></span><span class="No-Break"> parameter.</span></p>
			<p>When should we use <strong class="source-inline">Write-Verbose</strong> and when should we use <strong class="source-inline">Write-Debug</strong>? The <strong class="source-inline">Write-Verbose</strong> output is for the user, and we use it to tell the user what the script is doing – for example, a message such as loading files when we have a loop to process and ingest files from a directory. We use <strong class="source-inline">Write-Debug</strong> inside the loop to enumerate the files that we are loading. Consider the following <span class="No-Break">short script:</span></p>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/B17600_10_011.jpg" alt="Figure 10.11 – Write-Verbose versus Write-Debug"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Write-Verbose versus Write-Debug</p>
			<p>This contains a <strong class="source-inline">Write-Verbose</strong> message on <em class="italic">line 7</em>, outside the <strong class="source-inline">foreach</strong> loop, and a <strong class="source-inline">Write-Debug</strong> message inside the loop on <em class="italic">line 9</em>. The <strong class="source-inline">Write-Verbose</strong> message targets script users and tells them that the script is doing something, even if they think it isn’t. The <strong class="source-inline">Write-Debug</strong> message is targeted at us and tells us exactly what the script is doing and which file it is processing. <strong class="source-inline">Write-Debug</strong> and <strong class="source-inline">Write-Host</strong> actions are controlled by the <strong class="source-inline">$DebugPreference</strong> and <strong class="source-inline">$VerbosePreference</strong> variables, respectively. These variables are both set to <strong class="source-inline">SilentlyContinue</strong> by default and are overridden by their respective <strong class="source-inline">-Debug</strong> and <strong class="source-inline">-Verbose</strong> switch parameters, as we can see in the console output in the <span class="No-Break">preceding screenshot.</span></p>
			<p>This is all very well, but this only<a id="_idIndexMarker792"/> tells us how to deal with errors we anticipate. What happens<a id="_idIndexMarker793"/> when we don’t know what’s going wrong? We turn to the <span class="No-Break">debugging cmdlets.</span></p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor213"/>Debugging cmdlets</h2>
			<p>Debugging is hugely complex, and as we dig<a id="_idIndexMarker794"/> into it, we quickly come to realize we need a pretty good grasp of computer science to understand it thoroughly. That doesn’t mean that a working knowledge of the more common cmdlets isn’t incredibly useful. In this section, we’re going to look at how to use breakpoints in the console when running scripts. A breakpoint will pause a script from running and start the built-in PowerShell debugger. The cmdlets that set and manipulate them all use the <strong class="source-inline">PSBreakpoint</strong> noun. These are the <strong class="source-inline">PSBreakpoint</strong> cmdlets that we should<a id="_idIndexMarker795"/> be <span class="No-Break">aware of:</span></p>
			<ul>
				<li><strong class="source-inline">Set-PSBreakpoint</strong> enables a breakpoint at a particular line of a script, variable, <span class="No-Break">or command</span></li>
				<li><strong class="source-inline">Get-PSBreakpoint</strong> lists the breakpoints that are set in <span class="No-Break">a session</span></li>
				<li><strong class="source-inline">Remove-PSBreakpoint</strong> removes the <span class="No-Break">specified breakpoint</span></li>
				<li><strong class="source-inline">Disable-PSBreakpoint</strong> stops a breakpoint from triggering but doesn’t <span class="No-Break">remove it</span></li>
				<li><strong class="source-inline">Enable-PSBreakpoint</strong> enables a <span class="No-Break">disabled breakpoint</span></li>
			</ul>
			<p>Let’s use the previous <strong class="source-inline">debugVsVerbose.ps1</strong> script. If you haven’t already, create a new file, save it as <strong class="source-inline">debugVsVerbose.ps1</strong>, and add this content. You’ll need to change the <strong class="source-inline">$path</strong> variable to a location where you’ve got <span class="No-Break">some files:</span></p>
			<pre class="source-code">
[CmdletBinding()]
param (
    $Path = "C:\temp\poshbook\ch10"
)
$files = (Get-ChildItem -Path $path)
Write-Verbose "Getting Files..."
foreach ($file in $files) {
    Write-Debug "Current `$file is $file"
}</pre>			<p>Now, in the console, <em class="italic">not</em> in VS Code, navigate to the directory where you saved it, and type <span class="No-Break">the following:</span></p>
			<pre class="console">
Set-PSBreakpoint -Script .\debugVsVerbose.ps1 -Variable file -Mode read</pre>			<p>This tells PowerShell that when the <strong class="source-inline">debugVsVerbose.ps1</strong> script is run, start the debugger when the value of the <strong class="source-inline">$file</strong> variable is read. Remember – the variable name doesn’t include the preceding dollar <span class="No-Break">sign (</span><span class="No-Break"><strong class="source-inline">$</strong></span><span class="No-Break">).</span></p>
			<p>Now, run the script to enter debug mode when the variable <span class="No-Break">is read:</span></p>
			<pre class="console">
.\debugVsVerbose.ps1</pre>			<p>Once we are in debug mode, we can check the values of variables, run cmdlets, interrogate the call stack, display the script, and do lots of other things. Try it; get the current value of <strong class="source-inline">$file</strong> by typing <span class="No-Break">the following:</span></p>
			<pre class="console">
$file</pre>			<p>You should see the name of the first file in your location. It should all look something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer193" class="IMG---Figure">
					<img src="image/B17600_10_012.jpg" alt="Figure 10.12 – Using the console debugger"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Using the console debugger</p>
			<p>We can see here that in the first<a id="_idIndexMarker796"/> command, I set the breakpoint to trigger when <strong class="source-inline">$file</strong> is read. The next command is to run the script. The console tells us that we’ve hit a variable breakpoint in yellow and tells us where in the script that breakpoint is. The prompt then switches to the debug mode prompt <strong class="source-inline">[DBG]</strong>. I type <strong class="source-inline">$file</strong>, and the contents of the variable <span class="No-Break">are displayed.</span></p>
			<p>The last command I type is <strong class="source-inline">h</strong>, which is a debugger<a id="_idIndexMarker797"/> command, not part of the debugging process. <span class="No-Break">Try this.</span></p>
			<p>Type <strong class="source-inline">h</strong> to get the help contents. This will show<a id="_idIndexMarker798"/> us a list of the commands we can use inside <span class="No-Break">the debugger:</span></p>
			<table id="table002-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Command</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Effect</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">s</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">stepInto</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Single step (step into functions, scripts, and <span class="No-Break">so on).</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">v</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">stepOver</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Step to the next statement (step over functions, scripts, etc.). This will run a function or script block as a <span class="No-Break">single step.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">o</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">stepOut</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Step out of the current function, script, and <span class="No-Break">so on.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">c</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">continue</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Continue <span class="No-Break">the operation.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">q</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">quit</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Stop the operation and exit <span class="No-Break">the debugger.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">d</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">detach</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Continue the operation and detach <span class="No-Break">the debugger.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">k</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">Get-PSCallStack</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Display the <span class="No-Break">call stack.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body"/>
						<td class="No-Table-Style T---Body"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">l</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">list</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>List the source code for the <span class="No-Break">current script.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body"/>
						<td class="No-Table-Style T---Body">
							<p>Use <strong class="source-inline">list</strong> to start from the current line, <strong class="source-inline">list &lt;m&gt; </strong>to start from line <strong class="source-inline">&lt;m&gt;</strong>, and <strong class="source-inline">list &lt;m&gt; &lt;n&gt;</strong> to list <strong class="source-inline">&lt;n&gt;</strong> lines starting from <span class="No-Break">line </span><span class="No-Break"><strong class="source-inline">&lt;m&gt;</strong></span><span class="No-Break">.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><em class="italic">Enter</em></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Repeat the last command if it was <strong class="source-inline">stepInto</strong>, <strong class="source-inline">stepOver</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">list</strong></span><span class="No-Break">.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><strong class="source-inline">?</strong>, <strong class="source-inline">h</strong></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Displays the <span class="No-Break">help message.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.2 – PowerShell debugger commands</p>
			<p>There are a number of commands that help us navigate through our script and need a little more explanation, <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">StepOver</strong> will take us to the next statement; if that statement is a function, the debugger will just run the function. It won’t work through it line <span class="No-Break">by line.</span></li>
				<li><strong class="source-inline">StepInto</strong> will take us to the next line of code after the breakpoint and run it. It will step into functions and run them line by line, rather than just running <span class="No-Break">the function.</span></li>
				<li><strong class="source-inline">StepOut</strong> will complete a function if we are in it and take us to the next statement after <span class="No-Break">the function.</span></li>
				<li><strong class="source-inline">Continue</strong> will run the script, either to the end or to the <span class="No-Break">next breakpoint.</span></li>
				<li><strong class="source-inline">Get-PSCallStack</strong> will show us where we are in terms of scripts and functions. For instance, if we press the <em class="italic">K</em> key in our preceding debugger, it will show us that we are in the <strong class="source-inline">debugVsVerbose.ps1</strong> script, at <em class="italic">line 9</em>. If we were in a function in a script, it would show us the function name and our location within it, followed by the script name <span class="No-Break">and location.</span></li>
				<li><strong class="source-inline">List</strong> will show us the script, from whichever line <span class="No-Break">we choose.</span></li>
				<li>Finally, <strong class="source-inline">quit</strong> will exit<a id="_idIndexMarker799"/> <span class="No-Break">the debugger.</span></li>
			</ul>
			<p>In my experience, it’s not very often<a id="_idIndexMarker800"/> we’ll need to debug at the command line. Generally, debugging is easier in an editor such as VS Code. Let’s have a look at how we can <span class="No-Break">do that.</span></p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor214"/>Debugging with VS Code</h1>
			<p>VS Code is probably the best tool<a id="_idIndexMarker801"/> for debugging PowerShell. It has all the debugging features most people will need, such as remote debugging capabilities for connecting to other machines; far too many to cover here. This section is going to cover the basics and show how we can use VS Code to perform the basic debugging procedures we’ve just covered in the <span class="No-Break">command line.</span></p>
			<p>In a new VS Code session, press <em class="italic">Ctrl </em>+ <em class="italic">Shift</em> + <em class="italic">P</em> to open the Command Palette and type <strong class="source-inline">exam</strong>; you should see a link for the PowerShell extension examples folder, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/B17600_10_013.jpg" alt="Figure 10.13 – The PowerShell extension examples folder shortcut"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – The PowerShell extension examples folder shortcut</p>
			<p>In the File Explorer in the left-hand pane, double-click the <strong class="source-inline">DebugTest.ps1</strong> file to <span class="No-Break">open it.</span></p>
			<p>This is quite a short tutorial script that is provided with the PowerShell VS Code extension. It consists of two functions, <strong class="source-inline">Do-Work</strong> and <strong class="source-inline">Write-Item</strong>. Neither function does very much; <strong class="source-inline">Do-Work</strong> writes two lines of text, using two different cmdlets, <strong class="source-inline">Write-Output</strong> and <strong class="source-inline">Write-Host</strong>, and also calls the <strong class="source-inline">Write-Item</strong> function. <strong class="source-inline">Write-Item</strong> is a counting function that will count up to the value of the <strong class="source-inline">$Count</strong> variable, outputting a string each time, with a short delay between each iteration. <strong class="source-inline">Do-Work</strong> is called by the final line of the script, <span class="No-Break"><em class="italic">line 28</em></span><span class="No-Break">.</span></p>
			<p>Now, let’s set a breakpoint. Either select <em class="italic">line 15</em> by clicking on it and pressing <em class="italic">F9</em> or hover the mouse to the left of the line number and click. The dull red dot seen in the following screenshot will become <span class="No-Break">bright red:</span></p>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/B17600_10_014.jpg" alt="Figure 10.14 – Setting a breakpoint"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – Setting a breakpoint</p>
			<p>Now we have a breakpoint<a id="_idIndexMarker802"/> set, we can start the debugger. The easiest way to do this is to press <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">D</em>, or we can select <strong class="bold">Run</strong> from the <span class="No-Break"><strong class="bold">View</strong></span><span class="No-Break"> menu:</span></p>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="image/B17600_10_015.jpg" alt="Figure 10.15 – The VS Code Debug interface"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.15 – The VS Code Debug interface</p>
			<p>The <strong class="bold">Debug</strong> view is quite complex, and we’ll need to run the file to the breakpoint to see what it does. In the top-left corner, press the green arrow next to <strong class="bold">RUN AND DEBUG</strong> (number <em class="italic">1</em> in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.15</em>). The script will run to the breakpoint on <em class="italic">line 15</em> and stop. Let’s explore the interface. Firstly, we have the run controls (<em class="italic">2</em>). From left to right, these are <em class="italic">continue</em>, <em class="italic">step over</em>, <em class="italic">step in</em>, <em class="italic">step out</em>, <em class="italic">restart</em>, and <em class="italic">stop</em>, and are analogous to the controls in the console debugger in the last section. If we hover the mouse over them, we can see the associated<a id="_idIndexMarker803"/> keyboard shortcuts; for instance, we can also continue by pressing <em class="italic">F5</em>. These commands are also available from the <strong class="bold">Run</strong> menu in the top toolbar. We can see the breakpoint we’ve stopped at highlighted in the <span class="No-Break">script (</span><span class="No-Break"><em class="italic">3</em></span><span class="No-Break">).</span></p>
			<p>The panel on the left contains some really interesting tools in three windows, <strong class="bold">VARIABLES</strong>, <strong class="bold">WATCH</strong>, and <strong class="bold">CALL STACK</strong>. The top window contains the values of all the variables (<em class="italic">4</em>). There are five subsections here. <strong class="bold">Auto</strong> contains the variables around the current breakpoint and their current value; in our case, we are in the <strong class="source-inline">Write-Item</strong> function, and the variables are <strong class="source-inline">$i</strong>, <strong class="source-inline">$str</strong>, and <strong class="source-inline">$itemCount</strong>. If we hover the mouse over them, we can see the type of the variable. Ironically, <strong class="bold">Auto</strong> doesn’t show automatic variables. <strong class="bold">Command</strong> shows the variables associated with the current command – in this case, <strong class="source-inline">Write-Item</strong>. If we click the arrow to the left of the word <strong class="bold">Command</strong>, we can see automatic variables such as <strong class="source-inline">$args</strong> and <strong class="source-inline">$MyInvocation</strong>. If we expand <strong class="source-inline">$PSBoundParameters</strong>, we can see the parameter associated with <span class="No-Break"><strong class="source-inline">Write-Item</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">[itemCount]</strong></span><span class="No-Break">.</span></p>
			<p><strong class="bold">Local</strong>, <strong class="bold">Script</strong>, and <strong class="bold">Global</strong> show the values <a id="_idIndexMarker804"/>of all parameters that exist in each of those scopes, and we can see, for instance, that the  <strong class="source-inline">$i</strong> variable exists in the local scope, but not in the script or <span class="No-Break">global scopes.</span></p>
			<p>Let’s move on to the <strong class="bold">CALL STACK</strong> section (<em class="italic">5</em>). Call stacks run from bottom to top, or <strong class="bold">last-in, first-out</strong> (<strong class="bold">LIFO</strong>), so we can see that we start in the interactive<a id="_idIndexMarker805"/> session, and call the script, called <strong class="source-inline">&lt;ScriptBlock&gt;</strong>, here. This runs to <em class="italic">line 28</em> and calls the <strong class="source-inline">Do-Work</strong> function, which runs to <em class="italic">line 24</em> and calls the <strong class="source-inline">Write-Item</strong> function, which runs to the breakpoint on <em class="italic">line 15</em>. This allows us to trace the flow of execution through the script. If we click on the items in the call stack, we can see that the variable values in the top pane change to show their values in the relevant scope. For instance, if we select <strong class="source-inline">Do-Work</strong> instead of <strong class="source-inline">Write-Item</strong>, we can see that <strong class="source-inline">$PSBoundParameter</strong> now <span class="No-Break">contains </span><span class="No-Break"><strong class="source-inline">[workCount]</strong></span><span class="No-Break">.</span></p>
			<p>Finally, we have the <strong class="bold">WATCH</strong> section (<em class="italic">6</em>), in the middle pane. Here, we can add a variable or an expression that we always want to know the value of. Let’s try it. Hover the mouse over the <strong class="bold">WATCH</strong> pane and click the <strong class="bold">+</strong> button that appears. In the resulting textbox, type <strong class="source-inline">$i*2</strong> and press <em class="italic">Enter</em>. We should see the expression evaluated to <strong class="source-inline">4</strong>. If we now press the <strong class="bold">Continue</strong> button or <em class="italic">F5</em>, the script will run through until it hits the breakpoint again, and we should see that our expression is now evaluated <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">6</strong></span><span class="No-Break">.</span></p>
			<p>We’ve barely scratched the surface of debugging with VS Code, but we’ve done enough to see how we can use it to understand why our code isn’t behaving as we think it should. Debugging is an incredibly complex topic<a id="_idIndexMarker806"/> and the best way to learn it is to do it. VS Code can make that task a lot easier, though. Let’s summarize what we’ve covered in <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor215"/>Summary</h1>
			<p>We started this chapter by looking at what an error actually is and covered some computer science that is applicable to most programming languages. We saw how PowerShell is different from many languages by having the concept of terminating and non-terminating errors, and how this is a feature of it being an interpreted language that sits on top <span class="No-Break">of .NET.</span></p>
			<p>Once we understood what errors are, we looked at different ways in which PowerShell can handle those errors using the <strong class="source-inline">$ErrorActionPreference</strong> variable and <span class="No-Break">the</span><span class="No-Break"><strong class="source-inline">-ErrorAction</strong></span><span class="No-Break"> parameter.</span></p>
			<p>We saw how we must turn errors into terminating errors so that we can use the most common way of trapping errors, the <strong class="source-inline">Try</strong>/<strong class="source-inline">Catch</strong>/<strong class="source-inline">Finally</strong> family of statements. We also learned how we can use those statements to provide custom <span class="No-Break">error-handling routines.</span></p>
			<p>Having seen how we work with errors, we learned how we can use a <strong class="source-inline">Throw</strong> statement to generate our own terminating errors when we encounter situations that are undesirable but don’t naturally cause <span class="No-Break">an error.</span></p>
			<p>Having explored how we deal with errors, we looked at the art of debugging in the second half of the chapter. We started by looking at the concept of script instrumentation using <strong class="source-inline">Write-Debug</strong>, and how we can use it to generate insights into what our code is doing when we use the <strong class="source-inline">-Debug</strong> parameter to access the debug <span class="No-Break">output stream.</span></p>
			<p>We moved on to looking at how we can perform interactive debugging on our scripts using debugging cmdlets such as <strong class="source-inline">Set-PSBreakPoint</strong> to access the built-in PowerShell debugger. After seeing how difficult that is, we concluded the chapter by looking at a far more powerful and much easier way of interactively debugging our scripts using <span class="No-Break">VS Code.</span></p>
			<p>In the next chapter, we’re going to be looking at how we can distribute our code so that others can use it in a flexible fashion, by turning our scripts into modules. <span class="No-Break">Can’t wait!</span></p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor216"/>Exercises</h1>
			<ol>
				<li>In terms of running a script, what is the main difference between terminating and <span class="No-Break">non-terminating errors?</span></li>
				<li>How can we access detailed information <span class="No-Break">about errors?</span></li>
				<li>What is the purpose of the <strong class="source-inline">-ErrorActionPreference</strong> variable <span class="No-Break">in PowerShell?</span></li>
				<li>What is the purpose of the <strong class="source-inline">Write-Error</strong> cmdlet <span class="No-Break">in PowerShell?</span></li>
				<li>Why might we want to use a <span class="No-Break"><strong class="source-inline">Throw</strong></span><span class="No-Break"> statement?</span></li>
				<li>How can we display debug messages in <span class="No-Break">a script?</span></li>
				<li>How can we write debug messages in a script, and who are we writing <span class="No-Break">them for?</span></li>
				<li>What is a breakpoint <span class="No-Break">in PowerShell?</span></li>
				<li>What is the purpose of the <strong class="source-inline">stepOver</strong> <span class="No-Break">debugger command?</span></li>
			</ol>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor217"/>Further reading</h1>
			<ul>
				<li>If debugging interests you, the best way to learn is by doing it. However, you can get a head start by reading <em class="italic">The Science of Debugging</em>, by Matt Telles and <span class="No-Break">Yuan Hsieh:</span><p class="list-inset"><em class="italic">The Science of Debugging</em>, <em class="italic">Matt Telles</em> and <em class="italic">Yuan Hsieh</em>, <em class="italic">2001</em>, <span class="No-Break"><em class="italic">Coriolis Group</em></span></p></li>
				<li>There are some good docs on debugging PowerShell with VS Code that go into far <span class="No-Break">more detail:</span><ul><li><a href="https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-1/"><span class="No-Break">https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-1/</span></a></li><li><a href="https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-2/"><span class="No-Break">https://devblogs.microsoft.com/scripting/debugging-powershell-script-in-visual-studio-code-part-2/</span></a></li></ul></li>
				<li>And here is a more general link about the VS <span class="No-Break">Code debugger:</span><p class="list-inset"><a href="https://code.visualstudio.com/Docs/editor/debugging"><span class="No-Break">https://code.visualstudio.com/Docs/editor/debugging</span></a></p></li>
				<li>This article has lots of interesting links, although some of them are a little <span class="No-Break">old now:</span><p class="list-inset"><a href="https://learn.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode?view=powershell-7.3&#13;"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode?view=powershell-7.3</span></a></p></li>
			</ul>
		</div>
	</body></html>