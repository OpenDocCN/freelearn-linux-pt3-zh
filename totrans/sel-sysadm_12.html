<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div id="_idContainer030" class="calibre2">
			<h1 id="_idParaDest-275" class="calibre5"><em class="italic"><a id="_idTextAnchor279" class="pcalibre calibre6 pcalibre1"/>Chapter 10</em>: Using Xen Security Modules with FLASK</h1>
			<p class="calibre3">In <a href="B16276_09_Final_VK.xhtml#_idTextAnchor257" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 9</em></a>, <em class="italic">Secure Virtualization</em>, we saw that libvirt is able to apply sVirt protection measures, based upon SELinux domains and category assignation, to several supported hypervisors. Xen, another popular open source hypervisor, is also supported by libvirt, but it is much more common to use Xen on its own, independent from libvirt.</p>
			<p class="calibre3">Xen itself has a security framework called <strong class="bold">Xen Security Modules</strong> (<strong class="bold">XSM</strong>), similar to <strong class="bold">Linux Security Modules</strong> (<strong class="bold">LSM</strong>), and an access control system called XSM-FLASK, which is their SELinux-based security framework. We'll see how Xen uses XSM, how to build Xen with XSM support, and finally, how we can apply policies to Xen domains.</p>
			<p class="calibre3">In this chapter, we're going to cover the following main topics:</p>
			<ul class="calibre8">
				<li class="calibre9">Understanding Xen and XSM</li>
				<li class="calibre9">Running XSM-enabled Xen</li>
				<li class="calibre9">Applying custom XSM policies</li>
			</ul>
			<h1 id="_idParaDest-276" class="calibre5"><a id="_idTextAnchor280" class="pcalibre calibre6 pcalibre1"/>Technical requirements</h1>
			<p class="calibre3">Check out the following video to see the Code in Action: <a href="https://bit.ly/3kcCePl" class="pcalibre calibre6 pcalibre1">https://bit.ly/3kcCePl</a></p>
			<h1 id="_idParaDest-277" class="calibre5"><a id="_idTextAnchor281" class="pcalibre calibre6 pcalibre1"/>Understanding Xen and XSM</h1>
			<p class="calibre3">The Xen Project is <a id="_idIndexMarker720" class="pcalibre calibre6 pcalibre1"/>a Linux Foundation project that maintains the Xen hypervisor. While <a id="_idIndexMarker721" class="pcalibre calibre6 pcalibre1"/>the Xen Project manages multiple security and virtualized-related software titles, our focus is on the Xen hypervisor.</p>
			<h2 id="_idParaDest-278" class="calibre10"><a id="_idTextAnchor282" class="pcalibre calibre6 pcalibre1"/>Introducing the Xen hypervisor</h2>
			<p class="calibre3">The Xen hypervisor <a id="_idIndexMarker722" class="pcalibre calibre6 pcalibre1"/>runs directly on top of hardware and sits in between the various virtual machines and the hardware itself. Unlike QEMU or KVM, which run as a process within Linux to offer the virtualization functionality, Xen works more independently. As a result, administrators will not see the running instances as separate processes. Instead, they need to rely on Xen commands and APIs to get more information and to interact with the Xen hypervisor.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">As with libvirt, the Xen hypervisor uses the term <em class="italic">domain</em> to point to its guests. As we use the term <em class="italic">domain</em> frequently in SELinux to mean the SELinux type of a running process, and thus also the SELinux type of a running guest, we will use <em class="italic">guest</em> wherever possible. However, there will be some terminology associated with Xen where we will have to keep the <em class="italic">domain</em> terminology in place.</p>
			<p class="calibre3">Xen always <a id="_idIndexMarker723" class="pcalibre calibre6 pcalibre1"/>has at least one virtual guest defined, called <strong class="bold">Domain 0</strong> (<strong class="bold">dom0</strong>). This guest manages the system and runs the Xen daemon (<strong class="source-inline">xend</strong>). It is through dom0 that <a id="_idIndexMarker724" class="pcalibre calibre6 pcalibre1"/>administrators will create and operate virtual guests <a id="_idIndexMarker725" class="pcalibre calibre6 pcalibre1"/>running within Xen. These regular guests are unprivileged, and therefore abbreviated as <strong class="bold">domU</strong>—<strong class="bold">unprivileged domains</strong>.</p>
			<p class="calibre3">When administrators boot a Xen host, they boot into Xen's <em class="italic">dom0</em> instance, through which they then further interact with Xen. The Linux kernel has included support for running both within <em class="italic">dom0</em> as well as <em class="italic">domU</em> for quite some time now (with complete support, including backend drivers, since Linux kernel 3.0).</p>
			<p class="calibre3">Let's use an existing Linux deployment to install Xen, and use this existing deployment as Xen's dom0 guest.</p>
			<h2 id="_idParaDest-279" class="calibre10"><a id="_idTextAnchor283" class="pcalibre calibre6 pcalibre1"/>Installing Xen</h2>
			<p class="calibre3">While many <a id="_idIndexMarker726" class="pcalibre calibre6 pcalibre1"/>Linux distributions offer Xen out of the box, it is very likely that these deployments do not support XSM (which we will enable in the <em class="italic">Running XSM-enabled Xen</em> section). So, rather than fiddling with prebuilt Xen environments first, we want to build it from source as released by the Xen Project immediately.</p>
			<p class="calibre3">Before we start using Xen, let alone its XSM support, we first need to make sure that we are running with a Xen-enabled Linux kernel.</p>
			<h3 class="calibre12">Running with a Xen-enabled Linux kernel</h3>
			<p class="calibre3">The <a id="_idIndexMarker727" class="pcalibre calibre6 pcalibre1"/>Linux kernel on the system must have support for running (at least) inside a dom0 guest. Without this support, not only will the dom0 guest not be able to interact with the Xen hypervisor, it will also not be able to boot the Xen hypervisor itself (the Xen-enabled kernel needs to bootstrap the Xen hypervisor before launching itself as the dom0 guest).</p>
			<p class="calibre3">If you build your own Linux kernel, you need to configure the kernel with the settings as documented at <a href="https://wiki.xenproject.org/wiki/Mainline_Linux_Kernel_Configs" class="pcalibre calibre6 pcalibre1">https://wiki.xenproject.org/wiki/Mainline_Linux_Kernel_Configs</a>. Some Linux <a id="_idIndexMarker728" class="pcalibre calibre6 pcalibre1"/>distributions provide more in-depth build <a id="_idIndexMarker729" class="pcalibre calibre6 pcalibre1"/>instructions (such as Gentoo at <a href="https://wiki.gentoo.org/wiki/Xen" class="pcalibre calibre6 pcalibre1">https://wiki.gentoo.org/wiki/Xen</a>). On CentOS, however, out-of-the-box Xen support is currently missing from the last release (as CentOS focuses more on libvirt and related technologies for its virtualization support). </p>
			<p class="calibre3">Luckily, the community offers well-maintained Linux kernel builds that do include Xen support, through the <strong class="source-inline">kernel-ml</strong> package. Let's install this kernel package:</p>
			<ol class="calibre18">
				<li class="calibre9">Enable <a id="_idIndexMarker730" class="pcalibre calibre6 pcalibre1"/>the <strong class="bold">Enterprise Linux Repository</strong> (<strong class="bold">ELRepo</strong>), which introduces several other, community-driven repositories:<p class="source-code"><strong class="bold"># yum install elrepo-release</strong></p></li>
				<li class="calibre9">Install the <strong class="source-inline">kernel-ml</strong> package, which will install the most recent Linux kernel, with a configuration <a id="_idIndexMarker731" class="pcalibre calibre6 pcalibre1"/>that includes Xen support. We simultaneously enable the <strong class="source-inline">elrepo-kernel</strong> repository, through which this package is made available:<p class="source-code"><strong class="bold"># yum install --enablerepo=elrepo-kernel kernel-ml</strong></p></li>
				<li class="calibre9">Generally, the Linux boot loader will be reconfigured to include these new kernels. If not, or you want to make sure that the kernel is properly detected, the following command <a id="_idIndexMarker732" class="pcalibre calibre6 pcalibre1"/>can be used to regenerate the <strong class="bold">Grand Unified Bootloader</strong> (<strong class="bold">GRUB2</strong>) configuration file:<p class="source-code"><strong class="bold"># grub2-mkconfig -o /boot/grub2/grub.cfg</strong></p><p class="calibre3">Of course, if your system uses a different boot loader, different instructions apply. Consult your Linux distribution's documentation for more information on how to configure the boot loader.</p></li>
				<li class="calibre9">Reboot the system using the newly installed kernel:<p class="source-code"><strong class="bold"># reboot</strong></p></li>
			</ol>
			<p class="calibre3">If all goes well, you will now be running with a Xen-compatible kernel. That, of course, does not mean that Xen is active, but merely that the kernel can support Xen if it is needed. Let's now move forward with building the Xen hypervisor and related tooling.</p>
			<h3 class="calibre12">Building Xen from source</h3>
			<p class="calibre3">The Xen <a id="_idIndexMarker733" class="pcalibre calibre6 pcalibre1"/>hypervisor and tools have dependencies on various programs and libraries, and not all tools and libraries are properly detected as dependencies while building Xen from source.</p>
			<p class="calibre3">Let's first install these dependencies:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">Enable the <strong class="source-inline">PowerTools</strong> repository:<p class="source-code"><strong class="bold"># dnf config-manger --set-enabled PowerTools</strong></p></li>
				<li class="calibre9">Install the dependencies supported by the CentOS repositories:<p class="source-code"><strong class="bold"># yum install gcc xz-devel python36-devel acpica-tools uuid-devel ncurses-devel glib2-devel pixman-devel yajl yajl-devel zlib-devel transfig pandoc perl-Pod-Html git glibc-devel.i686 patch libuuid-devel</strong></p></li>
				<li class="calibre9">Install the <strong class="source-inline">dev86</strong> package. At the time of writing, this package is not yet available for CentOS 8 so we deploy the version from CentOS 7 instead:<p class="source-code"><strong class="bold"># yum install https://download-ib01.fedoraproject.org/pub/epel/7/x86_64/Packages/d/dev86-0.16.21-2.el7.x86_64.rpm</strong></p></li>
			</ol>
			<p class="calibre3">With the dependencies now installed, let's download the latest Xen and build it:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">Go to <a href="https://xenproject.org/downloads/" class="pcalibre calibre6 pcalibre1">https://xenproject.org/downloads/</a> and go to the last Xen Project release.</li>
				<li class="calibre9">At the bottom of the page, download the latest archive.</li>
				<li class="calibre9">Unpack the downloaded archive on the system:<p class="source-code"><strong class="bold">$ tar xvf xen-4.13.1.tar.gz</strong></p></li>
				<li class="calibre9">Enter the directory the archive is unpacked in:<p class="source-code"><strong class="bold">$ cd xen-4.13.1</strong></p></li>
				<li class="calibre9">Configure the sources for the local system. At this point, no specific arguments need to be passed on:<p class="source-code"><strong class="bold">$ ./configure</strong></p></li>
				<li class="calibre9">Build the Xen hypervisor and associated tools:<p class="source-code"><strong class="bold">$ make world</strong></p></li>
				<li class="calibre9">Install the Xen hypervisor and tools on the system:<p class="source-code"><strong class="bold"># make install</strong></p></li>
				<li class="calibre9">Reconfigure the boot loader. This should automatically detect the Xen binaries and add the necessary boot loader entries:<p class="source-code"><strong class="bold"># grub2-mkconfig -o /boot/grub2/grub.cfg</strong></p></li>
				<li class="calibre9">Configure the system to support libraries installed in <strong class="source-inline">/usr/local/lib</strong>:<p class="source-code"><strong class="bold"># echo "/usr/local/lib" &gt; /etc/ld.so.conf.d/local-xen.conf</strong></p><p class="source-code"><strong class="bold"># ldconfig</strong></p></li>
				<li class="calibre9">Create <a id="_idIndexMarker734" class="pcalibre calibre6 pcalibre1"/>equivalence rules for the subdirectories in <strong class="source-inline">/usr/local</strong> so that SELinux file contexts are correctly applied:<p class="source-code"><strong class="bold"># semanage fcontext -a -e /usr/local/bin /usr/bin</strong></p><p class="source-code"><strong class="bold"># semanage fcontext -a -e /usr/local/sbin /usr/sbin</strong></p></li>
				<li class="calibre9">Relabel the files inside <strong class="source-inline">/usr/local</strong>:<p class="source-code"><strong class="bold"># restorecon -RvF /usr/local</strong></p></li>
				<li class="calibre9">The result of these steps is that Xen is ready to be booted on the system. The boot loader will not use the Xen-enabled kernel by default though, so during reboot, it is important to select the right entry. Its title will contain <em class="italic">with Xen hypervisor</em>:<p class="source-code"><strong class="bold"># reboot</strong></p></li>
				<li class="calibre9">After rebooting into the Xen-enabled system, all we need to do is to start the Xen daemons:<p class="source-code"><strong class="bold"># systemctl start xencommons</strong></p><p class="source-code"><strong class="bold"># systemctl start xendomains</strong></p><p class="source-code"><strong class="bold"># systemctl start xendriverdomain</strong></p><p class="source-code"><strong class="bold"># systemctl start xen-watchdog</strong></p></li>
				<li class="calibre9">To verify that everything is working as expected, list the currently running guests:<p class="source-code"><strong class="bold"># xl list</strong></p><p class="source-code"><strong class="bold">Name           ID     Mem   VCPUs  State      Time(s)</strong></p><p class="source-code"><strong class="bold">Domain-0        0    7836     4    r-----      46.2</strong></p><p class="calibre3">The listing should contain a single guest, named <strong class="source-inline">Domain-0</strong>, which is the guest you just executed the <strong class="source-inline">xl list</strong> command in.</p></li>
				<li class="calibre9">Finalize the installation by ensuring that the previously started daemons are started at boot:<p class="source-code"><strong class="bold"># systemctl enable xencommons</strong></p><p class="source-code"><strong class="bold"># systemctl enable xendomains</strong></p><p class="source-code"><strong class="bold"># systemctl enable xendriverdomain</strong></p><p class="source-code"><strong class="bold"># systemctl enable xen-watchdog</strong></p></li>
			</ol>
			<p class="calibre3">Before we <a id="_idIndexMarker735" class="pcalibre calibre6 pcalibre1"/>move on to XSM, let's also create a guest inside Xen (as a domU) so that we can associate policies with it later, in the <em class="italic">Using XSM labels</em> section.</p>
			<h2 id="_idParaDest-280" class="calibre10"><a id="_idTextAnchor284" class="pcalibre calibre6 pcalibre1"/>Creating an unprivileged guest</h2>
			<p class="calibre3">When the Xen <a id="_idIndexMarker736" class="pcalibre calibre6 pcalibre1"/>hypervisor is active, the operating system through which we interact with Xen is called dom0 and is the (only) privileged guest that Xen supports. The other guests are unprivileged, and it is the interaction between these guests and the actions taken by these guests that we want to isolate and protect further with XSM.</p>
			<p class="calibre3">Let's first create a simple, unprivileged guest to run alongside the privileged dom0 one. We use Alpine <a id="_idIndexMarker737" class="pcalibre calibre6 pcalibre1"/>Linux in this example, but you can easily substitute this with other distributions or operating systems. This example will use the <strong class="bold">ParaVirtualized</strong> (<strong class="bold">PV</strong>) guest <a id="_idIndexMarker738" class="pcalibre calibre6 pcalibre1"/>approach, but Xen also supports <strong class="bold">Hardware Virtual Machine</strong> (<strong class="bold">HVM</strong>) guests:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">Download the ISO for the Alpine Linux distribution, as this distribution is more optimized for low memory consumption and lower (virtual) disk size requirements. Of course, you are free to pick other distributions as well if your system can handle it. We pick the release optimized for virtual systems from <a href="https://www.alpinelinux.org/downloads/" class="pcalibre calibre6 pcalibre1">https://www.alpinelinux.org/downloads/</a> and store the ISO on the system in <strong class="source-inline">/srv/data</strong>.</li>
				<li class="calibre9">Mount the ISO on the system so that we can use its bootable kernel when creating an unprivileged guest in our next steps:<p class="source-code"><strong class="bold"># mount -o loop -t iso9660 /srv/data/alpine-virt-3.8.0-x86_64.iso /media/cdrom</strong></p></li>
				<li class="calibre9">Create an image file, which will be used as the boot disk for the virtual guest:<p class="source-code"><strong class="bold"># dd if=/dev/zero of=/srv/data/a1.img bs=1M count=3000</strong></p></li>
				<li class="calibre9">Next, create a configuration file for the virtual guest. We call the file <strong class="source-inline">a1.cfg</strong> and place it in <strong class="source-inline">/etc/xen</strong>:<p class="source-code"># Alpine Linux PV DomU</p><p class="source-code"># Kernel paths for install</p><p class="source-code">kernel = "/media/cdrom/boot/vmlinuz-virt"</p><p class="source-code">ramdisk = "/media/cdrom/boot/initramfs-virt"</p><p class="source-code">extra = "modules=loop,squashfs console=hvc0"</p><p class="source-code"># Path to HDD and ISO file</p><p class="source-code">disk = [</p><p class="source-code">  'format=raw, vdev=xvda, access=w, target=/srv/data/a1.img',</p><p class="source-code">  'format=raw, vdev=xvdc, access=r, devtype=cdrom, target=/srv/data/alpine-virt-3.8.0-x86_64.iso'</p><p class="source-code">]</p><p class="source-code"># DomU settings</p><p class="source-code">memory = 512</p><p class="source-code">name = "alpine-a1"</p><p class="source-code">vcpus = 1</p><p class="source-code">maxvcpus = 1</p></li>
				<li class="calibre9">Boot <a id="_idIndexMarker739" class="pcalibre calibre6 pcalibre1"/>the virtual guest using the <strong class="source-inline">xl create</strong> command:<p class="source-code"><strong class="bold"># xl create -f /etc/xen/a1.cfg -c</strong></p><p class="calibre3">The <strong class="source-inline">-c</strong> option will immediately show the console to interact with, allowing you to initiate and complete the installation of the operating system in the guest. </p></li>
				<li class="calibre9">When the guest needs to reboot, use shutdown instead, and edit the configuration file. Remove the line referring to the ISO to prevent the guest from booting into the installation environment again.</li>
				<li class="calibre9">To launch the guest again, use the <strong class="source-inline">xl create</strong> command again. If the guest installation finishes and you no longer need to have access to the console, drop the <strong class="source-inline">-c</strong> option:<p class="source-code"><strong class="bold"># xl create -f /etc/xen/xa1.cfg</strong></p></li>
				<li class="calibre9">We can confirm that the virtual guest is running with <strong class="source-inline">xl list</strong>:<p class="source-code"><strong class="bold"># xl list</strong></p><p class="source-code"><strong class="bold">Name           ID     Mem VCPUs       State      Time(s)</strong></p><p class="source-code"><strong class="bold">Domain-0        0    7836     4      r-----         99.4</strong></p><p class="source-code"><strong class="bold">alpina-a1       1     128     1      -b----          2.5</strong></p></li>
			</ol>
			<p class="calibre3">With Xen, guests <a id="_idIndexMarker740" class="pcalibre calibre6 pcalibre1"/>are launched with the <strong class="source-inline">create</strong> subcommand and shut down with the <strong class="source-inline">shutdown</strong> (graceful) or <strong class="source-inline">destroy</strong> subcommands.</p>
			<p class="calibre3">With these steps behind us, we now have a working Xen installation and a running guest. It's time to learn what Xen has to offer us from a security perspective.</p>
			<h2 id="_idParaDest-281" class="calibre10"><a id="_idTextAnchor285" class="pcalibre calibre6 pcalibre1"/>Understanding Xen Security Modules</h2>
			<p class="calibre3">In <a href="B16276_01_Final_VK.xhtml#_idTextAnchor018" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 1</em></a>, <em class="italic">Fundamental SELinux Concepts</em>, we learned that SELinux is implemented through <a id="_idIndexMarker741" class="pcalibre calibre6 pcalibre1"/>a Linux subsystem called <strong class="bold">Linux Security Modules</strong> (<strong class="bold">LSM</strong>). Xen <a id="_idIndexMarker742" class="pcalibre calibre6 pcalibre1"/>has borrowed this idea and has a similar approach to its own security measures.</p>
			<p class="calibre3">With <strong class="bold">Xen Security Modules</strong> (<strong class="bold">XSM</strong>), Xen makes it possible to define and control actions between Xen guests, and between a Xen guest and the Xen hypervisor. Unlike the Linux kernel though, where several mandatory access control frameworks exist that can plug into the LSM subsystem, Xen <a id="_idIndexMarker743" class="pcalibre calibre6 pcalibre1"/>currently only has a single module available for XSM, called <strong class="bold">XSM-FLASK</strong>.</p>
			<p class="calibre3"><strong class="bold">FLASK</strong> stands for <strong class="bold">Flux Advanced Security Kernel</strong> and is the security architecture and approach <a id="_idIndexMarker744" class="pcalibre calibre6 pcalibre1"/>that SELinux also uses for its own access control expressions. With XSM-FLASK, developers and administrators can do the following:</p>
			<ul class="calibre8">
				<li class="calibre9">Define permissions and fine-grained access controls between guests</li>
				<li class="calibre9">Define limited privilege escalation for otherwise unprivileged guests</li>
				<li class="calibre9">Control direct hardware and device access from guests on a policy level</li>
				<li class="calibre9">Restrict and audit activities executed by privileged guests</li>
			</ul>
			<p class="calibre3">While XSM-FLASK uses SELinux-like naming conventions (and even SELinux build tools to build the policy), the XSM-FLASK-related settings are independent of SELinux. If dom0 is running with SELinux enabled (and there is no reason why it shouldn't), its policy has nothing to do with the XSM-FLASK policy.</p>
			<p class="calibre3">The labels that XSM-FLASK uses will also not be visible for regular Linux commands running inside the guests (and thus also dom0). As the running guests are not shown as processes within the system, they do not have an SELinux label at all, only an XSM-FLASK label (if enabled). Hence, Xen <a id="_idIndexMarker745" class="pcalibre calibre6 pcalibre1"/>cannot benefit from the sVirt approach, as documented in <a href="B16276_09_Final_VK.xhtml#_idTextAnchor257" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 9</em></a>, <em class="italic">Secure Virtualization</em>.</p>
			<h1 id="_idParaDest-282" class="calibre5"><a id="_idTextAnchor286" class="pcalibre calibre6 pcalibre1"/>Running XSM-enabled Xen</h1>
			<p class="calibre3">Switching <a id="_idIndexMarker746" class="pcalibre calibre6 pcalibre1"/>from a regular Xen deployment to an XSM-enabled Xen deployment is a matter of rebuilding Xen with XSM support and rebooting the system. Xen comes with an out-of-the-box policy that can be readily applied, which we will use as part of our XSM endeavor.</p>
			<h2 id="_idParaDest-283" class="calibre10"><a id="_idTextAnchor287" class="pcalibre calibre6 pcalibre1"/>Rebuilding Xen with XSM support</h2>
			<p class="calibre3">Let's rebuild <a id="_idIndexMarker747" class="pcalibre calibre6 pcalibre1"/>the Xen hypervisor and tools on the system with XSM support:</p>
			<ol class="calibre18">
				<li value="1" class="calibre9">Clean up the previous build by running the <strong class="source-inline">make clean</strong> command inside the <strong class="source-inline">build</strong> directory (<strong class="source-inline">xen-4.13.1</strong> in our example):<p class="source-code"><strong class="bold">$ make clean</strong></p></li>
				<li class="calibre9">Inside the <strong class="source-inline">build</strong> directory, go to the <strong class="source-inline">xen</strong> directory:<p class="source-code"><strong class="bold">$ cd xen</strong></p></li>
				<li class="calibre9">Launch the Xen configuration using <strong class="source-inline">make menuconfig</strong>:<p class="source-code"><strong class="bold">$ make menuconfig</strong></p></li>
				<li class="calibre9">Navigate to the XSM setting and enable the XSM-related parameters:<p class="source-code"><strong class="bold">Common Features ---&gt;</strong></p><p class="source-code"><strong class="bold">  [*] Xen Security Modules support</strong></p><p class="source-code"><strong class="bold">  [*]   FLux Advanced Security Kernel support</strong></p><p class="source-code"><strong class="bold">  [*]     Compile Xen with a built-in FLAS security </strong></p><p class="source-code"><strong class="bold">          policy</strong></p><p class="source-code"><strong class="bold">  [*]   SILO support</strong></p><p class="source-code"><strong class="bold">        Default XSM implementation (FLux Advanced </strong></p><p class="source-code"><strong class="bold">        Security Kernel)</strong></p></li>
				<li class="calibre9">Go back to the main build directory (<strong class="source-inline">xen-4.13.1</strong> in our example):<p class="source-code"><strong class="bold">$ cd ..</strong></p></li>
				<li class="calibre9">Rebuild the Xen hypervisor and tools:<p class="source-code"><strong class="bold">$ ./configure</strong></p><p class="source-code"><strong class="bold">$ make world</strong></p></li>
				<li class="calibre9">Install the updated Xen build on the system:<p class="source-code"><strong class="bold"># make install</strong></p><p class="calibre3">This will not only update the tools but will also provide an updated Xen kernel and an XSM policy inside <strong class="source-inline">/boot</strong> (named <strong class="source-inline">xenpolicy-4.13.1</strong>).</p></li>
				<li class="calibre9">Reconfigure the boot loader with the new Xen build, ensuring that the XSM policy is also loaded with it:<p class="source-code"><strong class="bold"># grub2-mkconfig -o /boot/grub2/grub.cfg</strong></p></li>
				<li class="calibre9">Reboot the system:<p class="source-code"><strong class="bold"># reboot</strong></p></li>
				<li class="calibre9">Once <a id="_idIndexMarker748" class="pcalibre calibre6 pcalibre1"/>rebooted, we can verify that the XSM policy is loaded and used by querying Xen for the labels associated with the running guests:<p class="source-code"><strong class="bold"># xl list -Z</strong></p><p class="source-code"><strong class="bold">Name               ID   ...     Security Label</strong></p><p class="source-code"><strong class="bold">Domain-0            0   ...   system_u:system_r:dom0_t</strong></p><p class="source-code"><strong class="bold">alpina-a1           1   ...   system_u:system_r:domU_t</strong></p></li>
			</ol>
			<p class="calibre3">If the <strong class="source-inline">xl list</strong> command, given the <strong class="source-inline">-Z</strong> argument, lists the security labels, then Xen is running with an XSM policy active. Let's see where these labels are used.</p>
			<h2 id="_idParaDest-284" class="calibre10"><a id="_idTextAnchor288" class="pcalibre calibre6 pcalibre1"/>Using XSM labels</h2>
			<p class="calibre3">When Xen <a id="_idIndexMarker749" class="pcalibre calibre6 pcalibre1"/>boots with XSM support and has its default policy active, the following types can be used by guests:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">dom0_t</strong> type is reserved for the privileged guest.</li>
				<li class="calibre9">The <strong class="source-inline">domU_t</strong> type is the default type to use for unprivileged guests.</li>
				<li class="calibre9">The <strong class="source-inline">isolated_domU_t</strong> type is the type to assign to unprivileged guests that should not be able to interact with other unprivileged guests, only with the privileged dom0 one.</li>
				<li class="calibre9">The <strong class="source-inline">prot_domU_t</strong> type is meant for guests that will be prevented from starting if the XSM policy boolean <strong class="source-inline">prot_doms_locked</strong> is set.</li>
				<li class="calibre9">The <strong class="source-inline">nomigrate_t</strong> type is applied to guests that are not allowed to be migrated from one Xen host to another. Internally, this prevents the dom0 guest from accessing the guest's memory once booted.</li>
			</ul>
			<p class="calibre3">There are <a id="_idIndexMarker750" class="pcalibre calibre6 pcalibre1"/>a few other types also available inside the XSM policy that are not meant for regular guests themselves:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">dm_dom_t</strong> type is assigned to the device model guest. This is a special, privileged guest that represents the hardware virtualized for an HVM-type guest, without jeopardizing dom0.</li>
				<li class="calibre9">The <strong class="source-inline">xenstore_t</strong> type is assigned to the <strong class="source-inline">xenstore</strong> stub guest. This is a special, privileged guest that provides support for unprivileged guests to access their virtualized resources, without jeopardizing dom0.</li>
				<li class="calibre9">The <strong class="source-inline">nic_dev_t</strong> type is assigned to hardware devices that can be used in passthrough mode (meaning domU guests can directly interact with these hardware devices rather than going through the privileged guests).</li>
			</ul>
			<p class="calibre3">These stub guests (<strong class="bold">stub domains</strong> or <strong class="bold">stubdoms</strong> as they are called in Xen) are a way for Xen to further <a id="_idIndexMarker751" class="pcalibre calibre6 pcalibre1"/>increase its security posture, as privileged operations that cannot be prevented are more isolated from dom0. If at any point a security vulnerability can be exploited in these privileged services, they do not necessarily affect dom0 and, with a proper XSM policy, can even be mitigated fully.</p>
			<p class="calibre3">Assigning one of these labels to a guest is a matter of editing the guest's configuration file inside <strong class="source-inline">/etc/xen</strong> and adding in the <strong class="source-inline">seclabel</strong> configuration parameter:</p>
			<p class="source-code">seclabel = 'system_u:system_r:isolated_domU_t'</p>
			<p class="calibre3">Once configured and rebooted (using <strong class="source-inline">xl create</strong>), the new label will be visible when querying the running guests:</p>
			<p class="source-code"># xl list -Z</p>
			<p class="source-code">Name               ID   ...   Security Label</p>
			<p class="source-code">Domain-0            0   ... system_u:system_r:dom0_t</p>
			<p class="source-code">alpina-a1           1   ... system_u:system_r:isolated_domU_t</p>
			<p class="calibre3">Applying the right label to the guest is the most common use case (as it effectively handles the access control and protection measures we seek from the XSM implementation), but other operations are supported as well.</p>
			<h2 id="_idParaDest-285" class="calibre10"><a id="_idTextAnchor289" class="pcalibre calibre6 pcalibre1"/>Manipulating XSM</h2>
			<p class="calibre3">As with <a id="_idIndexMarker752" class="pcalibre calibre6 pcalibre1"/>SELinux, several activities can be executed to further manipulate the XSM subsystem or the active policy.</p>
			<h3 class="calibre12">Defining the state, ranging from disabled to enforcing</h3>
			<p class="calibre3">When <a id="_idIndexMarker753" class="pcalibre calibre6 pcalibre1"/>Xen boots, we can add a kernel parameter called <strong class="source-inline">flask</strong>, which can be set to one of the following values:</p>
			<ul class="calibre8">
				<li class="calibre9">With <strong class="source-inline">flask=enforcing</strong>, we ensure that XSM is active, enforcing the policy between its guests and resources, and that the enforcement is immediate (no delayed activation).</li>
				<li class="calibre9">With <strong class="source-inline">flask=permissive</strong>, XSM will load the policy, but XSM will not enforce the rules set in the policy. This is obviously meant for development purposes and behaves similarly to SELinux's permissive mode.</li>
				<li class="calibre9">With <strong class="source-inline">flask=late</strong>, XSM will not enforce any access controls until a policy is loaded, after which the policy is enforced. This allows administrators to boot with XSM active, but only to load and apply a policy when the administrator deems it ready.</li>
				<li class="calibre9">With <strong class="source-inline">flask=disabled</strong>, XSM will not enforce any access controls nor load the policy.</li>
			</ul>
			<p class="calibre3">This parameter can be set either directly when booting (from the boot loader) or through the boot loader configuration on the system. For instance, with GRUB2, we can edit <strong class="source-inline">/etc/default/grub</strong> and add or modify the following parameter:</p>
			<p class="source-code">GRUB_CMDLINE_XEN_DEFAULT="flask=enforcing"</p>
			<p class="calibre3">Don't forget to regenerate the GRUB2 configuration file:</p>
			<p class="source-code"># grub2-mkconfig -o /boot/grub2/grub.cfg</p>
			<p class="calibre3">As with SELinux, we can also manipulate the state of XSM through the command line. With <strong class="source-inline">xl getenforce</strong>, we can query the current state:</p>
			<p class="source-code"># xl getenforce</p>
			<p class="source-code">Enforcing</p>
			<p class="calibre3">The <strong class="source-inline">xl setenforce</strong> command can be used to switch to another state:</p>
			<p class="source-code"># xl setenforce permissive</p>
			<p class="calibre3">These commands have nothing to do with the SELinux configuration within dom0: switching Xen from permissive mode to enforcing or vice versa is specific to Xen and has no impact on the SELinux settings inside dom0.</p>
			<h3 class="calibre12">Querying XSM logs</h3>
			<p class="calibre3">Like SELinux, XSM also uses AVC logging to provide feedback to the administrator about the decisions it <a id="_idIndexMarker754" class="pcalibre calibre6 pcalibre1"/>has taken. With <strong class="source-inline">xl dmesg</strong>, we can query this log information (alongside the other Xen output logging):</p>
			<p class="source-code"># xl dmesg</p>
			<p class="source-code">...</p>
			<p class="source-code">(XEN) avc: granted { setenforce } for domid=0 scontext=system_u:system_r:dom0_t tcontext=system_u:system_r:security_t tclass=security</p>
			<p class="calibre3">Not all granted operations will be logged, but denied operations will always result in an AVC entry. The AVC entries themselves are fully formatted like SELinux AVC entries, allowing administrators to use SELinux tools such as <strong class="source-inline">audit2allow</strong> to generate XSM policies.</p>
			<h3 class="calibre12">Using XSM booleans</h3>
			<p class="calibre3">The default <a id="_idIndexMarker755" class="pcalibre calibre6 pcalibre1"/>policy enabled by Xen has two booleans that can be toggled:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">guest_writeconsole</strong> boolean, which defaults to 1 (on), allows guests to access and write to the Xen console.</li>
				<li class="calibre9">The <strong class="source-inline">prot_doms_locked</strong> boolean, which defaults to 0 (off), will disallow <strong class="source-inline">prot_domU_t</strong> guests from launching if enabled.</li>
			</ul>
			<p class="calibre3">While no subcommand is available for the <strong class="source-inline">xl</strong> command to query and set XSM booleans, two other commands are installed on the system to accomplish this – <strong class="source-inline">flask-get-bool</strong> and <strong class="source-inline">flask-set-bool</strong>:</p>
			<ul class="calibre8">
				<li class="calibre9">With <strong class="source-inline">flask-get-bool</strong>, we can query the current state of a boolean, or list all booleans with their current value:<p class="source-code"><strong class="bold"># flask-get-bool -a</strong></p><p class="source-code"><strong class="bold">guest_writeconsole: 1</strong></p><p class="source-code"><strong class="bold">prot_doms_locked: 0</strong></p></li>
				<li class="calibre9">The <strong class="source-inline">flask-set-bool</strong> command is used to toggle booleans:<p class="source-code"><strong class="bold"># flask-set-bool prot_doms_locked 1</strong></p></li>
			</ul>
			<p class="calibre3">This is very similar to SELinux's <strong class="source-inline">getsebool</strong> and <strong class="source-inline">setsebool</strong> commands.</p>
			<h3 class="calibre12">Querying the XSM policy</h3>
			<p class="calibre3">The XSM policy file (<strong class="source-inline">xenpolicy-4.13.1</strong>) is quite similar to an SELinux policy file. As a result, we can use <a id="_idIndexMarker756" class="pcalibre calibre6 pcalibre1"/>the SELinux tools to query this file and learn more about the policy:</p>
			<ul class="calibre8">
				<li class="calibre9">With <strong class="source-inline">seinfo</strong>, we can query statistics about the policy, view which classes are supported, the constraints that are enabled within, and more. The only query that fails is listing the types supported within the policy:<p class="source-code"><strong class="bold">$ seinfo --all ./xenpolicy-4.13.1</strong></p></li>
				<li class="calibre9">With <strong class="source-inline">sesearch</strong>, we can query the XSM policy rules themselves, for instance, to list all allow rules:<p class="source-code"><strong class="bold">$ sesearch -A ./xenpolicy-4.13.1</strong></p></li>
			</ul>
			<p class="calibre3">When we <a id="_idIndexMarker757" class="pcalibre calibre6 pcalibre1"/>discuss analyzing SELinux policies in <a href="B16276_13_Final_VK.xhtml#_idTextAnchor330" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 13</em></a>, <em class="italic">Analyzing Policy Behavior</em>, we will get familiar with other tools that can also be used to analyze XSM policy files.</p>
			<h3 class="calibre12">Labeling hardware resources</h3>
			<p class="calibre3">With the <strong class="source-inline">flask-label-pci</strong> command, administrators can label specified PCI devices with a given type. This <a id="_idIndexMarker758" class="pcalibre calibre6 pcalibre1"/>approach allows administrators to mark certain devices for passthrough access by unprivileged guests.</p>
			<p class="calibre3">For instance, to label the PCI device with address <strong class="source-inline">3:2:0</strong> with the <strong class="source-inline">nic_dev_t</strong> type, use the following</p>
			<p class="source-code"># flask-label-pci 0000:03:02.0 system_u:object_r:nic_dev_t</p>
			<p class="calibre3">As you might guess from the name, this type is initially defined for passthrough access to network devices but can be used for other PCI hardware as well.</p>
			<h1 id="_idParaDest-286" class="calibre5"><a id="_idTextAnchor290" class="pcalibre calibre6 pcalibre1"/>Applying custom XSM policies</h1>
			<p class="calibre3">Xen also <a id="_idIndexMarker759" class="pcalibre calibre6 pcalibre1"/>allows administrators to build and use their own, custom policy.</p>
			<p class="calibre3">The default policy for Xen is available inside the <strong class="source-inline">tools/flask/policy</strong> directory within the Xen build directory. For instance, the policy rules for the dom0 guest are available inside <strong class="source-inline">modules/dom0.te</strong>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Adjusting the Xen XSM policy is beyond the scope of this chapter. You will find instructions on how to create SELinux policies using the reference policy-style method in <a href="B16276_15_Final_VK.xhtml#_idTextAnchor373" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 15</em></a>, <em class="italic">Using the Reference Policy</em>. The Xen XSM policy is based upon this style.</p>
			<p class="calibre3">Building a custom policy is a matter of updating these files (make a backup before you do) and then rebuilding the policy itself:</p>
			<p class="source-code">$ make</p>
			<p class="calibre3">The result of the policy build is a new <strong class="source-inline">xenpolicy-4.13.1</strong> file. This file can be loaded directly using the <strong class="source-inline">xl loadpolicy</strong> command:</p>
			<p class="source-code"># xl loadpolicy /path/to/xenpolicy-4.13.1</p>
			<p class="calibre3">This command <a id="_idIndexMarker760" class="pcalibre calibre6 pcalibre1"/>is similar to the <strong class="source-inline">flask-loadpolicy</strong> command:</p>
			<p class="source-code"># flask-loadpolicy /path/to/xenpolicy-4.13.1</p>
			<p class="calibre3">If, after testing, the policy is deemed ready to be used continuously, copy it over to <strong class="source-inline">/boot</strong> so that it is automatically picked up at the next boot as well.</p>
			<h1 id="_idParaDest-287" class="calibre5"><a id="_idTextAnchor291" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
			<p class="calibre3">The Xen hypervisor is quite different from the QEMU and KVM hypervisors, which are more readily used in libvirt. SELinux support for Xen is also different than sVirt as the SELinux subsystem can only be active inside Xen guests, and SELinux does not see other guests.</p>
			<p class="calibre3">Xen has resolved that by implementing its own SELinux copy as XSM-FLASK and has integrated the appropriate support for the XSM-FLASK labels in its own tooling. In this chapter, we've learned how to apply our own types to Xen guests, toggle the XSM state, toggle XSM booleans, and even how we can build and load our own XSM-FLASK policy.</p>
			<p class="calibre3">In the next chapter, we'll look at container workloads and how SELinux can help administrators to further harden and secure their container runtimes. We will see how sVirt can be applied to container runtimes, and how the tooling deals with SELinux support.</p>
			<h1 id="_idParaDest-288" class="calibre5"><a id="_idTextAnchor292" class="pcalibre calibre6 pcalibre1"/>Questions</h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">Why doesn't the regular SELinux subsystem govern Xen guests?</li>
				<li class="calibre9">How are labels assigned to Xen guests?</li>
				<li class="calibre9">What are the common Xen commands that deal with XSM labels?</li>
				<li class="calibre9">How can administrators load a custom policy for testing purposes?</li>
			</ol>
		</div>
	</div></body></html>