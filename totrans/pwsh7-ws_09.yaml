- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Don’t Repeat Yourself – Functions and Scriptblocks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要重复自己 – 函数和脚本块
- en: 'In this chapter, we’re going to look at one of the basic principles of software
    development and learn how to apply it to save ourselves effort and make our code
    easier to maintain: **Don’t Repeat Yourself**, also known as the **DRY** principle.
    In *The Pragmatic Programmer*, by Andy Hunt and Dave Thomas, the principle is
    stated as “*Every piece of knowledge must have a single, unambiguous, authoritative
    representation within a system.*” Some programmers will take this principle to
    its logical conclusion and have no repeating code anywhere. We’re writing scripts,
    and so we will apply the principle just as much as is convenient. We will talk
    about the concept of functions within code. By the end of the chapter, we will
    have seen how to write functions in our scripts to replace repeating code and
    learned how doing this makes our scripts easier to adapt and repair. We will also
    learn about another type of expression that is related to functions: **scriptblocks**.
    Along the way, we will also inevitably have to discuss the concept of **scope**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，我们将学习软件开发的基本原则之一，并学会如何应用它来节省我们的精力，使代码更易于维护：**不要重复自己**，也称为**DRY**原则。在安迪·亨特和戴夫·托马斯的《务实程序员》中，这一原则被表述为：“*每一条知识都必须在系统中有一个单一、明确、权威的表现形式。*”
    一些程序员会将这一原则推向其逻辑极限，确保代码中没有任何重复。我们写的是脚本，所以我们会在方便的情况下应用这一原则。我们将讨论代码中的函数概念。到本章结束时，我们将看到如何在脚本中编写函数来替换重复的代码，并了解这样做如何使我们的脚本更容易适应和修复。我们还将了解与函数相关的另一种表达式：**脚本块**。在此过程中，我们还必然会讨论**范围**的概念。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，我们将涵盖以下主题：
- en: Why do we care about repeating code?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们关心重复的代码？
- en: How to turn repeating code into a function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将重复的代码转换为函数
- en: The concept of scope
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围的概念
- en: Exploring scriptblocks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索脚本块
- en: Let’s do something useful
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们做点有用的事情
- en: Why do we care about repeating code?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们关心重复的代码？
- en: 'The obvious reason is that it is boring to figure out how to do something in
    PowerShell and then keep repeating the same lines over and over. For example,
    back in [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell Variables
    and Data Structures*, we discussed objects by referring to `TypeName Imaginary.Bike`.
    The `Imaginary.Bike` object had three properties: `handlebar`, `wheel`, and `color`.
    Let’s say we want to write a short script that validates that an imaginary bike
    has all its properties. It might look something like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的原因是，在PowerShell中搞清楚如何做某事之后，却还需要不断重复相同的行，实在是很无聊。例如，在[*第4章*](B17600_04.xhtml#_idTextAnchor071)《PowerShell变量与数据结构》中，我们通过引用`TypeName
    Imaginary.Bike`来讨论对象。`Imaginary.Bike`对象有三个属性：`handlebar`、`wheel`和`color`。假设我们想编写一个简短的脚本来验证假想自行车是否具备所有的属性。它可能看起来像这样：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the first line, I’m just defining my imaginary bike. The validation script
    starts after that. I’ve thrown in a non-existent property, `gears`, just to make
    sure that the code works. We can see that the script has a lot of `if` statements
    that do almost exactly the same thing as each other: they check whether an attribute
    is present and output a message if it is missing. We’re not too bothered about
    the repetition because we’re only checking four properties. But what if we needed
    to check 40 or 400? This is where the DRY principle comes in. We could write a
    script to do the same thing like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我只是定义了我的假想自行车。验证脚本从那之后开始。我加入了一个不存在的属性`gears`，只是为了确保代码能正常工作。我们可以看到脚本中有很多`if`语句，它们几乎做着完全相同的事情：检查一个属性是否存在，如果缺失则输出一条消息。我们对这些重复不太在意，因为我们只检查了四个属性。但如果我们需要检查40个或者400个属性呢？这就是DRY原则发挥作用的地方。我们可以像这样编写一个脚本来完成相同的事情：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each property we add from now on just needs a single word added to the `$properties`
    array, rather than three new lines of code. Great, huh?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们添加的每个属性只需要在`$properties`数组中添加一个单词，而不需要三行新的代码。很棒，对吧？
- en: We’re not just saving ourselves the effort of typing stuff out twice here, though.
    We’re also saving ourselves the effort of finding our typing mistakes in possibly
    hundreds of lines of code. If that `foreach` loop works for one property, it will
    work for all of them, unless we mistyped the property name when we added it to
    the `$properties` array. We know exactly where to look if something isn’t working,
    and so does anyone who needs to troubleshoot our script after us.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们这里不仅仅是在省去重复输入的麻烦。我们还在省去找出打字错误的努力，这些错误可能会出现在数百行代码中。如果`foreach`循环对一个属性有效，那它对所有属性都有效，除非我们在将属性添加到`$properties`数组时打错了属性名称。如果有什么不工作，我们知道该去哪里查找，任何需要在我们之后排查问题的人也能知道该查找哪里。
- en: 'The DRY principle doesn’t just refer to excessive code duplication; it can
    be applied far more widely in software. To quote *The Pragmatic Programmer* again,
    “*Many people took it [DRY] to refer to code only: they thought that DRY means
    “don’t copy-and-paste lines of source.” […] DRY is about the duplication of knowledge,
    of intent. It’s about expressing the same thing in two different places, possibly
    in two totally* *different ways.*”'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: DRY原则不仅仅适用于过度的代码重复，它在软件中可以广泛应用。再次引用《程序员修炼之道》中的话，“*许多人以为DRY只指代码：他们认为DRY意味着‘不要复制粘贴源代码’……
    DRY是关于知识、意图的重复。它是指在两个不同的地方表达相同的内容，可能用的是完全不同的方式。*”
- en: Imagine if we had written not just one script but a whole bunch of scripts that
    worked with imaginary bikes. Perhaps we run an imaginary bike shop and want a
    stock control application. We might find we need to refer to imaginary bike properties
    frequently in those scripts. It may be that we would end up with lists of properties
    in lots of places. It’s not hard to imagine that those lists might differ. Some
    might be incomplete. Some might be out of date. If we were to apply DRY to this,
    then there would be just one list of properties for all the scripts, a single
    source of truth when it comes to the properties that an imaginary bike might have,
    and whenever a script needed to refer to the list of properties, this is where
    they would find them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果我们不仅写了一个脚本，而是写了一堆与虚拟自行车相关的脚本。也许我们经营一家虚拟自行车店，并希望拥有一个库存管理应用程序。我们可能会发现，在这些脚本中，我们需要频繁引用虚拟自行车的属性。最终，可能会出现很多地方都有属性列表。我们不难想象，这些列表可能会有所不同。某些列表可能不完整，某些可能已经过时。如果我们应用DRY原则，那么就会有一个属性列表供所有脚本使用，当提到虚拟自行车的属性时，它们就会去这个列表中查找。
- en: 'To summarize, then, we care about repeating code for three reasons:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们关心重复代码的三个原因：
- en: We don’t want to write more code than is necessary.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不想编写超过必要的代码。
- en: We want it to be easier to find mistakes.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望更容易发现错误。
- en: We want a single source of truth for our code.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望我们的代码有一个单一的真实来源。
- en: 'Do we want to reduce code duplication all the time, in every case? Probably
    not. Going back to the section on automation in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162),
    *Writing Our First Script – Turning Simple Cmdlets into Reusable Code*, sometimes
    the effort required to reduce duplication to the minimum just isn’t worth it.
    Perhaps we’re only going to use a piece of code twice; in this case, copying and
    pasting it is perfectly fine, rather than working out how to do it just once.
    There are also two other software development principles worth knowing about:
    `if` statement, is preferable to writing the script in the second example with
    an abstraction that isn’t going to be used (*You Aren’t Gonna Need It*). We should
    do the simplest thing that could possibly work. One of the main takeaways from
    this is that software developers love an acronym.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否希望在所有情况下、每时每刻都减少代码重复？可能不是。回到[第8章](B17600_08.xhtml#_idTextAnchor162)中的自动化部分，*编写我们的第一个脚本
    - 将简单的Cmdlet转换为可重用代码*，有时候将重复最小化所需的努力并不值得。也许我们只会用到某段代码两次；在这种情况下，复制粘贴完全没问题，而不是想办法只写一次。还有两个值得了解的软件开发原则：`if`语句，比起编写第二个示例中的脚本，使用一个不会被用到的抽象（*你不会需要它*）更好。我们应该做出可能最简单的有效方案。这个原则的一个主要启示是，软件开发人员喜欢使用缩写。
- en: 'Now we know why we should reduce code duplication, let’s look at one of the
    main ways to do it in PowerShell: by using functions.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了为什么要减少代码重复，让我们来看看在PowerShell中实现这一点的主要方式之一：使用函数。
- en: How to turn repeating code into a function
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何将重复的代码转化为函数
- en: A function is a **named** section of code, a piece of code within a script or
    program that is given a label, and may be used by referring to the label. This
    is a very common programming paradigm and appears in most imperative programming
    languages. Some languages, such as PowerShell and Python, call these pieces of
    code functions. Some call them subroutines, subprograms, methods, or procedures.
    The paradigm is called procedural programming and lies between the scripting that
    most people practice with PowerShell and full object-oriented programming in languages
    such as C++ and Java. Functional programming is a different paradigm, with a declarative
    style.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一个**命名**的代码块，脚本或程序中的一段代码，它被赋予一个标签，可以通过引用该标签来使用。这是一个非常常见的编程范式，几乎所有的命令式编程语言都有出现。有些语言，如
    PowerShell 和 Python，将这些代码块称为函数。有些则称它们为子程序、子程序块、方法或过程。这个范式被称为过程式编程，位于大多数人使用 PowerShell
    编写脚本与像 C++ 和 Java 这样的全面面向对象编程语言之间。函数式编程是另一种范式，具有声明式风格。
- en: Imperative, Declarative, Procedural, and Functional
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式、声明式、过程式和函数式
- en: I’m throwing around a lot of new words here, so it’s worth quickly explaining
    what they mean.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里抛出了一些新词，因此值得快速解释一下它们的含义。
- en: '**Imperative** languages are *recipe* languages such as Python and PowerShell.
    Each step in the script or program tells the computer to do something, and often,
    how to do that thing. This is usually the first style of programming that people
    learn; often, it is the only style they learn.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令式**语言是像 Python 和 PowerShell 这样的*配方*语言。脚本或程序中的每一步都会告诉计算机做某事，并且通常会指定如何去做。这通常是人们学习的第一种编程风格；并且它通常是他们学到的唯一一种风格。'
- en: '`<Heading>`, but it is up to the browser that is interpreting the HTML to decide
    what a `<Heading>` looks like.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Heading>`，但它的样式由解释 HTML 的浏览器决定。'
- en: '**Procedural** programming is the style of programming we’re going to be examining
    in this chapter: writing procedures, which are called functions in PowerShell,
    and calling them from within our script. The overall programming style is still
    imperative.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程式**编程是我们在本章中将要探讨的编程风格：编写过程，这些过程在 PowerShell 中被称为函数，并且从脚本中调用它们。总体编程风格依然是命令式的。'
- en: '**Functional** programming is a declarative style of programming, where we
    create functions on objects and then call the functions. Pure functional programming
    is often described as declarative programming. Functional programming in PowerShell
    is not impossible, but it is pretty advanced, so we’re not going to cover it in
    this book. If you are really interested in having a look at it, then visit Chris
    Kuech’s GitHub page at [https://github.com/chriskuech/functional](https://github.com/chriskuech/functional)
    and have a play with his **functional** module for PowerShell.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式**编程是一种声明式的编程风格，在这种风格中，我们在对象上创建函数，然后调用这些函数。纯粹的函数式编程通常被描述为声明式编程。PowerShell
    中的函数式编程并不是不可能，但它相当高级，因此我们在本书中不打算讲解。如果你真的有兴趣了解一下，可以访问 Chris Kuech 的 GitHub 页面：[https://github.com/chriskuech/functional](https://github.com/chriskuech/functional)，并试用他为
    PowerShell 提供的**函数式**模块。'
- en: 'Let’s have a look at a function. In the PowerShell console, try this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下一个函数。在 PowerShell 控制台中，试试这个：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, type `get-square`, followed by a number, like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入 `get-square`，然后输入一个数字，像这样：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As if by magic, the square of our number is returned. While the console is open,
    we can use `get-square` as often as we like.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像魔法一样，我们的数字的平方值被返回了。只要控制台保持打开，我们可以随时使用`get-square`。
- en: What have we done there? Well, we’ve taken some code, `{$a * $a}`, and given
    it a label (or name), `get-square`, by using the `function` keyword. We’ve also
    told it to expect a variable, `$a`, by placing the variable in brackets directly
    after the name. Whenever we use the name of the function, the code runs on the
    object we’re passing – in this case, the integer `23`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了什么呢？嗯，我们取了一些代码，`{$a * $a}`，并通过使用 `function` 关键字给它一个标签（或名称）`get-square`。我们还告诉它，期望一个变量`$a`，通过将变量放在名称后面紧跟的括号中。每当我们使用函数名时，代码就在我们传递的对象上运行——在这个例子中是整数
    `23`。
- en: 'It’s pretty rare we would define and use a function in the console like that.
    Instead, I usually incorporate functions into my scripts. Let’s do that now. Open
    a new PowerShell file in VS Code so we can carry on playing. Let’s do something
    a little more adventurous. Let’s create a function that gets the square root of
    a number by approximation. Type this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在控制台中定义并使用函数的情况相对较少。相反，我通常将函数整合到我的脚本中。现在让我们来做这个。打开一个新的 PowerShell 文件，在 VS
    Code 中继续操作。让我们做一些更有挑战性的事情。我们来创建一个通过近似计算平方根的函数。输入以下内容：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'All this code does is start at `1`, and keep multiplying numbers by themselves
    until it gets to a number that is larger than the number we originally pass to
    the function – in this case, `785692`. It’s pretty rough and ready. If we run
    this code, we find that the approximate square root of 785,692 is 886, pretty
    close to the actual square root of 886.392 but not exact. It demonstrates one
    of the strengths of machines: fast repetition. It’s gone through that `while`
    loop 887 times.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用只是从`1`开始，不断将数字与自身相乘，直到得到一个大于我们最初传给函数的数字——在这种情况下是`785692`。它非常简单且直接。如果我们运行这段代码，我们会发现`785692`的近似平方根是886，离实际的平方根886.392非常接近，但并不完全准确。这展示了机器的一个优势：快速重复。它已经执行了887次`while`循环。
- en: Notice the `param()` block that we’ve opened on the second line. It’s the same
    as the `param()` blocks we’ve been using already. In fact, we can turn this function
    into an `cmdletbinding()` attribute, and then we could use all the common parameters
    with `Get-RoughRoot`. We can do all the same things with the `param()` block in
    a function as we can do with the `param()` block in a script.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在第二行开启的`param()`块。它与我们之前使用的`param()`块是一样的。事实上，我们可以将这个函数转变为一个`cmdletbinding()`属性，这样就可以在`Get-RoughRoot`中使用所有常用参数。我们可以像在脚本中使用`param()`块一样在函数中使用`param()`块。
- en: Activity 1
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 1
- en: If we type `65378 | Get-RoughRoot` at the end of our script and run it, what’s
    going to happen? Why is that, and how could we make that line work?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在脚本末尾输入`65378 | Get-RoughRoot`并运行，结果会怎样？为什么会这样，我们该如何使这行代码有效？
- en: Once we’ve created our function within a script, we can call it as many times
    as we like, just by referring to the name of the function and providing values
    for the parameters. Yes, there is a really easy way to get an accurate square
    root with PowerShell, and it’s much shorter, but where’s the fun in that?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在脚本中创建了函数，就可以通过引用函数名称并提供参数值来多次调用它。是的，PowerShell 中确实有一种非常简单的方式来得到精确的平方根，而且代码要短得多，但这样做有什么乐趣呢？
- en: What makes a function?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是函数？
- en: 'To create functions, we need the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建函数需要以下内容：
- en: The keyword, `function`, at the start.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字`function`，位于开始位置。
- en: A descriptive and meaningful name. It’s best to follow the PowerShell naming
    conventions and use an approved verb in a verb-noun pair, especially if the function
    is going to be shared with others.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个描述性且有意义的名称。最好遵循 PowerShell 的命名约定，并使用已批准的动词-名词搭配，尤其是当这个函数需要与他人共享时。
- en: A set of PowerShell cmdlets in braces, `{}`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组 PowerShell cmdlet，位于大括号`{}`中。
- en: We can include a set of parameters, either within a `param()` block after we’ve
    opened the braces, or we can include them in brackets appended to the name. It’s
    preferable to use the `param()` block, especially if we’ve got multiple parameters
    or if we want to add statements to the parameters – for instance, to control how
    they accept pipeline input, or what types they accept.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`param()`块中包含一组参数，放在大括号后面，或者将它们包含在方括号中并附加到名称后面。更推荐使用`param()`块，特别是当我们有多个参数时，或者如果我们希望向参数中添加语句——例如，控制它们如何接受管道输入，或者它们接受什么类型的输入。
- en: When we’re including functions in scripts, it is important to remember that
    the script is read by the computer from top to bottom, rather than ingested whole
    before executing. It is important, therefore, that we have defined our functions
    before we call them in the script. It’s usual to define all the functions in a
    script at the top, after the parameters.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在脚本中包含函数时，必须记住，计算机是从上到下读取脚本，而不是先读取整个脚本再执行。因此，我们必须在调用函数之前先定义它们。在脚本中通常会把所有函数的定义放在最上面，参数之后。
- en: 'Each function consists of four statement blocks: `begin`, `process`, `end`,
    and `clean`. We don’t need to include these statements for our function to work,
    but we need to be aware of how PowerShell will read our code if we don’t include
    them.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数由四个语句块组成：`begin`、`process`、`end` 和 `clean`。虽然我们不需要包含这些语句块来使函数正常工作，但如果不包含它们，我们需要了解
    PowerShell 如何解析我们的代码。
- en: The `begin` statement block is for statements that set up the function and will
    only run once when the function is called before the function does anything with
    its input. Similarly, the `end` block will only run once when the function is
    called. The `process` block will run for each object in the pipeline that is fed
    to the function, which is why we need to include it when accepting multiple objects
    from the pipeline, because if no statement blocks are specified, then PowerShell
    assigns all statements to the `end` block.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin` 语句块用于设置函数的语句，并且只在函数被调用时执行一次，且在函数对输入进行任何操作之前执行。类似地，`end` 语句块也只会在函数调用时执行一次。`process`
    语句块会对传递给函数的管道中的每个对象执行，因此当从管道接受多个对象时，我们需要包含它，因为如果没有指定语句块，PowerShell 会将所有语句分配给 `end`
    块。'
- en: The `clean` statement block was introduced in PowerShell 7.3\. It is similar
    to the `end` statement block, but it will always run, even if the function terminates
    due to an error or if the function is deliberately halted by pressing *Ctrl* +
    *C*, whereas the `end` block will not. The other difference is that the `end`
    block can output objects to the pipeline, and `clean` cannot.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`clean` 语句块是在 PowerShell 7.3 中引入的。它类似于 `end` 语句块，但无论函数是因错误终止还是用户按下 *Ctrl* +
    *C* 强制停止，`clean` 块都会始终执行，而 `end` 块则不会。另一个区别是，`end` 块可以将对象输出到管道，而 `clean` 块不能。'
- en: 'Let’s see how this looks in actual code. In the following figure, we’ve added
    `begin`, `end`, `process`, and `clean` statement blocks to our `Get-RoughRoot`
    function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际代码中是如何实现的。在以下图中，我们为 `Get-RoughRoot` 函数添加了 `begin`、`end`、`process` 和 `clean`
    语句块：
- en: '![Figure 9.1 – Begin, process, end, and clean statement blocks](img/B17600_09_001.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – Begin、process、end 和 clean 语句块](img/B17600_09_001.jpg)'
- en: Figure 9.1 – Begin, process, end, and clean statement blocks
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – Begin、process、end 和 clean 语句块
- en: The `begin` statement on line `12` contains a `Write-Output` cmdlet to display
    the value that is currently held in the `-number` parameter. We can see from the
    output at the bottom that there is no value held in this parameter when the `begin`
    block runs. The `process` block on line `15` then runs and feeds the current value
    of `-number` to the pipeline, and repeats for as many values of `-number` as there
    are in the pipeline. The `end` block on line `24` then runs once, and can only
    see the final value passed by the `-number` parameter. Finally, the `clean` block
    executes on line `28`. We can see that it produces no output at all, although
    it does complete successfully. If you don’t believe me, try it – write a line
    of code that can’t run, such as `write-rubbish "here is some rubbish"`. There
    will be a whole load of red text as PowerShell fails to execute it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第 `12` 行的 `begin` 语句块包含一个 `Write-Output` cmdlet，用于显示当前在 `-number` 参数中保存的值。从底部的输出可以看到，当
    `begin` 块运行时，`-number` 参数中并没有保存任何值。接着第 `15` 行的 `process` 语句块运行，并将当前的 `-number`
    值传递到管道中，且会对管道中每个 `-number` 的值进行重复处理。然后，第 `24` 行的 `end` 语句块执行一次，只能看到 `-number`
    参数传递的最终值。最后，第 `28` 行的 `clean` 块执行。我们可以看到它没有任何输出，但成功执行。如果你不相信我，可以试试——写一行无法运行的代码，比如
    `write-rubbish "here is some rubbish"`。这时 PowerShell 会报错，输出一堆红色的文本。
- en: 'There is also an important keyword to be aware of: `return`. The `return` keyword
    ends the current iteration of the block that is running. Let’s see what happens
    when we use it. Here is the code for the `Get-RoughRoot` function, with an `if`
    statement in the `process` block that returns the `pop` string if the original
    number is less than 10:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个需要注意的重要关键字：`return`。`return` 关键字用于结束当前正在执行的语句块的迭代。让我们看看使用它时会发生什么。以下是 `Get-RoughRoot`
    函数的代码，在 `process` 块中添加了一个 `if` 语句，如果原始数字小于 10，则返回 `pop` 字符串：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s now pass a number less than 10 in our pipeline, like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在管道中传递一个小于 10 的数字，如下所示：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will get the output in the following figure:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下图中看到输出：
- en: '![Figure 9.2 – Using the return keyword](img/B17600_09_002.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 使用 return 关键字](img/B17600_09_002.jpg)'
- en: Figure 9.2 – Using the return keyword
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 使用 return 关键字
- en: We can see that the rough roots of the two large numbers are returned, but the
    process block has terminated early when fed a number less than 10.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到两个大数字的粗略根被返回，但当输入一个小于 10 的数字时，进程块提前终止。
- en: The `return` keyword has returned the value it has been assigned (`pop`), but
    that is purely optional – we don’t need to assign a value to `return`. It’s worth
    noting that this is slightly confusing for those of us who are familiar with other
    languages. For example, in Python, the `return` statement is used to supply the
    result of the function. In both Python and PowerShell, `return` statements work
    in very similar ways but the intention behind them is different; PowerShell will
    return the output of the function without the `return` keyword, whereas Python
    will not. For both Python and PowerShell, `return` will stop the function at the
    point it is used.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`return` 关键字返回了它所分配的值（`pop`），但这完全是可选的——我们不需要给 `return` 分配一个值。值得注意的是，对于那些熟悉其他语言的人来说，这一点可能会有些困惑。例如，在
    Python 中，`return` 语句用于提供函数的结果。在 Python 和 PowerShell 中，`return` 语句的工作方式非常相似，但它们背后的意图不同；PowerShell
    会在没有 `return` 关键字的情况下返回函数的输出，而 Python 则不会。对于 Python 和 PowerShell，两者的 `return`
    都会在使用的地方停止函数的执行。'
- en: Basic and advanced functions
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本函数和高级函数
- en: Most of the functions I write within scripts are basic functions, but we can
    make a function behave like a cmdlet by using the `CmdletBinding` attribute. This
    gives us access to a range of behaviors that we see in cmdlets, such as the `-whatif`
    and `-confirm` parameters. It also gives us access to advanced methods such as
    `WriteCommandDetail` and `WriteError`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我在脚本中编写的大多数函数都是基本函数，但我们可以通过使用 `CmdletBinding` 特性使函数表现得像一个 Cmdlet。这让我们能够访问 Cmdlet
    中看到的一系列行为，比如 `-whatif` 和 `-confirm` 参数。它还让我们能够访问像 `WriteCommandDetail` 和 `WriteError`
    这样的高级方法。
- en: Function parameters
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数
- en: As we’ve mentioned, parameters for functions work the same way as parameters
    in scripts, but it’s worth recapping them here.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所提到的，函数的参数和脚本中的参数工作原理相同，但值得在这里重新回顾一下。
- en: Types of parameters
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数类型
- en: 'There are four types of parameters we can use with functions (and scripts!):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在函数（以及脚本中！）使用四种类型的参数：
- en: Named parameters
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名参数
- en: Switch parameters
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Switch 参数
- en: Positional parameters
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置参数
- en: Dynamic parameters.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态参数
- en: Let’s take a closer look.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看。
- en: Named parameters
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命名参数
- en: 'Named parameters are the parameters we’ve been working with, where we supply
    a variable that is used as the parameter’s name, like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数是我们一直在使用的参数，我们提供一个变量，作为参数的名称，像这样：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The name of that parameter, whether it is in a function or a script, is `-number`.
    We can use the `$number` variable anywhere within our function, and it will have
    the value supplied in the parameter. As we saw in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162),
    *Writing Our First Script – Turning Simple Cmdlets into Reusable Code*, we can
    set a default value for a parameter like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该参数的名称，无论是在函数还是脚本中，都是 `-number`。我们可以在函数的任何地方使用 `$number` 变量，它将具有在参数中提供的值。正如我们在[*第8章*](B17600_08.xhtml#_idTextAnchor162)中所看到的，*编写我们的第一个脚本——将简单的
    Cmdlet 转换为可重用的代码*，我们可以像这样为参数设置默认值：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also specify the type of the parameter by supplying a type value in
    square brackets before the variable: `[int]$number`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在变量前用方括号提供类型值来指定参数的类型：`[int]$number`。
- en: Switch parameters
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Switch 参数
- en: 'Switch parameters don’t require a value, they are simply on or off. If we supply
    the parameter to the function, then they are on; if they’re not supplied, then
    they are off. We specify the type of the parameter as `[switch]`, like this: `[switch]$heads`.
    We can test for the presence of the switch in our function with an `if` statement,
    like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Switch 参数不需要值，它们只是开或关。如果我们为函数提供了参数，则表示开；如果没有提供，则表示关。我们将参数的类型指定为 `[switch]`，像这样：`[switch]$heads`。我们可以在函数中使用
    `if` 语句来测试开关是否存在，像这样：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We don’t need the `.ispresent` property, we could just type `if ($heads)`, but
    I think that’s less clear. We could also use the `if ($heads -eq $true)` construction,
    which we may see in older articles on the web, but that is not Microsoft’s preferred
    method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要 `.ispresent` 属性，可以直接输入 `if ($heads)`，但我认为那样不够清晰。我们也可以使用 `if ($heads -eq
    $true)` 结构，这在旧的网络文章中可能会看到，但那不是微软推荐的方法。
- en: Positional parameters
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 位置参数
- en: 'These parameters make use of the `$Args` automatic variable instead of using
    a `param()` block. This parameter exists for every basic function and allows us
    to create unnamed parameters, like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数利用了`$Args`自动变量，而不是使用`param()`块。这个参数存在于每个基本函数中，并允许我们创建未命名的参数，像这样：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This means we can supply parameters like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以像这样提供参数：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can see the result in the following figure:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下图中看到结果：
- en: '![Figure 9.3 – Using positional parameters](img/B17600_09_003.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 使用位置参数](img/B17600_09_003.jpg)'
- en: Figure 9.3 – Using positional parameters
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 使用位置参数
- en: We can see the function has correctly assigned the values we supplied. The `$Args`
    parameter is an array.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，函数已经正确地赋值了我们提供的参数。`$Args`参数是一个数组。
- en: 'Note that if we use a `param()` block, then that will override this functionality;
    it won’t work, as we will need to specify positional parameters. By default, parameters
    are positional, in the order that the parameters are written down, so this will
    work:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们使用`param()`块，则它将覆盖此功能；它将无法正常工作，因为我们需要指定位置参数。默认情况下，参数是位置性的，按照参数的书写顺序排列，因此这将是有效的：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The value `2` will be assigned to `$a`, and the value `4` will be assigned to
    `$b`. If it is important that a parameter be at a specific position, however,
    we should use the `position` attribute, discussed in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 值`2`将被赋值给`$a`，值`4`将被赋值给`$b`。然而，如果某个参数必须位于特定位置，我们应该使用`position`属性，具体内容将在下一节中讨论。
- en: 'The `$Args` automatic variable can also be used to splat parameters into a
    function – review [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell
    Variables and Data Structures*, for more about splatting. Let’s see how that works
    in the following figure:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`$Args`自动变量还可以用于将参数传递到函数中——有关 splatting 的更多信息，请查看[*第 4 章*](B17600_04.xhtml#_idTextAnchor071)，*PowerShell
    变量与数据结构*。让我们通过下图来看一下它是如何工作的：'
- en: '![Figure 9.4 – Splatting the $Args variable](img/B17600_09_004.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 将 `$Args` 变量传递到函数中](img/B17600_09_004.jpg)'
- en: Figure 9.4 – Splatting the $Args variable
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 将 `$Args` 变量传递到函数中
- en: 'In the first line, we are creating a simple function called `Get-Fifteen20`.
    It runs `Get-Random`. We tell it to accept arguments from the command line into
    an array called `@Args` (note the array symbol, `@`). After that, we tell it to
    output the value of the `$Args` automatic variable. From the output, we can see
    we first get a random number between 15 and 20 (`19`), then we get the contents
    of the `$Args` variable. We can see it is an array of four objects: `-minimum`,
    `15`, `-maximum`, and `20`. These are supplied in sequence to the `Get-Random`
    cmdlet in the function, giving us an effective PowerShell statement of `Get-Random
    -minimum 15 -maximum 20`, which works just fine.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们创建了一个名为`Get-Fifteen20`的简单函数。它运行`Get-Random`。我们告诉它接受来自命令行的参数，并将这些参数存入一个名为`@Args`的数组中（请注意数组符号`@`）。之后，我们告诉它输出`$Args`自动变量的值。从输出结果来看，首先我们得到一个介于15和20之间的随机数（`19`），然后我们看到`$Args`变量的内容。它是一个包含四个对象的数组：`-minimum`、`15`、`-maximum`和`20`。这些参数顺序传递给函数中的`Get-Random`
    cmdlet，形成有效的 PowerShell 语句`Get-Random -minimum 15 -maximum 20`，该语句运行正常。
- en: Activity 2
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 2
- en: Why doesn’t `Get-Fifteen20 15` `20` work?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`Get-Fifteen20 15` `20`不起作用？
- en: Dynamic parameters
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动态参数
- en: Dynamic parameters are only available if a specified condition is true. They
    are not defined in the `param()` block, but in a separate `DynamicParam{}` block
    – note this uses braces, not brackets. Dynamic parameters are quite an advanced
    topic and should only be used if absolutely necessary, so we’re not going to spend
    much time on them here. A good example of how they work can be found in the `Get-ChildItem`
    cmdlet. `Get-ChildItem` can be used with any PSProvider – we covered PSProviders
    in [*Chapter 6*](B17600_06.xhtml#_idTextAnchor117), *PowerShell and Files – Reading,
    Writing, and Manipulating Data*. Depending on which PSProvider we are using, different
    parameters of `Get-ChildItem` are available. For instance, if we are in the `FileSystem`
    provider, we have access to parameters such as `-File` and `-Hidden`. If we are
    using the `Certificate` provider, then we can’t use those parameters but we have
    parameters such as `-DnsName` and `-``SslServerAuthentication` instead.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 动态参数仅在指定的条件为真时可用。它们不是在`param()`块中定义的，而是在单独的`DynamicParam{}`块中定义——请注意，这里使用的是大括号，而不是方括号。动态参数是一个相对高级的话题，只有在绝对必要时才应使用，因此我们在这里不会花太多时间讨论它们。关于它们如何工作的一个很好的例子可以在`Get-ChildItem`命令中找到。`Get-ChildItem`可以与任何PSProvider一起使用——我们在[*第6章*](B17600_06.xhtml#_idTextAnchor117)中讨论过PSProvider，*PowerShell与文件操作——读取、写入和处理数据*。根据我们使用的PSProvider不同，`Get-ChildItem`的可用参数也会不同。例如，如果我们使用的是`FileSystem`提供者，我们可以使用诸如`-File`和`-Hidden`等参数。如果我们使用的是`Certificate`提供者，那么这些参数将不可用，取而代之的是`-DnsName`和`-SslServerAuthentication`等参数。
- en: Now we’ve covered the types of parameters, let’s take a look at some of the
    attributes we can apply to our parameters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了参数的类型，让我们来看看我们可以应用于参数的一些属性。
- en: Parameter attributes
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数属性
- en: 'Attributes are optional arguments that we can use to control how parameters
    behave – whether they are mandatory or accept pipeline input, for example. To
    use attributes, we must start each parameter with the `Parameter()` attribute,
    which looks like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是可选的参数，我们可以用它们来控制参数的行为——例如，是否是必选的，或者是否接受管道输入。要使用属性，我们必须以`Parameter()`属性开始每个参数，它的形式如下：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Parameter()` attribute takes multiple arguments, but we must separate them
    with a comma (`,`). Let’s go through the more common parameters.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parameter()`属性接受多个参数，但我们必须用逗号（`,`）将它们分开。让我们来看一下更常见的几个参数。'
- en: CmdletBinding
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CmdletBinding
- en: The `CmdletBinding` attribute makes the function behave like a cmdlet. If we
    use this attribute within a function, we get access to the common parameters such
    as `-whatif` and `-confirm`. This removes access to the `$Args` automatic variable
    for that function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`CmdletBinding`属性使函数表现得像一个cmdlet。如果我们在函数中使用此属性，我们可以访问常见的参数，如`-whatif`和`-confirm`。这将移除该函数对`$Args`自动变量的访问。'
- en: Mandatory
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 必选
- en: 'As we saw in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *Writing Our
    First Script – Turning Simple Cmdlets into Reusable Code*, we can use the `Mandatory`
    argument to ensure a value is provided for a parameter, and the `HelpMessage`
    argument to provide help for that mandatory parameter:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第8章*](B17600_08.xhtml#_idTextAnchor162)中看到的，*编写我们的第一个脚本——将简单的cmdlet转化为可重用的代码*，我们可以使用`Mandatory`参数来确保为某个参数提供值，使用`HelpMessage`参数来为该必选参数提供帮助信息：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This means that at least one integer must be supplied with the `-number` parameter,
    and a help message can be accessed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着必须至少为`-number`参数提供一个整数，并且可以访问帮助信息。
- en: Position
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Position
- en: 'The `Position` argument allows a parameter to be passed without explicitly
    naming it and can specify at which position it must be supplied:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Position`参数允许在不明确指定名称的情况下传递参数，并且可以指定参数必须提供的位置：'
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code tells us that the first value passed without a preceding
    parameter name will be applied to the `-number` parameter. Two things to note
    are that named parameters are not counted, and that numbering starts at `0`, so
    the second position is `Position=1`. Note that if we’re using a `param()` block,
    the `$Args` functionality we’ve just covered won’t work, and we’ll not be able
    to splat parameters into a cmdlet within our function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码告诉我们，未指定名称的第一个传递值将应用于`-number`参数。有两点需要注意：第一，命名参数不计入其内，第二，编号是从`0`开始的，因此第二个位置为`Position=1`。请注意，如果我们使用的是`param()`块，我们之前讨论的`$Args`功能将无法使用，我们将无法在函数内将参数传递给cmdlet。
- en: If we don’t use a `Position` argument, then all the parameters will be assigned
    positions in the order they are declared in the `param()` block, but we shouldn’t
    rely on this working exactly as we expect. If we want a parameter to be positional,
    then we should declare it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用`Position`参数，那么所有参数将按照在`param()`块中声明的顺序分配位置，但我们不应依赖这种顺序完全按预期工作。如果我们希望参数是位置参数，那么我们应该明确声明它。
- en: ParameterSetName
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ParameterSetName
- en: We can use the `ParameterSetName` argument to define parameters that are only
    present for particular parameter sets. If `ParameterSetName` is not supplied,
    a parameter belongs to all parameter sets. I adhere to the philosophy that a function
    should do one thing, and so I’ve never really found the need for parameter sets.
    Some people, however, like to write Swiss Army knife functions that do lots of
    things, and so parameter sets are useful for them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ParameterSetName`参数来定义仅在特定参数集存在的参数。如果未提供`ParameterSetName`，则该参数属于所有参数集。我坚持认为一个函数应该做一件事，因此我从未真正需要参数集。然而，有些人喜欢编写多功能的“瑞士军刀”函数，因此参数集对他们来说是有用的。
- en: ValueFromPipeline
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ValueFromPipeline
- en: We’ve used this already in this chapter – it’s necessary to allow a function
    parameter to accept an object from the pipeline. The parameter accepts the whole
    object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经使用过这个属性——它是允许函数参数接受管道中的整个对象的必要条件。
- en: ValueFromPipelineByPropertyName
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ValueFromPipelineByPropertyName
- en: If we only want the parameter to accept a property of an object (for instance,
    a name), then we can use this argument. If the object in the pipeline has a name
    property, `$object.name`, then that will be used for this parameter. The object
    property must match the parameter name; otherwise, it won’t get passed. For instance,
    if we pass a string through the pipeline to a function with a `-length` parameter
    that accepts pipeline values by property name, then the parameter will be populated
    with the length of the string, not the actual string. If the parameter is called
    `-stringlength`, then it will be empty because the string doesn’t have a `stringlength`
    property.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只希望参数接受一个对象的属性（例如，名称），那么我们可以使用这个参数。如果管道中的对象有一个名称属性（例如，`$object.name`），那么该属性将被用作该参数。对象的属性名必须与参数名匹配；否则，参数不会传递。如果我们将一个字符串通过管道传递给一个接受管道值的`-length`参数，那么该参数将被填充为字符串的长度，而不是实际的字符串。如果参数名为`-stringlength`，那么它将为空，因为字符串没有`stringlength`属性。
- en: ValueFromRemainingArguments
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ValueFromRemainingArguments
- en: We can use this parameter to hold an indeterminate number of arguments that
    might be passed to a function, as an array. We can then access those arguments
    by using the index of their position in the array. This is useful in advanced
    functions, where we don’t have access to the `$Args` automatic variable, and we
    want to capture an unknown number of arguments.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个参数来保存一个不确定数量的参数，作为数组传递给函数。然后，我们可以通过数组中位置的索引访问这些参数。这在高级函数中非常有用，在这些函数中我们无法访问`$Args`自动变量，且我们希望捕获不确定数量的参数。
- en: HelpMessage
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: HelpMessage
- en: As we’ve seen already, this attribute can be used to provide a helpful message
    for mandatory parameters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们已经看到的，这个属性可以用来为必填参数提供一个有帮助的提示信息。
- en: Alias
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 别名
- en: I’m including this here for the sake of completeness, but I think I’ve made
    my views on aliases quite plain. They can occasionally be useful, but they also
    lead to confusion and make code less readable. It is possible, however, to use
    the `Alias` attribute to provide an alias for a parameter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其包括在这里是为了完整性，但我认为我已经明确表达了关于别名的看法。别名有时可能有用，但它们也会导致混淆，并使代码更难以阅读。不过，确实可以使用`Alias`属性为参数提供别名。
- en: SupportsWildcards
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SupportsWildcards
- en: We can use this parameter if we want a parameter to accept wildcards. Note that
    this doesn’t mean the function supports wildcards – we still need to write code
    in our function that can handle wildcard input.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望参数接受通配符，则可以使用这个参数。请注意，这并不意味着函数支持通配符——我们仍然需要在函数中编写能够处理通配符输入的代码。
- en: Argument completion attributes
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数完成属性
- en: There are two argument completion attributes that allow a user to complete the
    values of a parameter using the *Tab* key. These are similar to the `ValidateSet`
    attribute. We’re not going to cover them in this book, but it’s useful to know
    that it is something we can do if we want to.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个参数完成属性允许用户通过*Tab*键完成参数值。这些属性类似于`ValidateSet`属性。我们在本书中不会详细讨论它们，但知道如果需要，我们可以使用它们。
- en: Validation attributes
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 验证属性
- en: 'There are currently 14 attributes that we can use to validate parameters and
    the values supplied for them. We can validate that a value is null, that a value
    follows a specific pattern such as a credit card number or IP address, and that
    a value is of a certain length or falls in a certain range. We discovered the
    `ValidateSet` attribute in [*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *Writing
    Our First Script – Turning Simple Cmdlets into Reusable Code*. It works like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有14个属性可以用于验证参数及其提供的值。我们可以验证一个值是否为null，验证一个值是否符合特定模式（如信用卡号或IP地址），以及验证一个值是否具有特定的长度或是否在某个范围内。我们在[*第8章*](B17600_08.xhtml#_idTextAnchor162)中发现了`ValidateSet`属性，*编写我们的第一个脚本—将简单的Cmdlet转化为可重用代码*。它的工作方式如下：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will only accept the string if it appears in the array listed in `ValidateSet`.
    Note that validation attributes sit outside the `Parameter()` attribute.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当字符串出现在`ValidateSet`列出的数组中时，才会接受该字符串。请注意，验证属性位于`Parameter()`属性之外。
- en: 'While there are plenty more aspects of parameters we could cover, that’s enough
    for now. Let’s look at a specialized type of function: filters.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以覆盖更多关于参数的方面，但现在就先到这里吧。让我们来看一个专门类型的函数：过滤器。
- en: Filters
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器
- en: 'A filter is a specialized function that automatically runs on all objects in
    the pipeline. A filter is similar to a function with just a `process{}` statement
    block. We can use them like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器是一个专门的函数，自动在管道中的所有对象上运行。过滤器类似于一个只包含`process{}`语句块的函数。我们可以这样使用它们：
- en: '![Figure 9.5 – Using a filter](img/B17600_09_005.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 使用过滤器](img/B17600_09_005.jpg)'
- en: Figure 9.5 – Using a filter
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 使用过滤器
- en: Instead of using the `function` keyword, we’ve used `filter`. We’ve called our
    filter `square` and defined it as multiplying the pipeline object by itself. Now
    we can feed a value to the filter via the pipeline, and get an output. Notice
    that we can’t use it like a function; `square 36` won’t work as there’s nothing
    in the pipeline for the filter to work on.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用`function`关键字，而是使用了`filter`。我们把过滤器命名为`square`，并定义它为将管道对象与自身相乘。现在我们可以通过管道将一个值传递给过滤器，并获得输出。请注意，我们不能像使用函数那样使用它；`square
    36`是无效的，因为管道中没有任何东西可以供过滤器处理。
- en: 'Before we can really get on with using functions, though, we need to talk about
    an important concept: scope.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们真正开始使用函数之前，我们需要讨论一个重要的概念：作用域。
- en: The concept of scope
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围的概念
- en: 'PowerShell uses the concept of scope to protect variables, functions, PSDrives,
    and aliases from inadvertent change by limiting how they may be accessed and modified.
    Let’s demonstrate:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell使用作用域的概念来保护变量、函数、PSDrives和别名，避免它们被无意间更改，通过限制它们的访问和修改方式。让我们来演示一下：
- en: 'Create a variable and set its value:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量并设置其值：
- en: '[PRE17]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a function:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数：
- en: '[PRE18]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: $ScopeTest
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ScopeTest
- en: '[PRE19]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run our function:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行我们的函数：
- en: '[PRE20]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: $ScopeTest
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ScopeTest
- en: '[PRE21]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'PowerShell has the following types of scopes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell有以下几种作用域类型：
- en: '`$scopeTest` variable we just used. Anything that is defined in the global
    scope is available everywhere inside the current session.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们刚才使用的`$scopeTest`变量。任何在全局作用域中定义的内容在当前会话内的任何地方都可以使用。
- en: '`Set-ScopeTest` function, there is a different scope to the global scope. When
    we changed the `$SetScope` variable inside our function, it only changed in the
    local scope of the function, not the global scope. The local scope is relative
    to other scopes, not a predefined scope, so it may refer to the global scope,
    a script scope, or a child of the global or script scopes. We can create many
    nested local scopes. When we run a script or a function, we are creating a new
    local scope.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Set-ScopeTest`函数中，有一个与全局作用域不同的作用域。当我们在函数内部更改`$SetScope`变量时，它只会在函数的本地作用域中更改，而不会影响全局作用域。本地作用域相对于其他作用域，不是预定义的作用域，因此它可能指向全局作用域、脚本作用域或全局或脚本作用域的子作用域。我们可以创建多个嵌套的本地作用域。当我们运行脚本或函数时，我们就创建了一个新的本地作用域。
- en: '**Script**: This is the scope that is created when we run a script. Only the
    statements in the script run in the script scope, and those statements see the
    script scope as the local scope. Each script that is running has its own script
    scope; they don’t share objects.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本**：这是我们运行脚本时创建的作用域。只有脚本中的语句在脚本作用域内运行，这些语句将脚本作用域视为本地作用域。每个正在运行的脚本都有自己的脚本作用域；它们不会共享对象。'
- en: Parent and child scopes
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 父作用域和子作用域
- en: 'There is a hierarchy of scopes. A scope that is contained in another scope
    is called a child scope, and the containing scope is called the parent scope.
    The global scope is always the root scope, the parent of all scopes, and other
    scopes are child scopes of the global scope. So, when we ran `Set-ScopeTest` previously,
    we created a local scope for the function that is a child of the global scope.
    The local scope can read the variables of the parent scope, but by default, does
    not change them in the parent scope; it can only change them in its local scope.
    Let’s add a few lines to our `Set-ScopeTest` function to illustrate this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域有层级关系。包含在另一个作用域中的作用域被称为子作用域，包含作用域的作用域则被称为父作用域。全局作用域始终是根作用域，是所有作用域的父作用域，其他作用域都是全局作用域的子作用域。因此，当我们之前运行
    `Set-ScopeTest` 时，我们为该函数创建了一个本地作用域，它是全局作用域的子作用域。该本地作用域可以读取父作用域中的变量，但默认情况下不会更改父作用域中的变量；它只能在本地作用域中更改变量。接下来，让我们在
    `Set-ScopeTest` 函数中添加几行代码来说明这一点：
- en: '![Figure 9.6 – Illustrating parent and child scopes](img/B17600_09_006.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 示意父作用域和子作用域](img/B17600_09_006.jpg)'
- en: Figure 9.6 – Illustrating parent and child scopes
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 示意父作用域和子作用域
- en: The first line we’ve added gets the value of the `$ScopeTest` variable that
    the function inherits from its parent scope (in this case, `10`) and writes it
    to the screen. We then change the value of `$ScopeTest` within the function, as
    before, and output the new value. Next, we’ve got a couple of lines using `Get-Variable`
    that retrieve the value of the `$ScopeTest` variable in the global and local scopes.
    We can see that even within the function, the global value of `$ScopeTest` remains
    `10` – it is only the local instance of `$ScopeTest` that is changed by the function.
    What happens if we want to modify the value of a variable in the parent scope
    with our function, though? Let’s take a look at how we can do that.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的第一行代码获取了函数从其父作用域继承的 `$ScopeTest` 变量的值（在此情况下为 `10`），并将其输出到屏幕。然后我们像之前一样在函数内更改
    `$ScopeTest` 的值，并输出新的值。接着，我们使用 `Get-Variable` 获取全局和本地作用域中 `$ScopeTest` 变量的值。我们可以看到，即使在函数内，`$ScopeTest`
    的全局值仍然是 `10`，只有函数内部的本地实例的值被更改。那么，如果我们想要通过函数修改父作用域中变量的值，该怎么办呢？让我们看看如何实现这一点。
- en: Scope modifiers
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域修饰符
- en: 'Scopes are used for a reason – to protect ourselves from inadvertent changes
    – and we should only step outside the automatic scopes with caution, but sometimes
    we need to do it. PowerShell includes a number of scope modifiers that allow us
    to change the default scope. They include the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域的使用是有原因的——它们可以保护我们避免不小心更改内容——我们应当谨慎地跳出自动作用域，但有时我们确实需要这么做。PowerShell 包含多个作用域修饰符，允许我们更改默认作用域。它们包括以下几种：
- en: '`Global`: This specifies objects in the global scope.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Global`：指定全局作用域中的对象。'
- en: '`Local`: This specifies an object in the current scope.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Local`：指定当前作用域中的对象。'
- en: '`Script`: This specifies an object in the parent script scope, or in the global
    scope if there is no parent script; we’d use this with functions embedded in scripts.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Script`：指定父脚本作用域中的对象，或者如果没有父脚本，则指定全局作用域；我们在脚本中的函数中使用这个修饰符。'
- en: '`Private`: When this is used while creating variables, this prevents child
    scopes from using the object.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Private`：在创建变量时使用该修饰符，可以防止子作用域使用该对象。'
- en: '`<Variable-namespace>` These refer to PSDrive namespaces, such as `env:` and
    `variable:`.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Variable-namespace>` 这些指的是 PSDrive 名称空间，例如 `env:` 和 `variable:`。'
- en: 'There are also a couple of others that we won’t cover here: `workflow:`, which
    is deprecated, and `using:`, which is used with cmdlets such as `Invoke-Command`
    and `Start-Job`. Scripts operate by default in the `script:` scope. Functions
    operate in the `local:` scope by default, even when they are defined in a script.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他的修饰符我们这里不讨论：`workflow:`（已弃用）和 `using:`（用于像 `Invoke-Command` 和 `Start-Job`
    这样的 cmdlet）。脚本默认在 `script:` 作用域中运行。即使在脚本中定义，函数也默认在 `local:` 作用域中运行。
- en: 'We use the scope modifier between the `$` symbol and the variable name, like
    this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `$` 符号和变量名之间使用作用域修饰符，像这样：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will create a variable in the global scope called `ScopeTest` and set its
    value to `10` (remember, the variable name doesn’t have a `$` symbol – we use
    the `$` symbol to refer to the contents of the variable).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `ScopeTest` 的全局作用域变量，并将其值设置为 `10`（记住，变量名没有 `$` 符号——我们使用 `$` 符号来引用变量的内容）。
- en: 'Similarly, we can define the scope of a function like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以像这样定义函数的作用域：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that setting the scope of the function to global doesn’t change where
    the function acts, it changes where it is available. So, a function with a global
    scope doesn’t automatically act on global variables, as we can see here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将函数的作用域设置为全局作用域并不会改变函数的作用方式，而是改变它的可用范围。因此，一个全局作用域的函数并不会自动作用于全局变量，如我们在这里看到的：
- en: '![Figure 9.7 – Global functions and global variables](img/B17600_09_007.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 全局函数和全局变量](img/B17600_09_007.jpg)'
- en: Figure 9.7 – Global functions and global variables
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 全局函数和全局变量
- en: 'We can see the original value of `$ScopeTest` is `10`. We then define a global
    function called `Set-ScopeTest` that sets the value to `15`. Calling the function
    doesn’t change the global value of `$ScopeTest`. To do that, we need to tell the
    function to work on the global variable, not the local version running inside
    the function. We do that in the second command, with the following code: `$Global:ScopeTest
    =` `15`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `$ScopeTest` 的原始值是 `10`。然后我们定义了一个名为 `Set-ScopeTest` 的全局函数，将值设置为 `15`。调用该函数并不会改变
    `$ScopeTest` 的全局值。为了做到这一点，我们需要告诉函数作用于全局变量，而不是在函数内运行的本地版本。我们在第二个命令中通过以下代码来做到这一点：`$Global:ScopeTest
    =` `15`。
- en: As we work through the rest of the book, we’ll see the concept of scope, and
    no doubt be occasionally frustrated by it. Remember that it is there to protect
    us and provide a set of handy guardrails to prevent us from experiencing hilarious
    consequences. We should only step outside the default scope after some thought
    and consideration. We can often avoid this through passing variables as parameters,
    or explicitly writing output from inside our function and storing it as a variable.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的书中，我们会看到作用域的概念，并且无疑会偶尔为它感到沮丧。记住，它的存在是为了保护我们，提供一套有用的护栏，防止我们遇到滑稽的后果。我们应该在一些思考和考虑之后才跳出默认的作用域。我们通常可以通过将变量作为参数传递，或者明确地从函数内部写出输出并将其存储为变量来避免这样做。
- en: 'Now we understand functions, let’s look at their very close relatives: scriptblocks.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了函数，让我们来看一下它们的亲戚：脚本块（scriptblocks）。
- en: Exploring scriptblocks
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索脚本块
- en: 'A scriptblock is a collection of statements inside braces (`{}`) that can be
    used as a single unit. We’ve already used them numerous times: in `Where-Object`
    cmdlets, `if` and `else` statements, `foreach` loops, and earlier in this chapter,
    when we were writing functions. In this section, we are going to look at some
    of the properties of scriptblocks and how we can use them in our code.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本块是大括号（`{}`）内的一组语句，可以作为一个单元使用。我们已经多次使用过它们：在 `Where-Object` cmdlet、`if` 和 `else`
    语句、`foreach` 循环中，以及在本章前面，当我们写函数时。在本节中，我们将看看脚本块的一些属性，以及如何在代码中使用它们。
- en: 'Consider everything we’ve just done on functions. A function consists of the
    `function` keyword, a name, and a scriptblock: a set of statements inside braces.
    We don’t need the keyword to use the scriptblock – the keyword supplies a label
    that we use to call the scriptblock when we need it.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们刚才做过的所有关于函数的内容。一个函数由 `function` 关键字、名称和一个脚本块组成：一组位于大括号内的语句。我们不需要使用关键字来使用脚本块——关键字提供了一个标签，我们用它来调用脚本块，当我们需要时。
- en: 'Scriptblocks return the output of all the statements they contain; this may
    be a single object or an array of objects. We can use the `return` keyword, and
    it works the same as it does for a function: it will exit the scriptblock at that
    point.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本块返回它们包含的所有语句的输出；这可能是一个单一对象或一个对象数组。我们可以使用 `return` 关键字，它的作用和在函数中的作用一样：它会在那一点退出脚本块。
- en: We can create parameters for scriptblocks using a `param()` block, and it will
    accept all the parameter types and attributes that we use with a function. What
    we can’t do is pass parameters outside the braces, as we can with functions, because
    there is no name value to attach them to.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `param()` 块为脚本块创建参数，它将接受我们在函数中使用的所有参数类型和属性。我们不能做的是像函数一样在大括号外传递参数，因为没有名称值将其附加到。
- en: How to run a scriptblock
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何运行脚本块
- en: 'There are many ways to call scriptblocks – lots of cmdlets and statements such
    as `foreach` accept them. Sometimes, however, we want to just run the scriptblock.
    `Invoke-Command` is one way to do it, like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 调用脚本块有很多方法——许多 cmdlet 和语句（如 `foreach`）都接受它们。然而，有时我们只想运行脚本块。`Invoke-Command`
    是一种实现方式，像这样：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This gives us the output `100`. Let’s look at some of the other ways we might
    do it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回输出 `100`。让我们看看其他几种可能的实现方式。
- en: 'Unlike functions, scriptblocks may be stored in variables, like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数不同，脚本块可以存储在变量中，像这样：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we can use the `$square` variable in the following ways:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以以下方式使用`$square`变量：
- en: 'We can pass it as a parameter to `Invoke-Command`, either with the `-ScriptBlock`
    parameter name or not:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将其作为参数传递给`Invoke-Command`，无论是否带有`-ScriptBlock`参数名：
- en: '[PRE26]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using `Get-Member`, we can see that `$square` has a `TypeName` of `System.Management.Automation.ScriptBlock`.
    This type has a method called `invoke()`, which we can use like this:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Get-Member`，我们可以看到`$square`的`TypeName`是`System.Management.Automation.ScriptBlock`。这个类型有一个叫做`invoke()`的方法，我们可以像这样使用它：
- en: '[PRE27]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s say we’ve put a parameter in our scriptblock, like this:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们在脚本块中放了一个参数，像这样：
- en: '[PRE28]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'What we can’t do is just call the variable to run the scriptblock:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不能做的事是直接调用变量来运行脚本块：
- en: '![Figure 9.8 – How not to run a scriptblock](img/B17600_09_008.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 如何不运行脚本块](img/B17600_09_008.jpg)'
- en: Figure 9.8 – How not to run a scriptblock
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 如何不运行脚本块
- en: 'As you can see, if we call the variable, we get the contents of the scriptblock,
    not the output. Instead, we use the call operator (`&`) like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果我们调用这个变量，我们得到的是脚本块的内容，而不是输出。相反，我们使用调用操作符(`&`)来像这样调用：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can leave a space between `&` and `$square` as well, `& $square`, and we
    will often see it written like that.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`&`和`$square`之间留一个空格，写作`& $square`，我们经常会看到这样写。
- en: 'There is one other way: dot sourcing. Instead of the call operator, we can
    use a period (`.`) like this:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一种方法：点源。我们可以使用一个点(`.`)代替调用操作符，像这样：
- en: '[PRE30]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We need to be very careful when we call scriptblocks like this. Using `Invoke-Command`,
    `invoke()` and the call operator all run the scriptblock in a child scope, as
    we would expect. Dot sourcing will run it in the parent scope, as we can see in
    the following figure:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样调用脚本块时，需要非常小心。使用`Invoke-Command`、`invoke()`和调用操作符都会在子作用域中运行脚本块，这正是我们所期望的。点源会在父作用域中运行脚本块，如下图所示：
- en: '![Figure 9.9 – The call operator and dot sourcing](img/B17600_09_009.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 调用操作符和点源](img/B17600_09_009.jpg)'
- en: Figure 9.9 – The call operator and dot sourcing
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 调用操作符和点源
- en: 'In the first line, we’ve defined a variable, `$SbScope`, as the `Global scope!`
    string. We then define a variable, `$ChangeSbScope`, as a scriptblock that sets
    `$SbScope` to `Local scope!` and returns it. When we call `$ChangeSbScope` with
    the call operator, it runs in the local scope and leaves the global value `of
    $SbScope` unchanged: `Global scope!`. However, when we dot source `$ChangeSbScope`,
    we can see that it changes the value of `$SbScope` in the global scope. Be careful.
    Don’t dot source unless you’re absolutely sure that’s what you have to do.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们定义了一个变量`$SbScope`，它的值是`Global scope!`字符串。接着我们定义了一个变量`$ChangeSbScope`，它是一个脚本块，设置`$SbScope`为`Local
    scope!`并返回它。当我们用调用操作符调用`$ChangeSbScope`时，它会在本地作用域内运行，并保持`$SbScope`的全局值`Global
    scope!`不变。然而，当我们使用点源(`dot sourcing`)调用`$ChangeSbScope`时，我们会看到它改变了`$SbScope`的全局作用域值。要小心，除非你非常确定必须这样做，否则不要使用点源。
- en: Lambdas
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda
- en: 'Most programming languages have the concept of a **lambda** – an anonymous
    function, a function without a name. In PowerShell, we have the scriptblock, which
    is a broader concept that includes lambdas. So in Python, we might have a lambda
    statement such as the following, which adds a value to itself:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有**lambda**的概念——匿名函数，即没有名字的函数。在PowerShell中，我们有脚本块，它是一个更广泛的概念，包含了lambda。所以在Python中，我们可能会有如下的lambda语句，它将一个值加到它自身：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And we get the output `40`. In PowerShell, the equivalent lambda, using a scriptblock,
    would be as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们得到输出`40`。在PowerShell中，相应的lambda，使用脚本块，应该如下所示：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: And again, we get `40`. Lambdas in Python are limited to expressions and can’t
    include statements, whereas in PowerShell, we are not so restricted.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 再次地，我们得到`40`。Python中的lambda仅限于表达式，不能包含语句，而在PowerShell中，我们没有这样的限制。
- en: When do we want to use scriptblocks instead of functions? Generally, we use
    scriptblocks for short, simple blocks of code that may only occur a couple of
    times in a script. I often use them in the console as well. If I’m writing a script
    that is going to be used by other people, then anything more than a line or two
    of code would go in a function to improve readability and make sure other people
    know exactly what I was trying to do.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们什么时候需要使用脚本块而不是函数呢？通常情况下，我们使用脚本块来处理简短且简单的代码块，这些代码块在脚本中可能只会出现几次。我也常常在控制台中使用它们。如果我要写一个其他人也会用的脚本，那么任何超过一两行的代码都会放入函数中，以提高可读性，并确保其他人能清楚地知道我在做什么。
- en: The final case for scriptblocks is for people who come to PowerShell knowing
    another language, such as Python. Using scriptblocks as a substitute for lambdas
    allows them to continue writing code in a style they are used to.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于脚本块的最终应用场景，是针对那些已经掌握其他编程语言（如Python）的人。将脚本块用作lambda表达式的替代方案，允许他们继续以自己习惯的风格编写代码。
- en: That’s enough to learn about functions and scriptblocks. Let’s look at a practical
    application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于函数和脚本块的全部内容。接下来，我们来看看一个实际应用。
- en: Let’s do something useful
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们做点有用的事情
- en: When I am writing PowerShell scripts for customers, I like to make sure that
    the script records information about what it is doing and any changes it has made
    in a log file so that I can quickly pinpoint what is going on. I don’t write the
    functionality each time I write a script, however; I just include some saved PowerShell
    snippets in the script that give me a log file function. Let’s think about how
    we might do that now.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当我为客户编写PowerShell脚本时，我喜欢确保脚本能够记录它正在做的事情以及它所做的任何更改到日志文件中，这样我可以快速找到发生了什么情况。然而，每次编写脚本时，我并不会编写这些功能；我只是将一些已保存的PowerShell代码片段包含在脚本中，给我一个日志文件功能。现在，让我们考虑一下如何做到这一点。
- en: First, we need to think about where we create the log file. I use `C:\temp`,
    as that directory is usually where we put things that we don’t want to keep forever,
    and it usually has fairly relaxed permissions. We might want to think about a
    different directory on Linux or macOS, such as `/var/log/`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要考虑将日志文件创建在哪里。我使用`C:\temp`，因为这个目录通常是我们放置不需要永久保存的东西的地方，而且它通常具有较为宽松的权限。对于Linux或macOS，我们可能需要考虑选择不同的目录，例如`/var/log/`。
- en: We also want to create a file that is as easy to read as possible; I write to
    a text file but I use the suffix `.log` so that I know what sort of text file
    it is. The file we create needs to be date-stamped so that we know which file
    relates to which instance the script was run. This means we need to create it
    outside the function, at the script level; otherwise, we’ll create a new file
    every time the function is called.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望创建一个尽可能易于阅读的文件；我写入的是文本文件，但我使用`.log`后缀，这样我就知道它是什么类型的文本文件。我们创建的文件需要带有日期戳，以便知道哪个文件与脚本运行的哪个实例相关。这意味着我们需要在函数外部创建它，在脚本级别创建；否则，每次调用函数时，我们都会创建一个新文件。
- en: Each file entry needs to be time-stamped so we know in what order the events
    in the log occurred, and it also needs to record a string that we can pass from
    outside the function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件条目需要有时间戳，这样我们就能知道日志中事件发生的顺序，同时它还需要记录一个可以从函数外部传递的字符串。
- en: 'It looks like we need two parameters: `$LogFile` and `$LogString`. Let’s start
    writing this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们需要两个参数：`$LogFile`和`$LogString`。让我们开始编写：
- en: Create a new PowerShell file in VS Code; I’m calling mine `Write-Log.ps1`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中创建一个新的PowerShell文件；我将我的文件命名为`Write-Log.ps1`。
- en: 'First, let’s create `$LogFilename`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建`$LogFilename`：
- en: '[PRE33]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we need a descriptive name, such as `Write-Log`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个描述性的名称，例如`Write-Log`：
- en: '[PRE34]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Function Write-Log {
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Function Write-Log {
- en: Param(
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Param(
- en: $logString
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $logString
- en: )
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: '}'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE35]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let’s get onto the functionality. We need a variable that holds a string
    for the current date and time. Here’s another way to do it:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下功能部分。我们需要一个变量，用来存储当前日期和时间的字符串。这里有另一种实现方式：
- en: '[PRE36]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: $LogMessage = "$stamp $Logstring"
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $LogMessage = "$stamp $Logstring"
- en: '[PRE37]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we need to write it to the log file:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将其写入日志文件：
- en: '[PRE38]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And that’s it. Let’s add a line in the script after the function to check that
    it works:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样。让我们在函数后面加一行代码来检查它是否有效：
- en: '[PRE39]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: And let’s run it to see.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后让我们运行它看看效果。
- en: '![Figure 9.10 – Yes it is](img/B17600_09_010.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 – 是的，就是这样](img/B17600_09_010.jpg)'
- en: Figure 9.10 – Yes it is
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 是的，就是这样
- en: 'Here’s my complete code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的完整代码：
- en: '[PRE40]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The function I use for work does a number of other things as well, and we’ll
    be looking at some of them in the next chapter – [*Chapter 10*](B17600_10.xhtml#_idTextAnchor201),
    *Error Handling – Oh No! It’s* *Gone Wrong!*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我用于工作的函数还做了许多其他事情，我们将在下一章中讨论其中一些内容——[*第10章*](B17600_10.xhtml#_idTextAnchor201)，*错误处理——哦不！出错了！*
- en: Activity 3
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 活动3
- en: This function writes a file to a location on the client. If we regularly run
    scripts that make use of it, we’re going to end up with a lot of files cluttering
    things up. How might we go about writing a function that clears up old log files
    when we run the script?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将文件写入客户端的某个位置。如果我们经常运行使用它的脚本，最终会有很多文件堆积起来。那么，我们如何编写一个函数，在运行脚本时清理旧的日志文件呢？
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We’ve done some interesting stuff in this chapter. We considered some fundamental
    principles of software engineering, particularly DRY, and saw how we might apply
    them within PowerShell scripts. We looked in detail at how functions are constructed
    and how they work. We briefly discussed the difference between basic and advanced
    functions.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'We then discussed the four types of parameters we can use with functions: named,
    switch, positional, and dynamic parameters. We also learned about the `$Args`
    automatic variable and saw how we can use that to splat parameters into cmdlets
    in our basic function.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at the many types of attributes we can apply to our parameters
    to control how the script behaves. We concentrated on the more common attributes
    but acknowledged the existence of completion attributes and validation attributes.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at a special type of function – the filter – and saw how
    we could use it to process pipeline objects.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: We then spent some time looking at the concept of scope and saw how this is
    used to protect our environment and keep scripts and functions working in constrained
    areas of memory. We learned about parent and child scopes and the concept of scope
    hierarchy. Finally, we looked at how we could force functions and scripts to work
    outside their default scopes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'We then moved on to scriptblocks and saw how they are related to functions.
    We talked about different ways of calling them, including dot sourcing – a method
    we should use with caution. We then learned how scriptblocks relate to a common
    programming concept: the anonymous function or lambda.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: We covered a fair bit of theory, so we finished the chapter looking at how we
    could construct a function to do something useful that we can apply in many scripts
    – writing to a log file. I hope you found this useful; I know I use it a lot.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to be looking at how to handle errors, both
    in our script and ones we encounter when our script meets the outside world.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For information on the software engineering concepts we covered at the start
    of the chapter: *The Pragmatic Programmer*, 20th Anniversary Edition, David Thomas
    and Andrew Hunt, 2019, Addison Wesley. There’s lots of other really useful stuff
    in there as well.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are lots of help *About* files included in PowerShell on the topics we’ve
    covered in this chapter. It’s worth knowing and reading these ones:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About Functions: [https://learn.microsoft.com/en-us/powershell/ module/microsoft.powershell.core/about/about_functions?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions?view=powershell-7.3'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'About Advanced Functions: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced?view=powershell-7.3)'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About Advanced Function Methods: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_methods?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_methods?view=powershell-7.3)'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '关于高级函数方法: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_methods?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_methods?view=powershell-7.3)'
- en: 'About Advanced Function Parameters: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters?view=powershell-7.3)'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '关于高级函数参数: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters?view=powershell-7.3)'
- en: 'About Advanced Function Argument Completion: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_argument_completion?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_argument_completion?view=powershell-7.3)'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '关于高级函数参数补全: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_argument_completion?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_argument_completion?view=powershell-7.3)'
- en: 'About CmdletBinding: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute?view=powershell-7.3)'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '关于 CmdletBinding: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute?view=powershell-7.3)'
- en: 'About Function Output: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_outputtypeattribute?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_outputtypeattribute?view=powershell-7.3)'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '关于函数输出: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_outputtypeattribute?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_outputtypeattribute?view=powershell-7.3)'
- en: 'About ScriptBlocks: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_script_blocks?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_script_blocks?view=powershell-7.3)'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '关于脚本块: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_script_blocks?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_script_blocks?view=powershell-7.3)'
- en: Exercises
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: What does AHA stand for?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AHA 代表什么？
- en: Why should we be very careful when using dot sourcing?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在使用点来源时需要特别小心？
- en: 'We’ve created a variable called `$ScriptBlock` and populated it with a scriptblock.
    Let’s say we call it like this:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`$ScriptBlock`的变量，并用一个脚本块填充它。假设我们这样调用它：
- en: '[PRE41]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We don’t get the output we expect. Why not?
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们没有得到预期的输出。为什么呢？
- en: What parameter argument might we use to check that our input is a valid IP address?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用什么参数来检查输入是否为有效的 IP 地址？
- en: 'We’ve created a filter, `get-square`, and we’re trying to use it like this:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个过滤器`get-square`，并尝试这样使用它：
- en: '[PRE42]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Why isn’t there any output?
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为什么没有输出？
- en: What are we doing here?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里做了什么？
- en: '[PRE43]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: What’s the main difference between a function and a scriptblock?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数和脚本块之间的主要区别是什么？
- en: What are we doing wrong here?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里做错了什么？
- en: '[PRE44]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We’ve spent a lot of time in this chapter getting an inaccurate square root.
    How would we write a function to get an accurate square root?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这一章花了很多时间得到了一个不准确的平方根。我们如何编写一个函数来获得精确的平方根？
- en: '[PRE45]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
