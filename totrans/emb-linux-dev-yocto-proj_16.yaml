- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Speeding Up Product Development through Emulation – QEMU
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explore the possibilities of shortening product development
    through emulation and reducing the dependency on real hardware for most development.
    You will come to understand the benefits of using QEMU over hardware and when
    choosing real hardware is preferable. We also describe the `runqemu` capabilities
    and demonstrate some use cases.
  prefs: []
  type: TYPE_NORMAL
- en: What is QEMU?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Quick EMUlator** (**QEMU**) is a free, open source software tool that allows
    users to run multiple architectures on the same physical machine. It is a system
    emulator that can virtualize complete device hardware, including the CPU, memory,
    storage, and peripherals.'
  prefs: []
  type: TYPE_NORMAL
- en: Using QEMU for testing and debugging can save time and effort during development.
    It allows developers to test their code in various simulated environments.
  prefs: []
  type: TYPE_NORMAL
- en: Among other things, the Yocto Project uses QEMU to run automated **Quality Assurance**
    (**QA**) tests on final images shipped with each release. Within the context of
    the Yocto Project, QEMU allows you to run a complete image you have built using
    the Yocto Project as another task on your build system. In addition, QEMU helps
    to run and test images and applications on supported Yocto Project architectures
    without having actual hardware.
  prefs: []
  type: TYPE_NORMAL
- en: What are the benefits of using QEMU over hardware?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several situations where it may be more practical to use QEMU instead
    of real hardware for testing and debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to quickly and easily test your code in various simulated environments
    without constantly deploying it to the target device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don’t have the hardware that the software will be running on or if its
    availability is limited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to test software on multiple hardware platforms without having
    to set up multiple physical machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to debug software in a controlled environment, such as reduced
    memory availability, to observe its behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to validate software that isn’t hardware specific and wish to
    reduce the time needed for testing, such as flashing, board wiring, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it is essential to note that QEMU is a software emulator, which may
    not be a perfect substitute for real hardware at all times. Therefore, testing
    software on real hardware may be necessary to ensure it works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: When is choosing real hardware preferable?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several situations where it may be more practical, and even required,
    to use real hardware instead of QEMU for testing and debugging, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When the software relies on specific hardware features, for example, a particular
    **Video Processing Unit** (**VPU**) or **Graphics Processing Unit** (**GPU**)
    feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When evaluating the software performance, QEMU may not be able to replicate
    the performance of real hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While QEMU can be a valuable tool for testing and debugging software, it is
    not always a perfect substitute for real hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Using runqemu capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'QEMU is deeply integrated into the Yocto Project, and it is crucial to learn
    how to take advantage of this integration so we can plan the testing of our projects.
    The `runqemu` usage lists the variety of options available, which you can see
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 16.1 \uFEFF– The runqemu usage](img/Figure_16.1_B19361.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – The runqemu usage
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few use cases of QEMU that are important to highlight:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows choosing different kernel images for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows choosing different `rootfs` for booting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The capability to pass boot arguments for the kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports the use of a graphical environment with OpenGL or OpenGL ES options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can pass extra QEMU command-line parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows the use of serial console-only for rapid image testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the audio stack support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing different init systems (e.g., systemd)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following few sections, we use the `qemux86-64` machine as a reference
    to cover some common use cases, illustrating the main `runqemu` capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Using runqemu to test graphical applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we aim to validate the application, ignoring the embedded device GPU performance,
    we can rely on QEMU for such validation, for example, a Qt or GTK+ application.
    At first, we need to build the `core-image-weston` image. Next, we can run the
    validation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – The log after running QEMU with graphic support](img/Figure_16.2_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 – The log after running QEMU with graphic support
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you see the execution of `core-image-weston` inside QEMU:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 – Screenshot of QEMU running core-image-weston](img/Figure_16.3_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.3 – Screenshot of QEMU running core-image-weston
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the Wayland Terminal open, showing the information
    of the running Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Using runqemu to validate memory constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we aim to validate the application memory usage, we can rely on QEMU for
    such validation. At first, we need to build the `core-image-full-cmdline` image
    and run QEMU with the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4 – The log after running QEMU with 128 MB of RAM](img/Figure_16.4_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.4 – The log after running QEMU with 128 MB of RAM
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the amount of memory in use inside
    QEMU:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5 – Screenshot of QEMU running core-image-full-cmdline with 128
    MB of RAM](img/Figure_16.5_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.5 – Screenshot of QEMU running core-image-full-cmdline with 128 MB
    of RAM
  prefs: []
  type: TYPE_NORMAL
- en: Changing the command line used to run QEMU can help us test a set of different
    memory sizes via emulation.
  prefs: []
  type: TYPE_NORMAL
- en: Using runqemu to help with image regression tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Yocto Project provides an automated testing framework, a crucial part of
    the Yocto Project Quality Assurance process. The integration or validation testing
    support uses the `testimage` class to execute the images inside the target.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The testing framework can test existing recipes and images and be enhanced with
    custom tests to validate new applications and integrations. The testing framework
    capabilities are described in the section *Types of Testing Overview from Yocto
    Project* *Tests* ([https://docs.yoctoproject.org/4.0.4/test-manual/intro.html#yocto-project-tests-types-of-testing-overview](https://docs.yoctoproject.org/4.0.4/test-manual/intro.html#yocto-project-tests-types-of-testing-overview)).
  prefs: []
  type: TYPE_NORMAL
- en: First, we enabled the `testimage` support by adding `IMAGE_CLASSES += "testimage"`
    in `build/conf/local.conf` and made sure to build the `core-image-weston` image.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: During the image testing, the `sudo` command is used for networking setup and
    may trigger an error depending on your host configuration. Check *Yocto Project
    Development Tasks Manual*, in the *Enabling Runtime Tests on QEMU* section ([https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#enabling-runtime-tests-on-qemu](https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#enabling-runtime-tests-on-qemu))
    for how to avoid those errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we must build the `core-image-weston` image. We are ready now to start
    the execution of `testimage` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.6 – The result of running the testimage task for core-image-weston](img/Figure_16.6_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.6 – The result of running the testimage task for core-image-weston
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding log, we see the regression test results.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to use QEMU and how its capabilities can
    shorten the development cycle by emulating when possible and describing when it
    is not possible. It also presented some `runqemu` use cases.
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter, we offer a list of good practices that authors have been
    using over the years in the development of Yocto Project-based products.
  prefs: []
  type: TYPE_NORMAL
