<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer015">
			<h1 id="_idParaDest-144"><em class="italic"><a id="_idTextAnchor145"/>Chapter 6</em>: Databases</h1>
			<p>Technically database systems are applications that run on top of the operating system and should not be of direct concern to us as system administrators. That is an excellent theory. In the real-world, databases are tightly tied to the operating system, tend to be general knowledge items, require deep technical knowledge, and relatively little overall time. Because of this it almost universally makes sense that database management duties fall to system administrators; this is especially true on Linux distributions today because most databases that we are likely to use are bundled with the operating system itself.</p>
			<p>In this chapter we are going to learn about the following:</p>
			<ul>
				<li>Separating a Database from a DBMS</li>
				<li>Comparing Relational and NoSQL Databases</li>
				<li>Discovering Common Databases on Linux</li>
				<li>Understanding Database Replication and Data Protection Concepts</li>
			</ul>
			<p>In the good ol' days system administration and database administration were almost always two discrete tasks. The SA and DBA roles would work closely with each other, but the specialized skills and large time requirements of each role meant that they were typically discrete, dedicated staff. Typically, only one DBA was needed for every five to twenty system administrators, so teams were smaller, and the career field was always much smaller as the system administrator role exists even in companies that have no databases to administer.</p>
			<p>As both operating systems and database management systems have become simpler and more robust, the need for an extensive amount of database platform tweaking has been reduced to the point that the DBA career path is all but gone. The need to build a career around a single database platform just does not exist today. Those that manage databases generally do so for a wide variety of different databases, possibly on multiple operating systems.</p>
			<p>Over time most critical workloads become commoditized. By that we mean that they move from being specialist knowledge to being generalist knowledge. Good examples of these would be email servers (MTA) and web servers. Twenty years ago (around 2001) running either one of these was highly specialized knowledge and only a very rare system administrator would understand the workings of either one. You would typically have a system administrator just for the operating system and then a specialized email administrator or web administrator dedicated to managing just the single application that they specialized in. It would not be <em class="italic">all email servers</em> or anything like that. It was often a specialized skill to just a single email server such as Postfix or Exchange. Your knowledge would be completely centered on this one product and its unique quirks and needs. This was so extreme that products like Postfix, Exchange, Apache, MS SQL Server, Oracle Databases, IBM DB2, and so forth would have entire certification and professional development paths for each of them. Today, we just assume that any experienced system administrator will be more than capable of managing any email, web, or database server that is thrown at them.</p>
			<p>Because databases are highly complex and have evolved to be far more than they were in past decades, there are many concepts that we, as system administrators, should universally understand about them. They are highly stateful and represent a secondary storage layer to the file system and general storage subsystem. They do not represent a special case, but the broad application of a general case that we need to understand deeply. Web servers, email servers, and other applications are still important, but they represent common examples of the standard, expected situation in application design and so do not require special consideration in this manner. To be blunt, databases store things and are extremely fragile. Other applications use databases or the filesystem to store things and so are simple from an administration perspective. It is because a database represents a second-tier data storage layer that it is seen as special.</p>
			<p>To tackle this in a system administration way, we are going to start by delving into what a database really is and how it works and why it becomes a form of storage. Then we can look at database types and specifics common to Linux distributions. And then finally we will wrap up by looking at the most important aspect of databases: how to protect them.</p>
			<p>Let's get started and find out exactly what a database is and why we care so much about them.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor146"/>Separating a Database from a DBMS</h1>
			<p>As with most<a id="_idIndexMarker503"/> things in life, the terminology used casually <a id="_idIndexMarker504"/>around databases is often inaccurate with highly technical and specific terms being used to primarily refer to something different than what the term is meant to describe. But by digging into what a database truly is and how they almost universally work, and by building up correct semantics around the topic, we are going to build a nearly intrinsic understanding of database needs from a system administration perspective. This is often true, simply finding an accurate way to describe a thing allows us to understand it. Databases are not magic, but too often are treated as such.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor147"/>The Database</h2>
			<p>We have to <a id="_idIndexMarker505"/>begin by asking what a database is. A database is defined by the Oxford Dictionary as <em class="italic">a structured set of data held in a computer, especially one that is accessible in various ways</em>. Well that does not tell us very much. But, in a way, it kind of does. Databases cannot be unstructured; this is the most important piece and computers store things such as files. So, databases are structured data on a computer either stored on disk as a file or set of files, or they live in the computer's memory and never get written to disk. In the latter case the database is ephemeral and of little importance to a system administrator. But in the former case, which represents far more than ninety-nine percent of use cases, this matters a lot. Let's make a definition that we can use effectively as system administrators: a database is a file or a set of files that contain structured data.</p>
			<p>You might immediately jump to statements like, <em class="italic">but I have run a database and it is a service, not a file - I can interact with it!</em> We will address that shortly. Stick with me. Databases are just file(s).</p>
			<p>We should start with some examples because this helps to quickly understand what we mean. Let's take a standard text file, perhaps one in which we just write down some notes. This is a file, but is it a database? No, it is not. Sure, the file is encoded in some ANSII character standard, but the data is ad hoc, not structured. We <em class="italic">could</em> add structure manually to the file and that is okay to do, but the file and the tools that read that file are unaware of the structure. Any structure is purely accessible or visible only to the human using it, not the system itself. This is unstructured.</p>
			<p>Okay then, text files are not databases. What about a Word file? Same thing. It might have a strong format that a text file does not, but what is stored in the Word file is completely unstructured. We could put anything in the file, anywhere. It is unstructured.</p>
			<p>Now what about a spreadsheet file? Like we would get with Excel or a CSV? This is a tough one. This gets us into a grey area. Under normal conditions these files are not considered databases, but nominally they are. I would refer to them as <em class="italic">semi-structured</em>. They contain some structure (which you visibly see as cells) and they have a way to designate what is contained within that structure, and certain groups of data (namely what is represented as columns or rows) that are expected to relate to each other. But none of the structure within the cells or even between them is suggested or enforced. So, there is structure, but we generally assume that it is not as much structure as a database would require. We will call it a maybe. Do not break out a <strong class="source-inline">CSV</strong> file and try to defend it as the new database format at the next IT cocktail party, it is not defensible. It is only useful as<a id="_idIndexMarker506"/> a thought experiment. But we can see that a spreadsheet format has very easily the potential for acting like a database should.</p>
			<p>With a little more structure, we start to see real database-lite files emerge. XML makes a great example. XML is a little more structured than a spreadsheet format, like CSV, and can be used as a full-fledged database. There are some database formats that are based on XML. XML is still just ANSII text, but with enough specific structure to take us all the way to <em class="italic">very simple database</em>. XML maybe does not make for the most robust of databases, nor the fastest to use, but it is very simple and can be effective for the right purpose.</p>
			<p>Purpose built databases tend to avoid the unnecessary bloat of ANSII or similar text formats as this slows the system down when used by software, and databases really are not generally intended to be human readable on their own. Generally, some form of binary format or even compression is used to reduce read and write time from storage and minimize storage space needed today. A great example is <em class="italic">SQLite</em>, a free, open-source database that uses a highly optimized, but openly publicized, format that you can study if interested. It remains simply a file, like any other, but with even more structure than XML provides.</p>
			<p>All these examples use just one file per database. But there is no reason that a database might not use many files. A common purpose for this might be to simply break up data so that it is not all stored in a single file that is too large to easily manipulate or data might be broken up by purpose. Imagine a database that stores a list of user addresses and also user telephone numbers. One file that holds only the addresses and one that holds only the <a id="_idIndexMarker507"/>phone numbers would be a sensible <em class="italic">on disk</em> storage design.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor148"/>The Database engine</h2>
			<p>We now know what <a id="_idIndexMarker508"/>a database is. It is just a file (or files, of course) that we store that contain our structured data. We <em class="italic">assume</em> that in production circumstances, we will be using a database format that is highly efficient and not meant for a human to open it and read it directly, that would just be silly. So, the computer is going to read, write, and manipulate this file or these files.</p>
			<p>But how will the computer know how to work with the database file that is in such a specific structured format? Before we answer that, we should make a comparison to storage.</p>
			<p>In storage we have a standard raw format that we refer to as block storage. On top of that we implement filesystems. These filesystems interface with their operating system by providing a standard file access format that the operating system can use to store and retrieve data. Each filesystem can do this in quite different ways from each other. For the operating system to work with a filesystem it has to have a filesystem driver.</p>
			<p>Databases work the same way, but they generally do so one layer higher up the stack. To a database, the filesystem is the generic storage. The highly structured data goes on top of the filesystem, contained in a file, or files. But in the same way as we need a driver for the operating system to know how to talk to the filesystem, we need a driver for applications to know how to talk to databases! It is legitimate to refer to this as a database driver, but it is generally known as a database engine or a database library.</p>
			<h3>Filesystems are actually databases</h3>
			<p>Here is one<a id="_idIndexMarker509"/> of those <a id="_idIndexMarker510"/>weird things that those of us working in IT should understand and that you can never whip out at that proverbial cocktail party because you will never be able to convince anyone that this is true, and yet it is. Filesystems themselves are actually a form of database. They are an on-disk format of highly structured data that can contain other specifically formatted data, in the form of files, contain structured data about those files, and generally contains complex mechanisms for searching through the data structure. A filesystem is a database in every sense. Even down to how it is commonly used. They are simply databases with a unique, but extremely common, purpose that is so important that we have forgotten what it really is under the hood. </p>
			<p>This is similar to how web servers are actually file servers but are such a special case that no one ever talks about how that is what they really are. It is useful to understand that that is how they work because it helps us to understand them better and keeps our brains from getting confused when it realizes that the two overlap and you cannot figure out how they are separate - because they are not.</p>
			<p>This is so true that it used to be common for some high-performance databases to forego using files to store their data and would store directly on the block devices themselves so that they were in the same position that a filesystem would normally be. But because there were no files, they were not actually filesystems. But for all intents and purposes, they were.</p>
			<p>This filesystem replacement process was popular as a means of improving system performance because filesystems used to represent noticeable overhead to the servers. Today, filesystem overhead is completely trivial and attempting to replace the filesystem today presents so much complexity and so many problems that it is all but avoided.</p>
			<p>Once <a id="_idIndexMarker511"/>you<a id="_idIndexMarker512"/> think of a database as a sort of filesystem for your data, it all starts to make a lot more sense.</p>
			<p>The database engine is where all the real magic happens. The database itself is just the data sitting on the disk (or in memory.) Sure, it has a structure, but the structure is already there. The database does not create or enforce the structure or maintain it in anyway - all of that comes from the database engine. The database engine is the workhorse of the database stack. This is where the processing power goes, this is what we have to install, this is where the magic sauce gets applied.</p>
			<p>In some cases, we talk about database engines heavily. In some cases, we use them directly, like <strong class="bold">SQLite</strong> or <strong class="bold">Berkeley DB</strong>, where we just install the library (database engine) and access a file using it and voila, a working database system that we can use. Or in other cases, like if you use <strong class="bold">MongoDB</strong> or <strong class="bold">MariaDB</strong> products, you will often talk about the database engines that are being chosen under the hood (<strong class="bold">WiredTiger</strong>, <strong class="bold">InnoDB</strong>, <strong class="bold">MyISAM</strong>, and others) as key factors in database features and performance.</p>
			<p>Database engines get the raw deal in many cases with most people totally ignoring this all-important layer of the database services stack as it is hard to understand and generally hidden from view. Out of sight, out of mind applies heavily here. </p>
			<p>In some cases, like BDB and SQlite that I mentioned previously, we, as the system administrator, would be responsible for installing these libraries onto our servers to make them available for software to access. But, of course, these are often listed simply as dependencies and get installed and maintained by the package management systems on our servers that come from our Linux distribution making this simple and potentially even transparent to us. Because of these, system administrators are often nearly oblivious to what database engines are deployed or in use on the systems that they maintain.</p>
			<p>It may seem obvious, but it is worth noting, that database engines are code libraries (aka drivers) and are not programs that run or services that we find running. So, detecting a specific database engine on a system might be rather difficult. Sure, if SQlite is installed by APT or DNF we can query the system and find it easily enough. It is a library that sits on disk, has a directory, and is in the package configuration logs. We do not get to see it running in a process list or find it in the services directory, but we can find it one way or another.</p>
			<p>But there<a id="_idIndexMarker513"/> is <a id="_idIndexMarker514"/>every possibility that the code of a database engine library will get included into and compiled into a software project making it all but impossible to detect as it is simply binary data on disk somewhere inside another application. Sure, a block level tool could scan through every piece of data on disk to look for on disk patterns but that is getting into an extreme level that is more for forensics or law enforcement and not very useful in system administration. From a practical perspective, a compiled-in database engine is completely invisible to anyone using the system.</p>
			<p>When we are discussing the performance or features of one database or another, nearly always these features or performance characteristics are coming from the database engine in use. In most cases the database engine will also implement either a query language or an application programming interface API for querying the data on disk.</p>
			<p>For those following along you have probably noticed that since a database engine does not <em class="italic">run</em> that<a id="_idIndexMarker515"/> you <a id="_idIndexMarker516"/>cannot access it remotely. In order to interact with a database engine, you have to use the driver in a program to interact with the database.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor149"/>The Database management system</h2>
			<p>The most visible <a id="_idIndexMarker517"/>component of the database stack, and the only piece that is totally optional, is the database management system, often shortened to DBMS. For most people, even very technical people with a lot of database experience, the only part of the database system of which they are aware is the database management system.</p>
			<p>Before we dig into what exactly the database management system is, we should give some examples of real-world DBMS: <strong class="bold">MySQL</strong>, <strong class="bold">MariaDB</strong>, <strong class="bold">PostgreSQL</strong>, <strong class="bold">Oracle DB</strong>, <strong class="bold">Microsoft SQL Server</strong>, <strong class="bold">IBM DB2</strong>, <strong class="bold">MongoDB</strong>, <strong class="bold">Redis</strong>, <strong class="bold">Firebase</strong>, and so many more. These names should be much better known to most of you compared to database engine names.</p>
			<p>A DBMS does surprisingly little on its own. A DBMS is a program that uses one or more database engines to interact with the physical database on the disk and then provides access controls to that database. A DBMS might have a single database engine that is always associated with it, or like MySQL might provide access to a range of database engines while providing them a common interface to make it easy for developers to work with them. Those familiar with MySQL will be aware that when creating a new database inside of MySQL you must tell it which engine you want to use. Sure, there is a default in case you do not choose, but not choosing is very much a choice in that case.</p>
			<p>When working with a database engine you must specify the file or files that you are working with. So, any interaction with a database engine is only to a single database, whatever database is in that file. A DBMS does not typically work in this way. It is standard for a DBMS to have many databases connected to many <em class="italic">instances</em> of database engines which may be the same library instantiated multiple times or possibly different engines for different databases, all accessible at the same time. So much of what we picture as a database comes from the DBMS.</p>
			<p>It is the DBMS that provides, optionally of course, a way to connect to a database over a network or even over the Internet. Any networking capability comes from the DBMS. Moreover, it is the DBMS that <em class="italic">runs</em>, generally as a service, on your computer. This is where you see memory consumption, CPU usage, and other database usage details. The DBMS often provides extended features that cannot exist in the engine itself, such as in-memory caching.</p>
			<p>It should be obvious that in a pure database engine scenario that access control to the data in the database comes entirely from file system permissions. No different than opening a Word file with Microsoft Word. If you have read and write permissions on the file, and you can run the application that reads it, then you can read the file and write changes back to it. The same is tried with a database engine like SQLite. To allow a user to use the database you simply give them the filesystem permissions to do so. Very simple, and very limiting.</p>
			<p>With a DBMS we have more options. Most DBMS add networking and with this we can use the database's own tools to control access on a granular level, plus we can use operating system and networking tools to control access additionally. This becomes much more complex, but from this complexity we get power and flexibility. It is common to the point of assumption that the DBMS will offer user level controls and machine level controls and often very granular control within the sets of data that are managed under it such as row, table, or document level controls depending on the type of database engine in use.</p>
			<p>A DBMS adds power and flexibility, along with some ease of use in most cases, to the database <a id="_idIndexMarker518"/>ecosystem. In production environments there is no reason that you cannot use a database engine directly and many people do. But by and large it is DBMS that rules enterprise data storage. When people use the term <em class="italic">database server</em> it is the host containing the DBMS that they mean, by definition. It is the networking capability of a DBMS that allows for databases to be stored on and served out of a dedicated server (or set of servers) rather than requiring the database to always be local to the application that is using it. This is a very important flexibility as applications grow and need more resources. For small applications where there are plenty of resources to host an entire application and its entire database on a single server you will normally get the best performance out of using a database engine directly. But once you scale beyond that a DBMS is what allows databases to get so much bigger.</p>
			<p>A database engine on its own is not strictly a single connection limited system, but it is effectively so. It is possible for multiple people to connect to the same file on the filesystem at the same time, but this presents obvious problems. What if two people attempt to write changes at roughly the same time, do they overwrite each other, how do you update others to changes being made, and so forth. It presents the same problems that are seen when you have a SAN and connect multiple servers to the same filesystem. It solves them using the same clustered filesystem mechanics inside the database file. (See, I told you that databases acted like filesystems!)</p>
			<p>File level locking and access control can work for light usage up to about five users before it starts to exhibit real performance problems. For heavy use it will be problematic for even just two connections. Microsoft Access is famous for encouraging the use of the JetDB database engine (often just called the Access Database) and having horribly performing file locking that makes it untenable to try to use the system with more than a handful of users. That same<a id="_idIndexMarker519"/> system can switch to using <strong class="bold">MS SQL Server DBMS</strong> and handle thousands of users without a problem.</p>
			<p>So, for any real serious multiple connection situation (which can be caused by individual users or by many instances of a running service that needs to pull data from the database) a DBMS <a id="_idIndexMarker520"/>is required. There are so many more caching, locking, and permission control mechanics possible with a DBMS.</p>
			<h3>Identifying a shared database engine versus DBMS</h3>
			<p>If you are new to <a id="_idIndexMarker521"/>databases, you may not be aware of <a id="_idIndexMarker522"/>common ways to identify the use of one approach or another. Some situations are extremely easy, like if you must configure networking connection details for the database with hostnames and ports then you know that a DBMS has to be involved. But not all situations are so obvious.</p>
			<p>Many applications handle a lot of their own connection details, and you may have little way to know how they are working under the hood. So other than looking for open ports or something similar you might be left in the dark.</p>
			<p>One common mechanism, however, is requiring shared mapped drive access to a file or files. This is not needed by a DBMS in all but the rarest of cases and if it is, you have some serious performance issues. Sharing a database file directly to users or applications to access it is a sign of direct database engine use. This comes up with many legacy or poorly built applications and so you are likely to have come across it or to come across it in the future and know how database engines have to work helps to explain access, locking, performance, or even corruption problems with these deployments.</p>
			<p>As system administrators, and potentially as database administrators, the assumption is that other than installing a database engine library, that our interaction with running databases will all be in the form of the DBMS. This is where we will have to manage and monitor services, resource utilization, security, patching, access controls, and the like.</p>
			<p>We now have the knowledge of what databases are and how they work and what their components are so we can think critically about security and performance implications. Lacking this understanding of databases makes it very difficult to be able to deal with more complicated issues like performance tuning or effective backup measures. In the next section, we <a id="_idIndexMarker523"/>are going to talk about types of databases<a id="_idIndexMarker524"/> at a very high level to give us some insight into how system administrators may work with these different forms of data storage.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor150"/>Comparing relational and NoSQL databases</h1>
			<p>Databases <a id="_idIndexMarker525"/>come <a id="_idIndexMarker526"/>in two major categories: <em class="italic">Relational</em> and <em class="italic">NoSQL</em>. These are terrible categories, but sadly it is how the world sees databases. These terms are truly awful for several reasons. First because NoSQL is a reference to being <em class="italic">not-relational</em>. Which means that databases are either relational or not relational. That's pretty bad taxonomy right there. But it<a id="_idIndexMarker527"/> gets worse. SQL is the <em class="italic">structured query language</em> commonly associated with relational databases; it was a language written for querying relational databases. So, the term NoSQL refers to non-relational databases, but that's like trying to refer to people who aren't from England by calling them non-English speakers. The two can overlap, but often do not. </p>
			<p>SQL is not some intrinsic language of relations; it is just a common convention used to query them. You can make a relational database that cannot use SQL language queries and just as easily you can make a non-relational database that does! Not only can you, but this is very common. So just to be clear, you can use SQL with a NoSQL database, and people do it all the time! What madness is this?</p>
			<p>In the NoSQL world there are generally one or more query languages used by any given database. These tend to be unique to the individual database, but without some form of query language it is all but impossible to get data into or out of a data. It is these languages that form the basics of database communications with the applications that they support. As an example, MongoDB implements their own MongoDB Query Language.</p>
			<p>So we have to accept that these terms are ridiculous from the beginning and just realize that we are talking about relational databases on one hand and all other non-relational databases on the other which is a collection of many different database technologies. This weird situation simply exists because most popular, well-known databases are relational and for a great many years it was assumed that only relational databases were <em class="italic">good enough</em> for production use. Something that has proven to not be in any way true but it has lingering effects in the industry.</p>
			<p>NoSQL is therefore daunting on its own because it encompasses so many things, so many types of data structures. That said, we really do not have to understand them all. What we really need to understand is just that a NoSQL database can use any kind of on disk data structure (except, of course, to be relational) and may or may not use SQL or any other query language to be queried. This leaves more questions than answers. As a system administrator we will often simply be tasked with learning whatever database the applications that we support need. This may end up being something very common about which there is a broad amount of knowledge, or it might be something very obscure.</p>
			<p>The first databases were, by today's standards, NoSQL. This makes it odd that the earliest databases are thought of today in relation to not being something that came later. Early databases were extremely limited in capability. In the 1970s relational theory came along and the first truly modern databases came with it. Relational databases were born and proved to be so safe and effective that other database forms all but fell by the wayside<a id="_idIndexMarker528"/> in short order. The relational <a id="_idIndexMarker529"/>database was the king and was here to stay.</p>
			<p>For nearly four decades, relational databases represented nearly all business class databases with all other database types existing as little more than historical footnotes. When used in applications they were often implemented uniquely by an application rather than being provided by a large database vendor. Because of this, even when used they were relatively unknown. A database engine implemented inside of an application is essentially invisible to a systems administrator so even if these were being deployed with some regularity only the original developers would have known. In fact, I got my start in my career writing a NoSQL database engine and a GUI data retrieval system for it at the end of the 1980s. I saw this artefact of developers using NoSQL and the information technology department having no visibility firsthand from the other side at the height of the relational database dominance time period.</p>
			<p>The strength of a relational database comes from how efficiently it can store data, something that was extraordinarily important in the early decades of databases when finding storage systems large enough to hold them was continuously a challenge; and from how well relational databases can handle things like transactions and data integrity. This makes relational databases extremely good for any kind of system that deals with financial or other critical transactions where we need a high level of assurance that a transaction is completed entirely or not at all. Early databases were naturally very strongly focused on financial transactions because these were the data storage operations that were so critical that they could justify the use of expensive computers to make sure that they were done accurately. When a database costs a few millions dollars to implement it is easy to see why it would be useful to a bank, but very hard to justify running a blog from it.</p>
			<p>Relational databases get their name because they are built to specify actual relationships between pieces of data. For example, if you create a piece of user data, you might create a piece of telephone number data, and create a relationship between them. Then you might make more data, an address, for example. The address will also relate to the user. The basic idea behind a relational database is that the database engine will actively control these relationships. Maybe it automatically deletes the phone and <a id="_idIndexMarker530"/>address if the user is deleted, maybe <a id="_idIndexMarker531"/>it guarantees that a phone number can only belong to one person, or it can show when multiple people live at the same address. It can even stop you from creating a phone number that does not match a certain format or might block you from filling in complete fields. </p>
			<p>Relations might sound simple and superficial, but when put into well designed use they offer a lot of power to protect data integrity. They take a large load off of software developers and put data integrity into a position where the constraints used to protect the data remain even when the application that uses them is bypassed. Relational databases are a powerful mechanism. But that power comes at a cost to complexity.</p>
			<p>NoSQL databases, being free from the rules that govern relational databases and the assumed necessity of speaking a SQL dialect, can explore any number of data storage and integrity approaches. Some approach data with a <em class="italic">joie de vivre</em> carelessness that is downright shocking to traditional database administrators. Data can be just stored anywhere, without any controls. Sure, there might be structure, but the structure feels more like a suggestion than anything else. Coming from the hard and fast rules of relational theory, a document database, for example, feels like the wild west: throwing data willy nilly all over the place. One document's structure might not even match the next document. It is datalogical mayhem.</p>
			<p>The real power of NoSQL comes from this flexibility. Instead of having to work in a single, strongly predefined way or with heavy constraints, we are free to use data as it makes the most sense for our specific needs. We can use blogging as a great example of something that is generally the polar opposite of financial data in terms of our concerns. </p>
			<p>With financial data we are generally concerned heavily with accuracy and consistency and transactional completeness. With a blog we tend to care about speed and little else. If we have a popular website and need to make our blog available all over the world with lightning speed, we will likely want to have nodes serving out that content from locations all over the world so that most people can pull a relatively local copy of the blog rather than using a distant, centralized blog that might be hosted on another continent.</p>
			<p>A database that serves out the content via replication to many regions and does so with speed being the top priority can do things like miss the latest updates or get them out of order temporarily while data is updated, something that a relational database would be designed to avoid. Being able to replicate data as time allows while still serving out whatever data is available locally can make for very noticeable performance improvements. For many workloads, this performance tradeoff is ideal.</p>
			<p>As we move to a world where more and more systems become computerized, more and more of those workloads use databases and this means that the ways in which databases need to<a id="_idIndexMarker532"/> be used are getting broader. Databases <a id="_idIndexMarker533"/>are often <em class="italic">free</em> or incredibly low cost to implement today and that means that nearly everything is utilizing them at some point. It is no longer a world where they are exclusively for highly demanding workloads.</p>
			<p>Databases that provide only very simple lookups, session caches, and similar are not common. Or databases that replace text files for logging allowing for faster access to log data and, more importantly, robust searches of those logs can now be found almost everywhere. NoSQL is making the world of databases more powerful and flexible.</p>
			<p>As system administrators it will be very rare, if ever, that we are able to choose which database type will be used for a task. Even knowing which database types are most useful in different situations is likely to be unnecessary, while potentially very interesting. Far more importantly, we need to understand that databases now come with wonderous variety, share certain common factors as they relate to systems administration, no longer have the built-in assumptions such as SQL being a universal language, and that our applications will determine what database types and products that we need to learn and support.</p>
			<p>Understanding that relational and NoSQL represents our <em class="italic">two camps</em> of database products we<a id="_idIndexMarker534"/> will next take a brief survey of actual <a id="_idIndexMarker535"/>products most likely to be found in your Linux ecosystem today.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor151"/>Discovering common databases on Linux</h1>
			<p>Most operating <a id="_idIndexMarker536"/>systems have one or two really popular, key database<a id="_idIndexMarker537"/> products associated with them. On Windows this is Microsoft SQL Server, for example. Linux is very different in this regard. Not only is one singular database product not closely ideologically associated with the operating system, but there is typically a plethora of database options available already included in nearly every Linux distribution. This makes it so much more challenging to be prepared to be a Linux system administrator because the expectation that you are knowledgeable of and ready to manage any number of various database products exists. Your theoretical Windows system administrator counterpart would, culturally, need only have knowledge of one very predictable product to claim base knowledge of the entire field. Many databases <em class="italic">can run</em> on Windows, but anything other than MS SQL Server is considered an oddity and specialized knowledge. There would never be an expectation that you had any experience or knowledge of them.</p>
			<p>On Linux there may not be an expectation in most cases that you have truly deep knowledge of every possible database option, but that you know many of them and are prepared to administer nearly any is quite common. It is common for single servers to deploy multiple database management systems because they are built in and tend to be more purpose-built compared to say MS SQL Server and so using one database management system for one specific set of tasks and another for something with a very different data storage need is common and can be quite effective.</p>
			<p>We will maintain the natural assumed division in database categories and look at common relational database products as well as non-relational or NoSQL database products.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor152"/>Common relational databases on Linux</h2>
			<p>Probably the four<a id="_idIndexMarker538"/> best known databases on Linux, and some might be the best-known databases anywhere, are the relational databases. The big four are <strong class="bold">MySQL</strong>, <strong class="bold">MariaDB</strong>, <strong class="bold">PostgreSQL</strong>, and <strong class="bold">SQLite</strong>. Easily in fifth and sixth place, in no particular order, are <strong class="bold">Firebird</strong> and <strong class="bold">MS SQL Server</strong>. Yes, you read that right, the key Windows ecosystem database product is available on Linux.</p>
			<h3>MySQL</h3>
			<p>More than any other <a id="_idIndexMarker539"/>database, MySQL is synonymous with Linux<a id="_idIndexMarker540"/> systems. MySQL might be best known on Linux, but it is officially available on Windows as well and gets a reasonable amount of use there. MySQL is powerful and very fast and extremely well known. Nearly every Linux system administrator has worked with it at some point. MySQL is a full database management system that includes multiple database engines within it.</p>
			<p>MySQL gained its first real popularity by being the database used to power early dynamic websites. It was free, fast, and its lack of more advanced features often required for financial transactions did not matter to content management engines for blogging and similar dynamically generated site content. MySQL became known as the <em class="italic">go to</em> product for website needs but was often eschewed for other needs because of that stigma.</p>
			<p>Today MySQL is mature, advanced, and loaded with nearly any feature that you are likely to need for any type of workload. If you are going to learn only one database management, MySQL is certainly going to be it (or MariaDB, which I will explain shortly.) MySQL enjoys the broadest deployed user base, and by far the best overall industry knowledge penetration with almost any system administrator with Linux experience and a good number without being able to administer it with confidence. A large number of standard tools also exist for it, such as phpMyAdmin, which can make working with it even easier when you want to avoid, or move beyond, the command line. MySQL is used by nearly every major application project, at least optionally, that is made for Linux. It may not be the database most often deployed, but it is the database (when combined with MariaDB) most often deployed <em class="italic">intentionally</em> on not just Linux, but all operating systems combined.</p>
			<h3>MariaDB</h3>
			<p>There is really no <a id="_idIndexMarker541"/>way to talk about MySQL without<a id="_idIndexMarker542"/> mentioning MariaDB. MySQL's community and direction was divided a number of years ago and many of the original MySQL team left the product and took the open-source base with them and created MariaDB to be what they felt would be the spiritual successor to MySQL. To many, MariaDB is the <em class="italic">real</em> MySQL, given that it is ideologically aligned with the original product, is equally built from the same code base, and is built by the original team. Many, and probably the majority, of Linux distributions dropped MySQL and switched to using MariaDB instead. So much so, that most people who say that they use MySQL today actually use MariaDB - often without even knowing it.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor153"/>Drop In replacements</h2>
			<p>MariaDB's real<a id="_idIndexMarker543"/> claim to fame is that it is a full <em class="italic">drop-in replacement</em> for MySQL. That means that it is designed to be able to be used, completely transparently, anywhere that MySQL would be used. It uses the exact same protocols, interfaces, tools, names, ports, conventions, and others. Everything, in theory, is the same.</p>
			<p>MariaDB does this so well that many people say that they are using MySQL, when in fact they are using MariaDB. Some say it is kind of like a code. Others say it because management expects one thing, and it is not worth trying to explain why MariaDB is used instead of MySQL. Still others just have no idea that that is not what they installed. The most common tool for managing MariaDB is the <strong class="source-inline">mysql</strong> command line tool and that is quite often the closest thing to an actual view of the system that many people get. A database designer or a developer working on a system would only need to know that the system is MySQL compatible. There is no real artefact to lead them to suspect that it is one product or the other. They truly do look and act the same.</p>
			<p>It is common for people to now refer to the famous LAMP stack, which used to be Linux + Apache + MySQL + PHP, as being Linux + Apache + MariaDB + PHP. It seems that MariaDB has truly taken over MySQL's former position in the market. But it is extremely difficult to gauge this accurately as an indeterminately large percentage of the MariaDB market reports itself to be using MySQL either because they do not realize that they are different, they casually report inaccurately, or they truly have no idea what they are using.</p>
			<p>Drop in compatibility gives the additional benefit that learning MySQL means learning MariaDB and vice versa. You do not need to learn one or the other, since everything you do with one is<a id="_idIndexMarker544"/> identical on the other.</p>
			<h3>PostgreSQL</h3>
			<p>Pronounced <em class="italic">post gress</em> no matter how unlike that it looks, PostgreSQL is arguably the most mature <a id="_idIndexMarker545"/>and advanced database available on Linux <a id="_idIndexMarker546"/>systems today. PostgreSQL (originally written POSTGRES) was started in the 1980s as a successor to the <a id="_idIndexMarker547"/>successful Ingress database product (<strong class="bold">Postgres</strong> meaning <strong class="bold">POST inGRESs</strong>.) </p>
			<p>Today, PostgreSQL is often considered the fastest, most stable, and most feature rich database product available on Linux and possibly at all. Database distinctions of this nature are typically more opinion than anything else as performance measurements are rarely directly comparable and variances in features often outweigh straight query performance, but PostgreSQL's reputation is one of unmitigated excellence, but at a cost of being more complex and less well known compared to its competition which are generally perceived as being simpler systems.</p>
			<p>In recent years, PostgreSQL has seen a major resurgence in popularity. More and more today you will find that software that you deploy supports and even recommends it as the database of choice, a major change in the database winds since the heyday of MySQL a decade or more ago.</p>
			<p>As a Linux system administrator, the PostgreSQL database ecosystem is a solid second, if not first choice, alongside MySQL (and MariaDB which are identical) to learn as most Linux system administrators will need to manage PostgreSQL at some point.</p>
			<h3>SQLite</h3>
			<p>Far more commonly<a id="_idIndexMarker548"/> used than most system administrators <a id="_idIndexMarker549"/>realize is <strong class="bold">SQLite.</strong> So much so that SQLite claims to be the world's most deployed database! SQLite, as we have mentioned earlier, is a database engine, but not a database management system. Because of this, SQLite installs simply as a driver or <em class="italic">library</em> to the disk and is called by an application that uses it. There is no running SQLite service or SQLite program that you need to run or can even run if you want to. The closest thing is the <strong class="source-inline">sqlite</strong> client utility that you can use to read and alter a SQLite database file, but this is nothing like a database server.</p>
			<p>SQLite's power is in how simple and subtle it is. Outside of having its access library installed, a system administrator typically needs no knowledge of SQLite existing on the system. It does not get tuned or configured. It just exists. And because of the magic of software repositories and automated dependency management, SQLite tends to get deployed simply as a dependency to another piece of software and we might not even be aware that we have installed it or that it is available. It just appears automagically and does its job. It is possible that it is even built into an application that uses it and it may not even appear in a form that we can search for on the system!</p>
			<p>Because of how it exists and gets deployed most of the time, the average deployment of SQLite is unknown to everyone that uses the system. A normal installation does not hide the driver: a system administrator looking to discover it or patch it or to just find out where it exists would have little problem in doing so. But unless you are looking for it specifically, a<a id="_idIndexMarker550"/> typical<a id="_idIndexMarker551"/> server will have hundreds or even thousands of packages of this nature and we cannot generally invest the time into knowing which libraries exist on every system, let alone know which software depends on which packages. It just is not practical.</p>
			<h3>Firebird</h3>
			<p>Dramatically <a id="_idIndexMarker552"/>less well known than MySQL, PostgreSQL, SQLite, and<a id="_idIndexMarker553"/> MariaDB is <strong class="bold">Firebird</strong>. Firebird is a complete and mature database management system based on Interbase 6 but split off from that project in 2000. While considered relatively minor software in the Linux world, Firebird is nevertheless a capable and mature database management system whose primary claim to fame is around the overall small amount of system resources necessary to run it.</p>
			<p>Firebird is far more likely to come up in conversation than to actually end up being deployed on one of your servers. It simply is not very common. Linux has no shortage of database options and that makes it difficult to get any traction, even when you have a mature and serious database option like Firebird. </p>
			<h3>Microsoft SQL Server</h3>
			<p>This entrant <a id="_idIndexMarker554"/>on the list is always very <a id="_idIndexMarker555"/>shocking to those not aware of its availability. Long considered one of the best database products on the market, MS SQL Server was always limited only to Microsoft Windows operating systems. But in recent years Microsoft, in an attempt to gain traction in the more lucrative database licensing space (when compared to operating system licensing) has been releasing MS SQL Server to Linux as well as to Windows. Today, MS SQL Server is a completely rational and viable option for Linux system administrators to see.</p>
			<p>Like most of the more traditional options on this list, MS SQL Server is a complete database management system with multiple database engines under the hood. It is a big product with a lot of bells and whistles.</p>
			<p>MS SQL Server remains uncommon on Linux, and likely will for quite some time. But it is already far more common than Firebird, for example. Database departments are often focused very heavily on Linux, or at least UNIX in general, and so it has been problematic if applications require MS SQL Server and that a team that otherwise typically does not use Windows Server is required to manage a wholly different platform just for one database product. </p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor154"/>Common NoSQL Database Products on Linux</h2>
			<p>If the list of <a id="_idIndexMarker556"/>relational database products seems long, that is nothing compared to the potential list of NoSQL or non-relational database products that we can potentially discuss. Unlike the relational list where all of the products work in similar ways and would make sense for use by similar software tasks, the NoSQL list varies widely. What is an amazing product for one task might be completely useless for another.</p>
			<p>We cannot possibly go into all of the details of each of these database products, or even just all of the different types of databases that are lumped into this catchall of a category. We could easily fill a book this size with NoSQL database examples alone. We will do our best to race through and give enough highlights to make you appreciate what products are out there, why you care, and where to start your own investigations into products that you may want to learn about on your own.</p>
			<h3>MongoDB</h3>
			<p>Definitely the <a id="_idIndexMarker557"/>mind-space leader of the NoSQL<a id="_idIndexMarker558"/> field is MongoDB. MongoDB is what is known as a document database management system. Like many of the database management systems that we have mentioned, MongoDB can use multiple database engines, but nearly everyone who uses it today <a id="_idIndexMarker559"/>uses its <strong class="bold">WiredTiger</strong> database engine. Document databases are one of the closest NoSQL database types to a relational database with many situations where both would be capable of doing the job. A document database is almost as if we took a relational database and a traditional filesystem, and they met in the middle.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor155"/>Document databases</h2>
			<p>Document <a id="_idIndexMarker560"/>databases store structured documents. While every document database can use its own format and approach, the concept is universal. A good example could be XML. XML could be the format of an individual document inside of a document database. The database may dictate the structure of the XML, or it might be freeform. The database might contain millions of these XML documents. </p>
			<p>Since the database knows the intended use of the documents that it contains, it is able to use common fields throughout the documents to generate indexes and other artefacts to empower the database to do so much more that you could do if you were to simply save many XML documents to your hard drive.</p>
			<p>But it only takes a simple example like this before it begins to be obvious why a file system is truly not just a database, but a document database specifically!</p>
			<p>Document databases tend to be easy to use and very straightforward making life easy for developers and system administrators alike. They have proven to be a highly desired and effective alternative to relational databases for many common workloads.</p>
			<p>MongoDB is broadly deployed and used in a large variety of situations. Like most of the relational database examples that we mentioned initially, MongoDB can be found commonly with third party software packages, with Linux distribution vendor packages, while also remaining popular with internal software teams for bespoke development. If you are going to start experimenting with a NoSQL database on Linux, I would generally start with MongoDB as this is almost certainly going to be the most useful experience to have, even if MongoDB itself never ends up being a database management system that you support in production.</p>
			<p>MongoDB is a great way to explore many alternative database approaches, many of which have become somewhat standard in the <em class="italic">post relational</em> world.</p>
			<p>While document databases have proven to be the most common alternative to relational databases for common software usage, not many document databases have risen to prominence. MongoDB is the only really large, well-known example. Other examples<a id="_idIndexMarker561"/> are <strong class="bold">Apache CouchDB</strong> and <strong class="bold">OrientDB</strong> as a <a id="_idIndexMarker562"/>database management system and <strong class="bold">NeDB</strong>, a <a id="_idIndexMarker563"/>database<a id="_idIndexMarker564"/> engine with nearly identical data structures to MongoDB.</p>
			<h3>Redis</h3>
			<p>A completely<a id="_idIndexMarker565"/> different approach to storing data is <a id="_idIndexMarker566"/>Redis, which is what is known as a key-value store database management system. This type of database is much more popular as an assistant datastore rather than a primary one. The idea behind a key-value store is that the application using the database supplies a key and the database returns the data associated with that key. It is an extremely simple mechanism compared to the types of databases that we have already encountered, but it is a very useful one. </p>
			<p>Key-value stores (sometimes called dictionary lookups) are commonly used for high-speed online caches and can be a great way to manage such data as we might store when managing sessions. It would be rare, but not impossible, for an application to use a key-value database as the only data storage mechanism. It is almost always just one piece of a multi-part database strategy.</p>
			<p>Redis brings many of the advanced features needed for giant online applications to the key-value space, such as the ability to cluster across nodes and convenient access methods that make it very popular in large applications. It's performance and simplicity make it popular in web hosting realms.</p>
			<p>Other key-value stores<a id="_idIndexMarker567"/> remain <a id="_idIndexMarker568"/>popular such as <strong class="bold">memcached</strong> which is extremely<a id="_idIndexMarker569"/> popular on Linux for web hosting, <strong class="bold">LevelDB </strong>and even a key-value database engine under <strong class="bold">MS SQL Server</strong>.</p>
			<h3>Cassandra</h3>
			<p>A key (pun intended) competitor<a id="_idIndexMarker570"/> with relational and<a id="_idIndexMarker571"/> document databases for the <em class="italic">general purpose application</em> space is the wide column database and the big name here is Cassandra. Wide column databases deserve more attention and description than we can afford here, but needless to say they primarily tackle the same workloads as relational databases with an eye towards greater flexibility and scalability in most cases.</p>
			<p>Along with<a id="_idIndexMarker572"/> Cassandra, <strong class="bold">Apache HBase</strong> and <strong class="bold">ScyllaDB</strong> are major wide column databases common to <a id="_idIndexMarker573"/>Linux. You will not find this kind of database as frequently as you will see key-value and document, but it has some traction and is easy to acquire and experiment with if you are looking to expand your knowledge of database specifics or types.</p>
			<p>And beyond: NoSQL is not constrained by definitions and special purpose databases and database types keep arising. I would recommend also investigating <strong class="bold">Amazon OpenSearch</strong>, a search <a id="_idIndexMarker574"/>database, and <strong class="bold">InfluxDB</strong> and <strong class="bold">Prometheus</strong>, time<a id="_idIndexMarker575"/> series <a id="_idIndexMarker576"/>databases. All three of these databases, and both types of databases, are typically used in storing log or log-like data at high speed and great volume.</p>
			<p>Do not be afraid to search for new or interesting database approaches and products on your own. This is a fast-moving area of the industry and one where a book will become outdated quickly. Linux is the leader in database platforms in every sense, from market share to stability <a id="_idIndexMarker577"/>to performance to variety. You should have<a id="_idIndexMarker578"/> some familiarity with the major products, what is included in your distribution, and what is likely to be used by your applications. And a general sense of what involvement will be necessary from you. Remember that some organizations will continue to use dedicated database administrators to handle database tasks separate from the system administration team, but nearly all companies will combine these roles leaving the need to understand many database platforms often on your shoulders.</p>
			<p>We now have a great understanding of what products we are likely to see in the real world of Linux <a id="_idIndexMarker579"/>system administration. All these <a id="_idIndexMarker580"/>database concepts are fun and interesting, and it is always exciting to be able to get our hands on many different products, but what really matters is how we protect these systems and that is what we will address in our next section.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor156"/>Understanding database replication and data protection concepts</h1>
			<p>From the <a id="_idIndexMarker581"/>perspective <a id="_idIndexMarker582"/>of the Linux system administrator, nothing is going to be as important as database protection which includes, just as it does with systems in general, both disaster avoidance and disaster recovery. Because databases are so critical, and because they are so common, and additionally because their needs are so different from what we typically encounter otherwise in our systems, we are breaking them out here so that we can tackle the nearly unique needs of the database world with respect to data protection.</p>
			<p>Because databases store structured data, they come with all of the challenges to protect what we face with heavily used storage systems, which they effectively are. Because databases are highly stateful we must be very careful that we do not break state when looking at data protection.</p>
			<p>What does all of this mean in the simplest of terms? Basically, databases are all about storing data and to do what they do with any effectiveness at all they need to both hold open the files that represent their data on disk as well as keeping generally a large amount of that data in memory at any given time. This presents several challenges to us for when it comes to data protection.</p>
			<p>Open files are always a problem for backups. There is no good way to take a backup of a file that is currently being held open by an application because we have no way to know what the state of writing to the file is. Perhaps the file is perfectly fine as it is, or perhaps it has been half modified and the data is gibberish until more data that is current in memory or possibly has not been calculated yet has been added to the file, or perhaps the format of the file is not corrupt but the data that is in the file is no longer accurate. From outside of the application using the file we cannot know what the actual state of an open file is other that it cannot be trusted.</p>
			<p>Because of this, most file-based backups will simply ignore the file as they cannot lock the file to take a backup. For most files this is no problem because files only get locked occasionally and if you take backups on a regular basis you are expected to eventually get a good backup of any given file. It may not be deterministically safe, but it is statistically safe. And if you need determinism, you can always use a log to see if files that are critical have been safely backed up or not.</p>
			<p>Block based backups, that is backups that work from the block device layer instead of the file layer and are not aware of individual files or filesystem mechanics, can easily take a backup of an open file, but they cannot know if the file is in a safe or accurate state or not. So, in the first case, we assume that an open file will simply be skipped. In the second case, we assume that a backup of it will be taken but that the accuracy of that backup can only be determined at the time of restore. Neither option is ideal, of course. Both are better than nothing.</p>
			<p>The traditional method to move from <em class="italic">maybe we got a good backup</em> or <em class="italic">we almost always get a good backup</em> to fully knowing that a backup is good is to use an agent that informs applications to complete transactions and puts all data onto the disk and to close the file for the duration of a backup operation. Some applications have mechanisms for doing this, API calls to be made that tell them to prepare for a backup, and for others you do this via brute force by closing the application completely prior to taking a backup <a id="_idIndexMarker583"/>and restarting it when the backup is complete. The <a id="_idIndexMarker584"/>problem here being that only very few applications support this kind of communications, and any backup software agents have to support each unique piece of software individually to be able to do this. So, it requires both parties to work together, something that does not happen frequently given the large number of applications and backup tools on the market. It is impractical.</p>
			<p>What many applications resort to doing is taking their own <em class="italic">backups</em> of a sort by executing an internal data dump process and saving the data in a safe way to another storage location. This file, a complete copy of all of the data that is in the application, is kept closed and is only used for the backup software to read and use instead of the live data. This provides a universal mechanism for working around data corruption problems caused by open files. It is easy for the application writers to implement and works universally with all backup software.</p>
			<p>This method is totally effective but has a major caveat: we have to shut down the application in order to have it work. That means we must have a way to consistently bring the application down at the right time, and a way to bring it up at the right time. That part is generally feasible without too much work, although it is generally quite manual outside of a few common applications. But the real problem is getting organizations to agree to regular downtime for applications to allow for the backup process. Unlike a system reboot which we generally only look to do weekly or possibly monthly, we typically want to run backups daily at a minimum and sometimes hourly or even nearly continuously. This is not always something that we can do. </p>
			<p>Beyond scheduled backup frequency, it is generally desired that we be able to take <em class="italic">ad hoc</em> backups at a moment's notice, as well. If an <em class="italic">ad hoc</em> backup is going to trigger application downtime that is rarely going to be acceptable. Something else is needed.</p>
			<p>This all comes together to make database backups a dramatic problem. Databases are almost always the most critical <em class="italic">under the hood</em> workload components in your IT infrastructure, the least able to withstand any extended period of or unplanned downtime, the only ones that typically hold their files open indefinitely, and the ones for which backups are most critical.</p>
			<p>This challenge extends far beyond just backups. If we were dealing with a stateless application, rather than a database, such as a typical website, we have replication options that can be as simple as just copying the application directory between servers. Load balancing options can be as simple as directing some traffic to one application server or to another. In most cases, non-database application replication, backup, and even load balancing is easy.</p>
			<p>With a database<a id="_idIndexMarker585"/> we do not have the option of simply copying files <a id="_idIndexMarker586"/>between systems. For the data to be consistent and updated, the database management systems running on each host would need to coordinate with each other and ensure concepts such as locks, caches, and flushes to disks were done consistently and communicated around the cluster. Replication, if it is even an option for the database management system that you are using, is generally quite complex and comes with many caveats. There is no simple way to make databases have replication or clustering without introducing significant performance challenges.</p>
			<p>So, both protecting databases from failure, and making them easy and reliable to recover should they fail, is challenging. And while the techniques to do so, at the highest level, may be somewhat common, it is really configured and applied at the specific tool level every time. So, learning how it is handled in one ecosystem may not reflect in another.</p>
			<p>In all cases, backups or replication and clustering, is going to be handled by the database management system itself or a dedicated tool to that database. The capabilities of the system will be unique to that database. Some database management systems, for example, are limited to very simple clustering, perhaps on to a pair of mirrored servers or they might be limited to only a single node that is able to make changes to disk, but other nodes in the cluster maintain a cached copy of part or all of the data and serve out requests to read the data. Others have massive scalability and may allow hundreds of independent nodes, each of which is allowed to fully read and write data!</p>
			<p>So, because of this complexity we must learn each product completely individually. There is a strong <em class="italic">tendency </em>for NoSQL databases to have been replication and redundancy options. This generally comes from having fewer controls and constraints. As well as from the fact that most NoSQL databases are built in recent years and most relational databases are decades old so the considerations at the time of design were vastly different. Most relational databases that you know today had to adapt first to networking and then to the Internet over a period of many years. Nearly all NoSQL that you will encounter were made decades after the Internet was a part of everyday life.</p>
			<p>In many cases, databases being put into a cluster will work by locking some combination of file, record, document, row or other discrete portion of the database and signaling other cluster members of the lock. Then the original system waits for all members to communicate back with an acknowledgement of the lock. Once locked the system cannot write new data to at least a portion of the system and must unlock it before it can continue<a id="_idIndexMarker587"/> fulfilling data storage requests. This locking can be quite fast<a id="_idIndexMarker588"/> in some cases or can have storage impacts large enough to impact application usability in others. Doing this on a single server database can have noticeable impact. Doing this on a cluster where cluster nodes need to wait for each other to complete their locked tasks and report back to each other can magnify that effect by many times. If we then need to do the same thing while waiting for Internet latencies and possible outages happening during a locked operation the scale of potential impact can magnify many times again. Locks ensure consistency but always come at the cost of performance and complexity. The bigger our database system grows, the larger the potential impact of locking even a portion of that system.</p>
			<p>Traditionally, and mostly with relational databases, we have assumed that increasing performance was done by <em class="italic">scaling up</em> - that is adding more CPUs or faster CPUs, and more memory, and more or faster storage. This is really effective as long as we need to access the data more or less centrally and only until we are able to keep squeezing more and faster CPUs into a single box. After that, we hit a performance wall and we are stuck.</p>
			<p>Today more and more we see <em class="italic">scale out</em> designs where more, smaller nodes are added to a cluster like we have discussed in earlier chapters. Relational designs are not completely unable to use this model, but they tend to struggle to do so efficiently, especially if we expect write, as well as read, operations to scale with the system. It is NoSQL that has taken this need for data access and really run with it. New databases designed from the ground up to do this with amazing efficiency have emerged and are tackling data problems in whole new ways. Some are even using NoSQL <em class="italic">under the hood</em> while presenting common relational interfaces on top (via SQL language queries, for example) to add new performance options to otherwise old designs. </p>
			<p>Clusters of databases introduce new potential complications to our data protection plans. Depending on the database and the data integrity design a backup or replication operation may require something dramatic such as temporarily <em class="italic">freezing</em> the entire database cluster while the backup is taking place. Or it may require collecting data from individual nodes, when each contains unique data, to assemble a complete backup of data that does not exist in its entirely in any one location until the time of the backup operation. This approach, generally called a sharded database, can be logistically challenging as it is possible to have a scale of data that no node is well prepared to handle and restoration can be complicated as the data has to be fed back into the cluster and distributed out to the nodes. Reassembling the data may be a large task. Other databases might simply <em class="italic">take their chances</em> and provide backup of what they have without checking in with other cluster nodes. It all depends on the database and the setup of it.</p>
			<p>When working with database clusters there are many considerations and while we can talk about high<a id="_idIndexMarker589"/> level approaches here, in the real world each database and <a id="_idIndexMarker590"/>sometimes even the database deployments are unique. We will need to investigate the documentation for the unique setup and be mindful that we need to have a way to ensure consistency end to end through the process of collecting and storing the data.</p>
			<p>We also have to consider the case of straight database engines that do not include a database management system. In this case, there is no database management system to create consistent backup files to disk or to handle replication. Any data protection features will need to be handled by the application that uses the database rather than having a database product do the work. This situation is extra difficult for system administrators because every application is potentially very unique and challenging. Of course, we can <em class="italic">always </em>resort to shutting down the application or even the entire server in order to make a backup, but it is not a desirable process.</p>
			<p>With a database engine if we want any functionality around data protection without shutting down the system ourselves, we need to rely on the application in question to provide it. This <em class="italic">can</em> provide for the best possible options (along with applications doing this same thing on top of a database management system, of course) for data protection because the application itself will generally have exclusive access to the database as well as total knowledge of the current use case of the entire application stack. In theory the application layer, with its additional knowledge of the state of the system and intended use cases, can take backups that are more meaningful, at times that are more useful, and store them in more dynamic ways.</p>
			<p>For example, the application layer can replicate partial data, only data that is deemed truly critical, in near real time to an arbitrary data storage location, perhaps offsite. Maybe it records data in a log-like structure so that it can be recreated. Or maybe it knows when there is going to be downtime on writes and can lock the database and replicate it with greater intelligence than the database management system itself could do or the application layer could replicate a transaction across application nodes to ensure consistency before ever sending data down to the database for storage. There are many ways that the application layer, with its greater insight and flexibility can make the data storage layer better.</p>
			<p>An application layer backup has the potential to do interesting things such as take backups based on slow times of day and to be able to automate both backups and restores. Automating the setup of a new node can be an incredible benefit if the application allows for it. </p>
			<p>As was said about the database cluster situation, each scenario may be unique and will require knowing the application, knowing what accommodations it provides for data integrity, and<a id="_idIndexMarker591"/> adding our own knowledge to ensure that we are able to <a id="_idIndexMarker592"/>accomplish a consistent and integral data set. An application that is clustered may present the same challenges and opportunities that a clustered database does on its own. </p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor157"/>Summary</h1>
			<p>Databases are pretty much the most important thing that we will need to work with as system administrators. Whether we run the database ourselves, or only administer the operating system on which they run, they will require more of our attention and will cause us more stress than pretty much anything else that we will do. Our skills and expertise will matter most when working with databases and it is here that the greatest range of our skills will likely be tested.</p>
			<p>Wherever we have databases running or in use we need to evaluate how the data is stored on disk, how we can ensure consistency, and how that consistent data can be moved to a backup location whether tape, online, or other. This is probably the single most important task that we will do in system administration, Linux or otherwise.</p>
			<p>Our best practices around databases really focus on data protection. We would love to talk about how we should choose the right database type for the job that we will be performing, but in all but the rarest cases these decisions are made long before anything gets to the system administration team.</p>
			<p>Database best practices for backups are to ensure that a full consistent, fully safe, closed set of data is used as the source for a backup to ensure data protection is predictable. Whether this is handled by the database, by the application using the database, or manually, there must be a mechanism that ensures that data is not in flight at the time of the data acquisition.</p>
			<p>In clustering scenarios, the same logic applies. But now we must ensure that the data accessible to our node is accurate and complete in the context of the entire cluster.</p>
			<p>In our next chapter, we are going to start digging into the less glamorous, but super important world of documentation, monitoring, and logging.</p>
		</div>
	</div></body></html>