- en: '*Chapter 12*: Tuning SELinux Policies'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：调整SELinux策略'
- en: Until now, we have been working with an existing SELinux policy by tuning our
    system to deal with the proper SELinux contexts and assigning the right labels
    to files, directories, and even network ports. We've learned that the behavior
    that SELinux enforces is defined within the policies. To fine-tune the policy
    enforcement rules, we have already briefly covered SELinux booleans.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在通过调整系统来处理现有的SELinux策略，确保系统适应适当的SELinux上下文，并为文件、目录甚至网络端口分配正确的标签。我们已经了解到，SELinux执行的行为是由策略定义的。为了微调策略执行规则，我们已经简要介绍了SELinux布尔值。
- en: It's time we look into SELinux booleans in more detail, learning how to look
    up the impact booleans have. Within this chapter, we then consider SELinux policy
    modules themselves and what options administrators have when dealing with these
    modules. Finally, we will look at how to update or even replace existing policies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候更详细地研究SELinux布尔值了，学习如何查看布尔值的影响。在本章中，我们将考虑SELinux策略模块本身，以及管理员在处理这些模块时可以选择的选项。最后，我们将探讨如何更新甚至替换现有的策略。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要主题：
- en: Working with SELinux booleans
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SELinux布尔值
- en: Handling policy modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理策略模块
- en: Replacing and updating existing policies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换和更新现有策略
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2T7MkVK](https://bit.ly/2T7MkVK)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/2T7MkVK](https://bit.ly/2T7MkVK)
- en: Working with SELinux booleans
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SELinux布尔值
- en: One of the methods of manipulating SELinux policies is by toggling SELinux booleans.
    Ever since [*Chapter 2*](B16276_02_Final_VK.xhtml#_idTextAnchor045), *Understanding
    SELinux Decisions and Logging*, where we used the `secure_mode_policyload` boolean,
    these tunable settings have been popping up over the course of this book. With
    their simple ON/OFF state, they enable or disable parts of the SELinux policy.
    Policy developers and administrators use SELinux booleans to toggle parts of the
    policy that not all deployments always need to be active, but some still do.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 操作SELinux策略的其中一种方法是切换SELinux布尔值。自[*第2章*](B16276_02_Final_VK.xhtml#_idTextAnchor045)《理解SELinux决策和日志记录》以来，我们使用了`secure_mode_policyload`布尔值，这些可调设置在本书中随时出现。通过其简单的开/关状态，它们启用或禁用SELinux策略的部分内容。策略开发人员和管理员使用SELinux布尔值来切换策略的某些部分，因为并非所有部署都需要始终启用这些部分，但某些部署仍然需要。
- en: These booleans are added to the policy based on feedback from, and with the
    help of, the community at large. By establishing which policy rules are necessary
    against those that are optional, SELinux developers can provide an SELinux policy
    that works for a majority of systems, even when the uses of these systems differ.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些布尔值是根据来自社区反馈并在社区帮助下，添加到策略中的。通过明确哪些策略规则是必要的，哪些是可选的，SELinux开发人员可以提供适用于大多数系统的SELinux策略，即使这些系统的使用方式不同。
- en: Listing SELinux booleans
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出SELinux布尔值
- en: 'An overview of SELinux booleans can be obtained by using the `semanage` command
    with the `boolean` option. On a regular system, we can easily find over a hundred
    SELinux booleans, so it is necessary to filter them out for the description of
    the boolean we need:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`semanage`命令与`boolean`选项，获得SELinux布尔值的概览。在普通系统上，我们可以轻松找到上百个SELinux布尔值，因此需要筛选出我们需要的布尔值的描述：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The output not only gives us a brief description of the boolean, but also the
    current value (actually, it gives us the current value and then the value pending
    a policy change, but this will almost always be the same).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 输出不仅为我们简要描述了布尔值，还显示了当前值（实际上，它首先给出当前值，然后是等待策略变更的值，但这两个几乎总是相同的）。
- en: 'Another method for getting the current value of a boolean is through the `getsebool`
    command, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 获取布尔值当前值的另一种方法是通过`getsebool`命令，如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the name of the boolean is not exactly known, we can ask for an overview
    of all booleans (and their values) and filter for the one we need:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果布尔值的名称不完全明确，我们可以请求所有布尔值（及其值）的概览，并筛选出我们需要的：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another utility that can be used to view SELinux boolean descriptions is the
    `sepolicy booleans` command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以用来查看SELinux布尔值描述的工具是`sepolicy booleans`命令：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, this command does not show the current value of the boolean.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用该命令无法显示布尔值的当前值。
- en: 'Finally, booleans are also represented through the `/sys/fs/selinux` filesystem:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，布尔值也通过`/sys/fs/selinux`文件系统表示：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, booleans can be read as if they were regular files, and they return two
    values:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，布尔值可以像常规文件一样读取，并返回两个值：
- en: The first value is the current state of the boolean, where `0` means OFF and
    `1` means ON.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个值是布尔值的当前状态，`0`表示关闭，`1`表示开启。
- en: The second value is the pending state of the boolean.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个值是布尔值的待提交状态。
- en: A pending state allows administrators to change multiple boolean values simultaneously,
    but only when manipulating booleans through the `/sys/fs/selinux` filesystem,
    as we will see next.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 待提交状态允许管理员同时更改多个布尔值，但只有在通过`/sys/fs/selinux`文件系统操作布尔值时才会发生，如我们接下来将要看到的那样。
- en: Changing boolean values
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改布尔值
- en: 'We can change the value of a boolean using the `setsebool` command. For instance,
    to toggle the `httpd_can_sendmail` SELinux boolean, we can use the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`setsebool`命令更改布尔值。例如，要切换`httpd_can_sendmail`的SELinux布尔值，可以使用以下命令：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Some Linux distributions might also have the `togglesebool` command available.
    This command will flip the value of the boolean, so ON becomes OFF, and OFF becomes
    ON:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Linux发行版可能还提供`togglesebool`命令。此命令将切换布尔值，因此开启变为关闭，关闭变为开启：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: SELinux booleans have a default state defined by the policy administrator (and
    thus the default SELinux policy active on the system). Changing the value using
    `setsebool` updates the current active access controls, but this does not persist
    across reboots (if we toggle the boolean, then after rebooting, the old value
    will be used again).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux布尔值的默认状态由策略管理员定义（因此由系统上活动的默认SELinux策略定义）。使用`setsebool`更改值时，会更新当前活动的访问控制，但该更改不会跨重启持久化（如果切换布尔值，则重启后会使用旧的值）。
- en: 'In order to keep the changes permanently, add the `-P` option to the `setsebool`
    command as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使更改永久生效，请在`setsebool`命令中添加`-P`选项，如下所示：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the background, the updated SELinux boolean value is included in the policy
    store. Then, the current policy file is rebuilt and loaded. As a result, the policy
    file (called `policy.##` with `##` representing an integer value) residing in
    `/etc/selinux/targeted/policy` will be regenerated. This regeneration takes time,
    which is why switching a boolean value persistently (using `-P`) takes more time
    to complete than when we change a value without persisting it (using `setsebool`
    without `-P` or `togglesebool`) to the policy store.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，更新的SELinux布尔值会被包含在策略存储中。然后，当前的策略文件会被重建并加载。因此，位于`/etc/selinux/targeted/policy`中的策略文件（名为`policy.##`，其中`##`代表一个整数值）将会重新生成。这个过程需要一些时间，这也是为什么使布尔值持久生效（使用`-P`）比不持久更改布尔值（使用`setsebool`而不加`-P`或使用`togglesebool`）更耗时的原因。
- en: 'Another way to change and persist the boolean settings is to use the `semanage
    boolean` command as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 改变并使布尔设置持久化的另一种方法是使用`semanage boolean`命令，如下所示：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, we modify (`-m`) the boolean value and set it to ON (`--on`).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们修改（`-m`）布尔值并将其设置为开启（`--on`）。
- en: 'Booleans can also be changed through their `/sys/fs/selinux/booleans` representation.
    When this happens, the boolean value is not immediately activated – the change
    of the value is pending. This allows administrators to modify multiple booleans
    through `/sys/fs/selinux/booleans` first:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值也可以通过其`/sys/fs/selinux/booleans`表示进行更改。当这种情况发生时，布尔值不会立即生效——该值的更改处于待提交状态。这允许管理员先通过`/sys/fs/selinux/booleans`修改多个布尔值：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To commit the changes, write the value `1` into `/sys/fs/selinux/commit_pending_bools`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要提交更改，请将值`1`写入`/sys/fs/selinux/commit_pending_bools`：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As long as you modify booleans through the `semanage` or `setsebool` commands
    though, the changes will immediately be committed. Only operations through the
    `/sys/fs/selinux` structure allow pending boolean changes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 只要通过`semanage`或`setsebool`命令修改布尔值，变更将立即提交。只有通过`/sys/fs/selinux`结构进行的操作才允许布尔值更改处于待提交状态。
- en: Inspecting the impact of a boolean
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查布尔值的影响
- en: 'To discover which policy rules a boolean manipulates, the description usually
    suffices. Sometimes though, we might want to know which SELinux rules change when
    we alter a boolean value. With the `sesearch` application, we can query the SELinux
    policy, displaying the rules affected by a given boolean. To show this information
    in detail, we use the `-b` option (for the boolean) and `-A` option (to show all
    `allow` rules):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要发现一个布尔值操作了哪些策略规则，通常其描述就足够了。但有时我们可能想知道，当我们改变布尔值时，哪些SELinux规则会发生变化。通过`sesearch`应用程序，我们可以查询SELinux策略，显示受特定布尔值影响的规则。要详细显示这些信息，我们使用`-b`选项（表示布尔值）和`-A`选项（显示所有`allow`规则）：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we query the SELinux policy directly, conditional rules can be shown as
    part of the output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们直接查询SELinux策略时，条件规则也可以作为输出的一部分显示：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When `allow` rules are suffixed with an SELinux boolean between square brackets
    followed by `:True`, then these rules are only applied if the boolean is active.
    If the boolean is followed by `:False`, then the rule is applied if the boolean
    is not active.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当`allow`规则后面跟着一个SELinux布尔值并用方括号括起来，后面加上`:True`时，这些规则仅在布尔值处于活动状态时应用。如果布尔值后面跟着`:False`，则在布尔值不活动时应用规则。
- en: Not all situations can be perfectly defined by policy writers though. Sometimes
    we will need to create our own SELinux policy modules and load those. Let's see
    how we can handle SELinux policy modules specifically.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并不是所有情况都能被策略编写者完美定义。有时我们需要创建自己的SELinux策略模块并加载它们。让我们看看如何专门处理SELinux策略模块。
- en: Handling policy modules
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理策略模块
- en: When the system loads the SELinux policy in memory, it uses the `policy.##`
    file, with `##` representing the policy version, as explained at the end of [*Chapter
    1*](B16276_01_Final_VK.xhtml#_idTextAnchor018), *Fundamental SELinux Concepts*.
    This file, which resides in `/etc/selinux/targeted/policy`, is generated every
    time the policy is modified. This can be when booleans are changed (and persisted),
    or when SELinux policy modules are added or removed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统将SELinux策略加载到内存时，它使用`policy.##`文件，其中`##`代表策略版本，如[*第1章*](B16276_01_Final_VK.xhtml#_idTextAnchor018)《基本SELinux概念》结尾所述。此文件位于`/etc/selinux/targeted/policy`目录下，每次策略修改时都会生成。修改可能发生在布尔值改变（并持久化）时，或者当SELinux策略模块被添加或删除时。
- en: Listing policy modules
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出策略模块
- en: SELinux policy modules are sets of SELinux rules that can be loaded and unloaded.
    These modules, with `.pp` or `.cil` suffixes, can be loaded and unloaded as needed
    by the administrator. Once loaded, the policy module is made part of the SELinux
    policy store, and will be loaded even after a system reboot. Unlike SELinux boolean
    changes, SELinux policy module loads are always persisted.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux策略模块是一组可以加载和卸载的SELinux规则。这些带有`.pp`或`.cil`后缀的模块可以根据需要由管理员加载和卸载。一旦加载，策略模块就成为SELinux策略存储的一部分，并将在系统重启后继续加载。与SELinux布尔值更改不同，SELinux策略模块的加载始终是持久的。
- en: 'To list the currently loaded SELinux policy modules, we recommend using the
    `semodule` command. By default, `semodule` will show all loaded SELinux policy
    modules without any details:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出当前加载的SELinux策略模块，建议使用`semodule`命令。默认情况下，`semodule`会显示所有已加载的SELinux策略模块，但不包括任何详细信息：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'SELinux policy modules can, however, be loaded at a specified priority. This
    allows administrators to load a policy that overrules an already loaded policy:
    SELinux policy modules with a higher `--list-modules=full` argument:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，SELinux策略模块可以在指定的优先级下加载。这使得管理员能够加载一个覆盖已加载策略的策略：使用较高的`--list-modules=full`参数的SELinux策略模块：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Alongside the priority, the listing also shows whether the policy module is
    based upon the binary module format (`pp`) or the more modern `cil`).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了优先级外，列表还显示策略模块是基于二进制模块格式（`pp`）还是较新的`cil`格式。
- en: 'The SELinux utilities will copy the active policy modules into a policy-specific
    location. This allows administrators to list the currently active modules through
    regular filesystem queries as well:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux工具将把活动策略模块复制到策略特定的位置。这使得管理员也可以通过常规的文件系统查询列出当前活动的模块：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The use of the filesystem location for querying active policies is, however,
    not recommended, as we have no guarantee that the loaded policies match the filesystem:
    non-SELinux utilities can add or remove files from these locations without adjusting
    the SELinux policy state.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用文件系统位置查询活动策略并不推荐，因为我们无法保证加载的策略与文件系统匹配：非SELinux工具可以在不调整SELinux策略状态的情况下，添加或删除这些位置的文件。
- en: Loading and removing policy modules
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载和移除策略模块
- en: 'In the *Replacing and updating existing policies* section, we will learn how
    to generate new policy modules. Once created, they need to be loaded and/or removed.
    We load policy modules with `semodule` as well, regardless of the policy format
    (`.pp` or `.cil`):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在*替换和更新现有策略*一节中，我们将学习如何生成新的策略模块。创建后，需要加载和/或移除它们。无论策略格式是（`.pp`还是`.cil`），我们都使用`semodule`加载策略模块：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By default, SELinux policy modules are loaded at the `400` priority when invoked
    by the administrator, whereas SELinux policy modules loaded as part of the default
    system policy will be loaded at the `100` priority. When loading policies, the
    priority can be adjusted using the `-X` option. For instance, to load the `test.cil`
    policy with a priority of `500` we use the `-X` option as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SELinux 策略模块在管理员调用时会以 `400` 优先级加载，而作为默认系统策略一部分加载的 SELinux 策略模块会以 `100`
    优先级加载。在加载策略时，可以使用 `-X` 选项调整优先级。例如，要以 `500` 优先级加载 `test.cil` 策略，可以使用如下的 `-X` 选项：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To remove a policy module with `semodule`, use the `--remove` or `-r` option.
    In this case, we are not referring to an SELinux policy module *file*, but to
    the *name* of the module itself as displayed by `semodule`. Hence, we do not need
    to pass on a suffix:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `semodule` 移除一个策略模块，可以使用 `--remove` 或 `-r` 选项。在这里，我们并不是指 SELinux 策略模块的 *文件*，而是指通过
    `semodule` 显示的 *模块名称*。因此，我们不需要传递后缀：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To remove an SELinux policy module from a specified priority, use the `-X`
    option:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要从指定的优先级移除 SELinux 策略模块，可以使用 `-X` 选项：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The order of the arguments is important: the `-X` option will set the priority
    for the actions that follow it, not those that precede it. If it is not set, then
    a priority value of `400` will be used.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的顺序非常重要：`-X` 选项会设置后续操作的优先级，而不是前面的操作。如果没有设置，则会使用优先级值 `400`。
- en: 'Finally, it is possible to keep an SELinux policy module but disable it. This
    keeps the module in the policy store, but disables all the SELinux policy rules
    inside of it. We use the `--disable` (or `-d`) option to accomplish this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以保留 SELinux 策略模块但将其禁用。这会将模块保留在策略存储中，但禁用其中所有的 SELinux 策略规则。我们使用 `--disable`（或
    `-d`）选项来实现这一点：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To re-enable the policy, use the `--enable` (or `-e`) option:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新启用该策略，可以使用 `--enable`（或 `-e`）选项：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The disabled and enabled states of SELinux policy modules persist through reboots
    as well. Furthermore, if you are disabling an SELinux module, all instances of
    that module (including lower priority ones) will be disabled.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 策略模块的禁用和启用状态会在重启后保持不变。此外，如果你禁用了一个 SELinux 模块，该模块的所有实例（包括优先级较低的实例）都会被禁用。
- en: Disabling policies is strongly recommended when the policy module is part of
    the distribution's SELinux policy, as the modules themselves are not always available
    on the system and might require a reinstallation of the policy package just to
    get it back.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议在策略模块是发行版 SELinux 策略的一部分时禁用该策略，因为这些模块本身并不总是存在于系统中，可能需要重新安装策略包才能恢复它们。
- en: With loading and unloading policies explained, let's see how we can generate
    updates on the current SELinux policy.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过加载和卸载策略的说明，让我们来看看如何生成当前 SELinux 策略的更新。
- en: Replacing and updating existing policies
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换和更新现有策略
- en: When we replace or update existing policies, we need to load them using the
    `semodule` commands, as shown in the *Handling policy modules* section. But how
    do we create or update the policies, exactly? Let's consider a few use cases where
    SELinux policy adjustments are triggered.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们替换或更新现有策略时，需要使用 `semodule` 命令加载它们，如 *处理策略模块* 部分所示。但我们究竟如何创建或更新策略呢？让我们考虑一些触发
    SELinux 策略调整的使用场景。
- en: Creating policies using audit2allow
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 audit2allow 创建策略
- en: When SELinux prevents certain actions, we know it will log the appropriate denial
    (assuming no `dontaudit` statements are defined) in the audit logs. This denial
    can be used as the source to generate a custom SELinux policy that allows the
    activity.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SELinux 阻止某些操作时，我们知道它会在审计日志中记录相应的拒绝信息（前提是没有定义 `dontaudit` 语句）。这个拒绝信息可以作为生成自定义
    SELinux 策略的来源，以允许该活动。
- en: 'Consider the following denial, which occurred when a confined user called `su`
    to switch to the root user:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下拒绝情况：当一个受限用户使用 `su` 切换到 root 用户时发生的拒绝：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If we are certain that these operations need to be granted, then we can use
    the `audit2allow` command to generate a policy module for us that allows these
    activities. The `allow` rules. These rules can then be saved in a file, ready
    to be built into an SELinux policy module, which can then be loaded.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确定需要授权这些操作，可以使用 `audit2allow` 命令为我们生成一个允许这些活动的策略模块。`allow` 规则。这些规则可以保存到一个文件中，准备构建成一个
    SELinux 策略模块，然后加载。
- en: 'To generate SELinux policy `allow` rules, pipe the denials through the `audit2allow`
    application:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成 SELinux 策略 `allow` 规则，将拒绝信息通过 `audit2allow` 工具传递：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Based on the denials, `audit2allow` prepared an `allow` rule. We can also ask
    `audit2allow` to immediately create an SELinux policy module:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据拒绝记录，`audit2allow`准备了一个`allow`规则。我们还可以要求`audit2allow`立即创建一个SELinux策略模块：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A file called `localpolicy.pp` will be available in the current directory, which
    we can load using the `semodule` command. The source file will also be present,
    named `localpolicy.te`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`localpolicy.pp`的文件将出现在当前目录中，我们可以使用`semodule`命令加载它。源文件也将存在，名为`localpolicy.te`。
- en: 'If the denials that occurred are considered cosmetic in nature (meaning that
    the system functions as expected and the denials should not cause any updates
    on the policy), you can use `audit2allow` to generate `dontaudit` rules rather
    than `allow` rules. In that case, the denials will no longer be visible in the
    audit logs, while still preventing the actions from taking place:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生的拒绝记录被认为是外观性的（即系统按预期运行，并且拒绝不应该对策略产生任何更新），可以使用`audit2allow`生成`dontaudit`规则，而不是`allow`规则。在这种情况下，拒绝记录将不再出现在审计日志中，但仍然会阻止相关操作发生：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is likely, after including the necessary rules, that the action will result
    in more denials that were not previously triggered. As long as the previous AVC
    denials are still available in the audit logs, it is sufficient to regenerate
    the policy and continue. After all, `audit2allow` will consider all AVC denials
    that it encountered, regardless of the current SELinux policy state.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含必要规则之后，可能会导致更多之前未触发的拒绝记录。只要之前的AVC拒绝记录仍然存在于审计日志中，重新生成策略并继续操作就足够了。毕竟，`audit2allow`会考虑到它遇到的所有AVC拒绝记录，而不管当前的SELinux策略状态如何。
- en: Another popular approach is to put the system (or the application domain) in
    permissive mode to generate and fill up the audit logs with all the AVC denials
    related to the action. Although this generates more AVC denials to work with,
    it could also result in wrong decisions by the `audit2allow` command. Hence, always
    verify the denials before generating new policy constructs, and review the generated
    policy to make sure that it will enforce the right set of access controls and
    not grant more privileges than needed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的方法是将系统（或应用程序领域）设置为宽松模式，以生成并填充所有与操作相关的AVC拒绝记录到审计日志中。虽然这会生成更多的AVC拒绝记录供我们处理，但也可能导致`audit2allow`命令做出错误的决策。因此，在生成新的策略构建之前，始终验证拒绝记录，并审查生成的策略，以确保它能够执行正确的访问控制集，并且不会授予超过所需的权限。
- en: 'When the previous AVC denials are no longer available inside the audit log,
    a new policy module will need to be generated, as otherwise the previously fixed
    accesses will be denied again: the newly generated policy will no longer contain
    the `allow` rules from before, and when we load the new policy, the old policy
    is no longer active.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当先前的AVC拒绝记录不再出现在审计日志中时，就需要生成新的策略模块，否则之前已修复的访问将再次被拒绝：新生成的策略将不再包含以前的`allow`规则，而当我们加载新策略时，旧的策略不再生效。
- en: Using sensible module names
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用合理的模块名称
- en: In the previous section, we used the `audit2allow` command to generate a policy
    module named `localpolicy`. However, this name does not reveal what the purpose
    of the module is.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了`audit2allow`命令生成了一个名为`localpolicy`的策略模块。然而，这个名称并没有揭示模块的具体用途。
- en: Once we create a (binary) policy (such as the `localpolicy.pp` file) and load
    it, it is not always clear to the administrators and users at first glance what
    this module is meant to accomplish. Although it is possible to unpack the `.pp`
    file (using `semodule_unpackage`) and then disassemble the resulting `.mod` file
    into a `.te` file, it requires software not available on most distributions (the
    `dismod` application, for instance, part of the `checkpolicy` software, is often
    not included). Considering that we just want to get insights into the rules that
    are part of a module, this is a very elaborate and time-intensive approach.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个（二进制）策略（如`localpolicy.pp`文件）并加载它，管理员和用户一开始通常无法清楚地知道这个模块的目的。虽然可以通过解包`.pp`文件（使用`semodule_unpackage`）然后将得到的`.mod`文件反汇编成`.te`文件，但这需要在大多数发行版上都没有的软件（例如，`dismod`应用程序，它是`checkpolicy`软件的一部分，通常不包括在内）。考虑到我们只是想了解模块中包含的规则，这是一个非常复杂且费时的方法。
- en: 'The content of a module can also be somewhat deduced from its CIL code. For
    instance, an active `screen` module will have its code available at `/var/lib/selinux/targeted/active/modules/100/screen`,
    in a file called `cil`. On some distributions, this file will be a compressed
    file, so you might need to unzip it before viewing:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的内容也可以从其CIL代码中推断出来。例如，活动的`screen`模块的代码可以在`/var/lib/selinux/targeted/active/modules/100/screen`中找到，文件名为`cil`。在某些发行版中，此文件可能是压缩文件，因此在查看之前可能需要解压缩：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Still, having to dive into the rules to know what `localpolicy` is about is
    not only very cumbersome, but also requires sufficient privileges to be able to
    read these files.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，必须深入了解规则以了解`localpolicy`的内容，不仅非常繁琐，而且还需要足够的权限才能读取这些文件。
- en: Instead, it is a best practice to name the generated modules for their intended
    purposes. An SELinux policy that fixes a few AVC denials that come up when `su`
    executes from within the `staff_t` domain would be best named `custom_staff_su_faillog`,
    for instance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，最佳做法是为生成的模块命名以反映其预期用途。例如，修复`su`从`staff_t`域内执行时出现的几个AVC拒绝的SELinux策略，最好命名为`custom_staff_su_faillog`。
- en: 'It is also recommended to prefix (or suffix) the custom policies, so they can
    be more easily found:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 还建议对自定义策略添加前缀（或后缀），以便更容易找到：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This identifies that the policy module has been added by the administrator (or
    organization) and is not sourced from the default Linux distribution's policy.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明该策略模块是由管理员（或组织）添加的，而不是来自默认Linux发行版的策略。
- en: Generating reference policy style modules with audit2allow
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用audit2allow生成参考策略模块
- en: 'The reference policy project provides distributions and policy writers with
    a set of functions that simplify the development of SELinux policies. As an example,
    let''s see what the reference policy functions (called `su` situation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 参考策略项目为发行版和策略编写者提供了一组功能，这些功能简化了SELinux策略的开发。例如，我们来看一下参考策略函数（称为`su`情境）：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The rule in the example is `auth_rw_faillog(staff_t)`. This is a reference policy
    macro that explains an SELinux rule (or set of rules) in a more human-readable
    way. In this case, it allows the `staff_t` domain to read/write on `faillog_t`
    labeled resources. The `faillog_t` type is part of the system authentication SELinux
    policy (as suggested by the `auth_` prefix, which identifies the source SELinux
    policy module).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的规则是`auth_rw_faillog(staff_t)`。这是一个参考策略宏，它以更易读的方式解释了SELinux规则（或一组规则）。在这种情况下，它允许`staff_t`域对`faillog_t`标记的资源进行读/写操作。`faillog_t`类型是系统认证SELinux策略的一部分（由`auth_`前缀标识，该前缀表示源SELinux策略模块）。
- en: Important note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: As `audit2allow -R` uses an automated approach for finding potential functions,
    we need to review the results carefully. Sometimes it selects a method that creates
    far more privileges for a domain than needed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`audit2allow -R`使用自动化方法查找潜在的功能，我们需要仔细审查结果。有时它会选择一种方法，为一个域创建比所需更多的权限。
- en: All major distributions base their SELinux policies upon the macros and content
    provided by the reference policy. The list of methods we can call while building
    SELinux policies is available on the local filesystem, at `/usr/share/doc/selinux-policy/html`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要发行版都将其SELinux策略建立在参考策略提供的宏和内容之上。我们可以在本地文件系统的`/usr/share/doc/selinux-policy/html`中找到构建SELinux策略时可以调用的方法列表。
- en: These named methods bundle a set of rules related to the functionality that
    SELinux policy administrators want to enable. For instance, the `storage_read_tape()`
    method allows us to enhance an SELinux policy, providing a given domain with read
    access to tape storage devices.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命名方法将一组与SELinux策略管理员希望启用的功能相关的规则捆绑在一起。例如，`storage_read_tape()`方法允许我们增强SELinux策略，授予指定域对磁带存储设备的读取访问权限。
- en: Building reference policy - style modules
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建参考策略风格模块
- en: If we generate an SELinux policy using reference policy macros but do not have
    access to the binary policy module anymore, then we need to build the policy before
    loading it. CIL-based policies can be loaded directly, which is why this book
    uses CIL as much as possible. However, given the wide use of the reference policy,
    knowing how to build these modules is important as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用参考策略宏生成SELinux策略，但不再有访问二进制策略模块的权限，那么我们需要在加载之前构建该策略。基于CIL的策略可以直接加载，这就是为什么本书尽可能使用CIL的原因。然而，鉴于参考策略的广泛使用，了解如何构建这些模块同样很重要。
- en: 'Suppose that the *reference policy*-based SELinux policy code resides in a
    file called `custom_staff_su_faillog.te`, then we can build it into a `.pp` file
    as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设基于*参考策略*的SELinux策略代码位于名为`custom_staff_su_faillog.te`的文件中，那么我们可以按照以下方式将其构建为`.pp`文件：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once built, we can load it using `semodule`. Every time we change the policy
    code (in the `.te` file) or other policy information (such as file context definitions
    in the `.fc` file), we need to rebuild the `.pp` file before we can load it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以使用`semodule`加载它。每次我们修改策略代码（在`.te`文件中）或其他策略信息（如`.fc`文件中的文件上下文定义）时，我们都需要重新构建`.pp`文件，然后才能加载它。
- en: Building legacy-style modules
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建传统风格的模块
- en: If we ask `audit2allow` to generate the policy rules without using reference
    policy style macros (which we call a *legacy-style* SELinux policy), then building
    the `.pp` file from it requires a different approach.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要求`audit2allow`生成不使用参考策略样式宏（即我们称之为*传统风格*的SELinux策略）的策略规则，那么从中构建`.pp`文件需要不同的方法。
- en: 'Suppose we have the `.te` file as generated by `audit2allow -M`, but not the
    `.pp` file, then we can generate it as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有`audit2allow -M`生成的`.te`文件，但没有`.pp`文件，那么我们可以按照以下步骤生成它：
- en: 'First, create the `.mod` file using `checkmodule`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用`checkmodule`创建`.mod`文件：
- en: '[PRE30]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, generate the `.pp` file using `semodule_package`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`semodule_package`生成`.pp`文件：
- en: '[PRE31]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `audit2allow` command will automatically execute these commands, so this
    is only needed if the `.pp` file is no longer present, or when these more legacy-style
    SELinux policies are shared with you and you need to build and load them manually.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`audit2allow`命令将自动执行这些命令，因此仅在`.pp`文件不再存在，或者当这些较为传统风格的SELinux策略与您共享时，并且您需要手动构建和加载它们时才需要执行。'
- en: Replacing the default distribution policy
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换默认的分发策略
- en: When adding custom SELinux policies, all that users can do is to add more `allow`
    rules. SELinux does not have a deny rule that can be used to remove currently
    allowed access rules from the active policy.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加自定义SELinux策略时，用户所能做的只是添加更多的`allow`规则。SELinux没有可以用来移除当前允许访问规则的deny规则。
- en: If the current policy is too permissive for the administrator's liking, then
    the administrator will need to update the policy rather than just enhance it.
    That implies that the administrator has access to the current SELinux policy rules
    in use.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前策略对管理员来说过于宽松，那么管理员需要更新策略，而不仅仅是增强它。这意味着管理员可以访问当前使用的SELinux策略规则。
- en: 'To replace an active SELinux policy, most Linux distributions allow you to
    get the source code of the policy. For instance, for RPM-based Linux distributions,
    the source RPM of the SELinux policy package can be downloaded and unpacked to
    gain access to the policy as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换一个活动的SELinux策略，大多数Linux发行版允许你获取该策略的源代码。例如，对于基于RPM的Linux发行版，可以下载SELinux策略包的源RPM并解压，从而访问策略，方法如下：
- en: 'First, find out what the current version of the SELinux policy is:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，找出当前SELinux策略的版本：
- en: '[PRE32]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, try to obtain the source RPM shown in the output. Source RPMs can also
    be downloaded from third-party repositories. If the package is difficult to find,
    you can try to find it through [https://rpmfind.net](https://rpmfind.net).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，尝试获取输出中显示的源RPM。源RPM也可以从第三方仓库下载。如果难以找到该包，可以尝试通过[https://rpmfind.net](https://rpmfind.net)来查找。
- en: 'Next, use the `rpmbuild` utility to extract the source RPM:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`rpmbuild`工具提取源RPM：
- en: '[PRE33]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When finished, the SELinux policy source code can be found inside `~/rpmbuild/SOURCES`
    and is probably named `selinux-policy-9c02e99.tar.gz` or similar, which you can
    extract further:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，SELinux策略源代码可以在`~/rpmbuild/SOURCES`目录下找到，可能命名为`selinux-policy-9c02e99.tar.gz`或类似名称，您可以进一步解压：
- en: '[PRE34]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The policy files can now be safely copied over, manipulated at will, and built
    to replace the existing policy. If we load the updated SELinux policy module with
    the same (or higher) priority as the already loaded policy, it will take precedence
    in the policy.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，策略文件可以安全地复制、随意操作并构建，以替换现有的策略。如果我们以与已加载策略相同或更高的优先级加载更新后的SELinux策略模块，它将在策略中占据优先地位。
- en: Most distributions will also have their active SELinux policy available through
    an online source-controlled repository. For instance, the current SELinux policy
    for CentOS is available at [https://github.com/fedora-selinux/selinux-policy](https://github.com/fedora-selinux/selinux-policy).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数发行版还将通过在线源代码控制仓库提供其活动的SELinux策略。例如，CentOS当前的SELinux策略可以在[https://github.com/fedora-selinux/selinux-policy](https://github.com/fedora-selinux/selinux-policy)找到。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: The SELinux policy can be adjusted by administrators, either through SELinux
    booleans as provided by the SELinux policy itself, or by loading new SELinux policy
    modules. These modules can be generated automatically, or built manually by the
    policy developers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员可以通过 SELinux 布尔值（由 SELinux 策略本身提供）或加载新的 SELinux 策略模块来调整 SELinux 策略。这些模块可以自动生成，或者由策略开发人员手动构建。
- en: In this chapter, we've learned how to use SELinux booleans and how to query
    the active policy for the effects that the booleans will have on the system. We
    then learned how to use `semodule` to load and unload policies, or enable/disable
    modules on the system. We ended the chapter with information on how to generate
    and replace policies.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 SELinux 布尔值以及如何查询活动策略，以了解布尔值对系统的影响。接着，我们学习了如何使用 `semodule` 加载和卸载策略，或在系统上启用/禁用模块。我们在本章结束时介绍了如何生成和替换策略。
- en: In the next chapter, we will extend our query of the SELinux policy beyond just
    booleans, and learn how to analyze policy behavior in detail using specialized
    tools.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展对 SELinux 策略的查询，不仅仅局限于布尔值，并学习如何使用专业工具详细分析策略行为。
- en: Questions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How can we mark a boolean change as pending but not commit it yet?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将布尔值更改标记为待处理，但尚未提交？
- en: Which command can be used to query the impact of a boolean?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令可以用来查询布尔值的影响？
- en: Why can SELinux policy modules be loaded with different priorities?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么可以以不同的优先级加载 SELinux 策略模块？
- en: How can denials be transformed into new SELinux policy modules?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将拒绝转化为新的 SELinux 策略模块？
