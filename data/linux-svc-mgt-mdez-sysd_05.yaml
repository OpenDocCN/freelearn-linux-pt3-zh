- en: '*Chapter 4*: Controlling systemd Services'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：控制 systemd 服务'
- en: 'Now that we''ve seen what `systemd` services are, it''s time to learn how to
    control them. In this chapter, we''re going to do just that. Specifically, we''ll
    cover the following skills:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 `systemd` 服务，接下来是学习如何控制它们。在本章中，我们将专注于此。具体而言，我们将涵盖以下技能：
- en: Verifying the status of a service
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证服务状态
- en: Starting, stopping, and reloading services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动、停止和重新加载服务
- en: Enabling and disabling services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用和禁用服务
- en: Killing a service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杀死一个服务
- en: Masking services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏蔽服务
- en: These are good skills to have, because you'll be practicing them a lot in your
    routine as a Linux server administrator. So, if you're ready, let's get started.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技能非常实用，因为作为一名 Linux 服务器管理员，你会在日常工作中经常练习它们。所以，如果你准备好了，我们开始吧。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All you need for this chapter is a virtual machine of some sort, with full sudo
    privileges for your own user account. For my demos, I'll be using the brand-new
    AlmaLinux 8 for the Red Hat (RHEL) side of things and Ubuntu Server 20.04 for
    the Ubuntu side.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的仅是某种虚拟机，并且你自己的用户账户需具有完全的 sudo 权限。对于我的演示，我将使用全新的 AlmaLinux 8，代表 RHEL（红帽企业版
    Linux）方面，Ubuntu Server 20.04 代表 Ubuntu 方面。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3oev29P](https://bit.ly/3oev29P)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以观看《代码实战》视频：[https://bit.ly/3oev29P](https://bit.ly/3oev29P)
- en: A word about CentOS Linux
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 CentOS Linux 的说明
- en: I know, you're probably used to seeing CentOS Linux for these demos. But, at
    the end of 2020, the Red Hat company announced that they would end support for
    the enterprise-ready version of CentOS 8 at the end of 2021\. Its replacement,
    CentOS Stream, is a rolling-release distro that you might not want to use in the
    enterprise. Fortunately, there are suitable enterprise-ready replacements for
    CentOS 8 from other organizations, which include Oracle Enterprise Linux 8, Springdale
    Linux 8, and Alma Linux 8\. At the time of writing, Rocky Linux 8 is in the planning
    stages and will eventually be released by a founder of the original CentOS project.
    At this point, it's impossible to know which one will become the most popular
    replacement for CentOS. (Of course, there's also **Red Hat Enterprise Linux 8**
    (**RHEL 8**), but you'll need to purchase a subscription in order to do anything
    meaningful with it.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，你可能习惯于在这些演示中看到 CentOS Linux。但在 2020 年底，Red Hat 公司宣布他们将在 2021 年底停止对 CentOS
    8 企业版的支持。它的替代品 CentOS Stream 是一个滚动发布的发行版，可能不适合在企业中使用。幸运的是，其他组织提供了适合企业的 CentOS
    8 替代品，包括 Oracle Enterprise Linux 8、Springdale Linux 8 和 Alma Linux 8。在撰写本文时，Rocky
    Linux 8 正在规划阶段，最终将由原 CentOS 项目的创始人发布。目前，还无法确定哪个将成为 CentOS 的最受欢迎替代品。（当然，还有 **Red
    Hat Enterprise Linux 8** (**RHEL 8**)，但你需要购买订阅才能进行有意义的操作。）
- en: This is going to be hands-on, folks. So, if you're feeling spry, fire up a virtual
    machine and follow my lead.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个动手操作，大家准备好了吗？如果你有精力，启动一个虚拟机并跟随我一起操作。
- en: Verifying the status of a service
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证服务状态
- en: 'I''ll be using Alma Linux for this first demo, for a reason that will become
    clear in just a moment. First, let''s install the Apache web server by doing the
    following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这次演示中使用 Alma Linux，原因稍后会变得明了。首先，让我们通过以下步骤安装 Apache Web 服务器：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Before you can start using Apache, you'll want to know whether it's enabled,
    so that it will automatically start when you reboot the machine. You'll also want
    to know whether it's active, which just means that it's running.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始使用 Apache 之前，你需要知道它是否已启用，以便在重启机器时自动启动。你还需要知道它是否处于活动状态，即它是否正在运行。
- en: 'To see whether it''s enabled, do the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看它是否已启用，请执行以下操作：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, you see why I'm using a RHEL-type distro for this. When you install a
    service on any RHEL-type machine, it's normally `disabled` by default. When you
    install a service on Ubuntu, it's normally `enabled` by default. So, by doing
    this on Alma Linux, I can give you more to look at.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我为何使用 RHEL 类型的发行版。当你在任何 RHEL 类型的机器上安装服务时，默认情况下它通常是`禁用`的。而在 Ubuntu 上安装服务时，默认情况下它通常是`启用`的。所以，通过在
    Alma Linux 上进行此操作，我可以给你展示更多内容。
- en: 'Next, let''s see whether Apache is running, by doing the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过以下操作查看 Apache 是否正在运行：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Okay, it isn''t. Now, let''s look at both things at once:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，它没有启用。现在，让我们同时查看这两项内容：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are a couple of things that I want you to note about these commands.
    Firstly, if you just want to view information about services, you don''t need
    sudo privileges. Secondly, if you want to do anything with a service, you don''t
    need to append the `.service` filename extension. I mean, you can if you want
    to, and it won''t hurt anything, but you don''t have to. If there are multiple
    types of unit files with the same name, `systemctl` will always invoke the `.service`
    unit by default. For example, the `.service` unit, a `.path` unit, and a `.socket`
    unit, as you can see here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些命令，我有几点想让你注意。首先，如果你只是想查看有关服务的信息，你不需要sudo权限。其次，如果你想对服务进行任何操作，你不需要附加`.service`文件扩展名。我的意思是，你可以附加，且不会有任何问题，但其实不需要。如果有多个类型的单元文件同名，`systemctl`默认会调用`.service`单元。例如，`.service`单元、`.path`单元和`.socket`单元，如你在这里所看到的：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Without a filename extension, `systemctl` will show information about `cups.service`,
    as shown next:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 没有文件扩展名时，`systemctl`将显示有关`cups.service`的信息，如下所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This shows a lot more information about a running service than what the `is-active`
    option does. The `cups.service - CUPS Scheduler` line at the top comes from the
    `Description=CUPS Scheduler` line in the `[Unit]` section of the `cups.service`
    file, and information about the man page comes from the `Documentation=man:cupsd(8)`
    line. The `Main PID:` line shows that the main CUPS process has a `989`. Verify
    that with this handy `ps aux` command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这比`is-active`选项显示的有关正在运行服务的信息要多得多。顶部的`cups.service - CUPS Scheduler`一行来自`cups.service`文件`[Unit]`部分中的`Description=CUPS
    Scheduler`一行，关于手册页的信息来自`Documentation=man:cupsd(8)`一行。`Main PID:`这一行显示主CUPS进程的PID是`989`。通过这个方便的`ps
    aux`命令来验证：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Yes indeed, it is PID `989`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，PID是`989`。
- en: Don't worry about that `CGroup:` line for now. We'll talk about cgroups later.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时不用担心那一行`CGroup:`。我们稍后会讨论cgroups。
- en: The final thing you see is system log entries that got created when the service
    started. On a RHEL-type system, you'll see them in the `/var/log/messages` file.
    On Debian and its offspring, such as Ubuntu, you'll see them in the `/var/log/syslog`
    file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后你会看到系统日志条目，它们在服务启动时创建。在RHEL类型的系统上，你会在`/var/log/messages`文件中看到它们。在Debian及其后代系统（如Ubuntu）上，你会在`/var/log/syslog`文件中看到它们。
- en: 'To see information about the other types of units, you''ll need to append the
    filename extension, as shown:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看其他类型单元的信息，你需要附加文件扩展名，如下所示：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This makes for a shorter display, since there's less to show about `.path` units.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这样显示会更简短，因为`.path`单元的信息较少。
- en: All right, we're off to a good start. Let's get back to that Apache service
    and see what we can do with it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经有了一个好的开端。让我们回到那个Apache服务，看看我们能做些什么。
- en: Starting, stopping, and reloading services
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动、停止和重新加载服务
- en: We've already seen that when you install a service on a RHEL-type distro, such
    as Alma Linux, the service is normally disabled and not active by default. So
    now, I'll give you three guesses about what the command is to start a service.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，当你在RHEL类型的发行版上安装服务时，比如Alma Linux，服务通常是禁用的，默认情况下没有激活。那么现在，我给你三个猜测的机会，猜猜启动服务的命令是什么。
- en: 'Give up? Okay, here''s how we start Apache:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃了吗？好的，下面是如何启动Apache的命令：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Well, that''s easy enough. Let''s take a look at the status. Here''s the first
    part of the command output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这个很简单。让我们来看一下状态。这是命令输出的第一部分：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You see here that the service is active, but that it''s also still disabled.
    This means that if I were to reboot the machine, the service won''t automatically
    start. To see more information, use the `ps aux` command, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里服务是激活的，但它仍然是禁用的。这意味着如果我重启机器，服务不会自动启动。要查看更多信息，可以使用`ps aux`命令，如下所示：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first process listed here as PID `8654` belongs to the root user and is
    the main process that we see in the `systemctl status` output. The next four processes,
    with PIDs `8655` through `8658`, are used whenever someone connects to a website
    on this server and belong to the non-privileged `apache` user. This is a security
    feature that's been built into Apache for pretty much forever and has nothing
    to do with `systemd`. Running these processes under a non-privileged user account
    helps prevent attackers from taking over the system for their own nefarious purposes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的第一个进程，PID为`8654`，属于root用户，是我们在`systemctl status`输出中看到的主要进程。接下来的四个进程，PID从`8655`到`8658`，是每当有人连接到该服务器上的网站时使用的，属于非特权的`apache`用户。这是Apache内建的一个安全特性，几乎从一开始就存在，并且与`systemd`无关。以非特权用户身份运行这些进程有助于防止攻击者为了恶意目的控制系统。
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to see what the rest of the `ps` output means, view the `ps` man
    page by doing:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解其余的`ps`输出是什么意思，可以通过以下命令查看`ps`的手册页：
- en: '`man ps`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`man ps`'
- en: To stop the Apache service, just do `sudo systemctl stop httpd`. (Yeah, I bet
    you didn't see that one coming.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止Apache服务，只需执行`sudo systemctl stop httpd`。 (是的，我敢打赌你没有预料到这一点。)
- en: If you change the configuration of a running service, you'll need to reload
    it. You can do that with the `restart` option, which will restart the service
    and cause the new configuration to be reloaded. Certain services, such as Apache,
    also have the `reload` option. This will read in the new configuration without
    interrupting the running service. Be aware, though, that you can't always use
    `reload`. With Apache, for example, you can use `reload` to reload changes to
    website configuration files, but you'll need to use `restart` to read in certain
    changes to the Apache configuration, such as when you enable or disable an Apache
    module. To see whether `reload` works for any particular service, try consulting
    the documentation for that service.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更改了正在运行的服务的配置，你需要重新加载它。你可以使用`restart`选项，这将重新启动服务并使新的配置生效。某些服务，例如Apache，还具有`reload`选项。这样可以在不中断正在运行的服务的情况下读取新的配置。但是请注意，并非所有情况都可以使用`reload`。例如，在Apache中，你可以使用`reload`来重新加载网站配置文件的更改，但在某些情况下，像启用或禁用Apache模块时，你需要使用`restart`来读取Apache配置的更改。要查看`reload`是否适用于某个特定服务，可以尝试查阅该服务的文档。
- en: 'The specific commands to start, stop, restart, or reload a service can be defined
    in its associated `.service` file. Here are the relevant lines from the `httpd.service`
    file on the Alma machine:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 启动、停止、重启或重新加载服务的具体命令可以在其关联的`.service`文件中定义。以下是来自Alma机器上`httpd.service`文件的相关行：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For now, don''t worry about what the start and reload options you see here
    mean, because that knowledge is specific to Apache, rather than to `systemd`.
    What I do want you to notice is the `ExecReload=` line. We see here that Apache
    has its own built-in way of reloading its configuration. Contrast that with what
    you see in this `sshd.service` file, which is also from the Alma machine:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，不需要担心这里看到的启动和重新加载选项意味着什么，因为这些知识是Apache特有的，而不是`systemd`的内容。我要你注意的是`ExecReload=`这一行。我们可以看到Apache有自己的内建方式来重新加载配置。与此对比，你可以看到这个来自Alma机器的`sshd.service`文件：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we see that the Secure Shell service doesn't have its own internal mechanism
    for reloading its configuration. Instead, it relies on the old-fashioned `kill`
    utility that's been in Linux almost forever. Realize though that `kill` doesn't
    always mean *to kill*. When you use the `kill` utility, it sends a signal to a
    process to make it do something. Normally, you would send a signal that really
    would kill the process. But you can also use it to send the `HUP` signal to a
    service, which will cause the service to reload its configuration without service
    interruption. (In case you're wondering, `HUP` is an acronym for *Hang Up*. The
    original purpose of this signal was to inform running programs when a serial line
    was dropped. However, the purpose of the `HUP` signal has since been changed to
    what it is now.) The `$MAINPID` instance that you see is an environmental variable
    that `systemd` uses to access the PID number of the main Secure Shell process.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到安全外壳（Secure Shell）服务没有自己的内部机制来重新加载配置。相反，它依赖于几乎在Linux中永远存在的传统`kill`工具。不过要意识到，`kill`并不总是意味着*杀死*。当你使用`kill`工具时，它会向进程发送一个信号，让它做某些事情。通常，你会发送一个信号来真正“杀死”进程。但你也可以用它发送`HUP`信号给服务，这会导致服务在不中断的情况下重新加载其配置。（如果你想知道，`HUP`是*挂断*（Hang
    Up）的缩写。这个信号最初的目的是通知正在运行的程序，当串行线路中断时。然而，`HUP`信号的用途已经改变，现在用于让服务重新加载配置。）你看到的`$MAINPID`实例是`systemd`用来访问主Secure
    Shell进程PID的环境变量。
- en: 'Optionally, you can have a line that defines what happens when you issue a
    `stop` command. You don''t see that here on Alma Linux, but you do see it in the
    `apache2.service` file on Ubuntu as shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以添加一行来定义当你发出`stop`命令时发生的事情。你在Alma Linux中看不到这一点，但在Ubuntu的`apache2.service`文件中可以看到，如下所示：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You haven't seen an `ExecRestart=` parameter, because there isn't one. Restarting
    a service just consists of stopping it, and then starting it again.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你没有看到`ExecRestart=`参数，因为没有这个参数。重启服务只是将其停止，然后再启动。
- en: Next up, we'll look at how to enable and disable services.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解如何启用和禁用服务。
- en: Enabling and disabling services
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用和禁用服务
- en: 'It''s all well and good that we have Apache running, but if we were to reboot
    our Alma Linux machine, Apache won''t start until you start it manually. To begin
    this demo, first stop Apache with this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Apache已经在运行，但如果我们重新启动Alma Linux机器，Apache不会自动启动，直到你手动启动它。要开始这个演示，首先用以下命令停止Apache：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, enable it by doing this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过以下方式启用它：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we enable the Apache service, we create a symbolic link in the `/etc/systemd/system/multi-user.target.wants/`
    directory that points back to the `httpd.service` file. Now, I''ve been telling
    you all along that the unit files are in the `/lib/systemd/system/` directory.
    But the eagle-eyed among you will notice that the symbolic link points to the
    service file in the `/usr/lib/systemd/system/` directory. That''s because the
    newer versions of many Linux distros have gotten rid of certain top-level directories
    and now just use the corresponding directories that have always been under the
    `/usr/` directory. But the Linux gurus in the sky have been nice enough to accommodate
    old codgers like me who are used to having those top-level directories. They did
    this by creating symbolic links in the root level of the filesystem, which you
    can see here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启用Apache服务时，我们会在`/etc/systemd/system/multi-user.target.wants/`目录中创建一个指向`httpd.service`文件的符号链接。现在，我一直告诉你，单元文件位于`/lib/systemd/system/`目录。但细心的你会注意到，符号链接指向的是`/usr/lib/systemd/system/`目录中的服务文件。这是因为许多Linux发行版的新版已经删除了某些顶层目录，现在只使用一直位于`/usr/`目录下的相应目录。但天上的Linux大师们很贴心，为像我这样的老派程序员保留了这些顶层目录。他们通过在文件系统的根目录下创建符号链接来实现这一点，你可以在这里看到：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, if you're like me and keep forgetting that those top-level directories are
    no longer there, it's okay. The symbolic links work just fine. But, I digress.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你像我一样总是忘记那些顶层目录不再存在了，没关系。符号链接完全有效。但我有些偏题了。
- en: 'Go into the `/etc/systemd/system/multi-user.target.wants/` directory, and you''ll
    see the symbolic link that got created with our `systemctl enable` command, as
    shown here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`/etc/systemd/system/multi-user.target.wants/`目录，你将看到通过`systemctl enable`命令创建的符号链接，如下所示：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Okay, so you''re now wondering what that `multi-user.target.wants` thing is
    all about. Well, I''ll cover the `.target` concept in detail later. For now, just
    accept that the multi-user target is the *runlevel* in which the operating system
    is fully booted and is ready for normal operations. The `/etc/systemd/system/multi-user.target.wants/`
    directory contains the symbolic links for units that will automatically start
    whenever the operating system goes into multi-user mode. This directory mostly
    contains symbolic links to service units, but it can sometimes have links to other
    types of units. On this Alma Linux machine, there''s also a link to the `cups.path`
    unit, as shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你现在可能在想那个 `multi-user.target.wants` 是怎么回事。那么，我稍后会详细介绍 `.target` 的概念。现在，只需接受多用户目标是操作系统完全启动并准备好正常操作的*运行级别*。`/etc/systemd/system/multi-user.target.wants/`
    目录包含了在操作系统进入多用户模式时会自动启动的单元的符号链接。这个目录主要包含指向服务单元的符号链接，但有时也会包含指向其他类型单元的链接。在这台 Alma
    Linux 机器上，还有一个指向 `cups.path` 单元的链接，如下所示：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To determine where a symbolic link should be created, the `systemctl enable`
    command pulls in the setting from the `[Install]` section of the service file.
    At the bottom of the `httpd.service` file on the Alma machine, you see this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定应该在哪里创建符号链接，`systemctl enable` 命令会从服务文件的 `[Install]` 部分获取设置。在 Alma 机器上的
    `httpd.service` 文件底部，你可以看到这一行：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'At the bottom of the `accounts-daemon.service` file, you''ll see this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `accounts-daemon.service` 文件的底部，你会看到这一行：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The symbolic link for this service, when it's enabled, is in the `/etc/systemd/system/graphical.target.wants/`
    directory.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当该服务被启用时，它的符号链接位于 `/etc/systemd/system/graphical.target.wants/` 目录中。
- en: 'Be aware that when you enable a service that isn''t already running, the service
    doesn''t automatically start until you reboot the machine. You can see that here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当你启用一个尚未运行的服务时，直到你重启机器，服务才会自动启动。你可以在这里看到：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can issue a separate `start` command to start the service, or you can use
    the `enable --now` option to enable and start the service with just a single command,
    as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以发出单独的 `start` 命令来启动服务，或者你可以使用 `enable --now` 选项通过一个命令来启用并启动服务，如下所示：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you disable a unit, the symbolic link for it gets removed. We can see
    that here with the Apache service:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你禁用一个单元时，它的符号链接会被移除。我们可以通过 Apache 服务看到这一点：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the service is running, it will remain running after you issue the `disable`
    command. You can issue a separate `stop` command or use the `disable --now` option
    to disable and stop the service at the same time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务正在运行，执行 `disable` 命令后它仍会保持运行。你可以发出单独的 `stop` 命令，或者使用 `disable --now` 选项同时禁用并停止服务。
- en: 'Now, for you Ubuntu fans, here''s the command to install Apache on your Ubuntu
    machine:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于 Ubuntu 粉丝们，以下是安装 Apache 在你的 Ubuntu 机器上的命令：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you look at the official documentation on the Apache website, you'll see
    that the official way of doing business is to have `httpd` as the name of the
    Apache service. For some strange reason that I've never figured out, Debian developers
    have always marched to the beat of a different drummer in a few different ways.
    Ubuntu is derived from Debian, so Ubuntu developers generally carry on with Debian
    traditions. At any rate, you can try out the preceding commands on an Ubuntu machine
    and just replace `httpd` with `apache2`. The only real difference you'll see is
    that after you initially install Apache on Ubuntu, the service will already be
    enabled and running.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 Apache 网站上的官方文档，你会看到官方的做法是将 `httpd` 作为 Apache 服务的名称。出于某种我至今未能搞明白的原因，Debian
    开发者在一些方面总是采取不同的做法。Ubuntu 源自 Debian，因此 Ubuntu 开发者通常延续 Debian 的传统。无论如何，你可以在 Ubuntu
    机器上尝试前面的命令，只需将 `httpd` 替换为 `apache2`。你唯一会看到的真正区别是，在 Ubuntu 上首次安装 Apache 后，服务将自动启用并运行。
- en: 'Another cool thing you can do is to disable the manual start, stop, and restart
    functions of a service. The best example of this is the `auditd` service on RHEL-type
    machines. In the `[Unit]` section of the `auditd.service` file on my Alma machine,
    we see the line that does that:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以做的另一个酷炫的事情是禁用服务的手动启动、停止和重启功能。最好的例子是 RHEL 类型机器上的 `auditd` 服务。在我 Alma 机器上的
    `auditd.service` 文件的 `[Unit]` 部分，我们可以看到执行这一操作的这一行：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Trying to restart the service gives me the following error message:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试重新启动服务会给我以下错误信息：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Curiously, though, I can manually stop or restart the `auditd` service just
    fine if I use the old-fashioned `service` command from the SysV days, as we see
    here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，如果我使用老式的`service`命令（来自SysV时代），我可以手动停止或重新启动`auditd`服务，就像我们在这里看到的那样：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: I can understand why we'd want to restrict the ability to stop or restart `auditd`,
    since it is related to system security. But I've never understood why RHEL maintainers
    prevent users from doing it with `systemctl`, yet still allow us to do it with
    `service`. It's just one of those things that makes you go *Hmmmmm*. It's also
    interesting to note that when you install `auditd` on Ubuntu, you won't see the
    line that disables these functions. So, on Ubuntu, you can stop and restart `auditd`
    with `systemctl` in the normal manner.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以理解为什么我们要限制停止或重新启动`auditd`的权限，因为它与系统安全相关。但我从未理解为什么 RHEL 的维护者阻止用户使用`systemctl`进行操作，却仍允许我们用`service`来做。这就是那种让人不禁想“嗯……”的事情。另一个有趣的现象是，当你在
    Ubuntu 上安装`auditd`时，你不会看到禁用这些功能的那一行。因此，在 Ubuntu 上，你可以按正常方式使用`systemctl`来停止和重新启动`auditd`。
- en: Next, let's look at the proper way to kill a service.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下正确的杀死服务的方法。
- en: Killing a service
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杀死一个服务
- en: 'It''s sad, I know, but even on Linux things can sometimes crash. A great example
    is the Firefox web browser. Have you ever accidentally landed on a malicious web
    page that completely locked up your browser? I mean, you can''t close the tab,
    there''s an obnoxious noise blaring out of your computer speakers, and you can''t
    close the browser in the normal way. You''re just stuck. (Don''t be embarrassed
    about it if you have, it''s happened to all of us.) On a Linux machine, you''d
    get out of that by opening a terminal, using `ps aux | grep firefox` to find the
    PID for Firefox, and then issuing a `kill` command. For example, let''s say that
    the PID for Firefox is `3901`. To kill it, just do:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这很伤心，但即使在 Linux 上，事情有时也会崩溃。一个很好的例子就是 Firefox 浏览器。你有没有在不小心打开恶意网页时，浏览器完全卡住了的情况？就是说，你无法关闭标签页，电脑扬声器里传来刺耳的噪音，而且你也无法以正常方式关闭浏览器。你只能无奈地卡住。（如果你遇到过这种情况，不要觉得尴尬，这发生过在我们每个人身上。）在
    Linux 机器上，你可以通过打开终端，使用`ps aux | grep firefox`来找到 Firefox 的 PID，然后发出`kill`命令来解决。比如说，假设
    Firefox 的 PID 是`3901`，要终止它，只需执行：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'By default, this will send a number `15`, or `SIGTERM`, signal to Firefox,
    which will give the process a chance to clean up after itself by shutting down
    any associated files or network connections. Sometimes, if a process is locked
    up really badly, the number `15` signal won''t do the trick. For times like these,
    you''ll need to pop the cork off a bottle of strong medicine and use the number
    `9`, or `SIGKILL`, signal, like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这将向 Firefox 发送一个数字`15`，或者`SIGTERM`信号，给该进程一个机会通过关闭任何关联的文件或网络连接来进行自我清理。有时候，如果一个进程被严重锁定，数字`15`信号可能无法奏效。在这种情况下，你需要采取强力措施，使用数字`9`，或者`SIGKILL`信号，像这样：
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The number `9` signal is something you don't want to use unless you absolutely
    have to. It stops processes dead in their tracks, without giving them time to
    clean up after themselves.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 数字`9`信号是你除非绝对必要，否则不想使用的信号。它会直接停止进程，而不给它们清理的机会。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about the various Linux signals, you''ll want to look
    at the signal man page on your Ubuntu machine. (For some reason, the man page
    on the Alma Linux machine doesn''t have nearly as much information.) The command
    is:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于各种 Linux 信号的信息，你可以查看你 Ubuntu 机器上的信号手册页面。（出于某种原因，Alma Linux 机器上的手册页面没有那么多信息。）命令是：
- en: '`man signal`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`man signal`'
- en: 'Back in the SysV days, you would use the same method to kill troublesome services,
    except that you''d need sudo privileges to do it, because services don''t run
    under your own user account. The problem with that is that some services spawn
    more than one active process, and a normal `kill` command might not shut them
    all down. Those services might linger on as *zombie* processes until the operating
    system finally reaps them and gets rid of them. (When I say *reaps*, think of
    the Grim Reaper who drives stakes into the hearts of zombies to finally kill them
    off. Oh, wait. The stake in the heart thing is for vampires, so never mind.) A
    good example of this would be the Apache service. We''ve already seen that the
    Apache service spawns multiple processes when it starts, and that''s just on a
    machine that isn''t yet running active websites. On an actual production web server,
    Apache might spawn multiple other processes for CGI scripts, PHP scripts, or whatever
    else. If you ever need to kill Apache, you''ll want to make sure that those script
    processes also get killed, especially if they might be doing something malicious.
    On my Ubuntu machine with `systemd`, I''ll do that with the `sudo systemctl kill
    apache2` command. The results should look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SysV 时期，你会使用相同的方法来终止有问题的服务，唯一不同的是你需要 `sudo` 权限来执行此操作，因为服务不会在你的用户帐户下运行。问题在于，有些服务会启动多个活动进程，而普通的
    `kill` 命令可能无法终止它们所有。这些服务可能会以 *僵尸* 进程的形式继续存在，直到操作系统最终回收它们并将其清除。（当我说 *回收* 时，想象一下死神将尖木桩刺入僵尸心脏来最终杀死它们。哦，等等，刺心脏的是吸血鬼，而不是僵尸，所以算了。）一个很好的例子是
    Apache 服务。我们已经看到，Apache 服务在启动时会生成多个进程，这仅仅是在没有运行任何活动网站的机器上。在实际的生产 Web 服务器上，Apache
    可能会为 CGI 脚本、PHP 脚本或其他任何东西生成多个进程。如果你需要终止 Apache，务必确保那些脚本进程也被终止，特别是当它们可能正在做一些恶意的事情时。在我使用
    `systemd` 的 Ubuntu 机器上，我会通过 `sudo systemctl kill apache2` 命令来完成这个操作。结果应该如下所示：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As with the normal `kill` command, this sends a number `15`, or `SIGTERM`,
    signal by default. If you need to send another signal, use the `-s` option along
    with the signal name. To see what happens with that, I''ll start Apache back up
    on my Ubuntu machine, and send it the number `9`, or `SIGKILL` signal, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通的 `kill` 命令一样，默认情况下它发送数字 `15`，即 `SIGTERM` 信号。如果你需要发送其他信号，请使用 `-s` 选项并指定信号名称。为了看到发生了什么，我将在我的
    Ubuntu 机器上重新启动 Apache，并发送数字 `9`，即 `SIGKILL` 信号，像这样：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Oh, dear. That didn''t do anything for us, did it? To see why, let''s look
    in the `apache2.service` file. In the `[Service]` section, you''ll find the answer:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，这对我们没有任何作用，是吧？为了查看原因，让我们看看 `apache2.service` 文件。在 `[Service]` 部分，你会找到答案：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The last line in the `[Service]` section, the `Restart=on-abort` line, causes
    Apache to automatically restart if it receives an unclean kill signal. It so happens
    that `SIGKILL` is considered unclean. You can see the explanation for this in
    the `systemd.service` man page. Open the page and scroll down to Table 2, and
    you''ll find the different options for the `Restart=` parameter as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Service]` 部分中的最后一行，即 `Restart=on-abort` 行，表示如果 Apache 收到不干净的杀死信号，它会自动重启。恰好
    `SIGKILL` 被认为是不干净的信号。你可以在 `systemd.service` 手册页中查看对此的解释。打开该页面并向下滚动到表格 2，你会找到 `Restart=`
    参数的不同选项，如下所示：'
- en: '![](img/B17491_4.1_Table.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17491_4.1_Table.jpg)'
- en: Figure 4.1 – Table 2 from the systemd.service man page
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 来自 systemd.service 手册页的表格 2
- en: In the paragraphs just above and just below *Table 2*, you'll see explanations
    for the different options and how they affect using the various kill signals.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *表格 2* 上下的段落中，你会看到有关不同选项的解释，以及它们如何影响使用各种杀死信号。
- en: 'Back on the Alma Linux machine, things are a bit different. In its `httpd.service`
    file, there''s no `Restart=` line. Instead, we see these lines:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Alma Linux 机器上，情况稍有不同。在它的 `httpd.service` 文件中，没有 `Restart=` 行。相反，我们看到这些行：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `KillSignal=` line changes the default kill action from `SIGTERM` to `SIGWINCH`.
    This is curious, because `SIGWINCH` is supposed to kill a process only if the
    terminal window from which the process is running gets resized. Apache normally
    doesn''t run from a terminal window. Still, somebody at Red Hat apparently decided
    that `SIGWINCH` would be the appropriate signal for killing Apache gracefully,
    so that''s how it is. The `KillMode=mixed` line tells `systemd` to send a `SIGTERM`
    signal to the main Apache process but to send `SIGKILL` to the remaining processes
    in the Apache control group. The `systemd.kill` man page doesn''t say what this
    line does when the preceding `KillSignal=` line is set to `SIGWINCH`, but I would
    assume that it will replace `SIGTERM` with `SIGWINCH`. Anyway, let''s try to kill
    Apache on the Alma machine, just to see what happens:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`KillSignal=`行将默认的杀死动作从`SIGTERM`更改为`SIGWINCH`。这很奇怪，因为`SIGWINCH`应该只在进程所在的终端窗口大小发生变化时才会终止进程。而
    Apache 通常并不在终端窗口中运行。不过，看起来 Red Hat 的某些人决定将`SIGWINCH`作为优雅地终止 Apache 的信号，所以就这么定了。`KillMode=mixed`行告诉`systemd`向主
    Apache 进程发送`SIGTERM`信号，但向 Apache 控制组中的其余进程发送`SIGKILL`信号。`systemd.kill`手册页面没有说明当前面的`KillSignal=`行设置为`SIGWINCH`时这一行的作用，但我猜它会将`SIGTERM`替换为`SIGWINCH`。无论如何，让我们试着在
    Alma 机器上终止 Apache，看看会发生什么：'
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It looks just the same as it did on the Ubuntu machine. Send Apache a `SIGKILL`
    though, and you''ll see something different as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来和在 Ubuntu 机器上没什么区别。不过，向 Apache 发送`SIGKILL`信号时，你会看到不同的结果，如下所示：
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Without the `Restart=on-abort` line that Ubuntu has in its `apache2.service`
    file, the Apache service on Alma won't automatically restart when it receives
    the `SIGKILL` signal. Note that the `is-active` output shows `failed` rather than
    `inactive`, as it does when you use `SIGTERM` or `SIGWINCH`. Either way, the service
    isn't running, so the end result is the same.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 Ubuntu 在其`apache2.service`文件中的`Restart=on-abort`行，Alma 上的 Apache 服务在接收到`SIGKILL`信号时不会自动重启。请注意，`is-active`的输出显示为`failed`，而不是使用`SIGTERM`或`SIGWINCH`时显示的`inactive`。无论如何，服务并没有运行，因此最终结果是一样的。
- en: Okay, that's all good. But what if you want to prevent a service from ever running?
    Well, you'd mask it, which is what we'll look at next.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，一切正常。但是，如果你想防止某个服务运行呢？嗯，你可以将它屏蔽，这就是我们接下来要看的内容。
- en: Masking a service
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏蔽服务
- en: 'Now, let''s say that you have a service that you never want to start, either
    manually or automatically. You can accomplish this by masking the service, like
    this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个服务，你希望它永远不启动，无论是手动启动还是自动启动。你可以通过像这样将其屏蔽来实现：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This time, instead of creating a symbolic link that points back to the service
    file, we''ve created one that points to the `/dev/null` device. Let''s try to
    start our masked Apache service to see what happens:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不是创建一个指向服务文件的符号链接，而是创建了一个指向`/dev/null`设备的符号链接。让我们尝试启动我们屏蔽的 Apache 服务，看看会发生什么：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you change your mind, just use the `unmask` option.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你改变主意，只需使用`unmask`选项。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've covered a good bit of ground in this chapter, and even got to do some
    cool hands-on stuff. We looked at how to start, stop, restart, and reload services.
    We also looked at how to enable and disable services and looked at the symbolic
    links that get created when we enable a service. We wrapped things up by showing
    how to kill a service, and then how to mask a service. As a side benefit, we saw
    what some service parameters can do for us and how the maintainers of different
    Linux distros can set up services to behave differently on different distros.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这一章里已经覆盖了很多内容，甚至做了一些有趣的实操。我们学习了如何启动、停止、重启和重新加载服务。我们还了解了如何启用和禁用服务，并查看了启用服务时创建的符号链接。最后，我们展示了如何终止服务，以及如何屏蔽服务。作为附带收获，我们了解了一些服务参数的作用，以及不同
    Linux 发行版的维护者如何设置服务，使其在不同的发行版上行为有所不同。
- en: But what if you don't like the way that a service is set up on the distro that
    you're using? No worries. We'll discuss that in the next chapter, when we talk
    about editing and creating service unit files. I'll see you there.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你不喜欢在你使用的发行版中服务的设置怎么办？不用担心，我们将在下一章讨论这个问题，届时我们会讲解如何编辑和创建服务单元文件。我在那时见。
- en: Questions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: When you run the `sudo systemctl enable httpd` command, what will that do for
    you?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行`sudo systemctl enable httpd`命令时，这会为你做什么？
- en: a. It will start the `httpd` service.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 它会启动`httpd`服务。
- en: b. It will cause `httpd` to start when you boot the machine and will also do
    an immediate start.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 它会导致`httpd`在启动机器时启动，并且还会立即启动。
- en: c. It will only cause `httpd` to start when you reboot the machine.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 它只会在你重启机器时启动 `httpd`。
- en: d. It creates a symbolic link in the `/lib/systemd/system/` directory.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 它在 `/lib/systemd/system/` 目录下创建一个符号链接。
- en: What is the effect of using the normal `kill` command on a service?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用普通的 `kill` 命令对服务的影响是什么？
- en: a. It will shut down the service cleanly.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 它会干净地关闭服务。
- en: b. It will shut down the main service process, but it might not shut down the
    spawned processes.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 它会关闭主服务进程，但可能不会关闭生成的进程。
- en: c. It won't shut down a service.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 它不会关闭一个服务。
- en: d. You can use `kill` without sudo privileges to shut down a service.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 你可以在没有 `sudo` 权限的情况下使用 `kill` 关闭一个服务。
- en: What is the `SIGTERM` signal?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 `SIGTERM` 信号？
- en: a. It kills a process dead in its tracks without giving it a chance to clean
    up after itself.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 它会立即杀死一个进程，不给它任何清理的机会。
- en: b. It kills a process when it detects that a terminal window has been resized.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 当检测到终端窗口大小改变时，它会杀死一个进程。
- en: c. It restarts a process.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 它重新启动一个进程。
- en: d. It kills a process gracefully, giving it time to clean up after itself.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 它优雅地终止一个进程，给它时间进行清理。
- en: How would you enable and start the `httpd` service with just one command?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何仅用一条命令启用并启动 `httpd` 服务？
- en: a. You can't
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 你不能
- en: b. `sudo systemctl enable httpd`
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. `sudo systemctl enable httpd`
- en: c. `sudo systemctl start httpd`
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. `sudo systemctl start httpd`
- en: d. `sudo systemctl start --now httpd`
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. `sudo systemctl start --now httpd`
- en: e. `sudo systemctl enable --now httpd`
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e. `sudo systemctl enable --now httpd`
- en: What does the `ExecRestart=` parameter do for us?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ExecRestart=` 参数为我们做了什么？'
- en: a. It defines how to restart the service.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 它定义了如何重新启动服务。
- en: b. It defines how to reload the service configuration.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 它定义了如何重新加载服务配置。
- en: c. Nothing, because this parameter doesn't exist.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 什么都没有，因为这个参数不存在。
- en: d. It defines how to start a service.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 它定义了如何启动一个服务。
- en: Answers
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: c
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: b
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: d
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: e
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: e
- en: c
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: Further reading
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'My *Managing Services* video: [https://youtu.be/IuDmg75n6FU](https://youtu.be/IuDmg75n6FU)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 *管理服务* 视频：[https://youtu.be/IuDmg75n6FU](https://youtu.be/IuDmg75n6FU)
- en: 'How to manage `systemd` services: [https://www.howtogeek.com/216454/how-to-manage-systemd-services-on-a-linux-system/](https://www.howtogeek.com/216454/how-to-manage-systemd-services-on-a-linux-system/.)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如何管理 `systemd` 服务：[https://www.howtogeek.com/216454/how-to-manage-systemd-services-on-a-linux-system/](https://www.howtogeek.com/216454/how-to-manage-systemd-services-on-a-linux-system/.)
