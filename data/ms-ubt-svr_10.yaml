- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Connecting to Networks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到网络
- en: Linux networks took the IT industry by storm. Many organizations use Linux in
    their data centers, on both physical servers and in the cloud. Ubuntu Server is
    among the most popular choices for running mission-critical applications, but
    without a stable network to connect the individual components of your infrastructure
    together, even the most powerful server hardware will be ineffective.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 网络席卷了 IT 行业。许多组织在其数据中心使用 Linux，包括物理服务器和云服务器。Ubuntu Server 是运行关键任务应用程序最受欢迎的选择之一，但如果没有稳定的网络将基础设施的各个组件连接起来，即使是最强大的服务器硬件也将无效。
- en: So far in this book, we’ve worked with a single Ubuntu Server instance. Here,
    we begin a two-part look at networking in Linux. In this chapter, we’ll discuss
    topics related to initial network connectivity and remote management. We’ll continue
    learning additional networking topics in *Chapter 11*, *Setting Up Network Services*,
    where we’ll work on building and configuring additional components that will enable
    your servers to communicate more effectively, which will result in a strong foundational
    network that will serve your needs for years to come.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中我们一直使用单一的 Ubuntu Server 实例。在这里，我们开始对 Linux 网络进行两部分的探讨。本章将讨论与初始网络连接和远程管理相关的主题。我们将在*第11章*、*设置网络服务*中继续学习更多的网络话题，届时我们将构建和配置额外的组件，使您的服务器能够更有效地进行通信，从而建立一个强大的基础网络，满足您未来多年的需求。
- en: 'In this episode of our Ubuntu adventure, we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 Ubuntu 探险的这一章节中，我们将讨论：
- en: Setting the hostname
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置主机名
- en: Managing network interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理网络接口
- en: Assigning static IP addresses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配静态 IP 地址
- en: Understanding Linux name resolution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Linux 名称解析
- en: Getting started with OpenSSH
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 OpenSSH
- en: Getting started with SSH key management
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 SSH 密钥管理
- en: Simplifying SSH connections with a config file
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过配置文件简化 SSH 连接
- en: To get started in our exploration of networking, we should first give each of
    our Ubuntu servers its own identity; basically, we should give them a name to
    help distinguish each from the others.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索网络的过程中，首先应该为每台 Ubuntu 服务器分配一个唯一的身份；基本上，我们应该给它们一个名字，以便帮助区分它们之间的差异。
- en: Setting the hostname
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置主机名
- en: During installation, you were asked to create a hostname for your server. Specifically,
    the field was labeled `Your server's name` during the initial setup process. At
    that time, our goal was to simply get an Ubuntu Server installation set up for
    working through the examples in this book. At this point, you may consider changing
    the hostname of your server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，您被要求为您的服务器创建一个主机名。具体来说，在初始设置过程中，字段被标记为 `Your server's name`。那时，我们的目标只是简单地设置一个
    Ubuntu Server 实例，以便在本书中进行示例演示。现在，您可能考虑更改服务器的主机名。
- en: When we utilize OpenSSH to remotely manage our servers (as we’ll do later on
    in this chapter), the hostname is shown on the command line. That can be very
    confusing if all servers have the same name. More importantly, the hostname of
    a server gives it an identity. When it comes to real production deployments of
    Ubuntu Server, each individual server should have its own designated purpose,
    and be named accordingly. Often, organizations will have their own naming scheme.
    Perhaps web servers in a company are named similar to `webserver-01`, or with
    a fully qualified domain name, such as `webserver-01.example.com`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 OpenSSH 远程管理服务器（正如本章后面将要做的那样）时，主机名会显示在命令行上。如果所有服务器的名称都相同，这可能会让人感到非常困惑。更重要的是，服务器的主机名赋予了它一个身份。在实际的
    Ubuntu Server 生产部署中，每台服务器应该有其特定的用途，并相应地命名。通常，组织会有自己的命名方案。比如，公司的 web 服务器可能被命名为类似于
    `webserver-01`，或者使用完全限定的域名，例如 `webserver-01.example.com`。
- en: In this book, I won’t assume any particular naming scheme, so when we do work
    through changing the hostname, feel free to adjust the name as you see fit. If
    you don’t have a naming scheme (but would like to create one) feel free to get
    creative. I’ve seen quite a few variations, from naming servers after cartoon
    characters (who wouldn’t want a server named `daffy-duck`?), to Greek gods or
    goddesses. Some companies choose to be a bit boring and come up with naming schemes
    consisting of a series of characters separated by hyphens, with codes representing
    which rack the server is in, as well as its purpose. You can create your own naming
    convention if you haven’t already, and no matter what you come up with, I won’t
    judge you.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我不会假设使用任何特定的命名方案，因此，当我们讨论更改主机名时，你可以根据需要调整名称。如果你没有命名方案（但想要创建一个），可以尽情发挥创意。我见过许多不同的命名方式，从以卡通人物命名服务器（谁不想有一台名为`daffy-duck`的服务器？）到希腊神话中的神祇。一些公司选择更为简单的命名方案，使用由连字符分隔的一系列字符，其中包含服务器所在机架的代码，以及服务器的用途。如果你还没有命名方案，可以自己创造一个。不管你最终选择什么，我都不会评价你。
- en: As I mentioned, the hostname of your server is its identity. It identifies your
    server to the rest of the network. While a simple hostname, such as `ubuntu`,
    is fine if you have just one host, it would get confusing really quickly if you
    kept the default on every Ubuntu Server within your network. Giving each server
    a descriptive name helps you tell them apart from each other. But there’s more
    to a server’s name than its hostname, which we’ll get into in *Chapter 11*, *Setting
    Up Network Services*, when we discuss DNS. But for now, we’ll work through viewing
    and configuring the hostname, so you’ll be ready to make your hostname official
    with a DNS assignment, when we come to it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，服务器的主机名就是它的身份标识。它向网络中的其他设备标识你的服务器。虽然像`ubuntu`这样的简单主机名对于只有一个主机的情况是可以接受的，但如果在你的网络中每台
    Ubuntu 服务器都保留默认的主机名，很快就会变得混乱。为每台服务器命名一个描述性的名称有助于你区分它们。但是，服务器的名称不仅仅是主机名，更多内容将在*第11章*，*设置网络服务*中讨论，当我们讲解
    DNS 时会详细说明。现在，我们将介绍如何查看和配置主机名，等到我们讲到 DNS 时，你可以将主机名正式化并进行 DNS 分配。
- en: 'So, how do you view your hostname? One way is to simply look at your shell
    prompt; you’ve probably already noticed that your hostname is included there.
    While you can customize your shell prompt in many different ways, the default
    shows your current hostname. However, depending on what you’ve named your server,
    it may or may not show the entire name. Basically, the default prompt (known as
    a **PS1 prompt**, in case you were wondering) shows the hostname only until it
    reaches the first period. For example, if your hostname is `dev.mycompany.org`,
    your prompt will only show `dev`. To view the entire hostname, simply enter the
    `hostname` command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何查看你的主机名呢？一种方法是直接查看你的 shell 提示符；你可能已经注意到，主机名已经包含在提示符中。虽然你可以通过许多方式自定义 shell
    提示符，但默认情况下会显示当前的主机名。然而，根据你为服务器命名的方式，它可能会或不会显示完整的名称。通常，默认的提示符（如果你在想的话，它被称为**PS1
    提示符**）只显示主机名，直到第一个句点为止。例如，如果你的主机名是`dev.mycompany.org`，那么提示符只会显示`dev`。要查看完整的主机名，只需输入`hostname`命令：
- en: '![Graphical user interface, application  Description automatically generated](img/B18425_10_01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序 描述自动生成](img/B18425_10_01.png)'
- en: 'Figure 10.1: Output from the hostname command'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：hostname命令的输出
- en: 'Changing the hostname is fairly simple. To do this, we can use the `hostnamectl`
    command as `root` or with `sudo`. If, for example, I’d like to change my hostname
    from `dev.mynetwork.org` to `dev2.mynetwork.org`, I would execute the following
    command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 更改主机名是相当简单的。我们可以使用`hostnamectl`命令作为`root`用户或通过`sudo`来执行。例如，如果我想将主机名从`dev.mynetwork.org`更改为`dev2.mynetwork.org`，我会执行以下命令：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Simple enough, but what does that command actually do? Well, I’d love to give
    you a fancy outline, but all it really does is change the contents of a text file
    (specifically, `/etc/hostname`). To see this for yourself, feel free to use the
    `cat` command to view the contents of this file before and after making the change
    with `hostnamectl`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但这个命令究竟做了什么呢？嗯，我很想给你一个复杂的概述，但实际上它只是更改了一个文本文件的内容（具体来说，是`/etc/hostname`文件）。你可以通过在更改前后使用`cat`命令查看这个文件的内容来验证这一点：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You’ll see that this file contains only your hostname.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这个文件只包含你的主机名。
- en: 'Once you change your hostname, you may start seeing an error message similar
    to the following after executing some commands:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你更改了主机名，执行某些命令后，可能会看到类似以下的错误信息：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This error means that the computer is no longer able to resolve your local
    hostname. This is due to the fact that the `/etc/hostname` file is not the only
    file where your hostname is located; it’s also referenced in `/etc/hosts`. Unfortunately,
    the `hostnamectl` command doesn’t update `/etc/hosts` for you, so you’ll need
    to edit that file yourself to make the error go away. Here’s what an `/etc/hosts`
    file looks like on an example server:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误意味着计算机无法再解析您的本地主机名。这是因为`/etc/hostname`文件并不是唯一存放您主机名的文件；它还被引用于`/etc/hosts`。不幸的是，`hostnamectl`命令不会为您更新`/etc/hosts`，因此您需要自己编辑该文件以消除错误。以下是一个示例服务器上`/etc/hosts`文件的示例：
- en: '![Text  Description automatically generated](img/B18425_10_02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成的文本描述](img/B18425_10_02.png)'
- en: 'Figure 10.2: Sample contents from an /etc/hosts file'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：来自`/etc/hosts`文件的示例内容
- en: 'The first two entries, in this example, refer to the local machine itself.
    Localhost addresses, also known as **loopback addresses**, allow the machine to
    essentially reach itself. If you were to use the `ping` command against the `127.0.0.1`
    address, the reply would come from the machine that executed the command, not
    from another host on the network. On the first line, we have the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个条目在此示例中指代本地机器本身。本地主机地址，也称为**环回地址**，允许机器直接访问自身。如果您对`127.0.0.1`地址使用`ping`命令，回复将来自执行该命令的机器，而不是网络中的另一台主机。在第一行上，我们有以下内容：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you were to use any networking command to attempt to communicate with the
    local server, such as pinging `127.0.0.1` or `localhost`, the `/etc/hosts` file
    on this line declares that this communication is directed toward the underlying
    server itself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要使用任何网络命令尝试与本地服务器通信，例如ping `127.0.0.1`或`localhost`，则该行上的`/etc/hosts`文件声明此通信是针对底层服务器本身的。
- en: 'With the second line in the example screenshot, we have the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例截图的第二行中，我们有以下内容：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Depending on your configuration, such as whether you are using a physical server,
    a virtualization platform, or a cloud server provider, that line may or may not
    be present. You can add that line if it’s missing, but we’ll talk about that more
    in a moment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的配置，例如是否使用物理服务器、虚拟化平台或云服务器提供商，该行可能存在，也可能不存在。如果缺少该行，您可以添加它，但我们稍后会更详细地讨论这个问题。
- en: Essentially, that particular line identifies that the local server can also
    be reached at the IP address `127.0.1.1`, the fully qualified domain name of `dev.mynetwork.org`,
    as well as the simplified form of `dev`. A fully qualified domain name consists
    of the name of the server (`dev` in this case) as well as the domain name for
    the organization (`mynetwork.org` in this example). This enables you to ping your
    local server directly from that server by using the name `dev.mynetwork.org` or
    the simplified form of `dev`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，该特定行标识出本地服务器还可以通过IP地址`127.0.1.1`、完全限定域名`dev.mynetwork.org`以及简化形式`dev`访问。完全限定域名包括服务器名称（在此例中为`dev`）以及组织的域名（例如此示例中的`mynetwork.org`）。这使您可以通过使用名称`dev.mynetwork.org`或简化形式`dev`直接从该服务器ping本地服务器。
- en: 'If you don’t have a domain name to use with your servers, you can leave the
    fully qualified domain name out of the `/etc/hosts` file. So in our example, that
    line would look like the following if there was no domain:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有要与服务器一起使用的域名，可以在`/etc/hosts`文件中省略完全限定的域名。因此，在我们的示例中，如果没有域名，该行将如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Going back to our example of changing a hostname on a server, I mentioned that
    you can use the `hostnamectl` command to do that, but that command doesn’t update
    the `/etc/hosts` file for you, it only updates the `/etc/hostname` file. It’s
    a best practice to also update the `/etc/hosts` file to match. You can avoid using
    the `hostnamectl` command altogether and manually edit the `/etc/hosts` and `/etc/hostname`
    files, which is actually my preferred method. If I have to manually edit a text
    file, regardless of whether or not I use the `hostnamectl` command, I figure that
    I may as well use a text editor for both.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们更改服务器主机名的示例，我提到您可以使用`hostnamectl`命令来执行此操作，但该命令不会为您更新`/etc/hosts`文件，它只会更新`/etc/hostname`文件。最佳做法是同时更新`/etc/hosts`文件以保持一致。您可以完全避免使用`hostnamectl`命令，并手动编辑`/etc/hosts`和`/etc/hostname`文件，这实际上是我更喜欢的方法。如果我必须手动编辑文本文件，无论是否使用`hostnamectl`命令，我认为最好还是使用文本编辑器来处理。
- en: The main takeaway, though, is to give your servers an identity that makes sense
    and matches the role that the server will fill within your network. At a typical
    organization, you’ll have web servers, file servers, database servers, and more.
    A consistent and logical naming scheme will just make everything that much easier.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的收获是，给你的服务器赋予一个合理且与其在网络中角色相匹配的身份。在典型的组织中，你会有 Web 服务器、文件服务器、数据库服务器等等。一个一致且合乎逻辑的命名方案会使得所有事情变得更加简单。
- en: Now that we have learned how to give our servers an identity, we can learn how
    to manage network interfaces.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何为服务器赋予身份，接下来可以学习如何管理网络接口。
- en: Managing network interfaces
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理网络接口
- en: Networking is critical for server infrastructure. Without a network, servers
    cannot communicate with one another, and users will be unable to access them.
    In order for a server to connect to a network, it needs to have a network interface
    installed. Most servers will have a standard wired Ethernet adapter installed,
    allowing you to plug in a network cable to connect it to a switch. Assuming our
    server’s hardware has been properly detected by Ubuntu, this is handled pretty
    much automatically. However, the automatic configuration is not always ideal.
    Perhaps we want to customize the IP address or settings related to the connection.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 网络对于服务器基础设施至关重要。如果没有网络，服务器无法相互通信，用户也无法访问它们。为了让服务器连接到网络，需要安装网络接口。大多数服务器会安装标准的有线以太网适配器，使你能够插入网络电缆并将其连接到交换机。如果我们的服务器硬件已被
    Ubuntu 正确识别，那么这一过程基本上是自动完成的。然而，自动配置并不总是理想的。也许我们希望自定义 IP 地址或与连接相关的设置。
- en: 'First, we need to understand how to view the current connection parameters
    that the network card of our server currently has in effect. That’s the main goal
    of this section. We can do so using two basic commands: `ip` (which is recommended)
    and `ifconfig` (which was the previous method in older versions of Ubuntu, and
    its usage is no longer recommended).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解如何查看当前网络卡在服务器中生效的连接参数。这是本节的主要目标。我们可以使用两个基本命令来实现：`ip`（推荐使用）和 `ifconfig`（这是在
    Ubuntu 的早期版本中使用的方法，现在不再推荐使用）。
- en: 'We can review information regarding our network interfaces and manage them
    with the `ip` command. For example, we can use `ip addr show` to view our currently
    assigned IP address:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `ip` 命令查看和管理我们的网络接口信息。例如，我们可以使用 `ip addr show` 来查看当前分配的 IP 地址：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will produce an output similar to that shown in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似于以下截图的输出：
- en: '![Text  Description automatically generated](img/B18425_10_03.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Text  Description automatically generated](img/B18425_10_03.png)'
- en: 'Figure 10.3: Viewing IP information with the ip addr show command'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3：使用 `ip addr show` 命令查看 IP 信息
- en: Once you enter that command, you should see output that pertains to the network
    interfaces that you have available and their current status. Also, you can abbreviate
    the command all the way down to simply `ip a` (the output will be the same in
    either case). From the output, we can see several useful tidbits, such as the
    IP address for each device (if it has one), as well as its MAC address.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 输入该命令后，你应该会看到与可用的网络接口及其当前状态相关的输出。另外，你可以将命令简化为 `ip a`（无论哪种方式，输出都会相同）。从输出中，我们可以看到一些有用的信息，比如每个设备的
    IP 地址（如果有的话），以及它的 MAC 地址。
- en: 'Using the `ip` command, we can also manage the state of an interface. We can
    bring a device down (prevent it from connecting to networks), and then back up
    again:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ip` 命令，我们还可以管理接口的状态。我们可以将设备关闭（阻止它连接到网络），然后再将其启动：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In that example, I’m simply toggling the state for interface `enp0s3`. First,
    I’m bringing it down, and then I’m bringing it back up again.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我只是切换了接口 `enp0s3` 的状态。首先，我将其关闭，然后再将其重新启动。
- en: Bringing interfaces up and down is all well and good, but what’s up with that
    naming convention? The convention used in Ubuntu 22.04 may seem a bit strange
    for those of you that have grown accustomed to the scheme used in earlier versions,
    which utilized network interface names such as `eth0`, `wlan0`, and so on. Since
    Ubuntu is based on Debian, it has adopted the new naming convention that was introduced
    starting with Debian 9.0.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 启动和关闭接口是好的，但那种命名规则是什么情况呢？对于那些习惯于早期版本使用的命名方案（如 `eth0`、`wlan0` 等）的用户来说，Ubuntu
    22.04 使用的命名规则可能会显得有些奇怪。由于 Ubuntu 基于 Debian，因此它采用了从 Debian 9.0 开始引入的新命名规则。
- en: The new naming convention has been put in place in order to make interface naming
    more predictable. While you may argue that names such as `eth0` may be easier
    to memorize than something like `enp0s3`, the change helps the name stay persistent
    between boots. When you add new network interfaces to a Linux system, there’s
    always the possibility that other interface names may change as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 新的命名约定被引入是为了使接口命名更加可预测。虽然你可能认为像`eth0`这样的名称比`enp0s3`更容易记住，但这个变化有助于使名称在启动时保持一致。当你向Linux系统添加新的网络接口时，其他接口名称发生变化的可能性始终存在。
- en: For example, if you have an older Linux installation on a server with a single
    network card (`eth0`) and you add a second (which is given the name `eth1`), your
    configuration may break if the names were to get switched during the next boot.
    Imagine for a moment that one interface is connected to the internet and another
    connected to a switch (basically, you have an internet gateway). If the interfaces
    came up in the wrong order, internet access would be disrupted for your entire
    office, due to the fact that the firewall rules you’ve written are being applied
    to the wrong interfaces. Definitely not a pleasant experience!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在一台服务器上安装了较旧的Linux版本，并且该服务器有一个网络卡（`eth0`），然后你添加了第二个网络卡（命名为`eth1`），那么如果在下次启动时接口名称顺序发生了变化，可能会导致你的配置出现问题。假设一个接口连接到了互联网，另一个连接到了交换机（基本上，你拥有一个互联网网关）。如果接口顺序错乱，整个办公室的互联网连接将会中断，因为你编写的防火墙规则应用到了错误的接口上。显然，这并不是一种愉快的体验！
- en: 'In the past, previous versions of Ubuntu (as well as Debian, and even CentOS)
    have opted to use `udev` to make the names stick in order to work around this
    issue. This is no longer necessary nowadays, but I figured I’d mention it here
    just in case you end up working on a server with an older installation. These
    older servers would achieve stickiness with interface names from configuration
    stored in the following file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，Ubuntu的早期版本（以及Debian，甚至CentOS）选择使用`udev`来使网络接口名称保持不变，以解决这个问题。如今，这已经不再必要，但我还是想在这里提一下，以防你碰到的是一个老版本的服务器。这些老服务器通过存储在以下文件中的配置来实现接口名称的固定：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This file existed on older versions of some popular Linux distributions (including
    Ubuntu), as a workaround to this problem. This file contains some information
    that identifies specific qualities of the network interface, so that with each
    boot, it will always come up with the same name. Therefore, the card you recognize
    as `eth0` will always be `eth0`. If you have an older version of Ubuntu Server
    in use, you should be able to see this file for yourself. Here’s some sample output
    of this file on an older installation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件在一些流行的Linux发行版的早期版本中存在（包括Ubuntu），作为解决该问题的一个变通方法。这个文件包含了一些信息，用来识别网络接口的特定属性，因此每次启动时，它都会使用相同的名称。因此，你所熟悉的`eth0`始终会是`eth0`。如果你使用的是较旧版本的Ubuntu服务器，应该能够自己查看到这个文件。下面是这个文件在老旧安装中的一些示例输出：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, it’s using the MAC address of the card to identify it with `eth0`.
    But this becomes a small problem if I want to take an image of this machine and
    re-deploy it onto another server. This is a common practice—we administrators
    rarely start over from scratch if we don’t have to, and if another server is similar
    enough to a new server’s desired purpose, cloning it will be an option. However,
    when we restore the image onto another server, the `/etc/udev/rules.d/70-persistent-net-rules`
    file will come along for the ride. We’ll more than likely find that the new server’s
    first network interface will have a designation of `eth1`, even if we only have
    one interface.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它是通过卡的MAC地址来识别`eth0`的。但是如果我想将这台机器的镜像拍摄并重新部署到另一台服务器上，这就成了一个小问题。这是一个常见的做法——我们管理员通常不会轻易从头开始，除非没有选择。如果另一台服务器与新服务器的需求足够相似，克隆它将是一个可行的选项。然而，当我们将镜像恢复到另一台服务器时，`/etc/udev/rules.d/70-persistent-net-rules`文件也会一起迁移。我们很可能会发现，新的服务器的第一个网络接口会被命名为`eth1`，即使我们只有一个接口。
- en: This is because the file already designated a device as `eth0` (it’s referencing
    a device that’s not present in the system), so we would need to correct this file
    ourselves in order to reclaim `eth0`. We would do that by editing the `rules`
    file, deleting the line that contains the card that’s not on the system, and then
    changing the device designation on the remaining line back to `eth0`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为文件已经将设备指定为`eth0`（它引用了系统中不存在的设备），所以我们需要自己修正这个文件以重新占用`eth0`。我们可以通过编辑`rules`文件，删除包含系统中不存在的网卡的那一行，然后将剩余行中的设备名称改回`eth0`来完成这个操作。
- en: The new naming scheme is effective as of `systemd v197` and later (in case you
    didn’t already know from earlier topics in this book, `systemd` is the underlying
    framework utilized in Ubuntu for managing processes and various resources). For
    the most part, the new naming convention references the physical location of the
    network card on your system’s bus.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 新的命名方案从`systemd v197`及更高版本开始生效（如果你之前没有了解过，本书早些部分提到过，`systemd`是Ubuntu用于管理进程和各种资源的底层框架）。大多数情况下，新的命名规范参考了网络卡在系统总线上的物理位置。
- en: Therefore, the name it receives cannot change unless you were to actually remove
    the network card and place it in a different slot on the system’s board, or change
    the position of the virtual network device in your hypervisor.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它获得的名称除非你真的将网卡移除并将其放入系统板上的其他插槽，或者在虚拟化管理程序中更改虚拟网络设备的位置，否则无法更改。
- en: As a quick overview of how the network names break down, `en` is for Ethernet,
    and `wl` is for wireless. Therefore, we know that the example interface I mentioned
    earlier (`enp0s3`) references a wired card. The `p` references which bus is being
    used, so `p0` refers to the system’s first PCI bus (the numbering starts at 0).
    Next, we have `s3`, which references PCI slot 3\. Putting it together, `enp0s3`
    references a wired network interface card on the system’s first bus, placed in
    PCI slot 3\. The exact details of the new naming specification could even be a
    chapter of its own, but hopefully this gives you a general idea of how the new
    naming convention breaks down. There’s much more documentation online if you’re
    interested in the nitty-gritty details (see the *Further reading* section). The
    important point here is that since the new naming scheme is based on where the
    card is physically located, it’s much less likely to change abruptly. In fact,
    it can’t change, as long as you don’t physically switch the positions of your
    network cards inside the case.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 简单概述一下网络名称的组成：`en`表示以太网，`wl`表示无线网络。因此，我们知道我之前提到的示例接口（`enp0s3`）代表的是一个有线网卡。`p`表示使用的是哪条总线，`p0`表示系统的第一条PCI总线（编号从0开始）。接下来是`s3`，它代表的是PCI插槽3。把这些放在一起，`enp0s3`代表的是系统第一条总线上放置在PCI插槽3的有线网络接口卡。新的命名规范的详细内容甚至可以单独成章，但希望这能给你一个大概的了解。网上有更多关于这个细节的文档，如果你有兴趣了解更深入的信息，可以查看*进一步阅读*部分。这里需要强调的重点是，由于新的命名方案基于网卡的物理位置，因此它不太可能会突然改变。实际上，只要你不物理地更换网卡在机箱内的位置，它是不会改变的。
- en: Getting back to managing our interfaces, another command worth discussion is
    `ifconfig`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们如何管理网络接口，另一个值得讨论的命令是`ifconfig`。
- en: The `ifconfig` command is part of the `net-tools` suite of utilities, which
    has been deprecated (for the most part). Its replacement is the `iproute2` suite
    of utilities, which includes the `ip` command we’ve already discussed. In summary,
    this basically means you should be using commands from the `iproute2` suite, instead
    of commands such as `ifconfig`. The problem, though, is that most administrators
    nowadays still use `ifconfig`, with no sign of it slowing down. In fact, the `net-tools`
    suite has been recommended for deprecation for years now, and many Linux distributions
    shipping today still have this suite installed by default. Those that don’t have
    it installed offer it as an additional package that you can install. In the case
    of Ubuntu Server 22.04, the `net-tools` package is no longer installed by default,
    but it’s still available if you want to manually install it. I don’t recommend
    installing it though, since it’s deprecated and shouldn’t be used anymore.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifconfig` 命令是 `net-tools` 工具套件的一部分，该套件大部分已被弃用。它的替代工具是 `iproute2` 套件，其中包括我们已经讨论过的
    `ip` 命令。总结来说，这意味着你应该使用 `iproute2` 套件中的命令，而不是 `ifconfig` 之类的命令。问题是，如今大多数管理员仍然使用
    `ifconfig`，而且这种趋势没有减弱的迹象。事实上，`net-tools` 套件已被推荐弃用多年，许多今天出厂的 Linux 发行版仍然默认安装这个套件。那些没有安装它的发行版，提供它作为额外的软件包供你安装。在
    Ubuntu Server 22.04 中，`net-tools` 包不再默认安装，但如果你想手动安装，它仍然可用。不过，我不推荐安装它，因为它已被弃用，不再应该使用。'
- en: The reason commands such as `ifconfig` have a tendency to stick around so long
    after they’ve been deprecated usually comes down to the *change is hard* mentality,
    but quite a few scripts and programs out there are still using `ifconfig`, and
    therefore it’s worth discussing here. Even if you immediately stop using `ifconfig`,
    and move to `ip` from now on, you’ll still encounter this command on your travels,
    so you may as well know a few examples. Knowing the older commands will also help
    you if you find yourself on an older server.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如 `ifconfig` 之类的命令之所以在被弃用后仍然存在，通常归结于 *改变是困难的* 这种心态，但仍有相当多的脚本和程序在使用 `ifconfig`，因此在这里讨论它是有价值的。即使你立即停止使用
    `ifconfig`，并从今以后改用 `ip`，你仍然会在旅途中遇到这个命令，所以了解一些例子还是很有帮助的。如果你碰到老旧的服务器，了解旧命令也能帮你解决问题。
- en: First, when executed by itself with no options, `ifconfig` will print information
    regarding your interfaces like we did with `ip addr show` earlier. That seems
    pretty simple.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当单独执行 `ifconfig` 且没有任何选项时，它会打印有关你的网络接口的信息，就像我们之前使用 `ip addr show` 所做的那样。这看起来很简单。
- en: 'If you are unable to use `ifconfig` to view interface information using a normal
    user, try using the fully qualified command (include the full path):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用普通用户时无法通过 `ifconfig` 查看接口信息，可以尝试使用完整路径的命令（包括完整路径）：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `/usr/sbin` directory may or may not be in your `$PATH` (a set of directories
    your shell looks within for commands), so if your system doesn’t recognize `ifconfig`,
    using the fully qualified command should produce the desired output, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`/usr/sbin` 目录可能在你的 `$PATH` 中，也可能不在（这是一个 shell 查找命令的目录集合），所以如果你的系统无法识别 `ifconfig`，使用完整路径命令应该能够输出你想要的结果，如下所示：'
- en: '![Text  Description automatically generated](img/B18425_10_04.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18425_10_04.png)'
- en: 'Figure 10.4: Viewing interface information with the ifconfig command'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4：使用 `ifconfig` 命令查看接口信息
- en: 'Secondly, just like with the `ip` commands we practiced earlier, we can also
    bring an interface down or up with `ifconfig` as well:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，就像我们之前练习的 `ip` 命令一样，我们也可以通过 `ifconfig` 来禁用或启用一个接口：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are, of course, other options and variations of `ip` and `ifconfig`, so
    feel free to look up the man pages for either if you want more information. For
    the purposes of this section, the main thing is to remember how to view your current
    IP assignments, as well as how to bring an interface up or down.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`ip` 和 `ifconfig` 还有其他选项和变化，所以如果你需要更多信息，可以随时查阅它们的手册页。在本节中，主要需要记住的是如何查看当前的
    IP 分配，以及如何启用或禁用一个接口。
- en: As useful as our network interfaces can be, they’re useless without an IP address
    assigned to them. While a network will often use DHCP to take care of this, in
    the next section we’ll take a look at how to assign a static IP address.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的网络接口非常有用，但如果没有分配 IP 地址，它们就毫无用处。虽然网络通常会使用 DHCP 来处理这项工作，但在下一节中，我们将看看如何分配静态
    IP 地址。
- en: Assigning static IP addresses
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配静态 IP 地址
- en: With servers, it’s very important that your IP addresses remain fixed and do
    not change for any reason. If an IP address does change (such as a dynamic lease
    with no reservation), your users will experience an outage, services will fail,
    or entire sites may become unavailable. When you install Ubuntu Server, it will
    grab a dynamically assigned lease from your DHCP server, but after you configure
    the server the way you want it, it’s important to set a permanent IP address right
    away before it’s considered production-ready. One exception to this rule is an
    Ubuntu-based VPS. Cloud providers that bill you for these servers will have an
    automatic system in place to declare an IP address for your new VPS, and will
    already have it configured to remain in place. But in the case of virtual or physical
    servers you manage yourself, you’ll start off with a dynamic address, unless you’ve
    already configured a static IP address during installation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器来说，确保 IP 地址固定且不发生变化非常重要。如果 IP 地址发生变化（例如没有保留的动态租约），用户将会遇到中断，服务将会失败，甚至整个网站可能无法访问。当你安装
    Ubuntu Server 时，它会从 DHCP 服务器获取一个动态分配的租约，但在你配置好服务器并准备投入生产之前，重要的是要立即设置一个永久的 IP 地址。这个规则的唯一例外是基于
    Ubuntu 的 VPS。提供这些服务器的云服务商会有自动系统为你的新 VPS 声明一个 IP 地址，并且已经配置好使其保持不变。但对于你自己管理的虚拟或物理服务器来说，除非你在安装时已经配置了静态
    IP 地址，否则它们一开始会是动态地址。
- en: In most cases, you’ll have an IP address scheme in place at your office or organization,
    which will outline a range of IP addresses that are available for use with static
    assignments. If you don’t have such a scheme, it’s important to create one, so
    you will have less work to do later when you bring more servers online. We’ll
    talk about setting up a DHCP server and IP address scheme in *Chapter 11*, *Setting
    Up Network Services*, but for now, I’ll give you a few quick tips. Your DHCP server
    will typically have a range of IP addresses that will be automatically assigned
    to any host that requests an assignment. When setting up a static IP on a server,
    you’ll want to make sure that the IP address that you choose is outside of the
    range that your DHCP server assigns so you don’t end up with a duplicate IP on
    your network. For example, if your DHCP server assigns IPs ranging from `10.10.10.100`
    through `10.10.10.150`, you’ll want to use an IP address *not* included within
    that range for your servers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你的办公室或组织会有一个 IP 地址方案，其中会列出可用于静态分配的 IP 地址范围。如果你没有这样的方案，重要的是要创建一个，这样当你添加更多服务器时，会减少后续的工作量。我们将在*第
    11 章*，*设置网络服务*中讨论如何设置 DHCP 服务器和 IP 地址方案，但现在我会给你一些快速提示。你的 DHCP 服务器通常会有一个 IP 地址范围，自动分配给任何请求分配的主机。在为服务器设置静态
    IP 时，你需要确保所选择的 IP 地址不在 DHCP 服务器分配的范围内，这样就不会在网络中产生重复的 IP 地址。例如，如果你的 DHCP 服务器分配的
    IP 范围是从`10.10.10.100`到`10.10.10.150`，你就应该选择一个*不*包含在该范围内的 IP 地址来给服务器使用。
- en: There are two ways of assigning a fixed address to a network host, including
    your servers. The first is by using a static IP assignment, as I’ve already mentioned.
    With that method, you’ll arbitrarily grab an IP address that’s not being used
    by anything, and then configure your Ubuntu Server to use that address. In that
    case, your server is never requesting an IP address from your network’s DHCP server.
    It simply uses whatever you assign it. This is the method I’ll be going over in
    this section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 给网络主机（包括你的服务器）分配固定地址有两种方法。我之前提到过第一种方法，即使用静态 IP 分配。使用这种方法，你可以任意选择一个没有被任何设备使用的
    IP 地址，然后配置你的 Ubuntu 服务器使用该地址。在这种情况下，服务器不会向网络的 DHCP 服务器请求 IP 地址，而是直接使用你分配给它的地址。这就是我将在本节中讲解的方法。
- en: The other way of assigning a fixed address to a server is by using a static
    lease. This is also known as a **DHCP reservation**, but I prefer to use the former
    term. With this method, you configure your DHCP server to assign a specific IP
    address to specific hosts. In other words, your server will request an IP address
    from your local DHCP server, and your DHCP server is instructed to give a specific
    address to your server each time it asks for one. This is the method I prefer,
    because it makes your DHCP server the single source of truth for the IP addresses
    that are assigned on your network. I’ll go over it in more detail in *Chapter
    11*, *Setting Up Network Services*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务器分配固定地址的另一种方法是使用静态租约。这也被称为**DHCP保留**，但我更倾向于使用前者的术语。通过这种方法，您配置DHCP服务器将特定的IP地址分配给特定的主机。换句话说，您的服务器将从本地DHCP服务器请求IP地址，您的DHCP服务器被指示每次请求时都给服务器一个特定的地址。这是我喜欢的方法，因为它使得您的DHCP服务器成为网络上分配的IP地址的唯一真实来源。我会在*第11章*，*设置网络服务*中详细介绍这一点。
- en: However, you don’t always have a choice. As a Linux administrator, you may or
    may not be in charge of the DHCP server. It’s often the case at many organizations
    that administrators that manage servers are not the same individuals that also
    manage the network.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非总是有选择的余地。作为Linux管理员，您可能并不负责DHCP服务器。在许多组织中，管理服务器的管理员通常与管理网络的个人不同。
- en: If you don’t have authority over the design of the network, you’d use an IP
    address that would be provided to you by your network administrator, and then
    you’ll proceed to configure your Ubuntu Server to use it by applying the parameters
    they give you.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无权设计网络，您将使用由网络管理员提供的IP地址，并根据他们给出的参数配置您的Ubuntu服务器来使用它。
- en: 'Within the last several years, the method that we utilize to customize the
    IP address of our servers has changed from the way it was handled in the past.
    Since Ubuntu 17.10, which was released back in 2017, configuring your IP address
    settings is now done via Netplan. In the past, we would configure networking via
    NetworkManager, but that’s installed only by default in Ubuntu Desktop. With Netplan,
    configuration files for your network interfaces now reside in the `/etc/netplan`
    directory, in YAML format. Explaining the YAML format itself is beyond the scope
    of this book, but the syntax is very easy to follow so you don’t really need to
    thoroughly understand this format in order to configure your network interfaces.
    If you list the contents of the `/etc/netplan` directory, you should see at least
    one file there, often named `00-installer-config.yaml` or `50-cloud-init.yaml`.
    It’s possible the file could be saved with a different name, so check the contents
    of the `/etc/netplan` directory to see what the file is named on your end. On
    one of my servers, I see the following contents in the `/etc/netplan/00-installer-config.yaml`
    file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，我们用来自定义服务器IP地址的方法已经从过去的方式改变了。自Ubuntu 17.10发布以来，即2017年，配置IP地址设置现在通过Netplan完成。过去，我们会通过NetworkManager配置网络，但这只在Ubuntu桌面版中默认安装。通过Netplan，网络接口的配置文件现在以YAML格式存储在`/etc/netplan`目录中。本书不涵盖YAML格式本身的解释，但其语法非常易于理解，因此您在配置网络接口时无需深入理解这种格式。如果列出`/etc/netplan`目录的内容，您应该至少看到一个文件，通常命名为`00-installer-config.yaml`或`50-cloud-init.yaml`。文件可能以不同的名称保存，因此请检查`/etc/netplan`目录的内容以查看文件在您那里的名称。在我的一台服务器上，我在`/etc/netplan/00-installer-config.yaml`文件中看到以下内容：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can already glean some obvious information from this default file. First,
    the comment at the beginning mentions `subiquity`, which is the official name
    of the Ubuntu Server installer, used when you install the distribution from boot
    media created from the ISO file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经可以从这个默认文件中获取一些明显的信息。首先，开头的注释提到了`subiquity`，这是Ubuntu服务器安装程序的官方名称，在您使用从ISO文件创建的引导介质安装分发时使用。
- en: 'More importantly, we can see that this particular server is configured to utilize
    DHCP in order to grab an IP address, which we can tell from the following line:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们可以看到这台特定服务器配置为使用DHCP来获取IP地址，这可以从以下一行中看出：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also tell that this configuration file pertains to interface `enp0s3`.
    Putting it all together, this file is telling us that interface `enp0s3` is configured
    to automatically obtain an IP address via DHCP. If we’d like to convert this configuration
    to a static IP address instead, we should first back up the file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看出，这个配置文件与接口`enp0s3`相关。综合来看，这个文件告诉我们接口`enp0s3`已配置为通过DHCP自动获取IP地址。如果我们想将此配置更改为静态IP地址，首先应备份文件：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This way, if we make a mistake, we can easily restore the original file by
    renaming the backup file to the original name. This is a good practice to get
    into, regardless of the file we’re editing. Being able to restore a previous configuration
    is a best practice for just about any change we might be making. The first change
    we need to make is to remove the following line (or just change it to `false`):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，如果我们犯了错误，我们可以通过将备份文件重命名为原文件名来轻松恢复原始文件。这是一个很好的做法，适用于我们编辑的任何文件。能够恢复之前的配置是我们进行任何更改时的最佳实践。我们需要做的第一项更改是删除以下这一行（或者将其改为`false`）：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Essentially, to set up a static IP we will replace that line with the details
    specific to our configuration. Here’s an example of the file, configured for a
    static IP address:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，要设置静态IP，我们将用特定于我们配置的详细信息替换那一行。这是一个为静态IP地址配置的文件示例：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the example, I’ve bolded four lines, which were added in place of the `dhcp4:
    true` line. First, we set the actual IP address:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个示例中，我已经将四行加粗，这些行是替代`dhcp4: true`行所添加的。首先，我们设置实际的IP地址：'
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There, I’ve used an example IP address of `192.168.100.50/24`. On your end,
    you would make sure that the IP address you choose is within the scope of the
    network you’d like your server to be a part of. As I mentioned earlier, the IP
    address you choose should *not* be within the DHCP scope that automatically assigned
    IP addresses are chosen from. The preceding IP address would be fine if the example
    scope of the DHCP server on your network ranged from `192.168.100.100` to `192.168.100.150`.
    The IP chosen here of `192.168.100.50` is outside of that, so we don’t have to
    worry about another device being assigned that address.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了一个示例IP地址`192.168.100.50/24`。在你的环境中，你需要确保选择的IP地址位于你希望服务器加入的网络范围内。正如我之前提到的，你选择的IP地址*不能*在自动分配IP地址的DHCP范围内。如果你的网络上DHCP服务器的示例范围是从`192.168.100.100`到`192.168.100.150`，那么前面的IP地址就没有问题。这里选择的`192.168.100.50`在这个范围外，因此我们不需要担心会有其他设备被分配到这个地址。
- en: We also include `/24` to declare that the IP address is part of a 24-bit **subnet**,
    which is fairly standard unless your network administrator has set up a larger
    scope. An `/24` network is the same as a Class C network, in case that’s more
    familiar to you. This also takes care of the subnet mask, which we don’t need
    here since `/24` implies the same subnet mask as `255.255.255.0` (if you’re more
    familiar with the classful style, which shows the subnet mask in the same format
    as an IP address). We will discuss subnets in *Chapter 11*, *Setting Up Network
    Services*; however, a full walk-through of subnetting and the TCP/IP protocol
    would be more fitting for a book dedicated to networking concepts, so we won’t
    go anymore into detail than necessary.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了`/24`来声明IP地址是24位**子网**的一部分，这是相当标准的，除非你的网络管理员设置了更大的范围。`/24`网络等同于C类网络，如果这个说法更熟悉的话。这也解决了子网掩码的问题，我们这里不需要设置，因为`/24`意味着子网掩码为`255.255.255.0`（如果你更熟悉传统的网络分类样式，它会像IP地址一样显示子网掩码）。我们将在*第11章*，*设置网络服务*中讨论子网问题；不过，完整的子网划分和TCP/IP协议的介绍更适合放在专门讲解网络概念的书中，因此我们不会进一步展开讨论。
- en: 'Moving on, we also set up the gateway:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还需要设置网关：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When it comes to networking, the gateway refers to the device your outbound
    connections are routed through, which will often be a router or firewall, depending
    on how your network is set up. This value will need to match the actual default
    gateway address on your network, which is quite often the same as the IP address
    with the last portion being `.1`. If in doubt, you can check the IP address assignment
    of another device on the same network you’re joining the Ubuntu server to, which
    would be the same.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络配置中，网关指的是你的出站连接所通过的设备，这通常是路由器或防火墙，具体取决于你的网络设置。此值需要与网络中实际的默认网关地址匹配，默认网关地址通常与IP地址的最后一部分为`.1`。如果不确定，你可以检查连接到相同网络的另一台设备的IP地址，它应该是相同的。
- en: 'The last section allows us to configure the DNS server that our server will
    use to look up external domain names:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分允许我们配置服务器用来查找外部域名的 DNS 服务器：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The example configuration is just that, an example—all the values must match
    whatever is appropriate for your network. Often, the DNS server IP address will
    be the same as the gateway address, but that’s not always true. Sometimes a network
    administrator will have a custom IP scheme for DNS servers. I also added a secondary
    DNS server in the example, `192.168.100.2`, but you can remove the second IP address
    if that’s not necessary.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 示例配置仅仅是一个示例——所有值必须与适合你网络的设置相匹配。通常，DNS 服务器的 IP 地址与网关地址相同，但并非总是如此。有时，网络管理员会为 DNS
    服务器设置自定义 IP 方案。在示例中我还添加了一个次级 DNS 服务器 `192.168.100.2`，但如果不需要，可以删除第二个 IP 地址。
- en: 'Once you’ve ensured that the values in the file are appropriate, we’ll need
    to apply and test these changes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认文件中的值是合适的，我们需要应用并测试这些更改：
- en: If you are using a virtual machine, you may want to make the changes from the
    virtual machine console
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在使用虚拟机，你可能想要从虚拟机控制台进行更改
- en: If you’re updating a physical machine, you may want to have a display and keyboard
    attached
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在更新一台物理机器，你可能需要连接显示器和键盘。
- en: Although we discuss OpenSSH later in this chapter, if you’re already aware of
    how to connect to a server via OpenSSH, you probably won’t want to change network
    configuration over OpenSSH, since as soon as you activate these changes your connection
    will drop
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管我们在本章稍后讨论 OpenSSH，如果你已经知道如何通过 OpenSSH 连接到服务器，你可能不希望在 OpenSSH 中更改网络配置，因为一旦激活这些更改，你的连接将会断开。
- en: Just take your time and double-check everything to ensure you didn’t mistype
    anything, so you won’t find yourself with a server that cannot connect.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 慢慢来，仔细检查一切，确保没有输入错误，这样就不会遇到无法连接的服务器问题。
- en: 'To actually make these changes take effect, you can run the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这些更改生效，你可以运行以下命令：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When you run the previous command, it will let you know if there are any errors
    in the file or apply the changes if not. The new IP address will take effect immediately.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行之前的命令时，它会告诉你文件中是否有错误，如果没有错误则会应用更改。新的 IP 地址会立即生效。
- en: 'In the case of utilizing remote connections such as OpenSSH while configuring
    networking, you can work around the issue of being disconnected and having networking
    not restart properly by using `tmux`, a popular terminal multiplexer. A full run-through
    of `tmux` is beyond the scope of this book, but it is helpful to us in this scenario
    because it keeps commands running in the background, even if our connection to
    the server gets dropped. To use it, first install the package:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在配置网络时使用像 OpenSSH 这样的远程连接，你可以通过使用 `tmux`（一个流行的终端多路复用器）来解决断开连接和网络无法正确重启的问题。关于
    `tmux` 的完整教程超出了本书的范围，但在这个场景中它对我们非常有帮助，因为即使我们与服务器的连接丢失，它也能保持命令在后台运行。要使用它，首先安装该软件包：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then, activate `tmux` by simply typing `tmux` in your shell prompt.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需在你的终端提示符下输入 `tmux` 来激活 `tmux`。
- en: From this point on, `tmux` is now responsible for your session. If you run a
    command within `tmux`, it will continue to run, regardless of whether or not you’re
    attached to it. To see this in action, first enter `tmux` and then execute the
    `top` command. While `top` is running, disconnect from `tmux`. To do that, press
    *Ctrl* + *b* on your keyboard, release, and then press *d*. You’ll exit `tmux`,
    but if you enter the `tmux a` command to reattach your session, you’ll see that
    `top` was still running even though you disconnected. Following this same logic,
    you can activate `tmux` prior to executing the `sudo netplan apply` command.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从此时起，`tmux` 就负责你的会话。如果你在 `tmux` 中运行一个命令，它会继续运行，无论你是否已连接到它。要看到这一点，首先进入 `tmux`，然后执行
    `top` 命令。当 `top` 正在运行时，从 `tmux` 断开连接。为此，在键盘上按 *Ctrl* + *b*，松开后，再按 *d*。你将退出 `tmux`，但是如果你输入
    `tmux a` 命令重新连接会话，你会发现即使断开了连接，`top` 仍然在运行。按照这种逻辑，你可以在执行 `sudo netplan apply` 命令之前启动
    `tmux`。
- en: Most likely, you’ll still get dropped from your shell, since the process of
    activating network changes brings the network interface down and then back up
    again, but with `tmux` the command will complete in the background. You can then
    reconnect to the server and run `tmux a` to rejoin your `tmux` session.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，你仍然会被从 shell 中断开，因为激活网络更改的过程会使网络接口关闭并重新启动，但使用`tmux`时，命令会在后台完成。然后，你可以重新连接到服务器，并运行`tmux
    a`以重新加入你的`tmux`会话。
- en: 'The `tmux` utility is extremely powerful, and when harnessed can really enhance
    your workflow when using the Linux shell. Although a complete tutorial is outside
    the scope of this book, I highly recommend looking into using it, which you can
    do here: [https://www.packtpub.com/hardware-and-creative/getting-started-tmux](https://www.packtpub.com/hardware-and-creative/getting-started-tmux).
    If you need some guidance with it, check out the video guide on LearnLinuxTV that
    will be linked at the end of this chapter.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmux`工具非常强大，当正确使用时，它可以显著提升你在使用 Linux shell 时的工作效率。虽然本书无法详细讲解完整教程，但我强烈建议你深入了解如何使用它，你可以在这里找到更多信息：[https://www.packtpub.com/hardware-and-creative/getting-started-tmux](https://www.packtpub.com/hardware-and-creative/getting-started-tmux)。如果你需要一些指导，可以查看
    LearnLinuxTV 上的视频教程，链接将在本章末尾提供。'
- en: With networking restarted, you should be able to immediately reconnect to the
    server and see that the new IP assignment has taken place by executing `ip a`.
    If, for some reason, you cannot reconnect to the server, you may have made a mistake
    while editing the configuration file for Netplan. Double-check that file for any
    errors. But as long as you’ve followed along and typed in the proper values for
    your interface and network, you should be up and running with a static IP assignment.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 网络重启后，你应该能够立即重新连接到服务器，并通过执行`ip a`来查看新的 IP 分配是否已生效。如果由于某种原因无法重新连接到服务器，可能是你在编辑
    Netplan 配置文件时犯了错误。请仔细检查该文件，确保没有错误。但只要你按照步骤操作，并为你的接口和网络输入了正确的值，就应该能够成功配置静态 IP。
- en: Now, we have an actual network—we’ve named our server(s) and configured our
    network interfaces. We should also understand how name resolution works in Ubuntu,
    which is the process in which servers are able to find other servers by their
    name.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了实际的网络——我们已经为服务器命名并配置了网络接口。我们还应了解 Ubuntu 中的名称解析工作原理，这是服务器通过名称查找其他服务器的过程。
- en: Understanding Linux name resolution
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Linux 名称解析
- en: In *Chapter 11*, *Setting Up Network Services*, we’ll have a discussion on setting
    up a DNS server for local name resolution for your network. But before we get
    to that, it’s also important to understand how Linux resolves names in the first
    place. Most of you are probably aware of the concept of a **Domain Name System**
    (**DNS**), which matches human-understandable domain names to IP addresses. This
    makes browsing your network (as well as the internet) much easier. However, a
    DNS isn’t always the first thing that your Linux server will use when resolving
    names.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第11章*，*设置网络服务*中，我们将讨论为本地名称解析设置 DNS 服务器的过程。但在此之前，理解 Linux 如何解析名称是很重要的。你们中的大多数人可能都知道**域名系统**（**DNS**）的概念，它将人类可理解的域名映射到
    IP 地址。这使得浏览网络（以及互联网）变得更加轻松。然而，DNS 并不是 Linux 服务器在解析名称时首先使用的工具。
- en: 'For more information on the order in which Ubuntu Server checks resources to
    resolve names, feel free to take a look at the `/etc/nsswitch.conf` file. There’s
    a line in this file that begins with the word `hosts`. Here is the output of the
    relevant line from the file on my server:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解 Ubuntu Server 在解析名称时检查资源的顺序，欢迎查看`/etc/nsswitch.conf`文件。该文件中有一行以`hosts`开头。以下是我服务器中该行的输出：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case, the server is configured to first check local files, and then
    the DNS if the request isn’t found. This is the default order, and I see little
    reason to make any changes here (but you certainly can). Specifically, the file
    the server will check is `/etc/hosts`. If it doesn’t find what it needs there,
    it will move on to the DNS (basically, it will check the DNS server we configured
    earlier with Netplan, or the default server provided by DHCP).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，服务器配置为首先检查本地文件，如果未找到请求的信息，则检查 DNS。这是默认顺序，我认为没有理由在这里进行更改（但你当然可以）。具体来说，服务器将检查的文件是`/etc/hosts`。如果在那里找不到所需内容，它将转向
    DNS（基本上，它会检查我们之前通过 Netplan 配置的 DNS 服务器，或者由 DHCP 提供的默认服务器）。
- en: There are many other lines in the `nsswitch.conf` file, but I won’t discuss
    them here as they are out of scope of the topic of this section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`nsswitch.conf`文件中还有许多其他行，但由于超出了本节的讨论范围，我在这里不再讨论。'
- en: The `/etc/hosts` file, which we briefly discussed while working with our hostname,
    tells our server how to resolve itself (it has a hostname mapping to the localhost
    IP of `127.0.0.1`), but you are also able to create additional names to IP mappings
    here as well.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在讨论主机名时简要提到了`/etc/hosts`文件，它告诉我们的服务器如何解析自身（它有一个主机名映射到本地主机 IP `127.0.0.1`），但你也可以在这里创建其他名称到
    IP 的映射。
- en: 'For example, if I had a server (`myserver.mydomain.org`) at IP `10.10.96.124`,
    I could add the following line to `/etc/hosts` to make my machine resolve the
    server to that IP each time, without it needing to consult a DNS server at all:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我有一台服务器（`myserver.mydomain.org`）的 IP 地址是`10.10.96.124`，我可以在`/etc/hosts`中添加以下行，使得每次都能将我的机器解析到该
    IP，而不需要查询 DNS 服务器：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In practice though, this is usually not a very convenient method by which to
    configure name resolution. Don’t get me wrong, you can certainly list your servers
    in this file along with their IP addresses, and your server would be able to resolve
    those names just fine. The problem stems from the fact that this method is difficult
    to maintain. The name mappings apply only to the server you’ve made the `/etc/hosts`
    changes on; other servers wouldn’t benefit since they would only check their own
    `/etc/hosts` file. You could add a list of servers to the `hosts` file on each
    of your servers, but that would be a pain to manage. This is the main reason why
    having a central DNS server is a benefit to any network, especially for resolving
    the names of local resources.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际上，这通常不是一个非常方便的配置名称解析的方法。别误会，我并不是说你不能在这个文件中列出你的服务器和它们的 IP 地址，你的服务器肯定能解析这些名称。问题在于，这种方法很难维护。名称映射仅适用于你在其上修改了`/etc/hosts`文件的服务器；其他服务器无法受益，因为它们只会检查自己的`/etc/hosts`文件。你可以在每个服务器的`hosts`文件中添加服务器列表，但那会很麻烦。这也是为什么拥有一个中央
    DNS 服务器对任何网络都有好处，尤其是在解析本地资源名称时。
- en: However, the `/etc/hosts` file is used every now and again in the enterprise
    as a quick one-off workaround, and you’ll probably eventually end up needing to
    use this method for one reason or another. One very common reason to use such
    a manual method of resolving names is in the case where you’re testing a replacement
    server. In that case, you can configure the `/etc/hosts` file to have the same
    name as the original server, but with the IP address of the new server. Once you
    finish testing and confirm that the new server is operating properly, you can
    then replace the network-wide DNS name to point to the new IP address.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`/etc/hosts`文件偶尔仍在企业中作为快速的临时解决方案使用，最终你可能因某种原因需要使用这种方法。使用这种手动名称解析方法的一个非常常见的原因是在测试替换服务器的情况下。此时，你可以将`/etc/hosts`文件配置为与原始服务器相同的名称，但使用新服务器的
    IP 地址。完成测试并确认新服务器正常运行后，你就可以将全网的 DNS 名称替换为指向新 IP 地址。
- en: 'On legacy Ubuntu servers, the `/etc/resolv.conf` file included the IP addresses
    for DNS servers the system would use to resolve names. If you wanted to override
    the DNS servers for your server, you would alter that file. Although this file
    still exists in Ubuntu 22.04, it only exists to redirect lookups to `systemd-resolved`,
    which is a systemd unit that runs in the background and applies DNS settings based
    on what the system receives via DHCP or what you may have configured in Netplan.
    For the sake of completeness though, here is a brief overview of the syntax of
    this file in older releases, in case you end up working on such a server. An example
    of this file is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版 Ubuntu 服务器上，`/etc/resolv.conf`文件包含了系统用于解析名称的 DNS 服务器的 IP 地址。如果你想覆盖服务器的 DNS
    服务器，你需要修改这个文件。尽管这个文件在 Ubuntu 22.04 中仍然存在，但它仅用于将查询重定向到`systemd-resolved`，这是一个在后台运行并根据系统通过
    DHCP 接收到的设置或你在 Netplan 中配置的设置应用 DNS 配置的 systemd 单元。为了完整起见，这里简要概述一下旧版本中该文件的语法，以防你需要在这种服务器上工作。以下是该文件的示例：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, the `/etc/resolv.conf` output is utilizing servers `10.10.96.1`
    and `10.10.96.2`. Therefore, the server will first check `/etc/hosts` for a match
    of the resource you’re looking up, and if it doesn’t find it, it will then check
    `/etc/resolv.conf` in order to find out which server to check next. In this case,
    the server will check `10.10.96.1`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`/etc/resolv.conf`文件输出使用的是`10.10.96.1`和`10.10.96.2`这两台服务器。因此，服务器首先会检查`/etc/hosts`文件，看看是否有与正在查询的资源匹配的记录，如果没有，它将继续检查`/etc/resolv.conf`，以确定下一个要检查的服务器。在这个例子中，服务器将检查`10.10.96.1`。
- en: The `/etc/resolv.conf` file on legacy servers is typically not one that you’d
    make actual changes to, since it’s automatically generated by NetworkManager.
    NetworkManager is a service that helps you manage your network interfaces; however,
    it’s not used anymore with Ubuntu Server for a handful of releases now. Even though
    you don’t typically manually edit the `/etc/resolv.conf` file, it may be worth
    looking at on legacy servers to see which DNS servers were assigned, in case you’re
    troubleshooting some sort of networking issue.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 传统服务器上的`/etc/resolv.conf`文件通常不需要进行实际更改，因为它是由NetworkManager自动生成的。NetworkManager是一个帮助你管理网络接口的服务；然而，在Ubuntu
    Server的多个版本中，它已经不再使用了。尽管你通常不需要手动编辑`/etc/resolv.conf`文件，但在老旧服务器上查看它可能很有用，这样你就可以知道分配了哪些DNS服务器，以防你在排查网络问题时需要用到这些信息。
- en: 'Nowadays, modern Ubuntu servers utilize `systemd-resolved` to handle name resolution.
    If you’d like to see which DNS servers were assigned on a newer Ubuntu Server
    installation, you can simply look at the configuration file for Netplan that we
    worked through earlier in the case of a static IP assignment, but if DHCP is being
    used, the `resolvectl` command will let you know what DNS nameservers your server
    is currently pointing to. This will provide an output similar to that shown in
    the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，现代的Ubuntu服务器使用`systemd-resolved`来处理名称解析。如果你想查看在较新的Ubuntu Server安装中分配了哪些DNS服务器，你可以简单地查看之前我们在静态IP配置时使用的Netplan配置文件，但如果使用的是DHCP，`resolvectl`命令会告诉你当前服务器正在指向的DNS服务器。它的输出将类似于以下截图所示：
- en: '![](img/B18425_10_05.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_10_05.png)'
- en: 'Figure 10.5: Viewing a server’s current DNS assignment'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：查看服务器当前的DNS分配
- en: In a typical enterprise Linux network, you’ll set up a local DNS server to resolve
    your internal resources, which will then forward requests to a public DNS server
    in case you’re attempting to reach something that’s not internal. We’ll get to
    that in *Chapter 11*, *Setting Up Network Services*, but you should now understand
    how the name resolution process works on your Ubuntu Server.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的企业Linux网络中，你会设置一个本地DNS服务器来解析内部资源，然后将请求转发到公共DNS服务器，以防你试图访问某个非内部的资源。我们将在*第11章*，*设置网络服务*中讲解这个内容，但你现在应该了解在Ubuntu
    Server上名称解析的工作原理。
- en: As Linux administrators, we will likely manage a large number of servers, and
    often the server we’re managing may not even be in the same physical location
    as us. OpenSSH is a powerful tool for remote management, and it’s what we’ll explore
    next.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Linux管理员，我们可能需要管理大量服务器，而且我们管理的服务器往往不在与我们相同的物理位置。OpenSSH是一个强大的远程管理工具，接下来我们将深入探讨它。
- en: Getting started with OpenSSH
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用OpenSSH
- en: '**OpenSSH** is quite possibly the most useful tool in existence for managing
    Linux servers. Of all the countless utilities available, this is the one I recommend
    that everyone starts practicing as soon as they can. Technically, I could probably
    better fit a section for setting up OpenSSH in *Chapter 11*, *Setting Up Network
    Services*, but this utility is very handy, and we should start using it as soon
    as possible.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenSSH**可能是管理Linux服务器时最有用的工具。在所有可用的无数工具中，这是我建议每个人尽早开始练习的工具。从技术角度来看，我可能更适合在*第11章*，*设置网络服务*中加入一节内容来介绍如何设置OpenSSH，但这个工具非常实用，我们应该尽早开始使用它。'
- en: OpenSSH allows you to open a command shell on other Linux servers, enabling
    you to run commands as if you were there in front of the server. For Linux administrators
    like us, this is extremely convenient. We could be tasked with managing dozens,
    hundreds, or even thousands of servers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH允许你在其他Linux服务器上打开命令行界面，使你能够像在服务器面前一样执行命令。对于我们这样的Linux管理员来说，这非常方便。我们可能需要管理数十台、数百台，甚至上千台服务器。
- en: With OpenSSH, we can manage our entire server architecture without even getting
    out of our chairs. In this section, I’ll give you some information on OpenSSH
    and how to install it, and then I’ll finish up the section with a few examples
    of actually using it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 借助OpenSSH，我们可以在不离开椅子的情况下管理整个服务器架构。在本节中，我将为你提供关于OpenSSH的一些信息，并介绍如何安装它，最后通过一些实际使用的例子来结束这一节。
- en: Installing OpenSSH
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装OpenSSH
- en: OpenSSH consists of two components, the server daemon that runs in the background
    that accepts SSH connections, and the client that runs on a laptop, workstation,
    or another server that gives you the ability to connect to an SSH server and run
    commands. All operating systems nowadays give you access to an OpenSSH client
    that you can use to make the connection to the server, so that requirement is
    probably already met. When it comes to Linux, most distributions give you the
    OpenSSH client already. You can verify that by running `which ssh` at your shell
    prompt. If you have the client installed, your output should read `/usr/bin/ssh`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH由两个组件组成：在后台运行、接受SSH连接的服务器守护进程，以及运行在笔记本、工作站或其他服务器上的客户端，它使你能够连接到SSH服务器并运行命令。如今，所有操作系统都提供了OpenSSH客户端，可以用来连接到服务器，因此这一要求大概率已经满足。对于Linux，大多数发行版默认提供了OpenSSH客户端。你可以通过在命令行提示符下运行`which
    ssh`来验证这一点。如果客户端已经安装，你的输出应该是`/usr/bin/ssh`。
- en: 'If, for some reason, you don’t have this package installed and you’ve received
    no output from the previous command (which would be rare), you can install the
    OpenSSH client with the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，你没有安装此软件包，并且在运行前一个命令时没有收到任何输出（这种情况比较罕见），你可以使用以下命令来安装OpenSSH客户端：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Depending on the choices you’ve made during installation, your Ubuntu Server
    likely has the OpenSSH server installed already. If you don’t remember whether
    or not you opted to have this included during our initial installation, you can
    run the `which sshd` command at your shell prompt and you should see the output
    of `/usr/sbin/sshd`. You can also execute `systemctl status ssh` as well, and
    if the server component is present and running, then your server is ready to accept
    SSH connections:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你在安装过程中做出的选择，Ubuntu服务器很可能已经安装了OpenSSH服务器。如果你不记得在最初安装时是否选择了安装它，你可以在命令行提示符下运行`which
    sshd`命令，你应该会看到输出`/usr/sbin/sshd`。你也可以执行`systemctl status ssh`，如果服务器组件存在并且正在运行，那么你的服务器已经准备好接受SSH连接：
- en: '![Text  Description automatically generated](img/B18425_10_06.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![Text Description automatically generated](img/B18425_10_06.png)'
- en: 'Figure 10.6: Verifying that the OpenSSH service is running on a server'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：验证OpenSSH服务是否在服务器上运行
- en: 'In the case that you don’t have the OpenSSH server component installed on your
    server, you can install it with the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的服务器没有安装OpenSSH服务器组件，你可以使用以下命令来安装它：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With great power comes great responsibility, though. As great as OpenSSH is,
    any service that listens for connections has the potential of being abused. An
    outside intruder finding a weakness or exploit that allows them to take control
    over your server is a really bad situation. Therefore, like any service that runs
    on your server, you should only have it running if you need to use it. Since OpenSSH
    is incredibly helpful (and it’s the standard method of remote management) it’s
    very hard to *not* use it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，**强大的力量伴随巨大的责任**。尽管OpenSSH非常强大，但任何监听连接的服务都有可能被滥用。外部入侵者发现弱点或漏洞，进而控制你的服务器，情况将变得非常糟糕。因此，像所有在服务器上运行的服务一样，只有在需要时才应该启动它。由于OpenSSH极为有用（而且它是远程管理的标准方法），因此几乎很难*不使用*它。
- en: There are many methods you can utilize to secure such a service and help protect
    it. One method is covered in the next section, and we’ll talk about security pertaining
    to OpenSSH again before the book comes to a close. Specifically, in *Chapter 21*,
    *Securing Your Server*, I will walk you through various configuration changes
    you can make to help minimize the threat of miscreants breaking into your server
    from the outside and wreaking havoc.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用许多方法来保护此类服务并帮助加固它。下一节将介绍其中一种方法，我们在本书结束之前，还将再次讨论与OpenSSH相关的安全问题。具体来说，在*第21章*《保护你的服务器》中，我将带你逐步了解可以采取的各种配置更改，帮助最小化外部不法分子入侵服务器并造成破坏的威胁。
- en: Securing OpenSSH is actually not hard at all, and would probably only take a
    few minutes of your time. Therefore, feel free to make a detour to that chapter
    to read the section there that talks about securing OpenSSH, and then come back
    here when you’re done. For now, make sure that you have secure, randomly generated
    passwords on the server at the very least. If OpenSSH is reachable via the public
    internet, and any of your users have weak passwords, it definitely won’t be a
    fun situation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 保护 OpenSSH 实际上并不困难，可能只需要几分钟的时间。因此，您可以绕道阅读该章节中关于保护 OpenSSH 的部分，读完后再回来。现在，至少确保服务器上有安全的、随机生成的密码。如果
    OpenSSH 可以通过公共互联网访问，而您的用户有弱密码，那么这绝对不是一个好情况。
- en: With all of that out of the way, we can get started with actually using OpenSSH.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，我们就可以开始实际使用 OpenSSH 了。
- en: Issuing commands with OpenSSH
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 OpenSSH 执行命令
- en: 'After you’ve installed the `openssh-server` package on your target machine
    (the one you want to control remotely), you’ll need to start it if it hasn’t been
    already. By default, Ubuntu’s `openssh-server` package is automatically configured
    to start and become enabled once installed. Just as we’ve done earlier, you can
    verify that the required service is running with the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在您已安装 `openssh-server` 软件包到目标机器（您希望远程控制的那台机器）之后，如果它尚未启动，您需要启动它。默认情况下，Ubuntu
    的 `openssh-server` 软件包会在安装后自动配置为启动并启用。就像我们之前做的那样，您可以通过以下命令验证所需的服务是否正在运行：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If OpenSSH is running as a daemon on your server, you should see output that
    tells you that it’s `active (running)`. If not, you can start it with the following
    command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 OpenSSH 作为守护进程在您的服务器上运行，您应该看到输出信息，告知它处于 `active (running)` 状态。如果不是，您可以使用以下命令启动它：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the output of the `systemctl status ssh` command shows that the daemon is
    disabled (meaning it doesn’t start up automatically when the server boots), you
    can enable it with the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `systemctl status ssh` 命令的输出显示守护进程被禁用（意味着它不会在服务器启动时自动启动），您可以使用以下命令启用它：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With the OpenSSH server started and running, your server should now be listening
    for connections. To verify this, use the following command to list listening ports,
    restricting the output to SSH:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当 OpenSSH 服务器已启动并正在运行时，您的服务器现在应该在监听连接。为了验证这一点，可以使用以下命令列出监听的端口，将输出限制为 SSH：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `ss` command allows us to view a list of processes running on our server
    that are listening for connections. It will also display which port a process
    is listening on.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`ss` 命令允许我们查看正在服务器上运行并监听连接的进程列表。它还会显示进程监听的端口。'
- en: 'We’ll explore this command in more detail in *Chapter 21*, *Securing Your Server*.
    But for now, this command should produce an output similar to the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *第21章*，*保护您的服务器* 中更详细地探讨此命令。但现在，这个命令应该会输出类似以下内容：
- en: '![Graphical user interface, text  Description automatically generated](img/B18425_10_07.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![Graphical user interface, text  Description automatically generated](img/B18425_10_07.png)'
- en: 'Figure 10.7: Checking if the required port for SSH is listening'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7：检查 SSH 所需端口是否在监听
- en: If, for some reason, your server doesn’t show that it has an SSH server listening,
    double-check that you’ve started the daemon. By default, the SSH server listens
    for connections on port `22`. This can be changed by modifying the port declaration
    in the `/etc/ssh/sshd_config` file, but that’s a story for a later chapter. While
    I won’t be going over the editing of this file just yet, just take note that it’s
    the default configuration file for the daemon. OpenSSH reads this file for configuration
    values each time it’s started or restarted.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，您的服务器没有显示有 SSH 服务器在监听，仔细检查您是否已经启动了守护进程。默认情况下，SSH 服务器会在端口`22`上监听连接。可以通过修改`/etc/ssh/sshd_config`文件中的端口声明来更改这一设置，但这是后续章节的内容。虽然我现在不打算详细讲解如何编辑此文件，但请注意，它是守护进程的默认配置文件。每次
    OpenSSH 启动或重启时，它都会读取此文件中的配置值。
- en: 'To connect to a server using SSH, simply execute the `ssh` command followed
    by the name or IP address of the server you’d like to connect to:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 SSH 连接到服务器，只需执行 `ssh` 命令，后面跟上您要连接的服务器的名称或 IP 地址：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By default, the `ssh` command will use the username you’re currently logged
    in with for the connection. If you’d like to use a different username, specify
    it with the `ssh` command by including your username followed by the `@` symbol
    just before the IP address or hostname:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`ssh` 命令将使用你当前登录的用户名进行连接。如果你想使用不同的用户名，可以在 `ssh` 命令中指定它，通过在 IP 地址或主机名之前加入用户名，并跟随
    `@` 符号：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Unless you tell it otherwise, the `ssh` command assumes that your target is
    listening on port `22`. If it isn’t, you can give the command a different port
    with the `-p` option followed by a port number:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你另行指定，`ssh` 命令假定你的目标主机监听的是端口 `22`。如果不是，你可以通过 `-p` 选项后跟端口号来指定不同的端口：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once you’re connected to the target machine, you’ll be able to run shell commands
    and administer the system as if you were right in front of it. You’ll have all
    the same permissions as the user you’ve logged in with, and you’ll also be able
    to use `sudo` to run administrative commands if you normally have access to do
    so on that server.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你连接到目标机器，你就可以像直接站在它面前一样运行 shell 命令并管理系统。你将拥有与你登录时相同的权限，如果你在该服务器上有权限，你还可以使用
    `sudo` 来执行管理员命令。
- en: Basically, anything you’re able to do if you were standing right in front of
    the server, you’ll be able to do via SSH. When you’re finished with your session,
    simply type `exit` at the shell prompt, or press *Ctrl* + *d* on your keyboard.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，如果你在服务器面前时能够做的任何事情，你都能通过 SSH 来做。当你完成会话时，只需在 shell 提示符下输入 `exit`，或按下键盘上的
    *Ctrl* + *d*。
- en: When you exit an OpenSSH connection, any processes you may have had running
    in the background will be killed. Be sure you resume any background processes
    you may have running and finish working with them before you exit your connection.
    We took a look at how to run processes in the background back in *Chapter 7*,
    *Controlling and Monitoring Processes*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你退出 OpenSSH 连接时，任何在后台运行的进程都会被终止。请确保在退出连接之前，恢复你可能正在运行的后台进程，并完成相关工作。我们在*第 7 章*、*控制和监控进程*中讨论过如何在后台运行进程。
- en: As you can see, OpenSSH is a miraculous tool that will benefit you by allowing
    you to remotely manage your servers from anywhere you allow SSH access from. Make
    sure to read the relevant section in *Chapter 11*, *Setting Up Network Services*,
    with regard to securing it, though. In the next section, we’ll discuss SSH key
    management, which brings the benefit of convenience, but also allows you to increase
    security as well.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，OpenSSH 是一款神奇的工具，它能够让你从任何允许 SSH 访问的地方远程管理你的服务器。但要确保阅读*第 11 章*、*设置网络服务*中的相关部分，关于如何保证它的安全。在接下来的章节中，我们将讨论
    SSH 密钥管理，它带来了便利性，同时也能提升安全性。
- en: Getting started with SSH key management
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 SSH 密钥管理
- en: When you connect to a host via SSH, you’ll be asked for your password, and after
    you authenticate you’ll be connected. Instead of using your password, though,
    you can authenticate via public key authentication instead. The core benefit to
    this method is added security, as your system password is never transmitted during
    the process of connecting to the server. When you create an SSH key pair, you
    are generating two files, a *public key* and a *private key*. These two files
    are mathematically linked, so if you connect to a server that has your public
    key, it will know it’s you because you (and only you) have the private key that
    matches it. This method is far more secure than password authentication, and I
    highly recommend that you use it. To get the most out of the security benefit
    of authentication via keys, you can actually disable password-based authentication
    on your server so that your SSH key is your only way in. By disabling password-based
    authentication and using only keys, you’re increasing your server’s security by
    a sizeable margin. We’ll go over that in *Chapter 21*, *Securing Your Server*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过 SSH 连接到主机时，系统会要求你输入密码，验证通过后便会建立连接。不过，你可以选择通过公钥认证而不是输入密码进行验证。这种方法的核心优点是增加了安全性，因为在连接服务器的过程中，系统密码不会被传输。当你创建
    SSH 密钥对时，你会生成两个文件，一个*公钥*和一个*私钥*。这两个文件在数学上是相互关联的，因此，如果你连接到一台已保存你公钥的服务器，服务器会知道是你在连接，因为只有你（并且只有你）拥有与公钥匹配的私钥。这种方法比密码验证更加安全，我强烈建议你使用它。为了最大化通过密钥认证带来的安全性，你实际上可以在服务器上禁用基于密码的认证，这样你的
    SSH 密钥就成为唯一的登录方式。通过禁用基于密码的认证并仅使用密钥，你可以大幅提升服务器的安全性。我们将在*第 21 章*、*保护你的服务器*中讲解这一部分。
- en: Generating public and private keys
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成公钥和私钥
- en: 'To get started, you’ll first need to generate your key. To do so, on your workstation
    or laptop (the device you’re using to connect to the server), use the `ssh-keygen`
    command as your normal user account. The following screenshot shows what this
    process generally looks like:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要生成密钥。在你的工作站或笔记本电脑（即你用来连接服务器的设备）上，使用`ssh-keygen`命令，以普通用户账号进行操作。下面的截图展示了这一过程的大致样子：
- en: '![Text  Description automatically generated](img/B18425_10_08.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18425_10_08.png)'
- en: 'Figure 10.8: Generating an SSH key pair'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：生成SSH密钥对
- en: First, you’ll be asked for the directory in which to save your key files, defaulting
    to `/home/<user>/.ssh`. You’ll next be asked for a passphrase, which is optional.
    Although it does add an additional step to authenticating via keys, I recommend
    that you give it a passphrase (which should be different than your system password)
    since it greatly enhances security (the key would be unusable without the passphrase,
    if you gave it one). You can press *Enter* for the passphrase without entering
    one if you do not want this.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会被要求输入保存密钥文件的目录，默认路径是`/home/<user>/.ssh`。接下来，系统会询问是否设置密码短语，这一步是可选的。虽然这会增加通过密钥进行身份验证的步骤，但我建议你设置一个密码短语（与系统密码不同），因为它大大提高了安全性（如果你设置了密码短语，密钥没有密码短语就无法使用）。如果你不想设置密码短语，可以直接按*Enter*键跳过。
- en: What this command does is create a directory named `.ssh` in your `home` directory,
    if it doesn’t already exist. Inside that directory, it will create two files,
    `id_rsa` and `id_rsa.pub`. The `id_rsa` file is your private key. It should never
    leave your machine, be given to another user, or be stored on any external media.
    If your private key leaks out, your keys can no longer be trusted. By default,
    the private key is owned by the user that created it, with `rw` permissions given
    only to its owner.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的作用是，在你的`home`目录下创建一个名为`.ssh`的目录（如果它还不存在）。在该目录中，它会创建两个文件，`id_rsa`和`id_rsa.pub`。`id_rsa`文件是你的私钥，它永远不应该离开你的计算机、传给其他用户，或者存储在任何外部介质上。如果你的私钥泄露，你的密钥对就不再可信。默认情况下，私钥的拥有者是创建它的用户，且`rw`权限只授予文件所有者。
- en: 'The public key, on the other hand, can leave your computer and doesn’t need
    to be secured as much. Its permissions are more lenient, being readable by everyone
    and writeable by the owner. You can see this yourself by executing `ls -l /home/<user>/.ssh`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥则不同，它可以离开你的计算机，并且不需要像私钥那样严格保护。它的权限更加宽松，所有人都可以读取，只有所有者可以写入。你可以通过执行`ls -l /home/<user>/.ssh`来查看这一点：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B18425_10_09.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，描述自动生成，信心中等](img/B18425_10_09.png)'
- en: 'Figure 10.9: Listing the contents of the .ssh directory, showing the permissions
    of the newly created keys'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：列出.ssh目录的内容，显示新创建密钥的权限
- en: The public key is the key that actually gets copied to other servers to facilitate
    your being able to log in via such a key pair. When you log in to a server that
    has your key, it checks that it’s a mathematical match to your private key, and
    if it is, it will let you log in. You’ll also be asked for your passphrase, if
    you chose to set one when you first created it. But before we can actually use
    our key, we need to copy it over to the server we intend to connect to.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥是实际复制到其他服务器上的密钥，以便通过这样的密钥对进行登录。当你登录到一个包含你公钥的服务器时，服务器会检查公钥与私钥是否在数学上匹配，如果匹配，它会允许你登录。如果在创建密钥时设置了密码短语，系统也会要求你输入它。但在我们实际使用密钥之前，我们需要将公钥复制到目标服务器上。
- en: Copying your public key to a remote server
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将你的公钥复制到远程服务器
- en: 'To actually transmit your public key to a target server, we can use the `ssh-copy-id`
    command, as I’m doing in the following example command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际将公钥传输到目标服务器，可以使用`ssh-copy-id`命令，下面是我在例子中使用的命令：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With that command, replace the IP address with the actual IP address, or with
    the *hostname* of the target server. You’ll be asked to log in via your password
    first, and then your key will be copied over. From that point on, you’ll log in
    via your key, falling back to being asked for your password if, for some reason,
    your key relationship is broken. Here’s an example of what this process looks
    like, if I were to work through the process of copying my key to a server named
    `myserver.mycompany.org`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该命令时，将 IP 地址替换为目标服务器的实际 IP 地址，或替换为目标服务器的 *主机名*。你首先会被要求通过密码登录，然后密钥会被复制过去。从此以后，你将通过密钥登录，如果因某种原因密钥关系被破坏，你会被要求输入密码。以下是这个过程的示例，如果我要将我的密钥复制到名为
    `myserver.mycompany.org` 的服务器时的步骤：
- en: '![Text  Description automatically generated](img/B18425_10_10.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Text  Description automatically generated](img/B18425_10_10.png)'
- en: 'Figure 10.10: Using the ssh-copy-id command to copy a public key to a server'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10：使用 `ssh-copy-id` 命令将公钥复制到服务器
- en: So, what exactly did the `ssh-copy-id` command do? Where is your public key
    copied to, exactly? What happens with this command is that on the target server,
    a `.ssh` directory is created in your `home` directory on the target server if
    it didn’t already exist. Inside that directory, a file named `authorized_keys`
    is created if it wasn’t already present. The contents of `~/.ssh/id_rsa.pub` on
    your machine are copied into the `~/.ssh/authorized_keys` file on the target server.
    With each additional key you add (for example, you connect to that server from
    multiple machines), the key is added to the end of the `authorized_keys` file,
    one per line.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`ssh-copy-id` 命令到底做了什么呢？你的公钥到底被复制到了哪里？其实，执行此命令后，如果目标服务器的 `home` 目录下没有 `.ssh`
    目录，它会自动创建一个。在该目录内，如果没有现成的 `authorized_keys` 文件，它会创建一个。你机器上 `~/.ssh/id_rsa.pub`
    文件的内容将被复制到目标服务器的 `~/.ssh/authorized_keys` 文件中。每添加一个新的密钥（例如，你从多台机器连接到该服务器时），密钥会被添加到
    `authorized_keys` 文件的末尾，每个密钥占一行。
- en: Using the `ssh-copy-id` command is merely a matter of convenience; there’s nothing
    stopping you from copying the contents of your `id_rsa.pub` file and manually
    pasting it into the `authorized_keys` file of the target server. That method will
    actually work just fine as well.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ssh-copy-id` 命令仅仅是为了方便；你完全可以将 `id_rsa.pub` 文件的内容复制并手动粘贴到目标服务器的 `authorized_keys`
    文件中。那种方法其实也能正常工作。
- en: When you connect to a server that you have set up a key relationship with by
    adding your public key, SSH checks the contents of the `~/.ssh/authorized_keys`
    file on that server, looking for a key that mathematically matches the private
    key (`~/.ssh/id_rsa`) on your machine. If the two keys are an appropriate match,
    you are allowed access. If you set up a passphrase, you’ll be asked to enter it
    in order to open your public key.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你连接到已经设置了密钥关系的服务器时，SSH 会检查该服务器上 `~/.ssh/authorized_keys` 文件的内容，寻找一个与本机私钥（`~/.ssh/id_rsa`）在数学上匹配的密钥。如果这两个密钥匹配，你将被授予访问权限。如果你设置了密码短语，则在打开公钥时，会要求你输入密码短语。
- en: If you decided not to create a passphrase with your key, you’re essentially
    setting up authentication without a password, meaning you won’t be asked to enter
    anything when authenticating.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定在密钥中不设置密码短语，实际上就是在设置无需密码的身份验证，这意味着在身份验证时，你不需要输入任何内容。
- en: Utilizing an SSH agent
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SSH 代理
- en: When we created our SSH key earlier, it was mentioned that having a passphrase
    is optional but is a good idea. Using passphrases with OpenSSH key pairs boosts
    their security. If an OpenSSH key falls into the wrong hands, it will be useless
    if the person attempting to utilize it doesn’t know the passphrase. However, we
    lose a bit of convenience because we need to enter the passphrase for a key each
    time we want to use it. An OpenSSH key without a passphrase will allow us to connect
    to a server and be logged in without entering anything at all. With an *SSH agent*,
    you can actually cache your passphrase the first time you use it, so you won’t
    be asked for it with every connection. This essentially allows you to benefit
    from the added security of a passphrase, and still maintain at least some convenience.
    Best of all, if your laptop or desktop is able to utilize the OpenSSH client for
    connecting to remote systems, you should have an SSH agent on your system already.
    If we’re using a flavor of Linux or macOS on our workstation or laptop, for example,
    we will have the `ssh-agent` command available to us.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前创建SSH密钥时提到过，设置密码短语是可选的，但它是一个好主意。使用密码短语可以提高OpenSSH密钥对的安全性。如果一个OpenSSH密钥落入错误的人手中，只要他们不知道密码短语，就无法使用它。然而，我们也会失去一些便利，因为每次使用密钥时都需要输入密码短语。没有密码短语的OpenSSH密钥允许我们连接到服务器并直接登录，而不需要输入任何东西。使用*SSH代理*，你实际上可以在第一次使用密码短语时将其缓存，这样每次连接时就不需要再输入密码短语了。这实际上让你在享受密码短语增加的安全性的同时，仍然保持了一定的便利性。最棒的是，如果你的笔记本电脑或台式机能够使用OpenSSH客户端连接到远程系统，那么你应该已经在系统中安装了SSH代理。例如，如果我们在工作站或笔记本电脑上使用Linux或macOS的某种版本，`ssh-agent`命令会是可用的。
- en: 'The `ssh-agent` is used by starting it in the background in our terminal. We
    can then “unlock” our keys with our passphrase, and then the unlocked key will
    be stored in memory and will be automatically used when we attempt to connect
    to a server we’ve copied our public key to. To start it, enter the following command
    as your normal user account on the machine you’re starting your connections from
    (that is, your workstation):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`ssh-agent`是通过在终端后台启动来使用的。然后，我们可以使用密码短语“解锁”我们的密钥，解锁后的密钥将被存储在内存中，当我们尝试连接到已经将公钥复制到的服务器时，系统会自动使用这个解锁的密钥。要启动它，在你用来启动连接的机器上（也就是你的工作站）输入以下命令：'
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This command will start an SSH agent, which will continue to run in the background
    of your shell. But it’s not adding any value to us yet—so we will need to add
    an SSH key to the now-running agent. The `ssh-add` command allows us to add an
    SSH key to our running `ssh-agent`. To do so, we can give the `ssh-add` command
    the path to our public key as an argument:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将启动一个SSH代理，它将继续在你的shell后台运行。但它现在还没有给我们带来任何好处——所以我们需要将一个SSH密钥添加到正在运行的代理中。`ssh-add`命令允许我们将一个SSH密钥添加到正在运行的`ssh-agent`中。为此，我们可以将`ssh-add`命令与公钥的路径作为参数一起使用：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At this point, you’ll be asked for your passphrase. As long as you enter it
    properly, your key will remain open and you won’t need to enter it again for future
    connections, until you close that shell or log out. Now that you have the `ssh-agent`
    running in the background with your unlocked key, utilizing a key with a passphrase
    becomes much easier and you’ll end up typing a lot less.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到此时，你将被要求输入密码短语。只要你正确输入，它将保持解锁状态，未来的连接无需再次输入密码短语，直到你关闭该shell或注销。现在，你已经在后台运行了`ssh-agent`，并且密钥已经解锁，使用带有密码短语的密钥变得更加简单，你将输入更少的内容。
- en: Changing the passphrase of an OpenSSH key
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改OpenSSH密钥的密码短语
- en: 'At some point, you may want to change the passphrase associated with a key.
    If you’d like to do that, you can use the `-p` argument with the `ssh-keygen`
    command. That same argument can also be used if you didn’t choose to add a passphrase
    when you initially created the key. That’s all there is to it. The command you’d
    enter to add or change a passphrase is as simple as the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想要更改与密钥相关的密码短语。如果你想这样做，可以使用`-p`参数与`ssh-keygen`命令配合使用。如果你在最初创建密钥时没有选择添加密码短语，那个参数也可以用来添加。就是这么简单。你输入的命令就像以下这样简单：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once you enter that command, press *Enter* to accept the default file (`id_rsa`)
    unless the key you want to alter is under a different name, in which case you
    can type the path to, and the name of, that key. Then, you’ll be asked for your
    current passphrase (leave it blank if you don’t have one yet) followed by your
    new passphrase twice. The process looks like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入该命令，按 *Enter* 键接受默认文件（`id_rsa`），除非你想更改的密钥有不同的名称，届时你可以键入该密钥的路径和名称。接下来，你将被要求输入当前的密码短语（如果没有密码短语，可以留空），然后再输入两次新密码短语。整个过程如下所示：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B18425_10_11.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B18425_10_11.png)'
- en: 'Figure 10.11: Changing an SSH passphrase'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11：更改 SSH 密码短语
- en: These concepts may take a bit of practice if you’ve never used SSH before. The
    best way to practice is to set up multiple Ubuntu Server installations (perhaps
    several virtual machines), and practice using SSH to connect to them, as well
    as deploying your key to each machine via the `ssh-copy-id` command. It’s actually
    quite easy once you get the hang of it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未使用过 SSH，这些概念可能需要一些练习。最好的练习方法是设置多个 Ubuntu Server 安装（可能是几个虚拟机），并练习使用 SSH
    连接到它们，同时通过 `ssh-copy-id` 命令将你的密钥部署到每台机器上。实际上，一旦掌握了，它会变得相当简单。
- en: Simplifying SSH connections with a config file
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用配置文件简化 SSH 连接
- en: 'Before we leave the topic of OpenSSH, there’s another trick that has the benefit
    of convenience, and that is the creation of a local configuration file for SSH.
    This file must be stored in the `.ssh` directory of your home directory, and be
    named `config`. The full path for this file in my case looks like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开 OpenSSH 话题之前，还有一个便捷的技巧，那就是创建 SSH 的本地配置文件。这个文件必须存储在你的主目录的 `.ssh` 文件夹中，并命名为
    `config`。在我的情况下，这个文件的完整路径如下所示：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This file doesn’t exist by default, but if it’s found, SSH will parse it whenever
    you use the client and you’ll be able to benefit from it. Go ahead and open this
    file in your text editor, such as `nano`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件默认是不存在的，但如果它被找到，SSH 每次使用客户端时都会解析它，你将能够从中受益。请打开这个文件并在文本编辑器中编辑，例如 `nano`：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This `config` file allows you to type configuration for servers that you connect
    to often, which can simplify the `ssh` command automatically. The following are
    example contents from such a file that will help me illustrate what it does:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `config` 文件允许你为经常连接的服务器输入配置，从而自动简化 `ssh` 命令。以下是该文件中的示例内容，帮助我说明它的作用：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the example contents, I have two hosts outlined, `myserver` and `nagios`.
    For each, I’ve identified a way to reach it by name or IP address (the `Hostname`
    line), as well as the `Port` and `User` account to use for the connection. If
    I use `ssh` to connect to either `Host` by the name I outlined in this file, it
    will use the values I have stored there, for example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例内容中，我列出了两个主机，`myserver` 和 `nagios`。对于每个主机，我都标明了如何通过名称或 IP 地址（`Hostname` 行）来访问它，以及连接时使用的
    `Port` 和 `User` 账户。如果我通过文件中列出的名称使用 `ssh` 连接到这两个主机中的任何一个，它会使用我在那里存储的值，例如：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'That command is a lot shorter than if I set all the options manually. Considering
    I have a `config` file for SSH, that command is essentially the same as if I identified
    the connection details manually, which would’ve been the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令比手动设置所有选项要短得多。考虑到我有一个 SSH 的 `config` 文件，这个命令实际上和我手动识别连接详细信息后输入的命令是一样的，手动输入的命令如下所示：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: I’m sure you can see how much simpler it is to type the first command than the
    second. With the `config` file for SSH, I can have some of those details automatically
    applied. Since I’ve outlined that my `nagios` server is located at `nagios.mynetwork.org`,
    its SSH user is `nagiosuser`, and it’s listening on port `2222`, it will automatically
    use those values even though I only typed `ssh nagios`. Furthermore, you can also
    override this entry as well. If you provide a different username when you use
    the `ssh` command, it will use that instead of what you have written in the `config`
    file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你能看出，输入第一个命令比第二个命令要简单得多。通过 SSH 的 `config` 文件，我可以让一些细节自动应用。因为我已经在文件中说明了我的
    `nagios` 服务器位于 `nagios.mynetwork.org`，它的 SSH 用户是 `nagiosuser`，并且它监听的是 `2222` 端口，所以即使我只输入了
    `ssh nagios`，它也会自动使用这些值。此外，你还可以覆盖这个条目。如果你在使用 `ssh` 命令时提供了不同的用户名，它会使用你提供的用户名，而不是
    `config` 文件中写的用户名。
- en: In the first example (for the `myserver` server), I’m providing an IP address
    for the connection, rather than a hostname. This is useful in a situation where
    you may not have a DNS entry for your target server. With this example, I don’t
    have to remember that the IP address for `myserver` is `192.168.1.23`. I simply
    execute `ssh myserver` and it’s taken care of for me.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中（针对 `myserver` 服务器），我为连接提供了IP地址，而不是主机名。在没有目标服务器的DNS条目的情况下，这非常有用。通过这个示例，我不必记住
    `myserver` 的IP地址是 `192.168.1.23`。我只需要执行 `ssh myserver`，系统就会为我处理好这一切。
- en: The names of each server within the `config` file are arbitrary and don’t have
    to match the target server’s hostname. I could’ve named the first server `potato`
    and it would still have routed me to `192.168.1.23`, so I can create any sort
    of named shortcut I want, whatever I find is most convenient for me and easiest
    to remember. As you can see, maintaining a `config` file in your home directory
    containing your most commonly used SSH connections will certainly help keep you
    organized and allow you to connect more easily.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`config` 文件中的每个服务器名称都是任意的，不必与目标服务器的主机名匹配。我本可以将第一个服务器命名为 `potato`，它仍然会将我路由到
    `192.168.1.23`，所以我可以创建任何我想要的命名快捷方式，无论是最方便我记住的名字还是最容易记住的名称。如你所见，在你的主目录中维护一个包含最常用SSH连接的
    `config` 文件，肯定能帮助你保持井井有条，并且让你更容易连接。'
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we worked through several examples of connecting to other networks.
    We started off by configuring our hostname, managing network interfaces, assigning
    static IP addresses, as well as looking at how name resolution works in Linux.
    A decent portion of this chapter was dedicated to topics regarding OpenSSH, which
    is an extremely useful utility that allows you to remotely manage your servers.
    We’ll revisit OpenSSH in *Chapter 21*, *Securing Your Server*, with a look at
    boosting its security. Overall, we’ve only begun to scratch the surface of this
    tool. Entire books have been written about SSH, but the examples in this chapter
    should be enough to make you productive with it. The name of the game is to practice,
    practice, practice!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过多个示例讲解了如何连接到其他网络。我们从配置主机名开始，管理网络接口，分配静态IP地址，并了解Linux中的名称解析如何工作。本章的相当一部分内容专门讲解了OpenSSH，这是一个非常有用的工具，允许你远程管理服务器。在
    *第21章*《保护你的服务器》中，我们将再次探讨OpenSSH，重点讲解如何增强其安全性。总的来说，我们才刚刚触及到这个工具的表面。关于SSH已经写了整本书，但本章中的示例应该足以让你开始高效使用它。关键在于：练习，练习，再练习！
- en: In the next chapter, we’ll talk about managing software packages. We’ll work
    through adding and removing them, adding additional repositories, and more!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何管理软件包。我们将通过添加和删除软件包、添加附加软件库等内容进行讲解！
- en: Relevant videos
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关视频
- en: 'OpenSSH Guide (LearnLinuxTV): [https://linux.video/ssh-guide](https://linux.video/ssh-guide)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSH指南（LearnLinuxTV）：[https://linux.video/ssh-guide](https://linux.video/ssh-guide)
- en: 'tmux Guide (LearnLinuxTV): [https://linux.video/tmux-guide](https://linux.video/tmux-guide)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tmux指南（LearnLinuxTV）：[https://linux.video/tmux-guide](https://linux.video/tmux-guide)
- en: 'The OpenSSH Client Config File (LearnLinuxTV): [https://linux.video/ssh-config-file](https://linux.video/ssh-config-file)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSH客户端配置文件（LearnLinuxTV）：[https://linux.video/ssh-config-file](https://linux.video/ssh-config-file)
- en: 'Getting Started with OpenSSH Key Management (LearnLinuxTV): [https://linux.video/ssh-key-mgmt](https://linux.video/ssh-key-mgmt)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入门OpenSSH密钥管理（LearnLinuxTV）：[https://linux.video/ssh-key-mgmt](https://linux.video/ssh-key-mgmt)
- en: Further reading
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Netplan FAQ: [https://learnlinux.link/npf](https://learnlinux.link/npf)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netplan常见问题解答：[https://learnlinux.link/npf](https://learnlinux.link/npf)
- en: 'Ubuntu SSH key documentation: [https://learnlinux.link/u-ssh-keys](https://learnlinux.link/u-ssh-keys)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu SSH密钥文档：[https://learnlinux.link/u-ssh-keys](https://learnlinux.link/u-ssh-keys)
- en: 'NetworkInterfaceNames (from Debian’s wiki): [https://learnlinux.link/net-int-nam](https://learnlinux.link/net-int-nam)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络接口名称（来自Debian的wiki）：[https://learnlinux.link/net-int-nam](https://learnlinux.link/net-int-nam)
- en: Join our community on Discord
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code50046724-1955875156.png)'
