- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing with the Yocto Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have used Poky as a build tool. In other words, we have
    used it as a tool to design and generate the image delivered to products.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how to set up a development environment for use
    inside the target and meet the **Standard SDK** and **Extensible SDK** tools,
    which can help us develop applications outside the target. For example, they allow
    us to cross-compile applications, recipes, and images.
  prefs: []
  type: TYPE_NORMAL
- en: What is a software development kit?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In embedded development, the toolchain is often composed of cross-platform tools
    or tools executed on one architecture, which then produces a binary for use in
    another architecture – for example, a GCC tool that runs on an x86-64-compatible
    machine and generates binaries for an ARM machine is a cross-compiler. When a
    tool and the resulting binaries rely on dependencies from the same host on which
    the tool runs, this is commonly called a native build. Build and target architectures
    may be the same, but it is cross-compilation if the target binary uses a staged
    root filesystem to find its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **software development kit** (**SDK**) is a set of tools and files to develop
    and debug applications. These tools include compilers, linkers, debuggers, external
    libraries, headers, and binaries, also called a toolchain. It may also include
    extra utilities and applications. We can have two types of SDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-development SDKs**: These have the goal of being used in the development
    host to generate binaries for the target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Native SDKs**: These aim to run on the target device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a native SDK for on-device development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some embedded devices are powerful enough to be used as a development environment.
    However, the resources needed for the build vary significantly from one library
    or application to another, so using the target as the building environment may
    not always be viable. The development image needs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The header files and libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The toolchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following line adds these properties to an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – How to configure an image to include development artifacts](img/Figure_9.01_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – How to configure an image to include development artifacts
  prefs: []
  type: TYPE_NORMAL
- en: '`IMAGE_FEATURES` in the preceding example extends the image functionality as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dev-pkgs`: Installs development packages (headers and extra library links)
    for all packages installed in a given image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tools-sdk`: Installs the toolchain that runs on the device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IMAGE_FEATURES` variable is described in more detail in [*Chapter 12*](B19361_12.xhtml#_idTextAnchor147),
    *Creating* *Custom Layers*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If we want to modify only `build/conf/local.conf`, the variable we should use
    is `EXTRA_IMAGE_FEATURES`.
  prefs: []
  type: TYPE_NORMAL
- en: The target can use this image during the application development cycle and share
    the image among all developers working on the same project. Each developer will
    have a copy, and the development team will use the same development environment
    consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the types of cross-development SDKs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Yocto Project can generate two types of cross-development SDKs that aim
    to cover different needs. They are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Standard SDK**: This provides the artifacts for application development,
    be it for bootloader or Linux kernel development, or some other user space software'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sysroot` directory, as well as recipe and application integration inside a
    Yocto Project-controlled environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Standard SDK includes a toolchain and debugging applications. Its goal is
    to allow users to generate binaries for use in the target. The Extensible SDK
    is more powerful and can build images and recipes. A notable difference between
    the two types of SDK is the presence of `devtool` in the Extensible SDK.
  prefs: []
  type: TYPE_NORMAL
- en: '`devtool` is responsible for providing the additional features of the Extensible
    SDK. It is an interface for using BitBake and `recipetool`’s power. The `devtool`
    and `recipetool` commands are also available in the traditional Yocto Project
    environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Standard SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually, an SDK has a set of libraries and applications it must provide, which
    is defined in an image tailored to the product. These are called image-based SDKs.
    For example, we can generate the Standard SDK for `core-image-full-cmdline` with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – How to generate the Standard SDK for core-image-full-cmdline](img/Figure_9.02_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – How to generate the Standard SDK for core-image-full-cmdline
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to create a generic SDK with the toolchain and debugging
    tools. This generic SDK is called `meta-toolchain` and is used mainly for Linux
    kernel and bootloader development and their debugging processes. It may not be
    sufficient to build applications with complex dependencies. To create `meta-toolchain`,
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – How to generate a generic SDK](img/Figure_9.03_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – How to generate a generic SDK
  prefs: []
  type: TYPE_NORMAL
- en: 'In both cases, the resulting SDK self-installer files are at `build/tmp/deploy/sdk/`.
    Considering we used the Standard SDK for `core-image-full-cmdline`, we can see
    the following resulting set of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The resultant files after running bitbake core-image-full-cmdline
    -c populate_sdk](img/Figure_9.04_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The resultant files after running bitbake core-image-full-cmdline
    -c populate_sdk
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step after creating the Standard SDK is to install it, as the Standard
    SDK is wrapped in an installation script that can be executed in the same manner
    as any other script. The following sequence shows the Standard SDK installation
    process using the standard target directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The Standard SDK installation process](img/Figure_9.05_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – The Standard SDK installation process
  prefs: []
  type: TYPE_NORMAL
- en: The preceding Standard SDK illustrates how we can generate and install a Standard
    SDK. Still, it is not ideal to use a standard image that is not tailored to your
    current needs. Therefore, creating a custom image that fits our application needs
    is highly recommended. It is also recommended to base the Standard SDK on this
    custom image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Standard SDK is generated to match the machine architecture we set using
    the `MACHINE` variable. To use the Standard SDK to build a custom application,
    for example, `hello-world.c`, we can use the following lines, targeting the x86-64
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – The steps to build a C application using the Standard SDK](img/Figure_9.06_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – The steps to build a C application using the Standard SDK
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very commonly used project is the Linux kernel. When we want to build
    the Linux kernel source code, we can use the following sequence of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.7 – The steps to build the Linux \uFEFFkernel using the Standard\
    \ SDK](img/Figure_9.07_B19361.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – The steps to build the Linux kernel using the Standard SDK
  prefs: []
  type: TYPE_NORMAL
- en: '`unset LDFLAGS` is required to avoid using GCC for linking, which is the Yocto
    Project-based Standard SDK’s default.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Extensible SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Extensible SDK expands the functionalities of the Standard SDK. Some of
    the significant capabilities included are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install packages in the internal toolchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy packages to the target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those additional features are provided by the `devtool` utility, which is also
    available in the standard Yocto Project environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the Extensible SDK, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Command to generate the Extensible SDK](img/Figure_9.08_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Command to generate the Extensible SDK
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting files are in `build/tmp/deploy/sdk/`. Considering we used the
    Extensible SDK for `core-image-full-cmdline`, we see the following set of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – The resultant files after running bitbake core-image-full-cmdline
    -c populate_sdk_ext](img/Figure_9.09_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – The resultant files after running bitbake core-image-full-cmdline
    -c populate_sdk_ext
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step after creating the Extensible SDK is to install it. To install
    it, we can execute the generated script. The following sequence shows the Extensible
    SDK installation process using the standard target directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – The Extensible SDK installation process](img/Figure_9.10_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – The Extensible SDK installation process
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot illustrates how we can generate and install an Extensible
    SDK. Still, it is not ideal to use a standard image that is not tailored to your
    current needs. Therefore, creating a custom image that fits your application needs
    is highly recommended, as is basing the Extensible SDK on one. However, we can
    build and install any extra dependencies into the SDK using the Extensible SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we installed the Extensible SDK in `/home/user/poky_sdk`. After
    the installation has been completed, the next step is to use the provided script
    to export the required environment variables, which enables the Extensible SDK’s
    use, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Exporting the environment variables to allow the Extensible
    SDK to be used](img/Figure_9.11_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Exporting the environment variables to allow the Extensible SDK
    to be used
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will cover some use cases using `devtool`. All
    commands are executed inside a terminal with the Extensible SDK variables exported.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Extensible SDK is a different way to deliver the same Yocto Project tools
    and metadata. It wraps together the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A basic set of binaries for the Yocto Project environment execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Standard SDK for development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shared state cache to reduce local builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A snapshot of the Yocto Project metadata and configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essentially, the Extensible SDK is a snapshot of the environment used to create
    it. Therefore, all `devtool` commands, including those we will use in the following
    sections, are available inside the Yocto Project environment.
  prefs: []
  type: TYPE_NORMAL
- en: Building an image using devtool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating an image. The Extensible SDK is capable of creating
    any supported image. For example, to create `core-image-full-cmdline`, we can
    use the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Building core-image-full-cmdline with devtool](img/Figure_9.12_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Building core-image-full-cmdline with devtool
  prefs: []
  type: TYPE_NORMAL
- en: After running the `devtool` command, the generated files can be found in `/home/user/poky_sdk/tmp/deploy/images/qemux86-64`.
  prefs: []
  type: TYPE_NORMAL
- en: Running an image on QEMU
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can emulate the target hardware with QEMU using the previously built image,
    `core-image-full-cmdline`, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Emulating with devtool and QEMU](img/Figure_9.13_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Emulating with devtool and QEMU
  prefs: []
  type: TYPE_NORMAL
- en: 'It starts the QEMU execution and generates the boot splash, as is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – The QEMU boot splash](img/Figure_9.14_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – The QEMU boot splash
  prefs: []
  type: TYPE_NORMAL
- en: Creating a recipe from an external Git repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`devtool` is also capable of producing a recipe from an external Git repository.
    Here, we are going to use [https://github.com/OSSystems/bbexample](https://github.com/OSSystems/bbexample):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Creating the recipe using devtool](img/Figure_9.15_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Creating the recipe using devtool
  prefs: []
  type: TYPE_NORMAL
- en: '`devtool` creates a basic recipe file for the given repository. It creates
    a workspace with the package source code and the needed metadata. The file structure
    used by `devtool`, after the `devtool add https://github.com/OSSystems/bbexample`
    command is run, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – The file structure created by devtool when creating a recipe](img/Figure_9.16_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – The file structure created by devtool when creating a recipe
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, `devtool` generates a tentative recipe for projects based on the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Autotools (`autoconf` and `automake`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qmake`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A plain `Makefile`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Node.js module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python modules that use `setuptools` or `distutils`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a recipe using devtool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the recipe has been created under the workspace directory, we can
    build it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Building a recipe with devtool](img/Figure_9.17_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – Building a recipe with devtool
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to the target using devtool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After building the package with `devtool`, we can deploy it to the target.
    In our example, the target is the running QEMU. To access it, use the default
    QEMU IP address, `192.168.7.2`, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Deploying to the target using devtool](img/Figure_9.18_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Deploying to the target using devtool
  prefs: []
  type: TYPE_NORMAL
- en: 'The application is installed in the target. We can see `bbexample` being executed
    in the QEMU target, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.19 –\uFEFF bbexample executing on the target](img/Figure_9.19_B19361.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – bbexample executing on the target
  prefs: []
  type: TYPE_NORMAL
- en: Extending the SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the goals of the Extensible SDK is to allow us to install different
    recipes in the SDK environment. For example, to have `libusb1` available, we can
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20 – The installation of a new recipe in the Extensible SDK](img/Figure_9.20_B19361.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – The installation of a new recipe in the Extensible SDK
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The Yocto Project Extensible SDK allows for distributed development, as developers
    can update and extend the existing SDK environment during a project’s lifetime.
    There is some infrastructure setup required for the proper use of the Extensible
    SDK as a `sstate-cache` mirror and Extensible SDK server, which requires a complex
    configuration beyond the scope of this book. For more details, please refer to
    the *Providing Updates to the Extensible SDK After Installation* section of *Yocto
    Project Application Development and the Extensible Software Development Kit (**eSDK)*
    ([https://docs.yoctoproject.org/4.0.4/sdk-manual/appendix-customizing.html#providing-updates-to-the-extensible-sdk-after-installation](https://docs.yoctoproject.org/4.0.4/sdk-manual/appendix-customizing.html#providing-updates-to-the-extensible-sdk-after-installation)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that the Yocto Project can be used for development
    and image creation. We learned how to create different types of toolchains and
    also how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how we can configure Poky to help us in
    the debugging process, how we can configure our system to provide the required
    tools for remote debugging using GDB, and how we can track our changes using `buildhistory`.
  prefs: []
  type: TYPE_NORMAL
