- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Lions, Tigers, and Containers – Oh My! Podman and Friends
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 狮子、老虎和容器——哎呀！Podman 和朋友们
- en: These days, it’s all about containers. Docker made containers cool and brought
    them into the mainstream, and Podman is here to come to the rescue as an open
    source container runtime that is open and available to all. Oracle Linux 7 includes
    Oracle Container Runtime for Docker, whereas Oracle Linux 8 and beyond include
    Podman, Buildah, and Skopeo.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，一切都与容器有关。Docker 使容器变得酷并带入主流，而 Podman 作为一个开源的容器运行时，向所有人开放并准备救援。Oracle Linux
    7 包括 Oracle Container Runtime for Docker，而 Oracle Linux 8 及以后的版本包括 Podman、Buildah
    和 Skopeo。
- en: 'With every new release, Podman closes the gap between it and Docker. With Podman
    v2.0, it began offering a fully compliant build that enables technologies such
    as `docker-compose` to work interchangeably with Podman. With Podman v4.1.0, you
    are now able to seamlessly mount the host machine’s home directory into the Podman
    machine VM, making it available within container volume mounts. This chapter is
    largely intended for users who have some basic experience with Docker, and will
    help users understand the differences between Docker and Podman so that they can
    successfully migrate their workloads to this so-called “drop-in replacement.”
    If you’re not familiar with Docker or are new to the concept of containers, it
    may be helpful to peruse the Get Started guide from Docker, which can be found
    here: [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每次新版本的发布，Podman 正在缩小与 Docker 之间的差距。随着 Podman v2.0 的发布，它开始提供一个完全兼容的构建，使得 `docker-compose`
    等技术能够与 Podman 互换使用。随着 Podman v4.1.0 的发布，现在可以无缝地将主机机器的 home 目录挂载到 Podman 虚拟机中，使其在容器卷挂载中可用。本章主要面向有一定
    Docker 基础的用户，帮助他们理解 Docker 和 Podman 之间的差异，以便成功地将工作负载迁移到这一“即插即用替代品”。如果你不熟悉 Docker
    或容器概念，可以查阅 Docker 的入门指南，链接如下：[https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)。
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Ridding yourself of demons – err um – daemons, with Podman
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Podman 驱除守护进程（呃，那个……守护进程）
- en: Giving your containers a root canal
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给你的容器做根管治疗
- en: Creating handy-dandy utility containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建便捷的实用容器
- en: Docker Compose with Podman
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Podman 进行 Docker Compose
- en: Managing stacks with pods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pod 管理堆栈
- en: Containerized databases
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化数据库
- en: Buildah and Skopeo – Podman’s friends with benefits
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buildah 和 Skopeo – Podman 的得力助手
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Podman, Buildah, and Skopeo are all included in the `container-tools` module
    from application streams:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Podman、Buildah 和 Skopeo 都包含在 `container-tools` 模块中，来自应用流：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The source code for the recipes in this chapter can be found at [https://github.com/PacktPublishing/Oracle-Linux-Cookbook](https://github.com/PacktPublishing/Oracle-Linux-Cookbook).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中食谱的源代码可以在 [https://github.com/PacktPublishing/Oracle-Linux-Cookbook](https://github.com/PacktPublishing/Oracle-Linux-Cookbook)
    找到。
- en: Ridding yourself of demons – err um – daemons, with Podman
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Podman 驱除守护进程（呃，那个……守护进程）
- en: Docker and Podman are both tools that aim to make it easier to run and manage
    containers on a host machine. Since Podman is the new kid on the block, you may
    be wondering how you can switch from Docker to Podman. While technically it is
    possible to run both Docker and Podman together on the same system, there are
    very few practical reasons to do this. Since both tools provide the same core
    capabilities, I would advise you to choose one or the other.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 和 Podman 都是旨在简化在主机上运行和管理容器的工具。由于 Podman 是新兴工具，你可能会想知道如何将 Docker 切换到 Podman。虽然技术上可以在同一系统上同时运行
    Docker 和 Podman，但实际上几乎没有必要这样做。因为这两个工具提供相同的核心功能，我建议你选择其中一个。
- en: One of the key benefits of switching to Podman is you will inherently lose the
    daemon that lurked behind the scenes of Docker. You see, Docker relies on a daemon
    that does all the heavy lifting of managing containers. This may not seem so bad
    on the surface, but there are some things to be aware of when it comes to this
    architecture.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 Podman 的一个主要好处是你将不再使用 Docker 背后潜藏的守护进程。你看，Docker 依赖于一个守护进程，它负责管理容器的所有繁重工作。乍看之下，这似乎没什么问题，但在这种架构下，有些问题是需要注意的。
- en: For starters, having an extra daemon running in the background means there is
    one more point of failure. If that dedicated daemon for Docker crashes, you lose
    all your containers. The additional daemon also increases your attack surface,
    and because the Docker daemon has root access to the system, any compromise made
    to the Docker daemon puts your system at greater risk.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，后台有一个额外的守护进程运行意味着系统会有更多的故障点。如果专门为 Docker 运行的守护进程崩溃，你的所有容器都会丢失。额外的守护进程还会增加攻击面，因为
    Docker 守护进程具有 root 访问权限，任何对 Docker 守护进程的攻击都会使系统面临更大风险。
- en: This recipe aims to exorcise those demons – err, um – discontinue the use of
    the Docker daemon. The best thing is, if you aren’t using Docker and you only
    ever installed Podman, you don’t need to worry about anything – that’s because
    Podman is rootless by default, and it leverages **systemd** to manage your containers.
    **systemd** is a tried-and-tested system-level daemon that provides an array of
    system components, including a system and service manager, parallelization capabilities,
    logging, and utilities to manage and maintain system configuration.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案旨在驱逐那些“恶魔”——呃，嗯——停止使用 Docker 守护进程。最好的部分是，如果你没有使用 Docker，且只安装了 Podman，那么你无需担心任何问题——因为
    Podman 默认是无根的，并且它利用 **systemd** 来管理你的容器。**systemd** 是一个经过验证的系统级守护进程，提供了一系列系统组件，包括系统和服务管理器、并行化功能、日志记录，以及用于管理和维护系统配置的工具。
- en: On the other hand, if you were previously using Docker, we’re going to show
    you how to switch. It’s really quite simple – all you need to do is remove Docker
    and install Podman.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你之前使用的是 Docker，我们将向你展示如何切换。其实非常简单——你只需移除 Docker 并安装 Podman。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I’m running on x86-64 bit architecture, but Oracle Linux and Podman also work
    on Arm. However, it’s important to know that not all containers are compiled in
    Arm, or vice versa. With that being said, it may be easier to follow this guide
    using an x86-64 bit CPU:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用的是 x86-64 位架构，但 Oracle Linux 和 Podman 也可以在 Arm 上运行。不过，需要注意的是，并不是所有的容器都在 Arm
    上编译，反之亦然。话虽如此，使用 x86-64 位 CPU 跟随本指南可能会更容易：
- en: Oracle Linux
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Linux
- en: Podman
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Remove Docker by running the following command:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令来移除 Docker：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After this, you will be able to install Podman with the following:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，你将能够通过以下方式安装 Podman：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: $ sudo groupdel docker
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ sudo groupdel docker
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now you’re running containers without the Docker daemon, and by default with
    Podman, you’re rootless.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在没有 Docker 守护进程的情况下运行容器，默认情况下，使用 Podman 时，你是无根用户。
- en: Giving your containers a root canal
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给你的容器做个根管治疗
- en: Straight from the Docker documentation, you will find that “*The Docker daemon
    binds to a Unix socket instead of a TCP port. By default that Unix socket is owned
    by the user root and other users can only access it using sudo. The Docker daemon
    always runs as the* *root user.*”
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Docker 文档，你会发现“*Docker 守护进程绑定到一个 Unix 套接字，而不是 TCP 端口。默认情况下，这个 Unix 套接字归 root
    用户所有，其他用户只能使用 sudo 访问它。Docker 守护进程始终以 root 用户身份运行。*”
- en: The documentation then proceeds to instruct you to add your user to the `docker`
    group in order to use Docker without using `sudo`. That sounds great, right? Well,
    the thing is, the `docker` group grants privileges equivalent to the `root` user.
    This can have dire consequences. For instance, any location on your host filesystem
    can be mounted into the container – and I do mean any! This even includes the
    `/` (root) directory and the container can then alter your host filesystem without
    any restrictions. There are several other security vulnerabilities that are a
    direct result of this architecture, but you get the picture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 文档接着指导你将用户添加到 `docker` 组，以便在不使用 `sudo` 的情况下使用 Docker。听起来很不错，对吧？不过，问题是，`docker`
    组赋予的权限相当于 `root` 用户的权限。这可能会带来严重后果。例如，宿主文件系统上的任何位置都可以挂载到容器中——我说的“任何”都是真的！这甚至包括
    `/`（根）目录，容器可以在没有任何限制的情况下更改你的宿主文件系统。由于这种架构，存在许多其他安全漏洞，但你应该明白了。
- en: What’s different about Podman is that by default, it runs rootless; in other
    words, you can run containers using Podman without root privileges. When I first
    heard this, I thought it meant the user in the container was not root, but that’s
    not really the case. Rootless containers simply mean that the user instantiating
    the containers does not have root privileges. There are a few things to know about
    running a container without root privileges, and this recipe aims to instruct
    you how to run rootless containers, while at the same time explaining the differences
    between rootless and rootful.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 与其他工具不同之处在于，默认情况下，它是以无 root 权限的方式运行；换句话说，你可以在没有 root 权限的情况下使用 Podman
    运行容器。当我第一次听到这一点时，我以为这意味着容器中的用户不是 root，但事实并非如此。Rootless 容器的含义仅仅是启动容器的用户没有 root
    权限。关于在没有 root 权限的情况下运行容器，有一些需要了解的事项，本指南将教你如何运行 rootless 容器，同时解释 rootless 和 rootful
    之间的区别。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Oracle Linux
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Linux
- en: Podman
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman
- en: How to do it…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: To run rootless containers with Podman, all you need to do is use Podman as
    a user without root privileges. Also, do not append `sudo` to any Podman commands,
    because if you do, you would then be running the container as the root user.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 rootless 容器，只需以无 root 权限的用户身份使用 Podman。并且，千万不要在任何 Podman 命令前加上 `sudo`，因为如果加了
    `sudo`，那么你实际上是在以 root 用户身份运行容器。
- en: What’s different about rootless containers?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Rootless 容器有什么不同？
- en: Network modes
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络模式
- en: 'There are three common network modes supported by Podman:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 支持三种常见的网络模式：
- en: Bridged
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接
- en: macvlan
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macvlan
- en: slirp4netns
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: slirp4netns
- en: First, there’s a **bridged** network, which is the default used by rootful Podman.
    Bridged networking creates a network interface on the host and dedicates this
    interface to the container. Another network mode is **macvlan**, which is a virtual
    LAN that basically forwards an entire network interface from the host into the
    container. Finally, there is **slirp4netns**, which enables you to connect a network
    namespace to the internet in a completely unprivileged way. Rootless Podman leverages
    **slirp4netns** because unprivileged users lack the ability to create network
    interfaces on the host. In order to bypass this limitation, **slirp4netns** instead
    creates a tunnel from the host and into the container in order to forward traffic.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，**桥接**网络是 rootful Podman 默认使用的网络模式。桥接网络在主机上创建一个网络接口，并将该接口专门分配给容器。另一种网络模式是**macvlan**，它是一个虚拟局域网，基本上将整个网络接口从主机转发到容器。最后，还有**slirp4netns**，它允许你以完全无特权的方式将一个网络命名空间连接到互联网。Rootless
    Podman 利用**slirp4netns**，因为无特权用户无法在主机上创建网络接口。为了绕过这一限制，**slirp4netns**会在主机和容器之间创建一个隧道，以转发流量。
- en: Network ports
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络端口
- en: 'When you run your containers without root access, you may run into issues exposing
    certain network ports. For example, it is common for users to expose ports `80`
    and/or `443` when running containers; however, if you try to do this while running
    a rootless container, you will see a message like the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以非 root 用户身份运行容器时，可能会遇到暴露某些网络端口的问题。例如，用户在运行容器时通常会暴露`80`端口和/或`443`端口；然而，如果你在运行
    rootless 容器时尝试这样做，你将看到类似下面的消息：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Rootless Podman is limited to exposing ports `1024` and above. If you wanted
    to expose a lower port, you would need to first configure this as root in order
    to allow unprivileged users to expose lower port numbers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Rootless Podman 限制只能暴露 `1024` 以上的端口。如果你想暴露更低的端口，首先需要以 root 身份进行配置，以允许无特权用户暴露较低的端口号。
- en: 'Let’s say you wanted to allow rootless Podman to expose the standard HTTP web
    port (port `80`). In this case, you can run this command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想让 rootless Podman 暴露标准的 HTTP Web 端口（端口 `80`）。在这种情况下，你可以运行以下命令：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you want these settings to persist, simply follow the guidance of the error
    message received earlier. That is, edit the `/etc/sysctl.conf` file and append
    `net.ipv4.ip_unprivileged_port_start=80`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望这些设置保持不变，只需按照之前收到的错误信息的指引操作。也就是说，编辑 `/etc/sysctl.conf` 文件，并添加 `net.ipv4.ip_unprivileged_port_start=80`。
- en: Creating handy-dandy utility containers
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建实用的工具容器
- en: This recipe shows how to use Podman to quickly spin up a container to complete
    useful tasks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南展示了如何使用 Podman 快速启动一个容器，以完成有用的任务。
- en: This recipe will walk you through the process of creating super useful utilities
    leveraging containers. The basic principle of containers encourages us to formulate
    our containers to do only one thing – that is, to provide some form of utility
    and nothing more. You should not create a container that does too much. With that
    being said, most container images already exist to provide a useful utility. In
    this recipe, we are going to look at examples of containers that serve a useful
    purpose, and we’re going to explore how to make use of this.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将引导你通过使用容器创建超级实用工具的过程。容器的基本原则鼓励我们将容器设计为只做一件事——也就是说，提供某种形式的工具功能，其他的都不做。你不应创建一个功能过多的容器。话虽如此，大多数容器镜像已经存在，用于提供有用的工具。在本教程中，我们将查看一些有用的容器示例，并探索如何利用它们。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will require the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要以下工具：
- en: Oracle Linux
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Linux
- en: Podman
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman
- en: How to do it…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: The main intention of this recipe is to show how we can use containers to achieve
    a function without installing additional packages on our local machine. Once you
    have Podman installed on your local machine, you can tap into an entire ecosystem
    of useful packages and utilities without installing more packages – instead, you
    simply run a container image that contains those packages, or, alternatively,
    you create a new container and install the desired packages there.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的主要目的是展示如何使用容器实现功能，而无需在本地机器上安装额外的包。一旦在本地机器上安装了 Podman，你可以访问整个有用的包和工具生态系统，而无需安装更多的包——你只需运行一个包含所需包的容器镜像，或者，你可以创建一个新的容器并在那里安装所需的包。
- en: Why would anyone prefer to do this? For starters, it allows you to minimize
    the number of packages and dependencies you’re installing on your host machine.
    With fewer packages, you reduce your attack surface in terms of security. Additionally,
    your operating system’s repositories might be limited to access to certain packages,
    or it might not have access to the latest versions. Instead of going through the
    effort of adding potentially untrusted repositories to install the packages you
    need, why not simply launch a container that contains everything you need for
    the specific function you’re trying to achieve?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有人会选择这样做？首先，这可以帮助你最小化在主机上安装的包和依赖项的数量。通过减少包的数量，你可以降低安全方面的攻击面。此外，你的操作系统的仓库可能会限制某些包的访问，或者可能无法访问最新版本。与其通过添加可能不受信任的仓库来安装所需的包，不如直接启动一个包含所有你需要的功能的容器呢？
- en: Before we try to tap into the true potential of containers, we first need to
    discuss a few important concepts that will make this process a bit easier.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试挖掘容器的真正潜力之前，首先需要讨论一些重要的概念，这些概念将使这个过程变得更加简便。
- en: Entrypoint
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入口点
- en: The entrypoint of a container defines what command the container will run by
    default. You can find the entrypoint of a container by specifying the `inspect`
    command and piping that to `jq` to extract only the entrypoint.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的入口点定义了容器默认运行的命令。你可以通过指定 `inspect` 命令并将其结果传输到 `jq` 来提取入口点。
- en: 'First, pull the image if you don’t already have it on your system:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果系统中没有该镜像，请拉取镜像：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now let’s inspect the image and run `jq` to query for the entrypoint:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查镜像并运行 `jq` 查询入口点：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`jq` installed on our computer. In this case, we can pipe the output of `inspect`
    to a container that contains `jq`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的计算机上安装 `jq`。在这种情况下，我们可以将 `inspect` 的输出传输到一个包含 `jq` 的容器中：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In either case, the output of this command will be `/usr/local/bin/pandoc`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，这个命令的输出将是 `/usr/local/bin/pandoc`。
- en: This tells us that when we run the `pandoc/core` container, the default command
    that gets executed will be `/usr/local/bin/pandoc`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，当我们运行 `pandoc/core` 容器时，默认执行的命令将是 `/usr/local/bin/pandoc`。
- en: 'Sometimes, a container’s entrypoint might be a script. For example, you might
    check for the entrypoint and learn that the entrypoint is `docker-entrypoint.sh`.
    You can reveal more about this file by overriding the entrypoint and using `cat`
    to see the contents of the file. For example, let’s say we were to inspect the
    `node` container image:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，容器的入口点可能是一个脚本。例如，你可能检查入口点并发现入口点是 `docker-entrypoint.sh`。你可以通过重写入口点并使用 `cat`
    查看文件内容，从而揭示更多关于该文件的信息。例如，假设我们要检查 `node` 容器镜像：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We would find that the entrypoint is `docker-entrypoint.sh`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会发现入口点是 `docker-entrypoint.sh`。
- en: 'Now, let’s override the entrypoint to examine the contents of this file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们覆盖入口点来检查这个文件的内容：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this case, the output is the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出如下：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is because in the case of the `node` image, the `docker-entrypoint.sh`
    file is not in the working directory; instead, it is found in the path. So, we’ll
    try another way to examine this file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在`node`镜像的情况下，`docker-entrypoint.sh`文件不在工作目录中；相反，它位于路径中。所以，我们将尝试另一种方法来检查这个文件：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output will be as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 11.1 – Output of docker-entrypoint.sh](img/B18349_11_001.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – docker-entrypoint.sh 的输出](img/B18349_11_001.jpg)'
- en: Figure 11.1 – Output of docker-entrypoint.sh
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – docker-entrypoint.sh 的输出
- en: Now that we know about the default entrypoint, we can use this as we determine
    what we’re going to do with the container. Sometimes we might want to use the
    default entry point as intended, whereas other times we might benefit from overriding
    the default entrypoint to use some other available packages within the container
    – it all depends on what we’re trying to do.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了默认入口点，我们可以利用这一点来决定我们将如何使用这个容器。有时我们可能希望按预期使用默认入口点，而其他时候，我们可能从覆盖默认入口点来使用容器内的其他可用包中受益——这完全取决于我们想要做什么。
- en: Working directory
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作目录
- en: 'You’ll often want to specify the working directory inside the container, because
    that’s where the container is configured by default to perform its work. To get
    the working directory of a container, you can run the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常需要指定容器内部的工作目录，因为默认情况下，容器被配置为在该目录中执行其工作。要获取容器的工作目录，你可以运行以下命令：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Again, you get bonus points if you do this without installing `jq` by running
    this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，如果你能在不安装`jq`的情况下通过运行以下命令来实现，你将获得额外的奖励：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In either case, the output of this command will be `/data`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，执行此命令的输出将是`/data`。
- en: This tells us that when we run the `pandoc/core` container, the default working
    directory inside the container is `/data`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，当我们运行`pandoc/core`容器时，容器内的默认工作目录是`/data`。
- en: Volume mounting
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卷挂载
- en: In order to make use of a container that performs a task against files on your
    local machine, you’ll first need to mount a volume into the container. An easy
    way to do this is to specify your present working directory by specifying `$(pwd)`.
    Another method might be to specify `./`. The order in which this is done is by
    declaring the host machine’s directory first, and the container’s directory second.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用一个在本地机器上对文件执行任务的容器，你首先需要将一个卷挂载到容器中。一种简单的方法是通过指定`$(pwd)`来指定当前工作目录。另一种方法是指定`./`。执行此操作的顺序是先声明主机机器的目录，再声明容器的目录。
- en: For example, if you wanted to mount the present working directory of the host
    machine into the working directory of the container, you would run `-v $(pwd):/data`.
    In this example, we are saying we want our present working directory on the host
    machine to be accessible inside the container at the `/data` path. Remember, we
    found the working directory of the container when we used the `podman` `inspect`
    command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想将主机机器的当前工作目录挂载到容器的工作目录中，你可以运行`-v $(pwd):/data`。在这个例子中，我们是想让主机机器的当前工作目录在容器内的`/data`路径下可访问。记住，当我们使用`podman
    inspect`命令时，我们已经找到了容器的工作目录。
- en: Super useful utility containers
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超级实用的容器工具
- en: Now that we’ve discussed some of the important concepts, I am going to list
    examples of useful utilities I’ve found in containers and then will expand on
    the practicality of leveraging containers for these functions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了一些重要概念，我将列出我在容器中找到的有用工具的示例，并扩展利用容器执行这些功能的实际性。
- en: Converting a Markdown file to docx using pandoc
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 pandoc 将 Markdown 文件转换为 docx
- en: In this example, let’s imagine we have a document that we want to convert to
    another type. There are many tools we can leverage to do this, but one such tool
    that comes to mind is pandoc. Rather than installing pandoc on my local machine,
    I’ll simply run the `pandoc/core` container, which has pandoc preinstalled. The
    entrypoint in the `pandoc` container is `/bash/pandoc`. This means that anything
    after the specification of the container image will automatically append to the
    `pandoc` command inside the container.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，假设我们有一个文档，想要将其转换为另一种类型。我们可以利用许多工具来实现这一点，但有一个工具是 pandoc。与其在本地机器上安装 pandoc，不如直接运行已经预安装了
    pandoc 的`pandoc/core`容器。`pandoc`容器的入口点是`/bash/pandoc`。这意味着，在指定容器镜像后，任何内容都会自动附加到容器内的`pandoc`命令。
- en: 'We can run `--help` after the `pandoc/core` command to learn how to use the
    utility, for example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`pandoc/core`命令后加上`--help`来了解如何使用该工具，例如：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'From that (you can also view the man page maintained here: [https://linux.die.net/man/1/pandoc](https://linux.die.net/man/1/pandoc)),
    I now have some insight into how to use pandoc. In this case, I can use the `pandoc`
    command within the container by mounting my present working directory into the
    container and specifying my source document and what I want the output to be,
    for example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个（你也可以查看这里维护的手册页：[https://linux.die.net/man/1/pandoc](https://linux.die.net/man/1/pandoc)），我现在对如何使用pandoc有了一些了解。在这种情况下，我可以通过将当前工作目录挂载到容器中，并指定我的源文档和输出内容，来在容器中使用`pandoc`命令，例如：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since the working directory inside the container is `/data`, and since I have
    that mounted to my host system, if the container creates a new file inside that
    directory, I will be able to find the output on my host system. Cool!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器内的工作目录是`/data`，并且我已经将该目录挂载到我的主机系统上，如果容器在该目录中创建了新文件，我将能够在我的主机系统上找到输出结果。很酷！
- en: Making a change to an image or video file using FFMPEG
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用FFMPEG对图像或视频文件进行修改
- en: In this example, we will leverage FFMPEG within a container in the same way
    we leveraged pandoc in the previous container. Using the FFMPEG container is especially
    handy because FFMPEG tends to rely on lots and lots of dependencies that I’d prefer
    not to install on my local machine. Additionally, it’s nice that the official
    FFMPEG container comes packaged with the latest version, and it works great!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将以与之前使用pandoc容器相同的方式，在容器中使用FFMPEG。使用FFMPEG容器特别方便，因为FFMPEG通常依赖许多我不希望安装在本地计算机上的依赖项。此外，官方的FFMPEG容器自带最新版本，运行起来也很棒！
- en: 'Just like in the previous example, we can run `--help` after the `ghcr.io/linuxserver/ffmpeg`
    command to learn how to use FFMPEG, for example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的示例一样，我们可以在`ghcr.io/linuxserver/ffmpeg`命令后加上`--help`来了解如何使用FFMPEG，例如：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'From the output (you can also view the man page maintained here: [https://linux.die.net/man/1/ffmpeg](https://linux.die.net/man/1/ffmpeg)),
    I can see a plethora of options, but for the sake of brevity, I will simply show
    how you can use `ffmpeg` from a container to convert video within a container,
    for example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出结果来看（你也可以查看这里维护的手册页：[https://linux.die.net/man/1/ffmpeg](https://linux.die.net/man/1/ffmpeg)），我可以看到许多选项，但为了简洁起见，我将简单展示如何从容器中使用`ffmpeg`来转换容器内的视频，例如：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This command will start at 00 hours, 00 minutes, and 30 seconds (specified by
    `-ss`) into the video, and will record 5 seconds (specified by `-t`). It will
    then convert the video, and the output can be found in `./config/output.mp4`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会从视频的00小时00分钟30秒（由`-ss`指定）开始，并录制5秒钟（由`-t`指定）。然后，它会转换视频，输出结果可以在`./config/output.mp4`找到。
- en: Using Node.js within a container
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在容器中使用Node.js
- en: Let’s say we need to build a Node.js application. To do this, we’ll want to
    use Node and npm. In [*Chapter 10*](B18349_10.xhtml#_idTextAnchor304), we discussed
    the usefulness of application streams and how you can leverage application streams
    to install different versions of Node.js. Well, just like anything else in life,
    there is *more than one way to skin* *a cat*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要构建一个Node.js应用程序。为此，我们需要使用Node和npm。在[*第10章*](B18349_10.xhtml#_idTextAnchor304)中，我们讨论了应用流的有用性，以及如何利用应用流安装不同版本的Node.js。好吧，就像生活中的其他事情一样，*有多种方式可以解决问题*。
- en: Rather than installing Node.js on your host system, why not leverage Node.js
    within a container instead? The `node` container includes Node and npm. By default,
    when you run the `node` container, you are executing the `node` command, as this
    is the default entrypoint (as you may recall from earlier when we discussed entrypoints).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接在容器中使用Node.js，而不是在主机系统上安装Node.js呢？`node`容器包含了Node和npm。默认情况下，当你运行`node`容器时，你是在执行`node`命令，因为这是默认的入口点（就像我们之前讨论入口点时提到的那样）。
- en: 'Let’s say we want to use the `npm` command instead – we can do this by overriding
    the entrypoint. At this point, we know we can override the entrypoint by leveraging
    bash and appending a command at the end, but we also need to know where to mount
    our host system:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想使用`npm`命令——我们可以通过覆盖入口点来实现这一点。到此为止，我们知道可以通过利用bash并在末尾添加命令来覆盖入口点，但我们还需要知道如何挂载我们的主机系统：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'From this, we can see that the default working directory within the container
    is null. Does that mean we can’t use the container the way we want? Of course
    not, because we can simply override the entrypoint and take matters into our own
    hands. In this scenario, I will mount the present working directory from my host
    system into an `/app` directory, and I’ll override the entry point to bash so
    I can instruct the container to change directory to `/app` before I run the `npm`
    command to build my Node.js application. Here’s how that can be done:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以看到，容器内的默认工作目录是 null。这是否意味着我们不能按照自己的方式使用容器？当然不是，因为我们可以简单地覆盖入口点，自己来操作。在这种情况下，我会将主机系统中的当前工作目录挂载到
    `/app` 目录，并将入口点覆盖为 bash，这样我就可以指示容器在运行 `npm` 命令构建我的 Node.js 应用程序之前，先切换到 `/app`
    目录。以下是实现方法：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once NPM completes the build, you’ll find your application binaries inside a
    directory called `./build` on your host machine
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 NPM 完成构建，你将在主机机器上找到名为 `./build` 的目录，其中包含你的应用程序二进制文件。
- en: 'But wait, just as I mentioned earlier, there is *more than one way to skin
    a cat*. A more elegant way to achieve the same thing might be to instead tell
    Podman where you want the working directory to be. If we do this, we don’t even
    need to set bash as our entry point – instead, we can jump straight into npm.
    This can be done with the `-w` (or `--workdir`) command, like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，正如我之前提到的，*有很多种方法可以解决同一个问题*。一种更优雅的方法可能是直接告诉 Podman 你希望工作目录在哪里。如果我们这样做，我们甚至不需要将
    bash 设置为入口点——相反，我们可以直接跳到 npm。可以使用 `-w`（或 `--workdir`）命令来实现，方法如下：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In my opinion, the second approach is cleaner, but the end result is the same.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，第二种方法更简洁，但最终结果是一样的。
- en: Running a lightweight NGINX web server to preview a web page locally
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行一个轻量级的 NGINX 网络服务器以在本地预览网页
- en: In this example, we might as well continue from the last exercise, where we
    built a Node.js application. Now that we have our Node .js application built/compiled,
    let’s host it inside an NGINX container. We can do this by simply mounting the
    build directory into the `/user/share/nginx/html` directory inside the NGINX container.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们可以继续上一个练习，在那里我们构建了一个 Node.js 应用程序。现在我们已经构建/编译了 Node.js 应用程序，接下来让我们将其托管在
    NGINX 容器中。我们可以通过简单地将构建目录挂载到 NGINX 容器内的 `/user/share/nginx/html` 目录来实现这一点。
- en: How did I know to host it inside this specific directory? In this case, I had
    to read up on the NGINX documentation for the NGINX container. You can usually
    find this type of documentation on any container registry that hosts the container
    you’re looking to run.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我是怎么知道要把它托管在这个特定目录里的呢？在这种情况下，我不得不查阅 NGINX 容器的 NGINX 文档。你通常可以在任何托管你要运行的容器的容器注册表中找到这类文档。
- en: 'The command to host our build directory locally is the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 托管我们的构建目录的命令如下：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With Podman, the default setting for rootless ports cannot expose privileged
    port `80`. If you have not changed this setting, you will see a message such as
    this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Podman 时，rootless 端口的默认设置不能暴露特权端口 `80`。如果你没有更改此设置，你将看到如下信息：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can override this setting if you have root privileges, with the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你具有 root 权限，可以通过以下方式覆盖此设置：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Alternatively, you can simply choose to use a port number of `1024` or higher.
    Once you have the container running, you can preview the local website by navigating
    to `http://localhost` (if you’re using port `80`) or `http://localhost:8080` (or
    whatever port that you assigned if you did not go with port `80`).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以选择使用 `1024` 或更高的端口号。一旦容器运行起来，你可以通过导航到 `http://localhost`（如果你使用的是端口 `80`）或
    `http://localhost:8080`（如果你没有选择端口 `80`，则是你分配的端口）来预览本地网站。
- en: Docker Compose with Podman
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Podman 的 Docker Compose
- en: Podman is a powerful container engine that is typically accessed via a `docker-compose.yml`
    file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 是一个强大的容器引擎，通常通过 `docker-compose.yml` 文件进行访问。
- en: While Docker Compose is a great utility for configuring your containers as code,
    it’s important to know that Docker Compose was designed to be used with Docker.
    With that being said, there are a few things to be aware of when using Docker
    Compose with Podman.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Docker Compose 是一个很棒的工具，可以将容器配置为代码，但重要的是要知道 Docker Compose 设计时是为了与 Docker
    一起使用的。因此，在使用 Docker Compose 与 Podman 时，有几个需要注意的事项。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will require the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下内容：
- en: Oracle Linux
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Linux
- en: Podman
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman
- en: Docker Compose
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In this recipe, we’re going to talk about how you can use Docker Compose with
    Podman.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将讨论如何将 Docker Compose 与 Podman 一起使用。
- en: 'Since Compose files typically involve multiple containers and applications
    communicating with one another, I recommend the use of the Netavark- and Aardvark-based
    network stack rather than the CNI-based stack. Netavark and Aardvark are new in
    Podman 4.0 and offer reduced overhead and significant performance enhancements.
    Additionally, I experienced issues with the default CNI-based stack, whereas switching
    to Netavark and Aardvark enabled my containers to communicate with each other
    as expected:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Compose 文件通常涉及多个容器和应用程序之间的通信，我建议使用基于 Netavark 和 Aardvark 的网络堆栈，而不是基于 CNI
    的堆栈。Netavark 和 Aardvark 是 Podman 4.0 中的新特性，提供了更低的开销和显著的性能提升。此外，我在使用默认的 CNI 堆栈时遇到了一些问题，而切换到
    Netavark 和 Aardvark 后，容器之间能够按预期相互通信：
- en: 'To switch out your network stack, simply specify `netavark` as the network
    backend in the `/usr/share/containers/containers.conf` file. You can do this quickly
    by running the following `sed` command:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要切换网络堆栈，只需在 `/usr/share/containers/containers.conf` 文件中指定 `netavark` 作为网络后端。您可以通过运行以下
    `sed` 命令快速完成此操作：
- en: '[PRE25]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you already running containers on your system, you will need to run `sudo
    podman system reset` in order to fully switch to the Netavark- and Aardvark-based
    network stack, but just be aware that this command will remove all your existing
    images, containers, pods, networks, and volumes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在系统上运行容器，您需要运行 `sudo podman system reset` 才能完全切换到基于 Netavark 和 Aardvark
    的网络堆栈，但请注意，此命令将删除所有现有的镜像、容器、Pod、网络和卷。
- en: 'Now that is out of the way, let’s start by installing Docker Compose:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然这部分已经处理完了，我们来开始安装 Docker Compose：
- en: '[PRE26]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: sudo dnf install podman-docker
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo dnf install podman-docker
- en: '[PRE27]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we need to enable the Podman socket:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要启用 Podman 套接字：
- en: 'To use Docker Compose in a rootless manner, use this command:'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要以无 root 用户身份使用 Docker Compose，请使用以下命令：
- en: '[PRE28]'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To use Docker Compose in a rootful manner, use this command:'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要以 root 用户身份使用 Docker Compose，请使用以下命令：
- en: '[PRE29]'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that Docker Compose is ready to go, we’ll need a Compose file to test things
    with. Let’s first examine a Compose file:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 Docker Compose 准备就绪，我们需要一个 Compose 文件来进行测试。让我们首先查看一个 Compose 文件：
- en: '![Figure 11.2 – Compose file for Portainer](img/B18349_11_002.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – Portainer 的 Compose 文件](img/B18349_11_002.jpg)'
- en: Figure 11.2 – Compose file for Portainer
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – Portainer 的 Compose 文件
- en: In a `docker-compose.yml` file, we define how we want Docker (or Podman in this
    case) to run multi-container applications. In the case of this `docker-compose.yml`
    file, we define the services and the volumes we want Podman to create, and we
    configure various parameters of the service to our liking.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `docker-compose.yml` 文件中，我们定义了如何希望 Docker（或在本例中为 Podman）运行多容器应用程序。在这个 `docker-compose.yml`
    文件中，我们定义了 Podman 要创建的服务和卷，并根据我们的喜好配置了服务的各项参数。
- en: Info
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: For a comprehensive overview of the entire Compose specification, see [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要全面了解整个 Compose 规范，请参见 [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)。
- en: Now, let’s test things and see if Docker Compose will work. Save the contents
    of the Compose file in a file named `docker-compose.yml`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下，看看 Docker Compose 是否可以正常工作。将 Compose 文件的内容保存到名为 `docker-compose.yml`
    的文件中。
- en: 'Using the terminal, change directory to the same directory you saved the `docker-compose.yml`
    file in and run the following:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用终端，将当前目录切换到保存 `docker-compose.yml` 文件的目录，然后运行以下命令：
- en: '[PRE30]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Congratulations, you are now using Docker Compose with Podman.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您现在正在使用 Podman 和 Docker Compose。
- en: Managing stacks with pods
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pod 管理堆栈
- en: Keeping everything organized with stacks and prepping for Kubernetes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过堆栈管理保持一切有序，并为 Kubernetes 做准备。
- en: Podman supports concepts that do not exist in Docker. One of the big ones is
    pods – so I guess that’s where the name *Podman* derives from... *Podman = Pod
    Manager*. In this recipe, you will learn how to keep things organized by managing
    stacks with Podman. We’ll achieve this functionality through the use of pods.
    Pods consist of one or more containers. Because pods are the smallest deployable
    units that you can create and manage in Kubernetes, familiarizing yourself with
    pods will help you bridge the gap between containers and Kubernetes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 支持 Docker 中不存在的概念。一个重要的概念是 Pod——我想这也是 *Podman* 这个名字的来源... *Podman = Pod
    管理器*。在本教程中，您将学习如何通过使用 Pod 管理堆栈来保持一切有序。我们将通过使用 Pod 来实现这一功能。Pod 由一个或多个容器组成。由于 Pod
    是您可以在 Kubernetes 中创建和管理的最小可部署单元，因此熟悉 Pod 将帮助您弥合容器和 Kubernetes 之间的差距。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'We will require the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下内容：
- en: Oracle Linux
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Linux
- en: Podman
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman
- en: Docker Compose
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: How to do it…
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Before we jump into the recipe, we should first discuss a little more about
    pods. As mentioned previously, pods consist of one or more containers. Pods will
    always contain an `infra` container, which, by default is based on the `k8s.gcr.io/pause`
    image. The `infra` container basically does nothing but sleep – this ensures that
    the container continues to run even while idle, and it holds the port bindings,
    namespaces, and cgroups from the kernel. Once the pod is created, the attributes
    assigned to the `infra` container cannot be changed. It’s important to remember
    that any ports that need to be exposed will need to be done during the initial
    creation of the pod.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳入食谱之前，我们首先应该多讨论一下pods。如前所述，pods由一个或多个容器组成。pods将始终包含一个`infra`容器，默认情况下基于`k8s.gcr.io/pause`镜像。`infra`容器基本上什么也不做，只是睡眠——这确保即使在空闲时，容器仍然运行，并且它持有来自内核的端口绑定、命名空间和cgroups。一旦pod创建，分配给`infra`容器的属性就不能更改。重要的是要记住，任何需要暴露的端口必须在pod初次创建时完成。
- en: Outside of the pod exists a **conmon** (**container monitor**) instance that
    watches the primary process of the container. Each container has its own instance
    of conmon.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在pod外部存在一个**conmon**（**容器监控**）实例，负责监视容器的主进程。每个容器都有自己独立的conmon实例。
- en: The following diagram provides an architectural overview of what makes up a
    pod.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下图提供了构成pod的架构概述。
- en: '![Figure 11.3 – Architectural overview of a pod](img/B18349_11_003.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – pod的架构概述](img/B18349_11_003.jpg)'
- en: Figure 11.3 – Architectural overview of a pod
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – pod的架构概述
- en: 'Here are the Podman commands that relate to pods:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是与pods相关的Podman命令：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As can be seen from the preceding commands, you can use the Podman CLI to create
    a pod and run your containers within the pod.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的命令可以看到，你可以使用Podman CLI来创建pod并在pod内运行你的容器。
- en: Manual pod creation
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动创建pod
- en: 'Let’s say we wanted to deploy Wiki.js inside a pod. Wiki.js is open source
    Wiki software built on Node.js and relies on a database backend. In other words,
    we want a pod that looks like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要在pod内部署Wiki.js。Wiki.js是一个开源的Wiki软件，建立在Node.js上，并依赖于数据库后端。换句话说，我们希望pod看起来像这样：
- en: '![Figure 11.4 – Architecture of a Wiki.js pod](img/B18349_11_004.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – Wiki.js pod的架构](img/B18349_11_004.jpg)'
- en: Figure 11.4 – Architecture of a Wiki.js pod
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – Wiki.js pod的架构
- en: 'We can construct this pod manually by following these steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下步骤手动构建这个pod：
- en: 'The first step is to create a pod. As we do this, we need to ensure we configure
    the port mappings to allow ingress into port `3000`. We will do this using the
    `podman` `pod` command:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建一个pod。在我们这样做时，需要确保配置端口映射，以允许进入端口`3000`。我们将使用`podman` `pod`命令来实现：
- en: '[PRE32]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '--pod tag to ensure this container runs inside the same pod as the database:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --pod标签确保该容器在与数据库相同的pod内运行：
- en: '[PRE33]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Automatic pod creation
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动创建pod
- en: Podman allows you to create pods manually using the command-line interface,
    but another cool feature of Podman is that it natively supports Kubernetes manifests.
    Since pods are the smallest deployable units that you can create and manage in
    Kubernetes, this means that deploying Kubernetes manifests in Podman will result
    in the creation of pods by default.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Podman允许你通过命令行界面手动创建pods，但Podman的另一个酷功能是它原生支持Kubernetes清单。由于pods是你可以在Kubernetes中创建和管理的最小可部署单元，这意味着在Podman中部署Kubernetes清单将默认创建pods。
- en: 'Writing a full Kubernetes manifest is outside the scope of this recipe, but
    I’m going to show you how you can generate a Kubernetes manifest automatically
    using Podman, and subsequently use that manifest to deploy your containers into
    pods. Since we just learned about using Compose files in the previous recipe,
    we’re going to leverage them again here, and then we’ll supercharge them by converting
    them into Kubernetes manifests:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 编写完整的Kubernetes清单超出了本食谱的范围，但我将向你展示如何使用Podman自动生成Kubernetes清单，并随后使用该清单将容器部署到pods中。由于我们在前面的食谱中刚刚学习了如何使用Compose文件，所以我们将在这里再次利用它们，然后通过将它们转换为Kubernetes清单来增强它们：
- en: The first thing to do is to deploy your containers from a Compose file. For
    this recipe, we’ll start with a Compose file for Wiki.js.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要做的是从Compose文件部署容器。对于本食谱，我们将从Wiki.js的Compose文件开始。
- en: '![Figure 11.5 – Compose file for Wiki.js](img/B18349_11_005.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – Wiki.js的Compose文件](img/B18349_11_005.jpg)'
- en: Figure 11.5 – Compose file for Wiki.js
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – Wiki.js的Compose文件
- en: Wiki.js requires two containers, one for the application itself, and the other
    is a PostgreSQL database.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Wiki.js 需要两个容器，一个用于应用程序本身，另一个是 PostgreSQL 数据库。
- en: 'Now that we have our Compose file, let’s use Docker Compose to deploy the containers:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了 Compose 文件，接下来我们使用 Docker Compose 部署容器：
- en: '[PRE35]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Once the containers are running, verify that everything works by pointing your
    browser to http://127.0.0.1:3000.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦容器运行，验证一切是否正常，可以通过浏览器访问 http://127.0.0.1:3000 进行检查。
- en: 'If you see the Wiki.js setup screen, you’re good to go. At this point, we’re
    going to generate a Kubernetes manifest (called `wikijs.yaml`) from the two containers
    we just launched:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你看到了 Wiki.js 设置界面，说明一切正常。此时，我们将从刚刚启动的两个容器生成一个 Kubernetes 清单（名为 `wikijs.yaml`）：
- en: '[PRE36]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that the Kubernetes manifest is generated, let’s bring down the containers
    we just launched:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 Kubernetes 清单已生成，让我们关闭刚刚启动的容器：
- en: '[PRE37]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Podman run –rm -v ${PWD}:/workdir docker.io/mikefarah/yq e -i '(select(.kind
    == "Pod").spec.containers[] | select(.name == "wikijs" ).env[] | select(.name
    == "DB_HOST")).value = "wikijs-pod-wikijs-db"' wikijs.yaml
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Podman run –rm -v ${PWD}:/workdir docker.io/mikefarah/yq e -i '(select(.kind
    == "Pod").spec.containers[] | select(.name == "wikijs" ).env[] | select(.name
    == "DB_HOST")).value = "wikijs-pod-wikijs-db"' wikijs.yaml
- en: '[PRE38]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to the *Creating handy-dandy utility containers* recipe for more information
    on how to use a container as a utility.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考*创建方便实用的工具容器*一节，了解如何将容器用作工具。
- en: 'Once you’ve corrected the `DB_HOST` value, run the following command:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你修正了 `DB_HOST` 值，运行以下命令：
- en: '[PRE39]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Verify that the pod is running:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 Pod 是否正在运行：
- en: '[PRE40]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, go ahead and navigate to http://127.0.0.1:3000.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，继续访问 http://127.0.0.1:3000。
- en: Containerized databases
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化数据库
- en: This recipe discusses best practices regarding the use of containerized databases.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了使用容器化数据库的最佳实践。
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will require the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要以下资源：
- en: Oracle Linux
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Linux
- en: Podman
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman
- en: How to do it…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行…
- en: Containers make databases a much easier pill to swallow for your everyday application
    deployments. There’s not a lot to discuss in this recipe, but there are a few
    best practices with containerized databases that will definitely be useful to
    know about.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 容器使数据库成为日常应用部署中更容易接受的部分。本节讨论的内容不多，但有一些关于容器化数据库的最佳实践，了解这些将非常有帮助。
- en: Do one thing and one thing only
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 做一件事，只做一件事
- en: 'Just as a core principle of containers is to do one thing and one thing only,
    the same principle applies to containerized databases. What do I mean by that?
    Well, for starters, you might be inclined to launch a containerized database and
    subsequently create multiple schemas within that database and/or multiple databases
    within that single container. Let’s say you have several applications that require
    a MySQL database, then it probably seems like a good idea to have a single MySQL
    database container with separate database schemas for each containerized application…
    something that looks a bit like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 正如容器的核心原则是“做一件事，只做一件事”，同样的原则也适用于容器化数据库。这是什么意思呢？首先，你可能会倾向于启动一个容器化数据库，然后在该数据库中创建多个模式和/或多个数据库。假设你有几个需要
    MySQL 数据库的应用程序，那么让一个单独的 MySQL 数据库容器包含每个容器化应用程序的不同数据库模式似乎是个好主意……像这样：
- en: '![Figure 11.6 – What not to do with containerized databases](img/B18349_11_006.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 使用容器化数据库时不应做的事](img/B18349_11_006.jpg)'
- en: Figure 11.6 – What not to do with containerized databases
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 使用容器化数据库时不应做的事
- en: 'The problem with this architecture is that it does not adhere well to the principle
    of doing one thing and one thing only. Instead, I recommend spinning up a separate
    container for each database an application needs. Name that container so that
    it is complementary to the application it’s paired with – something like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构的问题在于它没有很好地遵循“做一件事，只做一件事”的原则。相反，我建议为每个应用所需的数据库启动一个独立的容器。为容器命名时，使其与应用程序相辅相成——像这样：
- en: '![Figure 11.7 – A better way to use containerized databases](img/B18349_11_007.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 更好的使用容器化数据库的方法](img/B18349_11_007.jpg)'
- en: Figure 11.7 – A better way to use containerized databases
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 更好的使用容器化数据库的方法
- en: For example, let’s say you have a WordPress container that requires a database.
    In this scenario, if you named your WordPress container `wordpress01`, then you
    should name your MySQL container `wordpress01-db`. Having a separate container
    for every database you want to run will make it easier to troubleshoot issues
    and will additionally serve as a more reliable architectural model for your deployed
    applications. If you need to take one containerized database down, you’re then
    only affecting one application, rather than all of them if you chose to run multiple
    databases within one container.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个需要数据库的 WordPress 容器。在这种情况下，如果你将你的 WordPress 容器命名为 `wordpress01`，那么你应该将
    MySQL 容器命名为 `wordpress01-db`。为每个要运行的数据库设置单独的容器会使排查问题变得更容易，而且这种做法还会作为你部署应用程序时更可靠的架构模型。如果你需要停用一个容器化的数据库，那么你只会影响一个应用程序，而不是所有应用程序（如果你选择将多个数据库运行在同一个容器中）。
- en: Data storage
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据存储
- en: 'Persistent data is something you’ll need to address when running databases
    in containers. With Podman, you have two primary options: volumes and bind mounts.
    With volumes, Podman will manage the storage of your database by writing the data
    to disk using its own internal volume management system. With bind mounts, you
    will need to specify a location on the host system and mount that into the container.
    Either option is fine, and typically volumes are easier because it requires less
    configuration by the user, but the downside is that the data can be more difficult
    to locate on the host system. Additionally, it is possible for the volumes to
    be deleted by mistake via careless use of the `podman volume prune` command. With
    that being said, for demonstrations or quick tests, I like to use volumes, but
    for persistent data that is truly important, I prefer to use bind mounts.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化数据是你在容器中运行数据库时需要处理的一个问题。在 Podman 中，你有两个主要选项：卷（volumes）和绑定挂载（bind mounts）。使用卷时，Podman
    会通过其内部的卷管理系统将数据写入磁盘，从而管理数据库的存储。而使用绑定挂载时，你需要指定主机系统上的位置，并将其挂载到容器中。两种选择都可以，通常来说，卷更容易一些，因为用户的配置要求较少，但缺点是数据可能在主机系统中更难找到。此外，卷有可能会因不小心使用
    `podman volume prune` 命令而被删除。因此，对于演示或快速测试，我喜欢使用卷，但对于真正重要的持久化数据，我更倾向于使用绑定挂载。
- en: Creating volumes is simple. There are a few ways in which Podman allows for
    the creation of volumes. You can create a volume manually from the command line
    via the `podman volume create [NAME]` command. You can also let Podman do the
    heavy lifting for you, as it is capable of creating volumes automatically during
    container creation. Podman can create a named volume if you specify the name;
    for example, running `podman run -v my_data:/var/lib/mysql mysql:8-oracle` will
    create a volume called `my_data`. Podman can also create an anonymous volume if
    you leave out the `-v my_data:/data` specification and instead run `podman run
    -``it oraclelinux:8`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 创建卷非常简单。Podman 提供了几种创建卷的方式。你可以通过 `podman volume create [NAME]` 命令从命令行手动创建卷。你也可以让
    Podman 自动为你创建卷，因为它在创建容器时可以自动创建卷。如果你指定名称，Podman 可以创建一个命名卷；例如，运行 `podman run -v
    my_data:/var/lib/mysql mysql:8-oracle` 将会创建一个名为 `my_data` 的卷。如果你省略了 `-v my_data:/data`
    参数，而运行 `podman run -it oraclelinux:8`，Podman 也会创建一个匿名卷。
- en: If you want to use a bind mount instead, all you need to do is specify the location
    of where that mount should reside on the host system. For example, if you want
    to store your data in `/mnt/hdd/podman/volumes/`, you would simply need to specify
    this location as the source location. I prefer to set my volume location as an
    environment variable called `VOLUME_DIR` so that I can reference it with `${VOLUME_DIR}`.
    Then, when I specify creating a bind mount in the container, I simply use `podman
    run -v ${VOLUME_DIR}/wordpress:/var/lib/mysql mysql:8-oracle`. This will ensure
    that all my data is stored in a predictable location on my system, and each container
    gets its dedicated folder within that path.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用绑定挂载，只需要指定挂载在主机系统上的位置。例如，如果你希望将数据存储在 `/mnt/hdd/podman/volumes/` 目录中，只需将该目录指定为源位置。我更倾向于将我的卷位置设置为名为
    `VOLUME_DIR` 的环境变量，这样我可以通过 `${VOLUME_DIR}` 来引用它。然后，在我指定在容器中创建绑定挂载时，只需使用 `podman
    run -v ${VOLUME_DIR}/wordpress:/var/lib/mysql mysql:8-oracle`。这将确保我的所有数据都存储在系统上一个可预测的位置，并且每个容器在该路径中都有自己的专用文件夹。
- en: Initialization scripts
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化脚本
- en: 'Most containerized databases feature a way to facilitate the running of scripts
    after initial setup, which can be very handy. This is typically done by allowing
    the user to mount a directory from the host machine that contains `.sql` and/or
    `.sh` files into the `/docker-entrypoint-initdb.d` directory of the container.
    The scripts are generally executed in alphabetical order and thus can be easily
    controlled by adding a prefix with a number, for example, `01_users.sql`, `02_permissions.sql`,
    `03_hostname.sh`, and so forth:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数容器化的数据库都提供了一种便捷的方式来执行初始化设置后的脚本，这非常实用。这通常是通过允许用户将包含 `.sql` 和/或 `.sh` 文件的主机目录挂载到容器的
    `/docker-entrypoint-initdb.d` 目录来实现的。脚本通常按字母顺序执行，因此可以通过添加带数字前缀的文件名来轻松控制顺序，例如：`01_users.sql`，`02_permissions.sql`，`03_hostname.sh`
    等等：
- en: 'The MySQL database:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 数据库：
- en: 'The MySQL database supports `*.sh` and `*.sql` scripts in the following mount
    points:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MySQL 数据库支持在以下挂载点运行 `*.sh` 和 `*.sql` 脚本：
- en: '[PRE41]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*.sh and *.js scripts in the following mount points:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*.sh 和 *.js 脚本位于以下挂载点：'
- en: '[PRE42]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Controlling the startup order
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制启动顺序
- en: Using a Compose file, you are able to control the startup order of your containers
    by using condition attributes. A nice way to ensure your database is up and running
    (and ready to accept connections) is to configure a health check against the database.
    Once the health check succeeds, the database container will become healthy. The
    application that requires the database can be configured not to start until the
    database container enters a healthy state. This can be done using the `depends_on`
    option.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Compose 文件，您可以通过使用条件属性来控制容器的启动顺序。一种确保数据库启动并正常运行（并且准备好接受连接）的好方法是配置数据库的健康检查。一旦健康检查成功，数据库容器将变为健康状态。需要数据库的应用程序可以配置为在数据库容器进入健康状态之前不会启动。这可以通过使用
    `depends_on` 选项来实现。
- en: 'If you wanted to add a health check to a PostgreSQL database, you could configure
    that with the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想为 PostgreSQL 数据库添加健康检查，您可以使用以下配置：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, for the application, you would simply specify the service name (in this
    example, `wikijs-db`):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于应用程序，您只需指定服务名称（在此示例中为 `wikijs-db`）：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When these options are configured properly, you will no longer see repeated
    connection failures as the application tries to connect to a database that isn’t
    ready, because the application container won’t even start until the database container
    is healthy.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些选项配置正确时，您将不再看到应用程序尝试连接未准备好的数据库时出现的重复连接失败，因为应用程序容器在数据库容器变为健康之前根本不会启动。
- en: Tying it all together
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将一切联系起来
- en: 'Now that we’ve discussed these database best practices, it’s time to tie it
    all together with a Compose file to deploy a WordPress website. WordPress requires
    a MySQL database, so in the Compose file, we’re deploying two services: `wordpress01`
    (WordPress content management system) and `wordpress01-db` (MySQL database).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了这些数据库最佳实践，是时候将它们与 Compose 文件结合起来，部署一个 WordPress 网站了。WordPress 需要一个
    MySQL 数据库，因此在 Compose 文件中，我们部署了两个服务：`wordpress01`（WordPress 内容管理系统）和 `wordpress01-db`（MySQL
    数据库）。
- en: '![Figure 11.8 – Visual topology of an application and its database](img/B18349_11_008.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – 应用程序及其数据库的可视化拓扑](img/B18349_11_008.jpg)'
- en: Figure 11.8 – Visual topology of an application and its database
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 应用程序及其数据库的可视化拓扑
- en: 'In the `wordpress01` service, we can easily reference the database host by
    the name label assigned to the service of the database – this is all thanks to
    the awesome name resolution capabilities supported by Podman `dns` plugins. You’ll
    also see that we are leveraging a health check on the `wordpress01-db` service
    so that it doesn’t become healthy until `mysqladmin` is able to get a response
    from pinging the database service, and `wordpress01` is configured with `depends_on`
    so that it will not try to start until `wordpress01-db` is in a healthy state.
    Since this example is intended to be a quick proof-of-concept deployment, I chose
    to use a named volume rather than a bind mount for the data, but you can also
    see the use of a bind mount for the initialization scripts. Last but not least,
    notice that we’re using a dedicated database container (`wordpress01-db`) that
    is complementary to the application container (`wordpress01`). The contents of
    the Compose file for this WordPress website might look something like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `wordpress01` 服务中，我们可以轻松地通过数据库服务的名称标签引用数据库主机——这一切都要归功于 Podman `dns` 插件所支持的出色名称解析功能。你还会看到，我们在
    `wordpress01-db` 服务上使用了健康检查，确保在 `mysqladmin` 能从数据库服务获取响应之前，`wordpress01-db` 不会被标记为健康状态，同时
    `wordpress01` 配置了 `depends_on`，这样它不会在 `wordpress01-db` 处于健康状态之前启动。由于这个示例旨在快速验证概念部署，我选择使用了一个命名卷而非绑定挂载来存储数据，但你也可以看到我们使用了绑定挂载来存储初始化脚本。最后，注意我们使用了一个专用的数据库容器（`wordpress01-db`），它与应用容器（`wordpress01`）互为补充。这个
    WordPress 网站的 Compose 文件内容可能如下所示：
- en: '![Figure 11.9 – Compose file for WordPress](img/B18349_11_009.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9 – WordPress 的 Compose 文件](img/B18349_11_009.jpg)'
- en: Figure 11.9 – Compose file for WordPress
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – WordPress 的 Compose 文件
- en: 'Go ahead and try to deploy this setup for yourself. You can view the logs of
    the application with `podman logs -f wordpress01` to see that it connects to the
    database successfully on the first attempt. Let’s use Docker Compose to create
    and start the containers. You can do that just as we described in the earlier
    recipe on Docker Compose, by navigating to the directory where your `docker-compose.yml`
    file lives and running the following command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请尝试自行部署这个设置。你可以使用 `podman logs -f wordpress01` 查看应用程序的日志，确保它在第一次尝试时成功连接到数据库。接下来，让我们使用
    Docker Compose 创建并启动容器。你可以像我们之前在 Docker Compose 配方中描述的那样，通过进入存放 `docker-compose.yml`
    文件的目录并运行以下命令来完成：
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Buildah and Skopeo – Podman’s friends with benefits
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Buildah 和 Skopeo – Podman 的得力伙伴
- en: The title of this chapter mentions *Podman and Friends*. Well, up until this
    point, you have probably noticed we didn’t talk much about Podman’s friends. Podman
    brings along a couple of companions to facilitate all your container management
    needs. These buddies of Podman are otherwise known as Buildah and Skopeo.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 本章标题提到了 *Podman 和它的朋友们*。直到此时，你可能已经注意到我们并没有太多讨论 Podman 的朋友们。Podman 带来了几个伙伴，帮助你处理所有容器管理需求。这些
    Podman 的伙伴分别是 Buildah 和 Skopeo。
- en: Where Podman is primarily focused on running containers, Buildah focuses on
    building them, and Skopeo focuses on handling images and transferring them to/from
    remote container registries.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 主要专注于运行容器，而 Buildah 专注于构建容器，Skopeo 专注于处理镜像并将其传输到远程容器注册表或从远程注册表传输镜像。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will require the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要以下内容：
- en: Oracle Linux
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle Linux
- en: Podman
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman
- en: Buildah
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buildah
- en: Skopeo
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Skopeo
- en: How to do it…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: In this recipe, we’ll explore the basic usage of Buildah and Skopeo to reveal
    how these two friends of Podman can enhance your experience and workflow when
    dealing with containers.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将探索 Buildah 和 Skopeo 的基本用法，展示这两款 Podman 的好伙伴如何提升你在处理容器时的体验和工作流。
- en: Building container images with Buildah
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Buildah 构建容器镜像
- en: While Podman can be used for basic container image builds, Buildah is a utility
    that is fully focused on building OCI-compliant images. Not only can Buildah be
    used to build images from a Containerfile or Dockerfile, but it can also very
    neatly change existing container images.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Podman 可以用于基本的容器镜像构建，但 Buildah 是一款专注于构建符合 OCI 标准的镜像的工具。Buildah 不仅可以用来从 Containerfile
    或 Dockerfile 构建镜像，还能非常简洁地修改现有的容器镜像。
- en: 'First things first, let’s see how Buildah can be used to build images from
    a Containerfile. With Podman, we build images using the `podman build -t <image_name>.`
    command. When we call on Podman to perform a build, it is actually using a subset
    of Buildah’s functionality to build the image. To use Buildah directly, we only
    need to use a slightly different command. For example, let’s say we have a file
    named `Containerfile` with the following content:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，先了解一下如何使用Buildah从Containerfile构建镜像。使用Podman时，我们通过`podman build -t <image_name>.`命令来构建镜像。当我们调用Podman执行构建时，它实际上是使用Buildah的一部分功能来构建镜像。要直接使用Buildah，我们只需使用稍微不同的命令。例如，假设我们有一个名为`Containerfile`的文件，其内容如下：
- en: '[PRE47]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In order to build it with Buildah. You’ll enter `buildah bud -t <image_name>`.
    In this example, I’m going to name the image `ol-repo-sync`. Let’s do this now:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Buildah构建镜像，你需要输入`buildah bud -t <image_name>`。在这个示例中，我将镜像命名为`ol-repo-sync`。现在开始吧：
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The results in this scenario are the same as if you were to do this with Podman.
    Where Buildah really shines, is its ability to make changes to working containers,
    and it can also create new images from working containers.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果与使用Podman构建镜像是相同的。Buildah真正的优势在于它能够对工作容器进行修改，并且还可以从工作容器创建新镜像。
- en: 'In order to keep things simple for this recipe, we’re going to replicate what
    was specified in `Containerfile`, except instead of using `Containerfile` directly,
    we’re going to do things ad hoc with Buildah. So let’s make some changes to a
    pre-existing Oracle Linux 8 image and store it as a new image. First, we’re going
    to run `buildah from` to load up a working container in Buildah:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化本教程，我们将复制`Containerfile`中指定的内容，除了不直接使用`Containerfile`，而是通过Buildah按需进行操作。因此，我们将对一个现有的Oracle
    Linux 8镜像进行更改，并将其存储为一个新镜像。首先，我们将运行`buildah from`来加载一个工作容器到Buildah：
- en: '[PRE49]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'That’s going to return the following output:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE50]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This tells us the name of the newly created working container. Now that we
    have a Buildah container ready to work with, let’s add some packages to it. In
    this example, we’re going to add the same packages that `Containerfile` specified
    earlier. Enter the following commands:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们新创建的工作容器的名称。现在我们已经有了一个准备好的Buildah容器，接下来让我们给它添加一些包。在这个示例中，我们将添加之前`Containerfile`中指定的相同包。请输入以下命令：
- en: '[PRE51]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You will see the DNF package manager do its thing, and afterward, you will be
    left with an Oracle Linux base image plus the new packages we installed as a result
    of the `buildah` `run` command.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到DNF包管理器的工作过程，完成后，你将得到一个基于Oracle Linux的基础镜像，以及我们通过`buildah`的`run`命令安装的新软件包。
- en: 'Finally, we need to define the `entrypoint` into this container. We can do
    this by leveraging the `buildah` `config` command:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义该容器的`entrypoint`。我们可以通过使用`buildah`的`config`命令来实现：
- en: '[PRE52]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, there appears to be a bug in Buildah that populates
    the `cmd` value unless we explicitly give it an empty value first. This can lead
    to unexpected behavior of the resulting image. According to the documentation
    for Buildah, setting `entrypoint` without defining a value for `cmd` should clear
    out any assigned value for `cmd`, but that was not the case in my testing of Buildah
    version `1.29.1`. To circumvent this, I found it best to explicitly set `cmd`
    to an empty value before defining the entry point for the image.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Buildah似乎存在一个bug，会填充`cmd`值，除非我们显式地先给它一个空值。这可能导致生成镜像的行为异常。根据Buildah的文档，设置`entrypoint`而不为`cmd`定义值应该会清除`cmd`中已分配的任何值，但在我测试Buildah版本`1.29.1`时并非如此。为了解决这个问题，我发现最好在定义镜像的入口点之前，先显式地将`cmd`设置为空值。
- en: 'In order to create a new image from this working container, all we need to
    do is run the `buildah commit` command. In this example, we’re going to name it
    `ol-repo-sync-buildah` so we can compare it with the image built from the aforementioned
    `Containerfile`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从这个工作容器创建新镜像，我们需要做的就是运行`buildah commit`命令。在这个示例中，我们将镜像命名为`ol-repo-sync-buildah`，以便与之前提到的`Containerfile`构建的镜像进行比较：
- en: '[PRE53]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now that we’ve created the image using Buildah, we can run `podman inspect`
    against both `ol-repo-sync` and `ol-repo-sync-buildah` and we’ll see that the
    two are more or less identical. Also, take note of the size of the two images.
    We can check that by using the `buildah` `images` command:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经使用Buildah创建了镜像，我们可以分别对`ol-repo-sync`和`ol-repo-sync-buildah`运行`podman
    inspect`，并看到这两个镜像几乎是一样的。还要注意两个镜像的大小。我们可以通过使用`buildah`的`images`命令来检查：
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output will look something like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 11.10 – Listing of Buildah images](img/B18349_11_010.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – Buildah 镜像列表示例](img/B18349_11_010.jpg)'
- en: Figure 11.10 – Listing of Buildah images
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – Buildah 镜像列表示例
- en: This time around, we can see that the size is a bit smaller because we leveraged
    the DNF package manager from the host system to install packages in the container
    via the `buildah mount` command. This is obviously not a huge difference in size,
    but it begins to show the benefits that Buildah brings to the table with containers.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们可以看到镜像大小稍微小了一些，因为我们利用了主机系统中的 DNF 包管理器，通过 `buildah mount` 命令将软件包安装到容器中。显然，大小的差异不大，但这开始显示出
    Buildah 在容器管理中带来的好处。
- en: As you can see, Buildah grants us fine-tuned control of our container images
    and it can be a very powerful ally because it allows us to temporarily mount files
    and packages from the host system in the container to perform actions without
    ever actually installing said files and packages in the container. Ultimately,
    you’re able to achieve a leaner container image. Furthermore, Buildah provides
    the ability to script out your container image builds as it’s all done from the
    command line. This can prove to be very powerful when combined with things such
    as automation and/or CI/CD pipelines. It may take some time to get the hang of
    building your container images with Buildah, but the results can be rewarding
    if you stick with it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Buildah 使我们能够对容器镜像进行精细化控制，它可以成为一个非常强大的助手，因为它允许我们从主机系统临时挂载文件和软件包到容器中，从而执行操作，而无需实际将这些文件和软件包安装到容器中。最终，你能够实现更精简的容器镜像。此外，Buildah
    还提供了通过命令行脚本化构建容器镜像的能力。当与自动化和/或 CI/CD 流水线结合使用时，这非常强大。可能需要一些时间来掌握如何使用 Buildah 构建容器镜像，但如果你坚持下去，结果可能会很有价值。
- en: Inspecting remote images using Skopeo
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Skopeo 检查远程镜像
- en: Do you remember when we talked about the need to pull an image before you can
    inspect it? This was covered in the *Creating handy-dandy utility containers*
    recipe. Well, what if I told you that we can leverage Skopeo to inspect images
    that are in remote repositories without needing to first pull them to our local
    machine? That is exactly what we’re going to do here.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们讨论过在检查镜像之前需要先拉取镜像吗？这一点在 *创建实用容器* 配方中有讲到。那么，如果我告诉你，我们可以利用 Skopeo 检查那些存在于远程仓库中的镜像，而不需要先将它们拉取到本地机器上呢？这正是我们在这里要做的事情。
- en: 'In the *Creating handy-dandy utility containers* recipe, you were instructed
    to run the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *创建实用容器* 配方中，你被要求运行以下命令：
- en: '[PRE55]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'That’s because if you tried to run `podman image inspect` without first pulling
    the container to your local machine, you would see the following error:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为如果你尝试在没有先将容器拉取到本地机器的情况下运行`podman image inspect`，你将看到以下错误：
- en: '`Error: inspecting object: pandoc/core: image not known`Skopeo allows us to
    work directly with container images living in remote repositories. To illustrate
    how this works, let’s first get rid of our local `pandoc/core` container image:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`错误：检查对象：pandoc/core: 镜像未知` Skopeo 允许我们直接处理存在于远程仓库中的容器镜像。为了说明这一点，让我们首先删除本地的
    `pandoc/core` 容器镜像：'
- en: '[PRE56]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now that the image is removed from our local machine, let’s use Skopeo to inspect
    the image directly from its remote repository:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在镜像已经从本地机器中删除，让我们使用 Skopeo 直接从其远程仓库检查该镜像：
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Pretty nifty, right? I did notice there were some minor changes to the JSON
    paths that affected how I needed to structure my `jq` command to properly extract
    the entry point I was looking for, but all in all, leveraging Skopeo to inspect
    remote images yields the same information that you would get if you first pulled
    it in with Podman. I can definitely see advantages to using Skopeo, especially
    when working with larger images and/or when needing to inspect images in an automated
    CICD pipeline.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷吧？我注意到 JSON 路径有一些小的变化，这影响了我如何构建 `jq` 命令来正确提取我想要的入口点，但总的来说，利用 Skopeo 检查远程镜像提供的信息与通过
    Podman 首先拉取镜像后检查得到的信息相同。尤其是在处理较大的镜像和/或需要在自动化 CI/CD 流水线中检查镜像时，我确实看到了使用 Skopeo 的优势。
- en: Handling remote images with Skopeo
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Skopeo 处理远程镜像
- en: 'Skopeo can also be used to transfer container images from one remote container
    repository to another, without needing to pull/download it locally first. The
    syntax is similar to the standard Linux `cp` command. In `cp`, we use `cp <source>
    <destination>`, and with Skopeo we use `skopeo copy <source> <destination>`. As
    an example, if we want to copy the `pandoc/core` image from one registry to another,
    all we need to do is run this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Skopeo 还可以用于将容器镜像从一个远程容器仓库转移到另一个仓库，而无需先将其拉取/下载到本地。语法类似于标准的 Linux `cp` 命令。在 `cp`
    中，我们使用 `cp <source> <destination>`，而在 Skopeo 中，我们使用 `skopeo copy <source> <destination>`。举个例子，如果我们想要将
    `pandoc/core` 镜像从一个注册表复制到另一个注册表，只需运行以下命令：
- en: '[PRE58]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Likewise, we can also transfer it to our local Podman container storage through
    the use of the `containers-storage` prefix, for example:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们还可以通过使用 `containers-storage` 前缀将镜像转移到本地的 Podman 容器存储中，例如：
- en: '[PRE59]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Additionally, if we wanted to specify some other location, we could simply
    use the `dir` prefix followed by the path. But in this case, be sure the path
    exists prior and omit any characters that are incompatible with the Linux filesystem,
    for example:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想指定其他位置，可以简单地使用 `dir` 前缀，后跟路径。但在这种情况下，请确保路径已经存在，并省略任何与 Linux 文件系统不兼容的字符，例如：
- en: '[PRE60]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Lastly, Skopeo can also be used to delete images from remote repositories or
    from local container storage. To do this, simply run the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Skopeo 还可以用于从远程仓库或本地容器存储中删除镜像。只需运行以下命令：
- en: '[PRE61]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
