- en: '21'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging Shell Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve ever written a beautiful looking script, only to be disappointed when
    it doesn’t work properly, don’t feel alone. This happens to all of us, and even
    happened to me a few times when I was creating scripts for this book. (I know,
    shocking, right?)
  prefs: []
  type: TYPE_NORMAL
- en: The debugging process should begin the moment that you begin to design your
    code. Put careful thought into the design, test each portion as you write it,
    and—for goodness’ sake—use a text editor with color-coded syntax highlighting.
    (That color highlighting will prevent you from making a multitude of typographical
    errors.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics in the chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding common scripting errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not Enough Quoting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Wild Loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using shell script debugging tools and techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `echo` Statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `xtrace` for Debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for Undefined Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for Errors with the `-e` Option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `bash` Debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging a script with bashdb
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting help with bashdb
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re ready, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, I’m mainly just using the Fedora workstation that I’m using
    to create this Word file. But, you can use whichever Linux virtual machine that
    you like, as long as it has a desktop environment installed. (One of the demos
    requires a desktop.)
  prefs: []
  type: TYPE_NORMAL
- en: For the final topic, I’ll show you how to install and use `bashdb` on Debian/Ubuntu,
    Fedora, FreeBSD, and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, you can grab the scripts by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Understanding Common Scripting Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important step in debugging is understanding the common errors that
    could cause your scripts to either outright fail, or to give you incorrect results.
    Let’s look at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Not Enough Quoting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can have a few different problems if you don’t surround variable names with
    quotes. Here are some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Filenames with Blank Spaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this demo, I’ve moved into an empty directory in order to keep the files
    I’ll be creating separate from the files in my main home directory. I want to
    create some files with a timestamp in the filename. To do that, I’ll use the `date`
    command, without any option switches.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I’ll create a file from the command-line using `touch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, let’s look at the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Whoa, now. What’s going on here? Instead of having one file, I have seven.
    Each file has a portion of the current date in its filename. Well, the problem
    is that `date`, without any option switches, produces output with blank spaces
    in it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So when the shell saw those blank spaces, it thought that I wanted to create
    multiple files, instead of just one. Let’s delete all of these files, and try
    this again with some quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You see how I’ve surrounded the command substitution construct with a pair of
    double quotes, which causes the shell to ignore the blank spaces. So now, I have
    just one file with the correct filename.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with Unset Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our next scenario, let’s look at the `quote_problem1.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'All it does is to tell us whether or not the value of `number` is 1\. Running
    the script looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, it works fine. Now, I’ll edit the file to change the value of `number`
    to 2, and run the script again. Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try that with an unset variable, as you see in `quote_problem2.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When we say that a variable is unset, it just means that we defined the variable,
    but haven’t assigned a value to it. Let’s see what happens with I try to run this
    script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that the `if [ $number = 1 ]` test is looking for some sort
    of value for the number variable. But, `number` has no value, which breaks the
    test. Fortunately, it’s an easy fix. All I’ll have to do is to surround the `$number`
    that’s in the test statement with a pair of double quotes, as you see in `quote_problem3.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this script will show the correct results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This works because instead of having no value at all as we had before, `number`
    now effectively has the value of a blank space. A blank space isn’t equal to 1,
    so the script works.
  prefs: []
  type: TYPE_NORMAL
- en: It’s normally better to always assign an initial value to your variables as
    you create them, in order to prevent these kinds of problems. However, it’s sometimes
    desirable to use an unset variable. For example, you might want your script to
    do one thing if a variable is unset, or to do something else if the variable is
    set with a value. That’s perfectly fine as long as you know how to use quotes
    to avoid these kinds of parsing problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this a bit more realistic, let’s make `quote_problem4.sh` so that it
    will accept a user-defined value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see how it works with different values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It works fine with either 1 or 5 as a value, but doesn’t work when I don’t
    supply a value. So, it appears that I forgot to quote the `$number`. Not to worry,
    I’ll fix that in `quote_problem5.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what we have now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It works like a champ, which means that once again, we’ve achieved coolness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ve been working with tests, let’s see what happens when we leave out
    a space, as I did in `space_problem1.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s the same as the `quote_problem5.sh` script, except that I deleted the
    space between the `[` and the `"$number"`. Here’s what happens when I run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Amazingly enough, it gives me the exact same error message as when I forgot
    to quote my `$number` variable. So, this shows us two things. First, you need
    to be careful about placing spaces in your test conditions. Secondly, you can’t
    always depend upon the shell’s error message to tell you exactly what the problem
    is. In this case, the exact same message showed up for two completely different
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait! Here’s one more way to troubleshoot this problem. We’ll just use
    the `-u` shell option to check for uninitialized variables, as you see here in
    the `quote_problem6.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference between this script and the previous one is that I added
    `-u` to the end of the shebang line. Let’s see what happens when I run it without
    supplying a value for `$1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is cool, because it tells us exactly what the problem is, instead of just
    showing us a generic error message. If you need to see a more verbose message,
    just add the `v` option, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the script now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When you’re finished debugging, be sure to delete the `-u` or `-uv` That’s because
    it could cause problems in production scripts.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll show you more about using the `-u` option in just a few pages, in the *Using
    Shell Script Debugging Tools* section.
  prefs: []
  type: TYPE_NORMAL
- en: For the next problem, you’ll need to buckle your seat belt. That’s because things
    are going to get wild.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Wild Loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you create some sort of loop, it’s real easy to accidentally create one
    that will run forever until you stop it. For example, let’s look at the `wild_loop1.sh`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This loop begins with a `count` value of 30, which will increment by 1 on each
    iteration of the loop. It’s supposed to go until `count` reaches a value of 25\.
    Okay, I know that the problem is blatantly obvious this time, but bear with me
    anyway. This could happen if a coder got in a hurry and just didn’t notice it.
    Anyway, trying to run this will output a list of numbers that just keeps on going
    and going. No matter how fast you hit *Ctrl-c*, the output will scroll past the
    top of your terminal, so that you’ll never get to see the top part of the output.
    So, I’ll fix that by directing the output into a text file. First though, I’ll
    open a second terminal window, and create a blank text file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, while still in that window, I’ll open the file with `tail -f`, in order
    to see the file as it gets updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ll now go back to my first terminal window, and run the `wild_loop1.sh` script,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'I hit *Cntrl-c* after only a few seconds. But, as you see in the second window,
    the count really went wild:'
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_21_1](img/B21693_21_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.1: The wild loop is going wild!'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `wild_loop.txt` file in `less`, and you’ll see that the script really
    does have the output begin at 30.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As I said before, the problem here is obvious. It’s just that I accidentally
    reversed the values of `count` and `limit`. So, let’s fix that in `wild_loop2.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, `count` is set to 25 and `limit` is set to 30\. Running this script
    should work better. Let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Oh yeah, that looks much better.
  prefs: []
  type: TYPE_NORMAL
- en: There are a whole lot more shell scripting pitfalls that I could share with
    you. But, in the interest of not trying to reinvent the proverbial wheel, I’ll
    end this here and instead share a few excellent resources that you might find
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filenames and Pathnames in Shell: How to do it Correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dwheeler.com/essays/filenames-in-shell.html](https://dwheeler.com/essays/filenames-in-shell.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Common Shell Script Mistakes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.pixelbeat.org/programming/shell_script_mistakes.html](https://www.pixelbeat.org/programming/shell_script_mistakes.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'BashPitfalls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://mywiki.wooledge.org/BashPitfalls](http://mywiki.wooledge.org/BashPitfalls)'
  prefs: []
  type: TYPE_NORMAL
- en: All right, let’s move on to the debugging tools.
  prefs: []
  type: TYPE_NORMAL
- en: Using Shell Script Debugging Tools and Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few different debugging tools that we can use, which include `shellcheck`,
    `checkbashisms`, and `shall`. We’ve already looked at them in *Chapter 19—Shell
    Script Portability*, so we won’t look at them again here. Instead, I’ll present
    some tools and techniques that we haven’t covered yet.
  prefs: []
  type: TYPE_NORMAL
- en: Using echo Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, if you have a problem with a shell script that you can’t figure out,
    placing `echo` statements in strategic locations can help you find the problem.
  prefs: []
  type: TYPE_NORMAL
- en: You may see in other references that some people think of `echo` statements
    as the poor man’s debugging tool. That’s because `echo` is always available, and
    can be used if you can’t use anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Back in *Chapter 16, Creating User Interfaces with yad, dialog, and xdialog*,
    I showed you the `xdialog-hello2.sh` script, which can automatically detect two
    things.
  prefs: []
  type: TYPE_NORMAL
- en: It can detect whether or not the `Xdialog` utility is present.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can also detect if your machine has a desktop environment installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If both a desktop environment and the `Xdialog` utility are detected, the script
    will run the graphical `Xdialog` utility. Otherwise, the script will run the ncurses-based
    `dialog` utility. Here’s what the script looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As a reminder, the `DISPLAY` environmental variable will have a non-zero length
    assigned value if a desktop environment is installed, and won’t have an assigned
    value if no desktop environment is installed. The `-n` in the `[[ -n $DISPLAY
    ]]` statement tests for the presence of a non-zero length assigned value. (The
    `-n` actually stands for *non-zero*.) So, if the `[[ -n $DISPLAY ]]` test returns
    a value of 0, which means that the condition is *true*, then a desktop environment
    has been detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Originally though, the script looked like this, as you see in the `xdialog-hello2-broken.sh`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you see, the only difference is that the test conditions in the two scripts
    are in a different order. The script that works has the `[[ $? == 0 ]]` test first,
    and the broken script has the `[[ -n $DISPLAY ]]` condition first.
  prefs: []
  type: TYPE_NORMAL
- en: When I tried running the original script, which had `[[ -n $DISPLAY ]]` first,
    it just wouldn’t work. I mean, it would work fine on desktop machines that had
    `Xdialog` installed or machines that were running in text mode. But, on desktop
    machines that didn’t have `Xdialog` installed, it would always tell me that it
    is installed. And of course, running the script would always fail because it was
    trying to run `Xdialog`. I couldn’t understand the reason for this, so I had to
    do some troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve never installed `Xdialog` on my Fedora workstation, so I can use it to
    show you my troubleshooting steps. When you try this demo, be sure to try it on
    a desktop-type virtual machine that also does not have `Xdialog` installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start troubleshooting by placing an `echo $?` command and a `sleep
    10` command just under the `command -v Xdialog` line. The script now looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: I wanted to see if the exit code would be 0 or 1, and the `sleep 10` command
    would pause the script long enough so that I could see the `echo $?` output.
  prefs: []
  type: TYPE_NORMAL
- en: I inserted the `sleep 10` command to give myself ten seconds to see the output
    of the `echo $?` command. Otherwise, the `clear` command at the end would clear
    away the output before I could see it. If you prefer, you can omit the `sleep
    10` command, and instead just comment out the `clear` command. Either way works,
    so the choice is yours.
  prefs: []
  type: TYPE_NORMAL
- en: 'A 1 would mean that `Xdialog` is not installed, and a 0 would mean that it
    is installed. Placing the `echo` and `sleep` commands under the `command -v Xdialog`
    command would show me if the script was properly detecting if the package was
    installed. Running the script now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The 1 exit code means that the script properly detects that `Xdialog` is not
    present. So, that portion of the script works. Next, you can comment out the whole
    `if. . then. .else` stanza, and place an `[[ -n $DISPLAY ]] && echo $?` statement
    and a `sleep 10` statement just above it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the script with this modification looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The 0 exit code indicates a true condition, which means that a desktop environment
    is indeed installed. So, that part of the code also works properly.
  prefs: []
  type: TYPE_NORMAL
- en: At this point we need to start thinking logically. If the `[[ -n $DISPLAY ]]`
    returns a 0 exit code, how would that affect the `[[ $? == 0 ]]` part? Well, it
    turns out that the `$?` in the second test condition was looking at the 0 exit
    code that was returned by the first test condition, instead of the exit code from
    the `command -v Xdialog` command. So on a desktop machine, the `$?` would always
    be looking at a 0 exit code, whether or not `Xdialog` was present. Fixing that
    was just a simple matter of swapping the order of the two test conditions, as
    you see above in the `xdialog-hello2.sh` script.
  prefs: []
  type: TYPE_NORMAL
- en: In hindsight, the solution to this problem should have been obvious. But for
    some reason I was having a mental block that prevented me from seeing that. It
    just goes to show that even the best of us can sometimes be buffaloed by simple
    scripting errors.
  prefs: []
  type: TYPE_NORMAL
- en: All right, let’s move on to the next debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: Using xtrace for Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using **xtrace** with your problematic scripts shows the actual execution of
    the commands in the scripts, along with their output. This can help you track
    down the source of your problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `xtrace` mode in three different ways, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: Append `-x` to the shebang line. This works for all shells that we’ve been working
    with. For example, if you’re writing a `bash` script, then the shebang line will
    be `#!/bin/bash -x`. If you’re creating a script where portability matters, you
    can use `#!/bin/sh -x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Place a `set -x` command into the script where you want to turn on debugging
    mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the `set -x` command from the command-line before you invoke a script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To demo this, let’s look at the `xdialog-hello2-broken2.sh` script, which has
    the same problem as the `xdialog-hello2-broken.sh` script that you saw in the
    previous section..
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, I placed a `-x` at the end of the shebang line, and then placed a `sleep
    10` line after the `diag=Xdialog` line and the `diag=dialog` line. Now, let’s
    run it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You can immediately see how this is even more useful than using `echo` commands.
    The `[[ -n :0 ]]` line is the expansion of the `[[ -n $DISPLAY ]]` test. It shows
    that the `DISPLAY` variable does indeed have an assigned value (`:0`), which means
    that a desktop environment is installed. But, the real key here is the `[[ 0 ==
    0 ]]` line, which is the expansion of the `[[ $? == 0 ]]` test. Invoking `Xdialog`
    from this script requires that `$?` equals 0, which would require that *both*
    of our test conditions return a 0\.
  prefs: []
  type: TYPE_NORMAL
- en: This in turn requires that both `Xdialog` and a desktop environment are present.
    But, even though `Xdialog` is not installed on this machine, this script erroneously
    shows that it is, as you see in the `diag=Xdialog` line. So again, the only obvious
    answer is to swap the test conditions, as we did before, and test it again. After
    you do that, the `[[ $? == 0 ]]` will expand to `[[ 1 == 0 ]]`, which is what
    we want to see in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using `#!/usr/bin/env bash` as your shebang line, than appending
    `-x` to the end of the shebang line won’t work. That’s because `env` only recognizes
    one option at a time, which in this case is `bash`. So instead, you’ll need to
    either use `set -x` from the command-line before you run the script, or place
    a `set -x` command inside the script, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you use `set -x` on the command-line, you can turn debug mode back off by
    doing `set +x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `-x` alone doesn’t show you enough information, you can enable verbose mode
    by adding the `v` option, as you see in `xdialog-hello2-broken4.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In addition to what we saw before, we now see the entire script echoed back
    at us. We also see that the value of the `diag` variable is `Xdialog`. Since `Xdialog`
    isn’t installed on this machine, the `diag` value should be `dialog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need a permanent record of your debugging for further study, you can
    redirect the `-x` output into a text file. The `-x` output is considered as `stderr`
    output, so you’ll redirect it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When you’re through debugging, be sure to remove the `-x` or set `-x` options
    from your script before you put it into production.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let’s move on to our next trick.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for Undefined Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I said at the beginning of this chapter, in the *Understanding Common Scripting
    Errors* section, it’s sometimes desirable to define a variable in a script without
    assigning an initial value to it. But, sometimes it isn’t. You can track down
    uninitialized variables by appending a `-u` to the end of your shebang line. In
    `bash` for example, you can use `#!/bin/bash -u`, which will turn this feature
    on for the entire script. Or, you can place a `set -u` command any place in the
    script where you’d like to start checking. For example, let’s look at the `unassigned_var1.sh`
    script, which has variable checking turned off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, without the `-u` setting, the script runs to completion. It’s just
    that trying to echo the value of the uninitialized `myvar` just shows us a blank
    space. Next, let’s turn on variable checking by adding the `-u` option, as you
    see in the `unassigned_var2.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what this does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This time the script failed as soon as it saw the uninitialized variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set the `-u` option anywhere in the script you like, by using `set
    -u`, as you see here in the `unassigned_var3.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, I have one uninitialized variable at the top, on line 2\. (Let’s just
    say that for whatever reason, I want this particular variable to be uninitialized.)
    I then turn on variable checking on line 5\. Let’s see how this runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Before I turn on variable checking, the uninitialized `myvar` just shows us
    a blank space. After I turn on variable checking, I initialized `myvar` with a
    value of `Donnie`, and it prints out normally. But, the uninitialized `myvar2`
    at the end crashes the script.
  prefs: []
  type: TYPE_NORMAL
- en: If you search the web for shell scripting security tutorials, you’ll find several
    that tell you to make either `-u` or `set -u` a permanent part of your scripts.
    The authors of these tutorials say that it enhances the security of your scripts,
    without giving any convincing explanation of why or how. Using `-u` or `set -u`
    is great for debugging, but it should only be used for just that—debugging! So,
    when you’re through debugging your scripts, be sure to remove the `-u` or the
    `set -u` before you place the script into production. Otherwise, your scripts
    could give you some rather unpredictable results.
  prefs: []
  type: TYPE_NORMAL
- en: Also, be aware that using `-u` can also help you detect typos in your scripts.
    For example, if you define a variable as `mynum=1`, but accidentally call back
    the value with `$mymum`, the `-u` will detect that `mymum` is an unset variable.
  prefs: []
  type: TYPE_NORMAL
- en: That about does it for the discussion of uninitialized variables. Let’s move
    on to our next trick.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for Errors with the -e Option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next trick is to use either the `-e` shell option or the `set -e` command
    to test our scripts for errors that cause commands within the script to fail.
    Let’s look at the `bad_dir1.sh` script to see how that works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: With this, I want to create the `mydir` directory, `cd` into it, and then do
    a file listing. But, my typing isn’t up to what it should be today, so in the
    `cd` line I accidentally typed `mydire`, instead of `mydir`. Let’s see what happens
    when I run it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Yeah, this problem is obvious, but that’s okay. That’s because the `-e` option
    does more than just identify the problem. It would cause the script to immediately
    exit if any command fails. Let’s put this option into the `bad_dir2.sh` script
    to see how that works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: All I did here was to insert the `-e` option. Now, I’ll delete the `mydir` directory
    that the first script created, and try running this one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Using `-e` also works when the failing command is part of a compound command
    structure, as you see in `bad_dir3.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, I’ll delete the `mydir` directory that the previous script created,
    and then run `bad_dir3.sh`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: So again, the `-e` stopped this script in its tracks when the `cd` command failed.
  prefs: []
  type: TYPE_NORMAL
- en: I know what you’re thinking, and I know that that’s a bit creepy. You’re thinking
    that the kinds of errors that `-e` would detect are fairly obvious. That’s because
    with these types of errors, the shell will display an error message that pinpoints
    the problem. So then, why do we need `-e`? Well, think of `-e` and `set -e` as
    more of a safety mechanism than a debugging tool. For example, if the next command
    after trying to `cd` into a non-existent directory is to `rm` all files, then
    allowing the script to run after the `cd` command fails could be disastrous.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, I’ve told you the good stuff about `-e` and `set -e`. Now, let me tell
    you some not-so-good stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Problems with set -e and -e
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although `-e` and `set -e` can be helpful, they can also cause you headaches.
    Sometimes, they can actually break a script that worked before. Here’s what I
    mean.
  prefs: []
  type: TYPE_NORMAL
- en: The `set -e` and `-e` settings work by detecting if a command in the script
    returns an exit code of something other than 0.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that an exit code of 0 indicates a successful command execution, and
    a non-0 exit code indicates a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes though, you’ll need for some commands in your script to return a
    non-0 exit code in order for the script to work. This makes the operation of `set
    -e` and `-e` unpredictable, at best. For example, take a look at this `set_e_fails1.sh`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note that `let i++` is a bashism that I haven’t yet shown you. You can replace
    it with `i=$(( i + 1 ))` in order to make the script portable to non-`bash` shells.
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates the `i` variable with a value of 0, increments that value by 1,
    and then prints out the final value of `i`. But, watch what happens with the `-e`
    setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, it prints out nothing. Let’s see what happens if I comment out the `set
    -e` command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Let’s run it again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the script runs perfectly fine without the `set -e`, but inserting the
    `set -e` breaks it. I know, that’s crazy, right? To help us figure out what’s
    going on, let’s create the `set_e_fails2.sh` script, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference is that I omitted the `set -e` line, and inserted `echo`
    statements that display the exit code of each command. Now, to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Exit code after incrementing i: 1` line shows us the problem. It’s just
    that for some truly bizarre reason that I don’t understand, the `let i++` command
    produces an exit code of 1, even though the command is successful. So in this
    case, using `-e` created a problem, instead of solving one. (Curiously though,
    using the portable `i=$(( i + 1 ))` construct will return exit code 0, which will
    prevent this problem. I have no idea why that is.)'
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned in the *Checking for Undefined Variables* section that some articles
    you’ll find on the web recommend making either `-u` or `set -u` a permanent part
    of your scripts, in order to enhance security. These authors actually recommend
    making both the `-e`/`set -e` and `-u`/`set -u` a permanent part of your scripts.
    But, as I’ve just demonstrated, `-e`/`set -e` can be rather unpredictable, and
    could cause you more problems than it solves. At any rate, if you do use this
    tool for troubleshooting, be sure to delete it from your scripts before you place
    them into production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although my personal belief is that `-e` and `set -e` can be useful when used
    with caution, that’s actually a controversial opinion. In the following article,
    you’ll see a lengthy write-up about why you should never, ever use `-e` or `set
    -e`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'BashFAQ105—Greg’s Wiki:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mywiki.wooledge.org/BashFAQ/105](https://mywiki.wooledge.org/BashFAQ/105)'
  prefs: []
  type: TYPE_NORMAL
- en: This author’s belief is that you would be better served by creating your own
    error checks, rather than relying on `-e`/`set -e`.
  prefs: []
  type: TYPE_NORMAL
- en: If you like, give the page a visit, and work through the examples that the author
    provides. The author also provides a link to a page with the counter-argument
    to this, so be sure to check that out as well so that you can decide for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let’s move on to our final debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: Using bash Debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **bash Debugger**, which you’ll normally see referred to as **bashdb**,
    allows you to step through a `bash` script, one command at a time. This allows
    you to see what each command in the script is doing before moving on to the next
    command. It’s pretty simple to use, once you get installed.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find a lot of `bashdb` tutorials on the web, but a lot of them are very
    old, and show you an obsolete method for installing `bashdb`. That’s because years
    ago, `bashdb` was included in the repositories of pretty much every Linux distro.
    So, you could install it with your normal package manager as those tutorials showed.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, for some strange reason, `bashdb` has been removed from most,
    if not all, Linux repositories. So now, if you want to run `bashdb` on Linux,
    you’ll need to compile it from source code as I’m about to show you.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `bashdb` is in the FreeBSD repository and in the Homebrew
    repository for macOS, so you’re all good there.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let’s look at installing `bashdb`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing bashdb on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I mentioned above in the info box, you’ll need to install `bashdb` from source
    code. Don’t fret though, because it’s easy.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. You’ll first need to install the `autoconf` and `texinfo` packages from
    your normal distro repository, using your distro’s normal package manager.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Download the `bashdb` source code by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 3\. `cd` into the `bashdb/` directory that the `git` command created.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run the following set of commands to compile and install `bashdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: That’s all there is to it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing bashdb on FreeBSD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is even easier. Just do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Installing on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On a Mac with Homebrew installed, just do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now that `bashdb` is installed, let’s see if we can actually use it.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a Script with bashdb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with a clean, unmodified copy of the original broken `xdialog`
    script, which I’ll call `xdialog-hello2-broken5.sh`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'As you’ve seen in the *Using xtrace for Debugging* section, the problem is
    that the script won’t properly detect if both `Xdialog` and a desktop display
    are installed. Let’s step through this with `bashdb` to see what it can tell us.
    Begin like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This runs the first command in the script, and then dumps us out at the `bashdb`
    command prompt. To run the next command, just enter `step`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see the `DISPLAY` variable that’s inside the test construct. Let’s
    examine that variable to see what its value is, by using the `examine` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `declare -x` part means that `bashdb` is marking the `DISPLAY` variable
    for export to subsequent commands. But, that’s not the important part. What’s
    important is that the `DISPLAY` variable has a value of `:0`, which means that
    the `[[ -n $DISPLAY ]]` test will return a value of 0 to indicate a true condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using the `examine DISPLAY` command, you can use the `print $DISPLAY`
    command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This way, the only thing that shows up is just the actual `DISPLAY` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we need to put on our thinking caps and ponder what it means
    to have this `DISPLAY` test come before the `$?` test. Well, we’ve already come
    up with that answer when we used the `echo` statement and `xtrace` methods to
    troubleshoot this. It’s just that if we do the `DISPLAY` detection first, the
    `$?` value in the second test will always be 0, even if no `Xdialog` executable
    is detected. But, for the sake of showing you a bit more, let’s say that we haven’t
    figured that out, and need to see more of what the script is doing. To do that,
    enter the series of commands that you see in the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: I started this by issuing two `step` commands, which gets me down to where the
    `diag` variable is defined and what its assigned value is. I then issued the `print
    $diag` command, but nothing showed up. Then, I issued another `step` command,
    followed by another `print $diag` command. At that point, I finally see that the
    `diag` variable has the value of `Xdialog`, even though `Xdialog` isn’t installed
    on this workstation.
  prefs: []
  type: TYPE_NORMAL
- en: The clear advantage of using `bashdb` is that I didn’t have to modify the script
    in order to debug it. As you see, I didn’t have to add any `echo` statements to
    obtain the value of the `DISPLAY` and `diag` variables. I also didn’t have to
    add a `sleep` command or comment out the ending `clear` command in order to prevent
    the screen from clearing before I could see the `DISPLAY` value. Obviously, this
    is a big win for `bashdb`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you might at times need to find extra information about what you
    can do with `bashdb`. Let’s look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Help with bashdb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you install `bashdb`, a man page will get installed with it. Frankly though,
    it doesn’t tell you much. Fortunately, `bashdb` has a built-in help function that
    you can use any time that you’re at the `bashdb` command-prompt. Just enter the
    `help` command, and you’ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21693_21_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.2: The bashdb help display'
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows the list of available `bashdb` commands. To see how to use a particular
    command, just enter `help` followed by the command name, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21693_21_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.3: Getting help for the break command'
  prefs: []
  type: TYPE_NORMAL
- en: That about wraps things up for this chapter. Let’s summarize and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some cool tips and tricks that can help you troubleshoot
    your code. We began by looking at some common shell scripting errors, and showed
    how to find them in a broken script. We then looked at some common debugging tools
    and techniques. For the `-u` and `-e` shell options, I showed you both the pros
    and the cons of using them. Finally, I showed you how to install and use `bashdb`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll take a brief look at scripting with `zsh`. I’ll see
    you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This time, instead of presenting you with questions to answer, I’ll present
    you with some buggy shell scripts. Try running them to observe the errors, and
    then try to debug them. Can you debug them? Sure you can. I have faith in you.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with the `bug1.sh` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the `bug2.sh` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, for `bug3.sh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the fourth and final, `bug4.sh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing Shell Scripts—Lesson 9: Stay Out of Trouble: [http://linuxcommand.org/lc3_wss0090.php](http://linuxcommand.org/lc3_wss0090.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Debug Bash Scripts: [https://linuxconfig.org/how-to-debug-bash-scripts](https://linuxconfig.org/how-to-debug-bash-scripts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '15 Essential Bash Debugging Techniques and Tools: [https://www.fosslinux.com/104144/essential-bash-debugging-techniques-and-tools.htm](https://www.fosslinux.com/104144/essential-bash-debugging-techniques-and-tools.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Debugging a Bash Script: [https://www.baeldung.com/linux/debug-bash-script](https://www.baeldung.com/linux/debug-bash-script)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '5 Simple Steps On How to Debug a Bash Shell Script: [https://www.shell-tips.com/bash/debug-script/#gsc.tab=0](https://www.shell-tips.com/bash/debug-script/#gsc.tab=0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filenames and Pathnames in Shell: How to do it Correctly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://dwheeler.com/essays/filenames-in-shell.html](https://dwheeler.com/essays/filenames-in-shell.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Common Shell Script Mistakes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.pixelbeat.org/programming/shell_script_mistakes.html](https://www.pixelbeat.org/programming/shell_script_mistakes.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'BashPitfalls:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://mywiki.wooledge.org/BashPitfalls](http://mywiki.wooledge.org/BashPitfalls
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Debugging your shell scripts with bashdb: [https://www.linux.com/news/debug-your-shell-scripts-bashdb/](https://www.linux.com/news/debug-your-shell-scripts-bashdb/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Debugging bash scripts with the bashdb debugger: [https://dafoster.net/articles/2023/02/22/debugging-bash-scripts-with-the-bashdb-debugger/](https://dafoster.net/articles/2023/02/22/debugging-bash-scripts-with-the-bashdb-debugger/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using BashDB to Debug Your Shell Scripts—YouTube: [https://www.youtube.com/watch?v=jbOQJDSTksA](https://www.youtube.com/watch?v=jbOQJDSTksA)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'BASH Debugger documentation: [https://bashdb.sourceforge.net/bashdb.html](https://bashdb.sourceforge.net/bashdb.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Bash Trap Trap: [https://medium.com/@dirk.avery/the-bash-trap-trap-ce6083f36700](https://medium.com/@dirk.avery/the-bash-trap-trap-ce6083f36700)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `if` statement, you need to insert a blank space between the `[` and
    the `$a`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to place a `done` statement after the `echo $i` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are a couple of problems with this script. First, the regular expression
    is set up wrong, which causes you to get either no or incorrect output from this
    script. Instead of
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[a-z]*.sh`, it should be `[a-z].sh`. (The `*` actually isn’t needed for this.)'
  prefs: []
  type: TYPE_NORMAL
- en: You can review the concept of regular expressions in *Chapter 9—Filtering Text
    with grep, sed, and Regular Expressions*.
  prefs: []
  type: TYPE_NORMAL
- en: There’s also the fact this regular expression isn’t doing much for us. Unless
    you have scripts with filenames that consist of nothing but either digits or upper-case
    characters, this `grep` command is going to show you all of the scripts in your
    directory. So, you could probably just omit the `grep` command altogether, and
    go with a simple `ls *.sh` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in the `echo` statement, you need to surround the variable with a
    pair of double quotes, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This will prevent problems with filenames that have blank spaces in them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This script is supposed to take values from the first and third field of the
    `sample.data` file that the script created, and add them together. The values
    of the first and third fields are 1 and 3, so the sum of the two should be 4\.
    However, here’s how it looks when you run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The problem is that the `cut` command on line 3 is piping its output into the
    `read` command. The problem with that is that the `read` command is built into
    the shell, instead of having its own executable file.
  prefs: []
  type: TYPE_NORMAL
- en: That’s significant, because you can only pipe output of one command into a command
    that has its own executable. So, you can’t pipe output into a command that’s a
    shell builtin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using a pipe, you can instead send the first and third field values
    to the `tmp.data` file, and then use the input redirector to obtain the input
    from the `tmp.data` file, as you see here in the `bug5.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option would be to use a *here* document, as you see in the `bug6.sh`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Either way, you’ll now see the correct results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Join our community on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Linux experts, and the author himself.
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10596186092701843.png)'
  prefs: []
  type: TYPE_IMG
