- en: '19'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging with GDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bugs happen. Identifying and fixing them is part of the development process.
    There are many different techniques for finding and characterizing program defects,
    including static and dynamic analysis, code review, tracing, profiling, and interactive
    debugging. We will look at tracers and profilers in the next chapter, but here
    I want to concentrate on the traditional approach of watching code execution through
    a debugger, which in our case is the **GNU Debugger** (**GDB**). GDB is a powerful
    and flexible tool. You can use it to debug applications, examine the postmortem
    files (core files) that are created after a program crash, and even step through
    kernel code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: GNU debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing to debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just-in-time debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging forks and threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GDB user interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging kernel code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples, make sure you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buildroot 2024.02.6 LTS release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yocto 5.0 (Scarthgap) LTS release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A microSD card reader and card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: balenaEtcher for Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Ethernet cable and router with an available port for network connectivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB to TTL serial cable with a 3.3 V level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Raspberry Pi 4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 5 V USB-C power supply capable of delivering 3 A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should have already installed the 2024.02.6 LTS release of Buildroot for
    [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110). If you have not, then refer
    to the *System requirements section* of *The Buildroot user manual* ([https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html))
    before installing Buildroot on your Linux host according to the instructions from
    [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110).
  prefs: []
  type: TYPE_NORMAL
- en: You should have already built the 5.0 (Scarthgap) LTS release of Yocto in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110). If you have not, then please refer to
    the *Compatible Linux Distribution* and *Build Host Packages* sections of the
    *Yocto Project Quick Build* guide ([https://docs.yoctoproject.org/brief-yoctoprojectqs/](https://docs.yoctoproject.org/brief-yoctoprojectqs/))
    before building Yocto on your Linux host according to the instructions in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter19](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter19).'
  prefs: []
  type: TYPE_NORMAL
- en: GNU debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GDB is a source-level debugger for compiled languages, primarily C and C++,
    although there is also support for a variety of other languages, such as Go and
    Objective-C. You should read the notes for the version of GDB you are using to
    find out the status of support for the various languages.
  prefs: []
  type: TYPE_NORMAL
- en: The project website is [https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)
    and it contains a lot of useful information, including the GDB user manual, *Debugging
    with GDB*.
  prefs: []
  type: TYPE_NORMAL
- en: Out of the box, GDB has a command-line user interface that some people find
    off-putting, although, in reality, it is easy to use with a little practice. If
    command-line interfaces are not to your liking, there are plenty of frontend user
    interfaces to GDB, and I will describe three of them later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing to debug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to compile the code you want to debug with debug symbols. GCC offers
    two options for this: `-g` and `-ggdb`. The latter adds debug information that
    is specific to GDB, whereas the former generates information in an appropriate
    format for whichever target operating system you are using, making it the more
    portable option. Since GDB is the default debugger on Linux, it is best to use
    `-ggdb`. Both options allow you to specify the level of debug information, from
    `0` to `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0`: This produces no debug information at all and is equivalent to omitting
    the `-g` or `-ggdb` switch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: This produces minimal information but includes function names and external
    variables, which is enough to generate a backtrace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: This is the default and includes information about local variables and
    line numbers so that you can perform source-level debugging and single-step through
    the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3`: This includes extra information which, among other things, means that
    GDB can handle macro expansions correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In most cases, `-g` suffices: reserve `-g3` or `-ggdb3` for if you are having
    problems stepping through code, especially if it contains macros.'
  prefs: []
  type: TYPE_NORMAL
- en: The next issue to consider is the level of code optimization. Compiler optimization
    tends to destroy the relationship between lines of source code and machine code,
    which makes stepping through the source unpredictable. If you experience problems
    such as this, you will most likely need to compile without optimization, leaving
    out the `-O` compile switch, or using `-Og`, which enables optimizations that
    do not interfere with debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'A related issue is that of stack-frame pointers, which are required by GDB
    to generate a backtrace of function calls up to the current one. On some architectures,
    GCC will not generate stack-frame pointers with higher levels of optimization
    (`-O2` and above). If you find yourself in a situation where you really have to
    compile with `-O2` but still want backtraces, you can override the default behavior
    with `-fno-omit-frame-pointer`. Also, look out for code that has been hand-optimized
    to leave out frame pointers through the addition of `-fomit-frame-pointer`: you
    may want to temporarily remove those bits.'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use GDB to debug applications in one of two ways: if you are developing
    code to run on desktops and servers, or indeed any environment where you compile
    and run the code on the same machine, it is natural to run GDB natively. However,
    most embedded development is done using a cross toolchain, and hence you want
    to debug code running on the device but control it from the cross-development
    environment, where you have the source code and the tools. I will focus on the
    latter case, since it is the most likely scenario for embedded developers, but
    I will also show you how to set up a system for native debugging. I am not going
    to describe the basics of using GDB here since there are many good references
    on that topic already, including the GDB user manual and the suggested *Further
    study* section at the end of the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Remote debugging using gdbserver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key component for remote debugging is the debug agent, **gdbserver**, which
    runs on the target and controls the execution of the program being debugged. `gdbserver`
    connects to a copy of GDB running on the host machine via a network connection
    or a serial interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging through `gdbserver` is almost, but not quite, the same as debugging
    natively. The differences are mostly centered around the fact that there are two
    computers involved, and they have to be in the right state for debugging to take
    place. Here are some things to look out for:'
  prefs: []
  type: TYPE_NORMAL
- en: At the start of a debug session, you need to load the program you want to debug
    on the target using `gdbserver` and then separately load GDB from your cross toolchain
    on the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GDB and `gdbserver` need to connect to each other before a debug session can
    begin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GDB needs to be told where on the host to look for debug symbols and source
    code, especially for shared libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GDB `run` command is not supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gdbserver` will terminate when the debug session ends, and you will need to
    restart it if you want another debug session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need debug symbols and source code for the binaries you want to debug on
    the host, but not on the target. Often, there is not enough storage space for
    them on the target, and they will need to be stripped before deploying to the
    target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The GDB/`gdbserver` combination does not support all the features of natively
    running GDB: for example, `gdbserver` cannot follow the child process after a
    fork, whereas native GDB can.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Odd things can happen if GDB and `gdbserver` are from different versions of
    GDB or are the same version but configured differently. Ideally, they should be
    built from the same source using your favorite build tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Debug symbols increase the size of executables dramatically, sometimes by a
    factor of 10\. As mentioned in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138),
    it can be useful to remove debug symbols without recompiling everything. The tool
    for the job is `strip` from the `binutils` package in your cross toolchain. You
    can control the strip level with these switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--strip-all`: This removes all symbols (default).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--strip-unneeded`: This removes symbols not required for relocation processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--strip-debug`: This removes only debug symbols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For applications and shared libraries, `--strip-all` (the default) is fine,
    but when it comes to kernel modules, you will find that it will stop the module
    from loading. Use `--strip-unneeded` instead. I am still working on a use case
    for `–-strip-debug`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With that in mind, let’s look at the specifics involved in debugging with The
    Yocto Project and Buildroot.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up The Yocto Project for remote debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two things to be done to debug applications remotely when using The
    Yocto Project: you need to add `gdbserver` to the target image, and you need to
    create an SDK that includes GDB and has debug symbols for the executables that
    you plan to debug. There is detailed documentation on setting up Yocto for remote
    debugging at [https://docs.yoctoproject.org/dev-manual/debugging.html#using-the-gdbserver-method](https://docs.yoctoproject.org/dev-manual/debugging.html#using-the-gdbserver-method).'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to include `gdbserver` in the target image, you can add the package
    explicitly by adding this to `conf/local.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the absence of a serial console, an SSH daemon also needs to be added so
    that you have some way to start `gdbserver` on the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can add `tools-debug` to `EXTRA_IMAGE_FEATURES`, which will
    add `gdbserver`, native `gdb`, and `strace` to the target image (I will talk about
    `strace` in the next chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then rebuild the target image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For the second part, you just need to build an SDK as I described in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The SDK contains a copy of GDB. It also contains a `sysroot` for thetarget with
    debug symbols for all the programs and libraries that are part of the target image.
    Lastly, the SDK contains the source code for the executables. Instead of the SDK,
    you can use the sysroots inside of the Yocto build directly ([https://docs.yoctoproject.org/sdk-manual/extensible.html#when-using-the-extensible-sdk-directly-in-a-yocto-build](https://docs.yoctoproject.org/sdk-manual/extensible.html#when-using-the-extensible-sdk-directly-in-a-yocto-build)).
  prefs: []
  type: TYPE_NORMAL
- en: The SDK built for the Raspberry Pi 4 for version 5.0.<n> of The Yocto Project
    is installed by default in `/opt/poky/5.0.<n>/`. The `sysroot` for the target
    is `/opt/poky/5.0.<n>/sysroots/cortexa72-poky-linux/`. The programs are in `/bin/`,
    `/sbin/`, `/usr/bin/`, and `/usr/sbin/`, relative to the `sysroot`, and the libraries
    are in `/lib/` and `/usr/lib/`. In each of these directories, you will find a
    subdirectory named `.debug/` that contains the symbols for each program and library.
    GDB knows to look in .`debug`/ when searching for symbol information. The source
    code for the executables is stored in `/usr/src/debug/` relative to the `sysroot`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Buildroot for remote debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Buildroot does not make a distinction between the environment used to build
    and the environment used for application development: there is no SDK. Assuming
    that you are using the Buildroot internal toolchain, you need to enable these
    options to copy GDB to the host and copy `gdbserver` to the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BR2_TOOLCHAIN_EXTERNAL`, in **Toolchain** | **Toolchain type** | **External
    toolchain**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BR2_TOOLCHAIN_EXTERNAL_GDB_SERVER_COPY`, in **Toolchain** | **Copy gdb server
    to the Target**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BR2_PACKAGE_GDB`, in **Target packages** | **Debugging, profiling and benchmark**
    | **gdb**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An external toolchain is needed because the toolchain that Buildroot 2024.02.6
    builds cannot compile `gdbserver`.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to build executables with debug symbols, for which you need to
    enable `BR2_ENABLE_DEBUG`, in **Build options** | **build packages with debugging
    symbols**.
  prefs: []
  type: TYPE_NORMAL
- en: This will create libraries with debug symbols in `output/host/<arch>/sysroot`.
  prefs: []
  type: TYPE_NORMAL
- en: Starting to debug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have `gdbserver` installed on the target and a cross GDB on the
    host, you can start a debug session.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting GDB and gdbserver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The connection between GDB and `gdbserver` can be through a network or serial
    interface. In the case of a network connection, you launch `gdbserver` with the
    TCP port number to listen on and, optionally, an IP address to accept connections
    from. In most cases, you don’t care which IP address is going to connect, so you
    can just provide the port number. In this example, `gdbserver` waits for a connection
    on port `10000` from any host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start the copy of GDB from your toolchain, pointing it at an unstripped
    copy of the program so that GDB can load the symbol table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In GDB, use the target remote command to make the connection to `gdbserver`,
    giving it the IP address or hostname of the target and the port it is waiting
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When `gdbserver` sees the connection from the host, it prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The procedure is similar for a serial connection. On the target, you tell `gdbserver`
    which serial port to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You may need to configure the port baud rate beforehand using `stty(1)` or
    a similar program. A simple example would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are many other options to `stty`, so read the manual page for more details.
    It is worthwhile noting that the port must not be used for anything else. For
    example, you can’t use a port that is being used as the system console.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the host, you make the connection to `gdbserver` using `target remote` plus
    the serial device at the host end of the cable. In most cases, you will want to
    set the baud rate of the host serial port first, using the GDB command `set serial
    baud`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Even though GDB and `gdbserver` are now connected, we are not ready to set breakpoints
    and start stepping through the source code yet.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the sysroot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GDB needs to know where to find debug information and source code for the program
    and shared libraries you are debugging. When debugging natively, the paths are
    well known and built into GDB. But when using a cross toolchain, GDB has no way
    to guess where the root of the target filesystem is. You have to provide this
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you built your application using The Yocto Project SDK, the `sysroot` is
    within the SDK, and so you can set it in GDB like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using Buildroot, you will find that the `sysroot` is in `output/host/<toolchain>/sysroot`,
    and that `output/staging` is a symbolic link to it. So, for Buildroot, you would
    set the `sysroot` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'GDB also needs to find the source code for the files you are debugging. GDB
    has a search path for source files, which you can see using the `show directories`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the defaults: `$cwd` is the current working directory of the GDB
    instance running on the host; `$cdir` is the directory where the source was compiled.
    The latter is encoded into the object files with the tag `DW_AT_comp_dir`. You
    can see these tags using `objdump --dwarf` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In most cases, the defaults, `$cdir` and `$cwd`, are sufficient, but problems
    arise if the directories have been moved between compilation and debugging. One
    such case occurs with The Yocto Project. Taking a deeper look at the `DW_AT_comp_dir`
    tags for a program compiled using The Yocto Project SDK, you may notice this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see multiple references to the directory `/usr/src/debug/glibc/2.39+git`,
    but where is it? The answer is that it is in the `sysroot` for the SDK, so the
    full path is `/opt/poky/5.0.6/sysroots/cortexa72-poky-linux/usr/src/debug/glibc/2.39+git`.
    The SDK contains source code for all of the programs and libraries in the target
    image. GDB has a simple way to cope with an entire directory tree being moved
    like this: `substitute-path`. So, when debugging with The Yocto Project SDK, you
    need to use these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You may have additional shared libraries that are stored outside the `sysroot`.
    In that case, you can use `set solib-search-path`, which can contain a colon-separated
    list of directories to search for shared libraries. GDB searches `solib-search-path`
    only if it cannot find the binary in the `sysroot`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A third way of telling GDB where to look for source code, for both libraries
    and programs, is to use the `directory` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Paths added in this way take precedence because they are searched *before* those
    from `sysroot` or `solib-search-path`.
  prefs: []
  type: TYPE_NORMAL
- en: GDB command files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are some things that you need to do each time you run GDB, like setting
    the `sysroot`. It is convenient to put such commands into a command file and run
    them each time GDB is started. GDB reads commands from `$HOME/.gdbinit`, then
    from `.gdbinit` in the current directory, and then from files specified on the
    command line with the `-x` parameter. However, recent versions of GDB will refuse
    to load `.gdbinit` from the current directory for security reasons. You can override
    that behavior by adding a line such as this to `$HOME/.gdbinit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you don’t want to enable auto-loading globally, you can specify
    a particular directory like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: My personal preference is to use the `-x` parameter to point to the command
    file, which exposes the location of the file so that I don’t forget about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you set up GDB, Buildroot creates a GDB command file containing the
    correct `sysroot` command in `output/staging/usr/share/buildroot/gdbinit`. It
    will contain a line like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that GDB is running and can find the information it needs, let’s look at
    some of the commands we can perform with it.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of GDB commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GDB has many more commands, which are described in the online manual and in
    the resources mentioned in the *Further study* section. To help you get going
    as quickly as possible, here is a list of the most commonly used commands. In
    most cases, there is a short form for commands, which are listed in the following
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are the commands for managing breakpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Short-form command** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '| Set a breakpoint on a function name, line number, or line. Examples of locations
    are `main`, `5`, and `sortbug.c:42`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| List breakpoints. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '| Delete the breakpoint `<N>`. |'
  prefs: []
  type: TYPE_TB
- en: Running and stepping
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are commands for controlling the execution of a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Short-form command** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '| Load a fresh copy of the program into memory and start running it. *This
    does not work for remote debugging using gdbserver*. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '| Continue execution from a breakpoint. |'
  prefs: []
  type: TYPE_TB
- en: '| *Ctrl + C* | - | Stop the program from being debugged. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '| Step one line of code, stepping *into* any function that is called. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '| Step one line of code, stepping *over* a function call. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '| - | Run until the current function returns. |'
  prefs: []
  type: TYPE_TB
- en: Getting information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are commands for getting information regarding the debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Short-form command** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '| List the call stack. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '| Display information about the threads executing in the program. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '| Display information about shared libraries currently loaded by the program.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '| Print the value of the variable. For example, `print foo`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '| List lines of code around the current program counter. |'
  prefs: []
  type: TYPE_TB
- en: Before we can begin stepping through a program inside a debug session, we first
    need to set an initial breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Running to a breakpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`gdbserver` loads the program into memory and sets a breakpoint at the first
    instruction. Then it waits for a connection from GDB. When the connection is made,
    you enter into a debug session. However, you will find that if you try to single-step
    immediately, you will get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the program has halted at code written in assembly, which creates
    the runtime environment for C/C++ programs. The first line of C/C++ code is the
    `main()` function. To stop at `main()`, you would set a breakpoint there and then
    use the `continue` command (abbreviation `c`) to tell `gdbserver` to continue
    from the start of the program and stop at `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you may see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'With older versions of GDB, you may instead see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the problem is that you have forgotten to set the `sysroot`!
    Take another look at the earlier section on `sysroot`.
  prefs: []
  type: TYPE_NORMAL
- en: This is all very different from starting a program natively, where you just
    type `run`. In fact, if you try typing `run` in a remote debug session, you will
    either see a message saying that the remote target does not support the `run`
    command, or, in older versions of GDB, it will just hang without any explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Extending GDB with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can embed a full Python interpreter into GDB to extend its functionality.
    This is done by configuring GDB using the `--with-python` option prior to building.
    GDB has an API that exposes much of its internal state as Python objects. This
    API allows us to define our own custom GDB commands as scripts written in Python.
    These extra commands may include useful debugging aids such as tracepoints and
    pretty printers that are not built into GDB.
  prefs: []
  type: TYPE_NORMAL
- en: Building GDB with Python support
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have already covered *Setting up Buildroot for remote debugging*. There are
    some additional steps needed to enable Python support inside GDB. We cannot use
    a toolchain generated by Buildroot to build GDB with Python support because it
    is missing some necessary thread support.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build cross GDB for the host with Python support, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the directory where you installed Buildroot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the configuration file for the board you wish to build an image for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clean previous build artifacts from the `output` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activate your configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Begin customizing your image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enable the use of an external toolchain by navigating to **Toolchain** | **Toolchain
    type** | **External toolchain** and selecting that option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of **External toolchain** and open the **Toolchain** submenu. Select
    a known working toolchain, such as **Linaro AArch64 2018.05**, as your external
    toolchain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Build cross gdb for the host** from the Toolchain page and enable both
    **TUI support** and **Python support**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **GDB debugger Version** submenu from the **Toolchain**
    page and select the newest version of GDB available in Buildroot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **Toolchain** page and drill down into **Build options**. Select
    **Build packages with debugging symbols**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **Build options** page, drill down into **System Configuration**,
    and select **Enable root login with password**. Open **Root password** and enter
    a non-empty password in the text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **System Configuration** page and drill down into **Target packages**
    | **Debugging, profiling and benchmark**. Select the **gdb** package to add `gdbserver`
    to the target image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of **Debugging, profiling and benchmark** and drill down into **Target
    packages** | **Networking applications**. Select the **dropbear** package to enable
    `scp` and `ssh` access to the target. Note that `dropbear` does not allow `root`
    `scp` and `ssh` access without a password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **haveged** entropy daemon, which can be found under **Target packages**
    | **Miscellaneous** so that SSH is available quicker upon booting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another package to your image so you have something to debug. I chose the
    `bsdiff` binary patch/diff tool, which is written in C and can be found under
    **Target packages** | **Development tools**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your changes and exit Buildroot’s `menuconfig`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save your changes to your configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the image for the target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A readymade `rpi4_64_gdb_defconfig` file for the Raspberry Pi 4 can be found
    in the code archive for this chapter if you wish to skip the previous `menuconfig`
    steps. Copy that file from `MELD/Chapter19/buildroot/configs/` to your `buildroot/configs`
    directory and run `make` on that if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: When the build is done, there should be a bootable `sdcard.img` file in `output/images/`
    that you can write to a microSD card using Etcher. Insert that microSD into your
    target device and boot it. Connect the target device to your local network with
    an Ethernet cable and locate its IP address using `arp-scan --localnet`. SSH into
    the device as `root` and enter the password that you set when configuring your
    image. I specified `temppwd` as the `root` password for my `rpi4_64_gdb_defconfig`
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s debug `bsdiff` remotely using GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate to the `/usr/bin` directory on the target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, start `bdiff` with `gdbserver`, as we did with `helloworld` earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On your Linux host, copy `tp.py` to your home directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, start the copy of GDB from your toolchain, pointing it at an unstripped
    copy of the program so that GDB can load the symbol table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In GDB, set the `sysroot` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, use the command target remote to make the connection to `gdbserver`,
    giving it the IP address or hostname of the target and the port it is waiting
    on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When `gdbserver` sees the connection from the host, it prints the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now load Python command scripts such as `tp.py` into GDB and invoke
    these commands like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, `tp` is the name of the *tracepoint* command and `search` is the
    name of a recursive function in `bsdiff`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set a breakpoint at `main()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continue again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `bsdiff` program performs binary diffs and takes three arguments: `oldfile`,
    `newfile`, and `patchfile`. The `patchfile` that `bsdiff` generates serves as
    input to the `bspatch` program for patching binaries. We start the `bsdiff` program
    on the target with `/usr/bin/bzless`, `/usr/bin/bzmore`, and `~/patchfile` as
    arguments. The output from the GDB *tracepoint* command indicates that the `search`
    function at *line 170* of `bsdiff.c` was called 10 times over the course of the
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: The Python support in GDB can also be used to debug Python programs. GDB has
    visibility into CPython’s internals that the standard `pdb` debugger for Python
    does not. It can even inject Python code into a running Python process. This enables
    the creation of powerful Python debugging tools like memory analyzers that would
    otherwise be impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Native debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running a native copy of GDB on the target is not as common as doing it remotely,
    but it is possible. In addition to installing GDB onto the target image, you will
    also need to install unstripped copies of the executables you wish to debug and
    their corresponding source code. Both The Yocto Project and Buildroot allow you
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: While native debugging is not a common activity for embedded developers, running
    profile and trace tools on the target is very common. These tools usually work
    best if you have unstripped binaries and source code on the target, which is half
    of the story I am telling here. I will return to this topic in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Yocto Project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin with, add `gdb` to the target image by adding this to `conf/local.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You need the debug information for the packages you want to debug. The Yocto
    Project builds debug variants of packages, which contain the debug info and symbols
    stripped from the binaries. You can add these debug packages selectively to your
    target image by adding `<package name>-dbg` to your `conf/local.conf`. Or, you
    can simply install all debug packages by adding `dbg-pkgs` to `EXTRA_IMAGE_FEATURES`
    as just shown. Be warned that this will increase the size of the target image
    dramatically, perhaps by several hundreds of megabytes.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can add source packages to your target image by adding `<package
    name>-src` to your `conf/local.conf`. Or, you can simply install all source packages
    by adding `src-pkgs` to `EXTRA_IMAGE_FEATURES`. Again, this will dramatically
    increase the size of the target image. The source code is installed in `/usr/src/debug/<package
    name>` in the target image. This means that GDB will pick it up without needing
    to run `set substitute-path`.
  prefs: []
  type: TYPE_NORMAL
- en: Buildroot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With Buildroot, you can tell it to install a native copy of GDB in the target
    image by enabling this option:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BR2_PACKAGE_GDB_DEBUGGER` in **Target packages** | **Debugging, profiling
    and benchmark** | **Full debugger**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, to build binaries with debug information and install them in the target
    image without stripping, enable the first and disable the second of these two
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BR2_ENABLE_DEBUG` in **Build options** | **Build packages with debugging symbols**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BR2_STRIP_strip` in **Build options** | **Strip target binaries**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s all I have to say about native debugging. Again, the practice is uncommon
    on embedded devices because the extra source code and debug symbols add bloat
    to the target image. Next, let’s look at another form of remote debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Just-in-time debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, a program will start to misbehave after it has been running for a
    while, and you would like to know what it is doing. The GDB `attach` feature does
    exactly this. I call it just-in-time debugging. It is available with both native
    and remote debug sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of remote debugging, you need to find the PID of the process to
    be debugged and pass it to `gdbserver` with the `--attach` option. For example,
    if the PID is 109, you would type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This forces the process to stop as if it were at a breakpoint, allowing you
    to start your cross GDB in the normal way and connect to `gdbserver`. When you
    are done, you can detach, allowing the program to continue running without the
    debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Attaching to a running process by PID is certainly handy, but what about multi-process
    or multithreaded programs? There are techniques for debugging those types of programs
    with GDB as well.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging forks and threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens when the program you are debugging forks? Does the debug session
    follow the parent process or the child? This behavior is controlled by `follow-fork-mode`,
    which may be `parent` or `child`, with `parent` being the default. Unfortunately,
    current versions of `gdbserver` do not support this option, so it only works for
    native debugging. If you really need to debug the child process while using `gdbserver`,
    a workaround is to modify the code so that the child loops on a variable immediately
    after the fork, giving you the opportunity to attach a new `gdbserver` session
    to it and then to set the variable so that it drops out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: When a thread in a multithreaded process hits a breakpoint, the default behavior
    is for all threads to halt. In most cases, this is the best thing to do as it
    allows you to look at static variables without them being changed by the other
    threads. When you resume execution of the thread, all the stopped threads start
    up, even if you are single-stepping, and it is especially this last case that
    can cause problems. There is a way to modify the way in which GDB handles stopped
    threads, through a parameter called `scheduler-locking`. Normally it is `off`,
    but if you set it to `on`, only the thread that was stopped at the breakpoint
    is resumed and the others remain stopped, giving you a chance to see what the
    thread alone does without interference. This continues to be the case until you
    turn `scheduler-locking` off. `gdbserver` supports this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Core files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Core files capture the state of a failing program at the point that it terminates.
    You don’t even have to be in the room with a debugger when the bug manifests itself.
    So, when you see `Segmentation fault (core dumped)`, don’t shrug; investigate
    the **core file** and extract the goldmine of information in there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first observation is that core files are not created by default, but only
    when the core file resource limit for the process is non-zero. You can change
    it for the current shell using `ulimit -c`. To remove all limits on the size of
    core files, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: By default, the core file is named `core` and is placed in the current working
    directory of the process, which is the one pointed to by `/proc/<PID>/cwd`. There
    are a number of problems with this scheme. Firstly, when looking at a device with
    several files named `core`, it is not obvious which program generated each one.
    Secondly, the current working directory of the process may well be in a read-only
    filesystem, there may not be enough space to store the core file, or the process
    may not have permissions to write to the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: There are two files that control the naming and placement of core files. The
    first is `/proc/sys/kernel/core_uses_pid`. Writing a `1` to it causes the PID
    number of the dying process to be appended to the filename, which is somewhat
    useful as long as you can associate the PID number with a program name from log
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much more useful is `/proc/sys/kernel/core_pattern`, which gives you a lot
    more control over core files. The default pattern is core, but you can change
    it to a pattern composed of these meta characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%p`: PID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%u`: Real UID of the dumped process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%g`: Real GID of the dumped process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%s`: Number of the signal causing the dump'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%t`: Time of dump expressed as seconds since the Epoch, 1970-01-01 00:00:00
    +0000 (UTC)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%h`: Hostname'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%e`: Executable filename'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%E`: Path name of executable with slashes (/) replaced by exclamation marks
    (!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%c`: Core file size soft resource limit of the dumped process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also use a pattern that begins with an absolute directory name so that
    all core files are gathered together in one place. As an example, the following
    pattern puts all core files into the `/corefiles` directory and names them with
    the program name and the time of the crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Following a core dump, you would find something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: For more information, refer to the `core(5)` manual page.
  prefs: []
  type: TYPE_NORMAL
- en: Using GDB to look at core files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a sample GDB session looking at a core file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that the program stopped at *line 41*. The list command shows the
    code in the vicinity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `backtrace` command (shortened to `bt`) shows how we got to this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an obvious mistake: `addtree()` was called with a null pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: GDB began as a command-line debugger and many people still use it this way.
    Even though the LLVM Project’s LLDB debugger is gaining in popularity, GCC and
    GDB remain the prominent compiler and debugger for Linux. So far, we have focused
    exclusively on GDB’s command-line interface. Now we will look at some frontends
    to GDB with progressively more modern user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: GDB user interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GDB is controlled at a low level through the GDB machine interface, GDB/MI,
    which can be used to wrap GDB in a user interface or as part of a larger program,
    and it considerably extends the range of options available to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, I will describe three that are well suited to debugging embedded
    targets: the **Terminal User Interface** (**TUI**), **Data Display Debugger**
    (**DDD**), and **Visual Studio Code**.'
  prefs: []
  type: TYPE_NORMAL
- en: Terminal User Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Terminal User Interface** (**TUI**) is an optional part of the standard
    GDB package. The main feature is a code window that shows the line of code about
    to be executed, together with any breakpoints. It is a definite improvement on
    the `list` command in command-line mode GDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attraction of the TUI is that it just works without any extra setup, and
    since it is in text mode, it is possible to use over an SSH terminal session,
    for example, when running `gdb` natively on a target. Most cross toolchains configure
    GDB with the TUI. Simply add `-tui` to the command line and you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.1 – TUI](img/B18466_19_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19.1 – TUI
  prefs: []
  type: TYPE_NORMAL
- en: If you still find the TUI lacking and prefer a truly graphical frontend to GDB,
    the GNU project also offers one of those ([https://www.gnu.org/software/ddd](https://www.gnu.org/software/ddd)).
  prefs: []
  type: TYPE_NORMAL
- en: Data Display Debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Data Display Debugger** (**DDD**) is a simple standalone program that gives
    you a graphical user interface to GDB with minimal fuss and bother, and although
    the UI controls look dated, it does everything that is necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `--debugger` option tells DDD to use GDB from your toolchain, and you can
    use the `-x` argument to give the path to a GDB command file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows off one of the nicest features: the data window,
    which contains items in a grid that you can rearrange as you wish. If you double-click
    on a pointer, it is expanded into a new data item and the link is shown with an
    arrow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.2 – DDD](img/B18466_19_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19.2 – DDD
  prefs: []
  type: TYPE_NORMAL
- en: If neither of these two GDB frontends is acceptable because you are a full stack
    web developer accustomed to working with the latest tools in your industry, then
    we still have you covered.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Visual Studio Code** is a very popular open-source code editor from Microsoft.
    Because it is an Electron application written in TypeScript, Visual Studio Code
    feels more lightweight and responsive than full-blown IDEs such as Eclipse. There
    is rich language support (code completion, go to definition, etc.) for many languages
    by way of extensions contributed by its large community of users. Remote cross
    GDB debugging can be integrated into Visual Studio Code using extensions for C/C++.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.3 – Visual Studio Code](img/B18466_19_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19.3 – Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: There are no prescribed workflows for integrating Visual Studio Code with Buildroot
    or Yocto. To enable remote GDB debugging, you need to edit project files like
    `settings.json` and `launch.json`. These project files point at the toolchain
    and `sysroot`. They also contain the target IP and SSH login credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging kernel code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use `kgdb` for source-level debugging, in a manner similar to remote
    debugging with `gdbserver`. There is also a self-hosted kernel debugger, `kdb`,
    that is handy for lighter-weight tasks such as seeing whether an instruction is
    executed and getting the backtrace to find out how it got there. Finally, there
    are kernel *Oops* messages and panics, which tell you a lot about the cause of
    a kernel exception.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging kernel code with kgdb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When looking at kernel code using a source debugger, you must remember that
    the kernel is a complex system, with real-time behaviors. Don’t expect debugging
    to be as easy as it is for applications. Stepping through code that changes the
    memory mapping or switches context is likely to produce odd results.
  prefs: []
  type: TYPE_NORMAL
- en: '**kgdb** is the name given to the kernel GDB stubs that have been part of mainline
    Linux for many years now. There is a user manual in the kernel DocBook, and you
    can find an online version at [https://kernel.org/doc/html/v6.6/dev-tools/kgdb.html](https://kernel.org/doc/html/v6.6/dev-tools/kgdb.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you will connect to `kgdb` over the serial interface, which is
    usually shared with the serial console. Hence, this implementation is called **kgdboc**,
    which is short for **kgdb over console**. To work, it requires a platform `tty`
    driver that supports I/O polling instead of interrupts, since `kgdb` has to disable
    interrupts when communicating with GDB. A few platforms support `kgdb` over USB,
    and there have been versions that work over Ethernet but, unfortunately, none
    of them have found their way into mainline Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The same caveats regarding optimization and stack frames apply to the kernel,
    with the limitation that the kernel is written to assume an optimization level
    of at least `-O1`. You can override the kernel compile flags by setting `KCFLAGS`
    before running `make`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These, then, are the kernel configuration options you will need for kernel
    debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONFIG_DEBUG_INFO` is in the **Kernel hacking** | **Compile-time checks and
    compiler options** | **Debug information** | **Rely on the toolchain’s implicit
    default DWARF version** menu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_FRAME_POINTER` may be an option for your architecture and is in the
    **Kernel hacking** | **Compile-time checks and compiler options** | **Compile
    the kernel with frame pointers** menu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_KGDB` is in the **Kernel hacking | Generic Kernel Debugging Instruments
    | KGDB: kernel debugger** menu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_KGDB_SERIAL_CONSOLE` is in the **Kernel hacking** | **Generic Kernel
    Debugging Instruments** | **KGDB: kernel debugger** | **KGDB: use kgdb over the
    serial console** menu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel image must be in ELF object format so that GDB can load the symbols
    into memory. This is the file called `vmlinux` that is generated in the directory
    where Linux is built. In Yocto, you can request that a copy be included in the
    target image and SDK. It is built as a package named `kernel-vmlinux`, which you
    can install like any other, for example, by adding it to the `IMAGE_INSTALL` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file is put into the `sysroot` boot directory, with a name like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In Buildroot, you will find `vmlinux` in the directory where the kernel was
    built, which is in `output/build/linux-<version string>/vmlinux`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to tell `kgdb` which serial port to use, either through the kernel
    command line or at runtime via `sysfs`. For the first option, add `kgdboc=<tty>,<baud
    rate>` to the kernel command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: A sample debug session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best way to show you how `kgdb` works is with a simple example. But before
    you can use `kgdb`, you first need to build it. To build `kgdb` and `kdb`, complete
    *Building GDB with Python support*, then perform these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the directory where you installed Buildroot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clean previous build artifacts from the output directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Comment out the `miniuart-bt` `dtoverlay` from `board/raspberrypi4-64/config_4_64bit.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the following lines to `board/raspberrypi4-64/config_4_64bit.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activate your saved configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build your saved configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Begin customizing your kernel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enable kernel debugging by navigating to **Kernel hacking** | **Compile-time
    checks and compiler options** | **Debug information** and selecting **Rely on
    the toolchain’s implicit default DWARF version**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect **Reduce debugging information**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of **Debug information** and select the **Compile the kernel with frame
    pointers** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back out of **Compile-time checks and compiler options** and drill down into
    **Generic Kernel Debugging Instruments** | **KGDB: kernel debugger**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select both **KGDB: use kgdb over the serial console** and **KGDB_KDB: include
    kdb frontend for kgdb**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of **Kernel hacking** and drill down into **Kernel Features**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect **Randomize the address of the kernel image**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your changes and exit `linux-menuconfig`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rebuild the kernel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete the microSD card image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Regenerate the microSD card image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the build is done, there should be a bootable `sdcard.img` file in `output/images/`
    that you can write to a microSD card using Etcher. Insert that microSD into your
    target device. Connect a USB-to-TTL serial cable to the Raspberry Pi 4 ([https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead](https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead)).
    Boot the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the target device to your local network with an Ethernet cable and
    locate its IP address using `arp-scan --localnet`. SSH into the device as `root`
    and enter the password that you set when configuring your image. I specified `temppwd`
    as the `root` password for my `rpi4_64_gdb_defconfig` image. Write the terminal
    name to the `/sys/module/kgdboc/parameters/kgdboc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Note that you cannot set the baud rate in this way. If it is the same `tty`
    as the console, then it is set already. If not, use `stty` or a similar program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can start GDB on the host, selecting the `vmlinux` file that matches
    the running kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: GDB loads the symbol table from `vmlinux` and waits for further input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, close any terminal emulator that is attached to the console: you are
    about to use it for GDB, and if both are active at the same time, some of the
    debug strings might get corrupted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can return to GDB and attempt to connect to `kgdb`. However, you will
    find that the response you get from the target remote at this time is unhelpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that `kgdb` is not listening for a connection at this point.
    You need to interrupt the kernel before you can enter into an interactive GDB
    session with it. Unfortunately, just typing *Ctrl + C* in GDB, as you would with
    an application, does not work. You have to force a trap into the kernel by launching
    another shell on the target, via SSH, for example, and writing `g` to `/proc/sysrq-trigger`
    on the target board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The target stops dead at this point. Now you can connect to `kgdb` via the
    serial device at the host end of the cable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'At last, GDB is in charge. You can set breakpoints, examine variables, look
    at backtraces, and so on. As an example, set a break on `__sys_accept4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the target comes back to life. Exit out of your SSH session and attempt
    to reconnect to the target device. Reconnecting calls `__sys_accept4` and hits
    the breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have finished the debug session and want to disable `kgdboc`, just set
    the `kgdboc` terminal to null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Like attaching to a running process with GDB, this technique of trapping the
    kernel and connecting to `kgdb` over a serial console works once the kernel is
    done booting. But what if the kernel never finishes booting because of a bug?
  prefs: []
  type: TYPE_NORMAL
- en: Debugging early code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding example works in cases where the code you are interested in is
    executed when the system is fully booted. If you need to get in early, you can
    tell the kernel to wait during boot by adding `kgdbwait` to the command line,
    after the `kgdboc` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you boot, you will see this on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you can close the console and connect from GDB in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging kernel modules presents an additional challenge because the code is
    relocated at runtime, and so you need to find out at what address it resides.
    The information is presented through `sysfs`. The relocation addresses for each
    section of the module are stored in `/sys/module/<module name>/sections`. Note
    that since ELF sections begin with a dot (`.`), they appear as hidden files, and
    you will have to use `ls -a` if you want to list them. The important ones are
    `.text`, `.data`, and `.bss`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take as an example a module named `mbx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use these numbers in `kgdb` to load the symbol table for the module
    at those addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything should now work as normal: you can set breakpoints and inspect global
    and local variables in the module just as you can in `vmlinux`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, force the device driver to call `mbx_write`, and it will hit the breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: If you already use GDB to debug code in user space, then you should feel right
    at home debugging kernel code and modules with `kgdb`. Let’s look at `kdb` next.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging kernel code with kdb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although `kdb` does not have the features of `kgdb` and GDB, it does have its
    uses, and, being selfhosted, there are no external dependencies to worry about.
    `kdb` has a simple command-line interface that you can use on a serial console.
    You can use it to inspect memory, registers, process lists, and `dmesg` and even
    set breakpoints to stop at a certain location.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure your kernel so that you can call `kdb` via a serial console, enable
    `kgdb` as shown previously, and then enable this additional option:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONFIG_KGDB_KDB` in **Kernel hacking** | **Generic Kernel Debugging Instruments**
    | **KGDB: kernel debugger** | **KGDB_KDB: include kdb frontend for kgdb**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, when you force the kernel into a trap, instead of entering into a GDB
    session, you will see the `kdb` shell on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'There are quite a few things you can do in the `kdb` shell. The `help` command
    will print all of the options. Here is an overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting information**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps`: Displays active processes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps A`: Displays all processes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lsmod`: Lists modules.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dmesg`: Displays the kernel log buffer.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Breakpoints**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bp`: Sets a breakpoint.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bl`: Lists breakpoints.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bc`: Clears a breakpoint.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bt`: Prints a backtrace.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go`: Continues execution.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inspect memory and registers**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`md`: Displays memory.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rd`: Displays registers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a quick example of setting a breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The kernel returns to life and the console shows the normal shell prompt. If
    you attempt to reconnect to the target, it hits the breakpoint and enters `kdb`
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '`kdb` is not a source-level debugger, so you can’t see the source code or single-step.
    However, you can display a backtrace using the `bt` command, which is useful for
    getting an idea of program flow and call hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at an Oops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the kernel performs an invalid memory access or executes an illegal instruction,
    a kernel **Oops** message is written to the kernel log. The most useful part of
    this is the backtrace, and I want to show you how to use the information there
    to locate the line of code that caused the fault. I will also address the problem
    of preserving Oops messages if they cause the system to crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Oops message was generated by writing to the mailbox driver in `MELD/Chapter19/mbx-driver-oops`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The line of the Oops that reads `pc` is at `mbx_write+0x2c/0xf8 [mbx]` and
    tells you most of what you want to know: the last instruction was in the `mbx_write`
    function of a kernel module named `mbx`. Furthermore, it was at offset `0x2c`
    bytes from the start of the function, which is `0xf8` bytes long.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, take a look at the backtrace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we don’t learn much more, merely that `mbx_write` was called from
    the virtual filesystem function, `_vfs_write`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be very nice to find the line of code that relates to `mbx_write+0x2c`,
    for which we can use the GDB command `disassemble` with the `/s` modifier so that
    it shows source and assembler code together. In this example, the code is in the
    `mbx.ko` module, so we load that into `gdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see from *line 97* that `m` has the type struct `mbx_data *`. Here
    is the place where that structure is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'So, it looks like the `m` variable is a null pointer, and that is what is causing
    the Oops. Looking at the code where `m` is initialized, we can see that there
    is a line missing. By initializing the pointer, as shown in the following code
    block, the Oops is eliminated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Not every Oops is this easy to pinpoint, especially if it occurs before the
    contents of the kernel log buffer can be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Preserving the Oops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decoding an Oops is only possible if you can capture it in the first place.
    If the system crashes during boot before the console is enabled, or after a suspend,
    you won’t see it. There are mechanisms to log kernel Oops and messages to an MTD
    partition or to persistent memory, but here is a simple technique that works in
    many cases and needs little prior thought.
  prefs: []
  type: TYPE_NORMAL
- en: 'So long as the contents of memory are not corrupted during a reset (and usually
    they are not), you can reboot into the bootloader and use it to display memory.
    You need to know the location of the kernel log buffer, remembering that it is
    a simple ring buffer of text messages. The symbol is `__log_buf`. Look this up
    in `System.map` for the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: From Linux 3.5 onward, there is a 16-byte binary header for each line in the
    kernel log buffer that encodes a timestamp, a log level, and other things. There
    is a discussion about it in the Linux weekly news entitled *Toward more reliable
    logging*, at [https://lwn.net/Articles/492125/](https://lwn.net/Articles/492125/).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we examined how kernel code can be debugged at the source level
    using `kgdb`. Then we looked at setting breakpoints and printing backtraces inside
    the `kdb` shell. Lastly, we learned how to read kernel Oops messages either from
    a console using `dmesg` or the U-Boot command line.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing how to use GDB for interactive debugging is a useful tool in the embedded
    system developer’s tool chest. It is a stable, well-documented, and well-known
    entity. It has the ability to debug remotely by placing an agent on the target,
    be it `gdbserver` for applications or `kgdb` for kernel code, and although the
    default command-line user interface takes a while to get used to, there are many
    alternative frontends. The three I mentioned were TUI, DDD, and Visual Studio
    Code. Eclipse is another popular frontend that supports debugging with GDB by
    way of the CDT plugin. I will refer you to the references in the *Further study*
    section for information on how to configure CDT to work with a cross toolchain
    and connect to a remote device.
  prefs: []
  type: TYPE_NORMAL
- en: A second and equally important way to approach debugging is to collect crash
    reports and analyze them offline. In this category, we looked at application core
    dumps and kernel Oops messages.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is only one way of identifying flaws in programs. In the next
    chapter, I will talk about profiling and tracing as ways of analyzing and optimizing
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: Further study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Art of Debugging with GDB, DDD, and Eclipse*, by Norman Matloff and Peter
    Jay Salzman'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GDB Pocket Reference*, by Arnold Robbins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Python Interpreter in GNU Debugger*, by crazyguitar – [https://www.pythonsheets.com/appendix/python-gdb.html](https://www.pythonsheets.com/appendix/python-gdb.html%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Extending GDB with Python*, by Lisa Roach – [https://www.youtube.com/watch?v=xt9v5t4_zvE](https://www.youtube.com/watch?v=xt9v5t4_zvE%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting to grips with Eclipse: cross compiling* – [https://2net.co.uk/tutorial/eclipse-cross-compile](https://2net.co.uk/tutorial/eclipse-cross-compile%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting to grips with Eclipse: remote access and debugging* – [https://2net.co.uk/tutorial/eclipse-rse](https://2net.co.uk/tutorial/eclipse-rse)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
