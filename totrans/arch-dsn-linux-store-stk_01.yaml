- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Where It All Starts From – The Virtual Filesystem
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切从哪里开始——虚拟文件系统
- en: Even with astronomical advances in software development, the Linux kernel remains
    one of the most complex pieces of code. Developers, programmers, and would-be
    kernel hackers constantly look to dive into kernel code and push for new features,
    whereas hobbyists and enthusiasts try to understand and unravel those mysteries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在软件开发取得了惊人的进展的今天，Linux 内核仍然是最复杂的代码之一。开发者、程序员和未来的内核黑客们不断试图深入内核代码并推动新特性，而爱好者和技术爱好者则尝试理解并解开这些谜团。
- en: Naturally, a lot has been written on Linux and its internal workings, from general
    administration to kernel programming. Over the decades, hundreds of books have
    been published, which cover a diverse range of important operating system topics,
    such as process creation, threading, memory management, virtualization, filesystem
    implementations, and CPU scheduling. This book that you’ve picked up (thank you!)
    will focus on the storage stack in Linux and its multilayered organization.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，关于 Linux 及其内部工作原理，已经写了很多，从一般的管理到内核编程。在过去的几十年里，已经出版了数百本书，涵盖了许多重要的操作系统主题，如进程创建、线程、内存管理、虚拟化、文件系统实现和
    CPU 调度。本书（感谢你选择它！）将专注于 Linux 中的存储堆栈及其多层次的组织。
- en: We’ll start by introducing the Virtual Filesystem in the Linux kernel and its
    pivotal role in allowing end user programs to access data on filesystems. Since
    we intend to cover the entire storage stack in this book, from top to bottom,
    getting a deeper understanding of the Virtual Filesystem is extremely important,
    as it is the starting point of an I/O request in the kernel. We’ll introduce the
    concept of user space and kernel space, understand system calls, and see how the
    *Everything is a file* philosophy in Linux is tied to the Virtual Filesystem.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从介绍 Linux 内核中的虚拟文件系统以及它在允许最终用户程序访问文件系统数据方面的关键作用开始。由于本书的目的是覆盖整个存储堆栈，从上到下，深入理解虚拟文件系统非常重要，因为它是内核中
    I/O 请求的起点。我们将介绍用户空间和内核空间的概念，了解系统调用，并看看 Linux 中的*一切皆文件*哲学是如何与虚拟文件系统相关联的。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要主题：
- en: Understanding storage in a modern-day data center
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解现代数据中心中的存储
- en: Defining system calls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义系统调用
- en: Explaining the need for a Virtual Filesystem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释虚拟文件系统的需求
- en: Describing the Virtual Filesystem
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述虚拟文件系统
- en: Explaining the *Everything is a* *file* philosophy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释*一切皆文件*哲学
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before going any further, I think is important to acknowledge here that certain
    technical topics may be more challenging for beginners to comprehend than others.
    Since the goal here is to comprehend the inner workings of the Linux kernel and
    its major subsystems, it will be helpful to have a decent foundational understanding
    of operating system concepts in general and Linux in particular. Above all, it
    is important to approach these topics with patience, curiosity, and a willingness
    to learn.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，我认为有必要在这里指出，某些技术主题对于初学者来说可能比其他主题更具挑战性。由于这里的目标是理解 Linux 内核及其主要子系统的内部工作原理，因此，拥有一定的操作系统基础知识，尤其是
    Linux 的基础知识，将非常有帮助。最重要的是，要以耐心、好奇心和愿意学习的态度来接触这些话题。
- en: 'The commands and examples presented in this chapter are distribution-agnostic
    and can be run on any Linux operating system, such as Debian, Ubuntu, Red Hat,
    and Fedora. There are a few references to the kernel source code. If you want
    to download the kernel source, you can download it from [https://www.kernel.org](https://www.kernel.org).
    The operating system packages relevant to this chapter can be installed as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中呈现的命令和示例与特定的发行版无关，可以在任何 Linux 操作系统上运行，例如 Debian、Ubuntu、Red Hat 和 Fedora。文中提到了一些内核源代码的参考。如果你想下载内核源代码，可以从[https://www.kernel.org](https://www.kernel.org)下载。本章相关的操作系统软件包可以按如下方式安装：
- en: 'For Ubuntu/Debian:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Ubuntu/Debian 系统：
- en: '`sudo apt` `install strace`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo apt` `install strace`'
- en: '`sudo apt` `install bcc`'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo apt` `install bcc`'
- en: 'For Fedora/CentOS/Red Hat-based systems:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Fedora/CentOS/Red Hat 系统：
- en: '`sudo yum` `install strace`'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo yum` `install strace`'
- en: '`sudo yum` `install bcc-tools`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo yum` `install bcc-tools`'
- en: Understanding storage in a modern-day data center
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解现代数据中心中的存储
- en: It is a capital mistake to theorize before one has data. Insensibly one begins
    to twist facts to suit theories, instead of theories to suit facts. – Sir Arthur
    Conan Doyle
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有数据的情况下进行理论推测是一项严重的错误。人们往往会开始扭曲事实以适应理论，而不是让理论适应事实。——亚瑟·柯南·道尔爵士
- en: Compute, storage, and networking are the basic building blocks of any infrastructure.
    How well your applications do is often dependent on the combined performance of
    these three layers. The workloads running in a modern data center vary from streaming
    services to machine learning applications. With the meteoric rise and adoption
    of cloud computing platforms, all the basic building blocks are now abstracted
    from the end user. Adding more hardware resources to your application, as it becomes
    resource-hungry, is the new normal. Troubleshooting performance issues is often
    skipped in favor of migrating applications to better hardware platforms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 计算、存储和网络是任何基础设施的基本构件。您的应用程序表现如何，通常取决于这三层的综合性能。现代数据中心中运行的工作负载从流媒体服务到机器学习应用都有。随着云计算平台的迅猛崛起和普及，所有这些基本构件现在都被从终端用户那里抽象出来。随着应用程序变得资源需求更大，向应用程序添加更多硬件资源已成为新常态。故障排除性能问题通常被跳过，转而将应用程序迁移到更好的硬件平台。
- en: Of the three building blocks, compute, storage, and networking, storage is often
    considered the bottleneck in most scenarios. For applications such as databases,
    the performance of the underlying storage is of prime importance. In cases where
    infrastructure hosts mission-critical and time-sensitive applications such as
    **Online Transaction Processing** (**OLTP**), the performance of storage frequently
    comes under the radar. The smallest of delays in servicing I/O requests can impact
    the overall response of the application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算、存储和网络这三个基础构件中，存储通常被认为是大多数场景中的瓶颈。对于像数据库这样的应用程序，底层存储的性能至关重要。在托管关键任务和时间敏感应用（例如**在线事务处理**（**OLTP**））的基础设施中，存储性能经常受到关注。即便是微小的I/O请求延迟，也可能影响整个应用程序的响应。
- en: The most common metric used to measure storage performance is latency. The response
    times of storage devices are usually measured in milliseconds. Compare that with
    your average processor or memory, where such measurements are measured in nanoseconds,
    and you’ll see how the performance of the storage layer can impact the overall
    working of your system. This results in a state of incongruity between the application
    requirements and what the underlying storage can actually deliver. For the last
    few years, most of the advancements in modern-day storage drives have been geared
    toward sizing – the **capacity arena**. However, performance improvement of the
    storage hardware has not progressed at the same rate. Compared to the compute
    functions, the performance of storage pales in comparison. For these reasons,
    it is often termed the *three-legged dog of the* *data center*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 测量存储性能的最常见指标是延迟。存储设备的响应时间通常以毫秒为单位进行测量。而与此相比，您的处理器或内存的测量通常以纳秒为单位，您就会发现存储层的性能如何影响系统的整体工作。这就导致了应用程序需求与底层存储实际能够提供的性能之间的不一致。在过去的几年里，现代存储硬盘的进展大多集中在大小方面——**容量领域**。然而，存储硬件的性能提升并没有按相同的速度发展。与计算功能相比，存储性能相形见绌。因此，它常被称为*数据中心的三条腿狗*。
- en: Having made a point about the choice of a storage medium, it’s pertinent to
    note that no matter how powerful it is, the hardware will always have limitations
    in its functionality. It’s equally important for the application and operating
    system to tune themselves according to the hardware. Fine-tuning your application,
    operating system, and filesystem parameters can give a major boost to the overall
    performance. To utilize the underlying hardware to its full potential, all layers
    of the I/O hierarchy need to function efficiently.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论存储介质的选择时，需要指出的是，无论硬件多么强大，它总会有其功能上的限制。应用程序和操作系统根据硬件进行调优同样重要。对您的应用程序、操作系统和文件系统参数进行精细调优，可以显著提升整体性能。为了充分利用底层硬件的潜力，I/O层次结构的所有层次都需要高效运作。
- en: Interacting with storage in Linux
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Linux中与存储交互
- en: 'The Linux kernel makes a clear distinction between the user space and kernel
    space processes. All the hardware resources, such as CPU, memory, and storage,
    lie in the kernel space. For any user space application wanting to access the
    resources in kernel space, it has to generate a **system call**, as shown in *Figure
    1**.1*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核明确区分了用户空间和内核空间进程。所有硬件资源，如 CPU、内存和存储，都位于内核空间。任何想要访问内核空间资源的用户空间应用程序，都必须生成一个
    **系统调用**，如 *图 1.1* 所示：
- en: '![Figure 1.1 – The interaction between user space and kernel space](img/B19430_01_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 用户空间与内核空间之间的交互](img/B19430_01_01.jpg)'
- en: Figure 1.1 – The interaction between user space and kernel space
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 用户空间与内核空间之间的交互
- en: '**User space** refers to all the applications and processes that live outside
    of the kernel. The kernel space includes programs such as device drivers, which
    have unrestricted access to the underlying hardware. The user space can be considered
    a form of sandboxing to restrict the end user programs from modifying critical
    kernel functions.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户空间** 指的是所有位于内核之外的应用程序和进程。内核空间包括设备驱动程序等程序，这些程序可以不受限制地访问底层硬件。用户空间可以视为一种沙箱机制，用来限制最终用户程序修改关键的内核功能。'
- en: This concept of user and kernel space is deeply rooted in the design of modern
    processors. A traditional x86 CPU uses the concept of protection domains, called
    **rings**, to share and limit access to hardware resources. Processors offer four
    rings or modes, which are numbered from 0 to 3\. Modern-day processors are designed
    to operate in two of these modes, ring 0 and ring 3\. The user space applications
    are handled in ring 3, which has limited access to kernel resources. The kernel
    occupies ring 0\. This is where the kernel code executes and interacts with the
    underlying hardware resources.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间与内核空间的概念深深植根于现代处理器的设计中。传统的 x86 CPU 使用保护域的概念，称为 **环**，来共享和限制对硬件资源的访问。处理器提供四个环或模式，编号从
    0 到 3。现代处理器设计只在其中两个模式下运行，即环 0 和环 3。用户空间应用程序运行在环 3 中，具有有限的内核资源访问权限。内核则占据环 0。内核代码在这里执行，并与底层硬件资源进行交互。
- en: 'When processes need to read from or write to a file, they need to interact
    with the filesystem structures on top of the physical disk. Every filesystem uses
    different methods to organize data on the physical disk. The request from the
    process doesn’t directly reach the filesystem or physical disk. In order for the
    I/O request of the process to be served by the physical disk, it has to traverse
    through the entire storage hierarchy in the kernel. The first layer in that hierarchy
    is known as the **Virtual Filesystem**. The following figure, *Figure 1**.2*,
    highlights the major components of the Virtual Filesystem:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程需要读取或写入文件时，它们需要与物理磁盘上方的文件系统结构进行交互。每种文件系统使用不同的方法来组织磁盘上的数据。进程的请求不会直接到达文件系统或物理磁盘。为了让物理磁盘服务于进程的
    I/O 请求，必须经过内核中整个存储层级。该层级中的第一层称为 **虚拟文件系统**。以下的图 *图 1.2* 突出了虚拟文件系统的主要组件：
- en: '![Figure 1.2 – The Virtual Filesystem (VFS) layer in the kernel](img/B19430_01_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 内核中的虚拟文件系统 (VFS) 层](img/B19430_01_02.jpg)'
- en: Figure 1.2 – The Virtual Filesystem (VFS) layer in the kernel
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 内核中的虚拟文件系统 (VFS) 层
- en: The storage stack in Linux consists of a multitude of cohesive layers, all of
    which ensure that the access to physical storage media is abstracted through a
    unified interface. As we move forward, we’re going to build upon this structure
    and add more layers. We’ll try to dig deep into each of them and see how they
    all work in harmony.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中的存储栈由多个紧密相连的层组成，这些层共同确保通过统一的接口抽象了对物理存储介质的访问。在接下来的内容中，我们将基于这一结构进行扩展，增加更多的层次。我们将尽力深入探讨每一层，了解它们如何协同工作。
- en: 'This chapter will focus solely on the Virtual Filesystem and its various features.
    In the coming chapters, we’re going to explain and uncover some under-the-hood
    workings of the more frequently used filesystems in Linux. However, bearing in
    mind the number of times the word *filesystem* is going to be used here, I think
    it’s prudent to briefly categorize the different filesystem types, just to avoid
    any confusion:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于虚拟文件系统及其各种特性。在接下来的章节中，我们将解释并揭示 Linux 中更常用的文件系统的一些底层工作原理。然而，考虑到这里将多次提到
    *文件系统* 这一词汇，我认为有必要简要地对不同的文件系统类型进行分类，以避免任何混淆：
- en: '**Block filesystems**: Block- or disk-based filesystems are the most common
    way to store user data. As a regular operating system user, these are the filesystems
    that users mostly interact with. Filesystems such as **Extended filesystem version
    2/3/4** (**Ext 2/3/4**), **Extent filesystem** (**XFS**), Btrfs, FAT, and NTFS
    are all categorized as disk-based or block filesystems. These filesystems speak
    in terms of **blocks**. The block size is a property of the filesystem, and it
    can only be set when creating a filesystem on a device. The block size indicates
    what size the filesystem will use when reading or writing data. We can refer to
    it as the logical unit of storage allocation and retrieval for a filesystem. A
    device that can be accessed in terms of blocks is, therefore, called a **block
    device**. Any storage device attached to a computer, whether it is a hard drive
    or an external USB, can be classified as a block device. Traditionally, block
    filesystems are mounted on a single host and do not allow sharing between multiple
    hosts.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块级文件系统**：块级或基于磁盘的文件系统是存储用户数据的最常见方式。作为普通操作系统用户，这些就是用户大多数交互的文件系统。像**扩展文件系统版本2/3/4**（**Ext
    2/3/4**）、**扩展文件系统**（**XFS**）、Btrfs、FAT和NTFS等文件系统都被归类为基于磁盘或块级文件系统。这些文件系统以**块**为单位。块大小是文件系统的一个属性，只有在创建设备上的文件系统时才能设置。块大小表示文件系统在读写数据时使用的大小。我们可以将其视为文件系统中存储分配和检索的逻辑单位。一个可以按块访问的设备因此被称为**块设备**。任何连接到计算机的存储设备，无论是硬盘还是外部USB，都可以归类为块设备。传统上，块级文件系统是挂载在单个主机上的，不允许多个主机之间共享。'
- en: '**Clustered filesystems**: Clustered filesystems are also block filesystems
    and use block-based access methods to read and write data. The difference is that
    they allow a single filesystem to be mounted and used simultaneously by multiple
    hosts. Clustered filesystems are based on the concept of **shared storage**, meaning
    that multiple hosts can concurrently access the same block device. Common clustered
    filesystems used in Linux are Red Hat’s **Global File System 2** (**GFS2**) and
    **Oracle Clustered File** **System** (**OCFS**).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群文件系统**：集群文件系统也是块级文件系统，使用基于块的访问方法来读写数据。不同之处在于，它们允许单个文件系统被多个主机同时挂载和使用。集群文件系统基于**共享存储**的概念，这意味着多个主机可以同时访问同一个块设备。Linux中常用的集群文件系统包括Red
    Hat的**全球文件系统2**（**GFS2**）和**Oracle集群文件系统**（**OCFS**）。'
- en: '**Network filesystems (NFS)**: NFS is a protocol that allows for remote file
    sharing. Unlike regular block filesystems, NFS is based on the concept of sharing
    data between multiple hosts. NFS works with the concept of a client and a server.
    The backend storage is provided by an NFS server. The host systems on which the
    NFS filesystem is mounted are called **clients**. The connectivity between the
    client and server is achieved using conventional Ethernet. All NFS clients share
    a single copy of the file on the NFS server. NFS doesn’t offer the same performance
    as block filesystems, but it is still used in enterprise environments, mostly
    to store long-term backups and share common data.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络文件系统（NFS）**：NFS是一种允许远程文件共享的协议。与常规的块级文件系统不同，NFS基于多个主机之间共享数据的概念。NFS的工作模式是客户端和服务器的概念。后端存储由NFS服务器提供。挂载NFS文件系统的主机系统称为**客户端**。客户端和服务器之间的连接是通过常规以太网实现的。所有NFS客户端共享NFS服务器上的单一文件副本。NFS的性能不如块级文件系统，但它仍然广泛应用于企业环境，主要用于存储长期备份和共享常用数据。'
- en: '`/proc (procfs)` and `/sys (sysfs)` fall under this category. These directories
    contain virtual or temporary files, which include information about the different
    kernel subsystems. These pseudo filesystems are also a part of the Virtual Filesystem
    landscape, as we’ll see in the *Everything is a* *file* section.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc (procfs)`和`/sys (sysfs)`属于这一类别。这些目录包含虚拟或临时文件，其中包含有关不同内核子系统的信息。这些伪文件系统也是虚拟文件系统的一部分，正如我们将在*万物皆文件*章节中看到的那样。'
- en: Now that we have a basic idea about user space, kernel space, and the different
    types of filesystems, let’s explain how an application can request resources in
    kernel space through system calls.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对用户空间、内核空间和不同类型的文件系统有了基本的了解，接下来我们将解释应用程序如何通过系统调用在内核空间中请求资源。
- en: Understanding system calls
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解系统调用
- en: 'While looking at the figure explaining the interaction between applications
    and the Virtual Filesystem, you may have noticed the intermediary layer between
    user space programs and the Virtual Filesystem; that layer is known as the **system
    call interface**. To request some service from the kernel, user space programs
    invoke the system call interface. These system calls provide the means for end
    user applications to access the resources in the kernel space, such as the processor,
    memory, and storage. The system call interface serves three main purposes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看说明应用程序与虚拟文件系统交互的图示时，你可能注意到了用户空间程序与虚拟文件系统之间的中介层；该层被称为**系统调用接口**。为了从内核请求某些服务，用户空间程序调用系统调用接口。这些系统调用为最终用户应用程序提供了访问内核空间资源（如处理器、内存和存储）的方式。系统调用接口有三个主要目的：
- en: '**Ensuring security**: System calls prevent user space applications from directly
    modifying resources in the kernel space'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保安全性**：系统调用防止用户空间的应用程序直接修改内核空间的资源。'
- en: '**Abstraction**: Applications do not need to concern themselves with the underlying
    hardware specifications'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象性**：应用程序不需要关注底层硬件规格'
- en: '**Portability**: User programs can be run correctly on all kernels that implement
    the same set of interfaces'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：用户程序可以在所有实现相同接口集的内核上正确运行'
- en: There’s often some confusion about the differences between system calls and
    an **application programming interface** (**API**). An API is a set of programming
    interfaces used by a program. These interfaces define a method of communication
    between two components. An API is implemented in user space and outlines how to
    acquire a particular service. A system call is a much lower-level mechanism that
    uses interrupts to make an explicit request to the kernel. The system call interface
    is provided by the standard C library in Linux.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于系统调用和**应用程序编程接口**（**API**）之间的区别，常常存在一些混淆。API是程序使用的一组编程接口，这些接口定义了两个组件之间的通信方式。API实现于用户空间，描述了如何获取特定的服务。而系统调用是一个更底层的机制，通过中断向内核发出显式请求。系统调用接口由Linux的标准C库提供。
- en: If the system call generated by the calling process succeeds, a file descriptor
    is returned. A `open ()` system call, a file descriptor is returned to the calling
    process. Once a file has been opened, programs use the file descriptor to perform
    operations on the file. All read, write, and other operations are performed using
    the file descriptor.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用进程生成的系统调用成功，将返回一个文件描述符。`open ()`系统调用会返回一个文件描述符给调用进程。一旦文件被打开，程序使用文件描述符对文件进行操作。所有的读取、写入以及其他操作都通过文件描述符来执行。
- en: 'Every process always has a minimum of three files opened – standard input,
    standard output, and standard error – represented by the 0, 1, and 2 file descriptors,
    respectively. The next file opened will be assigned the file descriptor value
    of 3\. If we do some file listing through `ls` and run a simple `strace`, the
    open system call will return a value of 3, which is the file descriptor representing
    the file – `/etc/hosts`, in this case. After that, this file descriptor value
    of 3 is used by the `fstat` and `close` calls to perform further operations:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程始终至少有三个打开的文件——标准输入、标准输出和标准错误，分别由文件描述符0、1和2表示。接下来的文件将分配文件描述符值为3。如果我们通过`ls`进行文件列表并运行一个简单的`strace`，`open`系统调用将返回一个值为3的文件描述符，代表文件——在此案例中为`/etc/hosts`。之后，这个文件描述符值3将被`fstat`和`close`调用用于执行进一步操作：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[The rest of the code is skipped for brevity.]'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[由于篇幅原因，省略其余代码。]'
- en: 'On x86 systems, there are around 330 system calls. This number could be different
    for other architectures. Each system call is represented by a unique integer number.
    You can list the available system calls on your system using the `ausyscall` command.
    This will list the system calls and their corresponding integer values:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86系统上，大约有330个系统调用。对于其他架构，这个数字可能不同。每个系统调用都有一个唯一的整数编号。你可以通过`ausyscall`命令列出系统上可用的系统调用，这将列出系统调用及其对应的整数值：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[The rest of the code is skipped for brevity.]'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[由于篇幅原因，省略其余代码。]'
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following table lists some common system calls:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了一些常见的系统调用：
- en: '| **System call** | **Description** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **系统调用** | **描述** |'
- en: '| `open ()`, `close ()` | Open and close files |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `open ()`, `close ()` | 打开和关闭文件 |'
- en: '| `create ()` | Create a file |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `create ()` | 创建文件 |'
- en: '| `chroot ()` | Change the `root` directory |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `chroot ()` | 更改`root`目录 |'
- en: '| `mount ()`, `umount ()` | Mount and unmount filesystems |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `mount ()`, `umount ()` | 挂载和卸载文件系统 |'
- en: '| `lseek ()` | Change the pointer position in a file |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `lseek ()` | 更改文件中的指针位置 |'
- en: '| `read ()`, `write ()` | Read and write in a file |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `read ()`, `write ()` | 读写文件 |'
- en: '| `stat ()`, `fstat ()` | Get a file status |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `stat ()`, `fstat ()` | 获取文件状态 |'
- en: '| `statfs ()`, `fstatfs ()` | Get filesystem statistics |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `statfs ()`, `fstatfs ()` | 获取文件系统统计信息 |'
- en: '| `execve ()` | Execute the program referred to by pathname |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `execve ()` | 执行路径名所指的程序 |'
- en: '| `access ()` | Checks whether the calling process can access the file pathname
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `access ()` | 检查调用进程是否能访问文件路径名 |'
- en: '| `mmap ()` | Creates a new mapping in the virtual address space of the calling
    process |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `mmap ()` | 在调用进程的虚拟地址空间中创建一个新的映射 |'
- en: Table 1.1 – Some common system calls
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 – 一些常见的系统调用
- en: So, what role do the system calls play in interacting with filesystems? As we’ll
    see in the succeeding section, when a user space process generates a system call
    to access resources in the kernel space, the first component it interacts with
    is the Virtual Filesystem. This system call is first handled by the corresponding
    system call handler in the kernel, and after validating the operation requested,
    the handler makes a call to the appropriate function in the VFS layer. The VFS
    layer passes the request on to the appropriate filesystem driver module, which
    performs the actual operations on the file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，系统调用在与文件系统交互中扮演什么角色呢？正如我们将在后续章节中看到的，当用户空间进程生成系统调用来访问内核空间中的资源时，它首先与虚拟文件系统交互。该系统调用首先由内核中的相应系统调用处理程序处理，在验证请求的操作后，处理程序会调用
    VFS 层中的适当函数。VFS 层将请求传递给适当的文件系统驱动模块，该模块执行文件上的实际操作。
- en: We need to understand the *why* here – why would the process interact with the
    Virtual Filesystem and not the actual filesystem on the disk? In the upcoming
    section, we’ll try to figure this out.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解这里的*原因*——为什么进程会与虚拟文件系统交互，而不是与磁盘上的实际文件系统交互？在接下来的章节中，我们将尝试弄清楚这个问题。
- en: To summarize, the system calls interface in Linux implements generic methods
    that can be used by the applications in user space to access resources in the
    kernel space.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，Linux 中的系统调用接口实现了通用的方法，用户空间的应用程序可以通过这些方法访问内核空间中的资源。
- en: Explaining the need for a Virtual Filesystem
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释虚拟文件系统的需求
- en: A **standard filesystem** is a set of data structures that determine how user
    data is organized on a disk. End users are able to interact with this standard
    filesystem through regular file access methods and perform common tasks. Every
    operating system (Linux or non-Linux) provides at least one such filesystem, and
    naturally, each of them claims to be *better, faster, and more secure* than the
    other. A great majority of modern Linux distributions use **XFS or Ext4** as the
    default filesystem. These filesystems have several features and are considered
    stable and reliable for daily usage.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**标准文件系统**是一组数据结构，决定了用户数据在磁盘上的组织方式。最终用户能够通过常规的文件访问方法与这个标准文件系统交互，并执行常见任务。每个操作系统（无论是
    Linux 还是非 Linux）至少提供一个这样的文件系统，显然，它们每个都宣称自己比其他的*更好、更快、更安全*。绝大多数现代 Linux 发行版将 **XFS
    或 Ext4** 作为默认文件系统。这些文件系统具有多个特性，并被认为在日常使用中稳定可靠。'
- en: However, the support for filesystems in Linux is not limited to only these two.
    One of the great benefits of using Linux is that it offers support for multiple
    filesystems, all of which can be considered perfectly acceptable alternatives
    to Ext4 and XFS. Because of this, Linux can peacefully coexist with other operating
    systems. Some of the more commonly used filesystems include older versions of
    Ext4, such as Ext2 and Ext3, Btrfs, ReiserFS, OpenZFS, FAT, and NTFS. When using
    multiple partitions, users can choose from a long list of available filesystems
    and create a different one on every disk partition as per their needs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Linux 对文件系统的支持不仅仅限于这两种。使用 Linux 的一个重要好处是它支持多种文件系统，所有这些文件系统都可以被视为 Ext4 和 XFS
    的完美替代方案。因此，Linux 可以与其他操作系统和谐共存。一些常用的文件系统包括 Ext4 的旧版本，如 Ext2 和 Ext3，Btrfs、ReiserFS、OpenZFS、FAT
    和 NTFS。在使用多个分区时，用户可以从长长的文件系统列表中进行选择，根据需求在每个磁盘分区上创建不同的文件系统。
- en: The smallest addressable unit of a physical hard drive is a sector. For filesystems,
    the smallest writable unit is called a block. A **block** can be considered a
    group of consecutive sectors. All operations by a filesystem are performed in
    terms of blocks. There is no singular way in which these blocks are addressed
    and organized by different filesystems. Each filesystem may use a different set
    of data structures to allocate and store data on these blocks. The presence of
    a different filesystem on each storage partition can be difficult to manage. Given
    the wide range of supported filesystems in Linux, imagine if applications needed
    to understand the distinct details of every filesystem. In order to be compatible
    with a filesystem, the application would need to implement a unique access method
    for each filesystem it uses. This would make the design of an application almost
    impractical.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 物理硬盘上最小的可寻址单位是扇区。对于文件系统来说，最小的可写单位称为块（block）。**块**可以视为一组连续的扇区。文件系统的所有操作都是以块为单位进行的。不同文件系统在如何寻址和组织这些块上并没有统一的方法。每个文件系统可能会使用不同的数据结构来分配和存储这些块上的数据。每个存储分区上可能存在不同的文件系统，这会使管理变得复杂。考虑到Linux支持的文件系统种类繁多，试想一下，如果应用程序需要理解每种文件系统的具体细节，会是多么麻烦。为了与文件系统兼容，应用程序需要为每种文件系统实现独特的访问方法，这几乎使应用程序的设计变得不切实际。
- en: Abstraction interfaces play a critical role in the Linux kernel. In Linux, regardless
    of the filesystem being used, the end users or applications can interact with
    the filesystem using uniform access methods. All this is achieved through the
    Virtual Filesystem layer, which hides the filesystem implementations under an
    all-inclusive interface.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象接口在Linux内核中起着至关重要的作用。在Linux中，无论使用哪种文件系统，最终用户或应用程序都可以通过统一的访问方法与文件系统进行交互。所有这些都是通过虚拟文件系统层（VFS）实现的，它通过一个包容性接口隐藏了文件系统的实现。
- en: Describing the VFS
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述VFS
- en: To ensure that applications do not face any such obstacles (as mentioned earlier)
    when working with different filesystems, the Linux kernel implements a layer between
    end user applications and the filesystem on which data is being stored. This layer
    is known as the `mkfs.vfs` command!) For this reason, some prefer the term **Virtual**
    **Filesystem Switch**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保应用程序在处理不同文件系统时不会遇到上述障碍，Linux内核在最终用户应用程序和存储数据的文件系统之间实现了一层抽象。这一层被称为`mkfs.vfs`命令！因此，一些人更喜欢使用**虚拟**
    **文件系统切换**这一术语。
- en: Think of the *magic wardrobe* from *The Chronicles of Narnia*. The wardrobe
    is actually a portal to the magical world of Narnia. Once you step through the
    wardrobe, you can explore the new world and interact with its inhabitants. The
    wardrobe facilitates accessing the magical world. In a similar way, the VFS provides
    a doorway to different filesystems.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下*纳尼亚传奇*中的*神奇衣橱*。衣橱实际上是通往纳尼亚魔法世界的门户。一旦你穿过衣橱，你就可以探索新世界并与其中的居民互动。衣橱帮助你进入魔法世界。同样地，VFS为不同的文件系统提供了一个通道。
- en: The VFS defines a generic interface that allows multiple filesystems to coexist
    in Linux. It’s worth mentioning again that with the VFS, we’re not talking about
    a standard block-based filesystem. We’re talking about an abstraction layer that
    provides a link between the end user application and the actual block filesystems.
    Through the standardization implemented in the VFS, applications can perform read
    and write operations, without worrying about the underlying filesystem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: VFS定义了一个通用接口，使得多个文件系统能够在Linux中共存。值得再次强调的是，VFS并非指标准的基于块的文件系统。我们在谈论的是一个抽象层，它提供了最终用户应用程序与实际块文件系统之间的联系。通过VFS中的标准化，应用程序可以执行读写操作，而无需担心底层的文件系统。
- en: 'As shown in *Figure 1**.3*, the VFS is interposed between the user space programs
    and actual filesystems:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图1.3*所示，VFS位于用户空间程序与实际文件系统之间：
- en: '![Figure 1.3 – The VFS acts as a bridge between user space programs and filesystems](img/B19430_01_03.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – VFS作为用户空间程序与文件系统之间的桥梁](img/B19430_01_03.jpg)'
- en: Figure 1.3 – The VFS acts as a bridge between user space programs and filesystems
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – VFS作为用户空间程序与文件系统之间的桥梁
- en: 'For the VFS to provide services to both parties, the following has to apply:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使VFS能够为双方提供服务，以下条件必须成立：
- en: All end user applications need to define their filesystem operations in terms
    of the standard interface provided by the VFS
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有最终用户应用程序需要根据VFS提供的标准接口来定义它们的文件系统操作
- en: Every filesystem needs to provide an implementation of the common interface
    provided by the VFS
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个文件系统需要提供VFS提供的通用接口的实现。
- en: We explained that applications in user space need to generate system calls when
    they want to access resources in the kernel space. Through the abstraction provided
    by the VFS, system calls such as `read()` and `write()` function properly, regardless
    of the filesystem in use. These system calls work across filesystem boundaries.
    We don’t need a special mechanism to move data to a different or non-native filesystem.
    For instance, we can easily move data from an Ext4 filesystem to XFS, and vice
    versa. At a very high level, when a process issues the `read()` or `write()` system
    call to read or write a file, the VFS will search for the filesystem driver to
    use and forward these system calls to that driver.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解释过，用户空间中的应用程序在需要访问内核空间中的资源时，需要生成系统调用。通过VFS提供的抽象，像`read()`和`write()`这样的系统调用可以正常工作，而不管使用的是哪种文件系统。这些系统调用能够跨文件系统边界工作。我们不需要特别的机制将数据移到不同或非本地文件系统。例如，我们可以轻松地将数据从Ext4文件系统移动到XFS，反之亦然。从高层次来说，当进程发出`read()`或`write()`系统调用以读取或写入文件时，VFS会搜索要使用的文件系统驱动程序，并将这些系统调用转发给该驱动程序。
- en: Implementing a common filesystem interface through the VFS
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过VFS实现通用文件系统接口
- en: The primary goal of the VFS is to represent a diverse set of filesystems in
    the kernel with minimum overhead. When a process requests a read or write operation
    on a file, the kernel substitutes this with the filesystem-specific function on
    which the file resides. In order to achieve this, every filesystem must adapt
    itself in terms of the VFS.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: VFS的主要目标是以最小的开销在内核中表示多种文件系统。当进程请求对文件进行读写操作时，内核将其替换为该文件所在文件系统的特定函数。为了实现这一点，每个文件系统必须根据VFS进行适配。
- en: Let’s go through the following example for a better understanding.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们来看看以下示例。
- en: 'Consider the example of the `cp` (`copy`) command in Linux. Let’s suppose we’re
    trying to copy a file from an Ext4 to an XFS filesystem. How does this copy operation
    complete? How does the `cp` command interact with the two filesystems? Have a
    look at *Figure 1**.4*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以Linux中的`cp`（`copy`）命令为例。假设我们要将一个文件从Ext4文件系统复制到XFS文件系统。那么，这个复制操作是如何完成的？`cp`命令是如何与这两个文件系统进行交互的？请参见*图
    1.4*：
- en: '![Figure 1.4 – The VFS ensures interoperability between different filesystems](img/B19430_01_04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – VFS确保不同文件系统之间的互操作性](img/B19430_01_04.jpg)'
- en: Figure 1.4 – The VFS ensures interoperability between different filesystems
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – VFS确保不同文件系统之间的互操作性
- en: First off, the `cp` command doesn’t care about the filesystems being used. We’ve
    defined the VFS as the layer that implements abstraction. So, the `cp` command
    doesn’t need to concern itself about the filesystem details. It will interact
    with the VFS layer through the standard system call interface. Specifically, it
    will issue the `open ()` and `read ()` system calls to open and read the file
    to be copied. An open file is represented by the file data structure in the kernel
    (as we’ll learn in the next chapter, [*Chapter 2*](B19430_02.xhtml#_idTextAnchor028),
    *Explaining the Data Structures in* *a VFS*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`cp`命令并不关心所使用的文件系统。我们已经将VFS定义为实现抽象的层。因此，`cp`命令无需关心文件系统的细节。它将通过标准的系统调用接口与VFS层进行交互。具体来说，它将发出`open()`和`read()`系统调用来打开和读取要复制的文件。一个已打开的文件在内核中由文件数据结构表示（正如我们将在下一章[*第二章*](B19430_02.xhtml#_idTextAnchor028)中学习的那样，*解释VFS中的数据结构*）。
- en: When `cp` generates these generic system calls, the kernel will redirect these
    calls to the appropriate function of the filesystem through a pointer, on which
    the file resides. To copy the file to the XFS filesystem, the `write()` system
    call is passed to the VFS. This will again be redirected to the particular function
    of the XFS filesystem that implements this feature. Through system calls issued
    to the VFS, the `cp` process can perform a copy operation using the `read ()`
    method of Ext4 and the `write ()` method of XFS. Just like a *switch*, the VFS
    will switch the common file access methods between their designated filesystem
    implementations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当`cp`生成这些通用系统调用时，内核将通过指针将这些调用重定向到文件所在文件系统的适当函数。为了将文件复制到XFS文件系统，`write()`系统调用会传递给VFS。然后，这个调用会再次被重定向到实现该功能的XFS文件系统的特定函数。通过向VFS发出的系统调用，`cp`进程可以使用Ext4的`read()`方法和XFS的`write()`方法执行复制操作。就像一个*开关*，VFS将在它们指定的文件系统实现之间切换通用的文件访问方法。
- en: The read, write, or any other function for that matter does not have a default
    definition in the kernel – hence the name **virtual**. The interpretation of these
    operations depends upon the underlying filesystem. Just like user programs that
    take advantage of this abstraction offered by the VFS, filesystems also reap the
    benefits of this approach. Common access methods for files do not need to be reimplemented
    by filesystems.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 内核中的读、写或任何其他功能没有默认定义——这也是**虚拟**一词的含义。对于这些操作的解释取决于底层文件系统。就像利用 VFS 提供的抽象的用户程序一样，文件系统也能从这种方法中受益。文件系统不需要重新实现文件的常见访问方法。
- en: That was pretty neat, right? But what if we want to copy something from Ext4
    to a non-native filesystem? Filesystems such as Ext4, XFS, and Btrfs were specifically
    designed for Linux. What if one of the filesystems involved in this operation
    is FAT or NTFS?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这还挺酷的，对吧？但是如果我们想从 Ext4 复制一些东西到一个非原生文件系统呢？像 Ext4、XFS 和 Btrfs 这样的文件系统是专门为 Linux
    设计的。如果其中一个文件系统是 FAT 或 NTFS，情况会怎样呢？
- en: Admittedly, the design of the VFS is biased toward filesystems that come from
    the Linux tribe. To an end user, there is a clear distinction between a file and
    a directory. In the Linux philosophy, everything is a file, including directories.
    Filesystems native to Linux, such as Ext4 and XFS, were designed keeping these
    nuances in mind. Because of the differences in the implementation, non-native
    filesystems such as FAT and NTFS do not support all of the VFS operations. The
    VFS in Linux uses structures such as inodes, superblocks, and directory entries
    to represent a generic view of a filesystem. Non-native Linux filesystems do not
    speak in terms of these structures. So how does Linux accommodate these filesystems?
    Take the example of the FAT filesystem. The FAT filesystem comes from a different
    world and doesn’t use these structures to represent files and directories. It
    doesn’t treat directories as files. So, how does the VFS interact with the FAT
    filesystem?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不得不承认，VFS 的设计偏向于源自 Linux 系列的文件系统。对于最终用户来说，文件和目录之间有明确的区别。在 Linux 的哲学中，一切都是文件，包括目录。原生
    Linux 文件系统，如 Ext4 和 XFS，都是在考虑到这些细微差别的情况下设计的。由于实现上的差异，非原生文件系统如 FAT 和 NTFS 并不支持所有
    VFS 操作。Linux 中的 VFS 使用 inode、超级块和目录项等结构来表示文件系统的通用视图。非原生 Linux 文件系统并不使用这些结构。那么，Linux
    是如何适配这些文件系统的呢？以 FAT 文件系统为例，FAT 文件系统来源于不同的世界，并未使用这些结构来表示文件和目录。它不会将目录视为文件。那么，VFS
    是如何与 FAT 文件系统交互的呢？
- en: All filesystem-related operations in the kernel are firmly integrated with the
    VFS data structures. To accommodate non-native filesystems on Linux, the kernel
    constructs the corresponding data structures dynamically. For instance, to satisfy
    the common file model for filesystems such as FAT, files corresponding to directories
    will be created in memory on the fly. These *files* are *virtual* and will only
    exist in memory. This is an important concept to understand. On native filesystems,
    structures such as inodes and superblocks are not only present in memory but also
    stored on the physical medium itself. Conversely, non-Linux filesystems merely
    have to perform the enactment of such structures in memory.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 内核中与文件系统相关的所有操作都与 VFS 数据结构紧密集成。为了支持 Linux 上的非原生文件系统，内核动态构建相应的数据结构。例如，为了满足 FAT
    等文件系统的通用文件模型，将在内存中动态创建对应于目录的文件。这些*文件*是*虚拟的*，只存在于内存中。这是一个需要理解的重要概念。在原生文件系统中，像 inode
    和超级块这样的结构不仅存在于内存中，还存储在物理介质上。相反，非 Linux 文件系统只需要在内存中执行这些结构的实现。
- en: Peeking at the source code
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看源代码
- en: 'If we take a look at the kernel source code, the different functions provided
    by the VFS are present in the `fs` directory. All source files ending in `.c`
    contain implementations of the different VFS methods. The subdirectories contain
    specific filesystem implementations, as shown in *Figure 1**.5*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看内核源代码，可以看到 VFS 提供的不同函数都在 `fs` 目录下。所有以 `.c` 结尾的源文件都包含了不同 VFS 方法的实现。子目录包含特定文件系统的实现，如*图
    1.5*所示：
- en: '![Figure 1.5 – The source for kernel 5.19.9](img/B19430_01_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 内核 5.19.9 的源代码](img/B19430_01_05.jpg)'
- en: Figure 1.5 – The source for kernel 5.19.9
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 内核 5.19.9 的源代码
- en: You’ll notice source files such as `open.c` and `read_write.c`, which are the
    functions invoked when a user space process generates `open ()`, `read ()`, and
    `write ()` system calls. These files contain a lot of code, and since we won’t
    create any new code here, this is merely a poking exercise. Nevertheless, there
    are a few important pieces of code in these files that highlight what we explained
    earlier. Let’s take a quick peek at the read and write functions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到诸如 `open.c` 和 `read_write.c` 这样的源文件，这些文件是在用户空间进程生成 `open ()`、`read ()`
    和 `write ()` 系统调用时被调用的。这些文件包含了大量的代码，鉴于我们在这里不会创建任何新代码，这仅仅是一次探索练习。不过，这些文件中确实有几段重要的代码，突显了我们之前所讲解的内容。让我们快速看一下
    `read` 和 `write` 函数。
- en: The `SYSCALL_DEFINE3` macro is the standard way to define a system call and
    takes the name of the system call as one of the parameters.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`SYSCALL_DEFINE3` 宏是定义系统调用的标准方法，接收系统调用名称作为参数之一。'
- en: 'For the `write` system call, this definition looks as follows. Note that one
    of the parameters is the file descriptor:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `write` 系统调用，其定义如下。请注意，参数之一是文件描述符：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Similarly, this is the definition for the `read` system call:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，这是 `read` 系统调用的定义：
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Both call the `ksys_write ()` and `ksys_read ()` functions. Let’s see the code
    for these two functions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都调用了 `ksys_write ()` 和 `ksys_read ()` 函数。我们来看一下这两个函数的代码：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The presence of the `vfs_read ()` and `vfs_write ()` functions indicates that
    we’re transitioning to the VFS. These functions look up the `file_operations`
    structure for the underlying filesystem and invoke the appropriate `read ()` and
    `write ()` methods:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`vfs_read ()` 和 `vfs_write ()` 函数的存在表明我们正在过渡到 VFS。这些函数查找底层文件系统的 `file_operations`
    结构，并调用适当的 `read ()` 和 `write ()` 方法：'
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Each filesystem defines the `file_operations` structure of pointers for supporting
    operations. There are multiple definitions of the `file_operations` structure
    in the kernel source code, unique to each filesystem. The operations defined in
    this structure describe how read or write functions will be performed:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件系统定义了支持操作的 `file_operations` 结构体。内核源代码中有多个 `file_operations` 结构体的定义，每个文件系统都有独特的定义。该结构体中定义的操作描述了读写函数如何执行：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[The rest of the code is skipped for brevity.]'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[其余代码因简洁性省略。]'
- en: As you can see, the `file_operations` structure is used for a wide range of
    file types, including regular files, directories, device files, and network sockets.
    In general, any type of file that can be opened and manipulated using standard
    file I/O operations can be covered by this structure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`file_operations` 结构体适用于各种文件类型，包括常规文件、目录、设备文件和网络套接字。一般来说，任何可以使用标准文件 I/O
    操作打开和操作的文件类型，都可以通过此结构体来处理。
- en: Tracing VFS functions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪 VFS 函数
- en: 'There are quite a few tracing mechanisms available in Linux that can offer
    a glance at how things work under the hood. One of them is the `funccount`. As
    the name suggests, `funccount` counts the number of function calls:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 提供了相当多的跟踪机制，可以让我们窥见其底层工作原理。其中之一是 `funccount`。顾名思义，`funccount` 用于计算函数调用的次数：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Just to test and verify our understanding of what we stated earlier, we’re
    going to run a simple copy process in the background and use the `funccount` program
    to trace the VFS functions that are invoked as a result of the `cp` command. As
    we’re going to count the VFS calls for the `cp` process only, we need to use the
    `-p` flag to specify a process ID. The `vfs_*` parameter will trace all the VFS
    functions for the process. You’ll see that the `vfs_read ()` and `vfs_write ()`
    functions are invoked by the `cp` process. The `COUNT` column specifies the number
    of times the function was called:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试和验证我们之前的理解，我们将在后台运行一个简单的复制进程，并使用 `funccount` 程序跟踪由于执行 `cp` 命令而调用的 VFS 函数。由于我们只需要计算
    `cp` 进程的 VFS 调用次数，因此需要使用 `-p` 标志来指定进程 ID。`vfs_*` 参数将跟踪该进程的所有 VFS 函数。你会看到 `vfs_read
    ()` 和 `vfs_write ()` 函数是由 `cp` 进程调用的。`COUNT` 列显示该函数被调用的次数：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s run this again and see what system calls are used when doing a simple
    copy operation. As expected, the most frequently used system calls when doing
    `cp` are read and write:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再运行一次，看看在执行简单的复制操作时使用了哪些系统调用。正如预期的那样，在执行 `cp` 时最常用的系统调用是 `read` 和 `write`：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let’s summarize what we covered in this section. Linux offers support for a
    wide range of filesystems, and the VFS layer in the kernel ensures that this can
    be achieved without any hassle. The VFS provides a standardized way for end user
    processes to interact with the different filesystems. This standardization is
    achieved by implementing a common file mode. The VFS defines several virtual functions
    for common file operations. As a result of this approach, applications can universally
    perform regular file operations. When a process generates a system call, the VFS
    will redirect these calls to the appropriate function of the filesystem.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本节内容。Linux支持多种文件系统，内核中的VFS层确保了这一目标能够轻松实现。VFS为终端用户进程与不同的文件系统交互提供了标准化的方法。这一标准化是通过实现通用文件模式来实现的。VFS定义了多个虚拟函数来执行常见的文件操作。由于这种方法，应用程序可以普遍地执行常规文件操作。当一个进程发出系统调用时，VFS会将这些调用重定向到相应的文件系统函数。
- en: Explaining the Everything is a file philosophy
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释“一切皆文件”哲学
- en: 'In Linux, all of the following are considered files:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，以下所有内容都被视为文件：
- en: Directories
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录
- en: Disk drives and their partitions
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘驱动器及其分区
- en: Sockets
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字
- en: Pipes
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: CD-ROM
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光盘
- en: The phrase *everything is a file* implies that all the preceding entities in
    Linux are represented by file descriptors, abstracted over the VFS. You could
    also say that *everything has a file descriptor*, but let’s not indulge in that
    debate.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*一切皆文件*这一说法意味着，Linux中的所有上述实体都通过文件描述符表示，并通过VFS进行了抽象。你也可以说*一切都有文件描述符*，不过我们不在此展开这个辩论。'
- en: The *everything is a file* ideology that characterizes the architecture of a
    Linux system is also implemented courtesy of the VFS. Earlier, we defined pseudo
    filesystems as filesystems that generate their content on the fly. These filesystems
    are also referred to as VFSes and play a major role in implementing this concept.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 特征化Linux系统架构的*一切皆文件*理念也得益于VFS的实现。之前我们定义了伪文件系统，它们是动态生成内容的文件系统。这些文件系统也被称为VFS，并在实现这一理念中发挥了重要作用。
- en: 'You can retrieve the list of filesystems currently registered with the kernel
    through the `procfs` pseudo filesystem. When seeing this list, note `nodev` in
    the first column against some filesystems. `nodev` indicates that this is a pseudo
    filesystem and is not backed by a block device. Filesystems such as Ext2, 3, and
    4 are created on a block device; hence, they do not have the `nodev` entry in
    the first column:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`procfs`伪文件系统获取当前已注册到内核的文件系统列表。在查看这个列表时，注意第一列中有些文件系统会标记为`nodev`。`nodev`表示这是一个伪文件系统，不依赖于块设备。像Ext2、3、4这样的文件系统是基于块设备创建的，因此它们在第一列中没有`nodev`标记：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[The rest of the code is skipped for brevity.]'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[其余代码省略以简化内容。]'
- en: 'You can also use the `mount` command to find out about the currently mounted
    pseudo filesystems in your system:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`mount`命令来查看当前系统中已挂载的伪文件系统：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[The rest of the code is skipped for brevity.]'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[其余代码省略以简化内容。]'
- en: 'Let’s take a tour of the `/proc` directory. You’ll see a long list of numbered
    directories; these numbers represent the IDs of all the processes that currently
    run on your system:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来浏览一下`/proc`目录。你会看到一长串编号的目录；这些数字代表了系统中当前运行的所有进程的ID：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[The rest of the code is skipped for brevity.]'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[其余代码省略以简化内容。]'
- en: 'The `procfs` filesystem offers us a glimpse into the running state of the kernel.
    The content in `/proc` is generated when we want to view this information. This
    information is not persistently present on your disk drive. This all happens in
    memory. As you can see from the `ls` command, the size of `/proc` on disk is zero
    bytes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`procfs`文件系统让我们得以窥见内核的运行状态。`/proc`中的内容是在我们查看时生成的。这些信息并不是持久保存在你的磁盘上的，所有这一切都发生在内存中。正如你从`ls`命令中看到的那样，`/proc`在磁盘上的大小为零字节：'
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`/proc` provides an on-the-spot view of the processes running on the system.
    Consider the `/proc/cpuinfo` file. This file displays the processor-related information
    for your system. If we check this file, it will be shown as `empty`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc`提供了一个实时视图，展示了系统中正在运行的进程。考虑一下`/proc/cpuinfo`文件。这个文件显示了与你系统相关的处理器信息。如果我们检查这个文件，它会显示为`empty`：'
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, when the file contents are viewed through `cat`, they show a lot of
    information:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当通过`cat`查看文件内容时，会显示大量信息：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[The rest of the code is skipped for brevity.]'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[其余代码省略以简化内容。]'
- en: 'Linux abstracts all entities such as processes, directories, network sockets,
    and storage devices into the VFS. Through the VFS, we can retrieve information
    from the kernel. Most Linux distributions offer a variety of tools for monitoring
    the consumption of storage, compute, and memory resources. All these tools gather
    stats for various metrics through the data available in `procfs`. For instance,
    the `mpstat` command, which provides stats about all the processors in a system,
    retrieves data from the `/proc/stat` file. It then presents this data in a human-readable
    format for a better understanding:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Linux将所有实体（如进程、目录、网络套接字和存储设备）抽象为VFS（虚拟文件系统）。通过VFS，我们可以从内核中获取信息。大多数Linux发行版提供多种工具来监控存储、计算和内存资源的消耗。所有这些工具通过`procfs`中的数据收集各种指标的统计信息。例如，`mpstat`命令提供关于系统中所有处理器的统计信息，它从`/proc/stat`文件中获取数据，然后以人类可读的格式呈现这些数据，便于理解：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[The rest of the code is skipped for brevity.]'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[为了简洁，省略了其余的代码。]'
- en: 'If we use the `strace` utility on the `mpstat` command, it will show that under
    the hood, `mpstat` uses the `/proc/stat` file to display processor stats:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`mpstat`命令上使用`strace`工具，它将显示在后台，`mpstat`使用`/proc/stat`文件来显示处理器统计信息：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, popular commands such as `top`, `ps`, and `free` gather memory-related
    information from the `/``proc/meminfo` file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，常用命令如`top`、`ps`和`free`会从`/proc/meminfo`文件中收集与内存相关的信息：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similar to `/proc`, another commonly used pseudo filesystem is `/sys`. The
    **sysfs filesystem** mostly contains information about hardware devices on your
    system. For example, to find information about the disk drive in your system,
    such as its model, you can issue the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`/proc`，另一个常用的伪文件系统是`/sys`。**sysfs文件系统**主要包含关于系统硬件设备的信息。例如，要查找系统中磁盘驱动器的信息，如其型号，可以执行以下命令：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Even LEDs on a keyboard have a corresponding file in `/sys`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是键盘上的LED灯也有一个对应的文件在`/sys`中：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The *everything is a file* philosophy is one of the defining features of the
    Linux kernel. It signifies that everything in a system, including regular text
    files, directories, and devices, can be abstracted over the VFS layer in the kernel.
    As a result, all these entities can be represented as file-like objects through
    the VFS layer. There are several pseudo filesystems in Linux that contain information
    about the different kernel subsystems. The content of these pseudo filesystems
    is only present in memory and generated dynamically.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*一切皆文件*的哲学是Linux内核的一个定义性特征。它意味着系统中的一切，包括常规文本文件、目录和设备，都可以通过内核中的VFS层进行抽象。因此，所有这些实体都可以通过VFS层表示为类似文件的对象。Linux中有几个伪文件系统，包含有关不同内核子系统的信息。这些伪文件系统的内容仅存在于内存中，并动态生成。'
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The Linux storage stack is a complex design and consists of multiple layers,
    all of which work in coordination. Like other hardware resources, storage lies
    in the kernel space. When a user space program wants to access any of these resources,
    it has to invoke a system call. The system call interface in Linux allows user
    space programs to access resources in the kernel space. When a user space program
    wants to access something on the disk, the first component it interacts with is
    the VFS subsystem. The VFS provides an abstraction of filesystem-related interfaces
    and is responsible for accommodating multiple filesystems in the kernel. Through
    its common filesystem interface, the VFS intercepts the generic system calls (such
    as `read()` and `write()`) from the user space programs and redirects them to
    their appropriate interfaces in the filesystem layer. Because of this approach,
    the user space programs do not need to worry about the underlying filesystems
    being used, and they can uniformly perform filesystem operations.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Linux存储栈是一个复杂的设计，由多个层次组成，所有这些层次都协同工作。像其他硬件资源一样，存储位于内核空间。当用户空间程序想要访问这些资源时，它必须调用系统调用。Linux中的系统调用接口允许用户空间程序访问内核空间中的资源。当用户空间程序想要访问磁盘上的内容时，它首先与VFS子系统交互。VFS提供文件系统相关接口的抽象，并负责在内核中容纳多个文件系统。通过其通用文件系统接口，VFS拦截来自用户空间程序的通用系统调用（如`read()`和`write()`），并将它们重定向到文件系统层中的适当接口。由于这种方式，用户空间程序无需关心底层使用的文件系统，它们可以统一地执行文件系统操作。
- en: This chapter served as an introduction to the major Linux kernel subsystem Virtual
    Filesystem and its primary functions in the Linux kernel. The VFS provides a common
    interface for all filesystems through data structures, such as inodes, superblocks,
    and directory entries. In the next chapter, we will take a look at these data
    structures and explain how they all help the VFS to manage multiple filesystems.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本章作为对主要Linux内核子系统虚拟文件系统（VFS）的介绍，讲解了其在Linux内核中的主要功能。VFS通过数据结构，如索引节点（inode）、超级块（superblock）和目录项（directory
    entries），为所有文件系统提供了一个统一的接口。在下一章，我们将深入探讨这些数据结构，并解释它们如何帮助VFS管理多个文件系统。
