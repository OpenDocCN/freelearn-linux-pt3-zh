- en: '23'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '23'
- en: Using PowerShell on Linux
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 上使用 PowerShell
- en: '**PowerShell** started its life as a closed-source, proprietary product that
    could only be installed on Windows operating systems. Now though, it’s Free Open
    Source Software, and is freely available for use on Linux-based and macOS-based
    machines.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**PowerShell** 最初是一个封闭源代码的专有产品，只能安装在 Windows 操作系统上。然而现在，它是自由开源软件，并且可以在基于 Linux
    和 macOS 的机器上自由使用。'
- en: I can’t give you a complete course on PowerShell in this chapter, because it’s
    something that would require an entire book. Instead, I’ll just give you a high-level
    overview of the PowerShell philosophy, show you how to install it, and provide
    some useful examples. I’ll also provide some rationale on why you, as a Linux
    or Mac administrator, might like to learn PowerShell. And of course, you’ll find
    plenty of PowerShell reference material links both throughout the chapter and
    in the *Further Reading* section.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我无法给你提供一整套 PowerShell 课程，因为这需要一本完整的书籍。而是，我将提供 PowerShell 哲学的高层次概述，展示如何安装它，并提供一些有用的示例。我还会说明为什么你作为
    Linux 或 Mac 管理员，可能会想要学习 PowerShell。当然，你会在整个章节中以及 *进一步阅读* 部分找到许多 PowerShell 参考资料的链接。
- en: 'Topics in this chapter include:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题包括：
- en: Installing PowerShell on Linux and macOS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 和 macOS 上安装 PowerShell
- en: Reasons for Linux and Mac Admins to Learn PowerShell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 和 Mac 管理员学习 PowerShell 的原因
- en: Differences Between PowerShell Scripting and Traditional Linux/Unix Scripting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 脚本与传统 Linux/Unix 脚本的区别
- en: Viewing the Available PowerShell Commands
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看可用的 PowerShell 命令
- en: Getting Help with PowerShell Commands
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 PowerShell 命令的帮助
- en: Real-World Cross-Platform PowerShell Scripts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际跨平台 PowerShell 脚本
- en: If you’re ready, let’s get started.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你准备好了，我们开始吧。
- en: Technical Requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can use a Fedora, Ubuntu, or Debian virtual machine for this. You won’t
    be using your FreeBSD or OpenIndiana virtual machines, because PowerShell isn’t
    available for them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Fedora、Ubuntu 或 Debian 虚拟机进行操作。你不会使用 FreeBSD 或 OpenIndiana 虚拟机，因为 PowerShell
    不支持这些操作系统。
- en: 'As always, you can grab the scripts by doing:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，你可以通过以下方式获取脚本：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing PowerShell on Linux and macOS
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 和 macOS 上安装 PowerShell
- en: We’ll first look at the methods for installing PowerShell on Linux, and then
    look at how to install it on macOS.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看在 Linux 上安装 PowerShell 的方法，然后再看看如何在 macOS 上安装它。
- en: Installing PowerShell on Linux via a snap Package
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 snap 包在 Linux 上安装 PowerShell
- en: The `snapd` system is a universal software packaging system that was invented
    by the developers of Ubuntu. It comes installed by default on Ubuntu operating
    systems, and can be installed on most other Linux distros.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`snapd` 系统是一个通用的软件打包系统，由 Ubuntu 的开发者发明。它在 Ubuntu 操作系统中默认安装，并且可以安装在大多数其他 Linux
    发行版上。'
- en: 'If you’re setting up a new Ubuntu Server, you can choose to install a selection
    of snap packages, including PowerShell, from the Ubuntu installer. Here’s what
    that looks like:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在设置一个新的 Ubuntu 服务器，你可以选择从 Ubuntu 安装程序中安装一些 snap 包，包括 PowerShell。如下所示：
- en: '![B21693_23_1](img/B21693_23_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_23_1](img/B21693_23_01.png)'
- en: 'Figure 23.1: Selecting the PowerShell snap package during Ubuntu installation'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23.1：在 Ubuntu 安装过程中选择 PowerShell snap 包
- en: 'You can install `snapd` on non-Ubuntu distros, but the installation instructions
    vary for different distros. You can find the installation instructions here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在非 Ubuntu 发行版上安装 `snapd`，但是不同发行版的安装说明有所不同。你可以在这里找到相关的安装说明：
- en: '[https://snapcraft.io/docs/installing-snapd](https://snapcraft.io/docs/installing-snapd)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://snapcraft.io/docs/installing-snapd](https://snapcraft.io/docs/installing-snapd)'
- en: 'Once you’ve installed `snapd`, you can install PowerShell by doing:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 `snapd` 后，你可以通过以下方式安装 PowerShell：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Installing PowerShell on Fedora
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Fedora 上安装 PowerShell
- en: 'On a Fedora system, you can use any of several methods for installing PowerShell.
    For example, you can install it either via a `.rpm` package, or via a Docker container.
    You’ll find detailed instructions for each of these methods, along with a few
    more, here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fedora 系统上，你可以使用多种方法安装 PowerShell。例如，你可以通过 `.rpm` 包或 Docker 容器来安装它。你可以在这里找到每种方法的详细说明：
- en: '[https://fedoramagazine.org/install-powershell-on-fedora-linux/](https://fedoramagazine.org/install-powershell-on-fedora-linux/)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://fedoramagazine.org/install-powershell-on-fedora-linux/](https://fedoramagazine.org/install-powershell-on-fedora-linux/)'
- en: Installing PowerShell on macOS
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 PowerShell
- en: 'You can install PowerShell on a Mac via the Homebrew system. You’ll find detailed
    instructions for that here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 Homebrew 系统在 Mac 上安装 PowerShell。你可以在这里找到详细的安装说明：
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-macos?view=powershell-7.4](https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-macos?view=powershell-7.4)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-macos?view=powershell-7.4](https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-macos?view=powershell-7.4)'
- en: Invoking PowerShell
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动 PowerShell
- en: 'Once PowerShell is installed, invoke it by entering the `pwsh` command. Your
    command-prompt will then look something like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 PowerShell 安装完成，输入 `pwsh` 命令来启动它。你的命令行界面会变成这样：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, before I show you any demos, let’s address the burning question of the
    day. Why should a Linux or Mac person such as yourself learn a scripting language
    that was invented at Microsoft?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我展示任何示范之前，我们先解决今天的燃眉之急。为什么像你这样使用 Linux 或 Mac 的人需要学习一个由微软发明的脚本语言？
- en: Reasons for Linux and Mac Admins to Learn PowerShell
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 和 Mac 管理员学习 PowerShell 的理由
- en: Scripting in PowerShell is a somewhat different experience from scripting in
    the traditional Linux and Unix shells. But, it’s not hard, and you might even
    like it once you get used to it. At any rate, there are some valid reasons why
    a Linux administrator might like to learn PowerShell. Let’s take a look at some
    of those reasons.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中编写脚本与在传统的 Linux 和 Unix shell 中编写脚本有些不同。但其实并不难，一旦习惯了，你甚至可能会喜欢它。无论如何，Linux
    管理员有一些合理的理由想要学习 PowerShell。我们来看看其中的一些原因。
- en: Working with Mixed Operating System Environments
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用混合操作系统环境
- en: The first reason is simply one of both convenience and flexibility. A lot of
    enterprises and organizations run a mixed bag of Linux and Windows servers, and
    usually run Windows on their workstations. It might be helpful if you could run
    one common scripting language across your Windows and Linux platforms. And, if
    you’re a Windows administrator who now needs to learn Linux administration, you
    might find it easier to do it with PowerShell, which you’ll likely already know.
    In fact, let me tell you a story about my own reason for learning PowerShell.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个理由仅仅是出于便利性和灵活性的考虑。许多企业和组织运行混合的 Linux 和 Windows 服务器，并且通常在工作站上运行 Windows。如果你能够在
    Windows 和 Linux 平台上使用相同的脚本语言，可能会非常有帮助。而且，如果你是 Windows 管理员，现在需要学习 Linux 管理，PowerShell
    可能会让你更容易做到，因为你可能已经掌握了它。事实上，让我告诉你我学习 PowerShell 的一个原因。
- en: Throughout the years 2010 and 2011, I worked with a client who had taken on
    the Nagios company as one of his clients. The Nagios company produces the Nagios
    network monitoring system, which can monitor pretty much every type of network
    device. (This includes servers that run either Linux or Windows, as well as various
    types of networking equipment.) My client’s job was threefold. He was to produce
    training documentation, conduct Nagios training classes, and fly around the country
    to set up Nagios monitoring systems for clients of the Nagios company.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2010 年和 2011 年这两年里，我和一个客户合作，他将 Nagios 公司作为他的客户之一。Nagios 公司生产 Nagios 网络监控系统，可以监控几乎所有类型的网络设备。（这包括运行
    Linux 或 Windows 的服务器，以及各种网络设备。）我的客户的工作分为三个部分：编写培训文档、进行 Nagios 培训课程，并飞往全国各地为 Nagios
    公司的客户设置 Nagios 监控系统。
- en: Anyway, every time my client needed to do anything with Windows servers, he
    would turn to me, because I knew Windows Server and he didn’t.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 反正，每当我的客户需要对 Windows 服务器做些什么时，他都会找我，因为我懂 Windows Server，而他不懂。
- en: Okay, I’ve been guarding a dark secret, and I hope you won’t think badly of
    me. It’s just that back in 2006, before I got involved with Linux, I obtained
    my Microsoft Certified Systems Engineer (MCSE) certification for Windows Server
    2003\. When I first got into Linux, I thought that I would never use my MSCE training.
    Boy, was I wrong.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我一直守着一个黑暗的秘密，希望你们不要对我有不好的看法。其实早在 2006 年，在我接触 Linux 之前，我已经获得了 Microsoft Certified
    Systems Engineer (MCSE) 认证，专注于 Windows Server 2003。当我第一次接触 Linux 时，我以为我再也不会用到我的
    MCSE 培训了。天啊，我错得真离谱。
- en: Unfortunately, my MCSE training didn’t include anything about PowerShell, because
    it hadn’t yet been invented. So, in order to come up with Windows Server monitoring
    solutions for my client, I had to give myself a crash course on PowerShell scripting.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我的 MCSE 培训并没有涉及 PowerShell，因为它在那时还没有被发明出来。因此，为了为我的客户提供 Windows Server 监控解决方案，我不得不自学
    PowerShell 脚本编写。
- en: The bottom line here is that if you’re involved with setting up any kind of
    network monitoring solution, even if you’re a Linux admin, learning PowerShell
    could be useful.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是，如果你参与任何类型的网络监控解决方案的设置，甚至如果你是Linux管理员，学习PowerShell也会很有用。
- en: PowerShell Commands Can Be Simpler
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PowerShell 命令可以更简洁
- en: 'The second reason is that in some cases, PowerShell is just easier to deal
    with. You’ve seen how in the traditional Linux/Unix shell languages, commands
    to perform a certain task can become quite long and convoluted. For example, let’s
    say that you want to view all of the system processes that are using 200 Megabytes
    or more of the machine’s Random Access Memory (RAM), and you want to see only
    certain fields of the output. The traditional Linux/Unix way of doing this would
    involve using the `ps` command with the proper option switches, and then piping
    the `ps` output into `awk`, like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个理由是，在某些情况下，PowerShell 更容易处理。你已经看到，在传统的 Linux/Unix shell 语言中，执行某些任务的命令可能变得很长且复杂。例如，假设你想查看所有占用200兆字节或更多机器随机存取内存（RAM）的系统进程，并且你只想看到输出的某些字段。在传统的
    Linux/Unix 方法中，你需要使用`ps`命令加上适当的选项开关，然后将`ps`输出传给`awk`，像这样：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, what’s the problem with this? Well first, you need to be familiar with
    the `ps` option switches, as well as with the various `ps` output fields. In this
    case, the `ps -e` command shows us something like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这有什么问题呢？首先，你需要熟悉`ps`的选项开关，以及各种`ps`输出字段。在这个例子中，`ps -e`命令会显示类似这样的内容：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But, that doesn’t show the `RSS` field, which contains the memory use data
    that we want to see. So, I’ll add the `O rss` option, so that the final `ps` command
    will be `ps -eO rss`. It should now show something that looks like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这并没有显示`RSS`字段，而这个字段包含了我们想要看到的内存使用数据。所以，我将添加`O rss`选项，这样最终的`ps`命令就会是`ps -eO
    rss`。现在它应该显示类似这样的内容：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The problem now is that that’s more than we want to see. Piping this output
    into `awk` will filter out all of the unwanted stuff. But, to use `awk`, you’ll
    need to know what’s in every field of the `ps` output, so that you’ll know what
    fields to list in the `awk` command. In this case, we want to see the `PID`, `RSS`,
    and `COMMAND` fields, which are fields 1, 2, and 6\. We want to see all processes
    for which field 2 has a number that’s greater than 200 Megabytes, which we’re
    expressing here as `(1024*200)`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，这比我们想要看到的要多。将这个输出传给`awk`，可以过滤掉所有不需要的内容。但为了使用`awk`，你需要知道`ps`输出的每一列是什么，以便知道在`awk`命令中列出哪些字段。在这个例子中，我们想看到`PID`、`RSS`和`COMMAND`字段，它们分别是第1列、第2列和第6列。我们想查看所有第2列大于200兆字节的进程，在这里我们将其表示为`(1024*200)`。
- en: Remember that the true definition of a Megabytes is 1024 Kilobytes. Since `awk`
    doesn’t understand measurements in Bytes, Kilobytes, Megabytes, and so forth,
    you’ll have to express your memory measurements as either a math formula or a
    normal integer. (The integer product of 1024*200 is 204800.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，兆字节的真正定义是1024千字节。由于`awk`无法理解字节、千字节、兆字节等单位，你必须将内存测量表达为数学公式或正常整数。（1024*200的整数结果是204800。）
- en: Finally, the `printf` command will print out just the fields that we want to
    see, with the proper formatting options.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`printf`命令会按照正确的格式选项打印出我们想要查看的字段。
- en: Okay, that’s doable. But, can we simplify that with PowerShell? Let’s see.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是可行的。但是，我们能用 PowerShell 简化一下吗？让我们看看。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Yeah, I’m thinking that that’s a lot easier. It’s a lot shorter, which will
    make it less prone to error. The only field name you need to know is the `WorkingSet
    (WS)` field, which is equivalent to the `RSS` field in `ps`. Also, you see that
    we can pipe the output of one command (`Get-Process`) into another command (`Where-Object`),
    similarly to how we pipe the output of a Linux/Unix utility into another one.
    The best part is that this command is so intuitive, that I think you can figure
    out what it’s doing without me even explaining it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我觉得这样更简单了。它更简短，这样也不容易出错。你只需要知道`WorkingSet (WS)`字段，它相当于`ps`中的`RSS`字段。此外，你可以看到，我们可以将一个命令（`Get-Process`）的输出传递给另一个命令（`Where-Object`），就像我们在Linux/Unix中将一个工具的输出传给另一个工具一样。最棒的是，这个命令非常直观，我认为即使我不解释，你也能理解它在做什么。
- en: All right, let’s move on to the next reason for learning PowerShell.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续学习 PowerShell 的下一个理由。
- en: Enhanced Builtin Math Capabilities
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强的内建数学功能
- en: If you need to create scripts that are heavy on math, PowerShell might be just
    what you need. You can do floating point math without loading any external program,
    and a function library is available for advanced math functions. Let’s look at
    some examples.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要创建大量数学计算的脚本，PowerShell可能正是你需要的。你可以在不加载任何外部程序的情况下进行浮点数学运算，并且提供了一个函数库来支持高级数学函数。让我们看一些例子。
- en: 'First, let’s do a simple division operation, like so:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们做一个简单的除法操作，像这样：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you see, PowerShell does floating point math by default, without having
    to invoke any special tricks. Now, let’s put some different math problems into
    the `math1.ps1` script, which looks like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，PowerShell默认进行浮点数学运算，不需要调用任何特殊技巧。现在，让我们在`math1.ps1`脚本中加入一些不同的数学题目，它看起来是这样的：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first thing to note here is the `param` line at the top. This is the directive
    that creates the positional parameters that I’ll use to pass arguments into the
    script. Instead of using `$1` and `$2` as positional parameters, I’m using `param`
    to create the `$number1` and `$number2` positional parameters. Note how I need
    to create both positional parameters with just one `param` directive. If I use
    two separate `param` lines, the script will error out, because it won’t recognize
    the second `param` line. Also, I’ve specified that the `number1` and `number2`
    variables that I’m using for the positional parameters will be of the floating
    point number type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里首先要注意的是顶部的`param`行。这是用来创建位置参数的指令，我将用它将参数传递到脚本中。我没有使用`$1`和`$2`作为位置参数，而是用`param`来创建`$number1`和`$number2`的位置参数。注意我只用一个`param`指令就创建了这两个位置参数。如果我使用两个单独的`param`行，脚本会出错，因为它无法识别第二行`param`。另外，我已经指定了`number1`和`number2`这两个用于位置参数的变量类型是浮点数。
- en: 'The rest of the script is a straightforward demonstration of how to do addition,
    division, multiplication, and modulo operations. Instead of using `echo` or `printf`
    statements, I’m using PowerShell’s native `Write-Host` command. Also, note how
    variable names will always be preceded by a `$`, whether you’re defining them
    or calling back their values. Now, let’s run the script with 5 and 2 as our arguments:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的脚本是一个简单的演示，展示如何进行加法、除法、乘法和取模操作。我没有使用`echo`或`printf`语句，而是使用了PowerShell的本地命令`Write-Host`。另外，请注意，无论是定义变量还是调用其值，变量名前面都会加上`$`符号。现在，让我们使用5和2作为参数来运行脚本：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Easy enough, right? Well, doing more advanced math in PowerShell is just as
    easy. To demonstrate, let’s create the `math2.ps1` script, like so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 够简单吧？好吧，在PowerShell中做更复杂的数学计算也同样容易。为了演示，我们创建`math2.ps1`脚本，如下所示：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, you see how I’m using the `[math]::` construct to call in the functions
    that calculate the tangent, cosine, square root, and logarithm of my specified
    number. The only slight catch is that the tangent and cosine functions work with
    radians by default. To make it work with degrees, I had to divide the number of
    degrees that I input by 180, and then multiply that by the value of pi (π).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我如何使用`[math]::`结构来调用计算正切、余弦、平方根和对数的函数。唯一的小问题是，正切和余弦函数默认使用弧度。如果想用角度来计算，我需要将输入的度数除以180，然后再乘以π的值。
- en: 'Now, let’s run this with 45 as my argument:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用45作为参数运行这个脚本：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Oh yeah, looking good.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，太好了，效果不错。
- en: 'You can read more about PowerShell math, including a more complete list of
    its math functions, here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里阅读更多关于PowerShell数学的内容，包括它的数学函数的完整列表：[https://ss64.com/ps/syntax-math.html](https://ss64.com/ps/syntax-math.html)
- en: '[https://ss64.com/ps/syntax-math.html](https://ss64.com/ps/syntax-math.html)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://ss64.com/ps/syntax-math.html](https://ss64.com/ps/syntax-math.html)'
- en: Next, let’s look at some fundamental differences between PowerShell and the
    more traditional shells.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看PowerShell与传统Shell的一些基本区别。
- en: Differences Between PowerShell Scripting and Traditional Linux/Unix Scripting
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell脚本与传统Linux/Unix脚本的区别
- en: PowerShell still uses many of the same programming constructs as other scripting
    languages use, such as functions, loops, `if` constructs, and so forth. But, as
    you’ve already seen there are also some differences in the basic design of PowerShell
    that set it apart from traditional Linux/Unix shell scripting. Let’s look at a
    few examples.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell仍然使用许多与其他脚本语言相同的编程结构，如函数、循环、`if`结构等。不过，正如你已经看到的，PowerShell在基础设计上也有一些不同之处，使其与传统的Linux/Unix
    Shell脚本有所区别。让我们来看几个例子。
- en: Using Filename Extensions and the Executable Permission
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文件名扩展名和可执行权限
- en: Throughout this book, you’ve seen me create normal Linux/Unix scripts with the
    `.sh` extensions on their filenames. In reality, you don’t have to use any filename
    extension on normal Linux/Unix scripts. This means that the `somescript.sh` script
    would work just as well if the its filename were just `somescript`. With PowerShell,
    the `.ps1` filename extension is mandatory for all PowerShell scripts. Without
    it, your PowerShell script just won’t run.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你看到我创建了带有 `.sh` 扩展名的普通 Linux/Unix 脚本。实际上，在普通的 Linux/Unix 脚本中你不必使用任何文件扩展名。这意味着
    `somescript.sh` 脚本只要文件名为 `somescript` 也能正常工作。但是对于 PowerShell 脚本，`.ps1` 扩展名对所有
    PowerShell 脚本都是必需的。没有这个扩展名，你的 PowerShell 脚本将无法运行。
- en: On the other hand, it’s not necessary to set the executable permission on PowerShell
    scripts, as it is for traditional Linux/Unix scripts. As long as the script file
    has `.ps1` at the end of its filename, and as long as you’re in the PowerShell
    environment, the script will run.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，不必像传统的 Linux/Unix 脚本那样设置 PowerShell 脚本的可执行权限。只要脚本文件名以 `.ps1` 结尾，并且你在 PowerShell
    环境中，脚本就会运行。
- en: PowerShell is Object-oriented
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PowerShell 是面向对象的
- en: The traditional Linux and Unix shell scripting languages are strictly **procedural
    languages**. This means that the commands in the program or script that you create
    will work on data from some external source.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 Linux 和 Unix shell 脚本语言是严格的**过程式语言**。这意味着你创建的程序或脚本中的命令将处理来自某些外部来源的数据。
- en: That source could be the keyboard, a file, a database, or even a *here* document
    that’s embedded within the script or program. Understand that the data and the
    commands that work on them are completely separate entities.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些源可以是键盘、文件、数据库，甚至是嵌入在脚本或程序中的*here*文档。请理解数据和处理数据的命令是完全独立的实体。
- en: With **object-oriented programming**, which you’ll sometimes see referred to
    as **OOP**, the data and the procedures that operate on the data are packaged
    together in an **object**. This allows you to do cool things, like telling a numerical
    object to double itself. It also allows you to create other objects that inherit
    characteristics from their parent objects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在**面向对象编程**中，有时会看到称为**OOP**的东西，数据和操作数据的过程被打包在一个**对象**中。这使你能够做一些很酷的事情，比如告诉一个数值对象将自己加倍。它还允许你创建从其父对象继承特性的其他对象。
- en: I know that this is a simplified explanation of object-oriented programming.
    But, a detailed explanation is way beyond the scope of this book. Of course, if
    you’ve ever programmed in languages like C++ or Java, you’ll know what I’m talking
    about.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这只是面向对象编程的简化解释。但是，详细的解释超出了本书的范围。当然，如果你曾经在像 C++ 或 Java 这样的语言中编程过，你会明白我在说什么。
- en: PowerShell Uses Cmdlets
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PowerShell 使用命令 Cmdlets
- en: Most PowerShell commands are actually referred to as **Cmdlets**, which you’ll
    pronounce as *command-lets*, while others are either aliases or functions. Each
    Cmdlet takes the form of a verb and a noun separated by a hyphen, such as `Get-Content`,
    which gets (reads) from a file, or `Set-Content`, which writes to a file. The
    way this works on Windows machines is that every Windows subsystem has its own
    set of Cmdlets. For example, a Windows machine that acts as a **Domain Name System**
    (**DNS**) server would have a set of Cmdlets to work with DNS, and a **Microsoft
    Exchange** server would have Cmdlets for working with Exchange.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 PowerShell 命令实际上被称为**Cmdlets**，你会发音为*command-lets*，而其他一些则是别名或函数。每个 Cmdlet
    的形式为由连字符分隔的动词和名词，例如 `Get-Content` 用于从文件获取（读取），或者 `Set-Content` 用于向文件写入。在 Windows
    机器上的工作方式是每个 Windows 子系统都有自己的一组 Cmdlets。例如，作为**域名系统**（**DNS**）服务器的 Windows 机器会有一组用于处理
    DNS 的 Cmdlets，而**Microsoft Exchange**服务器则会有用于处理 Exchange 的 Cmdlets。
- en: The Linux and Mac versions of PowerShell have far fewer sets of Cmdlets, because
    all of the Windows-specific stuff has been stripped out. You’ll find what you
    need to work with Linux or macOS, but nothing else.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 的 Linux 和 Mac 版本拥有较少的 Cmdlets 集合，因为所有的 Windows 特定内容都被剔除了。你会找到适用于
    Linux 或 macOS 的所需内容，但其他内容则没有了。
- en: As you see, these Cmdlets are a lot different from the commands that Linux/Unix
    admins are used to using. For that reason, you might consider using aliases to
    help ease the transition to PowerShell. Let’s check that out next.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些 Cmdlets 与 Linux/Unix 管理员习惯使用的命令有很大不同。因此，你可能考虑使用别名来帮助顺利过渡到 PowerShell。让我们接着来看看这个。
- en: Using Aliases on PowerShell
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 PowerShell 上使用别名
- en: 'On Windows machines, PowerShell has aliases already set up that allow you to
    use Linux/Unix commands in place of PowerShell commands. (Microsoft did this on
    purpose to make it easier for Linux/Unix admins to learn PowerShell.) For example,
    here’s how to list files in your current directory on PowerShell for Linux:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 机器上，PowerShell 已经设置了别名，允许你使用 Linux/Unix 命令替代 PowerShell 命令。（微软这样做是为了让
    Linux/Unix 管理员更容易学习 PowerShell。）例如，以下是如何在 PowerShell for Linux 上列出当前目录中文件的方式：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You see that the `Get-ChildItem` command does pretty much the same job as an
    `ls -l` command. On a Windows machine, there will already be a PowerShell alias
    that allows you to use the `ls` command to run the `Get-ChildItem` command. Here’s
    how that looks on one of my Windows machines:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到 `Get-ChildItem` 命令几乎与 `ls -l` 命令执行相同的工作。在 Windows 机器上，已经有一个 PowerShell
    别名允许你使用 `ls` 命令来运行 `Get-ChildItem` 命令。以下是在我其中一台 Windows 机器上的效果：
- en: '![B21693_23_2](img/B21693_23_02.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_23_2](img/B21693_23_02.png)'
- en: 'Figure 23.2: Using the ls PowerShell alias on Windows'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23.2：在 Windows 上使用 ls PowerShell 别名
- en: 'So yeah, this looks just like the `Get-ChildItem` command. But, if you open
    a PowerShell session on Linux or Mac and run the `ls` command, you won’t invoke
    the alias, because no aliases are set up by default. Instead, you’ll invoke the
    actual `ls` command from your Linux or Mac operating system. Here’s how that looks:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，是的，这看起来就像 `Get-ChildItem` 命令。但是，如果你在 Linux 或 Mac 上打开 PowerShell 会话并运行 `ls`
    命令，你不会调用别名，因为默认情况下没有设置别名。相反，你将调用来自你的 Linux 或 Mac 操作系统的实际 `ls` 命令。以下是它的效果：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You see that this looks nothing like `Get-ChildItem`. In fact, it’s just the
    normal output from your normal `ls` command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现这看起来一点也不像 `Get-ChildItem`。实际上，这只是你普通 `ls` 命令的正常输出。
- en: 'Fortunately though, you can create your own aliases on PowerShell, which can
    make typing PowerShell commands much easier. You can create aliases with either
    the `Set-Alias` or the `New-Alias` Cmdlets. Let’s first create the alias that
    will make `ls` run the `Get-ChildItem` command, using `Set-Alias`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以在 PowerShell 上创建自己的别名，这可以使得输入 PowerShell 命令更加容易。你可以使用 `Set-Alias` 或
    `New-Alias` 命令来创建别名。让我们首先创建一个别名，让 `ls` 命令运行 `Get-ChildItem` 命令，使用 `Set-Alias`：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The other way is to use `New-Alias`, like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `New-Alias`，如下所示：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Either way works equally well, but it’s only a temporary fix. Once you close
    your PowerShell session, you’ll lose the alias. To make your aliases permanent,
    you’ll need to edit your PowerShell profile file. You can find where it’s supposed
    to be by doing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式都能正常工作，但这只是一个临时修复。一旦关闭 PowerShell 会话，你将失去这个别名。要使你的别名永久生效，你需要编辑你的 PowerShell
    配置文件。你可以通过以下方式找到它的位置：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only problem is that the `.config/` directory is there, but neither the
    `powershell/` subdirectory nor the `Microsoft.PowerShell_profile.ps1` file is.
    So, you’ll need to create them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是 `.config/` 目录是存在的，但 `powershell/` 子目录和 `Microsoft.PowerShell_profile.ps1`
    文件都不在。因此，你需要创建它们。
- en: 'You can just use your normal Linux/Mac command to create the `powershell/`
    subdirectory, like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样使用你的正常 Linux/Mac 命令来创建 `powershell/` 子目录：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, use your favorite text editor to create the `Microsoft.PowerShell_profile.ps1`
    file within that new `powershell/` subdirectory. Add this line to create the `ls`
    to `Get-ChildItem` alias:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用你喜欢的文本编辑器在新的 `powershell/` 子目录中创建 `Microsoft.PowerShell_profile.ps1` 文件。添加以下行以创建
    `ls` 到 `Get-ChildItem` 的别名：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can add as many aliases to this file as you like. Just remember to log out
    of your PowerShell session, and then log back in to ensure that the new profile
    takes effect.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个文件中添加任意多个别名。只需记得退出你的 PowerShell 会话，然后重新登录以确保新配置文件生效。
- en: '**Important**: If you intend to create PowerShell scripts that will run on
    multiple machines, be aware that the aliases that you’ve created might not be
    available on some of them. Your best bet in that case will be to forget about
    using your own aliases, and just use the native PowerShell commands.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**：如果你打算创建在多台机器上运行的 PowerShell 脚本，请注意你创建的别名可能不会在某些机器上可用。在这种情况下，你最好放弃使用自己的别名，而是直接使用原生的
    PowerShell 命令。'
- en: Next, let’s see how to view the available PowerShell Commands.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何查看可用的 PowerShell 命令。
- en: Viewing the Available PowerShell Commands
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看可用的 PowerShell 命令
- en: 'To see what commands are available to you, just do:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的命令，只需执行：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Under `CommandType`, you see that we have aliases, functions, and Cmdlets. Under
    the `Source` column, you see the letter `M`, which means that these commands are
    all stored in some PowerShell module.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CommandType` 下，你会看到别名、函数和 Cmdlet。在 `Source` 列下，你会看到字母 `M`，这意味着这些命令都存储在某个
    PowerShell 模块中。
- en: 'Of course, there aren’t nearly as many PowerShell commands for Linux as there
    are for Windows. To see how many there are, just do this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Linux 上的 PowerShell 命令远没有 Windows 上的多。要查看有多少个命令，只需执行以下命令：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we begin by piping the output of the `Get-Command` Cmdlet into the `Measure-Object`
    Cmdlet. The official explanation of `Measure-Object`, according to the help file,
    is that it calculates the property values of certain types of objects. In this
    case, we only want to see one of those calculations, which shows us how many commands
    there are. We’ll do that by piping the `Measure-Object` output into `Select-Object
    -Property Count`, which works the same as the Linux/Unix `wc -l` command. After
    all that, we see that there are 293 PowerShell commands available on this Linux
    machine.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先将 `Get-Command` Cmdlet 的输出通过管道传输到 `Measure-Object` Cmdlet。根据帮助文件，`Measure-Object`
    的官方解释是它计算某些类型对象的属性值。在这个例子中，我们只想查看其中的一项计算，显示有多少个命令。我们通过将 `Measure-Object` 的输出管道传输到
    `Select-Object -Property Count` 来实现这一点，它与 Linux/Unix 中的 `wc -l` 命令作用相同。经过这些操作，我们看到这台
    Linux 机器上有 293 个可用的 PowerShell 命令。
- en: 'As I’ve mentioned a few pages back in the *PowerShell Uses Cmdlets* section,
    all Cmdlets are in the *Verb-Noun* format. You can use `Get-Command` with either
    the `-Verb` or `-Noun` options to see all of the commands for a particular verb
    or noun. For example, let’s see all of the available commands for the `Date` noun:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在 *PowerShell 使用 Cmdlets* 部分中提到的，所有 Cmdlet 都是 *动词-名词* 格式。你可以使用 `Get-Command`，并结合
    `-Verb` 或 `-Noun` 选项，查看某个特定动词或名词的所有命令。例如，让我们查看与 `Date` 名词相关的所有可用命令：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We see that there are only two Cmdlets for `Date`. Let’s see how many there
    are for the `Set` verb:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 `Date` 只有两个 Cmdlet。让我们看看 `Set` 动词有多少个：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, you’re wondering how to find out what all of these PowerShell commands
    do. Well, let’s look at that next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能在想如何找出这些 PowerShell 命令都做什么。好吧，让我们接着看。
- en: Getting Help with PowerShell Commands
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取 PowerShell 命令帮助
- en: 'This one is easy. Just use the `Get-Help` Cmdlet, followed by the name of the
    command for which you need information. For example, you can see information about
    the `Get-Module` Cmdlet like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个很简单。只需使用 `Get-Help` Cmdlet，后跟你需要了解信息的命令名称。例如，你可以这样查看 `Get-Module` Cmdlet 的信息：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What you’ll see will resemble a normal Linux/Unix man page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到的将类似于普通的 Linux/Unix 手册页。
- en: 'At the bottom of every `Get-Help` screen, you’ll see commands that will show
    you how to see even more information. For example, if you need to see examples
    of how to use the `Get-Module` Cmdlet, do this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 `Get-Help` 屏幕的底部，你会看到一些命令，告诉你如何查看更多的信息。例如，如果你需要查看如何使用 `Get-Module` Cmdlet
    的示例，可以这样做：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Sometimes, the help page for the command that you need to learn about isn’t
    available. In those cases, either run the `Update-Help` Cmdlet, or append the
    `-Online` option to the end of your `Get-Help` command.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要学习的命令的帮助页面可能不可用。在这种情况下，可以运行 `Update-Help` Cmdlet，或者将 `-Online` 选项附加到
    `Get-Help` 命令的末尾。
- en: 'Another great resource is the PowerShell Commands page, which you can find
    here: [https://ss64.com/ps/](https://ss64.com/ps/)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的资源是 PowerShell 命令页面，你可以在这里找到：[https://ss64.com/ps/](https://ss64.com/ps/)
- en: (Of course, a lot of the listed commands are Windows-specific, but you’ll also
    find quite a few that are cross-platform.)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: （当然，很多列出的命令是 Windows 专用的，但你也会发现不少是跨平台的。）
- en: Okay, I think that this does it for the PowerShell theory. Let’s look at a couple
    of real-world examples of PowerShell scripts.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想这就足够解释 PowerShell 的理论了。让我们来看几个实际的 PowerShell 脚本示例。
- en: Real-World Cross-Platform PowerShell Scripts
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台 PowerShell 脚本的实际应用
- en: 'To come up with some real-world examples of cross-platform PowerShell scripts,
    I did a DuckDuckGo search for the *PowerShell script examples Linux* text string.
    The coolest thing I found is the *Mega Collection of PowerShell Scripts* on Github.
    You can use `git` to download it by doing:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出一些跨平台的 PowerShell 脚本的实际应用示例，我在 DuckDuckGo 上搜索了 *PowerShell 脚本示例 Linux* 这个文本字符串。我发现的最酷的东西就是
    Github 上的 *Mega Collection of PowerShell Scripts*。你可以通过执行以下命令使用 `git` 下载它：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once it’s downloaded, `cd` into the `PowerShell/scripts/` directory, and take
    a look at what’s there. For our first example, let’s look at something simple
    that will run on all platforms.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，进入`PowerShell/scripts/`目录，看看那里面有什么。作为我们的第一个例子，让我们看一个简单的示例，它可以在所有平台上运行。
- en: The write-marquee.ps1 Script
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: write-marquee.ps1 脚本
- en: The `write-marquee.ps1` script is truly cross-platform, because it doesn’t use
    any commands that are specific to any particular operating system. All it does
    is create a marquee message that flows across on your screen. I can’t show the
    entire script here, but you can look at your own local copy. So, let’s just look
    at the individual parts of it to see how it’s set up.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`write-marquee.ps1` 脚本真正实现了跨平台，因为它没有使用任何特定于某一操作系统的命令。它所做的只是创建一个在屏幕上流动的跑马灯消息。我不能在这里展示整个脚本，但你可以查看你本地的副本。那么，让我们只看它的各个部分，看看它是如何设置的。'
- en: 'At the top, you see the comment section, which is surrounded by `<#` and `#>`.
    Actually, these are more than just comments. If you do `Get-Help ./write-marquee.ps1`,
    you’ll see that everything that’s within the `<#` and the `#>` will come up as
    a help screen, like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的顶部，你会看到注释部分，这部分被`<#`和`#>`包围。实际上，这些不仅仅是注释。如果你执行`Get-Help ./write-marquee.ps1`，你会看到`<#`和`#>`之间的所有内容会显示为帮助屏幕，像这样：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, the `param([string]$Text =` line creates the string-type variable that
    contains the marquee message. It looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`param([string]$Text =` 这一行创建了一个包含跑马灯消息的字符串类型变量。它看起来像这样：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `[int]$Speed = 60) # 60 ms pause` part at the end of the variable definition
    determines the speed at which the marquee message will flow across the screen.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '变量定义末尾的`[int]$Speed = 60) # 60 ms pause`部分决定了跑马灯消息在屏幕上流动的速度。'
- en: 'Next up is the `StartMarquee` function, which looks like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的`StartMarquee`函数是这样的：
- en: '![B21693_23_3](img/B21693_23_03.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_23_3](img/B21693_23_03.png)'
- en: 'Figure 23.3: The StartMarquee function'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图23.3：StartMarquee函数
- en: After drawing the marquee box and using `$LinePos` lines to ensure that everything
    gets properly positioned, you see the `foreach` loop that prints the message out
    to the screen, one letter at a time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制跑马灯框并使用`$LinePos`行确保所有内容正确定位后，你会看到`foreach`循环，它会一字一字地将消息打印到屏幕上。
- en: 'Finally, after the function definition, you see the function call:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在函数定义之后，你会看到函数调用：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The function call passes the `$Text` variable, which contains the marquee message,
    into the `StartMarquee` function. In between each iteration of the `$Text` message,
    there will be three plus signs (`+++`). The script will keep running until it’s
    gone through all iterations of the `$Text` message. Anyway, here’s how it looks
    when I run it on my Ubuntu Server virtual machine:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用将包含跑马灯消息的`$Text`变量传递给`StartMarquee`函数。在每次迭代之间，`$Text`消息将插入三个加号符号（`+++`）。脚本会一直运行，直到遍历完所有的`$Text`消息。无论如何，下面是我在Ubuntu
    Server虚拟机上运行时的效果：
- en: '![B21693_23_4](img/B21693_23_04.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_23_4](img/B21693_23_04.png)'
- en: 'Figure 23.4: Running the write-marquee.ps1 script'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图23.4：运行write-marquee.ps1脚本
- en: Pretty cool, eh? Now, let’s look at something that’s even more cool.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷吧？现在，让我们看看更酷的东西。
- en: The check-cpu.ps1 Script
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: check-cpu.ps1 脚本
- en: The `check-cpu.ps1` script attempts to retrieve the model number and name of
    your machine’s CPU, along with the CPU temperature.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`check-cpu.ps1` 脚本尝试检索机器CPU的型号和名称，并获取CPU温度。'
- en: If you want to see the CPU temperature, you’ll need to run this directly on
    a host Linux machine, instead of in a virtual machine. Running this in a virtual
    machine won’t allow the script to access the host machine’s temperature sensors.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看CPU温度，你需要直接在主机Linux机器上运行这个脚本，而不是在虚拟机中运行。在虚拟机中运行将无法让脚本访问主机的温度传感器。
- en: 'I say *attempt*, because when I run this script on my Fedora workstation, I
    get this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我说“尝试”，因为当我在我的Fedora工作站上运行这个脚本时，显示的结果是这样的：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So, all it shows me is that I’m running some sort of 64-bit CPU with 16 cores.
    The actual truth is that this machine is running an Intel(R) Xeon(R) CPU E5-2670,
    with eight cores and hyperthreading enabled. But, if I run this same script on
    a Windows 10 machine, I’ll get this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，它只显示我正在运行某种64位CPU，且有16个核心。实际情况是，这台机器运行的是英特尔(R) Xeon(R) CPU E5-2670，具有八个核心并启用了超线程。但是，如果我在Windows
    10机器上运行相同的脚本，我会看到这样的结果：
- en: '![B21693_23_5](img/B21693_23_05.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_23_5](img/B21693_23_05.png)'
- en: 'Figure 23.5: The check-cpu.ps1 script on a Windows machine'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图23.5：Windows机器上的check-cpu.ps1脚本
- en: On this ancient (circa 2008) Dell that’s running Windows 10 Pro, the script
    properly reports that the CPU is an old-school Core 2 Quad, model number Q9550\.
    On the other hand, the script properly reported the CPU temperature on the Linux
    machine, but not on the Windows machine. That part is easy to explain. It’s just
    that some computer motherboards, especially older ones, have temperature sensors
    that aren’t compatible with modern operating systems.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这台古老的（大约2008年的）戴尔Windows 10 Pro机器上，脚本正确地报告CPU是旧款Core 2 Quad，型号为Q9550。而另一方面，脚本在Linux机器上正确地报告了CPU温度，但在Windows机器上则没有。这个部分很容易解释。只是一些计算机主板，特别是旧的主板，带有的温度传感器不兼容现代操作系统。
- en: As far as getting the CPU model right, it seems that the PowerShell command
    for Linux can’t do that, but the command for Windows can. Let’s take a look at
    the script to see what’s going on with that.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 至于正确获取CPU型号，似乎Linux的PowerShell命令做不到这一点，而Windows的命令则可以。我们来看看脚本，看看发生了什么。
- en: 'Toward the top of the `check-cpu.ps1` script, you see the `GetCPUArchitecture`
    function, which looks like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在`check-cpu.ps1`脚本的顶部，你会看到`GetCPUArchitecture`函数，它是这样的：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you see, there’s a bit of difference in the syntax from what you’re used
    to in normal Linux/Unix scripting. One difference is that instead of surrounding
    a test condition with square brackets, PowerShell uses parentheses. Like this,
    for example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这里的语法与正常的Linux/Unix脚本有些不同。一个区别是，PowerShell用括号而不是方括号来包围测试条件。例如这样：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All this line does is to return the value of the `PROCESSOR_ARCHITECTURE` environmental
    variable, if one exists. The rest of this function is specifically for Linux,
    as evidenced by the `if (IsLinux)` stanza. You see here that it detects whether
    the CPU is x86, x86_64, or ARM. For ARM, it detects whether it’s a 32-bit or 64-bit
    version.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行的作用只是返回`PROCESSOR_ARCHITECTURE`环境变量的值，如果该变量存在的话。这个函数的其余部分专门用于Linux，正如`if
    (IsLinux)`语句块所证明的。你可以看到它在检测CPU是否为x86、x86_64或ARM。对于ARM，它会检测是32位版本还是64位版本。
- en: 'The only part of this function that Windows uses is the first line, which is
    the `if ("$env:PROCESSOR_ARCHITECTURE" -ne "") { return "$env:PROCESSOR_ARCHITECTURE"
    }` line. And, the only thing that this does on my Windows 10 machine is to insert
    the “AMD64” string into the information that you see in the above graphic. On
    Windows, all other CPU information is obtained from the **Windows Management Instrumentation**
    (**WMI**) interface. The code for that is in the `else` clause of the `try` stanza,
    which begins on line 44\. (The `else` clause begins on line 54.) Here’s how it
    looks:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中Windows使用的唯一部分是第一行，即`if ("$env:PROCESSOR_ARCHITECTURE" -ne "") { return
    "$env:PROCESSOR_ARCHITECTURE" }`这一行。而且，在我的Windows 10机器上，这行代码唯一的作用是将“AMD64”字符串插入到你在上面图形中看到的信息里。在Windows上，所有其他的CPU信息都是通过**Windows管理工具**（**WMI**）接口获取的。这部分代码位于`try`语句块的`else`分支中，从第44行开始。（`else`分支从第54行开始。）它看起来是这样的：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You see in the `if..else` construct that if the machine is running Linux, it
    will call the `GetCPUArchitecture` function, and retrieve the CPU information
    from it. In the `else` section, you see the code for Windows. Although the script
    does obtain one piece of information for Windows from the `PROCESSOR_ARCHITECTURE`
    environmental variable, it obtains most of the CPU information from the **Windows
    Management Instrumentation** (**WMI**) subsystem. As it happens, the `PROCESSOR_ARCHITECTURE`
    variable doesn’t contain any information for this particular Fedora workstation.
    So, all I get on this machine is just the generic message about whether I’m running
    a 32-bit or 64-bit machine, and whether it’s an x86 or an ARM machine. That’s
    okay though, because I can modify the script to fix that.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if..else`结构中，你可以看到如果机器运行的是Linux，它将调用`GetCPUArchitecture`函数并从中获取CPU信息。在`else`部分，你看到的是Windows的代码。尽管脚本通过`PROCESSOR_ARCHITECTURE`环境变量获取了Windows的一些信息，但大多数CPU信息是通过**Windows管理工具**（**WMI**）子系统获取的。事实上，`PROCESSOR_ARCHITECTURE`变量没有包含我这台特定Fedora工作站的任何信息。所以，在这台机器上，我只能得到一个关于我运行的是32位还是64位机器，或者是x86还是ARM机器的通用消息。虽然这样，但没关系，因为我可以修改脚本来解决这个问题。
- en: 'Open the `check-cpu.ps1` script in your editor, and scroll down until you see
    this line in the `try` stanza, which should be line 47:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中打开`check-cpu.ps1`脚本，向下滚动直到你看到`try`语句块中的这一行，它应该是第47行：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We’re going to leave that line alone, because Windows also uses the `GetCPUArchitecture`
    function. Instead, we’re going to add the following line after the `if ($IsLinux)
    {` line, which is line 48:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会保持这一行不变，因为Windows也使用`GetCPUArchitecture`函数。相反，我们将在`if ($IsLinux) {`这一行之后，即第48行，添加如下新行：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Instead of obtaining its value from the `GetCPUArchitecture` function, the `arch`
    variable now gets its value from a command substitution construct.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`arch`变量的值不是通过`GetCPUArchitecture`函数获取，而是通过命令替换构造获取。
- en: We see here a couple of other ways in which PowerShell scripting is different.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了PowerShell脚本的几个不同之处。
- en: First, anytime you work with a PowerShell variable, you need to precede the
    variable name with a `$`. This means that whether you’re defining a variable or
    calling back its value, you need that `$`. Secondly, you see that in PowerShell,
    you don’t surround the command substitution construct with `$( )`. Instead, just
    write the command as you normally would.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，每次使用PowerShell变量时，都需要在变量名之前加上`$`。这意味着无论是定义变量还是调用其值，都需要加上`$`。其次，你会看到，在PowerShell中，命令替换构造不需要用`$(
    )`括起来。相反，直接像平常那样写命令即可。
- en: Okay, let’s break this line down.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们分解这行代码。
- en: '`Get-Content`: This does the same job as the Linux/Unix `cat` command.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get-Content`：这与Linux/Unix的`cat`命令完成了相同的工作。'
- en: '`Select-String`: This does the same job as the Linux/Unix `grep` command.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select-String`：这与Linux/Unix的`grep`命令完成了相同的工作。'
- en: '`Select-Object -Unique`: This does the same job as the Linux/Unix `uniq` command.
    We need it here because my machine has 16 virtual cores, and I only want to see
    the information for one of them.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select-Object -Unique`：这与Linux/Unix的`uniq`命令完成了相同的工作。我们需要在这里使用它，因为我的机器有16个虚拟核心，而我只想看到其中一个的相关信息。'
- en: 'Running the modified script on my Fedora workstation looks like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的Fedora工作站上运行修改后的脚本是这样的：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'That’s much better, but it’s not quite perfect. I really want to get rid of
    the “model name” text string at the start of the output. So, let’s make one more
    slight edit to the script, like so:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这样好多了，但还不完全完美。我真想去掉输出开头的“model name”文本字符串。让我们再对脚本进行一次小改动，像这样：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'All I did here was to change the `$arch` to `$longarch` in the original `$arch`
    line. I’ll use that as my intermediate variable. Then, I added a new `$arch` line
    that uses the `-replace "model name\t: ", ""` command to delete the “model name”
    string, along with the following tab character, colon, and blank space. In this
    case, the `-replace` command is doing the same job as the Linux/Unix `sed` command.
    To put this into context, here’s how the relevant portion of the modified `try`
    stanza now looks:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '我在这里做的只是将原始的`$arch`行中的`$arch`改为`$longarch`。我会将这个作为我的中间变量。然后，我添加了一行新的`$arch`，使用`-replace
    "model name\t: ", ""`命令来删除“model name”字符串以及随后的制表符、冒号和空格。在这种情况下，`-replace`命令与Linux/Unix的`sed`命令完成了相同的工作。为了更好理解，这就是修改后的`try`语句块的相关部分：'
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here’s what running the new script looks like:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 运行新脚本的结果是这样的：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Perfect. This is exactly what I want to see, other than the fact that my workstation
    is running a bit hot for some reason. (Tomorrow, I’ll open it up to see if I need
    to blow out any dust bunnies.) The best part is that this is still a cross-platform
    script, because I didn’t do anything that would affect how it runs on Windows.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。这正是我想看到的，除了我的工作站似乎有点过热的原因。（明天，我会打开它，看看是否需要吹掉一些灰尘。）最棒的是，这仍然是一个跨平台脚本，因为我没有做任何可能影响它在Windows上运行的事情。
- en: Okay, I think that does it for our introduction to the mysteries of PowerShell.
    Let’s summarize and then wrap things up.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想这就是我们对PowerShell奥秘的介绍。让我们总结一下，然后结束这部分内容。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this final chapter, I’ve shown you a bit about scripting in PowerShell on
    a Linux machine. I started by showing you a bit of history, and then showed you
    the philosophy of scripting on PowerShell and how it differs from scripting in
    traditional Linux/Unix shells. You also saw the basics about how to use PowerShell
    commands, and how to obtain help for the commands. Finally, I showed you some
    real world examples of actual PowerShell scripts that work on either Windows or
    Linux. But, as I’ve said before, all I can do in just one chapter is to present
    a high-level overview of PowerShell scripting. If you need to learn more about
    it, there are plenty of resources both on-line and in books.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Oh, I almost forgot the most important thing. I also showed you some reasons
    about why you, as a Linux or Mac administrator, might want to consider scripting
    in PowerShell. Yeah, it’s different and takes a bit of getting used to. But, there
    are some definite benefits, especially if you need to work in a mixed environment
    of Linux, macOS, and Windows computers.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up not only *Chapter 23*, but also the book. Along the way, you went
    from a command-line beginner to a shell-scripting guru. Of course, you might not
    be able to remember everything off the top of your head, and that’s okay. Just
    use this book, and any other resources you can find, as ready-references if you
    ever need help in creating an awesome script.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, it’s been a long journey, but I’ve enjoyed it, and hope that you have
    as well. Take care, and maybe we’ll meet up again some time.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PowerShell Core for Linux Administrators Cookbook: [https://www.packtpub.com/en-us/product/powershell-core-for-linux-administrators-cookbook-9781789137231](https://www.packtpub.com/en-us/product/powershell-core-for-linux-administrators-cookbook-9781789137231)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I switched from bash to PowerShell, and it’s going great!: [https://www.starkandwayne.com/blog/i-switched-from-bash-to-powershell-and-its-going-great/index.html](https://www.starkandwayne.com/blog/i-switched-from-bash-to-powershell-and-its-going-great/index.html)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install PowerShell on Fedora Linux: [https://fedoramagazine.org/install-powershell-on-fedora-linux/](https://fedoramagazine.org/install-powershell-on-fedora-linux/)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell equivalents for common Linux/Bash commands: [https://mathieubuisson.github.io/powershell-linux-bash/](https://mathieubuisson.github.io/powershell-linux-bash/
    )'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bash vs. PowerShell: Comparing Scripting Shells: [https://smartscripter.com/bash-vs-powershell-choosing-the-right-scripting-shell/](https://smartscripter.com/bash-vs-powershell-choosing-the-right-scripting-shell/)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell differences on non-Windows platforms: [https://learn.microsoft.com/en-us/powershell/scripting/whats-new/unix-support?view=powershell-7.4](https://learn.microsoft.com/en-us/powershell/scripting/whats-new/unix-support?view=powershell-7.4)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell’s Equvalent to Linux’s ls -al: An In-depth Guide: [https://thelinuxcode.com/equivalent-of-linux-ls-al-in-powershell/](https://thelinuxcode.com/equivalent-of-linux-ls-al-in-powershell/)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell与Linux的ls -al等效命令：深入指南：[https://thelinuxcode.com/equivalent-of-linux-ls-al-in-powershell/](https://thelinuxcode.com/equivalent-of-linux-ls-al-in-powershell/)
- en: 'Bash vs PowerShell Cheat Sheet: [https://blog.ironmansoftware.com/daily-powershell/bash-powershell-cheatsheet/](https://blog.ironmansoftware.com/daily-powershell/bash-powershell-cheatsheet/  )'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash与PowerShell备忘单：[https://blog.ironmansoftware.com/daily-powershell/bash-powershell-cheatsheet/](https://blog.ironmansoftware.com/daily-powershell/bash-powershell-cheatsheet/)
- en: Leave a Review!
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下您的评论！
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoyed
    it! Your feedback is invaluable and helps us improve and grow. Please take a moment
    to leave an [Amazon review](https://packt.link/r/1835463576); it will only take
    a minute, but it makes a big difference for readers like you.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您购买Packt出版的这本书——我们希望您喜欢它！您的反馈至关重要，能帮助我们改进和成长。请花点时间留下一个[亚马逊评论](https://packt.link/r/1835463576)；它只需一分钟，但对像您这样的读者来说意义重大。
- en: Scan the QR code below to receive a free ebook of your choice.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描下面的二维码，获取您选择的免费电子书。
- en: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
- en: '![](img/review.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/review.png)'
- en: '![](img/New_Packt_Logo1.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/New_Packt_Logo1.png)'
- en: '[packt.com](http://packt.com)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[packt.com](http://packt.com)'
- en: Subscribe to our online digital library for full access to over 7,000 books
    and videos, as well as industry leading tools to help you plan your personal development
    and advance your career. For more information, please visit our website.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅我们的在线数字图书馆，全面访问超过7,000本书籍和视频，以及帮助您规划个人发展并推动职业发展的行业领先工具。欲了解更多信息，请访问我们的网站。
- en: Why subscribe?
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要订阅？
- en: Spend less time learning and more time coding with practical eBooks and Videos
    from over 4,000 industry professionals
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用来自4000多位行业专家的实用电子书和视频，减少学习时间，增加编程时间
- en: Improve your learning with Skill Plans built especially for you
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过为您特别设计的技能计划提升您的学习
- en: Get a free eBook or video every month
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每月免费获得一本电子书或视频
- en: Fully searchable for easy access to vital information
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全可搜索，便于访问关键信息
- en: Copy and paste, print, and bookmark content
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制、粘贴、打印和书签内容
- en: At [www.packt.com](http://www.packt.com), you can also read a collection of
    free technical articles, sign up for a range of free newsletters, and receive
    exclusive discounts and offers on Packt books and eBooks.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在[www.packt.com](http://www.packt.com)，您还可以阅读一系列免费的技术文章，注册各种免费的通讯，并获得Packt书籍和电子书的独家折扣和优惠。
- en: Other Books You May Enjoy
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他您可能喜欢的书籍
- en: 'If you enjoyed this book, you may be interested in these other books by Packt:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢这本书，您可能会对Packt出版的其他书籍感兴趣：
- en: '[![](img/9781803232225.jpg)](https://www.packtpub.com/en-in/product/linux-kernel-programming-9781803232225)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/9781803232225.jpg)](https://www.packtpub.com/en-in/product/linux-kernel-programming-9781803232225)'
- en: '**Linux Kernel Programming**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux内核编程**'
- en: Kaiwan N. Billimoria
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Kaiwan N. Billimoria
- en: 'ISBN: 9781803232225'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'ISBN: 9781803232225'
- en: Configure and build the 6.1 LTS kernel from source
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源代码配置并构建6.1 LTS内核
- en: Write high-quality modular kernel code (LKM framework) for 6.x kernels
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为6.x内核编写高质量的模块化内核代码（LKM框架）
- en: Explore modern Linux kernel architecture
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索现代Linux内核架构
- en: Get to grips with key internals details regarding memory management within the
    kernel
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握内核中关于内存管理的关键内部细节
- en: Understand and work with various dynamic kernel memory alloc/dealloc APIs
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并使用各种动态内核内存分配/释放API
- en: Discover key internals aspects regarding CPU scheduling within the kernel, including
    cgroups v2
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现关于内核中CPU调度的关键内部方面，包括cgroups v2
- en: Gain a deeper understanding of kernel concurrency issues
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更深入理解内核并发问题
- en: Learn how to work with key kernel synchronization primitives
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用关键的内核同步原语
- en: '[![](img/9781804616925.png)](https://www.packtpub.com/en-in/product/the-software-developers-guide-to-linux-9781804616925)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/9781804616925.png)](https://www.packtpub.com/en-in/product/the-software-developers-guide-to-linux-9781804616925)'
- en: '**The Software Developer’s Guide to Linux**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux软件开发人员指南**'
- en: David Cohen, Christian Sturm
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: David Cohen, Christian Sturm
- en: 'ISBN: 9781804616925'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 'ISBN: 9781804616925'
- en: Learn useful command-line tricks and tools that make software development, testing,
    and troubleshooting easy
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习有用的命令行技巧和工具，使软件开发、测试和故障排除变得轻松
- en: Understand how Linux and command line environments actually work
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Linux和命令行环境的实际工作原理
- en: Create powerful, customized tools and save thousands of lines of code with developer-centric
    Linux utilities
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建强大、定制化的工具，并通过以开发者为中心的 Linux 工具节省成千上万行代码
- en: Gain hands-on experience with Docker, SSH, and Shell scripting tasks that make
    you a more effective developer
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Docker、SSH 和 Shell 脚本任务获得实践经验，让你成为更高效的开发者
- en: Get comfortable searching logs and troubleshooting problems on Linux servers
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟练掌握在 Linux 服务器上搜索日志和排查问题
- en: Handle common command-line situations that stump other developers
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理那些让其他开发者头疼的常见命令行问题
- en: Packt is searching for authors like you
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Packt 正在寻找像你这样的作者
- en: If you’re interested in becoming an author for Packt, please visit [authors.packtpub.com](http://authors.packtpub.com)
    and apply today. We have worked with thousands of developers and tech professionals,
    just like you, to help them share their insight with the global tech community.
    You can make a general application, apply for a specific hot topic that we are
    recruiting an author for, or submit your own idea.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣成为 Packt 的作者，请访问 [authors.packtpub.com](http://authors.packtpub.com) 并立即申请。我们与成千上万的开发者和技术专业人士合作，帮助他们将自己的见解分享给全球技术社区。你可以进行通用申请，申请我们正在招聘的特定热门话题的作者，或者提交你自己的想法。
- en: Join our community on Discord!
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他读者、Linux 专家以及作者本人一起阅读本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 提问、为其他读者提供解决方案、通过问我任何问题（Ask Me Anything）环节与作者互动，等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
