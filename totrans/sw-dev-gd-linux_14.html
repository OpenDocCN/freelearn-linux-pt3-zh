<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer078">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 class="chapterTitle" id="_idParaDest-304"><span class="koboSpan" id="kobo.2.1">Version Control with Git</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.3.1">Git</span></strong><span class="koboSpan" id="kobo.4.1"> is a </span><strong class="keyWord"><span class="koboSpan" id="kobo.5.1">distributed version control system</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.7.1">DVCS</span></strong><span class="koboSpan" id="kobo.8.1">) that, over the last two decades, has become the most widely used version control </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.9.1">system in the world. </span><span class="koboSpan" id="kobo.9.2">Although it is very likely that you already know the basics of how to use Git, you might not be familiar with common command-line patterns, or some of its more rarely used (but powerful!) features. </span><span class="koboSpan" id="kobo.9.3">We’ll cover those here. </span><span class="koboSpan" id="kobo.9.4">This chapter will also give you some background knowledge so that commonly used Git terms make more sense and commonly referenced concepts are clear.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.10.1">Here’s what you’ll learn about:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">The basics of Git and distributed version control</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">First-time Git setup</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Basic Git commands</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Common Git terminology</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Two powerful and slightly more advanced Git concepts: bisecting and rebasing</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Git best practices, especially around using commit messages effectively</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Useful Git shell aliases that will save you lots of typing</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">GUI tools that you can use to interact with Git</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.19.1">Finally, the </span><em class="italic"><span class="koboSpan" id="kobo.20.1">Poor man’s GitHub</span></em><span class="koboSpan" id="kobo.21.1"> section presents a small but legitimately useful project that you can do to practice and integrate the Linux skills you’ve learned up to this point. </span><span class="koboSpan" id="kobo.21.2">We hope you’ll try it out: if you do, your comfort and skill on the command line will benefit tremendously.</span></p>
<h1 class="heading-1" id="_idParaDest-305"><span class="koboSpan" id="kobo.22.1">Some background on Git</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.23.1">Git is a DVCS developed by Linus Torvalds, the creator of the Linux kernel. </span><span class="koboSpan" id="kobo.23.2">The origin of Git dates back to 2005 when the relationship between the Linux kernel </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.24.1">community and a proprietary distributed version </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.25.1">control system called </span><em class="italic"><span class="koboSpan" id="kobo.26.1">BitKeeper</span></em><span class="koboSpan" id="kobo.27.1"> broke down.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.28.1">In response to this, Torvalds sought to create a free, open-source DVCS that would meet the needs of the Linux kernel development process. </span><span class="koboSpan" id="kobo.28.2">Within just a few days, he conceptualized and laid the foundation for Git.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.29.1">Prioritizing performance, security, flexibility, and non-linear development (supporting thousands of parallel branches), Git quickly gained traction within the software development community. </span><span class="koboSpan" id="kobo.29.2">Its design, which emphasizes speed, data integrity, and support for distributed workflows, made it a favorite among developers, and it has since become the de facto standard for version control in the software industry.</span></p>
<h1 class="heading-1" id="_idParaDest-306"><span class="koboSpan" id="kobo.30.1">What is a distributed version control system?</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.31.1">Traditional version control </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.32.1">systems (like </span><strong class="keyWord"><span class="koboSpan" id="kobo.33.1">concurrent versions system</span></strong><span class="koboSpan" id="kobo.34.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.35.1">CVS</span></strong><span class="koboSpan" id="kobo.36.1">) and others) use a central server that maintains a single, coherent repository state at all times. </span><span class="koboSpan" id="kobo.36.2">These</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.37.1"> systems let developers push and fetch code and allowed the use of branches, tags, and other familiar mechanisms. </span><span class="koboSpan" id="kobo.37.2">The important point is that these version control systems were designed with a central authority in mind.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.38.1">Git and other </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.39.1">DVCSs, like </span><strong class="keyWord"><span class="koboSpan" id="kobo.40.1">Mercurial</span></strong><span class="koboSpan" id="kobo.41.1"> and </span><strong class="keyWord"><span class="koboSpan" id="kobo.42.1">Fossil</span></strong><span class="koboSpan" id="kobo.43.1">, use a different approach. </span><span class="koboSpan" id="kobo.43.2">Each developer has their own complete repository. </span><span class="koboSpan" id="kobo.43.3">Other </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.44.1">developers, instead of going through a central server, pull from each others’ repositories to fetch changes. </span><span class="koboSpan" id="kobo.44.2">In the case of the Linux project, there are hundreds of independent repositories in use by developers. </span><span class="koboSpan" id="kobo.44.3">Once a developer feels that the state of one of these repositories is ready, they will ask for the changes to be pulled into the main kernel. </span><span class="koboSpan" id="kobo.44.4">This is where the</span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.45.1"> term </span><strong class="keyWord"><span class="koboSpan" id="kobo.46.1">pull request</span></strong><span class="koboSpan" id="kobo.47.1"> comes from.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.48.1">While GitHub, GitLab, sourcehut, and others provide centralized hosting for Git, taking care of things like user authorization and providing many other features surrounding the development of software projects, Git works well without any of these and provides many mechanisms to do so. </span><span class="koboSpan" id="kobo.48.2">It is even possible to send and receive patches and groups of commits using email, without ever leaving the command line and Git. </span><span class="koboSpan" id="kobo.48.3">This allows for easy collaboration, even when a contributor has nothing but an email address to send a patch to.</span></p>
<h1 class="heading-1" id="_idParaDest-307"><span class="koboSpan" id="kobo.49.1">Git basics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.50.1">Here is a quick refresher on the most important Git command-line basics. </span><span class="koboSpan" id="kobo.50.2">These are provided as a reference, not as step-by-step</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.51.1"> instructions – although we’ve written them so that you can follow along if you want to practice.</span></p>
<h2 class="heading-2" id="_idParaDest-308"><span class="koboSpan" id="kobo.52.1">First-time setup</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.53.1">First things first: if you’re running Git for </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.54.1">the first time on a machine, you may want to set a few global config options.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.55.1">Set the default branch name to </span><code class="inlineCode"><span class="koboSpan" id="kobo.56.1">main</span></code><span class="koboSpan" id="kobo.57.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.58.1">git config --global init.defaultBranch main
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.59.1">Now configure your default name and email (attached to all of your commits):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.60.1">git config --global user.email "you@example.com"
git config --global user.name "Your Name"
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.61.1">Now you can initialize a new Git repository.</span></p>
<h2 class="heading-2" id="_idParaDest-309"><span class="koboSpan" id="kobo.62.1">Initialize a new Git repository</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.63.1">Create a directory and enter it:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.64.1">mkdir my-repo
cd my-repo
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.65.1">Now tell Git you want to</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.66.1"> initialize this directory as a new Git repository:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.67.1">git init
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-310"><span class="koboSpan" id="kobo.68.1">Make and see changes</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.69.1">Create a file with some</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.70.1"> simple content, and show the resulting change that Git detects:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.71.1">echo "Hello World" &gt;&gt; README
git status
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-311"><span class="koboSpan" id="kobo.72.1">Stage and commit changes</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.73.1">Stage the change you made to be committed, and </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.74.1">observe how the output of </span><code class="inlineCode"><span class="koboSpan" id="kobo.75.1">git status</span></code><span class="koboSpan" id="kobo.76.1"> has changed:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.77.1">git add README
git status
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.78.1">Show the staged content:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.79.1">git diff --staged
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.80.1">Commit the staged changes:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.81.1">git commit -m 'Add README file'
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.82.1">This is the short form of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.83.1">commit</span></code><span class="koboSpan" id="kobo.84.1"> command, which specifies the message (</span><code class="inlineCode"><span class="koboSpan" id="kobo.85.1">-m</span></code><span class="koboSpan" id="kobo.86.1">) directly. </span><span class="koboSpan" id="kobo.86.2">There is an interactive version </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.87.1">of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.88.1">commit</span></code><span class="koboSpan" id="kobo.89.1"> command, which you’d get by running just </span><code class="inlineCode"><span class="koboSpan" id="kobo.90.1">git commit</span></code><span class="koboSpan" id="kobo.91.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.92.1">The interactive version of this command (without the </span><code class="inlineCode"><span class="koboSpan" id="kobo.93.1">–m</span></code><span class="koboSpan" id="kobo.94.1"> option) will open the text editor specified in your shell’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.95.1">EDITOR</span></code><span class="koboSpan" id="kobo.96.1"> environment variable, and once the file is saved and the editor exits – that is, when the </span><code class="inlineCode"><span class="koboSpan" id="kobo.97.1">$EDITOR</span></code><span class="koboSpan" id="kobo.98.1"> command returns – the commit will be written.</span></p>
<h2 class="heading-2" id="_idParaDest-312"><span class="koboSpan" id="kobo.99.1">Optional: add a remote Git repository</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.100.1">The following command will </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.101.1">add a remote repository with the local name </span><code class="inlineCode"><span class="koboSpan" id="kobo.102.1">origin</span></code><span class="koboSpan" id="kobo.103.1"> that Git can push to and pull from. </span><span class="koboSpan" id="kobo.103.2">This might look similar to the SSH login command that we covered in </span><em class="chapterRef"><span class="koboSpan" id="kobo.104.1">Chapter 13</span></em><span class="koboSpan" id="kobo.105.1">, </span><em class="italic"><span class="koboSpan" id="kobo.106.1">Secure Remote Access with SSH</span></em><span class="koboSpan" id="kobo.107.1">, because that’s exactly what Git will use in this case. </span><span class="koboSpan" id="kobo.107.2">Git also supports other protocols, such as HTTPS.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.108.1">git remote add origin git@example.org:repo-path
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.109.1">This is just an example, but when you’re working on a real repository – for example, one that exists on GitHub – you’ll change the hostname and </span><code class="inlineCode"><span class="koboSpan" id="kobo.110.1">repo-path</span></code><span class="koboSpan" id="kobo.111.1"> to match the repository you want to add. </span><span class="koboSpan" id="kobo.111.2">GitHub and other source-hosting tools all have clear documentation on how to do</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.112.1"> this for repositories hosted there.</span></p>
<h2 class="heading-2" id="_idParaDest-313"><span class="koboSpan" id="kobo.113.1">Pushing and pulling</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.114.1">Push changes from your current </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.115.1">branch to the remote Git repository:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.116.1">git push -u origin HEAD
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.117.1">Pull changes from</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.118.1"> the remote branch:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.119.1">git pull
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-314"><span class="koboSpan" id="kobo.120.1">Cloning a repository</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.121.1">Let’s clone a remote </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.122.1">repository – all of the code for a project-based Linux course I created:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.123.1">git clone https://github.com/groovemonkey/hands_on_linux-self_hosted_wordpress_for_linux_beginners
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.124.1">This will pull down the Git history for the codebase and set the origin of the remote repository to the URL specified. </span><span class="koboSpan" id="kobo.124.2">Then you can work on the codebase using all of the Git commands you’ve already learned in this chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.125.1">As before, you can check the status of the repository:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.126.1">git status
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.127.1">While this command is typically used to check what was modified, it will also provide you with information on ongoing merges, show affected files during a merge conflict, and help you when bisecting code and in various other situations. </span><span class="koboSpan" id="kobo.127.2">It’s worthwhile to check </span><code class="inlineCode"><span class="koboSpan" id="kobo.128.1">git status</span></code><span class="koboSpan" id="kobo.129.1"> when you are not sure what is going on; chances are that you are in a special Git state that you either want to get out of or finish before continuing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.130.1">Now that we’ve covered the commands you’ll use most often, let’s get you comfortable with some of the terminology that often confuses people who are new to working with Git.</span></p>
<h1 class="heading-1" id="_idParaDest-315"><span class="koboSpan" id="kobo.131.1">Terms you might come across</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.132.1">It can be very helpful to get a basic understanding of Git’s vocabulary. </span><span class="koboSpan" id="kobo.132.2">Although it can be confusing when other software mixes these terms up, knowing what they mean in the Git world allows you to work a lot more confidently, for example, when troubleshooting and reading error messages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.133.1">Here is an overview of the most common terms and what they mean.</span></p>
<h2 class="heading-2" id="_idParaDest-316"><span class="koboSpan" id="kobo.134.1">Repository</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.135.1">This is essentially a “project,” the root directory of the code that is being managed and tracked by version control – the one containing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.136.1">.git</span></code><span class="koboSpan" id="kobo.137.1"> directory. </span><span class="koboSpan" id="kobo.137.2">A repository holds your source code and its history and changes.</span></p>
<h3 class="heading-3" id="_idParaDest-317"><span class="koboSpan" id="kobo.138.1">Bare repository</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.139.1">This has a similar meaning, only</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.140.1"> that the code is not checked out. </span><span class="koboSpan" id="kobo.140.2">It matches what the </span><code class="inlineCode"><span class="koboSpan" id="kobo.141.1">.git</span></code><span class="koboSpan" id="kobo.142.1"> directory contains. </span><span class="koboSpan" id="kobo.142.2">On servers hosting the repositories, such as GitHub, GitLab, sourcehut, or your company’s Gogs or Gitea instances, these are usually in a directory </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.143.1">named </span><code class="inlineCode"><span class="koboSpan" id="kobo.144.1">project-name.git</span></code><span class="koboSpan" id="kobo.145.1"> containing only what you’d see in a checked-out (cloned) repository found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.146.1">project-name/.git</span></code><span class="koboSpan" id="kobo.147.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-318"><span class="koboSpan" id="kobo.148.1">Branch</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.149.1">If you imagine the first commit as the </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.150.1">seed of a new repository, a project is made up of various branches. </span><span class="koboSpan" id="kobo.150.2">There is a main branch (described below), and often one or more side branches, containing other directions a project is taking. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.151.1">These might be major version branches, which have bug fixes applied to them but will never be merged back into the main branch. </span><span class="koboSpan" id="kobo.151.2">They could be experiments that may or may not ever be merged back into the main branch. </span><span class="koboSpan" id="kobo.151.3">Or, they could be new features or bug fix branches that are still in development but will be merged as soon as they’re ready – the possibilities are endless.</span></p>
<h3 class="heading-3" id="_idParaDest-319"><span class="koboSpan" id="kobo.152.1">Main/master branch</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.153.1">This is the default branch, which will </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.154.1">be used when initializing or cloning a repository. </span><span class="koboSpan" id="kobo.154.2">Depending </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.155.1">on the project, it usually contains either the latest (in development) or the latest stable code.</span></p>
<h3 class="heading-3" id="_idParaDest-320"><span class="koboSpan" id="kobo.156.1">HEAD</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.157.1">This is the latest commit on a branch. </span><span class="koboSpan" id="kobo.157.2">It’s also sometimes referred to as the “tip” of a branch. </span><span class="koboSpan" id="kobo.157.3">On the command line, </span><code class="inlineCode"><span class="koboSpan" id="kobo.158.1">HEAD</span></code><span class="koboSpan" id="kobo.159.1"> is also commonly </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.160.1">used in combination with relative commits.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.161.1">For example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.162.1">HEAD~2</span></code><span class="koboSpan" id="kobo.163.1"> references two commits back; therefore, the following command would show you the log up to two commits ago:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.164.1">git log HEAD~2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.165.1">In scripts and daily usage, it can also be</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.166.1"> used as an alternative to the current branch, because it is the tip of the current branch.</span></p>
<h2 class="heading-2" id="_idParaDest-321"><span class="koboSpan" id="kobo.167.1">Tag</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.168.1">Unlike branches, tags are a way to </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.169.1">mark specific commits, for example, to create (and later reference) a specific version of the codebase.</span></p>
<h3 class="heading-3" id="_idParaDest-322"><span class="koboSpan" id="kobo.170.1">Shallow</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.171.1">Usually, “shallow” is used to</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.172.1"> describe checkouts that contain no – or very little – history. </span><span class="koboSpan" id="kobo.172.2">Shallow checkouts are used when Git is only used as a means to obtain code, rather than the full repository and its history. </span><span class="koboSpan" id="kobo.172.3">This, however, might prevent certain commands and tools that depend on more history from working.</span></p>
<h2 class="heading-2" id="_idParaDest-323"><span class="koboSpan" id="kobo.173.1">Merging</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.174.1">Merging is the process of integrating code </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.175.1">from one branch into another branch. </span><span class="koboSpan" id="kobo.175.2">This can happen in various scenarios, such as merging a feature branch into the main branch, pulling changes from a remote branch, retrieving code from the Git stash, and so on. </span><span class="koboSpan" id="kobo.175.3">These merges can happen in a fully automated way. </span><span class="koboSpan" id="kobo.175.4">Sometimes, as in the case of merge conflicts, a merge might need manual intervention.</span></p>
<h3 class="heading-3" id="_idParaDest-324"><span class="koboSpan" id="kobo.176.1">Merge commit</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.177.1">This is a commit that results from code being merged. </span><span class="koboSpan" id="kobo.177.2">When merging code, that merge itself becomes a commit. </span><span class="koboSpan" id="kobo.177.3">When there is a </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.178.1">merge conflict, this merge commit will have changes resolving that conflict. </span><span class="koboSpan" id="kobo.178.2">While technically possible, it’s not a good idea to add any other changes (such as additional bug fixes) to such a commit. </span><span class="koboSpan" id="kobo.178.3">Merge commits should contain only the changes that are needed to make that specific merge work.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.179.1">In the case of conflict-free merges that Git handles automatically, it’s common to just commit them without any </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.180.1">manual changes to the code or the message.</span></p>
<h2 class="heading-2" id="_idParaDest-325"><span class="koboSpan" id="kobo.181.1">Merge conflict</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.182.1">When Git is not sure how to merge incoming code, this will result in a merge conflict that you need to manually resolve, usually </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.183.1">with a merge tool. </span><span class="koboSpan" id="kobo.183.2">Such conflicts can occur when code is being pulled, when code is applied from the stash, when merging branches, or during any other activity that acts on your currently checked-out code. </span><span class="koboSpan" id="kobo.183.3">Merge conflicts need to be resolved and then committed. </span><code class="inlineCode"><span class="koboSpan" id="kobo.184.1">git status</span></code><span class="koboSpan" id="kobo.185.1"> will usually tell you how to proceed.</span></p>
<h2 class="heading-2" id="_idParaDest-326"><span class="koboSpan" id="kobo.186.1">Stash</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.187.1">Sometimes it is necessary to</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.188.1"> put changes away for later retrieval. </span><span class="koboSpan" id="kobo.188.2">Git provides a mechanism for this, called the stash. </span><span class="koboSpan" id="kobo.188.3">The stash is structured like a stack, making it easy to incrementally apply changes in order by </span><code class="inlineCode"><span class="koboSpan" id="kobo.189.1">git stash pop</span></code><span class="koboSpan" id="kobo.190.1">-ping from it.</span></p>
<h2 class="heading-2" id="_idParaDest-327"><span class="koboSpan" id="kobo.191.1">Pull request</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.192.1">Git is a distributed version control system, which means that every developer has their own full repository and, therefore, can work independently of other developers working on the same project.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.193.1">Imagine a developer, Steve, who</span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.194.1"> makes some changes to the code in his repository. </span><span class="koboSpan" id="kobo.194.2">He wants another developer, Sarah, to integrate these changes into the codebase before an upcoming software release. </span><span class="koboSpan" id="kobo.194.3">Steve requests Sarah to pull these changes into her repository – as we saw earlier in the chapter, this is where the term “pull request” comes from.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.195.1">Since many companies and projects do not use Git as a DVCS, preferring a central, authoritative code repository that all developers pull from and push to, the term “pull request” is now usually used to describe a request to add code to that authoritative repository (or sometimes just into the main branch of a repository).</span></p>
<div class="note">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.196.1">Note</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.197.1">Because this concept deviates from Git’s decentralized nature, there is no native Git word for it. </span><span class="koboSpan" id="kobo.197.2">Different products that implement this workflow (updating the authoritative, central</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.198.1"> version of the codebase) have different names for it: GitHub calls it a “pull request,” while Launchpad calls it a “merge proposal” and GitLab calls it a “merge request.”</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-328"><span class="koboSpan" id="kobo.199.1">Cherry-picking</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.200.1">Sometimes it makes sense to only obtain individual changes (commits) from a different branch. </span><span class="koboSpan" id="kobo.200.2">A typical example is bug fixes in a development branch, like a feature branch that should be added to a stable branch</span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.201.1"> to be released. </span><span class="koboSpan" id="kobo.201.2">This can be done by cherry-picking. </span><span class="koboSpan" id="kobo.201.3">Unlike merges where the whole branch is merged, cherry-picking allows you to specify individual commits to add.</span></p>
<h2 class="heading-2" id="_idParaDest-329"><span class="koboSpan" id="kobo.202.1">Bisecting</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.203.1">git bisect</span></code><span class="koboSpan" id="kobo.204.1"> is a way to quickly find a commit causing a change, typically used to identify which commit introduced a certain bug. </span><span class="koboSpan" id="kobo.204.2">To </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.205.1">do so, one specifies a known “bad” and a known “good” commit. </span><span class="koboSpan" id="kobo.205.2">The bad commit </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.206.1">contains a bug and the good one is still fine. </span><span class="koboSpan" id="kobo.206.2">Git will now present you with commits that you can use to test for the bug. </span><span class="koboSpan" id="kobo.206.3">Here is an example:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.207.1">git bisect start
git bisect bad
git bisect good a0634a0
Bisecting: 675 revisions left to test after this (roughly 10 steps)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.208.1">The first line starts the bisect. </span><span class="koboSpan" id="kobo.208.2">In the second one, we tell Git that the current version is bad, so it contains the bug. </span><span class="koboSpan" id="kobo.208.3">Since we know that commit </span><code class="inlineCode"><span class="koboSpan" id="kobo.209.1">a0634a0</span></code><span class="koboSpan" id="kobo.210.1"> is still good, we specify that on the third line. </span><span class="koboSpan" id="kobo.210.2">Of course, this doesn’t have to be a commit but can also be a tag or a branch. </span><span class="koboSpan" id="kobo.210.3">Git will then let us know how many versions will still have to be checked.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.211.1">Now it’s time to test the code for the bug we are trying to find. </span><span class="koboSpan" id="kobo.211.2">If it’s present, we type in </span><code class="inlineCode"><span class="koboSpan" id="kobo.212.1">git bisect bad</span></code><span class="koboSpan" id="kobo.213.1">, otherwise, </span><code class="inlineCode"><span class="koboSpan" id="kobo.214.1">git bisect good</span></code><span class="koboSpan" id="kobo.215.1">. </span><span class="koboSpan" id="kobo.215.2">Rinse and repeat. </span><span class="koboSpan" id="kobo.215.3">Eventually, you will end up with the exact commit that introduced the bug.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.216.1">If you want to get out of this mode and back to the state you were in before, typing </span><code class="inlineCode"><span class="koboSpan" id="kobo.217.1">git bisect reset</span></code><span class="koboSpan" id="kobo.218.1"> will do so.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.219.1">Depending on what you are trying to find, “good” and “bad” are not the best words and can be confusing when trying to find any other kind of behavior change. </span><span class="koboSpan" id="kobo.219.2">So it’s possible to use “old” and “new” instead, to find the commit introducing the new behavior. </span><span class="koboSpan" id="kobo.219.3">Keep in mind it’s not possible to mix these terms. </span><span class="koboSpan" id="kobo.219.4">It’s either </span><em class="italic"><span class="koboSpan" id="kobo.220.1">good</span></em><span class="koboSpan" id="kobo.221.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.222.1">bad</span></em><span class="koboSpan" id="kobo.223.1">, or </span><em class="italic"><span class="koboSpan" id="kobo.224.1">old</span></em><span class="koboSpan" id="kobo.225.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.226.1">new</span></em><span class="koboSpan" id="kobo.227.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.228.1">There are also ways to speed this</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.229.1"> process up, such as specifying files or directories, if you know where the behavior was introduced. </span><span class="koboSpan" id="kobo.229.2">If you know that a change has to be related to the contents of </span><code class="inlineCode"><span class="koboSpan" id="kobo.230.1">some/directory</span></code><span class="koboSpan" id="kobo.231.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.232.1">some/other/directory</span></code><span class="koboSpan" id="kobo.233.1">, you can narrow down your search like this:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.234.1">git bisect start -- some/directory some/other/directory
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.235.1">Git will make sure to consider only commits that make changes to these paths.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.236.1">There are even more ways to speed this process up, like specifying multiple good commits or even passing a test script that, depending on the exit code, will automatically find the commit. </span><span class="koboSpan" id="kobo.236.2">A look into </span><code class="inlineCode"><span class="koboSpan" id="kobo.237.1">man git-bisect</span></code><span class="koboSpan" id="kobo.238.1"> is also helpful if you need to go through a lot of commits.</span></p>
<h2 class="heading-2" id="_idParaDest-330"><span class="koboSpan" id="kobo.239.1">Rebasing</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.240.1">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.241.1">git rebase</span></code><span class="koboSpan" id="kobo.242.1"> is a common way to</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.243.1"> keep commit histories easy to follow by “replaying” (really, recreating) a given set of changes (like a feature branch) onto a new base commit, rather than the base commit where they really diverged.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.244.1">Because development is usually distributed, you may have a “true” commit history like this:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.245.1"><img alt="" role="presentation" src="../Images/B19251_14_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.246.1">Figure 14.1: “real” commit history</span></p>
<p class="normal"><span class="koboSpan" id="kobo.247.1">Having multiple feature branch histories intermingled in the history is often more confusing than it is useful, so Git’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.248.1">rebase</span></code><span class="koboSpan" id="kobo.249.1"> feature is used to streamline these feature commits as they are merged.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.250.1">Feature 1 is merged first, so it uses the original base commit. </span><span class="koboSpan" id="kobo.250.2">The history now looks like this:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.251.1"><img alt="" role="presentation" src="../Images/B19251_14_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.252.1">Figure 14.2: Feature 1 rebased/merged Jan 13th</span></p>
<p class="normal"><span class="koboSpan" id="kobo.253.1">Feature 3 is the next to be rebased and merged, so now the history looks like this:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.254.1"><img alt="" role="presentation" src="../Images/B19251_14_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.255.1">Figure 14.3: Feature 3 rebased/merged Jan 14th</span></p>
<p class="normal"><span class="koboSpan" id="kobo.256.1">Finally, Feature 2 is rebased, resulting in its base commit changing to the Jan. </span><span class="koboSpan" id="kobo.256.2">14th Feature 3 commit. </span><span class="koboSpan" id="kobo.256.3">Now we</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.257.1"> have a nice, streamlined history like this:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.258.1"><img alt="" role="presentation" src="../Images/B19251_14_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.259.1">Figure 14.4: Feature 2 rebased/merged Jan 15th</span></p>
<p class="normal"><span class="koboSpan" id="kobo.260.1">GitHub and other centralized Git repository hosts have features that automate this process when merging, so you’ll rarely have to rebase manually on the command line. </span><span class="koboSpan" id="kobo.260.2">However, here’s the process for doing so:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.261.1">Create a new branch and add a commit:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.262.1">git checkout -b dave/myfeature
git commit -m "made some changes"
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.263.1">Presuming the base branch is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.264.1">main</span></code><span class="koboSpan" id="kobo.265.1">, and some commits have been added since you started developing your branch, you can now “rebase on main”:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.266.1">git rebase main
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.267.1">This will modify the Git history to rebase your branch’s commits on the latest </span><code class="inlineCode"><span class="koboSpan" id="kobo.268.1">main</span></code><span class="koboSpan" id="kobo.269.1"> commit, as you saw in the graphic above. </span><span class="koboSpan" id="kobo.269.2">Because you’re changing existing history, this may require force-pushing to the authoritative repository (such as the GitHub repository), which can cause other users to have conflicts. </span><span class="koboSpan" id="kobo.269.3">Please be aware of this when rebasing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.270.1">Now that we have identified</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.271.1"> some of the key terminology and concepts that you will come across when using Git, we can overview some good practices for writing effective commit messages.</span></p>
<h1 class="heading-1" id="_idParaDest-331"><span class="koboSpan" id="kobo.272.1">Best practices for commit messages</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.273.1">As a general rule, “one change per commit, and one commit per change” is the way to keep your Git commits – and history – useful.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.274.1">There are many situations where you </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.275.1">might only work on one major change, but also add a few minor (unrelated) corrections and improvements to the code. </span><span class="koboSpan" id="kobo.275.2">These unrelated changes should generally be committed separately, though. </span><span class="koboSpan" id="kobo.275.3">It’s a good idea to keep individual commits focused on the one specific thing you are trying to accomplish: a minor fix, fixing a typo, changing style, adding a (single) feature, and so on. </span><span class="koboSpan" id="kobo.275.4">Even if you end up making multiple interrelated changes at once, it might still make sense to split them up into multiple commits later. </span><span class="koboSpan" id="kobo.275.5">Committing more frequently can make this process a lot easier.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.276.1">There are many reasons for this rule. </span><span class="koboSpan" id="kobo.276.2">One of the most practical reasons is that when your commits are small, individual changes can be easily cherry-picked or reverted should it become necessary (even if you never expected it while changing the code). </span><span class="koboSpan" id="kobo.276.3">Having small, tightly focused commits is also helpful when someone uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.277.1">git blame</span></code><span class="koboSpan" id="kobo.278.1"> to understand a change.</span></p>
<h2 class="heading-2" id="_idParaDest-332"><span class="koboSpan" id="kobo.279.1">Good commit messages</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.280.1">Sometimes, vague suggestions, for example, “keep the commit message short when using </span><code class="inlineCode"><span class="koboSpan" id="kobo.281.1">git commit</span></code><span class="koboSpan" id="kobo.282.1">,” can be confusing and</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.283.1"> hard to follow. </span><span class="koboSpan" id="kobo.283.2">For context, it makes </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.284.1">sense to explain how Git is intended to be used. </span><span class="koboSpan" id="kobo.284.2">Git, being a DVCS, allows for patches to be sent as emails. </span><span class="koboSpan" id="kobo.284.3">As a result, commit messages themselves – in a way – take the form of emails. </span><span class="koboSpan" id="kobo.284.4">The first line is considered the subject line, giving a brief overview of what is done, followed by an empty line and a more verbose summary of what was changed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.285.1">Because this is a very open-ended schema, there are some commonly agreed-upon rules. </span><span class="koboSpan" id="kobo.285.2">Like all such rules, they may be overridden on a per-project or per-organization basis, but here is an overview of what many well-established open-source projects do:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.286.1">Keep the first line short. </span><span class="koboSpan" id="kobo.286.2">It should be a summary using 72 characters or less.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.287.1">Make the first line an imperative verb (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.288.1">Add</span></code><span class="koboSpan" id="kobo.289.1">…, </span><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">Fix</span></code><span class="koboSpan" id="kobo.291.1">…).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.292.1">Capitalize the subject line.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.293.1">If you need more than that, add an empty line and a full summary.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.294.1">Use the body to explain </span><em class="italic"><span class="koboSpan" id="kobo.295.1">why</span></em><span class="koboSpan" id="kobo.296.1"> you have made this change. </span><span class="koboSpan" id="kobo.296.2">This can be very helpful for any future reader using </span><code class="inlineCode"><span class="koboSpan" id="kobo.297.1">git blame</span></code><span class="koboSpan" id="kobo.298.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.299.1">Make sure to describe how you </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.300.1">came to your conclusion/implementation, and why it is relevant. </span><span class="koboSpan" id="kobo.300.2">This</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.301.1"> is especially important for complex commits and for commits that might not immediately make sense to someone who is looking only at the code. </span><span class="koboSpan" id="kobo.301.2">This can be a tremendous help when tracking down bugs, removing obsolete code later, rewriting systems, or just getting into understanding the code.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.302.1">Consider whether some of what you’re writing in your commit message might not be better added to code comments.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.303.1">Imagine a reviewer or future reader having no context at all. </span><span class="koboSpan" id="kobo.303.2">Make sure that the code changes can be easily understood.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.304.1">With this advice in mind, you should be able to make clear and organized commit messages. </span><span class="koboSpan" id="kobo.304.2">Next, we will look at some further advice for easily and effectively using Git.</span></p>
<h1 class="heading-1" id="_idParaDest-333"><span class="koboSpan" id="kobo.305.1">GUIs</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.306.1">While this book is strongly focused on building up your command-line skills, it’s worth mentioning that there are some </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.307.1">graphical tools available that can make interacting with Git easier for some use cases.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.308.1">tig</span></code><span class="koboSpan" id="kobo.309.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.310.1">gitk</span></code><span class="koboSpan" id="kobo.311.1"> are two examples of graphical repository browsers, which give you a Git interface that’s similar to what many IDEs provide. </span><span class="koboSpan" id="kobo.311.2">To try them out, simply navigate to a repository using </span><code class="inlineCode"><span class="koboSpan" id="kobo.312.1">cd</span></code><span class="koboSpan" id="kobo.313.1"> and run </span><code class="inlineCode"><span class="koboSpan" id="kobo.314.1">gitk</span></code><span class="koboSpan" id="kobo.315.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.316.1">tig</span></code><span class="koboSpan" id="kobo.317.1">. </span><span class="koboSpan" id="kobo.317.2">You’ll likely have to install these tools via your package manager; many Unix flavors (including popular Linux distributions and macOS) don’t have them installed by default.</span></p>
<h1 class="heading-1" id="_idParaDest-334"><span class="koboSpan" id="kobo.318.1">Useful shell aliases</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.319.1">Here are a few useful shell aliases</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.320.1"> for common Git commands. </span><span class="koboSpan" id="kobo.320.2">Feel free to add these to your </span><code class="inlineCode"><span class="koboSpan" id="kobo.321.1">~/.bash_aliases</span></code><span class="koboSpan" id="kobo.322.1"> file (presuming you’re using Bash):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.323.1">alias gpo='git push origin $(git branch | grep "*" | cut -d " " -f2)'
alias gp='git pull'
alias gs='git status'
alias gd='git diff'
alias gds='git diff --staged'
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.324.1">If you’re typing in </span><code class="inlineCode"><span class="koboSpan" id="kobo.325.1">git status</span></code><span class="koboSpan" id="kobo.326.1"> dozens of times each day, it can be a huge improvement to add an alias that enables you to type </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">gs</span></code><span class="koboSpan" id="kobo.328.1"> instead. </span><span class="koboSpan" id="kobo.328.2">Feel free to change these to something even more convenient – that’s what customization is for!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.329.1">Now let’s zoom out a bit and see how we can practically apply all of this knowledge while building a small Linux server project: your very own private Git server.</span></p>
<h1 class="heading-1" id="_idParaDest-335"><span class="koboSpan" id="kobo.330.1">Poor man’s GitHub</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.331.1">In this section, we’ll show you how to set up a remote Git repository for yourself. </span><span class="koboSpan" id="kobo.331.2">You only need an SSH account on the remote </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.332.1">machine and a Git binary on your local machine (as in, the Git command itself). </span><span class="koboSpan" id="kobo.332.2">If Git is already installed on the remote machine, you won’t even need root access.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.333.1">This is a fun project that will make you comfortable with the basic OS-facing concepts involved with Git. </span><span class="koboSpan" id="kobo.333.2">This setup is not necessarily suggested for production use; rather, it will show you that there’s absolutely no magic when it comes to Git. </span><span class="koboSpan" id="kobo.333.3">Like everything else in Linux, it’s just files (in this case, remote files and an SSH tunnel).</span></p>
<h2 class="heading-2" id="_idParaDest-336"><span class="koboSpan" id="kobo.334.1">Considerations</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.335.1">Depending on whether you have root</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.336.1"> access and whether you want to share the repository with others, you might want to consider creating a specific user for your shared Git service. </span><span class="koboSpan" id="kobo.336.2">This is completely optional.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.337.1">We will use an SSH account for authentication, so if you share the Git repository, the person you share it with will have the same permissions as that user on the remote machine. </span><span class="koboSpan" id="kobo.337.2">It might make sense to create a separate user on the remote machine for this project (named </span><code class="inlineCode"><span class="koboSpan" id="kobo.338.1">git</span></code><span class="koboSpan" id="kobo.339.1">) if you don’t fully trust your fellow programmers to have access to this account.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.340.1">This project assumes you’re</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.341.1"> comfortable setting up SSH and connecting to a server – if you’re a bit rusty on the details, check out the previous chapter: </span><em class="chapterRef"><span class="koboSpan" id="kobo.342.1">Chapter 13</span></em><span class="koboSpan" id="kobo.343.1">, </span><em class="italic"><span class="koboSpan" id="kobo.344.1">Secure Remote Access with SSH</span></em><span class="koboSpan" id="kobo.345.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-337"><span class="koboSpan" id="kobo.346.1">1. </span><span class="koboSpan" id="kobo.346.2">Connect to your server</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.347.1">Connect to the server, using the account</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.348.1"> you want your repository to belong to (such as git, or your own user):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.349.1">ssh myuser@example.com
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-338"><span class="koboSpan" id="kobo.350.1">2. </span><span class="koboSpan" id="kobo.350.2">Install Git</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.351.1">First, check if Git is already installed </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.352.1">by running:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.353.1">git version
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.354.1">This should output the version of Git that is installed on your server. </span><span class="koboSpan" id="kobo.354.2">If you receive a message like </span><code class="inlineCode"><span class="koboSpan" id="kobo.355.1">command not found</span></code><span class="koboSpan" id="kobo.356.1">, then Git is not installed on your system.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.357.1">To install Git, simply use your system’s package manager to install the </span><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">git</span></code><span class="koboSpan" id="kobo.359.1"> package. </span><span class="koboSpan" id="kobo.359.2">On Ubuntu, you’d run:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.360.1">apt-get install git
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-339"><span class="koboSpan" id="kobo.361.1">3. </span><span class="koboSpan" id="kobo.361.2">Initialize a repository</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.362.1">Now you can initialize a new </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.363.1">bare repository. </span><span class="koboSpan" id="kobo.363.2">In this case, we will call it </span><code class="inlineCode"><span class="koboSpan" id="kobo.364.1">my-project</span></code><span class="koboSpan" id="kobo.365.1">. </span><span class="koboSpan" id="kobo.365.2">You can create this wherever you want. </span><span class="koboSpan" id="kobo.365.3">For the sake of simplicity, we will assume that it is your home directory:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.366.1">git init --bare my-project.git
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.367.1">This will create a directory called </span><code class="inlineCode"><span class="koboSpan" id="kobo.368.1">my-project.git</span></code><span class="koboSpan" id="kobo.369.1">. </span><span class="koboSpan" id="kobo.369.2">It is not a file, but a directory structure that Git considers a repository. </span><span class="koboSpan" id="kobo.369.3">We won’t go into detail here and it will probably be quite a while before you need to change something.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.370.1">Believe it or not, that’s actually</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.371.1"> all you need to do!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.372.1">You can now disconnect from the server (</span><em class="keystroke"><span class="koboSpan" id="kobo.373.1">Ctrl</span></em><span class="koboSpan" id="kobo.374.1">+</span><em class="keystroke"><span class="koboSpan" id="kobo.375.1">D</span></em><span class="koboSpan" id="kobo.376.1"> if you’re connected via SSH).</span></p>
<h2 class="heading-2" id="_idParaDest-340"><span class="koboSpan" id="kobo.377.1">4. </span><span class="koboSpan" id="kobo.377.2">Clone the repository</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.378.1">Despite it being completely empty, you can already clone the repository. </span><span class="koboSpan" id="kobo.378.2">After disconnecting from your server, run the following command from your local machine:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.379.1">git clone myuser@example.com:my-project.git
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.380.1">As mentioned earlier, this assumes that you created the repository in the home directory of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.381.1">myuser</span></code><span class="koboSpan" id="kobo.382.1"> user. </span><span class="koboSpan" id="kobo.382.2">Starting after the </span><code class="inlineCode"><span class="koboSpan" id="kobo.383.1">example.com</span></code><span class="koboSpan" id="kobo.384.1"> hostname (this might also just be your server’s IP address if you</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.385.1"> haven’t set up DNS), the path is relative to the user’s home directory. </span><span class="koboSpan" id="kobo.385.2">If you want to specify a full (absolute) path, just start with a slash. </span><span class="koboSpan" id="kobo.385.3">In other words, using the command </span><code class="inlineCode"><span class="koboSpan" id="kobo.386.1">git clone myuser@example.com:/home/myuser/my-project.git</span></code><span class="koboSpan" id="kobo.387.1"> would lead to the same directory being cloned.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.388.1">Git will warn you that you cloned an empty repository. </span><span class="koboSpan" id="kobo.388.2">But since this is what we expect, there’s no need to worry.</span></p>
<h2 class="heading-2" id="_idParaDest-341"><span class="koboSpan" id="kobo.389.1">5. </span><span class="koboSpan" id="kobo.389.2">Edit the project and push your changes</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.390.1">We can now switch to the cloned </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.391.1">directory and start working on the project:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.392.1">cd my-project
echo "My personal project" &gt;&gt; README
git add README
git commit -m 'initial commit'
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.393.1">Now that we have our first</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.394.1"> commit, we can push it. </span><span class="koboSpan" id="kobo.394.2">The very first push has a minor caveat to be aware of: because the repository is still completely empty, it doesn’t know any branches yet, not even the master branch. </span><span class="koboSpan" id="kobo.394.3">Git will tell you this if you only run </span><code class="inlineCode"><span class="koboSpan" id="kobo.395.1">git push</span></code><span class="koboSpan" id="kobo.396.1">. </span><span class="koboSpan" id="kobo.396.2">So just make sure to tell Git the branch when pushing to a new repository for the very first time:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.397.1">git push origin master
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.398.1">That’s it!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.399.1">Now you or someone else with access to your SSH account can clone, push to, and pull from this repository. </span><span class="koboSpan" id="kobo.399.2">You can even set up hooks and do other fun things. </span><span class="koboSpan" id="kobo.399.3">Git is a very powerful tool with a huge variety of features. </span><span class="koboSpan" id="kobo.399.4">It can take a while to get used to them, so just consider this your </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.400.1">starting point.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.401.1">The possibilities are endless, and I’m always excited to hear about people using Git for interesting or unique use cases. </span><span class="koboSpan" id="kobo.401.2">Have fun!</span></p>
<h1 class="heading-1" id="_idParaDest-342"><span class="koboSpan" id="kobo.402.1">Conclusion</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.403.1">In this chapter, you learned the basic concepts, commands, and workflows that you need to use Git effectively. </span><span class="koboSpan" id="kobo.403.2">Some of the often-used advanced features and terminology should be clearer to you now, and we passed on some advice for “soft” Git skills like writing good commit messages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.404.1">The shell aliases we showed you save us hundreds of keystrokes in a day of programming; we hope they are as useful to you as they have been to us, and that you’ll use command aliases for all the hard-to-remember or hard-to-type commands you run daily.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.405.1">We also hope that you followed along with the </span><em class="italic"><span class="koboSpan" id="kobo.406.1">Poor man’s GitHub</span></em><span class="koboSpan" id="kobo.407.1"> project! </span><span class="koboSpan" id="kobo.407.2">Running the commands only takes a few minutes, but if you take an afternoon and really try it out (rent a Linux VM for a few hours, set up a remote repository there, and push some example commits), you’ll get a feel for how powerful and effective your newfound Linux skills can be when they’re combined to solve real-world problems.</span></p>
<h1 class="heading-1"><span class="koboSpan" id="kobo.408.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.409.1">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SecNet"><span class="url"><span class="koboSpan" id="kobo.410.1">https://packt.link/SecNet</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.411.1"><img alt="" role="presentation" src="../Images/QR_Code1768422420210094187.png"/></span></p>
</div>
</body></html>