- en: '23'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '23'
- en: Preventing Disasters
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止灾难
- en: 'In an enterprise network, a disaster can strike at any time. While, as administrators,
    we always do our best to design the most stable and fault-tolerant server implementations
    we possibly can, what matters most is how we are able to deal with disasters when
    they do happen. As stable as server hardware is, any component of a server can
    fail at any time. In the face of a disaster, we need a plan. How can you attempt
    to recover data from a failed disk? What do you do when your server all of a sudden
    decides it doesn’t want to boot? These are just some of the questions we’ll answer
    as we take a look at several ways we can prevent and recover from disasters. In
    our final chapter, we’ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业网络中，灾难随时可能发生。作为管理员，尽管我们总是尽力设计尽可能稳定和容错的服务器系统，但最重要的是我们如何应对灾难的发生。尽管服务器硬件非常稳定，但服务器的任何组件都有可能随时出现故障。在灾难面前，我们需要一个计划。当磁盘发生故障时，你如何恢复数据？当服务器突然无法启动时，你该怎么办？这些只是我们将探讨的部分问题，我们将介绍几种防止和恢复灾难的方法。在最后一章中，我们将涵盖以下主题：
- en: Preventing disasters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止灾难
- en: Utilizing Git for configuration management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Git 进行配置管理
- en: Implementing a backup plan
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施备份计划
- en: Utilizing bootable recovery media
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可启动的恢复介质
- en: We’ll start off our final chapter by looking at a few tips to help prevent disaster.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一些防止灾难的技巧开始本章内容。
- en: Preventing disasters
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止灾难
- en: As we proceed through this chapter, we’ll look at ways we can recover from disasters.
    However, if we can prevent a disaster from occurring in the first place, then
    that’s even better. We certainly can’t prevent every type of disaster that could
    possibly happen but having a good plan in place and following that plan will lessen
    the likelihood. A good disaster recovery plan will include a list of guidelines
    to be followed with regard to implementing new servers and managing current ones.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章进行时，我们将探讨如何从灾难中恢复。然而，如果我们能从一开始就防止灾难的发生，那就更好了。虽然我们肯定不能防止所有可能发生的灾难，但有一个良好的计划，并严格按照计划执行，可以大大降低灾难发生的可能性。一个好的灾难恢复计划应该包括一系列实施新服务器和管理现有服务器时需要遵循的准则。
- en: This plan may include information such as an approved list of hardware (such
    as hardware configurations known to work efficiently in an environment), as well
    as rules and regulations for users, a list of guidelines to ensure physical and
    software security, proper training for end users, and method change control. Some
    of these concepts we’ve touched on earlier in the book but are worth repeating
    from the standpoint of disaster prevention.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 该计划可能包括一些信息，如经过认证的硬件列表（例如在某个环境中已知能高效运行的硬件配置），以及用户的规则和规定、确保物理和软件安全的指南列表、对终端用户的适当培训以及变更控制方法。这些概念在书中早些时候已提到，但从灾难预防的角度来看，值得再次强调。
- en: First, we talked about the **principle of least privilege** back in *Chapter
    21*, *Securing Your Server*. The idea is to give your users as few permissions
    as possible. This is very important for security, as you want to ensure only those
    trained in their specific jobs are able to access and modify only the resources
    that they are required to. Accidental data deletion happens all the time. To take
    full advantage of this principle, create a set of groups as part of your overall
    security design. List departments and positions in your company and the types
    of activities each is required to perform. Create system groups that correspond
    to those activities. For example, create an accounting-ro and accounting-rw group
    to categorize users within your Accounting department that should have the ability
    to only read or read and write data. If you’re simply managing a home file server,
    be careful of open network shares where users have read and write access by default.
    By allowing users to do as little as possible, you’ll prevent a great many disasters
    right away.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在*第21章*《保护你的服务器》中讨论过**最小权限原则**。其思想是给用户尽可能少的权限。这对安全性非常重要，因为你希望确保只有经过专门培训的人员，才能访问并修改他们需要的资源。数据丢失是常有的事。为了充分利用这一原则，你需要创建一组用户组，作为整体安全设计的一部分。列出你公司中的部门和岗位，以及每个岗位需要执行的活动类型。创建与这些活动相对应的系统组。例如，创建一个`accounting-ro`（只读）和`accounting-rw`（读写）组，用来分类你会计部门中的用户，这些用户应该只具有读取或读写数据的权限。如果你只是在管理一个家庭文件服务器，注意不要让默认情况下就有读写权限的开放网络共享。通过让用户尽可能少做，你可以立即防止许多灾难的发生。
- en: In *Chapter 2*, *Managing Users and Permissions* (as well as *Chapter 21*, *Securing
    Your Server*), we talked about best practices for the `sudo` command. While the
    `sudo` command is useful, it’s often misused. By default, anyone that’s a member
    of the `sudo` group can use `sudo` to do whatever they want. We talked about how
    to restrict `sudo` access to particular commands, which is always recommended.
    Only trusted administrators should have full access to `sudo`. Everyone else should
    have `sudo` permissions only if they really need them, and even then, only when
    it comes to commands that are required for their job. A user with full access
    to `sudo` can delete an entire filesystem, so it should never be taken lightly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第二章*，*用户与权限管理*（以及*第21章*，*保护你的服务器*）中，我们讨论了 `sudo` 命令的最佳实践。虽然 `sudo` 命令非常有用，但它经常被滥用。默认情况下，任何是
    `sudo` 组成员的人都可以使用 `sudo` 执行任何操作。我们讨论了如何限制 `sudo` 访问特定命令，这是始终推荐的做法。只有受信任的管理员才应该拥有完全的
    `sudo` 访问权限。其他人应该仅在真正需要时才获得 `sudo` 权限，而且只有在执行他们工作所必需的命令时才应授予此权限。拥有 `sudo` 完全访问权限的用户可以删除整个文件系统，因此这一权限绝不应轻视。
- en: In regard to network shares, it’s always best to default to read-only whenever
    possible. This isn’t just because of the possibility of a user accidentally deleting
    data; it’s always possible for applications to malfunction and delete data as
    well. With a read-only share, the modification or deletion of files isn’t possible.
    Additional read-write shares can be created for those who need them, but if possible,
    always default to read-only.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于网络共享，尽可能默认设置为只读总是最好的选择。这不仅是因为用户可能会不小心删除数据，还因为应用程序也有可能出现故障并删除数据。通过只读共享，文件的修改或删除是不可能的。可以为需要修改权限的人创建额外的读写共享，但如果可能的话，始终默认设置为只读。
- en: Although I’ve spent a lot of time discussing security in a software sense, physical
    security is important too. For the purposes of this book, physical security doesn’t
    really enter the discussion much because our topic is specifically Ubuntu Server,
    and nothing you install on Ubuntu is going to increase the physical security of
    your servers. It’s worth noting, however, that physical security is every bit
    as important as securing your operating systems, applications, and data files.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我花了很多时间讨论软件方面的安全性，但物理安全同样重要。就本书而言，物理安全并没有太多涉及，因为我们的主题专门是 Ubuntu Server，而你在
    Ubuntu 上安装的任何东西都不会增加服务器的物理安全性。值得注意的是，物理安全和操作系统、应用程序、数据文件的安全一样重要。
- en: All it would take is someone tripping over a network cable in a server room
    to disrupt an entire subnet or cause a production application to go offline. Server
    rooms should be locked, and only trusted administrators should be allowed to access
    your equipment. I’m sure this goes without saying and may sound obvious, but I’ve
    worked at several companies that did not secure their server room. Nothing good
    ever comes from placing important equipment within arm’s reach of unauthorized
    individuals.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要有人在服务器室里绊倒一根网络电缆，就能干扰整个子网或使生产应用程序下线。服务器室应该上锁，只有受信任的管理员可以访问设备。我相信这不言而喻，也许听起来很显然，但我曾在几家公司工作，它们并没有保护好服务器室。把重要设备放在未经授权人员触手可及的地方，绝不会带来好结果。
- en: In this section, I’ve mentioned *Chapter 21*, *Securing Your Server*, a couple
    of times. A good majority of a disaster prevention plan includes a focus on security.
    This includes, but is not limited to, ensuring security updates are installed
    in a timely fashion, utilizing security applications such as failure monitors
    and firewalls, and ensuring secure settings for OpenSSH. I won’t go over these
    concepts again here since we’ve already covered them, but essentially security
    is a very important part of a disaster prevention plan. After all, users cannot
    break what they cannot access, and hackers will have a harder time penetrating
    your network if you designed it in a security-conscious way.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我提到了*第21章*，*保护你的服务器*，已经好几次了。灾难预防计划的大多数内容都涉及安全性。这包括但不限于确保及时安装安全更新，使用如故障监视器和防火墙等安全应用程序，以及确保
    OpenSSH 设置安全。我在这里不会再重复这些概念，因为我们已经讨论过了，但本质上，安全性是灾难预防计划中的一个非常重要部分。毕竟，用户无法破坏他们无法访问的东西，如果你设计了一个注重安全的网络，黑客也更难侵入。
- en: Effective disaster prevention consists of a list of guidelines for things such
    as user management, server management, application installations, security, and
    procedure documents. A full walkthrough of proper disaster prevention would be
    an entire book in and of itself. My goal with this section is to provide you with
    some ideas you can use to begin developing your own plan. A disaster prevention
    plan is not something you’ll create all at once but is rather something you’ll
    create and refine indefinitely as you learn more about security and what types
    of things to watch out for.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的灾难预防包括一系列指南，涵盖用户管理、服务器管理、应用程序安装、安全性和流程文档等内容。完整的灾难预防解说本身将是一本完整的书。我在本节的目标是为您提供一些可以用来开始制定自己计划的想法。灾难预防计划不是一次性创建的，而是随着您对安全性和需要注意的事项的了解而不断创建和完善。
- en: The configuration files on your server determine the behavior of your services
    and applications, and backing up can enable you to recover their state. When it
    comes to managing the state of files, Git is a very powerful tool to do just that,
    and we’ll talk about it next.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器上的配置文件决定了服务和应用程序的行为，而备份可以帮助您恢复它们的状态。在管理文件状态方面，Git是一个非常强大的工具，我们将在接下来详细讨论它。
- en: Utilizing Git for configuration management
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Git进行配置管理
- en: One of the most valuable assets on a server is its configuration. This is second
    only to the data the server stores. Often, when we implement new technology on
    a server, we’ll spend a great deal of time editing configuration files all over
    the server to make it work as best as we can. This can include any number of things,
    from Apache virtual host files to DHCP server configuration, DNS zone files, and
    more. If a server were to encounter a disaster from which the only recourse was
    to completely rebuild it, the last thing we’d want to do is re-engineer all of
    this configuration from scratch. This is where Git comes in.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器上最有价值的资产之一是其配置。这仅次于服务器存储的数据。通常，当我们在服务器上实施新技术时，我们会花费大量时间编辑服务器上的各种配置文件，以使其尽可能地发挥作用。这可能包括从Apache虚拟主机文件到DHCP服务器配置、DNS区域文件等任意数量的内容。如果服务器遇到灾难，唯一的补救措施是完全重建它，那么我们最不想做的就是从头开始重新设计所有这些配置。这就是Git的用武之地。
- en: In a typical development environment, an application being developed by a team
    of engineers can be managed by Git, each contributing to a repository that hosts
    the source code for their software. One of the things that makes Git so useful
    is how you’re able to go back to previous versions of a file in an instant, as
    it keeps a history of all changes made to the files within the repository.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的开发环境中，由工程师团队开发的应用程序可以通过Git进行管理，每个工程师都可以贡献到托管其软件源代码的存储库中。使Git如此有用的其中一点是，您能够立即返回文件的以往版本，因为它保存了存储库内所有文件更改的历史记录。
- en: Git isn’t just useful for software engineers, though. It’s also a really useful
    tool we can leverage for keeping track of configuration files on our servers.
    For our use case, we can use it to record changes to configuration files and push
    them to a central server for backup. When we make configuration changes, we push
    the changes back to our Git server. If for some reason we need to restore the
    configuration after a server fails, we can simply download our configuration files
    from Git back onto our new server. Another useful aspect of this approach is that
    if an administrator implements a change to a configuration file that breaks a
    service, we can simply revert to a known working commit and we’ll be immediately
    back up and running. You can even correlate changes in log files to changes made
    at around the same time in a Git repository, which makes it easier to narrow down
    the root cause of an issue.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Git不仅对软件工程师有用，它也是我们在服务器上跟踪配置文件变化的非常有用的工具。对于我们的用例，我们可以使用它记录对配置文件的更改并将其推送到中央服务器进行备份。当我们进行配置更改时，我们将更改推送回我们的Git服务器。如果由于某种原因我们需要在服务器故障后恢复配置，我们只需从Git上下载我们的配置文件即可重新配置到新服务器上。这种方法的另一个有用之处是，如果管理员实施了破坏服务的配置文件更改，我们可以简单地回滚到已知的工作正常的提交，并立即恢复服务。您甚至可以将日志文件中的更改与Git存储库中大致相同时进行的更改进行关联，这样可以更容易地缩小问题的根本原因。
- en: 'Configuration management on servers is so important, in fact, I highly recommend
    that every Linux administrator takes advantage of version control for this purpose.
    Although it may seem a bit tricky at first, it’s actually really easy to get going
    once you practice with it. Once you’ve implemented Git for keeping track of all
    your server’s configuration files, you’ll wonder how you ever lived without it.
    We covered Git briefly in *Chapter 15*, *Automating Server Configuration with
    Ansible,* where I walked you through creating a repository on GitHub to host Ansible
    configuration. However, using Github is not mandatory in order to benefit from
    version control. Sure, it’s definitely convenient – but not required. The only
    required component for a server to function as a Git server is the presence of
    the `git` package:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器上的配置管理非常重要，事实上，我强烈建议每个 Linux 管理员都利用版本控制来进行配置管理。虽然一开始可能会觉得有点棘手，但一旦练习过后，实际上是非常容易上手的。完成将
    Git 用于跟踪所有服务器配置文件后，你会惊讶于没有它时你是如何生活的。我们在*第 15 章*《使用 Ansible 自动化服务器配置》中简要介绍了 Git，我带你通过创建
    GitHub 仓库来托管 Ansible 配置。然而，使用 GitHub 并不是使用版本控制的必要条件。虽然它确实非常方便，但并不是必需的。要让服务器作为
    Git 服务器工作，唯一需要的组件就是 `git` 包的存在：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And just like that, you now have a Git server. That may have seemed overly simplistic
    (and it is) but there aren’t a great deal of requirements in order to set up Git
    as a central resource on your network. Since Git uses OpenSSH by default, you’ll
    be able to store repositories on a server that has the `git` package and is accessible
    to clients on your network.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你现在已经有了一个 Git 服务器。这可能看起来过于简单（确实是），但要将 Git 设置为网络上的中央资源并没有太多要求。由于 Git 默认使用
    OpenSSH，你将能够在安装了 `git` 包并且对网络上的客户端可访问的服务器上存储仓库。
- en: If for some reason you don’t have an extra server to act as your Git server,
    you can install the `git` package on another instance and add that functionality
    to an existing server. My personal preference is for each server to focus on one
    task (and perform that one task well) but sometimes the budget of the organization
    may not allow for a stand-alone server for every service.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因你没有额外的服务器作为 Git 服务器，你可以在另一个实例上安装 `git` 包，并将该功能添加到现有服务器中。我个人的偏好是让每个服务器专注于一个任务（并且做好这个任务），但有时候组织的预算可能不允许为每个服务配置独立的服务器。
- en: Now, think of a configuration directory that’s important to you, and that you
    want to place into version control. A good example is the `/etc/apache2` directory
    on a web server. That’s what I’ll use in my examples in this section. But you’re
    certainly not limited to that. Any configuration directory you would rather not
    lose is a good candidate. If you choose to use a different configuration path,
    change the paths I give you in my examples to that path.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一个对你很重要的配置目录，你希望将其纳入版本控制。一个好的例子是 Web 服务器上的 `/etc/apache2` 目录。这个目录将在本节的示例中使用。但你当然不限于此，任何你不想丢失的配置目录都是一个合适的候选。如果你选择使用不同的配置路径，请在我的示例中将路径更改为该路径。
- en: 'On the server, create a directory to host your repositories. I’ll use `/git`
    in my examples:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，创建一个目录来存放你的仓库。我将在示例中使用 `/git`：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, you’ll want to modify this directory to be owned by the administrative
    user you use on your Ubuntu servers. Typically, this is the user that was created
    during the installation of the distribution. You can use any user you want actually,
    just make sure the user is allowed to use OpenSSH to access your Git server. Change
    the ownership of the `/git` directory so it is owned by this user. My user on
    my Git server is `jay`, so in my case, I would change the ownership with the following
    command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要将该目录的所有权修改为你在 Ubuntu 服务器上使用的管理员用户。通常，这个用户是在安装操作系统时创建的用户。实际上，你可以使用任何用户，只要确保该用户能够使用
    OpenSSH 访问你的 Git 服务器。将 `/git` 目录的所有权更改为此用户。我在 Git 服务器上的用户名是 `jay`，所以在我的例子中，我会使用以下命令更改所有权：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we’ll create our Git repository within the `/git` directory. For Apache,
    I’ll create a bare repository for it within the `/git` directory. A bare repository
    is basically a skeleton of a Git repository that doesn’t contain any useful data,
    just some default configuration to allow it to act as a Git folder. To create
    the bare repository, `cd` into the `/git` directory and execute:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`/git`目录内创建我们的 Git 仓库。对于 Apache，我将在`/git`目录内为其创建一个裸仓库。裸仓库基本上是一个 Git
    仓库的骨架，里面没有任何实际数据，只有一些默认配置使其能够作为一个 Git 文件夹。要创建裸仓库，`cd`进入`/git`目录并执行：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下输出：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That’s all we need to do on the server for now for the purposes of our Apache
    repository. On your client (the server that houses the configuration you want
    to place under version control), we’ll copy this bare repository by cloning it.
    To set that up, create a `/git` directory on your Apache server (or whatever kind
    of server you’re backing up) just as we did before. Then, `cd` into that directory
    and clone your repository with the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只需要在服务器上做这些操作，就可以实现 Apache 仓库的目的。在你的客户端（存放你想要放入版本控制的配置文件的服务器）上，我们将通过克隆来复制这个裸仓库。为此，请在你的
    Apache 服务器上创建一个`/git`目录（或你备份的任何服务器），就像我们之前做的那样。然后，`cd`进入该目录，并使用以下命令克隆你的仓库：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For that command, replace the IP address with either the IP address of your
    Git server or its hostname if you’ve created a DNS entry for it. You should see
    the following output, warning us that we’ve cloned an empty repository:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在该命令中，将 IP 地址替换为你的 Git 服务器的 IP 地址或其主机名，如果你为其创建了 DNS 条目。你应该会看到如下输出，警告我们已经克隆了一个空的仓库：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is fine, we haven’t actually added anything to our repository yet. If you
    were to `cd` into the directory we just cloned and list its storage, you’d see
    it as an empty directory. If you use `ls -a` to view hidden directories as well,
    you’ll see a `.git` directory inside. Inside the `.git` directory, we’ll have
    configuration items for Git that allow this repository to function properly. For
    example, the config file in the `.git` directory contains information on where
    the remote server is located. We won’t be manipulating this directory; I just
    wanted to give you a quick overview of what its purpose is.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这没关系，我们实际上还没有向仓库中添加任何内容。如果你`cd`进入我们刚才克隆的目录并列出其存储内容，你会发现它是一个空目录。如果使用`ls -a`来查看隐藏目录，你会看到里面有一个`.git`目录。在`.git`目录内，我们将有
    Git 配置项，这些配置项使得这个仓库能够正常工作。例如，`.git`目录中的配置文件包含有关远程服务器位置的信息。我们不会操作这个目录；我只是想给你一个简要的概述，说明它的用途。
- en: Note that if you delete the `.git` directory in your cloned repository, that
    basically removes version control from the directory and makes it a normal directory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你删除了克隆仓库中的`.git`目录，那么这基本上就会移除版本控制，使该目录变成一个普通目录。
- en: 'Anyway, let’s continue. We should first make a backup of our current `/etc/apache2`
    directory on our web server, in case we make a mistake while converting it to
    being version controlled:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不管怎样，我们继续。我们应该先对当前的`/etc/apache2`目录进行备份，以防在将其转为版本控制时出现错误：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we can move all the contents of `/etc/apache2` into our repository:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将`/etc/apache2`目录的所有内容移入我们的仓库：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `/etc/apache2` directory is now empty. Be careful not to restart Apache
    at this point; it won’t see its configuration files and will fail. Remove the
    (now empty) `/etc/apache2` directory:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/apache2`目录现在是空的。此时要小心不要重新启动 Apache；它无法看到配置文件，会启动失败。请删除（现在已经空的）`/etc/apache2`目录：'
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let’s make sure that Apache’s files are owned by `root`. The problem though
    is if we use the `chown` command, as we normally would to change ownership, we’ll
    also change the `.git` directory to be owned by `root` as well. We don’t want
    that, because the user responsible for pushing changes should be the owner of
    the `.git` folder. The following command will change the ownership of the files
    to `root`, but won’t touch hidden directories such as `.git`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们确保 Apache 的文件由`root`用户拥有。但问题是，如果我们像平常一样使用`chown`命令来更改所有权，我们也会将`.git`目录的所有权更改为`root`。我们不希望这样，因为负责推送更改的用户应该是`.git`文件夹的所有者。以下命令将会把文件的所有权更改为`root`，但不会影响像`.git`这样的隐藏目录：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you list the contents of your repository directory now, you should see
    that all files are owned by `root`, except for the `.git` directory, which should
    be owned by your administrative user account.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在列出你的代码库目录的内容时，你应该看到所有的文件都被`root`拥有，除了`.git`目录，它应该被你的管理用户账户所拥有。
- en: 'Next, create a symbolic link to your Git repository so the `apache2` daemon
    can find it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个符号链接到你的Git仓库，这样`apache2`守护程序就能找到它：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At this point, you should see a symbolic link for Apache, located at `/etc/apache2`.
    If you list the contents of `/etc` while grepping for `apache2`, you should see
    it as a symbolic link:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你应该能看到一个位于`/etc/apache2`的Apache符号链接。如果你列出`/etc`的内容并使用`apache2`作为关键词搜索，你应该能看到它作为一个符号链接：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The directory listing will look similar to the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 目录列表看起来应该类似于以下内容：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you reload Apache, nothing should change and it should find the same configuration
    files as it did before, since its directory in `/etc` maps to `/git/apache2`,
    which includes the same files it did before:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新加载Apache，不应该有任何变化，它应该能够找到与之前相同的配置文件，因为它在`/etc`目录中的目录映射到`/git/apache2`，其中包括之前相同的文件：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you see no errors, you should be all set. Otherwise, make sure you created
    the symbolic link properly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到任何错误，一切应该都设置好了。否则，请确保你正确创建了符号链接。
- en: 'Next, we get to the main attraction. We’ve copied Apache’s files into our repository,
    but we didn’t actually push those changes back to our Git server yet. To set that
    up, we’ll need to associate the files within our `/git/apache2` directory into
    version control. The reason for this is the files simply being in the `git` repository
    folder isn’t enough for Git to care about them. We have to tell Git to pay attention
    to individual files. We can add every file within our Git repository for Apache
    by entering the following command from within that directory:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看主要内容。我们已经将Apache的文件复制到我们的代码库中，但尚未将这些更改推送回Git服务器。为了完成这一步，我们需要将位于我们的`/git/apache2`目录内的文件关联到版本控制中。这么做的原因是，文件只放在`git`仓库文件夹中是不足以让Git关心它们的。我们必须告诉Git关注这些单独的文件。我们可以通过在该目录内输入以下命令来将Apache的每个文件添加到我们的Git仓库中：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This basically tells Git to add everything in the directory to version control.
    You can actually do the following to add an individual file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上告诉Git将目录中的所有内容添加到版本控制中。你实际上可以这样做来添加一个单独的文件：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, we want to add everything, so we used a period in place of a directory
    name to add the entire current directory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们想要添加所有内容，所以我们使用一个句点来代替目录名称，以添加当前整个目录。
- en: 'If you run the `git status` command from within your Git repository, you should
    see output indicating that Git has new files that haven’t been committed yet.
    A **Git commit** simply finalizes the changes locally. Basically, it packages
    up your current changes to prepare them for being copied to the server. To create
    a commit of all the files we’ve added so far, `cd` into your `/git/apache2` directory
    and run the following to stage a new commit:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Git仓库内运行`git status`命令，你应该会看到输出，指示Git有尚未提交的新文件。一个**Git提交**简单地在本地完成变更。基本上，它打包了你当前的变更以准备复制到服务器。要创建到目前为止添加的所有文件的提交，`cd`进入你的`/git/apache2`目录，并运行以下内容以准备一个新的提交：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this command, the `-a` option tells Git that you want to include anything
    that’s changed in your repository. The `-m` option allows you to attach a message
    to the commit, which is actually required. If you don’t use the `-m` option, it
    will open your default text editor and allow you to add a comment from there.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，`-a`选项告诉Git你想要包括所有已经变更的内容到你的仓库中。`-m`选项允许你附加一个提交消息，实际上这是必须的。如果你不使用`-m`选项，它会打开你的默认文本编辑器，并允许你从那里添加评论。
- en: 'Finally, we can `push` our changes back to the Git server:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将我们的更改`push`回Git服务器：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By default, the `git` suite of commands utilizes OpenSSH, so our `git push`
    command should create an SSH connection back to our server and push the files
    there. You won’t be able to inspect the contents of the Git directory on your
    Git server, because it won’t contain the same file structure as your original
    directory. Whenever you pull a Git repository though, the resulting directory
    structure will be just as you left it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`git`命令套件使用OpenSSH，因此我们的`git push`命令应该创建一个SSH连接返回我们的服务器并将文件推送到那里。你将无法检查Git服务器上的Git目录的内容，因为它不会包含与原始目录相同的文件结构。不过，每当你拉取一个Git仓库时，结果的目录结构将与你离开它时一样。
- en: 'From this point forward, if you need to restore a repository onto another server,
    all you should need to do is perform a Git clone. To clone the repository into
    your current working directory, execute the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从此之后，如果你需要将一个仓库恢复到另一台服务器上，你所需要做的就是执行 Git 克隆。要将仓库克隆到当前工作目录中，执行以下命令：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, each time you make changes to your configuration files, you can perform
    a `git commit` and then push the changes up to the server to keep the content
    safe:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次你修改配置文件时，你可以执行 `git commit`，然后将更改推送到服务器上，以确保内容的安全：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we know how to create a repository, push changes to a server, and pull
    the changes back down. Finally, we’ll need to know how to revert changes should
    our configuration get changed with non-working files. First, we’ll need to locate
    a known working commit. My favorite method is using the `tig` command. The `tig`
    package must be installed for this to work, but it’s a great utility to have:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何创建仓库、将更改推送到服务器并拉取更改。最后，我们还需要了解如何在配置被修改并出现无效文件时恢复更改。首先，我们需要定位一个已知的正常工作提交。我最喜欢的方法是使用
    `tig` 命令。为了使其工作，必须安装 `tig` 包，但它是一个非常实用的工具：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `tig` command (which is just `git` backward) gives us a semi-graphical
    interface to browse through our Git commits. To use it, simply execute the `tig`
    command from within a Git repository. In the following example screenshot, I’ve
    executed `tig` from within a Git repository on one of my servers:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`tig` 命令（其实是 `git` 的逆向命令）为我们提供了一个半图形化的界面，以便浏览我们的 Git 提交记录。要使用它，只需在 Git 仓库中执行
    `tig` 命令。在以下示例截图中，我已经在我的一台服务器上的 Git 仓库中执行了 `tig`：'
- en: '![](img/B18425_23_01.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_23_01.png)'
- en: 'Figure 23.1: An example of the tig command, looking at a repository for example
    scripts'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23.1：使用 `tig` 命令查看一个示例脚本仓库的示例
- en: 'While using `tig`, you’ll see a list of Git commits, along with their dates
    and comments that were entered with each. To inspect one, press the *up* and *down*
    arrows to change your selection, then press *Enter* on the one you want to view.
    You’ll see a new window, which will show you the `commit hash` (which is a long
    string of alphanumeric characters), as well as an overview of which lines were
    added or removed from the files within the commit. To revert one, you’ll first
    need to find the commit you want to revert to and get its commit hash. The `tig`
    command is great for finding this information. In most cases, the commit you’ll
    want to revert to is the one *before* the change took place. In my example screenshot,
    I fixed the syntax issue on 9/26/2020\. If I want to restore that file, I should
    revert to the commit below that. I can get the commit hash by highlighting that
    entry and pressing *Enter*. It’s at the top of the window. Then, I can exit `tig`
    by pressing *q*, and then revert to that commit:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `tig` 时，你会看到 Git 提交的列表，以及每个提交的日期和注释。要查看其中的一个，按 *上箭头* 和 *下箭头* 来更改选择，然后按 *Enter*
    键查看你想查看的提交。你会看到一个新窗口，显示 `commit hash`（这是一个由字母和数字组成的长字符串），以及该提交中哪些文件的行被添加或删除。要恢复某个提交，你首先需要找到你想恢复的提交，并获取其提交哈希值。`tig`
    命令非常适合用来查找这些信息。在大多数情况下，你需要恢复的提交是发生变更之前的那个。在我的示例截图中，我在 2020 年 9 月 26 日修复了语法问题。如果我想恢复那个文件，我应该恢复到它下面的那个提交。我可以通过高亮那个条目并按
    *Enter* 键来获取提交哈希。它会显示在窗口的顶部。然后，我可以按 *q* 键退出 `tig`，然后恢复到该提交：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And just like that, the entire directory tree for the repository instantly changes
    to exactly what it was before the bad commit took place. I can then restart or
    reload the daemon for this repository, and it will be back to normal.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，整个仓库的目录树会立刻恢复到坏提交发生之前的状态。我可以重新启动或重新加载该仓库的守护进程，它就会恢复正常。
- en: 'At this point, you’d want to test the application to make sure that the issue
    is completely fixed. After some time has passed and you’re finished testing, you
    can make the change permanent. First, we switch back to the most recent commit:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你需要测试应用程序，确保问题已经完全修复。在一些时间过去并完成测试后，你可以将更改永久化。首先，我们切换回最新的提交：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we permanently switch back to the commit that was found to be working
    properly:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们永久地切换回被认为正常工作的提交：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we can commit our reverted Git repository and push it back to the server:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以提交我们恢复的 Git 仓库，并将其推送回服务器：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, Git is a very useful ally to utilize when managing configuration
    files on your servers. This benefits disaster recovery, because if a bad change
    is made that breaks a daemon, you can easily revert the change. If the server
    were to fail, you can recreate your configuration almost instantly by just cloning
    the repository again. There’s certainly a lot more to Git than what we’ve gone
    over in this section, so feel free to pick up a book about it if you wish to take
    your knowledge to the next level. But in regard to managing your configuration
    with Git, all you’ll need to know is how to place files into version control,
    update them, and clone them to new servers. Some services you run on a server
    may not be a good candidate for Git, however. For example, managing an entire
    MariaDB database via Git would be a nightmare, since there is too much overhead
    with such a use case, and database entries would likely change too rapidly for
    Git to keep up. Use your best judgment. If you have some configuration files that
    are only manipulated every once in a while, they’ll be a perfect candidate for
    Git.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Git 是在管理服务器上的配置文件时非常有用的工具。这对灾难恢复有益，因为如果进行了不好的更改导致守护进程崩溃，你可以轻松地回退更改。如果服务器出现故障，你可以通过再次克隆仓库几乎立即重建配置。当然，Git
    远不止我们在本节中所讨论的内容，如果你希望将知识提升到更高的水平，可以考虑阅读一些相关书籍。不过，在管理配置时，使用 Git 你需要了解的只是如何将文件加入版本控制、更新文件以及将它们克隆到新服务器。有些服务可能不适合通过
    Git 来管理。例如，通过 Git 管理整个 MariaDB 数据库将是一场噩梦，因为这样的用例开销太大，并且数据库条目可能变化太快，Git 无法跟上。使用你的判断力。如果你有一些配置文件，它们只偶尔会被修改，那么它们将是
    Git 的理想管理对象。
- en: Backups are one of those things that some people don’t seem to take seriously
    until it’s too late. Data loss can be a catastrophic event for an organization,
    so it’s imperative that you implement a solid backup plan. In the next section,
    we’ll look at what that entails.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 备份是一些人往往在为时已晚时才意识到重要性的事情。数据丢失可能对组织造成灾难性影响，因此实施一个可靠的备份计划至关重要。在下一节中，我们将探讨这个计划包括哪些内容。
- en: Implementing a backup plan
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施备份计划
- en: Creating a solid backup plan is one of the most important things you’ll ever
    do as a server administrator. Even if you’re only using Ubuntu Server at home
    as a personal file server, backups are critical. During my career, I’ve seen disks
    fail many times. I often hear arguments about which hard disk manufacturer beats
    others in terms of longevity, but I’ve seen disk failures so often, I don’t trust
    any of them. All disks will fail eventually, it’s just a matter of when. And when
    they do fail, they’ll usually fail hard with no easy way to recover data from
    them. A sound approach to managing data is that any disk or server can fail, and
    it won’t matter, since you’ll be able to regenerate your data from other sources,
    such as a backup or secondary server.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可靠的备份计划是你作为服务器管理员所做的最重要的事情之一。即使你仅在家里使用 Ubuntu Server 作为个人文件服务器，备份也是至关重要的。在我的职业生涯中，我见过许多硬盘故障。我经常听到关于哪个硬盘厂商在耐用性方面优于其他厂商的争论，但我见过如此多的硬盘故障，已不再相信任何品牌。所有硬盘最终都会发生故障，这只是时间问题。当它们故障时，通常会非常严重，几乎没有简单的方法从中恢复数据。管理数据的明智方法是，任何硬盘或服务器都可能会失败，但这并不重要，因为你可以从其他来源（如备份或次要服务器）恢复数据。
- en: There’s no one best backup solution, since it all depends on what kind of data
    you need to secure, and what software and hardware resources are available to
    you. For example, if you manage a database that’s critical to your company, you
    should back it up regularly. If you have another server available, set up a replication
    secondary server so that your primary database isn’t a single point of failure.
    Not everyone has an extra server lying around, so sometimes you have to work with
    what you have available.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种最佳的备份解决方案，因为这完全取决于你需要保护的数据类型，以及你可用的软件和硬件资源。例如，如果你管理的是对公司至关重要的数据库，你应该定期进行备份。如果你有另一台服务器可用，可以设置一个复制的次要服务器，以确保你的主数据库不是单点故障。并不是每个人都有备用的服务器，所以有时候你必须利用现有的资源。
- en: This may mean that you’ll need to make some compromises, such as creating regular
    snapshots of your database server’s storage volume or regularly dumping a backup
    of your important databases to an external storage device.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能意味着你需要做出一些妥协，例如定期创建数据库服务器存储卷的快照，或者定期将重要数据库的备份导出到外部存储设备。
- en: The `rsync` utility is one of the most valuable pieces of software around to
    server administrators. It allows us to do some really wonderful things. In some
    cases, it can save us quite a bit of money. For example, online backup solutions
    are wonderful in the sense that we can use them to store off-site copies of our
    important files. However, depending on the volume of data, they can be quite expensive.
    With `rsync`, we can back up our data in much the same way, with not only our
    current files copied over to a backup target but also differentials. If we have
    another server to send the backup to, even better.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`rsync`工具是服务器管理员手中最有价值的软件之一。它使我们能够做一些非常棒的事情。在某些情况下，它甚至能为我们节省不少钱。例如，在线备份解决方案的优势在于，我们可以使用它们将重要文件的副本存储在异地。然而，根据数据量的不同，这些解决方案可能相当昂贵。使用`rsync`，我们可以以类似的方式备份数据，不仅能将当前文件复制到备份目标，还能进行增量备份。如果我们有另一台服务器可以接收备份，那就更好了。'
- en: At one company I managed servers for, they didn’t want to subscribe to an online
    backup solution. To work around that, a server was set up as a backup point for
    `rsync`. We set up `rsync` to back up to the secondary server, which housed quite
    a lot of files. Once the initial backup was complete, the secondary server was
    sent to one of our other offices in another state. From that point forward, we
    only needed to run `rsync` weekly, to back up everything that had been changed
    since the last backup. Sending files via `rsync` to the other site over the internet
    was rather slow, but since the initial backup was already complete before we sent
    the server there, all we needed to back up each week was differentials. Not only
    is this an example of how awesome `rsync` is and how we can configure it to do
    pretty much what paid solutions do but the experience was also a good example
    of utilizing what you have available to you.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾管理过一家公司，他们不想订阅在线备份解决方案。为了解决这个问题，我们将一台服务器设置为`rsync`的备份点。我们设置`rsync`将备份发送到一台包含大量文件的次级服务器。完成初始备份后，这台次级服务器被送到了我们其他州的一个办公室。从那时起，我们每周只需要运行`rsync`，备份自上次备份以来所有发生变化的文件。通过互联网将文件通过`rsync`发送到另一个站点的速度相当慢，但由于初始备份在服务器送到那里之前已经完成，因此每周备份的仅仅是增量数据。这不仅展示了`rsync`的强大功能以及我们如何配置它来完成与付费解决方案相似的工作，同时也展示了如何充分利用现有资源的经验。
- en: 'Since we’ve already gone over `rsync` in *Chapter 12*, *Sharing and Transferring
    Files*, I won’t repeat too much of that information here. But since we’re on the
    subject of backing up, the `--backup-dir` option is worth mentioning again. This
    option allows you to copy files that would normally be replaced to another location.
    As an example, here’s the `rsync` command I mentioned in *Chapter 12*, *Sharing
    and Transferring Files*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在*第12章*，*共享与传输文件*中讲解过`rsync`，所以在这里不会再重复太多的内容。但既然我们在讨论备份，还是值得再次提到`--backup-dir`选项。这个选项允许你将通常会被替换的文件复制到另一个位置。作为示例，以下是我在*第12章*，*共享与传输文件*中提到的`rsync`命令：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This command was part of the topic of creating an `rsync` backup script. The
    first command simply captures today’s date and stores it in a variable named `$CURDATE`.
    In the actual `rsync` command, we refer to this variable. The `-b` option (part
    of the `-avb` option string) tells `rsync` to make a copy of any file that would
    normally be replaced. If `rsync` is going to replace a file on the target with
    a new version, it will move the original file to a new name before overwriting
    it. The `--backup-dir` option tells `rsync` that when it’s about to overwrite
    a file, to put it somewhere else instead of copying it to a new name. We give
    the `--backup-dir` option a path, where we want the files that would normally
    be replaced to be copied. In this case, the backup directory includes the `$CURDATE`
    variable, which will be different every day. For example, a backup run on 8/16/2022
    would have a backup directory of the following path, if we used the command I
    gave as an example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令是创建`rsync`备份脚本主题的一部分。第一个命令只是捕获今天的日期，并将其存储在一个名为`$CURDATE`的变量中。在实际的`rsync`命令中，我们会引用这个变量。`-b`选项（`-avb`选项字符串的一部分）告诉`rsync`对任何通常会被替换的文件进行备份。如果`rsync`要用新版本替换目标文件，它将在覆盖之前将原始文件重命名并移动。`--backup-dir`选项告诉`rsync`，当它即将覆盖文件时，要将文件放到其他地方，而不是复制到新名称。在这个选项中，我们提供一个路径，指定通常会被替换的文件应该复制到哪里。在这种情况下，备份目录包含了`$CURDATE`变量，这样每天的备份目录都会不同。例如，如果在2022年8月16日执行备份，使用我提供的命令作为示例，备份目录的路径将如下所示：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This essentially allows you to keep differentials. Files on `/src` will still
    be copied to `/target`, but the directory you identify as `--backup-dir` will
    contain the original files before they were replaced that day.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上允许你保留差异。`/src`中的文件仍然会被复制到`/target`，但你指定的`--backup-dir`目录将包含在当天被替换前的原始文件。
- en: 'On my servers, I use the `--backup-dir` option with `rsync` quite often. I’ll
    typically set up an external backup drive, with the following three folders:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的服务器上，我经常使用`rsync`的`--backup-dir`选项。我通常会设置一个外部备份驱动器，并创建以下三个文件夹：
- en: '`current`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current`'
- en: '`archive`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`archive`'
- en: '`logs`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logs`'
- en: The `current` directory always contains a current snapshot of the files on my
    server. The `archive` directory on my backup disks is where I point the `--backup-dir`
    option. Within that directory will be folders named with the dates that the backups
    were taken. The `logs` directory contains log files from the backup. Basically,
    I redirect the output of my `rsync` command to a log file within that directory,
    each log file being named with the same `$CURDATE` variable so I’ll also have
    a backup log for each day the backup runs. I can easily look at any of the logs
    for which files were modified during that backup, and then traverse the archive
    folder to find an original copy of a file. I’ve found this approach to work very
    well. Of course, this backup is performed with multiple backup disks that are
    rotated every week, with one always off-site. It’s always crucial to keep a backup
    off-site in case of a situation that could compromise your entire local site.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`current`目录始终包含我服务器上文件的当前快照。我备份磁盘上的`archive`目录是我指定`--backup-dir`选项的位置。在该目录下，将有以备份日期命名的文件夹。`logs`目录包含来自备份的日志文件。基本上，我会将`rsync`命令的输出重定向到该目录中的日志文件，每个日志文件都以相同的`$CURDATE`变量命名，因此每次备份运行时我也会有一个备份日志。我可以轻松查看任何日志，以了解在那次备份中哪些文件被修改，然后遍历归档文件夹以找到文件的原始副本。我发现这种方法非常有效。当然，备份是通过多个备份磁盘执行的，每周轮换一次，并且总有一个备份是异地存储的。始终保持异地备份是至关重要的，以防发生可能危及本地站点的情况。'
- en: The `rsync` utility is just one of many you can utilize to create your own backup
    scheme. The plan you come up with will largely depend on what kind of data you’re
    wanting to protect and what kind of downtime you’re willing to endure.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`rsync`工具是你可以利用的众多工具之一，用来创建你自己的备份方案。你制定的计划将主要取决于你想要保护的数据类型以及你愿意承受的停机时间。'
- en: Ideally, we would have an entire warm site with servers that are carbon copies
    of our production servers, ready to be put into production should any issues arise,
    but that’s also very expensive, and whether you can implement such a routine will
    depend on your budget. However, Ubuntu has many great utilities available that
    you can use to come up with your own system that works. If nothing else, utilize
    the power of `rsync` to back up to external disks and/or external sites.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们会有一个完整的备用站点，里面的服务器是我们生产服务器的完整复制品，一旦出现问题可以立即投入生产，但这也是非常昂贵的，是否能够实现这样的常规将取决于你的预算。然而，Ubuntu提供了许多出色的工具，你可以利用它们来制定适合自己的系统。如果没有其他选择，至少可以利用`rsync`的强大功能，将备份存储到外部磁盘和/或外部站点。
- en: A tool that is very valuable when working to recover physical servers is USB
    recovery media, such as flash drives with a bootable ISO image written to them.
    In the next section, we’ll take a look.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在恢复物理服务器时，**USB恢复介质**是一个非常有价值的工具，例如将可启动的ISO镜像写入的闪存驱动器。在下一节中，我们将对此进行详细探讨。
- en: Utilizing bootable recovery media
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可启动恢复介质
- en: The concept of **live media** is a wonderful thing, as we can boot into a completely
    different working environment from the operating system installed on our device
    and perform tasks without disrupting installed software on the host system. The
    desktop version of Ubuntu, for example, offers a complete computing environment
    we can use in order to not only test hardware and troubleshoot our systems but
    also browse the web just as we would on an installed system. In terms of recovering
    from disasters, live media becomes a saving grace.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**实时介质**的概念非常棒，因为我们可以从安装在设备上的操作系统启动到一个完全不同的工作环境，并在不干扰主机系统上已安装软件的情况下执行任务。例如，Ubuntu的桌面版本提供了一个完整的计算环境，我们可以在其中不仅测试硬件和排除故障，还可以像在安装系统上一样浏览网页。在灾难恢复方面，实时介质成为了救命稻草。'
- en: As administrators, we run into one problem after another. This gives us our
    job security. Computers often seemingly have a mind of their own, failing when
    least expected (as well as seemingly every holiday). Our servers and desktops
    can encounter a fault at any time, and live media allows us to separate hardware
    issues from software issues, by troubleshooting from a known good working environment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为管理员，我们会遇到一个接一个的问题。这也为我们的职业安全提供了保障。计算机常常在最不经意的时候发生故障（而且似乎每个假期都会发生）。我们的服务器和台式机可能随时会出现故障，而直播媒体让我们能够通过从已知的正常工作环境进行故障排除，将硬件问题与软件问题区分开来。
- en: One of my favorites when it comes to live media is the desktop version of Ubuntu.
    Although geared primarily toward end users who wish to install Ubuntu on a laptop
    or desktop, as administrators we can use it to boot a machine that normally wouldn’t,
    or even recover data from failed disks. For example, I’ve used the Ubuntu live
    media to recover data from both failed Windows and Linux systems, by booting the
    machine with the live media and utilizing a network connection to move data from
    the bad machine to a network share. Often, when a computer or server fails to
    boot, the data on its disk is still accessible. Assuming the disk wasn’t encrypted
    during installation, you should have no problem accessing data on a server or
    workstation using live media such as Ubuntu live media.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在直播媒体方面，Ubuntu 的桌面版本是我最喜欢的之一。虽然它主要面向希望在笔记本或台式机上安装 Ubuntu 的终端用户，但作为管理员，我们可以利用它启动那些通常无法启动的计算机，甚至从故障磁盘中恢复数据。例如，我曾使用
    Ubuntu 直播媒体从失败的 Windows 和 Linux 系统中恢复数据，方法是通过直播媒体启动计算机，并利用网络连接将数据从故障计算机转移到网络共享。通常，当计算机或服务器无法启动时，其磁盘上的数据仍然可以访问。假设在安装时磁盘没有被加密，你应该可以通过使用像
    Ubuntu 直播媒体这样的直播媒体访问服务器或工作站上的数据。
- en: Sometimes, certain levels of failure require us to use different tools. While
    Ubuntu’s live media is great, it doesn’t work for absolutely everything. One situation
    is a failing disk. Often, you’ll be able to recover data using Ubuntu’s live media
    from a failing disk, but if it’s too far gone, then the Ubuntu media will have
    difficulty accessing data from it as well. Tools such as Clonezilla specialize
    in working with hard disks and may be a better choice.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，某些级别的故障需要我们使用不同的工具。虽然 Ubuntu 的直播媒体非常棒，但它并不适用于所有情况。一种情况是磁盘故障。通常，你可以使用 Ubuntu
    的直播媒体从故障磁盘中恢复数据，但如果磁盘问题过于严重，Ubuntu 媒体也会难以从中访问数据。像 Clonezilla 这样的工具专门用于处理硬盘，可能是更好的选择。
- en: Live media can totally save the day. The Ubuntu live image in particular is
    a great boot disk to have available to you, as it gives you a very extensive environment
    you can use to troubleshoot systems and recover data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 直播媒体完全可以救场。特别是 Ubuntu 直播镜像，它是一个很好的启动磁盘，可以随时使用，因为它为你提供了一个非常广泛的环境，可以用来进行系统故障排除和数据恢复。
- en: One of the best aspects of using the Ubuntu live image is that you won’t have
    to deal with the underlying operating system and software set at all, you can
    bypass both by booting into a known working desktop, and then copy any important
    files from the drive right onto a network share. Another important feature of
    Ubuntu live media is the memory test option. Quite often, strange failures on
    a computer can be traced to defective memory. Other than simply letting you install
    Ubuntu, the live media is a Swiss Army knife of many tools you can use to recover
    a system from disaster. If nothing else, you can use live media to pinpoint whether
    a problem is software- or hardware-related. If a problem can only be reproduced
    in the installed environment but not in a live session, chances are a configuration
    problem is to blame. If a system also misbehaves in a live environment, it may
    help you identify a hardware issue. Either way, every good administrator should
    have live media available to troubleshoot systems and recover data when the need
    arises.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ubuntu 直播镜像的最佳方面之一是，你根本不需要处理底层操作系统和软件集。你可以通过启动已知正常工作的桌面跳过这两者，然后将任何重要文件从驱动器直接复制到网络共享。Ubuntu
    直播媒体的另一个重要功能是内存测试选项。计算机上经常出现奇怪故障时，可以追溯到内存故障。除了让你安装 Ubuntu 之外，直播媒体是一个集多种工具于一体的瑞士军刀，你可以利用这些工具从灾难中恢复系统。即使没有其他功能，你也可以使用直播媒体来判断问题是软件相关还是硬件相关。如果问题只能在已安装的环境中重现，而在直播会话中没有重现，很可能是配置问题导致的。如果系统在直播环境中也出现异常，它可能帮助你识别硬件问题。不管怎样，每个优秀的管理员都应该拥有直播媒体，以便在需要时进行故障排除和数据恢复。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we looked at several ways in which we can prevent and recover
    from disasters. Having a sound prevention and recovery plan in place is an important
    key to managing servers efficiently. We need to ensure we have backups of our
    most important data ready for whenever servers fail, and we should also keep backups
    of our most important configurations. Ideally, we’ll always have a warm site set
    up with preconfigured servers ready to go in a situation where our primary servers
    fail, but one of the benefits of open source software is that we have a plethora
    of tools available to us that we can use to create a sound recovery plan. In this
    chapter, we looked at leveraging `rsync` as a useful utility for creating differential
    backups, and we also looked into setting up a Git server we can use for configuration
    management, which is also a crucial aspect of any sound prevention plan. We also
    talked about the importance of live media in diagnosing issues.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了几种可以防止和恢复灾难的方法。制定一个合理的预防和恢复计划是高效管理服务器的关键。我们需要确保在服务器发生故障时，能够准备好我们最重要数据的备份，同时还应该保留我们最重要配置的备份。理想情况下，我们总是会有一个热备站点，预配置好的服务器可以在主要服务器发生故障时启用，但开源软件的一个好处是我们可以使用众多工具来创建合理的恢复计划。在本章中，我们探讨了如何利用
    `rsync` 作为一种有用的工具来创建差异备份，我们还研究了如何设置一个 Git 服务器，用于配置管理，这也是任何合理的预防计划的关键部分。我们还讨论了在诊断问题时，实时介质的重要性。
- en: And with this chapter, this book comes to a close. Writing this book has been
    an extremely joyful experience. I was thrilled to write the first edition when
    Ubuntu 16.04 was in development, it was a fun project to write the second edition
    and update it to cover Ubuntu 18.04, the third edition for 20.04, and I’m even
    more thrilled to have had the opportunity to update this body of work yet again
    for 22.04 in this latest edition. I’d like to thank each and every one of you,
    my readers, for taking the time to read this book. In addition, I would like to
    thank all of the viewers of my YouTube channel, *Learn Linux TV* ([https://www.learnlinux.tv](https://www.learnlinux.tv)),
    because I probably wouldn’t have had the opportunity to write this in the first
    place had it not been for my viewers helping make my channel so popular.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一章的结束，本书也画上了句号。编写这本书是一次非常愉快的经历。当 Ubuntu 16.04 还在开发时，我激动地写下了第一版，编写第二版并更新它以涵盖
    Ubuntu 18.04 是一项有趣的项目，第三版则涵盖了 20.04，而我更高兴的是能够再次更新这本书，针对 22.04 发布了最新版本。我想感谢每一位读者，感谢你们抽出时间阅读本书。此外，我还要感谢我
    YouTube 频道的所有观众，*Learn Linux TV* ([https://www.learnlinux.tv](https://www.learnlinux.tv))，因为如果没有我的观众帮助使我的频道变得如此受欢迎，我可能根本没有机会写下这本书。
- en: I’d also like to thank Packt Publishing for giving me the opportunity to write
    a book about one of my favorite technologies. Writing this book was definitely
    an honor. When I first started with Linux in 2002, I never thought I’d actually
    be an author, teaching the next generation of Linux administrators the tricks
    of the trade. I wish each of you the best of luck, and I hope this book is beneficial
    to you and your career.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我还要感谢 Packt 出版社给我机会编写一本关于我最喜欢的技术之一的书。写这本书真的是一种荣幸。当我在 2002 年第一次接触 Linux 时，我从未想过自己会成为一名作者，教授下一代
    Linux 管理员行业的技巧。我祝愿你们每个人都好运，并希望这本书对你和你的职业有所帮助。
- en: For additional content, be sure to check out [https://learnlinux.tv](https://learnlinux.tv)
    for even more content. I have quite a few training videos available there, free
    of charge.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更多内容，务必访问 [https://learnlinux.tv](https://learnlinux.tv)，这里有更多的内容。我有许多免费的培训视频可供观看。
- en: Further reading
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Pro Git* by Scott Chacon and Ben Straub: [https://learnlinux.link/git-book](https://learnlinux.link/git-book)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pro Git* 由 Scott Chacon 和 Ben Straub 编写：[https://learnlinux.link/git-book](https://learnlinux.link/git-book)'
- en: '*Introduction to RAID terminology and concepts*: [https://learnlinux.link/raid-concepts](https://learnlinux.link/raid-concepts)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RAID 术语和概念简介*：[https://learnlinux.link/raid-concepts](https://learnlinux.link/raid-concepts)'
- en: Join our community on Discord
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 讨论区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者一起讨论：
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code50046724-1955875156.png)'
