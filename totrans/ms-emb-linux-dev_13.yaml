- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Updating Software in the Field
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现场软件更新
- en: In previous chapters, we discussed various ways to build software for a Linux
    device and how to create system images for various types of mass storage. When
    you go into production, you just need to copy the system image to the flash memory,
    and it is ready to be deployed. Now I want to consider the life of the device
    beyond the first shipment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了为 Linux 设备构建软件的各种方法，以及如何为各种类型的大容量存储设备创建系统镜像。当你进入生产阶段时，你只需要将系统镜像复制到闪存中，它就可以准备好部署了。现在，我想考虑设备在首次发货后的生命周期。
- en: As we move into the era of the *Internet of Things*, the devices that we create
    are very likely to be connected to the internet. At the same time, software is
    becoming exponentially more complex. More software means more bugs. Connection
    to the internet means those bugs can be exploited from afar. Consequentially,
    we have a common requirement to be able to update software *in the field*. By
    “in the field,” we mean “outside of the factory.” Software updates bring more
    advantages than fixing bugs. They open the door to adding value to existing hardware
    by enabling new features and improving system performance over time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入 *物联网* 时代，我们创建的设备很可能会连接到互联网。同时，软件变得越来越复杂。更多的软件意味着更多的漏洞。连接到互联网意味着这些漏洞可能会被远程利用。因此，我们有一个共同的需求，即能够在
    *现场* 更新软件。所谓“现场”是指“工厂之外”。软件更新带来的好处不仅仅是修复漏洞。它们为现有硬件增加新功能并随着时间的推移提高系统性能，从而带来了更多的价值。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: From where do updates originate?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新从哪里来源？
- en: What to update
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新内容
- en: Basics of software updates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件更新基础
- en: Types of update mechanism
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新机制的类型
- en: OTA updates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OTA 更新
- en: Using Mender for local updates
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mender 进行本地更新
- en: Using Mender for OTA updates
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mender 进行 OTA 更新
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟上示例，请确保你拥有以下内容：
- en: An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台至少有 90 GB 空闲磁盘空间的 Ubuntu 24.04 或更高版本的 LTS 主机系统
- en: Yocto 5.0 (scarthgap) LTS release
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yocto 5.0（scarthgap）LTS 版本
- en: You should have already built the 5.0 (scarthgap) LTS release of Yocto in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110). If you have not, then please refer to
    the *Compatible Linux Distributions* and *Build Host Packages* sections of the
    *Yocto Project Quick Build* guide ([https://docs.yoctoproject.org/brief-yoctoprojectqs/)](https://docs.yoctoproject.org/brief-yoctoprojectqs/))
    before building Yocto on your Linux host according to the instructions in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经在 [*第 6 章*](Chapter_04.xhtml#_idTextAnchor110) 中构建了 Yocto 5.0（scarthgap）LTS
    版本。如果没有，请在根据 [*第 6 章*](Chapter_04.xhtml#_idTextAnchor110) 中的说明在 Linux 主机上构建 Yocto
    之前，参考 *Yocto 项目快速构建* 指南中的 *兼容的 Linux 发行版* 和 *构建主机包* 部分 ([https://docs.yoctoproject.org/brief-yoctoprojectqs/)](https://docs.yoctoproject.org/brief-yoctoprojectqs/))。
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter10](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter10).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在本书 GitHub 仓库中的章节文件夹找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter10](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter10)。
- en: From where do updates originate?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新从哪里来源？
- en: 'There are many approaches to software updates. Broadly, I characterize them
    as the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以进行软件更新。大体上，我将它们归类为以下几种：
- en: '**Local updates**: Performed by a technician who carries the update on a portable
    medium such as a USB flash drive or an SD card and has to access each system individually.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地更新**：由技术人员执行，通过便携介质如 USB 闪存驱动器或 SD 卡携带更新，并需要逐一访问每个系统。'
- en: '**Remote updates**: Initiated by the user or a technician locally, but downloaded
    from a remote server.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程更新**：由用户或技术人员在本地发起，但从远程服务器下载。'
- en: '**Over-the-air** (**OTA**) **updates**: Pushed and managed entirely remotely
    without any need for local input.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空中下载更新**（**OTA**）**更新**：完全远程推送和管理，无需任何本地输入。'
- en: I will begin by describing several approaches to software updates, then I will
    show an example using Mender.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先描述几种软件更新的方法，然后展示一个使用 Mender 的示例。
- en: What to update
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新内容
- en: 'Embedded Linux devices are very diverse in their design and implementation.
    However, they all have these basic components:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式 Linux 设备在设计和实现上有很大的多样性。然而，它们都包含这些基本组件：
- en: Bootloader
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导加载程序
- en: Kernel
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核
- en: Root filesystem
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件系统
- en: System applications
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统应用程序
- en: Device-specific data
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定设备的数据
- en: 'Some components are harder to update than others, as summarized in this diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有些组件比其他组件更难更新，如下图所示：
- en: '![Figure 10.1 – Components of an update](img/B18466_10_01.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 更新的组件](img/B18466_10_01.png)'
- en: Figure 10.1 – Components of an update
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 更新的组件
- en: Let’s look at each component in turn.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个查看这些组件。
- en: Bootloader
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导加载程序
- en: 'The bootloader is the first piece of code to run when the processor is powered
    up. The way the processor locates the bootloader is very device-specific, but
    in most cases, there is only one such location, so there can only be one bootloader.
    If there is no backup, then updating the bootloader is risky: what happens if
    the system powers down midway? Consequently, most update solutions leave the bootloader
    alone. This is not a big problem, because the bootloader only runs for a short
    time at power-on and is not normally a great source of runtime bugs.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序是处理器上电后运行的第一段代码。处理器找到引导加载程序的方式非常依赖于设备，但在大多数情况下，只有一个这样的地点，因此只能有一个引导加载程序。如果没有备份，更新引导加载程序是有风险的：如果系统在过程中断电会发生什么？因此，大多数更新解决方案都不会更改引导加载程序。这并不是一个大问题，因为引导加载程序在开机时只运行很短的时间，通常不是导致运行时错误的主要源头。
- en: Kernel
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核
- en: The Linux kernel is a critical component that will certainly need updating from
    time to time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核是一个关键组件，肯定需要不时进行更新。
- en: 'There are several parts to the kernel:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 内核有多个部分：
- en: A binary image loaded by the bootloader, often stored in the root filesystem.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由引导加载程序加载的二进制映像，通常存储在根文件系统中。
- en: Many devices also have a **device tree binary** (**DTB**) that describes hardware
    to the kernel, and so must be updated in tandem. The DTB is usually stored alongside
    the kernel binary.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多设备还拥有一个**设备树二进制文件**（**DTB**），它向内核描述硬件，因此必须与内核一起更新。DTB 通常与内核二进制文件一起存储。
- en: There may be kernel modules in the root filesystem.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件系统中可能包含内核模块。
- en: The kernel and DTB may be stored in the root filesystem if the bootloader can
    read the filesystem format, or it may be in a dedicated partition. In either case,
    it is possible and safer to have redundant copies.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 内核和 DTB 可以存储在根文件系统中（如果引导加载程序能读取该文件系统格式），也可以存储在专用分区中。在任何一种情况下，拥有冗余副本都是可能的并且更安全。
- en: Root filesystem
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根文件系统
- en: The root filesystem contains the essential system libraries, utilities, and
    scripts needed to make the system work. It is very desirable to be able to replace
    and upgrade all of these. The mechanism depends on the filesystem implementation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统包含使系统正常工作的基本系统库、工具和脚本。能够替换和升级所有这些是非常期望的。机制依赖于文件系统的实现。
- en: 'Common formats for embedded root filesystems are the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式根文件系统的常见格式如下：
- en: '**RAM disk**: Loaded from raw flash memory or a disk image at boot. To update
    it, simply overwrite the RAM disk image and reboot.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAM 磁盘**：从原始闪存内存或磁盘映像加载。要更新它，只需覆盖 RAM 磁盘映像并重启系统。'
- en: '**Read-only compressed filesystems (squashfs**): Stored in a flash partition.
    Since these filesystems don’t have a write function, the only way to update them
    is to write a complete filesystem image to the partition.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只读压缩文件系统（squashfs）**：存储在闪存分区中。由于这些文件系统没有写功能，因此更新它们的唯一方法是将完整的文件系统映像写入分区。'
- en: '**Normal filesystem types**: JFFS2 and UBIFS formats are common for raw flash
    memory. For managed flash memory such as eMMC and SD cards, the format is likely
    to be ext4 or F2FS. Since these are writable at runtime, it is possible to update
    them file by file.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见文件系统类型**：JFFS2 和 UBIFS 格式通常用于原始闪存内存。对于如 eMMC 和 SD 卡这样的管理型闪存内存，格式可能是 ext4
    或 F2FS。由于这些文件系统在运行时可写，因此可以逐文件更新它们。'
- en: System applications
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统应用程序
- en: The system applications are the main payload of the device; they implement its
    primary function. As such, they are likely to be updated frequently to fix bugs
    and add features. They may be bundled with the root filesystem, but it is also
    common for them to be placed in a separate filesystem to make updating easier
    and to maintain separation between the system files, which are usually open source,
    and the application files, which are often proprietary.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应用程序是设备的主要载荷；它们实现了设备的主要功能。因此，它们可能会频繁更新以修复错误和添加功能。它们可能与根文件系统捆绑在一起，但也常常被放置在单独的文件系统中，以便更容易更新，并且可以保持系统文件（通常是开源的）与应用程序文件（通常是专有的）之间的分离。
- en: Device-specific data
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定设备的数据
- en: This is the combination of files that are modified at runtime. Device-specific
    data includes configuration settings, logs, user-supplied data, and similar files.
    It is not often that they need to be updated, but they do need to be preserved
    during an update. Such data needs to be stored in a partition of its own.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行时修改的文件组合。设备特定的数据包括配置设置、日志、用户提供的数据以及类似的文件。这些数据通常不需要更新，但在更新过程中需要被保留。这些数据需要存储在专用的分区中。
- en: Components that need to be updated
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要更新的组件
- en: In summary, an update may include new versions of the kernel, root filesystem,
    and system applications. The device will have other partitions that should not
    be disturbed by an update, as is the case with the device runtime data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，更新可能包括内核、新版本的根文件系统和系统应用。设备会有其他分区，更新时不应该受到干扰，像设备运行时数据一样。
- en: The cost of software updates failing can be catastrophic. Secure software updates
    are also a major concern within both enterprise and home internet environments.
    Before we can ship any hardware, we need to be able to update the software with
    confidence.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 软件更新失败的代价可能是灾难性的。安全的软件更新在企业和家庭互联网环境中都是一个重要问题。在我们能够发货任何硬件之前，我们必须能够自信地更新软件。
- en: Basics of software updates
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件更新基础
- en: 'Updating software seems, at first sight, to be a simple task: you just need
    to overwrite some files with new copies. But then your engineer training kicks
    in as you begin to realize all the things that could go wrong. What if the power
    goes down during the update? What if a bug missed during testing of the update
    renders a percentage of the devices unbootable? What if a third party sends a
    fake update that enlists your device as part of a botnet? At the very least, the
    software update mechanism must be:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 更新软件乍一看似乎是一个简单的任务：你只需要用新的文件覆盖旧的文件。但随着你工程师培训的展开，你开始意识到可能出错的地方。假如在更新过程中断电了怎么办？假如在更新测试中漏掉了一个bug，导致部分设备无法启动怎么办？假如第三方发送了一个假更新，把你的设备纳入了僵尸网络怎么办？至少，软件更新机制必须是：
- en: '**Robust** so that an update does not render the device unusable.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健壮**，确保更新不会导致设备无法使用。'
- en: '**Fail-safe** so that there is a fallback mode if all else fails.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障安全**，确保在所有失败时仍有备份模式。'
- en: '**Secure** to prevent the device from being hijacked by people installing unauthorized
    updates.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**，以防止设备被安装未经授权的更新而被劫持。'
- en: In other words, we need a system that is not susceptible to Murphy’s law. Murphy’s
    law states that if something can go wrong, then it eventually will go wrong. Some
    of these problems are non-trivial. Deploying software to a device in the field
    is different from deploying software to the cloud. Embedded Linux systems need
    to detect and respond to mishaps like kernel panics or boot loops without any
    human intervention.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们需要一个不容易受到墨菲定律影响的系统。墨菲定律表明，如果某件事有可能出错，那么它最终一定会出错。有些问题并非小事。将软件部署到现场设备与将软件部署到云端是不同的。嵌入式Linux系统需要在没有任何人工干预的情况下，检测并应对如内核崩溃或启动循环等意外情况。
- en: Making updates robust
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高更新的健壮性
- en: You might think that the problem of updating Linux systems was solved a long
    time ago − we all have Linux desktops that we update regularly (don’t we?). Also,
    there are vast numbers of Linux servers running in data centers that are similarly
    kept up to date. However, there is a difference between a server and a device.
    The former operates in a protected environment. It is unlikely to suffer a sudden
    loss of power or network connectivity. In the unlikely event that an update does
    fail, it is always possible to get access to the server and use external mechanisms
    to repeat the installation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为Linux系统更新的问题早已解决——我们都有定期更新的Linux桌面（不是吗？）。此外，数据中心里有大量的Linux服务器，也同样保持最新。然而，服务器和设备之间是有区别的。前者运行在一个受保护的环境中，不太可能突然失去电源或网络连接。如果更新确实失败了，仍然可以访问服务器，并使用外部机制重新安装。
- en: Devices, on the other hand, are often deployed at remote sites with intermittent
    power and a poor network connection, making it much more likely that an update
    will be interrupted. Therefore, consider that it may be very expensive to get
    access to a device to take remedial action over a failed update. What if, for
    example, the device is an environmental monitoring station at the top of a mountain
    or controlling the valves of an oil well at the bottom of the sea? In consequence,
    it is much more important for embedded devices to have a robust update mechanism
    that will not result in the system becoming unusable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，设备往往部署在远程站点，电力不稳定且网络连接差，这使得更新被中断的可能性大大增加。因此，考虑到在更新失败后，获取设备进行修复可能非常昂贵。比如，如果设备是一座山顶的环境监测站，或者是位于海底的油井阀门控制系统怎么办？因此，对于嵌入式设备来说，拥有一个健壮的更新机制尤为重要，以防系统无法使用。
- en: The key word here is **atomicity**. To be atomic, there should be no stage of
    the update where only part of the system is updated. There must be a single, uninterruptible
    change to the system that switches to the new version of the software.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键词是**原子性**。为了确保原子性，更新过程中不应有任何阶段是系统部分更新的。必须有一个单一且不可中断的更改，来将系统切换到新版本的软件。
- en: 'This removes the most obvious update mechanism from consideration: that of
    simply updating individual files by extracting an archive over parts of the filesystem.
    There is just no way to ensure that there will be a consistent set of files if
    the system is reset during the update. Even using a package manager such as `apt`,
    `dnf`, or `pacman` does not help. If you look at the internals of all these package
    managers, you will see that they do indeed work by extracting an archive over
    the filesystem and running scripts to configure the package both before and after
    the update. Package managers are fine for the protected world of the data center,
    or even your desktop, but not for a device.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这排除了最明显的更新机制：通过在文件系统的部分区域上提取归档文件来单独更新文件。若系统在更新过程中被重置，就无法确保文件的一致性。即使使用`apt`、`dnf`或`pacman`等包管理器也无法解决问题。如果你查看这些包管理器的内部工作机制，会发现它们的确是通过在文件系统上提取归档并运行脚本来配置软件包，既在更新之前，也在更新之后。包管理器在数据中心的受保护环境中，或者在你的桌面上是没问题的，但在设备上却不可行。
- en: To achieve atomicity, the update must be installed alongside the running system,
    and then a switch is thrown to move from the old to the new. In later sections,
    we will describe two different approaches to achieving atomicity. The first is
    to have two copies of the root filesystem and other major components. One copy
    is live, while the other can receive updates. When the update is complete, the
    switch is thrown so that, on reboot, the bootloader selects the updated copy.
    This is known as a **symmetric image update** or an **A/B image update**. A variant
    of this theme is to use a special **recovery mode** operating system that is responsible
    for updating the main operating system. The guarantee of atomicity is shared between
    the bootloader and the recovery operating system. This is known as an **asymmetric
    image update**. It is the approach taken by Android prior to the Nougat 7.x version.
    The second approach is to have two or more copies of the root filesystem in different
    subdirectories of the system partition, and then use `chroot(8)` at boot time
    to select one of them. Once Linux is running, the update client can install updates
    into the other root filesystem, and then when everything is complete and checked,
    it can throw the switch and reboot. This is known as an **atomic file update**
    and is exemplified by **OSTree**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现原子性，更新必须与正在运行的系统并行安装，然后切换到新版本的软件。在接下来的章节中，我们将描述实现原子性的两种不同方法。第一种方法是拥有两个根文件系统和其他主要组件的副本。一个副本是活动的，而另一个可以接收更新。当更新完成后，通过切换，重启时引导程序选择更新后的副本。这被称为**对称镜像更新**或**A/B镜像更新**。这种方法的变种是使用一个特殊的**恢复模式**操作系统，负责更新主操作系统。原子性的保证由引导程序和恢复操作系统共同承担。这被称为**非对称镜像更新**。这是Android在Nougat
    7.x版本之前采用的方法。第二种方法是，在系统分区的不同子目录中拥有两个或多个根文件系统副本，然后在启动时使用`chroot(8)`来选择其中一个副本。一旦Linux系统运行，更新客户端可以将更新安装到另一个根文件系统中，完成并检查所有内容后，可以切换并重启。这被称为**原子文件更新**，以**OSTree**为例。
- en: Making updates fail-safe
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使更新具备故障安全性
- en: The next problem to consider is that of recovering from an update that was installed
    correctly but that contains code that stops the system from booting. Ideally,
    we want the system to detect this case and revert to a previous working image.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来需要考虑的问题是，如何从一个已正确安装但包含使系统无法启动的代码的更新中恢复。理想情况下，我们希望系统能够检测到这种情况，并回滚到先前的工作镜像。
- en: There are several failure modes that can lead to a non-operational system. The
    first is a kernel panic, typically caused by a bug in a kernel device driver or
    being unable to run the `init` program. A sensible place to start is by configuring
    the kernel to reboot a number of seconds after a panic.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种故障模式可能导致系统无法操作。第一个是内核 panic，通常由内核设备驱动程序中的 bug 或无法运行`init`程序引起。一个合理的起点是通过配置内核，在
    panic 后的一定时间内重启。
- en: You can do this either when you build the kernel by setting `CONFIG_PANIC_TIMEOUT`
    or by setting the kernel command line to `panic`. For example, to reboot 5 seconds
    after a panic, you would add `panic=5` to the kernel command line.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在构建内核时通过设置`CONFIG_PANIC_TIMEOUT`来实现，或者通过将内核命令行设置为`panic`来实现。例如，要在 panic 后
    5 秒重启，可以将`panic=5`添加到内核命令行。
- en: You may want to go further and configure the kernel to `panic` on an Oops. Remember
    that an Oops is generated when the kernel encounters a fatal error. In some cases,
    it will be able to recover from the error, in other cases not. But in all cases,
    something has gone wrong and the system is not working as it should. To enable
    panic on Oops in the kernel configuration, set `CONFIG_PANIC_ON_OOPS=y` or, on
    the kernel command line, `oops=panic`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望进一步配置内核，使其在发生 Oops 错误时触发`panic`。请记住，Oops 是当内核遇到致命错误时生成的。在某些情况下，内核能够从错误中恢复，而在其他情况下则无法恢复。但无论如何，肯定是出现了问题，系统无法正常工作。要在内核配置中启用
    Oops 触发 panic，请设置`CONFIG_PANIC_ON_OOPS=y`，或者在内核命令行中设置`oops=panic`。
- en: A second failure mode occurs when the kernel launches `init` successfully but
    for some reason the main application fails to run. For this, you need a watchdog.
    A **watchdog** is a hardware or software timer that restarts the system if the
    timer is not reset before it expires. If you are using `systemd`, you can use
    the built-in watchdog function, which I’ll describe in [*Chapter 13*](Chapter_13.xhtml#_idTextAnchor431).
    If not, then you may want to enable the watchdog support built into Linux as described
    in `Documentation/watchdog` from the kernel source code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种故障模式发生在内核成功启动`init`后，但由于某种原因，主应用程序无法运行。对此，你需要一个看门狗。**看门狗**是一个硬件或软件定时器，如果定时器未在过期前重置，则会重新启动系统。如果你使用的是`systemd`，你可以使用内置的看门狗功能，我将在[*第
    13 章*](Chapter_13.xhtml#_idTextAnchor431)中描述。如果没有，你可能需要启用内核源代码中`Documentation/watchdog`描述的
    Linux 内置看门狗支持。
- en: 'Both failures result in **boot loops**: either a kernel panic or a watchdog
    timeout causes the system to reboot. If the problem is persistent, the system
    will reboot continually. To break out of the boot loop, we need some code in the
    bootloader to detect the case and to revert to the previously known good version.
    A typical approach is to use a **boot count** that is incremented by the bootloader
    on each boot and that is reset to zero in user space once the system is up and
    running. If the system enters a boot loop, the counter is not reset and so continues
    to increase. The bootloader is then configured to take remedial action if the
    counter exceeds a threshold.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种故障都会导致**启动循环**：无论是内核 panic 还是看门狗超时，都会导致系统重启。如果问题持续存在，系统将不断重启。要打破启动循环，我们需要在引导加载程序中添加一些代码，检测这种情况并回滚到先前已知的正常版本。一个典型的方法是使用**启动计数**，每次启动时引导加载程序都会递增该计数器，并且一旦系统启动并运行，计数器会在用户空间中被重置为零。如果系统进入启动循环，计数器不会被重置，从而继续增加。然后，配置引导加载程序，当计数器超过阈值时采取补救措施。
- en: 'In U-Boot this is handled by three variables:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 U-Boot 中，这通过三个变量来处理：
- en: '`bootcount`: Incremented each time the processor boots.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootcount`：每次处理器启动时递增。'
- en: '`bootlimit`: If `bootcount` exceeds `bootlimit`, U-Boot runs the commands in
    `altbootcmd` instead of `bootcmd`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootlimit`：如果`bootcount`超过`bootlimit`，U-Boot 将执行`altbootcmd`中的命令，而不是`bootcmd`。'
- en: '`altbootcmd`: Contains the alternative boot commands, for example, to roll
    back to a previous version of the software or to start the recovery-mode operating
    system.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`altbootcmd`：包含备用启动命令，例如回滚到先前的版本或启动恢复模式操作系统。'
- en: 'For this to work, there must be a way for a user-space program to reset the
    boot count. We can do that using U-Boot utilities that allow the U-Boot environment
    to be accessed at runtime:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一功能，必须有一种方法允许用户空间程序重置引导计数。我们可以使用 U-Boot 工具，通过它在运行时访问 U-Boot 环境：
- en: '`fw_printenv`: Prints the value of a U-Boot variable'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fw_printenv`：打印 U-Boot 变量的值'
- en: '`fw_setenv`: Sets the value of a U-Boot variable'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fw_setenv`：设置 U-Boot 变量的值'
- en: 'These two commands need to know where the U-Boot environment block is stored,
    for which there is a configuration file in `/etc/fw_env.config`. For example,
    if the U-Boot environment is stored at offset `0x800000` from the start of the
    eMMC memory with a backup copy at `0x1000000`, then the configuration would look
    like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令需要知道 U-Boot 环境块存储的位置，相关的配置文件位于 `/etc/fw_env.config`。例如，如果 U-Boot 环境存储在
    eMMC 内存的 `0x800000` 偏移位置，并且有一个备份副本在 `0x1000000`，那么配置文件会如下所示：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There is one final thing to cover in this section. Incrementing the boot count
    on each boot and then resetting it when the application starts leads to unnecessary
    writes to the environment block that wear out the flash memory. To prevent this
    from happening on all reboots, U-Boot has an additional variable named `upgrade_available`.
    If `upgrade_available` is `0`, then `bootcount` is not incremented since there
    is no unproven upgrade to guard against. `upgrade_available` is set to `1` after
    an update has been installed so that the boot count protection is only enabled
    when needed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最后需要讨论的一个问题是：每次启动时递增引导计数，并在应用程序启动时重置它，这会导致不必要的写入环境块，从而加速闪存的损耗。为了防止在每次重启时发生这种情况，U-Boot
    引入了一个名为 `upgrade_available` 的附加变量。如果 `upgrade_available` 为 `0`，则 `bootcount` 不会递增，因为没有未验证的升级需要防范。在安装更新后，`upgrade_available`
    会被设置为 `1`，这样只有在需要时才会启用引导计数保护。
- en: Making updates secure
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让更新变得安全
- en: The final problem relates to the potential misuse of the update mechanism itself.
    Your prime intention when implementing an update mechanism is to provide a reliable
    automated or semi-automated method to install security patches and new features.
    However, others may use the same mechanism to install unauthorized versions of
    software and hijack the device. We need to ensure that this does not happen.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题涉及更新机制本身的潜在滥用。当你实现更新机制时，主要目的是提供一种可靠的自动化或半自动化的方法来安装安全补丁和新功能。然而，其他人可能利用同样的机制安装未经授权的软件版本，并劫持设备。我们需要确保这种情况不会发生。
- en: The biggest vulnerability is that of a fake remote update. To prevent this,
    we need to authenticate the update server before starting the download. We also
    need a secure transfer channel, such as HTTPS, to guard against tampering with
    the download stream. Checksums offer a second line of defense. A checksum is generated
    for each update and published on the server. The update only gets applied if the
    checksum validates against the download. I will return to the topic of server
    authenticity when I describe OTA updates.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的安全漏洞是伪造的远程更新。为了防止这种情况发生，我们需要在下载开始之前验证更新服务器的身份。同时，我们还需要一个安全的传输通道，例如 HTTPS，以防止下载流的篡改。校验和提供了第二道防线。每个更新都会生成一个校验和，并发布到服务器上。只有在校验和与下载内容匹配时，更新才会被应用。当我描述
    OTA 更新时，我会回到服务器身份验证的话题。
- en: There is also the question of image authenticity. One way to detect a bogus
    update is to use a Secure Boot protocol in the bootloader. If the kernel image
    is signed at the factory with a digital key, the bootloader can check the signature
    before it loads the kernel and refuse to load it if verification fails. As long
    as the keys are kept private by the manufacturer, it will not be possible to load
    a kernel that is not authorized. U-Boot implements such a mechanism, which is
    described in the online documentation at [https://docs.u-boot.org/en/latest/usage/fit/verified-boot.html.](https://docs.u-boot.org/en/latest/usage/fit/verified-boot.html.%0D%0A)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个关于镜像真实性的问题。检测伪造更新的一种方法是在引导加载程序中使用安全启动协议。如果内核镜像在工厂时已经用数字密钥签名，引导加载程序可以在加载内核之前检查签名，并在验证失败时拒绝加载。如果制造商保持密钥的私密性，那么就无法加载未经授权的内核。U-Boot
    实现了这样的机制，相关内容可以在在线文档中查看：[https://docs.u-boot.org/en/latest/usage/fit/verified-boot.html](https://docs.u-boot.org/en/latest/usage/fit/verified-boot.html.%0D%0A)
- en: '**IMPORTANT NOTE**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'Secure Boot: good or bad?'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动：是好是坏？
- en: If I have purchased a device that has a software update feature, then I am trusting
    the vendor of that device to deliver useful updates. I definitely do not want
    a malicious third party to install software without my knowledge. But should I
    be allowed to install the software myself? If I own the device outright, should
    I not be entitled to modify it, including loading new software? Recall the TiVo
    set-top box, which ultimately led to the creation of the GPL v3 license. Remember
    the Linksys WRT54G Wi-Fi router. When access to the hardware became easy, it spawned
    a whole new industry, including the OpenWrt project. This is a complex issue that
    sits at the crossroads between freedom and control. It is my opinion that some
    device manufacturers use security as an excuse to protect their (sometimes shoddy)
    software.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我购买了一台具有软件更新功能的设备，那么我就是在信任该设备的供应商提供有用的更新。我绝对不希望一个恶意的第三方在我不知情的情况下安装软件。但是，我是否应该被允许自己安装软件呢？如果我完全拥有该设备，难道我不应有权修改它，包括加载新的软件吗？想想TiVo机顶盒，它最终促成了GPL
    v3许可证的诞生。记得Linksys WRT54G Wi-Fi路由器吗？当硬件访问变得容易时，它催生了一个全新的产业，包括OpenWrt项目。这是一个复杂的问题，位于自由与控制的交汇点。我的观点是，一些设备制造商将安全性作为借口，来保护他们（有时是劣质的）软件。
- en: Updating software may seem mundane but a bad update can do catastrophic damage
    to your business. The CrowdStrike outage of July 2024 is a perfect example. For
    that reason, it is important to roll out updates incrementally using safe techniques
    like blue-green deployments. That way, if something goes bad, you can roll back
    a software release without impacting many of your users. Now that we know what
    is required, how do we go about updating software on embedded Linux systems?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 更新软件可能看起来平凡，但一个坏的更新可能会对你的业务造成灾难性的损害。2024年7月的CrowdStrike宕机就是一个完美的例子。出于这个原因，使用蓝绿部署等安全技术逐步推出更新是非常重要的。这样，如果出了问题，你可以回滚软件发布，而不会影响到很多用户。那么，既然我们知道了所需的条件，我们如何在嵌入式Linux系统上更新软件呢？
- en: Types of update mechanism
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新机制的类型
- en: 'In this section, I will describe three approaches to applying software updates:
    symmetric, or A/B, image update; asymmetric image update, also known as *recovery
    mode update*; and finally, atomic file update.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍三种应用软件更新的方法：对称或A/B镜像更新；不对称镜像更新，也称为*恢复模式更新*；最后是原子文件更新。
- en: Symmetric image update
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对称镜像更新
- en: 'In this scheme, there are two copies of the operating system, each comprising
    the Linux kernel, root filesystem, and system applications. They are labeled as
    **A** and **B** in the following diagram:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方案中，有两个操作系统副本，每个副本包括Linux内核、根文件系统和系统应用程序。它们在下面的图中标记为**A**和**B**：
- en: '![Figure 10.2 – Symmetric image update](img/B18466_10_02.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 对称镜像更新](img/B18466_10_02.png)'
- en: Figure 10.2 – Symmetric image update
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 对称镜像更新
- en: 'Symmetric image updates work as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对称镜像更新的工作原理如下：
- en: The bootloader has a flag that indicates which image it should load. Initially,
    the flag is set to **A**, so the bootloader loads OS image **A**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动加载程序有一个标志，指示它应该加载哪个镜像。最初，标志被设置为**A**，因此启动加载程序加载操作系统镜像**A**。
- en: To install an update, the updater application, which is part of the operating
    system, overwrites OS image **B**.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装更新，更新程序应用程序（操作系统的一部分）会覆盖操作系统镜像**B**。
- en: When complete, the updater changes the boot flag to **B** and reboots.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，更新程序将引导标志更改为**B**并重新启动。
- en: Now the bootloader will load the new operating system.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，启动加载程序将加载新的操作系统。
- en: When a further update is installed, the updater overwrites image **A** and changes
    the boot flag to **A**, so you ping-pong between the two copies.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当安装进一步更新时，更新程序会覆盖镜像**A**并将引导标志更改为**A**，这样你就会在两个副本之间来回切换。
- en: If an update fails before the boot flag is changed, the bootloader continues
    to load the good operating system.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果更新在引导标志更改之前失败，启动加载程序将继续加载正常的操作系统。
- en: There are several open-source projects that implement symmetric image updates.
    One is the **Mender** client operating in standalone mode, which I will describe
    in the *Using Mender for local updates* section. Another is **SWUpdate** ([https://github.com/sbabic/swupdate](https://github.com/sbabic/swupdate)),
    which can receive multiple image updates in a CPIO format package and then deploy
    those updates to different parts of the system. It allows you to write plugins
    in the Lua language to do custom processing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个开源项目实现了对称镜像更新。其中之一是 **Mender** 客户端在独立模式下运行，我将在 *使用 Mender 进行本地更新* 部分中描述。另一个是
    **SWUpdate** ([https://github.com/sbabic/swupdate](https://github.com/sbabic/swupdate))，它可以接收多个镜像更新的
    CPIO 格式包，然后将这些更新部署到系统的不同部分。它允许你使用 Lua 语言编写插件进行自定义处理。
- en: SWUpdate also has filesystem support for raw flash memory that is accessed as
    MTD flash partitions, for storage organized into UBI volumes, and for SD/eMMC
    storage with a disk partition table. A third example is **RAUC**, the **Robust
    Auto-Update Controller** ([https://github.com/rauc/rauc](https://github.com/rauc/rauc)).
    It too has support for raw flash storage, UBI volumes, and SD/eMMC devices. The
    images can be signed and verified using OpenSSL keys. A fourth example is **fwup**
    ([https://github.com/fwup-home/fwup)](https://github.com/fwup-home/fwup) by long-time
    Buildroot contributor Frank Hunleth.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: SWUpdate 还支持原始闪存内存，作为 MTD 闪存分区访问的文件系统，支持组织为 UBI 卷的存储，以及支持具有磁盘分区表的 SD/eMMC 存储。第三个例子是
    **RAUC**，即 **稳健的自动更新控制器** ([https://github.com/rauc/rauc](https://github.com/rauc/rauc))。它也支持原始闪存存储、UBI
    卷和 SD/eMMC 设备。图像可以使用 OpenSSL 密钥进行签名和验证。第四个例子是 **fwup** ([https://github.com/fwup-home/fwup)](https://github.com/fwup-home/fwup))，由长期的
    Buildroot 贡献者 Frank Hunleth 提供。
- en: There are some drawbacks to this scheme. One is that by updating an entire filesystem
    image, the size of the update package is large, which can put a strain on the
    network infrastructure connecting the devices. This can be mitigated by sending
    only the filesystem blocks that have changed by performing a binary `diff` of
    the new filesystem with the previous version. SWUpdate, RAUC, and fwup all have
    support for such **delta updates**. So does the commercial edition of Mender.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案有一些缺点。其中之一是通过更新整个文件系统镜像，更新包的大小较大，这可能会对连接设备的网络基础设施造成压力。可以通过仅发送已经更改的文件系统块来缓解这一问题，这需要通过对比新旧文件系统的二进制
    `diff` 来完成。SWUpdate、RAUC 和 fwup 都支持这种 **增量更新**。Mender 的商业版也支持这一功能。
- en: A second drawback is the need to keep storage space for a redundant copy of
    the root filesystem and other components. If the root filesystem is the largest
    component, it comes close to doubling the amount of flash memory you need to fit
    both copies. It is for this reason that the asymmetric update scheme is used.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个缺点是需要为根文件系统及其他组件保留冗余副本的存储空间。如果根文件系统是最大的组件，它几乎会让你需要的闪存内存翻倍，以容纳两个副本。因此，采用非对称更新方案。
- en: Asymmetric image update
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非对称镜像更新
- en: 'You can reduce storage requirements by keeping a minimal recovery operating
    system purely for updating the main one as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过仅保留一个最小化的恢复操作系统用于更新主操作系统，如下所示，从而减少存储需求：
- en: '![Figure 10.3 – Asymmetric image update](img/B18466_10_03.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 非对称镜像更新](img/B18466_10_03.png)'
- en: Figure 10.3 – Asymmetric image update
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 非对称镜像更新
- en: 'To install an asymmetric update, do the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装非对称更新，请执行以下操作：
- en: Set the boot flag to point to the recovery OS and reboot.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置启动标志指向恢复操作系统并重新启动。
- en: Once the recovery OS is running, it can stream updates to the main operating
    system image.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦恢复操作系统启动，它可以将更新流式传输到主操作系统镜像。
- en: If the update is interrupted, the bootloader will again boot into the recovery
    OS, which can resume the update.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果更新被中断，启动加载程序将再次启动到恢复操作系统，这样可以继续更新。
- en: Only when the update is complete and verified will the recovery OS clear the
    boot flag and reboot again—this time, loading the new main operating system.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当更新完成并经过验证后，恢复操作系统才会清除启动标志并重新启动——这时，将加载新的主操作系统。
- en: The fallback in the case of a correct but buggy update is to drop the system
    back into recovery mode, which can attempt remedial actions, possibly by requesting
    an earlier update version.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在正确但存在漏洞的更新情况下，回退的做法是将系统恢复到恢复模式，系统可以尝试进行修复，可能通过请求较早的更新版本来解决问题。
- en: The recovery OS is usually a lot smaller than the main operating system, maybe
    only a few megabytes, and so the storage overhead is not great. As a matter of
    interest, this is the scheme that was adopted by Android prior to the Nougat release.
    For open-source implementations of an asymmetric image update, consider SWUpdate
    or RAUC.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: A major drawback of this scheme is that while the recovery OS is running, the
    device is not operational. Such a scheme also does not allow for updates of the
    recovery OS itself. That would require something like A/B image updates, thus
    defeating the whole purpose.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Atomic file updates
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another approach is to have redundant copies of a root filesystem present in
    multiple directories of a single filesystem and then use the `chroot(8)` command
    to choose one of them at boot time. This allows one directory tree to be updated
    while another is mounted as the root directory. Furthermore, rather than making
    copies of files that have not changed between versions of the root filesystem,
    you could use links. That would save a lot of disk space and reduce the amount
    of data to be downloaded in an update package. These are the basic ideas behind
    atomic file updates.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The `chroot` command runs a program in an existing directory. The program sees
    this directory as its root directory and so cannot access any files or directories
    at a higher level. It is often used to run a program in a constrained environment,
    which is sometimes referred to as **chroot jail**.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The **libostree** project ([https://github.com/ostreedev/ostree](https://github.com/ostreedev/ostree)),
    formerly **OSTree**, is the most popular implementation of this idea. OSTree started
    around 2011 as a means of deploying updates to the GNOME desktop developers and
    improving their continuous integration testing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: It has since been adopted as an update solution for embedded devices. It is
    one of the update methods available in **Automotive Grade Linux** (**AGL**), and
    it is available in The Yocto Project through the `meta-updater` layer, which is
    supported by **Advanced Telematic Systems** (**ATS**).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'With OSTree, the files are stored on the target in the `/ostree/repo/objects`
    directory. They are given names such that several versions of the same file can
    exist in the repository. Then, a given set of files is linked into a deployment
    directory which has a name such as `/ostree/deploy/os/29ff9…/`. This is referred
    to as *checking out* since it has some similarities to the way a branch is checked
    out of a Git repository. Each deployment directory contains the files that make
    up a root filesystem. There can be any number of them, but by default there are
    only two. For example, here are two `deploy` directories, each with links back
    into the `repo` directory:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To boot from an OSTree directory:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The bootloader boots the kernel with an `initramfs` passing on the kernel command
    line the path of the deployment to use:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `initramfs` contains an `init` program named `ostree-init` that reads the
    command line and executes the `chroot` to the path given.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a system update is installed, the files that have changed are downloaded
    into the `repo` directory by the OSTree install agent.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When complete, a new `deploy` directory is created with links to the collection
    of files that will make up the new root filesystem. Some of these will be new
    files. Some will be the same as before.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the OSTree install agent will change the bootloader’s boot flag so
    that on the next reboot, it will `chroot` to the new `deploy` directory.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bootloader implements the check on the boot count and falls back to the
    previous root if a boot loop is detected.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even though a developer can operate the updater or install the client manually
    on a target device, eventually software updates need to happen automatically OTA.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: OTA updates
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Updating **OTA** means having the ability to push software to a device or group
    of devices via a network, usually without any end user interaction with the device.
    For this to happen, we need a central server to control the update process and
    a protocol for downloading the update to the update client. In a typical implementation,
    the client polls the update server from time to time to check if there are any
    updates pending. The polling interval needs to be long enough that the poll traffic
    does not take a significant portion of the network bandwidth, but short enough
    that the updates can be delivered in a timely fashion. An interval of tens of
    minutes to several hours is often a good compromise. The poll messages from the
    device contain some sort of unique identifier, such as a serial number or MAC
    address, and the current software version. From this the update server can see
    if an update is needed. The poll messages may also contain other status information
    such as uptime, environmental parameters, or anything that would be useful for
    the central management of the devices.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The update server is usually linked to a management system that will assign
    new versions of software to the various populations of devices under its control.
    If the device population is large, it may send updates in batches to avoid overloading
    the network. There will be some sort of status display where the current state
    of the devices can be shown and problems highlighted.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the update mechanism must be secure so that fake updates cannot be
    sent to the end devices. This involves the client and server being able to authenticate
    each other by an exchange of certificates. Then the client can validate that the
    packages downloaded are signed by the key that is expected.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are three examples of open-source projects that you can use for OTA updates:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Mender in managed mode
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: balena
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse hawkBit ([https://github.com/eclipse/hawkbit)](https://github.com/eclipse/hawkbit)
    in conjunction with an updater client such as SWUpdate or RAUC
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will walk through Mender in detail.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Using Mender for local updates
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So much for the theory. In the remaining sections of this chapter, I will demonstrate
    how these principles work in practice. The first set of examples involves Mender.
    Mender uses a symmetric A/B image update mechanism with a fallback in the event
    of a failed update. It can operate in *standalone mode* for local updates or in
    *managed mode* for OTA updates. I will begin with standalone mode.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Mender is written and supported by Northern.tech. There is much more information
    about the software in the **Documentation** section of the website ([https://mender.io](https://mender.io)).
    I will not delve deeply into the configuration of the software here since my aim
    is to illustrate the principles of software updates. Let’s begin with the Mender
    client.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Building the Mender client
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Mender client is available as a Yocto meta layer. These examples use the
    scarthgap release of The Yocto Project, which is the same one that we used in
    [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by fetching the `meta-mender` layer as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You want to navigate one level above the `poky` directory before cloning the
    `meta-mender` layer so that the two directories are located next to each other
    at the same level.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The Mender client requires some changes to the configuration of U-Boot to handle
    the boot flag and boot count variables. The stock Mender client layer has sub-layers
    for sample implementations of this U-Boot integration that we can use straight
    out of the box, such as `meta-mender-qemu` and `meta-mender-raspberrypi`. We will
    use QEMU.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a build directory and add the layers for this configuration:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we need to set up the environment by adding some settings to `conf/local.conf`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Omit the line numbers (*1* to *5*) from `conf/local.conf`. *Line 2* includes
    a BitBake class named `mender-full`, which is responsible for the special processing
    of the image required to create the A/B image format. *Line 3* selects a machine
    named `vexpress-qemu`, which uses QEMU to emulate an Arm Versatile Express board
    instead of the Versatile PB that is the default for The Yocto Project. *Line 4*
    selects `systemd` as the i`nit` daemon in place of the default System V `init`.
    I describe `init` daemons in more detail in [*Chapter 13*](Chapter_13.xhtml#_idTextAnchor431).
    *Line 5* causes the root filesystem images to be generated in `ext4` format.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can build an image:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As usual, the results of the build are in `tmp/deploy/images/vexpress-qemu`.
    You will notice some new things here compared to The Yocto Project builds we have
    done in the past. There is a file named `core-image-full-cmdline-vexpress-qemu-grub-<timestamp>.mender`
    and another similarly named file that ends with `.uefiimg`. The `.mender` file
    is required for the next subsection: *Installing an update with Mender*. The `.uefiimg`
    file is created using a tool from The Yocto Project known as `wic`. The output
    is an image that contains a partition table and that is ready to be copied directly
    to an SD card or eMMC chip.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the QEMU target using the script provided by the Mender layer, which
    will first boot U-Boot and then load the Linux kernel:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If, instead of a login prompt, you see an error like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then install `qemu-system-arm` on your system and rerun the script:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Log on as `root` with no password. Looking at the layout of the partitions
    on the target, we can see this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are four partitions in all:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**Partition 1** contains the U-Boot boot files.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partitions 2 and 3** contain the A/B root filesystems (identical at this
    stage).'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partition 4** is just an extension partition that contains the remaining
    space.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running the `mount` command shows that the second partition is being used as
    the root filesystem, leaving the third to receive updates:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the Mender client now on board, we can begin installing updates.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Installing an update with Mender
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we want to make a change to the root filesystem and then install it as
    an update:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Open another shell and put yourself back in the working build directory:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Make a copy of the image we just built. This will be the live image that we
    are going to update:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we don’t do this, the QEMU script will just load the latest image generated
    by BitBake including updates, which defeats the object of the demonstration.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, change the hostname of the target, which will be easy to see when it
    is installed. To do this, edit `conf/local.conf` and add this line:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we can build the image in the same way as before:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This time we are not interested in the `.uefiimg` file, which contains a completely
    new image. Instead, we want to take only the new root filesystem, which is in
    `core-image-full-cmdline-vexpress-qemu-grub.mender`. The `.mender` file is in
    a format that is recognizessssd by the Mender client. The `.mender` file format
    consists of version information, a header, and the root filesystem image bundled
    together in a compressed .`tar` archive.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to deploy the new artifact to the target, initiating the update
    locally on the device, but receiving the update from a server. Stop the emulator
    you started in the previous Terminal session by pressing *Ctrl + A* then *x* to
    terminate it. This extra step ensures that QEMU boots with the previous image
    rather than the latest image. To boot QEMU with the previous image:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Check that the network is configured with QEMU at `10.0.2.15` and the host
    at `10.0.2.2`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, in another Terminal session, start a web server on the host that can serve
    up the update:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is listening on port `8000`. When you are done with the web server, press
    *Ctrl + C* to terminate it.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back on the target, issue this command to get the update:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The update was written to the third partition (`/dev/mmcblk0p3`) while our root
    filesystem is still on the second partition (`/dev`/`mmcblk0p2`).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Reboot QEMU by entering `reboot` from the QEMU command line. Note that now
    the root filesystem is mounted on partition 3 and that the hostname has changed:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Success!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more thing to do. We need to consider the issue of boot loops.
    Use `grub-mender-grubenv-print` to look at the relevant U-Boot variables:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the system reboots without clearing `bootcount`, U-Boot should detect it
    and fall back to the previous installation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test U-Boot’s fallback behavior:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Reboot the QEMU target immediately.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the target comes up again, we see that U-Boot has reverted to the previous
    installation:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let’s repeat the update procedure:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This time, after the reboot, commit the change:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once `upgrade_available` is cleared, U-Boot will no longer check `bootcount`,
    and so the device will continue to mount this updated root filesystem. When a
    further update is loaded, the Mender client will clear `bootcount` and set `upgrade_available`
    once again.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'This example uses the Mender client from the command line to initiate an update
    locally. The update itself came from a server but could just as easily have been
    provided on a USB flash drive or an SD card. In place of Mender we could have
    used one of the other image update clients mentioned: SWUpdate, RAUC, or fwup.
    They each have their advantages, but the basic technique is the same.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Using Mender for OTA updates
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, we will be using the Mender client on the device, but this time
    operating it in managed mode. In addition, we will be configuring a server to
    deploy the update so that no local interaction is needed. Mender provides an open-source
    server for this. For documentation on how to set up this demo server, see [https://docs.mender.io/2.4/getting-started/on-premise-installation.](https://docs.mender.io/2.4/getting-started/on-premise-installation)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The installation requires Docker Engine version 19.03 or later. It also requires
    Docker Compose version 1.25 or later. Refer to the Docker website at [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    and [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)
    for each.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify which versions of Docker and Docker Compose you have on your system,
    use these commands:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Docker Compose started being bundled with Docker in 2022\. If the second command
    fails, try invoking Docker Compose without the hyphen:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The Mender server also requires a command-line JSON parser called `jq`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once all three are installed, install the Mender integration environment as
    shown:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When you run `./demo up`, you will see that the script downloads several hundred
    megabytes of Docker images, which may take some time depending on your internet
    connection speed. After a while, you will see that it creates a new demo user
    and password. This means that the server is up and running.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: With the Mender web interface now running on `https://localhost/`, point a web
    browser at that URL and accept the certificate warning that pops up. The warning
    appears because the web service is using a self-signed certificate that the browser
    will not recognize. Enter the username and password generated by the Mender server
    into the login page.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to make a change to the configuration of the target so that it
    will poll our local server for updates. For this demonstration, we map the `docker.mender.io`
    and `s3.docker.mender.io` server URLs to the `10.0.2.2` localhost address by appending
    a line to the `hosts` file. To make this change with The Yocto Project, do the
    following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: First, navigate one level above the directory where you cloned Yocto.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a layer with a file that appends to the recipe that creates the
    `hosts` file, which is `recipes-core/base-files/base-files_%.bbappend`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is already a suitable layer in `MELD/Chapter10/meta-ota` that you can
    copy:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Source the working build directory:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the `meta-ota` layer:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Your layer structure should now contain eight layers including `meta-oe`, `meta-mender-core`,
    `meta-mender-demo`, `meta-mender-qemu`, and `meta-ota`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the new image using the following command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, make a copy. This will be our live image for the session:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Stop any emulator you may have started by pressing *Ctrl + A* then *x* in that
    Terminal session.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Boot up the live image:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After a few seconds, you will see a new device appear on the dashboard of the
    web interface. This happens so quickly because the Mender client has been configured
    to poll the server every 5 seconds for the purpose of demonstrating the system.
    A much longer polling interval would be used in production—30 minutes is recommended.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See how this polling interval is configured by looking at the `/etc/mender/mender.conf`
    file on the target:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice the server URL in there as well.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the web UI, click on the green checkmark to authorize the new device:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Accept device](img/B18466_10_04.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Accept device
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Then, click on the entry for the device to see the details.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once again, we can create an update and deploy it – this time OTA:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the following line in `conf/local.conf`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Build the image once again:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will produce a new `core-image-full-cmdline-vexpress-qemu-grub.mender`
    file in `tmp/deploy/images/vexpress-qemu`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Import this into the web interface by opening the **Releases** tab and clicking
    on the purple **Upload** button.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Browse for the `core-image-full-cmdline-vexpress-qemu-grub.mender` file in
    `tmp/deploy/images/vexpress-qemu` and upload it:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Upload an Artifact](img/B18466_10_05.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Upload an Artifact
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The Mender server should copy the file into the server data store, and a new
    artifact with the name **OTA-update1** should appear under **Releases**.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy the update to our QEMU device, do the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Devices** tab and select the device.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create deployment for this device** option at the bottom right
    of the device information.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **OTA-update1** artifact and click on the **CREATE DEPLOYMENT**
    button:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Create a deployment](img/B18466_10_06.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Create a deployment
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The deployment should shortly transition from **Pending** to **In Progress**.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **View details** button.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.7 – In Progress](img/B18466_10_07.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – In Progress
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: After about 13 minutes, the Mender client should finish writing the update to
    the spare filesystem image. At that point, QEMU will reboot and commit the update.
    The web UI should report **Finished** and now the client is running **OTA-update1**.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mender is neat and is used in many commercial products, but sometimes we just
    want to deploy a software project to a small fleet of popular dev boards as quickly
    as possible.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'After a few experiments with the Mender server, you may want to clear the state
    and start all over again. You can do that with these two commands from the `integration-3.7.9`
    directory:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Containers are the quickest way to deploy software to edge devices. We will
    revisit containerized software updates in [*Chapter 16*](Chapter_01.xhtml#_idTextAnchor030).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Using SWUpdate for local updates
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like Mender, SWUpdate uses a symmetric A/B image update mechanism with a fallback
    in the event of a failed update. SWUpdate can receive multiple image updates in
    a CPIO format package and then deploy those updates to different parts of the
    system. It allows you to write plugins in the Lua language to do custom processing.
    Lua is a powerful scripting language that is easy to embed in applications. SWUpdate
    is a client-only solution, so unlike Mender there is no corresponding enterprise
    hosting plan to pay for. Instead, you deploy your own OTA server using something
    like hawkBit.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The SWUpdate project ([https://github.com/sbabic/swupdate)](https://github.com/sbabic/swupdate)
    was started and is still maintained by Stefano Babic, an employee of DENX Software
    Engineering, the same folks behind U-Boot. There is extensive documentation ([https://sbabic.github.io/swupdate/)](https://sbabic.github.io/swupdate/)
    beginning with motives for robust and fail-safe updates followed by clear explanations
    of various update strategies.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to update the software on devices in the field is at the very least
    a useful attribute. If the device is connected to the internet, then updating
    software in the field is an absolute must. And yet, all too often it is a feature
    that is left until the last part of a project, on the assumption that it is not
    a hard problem to solve. In this chapter, I hope that I have illustrated the various
    problems associated with designing an effective and robust update mechanism. There
    are also several open-source options readily available. You do not have to reinvent
    the wheel anymore.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: The two approaches used most often are the symmetric image (A/B) update or its
    cousin, the asymmetric (recovery) image update. Here, you have the choice of SWUpdate,
    RAUC, Mender, and fwup. A more recent innovation is the atomic file update in
    the form of OSTree. Atomic file update reduces the amount of data that needs to
    be downloaded and the amount of redundant storage that needs to be fitted on the
    target. Lastly, with the proliferation of Docker came the desire for containerized
    software updates. This is the approach that balena takes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: It is quite common to deploy updates on a small scale by visiting each site
    and applying the update from a USB memory stick or SD card. However, if you want
    to deploy to remote locations, or deploy at scale, an OTA update option will be
    needed.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter describes how you control the hardware components of your system
    with device drivers, both in the conventional sense of drivers that are part of
    the kernel and the extent to which you can control hardware from user space.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
