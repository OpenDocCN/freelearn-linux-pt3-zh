- en: '*Chapter 13*: Using Arrays'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：使用数组'
- en: In one of the recipes in a previous chapter, we mentioned arrays as one of the
    possible compound data types that `bash` supports. We said that what `bash` has
    is two different data types (strings and numbers), but that there are ways that
    we can use more than that if we need to. Arrays are just that—something that we
    need to be able to use since we need something a little bit more complex than
    single-value variables to solve some problems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章的某个操作中，我们提到数组是`bash`支持的复合数据类型之一。我们说过，`bash`只有两种数据类型（字符串和数字），但如果需要的话，还有其他方式来使用更多的数据类型。数组就是其中之一——我们需要能够使用它，因为我们需要比单一值变量更复杂的东西来解决一些问题。
- en: 'In this chapter, we are going to cover two basic recipes connected to arrays:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖与数组相关的两个基本操作：
- en: Basic array manipulation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础数组操作
- en: Advanced array manipulation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级数组操作
- en: You can already see that we are being intentionally broad here; arrays are like
    that—simple on the surface, but with quite a few small tricks if we need to use
    them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经可以看到，我们在这里故意做得比较宽泛；数组就是这样——表面上简单，但如果需要使用它们的话，有一些小技巧。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with all the chapters that cover scripting, we are using any machine that
    works, and things as fundamental as arrays are going to work on all machines that
    run `bash`. You will therefore need the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 和所有涉及脚本编写的章节一样，我们使用的是任何可以工作的机器，像数组这样基础的内容将在所有运行`bash`的机器上工作。因此，你将需要以下内容：
- en: A **virtual machine** (**VM**) with any distributuon of Linux (in our case,
    it's going to be **Ubuntu 20.10**)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**虚拟机**（**VM**），安装任何版本的Linux（在我们的案例中，将使用**Ubuntu 20.10**）
- en: So, start your VM!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，启动你的虚拟机（VM）吧！
- en: Basic array manipulation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础数组操作
- en: The thing with `bash` and variables in `bash` is that they look deceptively
    simple. There are no formal declarations of type, or basically declarations of
    any kind. Typing is done by the shell itself, and we can do a lot of things implicitly.
    This is especially true for *regular* variables. Arrays are a little bit more
    complex, and they offer a few syntactic peculiarities when used, but they are
    an extremely useful tool. You may wonder why we are even mentioning them in any
    context since they are nothing more than one value under the same variable name.
    Well, the main reason is that we often actually need exactly this. A lot of times,
    we must store multiple values that belong to some set of data. Typically, that
    will be something such as an unordered list of values in case it is something
    that we do not care about having in a particular order, or an ordered list of
    values if we do.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`bash`和`bash`中的变量看起来很简单，但实际上它们非常具有迷惑性。没有正式的类型声明，或者说基本上没有任何形式的声明。类型由Shell本身来确定，我们可以隐式地做很多事情。这一点对于*常规*变量尤为明显。数组则稍微复杂一些，在使用时会有一些语法上的特殊之处，但它们是一个非常有用的工具。你可能会想，既然它们不过是同一个变量名下存储一个值，为什么我们还要在任何上下文中提到它们呢？嗯，主要原因是我们经常需要这样的结构。很多时候，我们必须存储属于某一数据集合的多个值。通常，这些值可能是一个无序的值列表，适用于我们不在意值的顺序的情况，或者是一个有序的值列表，适用于我们关心顺序的情况。'
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Usually, arrays are defined as *one-dimensional indexed arrays*, since they
    have an explicit order embedded in the very definition of an array. In essence,
    when we have any multi-value variable, it can be *ordered* and *unordered*. The
    difference is in whether we can define in which order the values are declared
    in the variable. If we can store values but are unable to get the order in which
    they are stored, that is called an unordered set. In `bash`, we only have ordered
    lists, which we call arrays. This means that every value in the variable has not
    only the value itself but a defined index or place. Not only can we add or remove
    values from an array, but we can also directly read any of them and we can reorder
    them if we need to.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数组被定义为*一维索引数组*，因为它们在数组的定义中嵌入了明确的顺序。实际上，当我们有任何多值变量时，它可以是*有序*的也可以是*无序*的。区别在于我们是否可以定义值声明的顺序。如果我们能存储值，但无法获取存储的顺序，那就叫做无序集合。在`bash`中，我们只有有序列表，称之为数组。这意味着变量中的每个值不仅有它本身的值，还有一个定义的索引或位置。我们不仅可以添加或移除数组中的值，还可以直接读取其中任何一个值，如果需要的话，还能重新排序。
- en: We have two types of arrays at our disposal. Both are ordered but one is *indexed*,
    which means that we have a numerical value that defines a particular element of
    the array. We also have something named associative arrays, sometimes also called
    *hash tables*. This type of array is useful because it doesn't use a numeric value
    but instead uses a string key to define a particular array element. We will talk
    a lot about both.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种类型的数组可供使用。两者都是有序的，但一种是*索引的*，这意味着我们有一个数值来定义数组的特定元素。我们还有一种名为关联数组的东西，有时也称为*哈希表*。这种类型的数组很有用，因为它不使用数值，而是使用字符串键来定义特定的数组元素。我们将详细讨论这两种。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The first thing we need to do is to declare a variable:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是声明一个变量：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We are off to a bad start. Obviously, we declared our variable correctly since
    there were no errors, but as soon as we tried to print it, we ran into problems.
    We had those before when we tried to print arrays. The solution is to use a special
    character to denote the index and tell bash that we want to print not only the
    first value but all values in the array:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开始并不顺利。显然，我们正确声明了变量，因为没有错误，但是一旦尝试打印它，就会遇到问题。以前我们尝试打印数组时也遇到过这种情况。解决方法是使用特殊字符来表示索引，并告诉bash我们想要打印的不仅是第一个值，而是数组中的所有值：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This works as intended since `bash` understands it needs to do a quick loop
    and go through every index in the array, printing all the values. An alternative
    to that is to use the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是有效的，因为`bash`理解需要快速循环并遍历数组中的每个索引，打印所有值。与此相对的替代方法是使用以下方式：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This has the exact same output as the previous command.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一条命令完全相同的输出。
- en: 'This should get you thinking: *Is there another way to use indexing?* Of course
    there is—we can use it to directly access a single value in the array:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该让你思考：*还有没有其他使用索引的方式？* 当然有——我们可以直接访问数组中的单个值：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Make a note we are *off by one* in this example since the first element in an
    array has an index of `0`. There is one more very interesting property rarely
    mentioned in terms of arrays. Before we show it, we need to explain another way
    of declaring an array.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个例子中我们*偏移了一个*，因为数组的第一个元素的索引是`0`。关于数组还有一个很少提到的非常有趣的属性。在展示之前，我们需要解释另一种声明数组的方式。
- en: 'Declaring a variable using simple brackets is the most common way to do this,
    but we can also do it by directly specifying elements in an array. The interesting
    thing is that we can do it in any order we want to:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单括号声明变量是最常见的方法，但我们也可以通过直接指定数组中的元素来完成。有趣的是，我们可以按任意顺序进行操作：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we now try to print our array, the result is going to be more dangerous
    than surprising:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试打印我们的数组，结果会比惊讶更危险：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our array has two values stored under indexes. We intentionally made an error
    in indexing—the value of `second` is stored under index number `2`, making it
    the third array element. What we didn''t do is declare the first element of our
    array. The reason we said that the result of the previous command is dangerous
    is that from its output, you cannot see the index of a particular element, so
    you have no idea what the actual index of a particular value is. This makes it
    easy to confuse the values—or, to make it more obvious, something such as this
    will not return a value, although we might think it should:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组在索引下存储了两个值。我们故意在索引中犯了一个错误——`second`的值存储在索引号`2`下，使其成为第三个数组元素。但我们没有声明数组的第一个元素。我们说前面命令的结果危险是因为从其输出中，您无法看到特定元素的索引，因此您不知道特定值的实际索引是多少。这使得混淆值变得很容易——或者更明显地说，像这样的东西不会返回一个值，尽管我们可能认为它应该返回：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Things such as these are a common source of errors that we need to troubleshoot,
    and they are especially complicated to spot if we use the direct syntax of specifying
    both a value and its index.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些东西通常是我们需要排除故障的常见错误源，如果使用直接指定值和其索引的语法，尤其复杂。
- en: What we are trying to say is to never use this way of declaring an array, unless
    you have a particular reason why you need it. Otherwise, things can become confusing
    later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要说的是，除非有特殊原因需要这种方式声明数组，否则不要使用这种方式。否则，以后可能会变得混乱。
- en: There is a third way to declare an array that is the least commonly used method.
    Using the `declare` statement and the `-a` switch, you explicitly declare that
    a particular variable is going to hold an array of values. The reason we rarely
    see this in code is that when we use either of the already mentioned implicit
    declarations, our variable will become appropriately typed, so there is simply
    no reason to do this twice unless you want to do so to make your code readable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三种声明数组的方式，这是最不常用的方法。使用`declare`语句和`-a`开关，你可以显式声明某个变量将保存一个值的数组。我们在代码中很少看到这种方式的原因是，当我们使用前面提到的隐式声明时，我们的变量会自动成为适当类型，因此除非你想提高代码的可读性，否则没有必要做两次声明。
- en: All of this was just different ways to create and print normal, indexed arrays.
    We mentioned that there is another type of array called an associative array,
    also known as a hash table, dictionary, or key-value paired array. This type was
    introduced in `bash` 4.0 and is still not available on some platforms; most notably,
    some versions of OS X require you to upgrade `bash` to be able to use this type.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是创建和打印普通索引数组的不同方式。我们提到过，还有一种叫做关联数组的数组类型，也称为哈希表、字典或键值对数组。这种类型在`bash` 4.0中引入，并且在某些平台上仍然不可用；最著名的是，某些版本的OS
    X需要你升级`bash`才能使用这种类型。
- en: 'Real life contains a lot of things that can be considered pairs of values.
    Things such as username/password, name/address, name/telephone number are naturally
    created pairs of data that are often used in scripts. Obviously, we could use
    a normal array to store this, but to do it in a way that enables us to understand
    which values are a part of a given pair, we would need not one but two separate
    arrays and a little bit of focus on how we declare indexes for them so that we
    can use the same index to get the first and the second value:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现实生活中有许多可以被视为值对的事物。像用户名/密码、姓名/地址、姓名/电话号码等，都是自然形成的数据对，通常会在脚本中使用。显然，我们可以使用普通数组来存储这些数据，但为了能够理解哪些值是某一对数据的一部分，我们不仅需要两个单独的数组，还需要花点心思去声明它们的索引，以便我们可以使用相同的索引来获取第一项和第二项值：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is going to give us an output that looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个类似于以下的输出：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This looks and works fine if we need to print out all of the data. Imagine
    now that we have information that we need to search for—imagine we are looking
    for a telephone number of a particular person. If we needed to do this using regular
    arrays, something like this could be done:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要打印出所有的数据，这看起来和运行良好。现在想象一下，我们有一些需要搜索的信息——假设我们在寻找某个人的电话号码。如果我们需要使用普通数组来实现，可能会像这样做：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to check all the values, we need to go through every element of one
    array and then print pairs if we find a match. First, we are going to test this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查所有的值，我们需要遍历一个数组中的每个元素，然后如果找到匹配的项，就打印出对应的对。首先，我们将测试这个：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Although this is working, it is not the right way to do it. Some of the downsides
    of this approach are obvious:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样是可行的，但这并不是正确的方法。这个方法的一些缺点显而易见：
- en: An array is indexed, so it can hold the same content at different indexes.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组是有索引的，因此它可以在不同的索引位置存储相同的内容。
- en: In order to find something, we need to go through all values.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了找到某个东西，我们需要遍历所有的值。
- en: If we mess up any of the arrays, we can create invalid data.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们弄错了任何一个数组，可能会创建无效的数据。
- en: The script is very complicated for a simple task.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个脚本对于一个简单任务来说非常复杂。
- en: That other *associative* array type we mentioned is the solution to this and
    many more problems. While in normal arrays, the values we are using are indexed
    by numbers. In this particular array type, we use any value as a *key* to reference
    a specific value in an array.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到的另一个*关联*数组类型就是解决这个问题和更多问题的方案。在普通数组中，我们使用数字来索引我们所使用的值。而在这种特定的数组类型中，我们可以使用任何值作为*键*来引用数组中的特定值。
- en: 'Doing this requires an explicit declaration of the array type that has to be
    done using the `declare` statement and the `-A` switch. Be very careful about
    this switch since it uses a capital letter *A*, while *normal* arrays are declared
    using the same letter in lowercase. While you may implicitly declare an indexed
    array in multiple ways, an associative array can be declared only by using this
    method and must be declared explicitly. Before we can do a script to fully demonstrate
    that, we need to show you how to declare an array of this type. Besides the fact
    that we must use the `declare` statement, we also need to declare the indexes
    since they can be any string, not just a number. The output looks something like
    this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做需要显式声明数组的类型，必须使用`declare`语句和`-A`选项来完成。要特别注意这个选项，因为它使用了大写字母*A*，而*普通*数组是使用小写字母来声明的。虽然你可以通过多种方式隐式声明索引数组，但关联数组只能通过这种方法显式声明。为了完全演示这一点，我们需要先展示如何声明这种类型的数组。除了必须使用`declare`语句外，我们还需要声明索引，因为它们可以是任何字符串，而不仅仅是数字。输出看起来像这样：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There is also a way to declare these arrays in one line, by specifying pairs:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以在一行中声明这些数组，通过指定键值对：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have defined this array in two ways, let''s do a small follow-up
    with other operations that we can carry out. We should be able to write out the
    array values. First, we will try the method we used with regular arrays:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经以两种方式定义了这个数组，让我们做一个小的后续操作，看看我们可以进行哪些其他操作。我们应该能够输出数组的值。首先，我们将尝试使用我们之前在常规数组中使用的方法：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is, of course, a problem, but we were expecting it. This syntax is designed
    for arrays that have a numerical index and is translated into something a human
    can understand, which means: *print all the values from an array called NAMES
    by using all possible indices*.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是一个问题，但我们早已预料到。这个语法是为具有数字索引的数组设计的，并且会被转化成人类可以理解的内容，这意味着：*通过使用所有可能的索引，打印出名为NAMES的数组的所有值*。
- en: The key here is that we are not printing the index of a value, just the value
    itself. Since we are using both the key and the value in our arrays, we need to
    be able to see what the key for a particular value is. This can be done using
    a `for` loop, but before we do that, we have a point to make—by design, arrays
    have multiple values, so not only can we redefine the whole array, but we can
    also add and remove elements from it. We already showed an example in which we
    added elements to a variable, and we did this by creating a new value under a
    new index.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是我们并不是打印某个值的索引，而只是打印该值本身。由于我们在数组中同时使用了键和值，我们需要能够看到某个特定值的键是什么。这可以通过使用`for`循环来完成，但在此之前，我们有一点需要说明——按照设计，数组有多个值，因此我们不仅可以重新定义整个数组，还可以从中添加或删除元素。我们已经展示过通过创建一个新索引下的新值来添加元素的例子。
- en: 'All this applies not only to associative arrays but to arrays in general; however,
    we are going to use associative arrays just to make you more familiar with this
    type. We are going to repeat the example from before, but with a twist:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些不仅适用于关联数组，也适用于数组的一般情况；然而，我们将仅使用关联数组，以便让你更熟悉这种类型。我们将重复之前的例子，但会做一些改变：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'What happened? First, we defined an array that consists of three value pairs.
    We did this by declaring every single pair by itself. After that, we used the
    alternative way of array declaration, but since we basically redeclared the array,
    the values we used completely replaced values that the array had before. What
    we should have done is *add* those values. There are two ways to do this—one is
    to just define the right values for the pairs again:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？首先，我们定义了一个由三个值对组成的数组。我们通过单独声明每个值对来实现这一点。之后，我们使用了另一种数组声明方式，但由于我们基本上是重新声明了该数组，因此我们使用的值完全替换了数组之前的值。我们本该做的是*添加*这些值。实现这一点有两种方法——一种是重新定义每一对值：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can now see our array has the expected number of values, although we still
    don't know how to get them printed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到数组中有了预期的值数量，尽管我们仍然不知道如何打印它们。
- en: 'Another way to do this is by using addition. We are going to change only one
    character in our example to do this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是通过使用加法。我们将在例子中只更改一个字符来实现：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Can you even notice the change? What we did is use the plus operator in front
    of the equals sign to tell `bash` that we want these pairs added to our array.
    This notation is completely the same as if we had used `NAMES=NAMES+([Ida]=11111
    ["That guy"]=122222)`—it is just a little shorter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你能注意到变化吗？我们所做的就是在等号前面使用加号操作符，告诉`bash`我们希望将这些键值对添加到数组中。这种表示法与我们使用`NAMES=NAMES+([Ida]=11111
    ["That guy"]=122222)`完全相同——只是稍微简短一些。
- en: The last thing we need to know is how to remove a value from an array.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道的最后一件事是如何从数组中删除一个值。
- en: 'The solution to this is simple—there is a command called `unset` that simply
    removes the value associated with a particular index or a key. More often than
    not, this is used on key-value pairs since it makes much more sense there, but
    you can also do it on a regular array:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案很简单——有一个叫做`unset`的命令，它可以简单地删除与特定索引或键相关联的值。通常，这个命令用于键值对，因为在这种情况下更为合理，但你也可以在常规数组上使用它：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we are going to tackle the big problem and rewrite our script from before,
    using our only associative array.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将解决一个大问题，并重新编写之前的脚本，使用我们唯一的关联数组。
- en: 'The idea of how to do this is based on the way `bash` uses sets of objects.
    We are going to create one such set out of all the keys, and then print both the
    key and the value it points to. To access keys directly, we can use an exclamation
    point:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法的原理基于`bash`如何使用对象集合。我们将从所有的键创建一个这样的集合，然后打印出键和值。要直接访问键，我们可以使用感叹号：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are some small things you need to notice in this script. For example,
    quotes are important since our keys contain spaces. The general rule here is that
    as soon you are using any string as a value of anything, it should be enclosed
    in quotes to get the space parsed correctly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，你需要注意一些小细节。例如，引用符号非常重要，因为我们的键包含空格。这里的一般规则是，只要你使用任何字符串作为某个值，它应该用引号括起来，以便正确解析空格。
- en: 'The `for` loop is going to go through keys one by one, and keys are going to
    be used as an entire key value, including a space. Some manuals will state that
    a key must be a single word, but officially it can be anything. The usage scenario
    for this type of variable is, however, that we will be using a word or two in
    most cases:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环将逐一遍历键，键将作为整个键值对使用，包括空格。某些手册会指出，键必须是一个单词，但官方来说，它可以是任何东西。然而，这种类型变量的使用场景是，在大多数情况下我们将使用一个或两个单词：'
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: We have demonstrated the way arrays work in practice, how to create them, how
    to read from them, and how to delete individual elements inside an array. What
    makes arrays a little bit different from regular variables is that variables hold
    one value, so there are no operations that can modify that value. If we need to
    change it, we simply redeclare the entire value. When dealing with arrays, we
    are dealing with multiple values in one array, and that still means we must redeclare
    any that we need to change, but we are then changing just a single value out of
    many, not the entire array. This is the main reason we have operations that add
    and remove elements.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了数组在实践中的工作方式，如何创建它们，如何从中读取数据，以及如何删除数组中的单个元素。数组与常规变量的一个不同之处在于，变量只持有一个值，因此没有操作可以修改该值。如果我们需要改变它，我们只需重新声明整个值。而在处理数组时，我们处理的是一个数组中的多个值，这仍然意味着我们必须重新声明需要更改的任何值，但我们只是改变多个值中的一个，而不是整个数组。这也是我们有添加和删除元素操作的主要原因。
- en: Some of you already familiar with different programming languages will probably
    be a little bit confused by the relaxed way some things are defined, especially
    when we are talking about regular arrays and the way they address individual values
    and print them. Probably the most confusing part is how you can completely skip
    a range of indexes and still get a valid array. We are going to talk a little
    bit more about this in the next recipe, but `bash` is inconsistently vague in
    some ways, and this is one of them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一些已经熟悉不同编程语言的你们可能会对某些定义方式感到有些困惑，特别是当我们谈论常规数组以及它们如何访问和打印单个值时。最令人困惑的部分可能是你如何完全跳过一段索引区间，却依然能得到一个有效的数组。我们将在下一个食谱中详细讲解这个问题，但`bash`在某些方面的模糊性是非常不一致的，而这就是其中之一。
- en: Associative arrays are going to be something you will need from time to time,
    especially when you need to deal with objects that have some properties. It is
    not possible to store more than one property per key, but even this makes for
    a nice environment since this single value can, for example, be an indexed value
    that then points to different arrays containing everything else that we need to
    store about a particular object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 关联数组是你不时需要用到的，特别是当你需要处理具有某些属性的对象时。每个键无法存储多个属性，但即便如此，这种情况也创造了一个不错的环境，因为这个单一的值可以是一个索引值，指向不同的数组，存储关于某个特定对象的其他所有信息。
- en: See also
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Arrays are complicated and, at the same time, very simple in their syntax.
    Check out these links for many more examples:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 数组很复杂，同时它们的语法也很简单。查看这些链接，你将看到更多的示例：
- en: https://www.shell-tips.com/bash/arrays/
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://www.shell-tips.com/bash/arrays/
- en: '[https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays](https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays](https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays)'
- en: Advanced array manipulation
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级数组操作
- en: Now we have finished dealing with the basics, we need to add much more to your
    knowledge of arrays. What we first need to do is to give you some ideas on how
    to make the arrays you create in your scripts more persistent, so we need to deal
    with storing and restoring them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了基本内容的处理，我们需要向你传授更多关于数组的知识。首先，我们需要做的是给你一些关于如何让你在脚本中创建的数组更加持久化的思路，因此我们需要处理数组的存储和恢复。
- en: The reason why this is important is that arrays can be quite large, depending
    on the script you are creating. Dumping and reusing variables in scripts is easy
    since we can use the *source* to declare variables we stored in a file. Arrays
    make for more complicated work since they can contain multiple variables, and
    sometimes we even need to create them from another data source.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为数组可能相当大，具体取决于你创建的脚本。转储和重用脚本中的变量很容易，因为我们可以使用*source*来声明我们存储在文件中的变量。数组则更加复杂，因为它们可以包含多个变量，有时我们甚至需要从其他数据源创建它们。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The thing with scripts is that they sometimes need to deal with a lot of data.
    In a lot of cases, we can use files to both store data in and load data from.
    There are, however, some cases where arrays—especially associative arrays—are
    a necessity for working with large amounts of data, and then we need to know how
    to save that data to the disk and reuse it. We are going to show you how to solve
    those problems and advise you when to do it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的问题是它们有时需要处理大量数据。在许多情况下，我们可以使用文件来存储和加载数据。然而，也有一些情况，特别是关联数组，在处理大量数据时是必需的，这时我们需要知道如何将这些数据保存到磁盘并重新使用它。我们将向你展示如何解决这些问题，并在何时使用它提供建议。
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: When talking about all of this, we always need an example where a particular
    feature makes sense. Some of the `bash` features we dealt with were so generic
    that our examples also had to be generic. Associative arrays are not like that.
    Although they can be used for a number of things, some scenarios are so common
    that you will automatically start to declare an array even before you think how
    and why you are doing it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论这些内容时，我们总是需要一个示例，来说明某个特性为何有意义。我们处理过的某些`bash`特性过于通用，因此我们的示例也必须是通用的。而关联数组不同，尽管它们可以用于多种情况，但有些场景如此常见，以至于你会在考虑如何以及为什么使用它之前，就自动开始声明一个数组。
- en: The most common scenario is saving user settings.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的场景是保存用户设置。
- en: Any larger script that deals with any task will have to be configurable. We
    mentioned that when we said that you can include files, and the most common ones
    are going to be the ones containing variables, storing values for different settings.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 任何处理任务的大型脚本都必须是可配置的。我们提到过，当我们说可以包含文件时，最常见的文件是包含变量的文件，用于存储不同设置的值。
- en: 'Most of the time, all the settings in a script look something like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，脚本中的所有设置看起来像这样：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These settings are just an example, but most scripts have a block of these either
    in a separate file or at the start of the script.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置只是一个示例，但大多数脚本都会在单独的文件中或脚本的开始部分有一个这样的块。
- en: Notice that all of them have a format of `KEY=VALUE` and look like they are
    created to be used in an associative array. Having said that, we need to make
    a point about using any feature of any programming language—do what is best for
    the performance and clarity of a given solution and don't use a feature just because
    you *know* it is used in a particular situation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它们都有`KEY=VALUE`的格式，看起来像是为联想数组而创建的。话虽如此，我们需要强调的是，使用任何编程语言的特性时，要做最有利于性能和清晰度的选择，而不是仅仅因为你*知道*在某个特定的情况下使用了这个特性就去使用它。
- en: This is where your experience is required. If a script has a set of settings
    that never change after we initially set them while loading and saving them from
    the disk, this makes no sense. The same goes for if a script only has a few variables
    defined when it starts—there is no point in using arrays here.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要经验的地方。如果一个脚本有一组设置，在我们最初加载并保存它们时它们就不再改变，那么使用数组毫无意义。如果一个脚本在启动时只定义了少量变量——在这种情况下也没有必要使用数组。
- en: But if a script has more than a few things that change between different script
    executions, and if you are using them to store some important runtime operations
    that are needed not only when the script starts but also during its run, arrays
    may be a solution.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果一个脚本在不同的执行过程中有很多变化，并且如果你使用它们来存储一些重要的运行时操作，这些操作不仅在脚本开始时需要，而且在运行过程中也需要，那么数组可能是一个解决方案。
- en: Our example is going to be a small script that will have a few settings it needs
    to remember, and we are going to use arrays to load them from disk, use them,
    and store them later back to disk. Working on this, we are also going to perform
    some tasks on a given array to demonstrate how to manipulate pairs in a script.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将是一个小脚本，它需要记住一些设置，我们将使用数组从磁盘加载它们，使用它们，并稍后将它们存回磁盘。在这个过程中，我们还将对给定的数组执行一些任务，以展示如何在脚本中操作键值对。
- en: But before we do any of that, we need to go through a few advanced examples
    to show you how some things we previously glanced over work.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们做这些之前，我们需要通过一些高级示例来向你展示一些我们之前略过的内容是如何工作的。
- en: 'First, we are going to deal with the difference between using `*` and `@` operators
    to read indices and keys in arrays. We said that for a given array, those two
    operators are different ways of going through all indices. Here''s an example
    to illustrate this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将处理使用`*`和`@`运算符读取数组中的索引和键的区别。我们之前说过，对于一个给定的数组，这两种运算符是不同的遍历所有索引的方式。这里有一个示例来说明这一点：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The same goes for associative arrays:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 联想数组也一样：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So far, the results are at first glance identical. This is one of those things
    in `bash` that will sometimes make you pull your hair out in despair because when
    we use them for loops, there will be a big difference that we are going to show
    by creating a small example script:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，结果乍一看是相同的。这就是`bash`中的一个问题，它有时会让你感到绝望，因为当我们在循环中使用它们时，结果会有很大差异，我们将通过创建一个小的示例脚本来展示这一点：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we run this script and both of those expressions return the same set of
    values, the output should be identical. But if we actually run it, we get this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个脚本，且这两个表达式返回相同的值集，那么输出应该是相同的。但如果我们真的运行它，得到的结果却是这样的：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We see that when we use `@`, we get what we expected, but as soon as we replace
    it with `*`, we can see the keys (or indices) but get no values in return.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，当我们使用`@`时，得到了预期的结果，但一旦我们用`*`替换它，我们可以看到键（或索引），但没有返回值。
- en: The reason behind this is, as always, the way `bash` works. Using the `@` sign
    signals to `bash` that we are trying to get each index or key separately. Using
    the `*` sign, on the other hand, makes `bash` return all the indices or keys as
    a single string divided by spaces. So, our script in one case reads each element
    one by one, and the other loop is run only once. Since the value that we are trying
    to look up is different from any single key value in our array, this one run gets
    no results. In the end, those two expressions are not identical, but the simple
    printout is—don't let that fool you.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 其背后的原因，像往常一样，是`bash`的工作方式。使用`@`符号告诉`bash`我们是尝试分别获取每个索引或键。另一方面，使用`*`符号会让`bash`将所有的索引或键作为一个由空格分隔的单一字符串返回。所以，在一种情况下，我们的脚本会逐个读取每个元素，而另一个循环只运行一次。由于我们试图查找的值与数组中的任何单个键值都不同，这次运行没有返回结果。最终，这两个表达式并不相同，但简单的输出是相同的——不要被它迷惑了。
- en: Now, we are going to create our master script for manipulating arrays and then
    add a few elements to it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个用于操作数组的主脚本，并添加一些元素。
- en: The obvious starting point is to create a file containing our array. There are
    multiple ways to do that, some more complicated than others, but almost all of
    them depend on using some loop to go through the array and either read it or write
    it to a file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，起点是创建一个包含我们数组的文件。有多种方法可以做到这一点，有些方法比其他方法复杂，但几乎所有方法都依赖于使用某种循环来遍历数组，并将其读入或写入文件。
- en: 'We are going to do it the canonical Linux way by using the `declare` statement.
    If we do the `-p` switch, we are telling it to print a particular variable with
    both its definition and the values stored in it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以经典的Linux方式来做，使用`declare`语句。如果我们使用`-p`选项，我们就是在告诉它打印特定变量的定义及其存储的值：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Obviously, this is great since this is the only thing we need to remember to
    have everything that is stored in the variable itself. To save it, we just redirect
    it to a file on disk:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是非常棒的，因为这是我们需要记住的唯一事项，以确保变量中存储的所有内容都被保存。为了保存它，我们只需将其重定向到磁盘上的文件：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To show that this worked, we are going to unset the variable and verify it
    was deleted so that the values only exist in a file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这个方法有效，我们将取消设置变量，并验证它已经被删除，以确保值只存在于文件中：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s look at how to reload the script from a disk. Notice that the output
    of the `declare` statement was an actual `declare` statement defining the variable.
    If we load it from disk and execute it, everything should be fine:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何从磁盘重新加载脚本。注意，`declare`语句的输出实际上是一个`declare`语句，用于定义变量。如果我们从磁盘加载并执行它，一切应该都没问题：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The internet is full of more complicated solutions, but for an array of a reasonable
    size, this should work great. At the same time, this is easy to read in a script,
    and the file that contains the data is in a universal format readable by any other
    `bash` version installed on any system (if it is `bash` 4.0 since that is when
    these types of arrays were introduced).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网充满了更复杂的解决方案，但对于一个合理大小的数组，这个方法应该非常有效。与此同时，它也很容易在脚本中读取，且包含数据的文件是通用格式，可以被任何安装了`bash`的系统上的其他版本读取（前提是`bash`版本为4.0，因为这是这些类型的数组首次被引入的版本）。
- en: 'We now know how to read and write an array to disk, but what else can we do
    with it? In our example, we are going to switch to a regular array to show you
    some things you can do:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何将数组读写到磁盘，但还能对它做什么呢？在我们的示例中，我们将切换到常规数组，向你展示一些可以做的事情：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So, we have created an array and we made an error. Since the array is already
    in the wrong order, we are going to reshuffle it even more (the `shuf` command
    randomizes the array):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们创建了一个数组，并且犯了一个错误。由于数组已经是错乱的顺序，我们将再次对其进行重新洗牌（`shuf`命令会随机打乱数组）：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Although you could create your own solution for the randomization of values,
    using an external command is the simplest solution.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以为值的随机化创建自己的解决方案，但使用外部命令是最简单的解决方案。
- en: Shuffling is easy but it is not permanent. What the command is doing is taking
    our array as its input, shuffling the values, and then printing the result while
    the original array stays the same.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 洗牌很简单，但它不是永久性的。命令的作用是将我们的数组作为输入，打乱其中的值，然后打印结果，而原始数组保持不变。
- en: We reassigned the array to the result of the command. The main reason we also
    created another variable and printed it is that we had to show that shuffling
    happens in real time, and the results are different each time the `shuf` command
    is started.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数组重新赋值为命令的结果。我们还创建了另一个变量并打印它，主要是为了展示洗牌是实时发生的，而且每次启动`shuf`命令时结果都会不同。
- en: Sorting an array is going to be more of a problem since it requires some sorting
    mechanism. Either you will create one yourself or you can, with a little care,
    use the `sort` command already included in `bash`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 排序数组会更麻烦，因为它需要某种排序机制。要么你自己创建一个，要么你可以小心地使用`bash`中已包含的`sort`命令。
- en: 'The next thing we are going to do is show you how to work with ranges of indices.
    We are going to reset our array and then show you some examples. When we declare
    ranges, in reality, we are using a mechanism built into `bash` that enables us
    to define a range of numbers. We already used that to create loops and iterators
    in them, so this will not be too much of a surprise to you:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示如何使用索引范围。我们将重置数组，然后展示一些示例。当我们声明范围时，实际上，我们是在使用`bash`内置的一个机制，它允许我们定义一个数字范围。我们已经用它来创建循环和迭代器，所以这对你来说应该不算惊讶：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We are using standard notation in `bash`. The first number after the variable
    is the starting index we want to print, and the optional number after it is the
    number of values we need. Notice that negative numbers do not work here unlike
    in some other places; we cannot go back from the end of the array this way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`bash`中使用的是标准语法。变量后的第一个数字是我们想要打印的起始索引，后面的可选数字是我们需要的值的数量。请注意，这里负数不起作用，和其他一些地方不同；我们不能通过这种方式从数组的末尾往回查找。
- en: The next thing we can do is concatenate two arrays.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们可以做的是拼接两个数组。
- en: 'Depending on what you want to do, the result of that operation will not get
    you what you might have been expecting:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你想做的事情，这个操作的结果可能并不会得到你预期的结果：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Another operation we can do is count the number of values in an array. We also
    already did this before, so let''s check if our arrays were merged correctly:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以执行的操作是计算数组中的值的数量。我们之前也做过这件事，所以让我们检查一下我们的数组是否已正确合并：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What happened here?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？
- en: 'In our concatenation, we made a huge error. What we wanted to do is create
    a new array that will hold the values from both arrays. What we did is create
    a `string` variable that contains one huge string created from all values in the
    arrays. We need to fix this by using brackets:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的拼接操作中，我们犯了一个大错。我们想做的是创建一个新数组，用于保存两个数组的所有值。但我们做的是创建了一个`string`变量，它包含了所有数组值组成的一个大字符串。我们需要通过使用括号来修复这个问题：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So, we created our array and checked how many values it holds. Since we wanted
    to be completely sure, we used the `declare` statement to show all the index/value
    pairs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们创建了数组并检查了它包含多少个值。由于我们想确保完全准确，因此使用了`declare`语句来展示所有的索引/值对。
- en: 'Before we move on, we need to make a small mistake by using a pair of quotation
    marks:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要通过使用一对引号制造一个小错误：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What we did is create something extremely similar to our first example, but
    at the same time, completely wrong. One of the values is a combination of two
    strings, not two separate values. Try all different combinations of quotation
    marks to try to see how they work and if using either `@` or `*` makes a difference
    to the resulting array.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的事情是创建了一个与我们第一个例子非常相似的东西，但同时完全错误。一个值是两个字符串的组合，而不是两个单独的值。尝试所有不同的引号组合，看看它们如何工作，以及使用`@`或`*`是否会对结果数组产生影响。
- en: How it works…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'We have dealt with different things you can do to an array in detail. What''s
    left is to see what else is there to know about arrays and how to check if an
    array contains a value. The length—or, more precisely, the number of values is
    something we just looked at, and if you need to know if an array already exists,
    you should check if the length of it is longer than `0`. This will tell you that
    either the array you are testing is not defined or it contains no elements. If
    you explicitly want to check if the variable is defined, use the `declare` statement
    and count the results. In our example, we have a variable called `TEST1` and an
    undefined name, `TEST2`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细处理了对数组可以执行的各种操作。剩下的就是看看关于数组还有什么需要了解的内容，以及如何检查数组是否包含某个值。数组的长度——或者更准确地说，值的数量是我们刚刚看过的。如果你需要知道数组是否已经存在，可以检查它的长度是否大于`0`。这将告诉你，要么你测试的数组没有定义，要么它不包含任何元素。如果你明确想检查一个变量是否已定义，可以使用`declare`语句并统计结果。在我们的示例中，我们有一个名为`TEST1`的变量和一个未定义的名字`TEST2`：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For most intents and purposes, just checking for the value count is enough,
    but sometimes you need to know if a variable is even defined.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，只检查值的数量就足够了，但有时你需要知道一个变量是否已经定义。
- en: 'Another common thing to do is try to find if there is a particular value inside
    an array. You can do this by creating your own loop to check for the values, or
    you can use the built-in test that `bash` already has. For example, you could
    do something like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的操作是尝试找出数组中是否包含特定的值。你可以通过创建自己的循环来检查值，或者使用`bash`已经提供的内置测试。例如，你可以像这样做：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once again, we used a one-line logical expression to quickly see the result.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用了一行逻辑表达式来快速查看结果。
- en: 'Now, here''s a small script that will show some of the things we learned in
    this recipe:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有一个小脚本，它将展示我们在这个教程中学到的一些内容：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We already know most of this, but we will go through the script.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道了大部分内容，但我们还是会通过这个脚本进行回顾。
- en: The first function in that script tests if a file exists. We could have done
    the same thing by using the `if` statement later in the code, but we wanted to
    remind you how to use functions and logical checks. The function returns `0` if
    the file is there, and `1` if it is not.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中的第一个函数用来测试文件是否存在。我们本可以在代码后面使用`if`语句来做同样的事情，但我们想提醒你如何使用函数和逻辑检查。如果文件存在，函数返回`0`，如果文件不存在，则返回`1`。
- en: Next, we have the function we called `assign_settings` that is used if the file
    is not found. What it does is simply create a new associative array that contains
    some data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们称之为`assign_settings`的函数，它在文件未找到时使用。它所做的就是简单地创建一个包含一些数据的新关联数组。
- en: Then, we are in the main body of code in our script, and first, we are declaring
    our arrays since they cannot be declared implicitly. Then, we decide if we have
    our file saved and if we should load our array from there or whether we need to
    reassign the defaults.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们进入脚本的主体部分，首先声明我们的数组，因为它们不能隐式声明。接着，我们决定是否已经保存了文件，并判断是否应该从文件中加载数组，或者是否需要重新分配默认值。
- en: After that, we are just printing out the values and then saving them to disk.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们只是输出值，然后将它们保存到磁盘。
- en: In a normal script, this would be a part of the script that does the importing
    and saving of important settings. The rest of the script would be right before
    the line that saves the variables.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通脚本中，这通常是导入和保存重要设置的部分。脚本的其他部分将在保存变量的那一行之前。
- en: 'We are going to start the script two times in a row. The result should be that
    it will detect we have no configuration and make it for us:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将连续两次启动脚本。结果应该是，它会检测到我们没有配置，并为我们创建配置：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When you are doing something such as this, we must also warn you that there
    may be big problems with local and global variables. Be very careful if you are
    declaring any variable that is supposed to be global in a function or—even worse—if
    you are sourcing it from a function since the scope will limit your values from
    propagating throughout the script.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在做类似的事情时，我们还必须提醒你，局部变量和全局变量可能会带来大问题。如果你在函数中声明任何应该是全局的变量，或者更糟的是，如果你从函数中引用它，务必小心，因为作用域会限制变量在脚本中的传播。
- en: This is where we will leave arrays and go on to more interesting stuff—starting
    to create some interfaces.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将暂时离开数组，转向更有趣的内容——开始创建一些接口。
- en: See also
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '*How to use bash array in a shell script*: [https://linuxconfig.org/how-to-use-arrays-in-bash-script](https://linuxconfig.org/how-to-use-arrays-in-bash-script)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何在 Shell 脚本中使用 Bash 数组*：[https://linuxconfig.org/how-to-use-arrays-in-bash-script](https://linuxconfig.org/how-to-use-arrays-in-bash-script)'
- en: '*The Ultimate Bash Array Tutorial with 15 Examples*: [https://www.thegeekstuff.com/2010/06/bash-array-tutorial/](https://www.thegeekstuff.com/2010/06/bash-array-tutorial/)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*终极 Bash 数组教程，含 15 个示例*：[https://www.thegeekstuff.com/2010/06/bash-array-tutorial/](https://www.thegeekstuff.com/2010/06/bash-array-tutorial/)'
