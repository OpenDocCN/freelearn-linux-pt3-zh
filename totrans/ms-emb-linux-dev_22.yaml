- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Managing Memory
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: This chapter covers issues related to memory management, which is an important
    topic for any Linux system but especially for embedded Linux, where system memory
    is usually in limited supply. After a brief refresher on virtual memory, I will
    show you how to measure memory usage and how to detect problems with memory allocation,
    including memory leaks, as well as what happens when you run out of memory. You
    will have to understand the tools that are available, from simple tools such as
    `free` and `top` to complex ones such as `mtrace` and Valgrind.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖与内存管理相关的问题，这是任何 Linux 系统中的重要话题，尤其是在嵌入式 Linux 中，系统内存通常是有限的。简要回顾虚拟内存后，我将向你展示如何衡量内存使用情况，如何检测内存分配问题，包括内存泄漏，以及当内存不足时会发生什么。你将需要了解可用的工具，从简单的工具如
    `free` 和 `top` 到复杂的工具如 `mtrace` 和 Valgrind。
- en: We will learn the difference between kernel- and user-space memory, and how
    the kernel maps physical pages of memory to the address space of a process. Then
    we will locate and read the memory maps for individual processes under the `proc`
    filesystem. We will see how the `mmap` system call can be used to map a program’s
    memory to a file, so that it can allocate memory in bulk or share it with another
    process. In the second half of this chapter, we will use `ps` to measure per-process
    memory usage before moving on to more accurate tools such as `smem` and `ps_mem`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习内核空间和用户空间内存的区别，以及内核如何将物理内存页映射到进程的地址空间。然后，我们将定位并读取 `proc` 文件系统下各个进程的内存映射。我们将看到如何使用
    `mmap` 系统调用将程序的内存映射到文件，这样它可以批量分配内存或与其他进程共享内存。在本章的后半部分，我们将使用 `ps` 来测量每个进程的内存使用情况，然后再使用更准确的工具，如
    `smem` 和 `ps_mem`。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Virtual memory basics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟内存基础
- en: Kernel-space memory layout
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核空间内存布局
- en: User-space memory layout
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户空间内存布局
- en: Process memory map
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程内存映射
- en: Managing memory
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理
- en: Swapping
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换
- en: Mapping memory with `mmap`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `mmap` 映射内存
- en: How much memory does my application use?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的应用程序使用了多少内存？
- en: Per-process memory usage
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进程的内存使用
- en: Identifying memory leaks
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别内存泄漏
- en: Running out of memory
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存不足
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along with the examples, make sure you have a Linux-based host system
    with `gcc`, `make`, `top`, `procps`, `valgrind`, and `smem` installed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随示例，确保你的 Linux 主机系统已安装 `gcc`、`make`、`top`、`procps`、`valgrind` 和 `smem`。
- en: All of these tools are available on most popular Linux distributions (such as
    Ubuntu, Arch, and so on).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些工具在大多数流行的 Linux 发行版（如 Ubuntu、Arch 等）上都可以使用。
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter18](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter18).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在本书的 GitHub 仓库的章节文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter18](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter18)。
- en: Virtual memory basics
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟内存基础
- en: To recap, Linux configures the **Memory Management Unit** (**MMU**) of the CPU
    to present a virtual address space to a running program that begins at zero and
    ends at the highest address, `0xffffffff`, on a 32-bit processor. This address
    space is divided into pages of 4 KB by default. If 4 KB pages are too small for
    your application, then you can configure the kernel to use **HugePages**, reducing
    the amount of system resources needed to access page table entries and increasing
    the **Translation Lookaside Buffer** (**TLB**) hit ratio.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，Linux 配置了 CPU 的 **内存管理单元** (**MMU**)，为正在运行的程序呈现一个从零开始并在 32 位处理器上以 `0xffffffff`
    结束的虚拟地址空间。这个地址空间默认被划分为 4 KB 的页面。如果 4 KB 的页面对你的应用来说太小，你可以配置内核使用 **HugePages**，从而减少访问页面表项所需的系统资源，并增加
    **转换后备缓冲区** (**TLB**) 的命中率。
- en: Linux divides this virtual address space into an area for applications, called
    **user space**, and an area for the kernel, called **kernel space**. The split
    between the two is set by a kernel configuration parameter named `PAGE_OFFSET`.
    In a typical 32-bit embedded system, `PAGE_OFFSET` is `0xc0000000`, giving the
    lower 3 gigabytes to user space and the top gigabyte to kernel space. The user
    address space is allocated per process so that each process runs in a sandbox,
    separated from the others. The kernel address space is the same for all processes,
    as there is only one kernel.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Linux将这个虚拟地址空间划分为供应用程序使用的区域，称为**用户空间**，以及供内核使用的区域，称为**内核空间**。两者之间的划分由一个名为`PAGE_OFFSET`的内核配置参数设置。在典型的32位嵌入式系统中，`PAGE_OFFSET`为`0xc0000000`，将低3GB分配给用户空间，顶端的1GB分配给内核空间。用户地址空间按进程分配，每个进程运行在自己的沙箱中，与其他进程隔离。内核地址空间对于所有进程都是相同的，因为只有一个内核。
- en: Pages in this virtual address space are mapped to physical addresses by the
    MMU, which uses page tables to perform the mapping.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个虚拟地址空间中的页面通过MMU映射到物理地址，MMU使用页表来执行映射。
- en: 'Each page of virtual memory may be unmapped or mapped as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟内存页面可以按以下方式进行映射或未映射：
- en: Unmapped so that trying to access these addresses will result in a `SIGSEGV`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未映射，因此尝试访问这些地址将导致`SIGSEGV`。
- en: Mapped to a page of physical memory that is private to the process.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射到进程专用的物理内存页面。
- en: Mapped to a page of physical memory that is shared with other processes.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射到与其他进程共享的物理内存页面。
- en: 'Mapped and shared with a **copy-on-write** (**CoW**) flag set: a write is trapped
    in the kernel, which makes a copy of the page and maps it to the process in place
    of the original page before allowing the write to take place.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射并共享，并设置**写时复制**（**CoW**）标志：写操作会被内核捕获，内核会复制该页面，并将其映射到进程中，取代原始页面，然后允许写操作发生。
- en: Mapped to a page of physical memory that is used by the kernel.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射到一个由内核使用的物理内存页面。
- en: The kernel may additionally map pages to reserved memory regions, for example,
    to access registers and memory buffers in device drivers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 内核还可以将页面映射到保留的内存区域，例如，访问设备驱动程序中的寄存器和内存缓冲区。
- en: 'An obvious question is this: why do we do it this way instead of simply referencing
    physical memory directly, as a typical RTOS would?'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显而易见的问题是：为什么要这样做，而不是像典型的实时操作系统那样直接引用物理内存？
- en: 'There are numerous advantages to virtual memory, some of which are described
    here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存有许多优势，以下是其中的一些描述：
- en: Invalid memory accesses are trapped and applications are alerted by `SIGSEGV`.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效的内存访问会被捕获，应用程序通过`SIGSEGV`收到警告。
- en: Processes run in their own memory space, isolated from other processes.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程在自己的内存空间中运行，彼此隔离。
- en: Efficient use of memory through the sharing of common code and data, for example,
    in libraries.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过共享公共代码和数据（例如在库中）高效使用内存。
- en: The possibility of increasing the apparent amount of physical memory by adding
    swap files, although swapping on embedded targets is rare.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加交换文件增加物理内存的表面量，尽管在嵌入式目标上交换操作很少见。
- en: These are powerful arguments, but I have to admit that there are some disadvantages
    as well. It is difficult to determine the actual memory budget of an application,
    which is one of the main concerns of this chapter. The default allocation strategy
    is to overcommit, which leads to tricky out-of-memory situations, which I will
    also discuss later, in the *Running out of memory* section. Finally, the delays
    introduced by the memory management code in handling exceptions—page faults—make
    the system less deterministic, which is important for real-time programs. I will
    cover this in [*Chapter 21*](Chapter_19.xhtml#_idTextAnchor654).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是有力的论点，但我不得不承认也有一些缺点。确定应用程序的实际内存预算是很困难的，这也是本章的主要关注点之一。默认的分配策略是过度承诺，这会导致棘手的内存不足情况，稍后我会在*内存不足*一节中讨论。最后，内存管理代码在处理异常（页面错误）时引入的延迟，使得系统变得不那么确定，这对实时程序来说非常重要。我将在[*第21章*](Chapter_19.xhtml#_idTextAnchor654)中讲解这一点。
- en: Memory management is different for kernel space and user space. The upcoming
    sections describe the essential differences and the things you need to know.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理在内核空间和用户空间中是不同的。接下来的章节将描述这些基本区别以及你需要了解的内容。
- en: Kernel-space memory layout
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核空间内存布局
- en: Kernel memory is managed in a straightforward way. It is not demand-paged, which
    means that for every allocation using `kmalloc()` or a similar function, there
    is real physical memory. Kernel memory is never discarded or paged out.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 内核内存的管理方式非常简单。它不是按需分页的，这意味着每次使用`kmalloc()`或类似函数进行分配时，都会有实际的物理内存。内核内存从不被丢弃或分页出去。
- en: 'Some architectures show a summary of the memory mapping at boot time in the
    kernel log messages. This trace is taken from a 32-bit Arm device (a BeagleBone
    Black):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一些架构在引导时会在内核日志消息中显示内存映射的摘要。这个跟踪来自一台32位的Arm设备（BeagleBone Black）：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The figure of 505,980 KB available is the amount of free memory the kernel sees
    when it begins execution but before it begins making dynamic allocations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 505,980 KB可用内存是内核开始执行时看到的自由内存量，但在内核开始进行动态分配之前。
- en: 'Consumers of kernel-space memory include the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 内核空间内存的消费者包括以下内容：
- en: The kernel itself, in other words, the code and data loaded from the kernel
    image file at boot time. This is shown in the preceding kernel log in the `.text`,
    `.init`, `.data`, and `.bss`. segments. The `.init` segment is freed once the
    kernel has completed initialization.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核本身，换句话说，是从引导时加载的内核映像文件中的代码和数据。这些内容在前面的内核日志中显示为`.text`、`.init`、`.data`和`.bss`段。`.init`段在内核初始化完成后会被释放。
- en: Memory allocated through the slab allocator, which is used for kernel data structures
    of various kinds. This includes allocations made using `kmalloc()`. They come
    from the region marked **lowmem**.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过slab分配器分配的内存，用于各种内核数据结构。这包括使用`kmalloc()`进行的分配。它们来自标记为**lowmem**的区域。
- en: Memory allocated via `vmalloc()`, usually for larger chunks of memory than is
    available through `kmalloc()`. These are in the **vmalloc** area.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`vmalloc()`分配的内存，通常用于分配比`kmalloc()`可用内存更大的内存块。这些位于**vmalloc**区域。
- en: A mapping for device drivers to access registers and memory belonging to various
    bits of hardware, which you can see by reading `/proc/iomem`. These also come
    from the **vmalloc** area, but since they are mapped to physical memory that is
    outside of the main system memory, they do not take up any real memory.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备驱动程序访问属于各种硬件部分的寄存器和内存的映射，您可以通过读取`/proc/iomem`来查看。这些也来自**vmalloc**区域，但由于它们映射到主系统内存之外的物理内存，因此不占用实际内存。
- en: Kernel modules which are loaded into the area marked **modules**.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载到标记为**modules**的区域中的内核模块。
- en: Other low-level allocations that are not tracked anywhere else.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他未在任何地方跟踪的低级别分配。
- en: Now that we know the layout of memory in kernel space, let’s find out how much
    memory the kernel is using.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了内核空间中内存的布局，让我们来看看内核实际使用了多少内存。
- en: How much memory does the kernel use?
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核使用了多少内存？
- en: Unfortunately, there isn’t a precise answer to the question of how much memory
    the kernel uses, but what follows is as close as we can get.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，关于内核使用多少内存这个问题，并没有确切的答案，但以下内容是我们能得到的最接近的答案。
- en: 'Firstly, you can see the memory taken up by the kernel code and data in the
    kernel log shown previously, or you can use the `size` command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以通过之前显示的内核日志查看内核代码和数据占用的内存，或者使用`size`命令：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Usually, the amount of memory taken by the kernel for the static code and data
    segments shown here is small when compared to the total amount of memory. If that
    is not the case, you need to look through the kernel configuration and remove
    the components that you don’t need. An effort to allow building small kernels
    known as **Linux Kernel Tinification** had been making good progress until the
    project stalled, and Josh Triplett’s patches were eventually removed from the
    `linux-next` tree in 2016\. Now, your best bet at reducing the kernel’s in-memory
    size is **Execute-in-Place** (**XIP**) where you trade RAM for flash ([https://lwn.net/Articles/748198/](https://lwn.net/Articles/748198/)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，与总内存量相比，内核为静态代码和数据段所占的内存较小。如果不是这种情况，您需要检查内核配置并删除不需要的组件。一个旨在构建小型内核的努力，称为**Linux内核简化**，在项目停滞之前取得了良好的进展，Josh
    Triplett的补丁最终在2016年从`linux-next`树中移除。现在，减少内核内存占用的最佳方法是**原地执行**（**XIP**），您可以通过牺牲RAM来换取闪存（[https://lwn.net/Articles/748198/](https://lwn.net/Articles/748198/)）。
- en: 'You can get more information about memory usage by reading `/proc/meminfo`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过读取`/proc/meminfo`获取更多内存使用信息：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is a description of each of these fields on the manual page `proc(5)`.
    The kernel memory usage is the sum of the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段的描述可以在手册页`proc(5)`中找到。内核内存使用量是以下各项的总和：
- en: '`Slab`: the total memory allocated by the slab allocator'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slab`：由slab分配器分配的总内存'
- en: '`KernelStack`: the stack space used when executing kernel code'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KernelStack`：执行内核代码时使用的栈空间'
- en: '`PageTables`: the memory used to store page tables'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PageTables`：用于存储页表的内存'
- en: '`VmallocUsed`: the memory allocated by `vmalloc()`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VmallocUsed`：`vmalloc()`分配的内存'
- en: In the case of slab allocations, you can get more information by reading `/proc/slabinfo`.
    Similarly, there is a breakdown of allocations in `/proc/vmallocinfo` for the
    **vmalloc** area. In both cases, you need detailed knowledge of the kernel and
    its subsystems in order to see exactly which subsystem is making the allocations
    and why, which is beyond the scope of this discussion.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于slab分配，你可以通过读取`/proc/slabinfo`获取更多信息。同样，`/proc/vmallocinfo`中有`**vmalloc**`区域的分配详细信息。在这两种情况下，你需要详细了解内核及其子系统，才能准确看到是哪个子系统进行的分配以及原因，这超出了本讨论的范围。
- en: 'With modules, you can use `lsmod` to find out the memory space taken up by
    the code and data:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块时，你可以通过`lsmod`查看代码和数据所占的内存空间：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This leaves the low-level allocations, of which there is no record, and that
    prevents us from generating an accurate account of kernel-space memory usage.
    This will appear as missing memory when we add up all the kernel- and user-space
    allocations that we know about.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这会留下低级分配，没有记录，这使得我们无法生成准确的内核空间内存使用统计。当我们将所有已知的内核和用户空间分配加起来时，这部分将表现为缺失的内存。
- en: Measuring kernel-space memory usage is complicated. The information in `/proc/meminfo`
    is somewhat limited and the additional information provided by `/proc/slabinfo`
    and `/proc/vmallocinfo` is difficult to interpret. User space offers better visibility
    into memory usage by way of the process memory map.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 测量内核空间内存使用情况比较复杂。`/proc/meminfo`中的信息有些有限，而`/proc/slabinfo`和`/proc/vmallocinfo`提供的附加信息难以解读。用户空间通过进程内存映射提供了更好的内存使用可见性。
- en: User-space memory layout
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户空间内存布局
- en: 'Linux employs a lazy allocation strategy for user space, only mapping physical
    pages of memory when the program accesses it. For example, allocating a buffer
    of 1 MB using `malloc(3)` returns a pointer to a block of memory addresses but
    no actual physical memory. A flag is set in the page table entries such that any
    read or write access is trapped by the kernel. This is known as a **page fault**.
    Only at this point does the kernel attempt to find a page of physical memory and
    add it to the page table mapping for the process. Let’s demonstrate this with
    a simple program from `MELD/Chapter18/pagefault-demo`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Linux对用户空间采用懒分配策略，只有当程序访问内存时，才会映射物理内存页。例如，使用`malloc(3)`分配1 MB的缓冲区时，返回的是指向内存地址块的指针，但并没有实际的物理内存。在页表条目中设置了一个标志，使得任何读或写访问都会被内核拦截。这就是**页面错误**。只有此时，内核才会尝试找到一页物理内存并将其添加到进程的页表映射中。让我们通过一个来自`MELD/Chapter18/pagefault-demo`的简单程序来演示这一点：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you run it, you will see output like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，你将看到如下输出：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There were 172 minor page faults encountered after initializing the program’s
    environment and a further 14 when calling `getrusage(2)` (these numbers will vary
    depending on the architecture and the version of the C library you are using).
    The important part is the increase when filling the memory with data: 442 - 186
    = 256\. The buffer is 1 MB, which is 256 pages. The second call to `memset(3)`
    makes no difference because all the pages are now mapped.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化程序环境后，遇到了172个小型页面错误，在调用`getrusage(2)`时又遇到了14个（这些数字会根据架构和你使用的C库版本有所不同）。重要的是填充内存时的增加：442
    - 186 = 256。缓冲区为1 MB，即256页。第二次调用`memset(3)`没有任何影响，因为所有页面现在已经映射。
- en: 'As you can see, a page fault is generated when the kernel traps access to a
    page that has not been mapped yet. In fact, there are two kinds of page faults:
    `minor` and `major`. With a minor fault, the kernel just has to find a page of
    physical memory and map it to the process address space, as shown in the preceding
    code. A major page fault occurs when the virtual memory is mapped to a file, for
    example, using `mmap(2)`, which I will describe shortly. Reading from this memory
    means that the kernel not only has to find a page of memory and map it in but
    also has to fill it with data from the file. Consequently, major faults are much
    more expensive in terms of time and system resources.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当内核截获对尚未映射的页面的访问时，会生成页面错误。事实上，有两种类型的页面错误：`轻微`和`严重`。在轻微错误中，内核只需找到一个物理内存页面并将其映射到进程地址空间，如前面的代码所示。严重页面错误发生在虚拟内存映射到文件时，例如使用`mmap(2)`，我稍后会描述。读取此内存意味着内核不仅需要找到一个内存页面并将其映射进来，还需要用文件中的数据填充它。因此，严重错误在时间和系统资源方面的成本要高得多。
- en: While `getrusage(2)` offers useful metrics on minor and major page faults within
    a process, sometimes what we really want to see is an overall memory map of a
    process.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`getrusage(2)`提供了有关进程中的轻微和严重页面错误的有用指标，但有时我们真正想看到的是进程的总体内存映射。
- en: Process memory map
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程内存映射
- en: 'Each running process in user space has a process map that we can inspect. These
    memory maps tell us how a program’s memory is allocated and what shared libraries
    it is linked to. You can see the memory map for a process through the `proc` filesystem.
    Here is the map for the `init` process (PID 1):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个在用户空间中运行的进程都有一个可以检查的进程映射。这些内存映射告诉我们程序如何分配内存以及它链接了哪些共享库。你可以通过`proc`文件系统查看进程的内存映射。以下是`init`进程（PID
    1）的映射：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first two columns show the start and end virtual addresses and the permissions
    for each mapping. The permissions are shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前两列显示每个映射的起始和结束虚拟地址，以及权限。权限在此处显示：
- en: '`r`: read'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`: 读取'
- en: '`w`: write'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`: 写入'
- en: '`x`: execute'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`: 执行'
- en: '`s`: shared'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`: 共享'
- en: '`p`: private (copy-on-write)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p`: 私有（写时复制）'
- en: 'If the mapping is associated with a file, the filename appears in the final
    column, and columns three, four, and five contain the offset from the start of
    the file, the block device number, and the inode of the file. Most of the mappings
    are to the program itself and the libraries it is linked with. There are two areas
    where the program can allocate memory, marked `[heap]` and `[stack]`. Memory allocated
    using malloc comes from the former (except for very large allocations, which we
    will come to later); allocations on the stack come from the latter. The maximum
    size of both areas is controlled by the process’s `ulimit`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果映射与文件相关联，则文件名出现在最后一列，第三、四和五列包含文件起始处的偏移量、块设备号和文件的inode。大多数映射指向程序本身和它链接的库。有两个区域，程序可以在其中分配内存，分别标记为`[heap]`和`[stack]`。使用`malloc`分配的内存来自前者（除了非常大的分配，我们稍后会提到）；堆栈上的分配来自后者。两个区域的最大大小由进程的`ulimit`控制：
- en: '**heap**: `ulimit -d`, default unlimited'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆**: `ulimit -d`，默认为无限制'
- en: '**stack**: `ulimit -s`, default 8 MB'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆栈**: `ulimit -s`，默认为8 MB'
- en: Allocations that exceed the limit are rejected by `SIGSEGV`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 超出限制的分配会被`SIGSEGV`拒绝。
- en: When running out of memory, the kernel may decide to discard pages that are
    mapped to a file and are read-only. If that page is accessed again, it will cause
    a major page fault and be read back in from the file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当内存不足时，内核可能决定丢弃那些映射到文件且为只读的页面。如果该页面再次被访问，将导致严重页面错误，并从文件中重新读取。
- en: Swapping
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换
- en: 'The idea of swapping is to reserve some storage where the kernel can place
    pages of memory that are not mapped to a file, freeing up the memory for other
    uses. It increases the effective size of physical memory by the size of the swap
    file. It is not a panacea: there is a cost to copying pages to and from a swap
    file, which becomes apparent on a system that has too little real memory for the
    workload it is carrying and so swapping becomes the main activity. This is sometimes
    known as **disk thrashing**.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 交换的理念是保留一些存储空间，内核可以将未映射到文件的内存页面放入其中，从而释放出内存供其他用途。它通过交换文件的大小增加了物理内存的有效大小。它并不是万能的：将页面复制到交换文件和从交换文件复制回来是有代价的，这在系统的实际内存不足以支撑其工作负载时变得显而易见，交换成为主要的活动。这有时被称为**磁盘抖动**。
- en: Swapping is seldom used on embedded devices because it does not work well with
    flash storage, where constant writing would wear it out quickly. However, you
    may want to consider swapping to compressed RAM (zram).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式设备上，交换通常不被使用，因为它不适用于闪存存储，频繁的写入会迅速磨损闪存。然而，你可能会考虑将交换设置为压缩 RAM（zram）。
- en: Swapping to compressed memory (zram)
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将内存交换到压缩内存（zram）
- en: The **zram** driver creates RAM-based block devices named `/dev/zram0`, `/dev/zram1`,
    and so on. Pages written to these devices are compressed before being stored.
    With compression ratios in the range of 30% to 50%, you can expect an overall
    increase in free memory of about 10% at the expense of more processing and a corresponding
    increase in power usage.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**zram** 驱动程序创建基于 RAM 的块设备，命名为 `/dev/zram0`、`/dev/zram1` 等。写入这些设备的页面在存储之前会被压缩。压缩比在
    30% 到 50% 之间，你可以期望空闲内存大约增加 10%，但这会增加更多的处理量并相应地增加功耗。'
- en: 'To enable zram, configure the kernel with these options:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 zram，请使用以下选项配置内核：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, mount zram at boot time by adding the following to `/etc/fstab`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过将以下内容添加到 `/etc/fstab` 中，在启动时挂载 zram：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can turn swapping on and off using the following commands:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令开启或关闭交换：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Swapping memory out to zram is better than swapping out to flash storage, but
    neither technique is a substitute for adequate physical memory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将内存交换到 zram 比交换到闪存存储更好，但这两种技术都不能替代足够的物理内存。
- en: User-space processes depend on the kernel to manage virtual memory for them.
    Sometimes a program wants greater control over its memory map than the kernel
    can offer. There is a system call that lets us map memory to a file for more direct
    access from user space.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间进程依赖内核管理虚拟内存。有时，程序需要比内核提供的更多的内存映射控制。有一个系统调用允许我们将内存映射到文件中，以便从用户空间进行更直接的访问。
- en: Mapping memory with mmap
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 mmap 映射内存
- en: 'A process begins life with a certain amount of memory mapped to the **text**
    (the code) and **data** segments of the program file, together with the shared
    libraries that it is linked with. It can allocate memory on its heap at runtime
    using `malloc(3)` and on the stack through locally scoped variables and memory
    allocated through `alloca(3)`. It may also load libraries dynamically at runtime
    using `dlopen(3)`. All of these mappings are taken care of by the kernel. However,
    a process can also manipulate its memory map in an explicit way using `mmap(2)`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程从启动时就会有一定量的内存映射到程序文件的 **文本**（代码）和 **数据** 段中，并与它链接的共享库一起。它可以在运行时使用 `malloc(3)`
    在堆上分配内存，并通过局部作用域变量以及使用 `alloca(3)` 分配的内存在栈上分配内存。它还可以在运行时使用 `dlopen(3)` 动态加载库。所有这些映射由内核处理。然而，进程也可以通过
    `mmap(2)` 显式地操作其内存映射：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function maps `length` bytes of memory from the file with the `fd` descriptor,
    starting at `offset` in the file, and returns a pointer to the mapping, assuming
    it is successful. Since the underlying hardware works in pages, `length` is rounded
    up to the nearest whole number of pages. The protection parameter, `prot`, is
    a combination of read, write, and execute permissions and the `flags` parameter
    contains at least `MAP_SHARED` or `MAP_PRIVATE`. There are many other flags, which
    are described in the `mmap` manpage.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从具有 `fd` 描述符的文件中映射 `length` 字节的内存，从文件中的 `offset` 位置开始，并返回指向映射的指针（如果成功）。由于底层硬件按页工作，`length`
    会向上舍入到最接近的整页数。保护参数 `prot` 是读、写和执行权限的组合，`flags` 参数至少包含 `MAP_SHARED` 或 `MAP_PRIVATE`。还有许多其他标志，详细说明可以参考
    `mmap` 的手册页。
- en: There are many things you can do with `mmap`. I will show some of them in the
    upcoming sections.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `mmap` 做很多事情。接下来的章节将展示其中的一些。
- en: Using mmap to allocate private memory
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 mmap 分配私有内存
- en: You can use `mmap` to allocate an area of private memory by setting `MAP_ANONYMOUS`
    in the `flags` parameter and setting the file descriptor `fd` to `-1`. This is
    similar to allocating memory from the heap using `malloc`, except that the memory
    is page-aligned and in multiples of pages. The memory is allocated in the same
    area as that used for libraries. In fact, this area is referred to by some as
    the `mmap` area for this reason.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 `flags` 参数中设置 `MAP_ANONYMOUS` 并将文件描述符 `fd` 设置为 `-1` 来使用 `mmap` 分配私有内存区域。这类似于使用
    `malloc` 从堆中分配内存，不同的是分配的内存是页对齐的，并且是页的倍数。分配的内存与库使用的内存区域相同。事实上，这个区域因此也被一些人称为 `mmap`
    区域。
- en: Anonymous mappings are better for large allocations because they do not pin
    down the heap with chunks of memory, which would make fragmentation more likely.
    Interestingly, you will find that `malloc` (in `glibc` at least) stops allocating
    memory from the heap for requests over 128 KB and uses `mmap` in this way, so
    in most cases, just using `malloc` is the right thing to do. The system will choose
    the best way of satisfying the request.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名映射更适合大块分配，因为它们不会将堆与内存块绑定，这样会增加碎片化的可能性。有趣的是，你会发现 `malloc`（至少在 `glibc` 中）在处理超过
    128 KB 的请求时，会停止从堆中分配内存，并改用 `mmap`，因此在大多数情况下，直接使用 `malloc` 就是正确的做法。系统会选择最合适的方式来满足请求。
- en: Using mmap to share memory
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 mmap 来共享内存
- en: 'As we saw in [*Chapter 17*](Chapter_17.xhtml#_idTextAnchor542), POSIX shared
    memory requires `mmap` to access the memory segment. In this case, you set the
    `MAP_SHARED` flag and use the file descriptor from `shm_open()`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第17章*](Chapter_17.xhtml#_idTextAnchor542) 中看到的，POSIX 共享内存需要 `mmap` 来访问内存段。在这种情况下，你需要设置
    `MAP_SHARED` 标志，并使用 `shm_open()` 的文件描述符：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Another process uses the same calls, filename, length, and flags to map to that
    memory region for sharing. Subsequent calls to `msync(2)` control when updates
    to memory are carried through to the underlying file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个进程使用相同的调用、文件名、长度和标志来映射到该内存区域以进行共享。后续调用 `msync(2)` 控制何时将内存更新传递到底层文件。
- en: Sharing memory via `mmap` also offers a straightforward way to read from and
    write to device memory.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `mmap` 共享内存还提供了一种直接的方式来读写设备内存。
- en: Using mmap to access device memory
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 mmap 访问设备内存
- en: As I mentioned in [*Chapter 11*](Chapter_11.xhtml#_idTextAnchor373), it is possible
    for a driver to allow its device node to be memory mapped and share some of the
    device memory with an application. The exact implementation is dependent on the
    driver.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在 [*第11章*](Chapter_11.xhtml#_idTextAnchor373) 中提到的，驱动程序可能允许其设备节点进行内存映射，并与应用程序共享一些设备内存。具体实现取决于驱动程序。
- en: 'One example is the Linux framebuffer, `/dev/fb0`. FPGAs such as the Xilinx
    Zynq series are also accessed as memory via `mmap` from Linux. The framebuffer
    interface is defined in `/usr/include/linux/fb.h`, including an `ioctl` function
    to get the size of the display and the bits per pixel. You can then use `mmap`
    to ask the video driver to share the framebuffer with the application and read
    and write pixels:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是 Linux 帧缓冲区 `/dev/fb0`。像 Xilinx Zynq 系列这样的 FPGA 也可以通过 `mmap` 从 Linux 中作为内存访问。帧缓冲接口定义在
    `/usr/include/linux/fb.h` 中，包括一个 `ioctl` 函数来获取显示的大小和每像素的位数。然后，你可以使用 `mmap` 请求视频驱动程序与应用程序共享帧缓冲区，并读取和写入像素：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A second example is the streaming video interface, **Video 4 Linux 2** (**V4L2)**,
    which is defined in `/usr/include/linux/videodev2.h`. Each video device has a
    node named `/dev/video<N>`, starting with `/dev/video0`. There is an `ioctl` function
    to ask the driver to allocate a number of video buffers that you can `mmap` into
    user space. Then, it is just a question of cycling the buffers and filling or
    emptying them with video data, depending on whether you are playing back or capturing
    a video stream.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子是流媒体视频接口 **Video 4 Linux 2** (**V4L2**) ，它定义在 `/usr/include/linux/videodev2.h`
    中。每个视频设备都有一个名为 `/dev/video<N>` 的节点，从 `/dev/video0` 开始。这里有一个 `ioctl` 函数来请求驱动程序分配一些视频缓冲区，你可以将其
    `mmap` 到用户空间。然后，只需要循环使用这些缓冲区，并根据是播放还是捕获视频流来填充或清空它们。
- en: Now that we have covered memory layout and mapping, let’s look at memory usage,
    starting with how to measure it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了内存布局和映射，让我们来看看内存使用情况，从如何衡量它开始。
- en: How much memory does my application use?
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我的应用程序使用了多少内存？
- en: As with kernel space, the different ways of allocating, mapping, and sharing
    user-space memory make it quite difficult to answer this seemingly simple question.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与内核空间一样，不同的用户空间内存分配、映射和共享方式使得回答这个看似简单的问题变得相当困难。
- en: 'To begin, you can ask the kernel how much memory it thinks is available, which
    you can do using the `free` command. Here is a typical example of the output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以询问内核它认为可用的内存量，你可以通过 `free` 命令来做到这一点。以下是输出的典型示例：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At first sight, this looks like a system that is almost out of memory, with
    only 4,704 KB free out of 509,016 KB: less than 1%. However, note that 26,456
    KB is in buffers and a whopping 363,860 KB is in caches. Linux believes that free
    memory is wasted memory; the kernel uses free memory for buffers and caches with
    the knowledge that they can be shrunk when the need arises. Removing buffers and
    cache from the measurement provides true free memory, which is 395,020 KSB: 77%
    of the total. When using `free`, the numbers on the second line marked `-/+ buffers/cache`
    are the important ones.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这看起来像是一个几乎没有内存的系统，只剩下4,704 KB的空闲内存，总共509,016 KB：少于1%。然而，请注意，26,456 KB在缓冲区中，而令人震惊的363,860
    KB在缓存中。Linux认为空闲内存是浪费的内存；内核使用空闲内存用于缓冲区和缓存，并知道在需要时可以缩小它们。从测量中去除缓冲区和缓存提供真正的空闲内存，即395,020
    KB：总量的77%。在使用`free`时，第二行标记为`-/+ buffers/cache`的数字是重要的。
- en: 'You can force the kernel to free up caches by writing a number between 1 and
    3 to `/proc/sys/vm/drop_caches`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将数字写入 `/proc/sys/vm/drop_caches` 强制内核释放缓存。
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The number is actually a bitmask that determines which of the two broad types
    of caches you want to free: `1` for the page cache and `2` for the dentry and
    inode caches combined. Since `1` and `2` are different bits, writing a `3` frees
    both types of caches.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字实际上是一个位掩码，确定你想要释放的两种广义缓存类型之一：`1` 表示页面缓存，`2` 表示dentry和inode缓存的组合体。因为 `1`
    和 `2` 是不同的位，写入 `3` 可以释放两种类型的缓存。
- en: The exact roles of these caches are not particularly important here, only that
    there is memory that the kernel is using but that can be reclaimed at short notice.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些缓存的确切角色在这里并不特别重要，只要知道内核正在使用但可以在短时间内收回的内存即可。
- en: The `free` command tells us how much memory is being used and how much is left.
    It neither tells us which processes are using the unavailable memory nor in what
    proportions. To measure that, we need other tools.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`free`命令告诉我们正在使用多少内存以及剩余多少。它既不告诉我们哪些进程正在使用不可用内存，也不告诉我们使用了多少。要测量这一点，我们需要其他工具。'
- en: Per-process memory usage
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个进程的内存使用情况
- en: 'There are several metrics to measure the amount of memory a process is using.
    I will begin with the two that are easiest to obtain: the **virtual set size**
    (**VSS**) and the **resident memory size** (**RSS**), both of which are available
    in most implementations of the `ps` and `top` commands:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种指标可以衡量进程正在使用的内存量。我将从最容易获取的两种开始：**虚拟集大小**（**VSS**）和**常驻内存大小**（**RSS**），这两者在大多数`ps`和`top`命令的实现中都可以找到：
- en: '**VSS**: Called `VSZ` in the `ps` command and `VIRT` in `top`, this is the
    total amount of memory mapped by a process. It is the sum of all the regions shown
    in `/proc/<PID>/map`. This number is of limited interest since only part of the
    virtual memory is committed to physical memory at any time.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VSS**：在`ps`命令中称为`VSZ`，在`top`中称为`VIRT`，这是由进程映射的所有内存区域的总和。由于虚拟内存的一部分仅在任何时候映射到物理内存中，这个数字的兴趣有限。'
- en: '**RSS**: Called `RSS` in `ps` and `RES` in `top`, this is the sum of memory
    that is mapped to physical pages of memory. This gets closer to the actual memory
    budget of the process, but there is a problem: if you add the RSS of all the processes,
    you will get an overestimate of the memory in use because some pages will be shared.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RSS**：在`ps`中称为`RSS`，在`top`中称为`RES`，这是映射到物理内存页的内存总和。这更接近进程实际内存预算，但存在一个问题：如果将所有进程的RSS相加，将会高估正在使用的内存，因为某些页面将是共享的。'
- en: Let’s learn more about the `top` and `ps` commands.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更多地了解`top`和`ps`命令。
- en: Using top and ps
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用top和ps
- en: The versions of `top` and `ps` from BusyBox provide very limited information.
    The examples that follow use the full versions from the `procps` package.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox提供的`top`和`ps`版本提供的信息非常有限。以下示例使用来自`procps`包的完整版本。
- en: 'Here is the output from a `ps` command with a custom format that includes `vsz`
    and `rss`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用自定义格式的`ps`命令的输出，包括`vsz`和`rss`：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Likewise, `top` shows a summary of the free memory and memory usage per process:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`top`显示了每个进程的空闲内存和内存使用情况的摘要：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These simple commands give you a feel for the memory usage and provide the first
    indication that you have a memory leak when you see that the RSS of a process
    keeps on increasing. However, they are not very accurate in the absolute measurements
    of memory usage.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的命令使您了解内存使用情况，并在看到进程的RSS持续增加时提供了内存泄漏的第一个迹象。但是，它们在内存使用的绝对测量方面并不十分精确。
- en: Using smem
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用smem
- en: 'In 2009, Matt Mackall began looking at the problem of accounting for shared
    pages in process memory measurement and added two new metrics called **unique
    set size** (**USS**) and **proportional set size** (**PSS**):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 2009年，Matt Mackall开始研究如何对进程内存中的共享页面进行记账的问题，并增加了两个新的指标，分别为**唯一集合大小**（**USS**）和**比例集合大小**（**PSS**）：
- en: '**USS**: This is the amount of memory that is committed to physical memory
    and is unique to a process; it is not shared with any others. It is the amount
    of memory that would be freed if the process were to terminate.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**USS**：这是分配到物理内存并且唯一属于一个进程的内存量；它不会与其他进程共享。它是进程终止时会释放的内存量。'
- en: '**PSS**: This splits the accounting of shared pages that are committed to physical
    memory between all the processes that have them mapped. For example, if an area
    of library code is 12 pages long and is shared by six processes, each will accumulate
    two pages in PSS. Thus, if you add the PSS numbers for all processes, you will
    get the actual amount of memory being used by those processes. In other words,
    PSS is the number we have been looking for.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PSS**：这会将共享页面在物理内存中被多进程映射时的记账分配给所有映射该页面的进程。例如，如果某个库代码区域有12页，并且被六个进程共享，那么每个进程的PSS将增加2页。因此，如果你将所有进程的PSS加起来，你将得到这些进程实际使用的内存量。换句话说，PSS就是我们一直在寻找的数字。'
- en: 'Information about PSS is available in `/proc/<PID>/smaps`, which contains additional
    information for each of the mappings shown in `/proc/<PID>/maps`. Here is a section
    from such a file that provides information on the mapping for the `libc` code
    segment:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 关于PSS的信息可以在`/proc/<PID>/smaps`中找到，该文件包含每个映射的附加信息，显示在`/proc/<PID>/maps`中。下面是该文件的一部分，提供了关于`libc`代码段映射的信息：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the `Rss` is `1132 kB`, but because it is shared between many other
    processes, the `Pss` is only `112 kB`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Rss`为`1132 kB`，但由于它在多个其他进程之间共享，因此`Pss`只有`112 kB`。
- en: There is a tool named **smem** that collates information from the `smaps` files
    and presents it in various ways, including as pie or bar charts. The project page
    for `smem` is [https://www.selenic.com/smem/](https://www.selenic.com/smem/).
    It is available as a package in most desktop distributions. However, since it
    is written in Python, installing it on an embedded target requires a Python environment,
    which may be too much trouble for just one tool. To help with this, there is a
    small program named **smemcap** that captures the state from `/proc` on the target
    and saves it to a TAR file that can be analyzed later on the host computer. `smemcap`
    is part of BusyBox, but it can also be compiled from source.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为**smem**的工具，它将来自`smaps`文件的信息整合并以多种方式呈现，包括饼状图或条形图。`smem`的项目页面是[https://www.selenic.com/smem/](https://www.selenic.com/smem/)。它作为软件包在大多数桌面发行版中提供。然而，由于它是用Python编写的，在嵌入式目标系统上安装它需要一个Python环境，这对于仅仅是一个工具来说可能太麻烦。为了解决这个问题，有一个名为**smemcap**的小程序，它从目标系统的`/proc`捕获状态，并将其保存到一个可以在主机计算机上分析的TAR文件中。`smemcap`是BusyBox的一部分，但也可以从源代码编译。
- en: 'If you run `smem` natively, as `root`, you will see these results:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以`root`身份直接运行`smem`，你将看到这些结果：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see from the last line of the output that, in this case, the total PSS
    is about half of the RSS.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出的最后一行可以看到，在这种情况下，总的PSS大约是RSS的一半。
- en: 'If you don’t have or don’t want to install Python on your target, you can capture
    the state using `smemcap`, again as `root`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装Python，或者不想在目标系统上安装Python，你可以使用`smemcap`捕获状态，再次以`root`身份运行：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, copy the TAR file to the host and read it using `smem -t -S`, although
    this time there is no need to run the command as `root`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将TAR文件复制到主机上，使用`smem -t -S`读取，尽管这一次不需要以`root`身份运行命令：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output is identical to the output we get when running `smem` natively.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与我们直接运行`smem`时获得的输出相同。
- en: Other tools to consider
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他工具可供考虑
- en: Another way to display PSS is via **ps_mem** ([https://github.com/pixelb/ps_mem](https://github.com/pixelb/ps_mem)),
    which prints much the same information but in a simpler format. It is also written
    in Python.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种显示PSS的方式是使用**ps_mem**（[https://github.com/pixelb/ps_mem](https://github.com/pixelb/ps_mem)），它以更简单的格式显示几乎相同的信息。它也是用Python编写的。
- en: Android also has a tool that displays a summary of USS and PSS for each process,
    named **procrank**, which can be cross-compiled for embedded Linux with a few
    small changes. You can get the code from [https://github.com/csimmonds/procrank_linux](https://github.com/csimmonds/procrank_linux).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Android也有一个工具，它显示每个进程的USS和PSS摘要，名为**procrank**，它可以通过一些小的修改交叉编译到嵌入式Linux上。你可以从[https://github.com/csimmonds/procrank_linux](https://github.com/csimmonds/procrank_linux)获取代码。
- en: We now know how to measure per-process memory usage. Let’s say we use the tools
    just shown to find the process that is the memory hog in our system. How do we
    then drill down into that process to figure out where it is going wrong? That
    is the topic of the next section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何衡量每个进程的内存使用情况。假设我们使用刚才展示的工具来找到系统中占用内存最多的进程。那么我们该如何进一步深入这个进程，找出它出问题的地方呢？这就是下一节的内容。
- en: Identifying memory leaks
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别内存泄漏
- en: A memory leak occurs when memory is allocated but not freed when it is no longer
    needed. Memory leakage is by no means unique to embedded systems, but it becomes
    an issue partly because targets don’t have much memory in the first place and
    partly because they often run for long periods of time without rebooting, allowing
    the leaks to become a large puddle.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏发生在内存被分配但在不再需要时没有释放。内存泄漏绝不仅仅是嵌入式系统的专属问题，但它成为一个问题，部分原因是目标设备本身内存有限，部分原因是它们通常长时间运行而不重启，这使得泄漏逐渐变成一个大水坑。
- en: You will realize that there is a leak when you run `free` or `top` and see that
    free memory is continually going down even if you drop caches, as shown in the
    preceding section. You will be able to identify the culprit (or culprits) by looking
    at the USS and RSS per process.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`free`或`top`并看到即使清空缓存，空闲内存仍然持续减少时，你就会意识到有内存泄漏，正如上一节所示。通过查看每个进程的USS和RSS，你将能够识别泄漏的罪魁祸首。
- en: 'There are several tools to identify memory leaks in a program. I will look
    at two: `mtrace` and `valgrind`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种工具可以识别程序中的内存泄漏。我将介绍两种：`mtrace`和`valgrind`。
- en: mtrace
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mtrace
- en: '**mtrace** is a component of `glibc` that traces calls to `malloc`, `free`,
    and related functions, and identifies areas of memory not freed when the program
    exits. You need to call the `mtrace()` function from within the program to begin
    tracing and then, at runtime, write a path name to the `MALLOC_TRACE` environment
    variable in which the trace information is written. If `MALLOC_TRACE` does not
    exist or if the file cannot be opened, the `mtrace` hooks are not installed.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**mtrace**是`glibc`的一个组件，它跟踪对`malloc`、`free`及相关函数的调用，并识别在程序退出时未释放的内存区域。你需要在程序中调用`mtrace()`函数以开始跟踪，然后在运行时将路径名写入`MALLOC_TRACE`环境变量中，该变量指定了写入跟踪信息的文件路径。如果`MALLOC_TRACE`不存在或无法打开该文件，则`mtrace`钩子将无法安装。'
- en: 'While the trace information is written in ASCII, it is usual to use the `mtrace`
    command to view it. Here is an example of a program that uses `mtrace` from `MELD/Chapter18/mtrace-example`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然跟踪信息是以ASCII格式写入的，但通常使用`mtrace`命令来查看它。以下是一个使用`mtrace`的程序示例，来自`MELD/Chapter18/mtrace-example`：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is what you might see when running the program and looking at the trace:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你在运行程序并查看跟踪时可能看到的内容：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Unfortunately, `mtrace` does not tell you about leaked memory while the program
    runs. It has to terminate first.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`mtrace`不会告诉你程序运行期间的泄漏内存。它必须先终止才能报告。
- en: Valgrind
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Valgrind
- en: '**Valgrind** is a very powerful tool used to discover memory problems including
    leaks and other things. One advantage is that you don’t have to recompile the
    programs and libraries that you want to check, although it works better if they
    have been compiled with the `-g` option so that they include debug symbol tables.
    It works by running the program in an emulated environment and trapping execution
    at various points. This leads to the big downside of Valgrind, which is that the
    program runs at a fraction of normal speed, which makes it less useful for testing
    anything with real-time constraints.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**Valgrind**是一个非常强大的工具，用于发现包括泄漏在内的内存问题。它的一个优势是你无需重新编译要检查的程序和库，尽管如果它们在编译时使用了`-g`选项，以便包含调试符号表，它的效果会更好。它通过在模拟环境中运行程序并在多个点截获执行来工作。这导致了Valgrind的一个大缺点，那就是程序运行速度远低于正常速度，这使得它在测试有实时约束的应用时效果较差。'
- en: '**TIP**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: 'Incidentally, the name is often mispronounced: it says in the Valgrind FAQ
    that the grind part is pronounced with a short *i*, as in grinned (rhymes with
    tinned) rather than grind (rhymes with find). The FAQ, documentation, and downloads
    are available at [https://valgrind.org](https://valgrind.org).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，Valgrind 的名字常被误读：Valgrind 常见 FAQ 中表示 "grind" 部分的发音应该是短音 *i*，就像 "grinned"（与
    "tinned" 押韵），而不是 "grind"（与 "find" 押韵）。FAQ、文档和下载可以访问 [https://valgrind.org](https://valgrind.org)。
- en: 'Valgrind contains several diagnostic tools:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind 包含多个诊断工具：
- en: '`memcheck`: This is the default tool, and it detects memory leaks and general
    misuse of memory.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memcheck`：这是默认的工具，用于检测内存泄漏和一般的内存误用。'
- en: '`cachegrind`: This calculates the processor cache hit rate.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cachegrind`：此工具计算处理器缓存命中率。'
- en: '`callgrind`: This calculates the cost of each function call.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callgrind`：此工具计算每个函数调用的开销。'
- en: '`helgrind`: This highlights the misuse of the Pthread API, including potential
    deadlocks, and race conditions.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`helgrind`：此工具突出了 Pthread API 的误用，包括潜在的死锁和竞争条件。'
- en: '`DRD`: This is another Pthread analysis tool.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DRD`：这是另一个 Pthread 分析工具。'
- en: '`massif`: This profiles the usage of the heap and stack.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`massif`：此工具分析堆和栈的使用情况。'
- en: 'You can select the tool you want with the `-tool` option. Valgrind runs on
    the major embedded platforms: Arm (Cortex-A), PowerPC, MIPS, and x86 in 32-bit
    and 64-bit variants. It is available as a package in both The Yocto Project and
    Buildroot.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `-tool` 选项选择你想使用的工具。Valgrind 支持主要的嵌入式平台：Arm（Cortex-A）、PowerPC、MIPS 和 x86
    的 32 位和 64 位版本。它在 Yocto 项目和 Buildroot 中都有提供作为软件包。
- en: 'To find our memory leak, we need to use the default `memcheck` tool, with the
    `-–leak-check=full` option to print the lines where the leak was found:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到我们的内存泄漏，我们需要使用默认的 `memcheck` 工具，并使用 `-–leak-check=full` 选项打印出发现泄漏的代码行：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output from Valgrind shows that two memory leaks were found in `mtrace-example.c`:
    a `malloc` at line 12 and a `calloc` at line 14\. The subsequent calls to `free`
    that are supposed to accompany these two memory allocations are missing from the
    program. Left unchecked, memory leaks in a long-running process may eventually
    result in the system running out of memory.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind 的输出显示在 `mtrace-example.c` 中发现了两个内存泄漏：第 12 行的 `malloc` 和第 14 行的 `calloc`。但是，程序中缺少与这两个内存分配配对的
    `free` 调用。如果不加以检查，长时间运行的进程中的内存泄漏最终可能导致系统内存耗尽。
- en: Running out of memory
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存耗尽
- en: 'The standard memory allocation policy is to **overcommit**, which means that
    the kernel will allow more memory to be allocated by applications than there is
    physical memory. Most of the time, this works fine because it is common for applications
    to request more memory than they really need. This also helps in the implementation
    of `fork(2)`: it is safe to make a copy of a large program because the pages of
    memory are shared with the copy-on-write flag set. In the majority of cases, `fork`
    is followed by an `exec` function call, which unshares the memory and then loads
    a new program.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的内存分配策略是**过度提交**，这意味着内核允许应用程序分配比物理内存更多的内存。大多数情况下，这种做法是有效的，因为应用程序请求的内存量通常超过其实际需求。这也有助于
    `fork(2)` 的实现：复制一个大型程序是安全的，因为内存页与写时复制标志共享。在大多数情况下，`fork` 之后会调用 `exec` 函数，这会解除共享内存并加载新程序。
- en: However, there is always the possibility that a particular workload will cause
    a group of processes to try to cash in on the allocations they have been promised
    simultaneously and so demand more than there really is. This is an **out-of-memory**,
    or **OOM**, situation. At this point, there is no other alternative but to kill
    off processes until the problem goes away. This is the job of the **out-of-memory
    killer**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，总是存在某些工作负载可能导致一组进程试图同时请求它们已经被承诺的内存分配，从而需求超过实际可用的内存量。这就是**内存不足**（**OOM**）的情况。此时，唯一的办法是终止一些进程，直到问题解决。这是**内存不足杀手**的工作。
- en: 'Before we get to that, there is a tuning parameter for kernel allocations in
    `/proc/sys/vm/overcommit_memory`, which you can set to the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，`/proc/sys/vm/overcommit_memory` 中有一个内核分配的调优参数，你可以将其设置为以下值：
- en: '`0`: heuristic overcommit'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：启发式过度提交'
- en: '`1`: always overcommit; never check'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：始终过度提交；绝不检查'
- en: '`2`: always check; never overcommit'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：始终检查；绝不过度提交'
- en: Option `0` is the default and is the best choice in the majority of cases.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 `0` 是默认设置，在大多数情况下是最佳选择。
- en: Option `1` is only useful if you run programs that work with large sparse arrays
    and allocate large areas of memory but write to a small proportion of them. Such
    programs are rare in the context of embedded systems.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 `1` 只在你运行的程序需要处理大型稀疏数组并分配大量内存但仅对其中一小部分进行写入时有用。在嵌入式系统的背景下，这种程序比较少见。
- en: Option `2` seems to be a good choice if you are worried about running out of
    memory, perhaps in a mission or safety-critical application. It will fail allocations
    that are greater than the commit limit, which is the size of swap space plus the
    total memory multiplied by the overcommit ratio. The overcommit ratio is controlled
    by /`proc/sys/vm/overcommit_ratio` and has a default value of 50%.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心内存耗尽，尤其是在任务或安全关键的应用中，选项 `2` 似乎是一个不错的选择。它将会失败大于提交限制的分配，而提交限制是交换空间大小加上总内存与过度提交比例的乘积。过度提交比例由
    `/proc/sys/vm/overcommit_ratio` 控制，默认值为 50%。
- en: 'As an example, suppose you have a device with 2 GB of system RAM and you set
    a really conservative ratio of 25%:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你有一台系统内存为 2 GB 的设备，并且你设置了一个非常保守的 25% 比例：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There is no swap, so the commit limit is 25% of `MemTotal`, as expected.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 没有交换空间，因此提交限制是 `MemTotal` 的 25%，这也是预期的结果。
- en: 'There is another important variable in `/proc/meminfo`, called `Committed_AS`.
    This is the total amount of memory that is needed to fulfill all the allocations
    made so far. I found the following on one system:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/meminfo` 中还有另一个重要变量，叫做 `Committed_AS`。它表示为了完成迄今为止所有分配所需的总内存。我在一个系统上找到了以下内容：'
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In other words, the kernel had already promised more memory than the available
    memory. Consequently, setting `overcommit_memory` to `2` would mean that all allocations
    would fail regardless of `overcommit_ratio`. To get to a working system, I would
    have to either install double the amount of RAM or severely reduce the number
    of running processes, of which there were about 40.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，内核已经承诺分配的内存超出了可用内存。因此，将 `overcommit_memory` 设置为 `2` 将意味着所有分配都会失败，无论 `overcommit_ratio`
    设置为多少。为了让系统正常工作，我必须要么安装双倍的内存，要么大幅减少正在运行的进程数量，而当时大约有 40 个进程。
- en: 'In all cases, the final defense is `oom-killer`. It uses a heuristic method
    to calculate a badness score between 0 and 1,000 for each process and then terminates
    those with the highest score until there is enough free memory. You should see
    something like this in the kernel log:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，最终的防线是 `oom-killer`。它使用启发式方法计算每个进程的“坏度”得分，范围从 0 到 1000，然后终止得分最高的进程，直到释放出足够的空闲内存。你应该在内核日志中看到类似这样的内容：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can force an OOM event using `echo f > /proc/sysrq-trigger`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行 `echo f > /proc/sysrq-trigger` 强制触发一个 OOM 事件。
- en: You can influence the badness score for a process by writing an adjustment value
    to `/proc/<PID>/oom_score_adj`. A value of `-1000` means that the badness score
    can never be greater than zero and so it will never be killed; a value of `+1000`
    means that it will always be greater than 1,000 and so it will always be killed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向 `/proc/<PID>/oom_score_adj` 写入调整值来影响进程的坏度得分。`-1000` 的值意味着坏度得分永远不会大于零，因此进程永远不会被杀死；`+1000`
    的值意味着它将始终大于 1000，因此进程将始终被杀死。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Accounting for every byte of memory used in a virtual memory system is just
    not possible. However, you can find a fairly accurate figure for the total amount
    of free memory, excluding that taken by buffers and the cache, using the `free`
    command. By monitoring it over a period of time and with different workloads,
    you should become confident that it will remain within a given limit.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟内存系统中，完全记录每一个字节的内存使用情况几乎是不可能的。不过，你可以通过 `free` 命令获得一个相当准确的空闲内存总量的数字，排除缓冲区和缓存所占用的内存。通过在一段时间内和不同的工作负载下监控它，你应该可以确认它会保持在一个给定的限制范围内。
- en: 'When you want to tune memory usage or identify sources of unexpected allocations,
    there are resources that give more detailed information. For kernel space, the
    most useful information is in `/proc`: `meminfo`, `slabinfo`, and `vmallocinfo`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要调整内存使用或识别意外分配的来源时，有一些资源可以提供更详细的信息。对于内核空间，最有用的信息在 `/proc` 目录下：`meminfo`、`slabinfo`
    和 `vmallocinfo`。
- en: When it comes to getting accurate measurements for user space, the best metric
    is PSS, as shown by `smem` and other tools. For memory debugging, you can get
    help from simple tracers such as `mtrace`, or you have the heavyweight option
    of the Valgrind `memcheck` tool.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取用户空间的准确测量时，最佳的度量标准是 PSS，如 `smem` 和其他工具所示。对于内存调试，你可以使用像 `mtrace` 这样的简单追踪工具，或者使用较为重型的
    Valgrind `memcheck` 工具。
- en: If you have concerns about the consequence of an OOM situation, you can fine-tune
    the allocation mechanism via `/proc/sys/vm/overcommit_memory` and you can control
    the likelihood of particular processes being killed though the `oom_score_adj`
    parameter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对OOM（内存不足）情况的后果有所担忧，你可以通过`/proc/sys/vm/overcommit_memory`来微调分配机制，并且可以通过`oom_score_adj`参数控制特定进程被终止的可能性。
- en: The next chapter is all about debugging user-space and kernel code using the
    GNU Debugger and the insights you can gain from watching code as it runs, including
    the memory management functions I have described here.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将详细介绍如何使用GNU调试器调试用户空间和内核代码，以及你通过观察代码运行时能够获得的洞见，其中包括我在这里描述的内存管理功能。
- en: Further study
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步学习
- en: '*Linux Kernel Development, 3rd edition*, by Robert Love'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux内核开发（第三版）*，作者：Robert Love'
- en: '*Linux System Programming, 2nd Edition*, by Robert Love'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux系统编程（第二版）*，作者：Robert Love'
- en: '*Understanding the Linux Virtual Memory Manager*, by Mel Gorman – [https://www.kernel.org/doc/gorman/pdf/understand.pdf](https://www.kernel.org/doc/gorman/pdf/understand.pdf)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解Linux虚拟内存管理*，作者：Mel Gorman – [https://www.kernel.org/doc/gorman/pdf/understand.pdf](https://www.kernel.org/doc/gorman/pdf/understand.pdf)'
- en: '*Valgrind 3.3: Advanced Debugging and Profiling for GNU/Linux Applications*,
    by Julian Seward, Nicholas Nethercote, and Josef Weidendorfer'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Valgrind 3.3：GNU/Linux应用程序的高级调试与性能分析*，作者：Julian Seward、Nicholas Nethercote
    和 Josef Weidendorfer'
