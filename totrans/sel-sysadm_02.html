<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div id="_idContainer010" class="calibre2">
			<h1 id="_idParaDest-18" class="calibre5"><em class="italic"><a id="_idTextAnchor018" class="pcalibre calibre6 pcalibre1"/>Chapter 1</em>: Fundamental SELinux Concepts</h1>
			<p class="calibre3"><strong class="bold">Security-Enhanced Linux (SELinux)</strong> brings additional security measures to your Linux system to further protect its resources. As part of the Linux kernel, it is a mandatory access control system supported by major Linux distributions. In this book, we cover all aspects of SELinux, from basic fundamentals to resolving SELinux issues, configuring applications to deal with SELinux, and even writing our own policies.</p>
			<p class="calibre3">Before we embark on the details of SELinux, let's first cover the concepts of this technology: why SELinux uses labels to identify resources, how SELinux differs from traditional Linux access controls, how SELinux enforces security rules, and other mandatory access control systems that are supported in the Linux kernel. We will also see how the access control rules enforced by SELinux are provided through policy files. At the end of the chapter, we will cover an overview of the differences between SELinux implementations across Linux distributions.</p>
			<p class="calibre3">In this chapter, we're going to cover the following main topics:</p>
			<ul class="calibre8">
				<li class="calibre9">Providing more security for Linux</li>
				<li class="calibre9">Labeling all resources and objects</li>
				<li class="calibre9">Defining and distributing policies</li>
				<li class="calibre9">Distinguishing between policies</li>
			</ul>
			<h1 id="_idParaDest-19" class="calibre5"><a id="_idTextAnchor019" class="pcalibre calibre6 pcalibre1"/>Technical requirements</h1>
			<p class="calibre3">Check out the following video to see the Code in Action: <a href="https://bit.ly/2FFaUdm" class="pcalibre calibre6 pcalibre1">https://bit.ly/2FFaUdm</a></p>
			<h1 id="_idParaDest-20" class="calibre5"><a id="_idTextAnchor020" class="pcalibre calibre6 pcalibre1"/>Providing more security for Linux</h1>
			<p class="calibre3">Seasoned Linux <a id="_idIndexMarker000" class="pcalibre calibre6 pcalibre1"/>administrators and security engineers already know that they need to put some trust in the users and processes of their system in order for the system to remain secure. This is partly because users can attempt to exploit vulnerabilities found in the software running on the system, but a large contribution to this trust level is because the secure state of the system depends on the behavior of the users. A Linux user with access to sensitive information could easily leak that out to the public, manipulate the behavior of the applications they launch, and do many other things that affect the security of the system. The default access controls active on a regular Linux system are <strong class="bold">discretionary</strong>; it is up <a id="_idIndexMarker001" class="pcalibre calibre6 pcalibre1"/>to the users how the access controls should behave.</p>
			<p class="calibre3">The Linux <strong class="bold">discretionary access control (DAC)</strong> mechanism is based on the user and/or group <a id="_idIndexMarker002" class="pcalibre calibre6 pcalibre1"/>information of the process and is matched against the user and/or group information of the file, directory, or other resource being manipulated. Consider the <strong class="source-inline">/etc/shadow</strong> file, which contains the password and account information of the local Linux accounts:</p>
			<p class="source-code">$ ls -l /etc/shadow </p>
			<p class="source-code">-rw-r-----. 1 root root 1019 Nov 28 20:44 /etc/shadow</p>
			<p class="calibre3">Without additional <a id="_idIndexMarker003" class="pcalibre calibre6 pcalibre1"/>access control mechanisms in place, this file is readable and writable by any process owned by the <strong class="source-inline">root</strong> user, regardless of the purpose of the process on the system. The <strong class="source-inline">shadow</strong> file is a typical example of a sensitive file that we don't want to see leaked or abused in any other fashion. Yet the moment someone has access to the file, that user can copy it elsewhere, for example to a home directory, or even mail it to another computer and attempt to attack the password hashes stored within.</p>
			<p class="calibre3">Another example of how Linux DAC requires trust from its users is the configuration of a database server. Database files themselves are (hopefully) only accessible to the runtime account of the <strong class="bold">database management system</strong> (<strong class="bold">DBMS</strong>) itself, and the Linux <strong class="source-inline">root</strong> user. Properly <a id="_idIndexMarker004" class="pcalibre calibre6 pcalibre1"/>secured systems will only grant trusted users access to these files (for instance, through <strong class="source-inline">sudo</strong>) by allowing them to change their effective user ID from their personal user to the database runtime user or even the <strong class="source-inline">root</strong> account, but only for a well-defined set of commands that the system administrator has configured up front. These users too, can analyze the database files and gain access to potentially confidential information in the database without going through the DBMS. Administrators often have to put significant trust in these users to provide a secure system, rather than being able to enforce this.</p>
			<p class="calibre3">However, regular users are not the only reason for securing a system. Lots of software daemons run as the Linux <strong class="source-inline">root</strong> user or have significant privileges on the system. Errors within those daemons can easily lead to information leakage or might even lead to remotely exploitable vulnerabilities. Backup software, monitoring software, change management software, scheduling software, and so on: they all often run with the highest privileged account possible on a regular Linux system. Even when the administrator does not allow privileged users, their interaction with daemons introduces a potential security risk. So, the users are still trusted to correctly interact with these applications in order for the system to function properly. Through this, the administrator leaves the security of the system to the <em class="italic">discretion</em> of its (many) users.</p>
			<p class="calibre3">Enter SELinux, which provides an additional access control layer <em class="italic">on top of</em> the standard Linux DAC mechanism. SELinux provides a <strong class="bold">mandatory access control (MAC)</strong> system that, unlike <a id="_idIndexMarker005" class="pcalibre calibre6 pcalibre1"/>its DAC counterpart, gives the administrator full control over what is allowed on the system and what isn't. It accomplishes this by supporting a policy-driven approach over what processes are and aren't allowed to do and by enforcing this policy through the Linux kernel.</p>
			<p class="calibre3"><strong class="bold">Mandatory</strong> means that <a id="_idIndexMarker006" class="pcalibre calibre6 pcalibre1"/>the operating system enforces the access control, defined solely by the policy rules that the system administrator (or security administrator) has enabled. Users and processes do not have permission to change the security rules, so they cannot work around <a id="_idIndexMarker007" class="pcalibre calibre6 pcalibre1"/>the access controls; security is not left to their discretion anymore.</p>
			<p class="calibre3">Considering the relational database example, a mandatory access control system would no longer require the administration to trust certain users, as it has full control over what these users can and cannot do. PostgreSQL, as we will see in <a href="B16276_08_Final_VK.xhtml#_idTextAnchor237" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 8</em></a>, <em class="italic">SEPostgreSQL – Extending PostgreSQL with SELinux</em>, can interact with the SELinux subsystem to allow the administrator full coverage over the data access involved, even inside the database.</p>
			<p class="calibre3">The word <em class="italic">mandatory</em> here, just like the word <em class="italic">discretionary</em> before, was not chosen accidentally to describe the abilities of the access control system: both are known terms in the security <a id="_idIndexMarker008" class="pcalibre calibre6 pcalibre1"/>research field. Many security publications use these terms, including the <strong class="bold">Trusted Computer System Evaluation Criteria</strong> (<strong class="bold">TSEC</strong>) (<a href="http://csrc.nist.gov/publications/history/dod85.pdf" class="pcalibre calibre6 pcalibre1">http://csrc.nist.gov/publications/history/dod85.pdf</a>) standard (also known as the <strong class="bold">Orange Book</strong>) published by the Department of Defense in the United States of America in 1985. This publication has led to the Common Criteria standard for computer security certification (ISO/IEC 15408), available at <a href="http://www.commoncriteriaportal.org/cc/" class="pcalibre calibre6 pcalibre1">http://www.commoncriteriaportal.org/cc/</a>.</p>
			<p class="calibre3">Next, we'll describe how the Linux kernel is responsible for the SELinux implementation.</p>
			<h2 id="_idParaDest-21" class="calibre10"><a id="_idTextAnchor021" class="pcalibre calibre6 pcalibre1"/>Introducing Linux Security Modules (LSM)</h2>
			<p class="calibre3">Consider the example of the <strong class="source-inline">shadow</strong> file again. A MAC system can be configured to only allow a limited <a id="_idIndexMarker009" class="pcalibre calibre6 pcalibre1"/>number of processes to read from and write to the file. On such specifically configured systems, a user logged on as <strong class="source-inline">root</strong> cannot directly access the file or even move it around. They can't even change the attributes of the file:</p>
			<p class="source-code"># id</p>
			<p class="source-code">uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),</p>
			<p class="source-code">4(adm),6(disk),10(wheel),11(floppy),26(tape),27(video) context=sysadm_u:sysadm_r:sysadm_t:s0-s0:c0.c1023</p>
			<p class="source-code"># cat /etc/shadow</p>
			<p class="source-code">cat: /etc/shadow: Permission denied</p>
			<p class="source-code"># chmod a+r /etc/shadow</p>
			<p class="source-code">chmod: changing permissions of '/etc/shadow': Permission denied</p>
			<p class="calibre3">The system enforces this through rules that describe when the contents of this file can be read, or when its attributes can be changed. With SELinux, these rules are defined in the SELinux policy and are loaded when the system boots. It is the Linux kernel itself that is responsible for enforcing the rules.</p>
			<p class="calibre3">Mandatory access control systems such as SELinux are supported in the Linux kernel through <strong class="bold">Linux Security Modules</strong> (<strong class="bold">LSM</strong>), a Linux subsystem <a id="_idIndexMarker010" class="pcalibre calibre6 pcalibre1"/>called before processing a user space request. Such requests are called <strong class="bold">system calls</strong>, and Linux supports over 100 of them.</p>
			<div class="calibre13">
				<div id="_idContainer006" class="img---figure">
					<img src="Images/B16276_01_001.jpg" alt="Figure 1.1 – High-level overview of how LSM integrates into the Linux kernel " class="calibre14"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – High-level overview of how LSM integrates into the Linux kernel</p>
			<p class="calibre3">LSM has been available in the Linux kernel since version 2.6, released in December 2003. It is a framework that provides hooks inside the Linux kernel at various locations, including the system call entry points. When these hooks trigger, registered security implementations such as SELinux have their functions executed automatically. In SELinux, these <a id="_idIndexMarker011" class="pcalibre calibre6 pcalibre1"/>functions check the policy and other information before returning a go/no-go. LSM by itself does not provide any security functionality; instead, it relies on security implementations that do the heavy lifting: the framework is <em class="italic">modular</em>.</p>
			<p class="calibre3">Within the LSM framework, two types of security modules exist: exclusive and non-exclusive modules. Two exclusive modules cannot be active simultaneously: each exclusive LSM module needs exclusive control over some kernel objects (generally those related to a security context) and is not able to deal with other LSM modules that need these objects as well. Non-exclusive modules don't have this need and can be combined (also known as <em class="italic">stacking</em>) at will, regardless of whether an exclusive LSM module is active or not.</p>
			<p class="calibre3">A major use case for stacking LSM modules is to enable different security models within containers running on the system. Right now, it is not possible to implement a different security module within a Linux container, and the security within the container falls back to the security module of the host. To support this, more and more exclusive LSM implementations (like SELinux) are working to make their implementation non-exclusive, and we <a id="_idIndexMarker012" class="pcalibre calibre6 pcalibre1"/>can expect improvements in this area within the next year. </p>
			<p class="calibre3">SELinux is one implementation that uses LSM. Several other implementations exist:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="bold">AppArmor</strong> is a <a id="_idIndexMarker013" class="pcalibre calibre6 pcalibre1"/>mandatory access control system that has a strong focus on application-level protections (called profiles), based largely on filesystem paths. This makes AppArmor easy to understand and implement for administrators, as it does not have the complexity of abstracting rules to labels (as SELinux does). In the <em class="italic">Labeling all resources and objects</em> section, we explain why SELinux uses labels. AppArmor is an exclusive LSM module at the time of writing, but will most likely become non-exclusive very soon.</li>
				<li class="calibre9"><strong class="bold">Smack</strong> is a mandatory <a id="_idIndexMarker014" class="pcalibre calibre6 pcalibre1"/>access control system that uses labels on processes and resources. The labels contain security identifiers interpreted by Smack to enforce access control, requiring fewer access rules in Smack (unlike SELinux, which does not perform an interpretation of labels – excluding sensitivity – and thus requires a higher number of policy rules). Smack is an exclusive LSM module.</li>
				<li class="calibre9"><strong class="bold">TOMOYO Linux</strong> is a mandatory access control system, but its access control mechanism is <a id="_idIndexMarker015" class="pcalibre calibre6 pcalibre1"/>also easy to use for system analysis. It automatically builds up policies based on application behavior, and like AppArmor, its policies primarily use paths rather than labels. TOMOYO Linux (and its fork, <strong class="bold">AKARI</strong>) is a <a id="_idIndexMarker016" class="pcalibre calibre6 pcalibre1"/>non-exclusive LSM module.</li>
				<li class="calibre9"><strong class="bold">LoadPin</strong> is an LSM <a id="_idIndexMarker017" class="pcalibre calibre6 pcalibre1"/>module that ensures that the Linux kernel resources (such as kernel modules and firmware) are all loaded from a single non-writable filesystem. LoadPin is a non-exclusive LSM module.</li>
				<li class="calibre9"><strong class="bold">Yama</strong> is an LSM module that adds additional access controls on activities that are not sufficiently <a id="_idIndexMarker018" class="pcalibre calibre6 pcalibre1"/>fine-grained by Linux, such as by attaching them to the memory of another process (using <strong class="source-inline">ptrace</strong>). Yama is a non-exclusive LSM module.</li>
				<li class="calibre9"><strong class="bold">SafeSetId</strong> is an LSM <a id="_idIndexMarker019" class="pcalibre calibre6 pcalibre1"/>module that allows finer control over which users can use <strong class="source-inline">setuid</strong> (switching to another user) toward another user. Rather than granting the use of <strong class="source-inline">setuid</strong>, SafeSetId can limit for which users this is allowed. This ensures that vulnerabilities or misconfigurations in tools such as <strong class="source-inline">sudo</strong> are still contained. SafeSetId is a non-exclusive LSM module.</li>
				<li class="calibre9"><strong class="bold">Lockdown</strong> is an LSM <a id="_idIndexMarker020" class="pcalibre calibre6 pcalibre1"/>module that protects the Linux kernel memory. It has two modes: in integrity mode, it prevents modifying kernel objects from user space (such as direct memory access or PCI access); in confidentiality mode, it additionally prevents extracting potentially confidential information from kernel objects. Lockdown is a non-exclusive LSM module.</li>
				<li class="calibre9">The <strong class="bold">capability</strong> LSM <a id="_idIndexMarker021" class="pcalibre calibre6 pcalibre1"/>module is, by default, enabled on systems and provides support for Linux capabilities (a set of permissions granted to a user when the user is assigned a certain capability). It is a non-exclusive LSM module.</li>
			</ul>
			<p class="calibre3">To query <a id="_idIndexMarker022" class="pcalibre calibre6 pcalibre1"/>the list of active LSM modules on a system, read <strong class="source-inline">/sys/kernel/security/lsm</strong>:</p>
			<p class="source-code">$ cat /sys/kernel/security/lsm</p>
			<p class="source-code">capability,selinux</p>
			<p class="calibre3">Next, we'll explain how SELinux works on top of regular Linux access controls.</p>
			<h2 id="_idParaDest-22" class="calibre10"><a id="_idTextAnchor022" class="pcalibre calibre6 pcalibre1"/>Extending regular DAC with SELinux</h2>
			<p class="calibre3">SELinux does <a id="_idIndexMarker023" class="pcalibre calibre6 pcalibre1"/>not change the Linux <a id="_idIndexMarker024" class="pcalibre calibre6 pcalibre1"/>DAC implementation, nor can it override denials made by the Linux DAC permissions. If a regular system (without SELinux) prevents a particular access, there is nothing SELinux can do to override this decision. This is because the LSM hooks are triggered <em class="italic">after</em> the regular DAC permission checks execute, a conscious design decision from the LSM project.</p>
			<p class="calibre3">For instance, if you need to allow an additional user access to a file, you cannot add an SELinux policy to do that for you. Instead, you will need to look into other features of Linux, such as the use of POSIX access control lists. Through the <strong class="source-inline">setfacl</strong> and <strong class="source-inline">getfacl</strong> commands, the user can set additional permissions on files and directories, opening up the selected resource to additional users or groups.</p>
			<p class="calibre3">As an example, let's grant a user <strong class="source-inline">admin</strong> read-write access to a file using <strong class="source-inline">setfacl</strong>:</p>
			<p class="source-code">$ setfacl -m u:admin:rw /srv/backup/setup.conf</p>
			<p class="calibre3">Similarly, to view the current POSIX ACLs applied to the file, use this command:</p>
			<p class="source-code">$ getfacl /srv/backup/setup.conf</p>
			<p class="source-code">getfacl: Removing leading '/' from absolute path names</p>
			<p class="source-code"># file: srv/backup/setup.conf</p>
			<p class="source-code"># owner: root</p>
			<p class="source-code"># group: root</p>
			<p class="source-code">user::rw-</p>
			<p class="source-code">user::admin:rw-</p>
			<p class="source-code">group::r--</p>
			<p class="source-code">mask::rw-</p>
			<p class="source-code">other::r—</p>
			<p class="calibre3">This shows <a id="_idIndexMarker025" class="pcalibre calibre6 pcalibre1"/>that the file is writable <a id="_idIndexMarker026" class="pcalibre calibre6 pcalibre1"/>not only by its owner but also by the <strong class="source-inline">admin</strong> user.</p>
			<h2 id="_idParaDest-23" class="calibre10"><a id="_idTextAnchor023" class="pcalibre calibre6 pcalibre1"/>Restricting root privileges</h2>
			<p class="calibre3">The regular Linux DAC allows an all-powerful user: <strong class="source-inline">root</strong>. Unlike most other users on the system, the <a id="_idIndexMarker027" class="pcalibre calibre6 pcalibre1"/>logged-on <strong class="source-inline">root</strong> user has all the rights needed to fully manage the entire system, ranging from overriding access controls to controlling audits, changing user IDs, managing the network, and much more. This is supported through a security <a id="_idIndexMarker028" class="pcalibre calibre6 pcalibre1"/>concept called <strong class="bold">capabilities</strong> (for an overview of Linux capabilities, check out the capabilities manual page: <strong class="source-inline">man capabilities</strong>). SELinux is also able to restrict access to these capabilities in a fine-grained manner.</p>
			<p class="calibre3">Due to this fine-grained authorization aspect of SELinux, even the <strong class="source-inline">root</strong> user can be confined without impacting the operations on the system. The previous example of accessing <strong class="source-inline">/etc/shadow</strong> is just one example of an activity that a powerful user such as <strong class="source-inline">root</strong> still might not be able to perform due to the SELinux access controls in place.</p>
			<h2 id="_idParaDest-24" class="calibre10"><a id="_idTextAnchor024" class="pcalibre calibre6 pcalibre1"/>Reducing the impact of vulnerabilities</h2>
			<p class="calibre3">If one <a id="_idIndexMarker029" class="pcalibre calibre6 pcalibre1"/>benefit of SELinux needs to be stressed, then it is its ability to reduce the impact of vulnerabilities. But this vulnerability reduction is also often misunderstood.</p>
			<p class="calibre3">A properly written SELinux policy confines applications so that their allowed activities are reduced <a id="_idIndexMarker030" class="pcalibre calibre6 pcalibre1"/>to a minimum set. This <strong class="bold">least-privilege model</strong> ensures that abnormal application behavior is not only detected and audited but also prevented. Many application vulnerabilities can be exploited to execute tasks that an application is not meant to do. When this happens, SELinux will prevent this.</p>
			<p class="calibre3">However, there are two misconceptions about SELinux's ability to thwart exploits, namely, the impact of the policy and the exploitation itself.</p>
			<p class="calibre3">If the policy is not written in a least-privilege model, then SELinux might consider this non-standard behavior as normal and allow the actions to continue. For policy writers, this means that their policy rules have to be very fine-grained. Sadly, that makes writing policies very time-consuming: with more than 130 classes and over 250 permissions known to SELinux, policy rules need to take all these classes and permissions into account for each interaction.</p>
			<p class="calibre3">As a result, policies tend to become convoluted and harder to maintain. Some policy writers make policies more permissive than is absolutely necessary, which might result in exploits becoming successful even though the action is not expected behavior from an application's point of view. Some application policies are explicitly marked as unconfined (which we discuss in <a href="B16276_14_Final_VK.xhtml#_idTextAnchor354" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 14</em></a>, <em class="italic">Dealing with New Applications</em>), showing that they are very liberal in their allowed permissions. Fedora, CentOS, and Red Hat Enterprise Linux even start application policies as permissive and only start enforcing access controls for those applications after a few releases (and additional testing).</p>
			<p class="calibre3">The second misconception is the exploit itself. If an application's vulnerability allows an unauthenticated user to use the application services as if the user were a regular, authorized user, then SELinux will not play a role in reducing the impact of the vulnerability; it will only notice the behavior of the application itself and not of the sessions internal to the application. As long as the application itself behaves as expected (such as accessing its own files and not poking around in other filesystems), SELinux will happily allow the actions to take place.</p>
			<p class="calibre3">It is only when the application starts behaving erratically that SELinux stops the exploit from continuing. SELinux <a id="_idIndexMarker031" class="pcalibre calibre6 pcalibre1"/>will prevent exploits such as <strong class="bold">remote command execution (RCE)</strong> against applications that should not be executing random commands (such as database management systems or web servers, excluding <a id="_idIndexMarker032" class="pcalibre calibre6 pcalibre1"/>CGI-like functionality), whereas session hijacking or SQL injection attacks are not controllable through SELinux policies.</p>
			<h2 id="_idParaDest-25" class="calibre10"><a id="_idTextAnchor025" class="pcalibre calibre6 pcalibre1"/>Enabling SELinux support</h2>
			<p class="calibre3">Enabling <a id="_idIndexMarker033" class="pcalibre calibre6 pcalibre1"/>SELinux on a Linux system is not just a matter <a id="_idIndexMarker034" class="pcalibre calibre6 pcalibre1"/>of enabling the SELinux LSM module within the Linux kernel.</p>
			<p class="calibre3">An SELinux implementation contains the following:</p>
			<ul class="calibre8">
				<li class="calibre9">The SELinux kernel subsystem, implemented in the Linux kernel through LSM</li>
				<li class="calibre9">Libraries, used by applications that need to interact with SELinux</li>
				<li class="calibre9">Utilities, used by administrators to interact with SELinux</li>
				<li class="calibre9">Policies, which define the access controls themselves</li>
			</ul>
			<p class="calibre3">The libraries and utilities are bundled by the SELinux user space project (<a href="https://github.com/SELinuxProject/selinux" class="pcalibre calibre6 pcalibre1">https://github.com/SELinuxProject/selinux</a>). Next to the applications and libraries provided by the SELinux user space project, various components on a Linux system are updated with SELinux-specific code, including the <strong class="source-inline">init</strong> system and several core utilities.</p>
			<p class="calibre3">Because SELinux isn't just a switch that needs to be toggled, Linux distributions that support it usually come with SELinux predefined and loaded: Fedora, CentOS, and Red Hat Enterprise Linux (with its derivatives, such as Oracle Linux) are well-known examples. Other supporting distributions might not automatically have SELinux enabled but can easily support it through the installation of additional packages (which is the case with Debian and Ubuntu), and others have a well-documented approach to how to convert a system to SELinux (for example, Gentoo and Arch Linux).</p>
			<p class="calibre3">Throughout the book, we will show examples for Gentoo and CentOS 8 (which is based on the free software of the Red Hat Enterprise Linux releases and is sponsored by Red Hat). These two distributions have different implementation details, which allow us to demonstrate the full potential of SELinux. To ensure the commands used within this book are available, some SELinux support tools might need to be installed.</p>
			<p class="calibre3">On Gentoo Linux, install at least the following packages:</p>
			<p class="source-code"># emerge app-admin/setools sys-apps/policycoreutils</p>
			<p class="calibre3">On CentOS Linux, install at least the following packages:</p>
			<p class="source-code"># yum install setools-console policycoreutils-python-utils</p>
			<p class="calibre3">As packages can change over time, it is sensible to look up which package provides a particular command. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If the mentioned packages no longer exist or do not cover all commands, please consult your distribution's documentation on which software packages to install. Most distributions allow searching for the most appropriate package as well, such as with <strong class="source-inline">e-file</strong> in Gentoo, or <strong class="source-inline">yum whatprovides</strong> on CentOS or related distributions.</p>
			<p class="calibre3">With the SELinux main functionality described, let's look at how SELinux knows what is on the <a id="_idIndexMarker035" class="pcalibre calibre6 pcalibre1"/>system, and which abstraction it uses to allow policies <a id="_idIndexMarker036" class="pcalibre calibre6 pcalibre1"/>to be developed for a wide set of users.</p>
			<h1 id="_idParaDest-26" class="calibre5"><a id="_idTextAnchor026" class="pcalibre calibre6 pcalibre1"/>Labeling all resources and objects</h1>
			<p class="calibre3">When SELinux <a id="_idIndexMarker037" class="pcalibre calibre6 pcalibre1"/>has to decide whether it has to allow or deny a particular action, it makes a decision based on the context of both the <strong class="bold">subject</strong> (who is initiating the action) and the <strong class="bold">object</strong> (which is the target of the action). These contexts (or parts of the context) are mentioned in the policy rules that SELinux enforces.</p>
			<p class="calibre3">The <strong class="bold">context</strong> of a process is what identifies the process to SELinux. SELinux has no notion of Linux process ownership and does not care how the process is called, which process ID it has, and what account the process runs as. All it wants to know is what the context of that process is, represented to users and administrators as a <strong class="bold">label</strong>. <em class="italic">Label</em> and <em class="italic">context</em> are often used interchangeably, and although there is a technical distinction (one is a representation of the other), we will not dwell on that much.</p>
			<p class="calibre3">Let's look at an example label – the context of the current user:</p>
			<p class="source-code">$ id -Z </p>
			<p class="source-code">sysadm_u:sysadm_r:sysadm_t:s0-s0:c0.c1023</p>
			<p class="calibre3">The <strong class="source-inline">id</strong> command, which returns information about the current user, is shown executing with the <strong class="source-inline">-Z</strong> switch (a commonly agreed upon switch for displaying additional security information obtained from the LSM-based security subsystem). It shows us the context of the current user (actually the context of the <strong class="source-inline">id</strong> process itself when it was executing). As we can see, the context has a string representation and looks as if it has five fields (it doesn't; it has four fields – the last field just happens to contain a colon character).</p>
			<p class="calibre3">SELinux developers decided to use labels instead of real process and file (or other resource) metadata for its access controls. This is different from MAC systems such as AppArmor, which uses the path of the binary (and thus the process name) and the paths of the resources to handle permission checks. The following reasons inspired the decision to make SELinux a label-based mandatory access control:</p>
			<ul class="calibre8">
				<li class="calibre9">Using paths might be easier to comprehend for administrators, but this doesn't allow us to keep the context information close to the resource. If a file or directory moves or remounts, or if a process has a different namespace view on the files, then the access controls might behave differently as they look at the path instead of the file. With label-based contexts, the system retains this information and keeps controlling the resource's access properly.</li>
				<li class="calibre9">Contexts reveal the purpose of the process very well. The same binary application can be launched in different contexts depending on how it got started. The context value (such as the one shown in the <strong class="source-inline">id -Z</strong> output earlier) is exactly what the administrator needs. With it, they know what the rights are of each of the running instances, but they can also deduce from it how the process was launched and what its purpose is.</li>
				<li class="calibre9">Contexts also make abstractions of the object itself. We are used to talking about processes and files, but contexts are also applicable to less tangible resources such as pipes (inter-process communication) or database objects. Path-based identification only works as long as you can write a path.</li>
			</ul>
			<p class="calibre3">As an <a id="_idIndexMarker038" class="pcalibre calibre6 pcalibre1"/>example, consider the following policy statements:</p>
			<ul class="calibre8">
				<li class="calibre9">Allow the <strong class="source-inline">httpd</strong> processes to bind to TCP port <strong class="source-inline">80</strong>.</li>
				<li class="calibre9">Allow the processes labeled with <strong class="source-inline">httpd_t</strong> to bind to TCP ports labeled with <strong class="source-inline">http_port_t</strong>.</li>
			</ul>
			<p class="calibre3">In the first example, we cannot easily reuse this policy when the web server process isn't using the <strong class="source-inline">httpd</strong> binary (perhaps because it was renamed or it isn't Apache but another web server) or when we want to have HTTP access on a different port. With the labeled approach, the binary could be called <strong class="source-inline">apache2</strong> or <strong class="source-inline">MyWebServer.py</strong>; as long as the process <a id="_idIndexMarker039" class="pcalibre calibre6 pcalibre1"/>is labeled with <strong class="source-inline">httpd_t</strong>, the policy applies. The same happens with the port definition: you can label the port <strong class="source-inline">8080</strong> with <strong class="source-inline">http_port_t</strong> and thus allow the web servers to bind to that port as well without having to write another policy statement.</p>
			<h2 id="_idParaDest-27" class="calibre10"><a id="_idTextAnchor027" class="pcalibre calibre6 pcalibre1"/>Dissecting the SELinux context</h2>
			<p class="calibre3">To come <a id="_idIndexMarker040" class="pcalibre calibre6 pcalibre1"/>to a context, SELinux uses at least three, and sometimes four, values. Let's look at the context of the SSH server as an example:</p>
			<p class="source-code">$ ps -eZ | grep sshd</p>
			<p class="source-code">system_u:system_r:sshd_t:s0-s0:c0.c1023 2629 ? 00:00:00 sshd</p>
			<p class="calibre3">As we can see, the process is assigned a context that contains the following fields:</p>
			<ul class="calibre8">
				<li class="calibre9">The SELinux user <strong class="source-inline">system_u</strong></li>
				<li class="calibre9">The SELinux role <strong class="source-inline">system_r</strong></li>
				<li class="calibre9">The SELinux type (also known as the domain when we are looking at a running process) <strong class="source-inline">sshd_t</strong></li>
				<li class="calibre9">The sensitivity level <strong class="source-inline">s0-s0:c0.c1023</strong></li>
			</ul>
			<p class="calibre3">When we work with SELinux, knowing the contexts is extremely important. In most cases, it is the <a id="_idIndexMarker041" class="pcalibre calibre6 pcalibre1"/>third field (called the <strong class="bold">domain</strong> or <strong class="bold">type</strong>) that <a id="_idIndexMarker042" class="pcalibre calibre6 pcalibre1"/>is most important since the majority of SELinux policy rules (over 99 percent) consist of rules related to the interaction between two types (without mentioning roles, users, or sensitivity levels).</p>
			<p class="calibre3">SELinux contexts are aligned with LSM security attributes and exposed to the user space in a standardized manner (compatible with multiple LSM implementations), allowing end users and applications to easily query the contexts. An easily accessible location where these attributes are presented is within the <strong class="source-inline">/proc</strong> pseudo filesystem.</p>
			<p class="calibre3">Inside each process's <strong class="source-inline">/proc/&lt;pid&gt;</strong> location, we find a subdirectory called <strong class="source-inline">attr</strong>, inside of which the following files can be found:</p>
			<p class="source-code">$ ls /proc/$$/attr</p>
			<p class="source-code">current  exec  fscreate  keycreate  prev  sockcreate</p>
			<p class="calibre3">All these files, if read, display either nothing or an SELinux context. If it is empty, then that means the application has not explicitly set a context for that particular purpose, and the SELinux context will be deduced either from the policy or inherited from its parent.</p>
			<p class="calibre3">The meaning <a id="_idIndexMarker043" class="pcalibre calibre6 pcalibre1"/>of the files are as follows:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">current</strong> file displays the current SELinux context of the process.</li>
				<li class="calibre9">The <strong class="source-inline">exec</strong> file displays the SELinux context that will be assigned by the next application execution done through this application. It is usually empty.</li>
				<li class="calibre9">The <strong class="source-inline">fscreate</strong> file displays the SELinux context that will be assigned to the next file written by the application. It is usually empty.</li>
				<li class="calibre9">The <strong class="source-inline">keycreate</strong> file displays the SELinux context that will be assigned to the keys cached in the kernel by this application. It is usually empty.</li>
				<li class="calibre9">The <strong class="source-inline">prev</strong> file displays the previous SELinux context for this particular process. This is usually the context of its parent application.</li>
				<li class="calibre9">The <strong class="source-inline">sockcreate</strong> file displays the SELinux context that will be assigned to the next socket created by the application. It is usually empty.</li>
			</ul>
			<p class="calibre3">If an application has multiple subtasks, then the same information is available in each subtask directory at <strong class="source-inline">/proc/&lt;pid&gt;/task/&lt;taskid&gt;/attr</strong>.</p>
			<h2 id="_idParaDest-28" class="calibre10"><a id="_idTextAnchor028" class="pcalibre calibre6 pcalibre1"/>Enforcing access through types</h2>
			<p class="calibre3">The SELinux type (the third part of an SELinux context) of <a id="_idIndexMarker044" class="pcalibre calibre6 pcalibre1"/>a process (called the <strong class="bold">domain</strong>) is the basis of the fine-grained access controls of that process with respect to itself and <a id="_idIndexMarker045" class="pcalibre calibre6 pcalibre1"/>other types (which can be processes, files, sockets, network interfaces, and more). In most SELinux literature, SELinux's label-based access control mechanism is fine-tuned to say that SELinux is a <strong class="bold">type enforcement</strong> mandatory <a id="_idIndexMarker046" class="pcalibre calibre6 pcalibre1"/>access control system: when some actions are denied, the (absence of the) fine-grained access controls on the type level are most likely to blame.</p>
			<p class="calibre3">With type enforcement, SELinux can control an application's behavior based on how it got executed in the first place: a web server launched by a user will run with a different type than a web server executed through the <strong class="source-inline">init</strong> system, even though the process binary and path are the same. The web server launched from the <strong class="source-inline">init</strong> system is most likely trusted (and thus allowed to do whatever web servers are supposed to do), whereas a manually launched web server is less likely to be considered <em class="italic">normal behavior</em> and as such will have different privileges.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The majority of SELinux's online resources focus on types. Even though the SELinux type is just the third part of an SELinux context, it is the most important one for most administrators. Most documentation will even just talk about a type such as <strong class="source-inline">sshd_t</strong> rather than a full SELinux context.</p>
			<p class="calibre3">Take a look at the following <strong class="source-inline">dbus-daemon</strong> processes:</p>
			<p class="source-code"># ps -eZ | grep dbus-daemon</p>
			<p class="source-code">swift_u:swift_r:swift_dbusd_t:s0-s0:c0.c512 571 ? 00:00:01 dbus-daemon</p>
			<p class="source-code">swift_u:swift_r:swift_dbusd_t:s0-s0:c0.c512 649 ? 00:00:00 dbus-daemon</p>
			<p class="source-code">system_u:system_r:system_dbusd_t:s0-s0:c0.c1023 2498 ? 00:00:00 dbus-daemon</p>
			<p class="calibre3">In this example, one <strong class="source-inline">dbus-daemon</strong> process is the system D-Bus daemon running with the aptly named <strong class="source-inline">system_dbusd_t</strong> type, whereas two other ones are running with the <strong class="source-inline">swift_dbusd_t</strong> type assigned to it. Even though their binaries are the same, they both serve a different purpose on the system and as such have a different type assigned. SELinux then uses this type to govern the actions allowed by the process toward other types, including how <strong class="source-inline">system_dbusd_t</strong> can interact with <strong class="source-inline">swift_dbusd_t</strong>.</p>
			<p class="calibre3">SELinux types are by convention suffixed with <strong class="source-inline">_t</strong>, although this is not mandatory.</p>
			<h2 id="_idParaDest-29" class="calibre10"><a id="_idTextAnchor029" class="pcalibre calibre6 pcalibre1"/>Granting domain access through roles</h2>
			<p class="calibre3">SELinux <a id="_idIndexMarker047" class="pcalibre calibre6 pcalibre1"/>roles (the second part of an SELinux context) allow SELinux to support role-based access controls. Although type enforcement is the most used (and known) part of SELinux, role-based access control is an important method to keep a system secure, especially from malicious user attempts. SELinux roles define which types (domains) can be accessed from the current context. These types (domains) on their part define the permissions. As such, SELinux roles help define what a user (who has access to one or more roles) can and cannot do.</p>
			<p class="calibre3">By convention, SELinux roles are defined with an <strong class="source-inline">_r</strong> suffix. On most SELinux-enabled systems, the administrator can assign the following SELinux roles to users:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">user_r</strong> role is meant for restricted users. This role is only allowed to have processes with types specific to end-user applications. Privileged types, including those used to switch to another Linux user, are not allowed for this role.</li>
				<li class="calibre9">The <strong class="source-inline">staff_r</strong> role is meant for non-critical operations. This role is generally restricted to the same applications as the restricted user, but it has the ability to switch roles. It is the default role for operators to have (so as to keep those users in their least privileged role as long as possible).</li>
				<li class="calibre9">The <strong class="source-inline">sysadm_r</strong> role is meant for system administrators. This role is very privileged, enabling various system administration tasks. However, certain end-user application types might not be supported (especially if those types are used for potentially vulnerable or untrusted software) to keep the system free from infections.</li>
				<li class="calibre9">The <strong class="source-inline">secadm_r</strong> role is meant for security administrators. This role allows changing the SELinux policy and manipulating the SELinux controls. It is generally used when a separation of duties is needed between system administrators and system policy management.</li>
				<li class="calibre9">The <strong class="source-inline">system_r</strong> role is meant for daemons and background processes. This role is quite privileged, supporting the various daemon and system process types. However, end-user application types and other administrative types are not allowed in this role.</li>
				<li class="calibre9">The <strong class="source-inline">unconfined_r</strong> role is meant for end users. This role allows a limited number of types, but those types are very privileged as they allow running any application launched by a user (or another unconfined process) in a more or less unconfined manner (not restricted by SELinux rules). This role, as such, is only available if the system administrator wants to protect certain processes (mostly daemons) while keeping the rest of the system operations almost untouched by SELinux.</li>
			</ul>
			<p class="calibre3">Other roles might exist, such as <strong class="source-inline">guest_r</strong> and <strong class="source-inline">xguest_r</strong>, depending on the distribution. It is wise to consult the distribution documentation for more information about the supported roles. The <strong class="source-inline">seinfo</strong> command is the most common method to obtain an overview of available roles:</p>
			<p class="source-code"># seinfo –-role</p>
			<p class="source-code">Roles: 9</p>
			<p class="source-code">   auditadm_r</p>
			<p class="source-code">   object_r</p>
			<p class="source-code">   secadm_r</p>
			<p class="source-code">   …</p>
			<p class="source-code">   user_r</p>
			<p class="calibre3">With <a id="_idIndexMarker048" class="pcalibre calibre6 pcalibre1"/>the SELinux roles identified, let's look at how we assign roles to users.</p>
			<h2 id="_idParaDest-30" class="calibre10"><a id="_idTextAnchor030" class="pcalibre calibre6 pcalibre1"/>Limiting roles through users</h2>
			<p class="calibre3">An SELinux <a id="_idIndexMarker049" class="pcalibre calibre6 pcalibre1"/>user (the first part of an SELinux context) is not the same as a Linux (account) user. Unlike Linux user information, which can change while the user is working on the system (through tools such as <strong class="source-inline">sudo</strong> or <strong class="source-inline">su</strong>), the SELinux policy can (and generally will) enforce that the SELinux user remains the same even when the Linux user itself has changed. Because of the immutable state of the SELinux user, we can implement specific access controls to ensure that users cannot work around the set of permissions granted to them, even when they get privileged access.</p>
			<p class="calibre3">An example <a id="_idIndexMarker050" class="pcalibre calibre6 pcalibre1"/>of such an access control is the <strong class="bold">user-based access control</strong> (<strong class="bold">UBAC</strong>) feature that some Linux distributions (optionally) enable, which prevents users from accessing files of different SELinux users even when those users try to use the Linux DAC controls to grant access to each other's files.</p>
			<p class="calibre3">The most <a id="_idIndexMarker051" class="pcalibre calibre6 pcalibre1"/>important feature of SELinux users, however, is that SELinux user definitions restrict which roles the (Linux) user can assume. A Linux user is first assigned to an SELinux user, which does not need to be unique: multiple Linux users can be assigned to the same SELinux user. Once set, that user cannot switch to an SELinux role not associated with that SELinux user.</p>
			<p class="calibre3">The following diagram shows the role-based access control implementation of SELinux:</p>
			<div class="calibre13">
				<div id="_idContainer007" class="img---figure">
					<img src="Images/B16276_01_002.jpg" alt="Figure 1.2 – Mapping Linux accounts to SELinux users " class="calibre15"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Mapping Linux accounts to SELinux users</p>
			<p class="calibre3"><strong class="bold">SELinux users</strong> are, by <a id="_idIndexMarker052" class="pcalibre calibre6 pcalibre1"/>convention, defined with an <strong class="source-inline">_u</strong> suffix, although this is not mandatory. The SELinux users that most distributions have available are <a id="_idIndexMarker053" class="pcalibre calibre6 pcalibre1"/>named after the role they represent, but instead of ending with <strong class="source-inline">_r</strong>, they end with <strong class="source-inline">_u</strong>. For instance, for the <strong class="source-inline">sysadm_r</strong> role, we have the <strong class="source-inline">sysadm_u</strong> SELinux user.</p>
			<h2 id="_idParaDest-31" class="calibre10"><a id="_idTextAnchor031" class="pcalibre calibre6 pcalibre1"/>Controlling information flow through sensitivities</h2>
			<p class="calibre3">The fourth <a id="_idIndexMarker054" class="pcalibre calibre6 pcalibre1"/>part of an SELinux context, the sensitivity, is not always present (some Linux distributions, by default, do not enable sensitivity labels, but most do). This part of the label is needed for the <strong class="bold">multilevel security (MLS)</strong> support within SELinux, which <a id="_idIndexMarker055" class="pcalibre calibre6 pcalibre1"/>is an optional setting. Sensitivity labels allow the classification of resources and the restriction of access to those resources based on a security clearance. These labels consist of two parts: a confidentiality value (prefixed with <strong class="source-inline">s</strong>) and a category value (prefixed with <strong class="source-inline">c</strong>).</p>
			<p class="calibre3">In many larger organizations and companies, documents are labeled internal, confidential, or strictly confidential. SELinux can assign processes certain clearance levels for these resources. With MLS, we can <a id="_idIndexMarker056" class="pcalibre calibre6 pcalibre1"/>configure SELinux to follow the <strong class="bold">Bell-LaPadula</strong> model, a security model characterized by <em class="italic">no read up, no write down</em>: based on a process's clearance level, that process cannot read anything with a higher confidentiality level nor write to (or communicate otherwise with) any resource with a lower confidentiality level. SELinux does not use internal, confidential, and other labels. Instead, it uses numbers from zero (the lowest confidentiality) to whatever the system administrator has defined as the highest value (this is configurable and set when the SELinux policy is built).</p>
			<p class="calibre3">Categories <a id="_idIndexMarker057" class="pcalibre calibre6 pcalibre1"/>allow us to assign resources with one or more categories, and to define access controls across categories. One of the functionalities resulting from using categories is to support multitenancy (for example, systems hosting applications for multiple customers) within a Linux system. Multitenancy is provided by assigning a set of categories to the processes and resources of one tenant, whereas the processes and resources of another tenant get a different set of categories. When a process does not have the proper categories assigned, it cannot touch the resources (or other processes) that have other categories assigned.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">An unwritten convention in the SELinux world is that (at least) two categories are used to differentiate between tenants. By having services randomly pick two categories for a tenant out of a predefined set of categories, while ensuring each tenant has a unique combination, these services receive proper isolation. The use of two categories is not mandatory, but services such as sVirt and Docker successfully implement this methodology.</p>
			<p class="calibre3">In that sense, categories are like tags, allowing us to grant access only when the tags of the process and the target resource match. As multilevel security is not often used, the benefits of only <a id="_idIndexMarker058" class="pcalibre calibre6 pcalibre1"/>using categories are persisted in what is called <strong class="bold">multi-category security</strong> (<strong class="bold">MCS</strong>). This is a special MLS case, which only supports a single confidentiality level (<strong class="source-inline">s0</strong>).</p>
			<p class="calibre3">Now that <a id="_idIndexMarker059" class="pcalibre calibre6 pcalibre1"/>we know how labels are used by SELinux policies, let's look at how SELinux policies are defined and distributed.</p>
			<h1 id="_idParaDest-32" class="calibre5"><a id="_idTextAnchor032" class="pcalibre calibre6 pcalibre1"/>Defining and distributing policies</h1>
			<p class="calibre3">Enabling SELinux <a id="_idIndexMarker060" class="pcalibre calibre6 pcalibre1"/>does not automatically start the enforcement <a id="_idIndexMarker061" class="pcalibre calibre6 pcalibre1"/>of access. If SELinux is enabled and it cannot find a policy, it will refuse to start because the policy defines the behavior of the system (what SELinux should allow). SELinux policies are generally distributed in a compiled form (just like with software) as policy modules. These modules are then aggregated into a single policy store and loaded in memory to allow SELinux to enforce the policy rules on the system.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Gentoo, a source-based meta-distribution, distributes SELinux policies as (source) code, compiled and built at install time, just like it does with other software.</p>
			<p class="calibre3">The following diagram shows the relationship between <strong class="bold">policy rules</strong> (<strong class="bold">policy code</strong>), <strong class="bold">policy modules</strong>, and a <strong class="bold">policy package</strong> (which is often a one-to-one mapping toward a <strong class="bold">policy store</strong>):</p>
			<div class="calibre13">
				<div id="_idContainer008" class="img---figure">
					<img src="Images/B16276_01_003.jpg" alt="Figure 1.3 – Relationship between policy rules (code), policy modules, and policy store " class="calibre16"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Relationship between policy rules (code), policy modules, and policy store</p>
			<p class="calibre3">As we <a id="_idIndexMarker062" class="pcalibre calibre6 pcalibre1"/>can see, policies are first written, then compiled in modules, after <a id="_idIndexMarker063" class="pcalibre calibre6 pcalibre1"/>which they are bundled and distributed. The next few sections describe each of these phases in detail.</p>
			<h2 id="_idParaDest-33" class="calibre10"><a id="_idTextAnchor033" class="pcalibre calibre6 pcalibre1"/>Writing SELinux policies</h2>
			<p class="calibre3">An SELinux <a id="_idIndexMarker064" class="pcalibre calibre6 pcalibre1"/>policy writer can write down the policy rules in three possible languages:</p>
			<ul class="calibre8">
				<li class="calibre9">In standard SELinux source format – a human-readable and well-established language for writing SELinux policies</li>
				<li class="calibre9">In reference policy style, which extends the standard SELinux source format with M4 macros to facilitate the development of policies</li>
				<li class="calibre9">In the <a id="_idIndexMarker065" class="pcalibre calibre6 pcalibre1"/>SELinux <strong class="bold">common intermediate language</strong> (<strong class="bold">CIL</strong>) – a computer-readable (and with some effort, human-readable) format for SELinux policies</li>
			</ul>
			<p class="calibre3">Most SELinux <a id="_idIndexMarker066" class="pcalibre calibre6 pcalibre1"/>supporting distributions base their policy on the reference policy (<a href="https://github.com/SELinuxProject/refpolicy/" class="pcalibre calibre6 pcalibre1">https://github.com/SELinuxProject/refpolicy/</a>), a fully functional SELinux policy set managed as a free software project. This allows distributions to ship with a functional policy set rather than having to write one themselves. Many project contributors are distribution developers, trying to push changes of their distribution to the reference policy project itself, where the <a id="_idIndexMarker067" class="pcalibre calibre6 pcalibre1"/>changes are peer-reviewed to ensure no rules are brought into the project that might jeopardize the security of any platform. Writing policies without the extensive set of M4 macros offered by the reference policy project is hard, which is why the reference policy has become the de facto source for policies.</p>
			<p class="calibre3">The SELinux CIL format is reasonably recent, and although it is very much in use already (the SELinux user space converts everything to CIL in the background), it is not that common yet for policy writers to use it directly.</p>
			<p class="calibre3">To show the differences between these three languages, consider the web server rule we discussed earlier, repeated here for your convenience: allow the processes labeled with <strong class="source-inline">httpd_t</strong> to bind to TCP ports labeled with <strong class="source-inline">http_port_t</strong>.</p>
			<p class="calibre3">In the standard SELinux source format, we write this down as follows:</p>
			<p class="source-code">allow httpd_t http_port_t : tcp_socket { name_bind };</p>
			<p class="calibre3">Using reference policy style, this rule is part of the following macro call:</p>
			<p class="source-code">corenet_tcp_bind_http_port(httpd_t)</p>
			<p class="calibre3">In the CIL language, the rule expression is like so:</p>
			<p class="source-code">(allow httpd_t http_port_t (tcp_socket (name_bind)))</p>
			<p class="calibre3">In most representations, we can see what the rule is about:</p>
			<ul class="calibre8">
				<li class="calibre9">The subject (who is taking the action); in this case, this is the set of processes labeled with the <strong class="source-inline">httpd_t</strong> type.</li>
				<li class="calibre9">The target resource or object (the target for the action); in this case, it is the set of TCP sockets (<strong class="source-inline">tcp_socket</strong>) labeled with the <strong class="source-inline">http_port_t</strong> type. In reference policy style, this is implied by the function name.</li>
				<li class="calibre9">The action or permission; in this case, it is the action of binding to a port (<strong class="source-inline">name_bind</strong>). In reference policy style, this is implied by the function name.</li>
				<li class="calibre9">The result that the policy will enforce; in this case, it is that the action is allowed (<strong class="source-inline">allow</strong>). In reference policy style, this is implied by the function name.</li>
			</ul>
			<p class="calibre3">A policy is generally written for an application or set of applications. So, the preceding example will be part of the policy written for web servers.</p>
			<p class="calibre3">Policy writers <a id="_idIndexMarker068" class="pcalibre calibre6 pcalibre1"/>will generally create three files per application or application set:</p>
			<ul class="calibre8">
				<li class="calibre9">A <strong class="source-inline">.te</strong> file, which contains the type enforcement rules.</li>
				<li class="calibre9">A <strong class="source-inline">.if</strong> file, which contains interface and template definitions, allowing policy writers to easily use the newly-generated policy rules to enhance other policies. You can compare this to header files in other programming languages.</li>
				<li class="calibre9">A <strong class="source-inline">.fc</strong> file, which contains file context expressions. These are rules that assign labels to resources on the filesystem.</li>
			</ul>
			<p class="calibre3">A finished policy is then packaged into an SELinux policy module.</p>
			<h2 id="_idParaDest-34" class="calibre10"><a id="_idTextAnchor034" class="pcalibre calibre6 pcalibre1"/>Distributing policies through modules</h2>
			<p class="calibre3">Initially, SELinux used a single, monolithic policy approach: all possible access control rules were <a id="_idIndexMarker069" class="pcalibre calibre6 pcalibre1"/>maintained in a single policy file. It quickly became clear that this is not manageable in the long term, and the idea of developing a modular policy approach was born.</p>
			<p class="calibre3">Within the modular approach, policy developers can write isolated policy sets for a particular application (or set of applications), roles, and so on. These policies then get built and distributed as policy modules. Platforms that need access controls for a particular application load the SELinux policy module that defines the access rules for that application.</p>
			<p class="calibre3">The following diagram shows the building of policy modules. It also shows where CIL comes into play, even when the policy rules themselves are not written in CIL:</p>
			<div class="calibre13">
				<div id="_idContainer009" class="img---figure">
					<img src="Images/B16276_01_004.jpg" alt="Figure 1.4 – Build process from policy rule to policy store " class="calibre17"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Build process from policy rule to policy store</p>
			<p class="calibre3">The binary <strong class="source-inline">*.pp</strong> files (which are the SELinux policy modules) are considered to  be written in a <strong class="bold">high-level language</strong> (<strong class="bold">HLL</strong>). Do not assume that this means they are human-readable: these files <a id="_idIndexMarker070" class="pcalibre calibre6 pcalibre1"/>are binary files. The consideration here is that SELinux wants to support writing SELinux policies in a number of formats, which it calls high-level <a id="_idIndexMarker071" class="pcalibre calibre6 pcalibre1"/>languages, as long as it has a parser that can convert the files into CIL. Marking the binary module formats (which in previous SELinux versions were the binary blobs loaded in memory) as high-level allows the SELinux project to introduce the distinction between high-level languages and CIL in a backward-compatible manner.</p>
			<p class="calibre3">When distributing SELinux policy modules, most Linux distributions place the <strong class="source-inline">*.pp</strong> SELinux policy modules inside <strong class="source-inline">/usr/share/selinux</strong>, usually within a subdirectory named after the policy store (such as <strong class="source-inline">targeted</strong>). There, these modules are ready for administrators to activate them.</p>
			<p class="calibre3">When activating a module, the <strong class="source-inline">semodule</strong> command will copy those modules into a dedicated directory (<strong class="source-inline">/var/lib/selinux/mcs/active/modules</strong>). When all modules are aggregated in a single location, the final policy binary is compiled, resulting in <strong class="source-inline">/etc/selinux/targeted/policy/policy.32</strong> (or some other number) and loaded in memory.</p>
			<p class="calibre3">On CentOS, the SELinux policies are provided by the <strong class="source-inline">selinux-policy-targeted</strong> (or <strong class="source-inline">-minimum</strong> or <strong class="source-inline">-mls</strong>) package. On Gentoo, they are provided by the various <strong class="source-inline">sec-policy/selinux-*</strong> packages (Gentoo uses separate packages for each module, reducing the number of SELinux policies loaded on an average system).</p>
			<h2 id="_idParaDest-35" class="calibre10"><a id="_idTextAnchor035" class="pcalibre calibre6 pcalibre1"/>Bundling modules in a policy store</h2>
			<p class="calibre3">A <strong class="bold">policy store</strong> contains <a id="_idIndexMarker072" class="pcalibre calibre6 pcalibre1"/>a single comprehensive policy, and only a single policy can be active <a id="_idIndexMarker073" class="pcalibre calibre6 pcalibre1"/>on a system at any point in time. Administrators can switch policy stores, although this often requires rebooting the system and might even require relabeling the entire system (relabeling is the act of resetting the contexts on all files and resources available on that system).</p>
			<p class="calibre3">The active policy on the system can be queried using <strong class="source-inline">sestatus</strong> (an SELinux status) as follows:</p>
			<p class="source-code"># sestatus | grep "Loaded policy name"</p>
			<p class="source-code">Loaded policy name:     mcs</p>
			<p class="calibre3">In this example, <strong class="source-inline">mcs</strong> is the currently loaded policy (store). The policy name that SELinux will use upon its next reboot is defined in the <strong class="source-inline">/etc/selinux/config</strong> configuration file as the <strong class="source-inline">SELINUXTYPE</strong> parameter.</p>
			<p class="calibre3">The system's <strong class="source-inline">init</strong> system (be it a <strong class="source-inline">SysV</strong>-compatible <strong class="source-inline">init</strong> system or <strong class="source-inline">systemd</strong>) is generally responsible for loading the SELinux policy, effectively activating SELinux support on the system. The <strong class="source-inline">init</strong> system reads the configuration, locates the policy store, and loads the policy file in memory. If the <strong class="source-inline">init</strong> system does not support this (in other words, it is not SELinux-aware) then the policy should be loaded through the <strong class="source-inline">load_policy</strong> command.</p>
			<p class="calibre3">As we now have a better view of the flow used in policy development and distribution, let's see how Linux distributions can differentiate their SELinux offering.</p>
			<h1 id="_idParaDest-36" class="calibre5"><a id="_idTextAnchor036" class="pcalibre calibre6 pcalibre1"/>Distinguishing between policies</h1>
			<p class="calibre3">The most <a id="_idIndexMarker074" class="pcalibre calibre6 pcalibre1"/>common SELinux policy store names are <strong class="source-inline">strict</strong>, <strong class="source-inline">targeted</strong>, <strong class="source-inline">mcs</strong>, and <strong class="source-inline">mls</strong>. None of the names assigned to policy stores are fixed though, so it is a matter of convention. Hence, we recommend consulting the distribution documentation to verify what the proper name of the policy should be. Still, the name often provides some information about the SELinux options enabled through the policy.</p>
			<h2 id="_idParaDest-37" class="calibre10"><a id="_idTextAnchor037" class="pcalibre calibre6 pcalibre1"/>Supporting MLS</h2>
			<p class="calibre3">One of the <a id="_idIndexMarker075" class="pcalibre calibre6 pcalibre1"/>options that can be enabled is MLS support. The SELinux context will not have a fourth field with sensitivity information in it if this option is disabled, making the contexts of processes and files look as follows:</p>
			<p class="source-code">staff_u:sysadm_r:sysadm_t</p>
			<p class="calibre3">To check whether MLS is enabled, it is sufficient to see whether a process context doesn't contain such a fourth field. Another way is to check the <strong class="source-inline">Policy MLS Status</strong> line in the output of <strong class="source-inline">sestatus</strong>:</p>
			<p class="source-code"># sestatus | grep MLS</p>
			<p class="source-code">Policy MLS status:       enabled</p>
			<p class="calibre3">Yet another method would be to look into the pseudo file, <strong class="source-inline">/sys/fs/selinux/mls</strong>. A value of <strong class="source-inline">0</strong> means disabled, whereas a value of <strong class="source-inline">1</strong> means enabled:</p>
			<p class="source-code"># cat /sys/fs/selinux/mls</p>
			<p class="source-code">1</p>
			<p class="calibre3">Policy stores that have MLS enabled are generally <strong class="source-inline">targeted</strong>, <strong class="source-inline">mcs</strong>, and <strong class="source-inline">mls</strong>, whereas <strong class="source-inline">strict</strong> generally has MLS disabled.</p>
			<h2 id="_idParaDest-38" class="calibre10"><a id="_idTextAnchor038" class="pcalibre calibre6 pcalibre1"/>Dealing with unknown permissions</h2>
			<p class="calibre3">Permissions (such as read, open, and lock) are defined both in the Linux kernel and in the policy itself. However, sometimes, newer Linux kernels support permissions that the current policy <a id="_idIndexMarker076" class="pcalibre calibre6 pcalibre1"/>does not yet understand.</p>
			<p class="calibre3">Take the <strong class="source-inline">block_suspend</strong> permission (to be able to block system suspension) as an example. If the Linux kernel supports (and checks) this permission but the loaded SELinux policy does not understand that permission yet, then SELinux has to decide how it should deal with the permission. We can configure SELinux to perform one of the following actions:</p>
			<ul class="calibre8">
				<li class="calibre9">Allow every action related to an unknown permission (<strong class="source-inline">allow</strong>).</li>
				<li class="calibre9">Deny every action related to an unknown permission (<strong class="source-inline">deny</strong>).</li>
				<li class="calibre9">Stop and halt the system when an unknown permission is checked (<strong class="source-inline">reject</strong>).</li>
			</ul>
			<p class="calibre3">We configure this through the <strong class="source-inline">deny_unknown</strong> value. To see the state for unknown permissions, look for the <strong class="source-inline">Policy deny_unknown status</strong> line in <strong class="source-inline">sestatus</strong>:</p>
			<p class="source-code"># sestatus | grep deny_unknown</p>
			<p class="source-code">Policy deny_unknown status:      allowed</p>
			<p class="calibre3">Administrators <a id="_idIndexMarker077" class="pcalibre calibre6 pcalibre1"/>can set this for themselves in the <strong class="source-inline">/etc/selinux/semanage.conf</strong> file through the <strong class="source-inline">handle-unknown</strong> variable (with <strong class="source-inline">allow</strong>, <strong class="source-inline">deny</strong>, or <strong class="source-inline">reject</strong>).</p>
			<h2 id="_idParaDest-39" class="calibre10"><a id="_idTextAnchor039" class="pcalibre calibre6 pcalibre1"/>Supporting unconfined domains</h2>
			<p class="calibre3">An SELinux <a id="_idIndexMarker078" class="pcalibre calibre6 pcalibre1"/>policy can be very strict, limiting applications as close as possible to their actual behavior, but it can also be very liberal in what applications are allowed to do. One of the concepts available in many SELinux policies is the idea of unconfined domains. When enabled, it means that certain SELinux domains (process contexts) are allowed to do almost anything they want (of course, within the boundaries of the regular Linux DAC permissions, which still hold) and only a select number of domains are truly confined (restricted) in their actions.</p>
			<p class="calibre3">Unconfined domains are introduced to allow SELinux to be active on desktops and servers where administrators do not want to fully restrict the entire system, but only a few of the applications running on it. Generally, these implementations focus on constraining network-facing services (such as web servers and database management systems) while allowing end users and administrators to roam around unrestricted.</p>
			<p class="calibre3">With other MAC systems, such as AppArmor, <em class="italic">unconfinement</em> is inherently part of the design of the system as they only restrict actions for well-defined applications or users. However, SELinux is designed to be a full mandatory access control system and thus needs to provide access control rules even for those applications that aren't the security administrator's primary focus. By marking these applications as unconfined, almost no restrictions are imposed by SELinux.</p>
			<p class="calibre3">We can see whether unconfined domains are enabled on the system using <strong class="source-inline">seinfo</strong>, by querying the policy and asking it whether the <strong class="source-inline">unconfined_t</strong> SELinux type is defined. On a system where unconfined domains are supported, this type will be available:</p>
			<p class="source-code"># seinfo -t unconfined_t</p>
			<p class="source-code">Types: 1</p>
			<p class="source-code">  unconfined_t</p>
			<p class="calibre3">For a system where unconfined domains are not supported, the type will not be part of the policy:</p>
			<p class="source-code"># seinfo -t unconfined_t</p>
			<p class="source-code">Types: 0</p>
			<p class="calibre3">Most distributions that enable unconfined domains call their policy <strong class="source-inline">targeted</strong>, but this convention <a id="_idIndexMarker079" class="pcalibre calibre6 pcalibre1"/>is not always followed. Hence, it is always best to consult the policy using <strong class="source-inline">seinfo</strong>. CentOS enables unconfined domains, whereas with Gentoo, this is a configurable setting through the <strong class="source-inline">unconfined USE</strong> flag.</p>
			<h2 id="_idParaDest-40" class="calibre10"><a id="_idTextAnchor040" class="pcalibre calibre6 pcalibre1"/>Limiting cross-user sharing</h2>
			<p class="calibre3">When <a id="_idIndexMarker080" class="pcalibre calibre6 pcalibre1"/>UBAC is enabled, certain SELinux types will be protected by additional constraints. This will ensure that one SELinux user cannot access the files (or other specific resources) of another user, even when those users are sharing their data through the regular Linux permissions. UBAC provides some additional control over information flow between resources, but it is far from perfect. Essentially, it is made to isolate SELinux users from one another.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">A constraint in SELinux is an access control rule that uses all parts of a context to make its decision. Unlike type enforcement rules, which are purely based on the type, constraints can take the SELinux user, SELinux role, or sensitivity label into account. Constraints are generally developed once and left untouched – most policy writers will not touch constraints during their development efforts.</p>
			<p class="calibre3">Many Linux distributions, including CentOS, disable UBAC. Gentoo allows users to decide whether they want UBAC through the Gentoo <strong class="source-inline">ubac USE</strong> flag (which is enabled by default).</p>
			<h2 id="_idParaDest-41" class="calibre10"><a id="_idTextAnchor041" class="pcalibre calibre6 pcalibre1"/>Incrementing policy versions</h2>
			<p class="calibre3">While <a id="_idIndexMarker081" class="pcalibre calibre6 pcalibre1"/>checking the output of <strong class="source-inline">sestatus</strong>, we see that there is also a reference to a policy version:</p>
			<p class="source-code"># sestatus | grep version</p>
			<p class="source-code">Max kernel policy version:       32</p>
			<p class="calibre3">This version has nothing to do with the versioning of policy rules but with the SELinux features that the currently running kernel supports. In the preceding output, 32 is the highest policy version that the running kernel supports. Every time a new feature is added to SELinux, the version number is increased. We can find the policy file itself (which contains all the SELinux rules loaded at boot time by the system) in <strong class="source-inline">/etc/selinux/targeted/policy</strong> (where targeted refers to the policy store used, so if the system uses a policy store named <strong class="source-inline">mcs</strong>, then the path will be <strong class="source-inline">/etc/selinux/mcs/policy</strong>).</p>
			<p class="calibre3">If multiple policy files exist, use <strong class="source-inline">seinfo</strong> to discover which policy version file is used:</p>
			<p class="source-code"># seinfo | grep Version</p>
			<p class="source-code">Policy version:                  31 (MLS enabled)</p>
			<p class="calibre3">A list of policy feature enhancements and the Linux kernel version in which that given feature is <a id="_idIndexMarker082" class="pcalibre calibre6 pcalibre1"/>introduced is provided next. Many of the features are only of concern to policy developers, but knowing the evolution of the features gives us a good idea about the evolution of SELinux:</p>
			<ul class="calibre8">
				<li class="calibre9">Version 12 represents the "old API" for SELinux, which is now deprecated.</li>
				<li class="calibre9">Version 15, introduced in Linux 2.6.0, provided the new API for SELinux.</li>
				<li class="calibre9">Version 16, introduced in Linux 2.6.5, added support for conditional policy extensions.</li>
				<li class="calibre9">Version 17, introduced in Linux 2.6.6, added support for IPv6.</li>
				<li class="calibre9">Version 18, introduced in Linux 2.6.8, added support for fine-grained netlink socket permissions.</li>
				<li class="calibre9">Version 19, introduced in Linux 2.6.12, added support for MLS.</li>
				<li class="calibre9">Version 20, introduced in Linux 2.6.14, reduced the size of the access vector table.</li>
				<li class="calibre9">Version 21, introduced in Linux 2.6.19, added support for MLS range transitions.</li>
				<li class="calibre9">Version 22, introduced in Linux 2.6.25, added policy capabilities.</li>
				<li class="calibre9">Version 23, introduced in Linux 2.6.26, added support for per-domain permissive mode.</li>
				<li class="calibre9">Version 24, introduced in Linux 2.6.28, added support for explicit hierarchy (type bounds).</li>
				<li class="calibre9">Version 25, introduced in Linux 2.6.39, added support for filename-based transitions.</li>
				<li class="calibre9">Version 26, introduced in Linux 3.0, added support for role-transitions for non-process <a id="_idIndexMarker083" class="pcalibre calibre6 pcalibre1"/>classes, as well as support for role attributes.</li>
				<li class="calibre9">Version 27, introduced in Linux 3.5, added support for the flexible inheritance of the SELinux user and SELinux role for newly-created objects.</li>
				<li class="calibre9">Version 28, introduced in Linux 3.5, added support for the flexible inheritance of the SELinux type for newly-created objects.</li>
				<li class="calibre9">Version 29, introduced in Linux 3.14, added support for attributes within SELinux constraints.</li>
				<li class="calibre9">Version 30, introduced in Linux 4.3, added support for extended permissions, implemented first on ioctl controls. It also introduced enhanced SELinux Xen support.</li>
				<li class="calibre9">Version 31, introduced in Linux 4.13, added support for InfiniBand access controls.</li>
				<li class="calibre9">Version <a id="_idIndexMarker084" class="pcalibre calibre6 pcalibre1"/>32, introduced in Linux 5.5, added support for automatically deducing the intersection in sensitivity labels, called <strong class="bold">greatest lower bound, largest upper bound</strong> (<strong class="bold">glblub</strong>).</li>
			</ul>
			<p class="calibre3">By default, when an SELinux policy is built, the highest supported version as defined by the Linux kernel and <strong class="source-inline">libsepol</strong> (the library responsible for building the SELinux policy binary) is used. Administrators can force a version to be lower using the <strong class="source-inline">policy-version</strong> parameter in <strong class="source-inline">/etc/selinux/semanage.conf</strong>.</p>
			<h2 id="_idParaDest-42" class="calibre10"><a id="_idTextAnchor042" class="pcalibre calibre6 pcalibre1"/>Different policy content</h2>
			<p class="calibre3">Besides the <a id="_idIndexMarker085" class="pcalibre calibre6 pcalibre1"/>policy capabilities described in the previous section, the main difference between policies (and distributions) is the policy content itself. We already covered that most distributions base their policy on the reference policy project. Although the reference policy project is considered the <em class="italic">master</em> for most distributions, each distribution has its own set of deviations from this main policy set.</p>
			<p class="calibre3">Many distributions make extensive additions to the policy without directly passing the policies to the upstream reference policy project. There are several possible reasons why this is not directly done:</p>
			<ul class="calibre8">
				<li class="calibre9">The policy enhancements or additions are still immature: Fedora, CentOS, and Red Hat initially start with active, permissive policies, meaning the policies are not enforced. Instead, SELinux logs what it would have prevented and, based on those logs, the policies are then enhanced. This means that a policy is only ready after a few releases.</li>
				<li class="calibre9">The policy enhancements or additions are too specific to the distribution: If a policy set is not reusable for other distributions, then some distributions will opt to keep those policies to themselves as the act of pushing changes to <em class="italic">upstream</em> projects takes quite some effort.</li>
				<li class="calibre9">The policy enhancements or additions haven't followed the upstream rules and guidelines: The reference policy has a set of guidelines that policies need to adhere to. If a policy set does not comply with these rules, then the reference policy will not accept the contribution.</li>
				<li class="calibre9">The policy enhancements or additions are not implementing the same security model as the reference policy project wants: As SELinux is a very extensive mandatory access control system, it is possible to write completely different policies.</li>
				<li class="calibre9">The distribution does not have the time or resources to push changes upstream.</li>
			</ul>
			<p class="calibre3">This means that SELinux policies can differ between distributions (and even releases of the same distribution).</p>
			<p class="calibre3">With this, we can conclude on some of the differentiation that distributions can put into their SELinux policies: they can opt to enable or disable MLS support, allow or deny unknown permissions, add <a id="_idIndexMarker086" class="pcalibre calibre6 pcalibre1"/>distribution-provided unconfined domains, support user-based access controls, and/or deviate from the reference policy project to suit the distribution's principles.</p>
			<h1 id="_idParaDest-43" class="calibre5"><a id="_idTextAnchor043" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, we saw that SELinux offers a more fine-grained access control mechanism on top of the Linux access controls. SELinux is implemented through Linux Security Modules and uses labels to identify its resources and processes based on ownership (user), role, type, and even the security sensitivity and categorization of the resource. We covered how SELinux policies are handled within an SELinux-enabled system and briefly touched upon how policy writers structure policies.</p>
			<p class="calibre3">Linux distributions implement SELinux policies, which can differ between distributions based on supported features, such as sensitivity labels, the default behavior for unknown permissions, support for confinement levels, or specific constraints put in place, such as UBAC. However, most of the policy rules themselves are similar and are even based on the same upstream reference policy project.</p>
			<p class="calibre3">Switching between SELinux enforcement modes and understanding the log events that SELinux creates when it prohibits certain access is the subject of our next chapter. In it, we will also cover how to approach the often-heard requirement of disabling SELinux, and why doing so is the wrong way forward.</p>
			<h1 id="_idParaDest-44" class="calibre5"><a id="_idTextAnchor044" class="pcalibre calibre6 pcalibre1"/>Questions</h1>
			<ol class="calibre18">
				<li class="calibre9">What is the most important difference between a DAC and a MAC system?</li>
				<li class="calibre9">How does Linux support the different MAC technologies?</li>
				<li class="calibre9">What four fields constitute an SELinux context?</li>
				<li class="calibre9">How does SELinux support role-based access controls?</li>
				<li class="calibre9">Why isn't there a single SELinux policy for all Linux distributions?</li>
			</ol>
		</div>
	</div></body></html>