- en: '19'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '19'
- en: Debugging with GDB
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GDB调试
- en: Bugs happen. Identifying and fixing them is part of the development process.
    There are many different techniques for finding and characterizing program defects,
    including static and dynamic analysis, code review, tracing, profiling, and interactive
    debugging. We will look at tracers and profilers in the next chapter, but here
    I want to concentrate on the traditional approach of watching code execution through
    a debugger, which in our case is the **GNU Debugger** (**GDB**). GDB is a powerful
    and flexible tool. You can use it to debug applications, examine the postmortem
    files (core files) that are created after a program crash, and even step through
    kernel code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是不可避免的，识别并修复它们是开发过程的一部分。找到并表征程序缺陷有许多不同的技术，包括静态和动态分析、代码审查、跟踪、性能分析和交互式调试。我们将在下一章讨论跟踪器和性能分析器，但这里我想专注于通过调试器查看代码执行的传统方法，在我们的案例中是**GNU调试器**（**GDB**）。GDB是一个强大且灵活的工具。你可以用它来调试应用程序、检查程序崩溃后生成的后期文件（核心文件），甚至逐步调试内核代码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下内容：
- en: GNU debugger
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU调试器
- en: Preparing to debug
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备调试
- en: Debugging applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试应用程序
- en: Just-in-time debugging
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即时调试
- en: Debugging forks and threads
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试分支和线程
- en: Core files
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心文件
- en: GDB user interfaces
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB用户界面
- en: Debugging kernel code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试内核代码
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟上示例的进度，请确保你已经准备好了以下内容：
- en: An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行Ubuntu 24.04或更高版本LTS的主机系统，且至少有90 GB的空闲磁盘空间
- en: Buildroot 2024.02.6 LTS release
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buildroot 2024.02.6 LTS版本
- en: Yocto 5.0 (Scarthgap) LTS release
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yocto 5.0（Scarthgap）LTS版本
- en: A microSD card reader and card
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个microSD卡读卡器和卡
- en: balenaEtcher for Linux
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于Linux的balenaEtcher
- en: An Ethernet cable and router with an available port for network connectivity
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根以太网电缆和一台具有可用端口的路由器，用于网络连接
- en: A USB to TTL serial cable with a 3.3 V level
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条带有3.3 V电平的USB转TTL串口电缆
- en: A Raspberry Pi 4
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台Raspberry Pi 4
- en: A 5 V USB-C power supply capable of delivering 3 A
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款能够提供3 A电流的5 V USB-C电源
- en: You should have already installed the 2024.02.6 LTS release of Buildroot for
    [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110). If you have not, then refer
    to the *System requirements section* of *The Buildroot user manual* ([https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html))
    before installing Buildroot on your Linux host according to the instructions from
    [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经安装了Buildroot的2024.02.6 LTS版本，参考[*第六章*](Chapter_04.xhtml#_idTextAnchor110)。如果没有，请在按照[*第六章*](Chapter_04.xhtml#_idTextAnchor110)的说明在你的Linux主机上安装Buildroot之前，参考*系统要求部分*的*Buildroot用户手册*（[https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html)）。
- en: You should have already built the 5.0 (Scarthgap) LTS release of Yocto in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110). If you have not, then please refer to
    the *Compatible Linux Distribution* and *Build Host Packages* sections of the
    *Yocto Project Quick Build* guide ([https://docs.yoctoproject.org/brief-yoctoprojectqs/](https://docs.yoctoproject.org/brief-yoctoprojectqs/))
    before building Yocto on your Linux host according to the instructions in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经在[*第六章*](Chapter_04.xhtml#_idTextAnchor110)中构建了Yocto的5.0（Scarthgap）LTS版本。如果还没有，请参考*兼容的Linux发行版*和*构建主机包*部分的*Yocto项目快速构建*指南（[https://docs.yoctoproject.org/brief-yoctoprojectqs/](https://docs.yoctoproject.org/brief-yoctoprojectqs/)），然后按照[*第六章*](Chapter_04.xhtml#_idTextAnchor110)中的说明在你的Linux主机上构建Yocto。
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter19](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter19).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的代码可以在本书GitHub仓库的章节文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter19](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter19)。
- en: GNU debugger
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GNU调试器
- en: GDB is a source-level debugger for compiled languages, primarily C and C++,
    although there is also support for a variety of other languages, such as Go and
    Objective-C. You should read the notes for the version of GDB you are using to
    find out the status of support for the various languages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: GDB是一个源级调试器，主要用于编译语言，如C和C++，但也支持多种其他语言，如Go和Objective-C。你应该阅读你所使用的GDB版本的说明，以了解对不同语言的支持情况。
- en: The project website is [https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)
    and it contains a lot of useful information, including the GDB user manual, *Debugging
    with GDB*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 项目网站是[https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)，上面包含了很多有用的信息，包括GDB用户手册《*调试与GDB*》。
- en: Out of the box, GDB has a command-line user interface that some people find
    off-putting, although, in reality, it is easy to use with a little practice. If
    command-line interfaces are not to your liking, there are plenty of frontend user
    interfaces to GDB, and I will describe three of them later in this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，GDB有一个命令行用户界面，虽然有些人觉得它不太友好，但实际上只需一些练习就能轻松使用。如果你不喜欢命令行界面，有很多GDB的前端用户界面可以选择，我将在本章稍后描述其中的三个。
- en: Preparing to debug
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备调试
- en: 'You need to compile the code you want to debug with debug symbols. GCC offers
    two options for this: `-g` and `-ggdb`. The latter adds debug information that
    is specific to GDB, whereas the former generates information in an appropriate
    format for whichever target operating system you are using, making it the more
    portable option. Since GDB is the default debugger on Linux, it is best to use
    `-ggdb`. Both options allow you to specify the level of debug information, from
    `0` to `3`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要用调试符号编译你想调试的代码。GCC为此提供了两个选项：`-g`和`-ggdb`。后者添加了专门针对GDB的调试信息，而前者生成适用于你所使用的目标操作系统的格式信息，使其更具可移植性。由于GDB是Linux上的默认调试器，因此最好使用`-ggdb`。这两个选项都允许你指定调试信息的级别，从`0`到`3`：
- en: '`0`: This produces no debug information at all and is equivalent to omitting
    the `-g` or `-ggdb` switch.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：这不生成任何调试信息，等同于省略`-g`或`-ggdb`选项。'
- en: '`1`: This produces minimal information but includes function names and external
    variables, which is enough to generate a backtrace.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：这生成最少的信息，但包括函数名称和外部变量，足以生成回溯。'
- en: '`2`: This is the default and includes information about local variables and
    line numbers so that you can perform source-level debugging and single-step through
    the code.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：这是默认设置，包含关于本地变量和行号的信息，以便你可以进行源代码级别的调试并逐步执行代码。'
- en: '`3`: This includes extra information which, among other things, means that
    GDB can handle macro expansions correctly.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：这包括额外的信息，其中包括使GDB能够正确处理宏展开。'
- en: 'In most cases, `-g` suffices: reserve `-g3` or `-ggdb3` for if you are having
    problems stepping through code, especially if it contains macros.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`-g`就足够了：如果你在逐步执行代码时遇到问题，尤其是当代码包含宏时，可以保留`-g3`或`-ggdb3`。
- en: The next issue to consider is the level of code optimization. Compiler optimization
    tends to destroy the relationship between lines of source code and machine code,
    which makes stepping through the source unpredictable. If you experience problems
    such as this, you will most likely need to compile without optimization, leaving
    out the `-O` compile switch, or using `-Og`, which enables optimizations that
    do not interfere with debugging.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步需要考虑的是代码优化的级别。编译器优化往往会破坏源代码行与机器代码之间的关系，这使得逐步调试变得不可预测。如果你遇到此类问题，很可能需要在不进行优化的情况下编译，省略`-O`编译选项，或者使用`-Og`，该选项启用不会干扰调试的优化。
- en: 'A related issue is that of stack-frame pointers, which are required by GDB
    to generate a backtrace of function calls up to the current one. On some architectures,
    GCC will not generate stack-frame pointers with higher levels of optimization
    (`-O2` and above). If you find yourself in a situation where you really have to
    compile with `-O2` but still want backtraces, you can override the default behavior
    with `-fno-omit-frame-pointer`. Also, look out for code that has been hand-optimized
    to leave out frame pointers through the addition of `-fomit-frame-pointer`: you
    may want to temporarily remove those bits.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的问题是栈帧指针，这是GDB生成函数调用回溯所必需的。在某些架构中，GCC在更高级别的优化（`-O2`及以上）下不会生成栈帧指针。如果你遇到必须使用`-O2`编译但仍希望生成回溯的情况，你可以通过`-fno-omit-frame-pointer`来覆盖默认行为。此外，注意一些经过手动优化的代码，它通过添加`-fomit-frame-pointer`来省略栈帧指针：你可能需要暂时去除这些部分。
- en: Debugging applications
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试应用程序
- en: 'You can use GDB to debug applications in one of two ways: if you are developing
    code to run on desktops and servers, or indeed any environment where you compile
    and run the code on the same machine, it is natural to run GDB natively. However,
    most embedded development is done using a cross toolchain, and hence you want
    to debug code running on the device but control it from the cross-development
    environment, where you have the source code and the tools. I will focus on the
    latter case, since it is the most likely scenario for embedded developers, but
    I will also show you how to set up a system for native debugging. I am not going
    to describe the basics of using GDB here since there are many good references
    on that topic already, including the GDB user manual and the suggested *Further
    study* section at the end of the chapter.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式使用 GDB 调试应用程序：如果你正在开发运行在桌面和服务器上的代码，或者在任何你编译并运行代码的相同机器环境下，运行 GDB 本地化是很自然的。然而，大多数嵌入式开发是使用交叉工具链完成的，因此你希望调试在设备上运行的代码，但从交叉开发环境中控制它，在那里你有源代码和工具。我将重点讲解后者的情况，因为它是嵌入式开发者最常见的场景，但我也会展示如何设置一个本地调试的系统。我在这里不会描述
    GDB 的基本使用方法，因为已经有很多很好的参考资料了，包括 GDB 用户手册和本章末尾建议的*进一步学习*部分。
- en: Remote debugging using gdbserver
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 gdbserver 进行远程调试
- en: The key component for remote debugging is the debug agent, **gdbserver**, which
    runs on the target and controls the execution of the program being debugged. `gdbserver`
    connects to a copy of GDB running on the host machine via a network connection
    or a serial interface.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 远程调试的关键组件是调试代理 **gdbserver**，它运行在目标设备上并控制被调试程序的执行。`gdbserver` 通过网络连接或串口接口连接到主机上运行的
    GDB 副本。
- en: 'Debugging through `gdbserver` is almost, but not quite, the same as debugging
    natively. The differences are mostly centered around the fact that there are two
    computers involved, and they have to be in the right state for debugging to take
    place. Here are some things to look out for:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `gdbserver` 进行调试几乎与本地调试相同，但并不完全一样。主要的区别集中在涉及两台计算机的事实上，它们必须处于正确的状态才能开始调试。以下是一些需要注意的事项：
- en: At the start of a debug session, you need to load the program you want to debug
    on the target using `gdbserver` and then separately load GDB from your cross toolchain
    on the host.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调试会话开始时，你需要通过 `gdbserver` 将你要调试的程序加载到目标设备上，然后从主机上的交叉工具链中单独加载 GDB。
- en: GDB and `gdbserver` need to connect to each other before a debug session can
    begin.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB 和 `gdbserver` 需要在调试会话开始之前相互连接。
- en: GDB needs to be told where on the host to look for debug symbols and source
    code, especially for shared libraries.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB 需要知道在主机上哪里可以找到调试符号和源代码，特别是对于共享库。
- en: The GDB `run` command is not supported.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB `run` 命令不被支持。
- en: '`gdbserver` will terminate when the debug session ends, and you will need to
    restart it if you want another debug session.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gdbserver` 在调试会话结束时会终止，如果你想进行另一次调试会话，你需要重新启动它。'
- en: You need debug symbols and source code for the binaries you want to debug on
    the host, but not on the target. Often, there is not enough storage space for
    them on the target, and they will need to be stripped before deploying to the
    target.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要调试符号和源代码来调试主机上的二进制文件，但不需要在目标设备上。这是因为目标设备上通常没有足够的存储空间存放这些符号和代码，它们需要在部署到目标设备之前被剥离。
- en: 'The GDB/`gdbserver` combination does not support all the features of natively
    running GDB: for example, `gdbserver` cannot follow the child process after a
    fork, whereas native GDB can.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB/`gdbserver` 组合并不支持本地运行 GDB 的所有功能：例如，`gdbserver` 不能在 `fork` 后跟踪子进程，而本地 GDB
    可以。
- en: Odd things can happen if GDB and `gdbserver` are from different versions of
    GDB or are the same version but configured differently. Ideally, they should be
    built from the same source using your favorite build tool.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 GDB 和 `gdbserver` 来自不同版本的 GDB，或者它们是相同版本但配置不同，可能会发生奇怪的情况。理想情况下，它们应该使用你喜欢的构建工具从相同的源代码构建。
- en: 'Debug symbols increase the size of executables dramatically, sometimes by a
    factor of 10\. As mentioned in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138),
    it can be useful to remove debug symbols without recompiling everything. The tool
    for the job is `strip` from the `binutils` package in your cross toolchain. You
    can control the strip level with these switches:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 调试符号会显著增加可执行文件的大小，有时会增加 10 倍。如 [*第 5 章*](Chapter_05.xhtml#_idTextAnchor138)
    所述，移除调试符号而不重新编译所有内容是很有用的。用于此目的的工具是交叉工具链中 `binutils` 包中的 `strip`。你可以通过这些开关来控制剥离级别：
- en: '`--strip-all`: This removes all symbols (default).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--strip-all`：此选项会移除所有符号（默认设置）。'
- en: '`--strip-unneeded`: This removes symbols not required for relocation processing.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--strip-unneeded`：此选项会移除不需要用于重定位处理的符号。'
- en: '`--strip-debug`: This removes only debug symbols.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--strip-debug`：此选项仅移除调试符号。'
- en: '**IMPORTANT NOTE**'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**重要说明**'
- en: For applications and shared libraries, `--strip-all` (the default) is fine,
    but when it comes to kernel modules, you will find that it will stop the module
    from loading. Use `--strip-unneeded` instead. I am still working on a use case
    for `–-strip-debug`.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于应用程序和共享库，`--strip-all`（默认设置）是可以的，但当涉及到内核模块时，你会发现它会导致模块无法加载。应该使用`--strip-unneeded`。我仍在为`--strip-debug`寻找一个用例。
- en: With that in mind, let’s look at the specifics involved in debugging with The
    Yocto Project and Buildroot.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这一点，让我们来看一下使用Yocto项目和Buildroot进行调试时的具体细节。
- en: Setting up The Yocto Project for remote debugging
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Yocto项目进行远程调试
- en: 'There are two things to be done to debug applications remotely when using The
    Yocto Project: you need to add `gdbserver` to the target image, and you need to
    create an SDK that includes GDB and has debug symbols for the executables that
    you plan to debug. There is detailed documentation on setting up Yocto for remote
    debugging at [https://docs.yoctoproject.org/dev-manual/debugging.html#using-the-gdbserver-method](https://docs.yoctoproject.org/dev-manual/debugging.html#using-the-gdbserver-method).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Yocto项目进行远程调试时需要做两件事：你需要将`gdbserver`添加到目标镜像中，并且需要创建一个包含GDB并具有调试符号的SDK，针对你打算调试的可执行文件。关于如何设置Yocto进行远程调试，有详细的文档可以参考[https://docs.yoctoproject.org/dev-manual/debugging.html#using-the-gdbserver-method](https://docs.yoctoproject.org/dev-manual/debugging.html#using-the-gdbserver-method)。
- en: 'First, to include `gdbserver` in the target image, you can add the package
    explicitly by adding this to `conf/local.conf`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了将`gdbserver`包含到目标镜像中，你可以通过在`conf/local.conf`中显式添加以下内容来实现：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the absence of a serial console, an SSH daemon also needs to be added so
    that you have some way to start `gdbserver` on the target:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有串口控制台，还需要添加一个SSH守护进程，这样你就能通过某种方式在目标设备上启动`gdbserver`：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can add `tools-debug` to `EXTRA_IMAGE_FEATURES`, which will
    add `gdbserver`, native `gdb`, and `strace` to the target image (I will talk about
    `strace` in the next chapter):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将`tools-debug`添加到`EXTRA_IMAGE_FEATURES`中，这样就会将`gdbserver`、原生`gdb`和`strace`添加到目标镜像中（我将在下一章中讲解`strace`）：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then rebuild the target image:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重新构建目标镜像：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For the second part, you just need to build an SDK as I described in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二部分，你只需要按照我在[*第6章*](Chapter_04.xhtml#_idTextAnchor110)中描述的方式构建一个SDK：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The SDK contains a copy of GDB. It also contains a `sysroot` for thetarget with
    debug symbols for all the programs and libraries that are part of the target image.
    Lastly, the SDK contains the source code for the executables. Instead of the SDK,
    you can use the sysroots inside of the Yocto build directly ([https://docs.yoctoproject.org/sdk-manual/extensible.html#when-using-the-extensible-sdk-directly-in-a-yocto-build](https://docs.yoctoproject.org/sdk-manual/extensible.html#when-using-the-extensible-sdk-directly-in-a-yocto-build)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SDK包含一个GDB副本，还包含目标的`sysroot`，其中有所有程序和库的调试符号。最后，SDK还包含可执行文件的源代码。你也可以直接使用Yocto构建中的sysroot，而不是SDK（[https://docs.yoctoproject.org/sdk-manual/extensible.html#when-using-the-extensible-sdk-directly-in-a-yocto-build](https://docs.yoctoproject.org/sdk-manual/extensible.html#when-using-the-extensible-sdk-directly-in-a-yocto-build)）。
- en: The SDK built for the Raspberry Pi 4 for version 5.0.<n> of The Yocto Project
    is installed by default in `/opt/poky/5.0.<n>/`. The `sysroot` for the target
    is `/opt/poky/5.0.<n>/sysroots/cortexa72-poky-linux/`. The programs are in `/bin/`,
    `/sbin/`, `/usr/bin/`, and `/usr/sbin/`, relative to the `sysroot`, and the libraries
    are in `/lib/` and `/usr/lib/`. In each of these directories, you will find a
    subdirectory named `.debug/` that contains the symbols for each program and library.
    GDB knows to look in .`debug`/ when searching for symbol information. The source
    code for the executables is stored in `/usr/src/debug/` relative to the `sysroot`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为版本5.0.<n>的Raspberry Pi 4构建的Yocto项目的SDK默认安装在`/opt/poky/5.0.<n>/`中。目标的`sysroot`位于`/opt/poky/5.0.<n>/sysroots/cortexa72-poky-linux/`。程序位于`/bin/`、`/sbin/`、`/usr/bin/`和`/usr/sbin/`中，这些路径相对于`sysroot`，而库文件则位于`/lib/`和`/usr/lib/`中。在这些目录中，你会找到一个名为`.debug/`的子目录，里面包含每个程序和库的符号。GDB会在`.debug/`中查找符号信息。可执行文件的源代码存储在`/usr/src/debug/`，相对于`sysroot`。
- en: Setting up Buildroot for remote debugging
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Buildroot进行远程调试
- en: 'Buildroot does not make a distinction between the environment used to build
    and the environment used for application development: there is no SDK. Assuming
    that you are using the Buildroot internal toolchain, you need to enable these
    options to copy GDB to the host and copy `gdbserver` to the target:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot 不区分构建环境和应用程序开发环境：没有 SDK。假设您正在使用 Buildroot 内部工具链，您需要启用这些选项以将 GDB 复制到主机并将
    `gdbserver` 复制到目标设备：
- en: '`BR2_TOOLCHAIN_EXTERNAL`, in **Toolchain** | **Toolchain type** | **External
    toolchain**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BR2_TOOLCHAIN_EXTERNAL`，在 **工具链** | **工具链类型** | **外部工具链**'
- en: '`BR2_TOOLCHAIN_EXTERNAL_GDB_SERVER_COPY`, in **Toolchain** | **Copy gdb server
    to the Target**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BR2_TOOLCHAIN_EXTERNAL_GDB_SERVER_COPY`，在 **工具链** | **将 gdb server 复制到目标设备**'
- en: '`BR2_PACKAGE_GDB`, in **Target packages** | **Debugging, profiling and benchmark**
    | **gdb**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BR2_PACKAGE_GDB`，在 **目标软件包** | **调试、性能分析和基准测试** | **gdb**'
- en: An external toolchain is needed because the toolchain that Buildroot 2024.02.6
    builds cannot compile `gdbserver`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 需要外部工具链，因为 Buildroot 2024.02.6 构建的工具链无法编译 `gdbserver`。
- en: You also need to build executables with debug symbols, for which you need to
    enable `BR2_ENABLE_DEBUG`, in **Build options** | **build packages with debugging
    symbols**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要构建带有调试符号的可执行文件，这需要在 **构建选项** | **构建带调试符号的软件包** 中启用 `BR2_ENABLE_DEBUG`。
- en: This will create libraries with debug symbols in `output/host/<arch>/sysroot`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会在 `output/host/<arch>/sysroot` 中创建带有调试符号的库。
- en: Starting to debug
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始调试
- en: Now that you have `gdbserver` installed on the target and a cross GDB on the
    host, you can start a debug session.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经在目标设备上安装了 `gdbserver`，并且在主机上有一个交叉编译的 GDB，您可以开始调试会话了。
- en: Connecting GDB and gdbserver
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接 GDB 和 gdbserver
- en: 'The connection between GDB and `gdbserver` can be through a network or serial
    interface. In the case of a network connection, you launch `gdbserver` with the
    TCP port number to listen on and, optionally, an IP address to accept connections
    from. In most cases, you don’t care which IP address is going to connect, so you
    can just provide the port number. In this example, `gdbserver` waits for a connection
    on port `10000` from any host:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 和 `gdbserver` 之间的连接可以通过网络或串行接口。在网络连接的情况下，您启动 `gdbserver` 时需要指定 TCP 端口号来监听，或者可选地指定一个
    IP 地址来接受连接。大多数情况下，您不关心哪个 IP 地址将进行连接，因此只需提供端口号即可。在这个例子中，`gdbserver` 等待来自任何主机的 `10000`
    端口的连接：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, start the copy of GDB from your toolchain, pointing it at an unstripped
    copy of the program so that GDB can load the symbol table:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动从您的工具链复制 GDB，指向一个未剥离的程序副本，以便 GDB 可以加载符号表：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In GDB, use the target remote command to make the connection to `gdbserver`,
    giving it the IP address or hostname of the target and the port it is waiting
    on:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GDB 中，使用 target remote 命令连接到 `gdbserver`，并提供目标设备的 IP 地址或主机名以及它等待的端口号：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When `gdbserver` sees the connection from the host, it prints the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `gdbserver` 检测到来自主机的连接时，它会打印以下信息：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The procedure is similar for a serial connection. On the target, you tell `gdbserver`
    which serial port to use:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于串行连接，过程类似。在目标设备上，您告诉 `gdbserver` 使用哪个串行端口：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You may need to configure the port baud rate beforehand using `stty(1)` or
    a similar program. A simple example would be as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要事先使用 `stty(1)` 或类似程序配置端口的波特率。一个简单的例子如下：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are many other options to `stty`, so read the manual page for more details.
    It is worthwhile noting that the port must not be used for anything else. For
    example, you can’t use a port that is being used as the system console.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`stty` 有许多其他选项，详情请阅读手册页。值得注意的是，端口不能被用于其他任何用途。例如，您不能使用正在作为系统控制台的端口。'
- en: 'On the host, you make the connection to `gdbserver` using `target remote` plus
    the serial device at the host end of the cable. In most cases, you will want to
    set the baud rate of the host serial port first, using the GDB command `set serial
    baud`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机上，您可以使用 `target remote` 命令加上连接线另一端的串口设备来连接 `gdbserver`。在大多数情况下，您需要先设置主机串口的波特率，使用
    GDB 命令 `set serial baud`：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Even though GDB and `gdbserver` are now connected, we are not ready to set breakpoints
    and start stepping through the source code yet.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 GDB 和 `gdbserver` 已经连接，我们仍然没有准备好设置断点并开始逐步调试源代码。
- en: Setting the sysroot
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 sysroot
- en: GDB needs to know where to find debug information and source code for the program
    and shared libraries you are debugging. When debugging natively, the paths are
    well known and built into GDB. But when using a cross toolchain, GDB has no way
    to guess where the root of the target filesystem is. You have to provide this
    information.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 需要知道在哪里找到你正在调试的程序和共享库的调试信息和源代码。在本地调试时，路径是已知的，并且内建在 GDB 中。但在使用交叉工具链时，GDB
    无法猜测目标文件系统的根目录在哪里。你必须提供这些信息。
- en: 'If you built your application using The Yocto Project SDK, the `sysroot` is
    within the SDK, and so you can set it in GDB like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Yocto 项目 SDK 构建了你的应用程序，`sysroot` 就在 SDK 内，因此你可以在 GDB 中这样设置它：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you are using Buildroot, you will find that the `sysroot` is in `output/host/<toolchain>/sysroot`,
    and that `output/staging` is a symbolic link to it. So, for Buildroot, you would
    set the `sysroot` like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Buildroot，你会发现 `sysroot` 在 `output/host/<toolchain>/sysroot` 中，而 `output/staging`
    是它的一个符号链接。所以，对于 Buildroot，你可以这样设置 `sysroot`：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'GDB also needs to find the source code for the files you are debugging. GDB
    has a search path for source files, which you can see using the `show directories`
    command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 还需要找到你正在调试的文件的源代码。GDB 有一个源代码搜索路径，你可以通过 `show directories` 命令查看：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These are the defaults: `$cwd` is the current working directory of the GDB
    instance running on the host; `$cdir` is the directory where the source was compiled.
    The latter is encoded into the object files with the tag `DW_AT_comp_dir`. You
    can see these tags using `objdump --dwarf` like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认值：`$cwd` 是在主机上运行的 GDB 实例的当前工作目录；`$cdir` 是源代码被编译的目录。后者通过标签 `DW_AT_comp_dir`
    被编码到目标文件中。你可以使用 `objdump --dwarf` 查看这些标签，方法如下：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In most cases, the defaults, `$cdir` and `$cwd`, are sufficient, but problems
    arise if the directories have been moved between compilation and debugging. One
    such case occurs with The Yocto Project. Taking a deeper look at the `DW_AT_comp_dir`
    tags for a program compiled using The Yocto Project SDK, you may notice this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，默认值 `$cdir` 和 `$cwd` 是足够的，但如果目录在编译和调试之间发生了移动，就会出现问题。一个这样的情况发生在 Yocto
    项目中。深入查看一个使用 Yocto 项目 SDK 编译的程序的 `DW_AT_comp_dir` 标签，你可能会注意到这一点：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, you can see multiple references to the directory `/usr/src/debug/glibc/2.39+git`,
    but where is it? The answer is that it is in the `sysroot` for the SDK, so the
    full path is `/opt/poky/5.0.6/sysroots/cortexa72-poky-linux/usr/src/debug/glibc/2.39+git`.
    The SDK contains source code for all of the programs and libraries in the target
    image. GDB has a simple way to cope with an entire directory tree being moved
    like this: `substitute-path`. So, when debugging with The Yocto Project SDK, you
    need to use these commands:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到多次提到目录`/usr/src/debug/glibc/2.39+git`，但它在哪里呢？答案是它在 SDK 的 `sysroot`
    中，所以完整路径是`/opt/poky/5.0.6/sysroots/cortexa72-poky-linux/usr/src/debug/glibc/2.39+git`。SDK
    包含了目标镜像中所有程序和库的源代码。GDB 有一个简单的方式来应对整个目录树被移动的情况：`substitute-path`。因此，在使用 Yocto 项目
    SDK 进行调试时，你需要使用这些命令：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You may have additional shared libraries that are stored outside the `sysroot`.
    In that case, you can use `set solib-search-path`, which can contain a colon-separated
    list of directories to search for shared libraries. GDB searches `solib-search-path`
    only if it cannot find the binary in the `sysroot`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有其他共享库存储在 `sysroot` 外部。在这种情况下，你可以使用 `set solib-search-path`，它可以包含一个以冒号分隔的目录列表，用来搜索共享库。GDB
    只有在无法在 `sysroot` 中找到二进制文件时，才会搜索 `solib-search-path`。
- en: 'A third way of telling GDB where to look for source code, for both libraries
    and programs, is to use the `directory` command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉 GDB 寻找源代码的第三种方式，无论是库还是程序，是使用 `directory` 命令：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Paths added in this way take precedence because they are searched *before* those
    from `sysroot` or `solib-search-path`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式添加的路径优先级更高，因为它们在 `sysroot` 或 `solib-search-path` 之前被搜索。
- en: GDB command files
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GDB 命令文件
- en: 'There are some things that you need to do each time you run GDB, like setting
    the `sysroot`. It is convenient to put such commands into a command file and run
    them each time GDB is started. GDB reads commands from `$HOME/.gdbinit`, then
    from `.gdbinit` in the current directory, and then from files specified on the
    command line with the `-x` parameter. However, recent versions of GDB will refuse
    to load `.gdbinit` from the current directory for security reasons. You can override
    that behavior by adding a line such as this to `$HOME/.gdbinit`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行 GDB 时，有一些操作是必须进行的，比如设置 `sysroot`。将这些命令放入命令文件中，并在每次启动 GDB 时运行它们非常方便。GDB
    会从 `$HOME/.gdbinit` 读取命令，然后从当前目录中的 `.gdbinit` 文件读取，再从通过 `-x` 参数指定的文件中读取命令。然而，GDB
    的最新版本出于安全原因会拒绝加载当前目录中的 `.gdbinit` 文件。你可以通过在 `$HOME/.gdbinit` 中添加如下行来覆盖这种行为：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, if you don’t want to enable auto-loading globally, you can specify
    a particular directory like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你不想全局启用自动加载，可以像这样指定一个特定目录：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: My personal preference is to use the `-x` parameter to point to the command
    file, which exposes the location of the file so that I don’t forget about it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人的偏好是使用 `-x` 参数指向命令文件，这样可以暴露文件的位置，避免忘记它。
- en: 'To help you set up GDB, Buildroot creates a GDB command file containing the
    correct `sysroot` command in `output/staging/usr/share/buildroot/gdbinit`. It
    will contain a line like this one:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你设置 GDB，Buildroot 创建了一个包含正确 `sysroot` 命令的 GDB 命令文件，该文件位于 `output/staging/usr/share/buildroot/gdbinit`。该文件包含如下行：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that GDB is running and can find the information it needs, let’s look at
    some of the commands we can perform with it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 GDB 正在运行并能找到所需的信息，让我们看看可以执行的一些命令。
- en: Overview of GDB commands
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GDB 命令概览
- en: GDB has many more commands, which are described in the online manual and in
    the resources mentioned in the *Further study* section. To help you get going
    as quickly as possible, here is a list of the most commonly used commands. In
    most cases, there is a short form for commands, which are listed in the following
    tables.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 还有许多其他命令，具体描述请参考在线手册和*进一步学习*部分提到的资源。为了帮助你尽快上手，下面列出了最常用的命令。在大多数情况下，命令有简短的形式，具体列在以下表格中。
- en: Breakpoints
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 断点
- en: 'These are the commands for managing breakpoints:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是管理断点的命令：
- en: '| **Command** | **Short-form command** | **Use** |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **简短命令** | **用途** |'
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '| Set a breakpoint on a function name, line number, or line. Examples of locations
    are `main`, `5`, and `sortbug.c:42`. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 在函数名、行号或行上设置断点。位置示例有 `main`、`5` 和 `sortbug.c:42`。 |'
- en: '|'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| List breakpoints. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 列出断点。 |'
- en: '|'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| Delete the breakpoint `<N>`. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 删除断点 `<N>`。 |'
- en: Running and stepping
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行与单步执行
- en: 'These are commands for controlling the execution of a program:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是控制程序执行的命令：
- en: '| **Command** | **Short-form command** | **Use** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **简短命令** | **用途** |'
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '| Load a fresh copy of the program into memory and start running it. *This
    does not work for remote debugging using gdbserver*. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 将程序的一个新副本加载到内存并开始运行。*这对使用 gdbserver 进行远程调试无效*。 |'
- en: '|'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| Continue execution from a breakpoint. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 从断点继续执行。 |'
- en: '| *Ctrl + C* | - | Stop the program from being debugged. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl + C* | - | 停止调试中的程序。 |'
- en: '|'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| Step one line of code, stepping *into* any function that is called. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 单步执行一行代码，*进入*任何被调用的函数。 |'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '| Step one line of code, stepping *over* a function call. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 单步执行一行代码，*跳过*函数调用。 |'
- en: '|'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '| - | Run until the current function returns. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| - | 运行直到当前函数返回。 |'
- en: Getting information
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取信息
- en: 'These are commands for getting information regarding the debugger:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是获取调试器信息的命令：
- en: '| **Command** | **Short-form command** | **Use** |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **简短命令** | **用途** |'
- en: '|'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '| List the call stack. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 列出调用栈。 |'
- en: '|'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '| Display information about the threads executing in the program. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 显示程序中当前执行的线程信息。 |'
- en: '|'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '| Display information about shared libraries currently loaded by the program.
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 显示当前程序加载的共享库信息。 |'
- en: '|'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '| Print the value of the variable. For example, `print foo`. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 打印变量的值。例如，`print foo`。 |'
- en: '|'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '| List lines of code around the current program counter. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 列出当前程序计数器周围的代码行。 |'
- en: Before we can begin stepping through a program inside a debug session, we first
    need to set an initial breakpoint.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始单步调试程序之前，首先需要设置一个初始断点。
- en: Running to a breakpoint
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行到断点
- en: '`gdbserver` loads the program into memory and sets a breakpoint at the first
    instruction. Then it waits for a connection from GDB. When the connection is made,
    you enter into a debug session. However, you will find that if you try to single-step
    immediately, you will get this message:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`gdbserver`将程序加载到内存中，并在第一条指令处设置断点。然后它会等待GDB的连接。当连接建立时，你将进入调试会话。然而，你会发现如果你立即尝试单步执行，你会看到以下信息：'
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is because the program has halted at code written in assembly, which creates
    the runtime environment for C/C++ programs. The first line of C/C++ code is the
    `main()` function. To stop at `main()`, you would set a breakpoint there and then
    use the `continue` command (abbreviation `c`) to tell `gdbserver` to continue
    from the start of the program and stop at `main()`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为程序在汇编代码中暂停，该代码为C/C++程序创建运行时环境。C/C++代码的第一行是`main()`函数。要在`main()`处停下，你需要在该处设置断点，然后使用`continue`命令（缩写`c`）告诉`gdbserver`从程序开始处继续并停在`main()`处：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'At this point, you may see the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能会看到以下内容：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With older versions of GDB, you may instead see this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在GDB的旧版本中，你可能会看到以下信息：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In both cases, the problem is that you have forgotten to set the `sysroot`!
    Take another look at the earlier section on `sysroot`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，问题是你忘记设置`sysroot`！请再看看前面关于`sysroot`的部分。
- en: This is all very different from starting a program natively, where you just
    type `run`. In fact, if you try typing `run` in a remote debug session, you will
    either see a message saying that the remote target does not support the `run`
    command, or, in older versions of GDB, it will just hang without any explanation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这与本地启动程序非常不同，在本地你只需输入`run`。事实上，如果你在远程调试会话中尝试输入`run`，你将看到一条消息，提示远程目标不支持`run`命令，或者在GDB的旧版本中，它会挂起而没有任何解释。
- en: Extending GDB with Python
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python扩展GDB
- en: We can embed a full Python interpreter into GDB to extend its functionality.
    This is done by configuring GDB using the `--with-python` option prior to building.
    GDB has an API that exposes much of its internal state as Python objects. This
    API allows us to define our own custom GDB commands as scripts written in Python.
    These extra commands may include useful debugging aids such as tracepoints and
    pretty printers that are not built into GDB.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个完整的Python解释器嵌入到GDB中，以扩展其功能。这是通过在构建前使用`--with-python`选项配置GDB来实现的。GDB有一个API，将其内部状态暴露为Python对象。这个API允许我们定义自己的自定义GDB命令，作为Python脚本编写。这些额外的命令可能包括一些有用的调试辅助功能，比如跟踪点和漂亮的打印器，这些功能并没有内建在GDB中。
- en: Building GDB with Python support
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建带有Python支持的GDB
- en: We have already covered *Setting up Buildroot for remote debugging*. There are
    some additional steps needed to enable Python support inside GDB. We cannot use
    a toolchain generated by Buildroot to build GDB with Python support because it
    is missing some necessary thread support.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讲解了*为远程调试设置Buildroot*。为了在GDB中启用Python支持，还需要一些额外步骤。我们不能使用Buildroot生成的工具链来构建具有Python支持的GDB，因为它缺少一些必要的线程支持。
- en: 'To build cross GDB for the host with Python support, perform the following
    steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建支持Python的交叉GDB，请执行以下步骤：
- en: 'Navigate to the directory where you installed Buildroot:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入你安装Buildroot的目录：
- en: '[PRE51]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Copy the configuration file for the board you wish to build an image for:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制你希望为其构建镜像的板子的配置文件：
- en: '[PRE52]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Clean previous build artifacts from the `output` directory:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除`output`目录中的先前构建的产物：
- en: '[PRE53]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Activate your configuration file:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活你的配置文件：
- en: '[PRE54]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Begin customizing your image:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始自定义你的镜像：
- en: '[PRE55]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Enable the use of an external toolchain by navigating to **Toolchain** | **Toolchain
    type** | **External toolchain** and selecting that option.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过进入**Toolchain** | **Toolchain type** | **External toolchain**并选择该选项来启用外部工具链的使用。
- en: Back out of **External toolchain** and open the **Toolchain** submenu. Select
    a known working toolchain, such as **Linaro AArch64 2018.05**, as your external
    toolchain.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出**外部工具链**，然后打开**工具链**子菜单。选择一个已知有效的工具链，比如**Linaro AArch64 2018.05**，作为你的外部工具链。
- en: Select **Build cross gdb for the host** from the Toolchain page and enable both
    **TUI support** and **Python support**.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从工具链页面选择**为主机构建交叉GDB**，并启用**TUI支持**和**Python支持**。
- en: Drill down into the **GDB debugger Version** submenu from the **Toolchain**
    page and select the newest version of GDB available in Buildroot.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**工具链**页面进入**GDB调试器版本**子菜单，选择Buildroot中可用的最新版本GDB。
- en: Back out of the **Toolchain** page and drill down into **Build options**. Select
    **Build packages with debugging symbols**.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 **工具链** 页面并进入 **构建选项**。选择 **构建包含调试符号的包**。
- en: Back out of the **Build options** page, drill down into **System Configuration**,
    and select **Enable root login with password**. Open **Root password** and enter
    a non-empty password in the text field.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 **构建选项** 页面，进入 **系统配置**，并选择 **启用密码登录为 root 用户**。打开 **Root 密码** 并在文本框中输入一个非空密码。
- en: Back out of the **System Configuration** page and drill down into **Target packages**
    | **Debugging, profiling and benchmark**. Select the **gdb** package to add `gdbserver`
    to the target image.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 **系统配置** 页面，进入 **目标包** | **调试、性能分析和基准测试**。选择 **gdb** 包以将 `gdbserver` 添加到目标镜像中。
- en: Back out of **Debugging, profiling and benchmark** and drill down into **Target
    packages** | **Networking applications**. Select the **dropbear** package to enable
    `scp` and `ssh` access to the target. Note that `dropbear` does not allow `root`
    `scp` and `ssh` access without a password.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 **调试、性能分析和基准测试**，进入 **目标包** | **网络应用**。选择 **dropbear** 包以启用 `scp` 和 `ssh`
    访问目标。请注意，`dropbear` 不允许没有密码的 `root` 用户通过 `scp` 和 `ssh` 进行访问。
- en: Add the **haveged** entropy daemon, which can be found under **Target packages**
    | **Miscellaneous** so that SSH is available quicker upon booting.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 **haveged** 熵守护进程，该进程可以在 **目标包** | **杂项** 下找到，以便在启动时更快地提供 SSH 服务。
- en: Add another package to your image so you have something to debug. I chose the
    `bsdiff` binary patch/diff tool, which is written in C and can be found under
    **Target packages** | **Development tools**.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向镜像中添加另一个包，以便有东西可以调试。我选择了 `bsdiff` 二进制补丁/差异工具，它是用 C 编写的，可以在 **目标包** | **开发工具**
    下找到。
- en: Save your changes and exit Buildroot’s `menuconfig`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改并退出 Buildroot 的 `menuconfig`。
- en: 'Save your changes to your configuration file:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你对配置文件所做的更改：
- en: '[PRE56]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Build the image for the target:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为目标设备构建镜像：
- en: '[PRE57]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: A readymade `rpi4_64_gdb_defconfig` file for the Raspberry Pi 4 can be found
    in the code archive for this chapter if you wish to skip the previous `menuconfig`
    steps. Copy that file from `MELD/Chapter19/buildroot/configs/` to your `buildroot/configs`
    directory and run `make` on that if you prefer.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跳过之前的 `menuconfig` 步骤，可以在本章的代码归档中找到 Raspberry Pi 4 的现成 `rpi4_64_gdb_defconfig`
    文件。将该文件从 `MELD/Chapter19/buildroot/configs/` 复制到你的 `buildroot/configs` 目录，并在其上运行
    `make`。
- en: When the build is done, there should be a bootable `sdcard.img` file in `output/images/`
    that you can write to a microSD card using Etcher. Insert that microSD into your
    target device and boot it. Connect the target device to your local network with
    an Ethernet cable and locate its IP address using `arp-scan --localnet`. SSH into
    the device as `root` and enter the password that you set when configuring your
    image. I specified `temppwd` as the `root` password for my `rpi4_64_gdb_defconfig`
    image.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建完成时，应该会在 `output/images/` 目录下生成一个可启动的 `sdcard.img` 文件，你可以使用 Etcher 将其写入 microSD
    卡。将该 microSD 卡插入目标设备并启动它。通过以太网线将目标设备连接到本地网络，并使用 `arp-scan --localnet` 查找其 IP 地址。通过
    SSH 以 `root` 身份登录设备，并输入配置镜像时设置的密码。我为我的 `rpi4_64_gdb_defconfig` 镜像指定了 `temppwd`
    作为 `root` 密码。
- en: 'Now, let’s debug `bsdiff` remotely using GDB:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 GDB 远程调试 `bsdiff`：
- en: 'First, navigate to the `/usr/bin` directory on the target:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到目标设备上的 `/usr/bin` 目录：
- en: '[PRE58]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, start `bdiff` with `gdbserver`, as we did with `helloworld` earlier:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，像之前调试 `helloworld` 一样，使用 `gdbserver` 启动 `bdiff`：
- en: '[PRE59]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'On your Linux host, copy `tp.py` to your home directory:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Linux 主机上，将 `tp.py` 复制到主目录：
- en: '[PRE60]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, start the copy of GDB from your toolchain, pointing it at an unstripped
    copy of the program so that GDB can load the symbol table:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，启动工具链中的 GDB，并指向未剥离的程序副本，以便 GDB 可以加载符号表：
- en: '[PRE61]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In GDB, set the `sysroot` like this:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 GDB 中，像这样设置 `sysroot`：
- en: '[PRE62]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, use the command target remote to make the connection to `gdbserver`,
    giving it the IP address or hostname of the target and the port it is waiting
    on:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用命令 `target remote` 连接到 `gdbserver`，并提供目标的 IP 地址或主机名及其监听的端口：
- en: '[PRE63]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When `gdbserver` sees the connection from the host, it prints the following:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `gdbserver` 看到来自主机的连接时，它会打印以下信息：
- en: '[PRE64]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can now load Python command scripts such as `tp.py` into GDB and invoke
    these commands like so:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将 Python 脚本如 `tp.py` 加载到 GDB 中，并像这样调用这些命令：
- en: '[PRE65]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this case, `tp` is the name of the *tracepoint* command and `search` is the
    name of a recursive function in `bsdiff`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`tp` 是 *tracepoint* 命令的名称，`search` 是 `bsdiff` 中一个递归函数的名称。
- en: 'Set a breakpoint at `main()`:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 处设置断点：
- en: '[PRE66]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Continue:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续：
- en: '[PRE67]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Continue again:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续：
- en: '[PRE68]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `bsdiff` program performs binary diffs and takes three arguments: `oldfile`,
    `newfile`, and `patchfile`. The `patchfile` that `bsdiff` generates serves as
    input to the `bspatch` program for patching binaries. We start the `bsdiff` program
    on the target with `/usr/bin/bzless`, `/usr/bin/bzmore`, and `~/patchfile` as
    arguments. The output from the GDB *tracepoint* command indicates that the `search`
    function at *line 170* of `bsdiff.c` was called 10 times over the course of the
    process.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`bsdiff`程序执行二进制差异比较，接受三个参数：`oldfile`，`newfile`和`patchfile`。`bsdiff`生成的`patchfile`作为输入传递给`bspatch`程序，用于修补二进制文件。我们在目标平台上启动`bsdiff`程序，参数为`/usr/bin/bzless`，`/usr/bin/bzmore`和`~/patchfile`。来自GDB
    *追踪点*命令的输出表明，`bsdiff.c`中*第170行*的`search`函数在整个过程中被调用了10次。'
- en: The Python support in GDB can also be used to debug Python programs. GDB has
    visibility into CPython’s internals that the standard `pdb` debugger for Python
    does not. It can even inject Python code into a running Python process. This enables
    the creation of powerful Python debugging tools like memory analyzers that would
    otherwise be impossible.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: GDB中的Python支持也可以用来调试Python程序。GDB可以查看CPython的内部实现，而标准的Python调试器`pdb`无法做到这一点。它甚至可以向正在运行的Python进程中注入Python代码。这使得创建像内存分析工具这样的强大Python调试工具成为可能，这在其他情况下是无法实现的。
- en: Native debugging
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地调试
- en: Running a native copy of GDB on the target is not as common as doing it remotely,
    but it is possible. In addition to installing GDB onto the target image, you will
    also need to install unstripped copies of the executables you wish to debug and
    their corresponding source code. Both The Yocto Project and Buildroot allow you
    to do this.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标平台上运行本地版的GDB并不像远程调试那样常见，但也是可行的。除了将GDB安装到目标镜像中，你还需要安装你希望调试的可执行文件的未去除符号版本以及它们对应的源代码。Yocto
    项目和 Buildroot 都允许你这么做。
- en: '**IMPORTANT NOTE**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: While native debugging is not a common activity for embedded developers, running
    profile and trace tools on the target is very common. These tools usually work
    best if you have unstripped binaries and source code on the target, which is half
    of the story I am telling here. I will return to this topic in the next chapter.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本地调试并不是嵌入式开发人员常做的活动，但在目标平台上运行性能分析和追踪工具却是非常常见的。这些工具通常在目标平台上具有未去除符号的二进制文件和源代码时效果最佳，这正是我在这里所要讲的内容的一部分。我将在下一章中回到这个话题。
- en: The Yocto Project
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Yocto 项目
- en: 'To begin with, add `gdb` to the target image by adding this to `conf/local.conf`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过将以下内容添加到`conf/local.conf`中，将`gdb`添加到目标镜像：
- en: '[PRE69]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You need the debug information for the packages you want to debug. The Yocto
    Project builds debug variants of packages, which contain the debug info and symbols
    stripped from the binaries. You can add these debug packages selectively to your
    target image by adding `<package name>-dbg` to your `conf/local.conf`. Or, you
    can simply install all debug packages by adding `dbg-pkgs` to `EXTRA_IMAGE_FEATURES`
    as just shown. Be warned that this will increase the size of the target image
    dramatically, perhaps by several hundreds of megabytes.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要调试的包的调试信息。Yocto 项目会构建包含调试信息和从二进制文件中去除的符号的包的调试版本。你可以通过将`<package name>-dbg`添加到`conf/local.conf`，选择性地将这些调试包添加到目标镜像中。或者，像之前所示，你可以通过将`dbg-pkgs`添加到`EXTRA_IMAGE_FEATURES`来一次性安装所有调试包。需要注意的是，这会大幅增加目标镜像的大小，可能增加几百兆字节。
- en: Similarly, you can add source packages to your target image by adding `<package
    name>-src` to your `conf/local.conf`. Or, you can simply install all source packages
    by adding `src-pkgs` to `EXTRA_IMAGE_FEATURES`. Again, this will dramatically
    increase the size of the target image. The source code is installed in `/usr/src/debug/<package
    name>` in the target image. This means that GDB will pick it up without needing
    to run `set substitute-path`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以通过将`<package name>-src`添加到`conf/local.conf`中，将源代码包添加到目标镜像中。或者，你也可以通过将`src-pkgs`添加到`EXTRA_IMAGE_FEATURES`来安装所有源代码包。再次强调，这将显著增加目标镜像的大小。源代码将被安装到目标镜像中的`/usr/src/debug/<package
    name>`目录下。这意味着GDB将能够自动找到它，而无需运行`set substitute-path`。
- en: Buildroot
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Buildroot
- en: 'With Buildroot, you can tell it to install a native copy of GDB in the target
    image by enabling this option:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Buildroot，你可以通过启用这个选项，告诉它将本地版 GDB 安装到目标镜像中：
- en: '`BR2_PACKAGE_GDB_DEBUGGER` in **Target packages** | **Debugging, profiling
    and benchmark** | **Full debugger**'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标包** | **调试、性能分析和基准测试** | **完整调试器**中的`BR2_PACKAGE_GDB_DEBUGGER`'
- en: 'Then, to build binaries with debug information and install them in the target
    image without stripping, enable the first and disable the second of these two
    options:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要构建带有调试信息的二进制文件并将其安装到目标镜像中而不去除符号，请启用这两个选项中的第一个并禁用第二个：
- en: '`BR2_ENABLE_DEBUG` in **Build options** | **Build packages with debugging symbols**'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建选项**中的`BR2_ENABLE_DEBUG` | **带调试符号的构建包**'
- en: '`BR2_STRIP_strip` in **Build options** | **Strip target binaries**'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建选项**中的`BR2_STRIP_strip` | **剥离目标二进制文件**'
- en: That’s all I have to say about native debugging. Again, the practice is uncommon
    on embedded devices because the extra source code and debug symbols add bloat
    to the target image. Next, let’s look at another form of remote debugging.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我关于本地调试的所有内容。再次强调，这种做法在嵌入式设备上并不常见，因为额外的源代码和调试符号会增加目标镜像的体积。接下来，我们来看看另一种形式的远程调试。
- en: Just-in-time debugging
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即时调试
- en: Sometimes, a program will start to misbehave after it has been running for a
    while, and you would like to know what it is doing. The GDB `attach` feature does
    exactly this. I call it just-in-time debugging. It is available with both native
    and remote debug sessions.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，程序在运行一段时间后开始表现异常，这时你可能想知道它在做什么。GDB的`attach`功能正是用来实现这一点的。我称之为即时调试。它适用于本地和远程调试会话。
- en: 'In the case of remote debugging, you need to find the PID of the process to
    be debugged and pass it to `gdbserver` with the `--attach` option. For example,
    if the PID is 109, you would type this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程调试的情况下，你需要找到要调试的进程的PID，并通过`--attach`选项将其传递给`gdbserver`。例如，如果PID是109，你可以输入：
- en: '[PRE70]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This forces the process to stop as if it were at a breakpoint, allowing you
    to start your cross GDB in the normal way and connect to `gdbserver`. When you
    are done, you can detach, allowing the program to continue running without the
    debugger:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这会强制进程停止，就像它处于断点一样，让你以正常的方式启动交叉GDB并连接到`gdbserver`。完成后，你可以分离调试器，让程序在没有调试器的情况下继续运行：
- en: '[PRE71]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Attaching to a running process by PID is certainly handy, but what about multi-process
    or multithreaded programs? There are techniques for debugging those types of programs
    with GDB as well.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 按PID附加到正在运行的进程无疑是很方便的，但多进程或多线程程序怎么办？也有使用GDB调试这类程序的技术。
- en: Debugging forks and threads
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试fork和线程
- en: What happens when the program you are debugging forks? Does the debug session
    follow the parent process or the child? This behavior is controlled by `follow-fork-mode`,
    which may be `parent` or `child`, with `parent` being the default. Unfortunately,
    current versions of `gdbserver` do not support this option, so it only works for
    native debugging. If you really need to debug the child process while using `gdbserver`,
    a workaround is to modify the code so that the child loops on a variable immediately
    after the fork, giving you the opportunity to attach a new `gdbserver` session
    to it and then to set the variable so that it drops out of the loop.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调试的程序创建子进程时会发生什么？调试会话是跟随父进程还是子进程？这个行为由`follow-fork-mode`控制，可能的值是`parent`或`child`，默认值是`parent`。不幸的是，当前版本的`gdbserver`不支持此选项，因此它仅适用于本地调试。如果你在使用`gdbserver`时确实需要调试子进程，一个解决方法是修改代码，使得子进程在`fork`后立即在一个变量上进行循环，从而给你机会附加一个新的`gdbserver`会话到它，并设置该变量以使其退出循环。
- en: When a thread in a multithreaded process hits a breakpoint, the default behavior
    is for all threads to halt. In most cases, this is the best thing to do as it
    allows you to look at static variables without them being changed by the other
    threads. When you resume execution of the thread, all the stopped threads start
    up, even if you are single-stepping, and it is especially this last case that
    can cause problems. There is a way to modify the way in which GDB handles stopped
    threads, through a parameter called `scheduler-locking`. Normally it is `off`,
    but if you set it to `on`, only the thread that was stopped at the breakpoint
    is resumed and the others remain stopped, giving you a chance to see what the
    thread alone does without interference. This continues to be the case until you
    turn `scheduler-locking` off. `gdbserver` supports this feature.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当多线程进程中的一个线程命中断点时，默认行为是所有线程都停止。在大多数情况下，这是最好的做法，因为它允许你查看静态变量，而不会被其他线程更改。当你恢复线程的执行时，所有停止的线程都会重新启动，即使你在逐步调试，尤其是这种情况可能会导致问题。可以通过一个名为`scheduler-locking`的参数来修改GDB处理停止线程的方式。通常它是`off`，但如果将其设置为`on`，只有在断点停下的线程会恢复，其他线程保持停止状态，这样你就可以看到该线程独立的行为，不受干扰。直到你将`scheduler-locking`关闭之前，这种状态会持续下去。`gdbserver`支持这个特性。
- en: Core files
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心文件
- en: Core files capture the state of a failing program at the point that it terminates.
    You don’t even have to be in the room with a debugger when the bug manifests itself.
    So, when you see `Segmentation fault (core dumped)`, don’t shrug; investigate
    the **core file** and extract the goldmine of information in there.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 核心文件捕获了在程序终止时程序失败的状态。你甚至不需要在调试器旁边，当错误表现出来时就能抓取到核心文件。所以，当你看到`Segmentation fault
    (core dumped)`时，不要只是耸耸肩；要调查**核心文件**，并从中提取宝贵的信息。
- en: 'The first observation is that core files are not created by default, but only
    when the core file resource limit for the process is non-zero. You can change
    it for the current shell using `ulimit -c`. To remove all limits on the size of
    core files, type the following command:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个观察结果是，核心文件默认是不会创建的，只有当进程的核心文件资源限制不为零时才会创建。你可以使用`ulimit -c`命令更改当前Shell的设置。要移除对核心文件大小的所有限制，请输入以下命令：
- en: '[PRE72]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: By default, the core file is named `core` and is placed in the current working
    directory of the process, which is the one pointed to by `/proc/<PID>/cwd`. There
    are a number of problems with this scheme. Firstly, when looking at a device with
    several files named `core`, it is not obvious which program generated each one.
    Secondly, the current working directory of the process may well be in a read-only
    filesystem, there may not be enough space to store the core file, or the process
    may not have permissions to write to the current working directory.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，核心文件被命名为`core`，并保存在进程的当前工作目录中，这个目录是由`/proc/<PID>/cwd`指向的。这个方案有不少问题。首先，当查看一个设备上有多个名为`core`的文件时，无法明显知道每个文件是由哪个程序生成的。其次，进程的当前工作目录可能是在一个只读文件系统中，可能没有足够的空间来存储核心文件，或者进程可能没有写入当前工作目录的权限。
- en: There are two files that control the naming and placement of core files. The
    first is `/proc/sys/kernel/core_uses_pid`. Writing a `1` to it causes the PID
    number of the dying process to be appended to the filename, which is somewhat
    useful as long as you can associate the PID number with a program name from log
    files.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个文件控制核心文件的命名和存放位置。第一个是`/proc/sys/kernel/core_uses_pid`。将`1`写入该文件会导致死掉的进程的PID编号被附加到文件名中，这在你能从日志文件中将PID编号与程序名称关联时，还是相当有用的。
- en: 'Much more useful is `/proc/sys/kernel/core_pattern`, which gives you a lot
    more control over core files. The default pattern is core, but you can change
    it to a pattern composed of these meta characters:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 更有用的是`/proc/sys/kernel/core_pattern`，它可以让你对核心文件有更多的控制。默认的模式是core，但你可以将其更改为由这些元字符组成的模式：
- en: '`%p`: PID'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%p`：PID'
- en: '`%u`: Real UID of the dumped process'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%u`：被转储进程的实际UID'
- en: '`%g`: Real GID of the dumped process'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%g`：被转储进程的实际GID'
- en: '`%s`: Number of the signal causing the dump'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%s`：导致转储的信号编号'
- en: '`%t`: Time of dump expressed as seconds since the Epoch, 1970-01-01 00:00:00
    +0000 (UTC)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%t`：转储的时间，以自纪元起的秒数表示，1970-01-01 00:00:00 +0000 (UTC)'
- en: '`%h`: Hostname'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%h`：主机名'
- en: '`%e`: Executable filename'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%e`：可执行文件名'
- en: '`%E`: Path name of executable with slashes (/) replaced by exclamation marks
    (!)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%E`：可执行文件的路径名，其中的斜杠（/）被感叹号（!）替换'
- en: '`%c`: Core file size soft resource limit of the dumped process'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%c`：被转储进程的核心文件大小软资源限制'
- en: 'You can also use a pattern that begins with an absolute directory name so that
    all core files are gathered together in one place. As an example, the following
    pattern puts all core files into the `/corefiles` directory and names them with
    the program name and the time of the crash:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用以绝对目录名称开头的模式，将所有核心文件集中在一个地方。例如，以下模式将所有核心文件放入`/corefiles`目录，并以程序名和崩溃时间命名：
- en: '[PRE73]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Following a core dump, you would find something like this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心转储之后，你会看到类似这样的内容：
- en: '[PRE74]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: For more information, refer to the `core(5)` manual page.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参考`core(5)`手册页。
- en: Using GDB to look at core files
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GDB 查看核心文件
- en: 'Here is a sample GDB session looking at a core file:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个查看核心文件的 GDB 会话示例：
- en: '[PRE75]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This shows that the program stopped at *line 41*. The list command shows the
    code in the vicinity:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明程序在*第 41 行*停止。`list`命令显示了附近的代码：
- en: '[PRE76]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `backtrace` command (shortened to `bt`) shows how we got to this point:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`backtrace`命令（简写为`bt`）显示我们是如何到达此处的：'
- en: '[PRE77]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This is an obvious mistake: `addtree()` was called with a null pointer.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个明显的错误：`addtree()`被传入了一个空指针。
- en: GDB began as a command-line debugger and many people still use it this way.
    Even though the LLVM Project’s LLDB debugger is gaining in popularity, GCC and
    GDB remain the prominent compiler and debugger for Linux. So far, we have focused
    exclusively on GDB’s command-line interface. Now we will look at some frontends
    to GDB with progressively more modern user interfaces.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 最初是一个命令行调试器，许多人至今仍然以这种方式使用它。尽管 LLVM 项目的 LLDB 调试器正在日益流行，但 GCC 和 GDB 仍然是 Linux
    上主要的编译器和调试器。到目前为止，我们一直专注于 GDB 的命令行界面。现在我们将看看一些 GDB 的前端界面，它们逐渐拥有更现代的用户界面。
- en: GDB user interfaces
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GDB 用户界面
- en: GDB is controlled at a low level through the GDB machine interface, GDB/MI,
    which can be used to wrap GDB in a user interface or as part of a larger program,
    and it considerably extends the range of options available to you.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 通过 GDB 机器接口（GDB/MI）在低级别进行控制，GDB/MI 可用于将 GDB 包装在用户界面中或作为更大程序的一部分，并大大扩展了可用选项的范围。
- en: 'In this section, I will describe three that are well suited to debugging embedded
    targets: the **Terminal User Interface** (**TUI**), **Data Display Debugger**
    (**DDD**), and **Visual Studio Code**.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍三种非常适合调试嵌入式目标的工具：**终端用户界面**（**TUI**）、**数据展示调试器**（**DDD**）和**Visual
    Studio Code**。
- en: Terminal User Interface
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端用户界面
- en: The **Terminal User Interface** (**TUI**) is an optional part of the standard
    GDB package. The main feature is a code window that shows the line of code about
    to be executed, together with any breakpoints. It is a definite improvement on
    the `list` command in command-line mode GDB.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**终端用户界面**（**TUI**）是标准 GDB 包中的一个可选部分。其主要特点是一个代码窗口，显示即将执行的代码行以及所有断点。这比命令行模式下的`list`命令有了明显的改进。'
- en: 'The attraction of the TUI is that it just works without any extra setup, and
    since it is in text mode, it is possible to use over an SSH terminal session,
    for example, when running `gdb` natively on a target. Most cross toolchains configure
    GDB with the TUI. Simply add `-tui` to the command line and you will see the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: TUI 的吸引力在于它无需额外设置就能正常工作，并且由于它是文本模式，因此可以在 SSH 终端会话中使用，例如，在目标上本地运行`gdb`时。大多数交叉工具链都配置了带有
    TUI 的 GDB。只需在命令行中添加`-tui`，你将看到如下界面：
- en: '![Figure 19.1 – TUI](img/B18466_19_01.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.1 – TUI](img/B18466_19_01.png)'
- en: Figure 19.1 – TUI
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.1 – TUI
- en: If you still find the TUI lacking and prefer a truly graphical frontend to GDB,
    the GNU project also offers one of those ([https://www.gnu.org/software/ddd](https://www.gnu.org/software/ddd)).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然觉得 TUI 不够完善，并且更倾向于使用真正的图形前端来操作 GDB，GNU 项目也提供了这样的一个工具（[https://www.gnu.org/software/ddd](https://www.gnu.org/software/ddd)）。
- en: Data Display Debugger
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据展示调试器
- en: '**Data Display Debugger** (**DDD**) is a simple standalone program that gives
    you a graphical user interface to GDB with minimal fuss and bother, and although
    the UI controls look dated, it does everything that is necessary.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据展示调试器**（**DDD**）是一个简单的独立程序，它为 GDB 提供了一个图形用户界面，且操作简便，尽管 UI 控件看起来有些过时，但它完成了所有必要的功能。'
- en: 'The `--debugger` option tells DDD to use GDB from your toolchain, and you can
    use the `-x` argument to give the path to a GDB command file:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`--debugger`选项告诉 DDD 使用你工具链中的 GDB，且你可以使用`-x`参数指定 GDB 命令文件的路径：'
- en: '[PRE78]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following screenshot shows off one of the nicest features: the data window,
    which contains items in a grid that you can rearrange as you wish. If you double-click
    on a pointer, it is expanded into a new data item and the link is shown with an
    arrow:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了其中一个最棒的功能：数据窗口，里面有一个网格，你可以随意调整其中的项目。如果双击指针，它会展开为一个新的数据项，并且链接会显示带箭头的形式：
- en: '![Figure 19.2 – DDD](img/B18466_19_02.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.2 – DDD](img/B18466_19_02.png)'
- en: Figure 19.2 – DDD
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.2 – DDD
- en: If neither of these two GDB frontends is acceptable because you are a full stack
    web developer accustomed to working with the latest tools in your industry, then
    we still have you covered.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个GDB前端都不可接受，因为你是一个习惯使用行业内最新工具的全栈Web开发人员，那么我们依然有解决方案。
- en: Visual Studio Code
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: '**Visual Studio Code** is a very popular open-source code editor from Microsoft.
    Because it is an Electron application written in TypeScript, Visual Studio Code
    feels more lightweight and responsive than full-blown IDEs such as Eclipse. There
    is rich language support (code completion, go to definition, etc.) for many languages
    by way of extensions contributed by its large community of users. Remote cross
    GDB debugging can be integrated into Visual Studio Code using extensions for C/C++.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**是微软推出的一个非常流行的开源代码编辑器。由于它是一个用TypeScript编写的Electron应用，Visual
    Studio Code比像Eclipse这样的完整IDE更轻量和响应迅速。通过社区贡献的扩展，它支持多种语言的丰富功能（代码补全、跳转到定义等）。还可以通过扩展将远程GDB调试集成到Visual
    Studio Code中，支持C/C++。'
- en: '![Figure 19.3 – Visual Studio Code](img/B18466_19_03.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图 19.3 – Visual Studio Code](img/B18466_19_03.png)'
- en: Figure 19.3 – Visual Studio Code
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.3 – Visual Studio Code
- en: There are no prescribed workflows for integrating Visual Studio Code with Buildroot
    or Yocto. To enable remote GDB debugging, you need to edit project files like
    `settings.json` and `launch.json`. These project files point at the toolchain
    and `sysroot`. They also contain the target IP and SSH login credentials.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 没有规定的工作流程来将Visual Studio Code与Buildroot或Yocto集成。要启用远程GDB调试，你需要编辑项目文件，如`settings.json`和`launch.json`。这些项目文件指向工具链和`sysroot`，并包含目标IP地址和SSH登录凭证。
- en: Debugging kernel code
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试内核代码
- en: You can use `kgdb` for source-level debugging, in a manner similar to remote
    debugging with `gdbserver`. There is also a self-hosted kernel debugger, `kdb`,
    that is handy for lighter-weight tasks such as seeing whether an instruction is
    executed and getting the backtrace to find out how it got there. Finally, there
    are kernel *Oops* messages and panics, which tell you a lot about the cause of
    a kernel exception.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`kgdb`进行源级调试，方式类似于使用`gdbserver`进行远程调试。还有一个自托管的内核调试器`kdb`，它适用于一些轻量级任务，比如查看指令是否被执行并获取回溯以找出程序如何到达当前状态。最后，还有内核的*Oops*信息和恐慌信息，它们能够告诉你内核异常的原因。
- en: Debugging kernel code with kgdb
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用kgdb调试内核代码
- en: When looking at kernel code using a source debugger, you must remember that
    the kernel is a complex system, with real-time behaviors. Don’t expect debugging
    to be as easy as it is for applications. Stepping through code that changes the
    memory mapping or switches context is likely to produce odd results.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用源代码调试器查看内核代码时，必须记住，内核是一个复杂的系统，具有实时行为。不要指望调试像应用程序那样简单。逐步调试可能会因为修改内存映射或切换上下文而产生奇怪的结果。
- en: '**kgdb** is the name given to the kernel GDB stubs that have been part of mainline
    Linux for many years now. There is a user manual in the kernel DocBook, and you
    can find an online version at [https://kernel.org/doc/html/v6.6/dev-tools/kgdb.html](https://kernel.org/doc/html/v6.6/dev-tools/kgdb.html).'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**kgdb**是指内核GDB存根，已经是主线Linux的一部分多年了。内核的DocBook中有用户手册，你可以在[https://kernel.org/doc/html/v6.6/dev-tools/kgdb.html](https://kernel.org/doc/html/v6.6/dev-tools/kgdb.html)找到在线版本。'
- en: In most cases, you will connect to `kgdb` over the serial interface, which is
    usually shared with the serial console. Hence, this implementation is called **kgdboc**,
    which is short for **kgdb over console**. To work, it requires a platform `tty`
    driver that supports I/O polling instead of interrupts, since `kgdb` has to disable
    interrupts when communicating with GDB. A few platforms support `kgdb` over USB,
    and there have been versions that work over Ethernet but, unfortunately, none
    of them have found their way into mainline Linux.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你将通过串行接口连接到`kgdb`，该接口通常与串行控制台共享。因此，这种实现被称为**kgdboc**，即**通过控制台的kgdb**。为了正常工作，它需要一个支持I/O轮询而非中断的`tty`驱动程序，因为`kgdb`在与GDB通信时必须禁用中断。一些平台支持通过USB进行`kgdb`，也有通过以太网工作的版本，但不幸的是，这些版本没有进入主流Linux内核。
- en: The same caveats regarding optimization and stack frames apply to the kernel,
    with the limitation that the kernel is written to assume an optimization level
    of at least `-O1`. You can override the kernel compile flags by setting `KCFLAGS`
    before running `make`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 与优化和堆栈帧相关的相同注意事项也适用于内核，唯一的限制是内核被写成假定优化级别至少为`-O1`。你可以通过在运行`make`之前设置`KCFLAGS`来覆盖内核的编译标志。
- en: 'These, then, are the kernel configuration options you will need for kernel
    debugging:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是你需要进行内核调试的内核配置选项：
- en: '`CONFIG_DEBUG_INFO` is in the **Kernel hacking** | **Compile-time checks and
    compiler options** | **Debug information** | **Rely on the toolchain’s implicit
    default DWARF version** menu.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_DEBUG_INFO`位于**内核调试** | **编译时检查和编译器选项** | **调试信息** | **依赖工具链的默认DWARF版本**菜单中。'
- en: '`CONFIG_FRAME_POINTER` may be an option for your architecture and is in the
    **Kernel hacking** | **Compile-time checks and compiler options** | **Compile
    the kernel with frame pointers** menu.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_FRAME_POINTER`可能是你架构的一个选项，位于**内核调试** | **编译时检查和编译器选项** | **使用帧指针编译内核**菜单中。'
- en: '`CONFIG_KGDB` is in the **Kernel hacking | Generic Kernel Debugging Instruments
    | KGDB: kernel debugger** menu.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_KGDB`位于**内核调试 | 通用内核调试工具 | KGDB：内核调试器**菜单中。'
- en: '`CONFIG_KGDB_SERIAL_CONSOLE` is in the **Kernel hacking** | **Generic Kernel
    Debugging Instruments** | **KGDB: kernel debugger** | **KGDB: use kgdb over the
    serial console** menu.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_KGDB_SERIAL_CONSOLE`位于**内核调试 | 通用内核调试工具** | **KGDB：内核调试器** | **KGDB：通过串行控制台使用kgdb**菜单中。'
- en: The kernel image must be in ELF object format so that GDB can load the symbols
    into memory. This is the file called `vmlinux` that is generated in the directory
    where Linux is built. In Yocto, you can request that a copy be included in the
    target image and SDK. It is built as a package named `kernel-vmlinux`, which you
    can install like any other, for example, by adding it to the `IMAGE_INSTALL` list.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 内核镜像必须是ELF对象格式，这样GDB才能将符号加载到内存中。这个文件就是在Linux构建目录中生成的`vmlinux`。在Yocto中，你可以要求将它的副本包含到目标镜像和SDK中。它作为名为`kernel-vmlinux`的包构建，你可以像安装其他软件包一样安装它，例如，通过将其添加到`IMAGE_INSTALL`列表中。
- en: 'The file is put into the `sysroot` boot directory, with a name like this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 文件被放入`sysroot`引导目录，文件名大致如下：
- en: '[PRE79]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In Buildroot, you will find `vmlinux` in the directory where the kernel was
    built, which is in `output/build/linux-<version string>/vmlinux`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在Buildroot中，你会在内核构建的目录下找到`vmlinux`，路径为`output/build/linux-<version string>/vmlinux`。
- en: 'You need to tell `kgdb` which serial port to use, either through the kernel
    command line or at runtime via `sysfs`. For the first option, add `kgdboc=<tty>,<baud
    rate>` to the kernel command line:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要告诉`kgdb`使用哪个串行端口，可以通过内核命令行或通过`sysfs`在运行时指定。对于第一个选项，将`kgdboc=<tty>,<baud rate>`添加到内核命令行：
- en: '[PRE80]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: A sample debug session
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个调试会话示例
- en: 'The best way to show you how `kgdb` works is with a simple example. But before
    you can use `kgdb`, you first need to build it. To build `kgdb` and `kdb`, complete
    *Building GDB with Python support*, then perform these steps:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 展示`kgdb`如何工作的最佳方式是通过一个简单的示例。但在你可以使用`kgdb`之前，首先需要构建它。要构建`kgdb`和`kdb`，请完成*构建带有Python支持的GDB*，然后执行以下步骤：
- en: 'Navigate to the directory where you installed Buildroot:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你安装Buildroot的目录：
- en: '[PRE81]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Clean previous build artifacts from the output directory:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输出目录清理之前的构建产物：
- en: '[PRE82]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Comment out the `miniuart-bt` `dtoverlay` from `board/raspberrypi4-64/config_4_64bit.txt`:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`board/raspberrypi4-64/config_4_64bit.txt`中注释掉`miniuart-bt`的`dtoverlay`：
- en: '[PRE83]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Append the following lines to `board/raspberrypi4-64/config_4_64bit.txt`:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行追加到`board/raspberrypi4-64/config_4_64bit.txt`：
- en: '[PRE84]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Activate your saved configuration file:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活你保存的配置文件：
- en: '[PRE85]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Build your saved configuration:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建你保存的配置：
- en: '[PRE86]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Begin customizing your kernel:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始定制你的内核：
- en: '[PRE87]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Enable kernel debugging by navigating to **Kernel hacking** | **Compile-time
    checks and compiler options** | **Debug information** and selecting **Rely on
    the toolchain’s implicit default DWARF version**.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**Kernel hacking** | **编译时检查和编译器选项** | **调试信息**并选择**依赖工具链的默认DWARF版本**来启用内核调试。
- en: Deselect **Reduce debugging information**.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选择**减少调试信息**。
- en: Back out of **Debug information** and select the **Compile the kernel with frame
    pointers** menu.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出**调试信息**，然后选择**用帧指针编译内核**菜单。
- en: 'Back out of **Compile-time checks and compiler options** and drill down into
    **Generic Kernel Debugging Instruments** | **KGDB: kernel debugger**.'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '退出**编译时检查和编译器选项**，并深入到**通用内核调试工具** | **KGDB: 内核调试器**。'
- en: 'Select both **KGDB: use kgdb over the serial console** and **KGDB_KDB: include
    kdb frontend for kgdb**.'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '选择**KGDB: 使用串行控制台上的kgdb**和**KGDB_KDB: 包含kgdb的kdb前端**。'
- en: Back out of **Kernel hacking** and drill down into **Kernel Features**.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出**内核黑客**，并深入到**内核功能**。
- en: Deselect **Randomize the address of the kernel image**.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选择**随机化内核镜像地址**。
- en: Save your changes and exit `linux-menuconfig`.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改并退出`linux-menuconfig`。
- en: 'Rebuild the kernel:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建内核：
- en: '[PRE88]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Delete the microSD card image:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除microSD卡映像：
- en: '[PRE89]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Regenerate the microSD card image:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新生成microSD卡映像：
- en: '[PRE90]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: When the build is done, there should be a bootable `sdcard.img` file in `output/images/`
    that you can write to a microSD card using Etcher. Insert that microSD into your
    target device. Connect a USB-to-TTL serial cable to the Raspberry Pi 4 ([https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead](https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead)).
    Boot the device.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，应该会在`output/images/`目录下生成一个可引导的`sdcard.img`文件，你可以使用Etcher将其写入microSD卡。将microSD卡插入目标设备中。将USB到TTL串行电缆连接到Raspberry
    Pi 4（[https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead](https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead)）。启动设备。
- en: 'Connect the target device to your local network with an Ethernet cable and
    locate its IP address using `arp-scan --localnet`. SSH into the device as `root`
    and enter the password that you set when configuring your image. I specified `temppwd`
    as the `root` password for my `rpi4_64_gdb_defconfig` image. Write the terminal
    name to the `/sys/module/kgdboc/parameters/kgdboc` file:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以太网电缆将目标设备连接到本地网络，使用`arp-scan --localnet`查找其IP地址。以`root`身份SSH登录设备，输入在配置映像时设置的密码。我为我的`rpi4_64_gdb_defconfig`映像指定了`temppwd`作为`root`密码。将终端名称写入`/sys/module/kgdboc/parameters/kgdboc`文件：
- en: '[PRE91]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note that you cannot set the baud rate in this way. If it is the same `tty`
    as the console, then it is set already. If not, use `stty` or a similar program.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你不能通过这种方式设置波特率。如果它与控制台使用的是相同的`tty`，那么它已经被设置。如果不是，请使用`stty`或类似程序。
- en: 'Now you can start GDB on the host, selecting the `vmlinux` file that matches
    the running kernel:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在主机上启动GDB，选择与正在运行的内核匹配的`vmlinux`文件：
- en: '[PRE92]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: GDB loads the symbol table from `vmlinux` and waits for further input.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: GDB从`vmlinux`加载符号表并等待进一步输入。
- en: 'Next, close any terminal emulator that is attached to the console: you are
    about to use it for GDB, and if both are active at the same time, some of the
    debug strings might get corrupted.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，关闭任何连接到控制台的终端模拟器：你将要用它进行GDB调试，如果两个同时活动，一些调试信息可能会被损坏。
- en: 'Now, you can return to GDB and attempt to connect to `kgdb`. However, you will
    find that the response you get from the target remote at this time is unhelpful:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以返回GDB并尝试连接到`kgdb`。然而，你会发现此时从目标远程设备收到的响应并没有帮助：
- en: '[PRE93]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The problem is that `kgdb` is not listening for a connection at this point.
    You need to interrupt the kernel before you can enter into an interactive GDB
    session with it. Unfortunately, just typing *Ctrl + C* in GDB, as you would with
    an application, does not work. You have to force a trap into the kernel by launching
    another shell on the target, via SSH, for example, and writing `g` to `/proc/sysrq-trigger`
    on the target board:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于此时`kgdb`并未监听连接。你需要中断内核，才能进入与其交互式的GDB会话。不幸的是，仅仅在GDB中输入*Ctrl + C*，像操作应用程序那样，并不起作用。你必须通过启动另一个shell（例如，通过SSH连接到目标设备），并向目标板的`/proc/sysrq-trigger`文件写入`g`，强制内核触发一个陷阱：
- en: '[PRE94]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The target stops dead at this point. Now you can connect to `kgdb` via the
    serial device at the host end of the cable:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 目标在这一点上停止了。现在，你可以通过电缆主机端的串行设备连接到`kgdb`：
- en: '[PRE95]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'At last, GDB is in charge. You can set breakpoints, examine variables, look
    at backtraces, and so on. As an example, set a break on `__sys_accept4`:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，GDB掌控了局面。你可以设置断点、检查变量、查看回溯等等。举个例子，在`__sys_accept4`上设置一个断点：
- en: '[PRE96]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now the target comes back to life. Exit out of your SSH session and attempt
    to reconnect to the target device. Reconnecting calls `__sys_accept4` and hits
    the breakpoint:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在目标设备重新启动。退出你的SSH会话并尝试重新连接到目标设备。重新连接会调用`__sys_accept4`并触发断点：
- en: '[PRE97]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'If you have finished the debug session and want to disable `kgdboc`, just set
    the `kgdboc` terminal to null:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了调试会话，并且想禁用`kgdboc`，只需将`kgdboc`终端设置为null：
- en: '[PRE98]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Like attaching to a running process with GDB, this technique of trapping the
    kernel and connecting to `kgdb` over a serial console works once the kernel is
    done booting. But what if the kernel never finishes booting because of a bug?
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 就像用GDB附加到正在运行的进程一样，这种将内核捕获并通过串口控制台连接到`kgdb`的技术，一旦内核启动完成就能工作。但如果因为bug内核一直无法完成启动呢？
- en: Debugging early code
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试早期代码
- en: 'The preceding example works in cases where the code you are interested in is
    executed when the system is fully booted. If you need to get in early, you can
    tell the kernel to wait during boot by adding `kgdbwait` to the command line,
    after the `kgdboc` option:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例适用于系统完全启动后执行的代码。如果你需要在早期介入，可以通过在`kgdboc`选项后将`kgdbwait`添加到命令行来让内核在启动时等待：
- en: '[PRE99]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now, when you boot, you will see this on the console:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你启动时，你将在控制台上看到这个：
- en: '[PRE100]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: At this point, you can close the console and connect from GDB in the usual way.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可以关闭控制台，并通过常规方式从GDB进行连接。
- en: Debugging modules
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试模块
- en: Debugging kernel modules presents an additional challenge because the code is
    relocated at runtime, and so you need to find out at what address it resides.
    The information is presented through `sysfs`. The relocation addresses for each
    section of the module are stored in `/sys/module/<module name>/sections`. Note
    that since ELF sections begin with a dot (`.`), they appear as hidden files, and
    you will have to use `ls -a` if you want to list them. The important ones are
    `.text`, `.data`, and `.bss`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 调试内核模块带来了额外的挑战，因为代码在运行时被重定位，因此你需要找出它所在的地址。这些信息通过`sysfs`提供。每个模块部分的重定位地址存储在`/sys/module/<module
    name>/sections`中。请注意，由于ELF节以点（`.`）开头，因此它们显示为隐藏文件，如果你想列出它们，需要使用`ls -a`。重要的部分有`.text`、`.data`和`.bss`。
- en: 'Take as an example a module named `mbx`:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个名为`mbx`的模块为例：
- en: '[PRE101]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now you can use these numbers in `kgdb` to load the symbol table for the module
    at those addresses:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在`kgdb`中使用这些数字来加载该模块在这些地址处的符号表：
- en: '[PRE102]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Everything should now work as normal: you can set breakpoints and inspect global
    and local variables in the module just as you can in `vmlinux`:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切应该正常工作：你可以像在`vmlinux`中一样设置断点并检查模块中的全局和局部变量：
- en: '[PRE103]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Then, force the device driver to call `mbx_write`, and it will hit the breakpoint:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，强制设备驱动调用`mbx_write`，它会触发断点：
- en: '[PRE104]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: If you already use GDB to debug code in user space, then you should feel right
    at home debugging kernel code and modules with `kgdb`. Let’s look at `kdb` next.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用GDB调试用户空间的代码，那么调试内核代码和模块时使用`kgdb`应该会让你感到非常熟悉。接下来我们来看一下`kdb`。
- en: Debugging kernel code with kdb
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用kdb调试内核代码
- en: Although `kdb` does not have the features of `kgdb` and GDB, it does have its
    uses, and, being selfhosted, there are no external dependencies to worry about.
    `kdb` has a simple command-line interface that you can use on a serial console.
    You can use it to inspect memory, registers, process lists, and `dmesg` and even
    set breakpoints to stop at a certain location.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`kdb`没有`kgdb`和GDB的功能，但它仍然有其用途，而且由于是自托管的，因此不需要担心外部依赖。`kdb`有一个简单的命令行界面，可以在串口控制台上使用。你可以用它来检查内存、寄存器、进程列表和`dmesg`，甚至可以设置断点以在特定位置停下来。
- en: 'To configure your kernel so that you can call `kdb` via a serial console, enable
    `kgdb` as shown previously, and then enable this additional option:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置你的内核，以便通过串口控制台调用`kdb`，请按照之前的步骤启用`kgdb`，然后启用这个额外的选项：
- en: '`CONFIG_KGDB_KDB` in **Kernel hacking** | **Generic Kernel Debugging Instruments**
    | **KGDB: kernel debugger** | **KGDB_KDB: include kdb frontend for kgdb**'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kernel hacking** | **Generic Kernel Debugging Instruments** | **KGDB: kernel
    debugger** | **KGDB_KDB: include kdb frontend for kgdb**中的`CONFIG_KGDB_KDB`'
- en: 'Now, when you force the kernel into a trap, instead of entering into a GDB
    session, you will see the `kdb` shell on the console:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你强制让内核进入陷阱时，控制台上将显示`kdb`的shell，而不是进入GDB会话：
- en: '[PRE105]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'There are quite a few things you can do in the `kdb` shell. The `help` command
    will print all of the options. Here is an overview:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `kdb` shell 中，你可以做很多事情。`help` 命令会列出所有选项。以下是概览：
- en: '**Getting information**:'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取信息**：'
- en: '`ps`: Displays active processes.'
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps`：显示活动进程。'
- en: '`ps A`: Displays all processes.'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps A`：显示所有进程。'
- en: '`lsmod`: Lists modules.'
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lsmod`：列出模块。'
- en: '`dmesg`: Displays the kernel log buffer.'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dmesg`：显示内核日志缓冲区。'
- en: '**Breakpoints**:'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断点**：'
- en: '`bp`: Sets a breakpoint.'
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bp`：设置断点。'
- en: '`bl`: Lists breakpoints.'
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bl`：列出断点。'
- en: '`bc`: Clears a breakpoint.'
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bc`：清除断点。'
- en: '`bt`: Prints a backtrace.'
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bt`：打印回溯信息。'
- en: '`go`: Continues execution.'
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go`：继续执行。'
- en: '**Inspect memory and registers**:'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查内存和寄存器**：'
- en: '`md`: Displays memory.'
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`md`：显示内存。'
- en: '`rd`: Displays registers.'
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rd`：显示寄存器内容。'
- en: 'Here is a quick example of setting a breakpoint:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是设置断点的一个简短示例：
- en: '[PRE106]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The kernel returns to life and the console shows the normal shell prompt. If
    you attempt to reconnect to the target, it hits the breakpoint and enters `kdb`
    again:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 内核恢复运行，控制台显示正常的 shell 提示符。如果你尝试重新连接到目标，它会触发断点并再次进入 `kdb`：
- en: '[PRE107]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '`kdb` is not a source-level debugger, so you can’t see the source code or single-step.
    However, you can display a backtrace using the `bt` command, which is useful for
    getting an idea of program flow and call hierarchy.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`kdb` 不是一个源级调试器，所以你无法查看源代码或逐步执行。然而，你可以使用 `bt` 命令显示回溯信息，这对于了解程序流程和调用层次结构非常有用。'
- en: Looking at an Oops
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看 Oops 信息
- en: When the kernel performs an invalid memory access or executes an illegal instruction,
    a kernel **Oops** message is written to the kernel log. The most useful part of
    this is the backtrace, and I want to show you how to use the information there
    to locate the line of code that caused the fault. I will also address the problem
    of preserving Oops messages if they cause the system to crash.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核执行无效的内存访问或非法指令时，内核 **Oops** 消息会被写入内核日志。最有用的部分是回溯信息，我将展示如何使用其中的信息来定位导致故障的代码行。我还会讨论如何在
    Oops 信息导致系统崩溃时保留这些信息。
- en: 'This Oops message was generated by writing to the mailbox driver in `MELD/Chapter19/mbx-driver-oops`:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 该 Oops 消息是通过写入 `MELD/Chapter19/mbx-driver-oops` 中的邮箱驱动程序生成的：
- en: '[PRE108]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The line of the Oops that reads `pc` is at `mbx_write+0x2c/0xf8 [mbx]` and
    tells you most of what you want to know: the last instruction was in the `mbx_write`
    function of a kernel module named `mbx`. Furthermore, it was at offset `0x2c`
    bytes from the start of the function, which is `0xf8` bytes long.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 该 Oops 信息中的 `pc` 行显示为 `mbx_write+0x2c/0xf8 [mbx]`，它告诉你大部分你想知道的内容：最后一条指令是在名为
    `mbx` 的内核模块的 `mbx_write` 函数中。更进一步，它位于该函数开始处偏移 `0x2c` 字节的位置，而该函数的总长度为 `0xf8` 字节。
- en: 'Next, take a look at the backtrace:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，查看回溯信息：
- en: '[PRE109]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: In this case, we don’t learn much more, merely that `mbx_write` was called from
    the virtual filesystem function, `_vfs_write`.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们并没有学到太多，仅仅是 `mbx_write` 是从虚拟文件系统函数 `_vfs_write` 被调用的。
- en: 'It would be very nice to find the line of code that relates to `mbx_write+0x2c`,
    for which we can use the GDB command `disassemble` with the `/s` modifier so that
    it shows source and assembler code together. In this example, the code is in the
    `mbx.ko` module, so we load that into `gdb`:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能找到与 `mbx_write+0x2c` 相关的代码行，那将非常有帮助。我们可以使用 GDB 命令 `disassemble` 并加上 `/s`
    修饰符，这样它会显示源代码和汇编代码。此示例中，代码位于 `mbx.ko` 模块中，因此我们将其加载到 `gdb` 中：
- en: '[PRE110]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'You can see from *line 97* that `m` has the type struct `mbx_data *`. Here
    is the place where that structure is defined:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *line 97* 可以看到，`m` 的类型是结构体 `mbx_data *`。这是该结构体定义的位置：
- en: '[PRE111]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'So, it looks like the `m` variable is a null pointer, and that is what is causing
    the Oops. Looking at the code where `m` is initialized, we can see that there
    is a line missing. By initializing the pointer, as shown in the following code
    block, the Oops is eliminated:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 `m` 变量是一个空指针，这就是导致 Oops 的原因。查看 `m` 初始化的代码，我们可以看到少了一行。通过初始化指针，如以下代码块所示，Oop
    错误被消除了：
- en: '[PRE112]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Not every Oops is this easy to pinpoint, especially if it occurs before the
    contents of the kernel log buffer can be displayed.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是每个 Oops 都这么容易定位，特别是当它发生在内核日志缓冲区内容还未显示时。
- en: Preserving the Oops
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留 Oops 信息
- en: Decoding an Oops is only possible if you can capture it in the first place.
    If the system crashes during boot before the console is enabled, or after a suspend,
    you won’t see it. There are mechanisms to log kernel Oops and messages to an MTD
    partition or to persistent memory, but here is a simple technique that works in
    many cases and needs little prior thought.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 解码 Oops 只有在你能够捕获它的情况下才可能。如果系统在启动时崩溃，且在控制台启用之前，或在挂起之后，你将无法看到它。虽然有机制可以将内核 Oops
    和消息记录到 MTD 分区或持久内存中，但这里有一种简单的技术，在许多情况下有效，且不需要太多预先考虑。
- en: 'So long as the contents of memory are not corrupted during a reset (and usually
    they are not), you can reboot into the bootloader and use it to display memory.
    You need to know the location of the kernel log buffer, remembering that it is
    a simple ring buffer of text messages. The symbol is `__log_buf`. Look this up
    in `System.map` for the kernel:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 只要内存的内容在重置过程中没有被破坏（通常不会），你可以重启进入引导加载程序并使用它来显示内存。你需要知道内核日志缓冲区的位置，记住它是一个简单的文本消息环形缓冲区。符号是
    `__log_buf`。你可以在内核的 `System.map` 中查找这个符号：
- en: '[PRE113]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '**IMPORTANT NOTE**'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: From Linux 3.5 onward, there is a 16-byte binary header for each line in the
    kernel log buffer that encodes a timestamp, a log level, and other things. There
    is a discussion about it in the Linux weekly news entitled *Toward more reliable
    logging*, at [https://lwn.net/Articles/492125/](https://lwn.net/Articles/492125/).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Linux 3.5 版本开始，内核日志缓冲区中的每一行都包含一个 16 字节的二进制头部，编码了时间戳、日志级别以及其他信息。关于这一点，有一篇 Linux
    每周新闻的讨论，标题为 *Towards more reliable logging*，链接为 [https://lwn.net/Articles/492125/](https://lwn.net/Articles/492125/)。
- en: In this section, we examined how kernel code can be debugged at the source level
    using `kgdb`. Then we looked at setting breakpoints and printing backtraces inside
    the `kdb` shell. Lastly, we learned how to read kernel Oops messages either from
    a console using `dmesg` or the U-Boot command line.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何使用 `kgdb` 在源代码级别调试内核代码。接着我们研究了在 `kdb` shell 中设置断点和打印回溯信息。最后，我们学习了如何通过
    `dmesg` 或 U-Boot 命令行读取内核 Oops 消息。
- en: Summary
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Knowing how to use GDB for interactive debugging is a useful tool in the embedded
    system developer’s tool chest. It is a stable, well-documented, and well-known
    entity. It has the ability to debug remotely by placing an agent on the target,
    be it `gdbserver` for applications or `kgdb` for kernel code, and although the
    default command-line user interface takes a while to get used to, there are many
    alternative frontends. The three I mentioned were TUI, DDD, and Visual Studio
    Code. Eclipse is another popular frontend that supports debugging with GDB by
    way of the CDT plugin. I will refer you to the references in the *Further study*
    section for information on how to configure CDT to work with a cross toolchain
    and connect to a remote device.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 学会如何使用 GDB 进行交互式调试是嵌入式系统开发者工具箱中的一项有用工具。它是一个稳定、文档齐全且知名的工具。它具有通过在目标上放置代理来进行远程调试的能力，无论是用于应用程序的
    `gdbserver` 还是用于内核代码的 `kgdb`，虽然默认的命令行用户界面需要一些时间来适应，但也有许多替代的前端。我提到的三种前端是 TUI、DDD
    和 Visual Studio Code。Eclipse 是另一个流行的前端，它通过 CDT 插件支持与 GDB 一起调试。我会在 *Further study*
    部分的参考文献中提供如何配置 CDT 以支持交叉工具链并连接到远程设备的信息。
- en: A second and equally important way to approach debugging is to collect crash
    reports and analyze them offline. In this category, we looked at application core
    dumps and kernel Oops messages.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种同样重要的调试方法是收集崩溃报告并离线分析它们。在这个类别中，我们研究了应用程序核心转储和内核 Oops 消息。
- en: However, this is only one way of identifying flaws in programs. In the next
    chapter, I will talk about profiling and tracing as ways of analyzing and optimizing
    programs.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只是识别程序缺陷的一种方式。在下一章中，我将讨论性能分析和跟踪作为分析和优化程序的方式。
- en: Further study
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步学习
- en: '*The Art of Debugging with GDB, DDD, and Eclipse*, by Norman Matloff and Peter
    Jay Salzman'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用 GDB、DDD 和 Eclipse 调试的艺术》*，作者：Norman Matloff 和 Peter Jay Salzman'
- en: '*GDB Pocket Reference*, by Arnold Robbins'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《GDB 口袋参考》*，作者：Arnold Robbins'
- en: '*Python Interpreter in GNU Debugger*, by crazyguitar – [https://www.pythonsheets.com/appendix/python-gdb.html](https://www.pythonsheets.com/appendix/python-gdb.html%0D%0A)'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python 解释器在 GNU 调试器中的应用》*，作者：crazyguitar – [https://www.pythonsheets.com/appendix/python-gdb.html](https://www.pythonsheets.com/appendix/python-gdb.html%0D%0A)'
- en: '*Extending GDB with Python*, by Lisa Roach – [https://www.youtube.com/watch?v=xt9v5t4_zvE](https://www.youtube.com/watch?v=xt9v5t4_zvE%0D%0A)'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《用 Python 扩展 GDB》*，作者：Lisa Roach – [https://www.youtube.com/watch?v=xt9v5t4_zvE](https://www.youtube.com/watch?v=xt9v5t4_zvE%0D%0A)'
- en: '*Getting to grips with Eclipse: cross compiling* – [https://2net.co.uk/tutorial/eclipse-cross-compile](https://2net.co.uk/tutorial/eclipse-cross-compile%0D%0A)'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*掌握 Eclipse：交叉编译* – [https://2net.co.uk/tutorial/eclipse-cross-compile](https://2net.co.uk/tutorial/eclipse-cross-compile%0D%0A)'
- en: '*Getting to grips with Eclipse: remote access and debugging* – [https://2net.co.uk/tutorial/eclipse-rse](https://2net.co.uk/tutorial/eclipse-rse)'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*掌握 Eclipse：远程访问和调试* – [https://2net.co.uk/tutorial/eclipse-rse](https://2net.co.uk/tutorial/eclipse-rse)'
