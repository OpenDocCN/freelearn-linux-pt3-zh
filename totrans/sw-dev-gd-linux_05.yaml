- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Introducing Files
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件简介
- en: 'In Linux, everything is – or can be represented as – a file. Files are organized
    into a filesystem, which is just a hierarchy of files and directories (directories
    are just a special kind of file). As a developer, just about everything you do
    on a Linux system will require knowledge about files: writing and copying source
    code, building Docker images, application logging, configuring dependencies, and
    more.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，一切都是——或者可以表示为——一个文件。文件被组织成一个文件系统，文件系统其实就是一个由文件和目录（目录只是特殊类型的文件）组成的层级结构。作为开发人员，你在
    Linux 系统上几乎做的每一件事都需要了解文件：编写和复制源代码、构建 Docker 镜像、应用日志、配置依赖关系等。
- en: In this chapter, we’ll cover the details of files in Linux. You’ll learn about
    the difference between plaintext files and binary files, which are the two most
    common types of file content you’ll be working with. We’ll show you how those
    are laid out and organized into a filesystem “tree” in Linux, before diving into
    the practical commands you’ll need to create, modify, move, and edit files. Then
    we’ll complete our tour of the basics with a practical introduction to file editing,
    using the most commonly available command-line text editors.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将详细介绍 Linux 中的文件。你将了解纯文本文件和二进制文件之间的区别，这两种文件内容类型是你最常接触的。我们会向你展示这些文件如何在
    Linux 中组织成一个文件系统“树”，然后再深入介绍你需要用到的命令，帮助你创建、修改、移动和编辑文件。接着，我们将通过介绍最常用的命令行文本编辑器，完成文件编辑的基本知识讲解。
- en: 'However, in this chapter, we don’t stop at the basics. Linux files are one
    topic where it pays (sometimes quite literally) to dive a bit deeper into some
    advanced knowledge. After all, “working with files” is one of the primary things
    you’ll be doing on Linux as a developer: writing and reading source code and configuration
    files, searching for specific file content, copying and moving log files around,
    and more. The more efficient you are at these basics, the more competent you’ll
    be as a well-rounded developer who doesn’t have to google basic Linux commands
    over and over, or get embarrassingly stuck in a command-line text editor during
    a troubleshooting Zoom call with your peers.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中，我们不仅仅停留在基础知识上。Linux 文件是一个值得深入了解的主题，掌握一些高级知识有时会带来实际的好处（有时甚至是直接的经济回报）。毕竟，“处理文件”是你在
    Linux 上作为开发人员最常做的事情之一：编写和读取源代码和配置文件、查找特定的文件内容、复制和移动日志文件等等。你在这些基础操作上越高效，作为一个全面的开发人员，你就越能避免不断在
    Google 上查找基本的 Linux 命令，或者在和同事的故障排除 Zoom 通话中尴尬地卡在命令行文本编辑器里。
- en: First, we’ll talk about searching for files in the filesystem tree and finding
    specific content or patterns inside individual files. Then, we’ll talk about special
    files and alternate filesystems that you’re likely to come across, and what you
    need to know to work with them effectively.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论如何在文件系统树中搜索文件，并在单个文件中查找特定内容或模式。接下来，我们将讨论你可能会遇到的特殊文件和替代文件系统，以及你需要了解的有效工作方法。
- en: 'By the end, you’ll know about:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到最后，你将了解：
- en: The many file types you might encounter, and what they’re used for
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能遇到的各种文件类型，以及它们的用途
- en: The most important kinds of file data you’ll need to work with
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要处理的最重要的文件数据类型
- en: The Linux filesystem and the commands you’ll use to work with it
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 文件系统和你将使用的相关命令
- en: File editing basics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件编辑基础
- en: Some common problems and how to avoid them
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些常见问题及如何避免它们
- en: There’s a lot of content in this chapter, and it’s one of the most important
    foundations for the rest of your Linux skills. Make sure you understand each part
    before moving on – you don’t have to memorize everything on your first readthrough,
    but try to get as much practical experience as you can in your own Linux environment
    while working through this chapter. There’s a tangible payoff to knowing this
    stuff when you’re troubleshooting real-world problems or interviewing for a job.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容丰富，是你学习 Linux 其他技能的基础之一。确保你在继续之前理解每一部分——你不必在第一次阅读时就记住所有内容，但尽量在自己的 Linux
    环境中尽可能多地获得实践经验。掌握这些知识，对于你在解决现实问题或面试时将有实际的回报。
- en: 'Files on Linux: the absolute basics'
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 中的文件：绝对基础
- en: 'In order to break up the larger topic of files on Linux, let’s cover some of
    the absolute basics that you probably already have some intuition of: plaintext
    files and binary files. We’ll also cover a practical error that you might see
    if you move Windows files to a Unix system, or vice versa.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地讲解Linux中文件的更大主题，让我们先讲一些你可能已经有直觉的绝对基础：纯文本文件和二进制文件。我们还将讨论在将Windows文件移动到Unix系统，或反之时，可能会遇到的一个实际错误。
- en: Plaintext files
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯文本文件
- en: One of the simplest forms of text files you’ll encounter is the mighty plaintext
    file. While historically they were ASCII files, they are now typically UTF-8 encoded.
    You might come across other file encodings, but this is rare as they are generally
    considered obsolete.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你会遇到的最简单的文本文件形式之一就是强大的纯文本文件。虽然它们在历史上是ASCII文件，但现在通常是UTF-8编码的。你可能会遇到其他文件编码，但这种情况很少见，因为它们通常被认为是过时的。
- en: What is a binary file?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是二进制文件？
- en: Unix doesn’t differentiate between binary and text files, the way many other
    operating systems do. All files can be streamed through pipes, edited, and appended
    to. A file is just a file. When a file is set to be executable, Unix will do its
    best to execute it, either succeeding in the case of **ELF** (**Executable and
    Linkable Format**, probably the most widely used executable format today) or failing
    – for example, when trying to execute an image or audio file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Unix不像许多其他操作系统那样区分二进制文件和文本文件。所有文件都可以通过管道流传输、编辑和附加。文件就是文件。当文件被设置为可执行时，Unix会尽力执行它，要么成功（如**ELF**格式文件，可能是今天最广泛使用的可执行格式），要么失败——例如，尝试执行一个图像或音频文件时。
- en: This simple mechanism opens up some amazing possibilities. For example, executables
    can be piped through a compression utility, then a network tunnel (such as SSH),
    before being decompressed and written back into a file – all in one command, without
    any temporary files.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的机制开辟了一些令人惊讶的可能性。例如，执行文件可以通过压缩工具，然后通过网络隧道（如SSH）传输，最后解压并写回到文件中——这一切都在一个命令中完成，而无需任何临时文件。
- en: It also means, however, that you should be careful to avoid creating a situation
    where random files, for example, ones uploaded or modified by users of a website
    (including log files!), have any possibility of being executed. This can lead
    to serious security issues.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也意味着，你应该小心避免创建一个情况，例如，网站用户上传或修改的随机文件（包括日志文件！）有任何可能被执行的机会。这可能导致严重的安全问题。
- en: Line endings
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行结束符
- en: While Unix files, especially text files, function similarly to files on other
    operating systems, it is worth mentioning that Windows (and DOS), among others,
    uses a different line-ending character, which can produce errors in many programs
    that use those text files. Although this is only the case for files that were
    created on one kind of system and then copied to another (for example, moving
    a file from Linux to DOS), it’s worth knowing about.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Unix文件，尤其是文本文件，和其他操作系统上的文件功能相似，但值得一提的是，Windows（和DOS）等系统使用不同的行结束符字符，这可能在许多使用这些文本文件的程序中导致错误。虽然这种情况只会发生在将一种系统上创建的文件复制到另一种系统时（例如，从Linux迁移到DOS），但值得了解。
- en: The reasons for the different line endings are historical, and many tools (for
    example, Git and various text editors) will automatically handle that difference
    for you. However, in rare circumstances, you might have to convert files manually.
    There are famous commands like `dos2unix` to do so, but these have to be manually
    installed on most Unix-like operating systems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的行结束符的原因是历史性的，许多工具（例如Git和各种文本编辑器）会自动为你处理这种差异。然而，在极少数情况下，你可能需要手动转换文件。有一些著名的命令，如`dos2unix`，可以做到这一点，但这些命令通常需要手动安装在大多数类Unix操作系统上。
- en: There are, however, some methods to convert them using more traditional utilities.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然有一些方法可以使用更传统的工具来转换它们。
- en: 'Using `sed`: `sed ''s/^M$//'' original_dos_file > unix_file`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sed`：`sed 's/^M$//' original_dos_file > unix_file`
- en: 'Using `tr`: `tr -d ''\r'' < original_dos_file > unix_file`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tr`：`tr -d '\r' < original_dos_file > unix_file`
- en: 'In place, using `perl`: `perl -pi -e ''s/\r\n/\n/g'' original_file`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`perl`就地替换：`perl -pi -e 's/\r\n/\n/g' original_file`
- en: 'Now that we’ve talked about the crucial basic concepts you need to know to
    understand files on Unix-like systems, let’s talk about the context that all of
    these files actually exist in: the Linux filesystem.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了理解类Unix系统中文件所需的基本概念，让我们来谈谈这些文件实际上存在的上下文：Linux文件系统。
- en: The filesystem tree
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统树
- en: 'The **Filesystem Hierarchy Standard** (**FHS**) describes the conventional
    directory layout of Unix-like systems. Linux conforms to this standard, essentially
    making it “the official folder structure of Linux.” The FHS is a standardized
    tree structure where every file and directory stems from the root (a directory
    simply named “`/`"). This hierarchy is crucial: although there’s a place for end-users
    to go wild with their own directory structure, every single subdirectory inside
    of `/` (the root directory) has a specific purpose.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件系统层次结构标准**（**FHS**）描述了类 Unix 系统的常规目录布局。Linux 遵循这一标准，实际上使其成为“Linux 的官方文件夹结构”。FHS
    是一个标准化的树形结构，其中每个文件和目录都源自根目录（一个名为“`/`”的目录）。这个层次结构至关重要：虽然有一个位置供最终用户自由创建自己的目录结构，但`/`（根目录）中的每个子目录都有其特定的用途。'
- en: 'The basic layout of this filesystem hierarchy doesn’t take long to learn, and
    by investing a few minutes now, you’ll develop an intuition for where things go
    – whether they’re application binaries, logs, data files, or external devices
    that your code needs access to. In other words, it eases both development and
    troubleshooting: when you know where things *should* be, you spend less time confused
    and unsure of where to look during an incident. Additionally, this knowledge is
    required when it comes to writing your own scripts and doing the light system
    administration tasks expected of a senior developer.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件系统层次结构的基本布局并不难学习，通过现在投入几分钟，你会对文件的位置产生直觉——无论它们是应用程序二进制文件、日志、数据文件，还是你的代码需要访问的外部设备。换句话说，它既有助于开发，也有助于故障排除：当你知道文件“应该”在哪里时，你就能减少在事故发生时迷茫和不确定该在哪里寻找的时间。此外，这些知识对于编写自己的脚本和进行高级开发者预期的轻量级系统管理任务是必需的。
- en: 'Here are some of the important places in the filesystem that you’ll often see
    referenced, or have to use yourself:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的是你经常会看到或需要自己使用的一些重要文件系统位置：
- en: '`/etc`: System and software configuration files go here, organized into many
    subdirectories.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc`：系统和软件配置文件存放在这里，按多个子目录进行组织。'
- en: '`/bin` and `/sbin`: System binaries go here. Don’t mess with these.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin` 和 `/sbin`：系统二进制文件存放在这里。不要随意更改这些文件。'
- en: '`/usr/bin` and `/usr/local/bin`: Your installed software and your own binaries
    go here, so that anyone on the system can see and execute them.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/bin` 和 `/usr/local/bin`：你的已安装软件和你自己的二进制文件存放在这里，系统中的任何人都可以看到并执行它们。'
- en: '`/var/log` and `/var/lib`: `/var` contains variable data, things that are prone
    to change while the system is running, such as application logs (`/var/log`) and
    dynamic libraries (`/var/lib`), files, and other state for running applications.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var/log` 和 `/var/lib`：`/var`包含可变数据，这些数据在系统运行时容易发生变化，例如应用日志（`/var/log`）和动态库（`/var/lib`）、文件及其他运行中的应用状态。'
- en: '`/var/lib/systemd`: One of several places on the filesystem that contain `systemd`
    configuration.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var/lib/systemd`：文件系统中包含`systemd`配置的多个位置之一。'
- en: '`/etc/systemd/system`: A good place for custom system unit files, if you’re
    creating services.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/systemd/system`：这是放置自定义系统单元文件的好地方，如果你正在创建服务的话。'
- en: '`/dev`: A special filesystem used to represent hardware devices.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev`：用于表示硬件设备的特殊文件系统。'
- en: '`/proc`: A special filesystem used to query or change system state.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc`：一个特殊的文件系统，用于查询或更改系统状态。'
- en: Basic filesystem operations
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的文件系统操作
- en: 'It’s time to dive into the foundational Unix commands you’ll use every single
    day as a developer. This set of commands will allow you to accomplish a range
    of basic command-line tasks you need to do on any system you interact with. Once
    you have learned and practiced the commands in this chapter, you’ll be able to
    do things like:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候深入了解你作为开发者每天都会用到的基础 Unix 命令了。这些命令将使你能够完成任何系统中需要执行的一系列基本命令行任务。一旦你学会并练习了本章中的命令，你将能够做一些事情，比如：
- en: Follow your application logs in real time.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时查看你的应用日志。
- en: Fix a broken configuration file to get your application working.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复一个损坏的配置文件，让你的应用正常运行。
- en: Move from one directory to another in a Git repository on your local macOS development
    machine.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地 macOS 开发机器上的 Git 仓库中从一个目录切换到另一个目录。
- en: Let’s get started with listing a directory. Make sure you’re logged in to a
    Linux or Unix system (Ubuntu or macOS is fine), and have the Terminal application
    open, ready to follow along.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从列出一个目录开始。确保你已登录到一个 Linux 或 Unix 系统（Ubuntu 或 macOS 均可），并打开终端应用程序，准备跟随操作。
- en: ls
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ls
- en: 'List a file or directory. This command is similar to “opening a folder” in
    a graphical user interface. It lists the contents of the directory it’s given.
    By default, it uses your current directory:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, my shell’s current location is the `/home/steve` directory,
    which contains a single file (`my_document.txt`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'You can ask `ls` to list any directory path on the system, though, by passing
    the directory as an argument:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For a more orderly output, you may want to add the “`-l`" option. This will
    give you a “long listing,” which means a single file or directory per line, along
    with extra information.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In short, the `ls` command is how you “look around” on a Unix filesystem.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: pwd
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Short for “print working directory.” This shows “where you are” on the filesystem,
    in the context of your current shell session. If I’m logged in to a Linux system
    as the `steve` user, and I’m in my home directory, I can expect to see `pwd` print
    something like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: cd
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Change the current working directory in your shell. The commands you run after
    using this command will run from the perspective of your new, changed location
    on the filesystem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example directory:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you’re sitting in the `Desktop` directory, but then change to the `documents`
    directory with `cd documents`, you’ll get a different listing from that new perspective
    when using the `ls` command. Let’s see this in action:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we can see our surroundings (`ls`), move around on the filesystem (`cd`),
    and find out where we are (`pwd`), let’s get into actually affecting the filesystem
    by creating and modifying files.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: touch
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This operation is written as `touch filepath`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on whether the filepath you give it already exists or not, this `touch`
    command will do one of two things:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'If a file does not already exist at that path, `touch` will create it:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If a file *does* exist at that path, `touch` will update the access and modification
    times for that file:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that the only thing that’s changed is the modification time shown in
    the long listing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: less
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`less` is what’s known as a “pager” – a program that allows you to view file
    content, one screen (page) at a time:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It’s interactive – once you’re using it to view a file, you can:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Scroll up or down, line by line, using your mouse wheel or arrow keys.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scroll down a whole page with **SPACE**.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search with */* (enter your search pattern) *RETURN*.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go to the next match: **n**.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use **q** to quit the program.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practice using it for a minute or two, and you’ll be fine.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: tail
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`tail` is used to view the last few lines of a file.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `-f` (follow) option for tail is very useful for live-streaming logs to
    your terminal:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Use **q** to quit out of tail.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: mv
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`mv` (move) is used to move and rename files.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Moving
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine you have a file named `somefile.txt`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Provided you’re sitting in the same directory as the file, here’s how you’d
    move it to the `/var/log` directory, without renaming it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Renaming
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you want to rename that file to `foobar`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That’s it!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: cp
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To copy files and directories, use the `cp` command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制文件和目录，请使用`cp`命令：
- en: '`cp file destination` copies a file named `file` to a destination filepath,
    `destination`. The most commonly used option is `-r`, or `–recursive`; if you’re
    copying a directory, this will copy everything inside as well.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp file destination` 将名为`file`的文件复制到目标文件路径`destination`。最常用的选项是`-r`，或者`–recursive`；如果你复制的是一个目录，它将复制其中的所有内容。'
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: mkdir
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mkdir
- en: 'Create a new, empty directory named `directoryname` with:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个新的空目录，命名为`directoryname`：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A useful option is `-p`, which allows you to create nested directories in a
    single command. For example, if you want to create a `Documents` directory that
    contains a directory named `school`, which in turn contains a directory named
    `reports`, you could run the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的选项是`-p`，它允许你在一个命令中创建嵌套目录。例如，如果你想创建一个包含名为`school`的目录的`Documents`目录，而`school`目录中又包含一个名为`reports`的目录，你可以运行以下命令：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: rm
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: rm
- en: '`rm` removes (deletes) files and directories:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`rm` 删除（删除）文件和目录：'
- en: '`rm filename` deletes a file named `filename`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm filename` 删除名为`filename`的文件。'
- en: '`rm -r directoryname` will delete a directory named `directoryname`, and every
    file and directory inside of it, recursively.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm -r directoryname` 将删除名为`directoryname`的目录，以及其中的所有文件和目录，递归地。'
- en: There’s a separate command for deleting empty directories named `rmdir`, but
    it’s usually only used in scripts where developers are being careful to limit
    the blast radius of an unintentional deletion.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 删除空目录有一个单独的命令，名为`rmdir`，但它通常只在脚本中使用，开发人员小心地限制不小心删除的范围。
- en: Editing files
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑文件
- en: Whether it’s updating configuration files, creating new Linux services, or taking
    notes during a troubleshooting session, your work on Linux is occasionally going
    to require you to edit files on the command line. We’re going to cover command-line
    file editing in detail in *Chapter 6*, *Editing Files on the Command Line*, but
    we’ll give you a very brief overview here.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是更新配置文件、创建新的Linux服务，还是在故障排除期间做笔记，你在Linux上的工作偶尔会要求你在命令行上编辑文件。我们将在*第六章*《命令行编辑文件》中详细介绍命令行文件编辑，但在这里我们会给你一个非常简短的概述。
- en: 'If you’re limited to a command-line-only environment, there are a few CLI text
    editors you might use:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只能使用命令行环境，可能会使用一些CLI文本编辑器：
- en: '**nano**: Almost always installed or available; easy to use'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nano**：几乎总是已安装或可用；易于使用'
- en: '**vi**: Installed almost everywhere; takes a bit of getting used to'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vi**：几乎到处都已安装；需要一点时间适应'
- en: '**vim**: Easy to install everywhere; more full-featured than `vi`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vim**：在所有地方都容易安装；比`vi`功能更全面'
- en: 'If any of these are not installed, you can install them via your package manager.
    For example, if you’re using Ubuntu Linux, that’ll be a command like `sudo apt-get
    install nano` (or substitute `nano` for `vim`). We’ll dive deeper into package
    management commands in *Chapter 9*, *Managing Installed Software*. Regardless
    of which editor you choose, you’ll edit a file by simply typing `[$EDITOR filename]`
    on the command line; for example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些编辑器没有安装，你可以通过你的包管理器安装它们。例如，如果你使用的是Ubuntu Linux，可以使用类似`sudo apt-get install
    nano`的命令（或将`nano`替换为`vim`）。我们将在*第九章*《管理已安装的软件》中深入探讨包管理命令。不管你选择哪个编辑器，你只需在命令行中输入`[$EDITOR
    filename]`来编辑文件；例如：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the file exists, you’ll be able to edit it in your editor.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件存在，你将能够在编辑器中编辑它。
- en: If it doesn’t, but the directory exists, you’ll create a new file at that path
    the first time you save it in the editor.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不存在，但目录存在，你将在编辑器中第一次保存时，在该路径下创建一个新文件。
- en: If the directory doesn’t exist, you might be able to edit the file, but the
    editor won’t be able to write it to the filesystem without a few extra steps.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目录不存在，你可能仍然能够编辑该文件，但编辑器在没有一些额外步骤的情况下无法将其写入文件系统。
- en: In the next chapter, *Chapter 6*, *Editing Files on the Command Line*, we’re
    going to dive much more deeply into the practical skills involved in file editing
    on the Linux command line. If you absolutely need to edit a file before you finish
    this chapter, just type nano `/path/to/the/file` and follow the on-screen cheatsheet
    to save and quit. In the meantime, let’s learn about the many kinds of files you’ll
    run into as a developer on Linux.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，*第六章*《命令行编辑文件》中，我们将深入探讨在Linux命令行上编辑文件的实际技能。如果你在完成本章之前绝对需要编辑文件，只需输入`nano
    /path/to/the/file`并按照屏幕上的备忘单保存并退出。与此同时，让我们了解一下你作为Linux开发者会遇到的各种文件类型。
- en: File types
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件类型
- en: We’ve already covered “regular” files, such as plaintext files or the binary
    data in your image files and executable programs. But there are several other
    file types that you’ll need to know how to recognize and work with in Linux. Whether
    you’re looking for the USB stick or keyboard you just plugged into your machine,
    creating a link that points to a file, or inspecting the network sockets that
    a web process has opened, you’ll want to know a bit about *all* of these.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了“常规”文件，比如纯文本文件或图像文件中的二进制数据以及可执行程序。但是，在 Linux 中，还有几种其他类型的文件，你需要知道如何识别并与之操作。无论你是在寻找你刚刚插入计算机的
    USB 闪存盘或键盘，创建指向文件的链接，还是检查一个 Web 进程打开的网络套接字，你都需要了解这些 *所有* 文件类型。
- en: 'Here are all of the Linux file types and what they’re used for:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是所有 Linux 文件类型及其用途：
- en: '**Regular file**: This is the most common file type, containing text or binary
    data. As a software engineer, you’ll encounter regular files in nearly every programming
    task, whether you’re writing code, editing configuration files, or executing programs.
    A typical example that you might see in a long listing could be a source code
    file like:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常规文件**：这是最常见的文件类型，包含文本或二进制数据。作为软件工程师，你会在几乎每个编程任务中遇到常规文件，无论是编写代码、编辑配置文件还是执行程序。在长列表中，你可能会看到的典型示例是像这样的源代码文件：'
- en: '[PRE18]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Directory**: Directories are special files that are used to organize other
    files and directories. You’re already familiar with directories if you’ve ever
    used Windows or macOS (where they’re called “folders”); they contain other files
    and directories. In a long listing, a directory like `/etc` will appear as:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**：目录是用于组织其他文件和目录的特殊文件。如果你曾经使用过 Windows 或 macOS（在这些系统中，它们被称为“文件夹”），那么你已经熟悉了目录；它们包含其他文件和目录。在长列表中，像
    `/etc` 这样的目录将显示为：'
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Block special**: This special file type provides buffered access to hardware
    devices, which makes them particularly useful for devices like hard disks where
    data is accessed in large, fixed-size blocks. You’ll rarely work with these directly,
    except when mounting filesystems. An example could be a hard disk partition, shown
    as:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块特殊文件**：这种特殊文件类型提供缓冲访问硬件设备，这使得它们特别适用于像硬盘这样的设备，因为数据是以大块、固定大小的块进行访问的。除非是在挂载文件系统时，你很少会直接使用这些文件。一个示例可能是一个硬盘分区，显示为：'
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This represents a block device with read and write permissions for the owner
    and group.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这表示一个块设备，具有所有者和组的读写权限。
- en: '**Character special**: Similar to block files, character files provide unbuffered,
    raw access to hardware devices, but they are designed for devices where data is
    not block-oriented, like keyboards or mice. You’ll never need to worry about these,
    although you may occasionally use them in the course of your work (for example,
    `/dev/urandom`, `/dev/null`, or `/dev/zero`). A character device like a terminal
    might appear in a long listing as:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符特殊文件**：与块文件类似，字符文件提供无缓冲的、原始的硬件设备访问，但它们是为数据不是以块方式组织的设备设计的，比如键盘或鼠标。你通常不需要关心这些文件，尽管在工作中你可能偶尔会用到它们（例如，`/dev/urandom`、`/dev/null`
    或 `/dev/zero`）。像终端这样的字符设备在长列表中可能会显示为：'
- en: '[PRE21]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**FIFO special (“named pipes”)**: Named pipes, not to be confused with the
    anonymous pipes frequently used in shells, are used for interprocess communication.
    You’ll almost never have to deal with these, although you’ll be using their anonymous
    cousins to become a Unix wizard in *Chapter 11*, *Pipes and Redirection*. You
    won’t often come across these, but one example is a named pipe file, which might
    look like this:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FIFO 特殊文件（“命名管道”）**：命名管道，不要与 shell 中经常使用的匿名管道混淆，用于进程间通信。你几乎不需要处理这些文件，尽管在
    *第11章*《管道和重定向》中，你将使用它们的匿名版本来成为 Unix 大师。你很少会遇到这些文件，但有一个示例是命名管道文件，它可能看起来像这样：'
- en: '[PRE22]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Links**: Links are a kind of shortcut to another file. There are two types
    of links – hard and symbolic (soft). You’ll almost never need to deal with hard
    links, but you might use symbolic links to create convenient paths to frequently
    accessed files or to ensure multiple paths lead to the same file. We’ll cover
    these more below. A symbolic link may appear as:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**：链接是一种指向其他文件的快捷方式。链接有两种类型——硬链接和符号链接（软链接）。你几乎不需要处理硬链接，但你可能会使用符号链接来创建指向常用文件的方便路径，或者确保多个路径指向同一个文件。我们将在下面详细介绍这些内容。符号链接可能显示为：'
- en: '[PRE23]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This example indicates a link named `latest` that points to a file named `app-3.1`.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个示例表示一个名为 `latest` 的链接，它指向名为 `app-3.1` 的文件。
- en: '**Sockets**: Unix sockets are used for IPC, similar to pipe files. You might
    encounter socket files when troubleshooting services that need to talk to each
    other (“Why is nginx not able to reach my application server?”). A socket file
    – in this case a socket used by nginx and `php-fpm` to communicate so that a WordPress
    application can run – might look like this:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字**：Unix套接字用于进程间通信（IPC），类似于管道文件。在故障排除需要相互通信的服务时，你可能会遇到套接字文件（“为什么nginx无法访问我的应用服务器？”）。例如，一个用于nginx和`php-fpm`之间通信的套接字文件，以便WordPress应用程序能够运行，可能如下所示：'
- en: '[PRE24]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This list has covered the additional, special file types you might encounter,
    and given you some intuition about how (and why) you might encounter them in the
    wild. To help you build useful practical skills, there are a few types in particular
    that we should explore in more detail. Let’s start by getting some real-world
    experience with the most common of these special file types: links.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表涵盖了你可能遇到的额外的特殊文件类型，并且给你提供了一些关于你为何以及如何在实际使用中遇到这些文件类型的直觉。为了帮助你建立实用的技能，我们应该特别深入探讨几种类型。让我们从体验最常见的这些特殊文件类型——链接开始。
- en: Symbolic links
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号链接
- en: Symbolic links, often referred to as symlinks or soft links, are a type of file
    that serves as a reference to another file or directory. Unlike a hard link, a
    symbolic link can point to a file or directory across different filesystems, and
    it maintains a separate inode from the file or directory it references.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接，通常称为symlink或软链接，是一种文件类型，用作指向另一个文件或目录的引用。与硬链接不同，符号链接可以跨不同的文件系统指向一个文件或目录，并且它维护与所引用的文件或目录不同的inode。
- en: 'You can create a symbolic link using this basic syntax:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下基本语法创建符号链接：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`ln` (lowercase L) is the “link” command.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`ln`（小写字母l）是“链接”命令。'
- en: 'For example, if you have a file named `file1.txt` in your current directory
    and you want to create a symlink to it named `link1`, you would use the command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在当前目录中有一个名为`file1.txt`的文件，并且你想创建一个指向它的符号链接，命名为`link1`，你可以使用以下命令：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, if you do a long listing of your directory with `ls -l`, you will see
    `link1` listed as a link to `file1.txt`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你使用`ls -l`列出目录的详细信息，你会看到`link1`作为指向`file1.txt`的链接列出：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When you access `link1`, for example, by printing out the file’s contents using
    `cat link1`, the system will automatically dereference the link and give you the
    contents of `file1.txt`. If `file1.txt` is moved, deleted, or renamed, the symbolic
    link will not update automatically and will be left pointing to a non-existing
    file (a broken link).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你通过使用`cat link1`查看`link1`的内容时，系统会自动取消引用该链接并显示`file1.txt`的内容。如果`file1.txt`被移动、删除或重命名，符号链接不会自动更新，并且会指向一个不存在的文件（即断开的链接）。
- en: Symbolic links are particularly useful for creating shortcuts, organizing files
    and directories, and maintaining flexible and logical filesystem structures.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接特别适用于创建快捷方式、组织文件和目录，并维护灵活和逻辑的文件系统结构。
- en: Hard links
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬链接
- en: 'A hard link is an additional name for an existing file on the same filesystem,
    effectively acting as an alias. Both the original file and the hard link share
    the same inode, meaning changes to one are reflected in the other. Unlike symbolic
    links, hard links can’t cross filesystem boundaries or link to directories. If
    the original file is removed, the hard link will still maintain the data. To create
    a hard link named `link1` to a file named `file1.txt`, you would use the command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 硬链接是同一文件系统上现有文件的额外名称，实际上充当了别名。原始文件和硬链接共享相同的inode，这意味着对一个的更改会反映到另一个上。与符号链接不同，硬链接不能跨文件系统边界或链接到目录。如果原始文件被删除，硬链接仍然会保持数据。要创建名为`link1`的硬链接，指向名为`file1.txt`的文件，你可以使用以下命令：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The file command
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`file`命令'
- en: 'The `file` command is a utility that can let you inspect the type of a file.
    The basic usage of the `file` command is simple: type `file` followed by the filename.
    For example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`命令是一个工具，可以让你检查文件的类型。`file`命令的基本用法很简单：输入`file`后跟文件名。例如：'
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'might output `mysecret.txt: ASCII text`, indicating that `mysecret.txt` is
    a plaintext file.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '可能输出`mysecret.txt: ASCII text`，表示`mysecret.txt`是一个纯文本文件。'
- en: 'If you have a binary file, like a compiled program named `mybinary`, running
    `file mybinary` might output something like `mybinary: ELF 64-bit LSB executable`,
    indicating that `program` is a binary executable file.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你有一个二进制文件，比如一个名为`mybinary`的已编译程序，运行`file mybinary`可能会输出类似`mybinary: ELF 64-bit
    LSB executable`的内容，表示`program`是一个二进制可执行文件。'
- en: 'For a directory, such as `/home/user`, running `file /home/user` will likely
    return `/home/user: directory`, signifying that `/home/user` is a directory.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '对于目录，例如`/home/user`，运行`file /home/user`通常会返回`/home/user: directory`，表示`/home/user`是一个目录。'
- en: The `file` command is a powerful tool for quickly understanding the types of
    files you’re working with, especially when dealing with unknown or unfamiliar
    files.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`命令是一个强大的工具，可以快速了解你正在处理的文件类型，尤其是在处理未知或不熟悉的文件时。'
- en: 'If you feel like exploring, use the `file` command to inspect the following
    files:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想探索，可以使用`file`命令检查以下文件：
- en: '`file /bin/sh`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file /bin/sh`'
- en: '`file /dev/zero`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file /dev/zero`'
- en: '`file /dev/urandom`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file /dev/urandom`'
- en: '`file /dev/sda1`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file /dev/sda1`'
- en: '`file ~/.bashrc`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file ~/.bashrc`'
- en: '`file /bin/ls`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file /bin/ls`'
- en: '`file /home`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file /home`'
- en: '`file /proc/1/cwd`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file /proc/1/cwd`'
- en: Advanced file operations
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级文件操作
- en: 'When you’re working with files in Unix-like operating systems, you’ll often
    want to perform actions on them, with them, or with their content, but without
    directly modifying them in an editor. For example, you may want to:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类Unix操作系统中处理文件时，你通常希望对它们或它们的内容执行某些操作，但不直接在编辑器中修改它们。例如，你可能想要：
- en: Search a file to see if it contains some content you’re looking for.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索文件，看看它是否包含你正在寻找的内容。
- en: Identify a batch of files that was modified at a specific time.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别在特定时间被修改的一批文件。
- en: Securely move a file to another system, instead of just copying it around with
    `mv` on the local machine.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全地将文件移动到另一个系统，而不是仅仅在本地机器上使用`mv`进行复制。
- en: You may even want to combine all three into a single action! This type of knowledge
    can really come in handy during troubleshooting (searching for a specific request
    ID or error code in a log), during development (finding recently modified source
    code files), or when you want to do some testing (copying updated application
    source code to a test system).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可能想将这三者结合成一个单一的操作！这种类型的知识在故障排除（在日志中搜索特定的请求 ID 或错误代码）、开发（查找最近修改的源代码文件）或测试（将更新的应用程序源代码复制到测试系统）时非常有用。
- en: Here’s a quick look at these kinds of file operations, to give you an idea of
    the tools and commands you’ll use to accomplish them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里快速介绍这些文件操作，帮助你了解将用于完成这些操作的工具和命令。
- en: Searching file content with grep
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用grep搜索文件内容
- en: Text matching is traditionally done with `grep`. On your personal or work laptop,
    you may want to install `ag` or `rg`, which are more programmer-friendly and faster
    versions of this idea (for example, `sudo apt-get install silversearcher-ag`),
    but on production systems, you’ll always have `grep`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 文本匹配传统上使用`grep`完成。在个人或工作笔记本上，你可能希望安装`ag`或`rg`，它们是更适合程序员的、更快速的版本（例如，`sudo apt-get
    install silversearcher-ag`），但在生产系统上，你将始终使用`grep`。
- en: 'Search for the pattern `search_pattern` in the file `path/to/file`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件`path/to/file`中搜索模式`search_pattern`：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can, of course, search for string literals like this, but `grep` is so
    powerful because it allows you to use regular expressions (regexes) to search
    for patterns. The following command will return lines that start with `startswith`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以像这样搜索字符串字面量，但`grep`之所以强大，是因为它允许你使用正则表达式（regex）来搜索模式。以下命令将返回以`startswith`开头的行：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And this command will return lines that end with `endswith`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将返回以`endswith`结尾的行：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Regular expressions are tremendously useful, and every developer and Linux user
    should be familiar with the basics.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式非常有用，每个开发者和Linux用户都应该熟悉其基础知识。
- en: 'You can also use `grep` to search recursively through a directory – that is,
    search through all files in all directories it contains:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`grep`递归地搜索一个目录——也就是说，搜索它包含的所有文件中的所有目录：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: But what if you don’t want to find strings *inside* of a file – what if you
    want to find specific files themselves?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你不想查找文件*内部*的字符串——如果你想找到特定的文件本身呢？
- en: Finding files with find
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用find查找文件
- en: '`find` can help you find files and directories by name, modification time,
    or other attributes. It’s essentially a breadth-first search of the filesystem
    tree, which is quite useful for things like:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`可以帮助你根据名称、修改时间或其他属性查找文件和目录。它本质上是文件系统树的广度优先搜索，非常适用于以下任务：'
- en: Finding all application log files that were created or modified in the last
    day.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找在过去一天内创建或修改的所有应用程序日志文件。
- en: Identifying all source code test files with names that end in `_test.go`.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别所有以`_test.go`结尾的源代码测试文件。
- en: Locating all of the `php.ini` files left behind by an intern programmer so you
    can delete them.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following examples, `/search/path` is the part of the filesystem you
    want to search. If you want to search your current directory and all of its subdirectories,
    you can use the period character (`.`), for example, `find . -name ''file.txt''`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Find files by extension:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Find files matching multiple path/name patterns:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Find directories matching a given name, in case-insensitive mode:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Find files matching a given pattern, excluding specific paths:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Find files matching a given size range:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Copying files between local and remote hosts with rsync
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`rsync` is an extremely useful tool that copies files and directories between
    and across hosts. It works just like `cp`, except it works when one or both hosts
    are remote.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '`rsync` is essentially a combination of `cp` (for copying data) and `ssh` (for
    secure, encrypted transport). If you’re unfamiliar with `ssh`, you’ll need to
    learn how it works (and set up your own SSH keys and access) before trying `rsync`
    commands.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few sample invocations, thanks to the `tldr` project:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Transfer a file from a local to a remote host:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Transfer a file from a remote host to the local host:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Transfer file in [`a`]rchive mode (to preserve attributes) and compressed ([`z`]ipped)
    mode with [`v`]erbose and [`h`]uman-readable [`P`]rogress:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That last example is one I’ve used a hundred times to make quick, automated
    backups.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Combining find, grep, and rsync
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll take a detailed look at combining commands with the `|` character in *Chapter
    11*, *Pipes and Redirection*, but here’s a quick preview.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'If, for example, you want to combine the examples you just saw, for example,
    to make a backup of all files in the `/tmp` directory that were modified in the
    last week, that’s just one clever command away:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, we run `find`, looking for files that have a modification time of less
    than 7 days ago. We use find’s `-exec` flag to execute a `grep` command with the
    `-l` flag, which simply returns the filename of the matching file. Then, we pipe
    those filenames into the `xargs` command, which applies an action to every line
    of input that it receives from the previous command. In this case, the action
    is to run a made-up backup script on each matching file, along with a made-up
    destination path that someone might want to back this file up to.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have the same files as in the `grep` section above, this wild-looking
    command will run two commands for you:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It’s doing exactly what we wanted: running the backup script on ONLY the two
    files that contain the “hello world” content we care about *and* that were modified
    in the last 7 days.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: While a command like this can certainly take a few minutes (and some googling)
    to put together, it may save you hours in the long run. That’s the power of the
    command-line environment, combined with small, focused Unix tools that you can
    arrange together however you need.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn more about Unix pipes and `xargs` in *Chapter 11*, *Pipes and Redirection*,
    but we’ve given you this example because it’s important for you to get a taste
    of how you’re going to combine all these simple commands together as you learn
    them.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Advanced filesystem knowledge for the real world
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve gotten an introduction to the various Linux filetypes now, and have some
    experience working with the most common ones. Now let’s take a look at some less-common
    filesystem knowledge that will come in handy during your time working on Linux
    systems.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll meet these when you’re:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting your first Docker application that has mounted storage volumes.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working on an application that talks to industrial controllers, cameras, or
    other external hardware.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing application code that needs access to randomness for securely generating
    passwords or API tokens. One of the special file types you’ll see are **block
    devices**, which are devices resembling some form of disk, where data is fetched
    and read in blocks.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Classical disk devices are block devices, and you’ll usually find them attached
    to your filesystem at these locations:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '`/dev/hdX`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev/sdX`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev/nvmeN`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where `X` and `N` are alphabetical or numerical indices of the respective disks,
    such as `/dev/sda` or `/dev/nvme0`. **Partitions** look just like disks, but with
    an additional digit or character appended, such as `/dev/sda0`, for the first
    partition on the first drive.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Note that even once the operating system detects a new hard drive and attaches
    it (and any detected partitions) in one of these locations, you’ll still have
    to intentionally “mount” the filesystem that’s on the drive, using the `mount`
    command. This isn’t a particularly common thing for developers to do, so we’ll
    leave it at that.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: There are also special “**software devices**.” These range from `/dev/null`,
    which you might have seen output to be piped to in the form of `somecommand >
    /dev/null`, to `/dev/random` and `/dev/urandom`, which provide you with random
    bytes. This is where the programming language of your choice will most likely
    retrieve its cryptographically secure random numbers from.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Another directory is `/proc`, which is a filesystem popularized by the Plan
    9 operating system, but envisioned in the early days of Unix. As the name suggests,
    it was created to represent processes as files. `/proc` contains directories named
    after process IDs, which contain files that can be used to read those processes’
    state. Particularly on Linux, it has been extended with various other interfaces,
    including ways to configure kernel drivers, read hardware information and sensor
    outputs, and even interact with BIOS and UEFI.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'FUSE: Even more fun with Unix filesystems'
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you’ve just seen, many things can be interpreted as files in Unix. The philosophy
    is that it’s common to edit files, so commands and programming languages able
    to interact with files provide a well-understood interface. **FUSE**, short for
    **Filesystem in Userspace**, is an API that allows anyone to implement new Unix
    filesystems without having to become a kernel programmer. In other words, because
    lots of things can talk to files, it’s useful to be able to “fake” the Unix file
    API for things that aren’t the kind of normal, locally stored data that you’d
    expect a file to be. If this sounds a bit wild, check out some of the things people
    have written with FUSE. FUSE has been used to implement many classical filesystem
    drivers, for example, NTFS, so you can read your old Windows filesystems on a
    Linux machine. However, because of FUSE’s flexibility and accessibility, there
    are also some pretty wild filesystems that have been implemented this way:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '`sshfs`, for example, allows you to locally mount a directory on another machine
    accessible via SSH.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other FUSE filesystems allow you to mount remote cloud storage (like Amazon’s
    S3) as a local directory.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some even more obscure ones allow you to mount Wikipedia as a directory of files,
    or to represent protocols such as IRC and services like weather APIs as filesystems.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FUSE is so useful that it has found its way into many Unix-like operating systems
    besides Linux, and is now even available on Windows. It’s worth knowing about,
    not just because it’s a novel use of the file abstraction in Unix but because
    it can be extremely useful when you are dealing with information that’s stored
    somewhere without a classical API that your application can use at the application
    layer. Any programming language you’re likely to use has a standard library that
    lets you talk to files on a Unix filesystem, and FUSE is a way of creating that
    interface for just about any kind of information.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was an intense journey through the basics – and some of the more
    advanced bits – of files and the filesystem on Linux. You saw the difference between
    plaintext files and binary files, explored how the Linux filesystem tree is laid
    out, and learned all the basic commands you need to work with files. If you did
    it right, you also spent some time in your own Linux environment, practicing the
    important command-line file editing skills we showed you here.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: After covering the basics, we jumped into the most critical intermediate and
    advanced topics that you’ll need. You saw how to find files and search them for
    content, and we also gave you a taste of special files and filesystems.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: All of this together arms you with the most important skills and knowledge you
    need in order to use Linux to solve real-world problems. We hope you had fun on
    this whirlwind tour!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的Discord社区——在这里你可以分享反馈、向作者提问并了解新版本的发布——请扫描下方的二维码：
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code1768422420210094187.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1768422420210094187.png)'
