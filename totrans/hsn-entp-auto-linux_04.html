<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Streamlining Infrastructure Management with AWX</h1>
                </header>
            
            <article>
                
<p class="mce-root">As we have<span> </span>discussed so far in this book, effective enterprise automation on Linux involves several key elements, including standardization of both tools and technologies, and implementing processes and tools that make the management of the environment more efficient. Ansible is a great first step in this journey and can be supplemented with a complementary technology called AWX to further streamline its application.</p>
<p>AWX is, in short, a GUI-driven tool for the management of Ansible jobs. It does not replace Ansible functionality, but rather adds to it by providing a multi-user GUI-driven frontend that allows for the simple management and orchestration of playbooks. When managing large Linux environments such as those in an enterprise, AWX is the perfect complement to Ansible automation and is an important step in effective and efficient management. In this chapter, we will cover the following topics:</p>
<ul>
<li>Introduction to AWX</li>
<li>Installing AWX</li>
<li>Running your playbooks from AWX</li>
<li>Automating routine tasks with AWX</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p><span>This chapter includes examples based on the following technologies:</span></p>
<ul>
<li class="mce-root">Ubuntu Server 18.04 LTS</li>
<li class="mce-root">CentOS 7.6</li>
<li class="mce-root">Ansible 2.8</li>
</ul>
<p>To run through these examples, you will need access to a server or virtual machine running one of the aforementioned operating systems and Ansible. Note that the examples given in this chapter may be destructive in nature (for example, they involve installing Docker and running services on the server) and, if run as is, are only intended to be run in an isolated test environment.</p>
<p class="mce-root">Once you are satisfied that you have a safe environment to operate in, let's get started by looking at the installation of new software packages with Ansible.</p>
<p><span>All example code discussed in this book is available from GitHub at:</span><span> <a href="https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux">https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux</a>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to AWX</h1>
                </header>
            
            <article>
                
<p>AWX sets out to solve the problems associated with Ansible automation in an enterprise environment. To maintain our hands-on focus, let's consider the organic growth scenario we discussed in <a href="c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml">Chapter 1</a>, <em>Building a Standard Operating Environment on Linux</em>. In a small environment where Ansible has been implemented, you might have just one or two key people responsible for writing and running playbooks against the environment. In this small scenario, it is reasonably easy to know who has run which playbooks and what the latest versions are, and the training requirements for Ansible are low as only a small number of key people are responsible for its use.</p>
<p>As the environment scales to enterprise sizing, so do the number of Ansible operators. If all of those responsible for running Ansible have it installed on their own machines, and all have local copies of the playbooks, suddenly the management of that environment becomes a nightmare! How can you ensure that everyone is using the latest versions of the playbooks? How do you know who ran what and what the outcome was? What if a change needs to be run out of hours? Can you pass the Ansible job off to a <strong><span>Network Operations Center</span><span> </span></strong><span>(</span><strong><span>NOC</span></strong><span>) team, or is that not possible because they would need training on how to use Ansible?</span></p>
<p>AWX sets out to address all of these challenges, as we shall see subsequently, starting in the next section, where we look at how AWX can reduce your staff training costs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AWX reduces training requirements</h1>
                </header>
            
            <article>
                
<p>Ansible is very easy to get up and running. It still needs a little training, though. For example, IT admins and operators who haven't received training may not be comfortable with running a playbook on the command line. This is demonstrated in the following example. Although fairly simple in Ansible terms, anyone unfamiliar with the tool will find that it isn't very user-friendly:</p>
<div class="column">
<pre><span><strong>$ ansible-playbook -i hosts --ask-pass simple.yml</strong><br/></span></pre></div>
<p class="layoutArea">Although it isn't a complex command, those unfamiliar with it might be reluctant to run it for fear of causing damage to production systems, let alone interpret the pages of output that a sizeable playbook can produce.</p>
<p class="layoutArea">To <span>alleviate</span> this, AWX provides a web GUI-based interface that is quite literally point and click. Although many advanced features can be used by those familiar with it, a playbook can be run with literally a few clicks of the mouse, and the results are shown using a simple <em>traffic light</em> system (red indicating that the playbook run failed, while green shows that it passed). In this way, AWX provides an interface from which even those with no prior Ansible experience can launch a playbook and pass the results on to another team for analysis.</p>
<p>AWX offers benefits for security teams and managers too, by logging detailed results of all actions and jobs performed, and we shall provide an overview of this in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AWX enables auditability</h1>
                </header>
            
            <article>
                
<p>Although the Ansible command-line tools provide logging options, these are not enabled by default and as a result, the run output of playbooks can be lost as soon as a terminal session is closed. This is not great in an enterprise scenario, particularly when an issue or outage occurs and a root cause analysis is required. </p>
<p>AWX addresses this in two ways. First of all, every user must log in to the GUI before any actions can be performed. AWX can integrate with centralized accounting systems such as LDAP or Active Directory, or users can be defined locally on the AWX host. All actions in the UI are then tracked, and as such, it is possible to trace back playbook runs to specific users and indeed configuration changes. In an enterprise environment, this level of accountability and this kind of audit trail is a <em>must-have</em>.</p>
<p class="mce-root"/>
<p>Beyond this, AWX captures all of the output of every playbook run, along with key pieces of information such as which inventory the playbook was run against, what variables were passed to it (if any), and the date and time of the run. This means that if an issue occurs, AWX can provide a complete audit trail to help you find out what happened and when. </p>
<p>Not only can AWX assist with auditing your automation, but it can also help with ensuring version control of your playbooks, as we shall discuss in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AWX supports version control</h1>
                </header>
            
            <article>
                
<p>In an enterprise scenario, individuals storing playbooks locally could be a problem waiting to happen. For example, if user A updates a playbook with a critical fix, how do you ensure that user B has access to that code? Ideally, the code should be stored in a version control system (for example, GitHub) and the local copy updated for every single run.</p>
<p>Good processes are an important component of enterprise automation of Linux and while user B should update their local playbooks before running them, you cannot enforce this. Again, AWX addresses this issue by allowing playbooks to be sourced from a version control repository, with the local copy of the playbooks on the AWX server being updated automatically.</p>
<div class="packt_infobox">Although AWX can help you, especially when it comes to ensuring the latest version of code has been pulled from the repository, it cannot help with other errant behaviors such as someone not committing their code in the first place. The intention, however, of enforcing the use of AWX for Ansible playbook runs is that anyone who makes changes must commit them for AWX to run them. Local access to the AWX server should be tightly restricted to prevent people from making code changes on the local filesystem, and in this way, you can have confidence that everyone is actively and effectively using your version control system.</div>
<p>These updates can be event-driven so that, for example, local playbooks can be updated every single time a playbook from that store is run. They can also be updated on a scheduled basis or manually, as per the decisions of the AWX administrators. </p>
<p>AWX can help with the security of your automation too. We shall explore this in the next section by looking at credential management in AWX.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AWX helps with credential management</h1>
                </header>
            
            <article>
                
<p>For Ansible to effectively manage an Enterprise Linux environment, it must have some form of credentials to access all of the servers it is managing. SSH authentication is normally secured with either SSH keys or passwords, and in a large team of Ansible operators, this can mean everyone has access to those passwords and SSH private keys since they are required for Ansible to be run. Needless to say, this presents a security risk! </p>
<p>As stated previously, from a security standpoint, this is less than desirable as it would be too easy for someone to copy and paste credentials and use them in a manner for which they were not intended. AWX also handles this by storing required credentials in its database, encrypted with a passphrase chosen at installation time. The GUI stores all the credentials using reversible encryption so that they can be passed to Ansible when playbooks are run later on. However, the GUI does not let you see any previously entered sensitive data (such as passwords or SSH private keys)—that is to say that they can be entered and changed, but you cannot show a password or SSH key in the GUI, and hence operators can't easily make use of the AWX frontend to obtain credential information for use elsewhere. In this way, AWX helps enterprises keep their credentials under lock and key and ensures that they are only used for Ansible deployments and are not leaked or used for any other unintended purposes.</p>
<p>Ansible Vault is an excellent tool for encrypting any sensitive data that a playbook needs to operate on, be that for playbook data in the form of variables or storing server credentials themselves, such as an SSH private key. Although Vault is highly secure, it is easy to see the vault contents if you have the vault password (here, you would need to run a playbook that uses the Vault). As a result, AWX provides unique functionality to supplement Ansible and ensure security in an enterprise environment.</p>
<p>In these ways, AWX helps to address many of the challenges that enterprises face when deploying Ansible in a large-scale environment. Before we complete this section of this chapter, we will touch very briefly on how AWX can help you to integrate with other services.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating AWX with other services</h1>
                </header>
            
            <article>
                
<p>There is a myriad of tools that AWX can integrate with—for example, both Red Hat's Satellite 6 and CloudForms products (and their open source Katello and ManageIQ counterparts) provide native integration with both AWX and Ansible Tower. These are just two examples, and this is all possible because everything that we will explore as we progress through this chapter is also accessible through an API and a command-line interface.</p>
<p class="mce-root"/>
<p>This enables AWX to be integrated with a wide variety of services, or you could even write your own that would run a playbook from AWX as a result of some other action, just by calling the API. The command-line interface (called <kbd>tower-cli</kbd>, after the commercial Ansible Tower product) is also incredibly useful, especially when it comes to programmatically populating data in AWX. For example, if you wanted to add a host to a static inventory, you could do this through the web user interface (as we shall demonstrate later), the API, or using the CLI. The latter two methods lend themselves incredibly well to integration with other services<span>—</span>for example, a <strong>Configuration Management Database</strong> (<strong>CMDB</strong>) could push new hosts into an inventory using the API, without the need for any manual action by the user.</p>
<p>To explore these two integration points further, you can refer to the following official documentation sources:</p>
<ul>
<li>The AWX API is documented here: <a href="https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html">https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html</a>.</li>
<li>The <kbd>tower-cli</kbd> command is documented here: <a href="https://tower-cli.readthedocs.io/en/latest/">https://tower-cli.readthedocs.io/en/latest/</a>.</li>
</ul>
<p><span>Given the wide and varied nature of such integrations, they are beyond the scope of this book—however, it is important to mention them here because it is hoped that, as you read this chapter, you will see opportunities for integration with other services and hence be able to explore this topic further. </span>In the next section of this chapter, we shall get hands-on with AWX and look at a simple deployment. Later in this chapter, this will be followed up with some example use cases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing AWX</h1>
                </header>
            
            <article>
                
<p>Installing AWX is a straightforward affair once you put the right prerequisites in place. In fact, one of the prerequisites for AWX is Ansible, proving the complementary nature of this technology. <span>Most of the AWX code runs in a set of Docker containers, which makes it straightforward to deploy in most Linux environments. </span></p>
<p class="column"><span>The use of Docker containers means that it is possible to run AWX in OpenShift or other Kubernetes environments</span><span>—</span><span>however, for the sake of simplicity here, we will get started by installing it on a single Docker host. Before you proceed any further, you should ensure that your chosen host has the following:</span></p>
<ul>
<li><span>Docker, fully installed and working</span></li>
<li><span><span>The <kbd>docker-py</kbd> module for your version of Python</span></span></li>
<li><span>Access to Docker Hub (internet access)</span></li>
<li><span>Ansible 2.4 or newer</span></li>
<li><span>Git 1.8.4 or newer</span></li>
<li>Docker Compose</li>
</ul>
<p>These prerequisites are normally readily available for most Linux systems. Now, we will perform the following steps to begin our<span> </span>installation:</p>
<ol>
<li>Continuing our example of the Ubuntu system we used in the previous chapter, we will run the following command to install the AWX requirements:</li>
</ol>
<pre class="layoutArea" style="padding-left: 60px"><strong>$ sudo apt-get install git docker.io python-docker docker-compose</strong></pre>
<ol start="2">
<li>Once these have been installed, the next task is to clone the AWX code from its repository on GitHub:</li>
</ol>
<div class="page">
<div class="layoutArea">
<div class="column">
<pre style="padding-left: 60px"><strong><span>$ git clone https://github.com/ansible/awx.git
</span></strong></pre>
<p style="padding-left: 60px">The Git tool will faithfully clone the latest and greatest version of the AWX source code<span>—</span>note that this project is under active development and there is a possibility that the latest release might have bugs in it.</p>
</div>
</div>
</div>
<div class="mce-root packt_tip">
<div class="page">
<div class="section">
<div class="layoutArea">
<div class="column"><span>If you want to clone one of the stable AWX releases, browse the</span><span> </span><span class="packt_screen"><span>Releases</span><span> </span></span><span>section of the repository and check out the desired version:</span><span> </span><a href="https://github.com/ansible/awx/releases"><span>https:/</span><span>​</span><span>/</span><span>​</span><span>github.</span><span>​</span><span>com/ansible/</span><span>​</span><span>awx</span><span>/</span><span>​</span><span>releases</span></a><span>.</span></div>
</div>
</div>
</div>
</div>
<ol start="3">
<li>We have cloned the repository, and it is now time for us to define the configuration for our installation of AWX, especially security details such as a password. To get started on this, change into the <kbd>installer</kbd> directory under the cloned repository:</li>
</ol>
<pre style="padding-left: 60px"><strong><span>$ cd awx/installer
</span></strong></pre>
<p style="padding-left: 60px">Hopefully, the contents of this directory will look familiar to you after reading the previous chapter. There is an<span> </span><kbd>inventory</kbd><span> </span>file, a playbook for us to run called<span> </span><kbd>install.yml</kbd><span>, </span>and a<span> </span><kbd>roles/</kbd><span> </span>directory. However, don't go and run the<span> </span><kbd>install.yml</kbd><span> </span>playbook just yet as there are some variables in the inventory file that we must set before we proceed.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p style="padding-left: 60px">If you take a look through the inventory file, you will see there is a great deal of configuration that can occur inside it. Some variables are commented out, while others are set to default values. There is a minimum of six variables that I recommend that you set before installing AWX, and these are as follows:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Variables name</strong></td>
<td><strong>Recommended value</strong></td>
</tr>
<tr>
<td><kbd>admin_password</kbd></td>
<td>
<div class="page">
<div class="section">
<div class="layoutArea">
<div class="column">
<p><span>This is the default password for the admin user—</span><span>you will need this the first time you log in, so be sure to set it to something memorable and secure!</span></p>
</div>
</div>
</div>
</div>
</td>
</tr>
<tr>
<td><kbd>pg_password</kbd></td>
<td>
<div class="page">
<div class="section">
<div class="layoutArea">
<div class="column">
<p><span>This is the password for the backend PostgreSQL database</span><span>—</span><span>be sure to set it to something unique and secure.</span></p>
</div>
</div>
</div>
</div>
</td>
</tr>
<tr>
<td><kbd>postgres_data_dir</kbd></td>
<td>
<div class="page">
<div class="section">
<div class="layoutArea">
<div class="column">
<p><span>This is the directory on the local filesystem where the PostgreSQL container will store its data</span><span>—</span><span>it defaults to a directory under</span><span> </span><kbd><span>/tmp</span></kbd><span>, </span><span>which, on most systems, will be automatically cleaned up regularly. This often destroys the PostgreSQL database, so set it to something AWX-specific (for</span><span> </span><span>example,</span><span> </span><kbd><span>/var/lib/awx/pgdocker</span></kbd><span>).</span></p>
</div>
</div>
</div>
</div>
</td>
</tr>
<tr>
<td><kbd>project_data_dir</kbd></td>
<td>
<div class="page">
<div class="section">
<div class="layoutArea">
<div class="column">
<p><span>For uploading playbooks manually to AWX without the need for a version control system, the playbooks must sit somewhere on the filesystem. To prevent having to copy them into a container, this variable maps the local folder specified to the required one inside a container. For the examples in this book, we will use the default (the</span><span> </span><kbd><span>/var/lib/awx/projects</span></kbd><span> </span><span>folder).</span></p>
</div>
</div>
</div>
</div>
</td>
</tr>
<tr>
<td><kbd>rabbitmq_password</kbd></td>
<td>
<div class="page">
<div class="section">
<div class="layoutArea">
<div class="column">
<p><span>This is the password for the backend RabbitMQ service</span><span>—</span><span>be sure to set it to something unique and secure.</span></p>
</div>
</div>
</div>
</div>
</td>
</tr>
<tr>
<td><kbd>secret_key</kbd></td>
<td>
<div class="page">
<div class="section">
<div class="layoutArea">
<div class="column">
<p><span>This is the secret key used to encrypt credentials in the PostgreSQL database. It must be the same between upgrades of AWX, so be sure to store it somewhere secure as it will need to be set in future AWX inventories. Make this something long and secure.</span></p>
</div>
</div>
</div>
</div>
</td>
</tr>
</tbody>
</table>
<p> </p>
<ol start="4">
<li>You will observe that in this inventory file there is a great deal of secret information that is in plaintext. While we can tolerate this for the duration of the installation process, this file should not be left lying around on the filesystem when the installation is complete as it could give a potential attacker all of the details they need to easily compromise your systems. Once the installation phase is complete, be sure to either copy this file into a password manager of some kind or simply store the individual passwords<span>—</span>either way, do not leave the file unencrypted!</li>
</ol>
<ol start="5">
<li>Once the inventory is customized, it is time to run the installation itself<span>—</span>this is launched by running the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo ansible-playbook -i inventory install.yml</strong></pre>
<p style="padding-left: 60px">From our work on Ansible in the previous chapter, you will recognize this command<span>—</span>it is using the <kbd>ansible-playbook</kbd> command to run the <kbd>install.yml</kbd> playbook, while also using the inventory file called <kbd>inventory</kbd> that we edited in <em>step 1</em>. Pages of output will pass by in the Terminal, and if the installation is successful, you should see something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dee5a8b0-d9cf-4bee-9b6f-9548214848c6.png" style="width:55.75em;height:38.58em;"/></p>
<ol start="6">
<li>Once the installation completes, it takes a few minutes for the Docker containers to actually start up and for the backend database to be created. However, once this is done, you should be able to navigate to the IP address of your chosen AWX host in your browser and see the login page, an example of which is shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7caaf347-b763-4d94-bc54-66c73f41c063.png" style="width:31.83em;height:23.42em;"/></p>
<ol start="7">
<li>Log in as the admin user using the password you set in the <kbd>admin_password</kbd> variable in the inventory file earlier. You should then be taken to the dashboard page of AWX:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e060d907-ecc2-4090-9e63-c63983ad2840.png" style="width:44.75em;height:30.50em;"/></p>
<p>That's it<span>—</span>you have successfully installed and logged in to AWX! Of course, there are many more advanced installation parameters you can define, and equally, in an enterprise, you would not rely on just a single AWX host with no backup (or high availability).</p>
<div class="packt_tip">Note that when you log in to AWX, the connection is not SSL-secured, which could result in sensitive data such as machine credentials being transmitted over your network in the clear. </div>
<p>There is no one solution to out-of-the-box high availability and SSL issues that will suit every enterprise, and so we leave the actual solution for this as an exercise for you. For example, if you have an OpenShift environment with multiple hosts, then installing AWX in this environment will enable it to keep running, even if the host it runs on fails. There are of course ways to achieve high availability without OpenShift too.</p>
<p class="mce-root"/>
<p>Applying secure HTTP to AWX is also going to be solved in a different manner in different environments. Most Docker environments will have some kind of load balancer in front of them to help to handle their multi-host nature, and as a result, the SSL encryption could be offloaded onto this. It is also possible to secure a single Docker host, such as the one we have built here, but installing something capable of reverse proxying (for example, nginx) and configuring that to handle the SSL encryption.</p>
<p>In short, there is no one-size-fits-all solution to this, but it is recommended that you address these in the manner best suited to your enterprise. For this reason, we will not discuss them further here, other than to recommend that you take them into account when deploying AWX for production use.</p>
<p>Now that you have an AWX instance running, we must configure it so that we can successfully replicate how we ran playbooks from the command line in the previous chapter. For example, we must define an inventory just as we did previously and ensure we have set up SSH authentication so that Ansible can perform the automated tasks on the remote computer. In the next part of this chapter, we will walk through all of the setup that's required to run your first playbook through<span> </span>AWX.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running your playbooks from AWX</h1>
                </header>
            
            <article>
                
<p>When we ran an example playbook from the command line, we created our inventory file and then our playbook and then ran it using the<span> </span><kbd>ansible-playbook</kbd><span> </span>command. All of this, of course, assumed that we had already set up connectivity to the remote system by way of either specifying a password interactively or through the setup of SSH keys.</p>
<p>Although the end result in AWX is very similar<span>—</span>playbooks are run against an inventory<span>—</span>the terminology and naming are rather different. In this part of this chapter, we will walk through the process of getting your first playbook up and running from AWX. Although we don't have space in this book to give a complete rundown on every feature AWX has to offer, this section intends to give you sufficient knowledge and confidence to start managing your playbooks from AWX, and to explore further on your own.</p>
<p>Before you can run your first playbook from AWX, there are several prerequisite setup stages that must be completed. In the next section, we will complete the first of these<span>—</span>creating the credentials that will be used to authenticate over SSH with our target machine.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up credentials in AWX</h1>
                </header>
            
            <article>
                
<p>When you log in to AWX, you will notice a menu bar down the left-hand side of the screen. To define a new set of credentials that we will use to allow Ansible to log into our target machine, perform the following steps:</p>
<ol>
<li>Click on<span class="packt_screen"> Credentials </span>in the left-hand menu<span> </span>bar.</li>
<li>Click on the green<span> </span><span class="packt_screen">+</span><span> icon </span>to create a new credential.</li>
<li>Give the credential a name and select<span class="packt_screen"> Machine </span>from the<span> </span><span class="packt_screen">CREDENTIAL TYPE</span><span> </span>field. There are many types of credentials that enable AWX to interact with a wide variety of services, but for now, we are only interested in this particular type.</li>
<li>There are many other fields available for specifying parameters for more advanced use cases<span>—</span>however, for our demonstration purposes, this is sufficient. </li>
</ol>
<p>Your end result should look something like the following screenshot. Note that I have specified the login password for my demo machine, but you could equally have specified the SSH private key in the larger text box on the screen. You will also observe the presence of the <span class="packt_screen">Prompt on launch </span>checkbox<span>—</span>there are many options in AWX that it can prompt the user for at the time a playbook is run, which can lend itself to a really rich interactive user experience. However, in this demo, we won't do this as we want to demonstrate playbooks running without user intervention:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4ff1346b-bb6c-46e1-9298-1f9ac3d128ce.png" style="width:36.58em;height:24.67em;"/></p>
<p>When you have a credential defined, the next step is to define the inventory to run our playbook against. We'll explore this in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating inventories in AWX</h1>
                </header>
            
            <article>
                
<p>Just like on the command line, AWX requires an inventory to be created for playbooks to be executed against. Here, we are going to make use of one of the official, publicly available Ansible example playbooks, which requires an inventory with two groups in it. In a larger setup, we would specify a different server for each group, but for this small demo, we can reuse the same server for both roles.</p>
<p>The code in question is used to install a simple LAMP stack on an RHEL or CentOS 7 machine and is available to view here: <a href="https://github.com/ansible/ansible-examples/tree/master/lamp_simple_rhel7">https://github.com/ansible/ansible-examples/tree/master/lamp_simple_rhel7</a>.</p>
<p>To run this demo, you will need a CentOS 7 machine. My demo host is called<span> </span><kbd>centos-testhost</kbd>, and if I were defining an inventory file on the command line, it would look like this:</p>
<pre>[webservers]<br/>centos-testhost<br/><br/>[dbservers]<br/>centos-testhost</pre>
<p>To replicate this in the AWX GUI, run through the following sequence:</p>
<ol>
<li>Click on<span> </span><span class="packt_screen">Inventories </span>on the left-hand menu bar.</li>
<li>Click on the green<span> </span><span class="packt_screen">+</span><span> icon </span>to create a new<span> </span>inventory.</li>
<li>Select<span> </span><span class="packt_screen">Inventory</span><span> </span>from the drop-down menu.</li>
<li>Give the inventory a suitable name and click<span> </span><span class="packt_screen">SAVE</span>.</li>
</ol>
<p class="mce-root"/>
<p>Your screen should look something like the one shown here once you have completed this process:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bed15396-0309-4519-a742-e4bb04628a76.png" style="width:49.83em;height:33.58em;"/></p>
<p>When complete, we can create our first group and put our test host into it. To do this, follow these steps:</p>
<ol>
<li>Click on the<span> </span><span class="packt_screen">GROUPS</span><span> </span>button at the top of the pane.</li>
<li>Click the green<span class="packt_screen"> +</span><span> icon </span>to create a new<span> </span>group.</li>
<li>Enter the name<span> </span><kbd>webservers</kbd><span> </span>into the<span class="packt_screen"> NAME </span>field.</li>
<li>Click the green<span> </span><span class="packt_screen">SAVE</span><span> </span>button.</li>
<li>Click the<span> </span><span class="packt_screen">HOSTS</span><span> </span>button at the top.</li>
<li>Click the green<span> </span><span class="packt_screen">+</span><span> icon </span>button to add a new host.
<ol>
<li>Select<span> </span><span class="packt_screen">New Host</span><span> </span>from the drop-down list.</li>
</ol>
</li>
<li>Enter the name<span> </span><kbd>centos-testhost</kbd><span> </span>into the<span class="packt_screen"> HOST NAME </span>field.</li>
<li>Click the green<span class="packt_screen"> SAVE</span><span> </span>button.</li>
</ol>
<p class="mce-root"/>
<p>Once you have completed these steps, your screen should look something like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9e74477c-6284-4e84-ad09-055599012176.png" style="width:49.75em;height:33.50em;"/></p>
<p>Repeat this process to define the<span> </span><kbd>dbservers</kbd><span> </span>group. Take care not to create this group as a subgroup of the<span> </span><kbd>webservers</kbd><span> </span>group, which is easy to do. You will note the breadcrumb trail at the top of the preceding screenshot<span>—</span>use that to navigate back to the top level of our new inventory by clicking on<span> </span><kbd>Hands on Inventory</kbd><span> </span>(or your name, if you chose a different one).</p>
<p>From here, the process is almost identical, except that when you come to adding the host to the newly created group (<em>step 6</em> onward from the preceding steps), choose<span> </span><span class="packt_screen">Existing Host</span><strong> </strong>as we are reusing our single host for both groups in this example. Your resulting screen should look something like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ca729358-47ce-4211-b682-4546efb81a52.jpg"/></p>
<p>With those steps complete, our inventory complete with groupings is complete in AWX, and we can move on to the next stage in defining our configuration<span>—</span>the creation of an AWX project. We will do exactly this in the next section of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a project in AWX</h1>
                </header>
            
            <article>
                
<p>If you were working with Ansible on the command line, it is unlikely you would store all of your playbooks and roles in one directory for very long as it would get unmanageable and very difficult to work out which file was which. This is the purpose of a project in AWX<span>—</span>it is quite simply a logical grouping of playbooks and is used to make organization easier and simpler.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Although we will not go into <strong>Role-Based Access Control</strong> (<strong>RBAC</strong>) in this book, projects also serve a role in this. In the screenshots provided so far, you may have noticed a <span class="packt_screen">PERMISSIONS</span> button at the top of a number of the panes. These are present throughout the UI and are used to define which users have access to which configuration items. For example, if you have a team of <strong>Database Administrators</strong> (<strong>DBAs</strong>) who should only have access to run playbooks relevant to database servers against those servers, you could create an inventory of database servers and only give the DBAs access to this. Similarly, you could put all of the DBA-related playbooks into one project, and again only give that team permission to access that project. In this way, AWX forms a part of the good processes inside an enterprise, both making Ansible more accessible, and ensuring that the right items are only available to the correct people.</p>
<p>To continue our simple example, let's create a new project to reference our example Ansible code:</p>
<ol>
<li>Click on<span> </span><span class="packt_screen">Projects</span><span> </span>on the left-hand menu bar.</li>
<li>Click on the green<span> </span><span class="packt_screen">+</span> icon<span> </span>to create a new project.</li>
<li>Give the project a suitable name.</li>
<li>Select<span class="packt_screen"> Git</span><span> </span>from the<span class="packt_screen"> SCM TYPE</span><span> </span>drop-down list.</li>
<li>Enter the following URL into the<span> </span><span class="packt_screen">SCM URL</span><span> </span>field: <a href="https://github.com/ansible/ansible-examples.git">https://github.com/ansible/ansible-examples.git</a>.</li>
<li>Optionally, you could also populate the <span class="packt_screen">SCM BRANCH/TAG/COMMIT</span> field if you wanted to only <span>work </span>with a specific commit or branch in the repository. In this simple example, we will use the latest commit, known in Git as <strong>HEAD</strong>.</li>
<li>No other credentials are necessary as this is a publicly available GitHub example<span>—</span>however, if you were using a password-protected repository, you would create an SCM credential to the machine credential we created in the <em>Setting up credentials in AWX</em> section of this chapter.</li>
<li>Check the<span> </span><span class="packt_screen">UPDATE REVISION ON LAUNCH</span><span> </span>checkbox<span>—</span>this causes AWX to pull the latest version of the code from our<span class="packt_screen"> SCM URL</span><span> </span>every time a playbook from this project is run. If this is unchecked, you must manually update the local copy of the code before AWX will see the latest version.</li>
<li>Click on the green<span class="packt_screen"><span> </span>SAVE</span><span> </span>button.</li>
</ol>
<p class="mce-root"/>
<p>When complete, the resulting screen should look something like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8d443141-ad17-4f37-a99e-c3400ce628df.png" style="width:53.08em;height:35.75em;"/></p>
<p class="mce-root"/>
<p>Before we can proceed to the final step of configuring our playbook for its first run, we need to manually pull the contents from the GitHub repository. To do this, click on the two semicircular arrows to the right of your newly created project<span>—</span>this forces a manual sync of the project from the upstream repository. An example of this is shown in the following screenshot for your reference:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dc1aba58-056f-4006-bdda-739c1be74faf.png" style="width:50.50em;height:34.00em;"/></p>
<p>The green dot to the left of the project title (as seen in the preceding screenshot) will pulsate during the sync. Once this completes successfully, it will turn a static green, whereas if something goes wrong, it will turn red. Assuming all is well, we can proceed to the final stage of preparing to run our playbook.</p>
<p>With our project defined in AWX, the next task required as we head toward running our first playbook from it is to create a template, and we will do exactly that in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a template in AWX</h1>
                </header>
            
            <article>
                
<p>Templates in AWX pull together all of the other configuration items you have created so far<span>—</span>in essence, a template is the AWX definition of all of the parameters you would specify on the command line following the<span> </span><kbd>ansible-playbook</kbd><span> </span>command.</p>
<p>Let's walk through the process of creating a template so that we can run our playbook:</p>
<ol>
<li>Click on<span> </span><span class="packt_screen">Templates</span><span> </span>on the left-hand menu bar.</li>
<li>Click on the green<span> </span><span class="packt_screen">+</span><span> icon </span>to create a new<span> </span>template.</li>
<li>Select<span class="packt_screen"> Job Template</span><span> </span>from the drop-down list.</li>
<li>Give the template a suitable name.</li>
<li>In the<span> </span><span class="packt_screen">INVENTORY</span><span> </span>field, select the inventory we created earlier in this chapter.</li>
<li>In the<span> </span><span class="packt_screen">PROJECT</span><span> </span>field, select the project we created earlier.</li>
<li>In the<span> </span><span class="packt_screen">PLAYBOOK</span><span> </span>field, note that the drop-down list has automatically been populated with a list of all of the viable playbooks that are available in the GitHub repository we specified in our<span> </span><span class="packt_screen">PROJECT </span>definition. Choose<span> </span><kbd>lamp_simple_rhel7/site.yml</kbd><span> </span>from the list.</li>
<li>Finally, select the credential we defined earlier in the<span> </span><span class="packt_screen">CREDENTIAL </span>field.</li>
<li>Click the green<span> </span><span class="packt_screen">SAVE</span><span> </span>button.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The end result should look something like the following screenshot, which shows all of the fields filled in:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d70ecb42-2c66-4ec7-a4e1-062c91d779ff.png" style="width:45.67em;height:30.75em;"/></p>
<p>With those steps complete, we have now completed everything required to run our first ever job from AWX. Hence, we shall proceed to do exactly that in the next section and observe the results.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running a playbook from AWX</h1>
                </header>
            
            <article>
                
<p>When we run a playbook from AWX, what we're actually doing is running a template. Hence, to do this interactively, we will navigate our way back to the <span class="packt_screen">Templates</span> screen, which should present a list of available templates. Note that when you are employing role-based access control, you can only see the templates (and inventories and other configuration items) that you have permission to see<span>—</span>if you don't have permission, it is invisible. This helps make AWX more manageable when using it across different teams.</p>
<p class="mce-root"/>
<p>We are using an administrator account, so we can see everything. To launch our newly created template, follow these instructions:</p>
<ol>
<li>Click on the rocket ship icon on the right of the template name, as shown in the following screenshot, which shows our newly created <span class="packt_screen">Templates</span> with the option to execute it highlighted:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b1b13551-3177-4e92-a149-87416697561a.png" style="width:50.08em;height:39.50em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p style="padding-left: 60px">When you do this, the screen automatically reloads and you will see details of the run on your screen. Don't worry if you navigate away from this<span>—</span>you can always find it again later by clicking on<span class="packt_screen"> Jobs</span><span> </span>on the left-hand menu bar. Since we have defined this job, it fails in the first instance. Luckily, the <span class="packt_screen">Jobs</span> pane shows you all of the same details and output that you would get when you run Ansible from the command line, only in AWX, it is archived in the database so that you can always go back to it at a later date or so that another user can analyze it simply by logging into AWX (assuming they have the required permissions).</p>
<ol start="2">
<li>Looking at the job output, we can see the problem is some kind of permissions issue, and a screenshot showing what this might look like is shown for your reference:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1c1d28ac-d66c-41ec-9999-8872caf5f667.png" style="width:49.83em;height:33.58em;"/></p>
<p class="mce-root"/>
<p style="padding-left: 60px">Taking a look at the playbook source code on GitHub, we can see that the original author hardcoded the use of the root user account for this playbook (note the<span> </span><kbd>remote_user: root</kbd><span> </span>statements in<span> </span><kbd>site.yml</kbd>). Normally, you wouldn't do this<span>—</span>it is generally better practice to get Ansible to log in using an unprivileged account, and then to use <kbd>sudo</kbd> as required by putting the <kbd>become: true</kbd><span> </span><span>statement</span><span> </span><span>in the play headers (we'll see this in action later in this book).</span></p>
<ol start="3">
<li>To work around this, for now, we'll simply allow root logins over SSH on our CentOS 7 server, and then modify the credential in AWX to be for the root account. Note that you could also define a new credential and change the credential linked to the template<span>—</span>either are acceptable solutions. Once you have changed the credential, run the template again<span>—</span>this time, the output should look somewhat different, as we can see in the following screenshot, which is showing now a successful run of the playbook:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d03368a4-488b-44fe-a351-31194a819cc8.png" style="width:49.17em;height:33.08em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As we can see from the preceding screenshot, we have a successful playbook run, along with all of the relevant details about which user launched it, which revision on GitHub was used, which credentials were used, which inventory, and so on. Scrolling down this pane gives the output from <kbd>ansible-playbook</kbd> that we saw in the error screenshot previously; if we wish to, we can further analyze the playbook run to see whether there were any warnings, what was changed, and so on. <span>Hence, </span>with AWX we really achieve a nice simple user interface to Ansible, which integrates all of the good practices that should be present when automating Linux in an enterprise environment such as security, auditability, and centralized control of Ansible (and indeed playbook code through source control integration).</p>
<p>We have seen how AWX can assist us with running tasks manually—but what if we want a truly <em>hands-off</em> approach to task automation? We will explore scheduling tasks in the next section of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automating routine tasks with AWX</h1>
                </header>
            
            <article>
                
<p>Although there are many facets to AWX that would require much more space than we have in this book, one particular one stands out<span>—</span>the automation of routine tasks. Routine tasks that Ansible could handle might include patching of servers, running some kind of compliance check or audit, or enforcing a security policy.</p>
<p>For example, you could write an Ansible playbook to ensure that the SSH daemon does not allow remote root logins as this is considered a good security practice. It is, of course, easy for any system administrator with root privileges to log in and turn this back on; however, running an Ansible playbook regularly to turn this off enforces it and ensures no-one (well-meaning or otherwise) turns it back on. The idempotent nature of Ansible changes means that where the configuration is already in place, Ansible will not make any changes, and hence running the playbook is safe, light on system resources, and non-disruptive.</p>
<p>If you wanted to do this with Ansible on the command line, you would need to create a cron job to run the <kbd>ansible-playbook</kbd> command regularly, along with all of the required parameters. This would mean having the SSH private keys installed on the server handling the automation, and means you have to keep track of which servers are running Ansible on a routine basis. This is not ideal for an enterprise where good practice is the byword of automation and ensures that everything keeps running smoothly.</p>
<p>Luckily, AWX can help us out here, too. To keep this example concise, we will reuse the LAMP stack example from the previous section of this chapter. In this scenario, we might want to schedule a one-off installation of the LAMP stack for a time when things are quiet, whereas for a routine task, it would be on an ongoing basis.</p>
<p class="mce-root"/>
<p>To set a schedule for this template, follow these steps:</p>
<ol>
<li>Click on<span class="packt_screen"> Templates</span><span> </span>on the left-hand menu bar.</li>
<li>Click on the template we created earlier.</li>
<li>Click on the<span class="packt_screen"> SCHEDULES</span><span> </span>button at the top of the<span> </span>pane.</li>
<li>Click on the green<span> </span><span class="packt_screen">+</span><span> icon </span>to add a new schedule to it.</li>
<li>Set the appropriate start date and time<span>—</span>I will set mine a few minutes from now to demonstrate it in action.</li>
<li>Also, set the appropriate timezone.</li>
<li>Finally, select the<span> </span><span class="packt_screen">REPEAT FREQUENCY</span><span>—</span>in this example, I will choose<span> </span><span class="packt_screen">None (run once)</span>, but note that other ongoing options are available from the drop-down list.</li>
<li>Click on the green<span> </span><span class="packt_screen">SAVE</span><span> </span>button to activate the schedule.</li>
</ol>
<p>When you have completed the preceding steps, the resulting configuration screen should look something like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0e8be2b3-313f-472a-8063-4aa45aa11664.png" style="width:45.67em;height:30.75em;"/></p>
<p class="mce-root"/>
<p>Now, if you watch the <span class="packt_screen">Jobs</span> pane, you should see your template start to run at the scheduled time. When you analyze the completed (or indeed running) job, you should see that it was launched by the name of the schedule you created earlier, rather than by the name of a user account such as admin (as we saw when we launched it manually). A screenshot is provided here that shows an example of a completed job that was launched by our <span class="packt_screen">Scheduled install</span> schedule that we created earlier in this section:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1941ebd7-ea00-422f-acbe-ec9d7827b5d0.png" style="width:47.42em;height:31.92em;"/></p>
<p>If you want to see all scheduled jobs that are forthcoming on your AWX instance, you can simply click on the <span class="packt_screen">Schedules</span> menu item on the left-hand menu bar, and a screen will load that lists all configured schedules in your AWX instance. For those of you familiar with Linux administration, this is akin to listing cron jobs. An example of such a screen is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/684bd26f-4715-4940-8223-a963b250e95f.png" style="width:45.08em;height:30.33em;"/></p>
<p>This gives you a concise overview of all of the schedules you have created, without having to go into the individual configuration items themselves to edit them.</p>
<p>In this way, AWX supports not just interactive automation of your Linux environment, but also hands-off scheduled automation tasks too, hence increasing the power and flexibility of your automation solution.</p>
<p>It is hoped that this overview gives you an idea of the benefits that a tool such as AWX or Ansible Tower can bring to your enterprise, and why it is beneficial to supplement your Ansible automation with this.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Ansible offers a great deal of power with just a small amount of learning, yet when deployed at a large scale in an enterprise, it can become more difficult to keep track of everything, especially which users have the latest versions of playbook code and who ran what playbook when. AWX supplements Ansible in the enterprise by bringing with it key benefits such as role-based access control, auditability, integrated source control management of playbook code, secure credential management, and job scheduling. It achieves this while providing an easy to use point and click interface, which further lowers the barrier to entry for all staff responsible for the Linux environment.</p>
<p>In this chapter, you learned why AWX is important to an Enterprise Linux environment and how to leverage a number of its key features. You then carried out a hands-on installation of a single AWX node before completing a practical end-to-end example of running a playbook directly from GitHub to install a LAMP stack on a CentOS 7 server. Finally, you learned about job scheduling to automate routine maintenance tasks using<span> </span>Ansible.</p>
<p>In the next chapter, we will look at the different deployment methodologies that are relevant to an Enterprise Linux environment and how to leverage these.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is a key advantage of using AWX to store your credentials over the methods available to you on the command line?</li>
<li>Why is it important to make good use of a version control system such as Git to store your playbooks?</li>
<li>How is AWX advantageous over Ansible on the command line when it comes to dynamic inventories?</li>
<li>What is a project in AWX?</li>
<li>What is a template in AWX analogous to on the command line?</li>
<li>How does AWX tell you which commit to a Git repository a playbook run was performed against?</li>
<li>Why is it advisable to restrict access to the server that hosts AWX, especially the shell and local filesystem?</li>
<li>If you need to programmatically launch playbook runs, how can AWX help you?</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>For an in-depth understanding of Ansible including AWX, please refer to <em>Mastering Ansible, Third Edition</em> by<em> James Freeman</em> and <em>Jesse Keating</em> (<a href="https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition">https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition</a>).</li>
<li>To achieve a greater understanding of version control with Git and best practices associated with its use, please refer to <em>Git Best Practices Guide</em> by<em> Eric Pidoux</em> (<a href="https://www.packtpub.com/application-development/git-best-practices-guide">https://www.packtpub.com/application-development/git-best-practices-guide</a>).</li>
<li>To understand how to access and work with the AWX API, please refer to <a href="https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html">https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html</a>.</li>
<li>If you wish to explore the control of AWX with the <kbd>tower-cli</kbd><span> </span>tool, please refer to the official documentation here: <a href="https://tower-cli.readthedocs.io/en/latest/">https://tower-cli.readthedocs.io/en/latest/</a>.</li>
</ul>


            </article>

            
        </section>
    </body></html>