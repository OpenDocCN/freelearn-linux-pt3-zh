- en: Automating Your IT Infrastructure with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there are numerous ways to automate tasks on Linux, there is one technology
    that stands out above the rest for automation at scale, and that is Ansible. Although
    it is entirely possible to automate a task (or tasks) easily with a shell script,
    there are a number of disadvantages to this, the most significant being that shell
    scripting does not scale up well in large environments. It should be said that
    there are other automation tools, but Ansible makes use of native communication
    protocols (for example, SSH on Linux, and WinRM on Windows) and hence is completely
    agentless! This makes deploying it into existing environments simple. While automation
    with Ansible is a huge, in-depth subject, this chapter is intended to cover the
    basics and get you up and running rapidly so that, even if you have no prior experience,
    you can follow the automation examples in this book. Indeed, this is one of the
    reasons for the rapid and widespread adoption of Ansible over the last few years—although
    it is incredibly powerful, getting started and automating your first tasks is extremely
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following Ansible topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Ansible playbook structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring inventories in Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding roles in Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Ansible variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Ansible templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bringing Ansible and the SOE together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter includes examples based on the following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu Server 18.04 LTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CentOS 7.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To run through these examples, you will need access to a server or virtual machine
    running one of the operating systems listed here, and also access to Ansible.
    Note that the examples given in this chapter may be destructive in nature (for
    example, they involve installing files and packages) and, if run as is, are only
    intended to be run in an isolated test environment.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are satisfied that you have a safe environment in which to operate,
    let's get started on looking at the installation of new software packages with
    Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: All example code discussed in this chapter is available from GitHub at: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter02](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Ansible playbook structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting up and running with Ansible is a straightforward endeavor, and packages
    are available for most major Linux distributions, FreeBSD, and just about any
    platform where Python runs. If you have a recent version of Microsoft Windows
    installed that supports the **Windows Subsystem for Linux** (**WSL**), Ansible
    even installs and runs under this.
  prefs: []
  type: TYPE_NORMAL
- en: Note, though, that there are no native Windows packages at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: The official Ansible documentation provides installation documentation for all
    major platforms. Please refer to [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html.](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html)
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, our examples will be run on Ubuntu Server 18.04.2\. However,
    as Ansible works across multiple different platforms, most examples should work
    on other operating systems too (or, at most, require minimal adaptation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the official installation documentation, the following commands are
    executed to install the latest version of Ansible on our demonstration system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes well, you should be able to query the Ansible binary for its version
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a45761cb-9567-4592-9b5f-d48c94196b6f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Congratulations! Now that Ansible is installed, let''s take a look at the fundamentals
    of running your first set of Ansible tasks, called a **playbook**. To get one
    of these to run, you actually need to have the following three things in place:'
  prefs: []
  type: TYPE_NORMAL
- en: A configuration file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An inventory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The playbook itself
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When Ansible is installed, a default configuration file is normally installed
    in `/etc/ansible/ansible.cfg`. There are many advanced features that can be changed
    through this file, and it can be overridden using a number of methods. For this
    book, we will work almost exclusively with the default settings, meaning that
    for now, it is sufficient to acknowledge the existence of this file.
  prefs: []
  type: TYPE_NORMAL
- en: To find out more about the Ansible configuration file, this document is a good
    starting point, available at [https://docs.ansible.com/ansible/latest/installation_guide/intro_configuration.html](https://docs.ansible.com/ansible/latest/installation_guide/intro_configuration.html)
  prefs: []
  type: TYPE_NORMAL
- en: Nothing happens on Ansible without an inventory. The inventory is a text file
    (or script) that provides the Ansible binaries with a list of hostnames to operate
    against, even if it is just the localhost. We will look at inventories in more
    detail in the next part of the chapter, as they are going to be important in our
    automation journey. For now, you will find that on most Linux platforms, a sample
    inventory file is installed in `/etc/ansible/hosts` as part of the Ansible installation.
    When the inventory file is empty (or contains only comments, as in the case of
    the sample one), Ansible implicitly operates against the localhost only.
  prefs: []
  type: TYPE_NORMAL
- en: Last, but by no means least, you must actually have a playbook to run against
    a server (or servers). Let's now work through an example to get a very simple
    playbook to run with Ansible. Ansible playbooks are written in YAML (a recursive
    acronym, meaning **YAML Ain't Markup Language**) and, as this is very easy to
    read—indeed, this is one of the core strengths of Ansible—playbooks can very easily
    be picked up by someone with minimal Ansible skills, and yet be easily understood,
    for either application or modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not used to writing code in Python or YAML, then the one thing you
    need to know about writing YAML for playbooks is this: indentation matters. Rather
    than using brackets or braces to define blocks of code, and semicolons to denote
    line ends (as is common in many high-level languages), YAML uses the indentation
    level itself to determine where in the code you are, and how it relates to the
    surrounding code. Indentation is always created using spaces—never use tabs. Even
    if the indentation looks the same to the naked eye, the YAML parser will not see
    it as the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is the beginning of an Ansible playbook. Ansible YAML files always start
    with three dashes (`---`), with no indentation. Next, we have a single line that
    defines the start of the play, denoted by the single dash (`-`), with no indentation.
    Note that an Ansible playbook can consist of one or more plays, with each play
    being (at a basic level) a set of tasks to be performed on a given set of hosts.
    This particular line of the playbook specifies the `name` for the play. Although
    the `name` keyword is optional in most places and can be omitted, it is strongly
    recommended to include it for all play definitions (just as we have here), and
    also, for each and every task. This, quite simply, aids the readability of the
    playbook and the speed at which someone new can pick it up, thus promoting efficiency
    and a low barrier to entry for newcomers, as we discussed in the preceding chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third line of this block tells Ansible which `hosts` the tasks included
    in the play should be run against. In this instance, we are only going to run
    against `localhost`. The fourth line tells Ansible not to `become` the superuser
    (root), as it is not required for this task. Some tasks—for example, restarting
    a system service—must be performed as the superuser and, in this case, you would
    specify `become: true`. Note the two-space indentation on both the third and fourth
    lines in the preceding code—this tells the YAML parser that the lines are part
    of the play, defined on the second line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add two tasks to our playbook by appending the following block
    of code under the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `tasks` keyword defines the end of the play definition, and the start of
    the actual tasks we wish to execute. Note that it is still indented by two spaces,
    which tells the parser it is part of the play we defined previously. We then increase
    the indentation again for the next line, to denote that this is part of the `tasks` block.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you will see a familiar pattern building up. Every time a line of code
    forms part of a preceding statement, we increase the indentation by two spaces.
    Each new item starts with a single dash (`-`), thus our preceding block of code
    contains two tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The first one uses the `name` keyword with the value `Show a message` by way
    of documentation (think of comments in other programming languages) and uses something
    called an **Ansible** **module**. Modules are predefined blocks of code that Ansible
    uses to perform given tasks. The `debug` module, included here, is used largely
    for displaying messages or variable contents and, hence, playbook debugging. We
    pass the `msg` parameter to the `debug` module by indenting `msg` by a further
    two spaces, telling the module which message we want to be printed when the playbook
    is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second task has the `name` and `Touch a file` keyword and uses the `file` module
    to touch a file located in `/tmp/foo`. When we run this playbook, the output should
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3dab3423-00d1-4ac8-8aa7-d697ae4b8df4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As a rule of thumb for most simple playbooks, tasks are run sequentially from
    top to bottom, making the order of execution predictable and easy to manage. That''s
    it! You have written and executed your first Ansible playbook. You will note how
    easy that was, and how little work was involved in integrating it with a single
    test system. Now, for such a simple example, a valid question would be: *Why go
    to all that trouble with Ansible when two lines of shell scripting could achieve
    the same thing?* An example of shell scripting can be seen in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first reason to use Ansible is that, while this example is very simple
    and easy to understand, as the required tasks for a script become more complex,
    they become much harder to read and require someone who understands shell scripting
    to debug or modify them. With the Ansible playbook, you can see that the code
    is incredibly readable, and each part has an associated `name`. The enforced indentation
    also serves to make the code more readable, and while both comments and indentation
    are supported in a shell script, neither is enforced, and they are commonly left
    out. On top of this, all modules must have documentation to be accepted into the
    core Ansible distribution—thus, you are guaranteed to have good-quality documentation
    on hand for your playbook. Module documentation can be found on the official Ansible
    website, or as part of the installed Ansible package. For example, if we wanted
    to learn how to use the `file` module we used earlier, we would simply enter the
    following  command in the shell of our system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When invoked, this command will give you the complete documentation for the
    file module, which incidentally is the same as the documentation on the official
    Ansible web site. Thus you always have the Ansible module documentation at your
    fingertips, even if the system you are working on is disconnected from the Internet.
    The following screenshot shows a page of the output from the command we just ran:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39027b91-585e-4fce-b4bf-b1d345a81f2a.png)'
  prefs: []
  type: TYPE_IMG
- en: The next reason is that the Ansible modules (mostly) offer support for idempotent
    changes. What this means is, if a change has already been made, we won't make
    it a second time. This is especially important for some changes that might be
    destructive in nature. It also saves time and compute resources, and even helps
    in auditing systems. On top of this, Ansible offers flow control and robust error
    handling and, where a shell script will continue even after an error, unless you
    integrate your own error-handling code (possibly causing unpredictable or undesirable
    results), Ansible will stop all further execution and require you to fix the problem
    before running the playbook again.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that while modules form a core part of the strength of
    Ansible, there could be times when the functionality you need is not handled by
    any of the available modules. The beauty of Ansible being **open source software**
    (**OSS**) is that you can write and integrate your own modules. This is beyond
    the scope of this book but is well worth exploring as you develop your Ansible
    skills. In instances where existing modules just don't have the required functionality,
    and you don't have the time or resources to write your own module, Ansible can
    also send raw shell commands to the system being automated. In fact, there are
    two modules—`shell` and `command`—that can send raw commands to remote systems.
    Thus, you can even mix shell scripting with Ansible if the need arises, although
    you should always use native Ansible modules before resorting to the use of `shell` or `command`.
    Ansible is incredibly flexible in this way—the built-in functionality is extensive,
    but in the event that it ever falls short, it is incredibly easy to extend the
    functionality yourself.
  prefs: []
  type: TYPE_NORMAL
- en: These benefits are just the tip of the iceberg, and we will explore some of
    the others as we proceed through this chapter. As stated earlier, this chapter
    is not intended to be exhaustive, but to serve as an introductory guide to Ansible,
    to get you started and help you understand the examples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore probably one of the biggest reasons to
    use Ansible over a simple shell script.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring inventories in Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already touched upon, one of the key reasons for the rapid uptake
    of Ansible is the fact that it can integrate, without an agent, into most major
    operating systems. For example, a single Ansible host can automate commands on
    just about any other Linux (or BSD) host to which it can connect over SSH. It
    can even automate tasks on Windows hosts that have had remote WinRM enabled, and
    it is here that we start to uncover the real power of Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section of this chapter, we only looked at Ansible running
    against the implicit localhost, without using SSH. Ansible supports two different
    kinds of inventories: static and dynamic. Throughout this book, we will mostly
    work with static inventories, as they serve the examples we are working with.
    Indeed, static inventories are perfect for small environments, where the workload
    of keeping the list of servers to be automated (which, in essence, is what an
    Ansible inventory is) is small. However, as inventories grow in scale, or remain
    small but change rapidly (for example, cloud compute resources or Docker containers),
    the work required to keep an Ansible inventory file up to date becomes much larger
    and prone to error.'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible offers a number of ready-made dynamic inventory solutions that integrate
    with popular public cloud platforms such as Microsoft Azure and Amazon Web Services,
    on-premise compute platforms such as OpenStack and VMware, and infrastructure
    management solutions such as Katello. It is even possible to write your own dynamic
    inventory scripts, and as your environment scales, you will most likely find yourself
    going down this path.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's focus on static inventories. Suppose that we want to take our
    example playbook from earlier in the chapter, and run it against two remote hosts
    rather than the localhost. First of all, let's create an inventory file that contains
    the names/addresses of the two hosts. A static inventory is written in INI format
    (as opposed to the YAML used in the playbooks) and, at its simplest level, consists
    of one host per line. Note that hosts can be specified either by DNS entry or
    by IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the inventory file for our demo environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the file is very simple. The first line, with square brackets
    around it, is the name of a group in which the servers below it are placed. Servers
    can live in more than one group, and this aids greatly in the day-to-day management
    of servers. For example, if you have a playbook to apply security updates to all
    Linux servers, then you would probably want a group called something like `[linux-servers]` that
    contains the addresses of all such servers. If you then had a playbook to deploy
    a web application, you would probably want to put all the web servers in a group
    called `[web-servers]`. This makes it easy to target the correct set of servers
    when running a given playbook—remember the `hosts:` line at the top of our playbook
    in the earlier example?
  prefs: []
  type: TYPE_NORMAL
- en: Groups can even be children of other groups. Thus, if you know your web servers
    are all based on Linux, you could specify the `web-servers` group as a child of
    the `linux-servers` group, thus including all web servers for security patching,
    without the need for duplication in the inventory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make a slight modification to our earlier playbook. The first four
    lines should now contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have now changed the `hosts` parameter from `localhost` to `all` (`all` is
    a special keyword, meaning all hosts in the inventory, regardless of group). If
    we had wanted to just specify the `test` group, we would have put in `hosts: test`,
    or even `hosts: testhost1`, for the playbook to run only against a single host.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we know that Ansible uses SSH to connect to remote Linux hosts in the
    inventory and, at this stage, we have not set up key-based SSH authentication.
    Thus, we need to tell Ansible to prompt for the SSH password (by default, it does
    not, meaning it will fail if key-based authentication is not set up). Similar
    to the SSH command-line utility, unless you tell Ansible otherwise, it will initiate
    an SSH connection to the remote system, using the username of the current session
    user on the local machine. Thus, in my example, the user `james` exists on my
    Ansible server and my two test systems, and all tasks are performed as this user.
    I can run the following command to run my playbook against my two remote systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks a little different from the last time we ran it—note the following
    new parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-i hosts`: Tells Ansible to use the file called `hosts` in the current working
    directory for the inventory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--ask-pass`: Tells Ansible to stop and prompt for the SSH password for access
    to the remote systems (it is assumed the password is the same on all systems)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simple.yml`: Tells Ansible the name of the playbook to run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see this in action, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e5755ef-d284-4c99-be50-5934aea13a32.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see that both the tasks we created earlier in the chapter have
    been run—only this time, they have been run on a pair of remote systems using
    the native SSH communication protocol. As SSH is normally enabled on most Linux
    servers, this immediately gives us massive scope for expanding our automation—this
    example has been performed on an inventory containing just two hosts, but it could
    just have easily contained 200 or more hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the tasks are still run in sequential order as before—only this time,
    each task is now run to completion on all hosts in the inventory before the next
    task is attempted, again making our playbook flow very predictable and easy to
    manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set up SSH keys for the remote hosts, then the `--ask-pass` parameter
    is no longer necessary, and the playbook runs without any interaction from the
    user, which is most desirable for many automation scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: SSH keys, while more secure than passwords, do bring their own risks, especially
    if the keys are not encrypted with a password. In this case, anyone who gets hold
    of an unencrypted private key will be able to gain remote access to any system
    with the matching public key, without any further prompt or challenge. If you
    do go down the route of setting up SSH keys, be sure you understand the security
    implications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run through a simple process to generate an SSH key and configure it
    on our test systems for Ansible to authenticate against:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a very simple SSH key-based access on our test hosts, we could run
    the following command from the Ansible host to create the key pair (do not do
    this if you already have a key pair, as you could overwrite it!):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This command silently creates a 2048-bit RSA key in the file at `~/.ssh/id_rsa`,
    with no passphrase (hence unencrypted). The corresponding public key to be copied
    to remote systems will be created as `~/.ssh/id_rsa.pub` (that is, the same filename
    and path specified by `-f`, with `.pub` appended). Now, copy it to the two remote
    hosts, using the following commands (you will be prompted for your SSH password
    both times):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can run our playbook just as we did before, but without the `--ask-pass` flag,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/443dab47-cb9e-48b9-8d1a-5cea5507a408.png)'
  prefs: []
  type: TYPE_IMG
- en: The difference, as you can see, is subtle but hugely important—no user intervention
    was required, meaning our simple playbook suddenly has massive scale across an
    environment of virtually any size.
  prefs: []
  type: TYPE_NORMAL
- en: Although here, we have taken advantage of the fact that Ansible will read (by
    default) the SSH private keys that are found in the `.ssh` directory for the user
    account in question, you are not limited to using these keys. You can specify
    a private key file manually by using the `ansible_ssh_private_key_file` host variable
    in the inventory, or you can use `ssh-agent` to make different private SSH keys
    available to Ansible in the current shell session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this is left as an exercise for you to complete, and the following pages
    from the official Ansible documentation will assist you with this:'
  prefs: []
  type: TYPE_NORMAL
- en: For an introduction to using `ssh-agent` with Ansible, please refer to[ https://docs.ansible.com/ansible/latest/user_guide/connection_details.html.](https://docs.ansible.com/ansible/latest/user_guide/connection_details.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an introduction to the inventory host variables available in Ansible, including `ansible_ssh_private_key_file`,
    please refer to [https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html.](https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, you don't need to perform all tasks on remote systems as the current
    user—you can use the `--user` (or `-u`) flag with `ansible-playbook` to specify
    a user to be used across all hosts in the inventory, or you can even use the `ansible_user` host
    variable within the inventory itself to specify user accounts on a per-host basis.
    Obviously, you should try to avoid a scenario such as this, as it goes against
    the principle of commonality that we discussed in [Chapter 1](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml),
    *Building a Standard Operating Environment on Linux*, but the important thing
    to note is that Ansible offers huge flexibility and opportunity to customize.
    It scales incredibly well in SOEs, but where there are deviations, it is easy
    to get Ansible to adapt without difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go into variables in greater detail later in this chapter, but it is
    worth mentioning at this stage that inventories can also contain variables. These
    can either be user-created variables or special variables, such as the aforementioned `ansible_user`.
    Extending our simple inventory from this chapter, if we wanted to set the SSH
    user to `bob` and create a new user-defined variable called `http_port` for use
    later in a playbook, our inventory might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That covers the basics of inventories that you will need to know to get started
    with Ansible and to proceed with this book. Hopefully, you are starting to get
    an idea of the low barrier to entry presented to new users by Ansible that has
    made it so popular.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding roles in Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As easy as Ansible is to get started with, and as readable as a playbook is
    when it is short, it does get more complex, as do the requirements. In addition,
    there are certain functions that may well be needed repeatedly in different scenarios.
    For example, you might need to deploy a MariaDB database server as a common task
    in your environment. A module called `apt` is used for managing packages on Ubuntu
    servers, and so, if we wanted to install the `mariadb-server` package on our test
    system, the playbook to perform this task could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this time, we have set `become` to `true`, as we need root privileges
    to install packages. This is, of course, a very simple example, as installing
    a database server normally requires a great deal more configuration work, but
    it serves as a starting point. We could run this on our test system, and yield
    the desired result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ea0cef2-b52a-40ac-b44e-066c91992fea.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, so good. If you had to do this on a routine basis, though, in different
    playbooks for different hosts, would you really want to be writing (or, indeed,
    copying and pasting) that tasks block from this example over and over again? Also,
    this example is simplistic, and in reality, the database deployment code would
    be far more complex. If someone makes a fix or improvement in the code, how do
    you ensure that this new revision of code is propagated into all the right places?
  prefs: []
  type: TYPE_NORMAL
- en: This is where roles come in, and an Ansible role, while in essence nothing more
    than a structured set of directories and YAML, enables efficient and effective
    reuse of code. It also makes the initial playbook easier to read, as we shall
    see shortly. Once roles are created, they can be stored in a central location,
    such as a version control repository (for example, GitHub), and then, the latest
    version can always be accessed whenever a playbook needs to install MariaDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Roles are (by default) run from a subdirectory called `roles/`, in the same
    directory as your playbook. Throughout this book, we will use this convention,
    though it must be stated that Ansible will also search for roles in `/etc/ansible/roles` and
    the paths specified by the `roles_path` parameter in the Ansible configuration
    file (which, by default, can be found in `/etc/ansible/ansible.cfg`, though there
    are ways to override this). Each role then has its own subdirectory under this,
    and that directory name forms the name of the role. Let''s explore this through
    a simple example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will get started by creating a `roles/` directory, and an `install-mariadb/` directory
    under this, for our first role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Each role has a fixed directory structure under it; however, for our simple
    example, we are only interested in one: `tasks/`. The `tasks/` subdirectory of
    a role contains the main list of tasks that will be run when the role is called,
    in a file called `main.yml`. Let''s create that directory now, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, you can use your preferred editor in place of `vi`. In the `main.yml` file,
    enter the following code—note that it is essentially the tasks block from the
    original playbook, but the indentation level has now changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created this file, we then edit our original `install-db.yml` playbook
    so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how much more compact the playbook is now! It is also a great deal easier
    to read, and yet if we run it, we can see that it performs the same function.
    Note how the state of the MariaDB server installation task was `changed` last
    time we ran it but is now `ok`. This means that Ansible detected that the `mariadb-server` package
    was already installed, and hence no further action was required. This is an example
    of the previously mentioned idempotent change in action, as can be seen in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/652109d8-f100-4d81-83a1-ab02d2eb5e9b.png)'
  prefs: []
  type: TYPE_IMG
- en: Well done! You have created and executed your first role. If you want to read
    more about roles and the required directory structure, please refer to [https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html).
  prefs: []
  type: TYPE_NORMAL
- en: There's even more to roles than this—not only are they invaluable in structuring
    your playbooks and enabling reuse of code; there is also a central repository
    for community-contributed roles, called **Ansible Galaxy**. If you search Ansible
    Galaxy for MariaDB-related roles, you will find (at the time of writing) 277 different
    roles, all designed to perform various database installation tasks. This means
    that you don't even have to write your own roles for common tasks—you can either
    make use of community-contributed ones or fork them, and modify them to your own
    ends. Most common server automation tasks have already been solved somewhere along
    the way by the Ansible community, and so it is very likely you will find exactly
    what you are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test this now, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install a role from Ansible Galaxy that installs MariaDB server on Ubuntu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will modify our playbook to reference this role instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all that is required—if we run it, we can see that this playbook performs
    many more tasks than our simple one, including a lot of the security setup that
    is good practice when installing a new database, as can be seen in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d56f1e5e-4018-4969-8d7d-908c5adc3b93.png)'
  prefs: []
  type: TYPE_IMG
- en: The end result, however, is that the `mariadb-server` package is installed on
    our test system—and this time, we barely even had to write any code! It is advisable,
    of course, to check what a role from Ansible Galaxy is going to do before blindly
    running it on your systems, in case it makes changes that you hadn't expected
    (or wanted!). Nonetheless, roles, in conjunction with Ansible Galaxy, form a powerful
    addition to the value that Ansible has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an understanding of roles under our belts, in the next section, we will
    look at an important concept to help you get the most out of your playbooks and
    roles by making their content dynamic: Ansible variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Ansible variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the examples we have looked at so far have been static in nature. This
    is fine for the simplest playbook examples, but in many cases, it is desirable
    to be able to either store values or define them easily in a central place, rather
    than having to go hunting through a playbook (and tree of roles) for a specific
    hardcoded value. As in other languages, it is also desirable to capture values
    somehow, for reuse later.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different types of variables in Ansible, and it is important
    to know that they have a strict order of precedence. Although we won't encounter
    this much in this book, it is important to be aware of this, as you might otherwise
    receive unexpected results from your variables.
  prefs: []
  type: TYPE_NORMAL
- en: More details on variable precedence can be found at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable)
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, variables can be defined in a number of locations, and the right
    location for a given scenario will be driven by the objective of the playbook.
    For example, if a variable is common to an entire group of servers, it would be
    logical to define it in the inventory as a group variable. If it applies to every
    host a specific playbook runs against regardless, then you would almost certainly
    define it in the playbook. Let''s take a quick look at this by modifying our `simple.yml` playbook
    from earlier in this chapter, this time, defining a play variable called `message` for
    our `debug` statement to display when the playbook is run, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have now defined a `vars` section before the `tasks` one and that
    the variable is accessed by placing it in pairs of curly braces. Running this
    playbook yields the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b475ffe8-4370-4e46-9683-65f5a45ce834.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you refer to the variable precedence order list, you will note that variables
    passed to the `ansible-playbook` binary on the command line are top of the list,
    and override all other variables. Thus, if we want to override the contents of
    our message variable without editing the playbook, we can do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the special quoting and escaping required to handle the spaces in the
    variable content, and the effects of this on the operation of the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76a57220-c019-4fae-ab81-6a5875a29bde.png)'
  prefs: []
  type: TYPE_IMG
- en: Variables can also be passed to roles, and are a simple yet powerful way of
    creating generic roles that can be used in a multitude of scenarios, without using
    identical configuration data. For example, in the previous section, we explored
    installing a MariaDB server. While this is a good candidate for a role, you certainly
    don't want the same root database password to be configured on every server. It
    thus makes sense to define a variable for the password, and pass this to the role
    from the calling playbook (or another appropriate source, such as a host or group
    variable).
  prefs: []
  type: TYPE_NORMAL
- en: As well as user-defined variables, Ansible also has a number of built-in variables,
    referred to as special variables. These can be accessed from anywhere in the playbook,
    and are useful for obtaining certain details pertaining to the state of the play.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you needed to know the hostname currently being acted upon for
    a specific task, this is available through the `inventory_hostname` variable.
    A full list of these variables is available at [https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html](https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'Many readers will, by now, have noticed that the output from all our example
    playbooks contains a line that says `Gathering Facts`. Although this can be turned
    off, it is, in fact, incredibly useful, and populates a wide array of variables
    with useful key system data. To get an idea of the kind of data gathered during
    this phase, run the following code from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This command, rather than running a playbook, instructs Ansible to run the `setup` module
    directly on the `localhost`—the `setup` module is the one that is run behind the
    scenes, during the `Gathering Facts` stage. The output will look something like
    this, and goes on for pages—this is just the first few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/148ad045-9ef8-48c9-a7d0-c4aa2f6493d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can immediately see there is some really useful information there, such
    as the IP addresses of the host, the root volume, and so on. Remember our discussion
    about commonality in [Chapter 1](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml),
    *Building a Standard Operating Environment on Linux*, and the difficulty in detecting
    the operating system you are running against? Well, Ansible makes this easy, as
    that data is all readily available in the gathered facts. We can modify our `debug`
    statement to display the Linux distribution we are running against, simply by
    specifying the appropriate fact, accessible from the output from the last command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run the playbook, we can easily tell we are running on Ubuntu,
    as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9f0d30a-5437-4133-973a-76327a5d3c4a.png)'
  prefs: []
  type: TYPE_IMG
- en: Ansible enables you to conditionally run individual tasks, roles, or even entire
    blocks of tasks, and hence having access to facts makes it straightforward to
    write robust playbooks that can be run against multiple platforms and perform
    the correct actions on each platform.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth noting that variables do not need to be stored in unencrypted
    text. Occasionally, it might be necessary to store a password in a variable (as
    discussed earlier—perhaps the root password for our MariaDB server install). Storing
    those details in plain text format presents a big security risk, but fortunately,
    Ansible includes a technology called **Vault**, which is capable of storing variable
    data encrypted using AES256\. These encrypted vaults can be referenced by any
    playbook, provided the vault password is passed to the playbook when it is run.
    Vaults are beyond the scope of this chapter, but if you would like to read more
    about them, please see [https://docs.ansible.com/ansible/latest/user_guide/playbooks_vault.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_vault.html).
    In this book, we will not use them extensively, simply to keep the example code
    concise. However, it is strongly recommended that in a production environment,
    you use vaults wherever sensitive data for a playbook needs to be stored.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have introduced the concept of variables in Ansible, and the various
    types available, let's take a look at an important means for managing configuration
    files in Ansible—the use of templates.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Ansible templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common automation requirement is to set a value in a configuration file,
    or even to deploy a new configuration file, based on some given parameters. Ansible
    provides modules that can perform similar functions to the venerable `sed` and `awk` utilities,
    and of course, these are valid ways to modify an existing configuration file.
    Let''s suppose we have a small Apache virtual host configuration file, containing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to deploy this configuration, but customize the `DocumentRoot` parameter
    for each host. Naturally, we could just deploy the preceding file, exactly as
    it is, to every host, and then use a regular expression, in conjunction with the
    Ansible `replace` module, to find the `DocumentRoot` line and modify it (similar
    to using the `sed` command-line utility). The resulting playbook might look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we create our sample static virtual host configuration file in `files/vhost.conf` with
    the preceding contents shown and run this playbook, we can see that it works,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f58744d-cbb1-406f-b02d-e701a3f19ba6.png)'
  prefs: []
  type: TYPE_IMG
- en: However, this is an inelegant solution. First of all, we're using two tasks,
    and if we wanted to customize `ServerName` as well, we'd need even more. Secondly,
    those who are familiar with regular expressions will know it wouldn't take much
    to trip up the simple one used here. Writing good robust regular expressions for
    tasks such as this is an art in itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, Ansible has inherited from the Python in which it is written a technology
    called **Jinja2 templating**. This is perfect for scenarios such as this (and
    many other deployment-related automation scenarios). Instead of a cumbersome multistep
    approach such as this, we now define our starting virtual host configuration file
    as a template in `templates/vhost.conf.j2`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is almost identical to our original configuration file,
    except that we have now replaced one of the static values with one of our variables,
    surrounded by pairs of curly braces, just as we would do in the playbook itself.
    Before we proceed with this example, it is worth mentioning that Jinja2 is an
    incredibly powerful templating system that goes far beyond simple variable substitution
    into a flat file. It is capable of conditional statements, such as `if...else` and `for`
    loops, and includes a wide array of filters that can be used to manipulate content
    (for example, to convert a string to uppercase, or to join the members of a list
    together to form a string).
  prefs: []
  type: TYPE_NORMAL
- en: With that said, this book is not intended as a complete language reference for
    either Ansible or Jinja2—rather, it is intended as a practical guide to show you
    how to build up your SOE using Ansible. Please refer to the *Further reading*
    section at the end of this chapter for some references, which will give you a
    more complete overview of both Ansible and Jinja2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to our example, we will modify the playbook to deploy this example,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how much more elegant this playbook is—the `template` module copies
    the configuration template to the remote host, just as the `copy` module did in
    the prior example, and also populates any variables we have specified. This is
    an incredibly powerful way to deploy configuration files in a repeatable, common
    manner, and it is highly recommended that you adopt this approach where possible.
    When human beings edit files, they often do so in an inconsistent manner, and
    that can be the enemy of automation, as you have to build a really robust regular
    expression to ensure you catch all possible edge cases. Deploying from templates
    with Ansible creates repeatable, reliable results that can easily be validated
    in a production environment. Running this playbook yields identical results to
    our previous, more complex example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75d5c782-39cc-4458-bbb8-9622ea4e9cef.png)'
  prefs: []
  type: TYPE_IMG
- en: That concludes our look at variables for now, and indeed, our crash course in
    Ansible. In the next section, we tie up everything we have learned, before drawing
    this chapter to a close.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing Ansible and the SOE together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already worked through a number of end-to-end examples with Ansible.
    Although simple, they showcase the fundamental building blocks of automation with
    Ansible, on which this book is based. A big part of achieving automation in a
    Linux environment at scale is having both good standards and robust processes.
    Hence, not only should your operating environment be standardized; so should your
    deployment and configuration processes.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the previous chapter, although a well-defined SOE will be consistent
    at the point of deployment, this consistency can soon be lost if administrators
    are allowed to make changes at will, using whatever their preferred method is.
    Just as it is desirable to deploy an SOE to achieve success in automation, so
    it is also desirable to make automation your go-to for as many (ideally all) administrative
    tasks as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, there should be one single source of truth for playbooks (for example,
    a central Git repository) and a single source of truth for inventories (this might
    be in the form of a centrally stored static inventory, or the use of a dynamic
    inventory).
  prefs: []
  type: TYPE_NORMAL
- en: The goal of any well-written Ansible playbook (or role) is that the results
    from running it are repeatable and predictable. Take, for example, the playbook
    we ran at the end of the previous section, where we were deploying a simple Apache
    `vhost.conf` file using a playbook that we wrote. Every time you run this playbook
    on any server, the contents of `/etc/apache2/sites-available/my-vhost.conf` will
    be the same, as the playbook deploys this file using a template, and overwrites
    the target file if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: This, of course, is but a microcosm of the standard operating environment, but
    such an environment will be built up of hundreds—if not thousands—of these tiny
    building blocks. After all, if you can't get your Apache configurations to be
    consistent across your infrastructure, how can you be confident that any other
    parts of it have been built in accordance with your standards?
  prefs: []
  type: TYPE_NORMAL
- en: The repeatable nature of well-written playbooks is important to mention here
    too—just because you deployed a consistent Apache configuration doesn't mean it
    will remain consistent. Five minutes after you deploy the configuration, someone
    with the required privileges could log in to the server and change the configuration.
    Thus, your environment could deviate from your SOE definition almost immediately.
    Running your Ansible playbooks repeatedly across your infrastructure is actually
    an important part of your ongoing processes, as the nature of these playbooks
    will be to bring the configuration back into line with your original standards.
    Thus Ansible playbooks are a vital component of not only defining and deploying
    your SOE but also in the ongoing enforcement of the standards.
  prefs: []
  type: TYPE_NORMAL
- en: No fixes should be manually deployed, if at all possible. Suppose someone manually
    tweaks the configuration in `/etc/apache2/sites-available/my-vhost.conf` to overcome
    an issue. This in itself is not a problem, but it is vital that these changes
    are placed back into the playbook, role, or template. If deploying or enforcing
    your SOE through Ansible somehow breaks it, then something is wrong with your
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, by implementing processes such as we have discussed so far, and will
    continue to explore throughout this book, successful automation across an enterprise
    can be achieved. The introduction to Ansible automation given in this chapter,
    while brief, serves as one part of these suggested processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is much more to learn about Ansible and, in short, I would like to propose
    a bold statement: If you can conceive it as a server deployment or configuration
    task, Ansible can help. Thanks to its open source nature, Ansible is very extensible,
    and its wide adoption means that many of the common automation challenges have
    already been solved, and relevant features included. It is hoped that this chapter
    has given you a head start on your journey into Linux automation with Ansible.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is a robust, powerful, open source tool that, once you have mastered
    a few simple concepts, can help you to achieve automation on a very large scale
    in your Linux environment. Ansible is agentless, and so requires no configuration
    on Linux client machines for you to begin your automation journey, and a robust
    community behind the project means that easy answers are available to most of
    the challenges you may wish to solve with it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned the fundamentals of playbook structure and some
    of the key files required to run a simple playbook. You learned about the importance
    of inventories and how to use them, and how to efficiently reuse code with roles
    (and indeed, how to leverage code from the community to save you time and effort).
    You learned about variables and facts, and how to reference them in playbooks,
    and how to make use of Jinja2 templating to aid your automation journey. Throughout
    this journey, you built and ran a number of complete playbooks, demonstrating
    the use of Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll discover how to streamline infrastructure management,
    and further refine your automation processes with AWX.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Ansible, and how is it different from running a simple shell script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an Ansible inventory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it generally beneficial to code your tasks into roles rather than single
    large playbooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which templating language does Ansible make use of?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you override variables in Ansible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you use the Ansible template module in place of a simple search and
    replace operation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How might you make use of Ansible facts to improve the flow of your playbook?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an in-depth understanding of Ansible and Jinja2 templating, please refer
    to *Mastering Ansible, Third Edition—**James Freeman* and *Jesse Keating* ([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
