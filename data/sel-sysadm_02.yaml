- en: '*Chapter 1*: Fundamental SELinux Concepts'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*：基本的SELinux概念'
- en: '**Security-Enhanced Linux (SELinux)** brings additional security measures to
    your Linux system to further protect its resources. As part of the Linux kernel,
    it is a mandatory access control system supported by major Linux distributions.
    In this book, we cover all aspects of SELinux, from basic fundamentals to resolving
    SELinux issues, configuring applications to deal with SELinux, and even writing
    our own policies.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**增强安全的Linux (SELinux)** 为你的Linux系统带来额外的安全措施，进一步保护其资源。作为Linux内核的一部分，它是一个由主要Linux发行版支持的强制访问控制系统。在本书中，我们涵盖了SELinux的各个方面，从基本原理到解决SELinux问题，配置应用程序以处理SELinux，甚至编写我们自己的策略。'
- en: 'Before we embark on the details of SELinux, let''s first cover the concepts
    of this technology: why SELinux uses labels to identify resources, how SELinux
    differs from traditional Linux access controls, how SELinux enforces security
    rules, and other mandatory access control systems that are supported in the Linux
    kernel. We will also see how the access control rules enforced by SELinux are
    provided through policy files. At the end of the chapter, we will cover an overview
    of the differences between SELinux implementations across Linux distributions.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨SELinux的细节之前，让我们首先介绍一下这项技术的概念：为什么SELinux使用标签来识别资源，SELinux与传统Linux访问控制的不同，SELinux如何执行安全规则，以及Linux内核中支持的其他强制访问控制系统。我们还将看到SELinux强制执行的访问控制规则是如何通过策略文件提供的。在本章的最后，我们将概述不同Linux发行版中SELinux实现的差异。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Providing more security for Linux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Linux提供更多的安全性
- en: Labeling all resources and objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对所有资源和对象进行标签化
- en: Defining and distributing policies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和分发策略
- en: Distinguishing between policies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分不同的策略
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2FFaUdm](https://bit.ly/2FFaUdm)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/2FFaUdm](https://bit.ly/2FFaUdm)
- en: Providing more security for Linux
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Linux提供更多的安全性
- en: Seasoned Linux administrators and security engineers already know that they
    need to put some trust in the users and processes of their system in order for
    the system to remain secure. This is partly because users can attempt to exploit
    vulnerabilities found in the software running on the system, but a large contribution
    to this trust level is because the secure state of the system depends on the behavior
    of the users. A Linux user with access to sensitive information could easily leak
    that out to the public, manipulate the behavior of the applications they launch,
    and do many other things that affect the security of the system. The default access
    controls active on a regular Linux system are **discretionary**; it is up to the
    users how the access controls should behave.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的Linux管理员和安全工程师已经知道，为了保持系统的安全性，他们需要对系统的用户和进程给予一定的信任。这部分是因为用户可能会尝试利用系统上运行的软件中的漏洞，但这一信任度的主要原因是系统的安全状态依赖于用户的行为。具有访问敏感信息的Linux用户可能会轻易将其泄露给公众，操控他们启动的应用程序行为，甚至做出许多其他影响系统安全的行为。常规Linux系统上默认的访问控制是**自主**的；访问控制如何行为由用户决定。
- en: 'The Linux `/etc/shadow` file, which contains the password and account information
    of the local Linux accounts:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的`/etc/shadow`文件，包含本地Linux账户的密码和账户信息：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Without additional access control mechanisms in place, this file is readable
    and writable by any process owned by the `root` user, regardless of the purpose
    of the process on the system. The `shadow` file is a typical example of a sensitive
    file that we don't want to see leaked or abused in any other fashion. Yet the
    moment someone has access to the file, that user can copy it elsewhere, for example
    to a home directory, or even mail it to another computer and attempt to attack
    the password hashes stored within.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有额外的访问控制机制，这个文件对任何由`root`用户拥有的进程都是可读和可写的，无论该进程在系统上的用途是什么。`shadow`文件是一个典型的敏感文件，我们不希望它被泄露或以其他方式滥用。然而，一旦某人有了对该文件的访问权限，该用户可以将其复制到其他地方，例如复制到主目录，甚至将其邮件发送到另一台计算机并尝试攻击其中存储的密码哈希值。
- en: Another example of how Linux DAC requires trust from its users is the configuration
    of a database server. Database files themselves are (hopefully) only accessible
    to the runtime account of the `root` user. Properly secured systems will only
    grant trusted users access to these files (for instance, through `sudo`) by allowing
    them to change their effective user ID from their personal user to the database
    runtime user or even the `root` account, but only for a well-defined set of commands
    that the system administrator has configured up front. These users too, can analyze
    the database files and gain access to potentially confidential information in
    the database without going through the DBMS. Administrators often have to put
    significant trust in these users to provide a secure system, rather than being
    able to enforce this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要用户信任的 Linux DAC 示例是数据库服务器的配置。数据库文件本身（希望如此）只对 `root` 用户的运行时账户可访问。妥善安全的系统将仅向受信任的用户授予对这些文件的访问权限（例如，通过
    `sudo`），允许他们将其有效用户 ID 从个人用户更改为数据库运行时用户，甚至是 `root` 账户，但仅限于系统管理员事先配置的一组特定命令。这些用户同样可以分析数据库文件，并访问数据库中可能的机密信息，而无需通过数据库管理系统（DBMS）。管理员往往不得不将大量信任寄托在这些用户身上，以保证系统的安全，而不是能够强制执行这些安全控制。
- en: 'However, regular users are not the only reason for securing a system. Lots
    of software daemons run as the Linux `root` user or have significant privileges
    on the system. Errors within those daemons can easily lead to information leakage
    or might even lead to remotely exploitable vulnerabilities. Backup software, monitoring
    software, change management software, scheduling software, and so on: they all
    often run with the highest privileged account possible on a regular Linux system.
    Even when the administrator does not allow privileged users, their interaction
    with daemons introduces a potential security risk. So, the users are still trusted
    to correctly interact with these applications in order for the system to function
    properly. Through this, the administrator leaves the security of the system to
    the *discretion* of its (many) users.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，普通用户并不是保障系统安全的唯一原因。许多软件守护进程以 Linux `root` 用户身份运行，或者在系统上具有重要权限。这些守护进程中的错误可能很容易导致信息泄漏，甚至可能导致可以远程利用的漏洞。备份软件、监控软件、变更管理软件、调度软件等等：它们通常都以在普通
    Linux 系统上可能拥有的最高权限账户运行。即使管理员不允许特权用户，其与守护进程的交互仍然会引入潜在的安全风险。因此，用户仍然被信任能够正确地与这些应用程序交互，以确保系统正常运行。通过这种方式，管理员将系统的安全性交给了其（众多）用户的*自行判断*。
- en: Enter SELinux, which provides an additional access control layer *on top of*
    the standard Linux DAC mechanism. SELinux provides a **mandatory access control
    (MAC)** system that, unlike its DAC counterpart, gives the administrator full
    control over what is allowed on the system and what isn't. It accomplishes this
    by supporting a policy-driven approach over what processes are and aren't allowed
    to do and by enforcing this policy through the Linux kernel.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，SELinux 就应运而生，它为标准 Linux DAC 机制提供了一个额外的访问控制层。SELinux 提供了一种**强制访问控制（MAC）**系统，不像
    DAC 机制那样，它使管理员能够完全控制系统上什么是允许的，什么是不允许的。它通过支持基于策略的方法来确定哪些进程可以做，哪些进程不能做，并通过 Linux
    内核强制执行这些策略来实现这一点。
- en: '**Mandatory** means that the operating system enforces the access control,
    defined solely by the policy rules that the system administrator (or security
    administrator) has enabled. Users and processes do not have permission to change
    the security rules, so they cannot work around the access controls; security is
    not left to their discretion anymore.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**强制**意味着操作系统执行访问控制，这些控制规则仅由系统管理员（或安全管理员）启用的策略规则定义。用户和进程没有权限更改安全规则，因此它们无法绕过访问控制；安全性不再交给他们的自行判断。'
- en: Considering the relational database example, a mandatory access control system
    would no longer require the administration to trust certain users, as it has full
    control over what these users can and cannot do. PostgreSQL, as we will see in
    [*Chapter 8*](B16276_08_Final_VK.xhtml#_idTextAnchor237), *SEPostgreSQL – Extending
    PostgreSQL with SELinux*, can interact with the SELinux subsystem to allow the
    administrator full coverage over the data access involved, even inside the database.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以关系数据库为例，强制访问控制系统将不再要求管理员信任某些用户，因为它完全控制这些用户可以做什么和不能做什么。正如我们将在 [*第 8 章*](B16276_08_Final_VK.xhtml#_idTextAnchor237)
    中看到的，*SEPostgreSQL – 通过 SELinux 扩展 PostgreSQL*，它可以与 SELinux 子系统交互，使管理员能够对数据访问进行全面控制，甚至在数据库内部也能实现这一点。
- en: 'The word *mandatory* here, just like the word *discretionary* before, was not
    chosen accidentally to describe the abilities of the access control system: both
    are known terms in the security research field. Many security publications use
    these terms, including the **Trusted Computer System Evaluation Criteria** (**TSEC**)
    ([http://csrc.nist.gov/publications/history/dod85.pdf](http://csrc.nist.gov/publications/history/dod85.pdf))
    standard (also known as the **Orange Book**) published by the Department of Defense
    in the United States of America in 1985\. This publication has led to the Common
    Criteria standard for computer security certification (ISO/IEC 15408), available
    at [http://www.commoncriteriaportal.org/cc/](http://www.commoncriteriaportal.org/cc/).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的*强制*一词，与之前的*自主*一词一样，并不是偶然选择用来描述访问控制系统的能力：这两个词在安全研究领域都是已知的术语。许多安全出版物使用这些术语，包括**可信计算机系统评估标准**（**TSEC**）（[http://csrc.nist.gov/publications/history/dod85.pdf](http://csrc.nist.gov/publications/history/dod85.pdf)）标准（也称为**橙皮书**），该标准由美国国防部于1985年发布。此出版物已促成了计算机安全认证的通用标准（ISO/IEC
    15408），详情请见[http://www.commoncriteriaportal.org/cc/](http://www.commoncriteriaportal.org/cc/)。
- en: Next, we'll describe how the Linux kernel is responsible for the SELinux implementation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将描述Linux内核如何负责SELinux的实现。
- en: Introducing Linux Security Modules (LSM)
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Linux安全模块（LSM）
- en: 'Consider the example of the `shadow` file again. A MAC system can be configured
    to only allow a limited number of processes to read from and write to the file.
    On such specifically configured systems, a user logged on as `root` cannot directly
    access the file or even move it around. They can''t even change the attributes
    of the file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 再考虑一下`shadow`文件的示例。一个MAC系统可以配置为仅允许有限数量的进程读取和写入该文件。在这种特定配置的系统上，作为`root`用户登录的用户无法直接访问该文件，甚至无法移动该文件。他们甚至不能更改文件的属性：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The system enforces this through rules that describe when the contents of this
    file can be read, or when its attributes can be changed. With SELinux, these rules
    are defined in the SELinux policy and are loaded when the system boots. It is
    the Linux kernel itself that is responsible for enforcing the rules.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 系统通过规则强制执行这些内容，这些规则描述了何时可以读取该文件的内容，或者何时可以更改其属性。在SELinux中，这些规则在SELinux策略中定义，并在系统启动时加载。正是Linux内核本身负责执行这些规则。
- en: Mandatory access control systems such as SELinux are supported in the Linux
    kernel through **Linux Security Modules** (**LSM**), a Linux subsystem called
    before processing a user space request. Such requests are called **system calls**,
    and Linux supports over 100 of them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 强制访问控制系统，如SELinux，支持通过**Linux安全模块**（**LSM**）集成到Linux内核中，这是一个在处理用户空间请求之前被调用的Linux子系统。此类请求称为**系统调用**，Linux支持超过100种系统调用。
- en: '![Figure 1.1 – High-level overview of how LSM integrates into the Linux kernel
    ](img/B16276_01_001.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – LSM如何集成到Linux内核中的高层次概述](img/B16276_01_001.jpg)'
- en: Figure 1.1 – High-level overview of how LSM integrates into the Linux kernel
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – LSM如何集成到Linux内核中的高层次概述
- en: 'LSM has been available in the Linux kernel since version 2.6, released in December
    2003\. It is a framework that provides hooks inside the Linux kernel at various
    locations, including the system call entry points. When these hooks trigger, registered
    security implementations such as SELinux have their functions executed automatically.
    In SELinux, these functions check the policy and other information before returning
    a go/no-go. LSM by itself does not provide any security functionality; instead,
    it relies on security implementations that do the heavy lifting: the framework
    is *modular*.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: LSM自2.6版本以来已在Linux内核中可用，该版本于2003年12月发布。它是一个框架，在Linux内核的多个位置提供钩子，包括系统调用入口点。当这些钩子被触发时，已注册的安全实现，如SELinux，会自动执行其功能。在SELinux中，这些功能会在返回许可/拒绝之前检查策略和其他信息。LSM本身不提供任何安全功能；相反，它依赖于执行繁重任务的安全实现：该框架是*模块化*的。
- en: 'Within the LSM framework, two types of security modules exist: exclusive and
    non-exclusive modules. Two exclusive modules cannot be active simultaneously:
    each exclusive LSM module needs exclusive control over some kernel objects (generally
    those related to a security context) and is not able to deal with other LSM modules
    that need these objects as well. Non-exclusive modules don''t have this need and
    can be combined (also known as *stacking*) at will, regardless of whether an exclusive
    LSM module is active or not.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LSM 框架内，存在两种类型的安全模块：独占模块和非独占模块。两个独占模块不能同时启用：每个独占的 LSM 模块需要对一些内核对象（通常是与安全上下文相关的对象）进行独占控制，并且无法处理其他也需要这些对象的
    LSM 模块。非独占模块没有这个需求，可以随意组合（也叫做 *堆叠*），无论是否启用了独占 LSM 模块。
- en: A major use case for stacking LSM modules is to enable different security models
    within containers running on the system. Right now, it is not possible to implement
    a different security module within a Linux container, and the security within
    the container falls back to the security module of the host. To support this,
    more and more exclusive LSM implementations (like SELinux) are working to make
    their implementation non-exclusive, and we can expect improvements in this area
    within the next year.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠 LSM 模块的一个主要用例是启用系统中运行的容器内的不同安全模型。目前，在 Linux 容器中无法实现不同的安全模块，容器内的安全性会回退到宿主机的安全模块。为了支持这一点，越来越多的独占
    LSM 实现（如 SELinux）正在努力将其实现改为非独占，我们可以预期在明年内这一领域会有所进展。
- en: 'SELinux is one implementation that uses LSM. Several other implementations
    exist:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 是使用 LSM 的一种实现方式。还有其他几种实现存在：
- en: '**AppArmor** is a mandatory access control system that has a strong focus on
    application-level protections (called profiles), based largely on filesystem paths.
    This makes AppArmor easy to understand and implement for administrators, as it
    does not have the complexity of abstracting rules to labels (as SELinux does).
    In the *Labeling all resources and objects* section, we explain why SELinux uses
    labels. AppArmor is an exclusive LSM module at the time of writing, but will most
    likely become non-exclusive very soon.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AppArmor** 是一个强制访问控制系统，专注于应用级别的保护（称为配置文件），主要基于文件系统路径。这使得 AppArmor 对管理员来说易于理解和实现，因为它不像
    SELinux 那样需要抽象规则到标签中，因此没有那么复杂。在 *标记所有资源和对象* 部分中，我们解释了为什么 SELinux 使用标签。在撰写本文时，AppArmor
    是一个独占的 LSM 模块，但很可能很快会变为非独占模块。'
- en: '**Smack** is a mandatory access control system that uses labels on processes
    and resources. The labels contain security identifiers interpreted by Smack to
    enforce access control, requiring fewer access rules in Smack (unlike SELinux,
    which does not perform an interpretation of labels – excluding sensitivity – and
    thus requires a higher number of policy rules). Smack is an exclusive LSM module.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Smack** 是一个强制访问控制系统，使用标签来标记进程和资源。这些标签包含由 Smack 解释的安全标识符，用于强制实施访问控制，要求 Smack
    中的访问规则比 SELinux 少（与 SELinux 不同，SELinux 不对标签进行解释——除了敏感性之外——因此需要更多的策略规则）。Smack 是一个独占的
    LSM 模块。'
- en: '**TOMOYO Linux** is a mandatory access control system, but its access control
    mechanism is also easy to use for system analysis. It automatically builds up
    policies based on application behavior, and like AppArmor, its policies primarily
    use paths rather than labels. TOMOYO Linux (and its fork, **AKARI**) is a non-exclusive
    LSM module.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TOMOYO Linux** 是一个强制访问控制系统，但其访问控制机制也易于进行系统分析。它会根据应用行为自动构建策略，类似于 AppArmor，它的策略主要使用路径而非标签。TOMOYO
    Linux（及其分支 **AKARI**）是一个非独占的 LSM 模块。'
- en: '**LoadPin** is an LSM module that ensures that the Linux kernel resources (such
    as kernel modules and firmware) are all loaded from a single non-writable filesystem.
    LoadPin is a non-exclusive LSM module.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoadPin** 是一个 LSM 模块，确保 Linux 内核资源（如内核模块和固件）都从一个不可写的单一文件系统加载。LoadPin 是一个非独占的
    LSM 模块。'
- en: '`ptrace`). Yama is a non-exclusive LSM module.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ptrace`）。Yama 是一个非独占的 LSM 模块。'
- en: '`setuid` (switching to another user) toward another user. Rather than granting
    the use of `setuid`, SafeSetId can limit for which users this is allowed. This
    ensures that vulnerabilities or misconfigurations in tools such as `sudo` are
    still contained. SafeSetId is a non-exclusive LSM module.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setuid`（切换到另一个用户）允许切换到另一个用户。与直接授权使用 `setuid` 不同，SafeSetId 可以限制哪些用户可以进行此操作。这样，即使工具如
    `sudo` 存在漏洞或配置错误，也能保证其仍然受到限制。SafeSetId 是一个非独占的 LSM 模块。'
- en: '**Lockdown** is an LSM module that protects the Linux kernel memory. It has
    two modes: in integrity mode, it prevents modifying kernel objects from user space
    (such as direct memory access or PCI access); in confidentiality mode, it additionally
    prevents extracting potentially confidential information from kernel objects.
    Lockdown is a non-exclusive LSM module.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lockdown** 是一个 LSM 模块，保护 Linux 内核内存。它有两种模式：在完整性模式下，它防止从用户空间修改内核对象（如直接内存访问或
    PCI 访问）；在机密性模式下，它还防止从内核对象提取潜在的机密信息。Lockdown 是一个非独占的 LSM 模块。'
- en: The **capability** LSM module is, by default, enabled on systems and provides
    support for Linux capabilities (a set of permissions granted to a user when the
    user is assigned a certain capability). It is a non-exclusive LSM module.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**capability** LSM 模块在系统上默认启用，并支持 Linux 能力（授予用户的权限集，当用户被分配某种能力时）。它是一个非独占的 LSM
    模块。'
- en: 'To query the list of active LSM modules on a system, read `/sys/kernel/security/lsm`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询系统上活动的 LSM 模块列表，可以读取`/sys/kernel/security/lsm`：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we'll explain how SELinux works on top of regular Linux access controls.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将解释 SELinux 如何在常规 Linux 访问控制之上工作。
- en: Extending regular DAC with SELinux
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SELinux 扩展常规 DAC
- en: SELinux does not change the Linux DAC implementation, nor can it override denials
    made by the Linux DAC permissions. If a regular system (without SELinux) prevents
    a particular access, there is nothing SELinux can do to override this decision.
    This is because the LSM hooks are triggered *after* the regular DAC permission
    checks execute, a conscious design decision from the LSM project.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 不会改变 Linux 的 DAC 实现，也无法覆盖由 Linux DAC 权限做出的拒绝。如果一个普通的系统（没有 SELinux）阻止了某个访问，SELinux
    无法覆盖这一决定。这是因为 LSM 钩子是在常规 DAC 权限检查执行*之后*触发的，这是 LSM 项目的一个设计决策。
- en: For instance, if you need to allow an additional user access to a file, you
    cannot add an SELinux policy to do that for you. Instead, you will need to look
    into other features of Linux, such as the use of POSIX access control lists. Through
    the `setfacl` and `getfacl` commands, the user can set additional permissions
    on files and directories, opening up the selected resource to additional users
    or groups.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你需要允许另一个用户访问某个文件，你不能通过添加 SELinux 策略来实现。相反，你需要查看 Linux 的其他功能，例如使用 POSIX
    访问控制列表。通过 `setfacl` 和 `getfacl` 命令，用户可以为文件和目录设置额外的权限，允许其他用户或组访问选定的资源。
- en: 'As an example, let''s grant a user `admin` read-write access to a file using
    `setfacl`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 `setfacl` 命令授予 `admin` 用户对文件的读写权限：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Similarly, to view the current POSIX ACLs applied to the file, use this command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要查看应用于文件的当前 POSIX ACL，可以使用此命令：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This shows that the file is writable not only by its owner but also by the `admin`
    user.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示该文件不仅可以由文件所有者写入，还可以由 `admin` 用户写入。
- en: Restricting root privileges
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制 root 权限
- en: 'The regular Linux DAC allows an all-powerful user: `root`. Unlike most other
    users on the system, the logged-on `root` user has all the rights needed to fully
    manage the entire system, ranging from overriding access controls to controlling
    audits, changing user IDs, managing the network, and much more. This is supported
    through a security concept called `man capabilities`). SELinux is also able to
    restrict access to these capabilities in a fine-grained manner.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 常规 Linux DAC 允许一个全能用户：`root`。与系统中的其他大多数用户不同，登录的 `root` 用户拥有完全管理整个系统所需的所有权限，从覆盖访问控制到控制审计、改变用户
    ID、管理网络等。这是通过一个叫做 `man capabilities` 的安全概念支持的。SELinux 也能以细粒度的方式限制对这些能力的访问。
- en: Due to this fine-grained authorization aspect of SELinux, even the `root` user
    can be confined without impacting the operations on the system. The previous example
    of accessing `/etc/shadow` is just one example of an activity that a powerful
    user such as `root` still might not be able to perform due to the SELinux access
    controls in place.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SELinux 细粒度授权的特点，即使是`root`用户也可以被限制，而不会影响系统的操作。之前访问`/etc/shadow`的例子只是一个示例，展示了像`root`这样的强大用户由于
    SELinux 的访问控制可能无法执行某些操作。
- en: Reducing the impact of vulnerabilities
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少漏洞的影响
- en: If one benefit of SELinux needs to be stressed, then it is its ability to reduce
    the impact of vulnerabilities. But this vulnerability reduction is also often
    misunderstood.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要强调 SELinux 的一个好处，那就是它能够减少漏洞的影响。但这种漏洞减少往往也被误解。
- en: A properly written SELinux policy confines applications so that their allowed
    activities are reduced to a minimum set. This **least-privilege model** ensures
    that abnormal application behavior is not only detected and audited but also prevented.
    Many application vulnerabilities can be exploited to execute tasks that an application
    is not meant to do. When this happens, SELinux will prevent this.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正确编写的SELinux政策将限制应用程序的行为，使其允许的活动减少到最小范围。这个**最小特权模型**确保不仅能够检测并审计异常的应用程序行为，还能够防止这种行为。许多应用程序的漏洞可以被利用来执行应用程序原本不应执行的任务。当这种情况发生时，SELinux将加以防止。
- en: However, there are two misconceptions about SELinux's ability to thwart exploits,
    namely, the impact of the policy and the exploitation itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有两个关于SELinux防止漏洞攻击能力的误解，即政策的影响和漏洞本身。
- en: 'If the policy is not written in a least-privilege model, then SELinux might
    consider this non-standard behavior as normal and allow the actions to continue.
    For policy writers, this means that their policy rules have to be very fine-grained.
    Sadly, that makes writing policies very time-consuming: with more than 130 classes
    and over 250 permissions known to SELinux, policy rules need to take all these
    classes and permissions into account for each interaction.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果政策没有遵循最小特权模型，那么SELinux可能会将这种非标准行为视为正常，并允许这些操作继续进行。对于政策编写者来说，这意味着他们的政策规则必须非常细致。不幸的是，这使得编写政策变得非常耗时：由于SELinux已知的有130多类和250多种权限，政策规则必须考虑到每次交互中所有这些类和权限。
- en: As a result, policies tend to become convoluted and harder to maintain. Some
    policy writers make policies more permissive than is absolutely necessary, which
    might result in exploits becoming successful even though the action is not expected
    behavior from an application's point of view. Some application policies are explicitly
    marked as unconfined (which we discuss in [*Chapter 14*](B16276_14_Final_VK.xhtml#_idTextAnchor354),
    *Dealing with New Applications*), showing that they are very liberal in their
    allowed permissions. Fedora, CentOS, and Red Hat Enterprise Linux even start application
    policies as permissive and only start enforcing access controls for those applications
    after a few releases (and additional testing).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，政策往往变得复杂，且更难维护。一些政策编写者会使政策比实际必要的更加宽松，这可能导致即使某些行为不是应用程序预期的行为，漏洞也能成功利用。一些应用程序政策明确标记为“无限制”（我们在[*第14章*](B16276_14_Final_VK.xhtml#_idTextAnchor354)中讨论，“处理新应用程序”），这表明它们在允许的权限上非常宽松。Fedora、CentOS和Red
    Hat Enterprise Linux甚至将应用程序的政策起初设为宽松，只有在经过几个版本的发布（和额外的测试）后，才会开始对这些应用程序实施访问控制。
- en: The second misconception is the exploit itself. If an application's vulnerability
    allows an unauthenticated user to use the application services as if the user
    were a regular, authorized user, then SELinux will not play a role in reducing
    the impact of the vulnerability; it will only notice the behavior of the application
    itself and not of the sessions internal to the application. As long as the application
    itself behaves as expected (such as accessing its own files and not poking around
    in other filesystems), SELinux will happily allow the actions to take place.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个误解是关于漏洞本身。如果应用程序的漏洞允许未经身份验证的用户以普通授权用户的身份使用应用程序服务，那么SELinux将无法减少漏洞的影响；它只会注意到应用程序本身的行为，而不是应用程序内部会话的行为。只要应用程序本身的行为符合预期（例如访问自己的文件，而不是乱动其他文件系统），SELinux将允许这些操作发生。
- en: It is only when the application starts behaving erratically that SELinux stops
    the exploit from continuing. SELinux will prevent exploits such as **remote command
    execution (RCE)** against applications that should not be executing random commands
    (such as database management systems or web servers, excluding CGI-like functionality),
    whereas session hijacking or SQL injection attacks are not controllable through
    SELinux policies.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当应用程序开始表现异常时，SELinux才会阻止漏洞攻击的继续。SELinux将防止诸如**远程命令执行（RCE）**等攻击，防止那些不应该执行任意命令的应用程序（如数据库管理系统或Web服务器，排除类似CGI的功能）被攻击，而会话劫持或SQL注入攻击是无法通过SELinux政策控制的。
- en: Enabling SELinux support
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用SELinux支持
- en: Enabling SELinux on a Linux system is not just a matter of enabling the SELinux
    LSM module within the Linux kernel.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统上启用SELinux不仅仅是启用Linux内核中的SELinux LSM模块。
- en: 'An SELinux implementation contains the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个SELinux的实现包含以下内容：
- en: The SELinux kernel subsystem, implemented in the Linux kernel through LSM
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux 内核子系统，通过 LSM 实现在 Linux 内核中
- en: Libraries, used by applications that need to interact with SELinux
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序用来与 SELinux 交互的库
- en: Utilities, used by administrators to interact with SELinux
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员用来与 SELinux 进行交互的实用程序
- en: Policies, which define the access controls themselves
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义访问控制本身的策略
- en: The libraries and utilities are bundled by the SELinux user space project ([https://github.com/SELinuxProject/selinux](https://github.com/SELinuxProject/selinux)).
    Next to the applications and libraries provided by the SELinux user space project,
    various components on a Linux system are updated with SELinux-specific code, including
    the `init` system and several core utilities.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库和实用程序由 SELinux 用户空间项目捆绑提供（[https://github.com/SELinuxProject/selinux](https://github.com/SELinuxProject/selinux)）。除了
    SELinux 用户空间项目提供的应用程序和库之外，Linux 系统上的各个组件也会通过 SELinux 特定的代码进行更新，包括 `init` 系统和一些核心实用程序。
- en: 'Because SELinux isn''t just a switch that needs to be toggled, Linux distributions
    that support it usually come with SELinux predefined and loaded: Fedora, CentOS,
    and Red Hat Enterprise Linux (with its derivatives, such as Oracle Linux) are
    well-known examples. Other supporting distributions might not automatically have
    SELinux enabled but can easily support it through the installation of additional
    packages (which is the case with Debian and Ubuntu), and others have a well-documented
    approach to how to convert a system to SELinux (for example, Gentoo and Arch Linux).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SELinux 不仅仅是一个需要切换的开关，支持 SELinux 的 Linux 发行版通常会预定义并加载 SELinux：Fedora、CentOS
    和 Red Hat 企业版 Linux（以及其衍生版本，如 Oracle Linux）是众所周知的例子。其他支持 SELinux 的发行版可能不会自动启用
    SELinux，但可以通过安装额外的软件包轻松支持 SELinux（例如 Debian 和 Ubuntu），还有一些发行版有文档说明如何将系统转换为 SELinux（例如
    Gentoo 和 Arch Linux）。
- en: Throughout the book, we will show examples for Gentoo and CentOS 8 (which is
    based on the free software of the Red Hat Enterprise Linux releases and is sponsored
    by Red Hat). These two distributions have different implementation details, which
    allow us to demonstrate the full potential of SELinux. To ensure the commands
    used within this book are available, some SELinux support tools might need to
    be installed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将展示 Gentoo 和 CentOS 8 的示例（CentOS 8 基于 Red Hat 企业版 Linux 发行版的自由软件，并由 Red
    Hat 赞助）。这两个发行版具有不同的实现细节，这使我们能够展示 SELinux 的全部潜力。为了确保本书中使用的命令可用，可能需要安装一些 SELinux
    支持工具。
- en: 'On Gentoo Linux, install at least the following packages:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gentoo Linux 上，至少需要安装以下软件包：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On CentOS Linux, install at least the following packages:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS Linux 上，至少需要安装以下软件包：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As packages can change over time, it is sensible to look up which package provides
    a particular command.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于软件包可能会随时间变化，查看某个特定命令提供哪个软件包是明智的做法。
- en: Important note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: If the mentioned packages no longer exist or do not cover all commands, please
    consult your distribution's documentation on which software packages to install.
    Most distributions allow searching for the most appropriate package as well, such
    as with `e-file` in Gentoo, or `yum whatprovides` on CentOS or related distributions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提到的软件包不再存在或未覆盖所有命令，请查阅您发行版的文档，了解需要安装哪些软件包。大多数发行版也允许搜索最合适的软件包，例如 Gentoo 中的
    `e-file` 或 CentOS 或相关发行版中的 `yum whatprovides`。
- en: With the SELinux main functionality described, let's look at how SELinux knows
    what is on the system, and which abstraction it uses to allow policies to be developed
    for a wide set of users.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍了 SELinux 的主要功能后，让我们来看看 SELinux 如何了解系统上的内容，以及它使用哪种抽象方法来允许为广泛的用户群体制定策略。
- en: Labeling all resources and objects
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为所有资源和对象打上标签
- en: When SELinux has to decide whether it has to allow or deny a particular action,
    it makes a decision based on the context of both the **subject** (who is initiating
    the action) and the **object** (which is the target of the action). These contexts
    (or parts of the context) are mentioned in the policy rules that SELinux enforces.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SELinux 必须决定是否允许或拒绝某个特定操作时，它会根据 **主体**（谁发起了操作）和 **客体**（操作的目标）之间的上下文做出决定。这些上下文（或上下文的一部分）在
    SELinux 强制执行的策略规则中有所提及。
- en: The **context** of a process is what identifies the process to SELinux. SELinux
    has no notion of Linux process ownership and does not care how the process is
    called, which process ID it has, and what account the process runs as. All it
    wants to know is what the context of that process is, represented to users and
    administrators as a **label**. *Label* and *context* are often used interchangeably,
    and although there is a technical distinction (one is a representation of the
    other), we will not dwell on that much.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程的上下文**是SELinux用来识别进程的。SELinux并不关心Linux进程的所有权，也不关心进程是如何命名的，它的进程ID是什么，或者该进程以什么账户运行。它只关心该进程的上下文是什么，这一上下文向用户和管理员展示为一个**标签**。*标签*和*上下文*通常可以互换使用，尽管它们之间有技术上的区别（一个是另一个的表现形式），但我们不会在此深入讨论。'
- en: 'Let''s look at an example label – the context of the current user:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例标签——当前用户的上下文：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `id` command, which returns information about the current user, is shown
    executing with the `-Z` switch (a commonly agreed upon switch for displaying additional
    security information obtained from the LSM-based security subsystem). It shows
    us the context of the current user (actually the context of the `id` process itself
    when it was executing). As we can see, the context has a string representation
    and looks as if it has five fields (it doesn't; it has four fields – the last
    field just happens to contain a colon character).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`命令返回当前用户的信息，显示了使用`-Z`选项执行的情况（这是一个常见的选项，用于显示从基于LSM的安全子系统获取的附加安全信息）。它显示了当前用户的上下文（实际上是`id`进程在执行时的上下文）。如我们所见，上下文有一个字符串表示，看起来似乎有五个字段（实际上没有，它有四个字段——最后一个字段只是恰好包含了一个冒号字符）。'
- en: 'SELinux developers decided to use labels instead of real process and file (or
    other resource) metadata for its access controls. This is different from MAC systems
    such as AppArmor, which uses the path of the binary (and thus the process name)
    and the paths of the resources to handle permission checks. The following reasons
    inspired the decision to make SELinux a label-based mandatory access control:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux的开发者决定使用标签而不是实际的进程和文件（或其他资源）元数据来进行访问控制。这与像AppArmor这样的MAC系统不同，后者使用二进制文件的路径（因此是进程名称）和资源的路径来进行权限检查。以下原因促使了SELinux采用基于标签的强制访问控制：
- en: Using paths might be easier to comprehend for administrators, but this doesn't
    allow us to keep the context information close to the resource. If a file or directory
    moves or remounts, or if a process has a different namespace view on the files,
    then the access controls might behave differently as they look at the path instead
    of the file. With label-based contexts, the system retains this information and
    keeps controlling the resource's access properly.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路径可能对管理员更容易理解，但这并不能让我们将上下文信息保持在资源附近。如果文件或目录移动或重新挂载，或者如果进程在不同的命名空间下查看文件，那么访问控制可能会表现不同，因为它们查看的是路径而非文件。通过基于标签的上下文，系统可以保留这些信息，并持续正确控制资源的访问。
- en: Contexts reveal the purpose of the process very well. The same binary application
    can be launched in different contexts depending on how it got started. The context
    value (such as the one shown in the `id -Z` output earlier) is exactly what the
    administrator needs. With it, they know what the rights are of each of the running
    instances, but they can also deduce from it how the process was launched and what
    its purpose is.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文很好地揭示了这个过程的目的。相同的二进制应用程序可以在不同的上下文中启动，具体取决于它是如何启动的。上下文值（例如前面在`id -Z`输出中看到的那个）正是管理员所需要的。有了它，他们可以知道每个运行实例的权限，但也能从中推断出该进程是如何启动的，以及它的目的是什么。
- en: Contexts also make abstractions of the object itself. We are used to talking
    about processes and files, but contexts are also applicable to less tangible resources
    such as pipes (inter-process communication) or database objects. Path-based identification
    only works as long as you can write a path.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文还对对象本身进行了抽象。我们习惯于讨论进程和文件，但上下文也适用于一些不太具体的资源，如管道（进程间通信）或数据库对象。基于路径的标识只有在你能够写出路径时才有效。
- en: 'As an example, consider the following policy statements:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，考虑以下策略声明：
- en: Allow the `httpd` processes to bind to TCP port `80`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许`httpd`进程绑定到TCP端口`80`。
- en: Allow the processes labeled with `httpd_t` to bind to TCP ports labeled with
    `http_port_t`.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许标记为`httpd_t`的进程绑定到标记为`http_port_t`的TCP端口。
- en: 'In the first example, we cannot easily reuse this policy when the web server
    process isn''t using the `httpd` binary (perhaps because it was renamed or it
    isn''t Apache but another web server) or when we want to have HTTP access on a
    different port. With the labeled approach, the binary could be called `apache2`
    or `MyWebServer.py`; as long as the process is labeled with `httpd_t`, the policy
    applies. The same happens with the port definition: you can label the port `8080`
    with `http_port_t` and thus allow the web servers to bind to that port as well
    without having to write another policy statement.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，当Web服务器进程不使用`httpd`二进制文件（可能因为已重命名或者不是Apache而是另一个Web服务器）或者当我们希望在不同端口上具有HTTP访问时，我们不能轻松地重用此策略。使用标记方法，二进制文件可以称为`apache2`或`MyWebServer.py`；只要进程以`httpd_t`标记，策略就适用。端口定义也是如此：您可以使用`http_port_t`标记端口`8080`，从而允许Web服务器绑定到该端口，而无需编写另一个策略语句。
- en: Dissecting the SELinux context
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析SELinux上下文
- en: 'To come to a context, SELinux uses at least three, and sometimes four, values.
    Let''s look at the context of the SSH server as an example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要达到上下文，SELinux使用至少三个，有时是四个值。让我们以SSH服务器的上下文为例：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we can see, the process is assigned a context that contains the following
    fields:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，进程被分配一个包含以下字段的上下文：
- en: The SELinux user `system_u`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux用户`system_u`
- en: The SELinux role `system_r`
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux角色`system_r`
- en: The SELinux type (also known as the domain when we are looking at a running
    process) `sshd_t`
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux类型（当我们查看运行中进程时也称为域）`sshd_t`
- en: The sensitivity level `s0-s0:c0.c1023`
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏感级别`s0-s0:c0.c1023`
- en: When we work with SELinux, knowing the contexts is extremely important. In most
    cases, it is the third field (called the **domain** or **type**) that is most
    important since the majority of SELinux policy rules (over 99 percent) consist
    of rules related to the interaction between two types (without mentioning roles,
    users, or sensitivity levels).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用SELinux时，了解上下文非常重要。在大多数情况下，第三个字段（称为**domain**或**type**）最重要，因为超过99%的SELinux策略规则涉及两个类型之间的交互（而不涉及角色、用户或敏感级别）。
- en: SELinux contexts are aligned with LSM security attributes and exposed to the
    user space in a standardized manner (compatible with multiple LSM implementations),
    allowing end users and applications to easily query the contexts. An easily accessible
    location where these attributes are presented is within the `/proc` pseudo filesystem.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux上下文与LSM安全属性对齐，并以标准化的方式向用户空间公开（与多个LSM实现兼容），允许最终用户和应用程序轻松查询上下文。这些属性呈现的一个方便获取的位置是在`/proc`伪文件系统中。
- en: 'Inside each process''s `/proc/<pid>` location, we find a subdirectory called
    `attr`, inside of which the following files can be found:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个进程的`/proc/<pid>`位置，我们可以找到一个名为`attr`的子目录，在其中可以找到以下文件：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All these files, if read, display either nothing or an SELinux context. If it
    is empty, then that means the application has not explicitly set a context for
    that particular purpose, and the SELinux context will be deduced either from the
    policy or inherited from its parent.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些文件，如果阅读，要么显示为空，要么显示一个SELinux上下文。如果为空，则意味着该应用程序未明确为该特定目的设置上下文，SELinux上下文将从策略中推断或从其父级继承。
- en: 'The meaning of the files are as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的含义如下：
- en: The `current` file displays the current SELinux context of the process.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current`文件显示进程当前的SELinux上下文。'
- en: The `exec` file displays the SELinux context that will be assigned by the next
    application execution done through this application. It is usually empty.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec`文件显示由此应用程序执行的下一个应用程序执行分配的SELinux上下文。通常为空。'
- en: The `fscreate` file displays the SELinux context that will be assigned to the
    next file written by the application. It is usually empty.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fscreate`文件显示由应用程序编写的下一个文件分配的SELinux上下文。通常为空。'
- en: The `keycreate` file displays the SELinux context that will be assigned to the
    keys cached in the kernel by this application. It is usually empty.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keycreate`文件显示将由此应用程序在内核中缓存的密钥分配的SELinux上下文。通常为空。'
- en: The `prev` file displays the previous SELinux context for this particular process.
    This is usually the context of its parent application.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prev`文件显示此特定进程的先前SELinux上下文。通常是其父应用程序的上下文。'
- en: The `sockcreate` file displays the SELinux context that will be assigned to
    the next socket created by the application. It is usually empty.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sockcreate`文件显示将由应用程序创建的下一个套接字分配的SELinux上下文。通常为空。'
- en: If an application has multiple subtasks, then the same information is available
    in each subtask directory at `/proc/<pid>/task/<taskid>/attr`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序有多个子任务，那么相同的信息可以在每个子任务目录中找到，路径为`/proc/<pid>/task/<taskid>/attr`。
- en: Enforcing access through types
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过类型强制执行访问控制
- en: 'The SELinux type (the third part of an SELinux context) of a process (called
    the **domain**) is the basis of the fine-grained access controls of that process
    with respect to itself and other types (which can be processes, files, sockets,
    network interfaces, and more). In most SELinux literature, SELinux''s label-based
    access control mechanism is fine-tuned to say that SELinux is a **type enforcement**
    mandatory access control system: when some actions are denied, the (absence of
    the) fine-grained access controls on the type level are most likely to blame.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的 SELinux 类型（SELinux 上下文的第三部分）（称为**领域**）是该进程与自己及其他类型（可以是进程、文件、套接字、网络接口等）之间精细粒度访问控制的基础。在大多数
    SELinux 文献中，SELinux 的标签基础访问控制机制被微调为 SELinux 是一个**类型强制**的强制访问控制系统：当某些操作被拒绝时，（类型层面的）精细粒度访问控制的缺失很可能是原因所在。
- en: 'With type enforcement, SELinux can control an application''s behavior based
    on how it got executed in the first place: a web server launched by a user will
    run with a different type than a web server executed through the `init` system,
    even though the process binary and path are the same. The web server launched
    from the `init` system is most likely trusted (and thus allowed to do whatever
    web servers are supposed to do), whereas a manually launched web server is less
    likely to be considered *normal behavior* and as such will have different privileges.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类型强制，SELinux 可以根据应用程序最初是如何执行的来控制其行为：由用户启动的 Web 服务器将与通过 `init` 系统执行的 Web 服务器使用不同的类型，即使它们的进程二进制文件和路径相同。通过
    `init` 系统启动的 Web 服务器最有可能被信任（因此允许执行 Web 服务器应该做的任何操作），而手动启动的 Web 服务器则不太可能被视为*正常行为*，因此将具有不同的权限。
- en: Important note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The majority of SELinux's online resources focus on types. Even though the SELinux
    type is just the third part of an SELinux context, it is the most important one
    for most administrators. Most documentation will even just talk about a type such
    as `sshd_t` rather than a full SELinux context.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 SELinux 的在线资源都集中在类型上。尽管 SELinux 类型只是 SELinux 上下文的第三部分，但对于大多数管理员来说，它是最重要的一部分。大多数文档甚至会只谈论像`sshd_t`这样的类型，而不是完整的
    SELinux 上下文。
- en: 'Take a look at the following `dbus-daemon` processes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下 `dbus-daemon` 进程：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, one `dbus-daemon` process is the system D-Bus daemon running
    with the aptly named `system_dbusd_t` type, whereas two other ones are running
    with the `swift_dbusd_t` type assigned to it. Even though their binaries are the
    same, they both serve a different purpose on the system and as such have a different
    type assigned. SELinux then uses this type to govern the actions allowed by the
    process toward other types, including how `system_dbusd_t` can interact with `swift_dbusd_t`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个 `dbus-daemon` 进程是运行的系统 D-Bus 守护进程，使用了恰如其名的 `system_dbusd_t` 类型，而另外两个则使用了
    `swift_dbusd_t` 类型。尽管它们的二进制文件相同，但它们在系统中的作用不同，因此分配了不同的类型。SELinux 然后使用该类型来管理进程对其他类型的操作，包括
    `system_dbusd_t` 如何与 `swift_dbusd_t` 进行交互。
- en: SELinux types are by convention suffixed with `_t`, although this is not mandatory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 类型按照约定以 `_t` 结尾，尽管这并非强制要求。
- en: Granting domain access through roles
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过角色授予领域访问权限
- en: SELinux roles (the second part of an SELinux context) allow SELinux to support
    role-based access controls. Although type enforcement is the most used (and known)
    part of SELinux, role-based access control is an important method to keep a system
    secure, especially from malicious user attempts. SELinux roles define which types
    (domains) can be accessed from the current context. These types (domains) on their
    part define the permissions. As such, SELinux roles help define what a user (who
    has access to one or more roles) can and cannot do.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 角色（SELinux 上下文的第二部分）允许 SELinux 支持基于角色的访问控制。尽管类型强制是 SELinux 中最常用（且最知名）的部分，基于角色的访问控制仍然是确保系统安全的重要方法，尤其是防止恶意用户尝试。SELinux
    角色定义了当前上下文可以访问哪些类型（领域）。这些类型（领域）又定义了权限。因此，SELinux 角色有助于定义一个用户（有权访问一个或多个角色）能做什么以及不能做什么。
- en: 'By convention, SELinux roles are defined with an `_r` suffix. On most SELinux-enabled
    systems, the administrator can assign the following SELinux roles to users:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 按约定，SELinux 角色定义时以 `_r` 结尾。在大多数启用 SELinux 的系统中，管理员可以为用户分配以下 SELinux 角色：
- en: The `user_r` role is meant for restricted users. This role is only allowed to
    have processes with types specific to end-user applications. Privileged types,
    including those used to switch to another Linux user, are not allowed for this
    role.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_r`角色用于受限用户。这个角色只允许具有特定于端用户应用程序的类型的进程。不允许使用特权类型，包括用于切换到另一个Linux用户的类型。'
- en: The `staff_r` role is meant for non-critical operations. This role is generally
    restricted to the same applications as the restricted user, but it has the ability
    to switch roles. It is the default role for operators to have (so as to keep those
    users in their least privileged role as long as possible).
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`staff_r`角色用于非关键操作。这个角色通常受限于与受限用户相同的应用程序，但具有切换角色的能力。这是操作员拥有的默认角色（以尽可能保持用户在最低特权角色下的状态）。'
- en: The `sysadm_r` role is meant for system administrators. This role is very privileged,
    enabling various system administration tasks. However, certain end-user application
    types might not be supported (especially if those types are used for potentially
    vulnerable or untrusted software) to keep the system free from infections.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sysadm_r`角色用于系统管理员。这个角色非常特权，能够执行各种系统管理任务。但是，某些端用户应用程序类型可能不受支持（特别是如果这些类型用于潜在的易受攻击或不受信任的软件），以保持系统免受感染。'
- en: The `secadm_r` role is meant for security administrators. This role allows changing
    the SELinux policy and manipulating the SELinux controls. It is generally used
    when a separation of duties is needed between system administrators and system
    policy management.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secadm_r`角色用于安全管理员。这个角色允许更改SELinux策略并操作SELinux控制。通常在需要系统管理员和系统策略管理之间进行职责分离时使用。'
- en: The `system_r` role is meant for daemons and background processes. This role
    is quite privileged, supporting the various daemon and system process types. However,
    end-user application types and other administrative types are not allowed in this
    role.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system_r`角色用于守护进程和后台进程。这个角色非常特权，支持各种守护进程和系统进程类型。然而，不允许使用此角色进行端用户应用程序类型和其他管理类型的操作。'
- en: The `unconfined_r` role is meant for end users. This role allows a limited number
    of types, but those types are very privileged as they allow running any application
    launched by a user (or another unconfined process) in a more or less unconfined
    manner (not restricted by SELinux rules). This role, as such, is only available
    if the system administrator wants to protect certain processes (mostly daemons)
    while keeping the rest of the system operations almost untouched by SELinux.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unconfined_r`角色用于端用户。这个角色允许有限数量的类型，但这些类型非常特权，因为它们允许以几乎无限制的方式运行用户（或另一个未受限制的进程）启动的任何应用程序（不受SELinux规则限制）。因此，只有当系统管理员希望保护某些进程（主要是守护进程）而保持系统其余操作几乎不受SELinux限制时，才会提供此角色。'
- en: 'Other roles might exist, such as `guest_r` and `xguest_r`, depending on the
    distribution. It is wise to consult the distribution documentation for more information
    about the supported roles. The `seinfo` command is the most common method to obtain
    an overview of available roles:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其他角色可能存在，例如`guest_r`和`xguest_r`，具体取决于发行版。建议查阅发行版文档获取更多关于支持角色的信息。最常用的获取可用角色概览的方法是使用`seinfo`命令：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the SELinux roles identified, let's look at how we assign roles to users.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 识别了SELinux角色后，让我们看看如何将角色分配给用户。
- en: Limiting roles through users
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过用户限制角色
- en: An SELinux user (the first part of an SELinux context) is not the same as a
    Linux (account) user. Unlike Linux user information, which can change while the
    user is working on the system (through tools such as `sudo` or `su`), the SELinux
    policy can (and generally will) enforce that the SELinux user remains the same
    even when the Linux user itself has changed. Because of the immutable state of
    the SELinux user, we can implement specific access controls to ensure that users
    cannot work around the set of permissions granted to them, even when they get
    privileged access.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux用户（SELinux上下文的第一部分）并非与Linux（账户）用户相同。与Linux用户信息不同的是，SELinux策略可以（并且通常会）强制保持SELinux用户即使Linux用户自身已更改也保持不变。由于SELinux用户的不可变状态，我们可以实施特定的访问控制，以确保用户无法绕过授予他们的权限集，即使他们获得特权访问也是如此。
- en: An example of such an access control is the **user-based access control** (**UBAC**)
    feature that some Linux distributions (optionally) enable, which prevents users
    from accessing files of different SELinux users even when those users try to use
    the Linux DAC controls to grant access to each other's files.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种访问控制的一个示例是某些 Linux 发行版（可选）启用的**基于用户的访问控制**（**UBAC**）功能，阻止用户在即使那些用户尝试使用 Linux
    DAC 控制来授予对彼此文件的访问时，访问不同 SELinux 用户的文件。
- en: 'The most important feature of SELinux users, however, is that SELinux user
    definitions restrict which roles the (Linux) user can assume. A Linux user is
    first assigned to an SELinux user, which does not need to be unique: multiple
    Linux users can be assigned to the same SELinux user. Once set, that user cannot
    switch to an SELinux role not associated with that SELinux user.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，SELinux 用户最重要的特性是，SELinux 用户定义限制了（Linux）用户可以承担的角色。Linux 用户首先被分配给一个 SELinux
    用户，且该用户不需要唯一：多个 Linux 用户可以分配给同一个 SELinux 用户。一旦设置，该用户不能切换到未与该 SELinux 用户关联的 SELinux
    角色。
- en: 'The following diagram shows the role-based access control implementation of
    SELinux:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 SELinux 的基于角色的访问控制实现：
- en: '![Figure 1.2 – Mapping Linux accounts to SELinux users ](img/B16276_01_002.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 将 Linux 账户映射到 SELinux 用户](img/B16276_01_002.jpg)'
- en: Figure 1.2 – Mapping Linux accounts to SELinux users
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 将 Linux 账户映射到 SELinux 用户
- en: '`_u` suffix, although this is not mandatory. The SELinux users that most distributions
    have available are named after the role they represent, but instead of ending
    with `_r`, they end with `_u`. For instance, for the `sysadm_r` role, we have
    the `sysadm_u` SELinux user.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`_u` 后缀，尽管这不是强制性的。大多数发行版中可用的 SELinux 用户名称是根据它们所代表的角色命名的，但它们的结尾是 `_u`，而不是 `_r`。例如，对于
    `sysadm_r` 角色，我们有 `sysadm_u` SELinux 用户。'
- en: Controlling information flow through sensitivities
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过敏感性控制信息流
- en: The fourth part of an SELinux context, the sensitivity, is not always present
    (some Linux distributions, by default, do not enable sensitivity labels, but most
    do). This part of the label is needed for the `s`) and a category value (prefixed
    with `c`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 上下文的第四部分是敏感性，这部分并非总是存在（某些 Linux 发行版默认不启用敏感性标签，但大多数会启用）。标签的这一部分对于 `s`
    和一个类别值（前缀为 `c`）是必要的。
- en: 'In many larger organizations and companies, documents are labeled internal,
    confidential, or strictly confidential. SELinux can assign processes certain clearance
    levels for these resources. With MLS, we can configure SELinux to follow the **Bell-LaPadula**
    model, a security model characterized by *no read up, no write down*: based on
    a process''s clearance level, that process cannot read anything with a higher
    confidentiality level nor write to (or communicate otherwise with) any resource
    with a lower confidentiality level. SELinux does not use internal, confidential,
    and other labels. Instead, it uses numbers from zero (the lowest confidentiality)
    to whatever the system administrator has defined as the highest value (this is
    configurable and set when the SELinux policy is built).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多较大的组织和公司中，文档被标记为内部、机密或严格机密。SELinux 可以为这些资源分配进程的某些安全级别。通过 MLS，我们可以配置 SELinux
    以遵循**贝尔-拉帕杜拉**模型，这是一种以*禁止向上读取，禁止向下写入*为特征的安全模型：根据进程的安全级别，该进程不能读取任何具有更高机密性级别的内容，也不能写入（或与之通信）任何具有较低机密性级别的资源。SELinux
    不使用内部、机密和其他标签，而是使用从零（最低机密性）到系统管理员定义的最高值的数字（这是可配置的，并且在构建 SELinux 策略时设置）。
- en: Categories allow us to assign resources with one or more categories, and to
    define access controls across categories. One of the functionalities resulting
    from using categories is to support multitenancy (for example, systems hosting
    applications for multiple customers) within a Linux system. Multitenancy is provided
    by assigning a set of categories to the processes and resources of one tenant,
    whereas the processes and resources of another tenant get a different set of categories.
    When a process does not have the proper categories assigned, it cannot touch the
    resources (or other processes) that have other categories assigned.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 分类使我们能够为资源分配一个或多个类别，并定义跨类别的访问控制。使用分类的一个功能是支持多租户（例如，为多个客户托管应用程序的系统）在 Linux 系统中的实现。多租户通过为一个租户的进程和资源分配一组类别来提供，而另一个租户的进程和资源则获得不同的类别。当进程没有分配正确的类别时，它无法访问具有其他类别的资源（或其他进程）。
- en: Important note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: An unwritten convention in the SELinux world is that (at least) two categories
    are used to differentiate between tenants. By having services randomly pick two
    categories for a tenant out of a predefined set of categories, while ensuring
    each tenant has a unique combination, these services receive proper isolation.
    The use of two categories is not mandatory, but services such as sVirt and Docker
    successfully implement this methodology.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SELinux 的世界里，有一个不成文的约定，那就是（至少）使用两种类别来区分不同的租户。通过让服务在预定义的类别集中随机选择两个类别来为租户分配，同时确保每个租户都有独特的组合，这些服务实现了适当的隔离。使用两种类别并不是强制性的，但像
    sVirt 和 Docker 这样的服务成功地实现了这一方法。
- en: In that sense, categories are like tags, allowing us to grant access only when
    the tags of the process and the target resource match. As multilevel security
    is not often used, the benefits of only using categories are persisted in what
    is called `s0`).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，类别就像标签，只在进程和目标资源的标签匹配时才允许访问。由于多级安全性并不常用，仅使用类别的好处被保留在所谓的 `s0` 中。
- en: Now that we know how labels are used by SELinux policies, let's look at how
    SELinux policies are defined and distributed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道 SELinux 策略如何使用标签，让我们来看看 SELinux 策略是如何定义和分发的。
- en: Defining and distributing policies
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和分发策略
- en: Enabling SELinux does not automatically start the enforcement of access. If
    SELinux is enabled and it cannot find a policy, it will refuse to start because
    the policy defines the behavior of the system (what SELinux should allow). SELinux
    policies are generally distributed in a compiled form (just like with software)
    as policy modules. These modules are then aggregated into a single policy store
    and loaded in memory to allow SELinux to enforce the policy rules on the system.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 SELinux 并不会自动开始执行访问控制。如果 SELinux 被启用但找不到策略，它将拒绝启动，因为策略定义了系统的行为（SELinux 应该允许什么）。SELinux
    策略通常以编译后的形式分发（就像软件一样），作为策略模块。这些模块随后会被聚合到一个单独的策略存储区，并加载到内存中，以便 SELinux 在系统上执行策略规则。
- en: Important note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Gentoo, a source-based meta-distribution, distributes SELinux policies as (source)
    code, compiled and built at install time, just like it does with other software.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Gentoo，一个基于源代码的元发行版，将 SELinux 策略分发为（源）代码，在安装时编译和构建，就像它处理其他软件一样。
- en: 'The following diagram shows the relationship between **policy rules** (**policy
    code**), **policy modules**, and a **policy package** (which is often a one-to-one
    mapping toward a **policy store**):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 **策略规则**（**策略代码**）、**策略模块**和 **策略包**（通常是与 **策略存储** 一一映射）之间的关系：
- en: '![Figure 1.3 – Relationship between policy rules (code), policy modules, and
    policy store ](img/B16276_01_003.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 策略规则（代码）、策略模块和策略存储的关系](img/B16276_01_003.jpg)'
- en: Figure 1.3 – Relationship between policy rules (code), policy modules, and policy
    store
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 策略规则（代码）、策略模块和策略存储的关系
- en: As we can see, policies are first written, then compiled in modules, after which
    they are bundled and distributed. The next few sections describe each of these
    phases in detail.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，策略首先被编写，然后编译成模块，之后这些模块被打包并分发。接下来的几个部分将详细描述这些阶段的过程。
- en: Writing SELinux policies
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 SELinux 策略
- en: 'An SELinux policy writer can write down the policy rules in three possible
    languages:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 策略编写者可以使用三种可能的语言编写策略规则：
- en: In standard SELinux source format – a human-readable and well-established language
    for writing SELinux policies
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标准的 SELinux 源格式中 —— 这是一种人类可读且已广泛应用的编写 SELinux 策略的语言
- en: In reference policy style, which extends the standard SELinux source format
    with M4 macros to facilitate the development of policies
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参考策略样式，它通过 M4 宏扩展了标准的 SELinux 源格式，以促进策略的开发
- en: In the SELinux **common intermediate language** (**CIL**) – a computer-readable
    (and with some effort, human-readable) format for SELinux policies
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SELinux **通用中间语言** (**CIL**) —— 这是一个计算机可读（并且经过一定努力后可供人类阅读）的 SELinux 策略格式
- en: Most SELinux supporting distributions base their policy on the reference policy
    ([https://github.com/SELinuxProject/refpolicy/](https://github.com/SELinuxProject/refpolicy/)),
    a fully functional SELinux policy set managed as a free software project. This
    allows distributions to ship with a functional policy set rather than having to
    write one themselves. Many project contributors are distribution developers, trying
    to push changes of their distribution to the reference policy project itself,
    where the changes are peer-reviewed to ensure no rules are brought into the project
    that might jeopardize the security of any platform. Writing policies without the
    extensive set of M4 macros offered by the reference policy project is hard, which
    is why the reference policy has become the de facto source for policies.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数支持SELinux的发行版基于参考策略（[https://github.com/SELinuxProject/refpolicy/](https://github.com/SELinuxProject/refpolicy/)）编写其策略，这是一个完全功能的SELinux策略集，作为自由软件项目进行管理。这使得发行版可以携带一个功能完整的策略集，而无需自己编写一个。许多项目贡献者是发行版开发者，他们试图将自己发行版的更改推送到参考策略项目中，这些更改会经过同行评审，以确保不会引入可能危及任何平台安全的规则。在没有参考策略项目提供的丰富M4宏集的情况下编写策略是困难的，这就是为什么参考策略已经成为政策的事实标准来源。
- en: The SELinux CIL format is reasonably recent, and although it is very much in
    use already (the SELinux user space converts everything to CIL in the background),
    it is not that common yet for policy writers to use it directly.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux CIL格式相对较新，尽管它已经在广泛使用（SELinux用户空间在后台将一切转换为CIL），但策略编写者直接使用它的情况尚不常见。
- en: 'To show the differences between these three languages, consider the web server
    rule we discussed earlier, repeated here for your convenience: allow the processes
    labeled with `httpd_t` to bind to TCP ports labeled with `http_port_t`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这三种语言之间的差异，考虑我们之前讨论过的Web服务器规则，方便起见再重复一遍：允许标记为`httpd_t`的进程绑定到标记为`http_port_t`的TCP端口。
- en: 'In the standard SELinux source format, we write this down as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准SELinux源格式中，我们将其写为如下：
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using reference policy style, this rule is part of the following macro call:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参考策略风格，这个规则是以下宏调用的一部分：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the CIL language, the rule expression is like so:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在CIL语言中，规则表达式如下：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In most representations, we can see what the rule is about:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数表示中，我们可以看到规则的内容：
- en: The subject (who is taking the action); in this case, this is the set of processes
    labeled with the `httpd_t` type.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体（谁在执行操作）；在此情况下，这是标记为`httpd_t`类型的进程集合。
- en: The target resource or object (the target for the action); in this case, it
    is the set of TCP sockets (`tcp_socket`) labeled with the `http_port_t` type.
    In reference policy style, this is implied by the function name.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标资源或对象（行动的目标）；在此情况下，它是标记为`http_port_t`类型的TCP套接字（`tcp_socket`）。在参考策略风格中，这是通过函数名称隐含的。
- en: The action or permission; in this case, it is the action of binding to a port
    (`name_bind`). In reference policy style, this is implied by the function name.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动或权限；在此情况下，它是绑定端口的操作（`name_bind`）。在参考策略风格中，这是通过函数名称隐含的。
- en: The result that the policy will enforce; in this case, it is that the action
    is allowed (`allow`). In reference policy style, this is implied by the function
    name.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略将强制执行的结果；在此情况下，它是允许执行该操作（`allow`）。在参考策略风格中，这是通过函数名称隐含的。
- en: A policy is generally written for an application or set of applications. So,
    the preceding example will be part of the policy written for web servers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 策略通常是为一个应用程序或一组应用程序编写的。因此，前面的示例将成为为Web服务器编写的策略的一部分。
- en: 'Policy writers will generally create three files per application or application
    set:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 策略编写者通常会为每个应用程序或应用程序集创建三个文件：
- en: A `.te` file, which contains the type enforcement rules.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`.te`文件，包含类型强制规则。
- en: A `.if` file, which contains interface and template definitions, allowing policy
    writers to easily use the newly-generated policy rules to enhance other policies.
    You can compare this to header files in other programming languages.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`.if`文件，包含接口和模板定义，允许策略编写者轻松使用新生成的策略规则来增强其他策略。你可以将其与其他编程语言中的头文件进行比较。
- en: A `.fc` file, which contains file context expressions. These are rules that
    assign labels to resources on the filesystem.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`.fc`文件，包含文件上下文表达式。这些是将标签分配给文件系统资源的规则。
- en: A finished policy is then packaged into an SELinux policy module.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的策略随后会打包成SELinux策略模块。
- en: Distributing policies through modules
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过模块分发策略
- en: 'Initially, SELinux used a single, monolithic policy approach: all possible
    access control rules were maintained in a single policy file. It quickly became
    clear that this is not manageable in the long term, and the idea of developing
    a modular policy approach was born.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，SELinux 使用单一的、单体的策略方法：所有可能的访问控制规则都保存在一个单一的策略文件中。很快就显而易见，这种方式从长远来看无法管理，于是开发模块化策略的方法应运而生。
- en: Within the modular approach, policy developers can write isolated policy sets
    for a particular application (or set of applications), roles, and so on. These
    policies then get built and distributed as policy modules. Platforms that need
    access controls for a particular application load the SELinux policy module that
    defines the access rules for that application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块化方法中，策略开发者可以为特定应用程序（或应用程序集）、角色等编写独立的策略集。然后，这些策略将被构建并作为策略模块分发。需要为特定应用程序提供访问控制的平台会加载定义该应用程序访问规则的
    SELinux 策略模块。
- en: 'The following diagram shows the building of policy modules. It also shows where
    CIL comes into play, even when the policy rules themselves are not written in
    CIL:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了策略模块的构建过程。它还展示了即使策略规则本身不是用 CIL 编写的，CIL 也如何发挥作用：
- en: '![Figure 1.4 – Build process from policy rule to policy store ](img/B16276_01_004.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 从策略规则到策略存储的构建过程](img/B16276_01_004.jpg)'
- en: Figure 1.4 – Build process from policy rule to policy store
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 从策略规则到策略存储的构建过程
- en: 'The binary `*.pp` files (which are the SELinux policy modules) are considered
    to be written in a **high-level language** (**HLL**). Do not assume that this
    means they are human-readable: these files are binary files. The consideration
    here is that SELinux wants to support writing SELinux policies in a number of
    formats, which it calls high-level languages, as long as it has a parser that
    can convert the files into CIL. Marking the binary module formats (which in previous
    SELinux versions were the binary blobs loaded in memory) as high-level allows
    the SELinux project to introduce the distinction between high-level languages
    and CIL in a backward-compatible manner.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制 `*.pp` 文件（即 SELinux 策略模块）被认为是用**高级语言**（**HLL**）编写的。但不要以为这意味着它们是人类可读的：这些文件是二进制文件。这里的考虑是，SELinux
    希望支持以多种格式编写 SELinux 策略，这些格式被称为高级语言，只要有一个能够将文件转换为 CIL 的解析器。将二进制模块格式（在早期版本的 SELinux
    中，这些是加载到内存中的二进制块）标记为高级语言，允许 SELinux 项目以向后兼容的方式引入高级语言和 CIL 之间的区别。
- en: When distributing SELinux policy modules, most Linux distributions place the
    `*.pp` SELinux policy modules inside `/usr/share/selinux`, usually within a subdirectory
    named after the policy store (such as `targeted`). There, these modules are ready
    for administrators to activate them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在分发 SELinux 策略模块时，大多数 Linux 发行版会将 `*.pp` SELinux 策略模块放置在 `/usr/share/selinux`
    中，通常是在一个以策略存储名称命名的子目录中（如 `targeted`）。在这里，这些模块准备好供管理员激活。
- en: When activating a module, the `semodule` command will copy those modules into
    a dedicated directory (`/var/lib/selinux/mcs/active/modules`). When all modules
    are aggregated in a single location, the final policy binary is compiled, resulting
    in `/etc/selinux/targeted/policy/policy.32` (or some other number) and loaded
    in memory.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在激活模块时，`semodule` 命令会将这些模块复制到一个专用目录（`/var/lib/selinux/mcs/active/modules`）。当所有模块聚集在一个位置时，最终的策略二进制文件会被编译，生成
    `/etc/selinux/targeted/policy/policy.32`（或其他某个编号），并加载到内存中。
- en: On CentOS, the SELinux policies are provided by the `selinux-policy-targeted`
    (or `-minimum` or `-mls`) package. On Gentoo, they are provided by the various
    `sec-policy/selinux-*` packages (Gentoo uses separate packages for each module,
    reducing the number of SELinux policies loaded on an average system).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 上，SELinux 策略由 `selinux-policy-targeted`（或 `-minimum` 或 `-mls`）包提供。在
    Gentoo 上，它们由不同的 `sec-policy/selinux-*` 包提供（Gentoo 为每个模块使用独立的包，减少了加载到系统上的 SELinux
    策略数量）。
- en: Bundling modules in a policy store
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在策略存储中捆绑模块
- en: A **policy store** contains a single comprehensive policy, and only a single
    policy can be active on a system at any point in time. Administrators can switch
    policy stores, although this often requires rebooting the system and might even
    require relabeling the entire system (relabeling is the act of resetting the contexts
    on all files and resources available on that system).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**策略存储**包含一个完整的策略，并且在任何时候，系统上只能激活一个策略。管理员可以切换策略存储，尽管这通常需要重新启动系统，甚至可能需要重新标记整个系统（重新标记是指重置系统中所有文件和资源的上下文）。'
- en: 'The active policy on the system can be queried using `sestatus` (an SELinux
    status) as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 系统上当前的活动策略可以通过以下方式使用 `sestatus`（SELinux 状态）查询：
- en: '[PRE15]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, `mcs` is the currently loaded policy (store). The policy name
    that SELinux will use upon its next reboot is defined in the `/etc/selinux/config`
    configuration file as the `SELINUXTYPE` parameter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`mcs` 是当前加载的策略（存储）。SELinux 在下一次重启时使用的策略名称在 `/etc/selinux/config` 配置文件中定义，作为
    `SELINUXTYPE` 参数。
- en: The system's `init` system (be it a `SysV`-compatible `init` system or `systemd`)
    is generally responsible for loading the SELinux policy, effectively activating
    SELinux support on the system. The `init` system reads the configuration, locates
    the policy store, and loads the policy file in memory. If the `init` system does
    not support this (in other words, it is not SELinux-aware) then the policy should
    be loaded through the `load_policy` command.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的 `init` 系统（无论是兼容 `SysV` 的 `init` 系统还是 `systemd`）通常负责加载 SELinux 策略，实际上是在系统上激活
    SELinux 支持。`init` 系统读取配置文件，找到策略存储并将策略文件加载到内存中。如果 `init` 系统不支持此功能（即它不支持 SELinux），则应通过
    `load_policy` 命令加载策略。
- en: As we now have a better view of the flow used in policy development and distribution,
    let's see how Linux distributions can differentiate their SELinux offering.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对策略开发和分发流程有了更好的了解，接下来看看 Linux 发行版如何区分它们的 SELinux 提供。
- en: Distinguishing between policies
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分策略
- en: The most common SELinux policy store names are `strict`, `targeted`, `mcs`,
    and `mls`. None of the names assigned to policy stores are fixed though, so it
    is a matter of convention. Hence, we recommend consulting the distribution documentation
    to verify what the proper name of the policy should be. Still, the name often
    provides some information about the SELinux options enabled through the policy.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的 SELinux 策略存储名称是 `strict`、`targeted`、`mcs` 和 `mls`。然而，分配给策略存储的名称并不是固定的，所以这只是一个约定。因此，我们建议查阅发行版文档，以验证正确的策略名称应该是什么。不过，名称通常提供了一些关于通过策略启用的
    SELinux 选项的信息。
- en: Supporting MLS
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持 MLS
- en: 'One of the options that can be enabled is MLS support. The SELinux context
    will not have a fourth field with sensitivity information in it if this option
    is disabled, making the contexts of processes and files look as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可以启用的选项之一是 MLS 支持。如果禁用此选项，SELinux 上下文将不会包含带有敏感信息的第四个字段，从而使进程和文件的上下文如下所示：
- en: '[PRE16]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To check whether MLS is enabled, it is sufficient to see whether a process
    context doesn''t contain such a fourth field. Another way is to check the `Policy
    MLS Status` line in the output of `sestatus`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 MLS 是否启用，只需查看进程上下文是否包含第四个字段。另一种方法是检查 `sestatus` 输出中的 `Policy MLS Status`
    行：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Yet another method would be to look into the pseudo file, `/sys/fs/selinux/mls`.
    A value of `0` means disabled, whereas a value of `1` means enabled:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是查看伪文件 `/sys/fs/selinux/mls`。值 `0` 表示禁用，而值 `1` 表示启用：
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Policy stores that have MLS enabled are generally `targeted`, `mcs`, and `mls`,
    whereas `strict` generally has MLS disabled.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 MLS 的策略存储通常是 `targeted`、`mcs` 和 `mls`，而 `strict` 通常禁用 MLS。
- en: Dealing with unknown permissions
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理未知权限
- en: Permissions (such as read, open, and lock) are defined both in the Linux kernel
    and in the policy itself. However, sometimes, newer Linux kernels support permissions
    that the current policy does not yet understand.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 权限（如读取、打开和锁定）在 Linux 内核和策略本身中都有定义。然而，有时较新的 Linux 内核支持当前策略尚未理解的权限。
- en: 'Take the `block_suspend` permission (to be able to block system suspension)
    as an example. If the Linux kernel supports (and checks) this permission but the
    loaded SELinux policy does not understand that permission yet, then SELinux has
    to decide how it should deal with the permission. We can configure SELinux to
    perform one of the following actions:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `block_suspend` 权限（用于阻止系统挂起）为例。如果 Linux 内核支持（并检查）该权限，但已加载的 SELinux 策略尚不理解该权限，那么
    SELinux 必须决定如何处理该权限。我们可以配置 SELinux 执行以下操作之一：
- en: Allow every action related to an unknown permission (`allow`).
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许与未知权限相关的所有操作（`allow`）。
- en: Deny every action related to an unknown permission (`deny`).
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝与未知权限相关的所有操作（`deny`）。
- en: Stop and halt the system when an unknown permission is checked (`reject`).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当检查到未知权限时，停止并终止系统（`reject`）。
- en: 'We configure this through the `deny_unknown` value. To see the state for unknown
    permissions, look for the `Policy deny_unknown status` line in `sestatus`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`deny_unknown`值来配置此设置。要查看未知权限的状态，请在`sestatus`中查找`Policy deny_unknown status`行：
- en: '[PRE19]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Administrators can set this for themselves in the `/etc/selinux/semanage.conf`
    file through the `handle-unknown` variable (with `allow`, `deny`, or `reject`).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员可以通过`/etc/selinux/semanage.conf`文件中的`handle-unknown`变量（取值为`allow`、`deny`或`reject`）来为自己设置此项。
- en: Supporting unconfined domains
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持unconfined域
- en: An SELinux policy can be very strict, limiting applications as close as possible
    to their actual behavior, but it can also be very liberal in what applications
    are allowed to do. One of the concepts available in many SELinux policies is the
    idea of unconfined domains. When enabled, it means that certain SELinux domains
    (process contexts) are allowed to do almost anything they want (of course, within
    the boundaries of the regular Linux DAC permissions, which still hold) and only
    a select number of domains are truly confined (restricted) in their actions.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一个SELinux策略可以非常严格，将应用程序的行为限制得尽可能接近实际情况，但它也可以在允许应用程序执行的操作上非常宽松。许多SELinux策略中都有unconfined域的概念。当启用时，这意味着某些SELinux域（进程上下文）可以几乎做任何它们想做的事情（当然，仍然会受到常规Linux
    DAC权限的限制），而只有少数域在其行为上受到真正的限制（约束）。
- en: Unconfined domains are introduced to allow SELinux to be active on desktops
    and servers where administrators do not want to fully restrict the entire system,
    but only a few of the applications running on it. Generally, these implementations
    focus on constraining network-facing services (such as web servers and database
    management systems) while allowing end users and administrators to roam around
    unrestricted.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 引入unconfined域是为了让SELinux在桌面和服务器上保持活跃，这些系统中管理员不希望完全限制整个系统，而仅仅是限制系统上少数几个应用程序。通常，这些实现专注于约束面向网络的服务（如Web服务器和数据库管理系统），同时允许最终用户和管理员在不受限制的情况下自由活动。
- en: With other MAC systems, such as AppArmor, *unconfinement* is inherently part
    of the design of the system as they only restrict actions for well-defined applications
    or users. However, SELinux is designed to be a full mandatory access control system
    and thus needs to provide access control rules even for those applications that
    aren't the security administrator's primary focus. By marking these applications
    as unconfined, almost no restrictions are imposed by SELinux.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他MAC系统，如AppArmor，*解限*是系统设计的固有部分，因为它们只限制特定应用程序或用户的行为。然而，SELinux旨在成为一个全面的强制访问控制系统，因此即使对于那些不是安全管理员主要关注的应用程序，也需要提供访问控制规则。通过将这些应用程序标记为unconfined，几乎不会对SELinux施加任何限制。
- en: 'We can see whether unconfined domains are enabled on the system using `seinfo`,
    by querying the policy and asking it whether the `unconfined_t` SELinux type is
    defined. On a system where unconfined domains are supported, this type will be
    available:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`seinfo`查看系统是否启用了unconfined域，通过查询策略并询问是否定义了`unconfined_t` SELinux类型。在支持unconfined域的系统上，此类型将是可用的：
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For a system where unconfined domains are not supported, the type will not
    be part of the policy:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不支持unconfined域的系统，该类型将不包含在策略中：
- en: '[PRE21]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Most distributions that enable unconfined domains call their policy `targeted`,
    but this convention is not always followed. Hence, it is always best to consult
    the policy using `seinfo`. CentOS enables unconfined domains, whereas with Gentoo,
    this is a configurable setting through the `unconfined USE` flag.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数启用unconfined域的发行版将其策略称为`targeted`，但这种约定并不总是被遵循。因此，最好始终使用`seinfo`查询策略。CentOS启用unconfined域，而Gentoo则通过`unconfined
    USE`标志来配置此设置。
- en: Limiting cross-user sharing
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制跨用户共享
- en: When UBAC is enabled, certain SELinux types will be protected by additional
    constraints. This will ensure that one SELinux user cannot access the files (or
    other specific resources) of another user, even when those users are sharing their
    data through the regular Linux permissions. UBAC provides some additional control
    over information flow between resources, but it is far from perfect. Essentially,
    it is made to isolate SELinux users from one another.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用UBAC时，某些SELinux类型将受到额外的约束。这将确保一个SELinux用户不能访问另一个用户的文件（或其他特定资源），即使这些用户通过常规Linux权限共享他们的数据。UBAC提供了对资源之间信息流的额外控制，但它远非完美。其本质是将SELinux用户相互隔离开来。
- en: Important note
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: A constraint in SELinux is an access control rule that uses all parts of a context
    to make its decision. Unlike type enforcement rules, which are purely based on
    the type, constraints can take the SELinux user, SELinux role, or sensitivity
    label into account. Constraints are generally developed once and left untouched
    – most policy writers will not touch constraints during their development efforts.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 中的约束是一个访问控制规则，它利用上下文的所有部分来做出决策。与仅基于类型的类型强制规则不同，约束可以考虑 SELinux 用户、SELinux
    角色或敏感性标签。约束通常只开发一次，之后不会再更改——大多数策略编写者在开发过程中不会触碰约束。
- en: Many Linux distributions, including CentOS, disable UBAC. Gentoo allows users
    to decide whether they want UBAC through the Gentoo `ubac USE` flag (which is
    enabled by default).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Linux 发行版，包括 CentOS，禁用了 UBAC。Gentoo 允许用户通过 Gentoo `ubac USE` 标志（默认启用）来决定是否启用
    UBAC。
- en: Incrementing policy versions
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增量的策略版本
- en: 'While checking the output of `sestatus`, we see that there is also a reference
    to a policy version:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查`sestatus`的输出时，我们看到也有对策略版本的引用：
- en: '[PRE22]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This version has nothing to do with the versioning of policy rules but with
    the SELinux features that the currently running kernel supports. In the preceding
    output, 32 is the highest policy version that the running kernel supports. Every
    time a new feature is added to SELinux, the version number is increased. We can
    find the policy file itself (which contains all the SELinux rules loaded at boot
    time by the system) in `/etc/selinux/targeted/policy` (where targeted refers to
    the policy store used, so if the system uses a policy store named `mcs`, then
    the path will be `/etc/selinux/mcs/policy`).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 该版本与策略规则的版本控制无关，而是与当前运行的内核支持的 SELinux 特性有关。在前面的输出中，32 是当前内核支持的最高策略版本。每次向 SELinux
    中添加新特性时，版本号都会增加。我们可以在`/etc/selinux/targeted/policy`中找到策略文件本身（该文件包含系统在启动时加载的所有
    SELinux 规则）（其中，targeted 是使用的策略存储区的名称，因此如果系统使用名为`mcs`的策略存储区，则路径将为`/etc/selinux/mcs/policy`）。
- en: 'If multiple policy files exist, use `seinfo` to discover which policy version
    file is used:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在多个策略文件，使用`seinfo`来查找正在使用的策略版本文件：
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A list of policy feature enhancements and the Linux kernel version in which
    that given feature is introduced is provided next. Many of the features are only
    of concern to policy developers, but knowing the evolution of the features gives
    us a good idea about the evolution of SELinux:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来提供了一个策略功能增强列表，以及该功能引入的 Linux 内核版本。许多特性仅对策略开发者相关，但了解特性的发展有助于我们更好地理解 SELinux
    的演变：
- en: Version 12 represents the "old API" for SELinux, which is now deprecated.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 12 代表 SELinux 的“旧 API”，现已被弃用。
- en: Version 15, introduced in Linux 2.6.0, provided the new API for SELinux.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 15，在 Linux 2.6.0 中引入，提供了新的 SELinux API。
- en: Version 16, introduced in Linux 2.6.5, added support for conditional policy
    extensions.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 16，在 Linux 2.6.5 中引入，增加了对条件策略扩展的支持。
- en: Version 17, introduced in Linux 2.6.6, added support for IPv6.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 17，在 Linux 2.6.6 中引入，增加了对 IPv6 的支持。
- en: Version 18, introduced in Linux 2.6.8, added support for fine-grained netlink
    socket permissions.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 18，在 Linux 2.6.8 中引入，增加了对精细化的 netlink 套接字权限的支持。
- en: Version 19, introduced in Linux 2.6.12, added support for MLS.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 19，在 Linux 2.6.12 中引入，增加了对 MLS 的支持。
- en: Version 20, introduced in Linux 2.6.14, reduced the size of the access vector
    table.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 20，在 Linux 2.6.14 中引入，减少了访问向量表的大小。
- en: Version 21, introduced in Linux 2.6.19, added support for MLS range transitions.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 21，在 Linux 2.6.19 中引入，增加了对 MLS 范围转换的支持。
- en: Version 22, introduced in Linux 2.6.25, added policy capabilities.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 22，在 Linux 2.6.25 中引入，增加了对策略能力的支持。
- en: Version 23, introduced in Linux 2.6.26, added support for per-domain permissive
    mode.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 23，在 Linux 2.6.26 中引入，增加了对每个域宽松模式的支持。
- en: Version 24, introduced in Linux 2.6.28, added support for explicit hierarchy
    (type bounds).
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 24，在 Linux 2.6.28 中引入，增加了对显式层次结构（类型边界）的支持。
- en: Version 25, introduced in Linux 2.6.39, added support for filename-based transitions.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 25，在 Linux 2.6.39 中引入，增加了对基于文件名的转换的支持。
- en: Version 26, introduced in Linux 3.0, added support for role-transitions for
    non-process classes, as well as support for role attributes.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 26，在 Linux 3.0 中引入，增加了对非进程类的角色转换支持，以及对角色属性的支持。
- en: Version 27, introduced in Linux 3.5, added support for the flexible inheritance
    of the SELinux user and SELinux role for newly-created objects.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 27，在 Linux 3.5 中引入，增加了对新创建对象的 SELinux 用户和 SELinux 角色的灵活继承支持。
- en: Version 28, introduced in Linux 3.5, added support for the flexible inheritance
    of the SELinux type for newly-created objects.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 28，首次在 Linux 3.5 中引入，增加了对新创建对象的 SELinux 类型灵活继承的支持。
- en: Version 29, introduced in Linux 3.14, added support for attributes within SELinux
    constraints.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 29，首次在 Linux 3.14 中引入，增加了对 SELinux 限制内属性的支持。
- en: Version 30, introduced in Linux 4.3, added support for extended permissions,
    implemented first on ioctl controls. It also introduced enhanced SELinux Xen support.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 30，首次在 Linux 4.3 中引入，增加了对扩展权限的支持，首先在 ioctl 控制上实现。它还引入了增强的 SELinux Xen 支持。
- en: Version 31, introduced in Linux 4.13, added support for InfiniBand access controls.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 31，首次在 Linux 4.13 中引入，增加了对 InfiniBand 访问控制的支持。
- en: Version 32, introduced in Linux 5.5, added support for automatically deducing
    the intersection in sensitivity labels, called **greatest lower bound, largest
    upper bound** (**glblub**).
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 32，首次在 Linux 5.5 中引入，增加了对自动推断敏感标签交集的支持，这被称为**最小下界，最大上界** (**glblub**)。
- en: By default, when an SELinux policy is built, the highest supported version as
    defined by the Linux kernel and `libsepol` (the library responsible for building
    the SELinux policy binary) is used. Administrators can force a version to be lower
    using the `policy-version` parameter in `/etc/selinux/semanage.conf`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当 SELinux 策略构建时，会使用由 Linux 内核和 `libsepol`（负责构建 SELinux 策略二进制文件的库）定义的最高支持版本。管理员可以使用
    `/etc/selinux/semanage.conf` 中的 `policy-version` 参数强制版本降级。
- en: Different policy content
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的策略内容
- en: Besides the policy capabilities described in the previous section, the main
    difference between policies (and distributions) is the policy content itself.
    We already covered that most distributions base their policy on the reference
    policy project. Although the reference policy project is considered the *master*
    for most distributions, each distribution has its own set of deviations from this
    main policy set.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前一节中描述的策略功能外，策略（和发行版）之间的主要区别是策略内容本身。我们已经讨论过，大多数发行版基于参考策略项目来构建他们的策略。尽管参考策略项目被视为大多数发行版的*主策略*，但每个发行版都有自己对这一主策略集的偏离。
- en: 'Many distributions make extensive additions to the policy without directly
    passing the policies to the upstream reference policy project. There are several
    possible reasons why this is not directly done:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 许多发行版对策略进行了大量增强，但并未直接将策略提交给上游参考策略项目。这样做可能有几个原因：
- en: 'The policy enhancements or additions are still immature: Fedora, CentOS, and
    Red Hat initially start with active, permissive policies, meaning the policies
    are not enforced. Instead, SELinux logs what it would have prevented and, based
    on those logs, the policies are then enhanced. This means that a policy is only
    ready after a few releases.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略的增强或新增仍不成熟：Fedora、CentOS 和 Red Hat 最初使用的是主动的宽松策略，这意味着策略并未强制执行。相反，SELinux 会记录它本应阻止的操作，并根据这些日志进一步增强策略。这意味着一个策略只有在发布几个版本后才算准备好。
- en: 'The policy enhancements or additions are too specific to the distribution:
    If a policy set is not reusable for other distributions, then some distributions
    will opt to keep those policies to themselves as the act of pushing changes to
    *upstream* projects takes quite some effort.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略的增强或新增过于特定于发行版：如果一个策略集不能在其他发行版中重用，那么一些发行版会选择将这些策略保留给自己，因为将更改推送到*上游*项目需要付出相当大的努力。
- en: 'The policy enhancements or additions haven''t followed the upstream rules and
    guidelines: The reference policy has a set of guidelines that policies need to
    adhere to. If a policy set does not comply with these rules, then the reference
    policy will not accept the contribution.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略的增强或新增没有遵循上游规则和指南：参考策略有一套策略需要遵循的指南。如果一个策略集不符合这些规则，那么参考策略将不接受该贡献。
- en: 'The policy enhancements or additions are not implementing the same security
    model as the reference policy project wants: As SELinux is a very extensive mandatory
    access control system, it is possible to write completely different policies.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略的增强或新增并未实现参考策略项目所期望的相同安全模型：由于 SELinux 是一个非常广泛的强制访问控制系统，因此可以编写完全不同的策略。
- en: The distribution does not have the time or resources to push changes upstream.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发行版没有足够的时间或资源将更改提交到上游。
- en: This means that SELinux policies can differ between distributions (and even
    releases of the same distribution).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 SELinux 策略在不同的发行版之间（甚至同一发行版的不同版本之间）可能会有所不同。
- en: 'With this, we can conclude on some of the differentiation that distributions
    can put into their SELinux policies: they can opt to enable or disable MLS support,
    allow or deny unknown permissions, add distribution-provided unconfined domains,
    support user-based access controls, and/or deviate from the reference policy project
    to suit the distribution''s principles.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们可以总结出各个发行版在 SELinux 策略中的一些差异：它们可以选择启用或禁用 MLS 支持，允许或拒绝未知权限，添加发行版提供的未受限域，支持基于用户的访问控制，和/或偏离参考策略项目以适应发行版的原则。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw that SELinux offers a more fine-grained access control
    mechanism on top of the Linux access controls. SELinux is implemented through
    Linux Security Modules and uses labels to identify its resources and processes
    based on ownership (user), role, type, and even the security sensitivity and categorization
    of the resource. We covered how SELinux policies are handled within an SELinux-enabled
    system and briefly touched upon how policy writers structure policies.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到 SELinux 在 Linux 访问控制之上提供了更细粒度的访问控制机制。SELinux 通过 Linux 安全模块实现，并使用标签根据所有权（用户）、角色、类型，甚至资源的安全敏感性和分类来识别其资源和进程。我们介绍了
    SELinux 策略在 SELinux 启用系统中的处理方式，并简要讨论了策略编写者如何构建策略。
- en: Linux distributions implement SELinux policies, which can differ between distributions
    based on supported features, such as sensitivity labels, the default behavior
    for unknown permissions, support for confinement levels, or specific constraints
    put in place, such as UBAC. However, most of the policy rules themselves are similar
    and are even based on the same upstream reference policy project.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 发行版实现了 SELinux 策略，这些策略在不同发行版之间可能会有所不同，具体取决于支持的功能，例如敏感度标签、未知权限的默认行为、对限制级别的支持，或施加的特定约束，如
    UBAC。然而，大多数策略规则本身是相似的，甚至基于相同的上游参考策略项目。
- en: Switching between SELinux enforcement modes and understanding the log events
    that SELinux creates when it prohibits certain access is the subject of our next
    chapter. In it, we will also cover how to approach the often-heard requirement
    of disabling SELinux, and why doing so is the wrong way forward.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 切换 SELinux 执行模式以及理解 SELinux 在禁止某些访问时创建的日志事件，是我们下一章的主题。在其中，我们还将介绍如何处理常听到的禁用 SELinux
    的要求，以及为什么这样做是错误的方向。
- en: Questions
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the most important difference between a DAC and a MAC system?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DAC 和 MAC 系统之间最重要的区别是什么？
- en: How does Linux support the different MAC technologies?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux 如何支持不同的 MAC 技术？
- en: What four fields constitute an SELinux context?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SELinux 上下文由哪四个字段构成？
- en: How does SELinux support role-based access controls?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SELinux 如何支持基于角色的访问控制？
- en: Why isn't there a single SELinux policy for all Linux distributions?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不同的 Linux 发行版没有统一的 SELinux 策略？
