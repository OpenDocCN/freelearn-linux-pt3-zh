- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automating Server Configuration with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, it’s not uncommon to have hundreds of servers that make up your organization’s
    infrastructure. As our user base grows, we’re able to scale our environment to
    meet the demands of our customers. As we scale our resources and add additional
    servers, the amount of time we spend configuring them and setting them up increases
    considerably. The time spent setting up new servers can be a major burden—especially
    if we need to create hundreds of servers within a small window of time. As workload
    demands increase, we need to have a solution in place to manage our infrastructure
    and quickly deploy new resources with as small a workload as possible. In this
    chapter, we explore the concept of configuration management along with automated
    deployments. This sure sounds complicated, but it’s not—you’ll be surprised how
    easy it is to automate your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Ansible?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your servers do your bidding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting it all together – automating web server deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible’s pull method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the introduction, I’ve already given you some examples of why you might want
    to consider building automation into your workflow and implement an effective
    solution in your environment. In the next section, we’ll explore the need for
    automation in more detail before we actually get started.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for configuration management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first started working in the IT industry, it was a much different landscape
    than it is today. Servers were all physical, and any time you needed a new server,
    you literally needed to call a vendor and order one.
  prefs: []
  type: TYPE_NORMAL
- en: You waited for a week or two for the server to be built and sent to you. When
    it arrived, you installed it in a rack, set up an operating system, and then installed
    whatever applications you needed. You then tested the server for a while to make
    sure the combination of software, hardware, and drivers was stable and reliable.
    After some time, you’d deploy the new server into production.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, it’s still the case that system administrators often need to purchase
    and install hardware, much like the process I mentioned in the previous paragraph.
    However, with virtual machines and containers, the physical hardware we install
    is commonly just a catalyst to host virtual resources. In the past, we had one
    physical server for each use case, which meant we needed to have very large server
    rooms. But in modern times, you may have a server with dozens of cores that are
    capable of running hundreds of virtual machines. But the problem of configuration
    remains—the process of setting up an operating system and applications is a very
    time-consuming endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: As the landscape changed, the need for automation increased. Servers needed
    to be deployed quickly and efficiently. With the large number of servers in a
    typical data center, it became less and less practical to connect to each of them
    and configure them one by one every time a change was necessary. For example,
    when a security vulnerability hit the news, the typical administrator would need
    to manually install a patch on every server. This could take days or even weeks.
    That’s not very efficient.
  prefs: []
  type: TYPE_NORMAL
- en: To better deal with this issue, the concept of configuration management has
    become very popular. With configuration management, an administrator can write
    some sort of code (such as a script) and then use a utility to execute it across
    every server. Configuration management is also known as **Infrastructure as Code**
    (**IaC**) and basically lets the administrator define a set of guidelines for
    servers of various types and have them automatically be provisioned to meet those
    requirements. This automation saves a ton of work.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management also comes into play while provisioning a new server.
    Imagine defining some rules for a specific type of server, and having it come
    to life meeting those exact specifications. The applications you want it to have
    are installed during the provisioning process, configuration files are copied
    over, users are created, and firewall rules are put in place, all automatically
    as defined in your specification. Put even more simply, imagine setting up something
    like a web server with just a single command. No need to install Apache or do
    any of that manual work. You simply request a server, and the configuration management
    solution you have in place will take care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: IaC, which is basically a fancy term for configuration management, is essentially
    just the automated running of scripts on your servers. In this book, we’ve looked
    at automation already. In *Chapter 6*, *Boosting Your Command-line Efficiency*,
    we wrote a simple script that we could use to back up a server. That same mentality
    can be used for provisioning servers as well, by simply having a server run a
    script when it comes online. For existing servers, you can make a change once
    and apply that change to every server you manage, or even just a subset.
  prefs: []
  type: TYPE_NORMAL
- en: This is where configuration management utilities, such as Chef, Puppet, and
    others, come into play. Each of these solutions features a specific type of scripting
    language that is designed from the ground up to facilitate the provisioning of
    resources. With such utilities, there is typically some sort of program (or locally
    installed agent) that interprets the instructions from a central server and runs
    them on its clients. Each solution is relatively smart; it will determine what
    needs to be done and perform the steps.
  prefs: []
  type: TYPE_NORMAL
- en: If a requirement is met, the instruction is skipped. If a required resource
    is not present, it will be configured appropriately. One such configuration management
    solution is Ansible, which we will use in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Why Ansible?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I will show you how to set up Ansible, and then we will use
    it to automate some configuration tasks. By the end of this chapter, you’ll understand
    the basic concepts you can use to start the process of automating deployments
    in your organization. You may be wondering, then, why Ansible and not one of the
    other solutions, such as Chef or Puppet?
  prefs: []
  type: TYPE_NORMAL
- en: Some configuration management solutions are relatively heavy from a resource
    perspective. With other solutions, you’ll generally have a central server, which
    will run a master program. This program will periodically *check in* with each
    server under its control by communicating with the agent installed on each server.
    Then, the agent will receive instructions from the central server and carry them
    out.
  prefs: []
  type: TYPE_NORMAL
- en: This means that you’ll need to maintain a server with modest CPU and RAM requirements,
    and the agent on the client side of the communication will also spend valuable
    CPU in order to carry out the instructions. This resource utilization can be very
    heavy on both the primary and client servers.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is very different than the other solutions in that there is no agent
    at all. There is typically a server, but it’s not required to run any resource-intensive
    software. The entire configuration process happens via SSH, so you can even carry
    out the instructions from your workstation if you want to skip having to maintain
    a central server. Typically, the administrator will create a user account on each
    server, and then the central Ansible server (or workstation) will execute commands
    over SSH to update the configuration on each machine. Since there is no agent
    installed on each server, the process takes a lot less CPU. Of course, the instructions
    that Ansible gives your servers will definitely result in CPU usage, but certainly
    a lot less than the other solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is typically set up by creating an **inventory file**, which contains
    a list of resources (servers) (in the form of hostnames or IP addresses that Ansible
    will be instructed to connect to and configure). If you want to add a new server,
    you simply make sure that a specific user account exists on that server, then
    you add it to the inventory list. If you want to remove it, you delete the line
    in the inventory file corresponding to that server. It’s very easy.
  prefs: []
  type: TYPE_NORMAL
- en: However, something that’s magical about Ansible is that you don’t even have
    to run a central server at all if you don’t want to. You can store your Ansible
    configuration in a Git repository, and have each server download code from the
    repository and run it locally. This means that if you do have a dynamic environment
    where servers come and go all the time (which is very common in cloud deployments),
    you don’t have to worry about maintaining an inventory file. Just instruct each
    server to download the code and provision themselves. This is known as the **pull
    method** of Ansible, which I will also show you.
  prefs: []
  type: TYPE_NORMAL
- en: While solutions such as Chef and Puppet have their merits and are definitely
    fun to use, I think you’ll find that Ansible scales better and gives you far more
    control over how these hosts are configured. While it’s up to you to figure out
    exactly how you want to implement Ansible, the creative freedom it gives you is
    second to none. I’ve been using Ansible for quite a while now, and I’m still finding
    new ways to use it. It’s a technology that will grow with you.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Git repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the examples in this chapter, it’s recommended that you create a Git repository
    to store your Ansible code. This isn’t required, as you can find other ways of
    hosting your code, but it’s highly recommended. This is especially true when we
    get to the pull method of Ansible at the end of this chapter. In this section,
    I’ll walk you through creating a repository. If you already know how to use GitHub,
    you can skip this section.
  prefs: []
  type: TYPE_NORMAL
- en: While a full walkthrough of Git is beyond the scope of this book, the basics
    are more than enough for following along here. When it comes to Git, you can simply
    install the `git` package on a server to have it host your code, but GitHub is
    probably the easiest way to get started. An added bonus is that GitHub is home
    to a lot of great projects you can benefit from, and browsing the code of these
    projects is a great way to become more accustomed to syntax rules with different
    scripting and programming languages. For our purposes, we’re going to use GitHub
    as a central place to store our Ansible code.
  prefs: []
  type: TYPE_NORMAL
- en: It probably goes without saying, but GitHub is a public resource. Any code you
    upload to the service will be available for all to see by default. Therefore,
    be mindful of the information you commit to your repository. Make sure you don’t
    include any personally identifiable information, passwords, blueprints, API keys,
    or anything else you don’t want the public to know about you or your organization.
    You can create a private repository to hide confidential information, but it’s
    still safer to not upload protected information at all (whether the repository
    is private or not).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, create an account at [https://www.github.com](https://www.github.com)
    if you don’t already have one. This is a free process. Make sure you create a
    reasonably secure password here. After you have created an account, click on **New
    repository**, and then give it a name (simply calling it `ansible` is fine):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_15_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: Creating an Ansible repository on GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: In the example screenshot, I created a repository that is **Public**, which
    means exactly that—anyone will be able to view the code. You can create **Private**
    repositories as well, if you prefer. Since we’re not going to include confidential
    information in the repository during the examples in this book, we don’t need
    to worry about that right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the repository is created using **Create repository**, we’ll need to download
    it locally. For that, we’ll need to install the `git` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we should set up our local Git client so that we can fill out our name
    and email address, otherwise Git will most likely complain. To do this, we can
    issue the following commands, substituting the content in the quotes with your
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To download our repository, the following will do the trick (ignore the warning
    about the repository being empty if you see such a message):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you have the Git repository downloaded locally. Right now, the repository
    doesn’t include anything useful. To create a file within the repository, you simply
    change your working directory to be inside the repository folder that was downloaded
    when you cloned it, and create whatever files you want inside. By default, Git
    doesn’t care about any files you create inside the repository until you add them.
    For example, we can create a test file and commit it to the repository with the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With these commands, we used `echo` to create a test file with some text in
    it. Then, we used the `git add` command to tell Git that we want the file to be
    a part of our repository. Finally, we finalized our changes by using `git commit`,
    along with the `-m` flag and a message about the commit. At this point, the changes
    only exist locally. To push our changes back to GitHub, we use the following command
    from inside the repository directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By following the on-screen prompts (GitHub username and password), our changes
    will be placed inside our actual repository.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does this help us when it comes to configuration management? Typically,
    the code that administrators use to provision servers will be placed inside a
    repository for safekeeping. If the local copy of the code is lost, it can simply
    be cloned again from the repository. GitHub is a safe place to put our code, since
    we can be reasonably sure that our code won’t disappear as the service is very
    stable (you still may want to create a local backup to be safe). Whether you’re
    using Ansible, Chef, Puppet, or another utility, it’s common practice to keep
    the code in a Git repository. With regard to Ansible, this will directly impact
    us in the last section of this chapter since we’ll be using the `ansible-pull`
    command, which expects a repository URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, when we create Ansible playbooks, you should commit those changes
    back to the repository. I won’t specifically call on you to do that, so go ahead
    and keep that in mind as we go. When you create a new playbook, add it to the
    repository, then commit it. If you make changes to existing files, commit those
    changes. Be sure to use the `git push` command to push your changes back to the
    repository. For example, if you created a file inside the repository named `myplaybook.yml`,
    you would execute commands such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and practice this a bit before you move on. Even if you don’t use Ansible
    in production, understanding the basics of Git is invaluable, as you’ll almost
    definitely need it at some point in your career.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to know about Ansible is that it changes constantly. New versions
    with exciting features are released regularly, and it shows no sign of slowing
    down whatsoever. There is a lot of excitement around this technology, so it’s
    regularly improving.
  prefs: []
  type: TYPE_NORMAL
- en: The reason I’m bringing this up is that although the examples in this book have
    been written for (and tested on) Ubuntu 22.04, new versions of Ansible are released
    regularly outside of Ubuntu’s repositories, and not only include new features
    but syntax changes as well. For our needs in this book, the version of Ansible
    included in the repositories should be more than fine. However, if you were to
    look at examples of Ansible playbooks online, they might be written for a newer
    version (or even an older version). If for any reason you have an issue with a
    particular example written for Ansible, a good first step in terms of troubleshooting
    is to compare the version of Ansible the tutorial was written for against the
    version installed. When it comes to Ubuntu 22.04, the version of Ansible that’s
    made available is 2.10.x. You can install a newer version of Ansible from the
    official website, but for the purposes of this book, we’ll use the version that’s
    in the default repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and install `ansible` via `apt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now you should have the `ansible-playbook` command available, which is the main
    binary that we’ll be using as we explore Ansible. There are other commands that
    Ansible provides us, but we’re not concerned with them.
  prefs: []
  type: TYPE_NORMAL
- en: In order to follow along with the remainder of this chapter, it’s recommended
    that you have at least two servers to work with; the more the better. If you have
    a **Virtual Machine** (**VM**) solution such as VirtualBox available, simply create
    additional VMs. To save time, consider cloning an existing VM a few times (just
    make sure you don’t overload your computer/server by over-allocating resources).
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common workflow of Ansible works something like this: you have a main
    server or workstation, on which Ansible is installed. While you don’t need an
    agent on the clients, they will, however, need OpenSSH installed and configured
    as that’s how Ansible communicates. To make things easy, it’s recommended to have
    a dedicated Ansible user on each machine, and the Ansible user on the server should
    be able to connect to each machine without a password. It doesn’t matter what
    you call the Ansible user; you can simply use `ansible` or something clever. We
    covered how to create SSH keys in *Chapter 10*, *Connecting to Networks*, so refer
    to that if you need a reminder. Creating users was covered in *Chapter 2*, *Managing
    Users and Permissions*. In a nutshell, here are the things you should work on
    in order to set up your environment for Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Ansible on a central server or workstation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a user for Ansible on each machine you want to manage configuration on
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the same user on your central server or your local machine
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the Ansible user on the server so that it can connect to clients via
    SSH without a password
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure `sudo` on the client machines so that the Ansible user can execute
    commands with `sudo` with no password
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In previous chapters, we covered how to create users and SSH keys, but we have
    yet to cover the last point. Assuming you named your Ansible user `ansible`, create
    the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside that file, place the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to ensure that the file is owned by `root`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to adjust the permissions of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and test this out. On the server, switch to the `ansible` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to test this out, use SSH to execute a command on a remote machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How does this work? You may or may not know this, but if you use SSH to execute
    just one command, you don’t necessarily need to set up a persistent connection.
    In this example, we first switch to the `ansible` user. Then, we connect to `192.168.1.123`
    (or whatever the IP address of the client is) and tell it to execute `sudo ls
    /etc`. Executing an `ls` command with `sudo` may seem like a silly thing to do,
    but it’s great—it allows you to test whether or not `sudo` works without doing
    anything potentially dangerous. Listing the contents of a directory is about as
    innocent as you can get.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem like an awful lot of steps in order to get configuration management
    working. But make sure you think with a system administrator’s mindset—these setup
    tips can be automated. In my case, I have a Bash script that I run on each of
    my servers that sets up the required user, keys, and `sudo` access specifically
    for Ansible. Anytime I want to add a new server to Ansible, I simply run that
    script on the machine just once, and from that point forward Ansible will take
    care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: What should have happened is that the command should have executed and printed
    the contents of `/etc` without prompting you for a password. If this doesn’t work,
    make sure you have completed each of the recommended steps. You should have an
    `ansible` user on each machine, and that user should have access to `sudo` without
    a password since we created a file for that user in `/etc/sudoers.d`. If the SSH
    portion fails, check the log file at `/var/log/auth.log` for clues, as that is
    where related errors will be saved. Once you have met these requirements, we can
    get automating with Ansible!
  prefs: []
  type: TYPE_NORMAL
- en: Making your servers do your bidding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As server administrators, we’re control freaks. There are few things more exciting
    than executing a command and having every single server obey it and carry it out.
    Now that we have Ansible set up, that’s exactly what we’re going to do. I’m assuming
    by now you have some machines you want to configure, and they’re all set up to
    communicate via SSH with your central server. Also, as I mentioned before, I highly
    recommend you utilize something like Git to store your configuration files, but
    that’s not required for this section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an inventory file and configuring Ansible settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we’ll need an inventory file, which is a special text file Ansible expects
    to find that tells it where to find servers to connect to. In previous versions,
    the process of installing the `ansible` package would provide you with some default
    configuration, located in `/etc/ansible`. In Ubuntu 22.04, at least with the version
    of Ansible that’s offered in the default repositories, this is no longer the case.
    For our purposes, that’s fine, though – we were going to create an empty configuration
    anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create the directory that we’ll be using for the configuration
    on our “controller” server (the one we’ll be using to control, or “configure,”
    other nodes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can create an empty inventory file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There’s actually a way to avoid needing to create an inventory file, which we’ll
    get into later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also make sure that only the Ansible user account can read it. Execute
    the following command to change ownership (replace `ansible` with whatever user
    account you chose as your Ansible account if you’re using something different):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify the permissions such that only the owner can view or change the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s edit the `/etc/ansible/hosts` file and populate it. If you did
    end up having a default `hosts` file created for you when you installed Ansible,
    you can simply empty the file since we’ll be creating our own anyway. What we’ll
    do with this file is populate it with the IP addresses of the servers we wish
    to manage. Feel free to make a backup of the original host file, if it already
    exists. For right now, we’re only including the IP addresses of the nodes we want
    to control with Ansible, so the file will end up looking similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it; it’s simply just a list of IP addresses. I bet you were expecting
    some long configuration with all kinds of syntax requirements? Sorry to disappoint.
    All you need to do is copy a list of IP addresses of the servers you want to manage
    into this file. If you have DNS names set up for the machines you want to configure,
    you can use them instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Since Ansible understands IP addresses as well as DNS names, we can use either
    or a combination of both in order to set up our inventory file. We can also split
    up our hosts within the inventory file between different roles, but that is outside
    the scope of this book. I do recommend learning about roles in Ansible if you
    wish to take your knowledge further (see the *Relevant videos* section for more
    information).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decide not to store your inventory file at `/etc/ansible/hosts`, you
    must tell Ansible where to find it. There is another important file to Ansible,
    and that is its configuration file, located at `/etc/ansible/ansible.cfg`. Inside
    this file, we can fine-tune Ansible to get the best performance possible. While
    we won’t go over this file in detail, just know that you can seriously increase
    the performance of Ansible by fine-tuning its settings, and Ansible will read
    settings from its configuration file every time it runs. In our case, if we wish
    to store our inventory file somewhere other than `/etc/ansible/hosts`, we will
    need to add the following two lines to this file (most likely, you’ll need to
    create this file since it probably doesn’t already exist at this point):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With the first setting, we’re basically telling Ansible where to find its inventory
    file. There are many more configuration items we can place in the `ansible.cfg`
    file to configure it further, but that’s all we need to configure right now. With
    the second line, we’re setting a default user to use for Ansible playbooks, which
    must exist on any servers you wish to manage with it.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the inventory file, Ansible also checks the local directory for a
    file named `ansible.cfg` to fetch its configuration, so you could actually include
    the configuration file in the Git repository as well, and then execute Ansible
    commands from within the repository directory. This works because Ansible will
    check for the existence of a configuration file in your current working directory,
    and use it if it’s found there. You may want to be careful about including your
    configuration file in your Git directory, though. While it’s not as private as
    the inventory file, it can potentially contain privileged information. Therefore,
    you may want to keep the file at `/etc/ansible/ansible.cfg` and manage it outside
    of the Git repository if you include anything private in the file (for example,
    encryption keys).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can test out whether or not Ansible is working at this point. Thankfully,
    this is also easy. Just simply execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The results should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_15_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: Testing Ansible'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how many servers you have set up, you should see that output one
    or more times. You may think that all that command has done is a simple ping test,
    but `ping` means something different to Ansible than usual. It’s actually attempting
    to make a connection to the server, to test its availability. If it fails, double-check
    that the hosts are available over SSH. Success here simply means that Ansible
    is able to communicate with your hosts via SSH. Now that the communication exists,
    we can build some actual configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring client servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible uses something called a **playbook** in order to store configuration.
    A playbook is essentially a file in the YAML format with instructions that Ansible
    understands, that are interpreted as a set of tasks run against hosts A full guide
    on YAML isn’t something we’ll be covering here – you don’t have to master this
    format or even fully understand it to use it with Ansible. That will automatically
    come in time. The takeaway here is that YAML is simply the format that Ansible
    uses, and it’s a file format that’s not specific to Ansible itself. A playbook
    is basically just a collection of instructions written in YAML format, and each
    individual instruction is known as a play.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of this with the analogy of a sport, like football. Although I
    don’t know the first thing about football, I do know that football coaches have
    playbooks containing things that they want their players to do, and each action
    by a player is a play. It’s the same concept here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write our first playbook. Create a file called `packages.yml` in your
    local Ansible directory. You can fill it with this content (make sure you include
    the hyphens):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run this playbook with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce an output that looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_15_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: Ansible in action'
  prefs: []
  type: TYPE_NORMAL
- en: Just like that, all of the hosts in your inventory file will have the `htop`
    package installed. It really doesn’t matter which package you install, so long
    as it exists in the repositories; I just used `htop` as a simple example. But
    once you run it, you should see an overview of what was changed. Ansible will
    tell you how many items your hosts updated, how many tasks have failed, and how
    many targets weren’t reachable at the time the playbook was run.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at what the instructions in this sample playbook do.
    The hyphens at the beginning are part of the YAML format, so we really don’t need
    to get into that. Spacing is very important with the YAML format, as you need
    to be consistent throughout.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my examples, I am inserting two spaces underneath each heading. A heading
    starts with a hyphen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declare which hosts we want to have the commands apply to. I added
    `all` here, which basically runs the configuration against every host in the inventory
    file. With advanced usage, you can actually create `roles` in Ansible and divide
    your hosts between them, such as a web server, database server, and so on. Then,
    you can apply configuration only to hosts inside a particular role. We’re not
    going to get into that in this chapter, but just know that it is possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line is `become`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This line is basically Ansible’s term for describing `sudo`. We’re telling
    Ansible to use `sudo` to execute the commands, since installing packages requires
    `root` privileges. The next part of the playbook is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This line starts the next section, which is where we place our individual tasks.
    Next, we name our new task (Ansible refers to a “task” as a “play”):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With `name`, we give the play a name. This isn’t required but you should always
    include it. The importance of this is that whatever we type here is what is going
    to show up in the logs if we enable logging, and will also print to the terminal
    as the play runs. We should be descriptive here, as it will certainly help if
    a play fails and we need to locate it in a log file that has hundreds of lines.
    Next, we utilize the `apt` module and tell it to install a package, `htop` in
    this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We use the `ansible.builtin.apt` module simply because Ubuntu uses the `apt`
    command to manage packages, but modules exist for all of the popular Linux distributions.
    Ansible’s support of package managers among various distributions is actually
    fairly extensive. All of the major distributions, such as Red Hat, Fedora, openSUSE,
    Arch Linux, and Debian, are supported (and those are just the ones I’ve used in
    my lab off the top of my head). If you want to execute a play against a server
    that’s running a distribution other than Ubuntu, simply adjust `ansible.builtin.apt`
    to something else, such as `ansible.builtin.dnf`.
  prefs: []
  type: TYPE_NORMAL
- en: Since Ansible allows you to use additional resources from Galaxy, a site that’s
    specific to Ansible that gives you access to additional capabilities, we use `ansible.builtin.apt`
    instead of simply `apt` in order to clarify that we’re using a built-in module,
    not something we’re using from an external resource.
  prefs: []
  type: TYPE_NORMAL
- en: This new naming scheme is new since the previous edition of this book was published.
    The older versions of the playbooks should still work just fine, but since the
    naming scheme has changed since then, we’ll use the new naming style going forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, of course, add additional packages by simply adding more plays to
    the existing playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'However, that’s not an extremely efficient method. I’ll show you how we can
    combine multiple similar plays in one play. Sure, you don’t have to, but I think
    you’ll agree that this method looks cleaner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With the new format, we include just one play to install multiple packages.
    This is similar to the concept of a *for loop* if you have programming knowledge.
    For every package we list, it will run the `ansible.builtin.apt` module against
    it. If we want to add additional packages, we just add a new one to the list.
    Simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also copy files to our hosts. Consider the following example playbook,
    which I will call `copy_files.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can run this playbook with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Inside the same directory, create a file called `motd` and place any text in
    it. It doesn’t really matter what you type into the file, but this file in particular
    acts as a message that is printed any time a user logs into a server. When you
    run the playbook, it will copy that file over to the server at the destination
    you configured. Since we created a message of the day (`motd`), we should see
    the new message the next time we log in to the server.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you’re probably seeing just how useful Ansible can be. Sure, we only
    installed a few packages and copied one file. We could’ve performed those tasks
    easily ourselves without Ansible, but this is only a start. Ansible lets you automate
    everything, and we have to start somewhere. You can tell it to not only install
    packages and copy files, but you can also use it to start services, apply configuration
    file templates, and much more—it will surprise you. In fact, you can go as far
    as to automate the setup of a web server, a user’s workstation... you name it!
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together – automating web server deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Speaking of automating the setup of a web server, why don’t we go ahead and
    do exactly that? It’ll be another simple example, but it will serve you well if
    we demonstrate more of what Ansible can do. We will set up a playbook to perform
    the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Apache
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the `apache2` service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy an HTML file for the new site
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, let’s set up the playbook to simply install Apache. I called mine `apache.yml`,
    but the name is arbitrary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'No surprises here; we’ve already installed a package at this point. Let’s add
    an additional instruction to start the `apache2` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: So far, the syntax should be self-explanatory. Ansible has a `service` module,
    which can be used to start a service on a host. In this case, we start the `apache2`
    service (the service would’ve already been started when `apache2` was installed,
    but at least this way we can make sure it’s started). You do have to know the
    service name ahead of time, but you don’t have to pay attention to what utility
    needs to be used in the background to start the service. Ansible already knows
    how to start services on all the popular distributions and takes care of the specifics
    for you in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a play that starts `apache2` may seem a bit redundant since most packages
    you install on an Ubuntu server will automatically start the associated service
    as soon as it’s installed (and `apache2` is no exception). But when we write automation
    code, it’s important to be clear and explicit about what the desired end result
    is supposed to be. Even though `apache2` will automatically start once Ansible
    installs the package, we’re adding a `service` play to clarify the fact that it
    needs to be running, so anyone looking at it will know what’s expected. Also,
    we can make sure `apache2` is `enabled` by adding one more line to that section
    of the code (note the bold line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: I’ll leave it up to you whether or not to include that extra line, but the takeaway
    is to be as clear and direct as you can when writing automation, so there’s no
    confusion about what the end result is supposed to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, that was easy. Let’s create a simple web page for Apache to serve for
    us. It doesn’t need to be fancy, we just want to see that it works. Create the
    following content inside a file named `index.xhtml` in the same working directory
    as the other Ansible files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, that HTML file is fairly lame, but it will work just fine for
    what we need. Next, let’s add another instruction to our Apache playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: With the `copy` module, we can copy a file from our local Ansible directory
    to the server. All we need to do is provide it with a source (`src`) and destination
    (`dest`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and run the new playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_15_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: Installing Apache and copying a default site file with Ansible'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a few minutes, you should have at least one web server configured by
    Ansible. In a real production environment, you would’ve only run this on servers
    within a specific role, but roles are beyond the scope of this chapter. But from
    the simple playbook we created, you should be able to see the power of this amazing
    piece of software:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_15_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: An example of a web page provisioned by Ansible'
  prefs: []
  type: TYPE_NORMAL
- en: At this point in our exploration into configuration management with Ansible,
    we’ve installed packages, started services, and copied files. Admittedly, this
    isn’t much, but it’s really all you need in order to practice the basics. The
    documentation for Ansible includes guides on how to do all sorts of things, and
    you’ll be able to utilize the various modules it provides to perform many different
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: To explore Ansible further, I recommend that you think about things you do on
    a regular basis that you would benefit from automating. Things like installing
    security updates, creating user accounts, setting passwords, and enabling services
    to automatically start at boot time are tasks that are easy to get started with.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you may want to consider adding a simple **cron job** to run under
    your `ansible` user, to run the playbook every hour or so. We covered cron jobs
    in *Chapter 7*, *Controlling and Managing Processes*. Adding a cron job shouldn’t
    add any overhead from a resource perspective, since Ansible won’t actually be
    doing much unless you add a new command. In more advanced usage, you’ll want to
    have Ansible check out code from a repository and then apply the configuration
    if it has changed. This way, all you have to do is commit to a Git repository
    and all of your servers will download the configuration and run it at the next
    scheduled time. One of the things I love most about Ansible is that it’s easy
    to get started, but you’ll continue to find new ways to use it and benefit from
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible’s pull method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way we set up our Ansible configuration in the previous section works very
    well if we have a list of specific servers that we want it to manage. To add a
    new server, we create the user account and set up the SSH configuration on the
    new host, and then add it to the inventory file. If we decommission that server,
    we simply remove it from the inventory file. This works well in a static environment,
    where servers you deploy typically stay around for a while. In a dynamic environment,
    though, this may not work as well.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic environments are very typical in the cloud. With cloud computing, you
    typically have one or more virtual servers that provide a service to your company
    or users. These servers may come and go at any time. With dynamic environments,
    servers will come online as needed to handle load and will also get decommissioned
    automatically as load decreases. Therefore, you never really know when a server
    is going to come online, and having to manually provision a server in such an
    environment is inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, Ansible’s inventory file may not be a good fit for dynamic
    infrastructure. There certainly are ways to make Ansible’s inventory work in such
    an environment, as you can actually replace the inventory file with an executable
    script that can make API calls and customize itself for your infrastructure if
    you so desire. However, that’s out of the scope of this book, and there’s an easier
    method anyway.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve seen, Ansible uses an inventory file and connects to every server listed
    in that file. However, Ansible also features a **pull mode**, where instead of
    having a central server that connects to other machines, each server in pull mode
    will actually run Ansible against itself. In my opinion, this is a great way to
    use Ansible and it doesn’t seem to get the attention it deserves. First, I’ll
    explain the theory of how it works, and then we can work through an actual example.
  prefs: []
  type: TYPE_NORMAL
- en: With pull mode, you’ll want to have your Ansible playbooks inside a Git repository.
    This repository must be accessible from the servers you will manage. For example,
    if you store the Git repository on GitHub, you’ll want to make sure the servers
    can access GitHub externally. If you host your own Git server internally, you’ll
    want to make sure your servers are able to access it through your firewall or
    any security rules you may have in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pull mode is used with the `ansible-pull` command, which comes bundled with
    Ansible. The syntax looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you’d replace the URL with the actual HTTP or HTTPS URL to your Git
    repository. However, that’s basically it. The `ansible-pull` command simply expects
    the `-U` option (short for URL) along with the URL to a Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for this to work, you’ll need a playbook inside the repository with
    a special name, `local.yml`. If you don’t declare a specific playbook with Ansible,
    it will expect to find a playbook with that name inside the root of the repository.
    If you choose to use a name for the main playbook that’s something other than
    `local.yml`, you’ll need to specify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `ansible-pull` command will cache the Git repository located
    at the specified URL locally, and run the playbook `myplaybook.yml` that you would
    have inside the repository. One thing you may find is that Ansible might complain
    about not finding an inventory file, even though that’s the entire point of the
    `ansible-pull` command. You can ignore this error. This will likely be fixed in
    Ansible at some point in the future, but as of the time of this writing, it will
    print a warning if it doesn’t detect an inventory file.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the theory out of the way, let’s work through an actual example. If you’ve
    been following along so far, we created a playbook in the previous section that
    automates the deployment of a hypothetical web server. We can reuse that code.
    However, it’s best practice to have a file with the name `local.yml`, so you can
    simply rename the `apache.yml` playbook we created earlier to `local.yml`. There’s
    one small change we need to make to the file, which I’ve highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we’re executing the playbook locally (without SSH) we changed the `hosts`:
    line to point to `localhost`, to instruct Ansible that we want to execute the
    commands locally rather than remotely. Now, we can push this playbook to our Git
    repository and execute it directly from the repository URL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay careful attention to the `hosts:` line of any playbook you intend to run.
    If you are using the pull method, this line will need to be changed from `hosts:
    all` to `hosts: localhost`, the reason being, we are executing the playbooks directly
    on localhost, rather than from a remote SSH connection. If you don’t make this
    change, you’ll see an error similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you run the playbook, you’ll want to first switch to your Ansible user,
    since the playbook will need to be run as a user with `sudo` privileges since
    it will execute system-level commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, execute the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If we kept the name as `apache.yml`, we would just specify that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that since `ansible-pull` executes playbooks directly on localhost,
    the playbook must be executed by a user that has access to `sudo`. If `sudo` is
    not configured to run as that user without a password, the playbook will fail
    as it’s not interactive (it won’t ask for the password). You can also use `sudo`
    in front of the `ansible-pull` command and provide the password before it runs,
    but that won’t work if you set it up to run automatically via cron.
  prefs: []
  type: TYPE_NORMAL
- en: If all goes according to plan, the playbook repository should be cached to the
    server, and the instructions carried out. If there is an error, Ansible is fairly
    good about presenting logical error messages. As long as the user has permission
    to execute privileged commands on the server, the required files are present in
    the repository, and the server has access to download the repository (a firewall
    isn’t blocking it), then the playbook will run properly.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to implementing the pull method in production across various server
    types, there are several ways we can go about this. One way is to have a separate
    playbook per server type. For example, perhaps you’d have an Apache playbook,
    as well as playbooks specific to database servers, file servers, user workstations,
    and so on. Then, depending on the type of server you’re deploying, you’d specify
    the appropriate playbook when you called the `ansible-pull` command. If you’re
    using a service such as cloud computing, you can actually provide a script for
    each server to execute upon creation. You can then instruct the service to automatically
    run the `ansible-pull` command any time a new server is created. In AWS, for example,
    you can use a feature known as user data to place a script for a server to execute
    when it’s launched for the first time. This saves you from having to provision
    anything manually. For this to work, you would first include a command for the
    server to install Ansible itself, and then the next command would be the `ansible-pull`
    command along with the URL to the repository. Just those two lines would completely
    automate the installation of Ansible and the application of your playbook. Try
    to think of the possibilities ahead of time so you can understand the many ways
    that automation can benefit you.
  prefs: []
  type: TYPE_NORMAL
- en: While provisioning new servers properly and efficiently is very important, so
    too is maintaining your existing servers. When you need to install a new package
    or apply a security update, the last thing you want to do is connect to all of
    your servers manually and update them one by one. The `ansible-pull` command allows
    simple management as well; you just simply run the command again. Every time you
    run `ansible-pull`, it will download the latest version of the code within your
    repository and run it. If there are any changes, they will be applied, while things
    that have already been applied will be skipped. For example, if you include a
    play to install the `apache2` package, Ansible won’t reinstall the package if
    you run the playbook a second time; it will skip that play since that requirement
    has already been met.
  prefs: []
  type: TYPE_NORMAL
- en: One trick worth knowing with `ansible-pull` is the `-o` option. This option
    will ensure that the playbook inside the repository is only run if there have
    been any actual changes to the repository. If you haven’t committed any changes
    to the repository, it will skip the entire thing. This is very useful if you set
    up the `ansible-pull` command syntax to be run periodically via cron, for example,
    every hour.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t include the `-o` option, Ansible will run the entire playbook every
    hour. This will consume valuable CPU resources for no good reason at all. With
    the `-o` option, Ansible will only use as much CPU as required for simply checking
    the repository for changes. The playbook will only be run if you actually commit
    changes to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction to Ansible within this chapter has been very basic, as we’ve
    only used the very core of the required components. By looking deeper into Ansible,
    you’ll find more advanced techniques, and some more clever ways to implement it.
    Examples include automating firewall rules, security patches, and user passwords,
    as well as having Ansible send you an email any time a server is successfully
    provisioned (or even when that fails). Basically, just about anything you can
    do manually, you can automate with Ansible. In the future, I recommend looking
    at server administration with an automation mindset. As I’ve mentioned several
    times before, if you will need to perform a task more than once, automate it.
    Ansible is one of the best ways of automating server administration.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at configuration management using Ansible. Ansible
    is an exciting technology that is exploding in popularity. It gives you the full
    power of configuration management utilities such as Chef or Puppet, without all
    the resource overhead. It allows you to automate just about everything. During
    our exploration, we walked through installing packages, copying files, and starting
    services. Near the end of the chapter, we worked through an example of using Ansible
    to provision a simple web server, and we even explored the pull method, which
    is very useful in dynamic environments. These concepts form the basis of knowledge
    that can be expanded to automate more complex rollouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter will be fun: we’ll set up our very own virtualization server
    with KVM. This is one of my favorite topics, and I’m sure you’ll enjoy it too.
    See you there!'
  prefs: []
  type: TYPE_NORMAL
- en: Relevant videos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Git Essentials (LearnLinuxTV): [https://linux.video/git-essentials](https://linux.video/git-essentials)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting Started with Ansible (LearnLinuxTV): [https://linux.video/learn-ansible](https://linux.video/learn-ansible)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible workstation/laptop configuration (LearnLinuxTV): [https://linux.video/ansible-workstation](https://linux.video/ansible-workstation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible Vault (LearnLinuxTV): [https://linux.video/ansible-vault](https://linux.video/ansible-vault)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible Pull (LearnLinuxTV): [https://linux.video/ansible-pull](https://linux.video/ansible-pull)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible documentation: [https://learnlinux.link/ansible-docs](https://learnlinux.link/ansible-docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible Roles documentation: [https://learnlinux.link/reuse-roles](https://learnlinux.link/reuse-roles)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible config file documentation article: [https://learnlinux.link/a-config](https://learnlinux.link/a-config)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible-pull` documentation: [https://learnlinux.link/a-pull](https://learnlinux.link/a-pull)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to manage your workstation configuration with Ansible: [https://learnlinux.link/a-ws](https://learnlinux.link/a-ws)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Git basics: [https://learnlinux.link/git-book](https://learnlinux.link/git-book)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting up Git (GitHub): [https://learnlinux.link/setup-git](https://learnlinux.link/setup-git)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code50046724-1955875156.png)'
  prefs: []
  type: TYPE_IMG
