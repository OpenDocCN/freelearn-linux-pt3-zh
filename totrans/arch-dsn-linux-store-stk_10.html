<html><head></head><body>
<div id="_idContainer110">
<h1 class="chapter-number" id="_idParaDest-161"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-162"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.2.1">Analyzing Filesystems and the Block Layer</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Read or write access to storage devices usually happens after passing through several intermediary layers, such as filesystems and the block layer. </span><span class="koboSpan" id="kobo.3.2">There is also the page cache, where requested data is preserved before being lazily committed to the underlying storage. </span><span class="koboSpan" id="kobo.3.3">So far, we’ve tried to understand the different factors that can affect disk performance and examined the important metrics associated with physical disks, but, as Sherlock Holmes would say, “</span><em class="italic"><span class="koboSpan" id="kobo.4.1">Perfectly sound analysis, but I was hoping you’d </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.5.1">go deeper.”</span></em></span></p>
<p><span class="koboSpan" id="kobo.6.1">Applications tend to interact with the filesystem, not with the physical storage. </span><span class="koboSpan" id="kobo.6.2">It is the job of a filesystem to translate the application’s request and send it down to the lower layers for further processing. </span><span class="koboSpan" id="kobo.6.3">The request will go through further processing in the block layer and be eventually scheduled for dispatch to the storage device. </span><span class="koboSpan" id="kobo.6.4">Each stage in this hierarchy will add its own processing overhead. </span><span class="koboSpan" id="kobo.6.5">Therefore, it is extremely important to examine the behavior of the filesystem and block layer to perform any </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">performance analysis.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">In this chapter, we will focus on the techniques that can be used to investigate the filesystem and block layer. </span><span class="koboSpan" id="kobo.8.2">At this stage, I would like to think that the first six chapters helped us to build a decent understanding of these layers (</span><em class="italic"><span class="koboSpan" id="kobo.9.1">I certainly hope so</span></em><span class="koboSpan" id="kobo.10.1">). </span><span class="koboSpan" id="kobo.10.2">Becoming acquainted with the relevant analysis methodologies should not be </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">a problem.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">Here’s a summary of what we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">be covering:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.14.1">Investigating filesystems and the </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">block layer</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">The different types of </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">filesystem I/O</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">What causes </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">filesystem latency?</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Identifying the </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">target layers</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Finding the </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">right tools</span></span></li>
</ul>
<h1 id="_idParaDest-163"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.24.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.25.1">This chapter will focus on the </span><strong class="bold"><span class="koboSpan" id="kobo.26.1">BPF Compiler Collection</span></strong><span class="koboSpan" id="kobo.27.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.28.1">BCC</span></strong><span class="koboSpan" id="kobo.29.1">) performance tools in Linux. </span><span class="koboSpan" id="kobo.29.2">Having basic system administration skills will be </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.30.1">helpful, as these tools deal with system-level monitoring and analysis. </span><span class="koboSpan" id="kobo.30.2">Understanding processes, system resource utilization, and performance metrics will assist you to interpret the results obtained from the BCC tools. </span><span class="koboSpan" id="kobo.30.3">It would be best to have the required privileges (</span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">root</span></strong><span class="koboSpan" id="kobo.32.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">sudo</span></strong><span class="koboSpan" id="kobo.34.1">) to run </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">these tools.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">The operating system packages relevant to this chapter can be installed </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.38.1">For Ubuntu/Debian:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">sudo apt </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">install strace</span></strong></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">sudo apt </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">install bpfcc-tools</span></strong></span></li></ul></li>
<li><span class="koboSpan" id="kobo.43.1">For Fedora/CentOS/Red </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">Hat-based systems:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">sudo yum </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">install strace</span></strong></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">sudo yum </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">install bcc-tools</span></strong></span></li></ul></li>
</ul>
<h1 id="_idParaDest-164"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.49.1">Investigating filesystems and the block layer</span></h1>
<p><span class="koboSpan" id="kobo.50.1">Given that storage is a lot more sluggish than other components in a system, it is no surprise that, very often, performance issues are related to I/O. </span><span class="koboSpan" id="kobo.50.2">However, simply categorizing a performance issue as I/O-based is </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">an oversimplification.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Filesystems are</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.53.1"> the first point of contact for an application and are considered to be sandwiched between the application and physical storage. </span><span class="koboSpan" id="kobo.53.2">Traditionally, physical storage has always been the center of attention while doing any performance analysis. </span><span class="koboSpan" id="kobo.53.3">Most tools focus on the utilization, throughput, and latency of the physical drives, while leaving out the other aspects of an I/O request. </span><span class="koboSpan" id="kobo.53.4">Scrutinizing storage usually begins and ends with physical disks, making filesystems analysis </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">an oversight.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Similarly, the events happening in the block layer also tend to slip under the radar when it comes to performance analysis. </span><span class="koboSpan" id="kobo.55.2">The tools that we discussed in </span><a href="B19430_09.xhtml#_idTextAnchor160"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.56.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.57.1"> usually provide averaged-out values over a specific interval, which can often be misleading. </span><span class="koboSpan" id="kobo.57.2">For instance, let’s say an application generates the following number of I/O requests in a </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">10-second interval:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-8">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.59.1">Second</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.60.1">Number </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.61.1">of requests</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.62.1">Second</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.63.1">Number </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.64.1">of requests</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.65.1">1</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.66.1">10</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.67.1">6</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.68.1">20</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.69.1">2</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.70.1">15</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.71.1">7</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.72.1">5</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.73.1">3</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.74.1">500</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.75.1">8</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.76.1">15</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.77.1">4</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.78.1">20</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.79.1">9</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.80.1">8</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.81.1">5</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.82.1">5</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.83.1">10</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.84.1">2</span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.85.1">Table 10.1 – The averaged out stats for I/O requests</span></p>
<p><span class="koboSpan" id="kobo.86.1">If I collect I/O statistics after every 10 seconds, then the number of average I/O requests issued per second will be 60 – that is, the total number of requests divided by the interval. </span><span class="koboSpan" id="kobo.86.2">The mean value might be considered normal, but it completely ignores the burst of I/O requests issued around the three-second mark. </span><span class="koboSpan" id="kobo.86.3">The tools that provide disk-level statistics do not provide any insight on a </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">per-I/O basis.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">The conventional approach has always been to gather information from the bottom end of the filesystem – that is, physical disks. </span><span class="koboSpan" id="kobo.88.2">However, this a multifaceted problem and involves analyzing the </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">following layers:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.90.1">System and library calls</span></strong><span class="koboSpan" id="kobo.91.1">: Applications use the generic system call interface to request resources from the kernel space. </span><span class="koboSpan" id="kobo.91.2">When an application calls a function that is provided by the kernel, then the execution time is spent inside the kernel space. </span><span class="koboSpan" id="kobo.91.3">This function is known as a </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">system call</span></strong><span class="koboSpan" id="kobo.93.1">. </span><span class="koboSpan" id="kobo.93.2">Library calls, conversely, are executed in user space. </span><span class="koboSpan" id="kobo.93.3">When an application wants to utilize functions defined in a programming library, such as the GNU C-library, it sends a request known as a </span><strong class="bold"><span class="koboSpan" id="kobo.94.1">library call</span></strong><span class="koboSpan" id="kobo.95.1">. </span><span class="koboSpan" id="kobo.95.2">To accurately assess performance, it’s essential to measure the time spent in both the kernel and user space. </span><span class="koboSpan" id="kobo.95.3">By tracing these calls, it’s possible to gain valuable insights into how the application behaves and identify any potential issues, such as resource contention or locking that may cause a process to </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">become stuck.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.97.1">VFS</span></strong><span class="koboSpan" id="kobo.98.1">: As we explained throughout this book, VFS acts as the interface between the user and the backing filesystem. </span><span class="koboSpan" id="kobo.98.2">It decouples the application’s file operations from the specific filesystem, masking the implementation details behind generic system calls. </span><span class="koboSpan" id="kobo.98.3">The VFS also includes the page cache, inode, and dentry cache to speed up disk access. </span><span class="koboSpan" id="kobo.98.4">Analyzing VFS can prove helpful for general workload characterization, to identify an application’s operational patterns over time, and to pinpoint how the application uses the different types of </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">available cache.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.100.1">Filesystems</span></strong><span class="koboSpan" id="kobo.101.1">: Every filesystem uses a different approach to organizing data on disk. </span><span class="koboSpan" id="kobo.101.2">As we explained in </span><a href="B19430_09.xhtml#_idTextAnchor160"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.102.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.103.1">, it is important to characterize the type of workload that the filesystem will be managing – for instance, access patterns of an application, synchronous and asynchronous operations, the ratio of read and write requests, the cache hit and miss ratio, and the size of I/O requests. </span><span class="koboSpan" id="kobo.103.2">Internally, filesystems perform operations such as read-ahead, pre-fetching, locking, and journaling, which can affect overall I/O performance in one way </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">or another.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.105.1">Block layer</span></strong><span class="koboSpan" id="kobo.106.1">: When an I/O request enters a block layer, it can be mapped onto another device, such as LVM, software </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">Redundant Array of Independent Disks</span></strong><span class="koboSpan" id="kobo.108.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.109.1">RAID</span></strong><span class="koboSpan" id="kobo.110.1">), or a multi-pathed device. </span><span class="koboSpan" id="kobo.110.2">It is commonplace to have a filesystem created on top of these logical devices. </span><span class="koboSpan" id="kobo.110.3">In such cases, with any filesystem I/O, the corresponding tasks for these techniques require resources that may be the source of an I/O contention, such as RAID striping or multi-pathing </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">I/O drivers.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.112.1">Scheduler</span></strong><span class="koboSpan" id="kobo.113.1">: The choice of a disk scheduler can also impact the I/O performance of an application. </span><span class="koboSpan" id="kobo.113.2">A scheduler can use techniques such as merging and sorting, which can change the eventual order in which a request lands on the disk. </span><span class="koboSpan" id="kobo.113.3">As we learned in </span><a href="B19430_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.114.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.115.1">, the Linux kernel offers different flavors of disk schedulers. </span><span class="koboSpan" id="kobo.115.2">Some I/O schedulers are only suited for high-end storage devices, while others work well with slower drives. </span><span class="koboSpan" id="kobo.115.3">As each environment is different, multiple factors need to be taken into account before deciding the appropriate </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">disk scheduler.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.117.1">Physical storage</span></strong><span class="koboSpan" id="kobo.118.1">: The physical layer is usually the point of focus in any troubleshooting scenario. </span><span class="koboSpan" id="kobo.118.2">We covered the part about analyzing the different physical disk metrics in </span><a href="B19430_09.xhtml#_idTextAnchor160"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.119.1">Chapter 9</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.120.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.121.1">Although not covered here, it’s important to know that it is possible to bypass the filesystem and write data directly to the physical storage. </span><span class="koboSpan" id="kobo.121.2">This is known as </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">raw access</span></strong><span class="koboSpan" id="kobo.123.1">, and a device accessed through such methods is known as a </span><strong class="bold"><span class="koboSpan" id="kobo.124.1">raw device</span></strong><span class="koboSpan" id="kobo.125.1">. </span><span class="koboSpan" id="kobo.125.2">Some applications, such as databases, are capable of writing to raw devices. </span><span class="koboSpan" id="kobo.125.3">The primary reason for this approach is that any layer of abstraction, such as a filesystem or a volume manager, adds processing overhead. </span><span class="koboSpan" id="kobo.125.4">Filesystems make use of a buffer cache to cache read and write operations, deferring their commitment to the disk until later. </span><span class="koboSpan" id="kobo.125.5">With the absence of a filesystem, large applications such as databases are able to bypass the filesystem cache, which allows them to manage their own cache. </span><span class="koboSpan" id="kobo.125.6">This approach provides more granular control over device I/O and may aid in testing the raw speed of storage devices, as it bypasses any additional </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">processing overhead.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.127.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.128.1">.1</span></em><span class="koboSpan" id="kobo.129.1"> highlights some factors that can affect the I/O performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">an application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<span class="koboSpan" id="kobo.131.1"><img alt="Figure 10.1 – The factors affecting an application’s I/O performance" src="image/B19430_10_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.132.1">Figure 10.1 – The factors affecting an application’s I/O performance</span></p>
<p><span class="koboSpan" id="kobo.133.1">In summary, the different layers in the I/O stack can influence an application’s I/O performance in various ways. </span><span class="koboSpan" id="kobo.133.2">Therefore, when troubleshooting any performance problem, breaking it down into smaller pieces is the first step; simplify the problem by removing as many layers </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">as possible.</span></span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.135.1">The different types of filesystem I/O</span></h1>
<p><span class="koboSpan" id="kobo.136.1">There are too</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.137.1"> many different types of I/O requests that can be issued to a filesystem. </span><span class="koboSpan" id="kobo.137.2">For the sake of clarity, we’ll consider an I/O request issued by a process as logical I/O, while the actual operation that was performed on the disk will be called physical I/O. </span><span class="koboSpan" id="kobo.137.3">As you can probably guess, the two are not equal. </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">Logical I/O</span></strong><span class="koboSpan" id="kobo.139.1"> refers </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.140.1">to the process of reading or writing data at the logical level, meaning at the level of the filesystem or application. </span><span class="koboSpan" id="kobo.140.2">Conversely, </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">physical I/O</span></strong><span class="koboSpan" id="kobo.142.1"> involves the transfer of data between the storage device and memory. </span><span class="koboSpan" id="kobo.142.2">It is during this </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.143.1">stage that the data is moved at the hardware level and managed by a hardware device such as a </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">disk controller.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">Disk I/O can be inflated or deflated. </span><span class="koboSpan" id="kobo.145.2">A single logical I/O request may result in multiple physical disk operations. </span><span class="koboSpan" id="kobo.145.3">Conversely, a logical request from a process may not require any physical I/O from </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">the disk.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">To elaborate on the concept, let’s take a look at some of the factors that make the two types of </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">requests disproportionate:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.149.1">Caching</span></strong><span class="koboSpan" id="kobo.150.1">: The </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.151.1">Linux kernel heavily uses available memory to cache data. </span><span class="koboSpan" id="kobo.151.2">If data is loaded from the disk, it is kept in the cache so that any subsequent access to the same data can be readily served. </span><span class="koboSpan" id="kobo.151.3">If a read request by an application is served from the cache, it will not result in a </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">physical operation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.153.1">Writeback</span></strong><span class="koboSpan" id="kobo.154.1">: As </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.155.1">filesystem writes are cached by default, this also contributes to the difference in the number of physical and logical operations. </span><span class="koboSpan" id="kobo.155.2">The writeback caching mechanism defers and coalesces write operations before eventually flushing them </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">to disks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.157.1">Prefetching</span></strong><span class="koboSpan" id="kobo.158.1">: Most </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.159.1">filesystems have a pre-fetching mechanism through which they can prefetch sequentially adjacent blocks in the cache while a block is read from the disk. </span><span class="koboSpan" id="kobo.159.2">The filesystem anticipates the data that an application will need and reads it into memory before the application actually requests it. </span><span class="koboSpan" id="kobo.159.3">The pre-fetching operations make sequential reads very fast. </span><span class="koboSpan" id="kobo.159.4">If the data has already been pre-fetched in the cache, the filesystem can avoid future trips to the physical storage, thereby reducing the number of </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">physical operations.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.161.1">Journaling</span></strong><span class="koboSpan" id="kobo.162.1">: Depending</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.163.1"> upon the type of journaling technique being employed by the filesystem, the number of write operations can be doubled. </span><span class="koboSpan" id="kobo.163.2">At first, they will be written to the filesystem journal, and then flushed </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">to disk.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.165.1">Metadata</span></strong><span class="koboSpan" id="kobo.166.1">: Every time a </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.167.1">file is accessed or modified, the filesystem will need to update its timestamps. </span><span class="koboSpan" id="kobo.167.2">Similarly, when writing any new data, the filesystem will also need to update its internal metadata, such as the number of used and free blocks. </span><span class="koboSpan" id="kobo.167.3">All these changes require physical operations to be performed </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">on disk.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.169.1">RAID</span></strong><span class="koboSpan" id="kobo.170.1">: This can be often</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.171.1"> overlooked, but the type of RAID configuration on the underlying storage can have a huge say in determining whether additional writes are necessary. </span><span class="koboSpan" id="kobo.171.2">For instance, operations such as striping data across multiple disks, writing parity information, creating mirrored copies, and rebuilding data will incur </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">additional writes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.173.1">Scheduling</span></strong><span class="koboSpan" id="kobo.174.1">: I/O schedulers</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.175.1"> usually employ techniques such as merging and reordering to minimize disk seeks and improve disk performance. </span><span class="koboSpan" id="kobo.175.2">Hence, multiple requests can be consolidated into a single request in the </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">scheduling layer.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.177.1">Data reduction</span></strong><span class="koboSpan" id="kobo.178.1">: If any </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.179.1">compression or deduplication is performed, the amount of physical I/O requests performed on disks will be lower than the logical requests initiated by </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">an application.</span></span></li>
</ul>
<h1 id="_idParaDest-166"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.181.1">What causes filesystem latency?</span></h1>
<p><span class="koboSpan" id="kobo.182.1">Latency, as we </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.183.1">discussed in </span><a href="B19430_09.xhtml#_idTextAnchor160"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.184.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.185.1">, is the single most important metric in any performance measurement and analysis. </span><span class="koboSpan" id="kobo.185.2">From the filesystem’s perspective, latency is measured as the time from which a logical request was initiated to the time it was completed on the </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">physical disk.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">The latency endured because of the bottlenecks in physical storage is one factor that adds to overall filesystem response time. </span><span class="koboSpan" id="kobo.187.2">However, to reiterate our discussion from the previous section, as filesystems do not simply hand over an I/O request to the physical disk, latency can be experienced in more than one way, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.189.1">Resource contention</span></strong><span class="koboSpan" id="kobo.190.1">: If multiple processes concurrently write to a single file, then this can impact filesystem performance. </span><span class="koboSpan" id="kobo.190.2">File locking can be a significant performance issue for large applications, such as databases. </span><span class="koboSpan" id="kobo.190.3">The purpose of locking is to serialize access to files. </span><span class="koboSpan" id="kobo.190.4">Filesystems in Linux use the generic VFS methods </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">for locking.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.192.1">Cache misses</span></strong><span class="koboSpan" id="kobo.193.1">: The purpose of caching data in memory is to avoid frequent trips to disks. </span><span class="koboSpan" id="kobo.193.2">If an application is configured to avoid using the page cache, then it can experience </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">some delays.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.195.1">Block size</span></strong><span class="koboSpan" id="kobo.196.1">: Most storage systems are designed to work with a specific block size, such as 8 K, 32 K, or 64 K. </span><span class="koboSpan" id="kobo.196.2">If the issued I/O requests are of large sizes, they will first need to be broken down into suitable sizes, which will involve </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">extra processing.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.198.1">Metadata updates</span></strong><span class="koboSpan" id="kobo.199.1">: Filesystem metadata updates can be a major source of latency. </span><span class="koboSpan" id="kobo.199.2">Updating filesystem metadata involves performing several disk operations, including seeking the appropriate disk location, writing the updated data, and then synchronizing the disk cache with the disk. </span><span class="koboSpan" id="kobo.199.3">Depending on the size and location of the metadata being updated, this sequence can take a significant amount of time, especially if</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.200.1"> the filesystem is heavily used and the disk is busy with other operations. </span><span class="koboSpan" id="kobo.200.2">This may result in a backlog of requests and an overall slowdown in </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">filesystem performance.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.202.1">Breakdown of logical I/O</span></strong><span class="koboSpan" id="kobo.203.1">: As explained earlier in the previous section, a logical I/O operation may need to be broken down into multiple physical I/O operations. </span><span class="koboSpan" id="kobo.203.2">This may increase the filesystem latency, as each physical I/O operation requires additional disk access time, which will result in additional </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">processing overhead.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.205.1">Data alignment</span></strong><span class="koboSpan" id="kobo.206.1">: File system partitions must be correctly aligned with the physical disk geometry. </span><span class="koboSpan" id="kobo.206.2">Incorrect partition alignment will cause reduced performance, especially with regard to </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">RAID volumes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.208.1">Given the </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.209.1">plethora of things that can affect the I/O performance of an application, it is no surprise that most people are reluctant to explore this avenue and merely focus on disk-level statistics, which are far easier to understand. </span><span class="koboSpan" id="kobo.209.2">We’ve so far only covered some common issues that can impact the life of an I/O request. </span><span class="koboSpan" id="kobo.209.3">Troubleshooting is a complex skill to master, and it can be a difficult decision to determine a good starting point. </span><span class="koboSpan" id="kobo.209.4">Adding to the confusion is the wealth of tools that can be used for performance analysis. </span><span class="koboSpan" id="kobo.209.5">Even though we’re only focusing on the storage side of things here, it is impossible to cover the long list of tools that can help us in our goal in one way </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">or another.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.211.1">Identifying the target layers</span></h1>
<p><span class="koboSpan" id="kobo.212.1">The following table summarizes the </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.213.1">different target layers for performance analysis and presents the pros and cons of </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">each approach:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.215.1">Layer</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.216.1">Pros</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.217.1">Cons</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.218.1">Application</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.219.1">Application logs, specific tools, or debugging techniques can determine the scope of the problem, which can aid in </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">subsequent steps.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.221.1">Debugging techniques are not common and vary for </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">each application.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.223.1">System </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">call interface</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.225.1">It’s easy to trace the calls generated by </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">a process.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.227.1">It’s difficult to filter, as there are multiple system calls for the </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">same function.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.229.1">VFS</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.230.1">Generic calls are used for </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">all filesystems.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.232.1">There is a need to isolate the filesystem in question, as tracing may include data for all filesystems, including </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">pseudo filesystems.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.234.1">Filesystems</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.235.1">Filesystems are the first point of contact for an application, which makes them an ideal candidate </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">for analysis.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.237.1">There are very few filesystem-specific tracing </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">mechanisms available.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.239.1">Block layer</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.240.1">Multiple tracing mechanisms are available, which can be used to identify how requests </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">are handled.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.242.1">Some components, such as schedulers, do not offer a lot </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">of tunables.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.244.1">Disk</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.245.1">This is easier to analyze, as this does not require a deep understanding of </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">higher layers.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.247.1">This does not paint a clear picture of an </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">application’s behavior.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.249.1">Table 10.2 – Comparing the pros and cons of analyzing each layer</span></p>
<p><span class="koboSpan" id="kobo.250.1">The general consensus (and it definitely has some merit) is that investigating each layer is way too laborious! </span><span class="koboSpan" id="kobo.250.2">Enterprises that have dedicated performance analysis engineers make it a habit to go through every tiny detail and identify the potential bottlenecks in a system. </span><span class="koboSpan" id="kobo.250.3">However, the more common approach in recent times has been to add more compute power, especially for cloud-based workloads. </span><span class="koboSpan" id="kobo.250.4">Adding more hardware resources to an application, as it becomes resource-hungry, is the new normal. </span><span class="koboSpan" id="kobo.250.5">Troubleshooting performance issues is often skipped in favor of migrating applications to better </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">hardware platforms.</span></span></p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.252.1">Finding the right tools</span></h1>
<p><span class="koboSpan" id="kobo.253.1">Trying to dig deep into an application’s behavior can be a daunting task. </span><span class="koboSpan" id="kobo.253.2">The abstraction layers in the I/O stack do not make our job easier in this regard. </span><span class="koboSpan" id="kobo.253.3">To analyze each layer in the I/O hierarchy, you must have a decent grasp of the concepts used in each layer. </span><span class="koboSpan" id="kobo.253.4">The job is made even tougher when you include the application in this setup. </span><span class="koboSpan" id="kobo.253.5">Although the tracing mechanisms in Linux can help to understand the patterns generated by an application, it is not possible for everyone to have the same level of visibility about the design and implementation details of </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">If you’re running a critical application, such as an </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">Online Transaction Processing</span></strong><span class="koboSpan" id="kobo.257.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.258.1">OLTP</span></strong><span class="koboSpan" id="kobo.259.1">) database that processes millions of transactions every day, it can be helpful to know where CPU cycles are wasted. </span><span class="koboSpan" id="kobo.259.2">For instance, there are several service-level agreements associated with a transaction, and it has to be completed within a few seconds. </span><span class="koboSpan" id="kobo.259.3">If a single transaction is required to be completed within 10 seconds, and only one second is spent processing the filesystem and disk I/O, then clearly your storage is not a bottleneck, as only 10 percent of the total time is being spent in the I/O stack. </span><span class="koboSpan" id="kobo.259.4">If the application was blocked at the filesystem level for five seconds, then clearly some tweaking </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">is required.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">Let’s take a look at the available options that we have to analyze the I/O stack. </span><span class="koboSpan" id="kobo.261.2">Note that this is not a complete list of tools by any means. </span><span class="koboSpan" id="kobo.261.3">The BCC itself contains an abundance of such tools. </span><span class="koboSpan" id="kobo.261.4">The tools presented as follows have just been cherry-picked based on </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">personal experience.</span></span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.263.1">Tracing application calls</span></h2>
<p><span class="koboSpan" id="kobo.264.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.265.1">strace utility</span></strong><span class="koboSpan" id="kobo.266.1"> is one of the most well-known tools in Linux, which displays information about system calls made by a process. </span><span class="koboSpan" id="kobo.266.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">strace</span></strong><span class="koboSpan" id="kobo.268.1"> command helps identify the kernel function on which a program spends its time. </span><span class="koboSpan" id="kobo.268.2">For instance, the following command provides a summarized report and shows the frequency and time spent on each system call. </span><span class="koboSpan" id="kobo.268.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">-c</span></strong><span class="koboSpan" id="kobo.270.1"> switch displays the count. </span><span class="koboSpan" id="kobo.270.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">myapp</span></strong><span class="koboSpan" id="kobo.272.1"> is just a simple user </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">space program:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<span class="koboSpan" id="kobo.274.1"><img alt="Figure 10.2 – Tracing system calls using strace" src="image/B19430_10_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.275.1">Figure 10.2 – Tracing system calls using strace</span></p>
<p><span class="koboSpan" id="kobo.276.1">This command can prove useful to pinpoint some types of process performance bottlenecks. </span><span class="koboSpan" id="kobo.276.2">To filter the output and only show stats for a specific system call, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">-</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">e</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.279.1"> flag:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<span class="koboSpan" id="kobo.280.1"><img alt="Figure 10.3 – Filtering specific calls" src="image/B19430_10_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.281.1">Figure 10.3 – Filtering specific calls</span></p>
<p><span class="koboSpan" id="kobo.282.1">Let’s take it up a notch and see whether we can make something out of the actual trace output. </span><span class="koboSpan" id="kobo.282.2">You can also print the timestamps and the time spent on each system call. </span><span class="koboSpan" id="kobo.282.3">The trace output can be saved to a file using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">-</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">o</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1"> flag:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.286.1">strace -T -ttt -o output.txt ./myapp</span></strong></pre>
<p><span class="koboSpan" id="kobo.287.1">Focusing only on the subset that corresponds to the I/O portion of the application, note the number after the equal sign in the first write call. </span><span class="koboSpan" id="kobo.287.2">We can see that the write call was able to buffer all data into a single write function call. </span><span class="koboSpan" id="kobo.287.3">The application wrote 319,488 bytes in </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">156 microseconds:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<span class="koboSpan" id="kobo.289.1"><img alt="Figure 10.4 – Analyzing the strace output" src="image/B19430_10_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.290.1">Figure 10.4 – Analyzing the strace output</span></p>
<p><span class="koboSpan" id="kobo.291.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">strace</span></strong><span class="koboSpan" id="kobo.293.1"> command can also be attached to a running process. </span><span class="koboSpan" id="kobo.293.2">The strace output is quite substantial, and you often have to laboriously look through a great deal of information before you get somewhere. </span><span class="koboSpan" id="kobo.293.3">This is why it is a good idea to know about the most frequently generated calls by an application. </span><span class="koboSpan" id="kobo.293.4">For I/O analysis, focus on common system calls, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">open</span></strong><span class="koboSpan" id="kobo.295.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">read</span></strong><span class="koboSpan" id="kobo.297.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">write</span></strong><span class="koboSpan" id="kobo.299.1">. </span><span class="koboSpan" id="kobo.299.2">This can help in understanding the I/O pattern of an application from the application’s perspective. </span><span class="koboSpan" id="kobo.299.3">Although </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">strace</span></strong><span class="koboSpan" id="kobo.301.1"> doesn’t tell you what the operating system did with the I/O requests afterward, it does tell you what the </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">application generates.</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">To summarize, for a quick analysis, do </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.305.1">Generate a summary of the system calls being generated by </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">the application.</span></span></li>
<li><span class="koboSpan" id="kobo.307.1">Check the execution times of </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">each call.</span></span></li>
<li><span class="koboSpan" id="kobo.309.1">Isolate the calls you want information about. </span><span class="koboSpan" id="kobo.309.2">For I/O analysis, focus on read and </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">write calls.</span></span></li>
</ul>
<h2 id="_idParaDest-170"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.311.1">Tracing VFS calls</span></h2>
<p><span class="koboSpan" id="kobo.312.1">At the very beginning of your investigation, analyzing VFS can be beneficial for general workload characterization. </span><span class="koboSpan" id="kobo.312.2">It can also be helpful to identify how efficiently an application makes use of the different types of available caches in VFS. </span><span class="koboSpan" id="kobo.312.3">The BCC program contains tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">vfsstat</span></strong><span class="koboSpan" id="kobo.314.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">vfscount</span></strong><span class="koboSpan" id="kobo.316.1">, which can help to understand the events </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">in VFS.</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">vfsstat</span></strong><span class="koboSpan" id="kobo.320.1"> tool shows a statistics summary for some common VFS calls, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">read</span></strong><span class="koboSpan" id="kobo.322.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">write</span></strong><span class="koboSpan" id="kobo.324.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">open</span></strong><span class="koboSpan" id="kobo.326.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">create</span></strong><span class="koboSpan" id="kobo.328.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">fsync</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<span class="koboSpan" id="kobo.332.1"><img alt="Figure 10.5 – The vfsstat output" src="image/B19430_10_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.333.1">Figure 10.5 – The vfsstat output</span></p>
<p><span class="koboSpan" id="kobo.334.1">In addition to the </span><strong class="bold"><span class="koboSpan" id="kobo.335.1">READ</span></strong><span class="koboSpan" id="kobo.336.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.337.1">WRITE</span></strong><span class="koboSpan" id="kobo.338.1"> calls, keep an eye out for the </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">OPEN</span></strong><span class="koboSpan" id="kobo.340.1"> column. </span><span class="koboSpan" id="kobo.340.2">This shows the number of files opened per second. </span><span class="koboSpan" id="kobo.340.3">A sudden increase in the number of open files can greatly increase the number of I/O requests, especially for </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">metadata operations.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">Running these tools alone might not offer much insight. </span><span class="koboSpan" id="kobo.342.2">A good use of these is to run them in conjunction with some disk analysis tools, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">iostat</span></strong><span class="koboSpan" id="kobo.344.1">. </span><span class="koboSpan" id="kobo.344.2">This will allow you to compare logical I/O requests with physical </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">I/O requests.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">One limitation with </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">vfsstat</span></strong><span class="koboSpan" id="kobo.348.1"> is that it doesn’t segregate the I/O activity at the filesystem level. </span><span class="koboSpan" id="kobo.348.2">Another program, </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">fsrwstat</span></strong><span class="koboSpan" id="kobo.350.1">, traces the read and write functions and breaks them down for the different available filesystems. </span><span class="koboSpan" id="kobo.350.2">The following figure shows the breakdown of the number of read and write calls for the </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">different filesystems:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer100">
<span class="koboSpan" id="kobo.352.1"><img alt="Figure 10.6 – The fsrwstat output" src="image/B19430_10_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.353.1">Figure 10.6 – The fsrwstat output</span></p>
<p><span class="koboSpan" id="kobo.354.1">Continuing with the output of </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">vfsstat</span></strong><span class="koboSpan" id="kobo.356.1">, if you notice a large number of files are open, consider using </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">filetop</span></strong><span class="koboSpan" id="kobo.358.1">. </span><span class="koboSpan" id="kobo.358.2">This shows the most frequently accessed files on your system and displays their read and </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">write activity:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer101">
<span class="koboSpan" id="kobo.360.1"><img alt="Figure 10.7 – The filetop output" src="image/B19430_10_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.361.1">Figure 10.7 – The filetop output</span></p>
<p><span class="koboSpan" id="kobo.362.1">The requests issued to VFS constitute logical I/O requests. </span><span class="koboSpan" id="kobo.362.2">When analyzing VFS, do </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.364.1">Try to get a picture of the general workload on </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">the system</span></span></li>
<li><span class="koboSpan" id="kobo.366.1">Check the frequency of common </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">VFS calls</span></span></li>
<li><span class="koboSpan" id="kobo.368.1">Compare the obtained figures with the requests at the </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">physical layer</span></span></li>
</ul>
<h2 id="_idParaDest-171"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.370.1">Analyzing cache usage</span></h2>
<p><span class="koboSpan" id="kobo.371.1">The VFS includes multiple caches to speed up access to frequently used objects. </span><span class="koboSpan" id="kobo.371.2">The default behavior in Linux is to complete all write operations in the cache and flush the written data to disk later. </span><span class="koboSpan" id="kobo.371.3">Similarly, the kernel also tries to serve the read operations from the cache and shows the page cache </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">hit-and-miss statistics.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">cachestat</span></strong><span class="koboSpan" id="kobo.375.1"> tool can be used to display statistics for the page cache </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">hit-and-miss ratios:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer102">
<span class="koboSpan" id="kobo.377.1"><img alt="Figure 10.8 – Using cachestat" src="image/B19430_10_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.378.1">Figure 10.8 – Using cachestat</span></p>
<p><span class="koboSpan" id="kobo.379.1">From the preceding figure, we can see an excellent cache hit ratio, sometimes even close to 100 percent. </span><span class="koboSpan" id="kobo.379.2">This indicates that the kernel is able to satisfy the application’s I/O requests from the memory. </span><span class="koboSpan" id="kobo.379.3">The higher the percentage of cache hits, the better the performance gains for </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">Similarly, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">cachetop</span></strong><span class="koboSpan" id="kobo.383.1"> tool provides process-wise statistics for the cache hits and misses. </span><span class="koboSpan" id="kobo.383.2">The output is displayed on an interactive interface like the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">top</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.385.1"> command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer103">
<span class="koboSpan" id="kobo.386.1"><img alt="Figure 10.9 – Using cachetop" src="image/B19430_10_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.387.1">Figure 10.9 – Using cachetop</span></p>
<p><span class="koboSpan" id="kobo.388.1">When using these tools to analyze cache usage, do </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.390.1">Look for the hits-and-misses ratio to understand what percentage of requests are being served </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">from memory</span></span></li>
<li><span class="koboSpan" id="kobo.392.1">If the ratio is on the lower side, the application or operating system parameters might need to </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">be tuned</span></span></li>
</ul>
<h2 id="_idParaDest-172"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.394.1">Analyzing filesystems</span></h2>
<p><span class="koboSpan" id="kobo.395.1">Although there aren’t many tools that can trace filesystem-level operations, BCC offers a few excellent scripts to observe filesystems. </span><span class="koboSpan" id="kobo.395.2">Two scripts, </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">ext4slower</span></strong><span class="koboSpan" id="kobo.397.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">xfsslower</span></strong><span class="koboSpan" id="kobo.399.1">, are used to analyze the slow operations on the two most frequently used filesystems, Ext4 </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">and XFS.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">The output for both tools, </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">ext4slower</span></strong><span class="koboSpan" id="kobo.403.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">xfsslower</span></strong><span class="koboSpan" id="kobo.405.1">, is identical. </span><span class="koboSpan" id="kobo.405.2">By default, both tools print operations that take more than 10 ms to complete, but you can change that by passing the duration value as a parameter. </span><span class="koboSpan" id="kobo.405.3">Both tools can also be attached to a </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">specific process:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer104">
<span class="koboSpan" id="kobo.407.1"><img alt="Figure 10.10 – Tracing the slow Ext4 operations" src="image/B19430_10_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.408.1">Figure 10.10 – Tracing the slow Ext4 operations</span></p>
<p><span class="koboSpan" id="kobo.409.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.410.1">T</span></strong><span class="koboSpan" id="kobo.411.1"> column shows the type of operation, which can be </span><strong class="bold"><span class="koboSpan" id="kobo.412.1">R</span></strong><span class="koboSpan" id="kobo.413.1"> for read, </span><strong class="bold"><span class="koboSpan" id="kobo.414.1">W</span></strong><span class="koboSpan" id="kobo.415.1"> for write, and </span><strong class="bold"><span class="koboSpan" id="kobo.416.1">O</span></strong><span class="koboSpan" id="kobo.417.1"> for open. </span><span class="koboSpan" id="kobo.417.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.418.1">BYTES</span></strong><span class="koboSpan" id="kobo.419.1"> column shows the size of the I/O in bytes, while the </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">OFF_KB</span></strong><span class="koboSpan" id="kobo.421.1"> column shows the file offset for the I/O, in KB. </span><span class="koboSpan" id="kobo.421.2">The most important values come from the </span><strong class="bold"><span class="koboSpan" id="kobo.422.1">LAT(ms)</span></strong><span class="koboSpan" id="kobo.423.1"> column, which shows the duration of an I/O request, measured from when it was issued by VFS to the filesystem to when it was completed. </span><span class="koboSpan" id="kobo.423.2">This is a fairly accurate measure of the latency endured by an application while performing </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">filesystem I/O.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">Another couple of tools included in this set are </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">xfsdist</span></strong><span class="koboSpan" id="kobo.427.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">ext4dist</span></strong><span class="koboSpan" id="kobo.429.1">. </span><span class="koboSpan" id="kobo.429.2">Both tools show the same information, just for different filesystems – that is, XFS and Ext4, respectively. </span><span class="koboSpan" id="kobo.429.3">These tools summarize the time spent while performing common filesystem operations and provide a breakdown of the distribution of the experienced latencies as histograms. </span><span class="koboSpan" id="kobo.429.4">Both these tools can be attached to </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">specific processes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer105">
<span class="koboSpan" id="kobo.431.1"><img alt="Figure 10.11 – Using xfsdist" src="image/B19430_10_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.432.1">Figure 10.11 – Using xfsdist</span></p>
<p><span class="koboSpan" id="kobo.433.1">When using filesystem-specific tools, remember </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.435.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">ext4dist</span></strong><span class="koboSpan" id="kobo.437.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">xfsdist</span></strong><span class="koboSpan" id="kobo.439.1"> tools can help to establish a baseline – that is, whether a workload is read- </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">or write-oriented.</span></span></li>
<li><span class="koboSpan" id="kobo.441.1">The two </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">ext4slower</span></strong><span class="koboSpan" id="kobo.443.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">xfsslower</span></strong><span class="koboSpan" id="kobo.445.1"> scripts are extremely effective in determining the actual latency experienced by a process when performing filesystem I/O. </span><span class="koboSpan" id="kobo.445.2">When running these, check the latency column to determine the amount of delay being endured by </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">the application.</span></span></li>
</ul>
<h2 id="_idParaDest-173"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.447.1">Analyzing block I/O</span></h2>
<p><span class="koboSpan" id="kobo.448.1">As we saw in </span><a href="B19430_09.xhtml#_idTextAnchor160"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.449.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.450.1">, the standard disk analysis tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">iostat</span></strong><span class="koboSpan" id="kobo.452.1"> provide information pertaining to the number of bytes read and written per second, disk utilization, and request queues associated with specific devices. </span><span class="koboSpan" id="kobo.452.2">These metrics are averaged out over a period of time and do not offer insights on a per-I/O basis. </span><span class="koboSpan" id="kobo.452.3">Extracting information about what happened at a specific interval is </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">not possible.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">Similar to VFS and filesystems, the BCC also includes several tools that can help to analyze the events happening in the block layer. </span><span class="koboSpan" id="kobo.454.2">One of these tools is </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">biotop</span></strong><span class="koboSpan" id="kobo.456.1">, which is like a </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">top</span></strong><span class="koboSpan" id="kobo.458.1"> command for disks. </span><span class="koboSpan" id="kobo.458.2">By default, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">biotop</span></strong><span class="koboSpan" id="kobo.460.1"> tool traces the I/O operations on the block device and displays a summary of each process’s activity every second. </span><span class="koboSpan" id="kobo.460.2">The summary is sorted based on the top disk consumers in terms of throughput, measured in KB. </span><span class="koboSpan" id="kobo.460.3">The process ID and name displayed in the summary represent the time when an I/O operation was initially created, which helps to identify the </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">responsible process:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer106">
<span class="koboSpan" id="kobo.462.1"><img alt="Figure 10.12 – Using biotop" src="image/B19430_10_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.463.1">Figure 10.12 – Using biotop</span></p>
<p><span class="koboSpan" id="kobo.464.1">Another BCC tool to analyze the block layer is </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">biolatency</span></strong><span class="koboSpan" id="kobo.466.1">. </span><span class="koboSpan" id="kobo.466.2">As the name suggests, </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">biolatency</span></strong><span class="koboSpan" id="kobo.468.1"> traces block device I/O and prints a histogram that shows the distribution of </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">I/O latency:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer107">
<span class="koboSpan" id="kobo.470.1"><img alt="Figure 10.13 – Using biolatency" src="image/B19430_10_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.471.1">Figure 10.13 – Using biolatency</span></p>
<p><span class="koboSpan" id="kobo.472.1">As evident from the preceding output, the bulk of I/O requests took 128–255 microseconds to complete. </span><span class="koboSpan" id="kobo.472.2">Depending on the workload, these figures can be </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">much higher.</span></span></p>
<p><span class="koboSpan" id="kobo.474.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">biosnoop</span></strong><span class="koboSpan" id="kobo.476.1"> tool from the BCC traces block device I/O and prints the details, including the process that initiated </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">the request:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer108">
<span class="koboSpan" id="kobo.478.1"><img alt="Figure 10.14 – Using biosnoop" src="image/B19430_10_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.479.1">Figure 10.14 – Using biosnoop</span></p>
<p><span class="koboSpan" id="kobo.480.1">The output from </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">biosnoop</span></strong><span class="koboSpan" id="kobo.482.1"> includes the latency from the time the request was issued to the device to its completion. </span><span class="koboSpan" id="kobo.482.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">biosnoop</span></strong><span class="koboSpan" id="kobo.484.1"> output can be used to identify the process responsible for excessive writes to </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">a disk.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">One final tool that I want to mention is </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">bitesize</span></strong><span class="koboSpan" id="kobo.488.1">, which is used to characterize the distribution of block device </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">I/O sizes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer109">
<span class="koboSpan" id="kobo.490.1"><img alt="Figure 10.15 – Using bitesize" src="image/B19430_10_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.491.1">Figure 10.15 – Using bitesize</span></p>
<p><span class="koboSpan" id="kobo.492.1">As </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.493.1">shown in the preceding output, the </span><strong class="bold"><span class="koboSpan" id="kobo.494.1">javaMyApp</span></strong><span class="koboSpan" id="kobo.495.1"> process (a simple Java-based application) generates requests between 16–32 KB, whereas </span><strong class="bold"><span class="koboSpan" id="kobo.496.1">mysql</span></strong><span class="koboSpan" id="kobo.497.1"> uses the 4–8 </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">KB range.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">When analyzing the block layer, remember </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.501.1">To get a top-end view of disk activity in</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.502.1"> your system, </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">biotop</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.506.1">To trace application I/O sizes, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">bitesize</span></strong><span class="koboSpan" id="kobo.508.1">. </span><span class="koboSpan" id="kobo.508.2">If the application workload is sequential, then using larger </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.509.1">block sizes might result in </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">better performance.</span></span></li>
<li><span class="koboSpan" id="kobo.511.1">To observe block device</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.512.1"> latencies, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">biolatency</span></strong><span class="koboSpan" id="kobo.514.1">. </span><span class="koboSpan" id="kobo.514.2">This will summarize the time ranges for the block I/O requests. </span><span class="koboSpan" id="kobo.514.3">If you see higher values, then further digging </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">is required.</span></span></li>
<li><span class="koboSpan" id="kobo.516.1">To </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.517.1">check further, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">biosnoop</span></strong><span class="koboSpan" id="kobo.519.1">. </span><span class="koboSpan" id="kobo.519.2">To find out the time spent between the creation of an I/O request and being issued to a device, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">-Q</span></strong><span class="koboSpan" id="kobo.521.1"> flag </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">biosnoop</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">.</span></span></li>
</ul>
<h2 id="_idParaDest-174"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.525.1">Summarizing the tools</span></h2>
<p><span class="koboSpan" id="kobo.526.1">The following table shows a summary of the tools that can be used to analyze the events in </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">different layers:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table003">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.528.1">Layer</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.529.1">Analysis tools</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.530.1">Application</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.531.1">Application-specific tools</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.532.1">System </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">call interface</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">strace</span></strong><span class="koboSpan" id="kobo.535.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">syscount</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.537.1"> (BCC)</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.538.1">VFS</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">vfsstat</span></strong><span class="koboSpan" id="kobo.540.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">vfscount</span></strong><span class="koboSpan" id="kobo.542.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">funccount</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.545.1">Cache</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">slabtop</span></strong><span class="koboSpan" id="kobo.547.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">cachestat</span></strong><span class="koboSpan" id="kobo.549.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">cachetop</span></strong><span class="koboSpan" id="kobo.551.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">dcstat</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">dcsnoop</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.555.1">Filesystems</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">ext4slower</span></strong><span class="koboSpan" id="kobo.557.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">xfsslower</span></strong><span class="koboSpan" id="kobo.559.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">ext4dist</span></strong><span class="koboSpan" id="kobo.561.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">xfsdist</span></strong><span class="koboSpan" id="kobo.563.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">filetop</span></strong><span class="koboSpan" id="kobo.565.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">fileslower</span></strong><span class="koboSpan" id="kobo.567.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">stackcount</span></strong><span class="koboSpan" id="kobo.569.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">funccount</span></strong><span class="koboSpan" id="kobo.571.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">nfsslower</span></strong><span class="koboSpan" id="kobo.573.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">nfsdist</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.576.1">Block layer</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">biolatency</span></strong><span class="koboSpan" id="kobo.578.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">biosnoop</span></strong><span class="koboSpan" id="kobo.580.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">biotop</span></strong><span class="koboSpan" id="kobo.582.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">bitesize</span></strong><span class="koboSpan" id="kobo.584.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">and</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.586.1"> blktrace</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.587.1">Disk</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">iostat</span></strong><span class="koboSpan" id="kobo.589.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">iotop</span></strong><span class="koboSpan" id="kobo.591.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">systemtap</span></strong><span class="koboSpan" id="kobo.593.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">vmstat</span></strong><span class="koboSpan" id="kobo.595.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">PCP</span></strong></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.598.1">Table 10.3 – A summary of tools</span></p>
<p><span class="koboSpan" id="kobo.599.1">Note that the tools are not limited to the ones mentioned in the table. </span><span class="koboSpan" id="kobo.599.2">The BCC toolset alone includes several other tools that can be used for performance analysis. </span><span class="koboSpan" id="kobo.599.3">Further, there are multiple arguments that can be passed to each tool to get a more meaningful output. </span><span class="koboSpan" id="kobo.599.4">Considering the multiple layers involved in the hierarchy, diagnosing I/O performance issues is a complex task, and as with any other troubleshooting scenario, it will require the involvement of </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">multiple teams.</span></span></p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.601.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.602.1">In this chapter, we resumed our performance analysis and extended it to the higher layers in the I/O stack. </span><span class="koboSpan" id="kobo.602.2">Most of the time, analyzing higher layers is skipped, and focus is solely kept on the physical layer. </span><span class="koboSpan" id="kobo.602.3">However, for time-sensitive applications, we need to broaden our approach and look for the potential source of delays in application </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">response times.</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">We started this chapter by explaining the different sources of delays that can be observed by an application when reading from or writing to a filesystem. </span><span class="koboSpan" id="kobo.604.2">Filesystems operations go beyond the I/O requests initiated by an application. </span><span class="koboSpan" id="kobo.604.3">In addition to application I/O requests, a filesystem can spend time on tasks such as performing metadata updates, journaling, or flushing existing cached data to disks. </span><span class="koboSpan" id="kobo.604.4">All these result in extra operations, which incur extra I/O operations. </span><span class="koboSpan" id="kobo.604.5">The tools discussed in </span><a href="B19430_09.xhtml#_idTextAnchor160"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.605.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.606.1"> were centered around disks and didn’t offer much visibility into the events happening in the VFS and the block layer. </span><span class="koboSpan" id="kobo.606.2">The BCC offers a rich set of scripts that can trace the events in the kernel and give us insight into individual </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">I/O requests.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">In the next chapter, we’ll take our analysis further and learn the different tweaks that we can apply at different levels in the I/O hierarchy, </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">improving performance.</span></span></p>
</div>
</body></html>