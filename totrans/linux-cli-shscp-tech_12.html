<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer239">
			<h1 id="_idParaDest-277"><em class="italic"><a id="_idTextAnchor283"/>Chapter 12</em>: Using Arguments and Functions</h1>
			<p>Whenever we are trying to program any kind of application or a script in any programming language, we should always try to make our code modular and easily maintainable. The thing that is going to help us a lot in this aspect of creating scripts is a concept known as a <strong class="bold">function</strong>. </p>
			<p>We will cover the following recipes in this chapter: </p>
			<ul>
				<li>Using custom functions in shell script code</li>
				<li><a id="_idTextAnchor284"/>Passing arguments to a function</li>
				<li>Local and global variables</li>
				<li>Working with returns from a function</li>
				<li>Loading an external function to a shell script</li>
				<li>Implementing commonly used procedures via functions</li>
			</ul>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor285"/>Technical requirements </h1>
			<p>For these recipes, we're going to use a Linux machine. We can use any <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>) from our previous recipes. For example, let's say that we're going to use a <strong class="source-inline">cli1</strong> VM as it's the most convenient to use, seeing that it's a <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>)-only machine. So, all in all, we need the following:</p>
			<ul>
				<li>A VM with Linux installed—any distribution (in our case, it's going to be <strong class="bold">Ubuntu 20.02</strong>).</li>
				<li>A bit of time to digest the complexities of using the VI(m) editor. Nano is less complex, therefore it's going to be easier to learn about that one.</li>
			</ul>
			<p>So, start your VM, and let's get cracking!</p>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor286"/>Using custom functions in shell script code</h1>
			<p>Up to <a id="_idIndexMarker883"/>this point, all we did was create very simple<a id="_idIndexMarker884"/> scripts that had a few commands at most. This is going to be most of your scripts since a lot of work that is solved by scripting is the simple elimination of repetitive tasks. In this chapter, we are going to work with functions as a way of creating modules of code in your script. Their main purpose is going to be to avoid repetitive blocks of code in your scripts, further simplifying the scripts themselves. </p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor287"/>Getting ready</h2>
			<p>When it comes to functions, Bash is a little bit strange. Things you may know about functions from other languages will look similar in <strong class="source-inline">bash</strong> but at the same time, completely different. We are going to start with how a function is defined. To make matters confusing from the very start, <strong class="source-inline">bash</strong> uses two very similar notations, one that looks more like something you would find in other languages, and another that is more in line with the rest of the <strong class="source-inline">bash</strong> syntax. </p>
			<p>Before we even mention them, have in mind that there is no difference in functionality or anything else in the way functions are defined—we can use either of them with the exact same results. </p>
			<p>The syntax of the first definition looks like something you would see in any programming language. There are no keywords—we simply specify the name of the function followed by two normal brackets, and then define a command block that makes up the function in curly brackets. </p>
			<p>There is a big difference between <strong class="source-inline">bash</strong> and almost every programming language out there, though. Usually, brackets in any language serve to pass arguments or parameters to the function. In <strong class="source-inline">bash</strong>, they are always empty—their only purpose is to define a function. Parameters are passed in a completely different way: </p>
			<p class="source-code">function_name () {</p>
			<p class="source-code">&lt;commands&gt;</p>
			<p class="source-code">}</p>
			<p>Another way to define a function is more in line with the way <strong class="source-inline">bash</strong> usually works. There is a reserved word, <strong class="source-inline">function</strong>; so, in order to define a function, we simply do this: </p>
			<p class="source-code">function function_name {</p>
			<p class="source-code">&lt;commands&gt;</p>
			<p class="source-code">}</p>
			<p>This version is more likely to remind you that arguments are provided in a different way, but that is probably the only difference between the two. </p>
			<p>A function must be defined before we can use it. This is completely logical since the shell runs every line one by one and, to understand a command, has to have it defined as either an internal command, an external command, or a function. Unlike some other languages, arguments and return values are not defined in advance—or, to be more precise, are not defined at all. </p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor288"/>How to do it…</h2>
			<p>As always, we<a id="_idIndexMarker885"/> are going to start with a <strong class="source-inline">hello world</strong> script, but <a id="_idIndexMarker886"/>with a little twist. We are going to use our <strong class="source-inline">echo</strong> command inside a function, and the main part of the script is going to run this function. We are also going to create an alternative version of our function just to show that both ways to define a function work the same. </p>
			<p>There are a couple of things to notice in this script—when we define a function, there is no <em class="italic">right</em> way to do it; both ways work, but they work differently. We prefer using the format that explicitly mentions the <strong class="source-inline">function</strong> keyword since it immediately draws attention to this being a definition of a function, but this is just our preference—you can use whichever format you like: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># Hello World done by a function</p>
			<p class="source-code">function HelloWorld {</p>
			<p class="source-code">    echo Hello World!</p>
			<p class="source-code">}</p>
			<p class="source-code">HelloWorld_alternate () {</p>
			<p class="source-code">    echo Hello World!</p>
			<p class="source-code">}</p>
			<p class="source-code">#now we call the functions</p>
			<p class="source-code">HelloWorld</p>
			<p class="source-code">HelloWorld_alternate</p>
			<p>When we run the script, we can see that both our functions behave exactly the same:</p>
			<p class="source-code">demo@cli1:~/scripting$ bash functions.sh </p>
			<p class="source-code">Hello World!</p>
			<p class="source-code">Hello World!</p>
			<p>Now, we <a id="_idIndexMarker887"/>are<a id="_idIndexMarker888"/> going to create an example that makes much more sense. There are going to be a lot of scripts that will require you to output things to the screen or into a file. Some parts of the output are going to be repeated over and over—a task that is exactly designed for a function:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">function PrintHeader {</p>
			<p class="source-code">    echo -----------------------</p>
			<p class="source-code">    echo Header of some sort</p>
			<p class="source-code">    echo -----------------------</p>
			<p class="source-code">}</p>
			<p class="source-code">echo In order to show how this looks like</p>
			<p class="source-code">echo we are going to print a header</p>
			<p class="source-code">PrintHeader</p>
			<p class="source-code">echo And once again</p>
			<p class="source-code">PrintHeader</p>
			<p class="source-code">echo That was it.</p>
			<p class="source-code">demo@cli1:~/scripting$ bash function.sh </p>
			<p class="source-code">In order to show how this looks like</p>
			<p class="source-code">we are going to print a header</p>
			<p class="source-code">-----------------------</p>
			<p class="source-code">Header of some sort</p>
			<p class="source-code">-----------------------</p>
			<p class="source-code">And once again</p>
			<p class="source-code">-----------------------</p>
			<p class="source-code">Header of some sort</p>
			<p class="source-code">-----------------------</p>
			<p class="source-code">That was it.</p>
			<p>What our function<a id="_idIndexMarker889"/> did is <a id="_idIndexMarker890"/>create a header for our output. When we learn to pass arguments to functions, we are going to use this trick a lot, especially when we need to output formatted text into logs or when we have a large block of text with a few variables that we need to fill in. </p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor289"/>How it works… </h2>
			<p>Functions are parts of the code that <strong class="source-inline">bash</strong> reproduces whenever we reference our function inside a script. Their purpose is primarily geared toward creating scripts that are easier to read and debug. There is another reason to use functions: avoiding errors in code. If we need to reuse parts of the code in different parts of the script, we can always copy and paste <a id="_idIndexMarker891"/>it, but that creates a large possibility<a id="_idIndexMarker892"/> that we will introduce bugs into the script. </p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor290"/>See also</h2>
			<ul>
				<li><a href="https://www.shell-tips.com/bash/functions/">https://www.shell-tips.com/bash/functions/</a></li>
				<li><a href="https://tldp.org/LDP/abs/html/complexfunct.html">https://tldp.org/LDP/abs/html/complexfunct.html</a></li>
			</ul>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor291"/>Passing arguments to a function </h1>
			<p>We started <a id="_idIndexMarker893"/>demonstrating<a id="_idIndexMarker894"/> what a function looks like by showing you a simple script, the simplest we could create. We still haven't defined how to <em class="italic">talk</em> to your function, and we still don't know how to give a function some parameters or arguments and get something in return. In this recipe, we are going to fix that. </p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor292"/>Getting ready</h2>
			<p>Since we mentioned arguments, we need to talk a little about them. <strong class="source-inline">bash</strong> treats arguments in functions the same as it does in the script itself—arguments become local variables inside the function block. To return a value, we also do almost exactly the same as when we need to deal with the whole script—we simply return a value from our function block and then read it inside the main script body. </p>
			<p>Remember when we said you can reference arguments that were given to your script when it was initially called, and that we used variables called <strong class="source-inline">$1</strong>, <strong class="source-inline">$2</strong>, <strong class="source-inline">$3</strong>, and so on to get the first, second, third, and other parameters that were in the command line? The exact same thing applies to functions. In this case, we use the same variable names as when referencing arguments given to our function. </p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor293"/>How to do it…</h2>
			<p>In order to send two parameters to a simple function that will display them, we would use something like this: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#passing arguments to a function</p>
			<p class="source-code">function output {</p>
			<p class="source-code">     echo Parameters you passed are $1 and $2</p>
			<p class="source-code">}</p>
			<p class="source-code">output First Second</p>
			<p>What happens when we try to run this script is that our arguments get passed in a way that we expect, one after the other, and then our function outputs them: </p>
			<p class="source-code">demo@cli1:~/scripting$ bash functionarg.sh </p>
			<p class="source-code">Parameters you passed are First and Second</p>
			<p>You may <a id="_idIndexMarker895"/>wonder<a id="_idIndexMarker896"/> how our scripts are going to handle arguments that are given to the script, compared to arguments we pass to the function. The short answer is that variables named <strong class="source-inline">$1</strong> and so on have a value that is local to the function and is defined by arguments we passed to the function. Outside of the function code block, these variables have the value of the arguments passed to the script. The long version of the answer is going to be in the next recipe and is called local and global variables. Using arguments is nothing but a special case of declaring a local variable; arguments that we pass simply become a local variable in the function: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#passing arguments to a function</p>
			<p class="source-code">function output {</p>
			<p class="source-code">    echo Parameters you passed are $1 and $2</p>
			<p class="source-code">}</p>
			<p class="source-code">#we are going to take input arguments of the script itself and #reverse them</p>
			<p class="source-code">output $2 $1</p>
			<p>The reason we are changing the order of the arguments is to show the order in which arguments are passed to the function and to make sure that we are not using the arguments we passed to the script in the function since they have the same name. What this script will do is get two arguments from the command line, reverse them, and then give them in reversed order as arguments to our function. The function is simply going to output them:</p>
			<p class="source-code">demo@cli1:~/scripting$ bash functionarg2.sh First Second</p>
			<p class="source-code">Parameters you passed are Second and First</p>
			<p>What happened <a id="_idIndexMarker897"/>here<a id="_idIndexMarker898"/> is also what we expected. Now, we are going to check one more thing that can be confusing to some people. Is the function even aware that some arguments are passed to the script or are the arguments strictly local? In order to check that, we are going to ignore whatever was in the script command line, and we are going to pass a pair of hardcoded strings to the function. If <strong class="source-inline">bash</strong> is behaving like we think it is, our script will output the hardcoded values. If the variables named <strong class="source-inline">$1</strong> and <strong class="source-inline">$2</strong> are set to values from the command line and they persist in the function, we should see that value in our <strong class="source-inline">echo</strong> statement. What we are going to do is create a <strong class="source-inline">functionarg3.sh</strong> file containing the following code:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#passing arguments to a function</p>
			<p class="source-code">function output {</p>
			<p class="source-code">    echo Parameters you passed are $1 and $2</p>
			<p class="source-code">}</p>
			<p class="source-code">#we are going to ignore input parameters</p>
			<p class="source-code">output Hardcoded Variables</p>
			<p>Now, we are going to run it and check what happened: </p>
			<p class="source-code">demo@cli1:~/scripting$ bash functionarg3sh First Second</p>
			<p class="source-code">Parameters you passed are Hardcoded and Variables</p>
			<p>We can see that our assumption was correct and that the arguments given to the function always take precedence. </p>
			<p>The next thing that we are going to do is show you how to handle simple operations using functions. Operations that can be done on variables is something we covered elsewhere in this book, but here, we are going to use an example we haven't used yet. We are simply going to add two arguments from the command line together. </p>
			<p>In order to do that, we are passing arguments from the command line into our function and then using <strong class="source-inline">echo</strong> to output the result of the calculation. Part of the function used to get the result is also very interesting since it reminds us that we have to explicitly use a function to add two numbers in order to do that. If we try to add variables together, we are going to end <a id="_idIndexMarker899"/>up <a id="_idIndexMarker900"/>creating a string—something like this: </p>
			<p class="source-code">demo@cli1:~/scripting$ a=1</p>
			<p class="source-code">demo@cli1:~/scripting$ b=2</p>
			<p class="source-code">demo@cli1:~/scripting$ echo $a+$b</p>
			<p class="source-code">1+2</p>
			<p class="source-code">demo@cli1:~/scripting$ echo $(($a+$b))</p>
			<p class="source-code">3</p>
			<p>This is the final version incorporated into our script: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#Doing some maths</p>
			<p class="source-code">function simplemath {</p>
			<p class="source-code">add=$(($1+$2))</p>
			<p class="source-code">echo $add is the result of addition</p>
			<p class="source-code">}</p>
			<p class="source-code">#we are going to take input arguments and pass them all the way</p>
			<p class="source-code">simplemath $1 $2</p>
			<p>Note that in this example, we are using a new variable inside a function to add the numbers and then outputting the value of this variable as the result. This is a better way to do this than directly doing the operation in the output itself—code that uses these temporary variables is always easier to read and understand than trying to find and understand variables embedded into output strings. </p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor294"/>How it works…</h2>
			<p>The next thing we want to show is a nifty little feature that is not so common in most programming languages. Since <strong class="source-inline">bash</strong> treats arguments in the function the same way as it treats arguments to the script and uses the same logic to turn these arguments into variables inside the function, we can actually send multiple arguments to the function without defining <a id="_idIndexMarker901"/>their <a id="_idIndexMarker902"/>number in advance. Of course, our function needs to be able to understand something such as this. </p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor295"/>See also</h2>
			<ul>
				<li><a href="https://linuxize.com/post/bash-functions/">https://linuxize.com/post/bash-functions/</a></li>
				<li><a href="https://linuxhint.com/create-bash-functions-arguments/">https://linuxhint.com/create-bash-functions-arguments/</a></li>
			</ul>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor296"/>Local and global variables</h1>
			<p>When it <a id="_idIndexMarker903"/>comes to <a id="_idIndexMarker904"/>declaring any variable in a script—or for that matter, anywhere at all—one crucial attribute for that variable is its scope. By scope, we mean <em class="italic">where the variable has the value we declared</em>. Scope is very important since not understanding how it works means that we can get unexpected results in some cases. </p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor297"/>Getting ready</h2>
			<p>Defining a global scope to our variables is something <strong class="source-inline">bash</strong> does by default, without any interaction with us. All variables that are defined are global variables; their value is the same in the entire script. If we change the variable value by reassigning it (remember that operations on the value do not change the value itself), this value changes globally, and the old value is lost. </p>
			<p>There is another thing we can do when declaring variables, and that is to declare them locally. In simple terms, this means that we are explicitly telling <strong class="source-inline">bash</strong> that we will use this variable in some limited part of the code and that it needs to keep the value just there, not globally in the entire script. </p>
			<p>What are the reasons to declare a local variable? There are a couple of them, the most important one being to make sure that we don't change the value of any global variable. If a variable is declared locally with the same name as a global one, <strong class="source-inline">bash</strong> will create another instance of the variable with the same name and will keep track of both values, the global and the local one. </p>
			<p>Global <a id="_idIndexMarker905"/>and<a id="_idIndexMarker906"/> local variables and how they work are something that is best explained by using an example. </p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor298"/>How to do it…</h2>
			<p>The script that we are going to use to show you how this works is something that you will find in almost every example on the internet and in any book covering the subject. The idea is to create a global variable and then create a local variable in the function that is going to have the same name as the global one. The value that the global variable has should be different than the local value, and once we display that value, we should see that the value changes depending on if we are referencing a global or local variable: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># First we define global variable</p>
			<p class="source-code"># Value of this variable should be visible in the entire script</p>
			<p class="source-code">VAR1="Global variable"</p>
			<p class="source-code">Function func {</p>
			<p class="source-code"># Now we define local variable with the same name</p>
			<p class="source-code"># as the global one. </p>
			<p class="source-code">local VAR1="Local variable"</p>
			<p class="source-code">#we then output the value inside the function</p>
			<p class="source-code">echo Inside the function variable has the value of: $VAR1 \</p>
			<p class="source-code">}</p>
			<p class="source-code">echo In the main script before function is executed variable \</p>
			<p class="source-code">has the value of: $VAR1</p>
			<p class="source-code">echo Now calling the function</p>
			<p class="source-code">func</p>
			<p class="source-code"># Value of the global variable shouldn't change</p>
			<p class="source-code">echo returned from function</p>
			<p class="source-code">echo In the main script after function is executed value is: \</p>
			<p class="source-code">$VAR1</p>
			<p>If we execute<a id="_idIndexMarker907"/> this<a id="_idIndexMarker908"/> script, we are going to see exactly how variables interact: </p>
			<p class="source-code">demo@cli1:~/scripting$ bash funcglobal.sh</p>
			<p class="source-code">In the main script before function is executed variable has the value of: Global variable</p>
			<p class="source-code">Now calling the function</p>
			<p class="source-code">Inside the function variable has the value of: Local variable</p>
			<p class="source-code">returned from function</p>
			<p class="source-code">In the main script after function is executed value is: Global variable</p>
			<p>This is completely expected—if there are a global variable and a local variable with the same name, the local variable will have its own values in the block it is defined in; otherwise, a global value will be used. </p>
			<p>We said scripts such as this are common as an example, but what happens if we define just the local value? <strong class="source-inline">bash</strong> is different from most other languages since, by default, it will not show an error if we mistakenly try to reference a variable that is undefined. When debugging scripts, this can be a big problem since an undefined variable and a defined variable with no value will, at first, look exactly the same when we try to reference them. </p>
			<p>To show this, we are going to make a small modification to our script and just remove the first variable definition. This will make our global value undefined—only the local value will <a id="_idIndexMarker909"/>have an <a id="_idIndexMarker910"/>actual value: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># We are not defining the value for our variable in the global #block</p>
			<p class="source-code">function func {</p>
			<p class="source-code"># Now we define local variable that is not defined globally</p>
			<p class="source-code"># as the global one. </p>
			<p class="source-code">local VAR1="Local variable"</p>
			<p class="source-code">#we then output the value inside the function</p>
			<p class="source-code">echo Inside the function variable has the value of: $VAR1</p>
			<p class="source-code">}</p>
			<p class="source-code">echo In the main script before function is executed undefined \</p>
			<p class="source-code">variable has the value of: $VAR1</p>
			<p class="source-code">echo Now calling the function</p>
			<p class="source-code">func</p>
			<p class="source-code"># Value of the global variable shouldn't change</p>
			<p class="source-code">echo returned from function</p>
			<p class="source-code">echo In the main script after function is executed undefined \</p>
			<p class="source-code">value is actually: $VAR1 </p>
			<p>In any strict programming language, something such as this would create an error. In <strong class="source-inline">bash</strong>, things are different: </p>
			<p class="source-code">demo@cli1:~/scripting$ bash funcglobal1.sh </p>
			<p class="source-code">In the main script before function is executed undefined variable has the value of:</p>
			<p class="source-code">Now calling the function</p>
			<p class="source-code">Inside the function variable has the value of: Local variable</p>
			<p class="source-code">returned from function</p>
			<p class="source-code">In the main script after function is executed undefined value is actually:</p>
			<p>We can see that instead of errors, the script just ignores the variable value and replaces it with nothing. As we mentioned, even though we are expecting this behavior, keep in mind that this can lead to unexpected consequences. Another important thing in this script is the local value. We can see that the local variable <em class="italic">exists</em> only in the block of code in which it is defined; defining it will not create a global variable, and the value will be lost as soon as the <a id="_idIndexMarker911"/>function<a id="_idIndexMarker912"/> or block of code is executed. </p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor299"/>How it works…</h2>
			<p>Using global variables in scripts can be useful for one more thing—forwarding values between functions. This feature of variables is something that can be useful, but at the same time, it is something that is dependent on your personal style of programming. Using global variables this way is easy—what you do is just declare a variable at the start of the script and then change its value whenever you need to. Usually, you assign a value before executing a particular function and then read the same variable after the function is done. This way, your function only needs to change the variable to give you the value that you expect. </p>
			<p>However, there is a big problem in this otherwise perfectly logical way of using global variables. Since you have no way of knowing if the function behaved correctly and got to the point where it had to change the value of the variable, you do not have any idea if the value itself is what you are expecting. If a function fails for any reason, your variable will have the same value you sent to the function, leaving you with something that could be wrong. </p>
			<p>What we are trying to say is that using global variables in this way is to be avoided, even though you can do it—the right way to work with functions and passing values is by using arguments and<a id="_idIndexMarker913"/> returning <a id="_idIndexMarker914"/>values by a mechanism we will look at in the next recipe. </p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor300"/>See also</h2>
			<ul>
				<li><a href="https://www.thegeekstuff.com/2010/05/bash-variables/">https://www.thegeekstuff.com/2010/05/bash-variables/</a></li>
				<li><a href="https://tldp.org/LDP/abs/html/localvar.html">https://tldp.org/LDP/abs/html/localvar.html</a></li>
			</ul>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor301"/>Working with returns from a function</h1>
			<p>We mentioned<a id="_idIndexMarker915"/> that it is possible to use global variables to<a id="_idIndexMarker916"/> pass values to the functions inside a script and to get results back. This is the worst possible way to do it. If we need to pass some value to a function, using arguments is the way it should be done. The problem that we still have is how to get the results back when the function finishes. We are going to solve that in this recipe. </p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor302"/>Getting ready</h2>
			<p>If nothing else, <strong class="source-inline">bash</strong> is logical and consistent in the syntax it uses. The reason we are mentioning this is that when functions return a value, they use the exact same mechanism that scripts use when returning a variable—the <strong class="source-inline">return</strong> command. Using this command, it is possible for a function to return a value when called, but the value can be in the range of numbers between <strong class="source-inline">0</strong> and <strong class="source-inline">255</strong>. There is also a possibility to set a global variable just to return a function value—for example, if we need to return a string—but try to avoid that since it creates code that is difficult to debug. When you are browsing the internet for function <strong class="source-inline">return</strong> statements, you may also run into a third solution that uses something called <em class="italic">reference passing</em> or <strong class="source-inline">nameref</strong>. This is a more complex solution that you should be aware of, but we are deliberately avoiding it in this recipe since it works only on the most recent versions of <strong class="source-inline">bash</strong> (from <strong class="source-inline">4.3</strong> up), and that breaks the compatibility and usability of our scripts. </p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor303"/>How to do it…</h2>
			<p>We'll show you both ways to return a function, starting with the one we consider wrong. The reason that we are even showing you a wrong solution is that you will often run into this in different scripts downloaded from the internet, and if you are unaware of this method, you will probably be a little bit puzzled at first because the variable is usually first defined in the function itself and does not exist before the function is first called:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#Doing some string adding inside a function and returning #values</p>
			<p class="source-code">#function takes two strings and returns them concatenated </p>
			<p class="source-code">function concatenate {</p>
			<p class="source-code">RESULT=$1$2</p>
			<p class="source-code">}</p>
			<p class="source-code"># calling the function with hardcoded strings</p>
			<p class="source-code">concatenate "First " "and second"</p>
			<p class="source-code">echo $RESULT</p>
			<p>What we did is <a id="_idIndexMarker917"/>just<a id="_idIndexMarker918"/> pass two strings to a function that returned them concatenated. Of course, this is silly—we could do that by simply using the expression we used in the function. This example is so basic that it doesn't even use any operators. </p>
			<p>What's important is the way we returned our value. By just assigning a new value and therefore creating a global variable named <strong class="source-inline">RESULT</strong>, we got our string, and we were able to use <strong class="source-inline">echo</strong> to write it to the screen. Why is this a problem? </p>
			<p>We have already explained this. What we are doing here is dangerous since we have no way of knowing if the function has done what it had to do. The only thing we have is the variable called <strong class="source-inline">RESULT</strong> that probably contains the value we expect. In this trivial example, we could check the outcome, but that would defeat the purpose of having a dedicated function. In order to reduce the uncertainty a little bit, there is a small trick that we can do. </p>
			<p>Consider this change to the script: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#Doing some string adding inside a function and returning \</p>
			<p class="source-code">values</p>
			<p class="source-code">#function takes two strings and returns them concatenated </p>
			<p class="source-code">function concatenate {</p>
			<p class="source-code">RESULT=$1$2</p>
			<p class="source-code">}</p>
			<p class="source-code">concatenate "First " "and second"</p>
			<p class="source-code">[ $? -eq 0 ] &amp;&amp; echo $RESULT || echo Function did not finish!</p>
			<p>What we did is <a id="_idIndexMarker919"/>create<a id="_idIndexMarker920"/> a conditional output. The format of the condition itself should be familiar to you by now—we are using logical functions to either print out the result of the function or to print out that the function did not work correctly. As a reminder to when we introduced logical operators, what our script does in the last line is check for the value of a variable called <strong class="source-inline">$?</strong>. If the variable value equals <strong class="source-inline">0</strong>, we print out the result of the function. If the value is not zero, we output the error message since we know that our function had an error somewhere inside its command block.</p>
			<p>The reason we can do this is simple—we already said that functions have the same way of communicating to the script as the script itself does to the rest of the operating system. This includes passing arguments and being able to use a <strong class="source-inline">return</strong> statement to return values, but also it means that <strong class="source-inline">bash</strong> sets a variable named <strong class="source-inline">?</strong> when the function is finished. When we use it to understand what happened to the script (which we already explained), if we check this variable and it has a value of <strong class="source-inline">0</strong>, this means that the function finished correctly, or at least that the last command in it finished correctly. </p>
			<p>This is a simple solution to a problem that we shouldn't create in the first place; whenever possible, we should use <strong class="source-inline">return</strong> to get our values. Here's an example: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#simple adding of two numbers</p>
			<p class="source-code">#function takes two numbers and returns result of addition</p>
			<p class="source-code">function simpleadd {</p>
			<p class="source-code">    local RESULT=$(($1+$2))</p>
			<p class="source-code">    return $RESULT</p>
			<p class="source-code">}</p>
			<p class="source-code">#we are going to hardcode two numbers</p>
			<p class="source-code">simpleadd 4 5 </p>
			<p class="source-code">echo $?</p>
			<p>This is a much <a id="_idIndexMarker921"/>better <a id="_idIndexMarker922"/>way if we are sure that our numbers fit into the range from <strong class="source-inline">0</strong> to <strong class="source-inline">255</strong>. We are outputting the result of the function, and this is as easy as referencing the right variable. We could also check if the value of the variable after the execution of the function is <strong class="source-inline">0</strong>, meaning that the function behaved correctly, and then output the result. </p>
			<p>Another thing you should know is that a function can use the <strong class="source-inline">exit</strong> command. By using it, you are telling <strong class="source-inline">bash</strong> to immediately stop what the function is doing and exit the function command block. The value that is going to be returned in this instance is going to be the error level of the last command that was executed before the <strong class="source-inline">exit</strong> command was invoked. </p>
			<p>Here's an example: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#exiting from a function before function finishes</p>
			<p class="source-code">function never {</p>
			<p class="source-code">echo This function has two statements, one will never be \</p>
			<p class="source-code">printed. </p>
			<p class="source-code">exit</p>
			<p class="source-code">echo This is the message that will never print</p>
			<p class="source-code">}</p>
			<p class="source-code">#here we run the function</p>
			<p class="source-code">never</p>
			<p>What is going to get printed is just the first line of output; since we used the <strong class="source-inline">exit</strong> statement, the second part of the output will never run: </p>
			<p class="source-code">demo@cli1:~/scripting$ bash funcreturn3.sh </p>
			<p class="source-code">This function has two statements, one will never be printed.</p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor304"/>How it works…</h2>
			<p>The main reason why all of this even exists is to enable you to more tightly control how functions and, more generally, the order of command execution works in your script. <strong class="source-inline">bash</strong> is very basic<a id="_idIndexMarker923"/> in the way it approaches this topic, and that at<a id="_idIndexMarker924"/> the same time makes it versatile. In order to use functions, you only need to know how arguments work in scripting—all the variable names and logic behind it are the same when applied to functions. </p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor305"/>See also</h2>
			<ul>
				<li><a href="https://www.assertnotmagic.com/2020/06/19/bash-return-multiple/">https://www.assertnotmagic.com/2020/06/19/bash-return-multiple/</a></li>
				<li><a href="https://www.linuxjournal.com/content/return-values-bash-functions">https://www.linuxjournal.com/content/return-values-bash-functions</a></li>
			</ul>
			<h1 id="_idParaDest-299"><a id="_idTextAnchor306"/>Loading an external function to a shell script</h1>
			<p>A problem <a id="_idIndexMarker925"/>that<a id="_idIndexMarker926"/> will often pop up when you need to create more complex shell scripts is going to be how to include other code into your script. Once you start scripting, you will often create a couple of common functions that you always use—things such as opening connections to servers, getting some operations done, and other things like that. </p>
			<p>Sometimes, your scripts will have to use a lot of preset variables that are defined by the user before they even run the script in order to avoid having to type them in each time a script is called. </p>
			<p>Of course, the solution to both of these problems can be to simply copy and paste the relevant code into your script and to make the user edit the script before running it. The reason we should never do this is that each time we copy and paste something, we are creating a new version of our code. If we notice an error in the code, we need to fix it in all the scripts that reuse it. Luckily, there is a better way to solve this problem, and that is to split the script into different files and then include them when we need them. </p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor307"/>Getting ready</h2>
			<p>This recipe<a id="_idIndexMarker927"/> is<a id="_idIndexMarker928"/> going to be useful in two scenarios that are not necessarily mutually exclusive. We already mentioned both of them briefly. </p>
			<p>The first one is when using external functions. Normally, when creating a script, everything is going to be in one file. All the functions, definitions, variables, and commands are going to be in one place. This is usually completely fine if we are creating something that is specially written to accomplish a particular task. </p>
			<p>More often than not, we will need to solve something that we already worked on before in some other solution. In this case, we usually already have some functions ready that can be considered part of the solution. </p>
			<p>In complex scripting solutions, you might even use some common things such as menus, interfaces, headers, footers, logs, and other things that are exactly the same across every script that you make. </p>
			<p>Another very common problem is settings that require some setup by the user. Large scripts can have server names, ports, filenames, users, and many different things that are required for the script to function. You can always put this information as arguments into the command line, but that will look bad and will make your script prone to errors since the user will have to type a lot of things by hand each time scripts are executed. </p>
			<p>A common practice in these circumstances is to put everything in one file as variables, and then have the user edit this file as part of the installation process for the script. Of course, you can put everything together with the script itself, but that will almost certainly mean some user will change something they shouldn't have. </p>
			<p>As always, there is a solution for that. </p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor308"/>How to do it…</h2>
			<p><strong class="source-inline">bash</strong> has built-in functionality that enables including different files into a script. The idea is pretty simple—there is a <em class="italic">master script file</em> that gets executed as the script itself. In that file are commands that tell <strong class="source-inline">bash</strong> to include different files and scripts. </p>
			<p>As with everything else, even though this is a pretty easy thing to do, there are some things you need to know. The command we are going to use first is <strong class="source-inline">source</strong>. Before we explain everything, we are going to create two scripts. The first one is going to be the script that the user<a id="_idIndexMarker929"/> is<a id="_idIndexMarker930"/> going to run, and it is going to look like this. Name the file <strong class="source-inline">main.sh</strong>: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#first we are going to output some environment variables and #define a few of our own</p>
			<p class="source-code">echo Shell level before we include $SHLVL</p>
			<p class="source-code">echo PWD value before include $PWD</p>
			<p class="source-code">TESTVAR='main'</p>
			<p class="source-code">echo Shell level after include $SHLVL</p>
			<p class="source-code">echo PWD value after include $PWD</p>
			<p class="source-code">echo Variable value after include $TESTVAR</p>
			<p>We are going to run it just to see how the script behaves: </p>
			<p class="source-code">demo@cli1:~/includes$ bash main.sh </p>
			<p class="source-code">Shell level before include 2</p>
			<p class="source-code">PWD value before include /home/demo/includes</p>
			<p class="source-code">Shell level after include 2</p>
			<p class="source-code">PWD value after include /home/demo/includes</p>
			<p class="source-code">Variable value after include main</p>
			<p>The results are what we expected—our current directory is the same as the one we ran the script in, and <strong class="source-inline">$SHLVL</strong> is <strong class="source-inline">2</strong> since we ran our script in a separate shell (<strong class="source-inline">lvl2</strong>) from the command line (<strong class="source-inline">lvl1</strong>). Our variable is defined as <strong class="source-inline">main</strong> and it hasn't changed. </p>
			<p>Now, we are going to create our second script and name it <strong class="source-inline">auxscript.sh</strong>: </p>
			<p class="source-code">echo Inside included file Shell level is $SHLVL</p>
			<p class="source-code">echo Inside included PWD is $PWD</p>
			<p class="source-code">echo Before we changed it variable had a value of: $TESTVAR</p>
			<p class="source-code">TESTVAR='AUX'</p>
			<p class="source-code">echo After we changed it variable has a value of: $TESTVAR</p>
			<p>The biggest thing here is that we are not using the usual <strong class="source-inline">#!/bin/bash</strong> notation at the start of the script. This <a id="_idIndexMarker931"/>is intentional, as this file is meant to be <a id="_idIndexMarker932"/>included in other scripts, not run by itself. </p>
			<p>After that, we are doing more or less the same things as in the main script, outputting some text and values, and working with variables. </p>
			<p>The reason we are changing the variable is to show what actually happens inside this included part of the file and how it interacts with the main script body. </p>
			<p>Now, we are going to change the <strong class="source-inline">main.sh</strong> script and add just one line: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#first we are going to output some environment variables and #define a few of our own</p>
			<p class="source-code">echo Shell level before we include $SHLVL</p>
			<p class="source-code">echo PWD value before include $PWD</p>
			<p class="source-code">TESTVAR='main'</p>
			<p class="source-code">source auxscript.sh</p>
			<p class="source-code">echo Shell level after include $SHLVL</p>
			<p class="source-code">echo PWD value after include $PWD</p>
			<p class="source-code">echo Variable value after include $TESTVAR</p>
			<p>The main thing now is to run the <strong class="source-inline">main.sh</strong> script again: </p>
			<p class="source-code">demo@cli1:~/includes$ bash main.sh </p>
			<p class="source-code">Shell level before include 2</p>
			<p class="source-code">PWD value before include /home/demo/includes</p>
			<p class="source-code">Inside included file Shell level is 2</p>
			<p class="source-code">Inside included PWD is /home/demo/includes</p>
			<p class="source-code">Before we changed it variable had a value of: main</p>
			<p class="source-code">After we changed it variable has a value of: AUX</p>
			<p class="source-code">Shell level after include 2</p>
			<p class="source-code">PWD value after include /home/demo/includes</p>
			<p class="source-code">Variable value after include AUX</p>
			<p>Some<a id="_idIndexMarker933"/> interesting <a id="_idIndexMarker934"/>things happened here. What we can see is that our environment variables haven't changed but the test variable did. </p>
			<p>We are going to explain that, but we are going to do one more thing before that—we are going to use another command instead of <strong class="source-inline">source</strong>. A lot of people new to scripting tend to confuse the <strong class="source-inline">source</strong> command that we just showed you with executing a script. After all, we are including a script inside a script, so those things do look similar. We are going to try to do it in our example. </p>
			<p>We are going to change a single line inside the main script, but our <strong class="source-inline">aux</strong> script is going to stay the same. There are multiple ways in which we can do it, but we intentionally chose to run <strong class="source-inline">bash</strong> and run our second script explicitly. The reason is simple—other methods require our script to have the executive bit set (something we haven't done) or depend on less readable versions of the same thing as just running a command called <strong class="source-inline">exec</strong>: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#first we are going to output some environment variables and #define a few of our own</p>
			<p class="source-code">echo Shell level before include $SHLVL</p>
			<p class="source-code">echo PWD value before include $PWD</p>
			<p class="source-code">TESTVAR='main'</p>
			<p class="source-code">bash auxscript.sh</p>
			<p class="source-code">echo Shell level after include $SHLVL</p>
			<p class="source-code">echo PWD value after include $PWD</p>
			<p class="source-code">echo Variable value after include $TESTVAR</p>
			<p>The only thing we<a id="_idIndexMarker935"/> have<a id="_idIndexMarker936"/> changed is that we are not including the script—we are executing it: </p>
			<p class="source-code">demo@cli1:~/includes$ bash mainexec.sh </p>
			<p class="source-code">Shell level before include 2</p>
			<p class="source-code">PWD value before include /home/demo/includes</p>
			<p class="source-code">Inside included file Shell level is 3</p>
			<p class="source-code">Inside included PWD is /home/demo/includes</p>
			<p class="source-code">Before we changed it variable had a value of:</p>
			<p class="source-code">After we changed it variable has a value of: AUX</p>
			<p class="source-code">Shell level after include 2</p>
			<p class="source-code">PWD value after include /home/demo/includes</p>
			<p class="source-code">Variable value after include main</p>
			<p>We can see, however, that this small change created a huge difference in the way our script works. </p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor309"/>How it works…</h2>
			<p>The last example we did requires quite a lot of explaining, and we need to start with how <strong class="source-inline">bash</strong> works. </p>
			<p>Using the <strong class="source-inline">source</strong> command tells <strong class="source-inline">bash</strong> to go find a file and use its contents at the place where we sourced the file. What <strong class="source-inline">bash</strong> does is straightforward—it just replaces this line with the entire file we pointed to. All the lines are inserted and then executed as if we copy-pasted the entire file into our original script. </p>
			<p>This is the reason why in our first example nothing changed. Our script started running from the main file, continued running commands from the auxiliary file, and then returned to the main file to finish the commands that followed. </p>
			<p>When we changed our <strong class="source-inline">source</strong> for <strong class="source-inline">bash</strong>, we created a completely different scenario. By using the <strong class="source-inline">bash</strong> command inside the script, we are telling the shell to start another instance and execute the script we are referring to. This means that the entire environment is <a id="_idIndexMarker937"/>created, and unless we explicitly specify <a id="_idIndexMarker938"/>that we need some variables in the new environment, they are not going to get exported. </p>
			<p>This is also the reason that our <strong class="source-inline">$SHLVL</strong> variable incremented—since we called another shell inside, the shell level had to go up. </p>
			<p>Our test variable vanished because we didn't export it, so it had no value before being set, and since our environment was created just to run these couple of lines, the same variable simply disappeared when the script we called ended. </p>
			<p>Remember that executing a script and sourcing it are completely different things, and when in doubt, think about what you are trying to do. If you want to execute something inside a script such as a regular command, use <strong class="source-inline">bash</strong> or <strong class="source-inline">exec</strong>. If you would otherwise copy-paste code from another script, use <strong class="source-inline">source</strong>. </p>
			<p>Before we finish with this recipe, we also need to mention functions. Including functions is exactly the same as including any other part of any other script, with one important difference. In order for your code to work, you <em class="italic">must</em> include functions at the start of the script or immediately before you try to use said functions. If you don't do that, the resulting error is going<a id="_idIndexMarker939"/> to be the same as if you hadn't defined <a id="_idIndexMarker940"/>your function at all. </p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor310"/>See also</h2>
			<ul>
				<li><a href="https://bash.cyberciti.biz/guide/Source_command">https://bash.cyberciti.biz/guide/Source_command</a></li>
				<li><a href="https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_01.html">https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_01.html</a></li>
			</ul>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor311"/>Implementing commonly used procedures via functions</h1>
			<p>By this point, we<a id="_idIndexMarker941"/> have created a lot of different and <a id="_idIndexMarker942"/>very simple scripts that more or less used <strong class="source-inline">echo</strong> and a few commands just to show how a particular thing in <strong class="source-inline">bash</strong> works. In this recipe, we are going to give you a couple of ideas on how to use what we have learned so far. </p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor312"/>Getting ready</h2>
			<p>We are going to create a small script that is going to show you how to easily automate the most mundane tasks on any system. The idea here is not to show you every task possible, but instead to show you how to tackle the most common problems. </p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor313"/>How to do it…</h2>
			<p>Before we even start with the script, we need to go back to the recipes where we were explaining how to start writing scripts. What we are talking about are the prerequisites and presumptions we are going to make when we create and run this script. </p>
			<p>Every script will have its own prerequisites. These are usually a list of things that your script needs to run—either it requires different packages or it needs some other condition that has to be met in order for the script to work, such as a working database or a working web server. </p>
			<p>For this one, we are presuming that you have installed a package called <strong class="source-inline">curl</strong> and that you are connected to the internet. </p>
			<p>Now, for the presumptions that we are depending on, this script has some commands that affect users and groups on the system. This means that in order for that part of the script to work, we absolutely need the script to be run either by the <strong class="source-inline">root</strong> user or another user who has administrative privileges. </p>
			<p>The script also presumes a lot about users and checks only if we have enough parameters, not the quality of arguments that were provided. This means that a user can give the script a number instead of a string, and the script will happily use this as a valid parameter. We will explain how to deal with that when we start dissecting the script. </p>
			<p>As a person responsible for writing scripts, part of your job is to be aware of these preconditions and to make sure to address them. There are two ways you can do that—the first is by stating what your script expects in some form of document that will follow your script. </p>
			<p>The other thing <a id="_idIndexMarker943"/>you<a id="_idIndexMarker944"/> can do (and we highly recommend this) is to check for every possible condition that you can think of, and if something is wrong, either print an error message and stop your script or, if you know what the problem is, try to rectify it. </p>
			<p>Examples of things you can solve inside the script are administrator privileges—your script can test if it can run, and ask the user to elevate privileges if the permissions are too low. You can also test if a particular package is present on the system if you see that some command that is not standard fails. </p>
			<p>In the end, how you solve problems in your script is going to be up to you and your skill level, but before you do anything, remember that when it comes to scripting, you need to test everything. </p>
			<p>Now, here's the actual script: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#shell script that automates common tasks</p>
			<p class="source-code">function rsyn {</p>
			<p class="source-code">rsync -avzh $1 $2 </p>
			<p class="source-code">}</p>
			<p class="source-code">function usage {</p>
			<p class="source-code">echo In order to use this script you can:</p>
			<p class="source-code">echo "$0 copy &lt;source&gt; &lt;destination&gt; to copy files from source \</p>
			<p class="source-code">to destination"</p>
			<p class="source-code">echo "$0 newuser &lt;name&gt; to createuser with the username \</p>
			<p class="source-code">&lt;username&gt;"</p>
			<p class="source-code">echo "$0 group &lt;username&gt; &lt;group&gt; to add user to a group"</p>
			<p class="source-code">echo "$0 weather to check local weather"</p>
			<p class="source-code">echo "$0 weather &lt;city&gt; to check weather in some city on earth"</p>
			<p class="source-code">echo "$0 help for this help"</p>
			<p class="source-code">}</p>
			<p class="source-code">if [ "$1" != "" ] </p>
			<p class="source-code">            Then</p>
			<p class="source-code">    case $1 in</p>
			<p class="source-code">         help)</p>
			<p class="source-code">            Usage</p>
			<p class="source-code">            Exit</p>
			<p class="source-code">            ;;</p>
			<p class="source-code">        copy)</p>
			<p class="source-code">                 if [ "$2" != "" &amp;&amp; "$3" != "" ]</p>
			<p class="source-code">                 then </p>
			<p class="source-code">            rsyn $2 $3</p>
			<p class="source-code">          fi</p>
			<p class="source-code">            ;;</p>
			<p class="source-code">    </p>
			<p class="source-code">              group)</p>
			<p class="source-code">            if [ "$2" != "" &amp;&amp; "$3" != "" ]</p>
			<p class="source-code">                  then </p>
			<p class="source-code">                       usermod -a -G $3 $2</p>
			<p class="source-code">            fi</p>
			<p class="source-code">                                        ;;</p>
			<p class="source-code">              newuser) </p>
			<p class="source-code">                  if [ "$2" != "" ]</p>
			<p class="source-code">                  then</p>
			<p class="source-code">                               useradd $2</p>
			<p class="source-code">                          fi</p>
			<p class="source-code">                          ;;</p>
			<p class="source-code">               weather)</p>
			<p class="source-code">                  if [ "$2" != "" ]</p>
			<p class="source-code">                          then </p>
			<p class="source-code">                                curl wttr.in/$2</p>
			<p class="source-code">                          else </p>
			<p class="source-code">                                curl wttr.in</p>
			<p class="source-code">                  fi</p>
			<p class="source-code">                  ;;</p>
			<p class="source-code">               *)</p>
			<p class="source-code">            echo "ERROR: unknown parameter $1\""</p>
			<p class="source-code">            usage</p>
			<p class="source-code">            exit 1</p>
			<p class="source-code">            ;;</p>
			<p class="source-code">    esac</p>
			<p class="source-code">                 else</p>
			<p class="source-code">            Usage</p>
			<p class="source-code">fi</p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor314"/>How it works…</h2>
			<p>This script<a id="_idIndexMarker945"/> requires <a id="_idIndexMarker946"/>some explaining, and we intentionally did not comment on any of it for two reasons. One was that comments would make the script so long it would require too many print pages, and the other one was to be able to go through it block by block in this explanation without breaking your flow with short comments. Having said that, always comment on your scripts!</p>
			<p>So, our script starts with a function. Considering this function has only one line, you may be surprised that we decided to break it into function, but we had a point to make. </p>
			<p>Some commands, such as <strong class="source-inline">rsync</strong> or <strong class="source-inline">tar</strong>, for example, have a complicated list of switches that are often used. When creating a script, it is sometimes easier to put some of those commands into a function to be able to call the function without having to remember all the switches every time. This also goes for commands that need a lot of parameters that are predetermined when the script is configured. Put all of them into a function and then call the function with only the bare minimum of arguments. </p>
			<p>Another thing we put into a function is <em class="italic">usage</em>, a block of text that helps the user to run the script, giving them enough information so they don't need any other type of help. </p>
			<p>If you can, please write more verbose help pages for your script. You can even create a <strong class="bold">manual</strong> (<strong class="bold">man</strong>) or info<a id="_idIndexMarker947"/> page, but at the same time, always provide help directly inside your script. Make your script display help when there is anything wrong with the command line. There is nothing more annoying than when a script just fails without any meaningful message, or when a script simply states <strong class="source-inline">read the help page for more information</strong>. </p>
			<p>In this function, we are using the <strong class="source-inline">$0</strong> positional argument in order to output the name of the script. Use this way of giving the user help when you are giving examples on script usage. Avoid hardcoding the script name because you don't know if the user changed the filename of the script, and hardcoded names can then completely puzzle them. </p>
			<p>Also, if you are <a id="_idIndexMarker948"/>using <a id="_idIndexMarker949"/>any special character in your text, use quotation marks; otherwise, you may run into errors or, worse, completely unexplainable errors. </p>
			<p>The next part of our script deals with each individual command. When creating a command-line utility such as this, decide in advance whether you are going to create a tool that will use <em class="italic">commands</em> such as this one, <em class="italic">switches</em> such as -<strong class="source-inline">h</strong> or <strong class="source-inline">—something</strong>, or some sort of simple textual interface. There are pros and cons for all of these, but in essence, the format that we chose is mostly used for scripts that can do multiple tasks one at a time. Switches enable you to introduce many parameters to a task, and <strong class="bold">user interfaces</strong> (<strong class="bold">UIs</strong>) are<a id="_idIndexMarker950"/> targeted toward inexperienced users. Also, remember that your script may be used from inside other scripts, so avoid interfaces that will block that. </p>
			<p>In the <strong class="source-inline">case</strong> statement, we are checking for a couple of things. First, we are testing if the first argument is a valid command. After that, we are checking if there are enough arguments for a given command to make sure that we can run it without errors. Even with this, we are not doing nearly enough testing for the validity of arguments. When reading this, try to add a few more sanity checks such as <em class="italic">are the parameters actually valid</em>, <em class="italic">did the user input a valid parameter containing spaces that got divided into multiple strings</em>, and so on. </p>
			<p>We are not going into too much detail for individual commands; we are only going to mention the one that, in all fairness, looks completely out of place. We are, of course, talking about the <strong class="source-inline">weather</strong> command that gives you a weather report for your city:</p>
			<div>
				<div id="_idContainer238" class="IMG---Figure">
					<img src="Images/Figure_12.1_B16269.jpg" alt="Figure 12.1 – wttr.in is one of many interesting services available online&#13;&#10;" width="1662" height="1125"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1 – wttr.in is one of many interesting services available online</p>
			<p>Internet is full of <a id="_idIndexMarker951"/>useful <a id="_idIndexMarker952"/>services, and <a href="http://wttr.in">wttr.in</a> is definitely one of those. If you go to <a href="http://wttr.in">wttr.in</a> or run <strong class="source-inline">curl wttr.in</strong>, you are going to get a weather report for the city that the system thinks you are living in. There is some deep magic involved here—the<a id="_idIndexMarker953"/> system is going to try to guess where you are based on your <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) address, and even while having to do that, it is going to give you a pretty accurate forecast almost immediately. </p>
			<p>We chose to show you this example on purpose—if you add a city name to the <a href="http://wttr.in">wttr.in</a> link, the system is going to show you the weather in that city, while even trying to guess the exact city name. There are a couple of really useful online services such as this accessible from the command line, and using some of them means you can extend your script in the most unusual ways. </p>
			<p>At the end of the recipe, note that we are checking for different errors in how the script is invoked in <a id="_idIndexMarker954"/>three<a id="_idIndexMarker955"/> different ways. Always try to anticipate errors such as this. </p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor315"/>See also</h2>
			<p>The following web page is a must-see if you do anything in the command line: </p>
			<ul>
				<li><a href="https://stackify.com/top-command-line-tools/">https://stackify.com/top-command-line-tools/</a></li>
			</ul>
		</div>
	</div></body></html>