- en: Streamlining Infrastructure Management with AWX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have discussed so far in this book, effective enterprise automation on
    Linux involves several key elements, including standardization of both tools and
    technologies, and implementing processes and tools that make the management of
    the environment more efficient. Ansible is a great first step in this journey
    and can be supplemented with a complementary technology called AWX to further
    streamline its application.
  prefs: []
  type: TYPE_NORMAL
- en: 'AWX is, in short, a GUI-driven tool for the management of Ansible jobs. It
    does not replace Ansible functionality, but rather adds to it by providing a multi-user
    GUI-driven frontend that allows for the simple management and orchestration of
    playbooks. When managing large Linux environments such as those in an enterprise,
    AWX is the perfect complement to Ansible automation and is an important step in
    effective and efficient management. In this chapter, we will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to AWX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing AWX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your playbooks from AWX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating routine tasks with AWX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter includes examples based on the following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu Server 18.04 LTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CentOS 7.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To run through these examples, you will need access to a server or virtual machine
    running one of the aforementioned operating systems and Ansible. Note that the
    examples given in this chapter may be destructive in nature (for example, they
    involve installing Docker and running services on the server) and, if run as is,
    are only intended to be run in an isolated test environment.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are satisfied that you have a safe environment to operate in, let's
    get started by looking at the installation of new software packages with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: All example code discussed in this book is available from GitHub at: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to AWX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWX sets out to solve the problems associated with Ansible automation in an
    enterprise environment. To maintain our hands-on focus, let's consider the organic
    growth scenario we discussed in [Chapter 1](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml),
    *Building a Standard Operating Environment on Linux*. In a small environment where
    Ansible has been implemented, you might have just one or two key people responsible
    for writing and running playbooks against the environment. In this small scenario,
    it is reasonably easy to know who has run which playbooks and what the latest
    versions are, and the training requirements for Ansible are low as only a small
    number of key people are responsible for its use.
  prefs: []
  type: TYPE_NORMAL
- en: As the environment scales to enterprise sizing, so do the number of Ansible
    operators. If all of those responsible for running Ansible have it installed on
    their own machines, and all have local copies of the playbooks, suddenly the management
    of that environment becomes a nightmare! How can you ensure that everyone is using
    the latest versions of the playbooks? How do you know who ran what and what the
    outcome was? What if a change needs to be run out of hours? Can you pass the Ansible
    job off to a **Network Operations Center **(**NOC**) team, or is that not possible
    because they would need training on how to use Ansible?
  prefs: []
  type: TYPE_NORMAL
- en: AWX sets out to address all of these challenges, as we shall see subsequently,
    starting in the next section, where we look at how AWX can reduce your staff training
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: AWX reduces training requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible is very easy to get up and running. It still needs a little training,
    though. For example, IT admins and operators who haven''t received training may
    not be comfortable with running a playbook on the command line. This is demonstrated
    in the following example. Although fairly simple in Ansible terms, anyone unfamiliar
    with the tool will find that it isn''t very user-friendly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although it isn't a complex command, those unfamiliar with it might be reluctant
    to run it for fear of causing damage to production systems, let alone interpret
    the pages of output that a sizeable playbook can produce.
  prefs: []
  type: TYPE_NORMAL
- en: To alleviate this, AWX provides a web GUI-based interface that is quite literally
    point and click. Although many advanced features can be used by those familiar
    with it, a playbook can be run with literally a few clicks of the mouse, and the
    results are shown using a simple *traffic light* system (red indicating that the
    playbook run failed, while green shows that it passed). In this way, AWX provides
    an interface from which even those with no prior Ansible experience can launch
    a playbook and pass the results on to another team for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: AWX offers benefits for security teams and managers too, by logging detailed
    results of all actions and jobs performed, and we shall provide an overview of
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: AWX enables auditability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the Ansible command-line tools provide logging options, these are not
    enabled by default and as a result, the run output of playbooks can be lost as
    soon as a terminal session is closed. This is not great in an enterprise scenario,
    particularly when an issue or outage occurs and a root cause analysis is required.
  prefs: []
  type: TYPE_NORMAL
- en: AWX addresses this in two ways. First of all, every user must log in to the
    GUI before any actions can be performed. AWX can integrate with centralized accounting
    systems such as LDAP or Active Directory, or users can be defined locally on the
    AWX host. All actions in the UI are then tracked, and as such, it is possible
    to trace back playbook runs to specific users and indeed configuration changes.
    In an enterprise environment, this level of accountability and this kind of audit
    trail is a *must-have*.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond this, AWX captures all of the output of every playbook run, along with
    key pieces of information such as which inventory the playbook was run against,
    what variables were passed to it (if any), and the date and time of the run. This
    means that if an issue occurs, AWX can provide a complete audit trail to help
    you find out what happened and when.
  prefs: []
  type: TYPE_NORMAL
- en: Not only can AWX assist with auditing your automation, but it can also help
    with ensuring version control of your playbooks, as we shall discuss in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: AWX supports version control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an enterprise scenario, individuals storing playbooks locally could be a
    problem waiting to happen. For example, if user A updates a playbook with a critical
    fix, how do you ensure that user B has access to that code? Ideally, the code
    should be stored in a version control system (for example, GitHub) and the local
    copy updated for every single run.
  prefs: []
  type: TYPE_NORMAL
- en: Good processes are an important component of enterprise automation of Linux
    and while user B should update their local playbooks before running them, you
    cannot enforce this. Again, AWX addresses this issue by allowing playbooks to
    be sourced from a version control repository, with the local copy of the playbooks
    on the AWX server being updated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Although AWX can help you, especially when it comes to ensuring the latest version
    of code has been pulled from the repository, it cannot help with other errant
    behaviors such as someone not committing their code in the first place. The intention,
    however, of enforcing the use of AWX for Ansible playbook runs is that anyone
    who makes changes must commit them for AWX to run them. Local access to the AWX
    server should be tightly restricted to prevent people from making code changes
    on the local filesystem, and in this way, you can have confidence that everyone
    is actively and effectively using your version control system.
  prefs: []
  type: TYPE_NORMAL
- en: These updates can be event-driven so that, for example, local playbooks can
    be updated every single time a playbook from that store is run. They can also
    be updated on a scheduled basis or manually, as per the decisions of the AWX administrators.
  prefs: []
  type: TYPE_NORMAL
- en: AWX can help with the security of your automation too. We shall explore this
    in the next section by looking at credential management in AWX.
  prefs: []
  type: TYPE_NORMAL
- en: AWX helps with credential management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For Ansible to effectively manage an Enterprise Linux environment, it must have
    some form of credentials to access all of the servers it is managing. SSH authentication
    is normally secured with either SSH keys or passwords, and in a large team of
    Ansible operators, this can mean everyone has access to those passwords and SSH
    private keys since they are required for Ansible to be run. Needless to say, this
    presents a security risk!
  prefs: []
  type: TYPE_NORMAL
- en: As stated previously, from a security standpoint, this is less than desirable
    as it would be too easy for someone to copy and paste credentials and use them
    in a manner for which they were not intended. AWX also handles this by storing
    required credentials in its database, encrypted with a passphrase chosen at installation
    time. The GUI stores all the credentials using reversible encryption so that they
    can be passed to Ansible when playbooks are run later on. However, the GUI does
    not let you see any previously entered sensitive data (such as passwords or SSH
    private keys)—that is to say that they can be entered and changed, but you cannot
    show a password or SSH key in the GUI, and hence operators can't easily make use
    of the AWX frontend to obtain credential information for use elsewhere. In this
    way, AWX helps enterprises keep their credentials under lock and key and ensures
    that they are only used for Ansible deployments and are not leaked or used for
    any other unintended purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Vault is an excellent tool for encrypting any sensitive data that a
    playbook needs to operate on, be that for playbook data in the form of variables
    or storing server credentials themselves, such as an SSH private key. Although
    Vault is highly secure, it is easy to see the vault contents if you have the vault
    password (here, you would need to run a playbook that uses the Vault). As a result,
    AWX provides unique functionality to supplement Ansible and ensure security in
    an enterprise environment.
  prefs: []
  type: TYPE_NORMAL
- en: In these ways, AWX helps to address many of the challenges that enterprises
    face when deploying Ansible in a large-scale environment. Before we complete this
    section of this chapter, we will touch very briefly on how AWX can help you to
    integrate with other services.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating AWX with other services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a myriad of tools that AWX can integrate with—for example, both Red
    Hat's Satellite 6 and CloudForms products (and their open source Katello and ManageIQ
    counterparts) provide native integration with both AWX and Ansible Tower. These
    are just two examples, and this is all possible because everything that we will
    explore as we progress through this chapter is also accessible through an API
    and a command-line interface.
  prefs: []
  type: TYPE_NORMAL
- en: This enables AWX to be integrated with a wide variety of services, or you could
    even write your own that would run a playbook from AWX as a result of some other
    action, just by calling the API. The command-line interface (called `tower-cli`,
    after the commercial Ansible Tower product) is also incredibly useful, especially
    when it comes to programmatically populating data in AWX. For example, if you
    wanted to add a host to a static inventory, you could do this through the web
    user interface (as we shall demonstrate later), the API, or using the CLI. The
    latter two methods lend themselves incredibly well to integration with other services—for
    example, a **Configuration Management Database** (**CMDB**) could push new hosts
    into an inventory using the API, without the need for any manual action by the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore these two integration points further, you can refer to the following
    official documentation sources:'
  prefs: []
  type: TYPE_NORMAL
- en: The AWX API is documented here: [https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html](https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tower-cli` command is documented here: [https://tower-cli.readthedocs.io/en/latest/](https://tower-cli.readthedocs.io/en/latest/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the wide and varied nature of such integrations, they are beyond the scope
    of this book—however, it is important to mention them here because it is hoped
    that, as you read this chapter, you will see opportunities for integration with
    other services and hence be able to explore this topic further. In the next section
    of this chapter, we shall get hands-on with AWX and look at a simple deployment.
    Later in this chapter, this will be followed up with some example use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Installing AWX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing AWX is a straightforward affair once you put the right prerequisites
    in place. In fact, one of the prerequisites for AWX is Ansible, proving the complementary
    nature of this technology. Most of the AWX code runs in a set of Docker containers,
    which makes it straightforward to deploy in most Linux environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of Docker containers means that it is possible to run AWX in OpenShift
    or other Kubernetes environments—however, for the sake of simplicity here, we
    will get started by installing it on a single Docker host. Before you proceed
    any further, you should ensure that your chosen host has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker, fully installed and working
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `docker-py` module for your version of Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to Docker Hub (internet access)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.4 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git 1.8.4 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These prerequisites are normally readily available for most Linux systems.
    Now, we will perform the following steps to begin our installation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing our example of the Ubuntu system we used in the previous chapter,
    we will run the following command to install the AWX requirements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once these have been installed, the next task is to clone the AWX code from
    its repository on GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Git tool will faithfully clone the latest and greatest version of the AWX
    source code—note that this project is under active development and there is a
    possibility that the latest release might have bugs in it.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to clone one of the stable AWX releases, browse the Releases section
    of the repository and check out the desired version: [https:/​/​github.​com/ansible/​awx/​releases](https://github.com/ansible/awx/releases).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have cloned the repository, and it is now time for us to define the configuration
    for our installation of AWX, especially security details such as a password. To
    get started on this, change into the `installer` directory under the cloned repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, the contents of this directory will look familiar to you after reading
    the previous chapter. There is an `inventory` file, a playbook for us to run called `install.yml`, and
    a `roles/` directory. However, don't go and run the `install.yml` playbook just
    yet as there are some variables in the inventory file that we must set before
    we proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look through the inventory file, you will see there is a great
    deal of configuration that can occur inside it. Some variables are commented out,
    while others are set to default values. There is a minimum of six variables that
    I recommend that you set before installing AWX, and these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variables name** | **Recommended value** |'
  prefs: []
  type: TYPE_TB
- en: '| `admin_password` |'
  prefs: []
  type: TYPE_TB
- en: This is the default password for the admin user—you will need this the first
    time you log in, so be sure to set it to something memorable and secure!
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `pg_password` |'
  prefs: []
  type: TYPE_TB
- en: This is the password for the backend PostgreSQL database—be sure to set it to
    something unique and secure.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `postgres_data_dir` |'
  prefs: []
  type: TYPE_TB
- en: This is the directory on the local filesystem where the PostgreSQL container
    will store its data—it defaults to a directory under `/tmp`, which, on most systems,
    will be automatically cleaned up regularly. This often destroys the PostgreSQL
    database, so set it to something AWX-specific (for example, `/var/lib/awx/pgdocker`).
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `project_data_dir` |'
  prefs: []
  type: TYPE_TB
- en: For uploading playbooks manually to AWX without the need for a version control
    system, the playbooks must sit somewhere on the filesystem. To prevent having
    to copy them into a container, this variable maps the local folder specified to
    the required one inside a container. For the examples in this book, we will use
    the default (the `/var/lib/awx/projects` folder).
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `rabbitmq_password` |'
  prefs: []
  type: TYPE_TB
- en: This is the password for the backend RabbitMQ service—be sure to set it to something
    unique and secure.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `secret_key` |'
  prefs: []
  type: TYPE_TB
- en: This is the secret key used to encrypt credentials in the PostgreSQL database.
    It must be the same between upgrades of AWX, so be sure to store it somewhere
    secure as it will need to be set in future AWX inventories. Make this something
    long and secure.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: You will observe that in this inventory file there is a great deal of secret
    information that is in plaintext. While we can tolerate this for the duration
    of the installation process, this file should not be left lying around on the
    filesystem when the installation is complete as it could give a potential attacker
    all of the details they need to easily compromise your systems. Once the installation
    phase is complete, be sure to either copy this file into a password manager of
    some kind or simply store the individual passwords—either way, do not leave the
    file unencrypted!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the inventory is customized, it is time to run the installation itself—this
    is launched by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'From our work on Ansible in the previous chapter, you will recognize this command—it
    is using the `ansible-playbook` command to run the `install.yml` playbook, while
    also using the inventory file called `inventory` that we edited in *step 1*. Pages
    of output will pass by in the Terminal, and if the installation is successful,
    you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dee5a8b0-d9cf-4bee-9b6f-9548214848c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the installation completes, it takes a few minutes for the Docker containers
    to actually start up and for the backend database to be created. However, once
    this is done, you should be able to navigate to the IP address of your chosen
    AWX host in your browser and see the login page, an example of which is shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7caaf347-b763-4d94-bc54-66c73f41c063.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Log in as the admin user using the password you set in the `admin_password`
    variable in the inventory file earlier. You should then be taken to the dashboard
    page of AWX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e060d907-ecc2-4090-9e63-c63983ad2840.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it—you have successfully installed and logged in to AWX! Of course, there
    are many more advanced installation parameters you can define, and equally, in
    an enterprise, you would not rely on just a single AWX host with no backup (or
    high availability).
  prefs: []
  type: TYPE_NORMAL
- en: Note that when you log in to AWX, the connection is not SSL-secured, which could
    result in sensitive data such as machine credentials being transmitted over your
    network in the clear.
  prefs: []
  type: TYPE_NORMAL
- en: There is no one solution to out-of-the-box high availability and SSL issues
    that will suit every enterprise, and so we leave the actual solution for this
    as an exercise for you. For example, if you have an OpenShift environment with
    multiple hosts, then installing AWX in this environment will enable it to keep
    running, even if the host it runs on fails. There are of course ways to achieve
    high availability without OpenShift too.
  prefs: []
  type: TYPE_NORMAL
- en: Applying secure HTTP to AWX is also going to be solved in a different manner
    in different environments. Most Docker environments will have some kind of load
    balancer in front of them to help to handle their multi-host nature, and as a
    result, the SSL encryption could be offloaded onto this. It is also possible to
    secure a single Docker host, such as the one we have built here, but installing
    something capable of reverse proxying (for example, nginx) and configuring that
    to handle the SSL encryption.
  prefs: []
  type: TYPE_NORMAL
- en: In short, there is no one-size-fits-all solution to this, but it is recommended
    that you address these in the manner best suited to your enterprise. For this
    reason, we will not discuss them further here, other than to recommend that you
    take them into account when deploying AWX for production use.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an AWX instance running, we must configure it so that we can
    successfully replicate how we ran playbooks from the command line in the previous
    chapter. For example, we must define an inventory just as we did previously and
    ensure we have set up SSH authentication so that Ansible can perform the automated
    tasks on the remote computer. In the next part of this chapter, we will walk through
    all of the setup that's required to run your first playbook through AWX.
  prefs: []
  type: TYPE_NORMAL
- en: Running your playbooks from AWX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we ran an example playbook from the command line, we created our inventory
    file and then our playbook and then ran it using the `ansible-playbook` command.
    All of this, of course, assumed that we had already set up connectivity to the
    remote system by way of either specifying a password interactively or through
    the setup of SSH keys.
  prefs: []
  type: TYPE_NORMAL
- en: Although the end result in AWX is very similar—playbooks are run against an
    inventory—the terminology and naming are rather different. In this part of this
    chapter, we will walk through the process of getting your first playbook up and
    running from AWX. Although we don't have space in this book to give a complete
    rundown on every feature AWX has to offer, this section intends to give you sufficient
    knowledge and confidence to start managing your playbooks from AWX, and to explore
    further on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can run your first playbook from AWX, there are several prerequisite
    setup stages that must be completed. In the next section, we will complete the
    first of these—creating the credentials that will be used to authenticate over
    SSH with our target machine.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up credentials in AWX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you log in to AWX, you will notice a menu bar down the left-hand side
    of the screen. To define a new set of credentials that we will use to allow Ansible
    to log into our target machine, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on Credentials in the left-hand menu bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the green + icon to create a new credential.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the credential a name and select Machine from the CREDENTIAL TYPE field.
    There are many types of credentials that enable AWX to interact with a wide variety
    of services, but for now, we are only interested in this particular type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are many other fields available for specifying parameters for more advanced
    use cases—however, for our demonstration purposes, this is sufficient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your end result should look something like the following screenshot. Note that
    I have specified the login password for my demo machine, but you could equally
    have specified the SSH private key in the larger text box on the screen. You will
    also observe the presence of the Prompt on launch checkbox—there are many options
    in AWX that it can prompt the user for at the time a playbook is run, which can
    lend itself to a really rich interactive user experience. However, in this demo,
    we won''t do this as we want to demonstrate playbooks running without user intervention:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ff1346b-bb6c-46e1-9298-1f9ac3d128ce.png)'
  prefs: []
  type: TYPE_IMG
- en: When you have a credential defined, the next step is to define the inventory
    to run our playbook against. We'll explore this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating inventories in AWX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like on the command line, AWX requires an inventory to be created for playbooks
    to be executed against. Here, we are going to make use of one of the official,
    publicly available Ansible example playbooks, which requires an inventory with
    two groups in it. In a larger setup, we would specify a different server for each
    group, but for this small demo, we can reuse the same server for both roles.
  prefs: []
  type: TYPE_NORMAL
- en: The code in question is used to install a simple LAMP stack on an RHEL or CentOS
    7 machine and is available to view here: [https://github.com/ansible/ansible-examples/tree/master/lamp_simple_rhel7](https://github.com/ansible/ansible-examples/tree/master/lamp_simple_rhel7).
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this demo, you will need a CentOS 7 machine. My demo host is called `centos-testhost`,
    and if I were defining an inventory file on the command line, it would look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To replicate this in the AWX GUI, run through the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on Inventories on the left-hand menu bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the green + icon to create a new inventory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Inventory from the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the inventory a suitable name and click SAVE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your screen should look something like the one shown here once you have completed
    this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bed15396-0309-4519-a742-e4bb04628a76.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When complete, we can create our first group and put our test host into it.
    To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the GROUPS button at the top of the pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the green + icon to create a new group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name `webservers` into the NAME field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the green SAVE button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the HOSTS button at the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the green + icon button to add a new host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select New Host from the drop-down list.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name `centos-testhost` into the HOST NAME field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the green SAVE button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have completed these steps, your screen should look something like
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e74477c-6284-4e84-ad09-055599012176.png)'
  prefs: []
  type: TYPE_IMG
- en: Repeat this process to define the `dbservers` group. Take care not to create
    this group as a subgroup of the `webservers` group, which is easy to do. You will
    note the breadcrumb trail at the top of the preceding screenshot—use that to navigate
    back to the top level of our new inventory by clicking on `Hands on Inventory` (or
    your name, if you chose a different one).
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, the process is almost identical, except that when you come to adding
    the host to the newly created group (*step 6* onward from the preceding steps),
    choose Existing Hostas we are reusing our single host for both groups in this
    example. Your resulting screen should look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca729358-47ce-4211-b682-4546efb81a52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With those steps complete, our inventory complete with groupings is complete
    in AWX, and we can move on to the next stage in defining our configuration—the
    creation of an AWX project. We will do exactly this in the next section of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project in AWX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you were working with Ansible on the command line, it is unlikely you would
    store all of your playbooks and roles in one directory for very long as it would
    get unmanageable and very difficult to work out which file was which. This is
    the purpose of a project in AWX—it is quite simply a logical grouping of playbooks
    and is used to make organization easier and simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Although we will not go into **Role-Based Access Control** (**RBAC**) in this
    book, projects also serve a role in this. In the screenshots provided so far,
    you may have noticed a PERMISSIONS button at the top of a number of the panes.
    These are present throughout the UI and are used to define which users have access
    to which configuration items. For example, if you have a team of **Database Administrators**
    (**DBAs**) who should only have access to run playbooks relevant to database servers
    against those servers, you could create an inventory of database servers and only
    give the DBAs access to this. Similarly, you could put all of the DBA-related
    playbooks into one project, and again only give that team permission to access
    that project. In this way, AWX forms a part of the good processes inside an enterprise,
    both making Ansible more accessible, and ensuring that the right items are only
    available to the correct people.
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue our simple example, let''s create a new project to reference our
    example Ansible code:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on Projects on the left-hand menu bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the green + icon to create a new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the project a suitable name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Git from the SCM TYPE drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the following URL into the SCM URL field: [https://github.com/ansible/ansible-examples.git](https://github.com/ansible/ansible-examples.git).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, you could also populate the SCM BRANCH/TAG/COMMIT field if you wanted
    to only work with a specific commit or branch in the repository. In this simple
    example, we will use the latest commit, known in Git as **HEAD**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No other credentials are necessary as this is a publicly available GitHub example—however,
    if you were using a password-protected repository, you would create an SCM credential
    to the machine credential we created in the *Setting up credentials in AWX* section
    of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the UPDATE REVISION ON LAUNCH checkbox—this causes AWX to pull the latest
    version of the code from our SCM URL every time a playbook from this project is
    run. If this is unchecked, you must manually update the local copy of the code
    before AWX will see the latest version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the green SAVE button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When complete, the resulting screen should look something like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d443141-ad17-4f37-a99e-c3400ce628df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we can proceed to the final step of configuring our playbook for its
    first run, we need to manually pull the contents from the GitHub repository. To
    do this, click on the two semicircular arrows to the right of your newly created
    project—this forces a manual sync of the project from the upstream repository.
    An example of this is shown in the following screenshot for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc1aba58-056f-4006-bdda-739c1be74faf.png)'
  prefs: []
  type: TYPE_IMG
- en: The green dot to the left of the project title (as seen in the preceding screenshot)
    will pulsate during the sync. Once this completes successfully, it will turn a
    static green, whereas if something goes wrong, it will turn red. Assuming all
    is well, we can proceed to the final stage of preparing to run our playbook.
  prefs: []
  type: TYPE_NORMAL
- en: With our project defined in AWX, the next task required as we head toward running
    our first playbook from it is to create a template, and we will do exactly that
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a template in AWX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates in AWX pull together all of the other configuration items you have
    created so far—in essence, a template is the AWX definition of all of the parameters
    you would specify on the command line following the `ansible-playbook` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through the process of creating a template so that we can run our
    playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on Templates on the left-hand menu bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the green + icon to create a new template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Job Template from the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the template a suitable name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the INVENTORY field, select the inventory we created earlier in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the PROJECT field, select the project we created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the PLAYBOOK field, note that the drop-down list has automatically been populated
    with a list of all of the viable playbooks that are available in the GitHub repository
    we specified in our PROJECT definition. Choose `lamp_simple_rhel7/site.yml` from
    the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, select the credential we defined earlier in the CREDENTIAL field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the green SAVE button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The end result should look something like the following screenshot, which shows
    all of the fields filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d70ecb42-2c66-4ec7-a4e1-062c91d779ff.png)'
  prefs: []
  type: TYPE_IMG
- en: With those steps complete, we have now completed everything required to run
    our first ever job from AWX. Hence, we shall proceed to do exactly that in the
    next section and observe the results.
  prefs: []
  type: TYPE_NORMAL
- en: Running a playbook from AWX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we run a playbook from AWX, what we're actually doing is running a template.
    Hence, to do this interactively, we will navigate our way back to the Templates
    screen, which should present a list of available templates. Note that when you
    are employing role-based access control, you can only see the templates (and inventories
    and other configuration items) that you have permission to see—if you don't have
    permission, it is invisible. This helps make AWX more manageable when using it
    across different teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using an administrator account, so we can see everything. To launch
    our newly created template, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the rocket ship icon on the right of the template name, as shown in
    the following screenshot, which shows our newly created Templates with the option
    to execute it highlighted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b1b13551-3177-4e92-a149-87416697561a.png)'
  prefs: []
  type: TYPE_IMG
- en: When you do this, the screen automatically reloads and you will see details
    of the run on your screen. Don't worry if you navigate away from this—you can
    always find it again later by clicking on Jobs on the left-hand menu bar. Since
    we have defined this job, it fails in the first instance. Luckily, the Jobs pane
    shows you all of the same details and output that you would get when you run Ansible
    from the command line, only in AWX, it is archived in the database so that you
    can always go back to it at a later date or so that another user can analyze it
    simply by logging into AWX (assuming they have the required permissions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the job output, we can see the problem is some kind of permissions
    issue, and a screenshot showing what this might look like is shown for your reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1c1d28ac-d66c-41ec-9999-8872caf5f667.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Taking a look at the playbook source code on GitHub, we can see that the original
    author hardcoded the use of the root user account for this playbook (note the `remote_user:
    root` statements in `site.yml`). Normally, you wouldn''t do this—it is generally
    better practice to get Ansible to log in using an unprivileged account, and then
    to use `sudo` as required by putting the `become: true` statement in the play
    headers (we''ll see this in action later in this book).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To work around this, for now, we''ll simply allow root logins over SSH on our
    CentOS 7 server, and then modify the credential in AWX to be for the root account.
    Note that you could also define a new credential and change the credential linked
    to the template—either are acceptable solutions. Once you have changed the credential,
    run the template again—this time, the output should look somewhat different, as
    we can see in the following screenshot, which is showing now a successful run
    of the playbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d03368a4-488b-44fe-a351-31194a819cc8.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding screenshot, we have a successful playbook run,
    along with all of the relevant details about which user launched it, which revision
    on GitHub was used, which credentials were used, which inventory, and so on. Scrolling
    down this pane gives the output from `ansible-playbook` that we saw in the error
    screenshot previously; if we wish to, we can further analyze the playbook run
    to see whether there were any warnings, what was changed, and so on. Hence, with
    AWX we really achieve a nice simple user interface to Ansible, which integrates
    all of the good practices that should be present when automating Linux in an enterprise
    environment such as security, auditability, and centralized control of Ansible
    (and indeed playbook code through source control integration).
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how AWX can assist us with running tasks manually—but what if we
    want a truly *hands-off* approach to task automation? We will explore scheduling
    tasks in the next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Automating routine tasks with AWX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although there are many facets to AWX that would require much more space than
    we have in this book, one particular one stands out—the automation of routine
    tasks. Routine tasks that Ansible could handle might include patching of servers,
    running some kind of compliance check or audit, or enforcing a security policy.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could write an Ansible playbook to ensure that the SSH daemon
    does not allow remote root logins as this is considered a good security practice.
    It is, of course, easy for any system administrator with root privileges to log
    in and turn this back on; however, running an Ansible playbook regularly to turn
    this off enforces it and ensures no-one (well-meaning or otherwise) turns it back
    on. The idempotent nature of Ansible changes means that where the configuration
    is already in place, Ansible will not make any changes, and hence running the
    playbook is safe, light on system resources, and non-disruptive.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to do this with Ansible on the command line, you would need to
    create a cron job to run the `ansible-playbook` command regularly, along with
    all of the required parameters. This would mean having the SSH private keys installed
    on the server handling the automation, and means you have to keep track of which
    servers are running Ansible on a routine basis. This is not ideal for an enterprise
    where good practice is the byword of automation and ensures that everything keeps
    running smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, AWX can help us out here, too. To keep this example concise, we will
    reuse the LAMP stack example from the previous section of this chapter. In this
    scenario, we might want to schedule a one-off installation of the LAMP stack for
    a time when things are quiet, whereas for a routine task, it would be on an ongoing
    basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a schedule for this template, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on Templates on the left-hand menu bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the template we created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the SCHEDULES button at the top of the pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the green + icon to add a new schedule to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the appropriate start date and time—I will set mine a few minutes from now
    to demonstrate it in action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, set the appropriate timezone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, select the REPEAT FREQUENCY—in this example, I will choose None (run
    once), but note that other ongoing options are available from the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the green SAVE button to activate the schedule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you have completed the preceding steps, the resulting configuration screen
    should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e8be2b3-313f-472a-8063-4aa45aa11664.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if you watch the Jobs pane, you should see your template start to run
    at the scheduled time. When you analyze the completed (or indeed running) job,
    you should see that it was launched by the name of the schedule you created earlier,
    rather than by the name of a user account such as admin (as we saw when we launched
    it manually). A screenshot is provided here that shows an example of a completed
    job that was launched by our Scheduled install schedule that we created earlier
    in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1941ebd7-ea00-422f-acbe-ec9d7827b5d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to see all scheduled jobs that are forthcoming on your AWX instance,
    you can simply click on the Schedules menu item on the left-hand menu bar, and
    a screen will load that lists all configured schedules in your AWX instance. For
    those of you familiar with Linux administration, this is akin to listing cron
    jobs. An example of such a screen is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/684bd26f-4715-4940-8223-a963b250e95f.png)'
  prefs: []
  type: TYPE_IMG
- en: This gives you a concise overview of all of the schedules you have created,
    without having to go into the individual configuration items themselves to edit
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, AWX supports not just interactive automation of your Linux environment,
    but also hands-off scheduled automation tasks too, hence increasing the power
    and flexibility of your automation solution.
  prefs: []
  type: TYPE_NORMAL
- en: It is hoped that this overview gives you an idea of the benefits that a tool
    such as AWX or Ansible Tower can bring to your enterprise, and why it is beneficial
    to supplement your Ansible automation with this.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible offers a great deal of power with just a small amount of learning, yet
    when deployed at a large scale in an enterprise, it can become more difficult
    to keep track of everything, especially which users have the latest versions of
    playbook code and who ran what playbook when. AWX supplements Ansible in the enterprise
    by bringing with it key benefits such as role-based access control, auditability,
    integrated source control management of playbook code, secure credential management,
    and job scheduling. It achieves this while providing an easy to use point and
    click interface, which further lowers the barrier to entry for all staff responsible
    for the Linux environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned why AWX is important to an Enterprise Linux environment
    and how to leverage a number of its key features. You then carried out a hands-on
    installation of a single AWX node before completing a practical end-to-end example
    of running a playbook directly from GitHub to install a LAMP stack on a CentOS
    7 server. Finally, you learned about job scheduling to automate routine maintenance
    tasks using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the different deployment methodologies
    that are relevant to an Enterprise Linux environment and how to leverage these.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a key advantage of using AWX to store your credentials over the methods
    available to you on the command line?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to make good use of a version control system such as Git
    to store your playbooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is AWX advantageous over Ansible on the command line when it comes to dynamic
    inventories?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a project in AWX?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a template in AWX analogous to on the command line?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does AWX tell you which commit to a Git repository a playbook run was performed
    against?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it advisable to restrict access to the server that hosts AWX, especially
    the shell and local filesystem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you need to programmatically launch playbook runs, how can AWX help you?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an in-depth understanding of Ansible including AWX, please refer to *Mastering
    Ansible, Third Edition* by* James Freeman* and *Jesse Keating* ([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To achieve a greater understanding of version control with Git and best practices
    associated with its use, please refer to *Git Best Practices Guide* by* Eric Pidoux*
    ([https://www.packtpub.com/application-development/git-best-practices-guide](https://www.packtpub.com/application-development/git-best-practices-guide)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand how to access and work with the AWX API, please refer to [https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html](https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you wish to explore the control of AWX with the `tower-cli` tool, please
    refer to the official documentation here: [https://tower-cli.readthedocs.io/en/latest/](https://tower-cli.readthedocs.io/en/latest/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
