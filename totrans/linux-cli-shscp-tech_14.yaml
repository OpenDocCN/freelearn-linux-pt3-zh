- en: '*Chapter 14*: Interacting with Shell Scripts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are almost done with explaining the basic concepts of scripting, but before
    we can say we are completely done with them, we need to learn how to interact
    with shell scripts. This isn't always necessary in shell scripting, but it may
    apply to most situations. For example, it's one thing to create a script that
    does one job and one job only. It's completely different to create a script that
    requires us to make some choices as it gets executed. If nothing else, this second
    type is a prime candidate for shell script interaction. In this chapter, we are
    going to cover three different ways to deal with shell script interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating text-based interactive scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using expect to automate repetitive tasks based on text output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dialog for menu-driven interactive scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with all the chapters thus far, we are going to use the same virtual machine
    running the Bash shell. So, we need a virtual machine with Linux installed – any
    distribution is fine (in our case, it's going to be *Ubuntu 20.10*).
  prefs: []
  type: TYPE_NORMAL
- en: Now, start your virtual machine!
  prefs: []
  type: TYPE_NORMAL
- en: Creating text-based interactive scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The one thing that we haven't done so far is put any interaction in our scripts.
    The reason for this is simple – at this point, we've only discussed how to output
    information and not how to get it from the user or any other source. In the real
    world, interaction is something that we need to deal with because it is at the
    core of creating any script. We could say that there are two kinds of interaction.
    First, our script can interact with the system itself. This means using different
    variables and other information that we can get from the system – for example,
    free space in memory or on mounted disks. You could say that this is not real
    interaction but instead just reading real-time data from the system. But, still,
    it's a very useful way of making sure that a script does what it needs to do.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that we can do is interact with the user starting it. If the script
    is run by the system, it isn't something that is going to interact with the user
    in any way, but user interaction is extremely important when we are creating scripts
    for day-to-day jobs. Consider this question – why would we create a script that
    backs up *a folder* (one folder only) when we can create a script that can be
    told to back up *one or more directories*? Isn't that way of designing a script
    much more usable?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we start creating our scripts, we must decide on the kind of interaction
    that we need in them. Depending on the type of script that's required, we may
    use interactive prompts, menus, some sort of pre-configuration, or even some graphical
    interface. For now, we are going to stay away from using GUIs for our scripts.
    However, we can use them if we need to with the help of some appropriate tools.
    Remember, scripts are barely more than some execution control that dictates how
    different commands and applications interact, so those commands are what matters
    most in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: For starters, our first recipe will be a simple interactive script asking the
    user for input and then acting on it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main commands that we are going to use in this recipe are going to be `read`
    and `echo`. Before we do anything else, we need to learn a few tricks regarding
    these commands. In theory, `read` is simple to understand – it waits for user
    input and then stores that input in some variable. But to show you the different
    things that are made possible by this simple command, we need to show you a few
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: '`read`, in its basic form, accepts one argument – the variable – and then takes
    whatever the user types in and puts it into this variable so that we can use it
    later. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we quickly test this script, this is what we will get as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, this is not enough. Sometimes, we need to get more than one value
    into our script. The problem here is the way users type in the values. Shell uses
    space characters as separators, so a space is going to be what separates the value
    in the `read` command. If we need to get a value that contains spaces, we will
    have to deal with it differently. As we saw in the previous example, this will
    only become a problem if we use more than one return variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, however, we use values that do not contain spaces, we can simply use the
    following code and save it in the `doublevar.sh` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try it and see if it works the way we are expecting it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We must stop here and do another test to clear a few things up. Bash performs
    no checks on what the type of the variable is. In our script, we presumed that
    the user is going to input numbers, but nothing stops them from using any string.
    Another thing would be how multiple values separated by spaces are going to be
    handled – the first value is going to be assigned to the first variable; everything
    after that is going to be assigned to the second one. If we use more than two
    variables to store values, the result is always going to be that each variable
    in the sequence will get one variable assigned and the last one will get whatever
    was left in the input line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way we can use `read` is to get the values into a predefined variable
    called `$REPLY`. If we simply omit the variable name, everything you type in is
    going to be in that variable, which can then be used in your script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple test proves that this behaves exactly as if we gave the command a
    proper variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of using `read` is by using the `-a` switch. By using this, we
    are saying that we want to store all the values it got as an array. After this
    switch, we need to state the name of the variable we are going to use to store
    the values, or we can simply use the default `$REPLY` variable. What we should
    not do is use more than one variable name. This is because we are storing multiple
    values in one variable, so it makes no sense to try and reference more than one
    variable in the first place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are reading multiple values into a single variable. Since we didn't
    ask Bash to create an array, it is going to store everything into this variable,
    but there will be no way of referencing the elements inside this variable. Bash
    treats all the values in the variable as a single, first element, so if we try
    to print it out, we will get everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second time we do this, we are getting the values from the user. Here,
    we are using an array. Everything looks the same but if we reference the first
    element of the variable, we will only print the first element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to experiment a bit with the `echo` command. In the entire scripting
    part of this book, we have been using this command in its most basic form to,
    well, output text to screen or, to be more precise, to standard output. This will
    work for the majority of cases, but there are some scripts where we need more
    control over the output. The problem with the way `echo` works is that it always
    terminates the string it outputs with a newline character, forcing the output
    into a new line once it''s printed whatever was given to it as a parameter. While
    this is alright for printing out information, when we try to interact with the
    user in our scripts, it will look strange if we always force the user to enter
    the values we are looking for in a new line. So, `echo` offers one additional
    option that changes the default behavior (`-n`). Let''s consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What we told `echo` to do here is that it should print the text inside quotation
    marks, but after that, it should stay in the same line. Since our `read` command
    naturally continues wherever the cursor was placed by the previous command, the
    result will be that the value we type in will appear most logically on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another way to do this that looks more complicated but behaves the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason we are showing you this is because this example uses special characters
    to denote the end of the line, but at the same time, there are more characters
    we can use for even finer control over the output. By default, the most commonly
    used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\\ backslash`: When we need to output the actual `\` character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\a alert (BEL)`: When we want to warn the user by using a loud sound.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\b backspace`: We use this when we need to provide a backspace character,
    deleting whatever is on the same line under the cursor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\c produce no further output`: This is used to tell `echo` to simply stop
    the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\t horizontal tab`: This is used to provide `tab` and align the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know about some of the basic `read` and `echo` syntaxes, let's try
    to put that to good use in a script.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know how to deal with everything in the Bash script that can be
    used for interaction, we can create a script that will show it all. Here, we are
    creating a simple menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Try it out!
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way to create an interactive menu that we can use in our script
    – using the `select` command. This command is often used to create simple menus,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`select` looks a lot like some sort of loop; it requires us to set a few variables
    in advance. `$PS3` contains the question that the user will see, while `$options`
    contains an array of strings that represent options. When a user runs this script,
    it will be presented with a list of numbered options, and they can input any of
    them as a number. `select` is going to then substitute the string from our options
    list based on the number that the user selected and run the appropriate command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is a great way to quickly create a script with multiple choices.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A lot more can be found about the `echo` and `read` commands at the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://linuxhint.com/bash_read_command/](https://linuxhint.com/bash_read_command/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.javatpoint.com/bash-read-user-input](https://www.javatpoint.com/bash-read-user-input)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using expect to automate repetitive tasks based on text output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash is a formidable tool but sometimes, we need to do a particular thing that
    needs additional tools. In this recipe, we are going to be working with just such
    a tool called `expect`. Before we start, we must note that `expect` is not part
    of Bash scripting – it is a whole separate scripting language, written for a particular
    purpose, to enable interaction between your scripts and users and other systems.
    The idea behind it is to enable your scripts to not only execute `normal` commands
    that provide information when executed (command output) but to also be able to
    interact with any application that has a **command-line interface** (**CLI**)
    and get information from it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a simplified way, `expect` acts as a virtual keyboard that can type in some
    text and read what is on the screen. This is a powerful thing that is often needed
    because several applications and scripts are created by people who either had
    no reason to enable scripting support or just didn't want to do it. This means
    that without a tool such as `expect`, we will not be able to interact with those
    applications. This sometimes means that we will not be able to do what we want
    from inside our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use `expect` to interact with another shell
    on another computer, how to type in a password and log in, and how to type commands
    and get a response from the other side.
  prefs: []
  type: TYPE_NORMAL
- en: But before we even do that, we need to install `expect` if it isn't installed
    on the system since it is not a standard part of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command and wait for it to finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We need to use `sudo` here. Only an administrator can install packages, so expect
    to have to input your user password.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since `expect` is not Bash, we must tell our script to use it. The syntax is
    the same as when we're creating a script using Bash – we need to make running
    `expect` the first line of our script. Note that this immediately means that our
    script no longer uses any of the commands from Bash, but we get many new things
    we can do.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start with the simple `hello world` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: What the script does is exactly what the commands sound like they do; when we
    start it, the script is going to look for a `hello` string and after it receives
    it, it is going to reply with the `world` string.
  prefs: []
  type: TYPE_NORMAL
- en: Strings are case-sensitive, so nothing else than the exact match will work.
    Also, `expect` has a built-in period during which it expects to get the string.
    If nothing is matched during that period, the script is going to continue from
    the next command. In our example, even if we give it no input, we are going to
    get the `world` string printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we start our script, we must use the `expect` command; we cannot start
    this script using Bash since it is written specifically for `expect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We tried three different ways of spelling the string here, and only the exact
    match worked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do something more interesting and explain what we did along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This script is intended to enable you to quickly connect to another host using
    the `ssh` protocol. When we run it, we need to provide three things: the name
    or IP address of the host, the username to use, and the cleartext password for
    the user that will log in. We are aware that using a password in this way is not
    normal at all, but we are providing an example here.'
  prefs: []
  type: TYPE_NORMAL
- en: At the start of the script, we are setting the timeout for the prompts. As we
    mentioned earlier, if the `expect` command doesn't detect any input, it will continue
    the script after the time specified in this `timeout` value. The next three lines
    deal with the arguments we passed to the script. We are assigning each of them
    to a variable so that we can use them later.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we are using the `spawn` command to call the `ssh` command in a
    separate process. We are using the standard `ssh` client and giving it usernames
    and hostnames so that we can start the login process.
  prefs: []
  type: TYPE_NORMAL
- en: After this, our script waits until it detects that we need to type in the password.
    When it detects the `password:` part of the prompt, it sends our password in cleartext.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last command in the script is `interact` and it hands over control to us
    so that we can use our freshly logged-in session to do what we intend to do. This
    is what it looks like when it''s run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is a good start if we need to work on a remote system. But how do we run
    other commands on the other system and what can we do with that?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to continue here; one is to simply wait for the prompt to
    show and then send commands, while another one is to script this *blindly* and
    just wait for a predetermined period and then send the commands that we need.
    So, let''s make an example script for both concepts. Our goal is to have a scenario
    in which one part of the script does its job as an *answer* to command output
    (in our script, this is the `ssh` part and its output). The second part is related
    to the concept of waiting for a predetermined period (`sleep 5` means waiting
    for 5 seconds) and then doing something. Let''s check out our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We added two things that we haven't mentioned previously. The first one is that
    we are using the `puts` command to print information to the screen. It behaves
    similar to `echo` does in Bash.
  prefs: []
  type: TYPE_NORMAL
- en: The `$expect_out (buffer)` variable holds data that the script got from running
    commands between two matches. So, in our script, this is going to hold information
    that was provided by the `ip add` command. If you are wondering where the login
    information disappeared, it is not visible since we issued the `clear` command
    to clear the screen, which, in turn, cleared the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`expect` is an amazing tool that has even more things up its sleeve. One of
    its main purposes is to automate administration tasks using scripts. One of the
    most common usages was what we did in the previous example – running commands
    remotely. The reason we may use it often is not only to automate logins but also
    to automate testing. After running a particular command, we can do whatever we
    want and then get the results into our scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: In this way, `expect` is usually used as part of another script. When we need
    some sort of data that only `expect` can provide, we call it and then continue
    processing the data in our main script. However, automating scripts can mean one
    more thing – getting them to accept information, which enables us to write tests
    to check if our script works. For this reason, `expect` has a tool that is used
    to create an `expect` script out of running any script that contains interaction
    with the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a quick example to demonstrate what we mean, but first, we
    are going to create a very simple script where we will use different ways of calling
    `echo` and `read` in Bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to start the `autoexpect` tool to grab both the input and
    output for the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `autoexpect` was tracking what our script used as prompts, as well as
    what we gave as answers. When we finished executing our script, it created an
    `expect` script, which enables us to completely automate running our Bash script.
    We are going to omit part of this script since it contains a lot of comments that
    give us both the information about the tool and the disclaimer. Here''s what the
    `autoexpect` output looks like; it is saved in a file named `script.exp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This script is a good starting point for automating our work, but be careful
    of one fatal flaw. In the last part that checks the inputs and outputs, it logged
    every typo and error that we made during input, but it hasn't saved the entire
    process of deleting them, so this input will not work. Before we can use it, we
    must edit this script and sort all the errors and inputs out. After that, we can
    expand on it and use additional arguments to test how our script is going to behave.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`expect` is amazing for testing. For more examples, please go to the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expect command: [https://likegeeks.com/expect-command/](https://likegeeks.com/expect-command/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expect man page: [https://linux.die.net/man/1/expect](https://linux.die.net/man/1/expect)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dialog for menu-driven interactive scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've used `expect`, we know how to interact with other applications.
    The only thing left to do is learn how to make our scripts more interactive. It
    will come as no surprise that this problem is already solved in a standard way.
    In this recipe, we will use `dialog`, a command that may look deceptively simple
    but enables you to create both complex and visually interesting interactions with
    end users.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By definition, `dialog`, as with any interaction, makes your scripts unusable
    in a non-interactive environment. This can be solved by either not using `dialog`
    at all or detecting if the script is running as a service or as an interactive
    script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `expect`, we must install `dialog` to use it. Simply use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Everything that you need is going to be installed as required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`dialog` is a whole application that contains not only menus but a lot of other
    widgets that are displayed in a GUI under text mode. It will use colors if they
    are available on your terminal (they probably are – terminals that are unable
    to show colors are long gone in our day and age) and will use cursor keys for
    navigation. We are going to show you a few of the most common ones, as well as
    how to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a start, try running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything has gone well, you should see something like this (the size will
    depend on your terminal window):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – The dialog command enables us to create menus in a single line
    of our script'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.1_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.1 – The dialog command enables us to create menus in a single line
    of our script
  prefs: []
  type: TYPE_NORMAL
- en: '`dialog` acts as a good-looking proxy between your script and the user. Your
    script is responsible for the logic of the process you are trying to automate;
    `dialog` is responsible for dealing with user input and output. We need to do
    something with this menu; if we just call it from our Bash prompt, we have no
    use for it. The reason we used it this way was to show you how to call a widget.
    A lot of people expect a complicated procedure when they first see `dialog` being
    used in a script, which is just a command in one line and a couple of arguments.
    To demonstrate this, let''s create an actual menu and save it in a file named
    `menu.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: What are we doing here? `dialog` requires a couple of parameters for every widget
    it can display. It needs a lot of values to correctly show whether something comes
    from your terminal. These are values such as the width and height of the screen
    and how to display the output correctly. As a rule, widgets only require user-defined
    things – the height and width of the widget itself, titles and other strings that
    are used in the widget, and the choices the user has. They are different from
    widget to widget, depending on the way it works and is used. In our first example,
    we are using a menu widget that requires a list of options and the size of the
    menu. We needed this list of options as it helps the user who's starting this
    script make a correct choice. We are also providing it with the titles, although
    we don't need all of them for our menu to function.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting thing to notice here is the way `dialog` returns the value that
    the user chose. To get that, we are providing indices in our list of possible
    options. When we run `dialog`, we are going to assign the value it got from the
    user directly to a variable and then act accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`dialog` is based on displaying different widgets using different graphical
    characters to give the feel of a graphical interface inside the normal terminal.
    As somebody who uses dialog, you can change almost all the elements'' appearance
    if you want, but usually, most scripts simply use `dialog` to quickly get the
    user to input the data they require.'
  prefs: []
  type: TYPE_NORMAL
- en: Using something like `dialog` is a great way to enable the user to choose values
    for different things in their script while avoiding a lot of input errors.
  prefs: []
  type: TYPE_NORMAL
- en: For another example, let's imagine we need to ask a user to provide us with
    a date. We can do this using a simple entry with the `read` and `echo` commands.
    This will work but with a big risk of the user using the wrong format. You could
    solve this by explaining to your users what format you expect, but they will inevitably
    forget and use the wrong one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `dialog`, you could do something simple, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Using the calendar widget to display dates is easy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.2_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.2 – Using the calendar widget to display dates is easy
  prefs: []
  type: TYPE_NORMAL
- en: The date we are going to get will be in the right format, depending on the regional
    setting of the system running the script, and the user can choose from several
    good-looking calendars. `dialog` helps a lot here since it will even jump to the
    current date if we do not specify which specific date is going to be the default.
    Depending on the type of terminal emulation, `dialog` may even support using a
    computer mouse to select data.
  prefs: []
  type: TYPE_NORMAL
- en: There are more very useful widgets that `dialog` provides, so we are going to
    show a few of them. We are not going to create a script for all of them since
    they are simple to use. The simplest way is to use the `—stdout` option to get
    the result of `dialog` into a variable and then work from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to choose a directory, that can be a big problem since the user
    would usually forget to write the path correctly or use absolute paths instead
    of relative ones. By using a simple `dialog command`, such as the following, we
    can avoid a lot of problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Choosing directories using dialog avoids a lot of errors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.3_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.3 – Choosing directories using dialog avoids a lot of errors
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple `dialog` is useful when we need to get a simple *yes* or *no* answer
    from the user. We can use the following code to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this `dialog` command, we should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Sometimes, you need to ask a simple question that will have
    a simple answer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.4_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.4 – Sometimes, you need to ask a simple question that will have a
    simple answer
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have more informative ones. In our scripts, we are often having to
    present the user with some information that they need to read. Having it in a
    formatted box is much nicer than simply printing it in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Displaying text is easy and effective when you''re using the
    right widget'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.5_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.5 – Displaying text is easy and effective when you're using the right
    widget
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few widgets we will not mention as we are trying to give you a
    quick glimpse into what is possible. For the last example, we are going to show
    you a useful one – this widget shows the contents of a text file and automatically
    updates it with changes, enabling you, for example, to show a log to the user
    while they''re installing something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6 – tailbox is the same as using tail -f on a file but is much
    better looking'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.6_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.6 – tailbox is the same as using tail -f on a file but is much better
    looking
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our overview of what `dialog` can do. Make sure that you read
    the documentation to learn about the rest of the widgets that you can use, as
    well as how to use them correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are other implementations of the same idea. One of those is
    called *whiptail* and is the same as `dialog` but uses a different way to draw
    objects on the screen. However, it is not as complete as `dialog`, and it lacks
    some widgets compared to `dialog`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`dialog` man page: [https://linux.die.net/man/1/dialog](https://linux.die.net/man/1/dialog)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Menu box guide: [https://bash.cyberciti.biz/guide/A_menu_box](https://bash.cyberciti.biz/guide/A_menu_box)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
