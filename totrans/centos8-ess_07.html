<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer115" class="_idGenObjectStyleOverride-1">&#13;
			<p id="_idParaDest-70" class="Chapter-Title"><span class="ChapterMarker">8. </span><a id="_idTextAnchor110"/>Using the <a id="_idIndexMarker108"/>Bash Shell on CentOS 8</p>&#13;
			<p class="My-Basic-Paragraph">An important part of learning to work with CentOS 8, and Linux distributions in general, involves gaining proficiency in working in the shell environment. While the graphical desktop environments such as GNOME included with Linux provide a user friendly interface to the operating system, in practice the shell environment provides far greater capabilities, flexibility and automation than can ever be achieved using graphical desktop tools. The shell environment also provides a means for interacting with the operating system when a desktop environment is not available; a common occurrence when working with a server-based operating system such as CentOS 8 or a damaged system that will not fully boot.</p>&#13;
			<p class="My-Basic-Paragraph">The goal of this chapter, therefore, is to provide an overview of the default shell environment on CentOS 8 (specifically the Bash shell). </p>&#13;
			<p id="_idParaDest-71" class="Heading-1-1"><span class="Heading11Marker">8.1 </span><a id="_idTextAnchor111"/>What is a <a id="_idIndexMarker109"/>Shell?</p>&#13;
			<p class="My-Basic-Paragraph">The shell is an interactive command interpreter environment within which commands may be typed at a prompt or entered into a file in the form of a script and executed. The origins of the shell can be traced back to the early days of the UNIX operating system. In fact, in the early days of Linux before the introduction of graphical desktops the shell was the only way for a user to interact with the operating system.</p>&#13;
			<p class="My-Basic-Paragraph">A variety of shell environments have been developed over the years. The first widely used shell was the Bourne shell, written by Stephen Bourne at Bell Labs.</p>&#13;
			<p class="My-Basic-Paragraph">Yet another early creation was the C shell which shared some syntax similarities with the C Programming Language and introduced usability enhancements such as command-line editing and history.</p>&#13;
			<p class="My-Basic-Paragraph">The Korn shell (developed by David Korn at Bell Labs) is based on features provided by both the <a id="_idIndexMarker110"/>Bourne shell and the <a id="_idIndexMarker111"/>C shell.</p>&#13;
			<p class="My-Basic-Paragraph">The default shell on CentOS 8 is the Bash shell (shorthand for Bourne Again SHell). This shell, which began life as an open source version of the Bourne shell, was developed for the GNU Project by Brian Fox and is based on features provided by both the Bourne shell and the C shell.</p>&#13;
			<p id="_idParaDest-72" class="Heading-1-1"><span class="Heading11Marker">8.2 </span><a id="_idTextAnchor112"/>Gaining Access to the Shell</p>&#13;
			<p class="My-Basic-Paragraph">From within the GNOME desktop environment, the shell prompt may be accessed from a Terminal window by selecting the Activities option in the top bar, entering Terminal into the search bar and clicking on the Terminal icon.</p>&#13;
			<p class="My-Basic-Paragraph">When remotely logging into a CentOS 8 server, for example using SSH, the user is also presented with a shell prompt. Details on accessing a remote server using SSH will be covered in the chapter entitled <a href="../Text/SSH_Authentication.xhtml#_idTextAnchor181"><span class="My-Italic _idGenCharOverride-1">“Configuring SSH Key-based Authentication on CentOS 8”</span></a>. When booting a server-based system in which a desktop environment has not been installed, the shell is entered immediately after the user completes the login procedure at the physical console terminal or remote login session.</p>&#13;
			<p id="_idParaDest-73" class="Heading-1-1"><span class="Heading11Marker">8.3 </span><a id="_idTextAnchor113"/>Entering Commands at the Prompt</p>&#13;
			<p class="My-Basic-Paragraph">Commands are entered at the shell command prompt simply by typing the command and pressing the Enter key. While some commands perform tasks silently, most will display some form of output before returning to the prompt. For example, the <a id="_idIndexMarker112"/><span class="My-Italic _idGenCharOverride-1">ls</span> command can be used to display the files and directories in the current working directory:</p>&#13;
			<p class="Code">$ ls</p>&#13;
			<p class="Code">Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos</p>&#13;
			<p class="My-Basic-Paragraph">The available commands are either built into the shell itself, or reside on the physical file system. The location on the file system of a command may be identified using the <a id="_idIndexMarker113"/><span class="My-Italic _idGenCharOverride-1">which</span> command. For example, to find out where the <span class="My-Italic _idGenCharOverride-1">ls</span> executable resides on the file system:</p>&#13;
			<p class="Code">$ which ls</p>&#13;
			<p class="Code">alias ls=’ls --color=auto’</p>&#13;
			<p class="Code">	/usr/bin/ls</p>&#13;
			<p class="My-Basic-Paragraph">Clearly the <span class="My-Italic _idGenCharOverride-1">ls</span> command resides in the <span class="My-Italic _idGenCharOverride-1">/usr/bin</span> directory. Note also that an alias is configured, a topic which will be covered later in this chapter. Using the <span class="My-Italic _idGenCharOverride-1">which </span>command to locate the path to commands that are built into the shell will result in a message indicating the executable cannot be found. For example, attempting to find the location of the <a id="_idIndexMarker114"/><span class="My-Italic _idGenCharOverride-1">history </span>command (which is actually built into the shell rather than existing as an executable on the file system) will result in output similar to the following:</p>&#13;
			<p class="Code">$ which history</p>&#13;
			<p class="Code">/usr/bin/which: no history in (/home/demo/.local/bin:/home/demo/bin:/usr/share/Modules/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin)</p>&#13;
			<p id="_idParaDest-74" class="Heading-1-1"><span class="Heading11Marker">8.4 </span><a id="_idTextAnchor114"/>Getting Information about a Command</p>&#13;
			<p class="My-Basic-Paragraph">Many of the commands available to the Linux shell can seem cryptic to begin with. To find out detailed information about what a command does and how to use it, use the <a id="_idIndexMarker115"/><span class="My-Italic _idGenCharOverride-1">man</span> command specifying the name of the command as an argument. For example, to learn more about the <a id="_idIndexMarker116"/><span class="My-Italic _idGenCharOverride-1">pwd</span> command:</p>&#13;
			<p class="Code">$ man pwd</p>&#13;
			<p class="My-Basic-Paragraph">When the above command is executed, a detailed description of the <a id="_idIndexMarker117"/><span class="My-Italic _idGenCharOverride-1">pwd</span> command will be displayed. Many commands will also provide additional information when run with the <span class="My-Italic _idGenCharOverride-1">--help</span> command-line option:</p>&#13;
			<p class="Code">$ wc --help</p>&#13;
			<p id="_idParaDest-75" class="Heading-1-1"><span class="Heading11Marker">8.5 </span><a id="_idTextAnchor115"/><a id="_idIndexMarker118"/>Bash Command-line Editing</p>&#13;
			<p class="My-Basic-Paragraph">Early shell environments did not provide any form of line editing capabilities. This meant that if you spotted an error at the beginning of a long command-line you were typing, you had to delete all the following characters, correct the error and then re-enter the remainder of the command. Fortunately Bash provides a wide range of command-line editing options as outlined in the following table:</p>&#13;
			<table id="table001" class="My-Table-Style TableOverride-1">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="My-Table-Style">&#13;
						<td class="My-Table-Style My-Table-Header-Style">&#13;
							<p class="My-Basic-Paragraph"><span class="My-Bold _idGenCharOverride-1">Key Sequence</span></p>&#13;
						</td>&#13;
						<td class="My-Table-Style My-Table-Header-Style">&#13;
							<p class="My-Basic-Paragraph"><span class="My-Bold _idGenCharOverride-1">Action</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="My-Table-Style _idGenTableRowColumn-1">&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Ctrl-b or Left Arrow</p>&#13;
						</td>&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Move cursor back one position</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="My-Table-Style">&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Ctrl-f or Right Arrow</p>&#13;
						</td>&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Move cursor forward one position</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="My-Table-Style _idGenTableRowColumn-1">&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Delete</p>&#13;
						</td>&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Delete character currently beneath the cursor</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="My-Table-Style">&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Backspace</p>&#13;
						</td>&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Delete character to the left of the cursor</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="My-Table-Style _idGenTableRowColumn-1">&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Ctrl-_</p>&#13;
						</td>&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Undo previous change (can be repeated to undo all previous changes)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="My-Table-Style">&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Ctrl-a</p>&#13;
						</td>&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Move cursor to the start of the line</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="My-Table-Style _idGenTableRowColumn-1">&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Ctrl-e</p>&#13;
						</td>&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Move cursor to the end of the line</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="My-Table-Style">&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Meta-f or Esc then f</p>&#13;
						</td>&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Move cursor forward one word</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="My-Table-Style _idGenTableRowColumn-1">&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Meta-b or Esc then b</p>&#13;
						</td>&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Move cursor back one word</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="My-Table-Style">&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Ctrl-l</p>&#13;
						</td>&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Clear the screen of everything except current command</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="My-Table-Style _idGenTableRowColumn-1">&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Ctrl-k</p>&#13;
						</td>&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Delete to end of line from current cursor position</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="My-Table-Style">&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Meta-d or Esc then d</p>&#13;
						</td>&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Delete to end of current word</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="My-Table-Style _idGenTableRowColumn-1">&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Meta-DEL or Esc then DEL</p>&#13;
						</td>&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Delete beginning to current word</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="My-Table-Style">&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Ctrl-w</p>&#13;
						</td>&#13;
						<td class="My-Table-Style">&#13;
							<p class="My-Basic-Paragraph">Delete from current cursor position to previous white space</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="Table-Caption"><span class="TableCaptionMarker">Table 8-1</span></p>&#13;
			<p id="_idParaDest-76" class="Heading-1-1"><span class="Heading11Marker">8.6 </span><a id="_idTextAnchor116"/>Working with the <a id="_idIndexMarker119"/><a id="_idIndexMarker120"/>Shell History</p>&#13;
			<p class="My-Basic-Paragraph">In addition to command-line editing features, the Bash shell also provides command-line history support. A list of previously executed commands may be viewed using the <a id="_idIndexMarker121"/><span class="My-Italic _idGenCharOverride-1">history</span> command:</p>&#13;
			<p class="Code">$ history</p>&#13;
			<p class="Code">    1  ps</p>&#13;
			<p class="Code">    2  ls</p>&#13;
			<p class="Code">    3  ls –l /</p>&#13;
			<p class="Code">    4  ls</p>&#13;
			<p class="Code">    5  man pwd</p>&#13;
			<p class="Code">    6  man apropos</p>&#13;
			<p class="My-Basic-Paragraph">In addition, Ctrl-p (or up arrow) and Ctrl-n (or down arrow) may be used to scroll back and forth through previously entered commands. When the desired command from the history is displayed, press the Enter key to execute it.</p>&#13;
			<p class="My-Basic-Paragraph">Another option is to enter the ‘!’ character followed by the first few characters of the command to be repeated followed by the Enter key.</p>&#13;
			<p id="_idParaDest-77" class="Heading-1-1"><span class="Heading11Marker">8.7 </span><a id="_idTextAnchor117"/><a id="_idIndexMarker122"/>Filename Shorthand</p>&#13;
			<p class="My-Basic-Paragraph">Many shell commands take one or more filenames as arguments. For example, to display the content of a text file named <span class="My-Italic _idGenCharOverride-1">list.txt</span>, the <a id="_idIndexMarker123"/><span class="My-Italic _idGenCharOverride-1">cat</span> command would be used as follows:</p>&#13;
			<p class="Code">$ cat list.txt</p>&#13;
			<p class="My-Basic-Paragraph">Similarly, the content of multiple text files could be displayed by specifying all the file names as arguments:</p>&#13;
			<p class="Code">$ cat list.txt list2.txt list3.txt list4.txt</p>&#13;
			<p class="My-Basic-Paragraph">Instead of typing in each name, <a id="_idIndexMarker124"/>pattern matching can be used to specify all files with names matching certain criteria. For example, the ‘*’ wildcard character can be used to simplify the above example:</p>&#13;
			<p class="Code">$ cat *.txt</p>&#13;
			<p class="My-Basic-Paragraph">The above command will display the content of all files ending with a <span class="My-Italic _idGenCharOverride-1">.txt</span> extension. This could be further restricted to any file names beginning with <span class="My-Italic _idGenCharOverride-1">list</span> and ending in <span class="My-Italic _idGenCharOverride-1">.txt</span>:</p>&#13;
			<p class="Code">$ cat list*.txt</p>&#13;
			<p class="My-Basic-Paragraph">Single character matches may be specified using the ‘?’ character:</p>&#13;
			<p class="Code">$ cat list?.txt</p>&#13;
			<p id="_idParaDest-78" class="Heading-1-1"><span class="Heading11Marker">8.8 </span><a id="_idTextAnchor118"/>Filename and <a id="_idIndexMarker125"/>Path Completion</p>&#13;
			<p class="My-Basic-Paragraph">Rather than typing in an entire file name or path, or using pattern matching to reduce the amount of typing, the shell provides the <span class="My-Italic _idGenCharOverride-1">filename completion</span> feature. In order to use filename completion, simply enter the first few characters of the file or path name and then press the Esc key twice. The shell will then complete the filename for you with the first file or path name in the directory that matches the characters you entered. To obtain a list of possible matches, press Esc = after entering the first few characters.</p>&#13;
			<p id="_idParaDest-79" class="Heading-1-1"><span class="Heading11Marker">8.9 </span><a id="_idTextAnchor119"/><a id="_idIndexMarker126"/>Input and Output Redirection</p>&#13;
			<p class="My-Basic-Paragraph">As previously mentioned, many shell commands output information when executed. By default this output goes to a device file called <a id="_idIndexMarker127"/><span class="My-Italic _idGenCharOverride-1">stdout</span> which is essentially the terminal window or console in which the shell is running. Conversely, the shell takes input from a device file named <a id="_idIndexMarker128"/><span class="My-Italic _idGenCharOverride-1">stdin</span>, which by default is the keyboard. </p>&#13;
			<p class="My-Basic-Paragraph">Output from a command can be redirected from stdout to a physical file on the file system using the ‘&gt;’ character. For example, to redirect the output from an <span class="My-Italic _idGenCharOverride-1">ls</span> command to a file named <span class="My-Italic _idGenCharOverride-1">files.txt</span>, the following command would be required:</p>&#13;
			<p class="Code">$ ls *.txt &gt; files.txt</p>&#13;
			<p class="My-Basic-Paragraph">Upon completion, <span class="My-Italic _idGenCharOverride-1">files.txt</span> will contain the list of files in the current directory. Similarly, the contents of a file may be fed into a command in place of stdin. For example, to redirect the contents of a file as input to a command:</p>&#13;
			<p class="Code">$ wc –l &lt; files.txt</p>&#13;
			<p class="My-Basic-Paragraph">The above command will display the number of lines contained in the <span class="My-Italic _idGenCharOverride-1">files.txt</span> file.</p>&#13;
			<p class="My-Basic-Paragraph">It is important to note that the ‘&gt;’ redirection operator creates a new file, or truncates an existing file when used. In order to append to an existing file, use the ‘&gt;&gt;’ operator:</p>&#13;
			<p class="Code">$ ls *.dat &gt;&gt; files.txt</p>&#13;
			<p class="My-Basic-Paragraph">In addition to standard output, the shell also provides standard error output using <a id="_idIndexMarker129"/><span class="My-Italic _idGenCharOverride-1">stderr</span>. While output from a command is directed to stdout, any error messages generated by the command are directed to stderr. This means that if stdout is directed to a file, error messages will still appear in the terminal. This is generally the desired behavior, though stderr may also be redirected if desired using the ‘2&gt;’ operator:</p>&#13;
			<p class="Code">$ ls dkjfnvkjdnf 2&gt; errormsg</p>&#13;
			<p class="My-Basic-Paragraph">On completion of the command, an error reporting the fact that the file named <span class="My-Italic _idGenCharOverride-1">dkjfnvkjdnf</span> could not be found will be contained in the <span class="My-Italic _idGenCharOverride-1">errormsg</span> file.</p>&#13;
			<p class="My-Basic-Paragraph">Both stderr and stdout may be redirected to the same file using the &amp;&gt; operator:</p>&#13;
			<p class="Code">$ ls /etc dkjfnvkjdnf &amp;&gt; alloutput</p>&#13;
			<p class="My-Basic-Paragraph">On completion of execution, the <span class="My-Italic _idGenCharOverride-1">alloutput</span> file will contain both a listing of the contents of the<span class="My-Italic _idGenCharOverride-1"> /etc</span> directory, and the error message associated with the attempt to list a non-existent file.</p>&#13;
			<p id="_idParaDest-80" class="Heading-1-1"><span class="Heading11Marker">8.10 </span><a id="_idTextAnchor120"/>Working with Pipes in the <a id="_idIndexMarker130"/>Bash Shell</p>&#13;
			<p class="My-Basic-Paragraph">In addition to I/O redirection, the shell also allows output from one command to be piped directly as input to another command. A pipe operation is achieved by placing the ‘|’ character between two or more commands on a command-line. For example, to count the number of processes running on a system, the output from the <a id="_idIndexMarker131"/><span class="My-Italic _idGenCharOverride-1">ps </span>command can be piped through to the <a id="_idIndexMarker132"/><span class="My-Italic _idGenCharOverride-1">wc</span> command:</p>&#13;
			<p class="Code">$ ps –ef | wc –l</p>&#13;
			<p class="My-Basic-Paragraph">There is no limit to the number of pipe operations that can be performed on a command-line. For example, to find the number of lines in a file which contain the name Smith:</p>&#13;
			<p class="Code">$ cat namesfile | grep Smith | wc –l</p>&#13;
			<p id="_idParaDest-81" class="Heading-1-1"><span class="Heading11Marker">8.11 </span><a id="_idTextAnchor121"/>Configuring <a id="_idIndexMarker133"/>Aliases</p>&#13;
			<p class="My-Basic-Paragraph">As you gain proficiency with the shell environment it is likely that you will find yourself frequently issuing commands with the same arguments. For example, you may often use the <span class="My-Italic _idGenCharOverride-1">ls</span> command with the <span class="My-Italic _idGenCharOverride-1">l</span> and <span class="My-Italic _idGenCharOverride-1">t</span> options:</p>&#13;
			<p class="Code">$ ls –lt</p>&#13;
			<p class="My-Basic-Paragraph">To reduce the amount of typing involved in issuing a command, it is possible to create an alias that maps to the command and arguments. For example, to create an alias such that entering the letter <span class="My-Italic _idGenCharOverride-1">l</span> will cause the <span class="My-Italic _idGenCharOverride-1">ls –lt </span>command to be executed, the following statement would be used:</p>&#13;
			<p class="Code">$ alias l="ls –lt"</p>&#13;
			<p class="My-Basic-Paragraph">Entering <span class="My-Italic _idGenCharOverride-1">l </span>at the command prompt will now execute the original statement.</p>&#13;
			<p id="_idParaDest-82" class="Heading-1-1"><span class="Heading11Marker">8.12 </span><a id="_idTextAnchor122"/><a id="_idIndexMarker134"/><a id="_idIndexMarker135"/>Environment Variables</p>&#13;
			<p class="My-Basic-Paragraph">Shell environment variables provide temporary storage of data and configuration settings. The shell itself sets up a number of environment variables that may be changed by the user to modify the behavior of the shell. A listing of currently defined variables may be obtained using the <a id="_idIndexMarker136"/><span class="My-Italic _idGenCharOverride-1">env</span> command:</p>&#13;
			<p class="Code">$ env</p>&#13;
			<p class="Code">SSH_CONNECTION=192.168.0.19 61231 192.168.0.28 22</p>&#13;
			<p class="Code">MODULES_RUN_QUARANTINE=LD_LIBRARY_PATH</p>&#13;
			<p class="Code">LANG=en_US.UTF-8</p>&#13;
			<p class="Code">HISTCONTROL=ignoredups</p>&#13;
			<p class="Code">HOSTNAME=-pc.ebookfrenzy.com</p>&#13;
			<p class="Code">XDG_SESSION_ID=15</p>&#13;
			<p class="Code">MODULES_CMD=/usr/share/Modules/libexec/modulecmd.tcl</p>&#13;
			<p class="Code">USER=demo</p>&#13;
			<p class="Code">ENV=/usr/share/Modules/init/profile.sh</p>&#13;
			<p class="Code">SELINUX_ROLE_REQUESTED=</p>&#13;
			<p class="Code">PWD=/home/demo</p>&#13;
			<p class="Code">HOME=/home/demo</p>&#13;
			<p class="Code">SSH_CLIENT=192.168.0.19 61231 22</p>&#13;
			<p class="Code">SELINUX_LEVEL_REQUESTED=</p>&#13;
			<p class="Code">.</p>&#13;
			<p class="Code">.</p>&#13;
			<p class="Code">.</p>&#13;
			<p class="My-Basic-Paragraph">Perhaps the most useful environment variable is <a id="_idIndexMarker137"/>PATH. This defines the directories in which the shell will search for commands entered at the command prompt, and the order in which it will do so. The PATH environment variable for a user account on a newly installed CentOS 8 system will likely be configured as follows:</p>&#13;
			<p class="Code">$ echo $PATH</p>&#13;
			<p class="Code">/home/demo/.local/bin:/home/demo/bin:/usr/share/Modules/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin</p>&#13;
			<p class="My-Basic-Paragraph">Another useful variable is <a id="_idIndexMarker138"/>HOME which specifies the home directory of the current user. If, for example, you wanted the shell to also look for commands in the scripts directory located in your home directory, you would modify the PATH variable as follows:</p>&#13;
			<p class="Code">$ export PATH=$PATH:$HOME/scripts</p>&#13;
			<p class="My-Basic-Paragraph">The current value of an existing environment variable may be displayed using the echo command:</p>&#13;
			<p class="Code">$ echo $PATH</p>&#13;
			<p class="My-Basic-Paragraph">You can create your own environment variables using the <a id="_idIndexMarker139"/><span class="My-Italic _idGenCharOverride-1">export</span> command. For example:</p>&#13;
			<p class="Code">$ export DATAPATH=/data/files</p>&#13;
			<p class="My-Basic-Paragraph">A useful trick to assign the output from a command to an environment variable involves the use of back quotes (`) around the command. For example, to assign the current date and time to an environment variable called NOW:</p>&#13;
			<p class="Code">$ export NOW=`date`</p>&#13;
			<p class="Code">$ echo $NOW</p>&#13;
			<p class="Code">Tue Apr 2 13:48:40 EDT 2019</p>&#13;
			<p class="My-Basic-Paragraph">If there are environment variable or alias settings that you need to be configured each time you enter the shell environment, they may be added to a file in your home directory named <a id="_idIndexMarker140"/><a id="_idIndexMarker141"/><span class="My-Italic _idGenCharOverride-1">.bashrc</span>. For example, the following example <span class="My-Italic _idGenCharOverride-1">.bashrc</span> file is configured to set up the DATAPATH environment variable and an alias:</p>&#13;
			<p class="Code"># .bashrc</p>&#13;
			<p class="Code">  </p>&#13;
			<p class="Code"># Source global definitions</p>&#13;
			<p class="Code">if [ -f /etc/bashrc ]; then</p>&#13;
			<p class="Code">        . /etc/bashrc</p>&#13;
			<p class="Code">fi</p>&#13;
			<p class="Code"> </p>&#13;
			<p class="Code"># User specific environment</p>&#13;
			<p class="Code">PATH="$HOME/.local/bin:$HOME/bin:$PATH"</p>&#13;
			<p class="Code">export PATH</p>&#13;
			<p class="Code"> </p>&#13;
			<p class="Code"># Uncomment the following line if you don't like systemctl's auto-paging feature:</p>&#13;
			<p class="Code"># export SYSTEMD_PAGER=</p>&#13;
			<p class="Code"> </p>&#13;
			<p class="Code"># User specific aliases and functions</p>&#13;
			<p class="Code"><span class="My-Bold _idGenCharOverride-2">export DATAPATH=/data/files</span></p>&#13;
			<p class="Code"><span class="My-Bold _idGenCharOverride-2">alias l="ls -lt"</span></p>&#13;
			<p id="_idParaDest-83" class="Heading-1-1"><span class="Heading11Marker">8.13 </span><a id="_idTextAnchor123"/>Writing <a id="_idIndexMarker142"/><a id="_idIndexMarker143"/>Shell Scripts</p>&#13;
			<p class="My-Basic-Paragraph">So far we have focused exclusively on the interactive nature of the Bash shell. By interactive we mean manually entering commands at the prompt one by one and executing them. In fact, this is only a small part of what the shell is capable of. Arguably one of the most powerful aspects of the shell involves the ability to create shell scripts. Shell scripts are essentially text files containing sequences of statements that can be executed within the shell environment to perform tasks. In addition to the ability to execute commands, the shell provides many of the programming constructs such as <span class="My-Italic _idGenCharOverride-1">for</span> and <span class="My-Italic _idGenCharOverride-1">do</span> loops and <span class="My-Italic _idGenCharOverride-1">if</span> statements that you might reasonably expect to find in a scripting language.</p>&#13;
			<p class="My-Basic-Paragraph">Unfortunately a detailed overview of shell scripting is beyond the scope of this chapter. There are, however, many books and web resources dedicated to shell scripting that do the subject much more justice than we could ever hope to achieve here. In this section, therefore, we will only be providing a very small taste of shell scripting.</p>&#13;
			<p class="My-Basic-Paragraph">The first step in creating a shell script is to create a file (for the purposes of this example we name it <span class="My-Italic _idGenCharOverride-1">simple.sh</span>) and add the following as the first line:</p>&#13;
			<p class="Code">#!/bin/sh</p>&#13;
			<p class="My-Basic-Paragraph">The #! is called the “shebang” and is a special sequence of characters indicating that the path to the interpreter needed to execute the script is the next item on the line (in this case the <span class="My-Italic _idGenCharOverride-1">sh</span> executable located in /bin). This could equally be, for example, <span class="My-Italic _idGenCharOverride-1">/bin/csh</span> or <span class="My-Italic _idGenCharOverride-1">/bin/ksh</span> if either were the interpreter you wanted to use.</p>&#13;
			<p class="My-Basic-Paragraph">The next step is to write a simple script:</p>&#13;
			<p class="Code">#!/bin/sh</p>&#13;
			<p class="Code">for i in *</p>&#13;
			<p class="Code">do</p>&#13;
			<p class="Code">     echo $i</p>&#13;
			<p class="Code">done</p>&#13;
			<p class="My-Basic-Paragraph">All this script does is iterate through all the files in the current directory and display the name of each file. This may be executed by passing the name of the script through as an argument to <span class="My-Italic _idGenCharOverride-1">sh</span>:</p>&#13;
			<p class="Code">$ sh simple.sh</p>&#13;
			<p class="My-Basic-Paragraph">In order to make the file executable (thereby negating the need to pass it through to the <a id="_idIndexMarker144"/><span class="My-Italic _idGenCharOverride-1">sh</span> command) the <a id="_idIndexMarker145"/><span class="My-Italic _idGenCharOverride-1">chmod </span>command can be used:</p>&#13;
			<p class="Code">$ chmod +x simple.sh</p>&#13;
			<p class="My-Basic-Paragraph">Once the execute bit has been set on the file’s permissions, it may be executed directly. For example:</p>&#13;
			<p class="Code">$ ./simple.sh</p>&#13;
			<p id="_idParaDest-84" class="Heading-1-1"><span class="Heading11Marker">8.14 </span><a id="_idTextAnchor124"/>Summary</p>&#13;
			<p class="My-Basic-Paragraph">In this chapter of CentOS 8 Essentials we have taken a brief tour of the Bash shell environment. In the world of graphical desktop environments it is easy to forget that the true power and flexibility of an operating system can often only be utilized by dropping down below the user friendly desktop interface and using a shell environment. Moreover, familiarity with the shell is a necessity when required to administer and maintain server-based systems that do not have the desktop installed or when attempting to repair a system that is damaged to the point that the desktop or Cockpit interface will no longer launch.</p>&#13;
			<p class="My-Basic-Paragraph">The capabilities of the shell go far beyond the areas covered in this chapter. If you are new to the shell then we strongly encourage you to seek out additional resources. Once familiar with the concepts you will quickly find that it is quicker to perform many tasks using the shell in a terminal window than it is to wade through menus and dialogs on the desktop.</p>&#13;
		</div>&#13;
</div>



  </body></html>