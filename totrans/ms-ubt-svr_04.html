<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer068">
<h1 class="chapterNumber">4</h1>
<h1 class="chapterTitle" id="_idParaDest-74">Navigating and Essential Commands</h1>
<p class="normal">At this point in our journey, we’ve already covered a lot of ground—we’ve learned how to deploy an Ubuntu server, how to manage users, and most recently, how to manage software packages. Before we go too far, we should take a moment to learn some important concepts and commands that will allow us to build more of the foundational knowledge that will serve us well for the remainder of the book and beyond. These foundational concepts include core Linux commands for navigating the shell, the Linux filesystem layout, viewing the contents of files, and even checking on log files. Specifically, this discussion will include:</p>
<ul>
<li class="bulletList">Learning essential Linux commands</li>
<li class="bulletList">Understanding the Linux filesystem layout</li>
<li class="bulletList">Viewing the contents of files</li>
<li class="bulletList">Viewing application log files</li>
</ul>
<p class="normal">Let’s take some time to learn some essential Linux commands that will help strengthen our command-line skills.</p>
<h1 class="heading-1" id="_idParaDest-75">Learning essential Linux commands</h1>
<p class="normal">Building a solid<a id="_idIndexMarker218"/> competency on the command line is essential and effectively gives any system administrator or engineer superpowers. Our new abilities won’t allow us to leap tall buildings in a single bound but will definitely enable us to execute terminal commands as if we’re command-line ninjas. While we won’t completely master the art of using the command line in this section (that can only come with years and experience), we will definitely become more confident.</p>
<p class="normal">First, let’s talk about moving from one place to another within the Linux filesystem. Specifically, by “Linux filesystem,” I’m referring to the default structure of the various folders (also referred to as “directories”) contained within your Ubuntu installation. The Linux filesystem contains many important directories, each with its own designated purpose, which we’ll talk about in more detail later in this chapter. </p>
<p class="normal">Before we can explore that further, we’ll need to learn how to navigate from one directory to another. The first command we’ll cover in this section relative to navigating the filesystem will clarify the directory you’re currently working from. For that, we have the <code class="inlineCode">pwd</code> command. This stands <a id="_idIndexMarker219"/>for <strong class="keyWord">print working directory</strong> and shows you where you currently are in the filesystem. If <a id="_idIndexMarker220"/>you run it, you may see output such as this:</p>
<figure class="mediaobject"><img alt="" height="147" src="../Images/B18425_04_01.png" width="525"/></figure>
<p class="packt_figref">Figure 4.1: Viewing the current working directory</p>
<p class="normal">In this example, when I ran <code class="inlineCode">pwd</code>, the output informed me that my current working directory is <code class="inlineCode">/home/jay</code>. This is known as your home directory and, by default, every user has one (as we discussed in <em class="chapterRef">Chapter 2</em>, <em class="italic">Managing Users and Permissions</em>). This is where all the files for your user account will reside by default. Sure, you can create files anywhere you’d like, even outside your home directory if you have permission to do so or you use <code class="inlineCode">sudo</code>. But just because you <em class="italic">can</em> doesn’t mean you <em class="italic">should</em>. As you’ll learn in this chapter, the Linux filesystem has a designated place for just about everything. But your home directory, located at <code class="inlineCode">/home/&lt;username&gt;</code>, is yours. You own it, you control it—it’s your home on the server. In the early 2000s, Linux installations with a graphical user interface even depicted your home directory with an icon of a house.</p>
<p class="normal">Typically, files that you create in your home directory will have permission strings similar to this:</p>
<pre class="programlisting con"><code class="hljs-con">-rw-rw-r-- 1 jay  jay      0 Jul  5 14:10 testfile.txt
</code></pre>
<p class="normal">We’ve discussed permissions and gone over how to read a permission string in <em class="chapterRef">Chapter 2</em>, <em class="italic">Managing Users and Permissions</em>, but you can see that by default, files you create in your home directory are owned by your user, your group, and are readable by all three categories (user, group, and other).</p>
<p class="normal">To change our current directory and navigate to another, we can use the <code class="inlineCode">cd</code> command along with a path we’d like to move to:</p>
<pre class="programlisting con"><code class="hljs-con">cd /etc
</code></pre>
<p class="normal">Now, I haven’t gone over the file and directory layout yet, so I just randomly picked the <code class="inlineCode">/etc</code> directory. The forward slash at the beginning designates the beginning of the filesystem. More on that later. Now, we’re in the <code class="inlineCode">/etc</code> directory, and our command prompt has even<a id="_idIndexMarker221"/> changed as well:</p>
<figure class="mediaobject"><img alt="" height="149" src="../Images/B18425_04_02.png" width="525"/></figure>
<p class="packt_figref">Figure 4.2: Command prompt and pwd command after changing a directory</p>
<p class="normal">As you could probably guess, the <code class="inlineCode">cd</code> command stands for <em class="italic">change directory</em>, and it’s how you move your working directory from one to another while navigating around. You can use the following command, for example, to return back to the home directory:</p>
<pre class="programlisting con"><code class="hljs-con">cd /home/&lt;user&gt;
</code></pre>
<p class="normal">In fact, there are several ways to return home, a few of which are demonstrated in the following screenshot:</p>
<figure class="mediaobject"><img alt="" height="318" src="../Images/B18425_04_03.png" width="668"/></figure>
<p class="packt_figref">Figure 4.3: Other ways of navigating to the home directory</p>
<p class="normal">The first command, <code class="inlineCode">cd -</code>, doesn’t actually have anything to do with your home directory specifically. It’s a neat<a id="_idIndexMarker222"/> trick to return you to whatever directory you were in most recently. For me, the <code class="inlineCode">cd –</code> command took me to the previous directory I was in, which just so happened to be <code class="inlineCode">/home/jay</code>. The second command, <code class="inlineCode">cd /home/jay</code>, took me directly to my home directory since I called out the entire path. The last command, <code class="inlineCode">cd ~</code>, also took me to my home directory. This is because <code class="inlineCode">~</code> is shorthand for the full path to your home directory, so you don’t really ever have to type out the entire path to <code class="inlineCode">/home/&lt;user&gt;</code>. You can just refer to that path simply as <code class="inlineCode">~</code>.</p>
<p class="normal">Another essential command is <code class="inlineCode">ls</code>. The <code class="inlineCode">ls</code> command lists the contents of the current working directory. We probably don’t have any content in our home directory yet. But if we navigate to <code class="inlineCode">/etc</code> by running <code class="inlineCode">cd /etc</code>, as we did earlier, and then execute <code class="inlineCode">ls</code>, we’ll see that the <code class="inlineCode">/etc</code> directory has a number of files in it. Go ahead and try it yourself and see:</p>
<pre class="programlisting con"><code class="hljs-con">cd /etc
ls
</code></pre>
<p class="normal">We didn’t actually have to change our working directory to <code class="inlineCode">/etc</code> just to list the contents. We could’ve just executed the following command:</p>
<pre class="programlisting con"><code class="hljs-con">ls /etc
</code></pre>
<p class="normal">Even better, we can run:</p>
<pre class="programlisting con"><code class="hljs-con">ls -l /etc
</code></pre>
<p class="normal">This gives us the contents in a long list, which I think is much easier to understand. It will show each directory or file entry on its own line, along with the permission string. But, you probably already remember <code class="inlineCode">ls</code> as well as <code class="inlineCode">ls -l</code> from back in <em class="chapterRef">Chapter 2</em>, <em class="italic">Managing Users and Permissions</em>, so I won’t go into too much more detail here. The <code class="inlineCode">-l</code> portion of the <code class="inlineCode">ls</code> command in that example is known<a id="_idIndexMarker223"/> as an <strong class="keyWord">argument</strong>. I’m not referring to an argument such as the ever-ensuing debate in the Linux community over which command-line text editor is the best between Vim and Emacs (it’s clearly Vim). Instead, I’m referring to the concept of an argument in shell commands that allow you to override the defaults, or feed options to the command in some way, such as in this example, where we format the output of <code class="inlineCode">ls</code> to be in a long list.</p>
<p class="normal">The <code class="inlineCode">rm</code> command is another one that we touched on in <em class="chapterRef">Chapter 2</em>, <em class="italic">Managing Users and Permissions</em>, when we were discussing manually removing the home directory of a user that was removed from the system. So, at this point, you’re probably well aware of that command and what it does (it removes files and directories). It’s a potentially dangerous command, as you <a id="_idIndexMarker224"/>could use it to accidentally remove something that you shouldn’t have. In that chapter, we used the following command to remove the home directory of user <code class="inlineCode">dscully</code>:</p>
<pre class="programlisting con"><code class="hljs-con">rm -r /home/dscully
</code></pre>
<p class="normal">As you can see, we’re using the <code class="inlineCode">-r</code> argument to alter the behavior of the <code class="inlineCode">rm</code> command, which, by default, doesn’t remove directories but only files. The <code class="inlineCode">-r</code> argument instructs <code class="inlineCode">rm</code> to remove everything recursively, even if it’s a directory. The <code class="inlineCode">-r</code> argument will also remove subdirectories of the path as well, so you’ll definitely want to be careful with this command. As I’ve mentioned earlier in the book, if you use <code class="inlineCode">sudo</code> with <code class="inlineCode">rm</code>, you can hypothetically delete your entire Ubuntu installation!</p>
<p class="normal">Another option offered by <code class="inlineCode">rm</code> is the <code class="inlineCode">-f</code> argument, which is short for <em class="italic">force</em>, and it tells <code class="inlineCode">rm</code> not to prompt before removing things. This argument won’t be needed as often, and use cases for it are outside the scope of this chapter. But keep in mind that it exists, should you need it.</p>
<p class="normal">Another foundational command that’s good to know is <code class="inlineCode">touch</code>, which actually serves two purposes. First, assuming you have permission to do so in your current working directory, the <code class="inlineCode">touch</code> command will create an empty file if it doesn’t already exist. Second, the <code class="inlineCode">touch</code> command will update the modification time of a file or directory if it does already exist:</p>
<figure class="mediaobject"><img alt="" height="296" src="../Images/B18425_04_04.png" width="825"/></figure>
<p class="packt_figref">Figure 4.4: Experimenting with the touch command</p>
<p class="normal">To illustrate this, in<a id="_idIndexMarker225"/> the related screenshot, I ran several commands. First, I ran the following command to create an empty file:</p>
<pre class="programlisting con"><code class="hljs-con">touch testfile.txt
</code></pre>
<p class="normal">That file didn’t exist before, so when I ran <code class="inlineCode">ls -l </code>afterward, it showed the newly created file with a size of 0 bytes. Next, I ran the <code class="inlineCode">touch testfile.txt</code> command again a minute later, and you can see in the screenshot that the modification time went from <code class="inlineCode">15:12</code> to <code class="inlineCode">15:13</code>.</p>
<p class="normal">When it comes to viewing the contents of a file, we’ll get to that later on in this chapter. And there are definitely more commands that we’ll need to learn to build the basis of our foundation. But for now, let’s take a break from the foundational concepts to understand the Linux filesystem layout better, which is pretty much mandatory for some of the commands we’ll learn later.</p>
<h1 class="heading-1" id="_idParaDest-76">Understanding the Linux filesystem layout</h1>
<p class="normal">As I mentioned<a id="_idIndexMarker226"/> earlier, every directory in a Linux installation has a designated purpose. It isn’t a hard rule that you have to follow, more of a strong recommendation for where certain things are supposed to go.</p>
<p class="normal">You can certainly go against the recommendations; ultimately, you have full control over your installation. But, if you make it a habit to place files in strange locations, you may annoy your colleagues. In this section, we’ll go over the most common directories and talk about their purpose.</p>
<p class="normal">The term <em class="italic">filesystem</em> itself can be somewhat confusing in the Linux world because it can refer to two different things—the default directory structure, as well as the actual filesystem we choose when formatting a volume such as a hard drive or flash drive (ext4, XFS, and so on). Specific to this section, we’re going to take a quick look at the Linux filesystem in the context of the default directory structure.</p>
<p class="normal">In Linux (Ubuntu uses the Linux kernel and related utilities, so therefore it is a <em class="italic">distribution</em> of Linux), the filesystem begins with a single forward slash, <code class="inlineCode">/</code>. This is considered the beginning of the filesystem, and directories and sub-directories branch out from there. For example, consider the <code class="inlineCode">/home</code> directory. This directory exists at the root level of the filesystem, which you can see from the fact that it begins with a forward slash. The home directory on my system is <code class="inlineCode">/home/jay</code>, which means that it’s the <code class="inlineCode">jay</code> directory, which is inside the <code class="inlineCode">home</code> directory, and that directory is at the beginning of the filesystem.</p>
<p class="normal">This is confusing at first but becomes very logical once you become accustomed to it. If you’re familiar with Microsoft Windows, then you can technically think of <code class="inlineCode">/</code> as the <code class="inlineCode">C:</code> drive. It’s actually a bit more complex than that, but if we forego some of the quirks, that comparison works. To really bring this home, use the <code class="inlineCode">ls</code> command against several directories on your server. If you execute <code class="inlineCode">ls /</code>, you will see all of the directories at the root of the filesystem. </p>
<p class="normal">You’ll see the <code class="inlineCode">home</code> directory among the results, among many others. For those of you who prefer a more visual representation, the following screenshot shows an example filesystem:</p>
<figure class="mediaobject"><img alt="Diagram  Description automatically generated" height="368" src="../Images/B18425_04_05.png" width="530"/></figure>
<p class="packt_figref">Figure 4.5: Diagram of a portion of a typical Linux filesystem</p>
<p class="normal">As you can see, the Linux filesystem resembles a tree, with a main branch that extends outward and directories branch out from one another. This default directory structure is part of <a id="_idIndexMarker227"/>the <strong class="keyWord">Filesystem Hierarchy Standard</strong> (<strong class="keyWord">FHS</strong>), which is a set of guidelines that defines how the directory<a id="_idIndexMarker228"/> structure is laid out. This specification defines the names of the directories, where they are located, and what they are for. Distributions will sometimes go against some of the definitions here, but for the most part, follow it fairly closely. This is why you may see a very similar (if not the same) directory structure on distributions of Linux other than Ubuntu.</p>
<p class="normal">So, why is this important? As I mentioned, each directory generally has a purpose. There are some debates about the default layout from time to time, and some changes are made every now and then. But in regard to Linux, the filesystem layout tends to change less frequently than other things do.</p>
<p class="normal">A full walkthrough of the FHS would be astronomical, but I have included a link to this specification at the end of the chapter should you decide to read more about it. There are some directories you definitely should know, however. Here are some of the more important ones.</p>
<table class="table-container" id="table001-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Directory</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Purpose</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/</code></p>
</td>
<td class="table-cell">
<p class="normal">The beginning of the filesystem; all directories are underneath this</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/etc</code></p>
</td>
<td class="table-cell">
<p class="normal">System-wide application configuration</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/home</code></p>
</td>
<td class="table-cell">
<p class="normal">User home directories</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/root</code></p>
</td>
<td class="table-cell">
<p class="normal">The home directory for root (root doesn’t have a directory under /home)</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/media</code></p>
</td>
<td class="table-cell">
<p class="normal">For removable media, such as flash drives</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/mnt</code></p>
</td>
<td class="table-cell">
<p class="normal">For volumes that are intended to stay mounted for a while</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/opt</code></p>
</td>
<td class="table-cell">
<p class="normal">Additional software packages (some programs are installed here, not as common)</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/bin</code></p>
</td>
<td class="table-cell">
<p class="normal">Essential user binaries (ls, cp, and so on)</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/proc</code></p>
</td>
<td class="table-cell">
<p class="normal">Virtual filesystem for OS-level components</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/usr/bin</code></p>
</td>
<td class="table-cell">
<p class="normal">A majority of user commands</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/usr/lib</code></p>
</td>
<td class="table-cell">
<p class="normal">Libraries</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">/var/log</code></p>
</td>
<td class="table-cell">
<p class="normal">Log files</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The <code class="inlineCode">/etc</code> directory <a id="_idIndexMarker229"/>deserves some additional discussion, as you’ll no doubt be working with it a lot. This directory, as mentioned in the preceding table, holds configuration files for applications that are intended to be respected system-wide. For example, if you’re running the OpenSSH daemon on your server, you’re listening for connections via port 22 by default. (Don’t worry, we’ll discuss these individual concepts in further chapters.) The configuration file for the OpenSSH server is located in the <code class="inlineCode">/etc/ssh</code> directory. Since OpenSSH is a service that runs on the system as a background process, its configuration is stored in the <code class="inlineCode">sshd_config</code> file inside that directory. If you remove the package responsible for providing OpenSSH, the configuration is retained in that file (removing packages doesn’t also remove config files by default), so if you go to reinstall OpenSSH later, you’ll have the same configuration the next time. If we want to wipe out the configuration while uninstalling a package, we can use the <code class="inlineCode">--purge</code> option with the <code class="inlineCode">apt remove</code> command to do so, as we saw in <em class="chapterRef">Chapter 3</em>, <em class="italic">Managing Software Packages</em>.</p>
<p class="normal">Other directories of importance will be discussed as we progress through the topics in this book. Don’t worry if some of this doesn’t make sense right now; it will come with time. The main point here is that there are many directories, each having its own purpose. If you want to know the purpose of a particular directory, consult the FHS. If you’re curious where you should place something on a server, also consult the FHS. But again, don’t worry too much about doing research outside of this book, as we’ll cover the necessary topics as we go along.</p>
<p class="normal">We now have a better understanding of the default filesystem layout and the purpose of some common <a id="_idIndexMarker230"/>directories. In the next section, we’ll explore how we can view the contents of files stored in those directories.</p>
<h1 class="heading-1" id="_idParaDest-77">Viewing the contents of files</h1>
<p class="normal">The Linux <a id="_idIndexMarker231"/>filesystem<a id="_idIndexMarker232"/> contains many directories and files. In the case of files, we need to learn how to read and manipulate them to round out our knowledge. We’ll cover more topics surrounding file management in the next chapter. For now, we can benefit by taking a look at how to view the content of existing files.</p>
<p class="normal">We can print the contents of a file to the screen with the <code class="inlineCode">cat</code> command, along with a filename as an argument. The following command, for example, can be used to view the contents of <code class="inlineCode">testfile.txt</code> in our current working directory, which we created earlier in the chapter when we discussed the <code class="inlineCode">touch</code> command. Sure, this exercise is rather pointless since that file is empty, but it offers a good first example:</p>
<pre class="programlisting con"><code class="hljs-con">cat testfile.txt
</code></pre>
<p class="normal">There’s no output, since again, the file is empty. So, let’s instead take a look at a more practical example. Here’s a file we can use <code class="inlineCode">cat</code> against that actually does have content inside:</p>
<pre class="programlisting con"><code class="hljs-con">cat /etc/os-release
</code></pre>
<p class="normal">The output of this command is as follows:</p>
<figure class="mediaobject"><img alt="" height="364" src="../Images/B18425_04_06.png" width="876"/></figure>
<p class="packt_figref">Figure 4.6: Viewing the contents of /etc/os-release</p>
<p class="normal">The <code class="inlineCode">/etc/os-release</code> file is one that exists on many distributions. It’s a special file that gives you some information about the distribution of Linux that’s currently installed. If you were to connect to a Linux server and wanted to know which distribution it was running, viewing the contents of this file is one way to find out. You can also view some of the same <a id="_idIndexMarker233"/>info <a id="_idIndexMarker234"/>in abbreviated form via the following command:</p>
<pre class="programlisting con"><code class="hljs-con">lsb_release -a
</code></pre>
<p class="normal">That command also works on various distributions, but I prefer the <code class="inlineCode">/etc/os-release</code> file because it contains more information. Regardless, the entire point of this exercise is to demonstrate that the <code class="inlineCode">cat</code> command allows you to view the contents of a file. More or less, there are other commands that also let you do the same thing. And I mean that literally—you can also try viewing the contents of <code class="inlineCode">/etc/os-release</code> with <code class="inlineCode">more</code> or <code class="inlineCode">less</code>:</p>
<pre class="programlisting con"><code class="hljs-con">more /etc/os-release
less /etc/os-release
</code></pre>
<p class="normal">The <code class="inlineCode">more</code> command allows you to more easily view larger files, so the benefit won’t be as immediately apparent with a file as short as <code class="inlineCode">/etc/os-release</code>. If you use <code class="inlineCode">more</code> to view a longer file, it will stop the output when it fills the screen, and allow you to press <em class="keystroke">Enter</em> to advance to the next line.</p>
<p class="normal">The <code class="inlineCode">less</code> command allows you to do the same thing, but also allows you to not only use your arrow keys in addition to <em class="keystroke">Enter</em> to view more output; it also allows you to advance forward or backward as well. So essentially, the <code class="inlineCode">less</code> command gives you more features than the <code class="inlineCode">more</code> command does.</p>
<p class="normal">In addition, we also have the <code class="inlineCode">grep</code> command at our disposal. It’s not typically used to simply view the contents of a file, but it’s definitely a great command to know that can help you view specifically what you want to view, rather than the entire file.</p>
<p class="normal">If you chose to install the OpenSSH server when you first installed Ubuntu Server, you should have the config file for it in your installation, and you can view the contents of that file with <code class="inlineCode">cat</code> as we normally would:</p>
<pre class="programlisting con"><code class="hljs-con">cat /etc/ssh/sshd_config
</code></pre>
<p class="normal">Of course, that’s going to dump the contents of that file onto our screen, and the file is many more lines than what the typical monitor is able to display all at once. We might be interested in a particular line or word, so we’ll need to be able to narrow down the file to what we actually care about. We’ll talk about the OpenSSH server in more detail in <em class="chapterRef">Chapter 10</em>, <em class="italic">Connecting to Networks</em>, so don’t worry about what this configuration file means yet. Let’s just say, hypothetically, we’re only interested in the port that OpenSSH is listening on. We <a id="_idIndexMarker235"/>can <a id="_idIndexMarker236"/>use the <code class="inlineCode">grep</code> command to try and print only the lines of the <code class="inlineCode">/etc/ssh/sshd_config</code> file that pertain to that specific configuration:</p>
<pre class="programlisting con"><code class="hljs-con">grep Port /etc/ssh/sshd_config
</code></pre>
<p class="normal">This command will produce the following output:</p>
<figure class="mediaobject"><img alt="" height="138" src="../Images/B18425_04_07.png" width="654"/></figure>
<p class="packt_figref">Figure 4.7: Viewing the contents of the /etc/ssh/sshd_config file with grep to find lines containing “Port”</p>
<p class="normal">Essentially, what we’re doing is instructing <code class="inlineCode">grep</code> to print only the lines of the <code class="inlineCode">/etc/ssh/sshd_config</code> file that contain the string <code class="inlineCode">Port</code>. In the screenshot, a single line contained a match for that string, so it displayed. That output is certainly better than scrolling through the 123 lines of text in the file, when we’re only interested in lines pertaining to the port.</p>
<p class="normal">By default, <code class="inlineCode">grep</code> is case-sensitive. This means that if we were to use <code class="inlineCode">grep</code> to find lines matching “port” (with a lowercase P), we would get no output at all. We can simply add the <code class="inlineCode">-i</code> argument to make the search case-insensitive.</p>
<p class="normal">It’s very common to see the <code class="inlineCode">grep</code> command paired with another command, such as <code class="inlineCode">cat</code>:</p>
<pre class="programlisting con"><code class="hljs-con">cat /etc/ssh/sshd_config | grep Port
</code></pre>
<p class="normal">That’s a perfectly valid command and will do the same thing. However, it’s fairly redundant. We’ll get into the concept of redirecting output in the next chapter, but essentially this command takes the output of the <code class="inlineCode">cat</code> command and redirects it as input to the <code class="inlineCode">grep</code> command. Using <code class="inlineCode">cat</code> to first print out the file and then have <code class="inlineCode">grep</code> grab the contents of that file and search it for a string is a two-step process where only one step is required. But again, it’s still a valid command. </p>
<p class="normal">To this day, I’ll personally use the <code class="inlineCode">cat</code> command with <code class="inlineCode">grep</code> to do the same thing out of habit, as this was how all new Linux users were taught back when I started. You’ll even see me do this in my YouTube videos—old habits are hard to break!</p>
<p class="normal">Log files are a great <a id="_idIndexMarker237"/>source<a id="_idIndexMarker238"/> of information about what’s going on in the background of your server, and are especially useful for troubleshooting. We’ll now transition into a discussion on viewing these files and some relevant commands pertaining to logging.</p>
<h1 class="heading-1" id="_idParaDest-78">Viewing application log files</h1>
<p class="normal">In the last section of <a id="_idIndexMarker239"/>this chapter, let’s explore log files a bit, as they bring several concepts that we’ve discussed full circle. We went through an overview of the default directory layout, practiced viewing files, and we learned how to search files for strings. We’ll discuss log files in greater detail later on in the book, but we can use all of these concepts to take an initial look at viewing log files now.</p>
<p class="normal">If you recall, during the discussion of the Linux filesystem layout earlier in this chapter, there was a table showing some of the most common directories that exist. Among the items in that table, I called out the <code class="inlineCode">/var/log</code> directory. While logging is transitioning to a different style (more on that in <em class="chapterRef">Chapter 22</em>, <em class="italic">Troubleshooting Ubuntu Servers</em>), we’ll have a series of logs in the <code class="inlineCode">/var/log</code> directory. Go ahead and use the <code class="inlineCode">ls</code> command yourself, and you’ll see there are quite a few files there. While I won’t go through all of them in this chapter, let’s take a look at <code class="inlineCode">/var/log/syslog</code>.</p>
<p class="normal">The content of this file is going to have quite a few lines. This is the system log, which is used to view informational messages about what’s going on in the background as Ubuntu runs on your server, and will show warnings and errors as well. If you run into a problem where something isn’t working quite right, you may see output in the system log that will provide you with some sort of error you can look up in a search engine so you can try and find a resolution. For example, you can use <code class="inlineCode">grep</code> to view any lines that contain the search term <em class="italic">Network</em> if you’re having issues with your connection:</p>
<pre class="programlisting con"><code class="hljs-con">grep Network /var/log/syslog
</code></pre>
<p class="normal">That’s just a hypothetical example, but it may show lines that are relevant. Adjust your search term to whatever you’re interested in finding.</p>
<p class="normal">This is also a good<a id="_idIndexMarker240"/> time to introduce you to the <code class="inlineCode">head</code> and <code class="inlineCode">tail</code> commands. These commands will show the first ten or last ten lines of a file, respectively. This is useful for the <code class="inlineCode">/var/log/syslog</code> file because again, that file is quite large, and you may only be interested in certain lines. You can also adjust the number of lines the <code class="inlineCode">head</code> and <code class="inlineCode">tail</code> commands show with the <code class="inlineCode">-n</code> option with a desired number of lines. For example, to view the last <code class="inlineCode">100</code> lines of a file:</p>
<pre class="programlisting con"><code class="hljs-con">tail -n 100 /var/log/syslog
</code></pre>
<p class="normal">Perhaps even more useful is the <code class="inlineCode">-f</code> option:</p>
<pre class="programlisting con"><code class="hljs-con">tail -f /var/log/syslog
</code></pre>
<p class="normal">This allows you to follow (watch) a file in (almost) real time. With the <code class="inlineCode">-f</code> option, the terminal will continue to display new lines in this file as they’re appended, so you can monitor the log file as someone attempts to reproduce a problem, for example. You can press <em class="keystroke">Ctrl </em>+ <em class="keystroke">c</em> on your keyboard to break out of the follow mode and return back to the command prompt.</p>
<p class="normal">Of course, there are many more foundational commands and concepts that we can go over, but I think that this is enough for now. In the next chapter, we’ll expand on this further. But for now, I recommend you practice all of the concepts in this chapter until you’re familiar with<a id="_idIndexMarker241"/> them before we go on.</p>
<h1 class="heading-1" id="_idParaDest-79">Summary</h1>
<p class="normal">There are more Linux commands than you’ll ever be able to memorize. Most of us just memorize our favorite commands and variations of commands, and you’ll develop your own menu of these commands as you learn and expand your knowledge. In this chapter, we covered many of the foundational commands that are, for the most part, essential. Commands such as <code class="inlineCode">grep</code>, <code class="inlineCode">cat</code>, <code class="inlineCode">cd</code>, <code class="inlineCode">ls</code>, and others were explored this time around. The next chapter is essentially a continuation of this one, but I wanted to split the foundational concepts into two chapters rather than one enormous one.</p>
<p class="normal">In the next chapter, we’ll expand our foundational knowledge with a deeper look at file management, including editing files, input/output streams, and symbolic links, and we’ll even reveal the secret to life itself. Well, maybe not the latter, but the next chapter will still be great. See you there!</p>
<h1 class="heading-1" id="_idParaDest-80">Relevant video</h1>
<ul>
<li class="bulletList">Linux Crash Course – Navigating the Linux Filesystem (LearnLinuxTV): <a href="https://linux.video/lcc-navigating"><span class="url">https://linux.video/lcc-navigating</span></a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-81">Further reading</h1>
<ul>
<li class="bulletList">Filesystem Hierarchy Standard: <a href="https://learnlinux.link/fhs-doc"><span class="url">https://learnlinux.link/fhs-doc</span></a></li>
<li class="bulletList">UsingTheTerminal: <a href="https://learnlinux.link/using-term"><span class="url">https://learnlinux.link/using-term</span></a></li>
</ul>
<h1 class="heading-1">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers: </p>
<p class="normal"><a href="https://packt.link/LWaZ0"><span class="url">https://packt.link/LWaZ0</span></a></p>
<p class="normal"><img alt="" height="177" src="../Images/QR_Code50046724-1955875156.png" width="177"/></p>
</div>
</div></body></html>