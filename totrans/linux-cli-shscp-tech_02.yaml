- en: '*Chapter 2*: Using Text Editors'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 2 章*：使用文本编辑器'
- en: There's just no way around the topic of this chapter, as system administrators
    edit `gedit`, although we won't cover that editor here as it's practically the
    same as using Notepad on Microsoft Windows. There are various reasons why these
    **editors** were chosen, but most importantly, they are installed out of the box
    on almost all Linux distributions, so they're the most common pre-installed editors.
    There are situations where additional software installation is not an option,
    such as *air-gapped* environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题是无法绕开的，因为系统管理员会编辑 `gedit`，尽管我们不会在这里介绍该编辑器，因为它几乎与在 Microsoft Windows 上使用记事本一样。选择这些
    **编辑器** 的原因有很多，但最重要的是，它们几乎都预装在所有 Linux 发行版中，因此它们是最常见的预安装编辑器。有些情况下无法安装额外的软件，比如
    *隔离* 环境。
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将覆盖以下食谱：
- en: Learning the basics of the Vi(m) editor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 Vi(m) 编辑器的基础
- en: Learning the basics of the nano editor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 nano 编辑器的基础
- en: Going through the advanced Vi(m) settings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览高级 Vi(m) 设置
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For these recipes, we''re going to use a Linux machine. We can use any virtual
    machine from our previous recipe. For example, let''s say that we''re going to
    use a `cli1` virtual machine as it''s the most convenient to use, seeing as it''s
    a command-line-interface-only machine. So, all in all, we need the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些食谱，我们将使用一台 Linux 机器。我们可以使用之前食谱中的任何虚拟机。例如，假设我们将使用 `cli1` 虚拟机，因为它最方便使用，毕竟它只是一个命令行界面（CLI）机器。所以，总的来说，我们需要以下内容：
- en: A virtual machine with any distribution of Linux installed (in our case, it's
    going to be *Ubuntu 20.10*).
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了任何 Linux 发行版的虚拟机（在我们的例子中，它将是 *Ubuntu 20.10*）。
- en: A bit of time to digest the complexities of using the Vi(m) editor. nano is
    less complex; therefore, it's going to be easier to learn about that one.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花些时间消化使用 Vi(m) 编辑器的复杂性。相比之下，nano 更简单，因此学习它会更容易一些。
- en: So, start your virtual machine and let's get cracking!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，启动你的虚拟机，让我们开始吧！
- en: Learning the basics of the Vi(m) Editor
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 Vi(m) 编辑器的基础
- en: Vi and Vim are *the text editors* of choice for many system administrators and
    engineers. In a nutshell, the difference between them is that **vim** (**vi improved**)
    has many more capabilities than the original vi (visual editor). You can find
    these editors everywhere – from all the Unixes and Linuxes to the commercial Linux-
    or Unix-based software of today. For example, VMware's *vSphere Hypervisor* has
    a version of the vi editor built in. The rationale for this is simple – you need
    to have some sort of *standardized editor* that can be used to edit various text
    files available on a filesystem. Over the years, you'll surely find some cutdown
    version of vi or Vim on various network devices such as switches and routers,
    and even more complex devices like firewalls. It's just the way it is. If something's
    Unix- or Linux-based, chances are it's using text configuration files, and text
    configuration files need a text editor. Pretty straightforward logic, isn't it?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Vi 和 Vim 是许多系统管理员和工程师的 *首选文本编辑器*。简而言之，它们的区别在于，**vim**（**vi 改进版**）拥有比原始的 vi（可视化编辑器）更多的功能。你可以在任何地方找到这些编辑器——从所有的
    Unix 和 Linux 到当今的商业 Linux 或 Unix 基础软件。例如，VMware 的 *vSphere Hypervisor* 就内置了 vi
    编辑器的一个版本。这样做的理由很简单——你需要有某种 *标准化编辑器*，可以用来编辑文件系统上各种文本文件。多年来，你肯定会在各种网络设备上找到简化版的 vi
    或 Vim，比如交换机、路由器，甚至是更复杂的设备如防火墙。就是这样。如果某个东西是基于 Unix 或 Linux 的，那么它很可能会使用文本配置文件，而文本配置文件需要一个文本编辑器。这是非常直接的逻辑，不是吗？
- en: Just as an example – the Vim editor has spinoffs that can be used in a variety
    of different ways, including **vim-athena** (created with *Athena GUI* support),
    **vim-gtk**, and **vim-gtk3** (created with *GTK/GTK3* support), **vim-tiny**
    (a slimmed-down version of Vim), and **vim-nox**. But still, most people that
    we know of prefer using the good old-fashioned vi or Vim in a CLI.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个例子来说——Vim 编辑器有许多衍生版本，可以用不同的方式使用，包括 **vim-athena**（支持 *Athena GUI*）、**vim-gtk**
    和 **vim-gtk3**（支持 *GTK/GTK3*）、**vim-tiny**（精简版的 Vim）、以及 **vim-nox**。不过，仍然大多数我们所知道的人更喜欢在命令行界面（CLI）中使用传统的
    vi 或 Vim。
- en: 'For this first part of our recipe, we''re going to explain the way vi and Vim
    work and use them to do some most common things, such as the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们食谱的第一部分，我们将解释 vi 和 Vim 的工作方式，并用它们完成一些常见的操作，比如以下几项：
- en: Three `vi(m)` modes – `insert`, `command`, and `ex` mode
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三种 `vi(m)` 模式——`插入`、`命令` 和 `ex` 模式
- en: Moving around a text file that we want to edit by moving the cursor
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们想要编辑的文本文件中移动光标
- en: Deleting text (we could refer to it as *cutting* and *deleting* at the same
    time)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文本（我们可以称之为 *剪切* 和 *删除* 同时进行）
- en: Inserting additional content into a text file
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向文本文件中插入附加内容
- en: Saving and exiting in the vi(m) editors
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 vi(m) 编辑器中保存并退出
- en: Finding content in a text file
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文本文件中查找内容
- en: Copying and pasting text (what vi and Vim refer to as *yank* and *paste*)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制和粘贴文本（vi 和 Vim 称之为 *yank* 和 *paste*）
- en: That's going to be enough for this first recipe. We're going to go back to the
    **advanced vim capabilities** in the last recipe of this chapter, where we're
    going to dig much deeper into Vim and learn how to use much more advanced concepts,
    such as using regular expressions, line marking, buffers, and sorting.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这对第一个示例来说已经足够了。我们将在本章最后一个食谱中回到 **高级 vim 功能**，深入研究 Vim，学习如何使用更高级的概念，如正则表达式、行标记、缓冲区和排序。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We just need to check whether vi and Vim are installed on our system. The simplest
    way to do it is to just go brute-force and issue the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要检查一下 vi 和 Vim 是否已经安装在系统中。最简单的方法就是直接执行以下命令：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Ubuntu doesn''t have or use the vi editor by default, so we can just install
    the `Vim-tiny` package to kind of emulate the same thing. Another way to use the
    vi editor in Ubuntu would be to use the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ubuntu 并不自带或使用 vi 编辑器，所以我们可以安装 `Vim-tiny` 包来模拟类似的功能。另一种在 Ubuntu 中使用 vi
    编辑器的方法是使用以下命令：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Seeing that `busybox` is a command-line tool that *embeds* multiple Linux command-line
    utilities into one, this command is something that we need to be aware of. But
    also, we need to remember that the intent of `busybox` is to have a way to embed
    multiple popular CLI tools into one, which in turn means that none of these tools
    are completely the same as their standalone versions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`busybox` 是一款将多个 Linux 命令行工具 *嵌入* 到一个工具中的命令行工具，因此这个命令是我们需要关注的内容。同时，我们还需要记住，`busybox`
    的目的是将多个流行的 CLI 工具嵌入一个工具中，这意味着这些工具都与它们的独立版本有所不同。'
- en: 'After installation is done (if needed at all), we''re going to start using
    Vim and learn how to use it via examples. Let''s issue the following commands
    as `root`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后（如果需要安装的话），我们将开始使用 Vim，并通过示例学习如何使用它。作为 `root` 用户，让我们执行以下命令：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Take note of the fact that between `cp`, `/etc/passwd`, and `/root` (the same
    thing applies to `cp`, `/usr/share/dict/words`, and `/root` in the second command),
    we need to hit *the spacebar* on our keyboard. We're effectively copying the `passwd`
    and `words` files to the `/root` directory to have some source files to play with.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 `cp`、`/etc/passwd` 和 `/root` 之间（第二个命令中的 `cp`、`/usr/share/dict/words` 和
    `/root` 也适用），我们需要按下 *空格键*。我们实际上是在将 `passwd` 和 `words` 文件复制到 `/root` 目录，以便获得一些源文件进行操作。
- en: 'When we have successfully finished copying these files, we''ll start the Vim
    editor and start editing. First, we''re going to use the `passwd` file. Type in
    the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们成功复制了这些文件后，我们将启动 Vim 编辑器并开始编辑。首先，我们将使用 `passwd` 文件。输入以下内容：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's start learning!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 开始学习吧！
- en: How to do it…
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Now that we have the `/root/passwd` file opened in our Vim editor, let's play
    with it a bit. Moving around in normal mode is straightforward. Let's just start
    by using the arrow keys on our keyboard to move up and down and left and right.
    After we're done with that, let's just jump to the top of our file by using the
    *gg* sequence (by pressing the *g* key twice).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在 Vim 编辑器中打开了 `/root/passwd` 文件，让我们试着在其中进行操作。在普通模式下，移动光标很简单。我们可以通过键盘上的箭头键向上、向下、向左或向右移动。完成后，让我们通过按
    *gg*（两次按 *g* 键）跳到文件的顶部。
- en: 'First, we''re going to delete the first line. Vi(m) starts in something called
    *normal* mode, and if we press the *d* key twice, we''re going to delete the first
    line. Let''s check the before state:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将删除第一行。Vi(m) 编辑器默认启动在 *普通* 模式，如果我们按两次 *d* 键，就会删除第一行。让我们查看一下删除前的状态：
- en: '![Figure 2.1 – The top section of the /root/passwd file'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – /root/passwd 文件的顶部部分'
- en: '](img/Figure_2.1_B16269.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.1_B16269.jpg)'
- en: Figure 2.1 – The top section of the /root/passwd file
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – /root/passwd 文件的顶部部分
- en: 'And now, after we have pressed the *d* key twice, it should look like this
    (if we are still positioned at the first line, the `root` line):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们按下 *d* 键两次后，应该是这样的效果（如果我们仍然处于第一行，即 `root` 行）：
- en: '![Figure 2.2 – After pressing the d key twice, the first line is gone'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2 – 按下 d 键两次后，第一行已被删除'
- en: '](img/Figure_2.2_B16269.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.2_B16269.jpg)'
- en: Figure 2.2 – After pressing the d key twice, the first line is gone
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 按下 d 键两次后，第一行已被删除
- en: 'Let''s now expand this use case further by pressing (just as an example) the
    *5dd* key sequence. The result should look something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过按下（仅作为示例）*5dd* 键序列进一步扩展这个用例。结果应该是这样的：
- en: '![Figure 2.3 – After the 5dd operation (deleting five lines), we deleted five
    lines after the cursor'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – 执行 5dd 操作（删除五行）后，光标后的五行被删除'
- en: '](img/Figure_2.3_B16269.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.3_B16269.jpg)'
- en: Figure 2.3 – After the 5dd operation (deleting five lines), we deleted five
    lines after the cursor
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 执行 5dd 操作（删除五行）后，光标后的五行被删除
- en: As we can see, the first five lines after our cursor (the lines starting with
    `daemon`, `bin`, `sys`, `sync`, and `games`) are gone.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，光标后的前五行（以 `daemon`、`bin`、`sys`、`sync` 和 `games` 开头的行）已经消失。
- en: 'Let''s now jump to the last line in our `/root/passwd` file, and copy and paste
    it behind the last line. First, we need to go to the end of our file, which can
    be achieved by using the *Shift* + *g* sequence (basically, the capital letter
    *G*). After that, if we want to copy the line after the cursor (in effect, complete
    the last line in the file), we need to first yank it (copy) and then paste it
    to a correct spot. Yanking can be achieved by using the *yy* sequence (pressing
    the *y* key twice). That puts the line after our cursor in a copy and paste buffer.
    If we want to paste it after our last line, we need to press the *p* key. Our
    copied line will automatically be pasted after the last line. The end result,
    if we used the same virtual machine as in [*Chapter 1*](B16269_01_Final_PD_ePub.xhtml#_idTextAnchor012)*,
    Basics of Shell and Text Terminal*, should be something like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们跳到 `/root/passwd` 文件的最后一行，并将其复制粘贴到最后一行后面。首先，我们需要跳到文件的末尾，可以通过使用 *Shift*
    + *g* 键序列（即大写字母 *G*）来实现。接下来，如果我们想复制光标后的这一行（实际上是完成文件的最后一行），我们需要先 yank（复制）它，然后粘贴到正确的位置。yank
    可以通过使用 *yy* 键序列（按两次 *y* 键）来实现。这样，光标后的这一行就会放入复制和粘贴缓冲区。如果我们想把它粘贴到最后一行后面，我们需要按下 *p*
    键。我们复制的行将会自动粘贴到最后一行后面。如果我们使用的是和 [*第1章*](B16269_01_Final_PD_ePub.xhtml#_idTextAnchor012)*，Shell
    和文本终端基础* 中相同的虚拟机，最终结果应该是这样的：
- en: '![Figure 2.4 – The yank and paste of a single line'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4 – 一行的 yank 和 paste'
- en: '](img/Figure_2.4_B16269.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.4_B16269.jpg)'
- en: Figure 2.4 – The yank and paste of a single line
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 一行的 yank 和 paste
- en: Now, let's select three lines beginning with `sshd` (so, the `sshd`, `systemd-coredump`,
    and `student` lines) and copy and paste them after the line beginning with `joe`.
    First, we're going to use cursor keys to position at the beginning of the `sshd`
    line. Then, we're going to type the *y3y* key sequence. This will start yanking
    (copying) from the cursor, copy the next three lines in the copy and paste buffer,
    and then end yanking. If we did that successfully, Vim is going to throw us a
    message at the bottom of the screen, saying `3 lines yanked`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们选择三行以 `sshd` 开头的行（即 `sshd`、`systemd-coredump` 和 `student` 行），并将它们复制粘贴到以
    `joe` 开头的行后面。首先，我们使用光标键将光标定位到 `sshd` 行的开头。然后，我们输入 *y3y* 键序列。这将开始 yank（复制）从光标所在位置开始的三行，将它们复制到复制和粘贴缓冲区中，然后结束
    yank。如果我们成功执行了这一步，Vim 会在屏幕底部给我们提示，显示 `3 lines yanked`。
- en: 'After we have these lines in the copy and paste buffer, we need to paste them.
    Let''s use the cursor keys to move to the line beginning with `joe`, and then
    press the *p* key. The result should look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将这些行放入复制和粘贴缓冲区后，我们需要粘贴它们。让我们使用光标键移动到以 `joe` 开头的行，然后按下 *p* 键。结果应该是这样的：
- en: '![Figure 2.5 – Yank and paste, and multiple lines of text'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.5 – Yank 和 paste，以及多行文本'
- en: '](img/Figure_2.5_B16269.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.5_B16269.jpg)'
- en: Figure 2.5 – Yank and paste, and multiple lines of text
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – Yank 和 paste，以及多行文本
- en: 'Now that we have played with yank and paste and delete, it''s time to add some
    content to this file. In order to do that, we need to enter **insert mode**. That
    can be achieved by typing the *i* key. So, let''s add a bit of text after our
    cursor – press the *i* key and start typing. Let''s add the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经玩过了 yank、paste 和 delete，接下来是时候往这个文件中添加一些内容了。为了做到这一点，我们需要进入 **插入模式**。可以通过按下
    *i* 键来实现。现在，让我们在光标后添加一些文本——按下 *i* 键并开始输入。我们来添加以下内容：
- en: '`something:x:1400:1400::/home/something:/bin/bash`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`something:x:1400:1400::/home/something:/bin/bash`'
- en: 'After we''re done with inserting, press the *Esc* key (to go back to **normal
    mode**). The end result should look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 完成插入后，按下*Esc*键（返回到**普通模式**）。最终的效果应该如下所示：
- en: '![Figure 2.6 – Inserting additional text with insert mode'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6 – 使用插入模式插入额外文本'
- en: '](img/Figure_2.6_B16269.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.6_B16269.jpg)'
- en: Figure 2.6 – Inserting additional text with insert mode
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 使用插入模式插入额外文本
- en: Now that we've done that successfully, the next logical step will be to save
    the file if we're happy with its contents. Let's say that we are and we're ready
    to save the file. In order for us to do that, we need to enter **ex mode** and
    tell Vim that we want to exit and save. There are several different key sequences
    that will make this happen for us. The first one is *:wq!* (write and quit – don't
    ask us for confirmation), and the second one is *:x*. There are other ways, such
    as using the *ZZ* key sequence, but let's stick to the more commonly used ones
    (*wq* and *x*). We need to make sure that we type these key sequences with a colon
    sign (*:*). As we will explain in a bit, using the colon sign means that we want
    to enter ex mode and do some final operations with our edited file. If we use
    this key sequence successfully, we should end up in shell, with our original file
    saved with all the changes that we made to it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功完成了这些操作，接下来的步骤是，如果我们对文件内容满意，就保存文件。假设我们满意并准备保存文件。为了保存文件，我们需要进入 **ex 模式**
    并告诉 Vim 我们想退出并保存文件。可以使用几个不同的按键组合来完成这个操作，第一个是 *:wq!*（写入并退出 – 不要求确认），第二个是 *:x*。还有其他方法，比如使用
    *ZZ* 键组合，但我们先使用更常见的方法（*wq* 和 *x*）。我们需要确保在输入这些按键组合时加上冒号符号（*:*）。正如我们稍后会解释的，使用冒号符号意味着我们想进入
    ex 模式并对编辑过的文件进行最终操作。如果我们成功使用这个按键组合，我们应该会回到 shell，文件已经保存并包含我们所做的所有更改。
- en: 'In truth, Vim has a spectacular number of key sequences that can be used for
    a variety of operations on text files. Feel free to translate this *spectacular*
    as either a very good or very bad thing, as it''s all subjective – some of us
    like it a lot, some of us will hate it. Here are some commonly used key sequences:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Vim 有大量的按键组合可以用于对文本文件执行各种操作。你可以根据自己的看法将 *spectacular* 翻译为好或坏，因为这是主观的——有些人喜欢它，有些人会讨厌它。以下是一些常用的按键组合：
- en: '*dw* – delete a word'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*dw* – 删除一个单词'
- en: '*2dw* – delete two words'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*2dw* – 删除两个单词'
- en: '*yw* – yank one word'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*yw* – 复制一个单词'
- en: '*u* – undo the last change'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*u* – 撤销上一次更改'
- en: '*U* – undo changes made to the current line'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*U* – 撤销当前行的更改'
- en: '*a* – append text after the cursor'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*a* – 在光标后追加文本'
- en: '*A* – append text to the end of the current line'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A* – 将文本追加到当前行的末尾'
- en: '*Ctrl* + *f* – scroll the file forward by one screen'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl* + *f* – 向前滚动文件一页'
- en: '*n Ctrl* + *f* – scroll the file forward by *n* screens'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n Ctrl* + *f* – 向前滚动文件 *n* 页'
- en: '*Shift* + *m* – move the cursor to the middle of the page'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Shift* + *m* – 将光标移动到页面的中间'
- en: '*:50* – move the cursor to line 50 of the current file'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*:50* – 将光标移动到当前文件的第50行'
- en: '*$* – move the cursor to the end of the line'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*$* – 将光标移动到行尾'
- en: '*x* – delete the character at the cursor'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x* – 删除光标处的字符'
- en: '*X* – delete the character before the cursor'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*X* – 删除光标前的字符'
- en: '*^* – go to the first character of the line'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*^* – 跳转到行首'
- en: '*o* – insert a line after the current one'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*o* – 在当前行后插入一行'
- en: '*Ctrl* + *g* – print the file info'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl* + *g* – 打印文件信息'
- en: 'There are literally hundreds of other commands, and we deliberately selected
    only some of them that we feel are useful and commonly used. Let''s now do some
    more complex things by using a built-in Vim teaching tool called **Vimtutor**.
    In the command line, start Vimtutor by typing the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还有成百上千个其他命令，我们特意选择了一些我们认为有用且常用的命令。现在，让我们通过使用一个内建的 Vim 教学工具 **Vimtutor** 来做一些更复杂的操作。在命令行中，通过输入以下内容启动
    Vimtutor：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After that, Vimtutor is going to ask us about the intended output file for
    practice, and we can just press the *Enter* key here. We should have the following
    content on our screen:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，Vimtutor 会询问我们练习的目标输出文件，我们可以直接按下 *Enter* 键。此时，屏幕上应该显示以下内容：
- en: '![Figure 2.7 – The Vimtutor start page'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 – Vimtutor 启动页'
- en: '](img/Figure_2.7_B16269.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.7_B16269.jpg)'
- en: Figure 2.7 – The Vimtutor start page
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – Vimtutor 启动页
- en: Let's now use this file to practice a bit. The first thing that we're going
    to do is copy the first paragraph (starting with **Vim** and ending with **editor.**)
    before the paragraph starting with **The approximate time**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用这个文件进行一些练习。我们要做的第一件事是复制第一段（从 **Vim** 开始，到 **editor.** 结束），然后粘贴到以 **The
    approximate time** 开头的段落之前。
- en: 'Let''s position our cursor at the beginning of the Vim line by using the arrow
    keys. After we have done that, we need to use the *y}* key sequence to instruct
    Vim to **yank** the paragraph starting at the cursor. Then, we need to move to
    the empty line between the first and second paragraphs by using the cursor keys
    and pressing the *p* key to paste the copied paragraph after the cursor. The result
    should look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用箭头键将光标定位到 Vim 行的开头。做完后，我们需要使用 *y}* 键序列指示 Vim **剪切** 从光标开始的段落。然后，使用光标键移动到第一段和第二段之间的空行，按
    *p* 键将剪切的段落粘贴到光标之后。操作结果应该是这样的：
- en: '![Figure 2.8 – Yanking and pasting a text paragraph'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.8 – 剪切和粘贴文本段落](img/Figure_2.8_B16269.jpg)'
- en: '](img/Figure_2.8_B16269.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.8_B16269.jpg)'
- en: Figure 2.8 – Yanking and pasting a text paragraph
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 剪切和粘贴文本段落
- en: 'Let''s say that we want to convert the complete file to lowercase characters.
    Of course, this operation involves several other operations:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想将整个文件转换为小写字符。当然，这个操作涉及到其他几个步骤：
- en: We need to move to the beginning of our file (*gg*).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要移动到文件的开头（*gg*）。
- en: We need to turn on **visual mode** (more about this a bit later), achieved by
    pressing the *Shift* + *v* key sequence (uppercase *V*).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要开启 **视觉模式**（稍后会详细讲解），可以通过按下 *Shift* + *v* 键组合（大写 *V*）来实现。
- en: We need to mark the text all the way to the end of our file, achieved by pressing
    the *Shift* + *g* key sequence (uppercase *G*).
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要标记文本直到文件的末尾，可以通过按下 *Shift* + *g* 键组合（大写 *G*）来实现。
- en: We need to make the text lowercase, achieved by pressing the *u* key.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将文本转换为小写，可以通过按 *u* 键来实现。
- en: 'So, the key sequence we''re looking for is *ggVGu*. The result of our operation
    should look like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们要找的键序列是 *ggVGu*。我们的操作结果应该是这样的：
- en: '![Figure 2.9 – Our Vimtutor file, with all lowercase characters'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.9 – 我们的 Vimtutor 文件，所有字符为小写](img/Figure_2.9_B16269.jpg)'
- en: '](img/Figure_2.9_B16269.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.9_B16269.jpg)'
- en: Figure 2.9 – Our Vimtutor file, with all lowercase characters
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 我们的 Vimtutor 文件，所有字符为小写
- en: If we wanted to do the opposite (uppercase all the characters), we'd use the
    *ggVGU* key sequence (*U* is for uppercase and *u* is for lowercase characters).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想做相反的操作（将所有字符转换为大写），我们将使用 *ggVGU* 键序列（*U* 表示大写，*u* 表示小写）。
- en: We're going to take a short break from all of these key sequences by explaining
    how Vim works – specifically, we're going to focus on commonly used modes and
    briefly mention some of the lesser-used ones. Let's start with **normal mode**
    and work our way toward visual and **replace** modes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍微停一下，暂时不讨论这些键序列，来解释一下 Vim 的工作原理——具体来说，我们将专注于常用的几种模式，并简要提及一些不太常用的模式。我们先从
    **普通模式** 开始，然后逐步讲解到视觉模式和 **替换模式**。
- en: How it works…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The Vim editor has more than 10 different modes, which roughly translates into
    the different ways in which it works. The most used modes are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Vim 编辑器有超过 10 种不同的模式，基本上是它工作方式的不同表现。最常用的模式如下：
- en: Normal mode
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通模式
- en: Insert mode
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入模式
- en: Ex mode
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ex 模式
- en: Visual mode
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉模式
- en: Replace mode
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换模式
- en: When we start Vim, we're in normal mode; we can sniff around in it by using
    the cursor, we can do a bit of yank and paste, and we can delete. So, it's used
    for general operations such as navigating through an edited file, a bit of rough-cut
    editing, and that's that.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动 Vim 时，默认处于普通模式；我们可以在其中使用光标进行浏览，也可以进行一些剪切和粘贴操作，还能删除文本。因此，它主要用于诸如在编辑的文件中导航、简单的编辑等常规操作。
- en: If we want to add additional content to our text file, we usually switch to
    insert mode by using the *i* key. In insert mode, we can easily add a bit of text
    after our cursor and move around in our edited file. When we're ready to go back
    to normal mode, we can do that by pressing the *Esc* key. If, however, we're done
    with file editing and we just want to save the file and exit, we need to go to
    normal mode and then to ex mode. This is achieved by pressing the *Esc* key, followed
    by the colon (*:*). That puts us in ex mode, and then we can proceed to do *wq!*,
    *x*, or *ZZ*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在文本文件中添加额外的内容，通常会使用 *i* 键切换到插入模式。在插入模式下，我们可以轻松地在光标后添加文本并在编辑文件中移动。当我们准备好返回正常模式时，可以按
    *Esc* 键。如果我们完成文件编辑并只想保存文件并退出，则需要进入正常模式，然后进入 ex 模式。这可以通过按 *Esc* 键，然后输入冒号 (*:*)
    来实现。这样我们就进入了 ex 模式，然后可以继续执行 *wq!*、*x* 或 *ZZ*。
- en: Visual and replace modes are quite a bit different. Visual mode has sub-modes
    (**character**, **line**, and **block**), and can be used to select (highlight)
    parts of the text that we want to work with and manipulate. For example, line
    and block modes can be useful for modifying YAML files when working with Ansible.
    Character mode can be used to highlight a part of code. YAML syntax is sensitive
    to indenting, so by using line mode, we can highlight portions of our playbooks
    and indent them left or right (by using the *>* and *<* keys) so that we don't
    have to do it manually. Block mode can be used efficiently to check indentation
    that was created by using line mode. These modes can be entered by using *Shift*
    + *V* (line mode) and *Ctrl* + *v* (block mode). Character mode can be entered
    by using the *v* key.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可视模式和替换模式有很大不同。可视模式有子模式（**字符**、**行**和**块**），可以用来选择（高亮）我们想要处理和操作的文本部分。例如，行模式和块模式在使用
    Ansible 修改 YAML 文件时非常有用。字符模式可以用来高亮代码的一部分。由于 YAML 语法对缩进非常敏感，因此通过使用行模式，我们可以高亮显示剧本中的部分内容并调整其缩进（使用
    *>* 和 *<* 键），这样就不必手动进行调整。块模式则可以高效地检查通过行模式创建的缩进。这些模式可以通过使用 *Shift* + *V*（行模式）和
    *Ctrl* + *v*（块模式）进入。字符模式可以通过使用 *v* 键进入。
- en: Replace mode allows us to type in our content in a text file over existing content.
    We can use the *R* key to enter replace mode (from normal mode).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 替换模式允许我们在现有内容上输入文本。我们可以使用 *R* 键进入替换模式（从正常模式）。
- en: See also
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'If you need more information about the basics of Vim, we suggest that you check
    out this content:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于 Vim 基础的信息，我们建议你查看以下内容：
- en: 'Vim: [https://www.Vim.org/](https://www.Vim.org/)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vim：[https://www.Vim.org/](https://www.Vim.org/)
- en: '*Mastering Vim*: [https://www.amazon.com/exec/obidos/ASIN/1789341094/stichtingiccfhol](https://www.amazon.com/exec/obidos/ASIN/1789341094/stichtingiccfhol)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精通 Vim*：[https://www.amazon.com/exec/obidos/ASIN/1789341094/stichtingiccfhol](https://www.amazon.com/exec/obidos/ASIN/1789341094/stichtingiccfhol)'
- en: 'An interactive Vim tutorial: [https://www.openVim.com/](https://www.openVim.com/)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式 Vim 教程：[https://www.openVim.com/](https://www.openVim.com/)
- en: Learning the basics of the nano editor
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 nano 编辑器的基础
- en: If you feel that the Vim editor is too complicated for you, we can feel your
    pain. That's why choosing the editor you're going to work with is a subjective
    choice. We'd like to offer another much simpler editor to the table, called **nano**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得 Vim 编辑器对你来说太复杂了，我们能理解你的感受。正因如此，选择你将要使用的编辑器是一个主观的选择。我们想为你提供一个更简单的编辑器，叫做
    **nano**。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Keep the CLI1 virtual machine powered on and let's continue editing our files.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 CLI1 虚拟机处于开机状态，让我们继续编辑文件。
- en: How to do it…
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We''re going to edit the `words` file that we copied in the previous recipe.
    Before that, let''s just make sure that nano is installed by typing in the following
    command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编辑在之前的步骤中复制的 `words` 文件。在此之前，让我们先通过输入以下命令来确认是否已安装 nano：
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s now open the file called `words` from the `root` directory by typing
    in the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过输入以下命令打开 `root` 目录下的 `words` 文件：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our file should be opened in the nano editor, as shown in the following screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的文件应已在 nano 编辑器中打开，如下图所示：
- en: '![Figure 2.10 – Starting editing with the nano editor'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.10 – 使用 nano 编辑器开始编辑'
- en: '](img/Figure_2.10_B16269.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.10_B16269.jpg)'
- en: Figure 2.10 – Starting editing with the nano editor
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 使用 nano 编辑器开始编辑
- en: For those of us who are more prone to using text editors such as Notepad or
    Wordpad, nano should be a bit more familiar territory. It doesn't have the scope
    of capabilities or advanced functionality that Vim has, but for the most part,
    that might not be so important, at least not for most text file editing operations.
    Or is it really that simple? Let's check it out.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些更习惯使用记事本或 Wordpad 等文本编辑器的人来说，nano 应该是一个更熟悉的领域。它没有 Vim 那样的广泛功能或高级功能，但大多数情况下，这可能并不那么重要，至少对于大多数文本文件编辑操作而言。或者，真的这么简单吗？让我们来检查一下。
- en: 'Editing in nano works in the same fashion as with other *regular* editors –
    we just need to explain the lower part of the screenshot (the part where we can
    see `Help`, `Exit`, and so on). In nano, if we need help, we need to press *Ctrl*
    + *g*. This is the result that we''ll get:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 nano 中的编辑方式与其他*常规*编辑器类似——我们只需要解释截图下半部分（我们可以看到 `Help`、`Exit` 等部分）。在 nano 中，如果我们需要帮助，需要按
    *Ctrl* + *g*。这是我们会得到的结果：
- en: '![Figure 2.11 – nano help'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.11 – nano 帮助'
- en: '](img/Figure_2.11_B16269.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.11_B16269.jpg)'
- en: Figure 2.11 – nano help
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – nano 帮助
- en: We can spend our time scrolling through this help window if we want to. But,
    for starters, let's just say that this `^` character means *press the Ctrl key*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，可以花时间滚动浏览这个帮助窗口。但是，首先我们可以说，这个 `^` 字符表示 *按下 Ctrl 键*。
- en: So, on our first nano screenshot, `^G` means *Ctrl* + *G*, `^X` means *Ctrl*
    + *X*, and so on. It still isn't as easy as using some text editors that a lot
    of people use on Microsoft Windows, but it's a bit more user-friendly than Vim.
    If nothing else, some of the commonly used commands are right at the bottom of
    our screen so that we don't have to learn all of the key sequences or research
    them online before we consider using the editor.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在我们第一个 nano 截图中，`^G` 表示 *Ctrl* + *G*，`^X` 表示 *Ctrl* + *X*，以此类推。它仍然不像很多人在微软
    Windows 上使用的一些文本编辑器那么简单，但比 Vim 更加用户友好。如果没有其他的话，某些常用命令就在我们屏幕的底部，这样我们就不需要记住所有的键盘序列或在使用编辑器之前在网上查找它们。
- en: If we want to close our help window from the second nano screenshot, we just
    need to press *Ctrl* + *X*. This will get us back to the state shown in the first
    nano screenshot.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想关闭第二个 nano 截图中的帮助窗口，只需要按 *Ctrl* + *X*。这样我们就会回到第一个 nano 截图所示的状态。
- en: 'If we want to delete a line, we need to use *Ctrl* + *K*. If we need to delete
    multiple lines, things start to get a bit more complex. We first need to select
    the content that we want to delete (*Ctrl* + *Shift* + *6*), use the cursor to
    move to the place that we want to delete to, and then press *Ctrl* + *K*. Let''s
    say that we want to delete five lines. So, selecting content that we want to delete
    looks like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想删除一行，我们需要使用 *Ctrl* + *K*。如果我们需要删除多行，事情就开始变得有些复杂。我们首先需要选择要删除的内容（*Ctrl* +
    *Shift* + *6*），使用光标移动到我们要删除的地方，然后按 *Ctrl* + *K*。假设我们要删除五行。那么，选择要删除的内容就像这样：
- en: '![Figure 2.12 – After pressing Ctrl + Shift + 6 and using the cursor keys to'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.12 – 按下 Ctrl + Shift + 6，并使用光标键'
- en: go down five lines, we're ready for Ctrl + K
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动五行，我们准备好按 Ctrl + K 了
- en: '](img/Figure_2.12_B16269.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.12_B16269.jpg)'
- en: Figure 2.12 – After pressing Ctrl + Shift + 6 and using the cursor keys to go
    down five lines, we're ready for Ctrl + K
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 按下 Ctrl + Shift + 6，并使用光标键向下滚动五行后，我们准备好按 Ctrl + K 了
- en: 'After we have selected the correct text, we just need to press *Ctrl* + *K*
    to delete it. The result will look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们选择了正确的文本之后，我们只需要按 *Ctrl* + *K* 来删除它。结果将如下所示：
- en: '![Figure 2.13 – Five lines successfully deleted – result!'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.13 – 五行成功删除 – 结果！'
- en: '](img/Figure_2.13_B16269.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.13_B16269.jpg)'
- en: Figure 2.13 – Five lines successfully deleted – result!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 五行成功删除 – 结果！
- en: The same idea applies to doing a copy and paste operation on a paragraph. We'd
    use *Ctrl* + *Shift* + *6* and the cursor to mark the text, *Alt* + *6* to put
    the copied text in the copy and paste buffer, and then use *Ctrl* + *U* to paste
    it wherever it needs to be pasted in nano. Saving the file is equivalent to using
    *Ctrl* + *X* to exit, and then confirming that we want the changes to be saved
    to a file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的思路适用于对段落进行复制和粘贴操作。我们需要使用 *Ctrl* + *Shift* + *6* 和光标标记文本，*Alt* + *6* 将复制的文本放入复制粘贴缓冲区，然后使用
    *Ctrl* + *U* 将其粘贴到 nano 中需要粘贴的地方。保存文件相当于使用 *Ctrl* + *X* 退出，然后确认我们希望将更改保存到文件中。
- en: There's more…
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'If you need to learn more about nano, check out the following links:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 nano 的信息，可以查看以下链接：
- en: 'The nano editor cheat sheet: [https://www.nano-editor.org/dist/latest/cheatsheet.html](https://www.nano-editor.org/dist/latest/cheatsheet.html)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nano 编辑器备忘单：[https://www.nano-editor.org/dist/latest/cheatsheet.html](https://www.nano-editor.org/dist/latest/cheatsheet.html)
- en: 'How to use nano: [https://linuxize.com/post/how-to-use-nano-text-editor/](https://linuxize.com/post/how-to-use-nano-text-editor/)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 nano：[https://linuxize.com/post/how-to-use-nano-text-editor/](https://linuxize.com/post/how-to-use-nano-text-editor/)
- en: Going through the advanced Vi(m) settings
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过高级 Vi(m) 设置
- en: In the first part of this chapter, we learned some basic Vim operations, which
    were moving around, copying and pasting, saving, and exiting. Let's take care
    of some more **advanced operations**, such as working with find and replace, regular
    expressions, and similar concepts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们学习了一些基本的 Vim 操作，包括移动、复制粘贴、保存和退出。接下来，让我们处理一些**高级操作**，比如查找和替换、正则表达式以及类似的概念。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We need to leave our CLI virtual machine running. If it's not powered on, we
    need to power it back on.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要保持 CLI 虚拟机运行。如果它没有开机，我们需要重新开机。
- en: How to do it…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Finding content in Vim is a multi-step process, and it depends on a couple
    of things. First, it depends on the *direction* that we want to take, *forward*
    or *backward*, as there are different key sequences for these operations. Let''s
    open the `/root/words` file again to find some text:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vim 中查找内容是一个多步骤的过程，取决于几个因素。首先，它取决于我们想要的*方向*，是*向前*还是*向后*，因为这两种操作有不同的快捷键序列。让我们再次打开`/root/words`文件，查找一些文本：
- en: '[PRE7]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s start by finding the word `fast`. For that to work, we need to use the
    `/` character from normal mode, as it tells Vim that we''re about to use the `search`
    function. So, `/fast` will search for the words `fast forward` from our cursor.
    This is the expected result:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查找单词 `fast` 开始。为此，我们需要从正常模式使用`/`字符，因为它告诉 Vim 我们即将使用`搜索`功能。所以，`/fast`将从当前光标位置搜索单词
    `fast forward`。这是预期的结果：
- en: '![Figure 2.14 – Finding a word in Vim'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.14 – 在 Vim 中查找单词'
- en: '](img/Figure_2.14_B16269.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.14_B16269.jpg)'
- en: Figure 2.14 – Finding a word in Vim
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 在 Vim 中查找单词
- en: 'If we now press *Enter* and then the *n* key, we will search for the next appearance
    of the word `fast`. This is the expected result:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在按下*Enter*键，然后按下*n*键，我们将搜索单词 `fast` 的下一个出现位置。预期的结果是：
- en: '![Figure 2.15 – The next appearance of the word fast'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.15 – 查找单词 fast 的下一个出现位置'
- en: '](img/Figure_2.15_B16269.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.15_B16269.jpg)'
- en: Figure 2.15 – The next appearance of the word fast
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – 查找单词 fast 的下一个出现位置
- en: 'However, if we want to find the 10th appearance of the word `fast`, we need
    to either press the correct key sequence or use a regular expression. Let''s start
    with a key sequence, which is going to be (again from normal mode) `10/fast`.
    This is the expected result:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想查找单词 `fast` 的第 10 次出现，我们需要按下正确的快捷键序列或使用正则表达式。让我们先从快捷键序列开始，它是（再次从正常模式）`10/fast`。这是预期的结果：
- en: '![Figure 2.16 – Finding the n-th appearance of a word'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.16 – 查找单词的第 n 次出现'
- en: '](img/Figure_2.16_B16269.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.16_B16269.jpg)'
- en: Figure 2.16 – Finding the n-th appearance of a word
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 查找单词的第 n 次出现
- en: 'If we want to find the previous appearance of our word (basically, search backward),
    we need to press the *N* key (capital *N*). This is the expected result:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想查找单词的上一个出现位置（基本上是向后搜索），我们需要按下*N*键（大写 *N*）。这是预期的结果：
- en: '![Figure 2.17 – Finding a word backward from the previous cursor'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.17 – 从上一个光标位置向后查找单词'
- en: '](img/Figure_2.17_B16269.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.17_B16269.jpg)'
- en: Figure 2.17 – Finding a word backward from the previous cursor
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 从上一个光标位置向后查找单词
- en: 'Let''s now do a bit of search and replace. Let''s say that we want to find
    all appearances of the word `airplane` and change them to `metro`, starting from
    the beginning of our file. The key sequence used for that would be *gg* (to go
    back to the file beginning) and then `:%s/airplane/metro/g`, followed by the *Enter*
    key. This is the expected result:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来做一些搜索和替换。假设我们想要查找单词 `airplane` 的所有出现，并将它们替换为 `metro`，从文件的开头开始。为此，使用的快捷键序列是*gg*（返回文件开头），然后是
    `:%s/airplane/metro/g`，接着按下*Enter*键。预期的结果是：
- en: '![Figure 2.18 – Replacing all appearances of a word with another word'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.18 – 用另一个单词替换单词的所有出现'
- en: '](img/Figure_2.18_B16269.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.18_B16269.jpg)'
- en: Figure 2.18 – Replacing all appearances of a word with another word
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – 用另一个单词替换单词的所有出现
- en: 'This syntax presumes the automatic replacement of all occurrences of the word
    `airplane` with the word `metro` placed anywhere in the file. If we just wanted
    to replace the first appearance of a string in any line, we need to first find
    that word by using the `/word` key sequence. Then, we need to use the `:s/word1/word2/`
    key sequence to only change the first appearance of `word1` with `word2`. Let''s
    use the word `airship` for that example and change that word to `ship`. If we
    type in `/airship`, followed by the *Enter* key, Vim will position us to the first
    next appearance of the word `airship`. If we then use the `:s/airship/ship/` key
    sequence followed by the *Enter* key, we should get this result:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Replacing one appearance of a word in a specific line with
    another word'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.19_B16269.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.19 – Replacing one appearance of a word in a specific line with another
    word
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: It's a subtle difference, but an important one.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: We could also use many more commands in vi – for example, using a dot sign (`.`).
    That can be used to repeat the last change made in normal mode, which you might
    also find to be very useful.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: We're going to stop here, as we will cover more advanced text search patterns
    by using regular expressions in [*Chapter 7*](B16269_07_Final_PD_ePub.xhtml#_idTextAnchor160),
    *Network-Based File Synchronization*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`sed`, a **stream editor**. This command is regularly used by system engineers
    all over the world to quickly replace simple or complex text patterns of any given
    file (or multiple files) to another complex text pattern. It uses regular expressions
    as a basis (explained in [*Chapter 7*](B16269_07_Final_PD_ePub.xhtml#_idTextAnchor160),
    *Network-Based File Synchronization*), which means that, by default, doing search
    and replace in Vim is quite powerful, albeit a bit complex, as we need to learn
    the ins and outs of sed and the way Vim treats it as a *plugin*.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: That being said, most of us focus on the *quite powerful* part of the last paragraph,
    as using a Vim/sed combination to quickly replace complex text patterns yields
    fast and precise results – as long as we know what we're doing, of course.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using these concepts requires a bit of extra reading. So, we need to make sure
    that we check the following additional links:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Vim Tips Wiki – search and replace: [https://Vim.fandom.com/wiki/Search_and_replace](https://Vim.fandom.com/wiki/Search_and_replace)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vim tips: the basics of search and replace*: [https://www.linux.com/training-tutorials/Vim-tips-basics-search-and-replace/](https://www.linux.com/training-tutorials/Vim-tips-basics-search-and-replace/)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
