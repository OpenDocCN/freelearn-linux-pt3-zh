- en: '22'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '22'
- en: Introduction to Z Shell Scripting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Z Shell 脚本编写
- en: Thus far, we’ve mainly talked about `bash`, since it’s the preeminent login
    shell and scripting environment for Linux. In recent years, a fairly new kid on
    the block, **Z Shell** (`zsh`) has been gaining a bit of popularity as a default
    login shell. But, even on the operating systems that come with `zsh` as the login
    shell, `bash` is still there, and `bash` is what most people still use for scripting
    purposes. Be aware though, that scripting in `zsh` does have certain advantages,
    such as better math capabilities, enhanced variable expansion, and the ability
    to use native `zsh` commands instead of utilities such as `find`, `grep`, or `sed`.
    These features can help you create scripts that are a bit simpler and lighter
    than equivalent `bash` scripts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要讨论了 `bash`，因为它是 Linux 的主要登录 shell 和脚本环境。近年来，一个相对较新的登录 shell **Z Shell**
    (`zsh`) 作为默认登录 shell 越来越受欢迎。但即使在预装 `zsh` 作为登录 shell 的操作系统上，`bash` 仍然存在，并且大多数人仍然将其用于脚本编写。然而，需要注意的是，在
    `zsh` 中进行脚本编写确实有一些优势，比如更好的数学能力、增强的变量展开功能，以及能够使用本地 `zsh` 命令而不是像 `find`、`grep` 或
    `sed` 这样的实用程序。这些特性可以帮助您创建比等效的 `bash` 脚本更简单、更轻量的脚本。
- en: Most articles and YouTube videos that you see about `zsh` focus on the user
    interface enhancements, and very few focus on `zsh` scripting. Unfortunately,
    the few books and tutorials that do focus on `zsh` scripting aren’t very well-written,
    and you won’t get much out of them. Hopefully, I can provide some clarification.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数关于 `zsh` 的文章和 YouTube 视频都集中在用户界面增强上，而很少关注 `zsh` 脚本编写。不幸的是，少数关注 `zsh` 脚本编写的书籍和教程写得不太好，您不会从中获得太多收获。希望我能提供一些澄清。
- en: Rather than present a detailed tutorial, I’d like to just present a high-level
    overview of `zsh` scripting, so that you can decide for yourself if it’s for you.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与其提供详细的教程，我更想简要概述 `zsh` 脚本编写，让您自己决定是否适合您。
- en: 'Topics in this chapter include:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题包括：
- en: Introducing `zsh`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 `zsh`
- en: Installing `zsh`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 `zsh`
- en: Understanding the Unique Features of `zsh` Scripting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `zsh` 脚本编写的独特功能
- en: Using `zsh` Modules
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `zsh` 模块
- en: If you’re ready, let’s dig in.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您准备好了，让我们开始吧。
- en: Technical Requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can use any of your Linux virtual machines for this chapter. As always,
    you can grab the demo scripts by doing:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任何 Linux 虚拟机上使用本章内容。与往常一样，您可以通过执行以下操作获取演示脚本：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Introducing zsh
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 zsh
- en: Z Shell was created in 1990 by Paul Falstad. It’s an extension of the Bourne
    Shell, but also includes features from `bash`, Korn Shell (`ksh`), and C Shell
    (`tcsh`).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Z Shell 由 Paul Falstad 于 1990 年创建。它是 Bourne Shell 的扩展，同时还包括来自 `bash`、Korn Shell
    (`ksh`) 和 C Shell (`tcsh`) 的功能。
- en: The **C Shell**, which used to be somewhat popular with Unix and Unix-like distros,
    is vastly different from anything you’ve seen. Writing a C Shell script is more
    akin to writing a C language program than it is to what you’re used to. So if
    you’re a C language programmer, you might like it. If you’re not, then you might
    not like it so much.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**C Shell** 曾在 Unix 和类 Unix 发行版中颇受欢迎，但它与你之前接触的任何东西大不相同。编写 C Shell 脚本更类似于编写
    C 语言程序，而不是你所熟悉的方式。所以如果你是 C 语言程序员，你可能会喜欢它。如果不是，那你可能不会那么喜欢。'
- en: Z Shell comes as the default login shell for both macOS and Kali Linux. For
    pretty much everything else, you’ll need to install it yourself. As far as `zsh`
    scripting goes, most of what you’ve learned about scripting in `bash` also applies
    to scripting in `zsh`. So, in this chapter I’ll just present the unique features
    of `zsh`, and show you some simple scripting examples.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Z Shell 是 macOS 和 Kali Linux 的默认登录 shell。对于几乎所有其他系统，您都需要自行安装。至于 `zsh` 脚本编写，大多数在
    `bash` 中学到的内容也适用于 `zsh`。因此，在本章中，我将仅介绍 `zsh` 的独特功能，并展示一些简单的脚本示例。
- en: Installing zsh
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 zsh
- en: The `zsh` package is available in all Linux and BSD-type distros that I’ve tried,
    as well as on OpenIndiana. The package name is `zsh` in all cases, so you can
    just install it with your normal package manager.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我尝试过的所有 Linux 和 BSD 类型发行版以及 OpenIndiana 上，都可以使用 `zsh` 包。在所有情况下，包名称都是 `zsh`，因此您可以使用正常的包管理器安装它。
- en: 'On the BSD distros, you’ll have the same path problem that you had with `bash`.
    That is, on BSD distros, the `zsh` executable is in the `/usr/local/bin/` directory,
    instead of the `/bin/` directory. That’s okay, though. Just create a symbolic
    link in the `/bin/` directory, as you did for `bash`. On my FreeBSD machine, the
    command looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BSD 系统中，你会遇到与`bash`相同的路径问题。也就是说，在 BSD 系统中，`zsh`的可执行文件位于`/usr/local/bin/`目录下，而不是`/bin/`目录下。不过没关系，你可以像在`bash`中那样，在`/bin/`目录下创建一个符号链接。在我的
    FreeBSD 机器上，命令如下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, if you need to run your `zsh` scripts on Linux, OpenIndiana, and BSD machines,
    you can use the same shebang line, which looks like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你需要在 Linux、OpenIndiana 和 BSD 机器上运行你的`zsh`脚本，可以使用相同的 shebang 行，格式如下：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you want to use `zsh` as your temporary login shell, you can just enter
    `zsh` at your normal shell’s command prompt. If you want to set `zsh` as your
    permanent login shell, use the `chsh` command on Linux and the BSD distros, and
    the `passwd` command on OpenIndiana. Here’s how that looks on Linux and the BSD
    distros:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将`zsh`作为临时登录 shell 使用，可以直接在当前 shell 的命令提示符下输入`zsh`。如果你想将`zsh`设置为永久登录 shell，则可以在
    Linux 和 BSD 系统上使用`chsh`命令，在 OpenIndiana 上使用`passwd`命令。Linux 和 BSD 系统上可以这样设置：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s how it looks on OpenIndiana:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenIndiana 上的表现如下：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that when you change the shell for your own user account, you’ll be prompted
    to enter your own user password. However, this has nothing to do with `sudo`,
    because even non-privileged users can use `chsh` on Linux/BSD distros and `passwd
    -e` on OpenIndiana to change their own default shells.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当你为自己的用户账户更改 shell 时，系统会提示你输入自己的用户密码。然而，这与`sudo`无关，因为即使是非特权用户，也可以在 Linux/BSD
    系统上使用`chsh`，在 OpenIndiana 上使用`passwd -e`来更改自己的默认 shell。
- en: 'The first time you log in with `zsh`, you’ll be presented with a setup menu
    that looks like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用`zsh`登录时，你会看到一个设置菜单，内容如下所示：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Hit the **1** key to go to the main menu, and choose your preferred setup options.
    The configuration will be saved to the `.zshrc` file in your home directory.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 按下**1**键返回主菜单，并选择你首选的设置选项。配置将保存到你家目录下的`.zshrc`文件中。
- en: Next, let’s look at some of the unique features of `zsh` scripting.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下`zsh`脚本的一些独特功能。
- en: Understanding the Unique Features of zsh Scripting
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`zsh`脚本的独特功能
- en: When you script in `zsh`, you can take advantage of certain enhancements that
    aren’t in `bash`. Here’s a quick review of some of those enhancements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`zsh`中编写脚本时，你可以利用一些`bash`没有的增强功能。这里简要回顾一下其中的一些增强功能。
- en: Differences in Variable Expansion
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量扩展的区别
- en: In *Chapter 8—Basic Shell Script Construction*, I explained the concept of **variable
    expansion**, which is also sometimes called **parameter expansion**. This allows
    you to write cool scripts that do cool things, such as changing the filename extensions
    on a whole batch of files at a time. Most of the same variable expansion constructs
    that are in `bash` are also in `zsh`, but `zsh` has additional ones that provide
    additional capabilities. Let’s look at a few examples.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第8章—基本 Shell 脚本构建*中，我解释了**变量扩展**的概念，这个概念有时也叫做**参数扩展**。这使得你可以编写一些很酷的脚本来完成很酷的事情，比如一次性修改一批文件的文件扩展名。`bash`中大部分的变量扩展构造在`zsh`中也能使用，但`zsh`还提供了一些额外的扩展功能，增加了更多的能力。让我们来看几个例子。
- en: Substituting Values
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换值
- en: 'Substituting values in `zsh` works the same as it does in `bash`, with one
    exception. That is, if you substitute a value in a text string that includes an
    exclamation point, you’ll have to escape it in a `zsh` script. For example, here’s
    how it works in `bash`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`zsh`中替换值的方式与`bash`相同，唯一的例外是，如果你在包含感叹号的文本字符串中替换值，在`zsh`脚本中需要对感叹号进行转义。例如，在`bash`中，效果如下：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As I explained in *Chapter 8*, the `variable_name:-default_value` construct
    supplies a default value for any variable that doesn’t yet have a value assigned
    to it. This same construct is supposed to work in `zsh`, but watch what happens
    when I try it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在*第8章*中所解释的，`variable_name:-default_value`结构为任何尚未赋值的变量提供了默认值。这个结构本应在`zsh`中也能工作，但看我尝试它时发生了什么：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When I hit the **Enter** key after typing the `echo` command, `zsh` takes me
    to the `dquote>` prompt. If I hit the `"` key a second time, I get the output
    that I want. To get it right the first time, I’ll just place a `\` before the
    `!`, like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在输入完`echo`命令后按下**Enter**键，`zsh`会将我带到`dquote>`提示符。如果我第二次按下`"`键，就能得到我想要的输出。为了第一次就正确输出，我只需在`!`之前加上`\`，像这样：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, with the `\` in front of the exclamation point, it works just fine. I don’t
    know why the `!` needs to be escaped in `zsh`, but whatever works, right?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在感叹号前加上`\`，它就能正常工作。我不知道为什么`zsh`中感叹号需要转义，不过，反正能用就行，对吧？
- en: Substituting Substrings
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子字符串替换
- en: Substring substitution partly works in `bash`, but not completely. Here’s what
    I mean.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 子字符串替换在`bash`中部分有效，但不是完全有效。我的意思是这样。
- en: 'I’ll first create the `name` variable with the value of `lionel`. Then, on
    both `bash` and `zsh`, I’ll attempt to replace the first lower-case *l* with an
    upper-case *l*. First, on `bash`, like so:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先创建`name`变量，赋值为`lionel`。然后，在`bash`和`zsh`中，我会尝试将第一个小写字母*l*替换成大写字母*L*。首先在`bash`中，像这样：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, on `zsh`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`zsh`中：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `${name/l/L}` construct, you see that I first listed the variable `name`
    with a forward slash and the letter that I want to replace, followed by another
    forward slash and the letter that I want to substitute. As you can see, this works
    on both `bash` and `zsh`. I can also replace both both occurrences of the lower-case
    *l* by using two forward slashes after the `name` variable, like so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`${name/l/L}`构造中，你可以看到我首先列出了`name`变量，并用正斜杠后跟要替换的字母，然后是另一个正斜杠和要替换成的字母。如你所见，这在`bash`和`zsh`中都能正常工作。我还可以通过在`name`变量后使用两个正斜杠来替换所有的小写*l*，像这样：
- en: 'On `bash`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bash`中：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On `zsh`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`zsh`中：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Again, this works on both `bash` and `zsh`. So, if this works on both shells,
    why am I showing this to you? Well, it’s just that on `bash`, this only works
    if the text string doesn’t contain any blank spaces.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在`bash`和`zsh`中都能使用。那么，如果它在这两种 shell 中都能工作，为什么我还要向你展示呢？其实，原因是：在`bash`中，这个方法仅在字符串不包含空格的情况下有效。
- en: 'Here’s an example of what I mean:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我想表达的意思：
- en: 'On `bash`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bash`中：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This time, I wanted to replace all occurrences of *and* with an ampersand. But,
    this doesn’t work on `bash` because the text string contains blank spaces. So,
    let’s try this on `zsh`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我想把所有的*and*替换成&符号。但在`bash`中这行不通，因为字符串包含空格。我们来试试在`zsh`中做这个操作。
- en: 'On `zsh`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`zsh`中：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On `zsh`, having a text string with blank spaces doesn’t matter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`zsh`中，字符串中包含空格并不影响操作。
- en: Translating Between Upper and Lower Case
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大小写转换
- en: Here’s an example of the exact opposite situation. This time, I’ll show you
    something that works on `bash`, but not on `zsh`. Then, I’ll show you the alternative
    method for `zsh`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完全相反情况的示例。这一次，我将展示一个在`bash`中有效，但在`zsh`中无效的例子。然后，我会展示在`zsh`中使用的替代方法。
- en: 'First, let’s say that we want to capitalize the first letter of the value that’s
    assigned to the `name` variable. Here’s how to do it on `bash`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设我们想要将分配给`name`变量的值的首字母大写。以下是在`bash`中的方法：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'All I did here was to place a `^` after the `name` variable in the `echo` statement.
    Now, let’s say that I want to capitalize all letters. I’ll do that by using two
    `^` characters, like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我这里做的只是将一个`^`放在`name`变量的`echo`语句后面。现在，假设我想让所有字母大写，我可以使用两个`^`字符，像这样：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you have a text string with all upper-case characters, use either one or
    two commas to convert either the first letter or all letters to lower-case, like
    this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个全大写的字符串，可以使用一个或两个逗号，将第一个字母或所有字母转换为小写，就像这样：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On `zsh`, none of this works at all, as you see here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`zsh`中，完全不管用，正如你看到的：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I’m showing you this because some `zsh` scripting books say this will work on
    `zsh`. But, as you see, it definitely doesn’t.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以向你展示这个，是因为一些`zsh`脚本书说这种方法在`zsh`中有效。但如你所见，显然无效。
- en: 'So, what’s the alternative on `zsh`? Well, you just use a builtin `zsh` function.
    Let’s first use the `U` function to convert an entire text string to upper-case:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在`zsh`中的替代方法是什么呢？其实，你只需使用一个内建的`zsh`函数。我们首先使用`U`函数将整个字符串转换为大写：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Instead of placing a pair of `^` characters after the name variable, I just
    placed a `(U)` before the `name` variable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有在变量名后面加一对`^`字符，而是直接在`name`变量前加了一个`(U)`。
- en: 'As far as I’ve been able to find, there’s no function that converts just the
    first letter. So, let’s convert the first letter like this, instead:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 据我所知，`zsh`中并没有直接转换第一个字母的函数。所以，我们只能像这样转换第一个字母：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is the same method that I’ve just shown you in the previous section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这和我在上一部分所展示的方法是一样的。
- en: Next, let’s do some globbing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来做一些通配符操作。
- en: Extended File Globbing
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展文件通配符
- en: '“What’s **file globbing”**, you say? Well, you’ve actually been working with
    it throughout this book. It’s just that I’ve never told you what it’s called.
    All it means is that you can use wildcard characters, such as the `*` and the
    `?`, to work with multiple files at the same time. For example, you can do this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: “**文件模式匹配**”，你问什么？嗯，其实你在本书的整个过程中都在使用它。只是我从未告诉过你它叫什么。它的意思是，你可以使用通配符字符，比如`*`和`?`，同时处理多个文件。例如，你可以这样做：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All I’m doing here is using the `*` wildcard to view all of the `.zip` files
    in my directory.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里做的只是使用`*`通配符来查看我目录中的所有`.zip`文件。
- en: 'You can do all this and more in `zsh`. The only catch is that you need to have
    the `extendedglob` feature turned on. To verify that it is, look in the `.zshrc`
    file in your home directory. You should see a line that looks something like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`zsh`中做所有这些操作，甚至更多。唯一的条件是你需要开启`extendedglob`功能。要验证它是否开启，检查你家目录下的`.zshrc`文件。你应该能看到像这样的行：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the `extendedglob` option is there, then you’re good. If it isn’t, just add
    it in. So now, let’s look at a few examples of extended globbing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`extendedglob`选项开启，那么你就可以使用它了。如果没有开启，只需添加它。那么，现在我们来看看几个扩展文件模式匹配的例子。
- en: Why is extended file globbing on `zsh` useful? Well, it’s just that in many
    cases, you’ll be able to use the extended globbing features of `zsh` instead of
    using the `find` utility. You might find this easier than using `find`. Or, you
    might prefer using `find`, if that’s what you’re used to using. I’ll let you make
    the decision.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`zsh`中的扩展文件模式匹配有用？嗯，实际上，在许多情况下，你可以使用`zsh`的扩展模式匹配功能，而不是使用`find`工具。你可能会觉得这比使用`find`更简单。或者，如果你习惯使用`find`，你可能更喜欢使用它。我会让你自己做决定。
- en: Also, for demo purposes, I’m mainly showing you this with the `ls` utility.
    But, you can also use globbing with other utilities, such as `cp`, `mv`, `rm`,
    `chmod`, or `chown`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了演示的目的，我主要用`ls`工具来展示这个功能。但你也可以使用文件模式匹配与其他工具一起使用，比如`cp`、`mv`、`rm`、`chmod`或`chown`。
- en: Filtering ls Output
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过滤`ls`输出
- en: 'With this cool feature enabled, you can do cool things like excluding files
    that you don’t want to see. For example, let’s say that you want to see all files
    in your directory except for the `.sh` files. Just do this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 启用这个酷炫的功能后，你可以做一些很酷的事情，比如排除你不想看到的文件。例如，假设你想查看目录中的所有文件，但不包括`.sh`文件。只需这样做：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `^` that precedes the `*.sh` is a negation symbol. This is what prevents
    the `ls` command from showing you the `.sh` files.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`*.sh`前面的`^`是一个否定符号。这会阻止`ls`命令显示`.sh`文件。
- en: Note that I had to include the `-d` option for `ls`. Otherwise, you’ll also
    see files in any subdirectories that you might have. For some reason, the `^`
    filters out the unwanted files in my top level directory, but it doesn’t filter
    out the unwanted files in the subdirectories. So, without the `-d`, you’ll also
    see all files that are in the subdirectories, including the ones that you want
    to filter out.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我必须为`ls`添加`-d`选项。否则，你还会看到任何可能存在的子目录中的文件。由于某种原因，`^`可以过滤掉我顶层目录中不需要的文件，但它不会过滤掉子目录中的不需要的文件。所以，如果没有`-d`，你还会看到子目录中的所有文件，包括那些你想过滤掉的文件。
- en: 'You can use the `*~` operator to accomplish the same thing. Here’s how that
    looks:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`*~`操作符来实现相同的效果。看起来是这样的：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you see, the output is identical to that of the `ls -d ^.sh` output. To
    exclude multiple types of files, just use the *or* operator (`|`), like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，输出与`ls -d ^.sh`的输出完全相同。要排除多种类型的文件，只需使用*或*操作符(`|`)，像这样：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So in this case, I filtered out the `.sh`, `.jpg`, `.txt`, and `.c` files. Now,
    let’s look at our next trick.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这个例子中，我过滤掉了`.sh`、`.jpg`、`.txt`和`.c`文件。现在，让我们看看下一个技巧。
- en: Grouping ls Searches
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分组`ls`搜索
- en: 'Something else that you can’t do in `bash` is to group your `ls` searches,
    like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`bash`中做不到的另一件事是将`ls`搜索结果进行分组，像这样：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, I’m using the `|` symbol as an *or* operator, to view all files with either
    `ex` or `test` as the first portion of their filenames.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用`|`符号作为*或*操作符，查看所有文件，其文件名的前部分是`ex`或`test`。
- en: Using Globbing Flags
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用文件模式匹配标志
- en: 'As you know, Linux and Unix operating systems are normally case-sensitive.
    So, if you were to use the `ls *.jpg` command to view all JPEG-type graphics files,
    you would completely miss any files that might have the `*.JPG` extension. With
    `zsh`, you can use **globbing flags** to make your commands case-insensitive.
    Here’s an example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知道的，Linux 和 Unix 操作系统通常区分大小写。因此，如果你使用 `ls *.jpg` 命令来查看所有 JPEG 类型的图像文件，你将完全错过任何可能有
    `*.JPG` 扩展名的文件。使用 `zsh` 时，你可以使用**通配符标志**来使命令不区分大小写。下面是一个例子：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `(#i)` in the second `ls` command is the globbing flag. The `#` indicates
    that it’s a flag, and it will precede the pattern that you want to match.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `ls` 命令中的 `(#i)` 就是通配符标志。`#` 表示这是一个标志，它会出现在你想要匹配的模式前面。
- en: 'The `(#l)` flag will match either a lower-case or upper-case pattern if you
    specify a lower-case pattern for your search. If you specify an upper-case pattern,
    then it will only match the upper-case pattern. Here’s how that looks:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`(#l)` 标志会匹配小写或大写的模式，如果你为搜索指定小写模式，它就会匹配小写模式。如果你指定大写模式，那么它只会匹配大写模式。下面是它的样子：'
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You see here that when I specified `*.jpg` as the pattern, it also found the
    `.JPG` file. But, when I specified `.JPG` as the pattern, it only found the `.JPG`
    file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当我指定 `*.jpg` 作为模式时，它也找到了 `.JPG` 文件。但是，当我指定 `.JPG` 作为模式时，它只找到了 `.JPG` 文件。
- en: Now, let’s expand some directories.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们扩展一些目录。
- en: Expanding Directories
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扩展目录
- en: 'You can use **globbing qualifiers** to view different types of directories
    or files. We’ll start with the qualifiers for directories, which are:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**通配符限定符**查看不同类型的目录或文件。我们将从目录的限定符开始，具体包括：
- en: '`*(F)`: This expands non-empty directories.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*(F)`：这个扩展了非空目录。'
- en: '`*(^F)`: This expands both plain files and empty directories.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*(^F)`：这个扩展了普通文件和空目录。'
- en: '`*(/^F)`: This only expands empty directories.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*(/^F)`：这个仅扩展空目录。'
- en: First, let’s look at the non-empty directories that are in my home directory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们查看我主目录中的非空目录。
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You see here that this command shows the non-empty directories and their contents.
    But, it doesn’t show any files that are in my top-level home directory. So, it’s
    all good.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这个命令显示了非空目录及其内容。但它没有显示我顶层主目录中的任何文件。所以，一切正常。
- en: 'Now, I want to see all of the files that are in my top-level home directory,
    along with any empty directories that might also be there. I’ll do that like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想查看我顶层主目录中的所有文件，以及可能存在的任何空目录。我会这样做：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The two empty directories show up at the bottom of the output.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个空目录出现在输出的底部。
- en: 'Finally, I only want to see the empty directories, like so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我只想看到空目录，如下所示：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Pretty cool, eh?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷吧？
- en: Next, let’s look at file expansion.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看文件扩展。
- en: Expanding Files
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扩展文件
- en: There are several ways to expand files. First, we’ll expand by either the file
    or directory file types.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展文件的方式有几种。首先，我们将根据文件或目录的文件类型进行扩展。
- en: Expanding Files and Directories
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 扩展文件和目录
- en: 'If you want to see the files in your directory, but don’t want to see any directories,
    do this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看目录中的文件，但又不想看到任何目录，可以这样做：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you only want to see your directories, both empty and non-empty, do this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想看到你的目录，无论是空目录还是非空目录，可以这样做：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Okay, I think you see what’s going on with this. Let’s move on to look at file
    permissions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想你已经明白这里发生了什么。让我们继续看一下文件权限。
- en: Expanding by File Permissions
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过文件权限扩展
- en: In *Chapter 20, Shell Script Security*, I explained about how file and directory
    permissions work. Let’s do a quick review.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第20章，Shell 脚本安全性*中，我解释了文件和目录权限是如何工作的。让我们快速回顾一下。
- en: 'The permissions settings are divided between the *user*—which is what we call
    the owner of the file or directory—the *group*, and *others*. Each of these can
    have any combination of read, write, and executable permissions set for any given
    file or directory. If you need to search for files or directories with certain
    permissions settings, you can use the `find` utility. On `zsh`, you can use **globbing
    qualifiers** instead of `find`. Here’s the list of the qualifiers that you’ll
    work with:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 权限设置分为*用户*（即文件或目录的所有者）、*组*和*其他*。每一项都可以设置任何组合的读取、写入和执行权限。如果你需要查找具有特定权限设置的文件或目录，你可以使用
    `find` 工具。在 `zsh` 中，你可以使用**通配符限定符**代替 `find`。这里是你将使用的限定符列表：
- en: 'For the user:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户：
- en: '`r:`The user has the read permission.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r:` 用户具有读取权限。'
- en: '`w`: This denotes files for which the user has the write permission.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`: 这表示用户具有写权限的文件。'
- en: '`x`: The user has the executable permission.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`: 用户具有可执行权限。'
- en: '`U`: This looks for files or directories that belong to the current user.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`U`: 这会查找属于当前用户的文件或目录。'
- en: '`s`: This looks for files with the SUID permission set.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`: 这会查找具有SUID权限设置的文件。'
- en: 'For the group:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于组：
- en: '`A`: The group has the read permission.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A`: 该组具有读取权限。'
- en: '`I`: The group has the write permission.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I`: 该组具有写权限。'
- en: '`E`: The group has the executable permission.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E`: 该组具有可执行权限。'
- en: '`G`: This looks for files or directories that belong to the current user’s
    group.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G`: 这会查找属于当前用户组的文件或目录。'
- en: '`S`: This looks for files or directories that have the SGID permission set.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S`: 这会查找具有SGID权限设置的文件或目录。'
- en: 'For others:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他人：
- en: '`R`: Others have the read permission.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R`: 其他人具有读取权限。'
- en: '`W`: Others have the write permission.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`W`: 其他人具有写权限。'
- en: '`X`: Others have the executable permission.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X`: 其他人具有可执行权限。'
- en: '`t`: This looks for directories that have the sticky bit set.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t`: 这会查找具有粘滞位的目录。'
- en: 'So, how does all this work? Well, let’s say that you’re in the `/bin/` directory,
    and you want to see all of the files that have the SUID permission set. Just do
    something like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，所有这些是如何工作的呢？假设您在`/bin/`目录中，并且想查看所有具有SUID权限的文件。只需像这样做：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you’re in your own home directory and want to see all of the SUID files
    that are on the entire filesystem, just make your search recursive, like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在自己的家目录中并且想查看整个文件系统中的所有SUID文件，只需使搜索递归，如下所示：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Unlike `find`, `ls` isn’t inherently recursive. So, if want to search through
    all of the lower-level subdirectories of the directory you’re already in, just
    do this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与`find`不同，`ls`并非本质上是递归的。因此，如果您想在当前目录的所有下级子目录中进行搜索，只需这样做：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The only difference between this and the full filesystem search is that I used
    `**/*(s)` instead of `/**/*(s)`. (Of course, there are no SUID files in my home
    directory, which is to be expected.)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这与完整的文件系统搜索之间的唯一区别是，我使用了`**/*(s)`而不是`/**/*(s)`。 （当然，在我的家目录中没有SUID文件，这是可以预期的。）
- en: 'If you need to actually do something with this `ls` output, you can create
    a `zsh` script, like this `find_suid.sh` script:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要实际处理这个`ls`输出，您可以创建一个`zsh`脚本，像这样创建一个`find_suid.sh`脚本：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It’s just a simple little script that creates a text file with a list of the
    SUID files on your system. But hey, who says we can’t fancy it up a bit? Let’s
    see what we can do in the `find_suid2.sh` script:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的小脚本，它创建一个包含您系统中所有SUID文件的文本文件。但嘿，谁说我们不能把它弄得更花哨一些呢？让我们看看如何在`find_suid2.sh`脚本中实现：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With this script, you’ll specify the name of the file where you want the results
    to be saved. If there’s already a file with that filename, the script will give
    you a warning message and then exit.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此脚本时，您需要指定要保存结果的文件名。如果该文件名已经存在，脚本会给出警告信息并退出。
- en: 'You can use any of the other globbing qualifiers in the same manner. For example,
    let’s say that you need to search through the entire filesystem for files that
    belong to you. Let’s see how that works:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以相同的方式使用其他任何通配符限定符。例如，假设您需要搜索整个文件系统中属于您的文件。让我们看看是如何工作的：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will make for a very long list, so I have to pipe this into `less` to
    prevent the output from scrolling off the top of the screen. Here’s some of what
    you’ll see:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成一个非常长的列表，因此我必须将其管道输出到`less`以防止输出内容滚出屏幕顶部。以下是您将看到的一部分内容：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you see, a typical Linux system has files that belong to you all over the
    place.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，典型的Linux系统中到处都有属于您的文件。
- en: This is one clear advantage that `zsh` has over every other shell, including
    `bash`. The extended file globbing capabilities of `zsh` can replace much of the
    functionality of `find`, but with much simpler syntax. (Of course, you can also
    use this trick with other utilities besides `ls`, such as `cp`, `mv`, `rm`, `chmod`,
    or `chown`.)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`zsh`相对于其他所有shell（包括`bash`）的一个明显优势。`zsh`的扩展文件通配符功能可以替代`find`的大部分功能，但语法更简单。（当然，您也可以使用这个技巧与除了`ls`之外的其他实用程序一起使用，例如`cp`，`mv`，`rm`，`chmod`或`chown`。）
- en: You can also use `zsh` file globbing to replace utilities such as `grep`, `awk`
    and `tr`. Honestly though, the syntax for globbing commands that replace those
    utilities is so convoluted that you’re better off using the utilities. On the
    other hand, using `zsh` file globbing instead could make your scripts somewhat
    lighter and faster. And, you can use file globbing in those rare cases where you
    might find that the utilities aren’t installed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`zsh`文件通配符来替代`grep`、`awk`和`tr`等工具。老实说，用于替代这些工具的通配符命令语法复杂到让人头疼，因此你最好还是使用这些工具。不过，使用`zsh`文件通配符会使你的脚本变得稍微轻便和更快。而且，在那些可能没有安装这些工具的罕见情况下，你还可以使用文件通配符。
- en: 'At any rate, if you want to read about the additional file globbing capabilities
    of `zsh`, here’s the link:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果你想了解`zsh`的额外文件通配符功能，这里有一个链接：
- en: 'Zsh Native Scripting Handbook:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Zsh原生脚本手册：
- en: '[https://github.zshell.dev/docs/zsh/Zsh-Native-Scripting-Handbook.html](https://github.zshell.dev/docs/zsh/Zsh-Native-Scripting-Handbook.html)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.zshell.dev/docs/zsh/Zsh-Native-Scripting-Handbook.html](https://github.zshell.dev/docs/zsh/Zsh-Native-Scripting-Handbook.html)'
- en: You can also find out more about both file globbing and variable expansion by
    reading the `zshexpn` man page.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过阅读`zshexpn`的手册页来进一步了解文件通配符和变量扩展的相关内容。
- en: All right, let’s talk briefly about arrays.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们简要谈谈数组。
- en: Understanding zsh Arrays
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`zsh`数组
- en: 'This will be quick, because there are only three things that I want to point
    out about `zsh` arrays. The first thing is that instead of having array index
    numbers begin with 0, as is the case with `bash` arrays, the index numbers for
    `zsh` arrays begin with 1\. Here’s how it looks on `bash`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这会很快，因为我只想指出`zsh`数组的三点。第一点是，`zsh`数组的索引编号从1开始，而不像`bash`数组那样从0开始。下面是`bash`的示例：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You see how using an index number of 0 brings up the first name in the list,
    and an index number of 1 brings up the second name. Now, here’s how it looks on
    `zsh`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到使用索引号0时，返回的是列表中的第一个元素，而索引号1则返回第二个元素。现在，在`zsh`中是这样的：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This time, the index number of 0 brings up nothing, because index 0 doesn’t
    exist.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，索引号为0什么也不会返回，因为索引0不存在。
- en: 'The second big difference is in how you can view the entire contents of an
    array. With `bash`, you need to do something like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个大的区别在于如何查看整个数组的内容。使用`bash`时，你需要像这样做：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can still do this on `zsh` if you like, but you don’t have to. Instead,
    you can just view the contents of the array the same as you’d view the value of
    a normal variable, like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你仍然可以在`zsh`中这样做，但你不必这样做。你可以像查看普通变量的值一样查看数组的内容，像这样：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, I want to show you how to eliminate duplicate entries that might be
    in a array. To demonstrate, let’s create an array with a list of fruits, like
    this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想向你展示如何消除数组中的重复条目。为了演示，让我们创建一个包含水果列表的数组，像这样：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you see, there are several duplicates in the list. To get rid of the duplicates,
    just do this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，列表中有几个重复项。要去除这些重复项，只需这样做：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Replacing the `(u)` with `(U)` prints out the entire list in upper-case letters.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将`(u)`替换为`(U)`会将整个列表以大写字母打印出来。
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Combine the `u` with the `U`, and you’ll eliminate duplicates and print out
    the list in upper-case letters.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将`u`和`U`结合使用，你就能去除重复项，并将列表以大写字母打印出来。
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To show this in practice, let’s look at the `fruit_array.sh` script:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际展示，让我们看看`fruit_array.sh`脚本：
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the first stanza, I’m using a `for` loop to print out each individual fruit
    that’s in the `fruits` array. In the second stanza, I wanted to print out each
    individual fruit, without the duplicates. Using `echo` would have printed all
    of the fruits out on a single line, as I showed you in the command-line example
    above. So instead of `echo`, I used `printf`. Here, the `%s` parameter tells `printf`
    to print the designated text strings, which in this case is each member of the
    array. The `\n` option inserts a newline after each fruit. Running the script
    looks like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个代码段中，我使用`for`循环打印出`fruits`数组中的每个水果。在第二个代码段中，我想打印出每个独立的水果，但不包括重复项。使用`echo`会将所有水果打印在同一行，就像我在上面的命令行示例中展示的那样。因此，我没有使用`echo`，而是用了`printf`。这里，`%s`参数告诉`printf`打印指定的文本字符串，在本例中就是数组中的每个成员。`\n`选项在每个水果后插入换行符。运行脚本的效果如下：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There are actually a lot more things that you can do with arrays than I can
    show you here. To read about them, take a look at the `zshexpn` man page.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其实你可以在数组上做更多的事情，比我在这里所能展示的要多。要了解它们，看看 `zshexpn` 手册页。
- en: That does it for arrays. So now, let’s talk about math.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 数组部分到此为止。那么现在，让我们来谈谈数学。
- en: Enhanced Math Capabilities
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强的数学功能
- en: In *Chapter 11—Performing Mathematical Operations*, I explained that `bash`
    has only limited builtin math capabilities, and that it can only work with integers.
    For anything beyond that, you’ll need to use an external program, such as `bc`,
    in your `bash` scripts. On the other hand, `zsh` has expanded math capabilities
    built right in.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 11 章—执行数学运算* 中，我解释了 `bash` 只有有限的内建数学功能，并且只能处理整数。对于更复杂的运算，你需要在 `bash` 脚本中使用外部程序，例如
    `bc`。另一方面，`zsh` 内建了更强大的数学功能。
- en: 'For our first example, let’s try to divide 5 by 2 from the `zsh` command-line:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个例子，让我们尝试在 `zsh` 命令行中将 5 除以 2：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Well, that wasn’t what I wanted. I should see a final answer of 2.5, instead
    of 2\. What’s going on? The answer is that to perform floating point math, you
    have to explicitly express one of the numbers as a floating point number. So,
    let’s fix that.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那不是我想要的。我应该看到最终答案是 2.5，而不是 2。发生了什么？答案是，为了执行浮动点数学，你必须明确地将其中一个数字表示为浮动点数。所以，我们来修正这个问题。
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Much better. By expressing the first number as 5.0 instead of 5, the floating
    point math works. Unfortunately though, the `zsh` math isn’t quite perfect. I
    mean, it worked fine for this division example, but watch what happens when I
    try any other operation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 好得多。通过将第一个数字表示为 5.0 而不是 5，浮动点数学得以正常工作。不幸的是，`zsh` 的数学功能并不完美。我的意思是，它在这个除法例子中工作得很好，但看看当我尝试其他任何操作时会发生什么：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For some reason that I don’t understand, `zsh` adds extra trailing digits after
    the decimal point. It wouldn’t matter much if they were all zeros, but you also
    have the spurious 2 and 9 at the end, which throws off our calculations. Fortunately,
    we can easily correct that by just assigning the results to a variable, like so:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 出于某种我不理解的原因，`zsh` 在小数点后添加了额外的尾随数字。如果它们全是零倒还无所谓，但尾随的 2 和 9 让我们的计算结果出现了问题。幸运的是，我们可以通过简单地将结果赋给一个变量来轻松修正这个问题，就像这样：
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The trailing zeros are still there, but at least the spurious 2 and 9 digits
    aren’t.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尾随的零仍然存在，但至少多余的 2 和 9 数字不见了。
- en: Even after some rather extensive research, I was never able to find any command
    or option switch that I can use to specify the number of digits to show past the
    decimal point.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 即使经过了一些相当广泛的研究，我也从未找到可以用来指定小数点后显示数字位数的命令或选项开关。
- en: 'Grouping math operations, in order to specify their precedence, looks like
    this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 分组数学运算，以指定它们的优先级，像这样写：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If just simple math isn’t enough for you, you can load the `mathfunc` module,
    which I’ll show you in the next section.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果简单的数学运算不足以满足你的需求，你可以加载 `mathfunc` 模块，我将在接下来的章节中展示给你。
- en: Using zsh Modules
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 zsh 模块
- en: A lot of `zsh` functionality is contained in loadable `zsh` modules. I can’t
    cover all of the `zsh` modules in this chapter, so let’s just look at some of
    the more useful ones.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 很多 `zsh` 功能包含在可加载的 `zsh` 模块中。我无法在本章中涵盖所有的 `zsh` 模块，因此我们只看一些更有用的模块。
- en: 'First, let’s see which modules get loaded into a `zsh` session by default:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下默认情况下哪些模块会加载到 `zsh` 会话中：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There are a lot more optional modules that you can load yourself by using the
    `zmodload` command, as we’ll see next.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多更多可选的模块，你可以通过使用 `zmodload` 命令自行加载，正如我们接下来要看到的。
- en: To read about all of the available `zsh` modules, see the `zshmodules` man page.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可用的 `zsh` 模块，请参阅 `zshmodules` 手册页。
- en: Now, let’s get a bit more specific by looking at the `mathfunc` module.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过查看 `mathfunc` 模块来更具体一些。
- en: Using the mathfunc Module
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 mathfunc 模块
- en: 'If you want to create some really fancy math scripts without having to use
    an external utility such as `bc`, just load the `mathfunc` module, like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一些非常复杂的数学脚本，而不需要使用像 `bc` 这样的外部工具，只需加载 `mathfunc` 模块，如下所示：
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This module provides functions for trigonometry, logarithms, exponentiation,
    as well as some other math functions. You can see all the functions that the modules
    provide, like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块提供了三角函数、对数、指数运算以及其他一些数学函数。你可以这样查看模块提供的所有函数：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'So now, let’s say that you want to see the square root of 9\. Do it like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在，假设你想查看 9 的平方根。可以这样做：
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, let’s put this into the `squareroot.sh` script:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把这个放入 `squareroot.sh` 脚本中：
- en: '[PRE60]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note here that I’ve had to place a `zmodload zsh/mathfunc` command at the beginning
    of this script. That’s because every time you close your terminal or log out of
    your machine, any modules that you’ve loaded from the command-line will automatically
    unload. So, you’ll have to add this `zmodload` command to your scripts.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我必须在此脚本的开头放置一个`zmodload zsh/mathfunc`命令。这是因为每次关闭终端或注销计算机时，您通过命令行加载的任何模块都会自动卸载。因此，您需要将此`zmodload`命令添加到脚本中。
- en: Here, I’m using the `your_number` variable to contain the value of the number
    that the user specifies for the `$1` parameter. Let’s see if it works.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用`your_number`变量来保存用户为`$1`参数指定的数字值。让我们看看它是否有效。
- en: '[PRE61]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Oh yeah, it works just fine, and all without messing with any external programs,
    such as `bc`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，没错，它运行得很好，而且完全不需要修改任何外部程序，比如`bc`。
- en: All of the other `mathfunc` functions work in a similar manner. Use your own
    imagination and the scripting concepts that I’ve shown you for `bash` to come
    up with your own `zsh` math scripts.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 其他所有`mathfunc`函数也以类似方式工作。运用你的想象力，以及我为`bash`展示的脚本概念，来创建你自己的`zsh`数学脚本。
- en: That does it for your introduction of the `mathfunc` module. Next, let’s briefly
    look at the `datetime` module.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你对`mathfunc`模块的简介。接下来，我们简要看看`datetime`模块。
- en: The datetime Module
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`datetime`模块'
- en: 'The `datetime` module does pretty much the same job as the `date` utility.
    You can use either one to do cool things, like creating files with timestamps
    in their filenames. It’s not loaded by default, so let’s do that now:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`datetime`模块的功能几乎与`date`命令相同。你可以使用其中任何一个做一些酷的事情，比如在文件名中创建带时间戳的文件。它默认没有加载，因此我们现在来加载它：'
- en: '[PRE62]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, let’s see what it provides:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看它提供了什么：
- en: '[PRE63]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here’s the breakdown of what you’re looking at:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是你正在查看的内容的详细说明：
- en: '`strftime`: This is the only function that this module contains. You can use
    it the same as you’d use the `date` utility.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strftime`：这是此模块中唯一的函数。你可以像使用`date`命令一样使用它。'
- en: '`EPOCHSECONDS`: This environmental variable is an integer value that represents
    the number of seconds that have elapsed since the beginning of the Unix epoch.
    This variable is also available in `bash`.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EPOCHSECONDS`：这个环境变量是一个整数值，表示自Unix纪元开始以来经过的秒数。这个变量在`bash`中也可用。'
- en: '`EPOCHREALTIME`: This environmental variable is a floating point value that
    represents the number of seconds that have elapsed since the beginning of the
    Unix epoch. Depending upon the particular system, this value can be to either
    nanosecond or microsecond accuracy. This variable is also available in `bash`.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EPOCHREALTIME`：这个环境变量是一个浮动值，表示自Unix纪元开始以来经过的秒数。根据系统的不同，这个值的精确度可能达到纳秒或微秒级别。这个变量在`bash`中也可用。'
- en: '`epochtime`: This variable contains two components. It’s like the `EPOCHREALTIME`
    variable, except that the decimal point is replaced by a blank space. This variable
    is not available in `bash`.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`epochtime`：这个变量包含两个组件。它像`EPOCHREALTIME`变量，只不过小数点被空格代替。这个变量在`bash`中不可用。'
- en: The Unix epoch began on 1 January, 1970\. In the early days of Unix, Unix developers
    decided that the easiest way to set the time on a Unix computer would be to express
    it as the number of seconds that have elapsed since that date.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Unix纪元从1970年1月1日开始。早期的Unix开发者决定，设置Unix计算机时间的最简单方法就是以自该日期以来经过的秒数来表示时间。
- en: 'You can see the current values of the three variables like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式查看当前三个变量的值：
- en: '[PRE64]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, let’s create the `zsh_time.sh` script that uses the `strftime` function:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个使用`strftime`函数的`zsh_time.sh`脚本：
- en: '[PRE65]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `strftime` function uses the same date and time formatting options as the
    `date` utility uses. In this case we have:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`strftime`函数使用与`date`命令相同的日期和时间格式选项。在这种情况下，我们有：'
- en: '`%A`: This is the day of the week.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%A`：这是星期几。'
- en: '`%F`: This is the date in YYYY-MM-DD format.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%F`：这是以YYYY-MM-DD格式表示的日期。'
- en: '`%T`: This is the time in HH:MM:SS format.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%T`：这是以HH:MM:SS格式表示的时间。'
- en: 'The only real difference between using `date` and `strftime` is that with `date`,
    you have to precede the string of formatting options with a `+`, like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`date`和`strftime`的唯一区别是，使用`date`时，必须在格式选项字符串前加上`+`，像这样：
- en: '[PRE66]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `strftime` function has its own man page, which you can view by doing `man
    strftime`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`strftime`函数有自己的手册页，你可以通过运行`man strftime`来查看。'
- en: 'After I run the script, I should have my file:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我运行脚本之后，我应该会得到我的文件：
- en: '[PRE67]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: I’ve covered what I believe are the most useful modules. If you want to read
    about the rest of the `zsh` modules, take a look at the `zshmodules` man page.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经介绍了我认为最有用的模块。如果你想阅读其他`zsh`模块的内容，可以查看`zshmodules`手册页。
- en: I think that this will just about do it for our introduction to `zsh` scripting.
    Let’s wrap up and move on.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这差不多可以作为我们对`zsh`脚本的介绍了。让我们总结一下，继续前进。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I introduced you to the concept of scripting in `zsh` instead
    of in `bash`. I began by showing you how to install `zsh`, if it isn’t installed
    already. I showed you some of the differences between `bash` and `zsh` features
    that could impact how you’d write a `zsh` script. These include differences in
    file globbing, variable expansion, array indexing, and math operations. Along
    the way, I showed you how these `zsh` features can help you build scripts that
    are simpler, yet more functional, than `bash` scripts.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我向你介绍了在`zsh`中编写脚本的概念，而不是在`bash`中编写。我从展示如何安装`zsh`开始，如果它还没有安装的话。我展示了`bash`和`zsh`之间的差异，这些差异可能会影响你编写`zsh`脚本的方式。这些差异包括文件通配符、变量扩展、数组索引和数学运算的不同。在过程中，我向你展示了这些`zsh`特性如何帮助你编写比`bash`脚本更简单、更有功能的脚本。
- en: The main problem with `zsh` scripting, other than the fact that `bash` is much
    more prevalent, is the lack of documentation. There are plenty of tutorials and
    articles about setting up a `zsh` user environment, but very little about `zsh`
    scripting. Hopefully, you’ll be able to use the knowledge that I’ve provided here
    to write some cool `zsh` scripts.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`zsh`脚本的主要问题，除了`bash`更加普及之外，就是缺乏文档。关于设置`zsh`用户环境的教程和文章有很多，但关于`zsh`脚本的很少。希望你能利用我在这里提供的知识编写一些酷炫的`zsh`脚本。'
- en: In the next and final chapter, I’ll introduce you to the idea of using PowerShell
    on Linux. (Yes, you read that correctly.) I’ll see you there.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，也是最后一章中，我将向你介绍如何在Linux上使用PowerShell。（是的，你没看错。）我们在那里见。
- en: Questions
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which command would you use to view all of the `zsh` modules that have been
    loaded into your `zsh` session?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪个命令来查看已加载到你的`zsh`会话中的所有`zsh`模块？
- en: '`zmodls`'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zmodls`'
- en: '`zmod -l`'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zmod -l`'
- en: '`zmodload -l`'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zmodload -l`'
- en: '`zmodload`'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zmodload`'
- en: You want to load the math function module. Which of these commands would you
    use?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想加载数学函数模块。你会使用以下哪个命令？
- en: '`zmod mathfunc`'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zmod mathfunc`'
- en: '`zmod zsh/mathfunc`'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zmod zsh/mathfunc`'
- en: '`zmodload -l mathfunc`'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zmodload -l mathfunc`'
- en: '`zmodload -l zsh/mathfunc`'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zmodload -l zsh/mathfunc`'
- en: '`zmodload zsh/mathfunc`'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zmodload zsh/mathfunc`'
- en: What is a major difference between the way that `bash` and `zsh` handle arrays?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bash`和`zsh`处理数组的主要区别是什么？'
- en: There is no difference.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有区别。
- en: '`bash` array indexing begins at 1, `zsh` array indexing begins at 0.'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bash`数组索引从1开始，`zsh`数组索引从0开始。'
- en: '`bash` array indexing begins at 0, `zsh` array indexing begins at 1.'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bash`数组索引从0开始，`zsh`数组索引从1开始。'
- en: '`bash` can work with arrays, but `zsh` can’t.'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bash`可以处理数组，但`zsh`不能。'
- en: Which `zsh` command would you use to view all of the `.png` files and all of
    the `.PNG` files that are in your directory?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪个`zsh`命令来查看目录中所有的`.png`文件和`.PNG`文件？
- en: '`ls *.png`'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ls *.png`'
- en: '`ls (#i).png`'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ls (#i).png`'
- en: '`ls (#l).PNG`'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ls (#l).PNG`'
- en: '`ls *.PNG`'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ls *.PNG`'
- en: You only want to view the empty directories that are in your current working
    directory. Which of these `zsh` commands would you use?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你只想查看当前工作目录中的空目录。你会使用以下哪个`zsh`命令？
- en: '`ls -l *(/^F)`'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ls -l *(/^F)`'
- en: '`ls -l *(^F)`'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ls -l *(^F)`'
- en: '`ls -l *(F)`'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ls -l *(F)`'
- en: '`ls -ld`'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ls -ld`'
- en: Further Reading
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The Z Shell Manual: [https://zsh-manual.netlify.app/](https://zsh-manual.netlify.app/)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z Shell手册：[https://zsh-manual.netlify.app/](https://zsh-manual.netlify.app/)
- en: 'What is ZSH, and Why Should You Use It Instead of Bash?: [https://www.howtogeek.com/362409/what-is-zsh-and-why-should-you-use-it-instead-of-bash/](https://www.howtogeek.com/362409/what-is-zsh-and-why-should-you-use-it-instead-of-bash/)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是ZSH，为什么你应该使用它而不是Bash？：[https://www.howtogeek.com/362409/what-is-zsh-and-why-should-you-use-it-instead-of-bash/](https://www.howtogeek.com/362409/what-is-zsh-and-why-should-you-use-it-instead-of-bash/)
- en: 'ZSH for Starters: Exploring Linux’s Elegant Shell: [https://www.fosslinux.com/133167/zsh-for-beginners-exploring-linuxs-elegant-shell.htm](https://www.fosslinux.com/133167/zsh-for-beginners-exploring-linuxs-elegant-shell.htm)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ZSH入门：探索Linux的优雅Shell：[https://www.fosslinux.com/133167/zsh-for-beginners-exploring-linuxs-elegant-shell.htm](https://www.fosslinux.com/133167/zsh-for-beginners-exploring-linuxs-elegant-shell.htm)
- en: 'How to Write Script for ZSH: [https://www.linuxtoday.com/blog/writing-scripts-for-zsh/](https://www.linuxtoday.com/blog/writing-scripts-for-zsh/)'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为ZSH编写脚本：[https://www.linuxtoday.com/blog/writing-scripts-for-zsh/](https://www.linuxtoday.com/blog/writing-scripts-for-zsh/)
- en: Answers
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: d
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: e
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: e
- en: c
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: b
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: a
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a
- en: Join our community on Discord!
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Linux专家以及作者本人一起阅读这本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 提出问题，为其他读者提供解决方案，通过“问我任何问题”（Ask Me Anything）环节与作者交流，等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
