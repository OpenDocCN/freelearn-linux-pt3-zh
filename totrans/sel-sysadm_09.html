<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div id="_idContainer026" class="calibre2">
			<h1 id="_idParaDest-212" class="calibre5"><em class="italic"><a id="_idTextAnchor216" class="pcalibre calibre6 pcalibre1"/>Chapter 7</em>: Configuring Application-Specific SELinux Controls</h1>
			<p class="calibre3">Several Linux services and applications enable additional SELinux controls besides the kernel-enforced SELinux policy. They allow the administrator to further manipulate and enforce policy rules through the application itself—isolating users, reducing data leakage risks, and mitigating the impact of malicious behavior.</p>
			<p class="calibre3">In this chapter, we will look at several SELinux-aware applications, such as systemd services and how they allow administrators to set up and specify target domains and resource labels. We'll also cover the D-Bus service, which allows SELinux policies to control the service binding and message communication within D-Bus itself. Next, we'll jump to PAM-enabled services that allow users to log in through them.</p>
			<p class="calibre3">Finally, we'll end the chapter with <strong class="source-inline">mod_selinux</strong>, an Apache module that allows SELinux-specific tuning of the web server's behavior. This approach shows how applications that do not natively have SELinux support can still be extended to address the administrator's requirements.</p>
			<p class="calibre3">We will cover the following topics in this chapter:</p>
			<ul class="calibre8">
				<li class="calibre9">Tuning systemd services, logging, and device management</li>
				<li class="calibre9">Communicating over D-Bus</li>
				<li class="calibre9">Configuring PAM services</li>
				<li class="calibre9">Using mod_selinux with Apache</li>
			</ul>
			<h1 id="_idParaDest-213" class="calibre5"><a id="_idTextAnchor217" class="pcalibre calibre6 pcalibre1"/>Technical requirements</h1>
			<p class="calibre3">Check out the following video to see the Code in Action: <a href="https://bit.ly/37jYtze" class="pcalibre calibre6 pcalibre1">https://bit.ly/37jYtze</a></p>
			<h1 id="_idParaDest-214" class="calibre5"><a id="_idTextAnchor218" class="pcalibre calibre6 pcalibre1"/>Tuning systemd services, logging, and device management</h1>
			<p class="calibre3"><strong class="bold">systemd</strong> is a <a id="_idIndexMarker529" class="pcalibre calibre6 pcalibre1"/>core component of many Linux distributions. Since its <a id="_idIndexMarker530" class="pcalibre calibre6 pcalibre1"/>birth in 2010, many distributions have gradually adopted systemd as the core <strong class="source-inline">init</strong> system, responsible for handling services and boot-up operations.</p>
			<p class="calibre3">Throughout <a id="_idIndexMarker531" class="pcalibre calibre6 pcalibre1"/>its development phase, systemd added several other <a id="_idIndexMarker532" class="pcalibre calibre6 pcalibre1"/>components to its portfolio:</p>
			<ul class="calibre8">
				<li class="calibre9">D-Bus, which offers a system and session bus service allowing the use of D-Bus for inter-application communication, merged with systemd.</li>
				<li class="calibre9">systemd also incorporated <strong class="source-inline">udev</strong>, which offers a flexible device-node management application.</li>
				<li class="calibre9">Login capabilities were added to systemd, enabling fine-grained control over user sessions.</li>
				<li class="calibre9">The <strong class="source-inline">journald</strong> daemon joined the systemd family to provide a new approach to system and service logging, replacing some of the functionality of standard system loggers.</li>
				<li class="calibre9">The <strong class="source-inline">timerd</strong> daemon provides support for the time-based execution of tasks, replacing some of the functionality of standard cron daemons.</li>
				<li class="calibre9">Network configurations can be managed by systemd-networkd.</li>
			</ul>
			<p class="calibre3">This ongoing approach of absorbing several system services into a single application suite has not gone unnoticed and isn't without controversy. Some distributions even refuse to have systemd as the default <strong class="source-inline">init</strong> system.</p>
			<p class="calibre3">The systemd project includes SELinux support for most of its services. Applications such as systemd, which not only include SELinux awareness but also enforce access controls on specific <a id="_idIndexMarker533" class="pcalibre calibre6 pcalibre1"/>SELinux classes and permissions (rather than relying on the Linux kernel), are called <strong class="bold">userspace object managers</strong>:</p>
			<div class="calibre13">
				<div id="_idContainer025" class="img---figure">
					<img src="Images/B16276_07_001.jpg" alt="Figure 7.1 — The difference between kernel-enforced, standard SELinux, and userspace-managed SELinux " class="calibre26"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 — The difference between kernel-enforced, standard SELinux, and userspace-managed SELinux</p>
			<p class="calibre3">If an <a id="_idIndexMarker534" class="pcalibre calibre6 pcalibre1"/>application enforces access controls toward certain classes <a id="_idIndexMarker535" class="pcalibre calibre6 pcalibre1"/>and permissions, then it will also have its own AVC (see <a href="B16276_02_Final_VK.xhtml#_idTextAnchor045" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding SELinux Decisions and Logging</em>, for more information about the AVC). Log <a id="_idIndexMarker536" class="pcalibre calibre6 pcalibre1"/>events resulting from these applications will be identified as <strong class="source-inline">USER_AVC</strong> events rather than (kernel-managed) <strong class="source-inline">AVC</strong> events. The systemd application has support for systemd-specific classes, as we will see in the <em class="italic">Governing unit operation access </em>section. But before we dive into these specific details, let's first see what systemd is all about and what SELinux support it has.</p>
			<h2 id="_idParaDest-215" class="calibre10"><a id="_idTextAnchor219" class="pcalibre calibre6 pcalibre1"/>Service support in systemd</h2>
			<p class="calibre3">The main <a id="_idIndexMarker537" class="pcalibre calibre6 pcalibre1"/>capability of the system daemon that most people know about is its support for system services. Unlike traditional SysV-compatible <strong class="source-inline">init</strong> systems, systemd does not use scripts to manage services. Instead, it uses a declarative approach for the various services, documenting the wanted state and configuration parameters while using its own logic to ensure that the right set of services start at the right time and in the correct order.</p>
			<h3 class="calibre12">Understanding unit files</h3>
			<p class="calibre3">systemd uses <a id="_idIndexMarker538" class="pcalibre calibre6 pcalibre1"/>unit files to declare how a service should behave. These unit files use the INI-style syntax, supporting sections and key/value pairs within each file. A service can have multiple unit files that influence the service at large. It is important to remember that different unit files for the same service are all related:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">*.service</strong> unit files define how a system service should be launched, what its dependencies are, how systemd should treat sudden failures, and so on.</li>
				<li class="calibre9">The <strong class="source-inline">*.socket</strong> unit files define which socket(s) should be created and which permissions should be assigned to it. systemd uses this for services that can be launched on request rather than directly at boot.</li>
				<li class="calibre9">The <strong class="source-inline">*.timer</strong> unit files define at what time or frequency the service should be launched. Services that do not necessarily run daemonized but need to execute a certain logic at defined intervals can use these timer files to ensure regular runs. These settings are comparable to the more classic yet still widely used crontabs, which we briefly touch upon in <em class="italic">PAM services</em>, in the subsection called <em class="italic">Cron</em>.</li>
			</ul>
			<p class="calibre3">Other unit files exist as well, although those have more in common with generic system configurations (such as slice definitions and automount settings) and less with runtime services.</p>
			<p class="calibre3">System unit files can be placed in one of three locations:</p>
			<ul class="calibre8">
				<li class="calibre9">Unit files are installed by default by the system's package manager inside <strong class="source-inline">/usr/lib/systemd/system</strong>.</li>
				<li class="calibre9">At runtime, updates can be placed inside <strong class="source-inline">/run/systemd/system</strong>, which will override the unit files in the default location. However, this location is transient and will not persist across reboots.</li>
				<li class="calibre9">System administrators can override the configurations in the two locations by placing unit files in <strong class="source-inline">/etc/systemd/system</strong>. These unit files override previous definitions, so there is no need to remove the unit files from the previous locations.</li>
			</ul>
			<p class="calibre3">As an example, check out the default Nginx service unit file, <strong class="source-inline">nginx.service</strong>, inside <strong class="source-inline">/usr/lib/systemd/system</strong>:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=The nginx HTTP and reverse proxy server</p>
			<p class="source-code">After=network.target remote-fs.target nss-lookup.target</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">Type=forking</p>
			<p class="source-code">PIDFile=/run/nginx.pid</p>
			<p class="source-code">ExecStartPre=/usr/bin/rm -f /run/nginx.pid</p>
			<p class="source-code">ExecStartPre=/usr/sbin/nginx -t</p>
			<p class="source-code">ExecStart=/usr/sbin/nginx</p>
			<p class="source-code">ExecReload=/bin/kill -s HUP $MAINPID</p>
			<p class="source-code">KillSignal=SIGQUIT</p>
			<p class="source-code">TimeoutStopSec=5</p>
			<p class="source-code">KillMode=mixed</p>
			<p class="source-code">PrivateTmp=true</p>
			<p class="source-code">[Install]</p>
			<p class="source-code">WantedBy=multi-user.target</p>
			<p class="calibre3">This unit file <a id="_idIndexMarker539" class="pcalibre calibre6 pcalibre1"/>declares the command to launch Nginx with and informs systemd that the service should be launched after successfully reaching the <strong class="source-inline">network</strong>, <strong class="source-inline">remote-fs</strong>, and <strong class="source-inline">nss-lookup</strong> targets (which is a milestone in the boot process, allowing proper dependency handling). The unit file also declares that it is a dependency of the <strong class="source-inline">multi-user</strong> target (which is the equivalent of the default run level when using SysV-style <strong class="source-inline">init</strong> services), which means the service should launch when the system boots.</p>
			<h3 class="calibre12">Setting the SELinux context for a service</h3>
			<p class="calibre3">When <a id="_idIndexMarker540" class="pcalibre calibre6 pcalibre1"/>systemd launches a service, it executes the command defined through the <strong class="source-inline">ExecStart=</strong> configuration entry in the service unit file. By default, a standard domain transition will occur as defined through the SELinux policy.</p>
			<p class="calibre3">Package developers and system administrators can, however, update the service unit files to have the service launched in an explicitly mentioned SELinux domain. To accomplish this, the <strong class="source-inline">[Service]</strong> section of the unit file can be extended with the <strong class="source-inline">SELinuxContext=</strong> configuration entry.</p>
			<p class="calibre3">For instance, to ensure that Nginx launches with the <strong class="source-inline">httpd_t:s0:c0.c128</strong> context, you'd use this:</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">Type=forking</p>
			<p class="source-code">PIDFile=/run/nginx.pid</p>
			<p class="source-code">ExecStartPre=/usr/bin/rm -f /run/nginx.pid</p>
			<p class="source-code">ExecStartPre=/usr/sbin/nginx -t</p>
			<p class="source-code">ExecStart=/usr/sbin/nginx</p>
			<p class="source-code">ExecReload=/bin/kill -s HUP $MAINPID</p>
			<p class="source-code"><strong class="bold">SELinuxContext=system_u:system_r:httpd_t:s0:c0.c128</strong></p>
			<p class="source-code">KillSignal=SIGQUIT</p>
			<p class="source-code">TimeoutStopSec=5</p>
			<p class="source-code">KillMode=mixed</p>
			<p class="source-code">PrivateTmp=true</p>
			<p class="calibre3">Of course, it is also possible to use this to have a service running with a different context, which can be useful when developing custom policies for daemons. However, keep in mind that the SELinux policy rules still apply: you cannot ask systemd to launch Nginx, for instance, with the <strong class="source-inline">dnsmasq_t</strong> domain without updating the SELinux policy so that <strong class="source-inline">httpd_exec_t</strong> (the entry point for the <strong class="source-inline">httpd_t</strong> domain) is also made an entry point for the <strong class="source-inline">dnsmasq_t</strong> domain.</p>
			<p class="calibre3">When you <a id="_idIndexMarker541" class="pcalibre calibre6 pcalibre1"/>request systemd to explicitly use an SELinux context for a service, systemd will attempt to use this context for all execution-related tasks: <strong class="source-inline">ExecStartPre</strong>, <strong class="source-inline">ExecStart</strong>, <strong class="source-inline">ExecStartPost</strong>, <strong class="source-inline">ExecStopPre</strong>, <strong class="source-inline">ExecStop</strong>, <strong class="source-inline">ExecStopPost</strong>, and <strong class="source-inline">ExecReload</strong>. As these tasks often are not labeled with the right entry point label, these commands can fail. In that case, prefix the commands with <strong class="source-inline">+</strong> so that the SELinux context definition does not apply to them:</p>
			<p class="source-code">[Service]</p>
			<p class="source-code">Type=forking</p>
			<p class="source-code">PIDFile=/run/nginx.pid</p>
			<p class="source-code"><strong class="bold">ExecStartPre=+/usr/bin/rm -f /run/nginx.pid</strong></p>
			<p class="source-code">ExecStartPre=/usr/sbin/nginx -t</p>
			<p class="source-code">ExecStart=/usr/sbin/nginx</p>
			<p class="source-code">ExecReload=/bin/kill -s HUP $MAINPID</p>
			<p class="source-code">SELinuxContext=system_u:system_r:httpd_t:s0:c0.c128</p>
			<p class="source-code">KillSignal=SIGQUIT</p>
			<p class="source-code">TimeoutStopSec=5</p>
			<p class="source-code">KillMode=mixed</p>
			<p class="source-code">PrivateTmp=true</p>
			<p class="calibre3">While developing and changing unit files, the changed settings might not always be immediately applied to the system. Running <strong class="source-inline">systemctl daemon-reload</strong> after modifying unit files will ensure that the latest changes on the system are read by systemd.</p>
			<h3 class="calibre12">Using transient services</h3>
			<p class="calibre3">systemd <a id="_idIndexMarker542" class="pcalibre calibre6 pcalibre1"/>can also be used to launch applications as if they are services and have them under systemd's control. Such applications <a id="_idIndexMarker543" class="pcalibre calibre6 pcalibre1"/>are called <strong class="bold">transient services</strong> as they lack the unit files that generally declare how systemd should behave.</p>
			<p class="calibre3">Transient services are launched through the <strong class="source-inline">systemd-run</strong> application. To show this, let's create a simple Python script (one that calculates Pi up to 10,000 digits):</p>
			<p class="source-code">from decimal import Decimal, getcontext</p>
			<p class="source-code">getcontext().prec=10000</p>
			<p class="source-code">with open('/tmp/pi.out', 'w') as f:</p>
			<p class="source-code">  print(sum(1/Decimal(16)**k * (</p>
			<p class="source-code">    Decimal(4)/(8*k+1)-</p>
			<p class="source-code">    Decimal(2)/(8*k+4)-</p>
			<p class="source-code">    Decimal(1)/(8*k+5)-</p>
			<p class="source-code">    Decimal(1)/(8*k+6)) for k in range(10000)), file=f)</p>
			<p class="calibre3">As this takes some time, we can opt to run this Python script under systemd's control:</p>
			<p class="source-code"># systemd-run python3.6 /tmp/pi.py</p>
			<p class="source-code">Running as unit: run-rf9ce45c...f343.service</p>
			<p class="calibre3">As transient <a id="_idIndexMarker544" class="pcalibre calibre6 pcalibre1"/>services do not have unit files to manage, changing the SELinux context must be accomplished through the command line as well. Of course, this is only needed if the standard domain transitions defined in the policy do not result in the wanted behavior:</p>
			<p class="source-code"># systemd-run -p SELinuxContext=guest_u:guest_r:guest_t:s0 python3.6 /tmp/pi.py</p>
			<p class="calibre3">The <strong class="source-inline">systemd-run</strong> application supports this through the <strong class="source-inline">--property</strong> (or <strong class="source-inline">-p</strong>) option, through which unit file properties can be added. In the previous example, we use this option to run the script in the <strong class="source-inline">guest_t</strong> domain using the <strong class="source-inline">SELinuxContext</strong> property, similar to how we would define this in the unit file itself.</p>
			<h3 class="calibre12">Requiring SELinux for a service</h3>
			<p class="calibre3">Some services <a id="_idIndexMarker545" class="pcalibre calibre6 pcalibre1"/>should only run when SELinux is enabled or disabled. With systemd, this can be defined through its conditional parameters.</p>
			<p class="calibre3">A service unit file can contain several conditions that need to be valid before systemd will consider executing the service. These conditionals can point to the system type (virtualized or not), kernel command-line parameters, files that do or don't exist, and so on. The one we are interested in is <strong class="source-inline">ConditionSecurity</strong>, which represents the state of the given security system—in our case, SELinux.</p>
			<p class="calibre3">For instance, look at the <strong class="source-inline">selinux-autorelabel.service</strong> unit file inside <strong class="source-inline">/usr/lib/systemd/system</strong>:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=Relabel all filesystems</p>
			<p class="source-code">DefaultDependencies=no</p>
			<p class="source-code">Conflicts=shutdown.target</p>
			<p class="source-code">After=sysinit.target</p>
			<p class="source-code">Before=shutdown.target</p>
			<p class="source-code"><strong class="bold">ConditionSecurity=selinux</strong></p>
			<p class="source-code">[Service]</p>
			<p class="source-code">ExecStart=/usr/libexec/selinux/selinux-autorelabel</p>
			<p class="source-code">Type=oneshot</p>
			<p class="source-code">TimeoutSec=0</p>
			<p class="source-code">RemainAfterExit=yes</p>
			<p class="source-code">StandardOutput=journal+console</p>
			<p class="calibre3">Similarly, the <a id="_idIndexMarker546" class="pcalibre calibre6 pcalibre1"/>Linux distribution provides the <strong class="source-inline">selinux-autorelabel-mark.service</strong> file. This service ensures that, if SELinux is not active when the system boots (and no <strong class="source-inline">/.autorelabel</strong> file exists yet), then systemd will create an empty <strong class="source-inline">/.autorelabel</strong> file. This file ensures that, when the system reboots with SELinux support, the relabeling operation occurs.</p>
			<h3 class="calibre12">Relabeling files during service startup</h3>
			<p class="calibre3">One of the <a id="_idIndexMarker547" class="pcalibre calibre6 pcalibre1"/>actions that many services require is the preparation of service-specific runtime directories, such as <strong class="source-inline">/run/httpd</strong> for the Apache service. systemd supports this through <strong class="source-inline">tmpfiles.d</strong>. We have briefly covered <strong class="source-inline">tmpfiles</strong> in <a href="B16276_04_Final_VK.xhtml#_idTextAnchor095" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 4</em></a>, <em class="italic">Using File Contexts and Process Domains</em>. Within <strong class="source-inline">tmpfiles</strong>, we can define the files and locations requested to be provided or updated immediately (at boot time) when these are not placed in the (persisted) filesystem.</p>
			<p class="calibre3">For instance, the package that provides the Apache daemon installs the following definition as <strong class="source-inline">/usr/lib/tmpfiles.d/httpd.conf</strong> on the system:</p>
			<p class="source-code">d /run/httpd	710 root apache</p>
			<p class="source-code">d /run/httpd/htcacheclean	700 apache</p>
			<p class="calibre3">Like the systemd unit files, the files that contain these settings should be declared in one of the following three locations. Each location overrides the settings of the previous one:</p>
			<ul class="calibre8">
				<li class="calibre9">The default, package-provided location is <strong class="source-inline">/usr/lib/tmpfiles.d</strong>.</li>
				<li class="calibre9">Runtime declarations can be placed in <strong class="source-inline">/run/tmpfiles.d</strong>.</li>
				<li class="calibre9">Local system administrator-provided declarations are placed in <strong class="source-inline">/etc/tmpfiles.d</strong>.</li>
			</ul>
			<p class="calibre3">These definitions can get much more specific than just directory creation. Through the <strong class="source-inline">tmpfiles.d</strong> application, definitions can be set to create files, empty directories upfront, create sub-volumes, manage special files such as symbolic links or block devices, set extended attributes, and more.</p>
			<p class="calibre3">One of its features is to set the file mode and ownership, and restore the SELinux context on a file (<strong class="source-inline">z</strong>) or recursively against a directory (<strong class="source-inline">Z</strong>). This can be used to change contexts on files that have a proper context definition in the policy, but whose context is not properly assigned.</p>
			<p class="calibre3">For instance, look at the definitions in the <strong class="source-inline">selinux-policy.conf</strong> file inside <strong class="source-inline">/usr/lib/tmpfiles.d</strong>:</p>
			<p class="source-code">z /sys/devices/system/cpu/online - - -</p>
			<p class="source-code">Z /sys/class/net - - -</p>
			<p class="source-code">z /sys/kernel/uevent_helper - - -</p>
			<p class="source-code">w /sys/fs/selinux/checkreqprot - - - - 0</p>
			<p class="calibre3">We need <a id="_idIndexMarker548" class="pcalibre calibre6 pcalibre1"/>to relabel files inside <strong class="source-inline">/sys</strong> because this location is labeled with <strong class="source-inline">sysfs_t</strong> by default and changing the context at runtime does not preserve its status across reboots. Yet some of its files should have a different label – the <strong class="source-inline">/sys/devices/system/cpu/online</strong> file, for instance, requires the <strong class="source-inline">cpu_online_t</strong> label:</p>
			<p class="source-code"># matchpathcon /sys/devices/system/cpu/online</p>
			<p class="source-code">/sys/devices/system/cpu/online  system_u:object_r:cpu_online_t:s0</p>
			<p class="calibre3">The definition ensures that this (pseudo) file is relabeled at boot so that all other processes that rely on the file labeled with <strong class="source-inline">cpu_online_t</strong> can happily continue working.</p>
			<p class="calibre3">The other <a id="_idIndexMarker549" class="pcalibre calibre6 pcalibre1"/>arguments to the definition are explicitly marked with a dash in <a id="_idIndexMarker550" class="pcalibre calibre6 pcalibre1"/>the previous example, meaning that no other parameters need to be configured. They can be used to set the mode, <strong class="bold">User Identifier</strong> (<strong class="bold">UID</strong>), <strong class="bold">Group Identifier</strong> (<strong class="bold">GID</strong>), age, and argument related to the rule.</p>
			<p class="calibre3">An example configuration that uses some of these other parameters with the <strong class="source-inline">z</strong> or <strong class="source-inline">Z</strong> state is the <strong class="source-inline">systemd.conf</strong> file:</p>
			<p class="source-code"># grep ^[zZ] /usr/lib/tmpfiles.d/systemd.conf</p>
			<p class="source-code">z /run/log/journal 2755 root systemd-journal - -</p>
			<p class="source-code">Z /run/log/journal/%m ~2750 root systemd-journal - -</p>
			<p class="source-code">z /var/log/journal 2755 root systemd-journal - -</p>
			<p class="source-code">z /var/log/journal/%m 2755 root systemd-journal - -</p>
			<p class="source-code">z /var/log/journal/%m/system.journal 0640 root systemd-journal - -</p>
			<p class="calibre3">For more information about the definition format, see <strong class="source-inline">man tmpfiles.d</strong>.</p>
			<h3 class="calibre12">Using socket-based activation</h3>
			<p class="calibre3">The system <a id="_idIndexMarker551" class="pcalibre calibre6 pcalibre1"/>daemon also supports socket-based activation. When configured, systemd will create the socket on which the daemon usually listens and will have the daemon launched when the socket is first used. This allows systems to boot quickly (as many daemons do not need to be launched immediately) while still ensuring that all required sockets are available.</p>
			<p class="calibre3">When a client only writes information to the socket (such as with the <strong class="source-inline">/dev/log</strong> socket), the client does not even need to wait for the daemon to be activated. The data is stored in a buffer until the daemon can read it. Only when the buffer is full will the operation block until the daemon flushes the buffer.</p>
			<p class="calibre3">Take a <a id="_idIndexMarker552" class="pcalibre calibre6 pcalibre1"/>look at the <strong class="source-inline">systemd-journald.socket</strong> unit file, available inside <strong class="source-inline">/usr/lib/systemd/system</strong>:</p>
			<p class="source-code">[Unit]</p>
			<p class="source-code">Description=Journal socket</p>
			<p class="source-code">Documentation=man:systemd-journal.service(8) man:journald.conf(8)</p>
			<p class="source-code">DefaultDependencies=no</p>
			<p class="source-code">Before=sockets.target</p>
			<p class="source-code">IgnoreOnIsolate=yes</p>
			<p class="source-code">[Socket]</p>
			<p class="source-code"><strong class="bold">ListenStream=/run/systemd/journal/stdout</strong></p>
			<p class="source-code"><strong class="bold">ListenDatagram=/run/systemd/journal/socket</strong></p>
			<p class="source-code">SocketMode=0666</p>
			<p class="source-code">PassCredentials=yes</p>
			<p class="source-code">PassSecurity=yes</p>
			<p class="source-code">ReceiveBuffer=8M</p>
			<p class="source-code">Service=systemd-journald.service</p>
			<p class="calibre3">When a client uses one of the mentioned sockets, then systemd will launch the <strong class="source-inline">systemd-journald.service</strong> unit to accommodate the client interaction. As long as these sockets are not used, the service will not be started.</p>
			<p class="calibre3">Inside the <strong class="source-inline">[Socket]</strong> section, an SELinux-specific entry can be defined: <strong class="source-inline">SELinuxContextFromNet=true</strong>. When a unit file has this entry set, systemd will obtain the MLS/MCS information from the client context (the application connecting to the socket) and append this to the context of the service. This sensitivity inheritance can be used to prevent any information leakage from taking place when communication is happening through sockets.</p>
			<h3 class="calibre12">Governing unit operation access</h3>
			<p class="calibre3">Until now, we've <a id="_idIndexMarker553" class="pcalibre calibre6 pcalibre1"/>looked at configuration settings related to systemd's SELinux support. systemd also uses SELinux to control access to services defined through unit files. When a user wants to perform an operation against a unit (such as starting a service or checking the state of a running service), systemd queries the SELinux policy to see whether it will allow this operation.</p>
			<p class="calibre3">The systemd daemon uses the service class to validate the permissions of the client's domain toward the requested operation. For instance, to validate whether a user context, <strong class="source-inline">sysadm_t</strong>, can view the status of the service associated with the <strong class="source-inline">sshd.service</strong> unit file, it checks the context of this file (being <strong class="source-inline">sshd_unit_file_t</strong>) and then validates whether the status permission is granted:</p>
			<p class="source-code"># sesearch -s sysadm_t -t sshd_unit_file_t -c service -p status -A</p>
			<p class="calibre3">Other supported permissions are <strong class="source-inline">disable</strong>, <strong class="source-inline">enable</strong>, <strong class="source-inline">reload</strong>, <strong class="source-inline">start</strong>, and <strong class="source-inline">stop</strong>. When a permission is not granted, a <strong class="source-inline">USER_AVC</strong> denial message will be visible in the audit logs (rather than an <strong class="source-inline">AVC</strong> message) as the message is not generated by the Linux kernel, but by systemd. So, while the rules themselves are part of the SELinux policy, it is systemd that enforces the access.</p>
			<p class="calibre3">systemd, or the <a id="_idIndexMarker554" class="pcalibre calibre6 pcalibre1"/>client through which systemd is queried, might also provide additional error messages to reflect that the SELinux policy prevents the action. For instance, if we attempt to query systemd over D-Bus (which we cover in the <em class="italic">D-Bus communication</em> section) from an unprivileged user domain, then we get the following error:</p>
			<p class="source-code">Error: GDBus.Error:org.freedesktop.DBus.Error.AccessDenied: SELinux policy denies access</p>
			<p class="calibre3">To facilitate troubleshooting any systemd-triggered failures, systemd also has an extensive logging component, called <strong class="source-inline">systemd-journald</strong>, which we'll cover next.</p>
			<h2 id="_idParaDest-216" class="calibre10"><a id="_idTextAnchor220" class="pcalibre calibre6 pcalibre1"/>Logging with systemd</h2>
			<p class="calibre3">systemd is <a id="_idIndexMarker555" class="pcalibre calibre6 pcalibre1"/>not only responsible for service management: it takes up several other tasks as well. One of these tasks is log management, traditionally implemented through a system logger.</p>
			<p class="calibre3">While systemd still supports running with a traditional system logger, it now suggests the use of <strong class="source-inline">systemd-journald</strong>. One of the advantages of the journal daemon is that it is not limited to textual, single-line log messages. Daemons can now use binaries as well as multiline messages as part of its logging capabilities.</p>
			<p class="calibre3">The journal daemon also registers information about the sending process alongside the log messages themselves. This additional information contains ownership data (the process owner) including the SELinux context of the sending process.</p>
			<h3 class="calibre12">Retrieving SELinux-related information</h3>
			<p class="calibre3">The traditional approach to receive SELinux-related information (excluding the audit events we tackled before) is <a id="_idIndexMarker556" class="pcalibre calibre6 pcalibre1"/>to <strong class="source-inline">grep</strong> through the log information. With the journal daemon, we can accomplish this as follows:</p>
			<p class="source-code"># journalctl -b | grep -i selinux</p>
			<p class="calibre3">The <strong class="source-inline">-b</strong> option passed on to the journal control application informs the journal daemon that we are only interested in the log messages that originated for a specific boot.</p>
			<h3 class="calibre12">Querying logs given an SELinux context</h3>
			<p class="calibre3">A unique <a id="_idIndexMarker557" class="pcalibre calibre6 pcalibre1"/>feature of the journal daemon is to use the information associated with the log messages as part of the query to be launched against the journal database. For instance, we can ask the journal daemon to only show those messages that originated from a daemon or application running in the <strong class="source-inline">udev_t</strong> context:</p>
			<p class="source-code"># journalctl _SELINUX_CONTEXT=system_u:system_r:init_t:s0</p>
			<p class="calibre3">The available contexts can be retrieved through the Bash completion support on the system. After writing <strong class="source-inline">_SELINUX_CONTEXT=</strong>, press <em class="italic">Tab</em> twice to see the possible values.</p>
			<h3 class="calibre12">Using setroubleshoot integration with journal</h3>
			<p class="calibre3">The <a id="_idIndexMarker558" class="pcalibre calibre6 pcalibre1"/>SELinux troubleshoot daemon is also integrated with <strong class="source-inline">systemd-journald</strong>. Any alert that comes up from <strong class="source-inline">setroubleshootd</strong> is also available through the journal daemon.</p>
			<p class="calibre3">This helps administrators as they will quickly find out about SELinux denials when investigating problems. For instance, when the Nginx web server is not working properly and this is due to an SELinux policy, a quick investigation of the status of the service will reveal that the SELinux policy is preventing some actions:</p>
			<p class="source-code"># systemctl status nginx</p>
			<p class="calibre3">To get more information about the message, use <strong class="source-inline">journalctl</strong>:</p>
			<p class="source-code"># journalctl -xe</p>
			<p class="calibre3">As you can see, <strong class="source-inline">systemd-journald</strong> has captured environment information related to the service, which can provide much-needed guidance on resolving potential problems.</p>
			<p class="calibre3">A third systemd service that has SELinux configuration possibilities is the device daemon.</p>
			<h2 id="_idParaDest-217" class="calibre10"><a id="_idTextAnchor221" class="pcalibre calibre6 pcalibre1"/>Handling device files</h2>
			<p class="calibre3">Linux has <a id="_idIndexMarker559" class="pcalibre calibre6 pcalibre1"/>a long history of device managers. Initially, administrators needed to make sure that the device nodes were already present on the filesystem (<strong class="source-inline">/dev</strong> was part of the persisted filesystem). Gradually, Linux adopted more dynamic approaches for device management.</p>
			<p class="calibre3">Nowadays, device files are managed through a combination of a pseudo filesystem (<strong class="source-inline">devtmpfs</strong>) and a userspace device manager called udev. This device manager is merged in systemd as well, becoming <strong class="source-inline">systemd-udevd</strong>.</p>
			<p class="calibre3">The device <a id="_idIndexMarker560" class="pcalibre calibre6 pcalibre1"/>manager listens on a kernel socket for kernel events. These events inform the device manager about detected or plugged-in devices (or the removal of such devices) and allow the device manager to take appropriate action. For udev, these actions are defined in udev rules.</p>
			<h3 class="calibre12">Using udev rules</h3>
			<p class="calibre3">Configuring the <a id="_idIndexMarker561" class="pcalibre calibre6 pcalibre1"/>udev subsystem is mainly done through udev rules. These rules are one-liners that contain a matching part and an action part.</p>
			<p class="calibre3">The matching part contains validations, executed against the event(s) that udev receives from the Linux kernel. This validation uses key/value pairs obtained from the event, and includes the following possible keys:</p>
			<ul class="calibre8">
				<li class="calibre9">Kernel-provided device name (<strong class="source-inline">KERNEL</strong>)</li>
				<li class="calibre9">Device subsystem (<strong class="source-inline">SUBSYSTEM</strong>)</li>
				<li class="calibre9">Kernel driver (<strong class="source-inline">DRIVER</strong>)</li>
				<li class="calibre9">Specific attributes (<strong class="source-inline">ATTR</strong>)</li>
				<li class="calibre9">Active environment variables (<strong class="source-inline">ENV</strong>)</li>
				<li class="calibre9">The action type to inform if the device is detected or removed (<strong class="source-inline">ACTION</strong>)</li>
			</ul>
			<p class="calibre3">While more match keys are possible, the preceding list is most commonly used.</p>
			<p class="calibre3">The Linux kernel will also inform the device manager about the device hierarchy. This allows rules to be defined based on, for instance, the USB controller through which a USB device is plugged in. Alongside the information for the device itself, the kernel will also provide hierarchically related information through similar key/value pairs. These pairs, however, use a key definition in plural form: <strong class="source-inline">SUBSYSTEMS</strong> instead of <strong class="source-inline">SUBSYSTEM</strong>, <strong class="source-inline">DRIVERS</strong> instead of <strong class="source-inline">DRIVER</strong>, and so on.</p>
			<p class="calibre3">For instance, to match a USB webcam with vendor ID <strong class="source-inline">05a9</strong> and product ID <strong class="source-inline">4519</strong>, the match-related pairs could look like this:</p>
			<p class="source-code">KERNEL=="video[0-9]*", SUBSYSTEM=="video4linux", SUBSYSTEMS=="usb", ATTR{idVendor}=="05a9", ATTR{idProduct}=="4519"</p>
			<p class="calibre3">The second part of a udev rule is the action to take. The most common action is to create a symbolic link to the created device file, ensuring that applications can always reach the same device through the same symbolic link, even when the device from the kernel point of view has a different name. We can, for instance, extend the preceding example with <strong class="source-inline">SYMLINK+="webcam1"</strong> to have <strong class="source-inline">/dev/webcam1</strong> point to this newly detected device.</p>
			<p class="calibre3">The udev application supports many more actions than just defining symbolic links, of course. It can associate ownership (<strong class="source-inline">OWNER</strong>) or group membership (<strong class="source-inline">GROUP</strong>) on the device, controlling who <a id="_idIndexMarker562" class="pcalibre calibre6 pcalibre1"/>can access the devices. udev can also set environment variables (<strong class="source-inline">ENV</strong>) and even run a command (<strong class="source-inline">RUN</strong>) when the matched device is plugged in or detached from the system. To make sure the command is only executed when the device is added, we need to add an <strong class="source-inline">ACTION</strong> setting such as <strong class="source-inline">ACTION=="add"</strong>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">udev can interpret <strong class="source-inline">ENV</strong> as both a matching key as well as an action key. The difference is the operation performed (a single equals sign <strong class="source-inline">=</strong> or a double <strong class="source-inline">==</strong>). <strong class="source-inline">ENV{envvar}=="value"</strong> is a match operation (checking whether the variable matches the given <strong class="source-inline">value</strong>), whereas <strong class="source-inline">ENV{envvar}="value"</strong> is an action (setting the variable to <strong class="source-inline">value</strong>).</p>
			<p class="calibre3">udev rules are provided by default through the <strong class="source-inline">/usr/lib/udev/rules.d</strong> location. Distributions and applications/drivers will store their default rules in this location. Additional rules or rule overrides can be placed in <strong class="source-inline">/etc/udev/rules.d</strong>.</p>
			<p class="calibre3">It's important to remember that udev will continue processing rules even when it has already encountered a matching rule. This can be changed on a per-rule basis through the <strong class="source-inline">OPTIONS</strong> action, as with <strong class="source-inline">OPTIONS+="last_rule"</strong>, which informs udev that it can stop processing further rules for this event.</p>
			<h3 class="calibre12">Setting an SELinux label on a device node</h3>
			<p class="calibre3">One of <a id="_idIndexMarker563" class="pcalibre calibre6 pcalibre1"/>the actions that udev supports is to assign an SELinux context on the device node. We can do this using the <strong class="source-inline">SECLABEL{selinux}</strong> action:</p>
			<p class="source-code">KERNEL=="fd0", ..., SECLABEL{selinux}="system_u:object_r:my_device_t:s0"</p>
			<p class="calibre3">Note that this action only sets the context on the device node. If the rule also sets a symbolic link, then the symbolic link itself will inherit the default <strong class="source-inline">device_t</strong> context.</p>
			<p class="calibre3">Placing an SELinux label on a device node is often done together with the other security-related permissions, so the rule often receives additional actions such as setting the target owner (<strong class="source-inline">OWNER</strong>), group (<strong class="source-inline">GROUP</strong>), and permission set (<strong class="source-inline">MODE</strong>). After all, SELinux security controls only apply <em class="italic">after</em> the regular, discretionary access control checks have passed, so don't forget to make sure your users have access to the device nodes outside of the SELinux controls as well.</p>
			<p class="calibre3">All the <a id="_idIndexMarker564" class="pcalibre calibre6 pcalibre1"/>settings we've seen so far are about systemd service management and system support. Another component within the systemd ecosystem is D-Bus, which is less about system management and more about facilitating communication and interaction between different applications over a programmable communication bus.</p>
			<h1 id="_idParaDest-218" class="calibre5"><a id="_idTextAnchor222" class="pcalibre calibre6 pcalibre1"/>Communicating over D-Bus</h1>
			<p class="calibre3">The D-Bus <a id="_idIndexMarker565" class="pcalibre calibre6 pcalibre1"/>daemon provides an inter-process communication channel between applications. Unlike traditional IPC methods, D-Bus is a higher-level communication channel that offers more than simple signaling or memory sharing. Applications that want to chat over D-Bus link with one of the many D-Bus-compatible libraries, such as those provided by the libdbus, sd-bus (part of systemd), GDBus, and QtDBus applications.</p>
			<p class="calibre3">The D-Bus daemon is part of the systemd application suite.</p>
			<h2 id="_idParaDest-219" class="calibre10"><a id="_idTextAnchor223" class="pcalibre calibre6 pcalibre1"/>Understanding D-Bus</h2>
			<p class="calibre3">Linux generally <a id="_idIndexMarker566" class="pcalibre calibre6 pcalibre1"/>supports two D-Bus types – system-wide and session-specific D-Bus instances:</p>
			<ul class="calibre8">
				<li class="calibre9">The <a id="_idIndexMarker567" class="pcalibre calibre6 pcalibre1"/>system-wide D-Bus is the main instance used for <a id="_idIndexMarker568" class="pcalibre calibre6 pcalibre1"/>system communication. Many services or daemons will associate themselves with the system D-Bus to allow others to communicate with them through D-Bus.</li>
				<li class="calibre9">The <a id="_idIndexMarker569" class="pcalibre calibre6 pcalibre1"/>session-specific D-Bus is an instance running <a id="_idIndexMarker570" class="pcalibre calibre6 pcalibre1"/>for each logged-in user. It is commonly used by graphical applications to communicate with each other within a user session.</li>
			</ul>
			<p class="calibre3">Both D-Bus instances are provided through the <strong class="source-inline">dbus-daemon</strong> application. The system-wide D-Bus will run with the <strong class="source-inline">--system</strong> option, whereas a session-specific instance will run with the <strong class="source-inline">--session</strong> option.</p>
			<p class="calibre3">Applications register themselves against D-Bus through a namespace. Conventionally, this namespace uses the domain name of the project. For instance, systemd declares the <strong class="source-inline">org.freedesktop.systemd1</strong> namespace, whereas D-Bus is at <strong class="source-inline">org.freedesktop.DBus</strong>.</p>
			<p class="calibre3">The currently associated applications can be queried using Python easily:</p>
			<p class="source-code"># python3.6</p>
			<p class="source-code">&gt;&gt;&gt; import dbus</p>
			<p class="source-code">&gt;&gt;&gt; for service in dbus.SystemBus().list_names():</p>
			<p class="source-code">...   print(service)</p>
			<p class="source-code">org.freedesktop.DBus</p>
			<p class="source-code">org.freedesktop.login1</p>
			<p class="source-code">org.freedesktop.systemd1</p>
			<p class="source-code">org.freedesktop.PolicyKit1</p>
			<p class="source-code">com.redhat.tuned</p>
			<p class="source-code">:1.10</p>
			<p class="source-code">:1.11</p>
			<p class="source-code">org.freedesktop.NetworkManager</p>
			<p class="source-code">...</p>
			<p class="calibre3">Each application <a id="_idIndexMarker571" class="pcalibre calibre6 pcalibre1"/>then provides objects on the bus that can be reached by other objects (other applications)—of course, assuming they have the privileges to do so. These objects are represented through a path-like syntax and generally also use the domain of the project as a prefix.</p>
			<p class="calibre3">For instance, to list the objects currently associated with <strong class="source-inline">org.freedesktop.systemd1</strong>, we can use the <strong class="source-inline">gdbus</strong> command. To facilitate its use, we first enable auto-completion support, after which we can use the <em class="italic">Tab</em> key to easily add the appropriate values:</p>
			<p class="source-code"># source /usr/share/bash-completion/completions/gdbus</p>
			<p class="source-code"># gdbus call --system --dest &lt;TAB&gt;&lt;TAB&gt;</p>
			<p class="source-code"># gdbus call --system --dest org.freedesktop.systemd1 --object-path /org/freedesktop/systemd1&lt;TAB&gt;&lt;TAB&gt;</p>
			<p class="source-code">Display all 220 possibilities? (y or no)</p>
			<p class="source-code">/org/freedesktop/systemd1</p>
			<p class="source-code">/org/freedesktop/systemd1/job</p>
			<p class="source-code">/org/freedesktop/systemd1/unit</p>
			<p class="source-code">...</p>
			<p class="calibre3">Applications can trigger methods on these objects, or send messages to the applications bound to these objects through these methods.</p>
			<p class="calibre3">For instance, to get the state of the <strong class="source-inline">sshd.service</strong> unit through D-Bus, we invoke the <strong class="source-inline">org.freedesktop.systemd1.Manager.GetUnitFileState</strong> method on the <strong class="source-inline">org.freedesktop.systemd1</strong> object reachable through the <strong class="source-inline">/org/freedesktop/systemd1</strong> path, and with the <strong class="source-inline">sshd.service</strong> argument, like this:</p>
			<p class="source-code"># gdbus call --system \</p>
			<p class="source-code">  --dest org.freedesktop.systemd1 \</p>
			<p class="source-code">  --object-path /org/freedesktop/systemd1 \</p>
			<p class="source-code">  --method org.freedesktop.systemd1.Manager.GetUnitFileState \</p>
			<p class="source-code">  sshd.service</p>
			<p class="source-code">('enabled',)</p>
			<p class="calibre3">These calls <a id="_idIndexMarker572" class="pcalibre calibre6 pcalibre1"/>can also be controlled through the SELinux policy, as we will learn next.</p>
			<h2 id="_idParaDest-220" class="calibre10"><a id="_idTextAnchor224" class="pcalibre calibre6 pcalibre1"/>Controlling service acquisition with SELinux</h2>
			<p class="calibre3">The D-Bus <a id="_idIndexMarker573" class="pcalibre calibre6 pcalibre1"/>application, like systemd, will query the SELinux policy to verify whether to allow an operation. Again, it is the D-Bus application itself that enforces the policy and not a Linux kernel subsystem.</p>
			<p class="calibre3">The first control that administrators can enable within D-Bus is to ensure that only well-established domains can acquire a specified object within D-Bus. Without this control, malicious code could register itself as <strong class="source-inline">org.freedesktop.login1</strong>, for instance, and act as a system daemon on the bus. Other applications might mistakenly send out sensitive information to the application.</p>
			<p class="calibre3">Applications store this policy information in files hosted in <strong class="source-inline">/usr/share/dbus-1/system.d</strong>. The login service, for instance (stored as <strong class="source-inline">org.freedesktop.login1.conf</strong>) has the following policy snippet installed:</p>
			<p class="source-code">&lt;busconfig&gt;</p>
			<p class="source-code">  &lt;policy user="root"&gt;</p>
			<p class="source-code">    &lt;allow own="org.freedesktop.login1"/&gt;</p>
			<p class="source-code">    &lt;allow send_destination="org.freedesktop.login1"/&gt;</p>
			<p class="source-code">    &lt;allow receive_sender="org.freedesktop.login1"/&gt;</p>
			<p class="source-code">  &lt;/policy&gt;</p>
			<p class="source-code">  &lt;policy context="default"&gt;</p>
			<p class="source-code">    &lt;deny send_destination="org.freedesktop.login1"/&gt;</p>
			<p class="source-code">    &lt;allow</p>
			<p class="source-code">       send_destination="org.freedesktop.login1"</p>
			<p class="source-code">       send_interface="org.freedesktop.DBus.Introspectable"/&gt;</p>
			<p class="source-code">    ...</p>
			<p class="source-code">  &lt;/policy&gt;</p>
			<p class="source-code">&lt;/busconfig&gt;</p>
			<p class="calibre3">As the login daemon runs in the <strong class="source-inline">systemd_logind_t</strong> domain, we could enhance this configuration as follows:</p>
			<p class="source-code">&lt;busconfig&gt;</p>
			<p class="source-code">  &lt;selinux&gt;</p>
			<p class="source-code">    &lt;associate</p>
			<p class="source-code">      own="org.freedesktop.login1"</p>
			<p class="source-code">      context="system_u:system_r:systemd_logind_t:s0" /&gt;</p>
			<p class="source-code">  &lt;/selinux&gt;</p>
			<p class="source-code">  ...</p>
			<p class="source-code">&lt;/busconfig&gt;</p>
			<p class="calibre3">With this <a id="_idIndexMarker574" class="pcalibre calibre6 pcalibre1"/>enhancement in place, D-Bus will check whether the application (which we presume is running in the <strong class="source-inline">systemd_logind_t</strong> context) has the <strong class="source-inline">acquire_svc</strong> permission (of the <strong class="source-inline">dbus</strong> class) against the <strong class="source-inline">systemd_logind_t</strong> context. By default, the SELinux policy does not have this permission, and as such, the registration fails:</p>
			<p class="source-code"># systemctl restart dbus-org.freedesktop.login1</p>
			<p class="source-code">Job for systemd-logind.service failed because a timeout was exceeded.</p>
			<p class="source-code">See "systemctl status systemd-logind.service" and "journalctl -xe" for details.</p>
			<p class="source-code"># ausearch -m user_avc -ts recent</p>
			<p class="calibre3">When we add the following SELinux policy rule, the registration of <strong class="source-inline">systemd-logind</strong> will succeed, as expected:</p>
			<p class="source-code">(allow systemd_logind_t systemd_logind_t (dbus (acquire_svc)))</p>
			<p class="calibre3">Load this policy (say <strong class="source-inline">test.cil</strong>) and try the <strong class="source-inline">restart</strong> operation again:</p>
			<p class="source-code"># semodule -i test.cil</p>
			<p class="source-code"># systemctl restart dbus-org.freedesktop.login1</p>
			<p class="calibre3">By limiting which domains can obtain a given service, we ensure that only trusted applications are used. Non-trusted applications will generally not run within the domain of that application (end users, for instance, cannot trigger a transition to such a domain) even if they receive root privileges (which is another check that D-Bus does for the login service, as shown in the first <strong class="source-inline">busconfig</strong> snippet).</p>
			<p class="calibre3">Administrators can enhance this D-Bus configuration without having to alter the existing configuration files. For instance, the previously mentioned SELinux-governing <strong class="source-inline">busconfig</strong> snippet could very well be saved as a different file.</p>
			<h2 id="_idParaDest-221" class="calibre10"><a id="_idTextAnchor225" class="pcalibre calibre6 pcalibre1"/>Governing message flows</h2>
			<p class="calibre3">A second control that D-Bus validates is which applications can communicate with each other. This is not <a id="_idIndexMarker575" class="pcalibre calibre6 pcalibre1"/>configurable through the service configurations but is a pure SELinux policy control.</p>
			<p class="calibre3">Whenever a source application is calling a method of a target application, D-Bus validates the <strong class="source-inline">send_msg</strong> permission between the two domains associated with the source and target applications.</p>
			<p class="calibre3">For instance, communication over D-Bus between a user domain (<strong class="source-inline">sysadm_t</strong>) and service domain (<strong class="source-inline">systemd_logind_t</strong>) will check the following permissions:</p>
			<p class="source-code">allow sysadm_t systemd_logind_t : dbus send_msg;</p>
			<p class="source-code">allow systemd_logind_t sysadm_t : dbus send_msg;</p>
			<p class="calibre3">If these permissions are not granted, then D-Bus will not allow the communication to happen. If at any point, the application context cannot be obtained, then the bus daemon context will be used.</p>
			<p class="calibre3">Failures will be logged as <strong class="source-inline">USER_AVC</strong> entries in the audit log. If the communication should be allowed, we can create a simple SELinux policy file to address this like so:</p>
			<p class="source-code">(allow sysadm_t systemd_logind_t (dbus (send_msg)))</p>
			<p class="source-code">(allow systemd_logind_t sysadm_t (dbus (send_msg)))</p>
			<p class="calibre3">Store these rules in a file with the suffix <strong class="source-inline">.cil</strong> (say, <strong class="source-inline">local_logind_systemd.cil</strong>), and load it with <strong class="source-inline">semodule</strong>:</p>
			<p class="source-code"># semodule -i local_logind_systemd.cil</p>
			<p class="calibre3">Let's consider a few other applications that have SELinux support, not necessarily built-in, but through the SELinux policy and PAM integration within the system.</p>
			<h1 id="_idParaDest-222" class="calibre5"><a id="_idTextAnchor226" class="pcalibre calibre6 pcalibre1"/>Configuring PAM services</h1>
			<p class="calibre3">systemd and D-Bus <a id="_idIndexMarker576" class="pcalibre calibre6 pcalibre1"/>are SELinux-aware applications, with explicit SELinux support built in. Several other services exist on a Linux system that play nicely together with SELinux yet are not SELinux-aware themselves. Many of these services have an affinity with SELinux through their PAM integration.</p>
			<p class="calibre3">We covered PAM integration in <a href="B16276_03_Final_VK.xhtml#_idTextAnchor071" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing User Logins</em>. In this section, we'll cover three example services using PAM, and how SELinux can be further fine-tuned to support these services.</p>
			<h2 id="_idParaDest-223" class="calibre10"><a id="_idTextAnchor227" class="pcalibre calibre6 pcalibre1"/>Cockpit</h2>
			<p class="calibre3">Cockpit is <a id="_idIndexMarker577" class="pcalibre calibre6 pcalibre1"/>a simple, browser-based management application <a id="_idIndexMarker578" class="pcalibre calibre6 pcalibre1"/>that allows administrators to easily see system resources (monitoring) as well as to interact with the system. It also allows users to log into the system through the browser.</p>
			<p class="calibre3">It is this browser-based terminal that we want to configure: by tuning the target SELinux roles for the SELinux users, we can selectively put users in a specific role. This effectively defines what the users can accomplish through this browser-based session.</p>
			<h3 class="calibre12">Installing Cockpit</h3>
			<p class="calibre3">The Cockpit <a id="_idIndexMarker579" class="pcalibre calibre6 pcalibre1"/>application is readily available in the CentOS repository, so installing it is a breeze:</p>
			<p class="source-code"># yum install cockpit</p>
			<p class="calibre3">While the application does not need additional configuration, if you do need tweaks, you will need to create the configuration file, <strong class="source-inline">/etc/cockpit/cockpit.conf</strong>, yourself as the application does not create a default configuration file. Within this configuration file, you can configure the TLS settings, or disable encrypted communication generally. </p>
			<p class="calibre3">Let's disable the encrypted communication for this demonstration run (but if you intend to use Cockpit in production, you should not only keep encryption on but also ensure that only trusted hosts are connecting, possibly even requiring client certificate authentication using the <strong class="source-inline">ClientCertAuthentication</strong> directive):</p>
			<p class="source-code">[WebService]</p>
			<p class="source-code">AllowUnencrypted=true</p>
			<p class="calibre3">With this set, we can continue with configuring SELinux for Cockpit.</p>
			<h3 class="calibre12">Restricting user logins</h3>
			<p class="calibre3">Through <a id="_idIndexMarker580" class="pcalibre calibre6 pcalibre1"/>these instructions, we will add the more restricted <strong class="source-inline">user_r</strong> role to the <strong class="source-inline">staff_u</strong> SELinux user, and then ensure that all logins mapped to the <strong class="source-inline">staff_u</strong> SELinux user are logged in using the <strong class="source-inline">user_r</strong> role when they log in through Cockpit. If they log in through other services, they will continue using the default <strong class="source-inline">staff_r</strong> role.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The use of the <strong class="source-inline">user_r</strong> role rather than the (even more restricted) <strong class="source-inline">guest_r</strong> role is to allow the Cockpit application to function properly. The application will run a service under the user's privileges, which are not sufficient for Cockpit if we use the <strong class="source-inline">guest_t</strong> user domain.</p>
			<p class="calibre3">Let's first add the <strong class="source-inline">user_r</strong> role so that we can put the users in the correct context later:</p>
			<p class="source-code"># semanage user -m -R "staff_r sysadm_r system_r user_r" staff_u</p>
			<p class="calibre3">Next, we want to update the SELinux configuration so that any Cockpit login by <strong class="source-inline">staff_u</strong> mapped users is going to use the <strong class="source-inline">user_r</strong> role. The Cockpit application has logins done through a service running in the <strong class="source-inline">cockpit_session_t</strong> context, which we find out by checking the context of the process first, and then logging in on Cockpit and checking the context of the processes again. There, we notice that a new process (<strong class="source-inline">cockpit-session</strong>) runs with the <strong class="source-inline">cockpit_session_t</strong> context:</p>
			<p class="source-code"># ps -eZ | grep cockpit</p>
			<p class="source-code">system_u:system_r:cockpit_ws_t:s0	 ... cockpit-ws</p>
			<p class="source-code">system_u:system_r:cockpit_session_t:s0 ... cockpit-session localhost</p>
			<p class="calibre3">With this <a id="_idIndexMarker581" class="pcalibre calibre6 pcalibre1"/>information now available, we can edit the <strong class="source-inline">/etc/selinux/targeted/contexts/users/staff_u</strong> file as follows:</p>
			<p class="source-code">system_r:local_login_t:s0   staff_r:staff_t:s0 sysadm_r:sysadm_t:s0</p>
			<p class="source-code">system_r:remote_login_t:s0  staff_r:staff_t:s0</p>
			<p class="source-code">system_r:sshd_t:s0          staff_r:staff_t:s0 sysadm_r:sysadm_t:s0</p>
			<p class="source-code"><strong class="bold">system_r:cockpit_session_t:s0   user_r:user_t:s0</strong></p>
			<p class="source-code">system_r:crond_t:s0         staff_r:staff_t:s0 staff_r:cronjob_t:s0</p>
			<p class="calibre3">By adjusting the order of the roles listed for the <strong class="source-inline">cockpit_session_t</strong> context (or limiting them to only the <strong class="source-inline">user_r</strong> role), we ensure that users allowed to run with the <strong class="source-inline">user_r</strong> role (like the <strong class="source-inline">staff_u</strong> user we configured earlier on) do so through the <strong class="source-inline">user_r</strong> role. As this role is more restricted than the default <strong class="source-inline">staff_t</strong> user domain, logins through Cockpit are thus more isolated.</p>
			<p class="calibre3">This approach can be used for all PAM-enabled services, as this solely relies on the <strong class="source-inline">pam_selinux.so</strong> call in the service PAM configuration. For some services, the SELinux policy administrators add in a few more tweaks to use, such as with cron and SSH, which we'll discuss next.</p>
			<h2 id="_idParaDest-224" class="calibre10"><a id="_idTextAnchor228" class="pcalibre calibre6 pcalibre1"/>Cron</h2>
			<p class="calibre3">Cron services on <a id="_idIndexMarker582" class="pcalibre calibre6 pcalibre1"/>a system allow you to run tasks or commands <a id="_idIndexMarker583" class="pcalibre calibre6 pcalibre1"/>on predefined schedules. Some cron applications are explicitly made SELinux-aware (such as fcron), allowing them to compute the target context a job should run in. Even cron systems that do not have any specific SELinux logic built in can be fine-tuned.</p>
			<h3 class="calibre12">Switching between user-specific and generic contexts</h3>
			<p class="calibre3">A common <a id="_idIndexMarker584" class="pcalibre calibre6 pcalibre1"/>setup supported through the SELinux policy is to toggle whether user tasks run in the user's default context (such as <strong class="source-inline">staff_t</strong> for staff users) or in a default, restricted cron context (<strong class="source-inline">cronjob_t</strong>). Both approaches have their pros and cons.</p>
			<p class="calibre3">When we configure the system to have user jobs run in the user's default context, then users know what the privileges are of their jobs. A guest user has guest privileges, a staff user has staff privileges, and so forth. This is the most common configuration, and the default cron system on CentOS uses the context of the file containing the user's tasks (located in <strong class="source-inline">/var/spool/cron</strong>) to deduce the target runtime context.</p>
			<p class="calibre3">By running user jobs in a more restricted context such as <strong class="source-inline">cronjob_t</strong>, all users' cron jobs run with the same privileges, and the administrator can easily fine-tune the privileges for all user jobs. This also allows the administrator to grant specific privileges for cron jobs while keeping the user contexts free of these rights.</p>
			<p class="calibre3">Let's have a simple task executed every minute, namely a 59-second sleep. As a regular user, create a file (let's say <strong class="source-inline">lisa.cron</strong>) with the following content:</p>
			<p class="source-code">* * * * * sleep 59</p>
			<p class="calibre3">This file uses the common cron syntax, where the following applies:</p>
			<ol class="calibre18">
				<li class="calibre9">The first field covers the minute.</li>
				<li class="calibre9">The second field covers the hour.</li>
				<li class="calibre9">The third field covers the day of the month.</li>
				<li class="calibre9">The fourth field covers the month.</li>
				<li class="calibre9">The fifth field covers the day of the week.</li>
				<li class="calibre9">The rest of the line is the command to execute.</li>
			</ol>
			<p class="calibre3">The fields can use expressions to facilitate time definitions. For instance, to run every 15 minutes, you can use <strong class="source-inline">*/15</strong> in the first field. If you want to run only at 8 o'clock and 18 o'clock, you can use the <strong class="source-inline">8,18</strong> value in the second field. Another example is if you only want to run on workdays, for which you can use <strong class="source-inline">1-5</strong> in the fifth field (in cron, Sunday holds both 0 and 7 as valid values).</p>
			<p class="calibre3">By loading it with the <strong class="source-inline">crontab</strong> command, the file is checked for errors and, if error-free, is securely placed inside <strong class="source-inline">/var/spool/cron</strong> (the <strong class="source-inline">crontab</strong> command is a <strong class="source-inline">setuid</strong> command that is able to modify <strong class="source-inline">/var/spool/cron</strong> even though this location is inaccessible by regular users):</p>
			<p class="source-code">$ crontab ./lisa.cron</p>
			<p class="calibre3">From here, the cron daemon will pick up this file, and 1 minute later we will see the command active in the background:</p>
			<p class="source-code">$ ps -efZ | grep sleep</p>
			<p class="source-code">staff_u:staff_r:staff_t:s0 ...  sleep 59</p>
			<p class="calibre3">As seen from the output, the command is running in the <strong class="source-inline">staff_t</strong> context. To change this to the <strong class="source-inline">cronjob_t</strong> type, rather than editing the SELinux context definition file as we did with the Cockpit application, use the <strong class="source-inline">cron_userdomain_transition</strong> SELinux boolean:</p>
			<p class="source-code"># setsebool cron_userdomain_transition off</p>
			<p class="calibre3">This <a id="_idIndexMarker585" class="pcalibre calibre6 pcalibre1"/>boolean changes the active SELinux policy behavior so that any user task executed from the cron system executes within the <strong class="source-inline">cronjob_t</strong> domain. You might need to reset the crontab definition (this depends on the cron system used), but afterward, we will see the job running in the <strong class="source-inline">cronjob_t</strong> domain:</p>
			<p class="source-code">$ ps -efZ | grep sleep</p>
			<p class="source-code">staff_u:staff_r:cronjob_t:s0 ...  sleep 59</p>
			<p class="calibre3">The use of SELinux booleans to allow administrators to differentiate system behavior as needed is commonly used. For the SSH daemon, SELinux policy administrators have defined something similar.</p>
			<h2 id="_idParaDest-225" class="calibre10"><a id="_idTextAnchor229" class="pcalibre calibre6 pcalibre1"/>OpenSSH</h2>
			<p class="calibre3">The OpenSSH <a id="_idIndexMarker586" class="pcalibre calibre6 pcalibre1"/>daemon is the most common secure shell daemon around. It <a id="_idIndexMarker587" class="pcalibre calibre6 pcalibre1"/>allows users to remotely access systems through a terminal, as well as to securely transfer files, tunnel application communications, and more. </p>
			<p class="calibre3">When logging in through SSH, the PAM controls apply, but the SELinux policy also has specific SSH controls embedded and controllable through SELinux booleans.</p>
			<h3 class="calibre12">Directly logging in as sysadm_t</h3>
			<p class="calibre3">The first <a id="_idIndexMarker588" class="pcalibre calibre6 pcalibre1"/>change to assess is to allow directly logging in using the <strong class="source-inline">sysadm_r</strong> role. Users mapped to the <strong class="source-inline">staff_u</strong> SELinux user by default log in using the (more restricted) <strong class="source-inline">staff_r</strong> role, and then need to explicitly switch roles to obtain the more privileged <strong class="source-inline">sysadm_r</strong> role.</p>
			<p class="calibre3">The first change we need to make is to edit the <strong class="source-inline">/etc/selinux/targeted/contexts/users/staff_u</strong> file and adjust the order of the roles listed for the <strong class="source-inline">sshd_t</strong> context:</p>
			<p class="source-code">system_r:local_login_t:s0   staff_r:staff_t:s0 sysadm_r:sysadm_t:s0</p>
			<p class="source-code">system_r:remote_login_t:s0  staff_r:staff_t:s0</p>
			<p class="source-code"><strong class="bold">system_r:sshd_t:s0          sysadm_r:sysadm_t:s0 </strong><strong class="bold">staff_r:staff_t:s0</strong> </p>
			<p class="source-code">system_r:cockpit_session_t:s0   user_r:user_t:s0</p>
			<p class="source-code">system_r:crond_t:s0         staff_r:staff_t:s0 staff_r:cronjob_t:s0</p>
			<p class="calibre3">However, this is not enough. The SELinux policy administrators have disabled direct logins through SSH to the <strong class="source-inline">sysadm_r</strong> role, forcing users to explicitly change roles (and thus reauthenticate). This approach is because SSH is often a publicly reachable and not otherwise <a id="_idIndexMarker589" class="pcalibre calibre6 pcalibre1"/>easily controllable service (unlike services such as web servers, which can have reverse proxies and web application firewalls in front).</p>
			<p class="calibre3">Change the SELinux <strong class="source-inline">ssh_sysadm_login</strong> boolean to <strong class="source-inline">true</strong> to enable the wanted behavior:</p>
			<p class="source-code"># setsebool ssh_sysadm_login true</p>
			<p class="calibre3">This boolean changes the SELinux policy behavior to allow logins to the <strong class="source-inline">sysadm_r</strong> role from the SSH daemon.</p>
			<h3 class="calibre12">Chrooting Linux users</h3>
			<p class="calibre3">Another <a id="_idIndexMarker590" class="pcalibre calibre6 pcalibre1"/>feature that SSH supports is forcing logins from selected users to be chrooted. A <strong class="bold">chroot</strong> (which is a portmanteau of <strong class="bold">change root</strong>) is an <a id="_idIndexMarker591" class="pcalibre calibre6 pcalibre1"/>isolation method for processes, where the process no longer sees the entire filesystem but only a part of it.</p>
			<p class="callout-heading">Informational note</p>
			<p class="callout">Now, chroot environments are an easy way to isolate processes, but a chroot itself is still governed through Linux's discretionary access controls, and escaping chroot environments is not impossible. Using SELinux to further confine the process is recommended but is not in the scope of this section. For that, we refer to <a href="B16276_14_Final_VK.xhtml#_idTextAnchor354" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 14</em></a>, <em class="italic">Dealing with New Applications</em>.</p>
			<p class="calibre3">Before we configure SSH to chroot some users, we need to create a properly functioning environment: once we change the root for a process, all commands and libraries that the process wants to read or execute need to be available within this chroot environment.</p>
			<p class="calibre3">Let's first create a chroot environment. A nice utility that assists in creating the right folder structure and files is Jailkit. Jailkit is not available by default through the regular repositories but can be easily installed and only requires a working compiler and Python environment.</p>
			<p class="calibre3">We start off by installing the necessary dependencies:</p>
			<p class="source-code"># yum install gcc python36-devel</p>
			<p class="calibre3">Next, we <a id="_idIndexMarker592" class="pcalibre calibre6 pcalibre1"/>download the Jailkit source code and build it. As CentOS does not have a linked Python binary by default (as it requires the use of <strong class="source-inline">python3</strong> as the runtime), we need to tell the build scripts how to address Python. We do this by declaring the <strong class="source-inline">PYTHONINTERPRETER</strong> environment variable:</p>
			<p class="source-code"># wget https://olivier.sessink.nl/jailkit/jailkit-2.21.tar.bz2</p>
			<p class="source-code"># tar xvf jailkit-2.21.tar.bz2</p>
			<p class="source-code"># cd jailkit-2.21</p>
			<p class="source-code"># export PYTHONINTERPRETER=/usr/bin/python3</p>
			<p class="source-code"># ./configure</p>
			<p class="source-code"># make</p>
			<p class="source-code"># make install</p>
			<p class="calibre3">Once the installation is complete, you might need to remove a duplicate <strong class="source-inline">includesections</strong> call within the Jailkit configuration file (the <strong class="source-inline">jk_init</strong> command, which we will use next, will inform you about it if you don't). The <strong class="source-inline">openvpn</strong> section in <strong class="source-inline">/etc/jailkit/jk_init.ini</strong> should look like this:</p>
			<p class="source-code">[openvpn]</p>
			<p class="source-code">comment = jail for the openvpn daemon</p>
			<p class="source-code">paths = /usr/sbin/openvpn</p>
			<p class="source-code">users = root,nobody</p>
			<p class="source-code">groups = root,nobody</p>
			<p class="source-code">devices = /dev/urandom, /dev/random, /dev/net/tun</p>
			<p class="source-code">includesections = netbasics, uidbasics</p>
			<p class="source-code">need_logsocket = 1</p>
			<p class="calibre3">With the configuration updated, we can now create the chroot environment. Let's create the <strong class="source-inline">/srv/chroot</strong> directory and then populate it with the necessary files, directories, device nodes, and more with the <strong class="source-inline">jk_init</strong> command:</p>
			<p class="source-code"># mkdir /srv/chroot</p>
			<p class="source-code"># jk_init -v -j /srv/chroot extshellplusnet</p>
			<p class="calibre3">We want to make sure that the SELinux contexts for the resources inside this location are equivalent to the root location, so let's create a file context equivalency definition:</p>
			<p class="source-code"># semanage fcontext -a -e / /srv/chroot</p>
			<p class="source-code"># restorecon -RvF /srv/chroot</p>
			<p class="calibre3">With the <a id="_idIndexMarker593" class="pcalibre calibre6 pcalibre1"/>chroot environment set, we can now update the SSH configuration to chroot a user:</p>
			<p class="source-code">Match User lisa</p>
			<p class="source-code">  X11Forwarding no</p>
			<p class="source-code">  AllowTcpForwarding no</p>
			<p class="source-code">  ChrootDirectory /srv/chroot</p>
			<p class="calibre3">While not applicable to all systems (as it depends on the distribution), we might need to tell the SELinux policy that the user domains for the users can chroot. This privilege (<strong class="source-inline">sys_chroot</strong>) is often not enabled by default for user domains:</p>
			<p class="source-code"># setsebool selinuxuser_use_ssh_chroot true</p>
			<p class="calibre3">With this set, restart the SSH daemon and see whether the chroot is successful: </p>
			<p class="source-code"># systemctl restart ssh</p>
			<p class="calibre3">Chroot environments are not only sensible for SSH access; other daemons might support chroot environments to further protect the resources on the system. In the past, chroot support was a common way to further harden the system. Namespace and resource isolation support has, however, largely surpassed the need for chroot jails. These new features have also jumpstarted the containerized ecosystem, which we will cover in <a href="B16276_11_Final_VK.xhtml#_idTextAnchor293" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 11</em></a>, <em class="italic">Enhancing the Security of Containerized Workloads</em>.</p>
			<p class="calibre3">The SELinux support for applications such as Cockpit, cron, and OpenSSH is generally provided through the SELinux policy and uses PAM integration to link SELinux controls within the application. It is, however, also possible to explicitly build in SELinux support in applications not intentionally SELinux-aware, but who support dynamic additions of logic through a modular design. As an example of this, we will look at Apache and the <strong class="source-inline">mod_selinux</strong> Apache module next.</p>
			<h1 id="_idParaDest-226" class="calibre5"><a id="_idTextAnchor230" class="pcalibre calibre6 pcalibre1"/>Using mod_selinux with Apache</h1>
			<p class="calibre3">Applications <a id="_idIndexMarker594" class="pcalibre calibre6 pcalibre1"/>are often web-based, exposing their <a id="_idIndexMarker595" class="pcalibre calibre6 pcalibre1"/>interface as either a common website or a simple web service, and executing the bulk of logic either within the web server or in backend services that the web server interacts with for the user.</p>
			<p class="calibre3">A web-based application has the huge advantage that end users often don't require any application or client to be installed on top of what is available by default on their device, be it a workstation, laptop, mobile, wristwatch, or smart TV.</p>
			<p class="calibre3">However, unlike <a id="_idIndexMarker596" class="pcalibre calibre6 pcalibre1"/>the services discussed earlier, Apache <a id="_idIndexMarker597" class="pcalibre calibre6 pcalibre1"/>does not run individual user sessions through PAM logins on the system. Instead, user requests are handled by the web server threads and processes themselves, which makes easy SELinux-based controls a bit harder to accomplish.</p>
			<h2 id="_idParaDest-227" class="calibre10"><a id="_idTextAnchor231" class="pcalibre calibre6 pcalibre1"/>Introducing mod_selinux</h2>
			<p class="calibre3">Apache has <a id="_idIndexMarker598" class="pcalibre calibre6 pcalibre1"/>support for modules: dynamically loadable code that enhances the functionality of the web server, without having to rebuild the web server code itself. This modularity has given rise to the popularity of Apache, as we can see through its support for features such as PHP, introducing dynamic web applications to a server platform that was once meant to serve static content only.</p>
			<p class="calibre3"><strong class="source-inline">mod_selinux</strong> uses the same modular support, which allows the Apache web server to become SELinux-aware. Once we enable <strong class="source-inline">mod_selinux</strong>, we can configure Apache to switch SELinux sensitivity or even SELinux domains for running code, further isolating the behavior of the web server and allowing SELinux policies to control what the web server can do. <strong class="source-inline">mod_selinux</strong> also supports user mappings, allowing the Apache web server to run specific user sessions in different domains.</p>
			<p class="calibre3">Before building the <strong class="source-inline">mod_selinux</strong> module, let's first install the necessary dependencies on the system:</p>
			<p class="source-code"># yum install gcc git httpd httpd-devel redhat-rpm-config libselinux-devel</p>
			<p class="calibre3">Once the dependencies are installed, we can download and build the <strong class="source-inline">mod_selinux</strong> code. The code is available on GitHub in Kaigai's <strong class="source-inline">mod_selinux</strong> repository:</p>
			<p class="source-code"># git clone https://github.com/kaigai/mod_selinux</p>
			<p class="source-code"># cd mod_selinux</p>
			<p class="source-code"># apxs -c -i mod_selinux.c</p>
			<p class="calibre3">The <strong class="source-inline">apxs</strong> command <a id="_idIndexMarker599" class="pcalibre calibre6 pcalibre1"/>is the <strong class="bold">Apache Extension Tool</strong>, which facilitates building and installing Apache modules. The command both compiles (<strong class="source-inline">-c</strong>) and installs (<strong class="source-inline">-i</strong>) the <strong class="source-inline">mod_selinux</strong> module. We have yet to activate it in the Apache configuration though, which we accomplish by creating a new module configuration file in <strong class="source-inline">/etc/httpd/conf.modules.d</strong> called <strong class="source-inline">99-selinux.conf</strong> (you can pick whatever name you want, but make sure it ends with the <strong class="source-inline">.conf</strong> suffix):</p>
			<p class="source-code">LoadModule selinux_module modules/mod_selinux.so</p>
			<p class="calibre3">Now, while we have now installed the module, it is not ready for consumption yet, as we have not loaded the SELinux policy for it.</p>
			<p class="calibre3">The <strong class="source-inline">mod_selinux</strong> repository contains the necessary SELinux policy code. However, it is not fully compatible with the more recent SELinux policy used by Linux distributions. We need to edit the <strong class="source-inline">mod_selinux.if</strong> file and remove all references to <strong class="source-inline">httpd_user_script_ro_t</strong>, <strong class="source-inline">httpd_user_script_rw_t</strong>, and <strong class="source-inline">httpd_user_script_ra_t</strong>, as those types are no longer present in current SELinux policies:</p>
			<p class="source-code"># sed -i '/script_r/d' mod_selinux.if</p>
			<p class="calibre3">A second <a id="_idIndexMarker600" class="pcalibre calibre6 pcalibre1"/>change – cosmetic for now – is to rename the calls from <strong class="source-inline">miscfiles_read_certs</strong> to <strong class="source-inline">miscfiles_read_generic_certs</strong>. These are functions used in the reference policy, a different – and still the most common way – of writing SELinux policies (which we cover in <a href="B16276_15_Final_VK.xhtml#_idTextAnchor373" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 15</em></a>, <em class="italic">Using the Reference Policy</em>), and while both functions are supported at the time of writing, the <strong class="source-inline">miscfiles_read_certs</strong> function is no longer recommended for use and will disappear soon:</p>
			<p class="source-code"># sed -i 's/miscfiles_read_certs/miscfiles_read_generic_certs/g' mod_selinux.if</p>
			<p class="calibre3">Once we have adjusted the policy, we can build and load it. As this policy is developed using the reference policy style, the installation first requires building the module before we load it (unlike the directly loadable CIL examples we've used so far):</p>
			<p class="source-code"># make -f /usr/share/selinux/devel/Makefile mod_selinux.pp</p>
			<p class="source-code"># semodule -i mod_selinux.pp</p>
			<p class="calibre3">With the SELinux module loaded and the <strong class="source-inline">mod_selinux</strong> Apache module installed, we can start configuring the Apache daemon with SELinux-specific controls.</p>
			<h2 id="_idParaDest-228" class="calibre10"><a id="_idTextAnchor232" class="pcalibre calibre6 pcalibre1"/>Configuring the general Apache SELinux sensitivity</h2>
			<p class="calibre3">The <a id="_idIndexMarker601" class="pcalibre calibre6 pcalibre1"/>simplest configuration setting that <strong class="source-inline">mod_selinux</strong> supports is to configure Apache to run with a specific SELinux sensitivity. Suppose we want Apache to run with the <strong class="source-inline">s0-s0:c0.c100</strong> sensitivity, then we need to adjust the Apache configuration and use the <strong class="source-inline">selinuxServerDomain</strong> directive.</p>
			<p class="calibre3">Assuming we want to adjust the sensitivity for the default welcome site, edit <strong class="source-inline">/etc/httpd/conf.d/welcome.conf</strong> and add in the following code snippet:</p>
			<p class="source-code">&lt;IfModule mod_selinux.c&gt;</p>
			<p class="source-code">  selinuxServerDomain *:s0-s0:c0.c100</p>
			<p class="source-code">&lt;/IfModule&gt;</p>
			<p class="calibre3">If the Apache web server uses virtual host definitions (allowing a single web server definition to manage multiple websites, based on the hostname that the client is using to access the web content), the <strong class="source-inline">selinuxDomainVal</strong> directive needs to be used instead of the <strong class="source-inline">selinuxServerDomain</strong> one.</p>
			<p class="calibre3">For instance, suppose the web server manages two virtual hosts, one for the <strong class="source-inline">apps.genfic.local</strong> domain, and the other for <strong class="source-inline">intranet.genfic.local</strong>, then we can assign each virtual host with its own sensitivity set like so:</p>
			<p class="source-code">&lt;VirtualHost *:80&gt;</p>
			<p class="source-code">  DocumentRoot /srv/web/apps/htdocs</p>
			<p class="source-code">  ServerName apps.genfic.local</p>
			<p class="source-code">  <strong class="bold">selinuxDomainVal *:s0:c1,c2</strong></p>
			<p class="source-code">&lt;/VirtualHost&gt;</p>
			<p class="source-code">&lt;VirtualHost *:80&gt;</p>
			<p class="source-code">  DocumentRoot /srv/web/intranet/htdocs</p>
			<p class="source-code">  ServerName intranet.genfic.local</p>
			<p class="source-code">  <strong class="bold">selinuxDomainVal *:s0:c3,c4</strong></p>
			<p class="source-code">&lt;/VirtualHost&gt;</p>
			<p class="calibre3">Restart <a id="_idIndexMarker602" class="pcalibre calibre6 pcalibre1"/>the Apache web server and validate that the setting is active:</p>
			<p class="source-code"># systemctl restart httpd</p>
			<p class="source-code"># ps -efZ | grep httpd_t</p>
			<p class="source-code">system_u:system_r:httpd_t:s0-s0:c0.c100 ... /usr/sbin/httpd</p>
			<p class="calibre3">As you can see, the web server is now running with the given sensitivity. An important caveat though: the <strong class="source-inline">mod_selinux</strong> code does not support <strong class="source-inline">mcstransd</strong>, the translation daemon we covered in <a href="B16276_03_Final_VK.xhtml#_idTextAnchor071" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing User Logins</em>, so you cannot use human-readable sensitivity definitions such as <strong class="source-inline">SystemLow-SystemHigh</strong>.</p>
			<h2 id="_idParaDest-229" class="calibre10"><a id="_idTextAnchor233" class="pcalibre calibre6 pcalibre1"/>Mapping end users to specific domains</h2>
			<p class="calibre3">To map <a id="_idIndexMarker603" class="pcalibre calibre6 pcalibre1"/>users, when logged in to a web application, to a specific domain, we need to create a user mapping file. This mapping file is then referred to using the <strong class="source-inline">selinuxDomainMap</strong> directive in the web server configuration.</p>
			<p class="calibre3">Let's first create the mapping file inside <strong class="source-inline">/etc/httpd/conf.d</strong>, naming it <strong class="source-inline">mod_selinux.map</strong>, with the following content:</p>
			<p class="source-code">test	user_webapp_t:s0:c0.c100</p>
			<p class="source-code">*	user_webapp_t:s0:c0,c1</p>
			<p class="source-code">__anonymous__	anon_webapp_t:s0</p>
			<p class="calibre3">This mapping file contains three mappings:</p>
			<ul class="calibre8">
				<li class="calibre9">The first one is for a user called <strong class="source-inline">test</strong> and is mapped to the <strong class="source-inline">user_webapp_t</strong> domain and <strong class="source-inline">s0:c0.c100</strong> sensitivity.</li>
				<li class="calibre9">The second one is for any successfully authenticated user and is mapped to the <strong class="source-inline">user_webapp_t</strong> domain and <strong class="source-inline">s0:c0,c1</strong> sensitivity.</li>
				<li class="calibre9">The third one is for unauthenticated users and is mapped to the <strong class="source-inline">anon_webapp_t</strong> domain.</li>
			</ul>
			<p class="calibre3">We can <a id="_idIndexMarker604" class="pcalibre calibre6 pcalibre1"/>then refer to this map by adjusting the previously created snippet like so:</p>
			<p class="source-code">&lt;IfModule mod_selinux.c&gt;</p>
			<p class="source-code">  selinuxServerDomain *:s0-s0:c0.c100</p>
			<p class="source-code">  selinuxDomainMap /etc/httpd/conf.d/mod_selinux.map</p>
			<p class="source-code">&lt;/IfModule&gt;</p>
			<p class="calibre3">Restart the web server to apply the changes.</p>
			<h2 id="_idParaDest-230" class="calibre10"><a id="_idTextAnchor234" class="pcalibre calibre6 pcalibre1"/>Changing domains based on source</h2>
			<p class="calibre3">The <strong class="source-inline">mod_selinux</strong> module also supports setting the server domain value based on environment <a id="_idIndexMarker605" class="pcalibre calibre6 pcalibre1"/>variables that we have defined elsewhere in the configuration. For instance, we can first declare the value in an environment variable when a certain condition triggers, and then tell <strong class="source-inline">mod_selinux</strong> that this environment variable's value is to be used for the server domain setting.</p>
			<p class="calibre3">Let's make this a bit more tangible with an example. Suppose the website manages web applications for both local (internal) people, as well as for people that work from remote locations. Assuming these users enter the web server through different source IP addresses, we can use the source IP address to differentiate between the two and assign a different SELinux sensitivity value.</p>
			<p class="calibre3">We can do this in the Apache configuration with the <strong class="source-inline">SetEnvIf</strong> directive, which declares an environment variable but only if a request matches a particular condition. The condition we use is then the <strong class="source-inline">Remote_Addr</strong> directive, which checks the source IP address against the expression that follows.</p>
			<p class="calibre3">Suppose local users come from <strong class="source-inline">10.10.0.0/16</strong> and remote users from a load balancer or reverse proxy with the IP address <strong class="source-inline">10.121.12.15</strong>, then we can differentiate this as follows:</p>
			<p class="source-code">SetEnvIf Remote_Addr "10.10.[0-9]+.[0-9]+$" SENSITIVITY=*:s0:c0.c80</p>
			<p class="source-code">SetEnvIf Remote_Addr "10.121.12.15" SENSITIVITY=*:s0:c90</p>
			<p class="source-code">selinuxDomainEnv SENSITIVITY</p>
			<p class="calibre3">It is possible to mix and match multiple <strong class="source-inline">mod_selinux</strong> directives. The module will use the first successful declaration, so you could use a user mapping first, and if that user mapping does not result in a hit (because the user is not declared in the map), use the environment variable, and if that fails, fall back to a default setting.</p>
			<p class="calibre3">All we have <a id="_idIndexMarker606" class="pcalibre calibre6 pcalibre1"/>to do to accomplish this fallback definition is to sequentially declare the <strong class="source-inline">mod_selinux</strong> directives, like so:</p>
			<p class="source-code">selinuxDomainMap /etc/httpd/conf.d/mod_selinux.map</p>
			<p class="source-code">selinuxDomainEnv SENSITIVITY</p>
			<p class="source-code">selinuxDomainVal *:s0:c0,c1</p>
			<p class="calibre3">Through these declarations, you can fine-tune the web server security using SELinux domains and sensitivities. While this should never replace the security approach within the application itself, it provides additional isolation in case an unauthorized or malicious user exploits an error within the application.</p>
			<h1 id="_idParaDest-231" class="calibre5"><a id="_idTextAnchor235" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, we started out with an introduction to systemd and a strong focus on the service management capabilities that systemd offers. We learned how to start a service with a custom SELinux context as well as how additional files can be properly labeled upon boot. Alongside the service management, through systemd's unit files, this chapter also covered transient services and how to immediately associate the right SELinux context.</p>
			<p class="calibre3">Other systemd capabilities and services were touched upon as well. We saw how SELinux contexts are registered as part of the systemd journal and how to query for events using this context. We took a brief look at udev and how its rules can be used to support administrators in managing devices. One of its actions is to set the SELinux context of the device node.</p>
			<p class="calibre3">We then looked at D-Bus, how SELinux can be used to control the association of applications with services, and how D-Bus uses the <strong class="source-inline">send_msg</strong> permission to validate communications across its channels.</p>
			<p class="calibre3">After D-Bus, we looked at several services that use PAM to launch user contexts, and we dived into specific examples such as SSH, learning how SELinux policy developers have further fine-tuned support for these services.</p>
			<p class="calibre3">We finished with a look at <strong class="source-inline">mod_selinux</strong>, a dynamic module for Apache that enables SELinux support within Apache's configuration even though Apache itself does not have any SELinux specifics in it.</p>
			<p class="calibre3">In the next chapter, we will look at another SELinux-aware application, SEPostgreSQL, which extends the popular and robust PostgreSQL database with mandatory access control support through SELinux.</p>
			<h1 id="_idParaDest-232" class="calibre5"><a id="_idTextAnchor236" class="pcalibre calibre6 pcalibre1"/>Questions</h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">Why should you not update unit files in <strong class="source-inline">/usr/lib/systemd/system</strong> directly?</li>
				<li class="calibre9">What application allows resetting the SELinux context of files during boot?</li>
				<li class="calibre9">How can we get all log events in journald associated with a given SELinux context?</li>
				<li class="calibre9">How can you set the SELinux label for a device node created by udev?</li>
				<li class="calibre9">Are SELinux controls always applicable to D-Bus associations?</li>
				<li class="calibre9">How is it possible for Apache to be SELinux-aware without Apache having any SELinux code in it?</li>
			</ol>
		</div>
	</div></body></html>