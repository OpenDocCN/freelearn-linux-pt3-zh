- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Creating User Interfaces with yad, dialog, and xdialog
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 yad、dialog 和 xdialog 创建用户界面
- en: I know, you’re thinking that shell scripting consists of nothing but entering
    boring, plain-text commands in a terminal. But, what if I told you that you can
    fancy up your scripts by adding a user interface? What if I told you that you
    can have a graphical interface for desktop systems or a non-graphical interface
    for text-mode servers? Well, you can, and I’m here to show you how.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，你可能在想 shell 脚本不过是进入终端输入无聊的纯文本命令而已。但如果我告诉你，你可以通过添加用户界面来让你的脚本更炫酷呢？如果我告诉你，你可以为桌面系统添加图形界面，为文本模式的服务器添加非图形界面呢？没错，你完全可以做到，而我会告诉你怎么做。
- en: 'Topics in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容包括：
- en: Creating a graphical user interface with `yad`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `yad` 创建图形用户界面
- en: Creating user interfaces with `dialog` and `xdialog`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `dialog` 和 `xdialog` 创建用户界面
- en: If you’re ready, let’s get started.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你准备好了，我们就开始吧。
- en: Technical Requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For `yad` and `xdialog`, you’ll need to use a desktop implementation of Linux.
    It doesn’t much matter which distro you use, as long as the `yad` and `xdialog`
    packages are in the repository. Just use your distro’s normal package management
    tool to install them. (The `yad` and `xdialog` packages are also available for
    GhostBSD, which is FreeBSD with either the Mate or Xfce desktop environment. If
    you’re on a Mac, you’ll need to install `yad` or `xdialog` via Homebrew. Alas,
    neither one is available for OpenIndiana, and `yad` isn’t available for any of
    the RHEL 9-type distros.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `yad` 和 `xdialog`，你需要使用桌面版的 Linux。使用哪种发行版并不重要，只要 `yad` 和 `xdialog` 包在软件仓库中即可。只需使用你发行版的标准包管理工具来安装它们。（`yad`
    和 `xdialog` 包也适用于 GhostBSD，它是 FreeBSD 的一个版本，支持 Mate 或 Xfce 桌面环境。如果你在 Mac 上，你需要通过
    Homebrew 安装 `yad` 或 `xdialog`。遗憾的是，OpenIndiana 上没有这两个工具，而 `yad` 在任何 RHEL 9 类的发行版上都不可用。）
- en: For the `dialog` section, you can use either a desktop or a text-mode server
    implementation of Linux.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `dialog` 部分，你可以使用桌面或文本模式服务器实现的 Linux。
- en: 'And, as always, you can grab the scripts by running:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，你可以通过运行以下命令来获取脚本：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Okay, let’s begin by looking at `yad`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们从 `yad` 开始看起。
- en: Creating a Graphical User Interface with yad
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 yad 创建图形用户界面
- en: '**Yet Another Dialog**, or **yad** for short, is a very cool program that allows
    you to add GUI-type interfaces to your shell scripts. There’s a lot you can do
    with it, and I’d like to show you a few simple examples.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Yet Another Dialog**，简称 **yad**，是一个非常酷的程序，可以让你为 shell 脚本添加图形化界面。你可以用它做很多事情，我想给你展示几个简单的例子。'
- en: The yad Basics
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: yad 基础
- en: 'In the `yad` man page, you’ll see a list of pre-defined components that you
    can use in your `yad` scripts. For example, if you do `yad --file`, you’ll open
    the file manager that looks like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `yad` 的手册页中，你会看到一列预定义的组件，可以在你的 `yad` 脚本中使用。例如，如果你运行 `yad --file`，你会打开一个像这样的文件管理器：
- en: '![B21693_16_1](img/B21693_16_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_1](img/B21693_16_01.png)'
- en: 'Figure 16.1: The yad file manager'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1：yad 文件管理器
- en: 'As it is, this file manager won’t do anything for you. If you click on a file
    and then click the **OK** button, the manager will close and the name of the file
    that you chose will print out on the command line, like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，这个文件管理器对你没有任何帮助。如果你点击一个文件，然后点击 **OK** 按钮，管理器会关闭，并且你选择的文件名会打印在命令行上，像这样：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To make this useful, you’ll need to add code that will perform some desired
    action upon the chosen file. Before we attempt something this complex though,
    let’s begin with something that’s a bit more simple.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使它更有用，你需要添加代码，对所选文件执行一些预期的操作。不过，在尝试这么复杂的操作之前，我们先从一些稍微简单的内容开始。
- en: Creating Data Entry Forms
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据输入表单
- en: 'Let’s say that you’re a collector of classic automobiles, and you need to create
    a simple database to keep track of your vast collection. We’ll begin by testing
    the basic script, which looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一个经典汽车收藏爱好者，你需要创建一个简单的数据库来跟踪你庞大的收藏。我们将从测试基本脚本开始，脚本内容如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That’s a bit hard to read, though. So, let’s make the `yad-form-auto1.sh` script
    a bit more readable, like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这个有点难读。所以，让我们稍微调整一下 `yad-form-auto1.sh` 脚本，使其更具可读性，像这样：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This `yad` command is actually one long command. To make it more readable, I’ve
    broken it up over several lines, by adding a backslash after each option definition.
    You could leave out the backslashes and just place the entire command on one line,
    as you saw above, but this looks much better.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`yad`命令实际上是一个长命令。为了使其更易读，我将其分成了几行，每个选项定义后都加上了反斜杠。如果你愿意，也可以去掉反斜杠，将整个命令写成一行，就像上面看到的那样，但分行显示要好得多。
- en: 'On the first line, I’ve placed both the `--title` and the `--text` definitions,
    which should be self-explanatory. The second line defines a form with a width
    of 400 pixels. Following that are the definitions for the data entry fields. Note
    that the `Year` field can only accept a numerical value, as indicated by the `:NUM`
    parameter. At the end, I’m redirecting the output into the `classic_autos.txt`
    file. (I’m using the `>>` operator so that I can add more than one auto to the
    file.) Here’s how it looks when I run the script:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我同时设置了`--title`和`--text`定义，这些应该是显而易见的。第二行定义了一个宽度为400像素的表单。接下来的定义是数据输入字段。请注意，`Year`字段只能接受数字值，如`:NUM`参数所示。最后，我将输出重定向到`classic_autos.txt`文件中。（我使用`>>`操作符，以便可以将多个汽车信息添加到文件中。）这是我运行脚本时的样子：
- en: '![B21693_16_2](img/B21693_16_02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_2](img/B21693_16_02.png)'
- en: 'Figure 16.2: Running yad-form-auto1.sh'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：运行yad-form-auto1.sh
- en: 'When I hit the **OK** button, the output will be saved to the `classic_autos.txt`
    file, which will look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我点击**OK**按钮时，输出将被保存到`classic_autos.txt`文件中，内容如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By default, `yad` uses the `|` symbol as the output field separator. That’s
    okay, because if you open this file in a spreadsheet program, you can set the
    `|` symbol as the field separator, and it will work just fine. But, you can change
    the field separator if you like. For example, if you want to create `.csv` files,
    just add the `--separator=","` parameter to the `--form` line.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`yad`使用`|`符号作为输出字段分隔符。这是可以的，因为如果你在电子表格程序中打开此文件，你可以设置`|`符号作为字段分隔符，它会正常工作。不过，如果你愿意，你也可以更改字段分隔符。例如，如果你想创建`.csv`文件，只需在`--form`行中添加`--separator=","`参数。
- en: 'One slight problem with this script is that every time you hit the **OK** button
    to create an entry in your text file, the script will exit. Each time you add
    an auto, you’ll need to invoke the script again. Let’s fix that with a `while`
    loop, as you see here in the `yad-form-auto2.sh` script:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本有一个小问题，每当你点击**OK**按钮将一个条目创建到文本文件中时，脚本就会退出。每次添加一辆车，你都需要重新启动脚本。让我们通过在`yad-form-auto2.sh`脚本中使用`while`循环来修复这个问题：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By using a `:` as the while condition, we’re creating what’s known as an infinite
    loop. In other words, this will never quit until you press **Ctrl-c**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`:`作为`while`条件，我们创建了一个所谓的无限循环。换句话说，除非按下**Ctrl-c**，否则它将永远不会退出。
- en: 'While I was at it, I added the `Date Acquired` field with the `:DT` option.
    This option causes a handy-dandy calendar to pop up whenever I click on the calendar
    icon. Here’s how it looks:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我添加了`Date Acquired`字段，并使用了`:DT`选项。这个选项会在我点击日历图标时弹出一个方便的日历。这里是它的显示样式：
- en: '![B21693_16_3](img/B21693_16_03.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_3](img/B21693_16_03.png)'
- en: 'Figure 16.3: The yad-form-auto2.sh script'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3：yad-form-auto2.sh脚本
- en: This is good, but it’s still not perfect. Due to using a `:` for the while condition,
    the only way to end this script is to **Ctrl-c** out of it, because the **Cancel**
    button won’t do anything. To fix that, you need to understand that the **OK**
    button returns a 0 as the exit code, and the **Cancel** button returns a 1 as
    the exit code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做不错，但仍然不完美。由于使用了`:`作为`while`条件，结束这个脚本的唯一方法就是**Ctrl-c**，因为**取消**按钮不会起作用。要解决这个问题，你需要明白，**OK**按钮返回0作为退出代码，而**取消**按钮返回1作为退出代码。
- en: If you need to review the concept of exit codes, refer back to *Chapter 8, Basic
    Shell Script Construction*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要复习退出代码的概念，请参考*第8章，基本Shell脚本构建*。
- en: 'So, let’s modify the `while` loop in this `yad-form-auto3.sh` script:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们修改一下`yad-form-auto3.sh`脚本中的`while`循环：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `$? == 0` parameter retrieves the exit code and verifies that it’s 0\. This
    keeps the script running as long as you don’t click on either the **Cancel** button
    or the **X** at the top corner of the window. (I forgot to mention that hitting
    the **X** returns an exit code of 252.)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`$? == 0`参数获取退出代码并验证它是否为0。这使得脚本在你没有点击**取消**按钮或窗口右上角的**X**时一直运行。（我忘记提到，点击**X**会返回退出代码252。）'
- en: Now, let’s wrap this section up with one last modification.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过最后一次修改来结束这一部分。
- en: Creating a Drop-down List
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建下拉列表
- en: 'This time, we’ll add a drop-down list for choosing the body style, and a free-form
    text box. Here’s the `yad-form-auto4.sh` script to show you how it’s done:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将添加一个下拉列表供选择车身样式，并加入一个自由文本框。以下是`yad-form-auto4.sh`脚本，展示了如何实现：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `bodystyles=` line, the `--item-separator` parameter in the `--form` line,
    and the `"" "" ""` line all work together to create the drop-down list. The `bodystyles=`
    defines the list of available body styles, separated by commas. This goes along
    with the `--item-separator` parameter, which ensures that the drop-down list appears
    with only one body style per line, instead of having all body styles on one line.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`bodystyles=`行、`--form`行中的`--item-separator`参数和`"" "" ""`行一起工作，创建了下拉列表。`bodystyles=`定义了可用车身样式的列表，样式之间用逗号分隔。这与`--item-separator`参数配合使用，确保下拉列表每行只显示一个车身样式，而不是将所有车身样式放在同一行。'
- en: 'The `:CBE` parameter at the end of the `--field="Body Style"` line defines
    this field as a drop-down list with the option to edit it if you choose the **other**
    option. The last line in the `while` loop tells `yad` where to place the values
    of the `bodystyles` variable. We see that the `Body Style` field is the fourth
    field. So to represent the first three fields, which are blank by default, we
    place three pairs of double quotes ahead of the `$bodystyles` variable. The last
    item on the line places a line of text in the `Date Acquired` field. The final
    field definition is the free-form text box, as you see by the `:TXT` parameter.
    (The text box field comes after the drop-down list field, which means that you
    don’t have to add another pair of double-quotes to be a placeholder.) Here’s how
    it looks when I choose a body style:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`--field="Body Style"`行末的`:CBE`参数将此字段定义为下拉列表，并在选择**其他**选项时可以编辑。`while`循环中的最后一行告诉`yad`在哪里放置`bodystyles`变量的值。我们看到`Body
    Style`字段是第四个字段。所以为了表示前三个字段（默认是空的），我们在`$bodystyles`变量前放置了三对双引号。行末的最后一项将一行文本放入`Date
    Acquired`字段。最终字段定义是自由文本框，正如通过`:TXT`参数看到的。（文本框字段在下拉列表字段之后，这意味着您不需要再添加一对双引号作为占位符。）当我选择车身样式时，它看起来是这样的：'
- en: '![B21693_16_4](img/B21693_16_04.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_4](img/B21693_16_04.png)'
- en: 'Figure 16.4: Using a drop-down list'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4：使用下拉列表
- en: Of course, you can adapt this script for pretty much any purpose. That can include
    keeping inventories of your own personal collections, store merchandise, or software
    licenses. (Let your imagination run wild.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以将这个脚本适应于几乎任何目的。这包括管理您个人收藏的库存、商店商品或软件许可证。（让您的想象力尽情驰骋。）
- en: That wraps it up for this demo. Now, let’s manage some files.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本次演示的结束。现在，让我们来管理一些文件吧。
- en: Using the yad File Manager
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用yad文件管理器
- en: The easiest way to work with files is to create a variable, with its value assigned
    by a `yad` command substitution construct. Then, you can do whatever you want
    with the value of the variable. Let’s see what we can do with that.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件交互的最简单方法是创建一个变量，并通过`yad`命令替换结构为其赋值。然后，您可以对该变量的值执行任何操作。我们来看看可以做些什么。
- en: Creating a File Checksum Utility
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建文件校验和工具
- en: 'For the first example, let’s say that you want to create a list of files with
    their `sha512` checksums. Here’s the `yad-file-checksum1.sh` script that does
    just that:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个例子，假设您想创建一个包含`sha512`校验和的文件列表。以下是实现此功能的`yad-file-checksum1.sh`脚本：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Clicking on a file assigns the name of that file to the `filetocheck` variable.
    We can then use the value of that variable as the argument for the `sha512sum`
    command.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 点击一个文件会将该文件的名称赋值给`filetocheck`变量。然后，我们可以使用该变量的值作为`sha512sum`命令的参数。
- en: 'Here’s how it looks:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它的样子如下：
- en: '![B21693_16_5](img/B21693_16_05.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_5](img/B21693_16_05.png)'
- en: 'Figure 16.5: Opening a file with yad-file-checksum1.sh script'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5：使用yad-file-checksum1.sh脚本打开文件
- en: 'Clicking the **OK** button creates the `file_checksum.txt` file, which contains
    the SHA512 checksum of the `people.txt` file, which looks like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**按钮会创建`file_checksum.txt`文件，该文件包含`people.txt`文件的SHA512校验和，内容如下所示：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That’s great, but as always, we can fancy things up a bit. In the `yad-file-checksum2.sh`
    script, we’ll add a `while` loop so that the **Cancel** button will work, and
    also add the ability to choose multiple files. And, while we’re at it, let’s add
    a file preview feature. Here’s how that looks:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，但一如既往地，我们可以让它更精致。在`yad-file-checksum2.sh`脚本中，我们将添加一个`while`循环，使**取消**按钮能够工作，并且还可以选择多个文件。同时，我们还会加入一个文件预览功能。它看起来是这样的：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `--multiple` and the `--separator=''\n''` options work together. Without
    the `--separator` option, the `--multiple` option will cause all filenames to
    appear as one long line, with filenames separated by a `|` symbol. This will cause
    the `sha512sum` utility to view that line as a single filename, which will cause
    an error. Placing a new line after each filename solves the problem. The `--add-preview`
    and the `--width` options should be self-explanatory, so I won’t comment about
    them. At any rate, here’s how the new script works:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`--multiple`和`--separator=''\n''`选项一起工作。没有`--separator`选项时，`--multiple`选项会导致所有文件名作为一行显示，文件名之间用`|`符号分隔。这会导致`sha512sum`工具将这一行视为单个文件名，从而导致错误。在每个文件名后面加上换行符可以解决这个问题。`--add-preview`和`--width`选项应该不言自明，因此我不再赘述。总之，以下是这个新脚本的工作方式：'
- en: '![B21693_16_6](img/B21693_16_06.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_6](img/B21693_16_06.png)'
- en: 'Figure 16.6: The file selector with the preview and multiple file options'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：带预览和多个文件选项的文件选择器
- en: You can select multiple non-consecutive files by holding down the **Ctrl** key,
    or multiple consecutive files by holding down the **Shift** key. The end result
    will be a text file that contains the SHA512 sum checks of all the selected files.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过按住**Ctrl**键选择多个不连续的文件，或者按住**Shift**键选择多个连续的文件。最终结果将是一个文本文件，包含所有选中文件的SHA512校验和。
- en: I have to confess that there’s something weird going on with this script, and
    that it has me stumped. When you click on either the **Cancel** button or the
    **X** button, the dialog box will close down as it’s supposed to do. But, for
    some strange reason the process doesn’t end, which means that the terminal never
    returns to the command-prompt. I’ve tried performing every unnatural act I could
    think of to fix that, but to no avail. So, it appears that whenever you run this
    script, you’ll just have to **Ctrl-c** out of it when you’re done.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，这个脚本有点怪异，让我感到困惑。当你点击**取消**按钮或**X**按钮时，弹窗应该会关闭。但由于某些奇怪的原因，进程并没有结束，这意味着终端永远不会返回到命令提示符。我试过了所有能想到的非自然手段来解决这个问题，但都没有成功。所以，看起来每次运行这个脚本时，完成后你只需**Ctrl-c**退出即可。
- en: All right, let’s move on to the next example.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来我们继续下一个例子。
- en: Creating a GUI Front-end for ImageMagick
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个图形界面前端用于ImageMagick
- en: 'Next, let’s see if we can create a GUI front-end for the ImageMagick program
    that we talked about back in *Chapter 13, Scripting with ImageMagick*. We’ll begin
    with the `yad-image-resize1.sh` script, which looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看能否为我们在*第13章，使用ImageMagick编写脚本*中提到的ImageMagick程序创建一个图形界面前端。我们将从`yad-image-resize1.sh`脚本开始，脚本内容如下：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first line creates the initial file selection window. It then assigns the
    filename of the selected file to the `imageFile` variable. Here’s how this initial
    window looks:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了初始的文件选择窗口。然后，它将所选文件的文件名分配给`imageFile`变量。以下是这个初始窗口的样子：
- en: '![B21693_16_7](img/B21693_16_07.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_7](img/B21693_16_07.png)'
- en: 'Figure 16.7: The initial file selection window for resizing images'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：用于调整图像大小的初始文件选择窗口
- en: The second line creates the **Image Resize** window that you’ll use for entering
    the resize and quality parameters. When you enter your desired parameters, they’ll
    get stored in the `dialog` variable as a single line, with the two parameters
    separated by a `|` symbol.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行创建了**图像调整大小**窗口，你将用它来输入调整大小和质量参数。当你输入所需的参数时，它们会以单行的形式存储在`dialog`变量中，两个参数之间用`|`符号分隔。
- en: 'The next two lines create the `size` and `quality` variables, using the values
    that are stored in the `dialog` variable. We need a way to extract each individual
    parameter, and `awk` gives us a handy way to do it. Anyway, here’s how the **Image
    Resize** window looks:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行创建了`size`和`quality`变量，使用存储在`dialog`变量中的值。我们需要一种方法来提取每个单独的参数，而`awk`为我们提供了一个方便的方法。总之，以下是**图像调整大小**窗口的样子：
- en: '![B21693_16_8](img/B21693_16_08.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_8](img/B21693_16_08.png)'
- en: 'Figure 16.8: the Image Resize window'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：图像调整大小窗口
- en: Next comes the `convert` line, which performs the actual resizing. You see that
    it’s using values from the `size`, `quality`, and `imageFile` variables. When
    I click on the **OK** button, the resizing process will take place.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`convert`行，它执行实际的调整大小操作。你会看到它使用了`size`、`quality`和`imageFile`变量中的值。当我点击**确定**按钮时，调整大小过程将会发生。
- en: 'The final line creates the **Status** window, which shows that the process
    is complete. By default, `yad` windows have both a **Cancel** and an **OK** button.
    In this case, we only want the **OK** button, so we override the default behavior
    by explicitly creating an **OK** button with the `--button` option. Here’s how
    this window looks:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行创建了**状态**窗口，显示处理过程已完成。默认情况下，`yad`窗口有**取消**和**确定**按钮。在这种情况下，我们只需要**确定**按钮，因此我们通过显式创建一个**确定**按钮来覆盖默认行为，使用`--button`选项。以下是该窗口的样子：
- en: '![B21693_16_9](img/B21693_16_09.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_9](img/B21693_16_09.png)'
- en: 'Figure 16.9: The Status window'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.9：状态窗口
- en: Look in your directory, and you should see that the image has indeed been resized.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的目录中查看，你应该能看到图像确实已经被调整大小。
- en: To give credit where credit is due, I borrowed this script from a *Linux Magazine*
    article that was posted way back in 2012, and made a couple of minor tweaks to
    it. You’ll find the link to the original article in the *Further Reading* section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 说一句公道话，我借用了这段脚本，它最初出现在2012年的一篇*Linux Magazine*文章中，并对其做了几个小的修改。你可以在*进一步阅读*部分找到原始文章的链接。
- en: 'The major flaw with this script is that it overwrites the original graphics
    file with the resized version. Let’s modify it so that it will save the resized
    version as a new file with a new filename. Here’s the `yad-image-resize2.sh` script
    that does that:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的主要缺陷是它会用调整大小后的版本覆盖原始的图形文件。让我们修改它，使得它能够将调整大小后的版本保存为一个新文件，并且使用新的文件名。以下是执行此操作的`yad-image-resize2.sh`脚本：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To make this work, I created two new variables and used variable expansion
    to assign them their values. The `newfilename=${imageFile%%.*}` line grabs the
    first part of the `imageFile` filename, up to the dot for the filename extension.
    For example, let’s say that the value of `imageFile` is `somegraphic.jpg`. Using
    variable expansion to strip off the `.jpg` would result in assigning a value of
    `somegraphic` to the `newfilename` variable. The `suffix` variable uses the offset
    feature of variable expansion. In this case, the `${imageFile: -4}` construct
    grabs the last four characters of the filename. This results in assigning a value
    of `.jpg` to the `suffix` variable.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '为了实现这一点，我创建了两个新变量，并使用变量扩展为它们赋值。`newfilename=${imageFile%%.*}`这一行提取了`imageFile`文件名的第一部分，直到文件扩展名的点为止。例如，假设`imageFile`的值是`somegraphic.jpg`。使用变量扩展来去除`.jpg`后，将`somegraphic`赋值给`newfilename`变量。`suffix`变量使用了变量扩展的偏移特性。在这种情况下，`${imageFile:
    -4}`构造会提取文件名的最后四个字符。因此，它会将`.jpg`赋值给`suffix`变量。'
- en: 'The next thing to note is how I had to modify the `convert` command. (By the
    way, note that this `convert` command is quite long, and wraps around on the page.)
    All I did was to add the `-delete 1 "$newfilename"_resized"$suffix"` part to the
    end of the command that I had before. You’ve probably figured out that with our
    current example, this would create a new file with the filename, `somegraphic_resized.jpg`.
    But, you might be puzzled by the `-delete 1` part. Well, it’s just that under
    certain conditions, the `convert` command will create two output files, instead
    of just one, as you see here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的要点是如何修改`convert`命令。（顺便提一下，请注意，这个`convert`命令相当长，并且在页面上会换行。）我所做的只是将`-delete
    1 "$newfilename"_resized"$suffix"`部分添加到我之前的命令末尾。你可能已经猜到，在我们当前的示例中，这会创建一个新文件，文件名为`somegraphic_resized.jpg`。但是，你可能会对`-delete
    1`这一部分感到困惑。其实，这只是因为在某些条件下，`convert`命令会创建两个输出文件，而不仅仅是一个，正如你在这里看到的：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Adding the `-delete 1` parameter just before the output filename parameter
    eliminates that problem, as you see here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出文件名参数之前添加`-delete 1`参数，解决了这个问题，正如你在这里看到的：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The final modification I’ll show you, which I’ll put in `yad-image-resize3.sh`,
    causes the file manager to only display certain file types. Since we’re dealing
    with graphics files, we only want the file manager to show us files with the `.JPG`,
    `.jpg`, `.PNG`, and `.png` filename extensions. We’ll do that by just adding the
    `--file-filter "Graphics files | *.JPG *.jpg *.PNG *.png")` option to the `imageFile=`
    line that’s at the top of the script. The new line now looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示的最终修改，我会将其放入`yad-image-resize3.sh`，它会使文件管理器只显示特定类型的文件。由于我们处理的是图形文件，所以我们只希望文件管理器显示`.JPG`、`.jpg`、`.PNG`和`.png`扩展名的文件。我们可以通过将`--file-filter
    "Graphics files | *.JPG *.jpg *.PNG *.png"`选项添加到脚本顶部的`imageFile=`行来实现。新的行现在看起来是这样的：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that the line is quite long, let’s make it more readable by breaking it
    up with backslashes, like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一行相当长，我们可以通过使用反斜杠将其分成多行，以便提高可读性，像这样：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That looks much better, right?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那看起来好多了，对吧？
- en: All right, let’s move on to our final example.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续进行最后一个例子。
- en: Programming Form Buttons
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程表单按钮
- en: 'In this scenario, we’re in a software developer’s shop that’s running a small
    fleet of Fedora Linux-powered workstations. We want to create a GUI-type setup
    utility that will simplify the process of setting up a new workstation. Furthermore,
    we want to carry this utility around on a USB memory stick so that we can either
    run it directly from the memory stick, or copy it to each workstation. Fortunately,
    that’s easy with `yad`. Here’s the `yad-system-tool.sh` script that does that:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们处在一个软件开发者的工作室，运行着一小队由Fedora Linux驱动的工作站。我们想创建一个图形界面类型的设置工具，以简化设置新工作站的过程。此外，我们还希望将这个工具存放在USB闪存盘中，这样我们可以直接从闪存盘运行它，或者将它复制到每台工作站上。幸运的是，使用`yad`很容易做到这一点。下面是完成这项工作的`yad-system-tool.sh`脚本：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this script, you see some options that you haven’t seen before. The `--columns=3`
    option in the first line means that we want to create a form with three buttons
    across on each row. On the second line, you see a `--height` option, as well as
    a `--width` option. In each of the `--field` lines, you see the `:FBTN` option,
    which defines the fields as programmable buttons. The `<b>` and `</b>` tags that
    surround the button text make the button text appear in bold type. The final portion
    of each `--field` line consists of the command that will run when you click on
    the button.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，你会看到一些你之前没见过的选项。第一行中的`--columns=3`选项表示我们想要在每一行中创建三个按钮。第二行中你会看到`--height`选项以及`--width`选项。在每个`--field`行中，你会看到`：FBTN`选项，它定义了这些字段为可编程按钮。围绕按钮文本的`<b>`和`</b>`标签使按钮文本以粗体显示。每个`--field`行的最后一部分是点击按钮时将运行的命令。
- en: 'The first button is programmed to perform a system update with the `dnf -y
    upgrade` command. The `-y` causes the command to run without stopping to prompt
    the user about whether he or she really wants to do it. I had to use the `-y`
    option, because without it, the operation would abort at the prompt. The next
    two buttons each install a selected group of software packages. If you want to
    see what’s in each of these groups, just run these two commands:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个按钮被编程为使用`dnf -y upgrade`命令执行系统更新。`-y`使得命令在运行时不会停止并提示用户是否真的要继续。我必须使用`-y`选项，因为如果没有它，操作会在提示时中止。接下来的两个按钮每个安装一组选定的软件包。如果你想查看每个组中包含的软件包，只需运行这两个命令：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since we’re dealing with administrative commands in this script, we’ll need
    to run it with `sudo`. Here’s how it looks:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个脚本中使用了管理员命令，因此我们需要用`sudo`来运行它。下面是它的样子：
- en: '![B21693_16_10](img/B21693_16_10.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_10](img/B21693_16_10.png)'
- en: 'Figure 16.10: A yad form with programmable buttons'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10：带有可编程按钮的yad表单
- en: Now, just click on a button and watch what happens.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需点击一个按钮，看看会发生什么。
- en: 'Adding more software installation choices is easy, by just adding more `--field`
    lines. If you want to see the list of software packages that are available on
    Fedora, just do:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更多的软件安装选项很简单，只需添加更多的`--field`行。如果你想查看在Fedora上可用的软件包列表，只需执行：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I know, you’re thinking that this type of chore would be more easily accomplished
    with a set of plain, text-mode scripts. And yeah, you’re right. So, just think
    of this example as a template that you can use for your own purposes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，你可能认为这种任务用一组普通的文本模式脚本来完成会更简单。是的，你说得对。所以，只需把这个例子当作一个模板，供你根据自己的需要使用。
- en: Also, I neglected to mention before that you’ll need to manually install `yad`
    on each system that you want to administer with this script.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我之前没有提到，你需要手动在每个你想用这个脚本管理的系统上安装`yad`。
- en: That wraps things up for this script, so let’s move on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个脚本的全部内容，让我们继续进行下一个。
- en: Some Final Thoughts about yad
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于yad的一些最终思考
- en: '`yad` is a really cool program, and you can do a lot of really cool stuff with
    it. In fact, a person could probably write a whole book on nothing but `yad`.
    I can’t do that at the moment, but I’ve hopefully given you enough to whet your
    appetite.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`yad`是一个非常酷的程序，你可以用它做很多非常酷的事情。事实上，一个人可能会写一本关于`yad`的书。我现在不能这样做，但希望我已经给你足够的内容来引起你的兴趣。'
- en: The main problem with `yad` is that for whatever reason, its creator has never
    written any real documentation for it, other than a very sparse man page. Fortunately,
    a lot of other people have taken up the challenge, and have created their own
    documentation and tutorials on both the web and on YouTube. (I’ll link to some
    of these resources in the `Further Reading` section.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`yad` 的主要问题是，无论出于什么原因，它的创建者从未为其编写过任何真正的文档，除了一个非常简略的 man 页面。幸运的是，很多其他人已经接过了这个挑战，创建了自己的文档和教程，这些资源可以在网络和
    YouTube 上找到。（我将在 `进一步阅读` 部分链接到这些资源。）'
- en: Next, let’s turn our attention to `dialog` and `xdialog`, which we can also
    use to create user interfaces for our scripts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将注意力转向 `dialog` 和 `xdialog`，我们也可以使用它们为我们的脚本创建用户界面。
- en: Creating User Interfaces with dialog and xdialog
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 dialog 和 xdialog 创建用户界面
- en: Another slight problem with `yad` is that you can only use it on machines that
    have a desktop environment installed. But, many Linux, Unix, and Unix-like servers
    are set up with a full text-mode environment and don’t have to use graphical desktops.
    Another slight problem with `yad` is that even on desktop-type operating systems,
    it’s not always available for installation. However, if `yad` isn’t available
    and you still need a GUI solution, you might be able to use `xdialog`, which is
    more universally available. Let’s begin with a look at `dialog`, which can be
    used on text-mode machines.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`yad` 的另一个小问题是，你只能在安装了桌面环境的机器上使用它。但许多 Linux、Unix 和类 Unix 服务器配置为仅使用全文本模式环境，并且不必使用图形桌面。另一个小问题是，即使在桌面操作系统上，它也并不总是可以安装。然而，如果
    `yad` 不可用，而你仍然需要一个 GUI 解决方案，你可能能够使用 `xdialog`，它更具普适性。让我们先看看 `dialog`，它可以在文本模式的机器上使用。'
- en: The dialog Basics
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对话框基础
- en: '`dialog` used to be installed by default on all Linux systems, but it no longer
    is. However, it’s available for installation for pretty much every Linux distro.
    So, you can install it with your distro’s normal package manager. On most Unix
    and Unix-like systems, such as OpenIndiana and FreeBSD, it still comes installed
    by default.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`dialog` 曾经是所有 Linux 系统的默认安装，但现在不再是了。然而，它几乎可以在所有 Linux 发行版中安装。所以，你可以通过你发行版的常规包管理器安装它。在大多数
    Unix 和类 Unix 系统中，如 OpenIndiana 和 FreeBSD，它仍然是默认安装的。'
- en: 'The basic `dialog` building blocks are known as **widgets**. Each widget has
    a set of parameters that you need to specify when you use it. For example, open
    the `dialog` man page and scroll down to the `--msgbox` paragraph, where you’ll
    see this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 `dialog` 构建块被称为 **小部件**。每个小部件都有一组参数，你在使用时需要指定。例如，打开 `dialog` 的 man 页面，滚动到
    `--msgbox` 段落，你将看到如下内容：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, this widget requires you to specify three parameters. (Unlike `yad`, specifying
    the dimensions of a `dialog` box isn’t optional.) Let’s see how that looks in
    the `dialog-hello.sh script`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这个小部件需要你指定三个参数。（与 `yad` 不同，指定 `dialog` 框的尺寸不是可选项。）让我们看看在 `dialog-hello.sh
    脚本` 中是如何实现的：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you’ve seen before in the `yad` section, I used a backslash to break the
    command into two lines, which makes things a bit more readable. On the `--msgbox`
    line, we see the message text, the height as defined by the number of rows in
    the box, and the width as defined by the number of characters that fit on a line.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 `yad` 部分之前看到的，我使用了反斜杠将命令分成两行，这样让内容更易读。在 `--msgbox` 行中，我们可以看到消息文本、由框中的行数定义的高度，以及由一行中可容纳的字符数定义的宽度。
- en: 'Running the script looks like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本的效果如下所示：
- en: '![B21693_16_11](img/B21693_16_11.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_11](img/B21693_16_11.png)'
- en: 'Figure 16.11: Running the dialog-hello.sh script'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11：运行 dialog-hello.sh 脚本
- en: To close the window, just hit the **Enter** key, which activates the **OK**
    button by default. (On a desktop machine, you also have the option of clicking
    on the **OK** button with your mouse.) Once the window is closed, run the `clear`
    command to remove the blue background from your terminal.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭窗口，只需按 **Enter** 键，这会默认激活 **OK** 按钮。（在桌面机器上，你也可以选择用鼠标点击 **OK** 按钮。）一旦窗口关闭，运行
    `clear` 命令即可去除终端中的蓝色背景。
- en: 'By default, `dialog` windows always appear in the center of your terminal,
    and the blue background won’t clear until you clear it yourself. Fortunately,
    you can change both behaviors. Here’s a slightly modified version of our script,
    which places the window at the top left corner of the terminal:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`dialog` 窗口总是出现在终端的中央，蓝色背景不会自动清除，直到你手动清除它。幸运的是，你可以改变这两种行为。下面是我们稍作修改后的脚本，它将窗口放置在终端的左上角：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here’s how that looks:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是这样的：
- en: '![B21693_16_12](img/B21693_16_12.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_12](img/B21693_16_12.png)'
- en: 'Figure 16.12: Placing the dialog box in the upper-left corner'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.12：将对话框放置在左上角
- en: The `--begin` option takes two parameters. The first one denotes the vertical
    position of the box, and the second one denotes the horizontal position. For example,
    by changing the line to `--begin 15 2`, the box would show up in the lower left
    corner. To place it into the upper right corner, you could change it to `--begin
    2 50`. The `clear` command at the end will clear away the blue background when
    you hit the **OK** button.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`--begin`选项接受两个参数。第一个表示框的垂直位置，第二个表示水平位置。例如，通过将该行改为`--begin 15 2`，框将出现在左下角。要将其放置到右上角，可以更改为`--begin
    2 50`。当你按下**OK**按钮时，`clear`命令会清除蓝色背景。'
- en: Of course, this script isn’t very useful, but that’s okay. I’ll show you some
    more useful concepts in just a bit. First though, allow me to say a few words
    about `xdialog`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个脚本本身并不是很有用，但没关系。稍后我会展示一些更有用的概念。首先，请允许我说几句关于`xdialog`的话。
- en: The xdialog Basics
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: xdialog基础
- en: If you need a GUI-type of user interface and `yad` isn’t available for your
    desktop system, `xdialog` could be a good alternative. (I say could be, because
    neither `yad` nor `xdialog` is available for OpenIndiana.) It should be in the
    normal repository of your Linux or Unix-like distro, so just use your normal package
    manager to install it. The reason I can talk about both `dialog` and `xdialog`
    in the same section is because for the most part, code that’s written for `dialog`
    can also run with `xdialog`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个GUI类型的用户界面，而你的桌面系统没有`yad`，那么`xdialog`可能是一个不错的替代方案。（我说“可能”，因为`yad`和`xdialog`都没有在OpenIndiana中提供。）它应该在你的Linux或类似Unix的发行版的标准软件库中，因此只需使用你常用的软件包管理器安装它。我之所以能够在同一节中讨论`dialog`和`xdialog`，是因为大多数为`dialog`编写的代码也可以在`xdialog`上运行。
- en: There’s one thing to look out for that could trip you up. For some strange reason,
    the package name is `xdialog`, in all lower-case letters. But, after it’s installed,
    you’ll need to invoke the program by typing `Xdialog`, with an upper-case X. (After
    I installed it, it took me a while to figure out why I couldn’t get it to work.)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件事需要注意，可能会让你困惑。出于某种奇怪的原因，包的名称是`xdialog`，全小写字母。但安装后，你需要通过输入`Xdialog`来调用该程序，其中`X`是大写字母。（我安装后，花了一段时间才弄明白为什么它不起作用。）
- en: 'For the most part, changing a `dialog` script to run as a GUI-type program
    is a simple matter of changing all instances of `dialog` to `Xdialog`, as you
    see here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，将`dialog`脚本改为以GUI类型的程序运行，只需将所有`dialog`实例替换为`Xdialog`，就像你在这里看到的那样：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Running the script on a desktop system gives you this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面系统上运行该脚本会得到如下效果：
- en: '![B21693_16_13](img/B21693_16_13.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_13](img/B21693_16_13.png)'
- en: 'Figure 16.13: Running the script with xdialog'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.13：使用xdialog运行脚本
- en: 'The first thing to note is that `xdialog` ignores the `--begin` option, and
    just places the box in the center of the terminal. There’s also the fact that
    `xdialog` often requires you to create boxes with larger dimensions so that you
    can see everything. So, let’s change that in the final `xdialog-hello.sh` script,
    like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要注意的是，`xdialog`会忽略`--begin`选项，并将对话框放置在终端的中央。还有一个事实是，`xdialog`通常要求你创建更大的框，以便你能看到所有内容。因此，让我们在最终的`xdialog-hello.sh`脚本中做如下更改：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you see here, this makes things look much better:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，这样看起来好多了：
- en: '![B21693_16_14](img/B21693_16_14.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_14](img/B21693_16_14.png)'
- en: 'Figure 16.14: The improved xdialog script'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.14：改进后的xdialog脚本
- en: With `xdialog`, the clear command at the end of the script is no longer necessary,
    but it doesn’t hurt anything to leave it. In fact, we’ll need it for the next
    demo.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`xdialog`时，脚本末尾的`clear`命令不再必要，但留下它不会造成任何问题。事实上，我们将需要它来进行下一个演示。
- en: Automatically Choosing Either dialog or xdialog
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动选择`dialog`或`xdialog`
- en: 'Now, here’s something that’s really cool. With only a few extra lines of code,
    you can make your script automatically detect whether it’s running on a desktop
    or text-mode machine, and whether `xdialog` is installed. Here’s the `xdialog-hello2.sh`
    script to show how it works:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有一个非常酷的东西。只需再添加几行代码，你就可以让脚本自动检测它是运行在桌面系统还是文本模式机器上，以及`xdialog`是否已安装。以下是`xdialog-hello2.sh`脚本，展示它如何工作：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'There are several ways to detect if a program is installed. In *Chapter 12,
    Automating Scripts with here Documents and expect*, I showed you this method in
    the `system_info.sh` script:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以检测程序是否已安装。在*第12章，通过here文档和expect自动化脚本*中，我在`system_info.sh`脚本中向你展示了这种方法：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `pandoc` executable that we needed is in the `/usr/local/bin/` directory
    on FreeBSD, and in the `/usr/bin/` directory on everything else. So, I set up
    this `if..then` construct to detect if the executable is in either place. That
    works, but I’d now like to show you an easier way.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的`pandoc`可执行文件在FreeBSD的`/usr/local/bin/`目录中，而在其他系统上则位于`/usr/bin/`目录。因此，我设置了这个`if..then`结构来检测可执行文件是否位于这两个位置之一。这样有效，但我现在想展示一个更简单的方法。
- en: 'In the `xdialog-hello2.sh` script, the `command -v Xdialog` command detects
    if the `Xdialog` executable file is present, regardless of which directory it’s
    in. If it is, the command will return exit code 0\. If it’s not, the command will
    return exit code 1\. To see how this works, go ahead and run this on the command
    line. Here’s how it looks if the `Xdialog` executable isn’t detected:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`xdialog-hello2.sh`脚本中，`command -v Xdialog`命令会检测`Xdialog`可执行文件是否存在，而不管它在哪个目录中。如果存在，命令将返回退出码0。如果不存在，命令将返回退出码1。要查看这个是如何工作的，请在命令行上运行这个命令。如果未检测到`Xdialog`可执行文件，效果如下：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And, here’s how it looks if it is detected:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如果检测到它时的效果：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the next line, you see an `if..then` construct that checks for two things.
    First, it checks the exit code from the `command` command, and then it checks
    to see if a graphical desktop environment is installed. If the value of the `DISPLAY`
    environmental variable is of a non-zero length, then a desktop environment is
    installed. You can see how this works by running the `echo $DISPLAY` command yourself.
    Here’s how it looks on a desktop machine:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，你可以看到一个`if..then`结构，它检查两个条件。首先，它检查`command`命令的退出码，然后检查是否安装了图形桌面环境。如果`DISPLAY`环境变量的值是非零长度，那么说明已安装桌面环境。你可以通过运行`echo
    $DISPLAY`命令来查看这个是如何工作的。这是桌面机器上的显示效果：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'On a text-mode machine, you’ll get no output at all, as you see here on this
    Ubuntu Server virtual machine:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本模式机器上，你将完全没有输出，就像在这个Ubuntu Server虚拟机上看到的那样：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For our purposes, we can say that the value of `DISPLAY` is zero characters
    long on this text-mode machine.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们可以说，在这个文本模式机器上，`DISPLAY`的值是零个字符长。
- en: 'Now, let’s take another look at our `if..then` statement:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再看看我们的`if..then`语句：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This means that if the exit code from the `command -v Xdialog` line is 0, and
    the value of the `DISPLAY` environmental variable is of a non-zero length, then
    the value of the `diag` variable becomes `Xdialog`. If either the `Xdialog` executable
    is missing or the value of `DISPLAY` is *not* a non-zero length, then the value
    of `diag` becomes `dialog`. What makes this even more cool is that this works
    the same on all Linux, Unix, or Unix-like systems. I’ve tested this script on
    FreeBSD, GhostBSD, DragonflyBSD, OpenIndiana, and on both desktop and text-mode
    implementations of Linux. On all of them, the script correctly detects everything
    that it’s supposed to detect, and correctly chooses whether to run either `dialog`
    or `Xdialog`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果`command -v Xdialog`命令的退出码为0，并且`DISPLAY`环境变量的值非零长度，那么`diag`变量的值将变为`Xdialog`。如果`Xdialog`可执行文件缺失或`DISPLAY`的值*不是*非零长度，则`diag`的值将变为`dialog`。更酷的是，这在所有Linux、Unix或类Unix系统上都能正常工作。我已经在FreeBSD、GhostBSD、DragonflyBSD、OpenIndiana以及Linux的桌面和文本模式实现上测试过这个脚本。在所有这些系统上，脚本都能正确检测到它应该检测的内容，并正确选择是运行`dialog`还是`Xdialog`。
- en: Here’s something that caused me a bit of consternation. I accidentally found
    out that the order in which you test for things sometimes matters. In the `if..then`
    construct of this script, I originally checked for the value of `DISPLAY` first,
    and then checked for the exit code of the `command` command. The script wouldn’t
    run correctly like that, because the test for the `DISPLAY` value was setting
    the exit code to 0\. When I reversed the order of the tests, everything began
    to work correctly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一件事让我有点困惑。我无意中发现，你检查某些内容的顺序有时很重要。在这个脚本的`if..then`结构中，我最初先检查了`DISPLAY`的值，然后检查了`command`命令的退出码。这样脚本无法正确运行，因为对`DISPLAY`值的检查会将退出码设置为0。当我将检查顺序反过来时，一切开始正常工作。
- en: Go ahead and try running this script on a variety of systems, just to see what
    happens.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试在各种系统上运行这个脚本，看看会发生什么。
- en: Next, let’s build on what we’ve already done by adding another widget.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在已有的基础上添加另一个小部件。
- en: Adding Widgets
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加小部件
- en: 'You can add more functionality by adding more widgets. Take for example the
    `dialog-hello2.sh` script, which you can download from the Github repository.
    I can’t show the entire file at once due to formatting constraints, so I’ll show
    it to you a section at a time. Here’s the top section:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加更多的小部件来增加更多功能。例如，`dialog-hello2.sh` 脚本，你可以从 GitHub 仓库中下载。由于格式限制，我不能一次性展示整个文件，所以我会分段展示给你。这里是顶部部分：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We’ve already seen this in the previous script, and I’ve already explained
    it. So, let’s move on. Here’s the next section:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的脚本中已经看到过这个内容，我也已经做过解释。所以，接下来我们继续。这里是下一部分：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first `$diag` line creates the initial message box in the top left corner,
    as specified by the `--begin 2 2` option. The second `$diag` line creates a box
    with two buttons that are labeled as **Yes** and **No**. The `--begin 4 4` option
    positions the `yesno` box just slightly lower and slightly more to the right of
    where the initial message box was. After `--yesno`, we see the text that we want
    the box to display and the height and width parameters. (Setting the height and
    width to 0 and 0 causes the box to size itself automatically.)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行 `$diag` 创建了一个初始消息框，位于左上角，位置由 `--begin 2 2` 选项指定。第二行 `$diag` 创建了一个带有两个按钮的框，按钮标记为
    **是** 和 **否**。`--begin 4 4` 选项将 `yesno` 框略微放置在初始消息框的下方和右侧。`--yesno` 后面是我们希望框显示的文本和高度、宽度参数。（将高度和宽度设置为
    0 和 0 会使框自动调整大小。）
- en: 'Next, we have a `case..esac` construct that assigns commands to the two buttons.
    Remember that when clicked, the **Yes** button returns exit code 0, and the **No**
    button returns exit code 1\. Pressing the **Esc** key returns exit code 255\.
    We can use these exit codes to trigger a desired command, as you see here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个 `case..esac` 结构，将命令分配给两个按钮。记住，当点击时，**是**按钮返回退出代码 0，**否**按钮返回退出代码 1。按下
    **Esc** 键时，返回退出代码 255。我们可以利用这些退出代码来触发所需的命令，如你在这里看到的：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Okay, all this script does is display a message when you press a button. But,
    it does serve to demonstrate the concept, so it’s all good.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这个脚本的作用就是当你按下按钮时显示一个消息。但它确实展示了这个概念，所以一切都很好。
- en: 'You’ve already seen the initial message box, so I won’t show that again. Instead,
    I’ll show the `yesno` box that comes up next:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看过初始消息框，所以我不会再展示它了。相反，我会展示接下来的 `yesno` 框：
- en: '![B21693_16_15](img/B21693_16_15.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_15](img/B21693_16_15.png)'
- en: 'Figure 16.15: The yesno box'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.15：yesno 框
- en: 'When I click the **Yes** button, I’ll see the appropriate message, as you see
    here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我点击 **是** 按钮时，我会看到相应的消息，如你在这里看到的：
- en: '![B21693_16_16](img/B21693_16_16.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_16](img/B21693_16_16.png)'
- en: 'Figure 16.16: After clicking on the Yes button'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.16：点击 **是** 按钮后
- en: And of course, this script runs equally well with `xdialog` on a machine that
    supports it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个脚本在支持 `xdialog` 的机器上也能同样运行。
- en: Next, let’s create something that will actually do some useful work for us.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一些真正能为我们做有用工作的东西。
- en: Creating an SSH Login Interface
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 SSH 登录界面
- en: 'Let’s say that you have a fleet of Linux, Unix, or Unix-like servers that you
    need to administer remotely via SSH. Trying to keep track of the server IP addresses
    is a confusing mess, so you’ve decided to simplify things. You’ve decided to create
    the `xdialog-menu-test.sh` to help you out. It’s also too long to show here in
    its entirety, so I’ll break it up into sections. Here’s the top part:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一组 Linux、Unix 或类 Unix 服务器，需要通过 SSH 远程管理。试图跟踪服务器的 IP 地址是件非常混乱的事情，因此你决定简化操作。你决定创建
    `xdialog-menu-test.sh` 来帮助你。这个脚本也太长，不能在这里一次性展示，所以我会将它分段展示。这里是顶部部分：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is the same as it was in the previous script, so you already know about
    it. Here’s the next section:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的脚本相同，所以你已经了解了它。接下来是下一部分：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `cmd=` line creates a command within a pair of parentheses, and then assigns
    that command to the `cmd` variable array. This command, which will be invoked
    in the final line of the script, will build either a `dialog` or `xdialog` menu
    window. According to the `dialog` man page, the `--keep-tite` option is desirable
    when running the script in a graphical terminal emulator on a desktop machine,
    because it prevents the script from switching back and forth between the graphical
    terminal and the underlying shell terminal. After the `--menu` option, we see
    the text that is to be displayed, the height and width of the menu box, followed
    by the maximum number of menu entries that will be displayed at a time. (In this
    example, the user would need to scroll down to see past the first 16 menu entries.)
    The menu entries would be designated with a tag and an item string. For example,
    the first menu entry we see has a **1** as the tag, and **Remote SSH to Debian
    miner** as the item.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmd=` 行在一对括号内创建一个命令，然后将该命令分配给 `cmd` 变量数组。这个命令将在脚本的最后一行被调用，构建一个 `dialog` 或
    `xdialog` 菜单窗口。根据 `dialog` 手册页，当在桌面机器的图形终端模拟器中运行脚本时，`--keep-tite` 选项是推荐使用的，因为它可以防止脚本在图形终端和底层
    shell 终端之间来回切换。在 `--menu` 选项之后，我们会看到要显示的文本、菜单框的高度和宽度，然后是一次显示的最大菜单项数。（在这个例子中，用户需要向下滚动才能看到前16个菜单项之外的内容。）菜单项将通过标签和项字符串来指定。例如，我们看到的第一个菜单项标签为
    **1**，项为 **Remote SSH to Debian miner**。'
- en: Next, we have the `options` stanza, which inserts all of the menu entries into
    an array. The `choices=` line uses the `2>&1>` redirection operator to dump the
    contents of the array onto the terminal screen (`/dev/tty`). The `@` in `${options[@]}`
    is a form of variable expansion, because it allows an action to be carried out
    according to which menu item that a user chooses. The `@` represents the index
    number of the array item that corresponds with a menu choice.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `options` 语句，它将所有菜单项插入到一个数组中。`choices=` 行使用 `2>&1>` 重定向操作符将数组的内容输出到终端屏幕
    (`/dev/tty`) 上。`${options[@]}` 中的 `@` 是一种变量扩展方式，因为它允许根据用户选择的菜单项执行相应的操作。`@` 代表数组项的索引号，该索引对应用户所选的菜单项。
- en: In *Chapter 8, Basic Shell Script Construction*, I showed you how to use either
    the `*` or the `@` in place of a specific index number to show all elements in
    an array. In the `cmd=` line, each component of the `$diag --keep-tite --menu
    "Select options:" 22 76 16` command that’s within the parentheses is a separate
    element of the `cmd` array. For this reason, we need to use either the `*` or
    the `@` as the index for the `cmd` array in the `choices=` line at the bottom,
    so that the entire command will get invoked. The same thing is true for the list
    of options that get assigned to the `options` array in the `options=` line, as
    you’ll see in a moment.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第8章，基本 Shell 脚本构建* 中，我向你展示了如何用 `*` 或 `@` 替代特定的索引号，以显示数组中的所有元素。在 `cmd=` 行中，`$diag
    --keep-tite --menu "Select options:" 22 76 16` 命令中的每个组件都是 `cmd` 数组的一个独立元素。因此，我们需要在
    `choices=` 行的底部使用 `*` 或 `@` 作为 `cmd` 数组的索引，以便整个命令被调用。对于分配给 `options` 数组的选项列表也同样如此，稍后你将看到。
- en: 'Now that we have a menu, we need to make it do something. That comes in the
    next section, which you see here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个菜单，接下来需要让它执行一些操作。这将在下一个部分中完成，如下所示：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is nothing that you haven’t seen before. It’s just a normal `for` loop
    that operates a `case..esac` construct. What is a bit different is that the value
    of the `choices` variable is the index number of the array item that corresponds
    with the chosen menu item. Each of the listed options in the options array consists
    of a number, followed by a complete phrase, such as `1 "Remote SSH to Debian miner"`.
    In this example, the number 1 represents element number 0 of the options array,
    and the following words in the phrase represent elements 1 through 5\. In order
    for the options to properly display in the menu, you’ll have to invoke the array
    with either `*` or `@` in place of the index number. Here’s the complete line
    where that happens:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是你没见过的东西。这只是一个正常的 `for` 循环，执行一个 `case..esac` 结构。有一点不同的是，`choices` 变量的值是与所选菜单项对应的数组项的索引号。`options`
    数组中列出的每个选项都由一个数字和一个完整的短语组成，如 `1 "Remote SSH to Debian miner"`。在这个例子中，数字 1 代表 `options`
    数组的第0个元素，短语中的其余部分代表第1至第5个元素。为了使选项正确显示在菜单中，你需要用 `*` 或 `@` 替代索引号来调用数组。下面是这一操作发生的完整行：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Since only one index value is ever assigned to `choices`, the `for` loop exits
    after its first run.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有一个索引值被赋给 `choices`，所以 `for` 循环在第一次运行后就退出了。
- en: 'Now that everything is built, let’s see if it works. Here’s how it looks using
    `xdialog` on GhostBSD with the Mate desktop:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都构建好了，让我们来看看它是否能正常工作。以下是使用 `xdialog` 在 GhostBSD 上，Mate 桌面环境下的效果：
- en: '![B21693_16_17](img/B21693_16_17.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_17](img/B21693_16_17.png)'
- en: 'Figure 16.17: The xdialog-menu-test.sh script on GhostBSD'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.17：在 GhostBSD 上使用 xdialog 的 xdialog-menu-test.sh 脚本
- en: 'And, here’s the exact same script on Fedora with `dialog`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是同样的脚本，在 Fedora 上使用 `dialog` 的效果：
- en: '![B21693_16_18](img/B21693_16_18.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_16_18](img/B21693_16_18.png)'
- en: 'Figure 16.18: The xdialog-menu-test.sh script on Fedora with dialog'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.18：在 Fedora 上使用 dialog 的 xdialog-menu-test.sh 脚本
- en: When you choose a menu item, the script will open a remote login prompt in the
    terminal, and then exit. That’s okay, because if you want to connect to multiple
    remote servers at once, you’ll need to open other terminals anyway.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择一个菜单项时，脚本会在终端中打开一个远程登录提示，然后退出。这没问题，因为如果你希望同时连接多个远程服务器，你无论如何都需要打开其他终端。
- en: Of course, you can fancy this script up to make it even more functional. For
    example, you can configure your SSH client to use different profiles or different
    encryption keys for different server sessions, and modify the commands in the
    menu accordingly. Or, you can use this as a template for something else altogether.
    As I keep saying, let your imagination run wild!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以将这个脚本装饰得更漂亮，使它更加实用。例如，你可以配置 SSH 客户端，使用不同的配置文件或加密密钥来连接不同的服务器会话，并相应地修改菜单中的命令。或者，你可以将其作为其他用途的模板。正如我一直说的，让你的想象力飞翔吧！
- en: All right, I think that this about does it for `yad`, `dialog`, and `xdialog`.
    Let’s wrap up and move on.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我觉得关于 `yad`、`dialog` 和 `xdialog` 的部分差不多了。让我们总结一下，继续前进吧。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As always, we’ve covered a lot of ground in this chapter, and saw some cool
    stuff. We began with a discussion of `yad`, and how to use it to create graphical
    user interfaces for shell scripts. We then looked at how to use `dialog` to create
    user interfaces for text-mode environments, and `xdialog` for graphical environments.
    As an added bonus, you saw how to create scripts that will run with `xdialog`
    on machines that support it, and `dialog` on machines that don’t.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如往常一样，我们在这一章中涵盖了很多内容，看到了一些很酷的东西。我们从讨论 `yad` 开始，了解了如何使用它为 shell 脚本创建图形用户界面。然后，我们看了如何使用
    `dialog` 为文本模式环境创建用户界面，如何使用 `xdialog` 为图形环境创建用户界面。作为额外的奖励，你还看到了如何创建脚本，使其在支持 `xdialog`
    的机器上运行，在不支持的机器上运行 `dialog`。
- en: These actually aren’t the only three utilities that you can use to create user
    interfaces for your scripts. Other choices include `whiptail`, `cdialog`, and
    `zenity`. The good news is that once you’ve learned one, switching to another
    is fairly easy.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这些其实并不是你可以用来为脚本创建用户界面的唯一三种工具。其他选择还包括 `whiptail`、`cdialog` 和 `zenity`。好消息是，一旦你学会了其中一种，切换到另一种是相对容易的。
- en: Now, you can do more with these utilities than I’ve been able to show you here.
    On the other hand, none of these utilities is suitable for creating anything that’s
    really complex. For that, you’ll need to learn a more complex programming language.
    Regardless, if all you need is a simple interface to make things easier for either
    yourself or for your users, these utilities can fill the bill.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以用这些工具做比我在这里展示的更多的事情。另一方面，这些工具都不适合创建非常复杂的东西。要做到这一点，你需要学习一种更复杂的编程语言。无论如何，如果你所需的仅仅是一个简单的界面，以便让你自己或你的用户操作更轻松，这些工具完全能够胜任。
- en: In the next chapter, we’ll look at how to run shell scripts with option switches.
    I’ll see you there.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用选项开关运行 shell 脚本。我在那儿等你。
- en: Questions
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a graphical user interface for a shell script that will run
    on a wide variety of Linux, Unix, and Unix-like operating systems. Which of the
    follow utilities would you use for best availability?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想为一个将在各种 Linux、Unix 和类 Unix 操作系统上运行的 shell 脚本创建图形用户界面。以下哪个工具可以提供最佳的可用性？
- en: '`zenity`'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zenity`'
- en: '`cdialog`'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cdialog`'
- en: '`xdialog`'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`xdialog`'
- en: '`yad`'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`yad`'
- en: Which of the following statements is true about this code snippet?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下关于这个代码片段的哪个说法是正确的？
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It’s good code, and will work just fine.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是很好的代码，能够正常工作。
- en: It won’t work, because it uses the wrong method to detect if the `Xdialog` executable
    is present.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它无法工作，因为它使用了错误的方法来检测 `Xdialog` 可执行文件是否存在。
- en: It won’t work, because it’s not possible to detect if a certain executable is
    present.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它无法工作，因为无法检测某个可执行文件是否存在。
- en: It won’t work, because having the `[[ -n $DISPLAY ]]` test come first ensures
    that `$?` always returns a value of 0.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它无法正常工作，因为首先进行`[[ -n $DISPLAY ]]`测试确保`$?`总是返回0的值。
- en: Further Reading
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Dress Up Bash Scripts with YAD: [https://www.linux-magazine.com/Online/Blogs/Productivity-Sauce/Dress-Up-Bash-Scripts-with-YAD](https://www.linux-magazine.com/Online/Blogs/Productivity-Sauce/Dress-Up-Bash-Scripts-with-YAD)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用YAD装饰Bash脚本：[https://www.linux-magazine.com/Online/Blogs/Productivity-Sauce/Dress-Up-Bash-Scripts-with-YAD](https://www.linux-magazine.com/Online/Blogs/Productivity-Sauce/Dress-Up-Bash-Scripts-with-YAD)
- en: 'YAD Guide: [https://yad-guide.ingk.se/](https://yad-guide.ingk.se/)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAD指南：[https://yad-guide.ingk.se/](https://yad-guide.ingk.se/)
- en: 'How to use ncurses widgets in shell scripts on Linux: [https://linuxconfig.org/how-to-use-ncurses-widgets-in-shell-scripts-on-linux](https://linuxconfig.org/how-to-use-ncurses-widgets-in-shell-scripts-on-linux)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Linux上的Shell脚本中使用ncurses小部件：[https://linuxconfig.org/how-to-use-ncurses-widgets-in-shell-scripts-on-linux](https://linuxconfig.org/how-to-use-ncurses-widgets-in-shell-scripts-on-linux)
- en: 'Designing Simple front ends with dialog/Xdialog: [https://linuxgazette.net/101/sunil.html](https://linuxgazette.net/101/sunil.html)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用dialog/Xdialog设计简单的前端：[https://linuxgazette.net/101/sunil.html](https://linuxgazette.net/101/sunil.html)
- en: 'Adding dialog boxes to shell scripts: [https://www.linux-magazine.com/Issues/2019/228/Let-s-Dialog](https://www.linux-magazine.com/Issues/2019/228/Let-s-Dialog)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Shell脚本中添加对话框：[https://www.linux-magazine.com/Issues/2019/228/Let-s-Dialog](https://www.linux-magazine.com/Issues/2019/228/Let-s-Dialog)
- en: 'Menu Driven Shell Script - Using Dialog Utility: [http://web.archive.org/web/20120318060251/http://www.bashguru.com/2011/01/menu-driven-shell-script-using-dialog.html](http://web.archive.org/web/20120318060251/http://www.bashguru.com/2011/01/menu-driven-shell-script-using-dialog.html)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单驱动的Shell脚本 - 使用对话框工具：[http://web.archive.org/web/20120318060251/http://www.bashguru.com/2011/01/menu-driven-shell-script-using-dialog.html](http://web.archive.org/web/20120318060251/http://www.bashguru.com/2011/01/menu-driven-shell-script-using-dialog.html)
- en: 'Xdialog Documentation: [http://web.mit.edu/outland/share/doc/Xdialog-2.1.2/](http://web.mit.edu/outland/share/doc/Xdialog-2.1.2/)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xdialog文档：[http://web.mit.edu/outland/share/doc/Xdialog-2.1.2/](http://web.mit.edu/outland/share/doc/Xdialog-2.1.2/)
- en: Answers
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: c
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: d
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: Join our community on Discord!
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Linux专家以及作者一起阅读本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 提出问题，提供解决方案，和作者通过“问我任何问题”环节交流，还有更多内容。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
