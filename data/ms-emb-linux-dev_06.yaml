- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Building a Root Filesystem
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建根文件系统
- en: The root filesystem is the fourth element of embedded Linux. Once you have read
    this chapter, you will be able to build, boot, and run a simple embedded Linux
    system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统是嵌入式 Linux 的第四个要素。阅读完本章后，你将能够构建、启动并运行一个简单的嵌入式 Linux 系统。
- en: The techniques described here are broadly known as **roll your own**, or **RYO**.
    Back in the early days of embedded Linux, this was the only way to create a root
    filesystem. There are still some use cases where an RYO root filesystem is applicable
    – for example, when the amount of RAM or storage is very limited, for quick demonstrations,
    or for any case in which your requirements are not easily covered by the standard
    build system tools. However, these cases are quite rare.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的技术通常被称为 **自己动手做**，或 **RYO**。在嵌入式 Linux 的早期，这是一种创建根文件系统的唯一方式。至今，仍然有一些使用场景适用
    RYO 根文件系统——例如，当内存或存储非常有限时，用于快速演示，或在某些需求无法轻松通过标准构建系统工具覆盖的情况下。然而，这些场景相当罕见。
- en: The purpose of this chapter is educational. It is not meant to be a recipe for
    building everyday embedded systems. Use the tools described in the next chapter
    for this.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的在于教育性展示，并非构建日常嵌入式系统的配方。对于此类构建，请使用下一章中描述的工具。
- en: Our first objective is to create a minimal root filesystem that will give us
    a shell prompt. Then, using this as a base, we will add scripts to start up other
    programs and configure a network interface and user permissions. There are examples
    for both the BeaglePlay and QEMU targets. Knowing how to build the root filesystem
    from scratch is a useful skill. It will help you to understand what is going on
    when we look at more complex examples in later chapters.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个目标是创建一个最小的根文件系统，使其能提供一个 shell 提示符。然后，基于此，我们将添加脚本来启动其他程序并配置网络接口和用户权限。对于
    BeaglePlay 和 QEMU 目标都有示例。知道如何从头开始构建根文件系统是一个有用的技能。它将帮助你理解在后续章节中我们查看更复杂示例时发生了什么。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What should be in the root filesystem?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件系统中应该包含什么？
- en: Transferring the root filesystem to the target
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将根文件系统传输到目标设备
- en: Creating a boot `initramfs`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建引导 `initramfs`
- en: '`init` program'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init` 程序'
- en: Configuring user accounts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置用户账户
- en: A better way of managing device nodes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的设备节点管理方式
- en: Configuring the network
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置网络
- en: Creating filesystem images with device tables
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用设备表创建文件系统镜像
- en: Mounting the root filesystem using NFS
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NFS 挂载根文件系统
- en: Using TFTP to load the kernel
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TFTP 加载内核
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随示例，确保你拥有以下内容：
- en: An Ubuntu 24.04 or later LTS host system
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Ubuntu 24.04 或更高版本的 LTS 主机系统
- en: A microSD card reader and card
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台 microSD 卡读卡器和卡
- en: A microSD card prepared for the BeaglePlay from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 BeaglePlay 准备的 microSD 卡，来自[*第 4 章*](Chapter_04.xhtml#_idTextAnchor096)
- en: An `Image` file for QEMU from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[*第 4 章*](Chapter_04.xhtml#_idTextAnchor096)的 QEMU `Image` 文件
- en: A USB to TTL serial cable with a 3.3V logic level
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条带有 3.3V 逻辑电平的 USB 到 TTL 串行电缆
- en: A BeaglePlay
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台 BeaglePlay
- en: A 5V USB-C power supply capable of delivering 3A
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款能够提供 3A 电流的 5V USB-C 电源
- en: 'The code used in this chapter can be found in the `Chapter05` folder in the
    book’s GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter05](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter05).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在书籍 GitHub 仓库的 `Chapter05` 文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter05](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter05)。
- en: What should be in the root filesystem?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根文件系统中应该包含什么？
- en: The kernel gets a root filesystem either as an `initramfs` passed as a pointer
    from the bootloader, or by mounting the block device given on the kernel command
    line with the `root=` parameter. Once it has a root filesystem, the kernel executes
    the first program – by default, named `init`, as described in the *Early user
    space* section from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096). Then, as
    far as the kernel is concerned, its job is complete. It is up to the `init` program
    to start other programs and bring the system to life.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 内核通过引导加载程序传递的指针获得一个根文件系统，通常是一个`initramfs`，或者通过挂载内核命令行中给出的块设备（使用`root=`参数）。一旦它有了根文件系统，内核就会执行第一个程序——默认名为`init`，正如在[《第4章》](Chapter_04.xhtml#_idTextAnchor096)中*早期用户空间*部分所描述的那样。然后，就内核而言，它的工作已经完成。由`init`程序来启动其他程序并让系统运行起来。
- en: 'To make a minimal root filesystem, you need these components:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个最小化的根文件系统，你需要以下组件：
- en: '**init**: This is the program that starts everything off, usually by running
    a series of scripts. I will describe how `init` works in much more detail in [*Chapter
    13*](Chapter_13.xhtml#_idTextAnchor431).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**init**：这是启动一切的程序，通常通过运行一系列脚本来实现。我将在[《第13章》](Chapter_13.xhtml#_idTextAnchor431)中更详细地描述`init`的工作原理。'
- en: '**shell**: Gives you a command prompt and (more importantly) runs the shell
    scripts called by `init` and other programs.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**shell**：为你提供命令提示符，并（更重要的是）运行`init`和其他程序调用的Shell脚本。'
- en: '**daemons**: These are background programs that provide services to others.
    Good examples are the system log daemon (`syslogd`) and the secure shell daemon
    (`sshd`). The `init` program must start the initial population of daemons to support
    the main system applications. In fact, `init` is itself a daemon. It is the daemon
    that provides the service of launching other daemons.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**守护进程**：这些是后台程序，为其他程序提供服务。典型的例子包括系统日志守护进程（`syslogd`）和安全外壳守护进程（`sshd`）。`init`程序必须启动守护进程的初始集合，以支持主系统应用程序。实际上，`init`本身就是一个守护进程。它是提供启动其他守护进程服务的守护进程。'
- en: '**shared libraries**: Most programs are linked with shared libraries, so they
    must be present in the root filesystem.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享库**：大多数程序都与共享库链接，因此它们必须存在于根文件系统中。'
- en: '**configuration files**: These are a series of text files, usually stored in
    the `/etc` directory, that configure `init` and other daemons.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**：这些是一些文本文件，通常存储在`/etc`目录中，用于配置`init`和其他守护进程。'
- en: '**device nodes**: These are the special files that give access to various device
    drivers.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备节点**：这些是特殊文件，用于访问各种设备驱动程序。'
- en: '**proc and sys**: These are two pseudo filesystems that represent kernel data
    structures as a hierarchy of directories and files. Many programs and library
    functions depend on `/proc` and `/sys`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**proc 和 sys**：这两个伪文件系统将内核数据结构表示为一系列目录和文件。许多程序和库函数依赖于`/proc`和`/sys`。'
- en: '**kernel modules**: Need to be installed in the root filesystem, usually in
    `/lib/modules/<kernel version>`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核模块**：需要安装在根文件系统中，通常位于`/lib/modules/<kernel version>`目录下。'
- en: Additionally, there are the device-specific applications that make the device
    do the job it is intended for and the runtime data files that they generate.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些设备特定的应用程序，使设备能够完成其预定的工作，以及它们生成的运行时数据文件。
- en: '**IMPORTANT NOTE**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'In some cases, you could condense most of the above programs into a single
    statically linked program and start that program instead of `init`. For example,
    if your program was named `/myprog`, you would add the following command to the
    kernel command line: `init=/myprog`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可以将上述大多数程序合并为一个静态链接的程序，并启动该程序而不是`init`。例如，如果你的程序名为`/myprog`，你可以将以下命令添加到内核命令行：`init=/myprog`。
- en: I have come across such a configuration only once in a secure system in which
    the fork system call had been disabled, thus making it impossible for any other
    program to be started. The downside of this approach is that you can’t make use
    of the many tools that normally go into an embedded system. You have to do everything
    yourself.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一个安全系统中只遇到过一次这样的配置，其中禁用了`fork`系统调用，从而使得无法启动任何其他程序。这种方法的缺点是你无法使用通常嵌入式系统中的许多工具。你必须自己做所有事情。
- en: Directory layout
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录布局
- en: The Linux kernel does not care about the layout of files and directories beyond
    the existence of the program named by `init=` or `rdinit=`, so you are free to
    put things wherever you like. For example, compare the file layout of a device
    running Android to that of a desktop Linux distribution. They are almost completely
    different.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核并不关心文件和目录的布局，除非是存在名为`init=`或`rdinit=`的程序，因此你可以随意安排文件的存放位置。例如，比较运行 Android
    的设备与桌面 Linux 发行版的文件布局，它们几乎完全不同。
- en: 'However, many programs expect certain files to be in certain places, and it
    helps us developers if devices use a similar layout. The basic layout of most
    Linux systems is defined in the **Filesystem Hierarchy Standard** (**FHS**), which
    is available at [https://refspecs.linuxfoundation.org/fhs.shtml](https://refspecs.linuxfoundation.org/fhs.shtml).
    The FHS covers all implementations of Linux operating systems, from the largest
    to the smallest. Embedded devices tend to use a subset based on their needs, but
    each usually includes the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多程序期望某些文件位于特定的位置，若设备使用类似的布局对开发人员有帮助。大多数 Linux 系统的基本布局在**文件系统层次标准**（**FHS**）中有所定义，详情请见[https://refspecs.linuxfoundation.org/fhs.shtml](https://refspecs.linuxfoundation.org/fhs.shtml)。FHS涵盖了所有
    Linux 操作系统的实现，从最大到最小。嵌入式设备通常根据其需求使用一个子集，但每个设备通常都包括以下内容：
- en: '`/bin`: Programs essential for all users'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin`：所有用户都需要的程序'
- en: '`/dev`: Device nodes and other special files'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev`：设备节点和其他特殊文件'
- en: '`/etc`: System configuration files'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc`：系统配置文件'
- en: '`/lib`: Essential shared libraries, including those that make up the C library'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/lib`：基本的共享库，包括构成 C 库的库文件'
- en: '`/proc`: Information about processes represented as virtual files'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc`：以虚拟文件形式呈现的进程信息'
- en: '`/sbin`: Programs essential to the system administrator'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sbin`：系统管理员必需的程序'
- en: '`/sys`: Information about devices and their drivers, represented as virtual
    files'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys`：以虚拟文件形式呈现的设备及其驱动信息'
- en: '`/tmp`: A place to put temporary or volatile files'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tmp`：用于存放临时或易失性文件的地方'
- en: '`/usr`: Additional programs, libraries, and system administrator utilities
    stored in the directories `/usr/bin`, `/usr/lib`, and `/usr/sbin`, respectively'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr`：附加程序、库文件和系统管理员工具，分别存放在`/usr/bin`、`/usr/lib`和`/usr/sbin`目录中'
- en: '**IMPORTANT NOTE**'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The `/usr` directory contains all system-wide, read-only files that are installed
    or provided by the operating system. In the distant past, `/bin` , `/sbin`, and
    `/lib` only contained executables and libraries required for booting, while `/usr/bin`,
    `/usr/sbin`, and `/usr/lib` contained all the other executables and binaries.
    That distinction has since blurred, culminating in a modern movement that merges
    `/bin`, `/sbin`, and `/lib` into `/usr/bin`, `/usr/sbin`, and `/usr/lib`. Nowadays,
    the files in `/bin`, `/sbin`, and `/lib` are just symbolic links to their `/usr`
    counterparts. The `/usr/sbin` directory, like the `/sbin` directory, is for commands
    that can only be executed by the `root` user.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`/usr`目录包含所有系统范围内的只读文件，这些文件是由操作系统安装或提供的。过去，`/bin`、`/sbin`和`/lib`仅包含启动所需的可执行文件和库文件，而`/usr/bin`、`/usr/sbin`和`/usr/lib`包含所有其他可执行文件和二进制文件。这一区别后来模糊了，最终出现了将`/bin`、`/sbin`和`/lib`合并到`/usr/bin`、`/usr/sbin`和`/usr/lib`的现代趋势。如今，`/bin`、`/sbin`和`/lib`中的文件仅仅是指向它们在`/usr`中的对应文件的符号链接。`/usr/sbin`目录像`/sbin`目录一样，存放只能由`root`用户执行的命令。'
- en: '`/var`: a hierarchy of files and directories that can be modified at runtime,
    like log messages, some of which must be retained after boot'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var`：在运行时可以修改的文件和目录层次结构，例如日志信息，其中一些必须在启动后保留'
- en: There are some subtle distinctions here. The difference between `/bin` and `/sbin`
    is simply that the latter need not be included in the search path for non-root
    users. Users of Red Hat-derived distributions will be familiar with this.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些微妙的区别。`/bin`和`/sbin`的区别仅仅在于后者不需要包含在非 root 用户的搜索路径中。Red Hat 衍生的发行版用户对此应该比较熟悉。
- en: Staging directory
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时目录
- en: 'You should begin by creating a **staging** directory on your host computer
    where you can assemble the files that will eventually be transferred to the target.
    In the following examples, I have used `~/rootfs`. You need to create a skeleton
    directory structure in it. Look at the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该首先在主机计算机上创建一个**临时**目录，用于汇总最终会被传输到目标设备的文件。在以下示例中，我使用了`~/rootfs`。你需要在其中创建一个骨架目录结构。请看下面：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To see the directory hierarchy more clearly, you can use the handy `tree` command
    with the `-d` option to show only the directories:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要更清晰地查看目录层次结构，可以使用便捷的`tree`命令，带上`-d`选项仅显示目录：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Not all directories have the same file permissions, and the individual files
    inside a directory can have stricter permissions than the directory itself.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有目录具有相同的文件权限，目录中的个别文件可以比目录本身有更严格的权限。
- en: POSIX file access permissions
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POSIX文件访问权限
- en: Every process or running program belongs to a user and one or more groups. The
    user is represented by a 32-bit number called the **user ID** or **UID**. Information
    about users, including the mapping from a UID to a name, is kept in `/etc/passwd`.
    Likewise, groups are represented by a **group ID** or **GID**, with information
    kept in `/etc/group`. There is always a `root` user with a UID of 0 and a `root`
    group with a GID of 0\. The `root` user is also called the **superuser** because,
    in a default configuration, it bypasses most permission checks and can access
    all the resources in the system. Security in Linux-based systems is mainly about
    restricting access to the root account.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程或运行程序都属于一个用户和一个或多个组。用户由一个称为**用户ID**或**UID**的32位数字表示。关于用户的信息，包括从UID到名称的映射，保存在`/etc/passwd`中。同样，组由一个称为**组ID**或**GID**的数字表示，信息保存在`/etc/group`中。始终存在一个`root`用户，其UID为0，并且一个`root`组，其GID为0。`root`用户也称为**超级用户**，因为在默认配置下，它可以绕过大部分权限检查并访问系统中的所有资源。Linux系统中的安全性主要是关于限制对root账户的访问。
- en: 'Each file and directory also has an owner and belongs to exactly one group.
    The level of access a process has to a file or directory is controlled by a set
    of access permission flags called the **mode** of the file. There are three collections
    of three bits: the first collection applies to the *owner* of the file, the second
    to the *members* of the same group as the file, and the last to *everyone else*
    – the rest of the world. The bits are for **read** (`r`), **write** (`w`), and
    **execute** (`x`) permissions on the file. Three bits result in 2³ = 8 possible
    values, represented as octal digits from 0 to 7:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件和目录还有一个所有者，并且属于恰好一个组。进程对文件或目录的访问级别由一组称为文件的**模式**的访问权限标志控制。有三组三位数：第一组适用于文件的*所有者*，第二组适用于与文件相同组的*成员*，最后一组适用于*其他所有人*
    - 世界上的其余人。这些位用于文件的**读**（`r`）、**写**（`w`）和**执行**（`x`）权限。三位数的组合产生2³ = 8个可能的值，表示为从0到7的八进制数字：
- en: '0: No permissions'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: 没有权限'
- en: '1: Execute only (--x)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1: 仅执行 (--x)'
- en: '2: Write only (-w-)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '2: 只写 (-w-)'
- en: '3: Write and execute (-wx)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '3: 写和执行 (-wx)'
- en: '4: Read only (r--)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '4: 只读 (r--)'
- en: '5: Read and execute (r-x)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '5: 读和执行 (r-x)'
- en: '6: Read and write (rw-)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '6: 读和写 (rw-)'
- en: '7: Read, write, and execute (rwx)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '7: 读、写和执行 (rwx)'
- en: Since three bits fit neatly into an octal digit, file access permissions are
    usually represented in octal.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于三位数可以完美地放入八进制数字中，文件访问权限通常用八进制表示。
- en: 'Here are some common file modes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些常见的文件模式：
- en: '600: Owner - rw-, Group - ---, and Others - ---'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '600: 所有者 - rw-, 组 - ---, 和其他人 - ---'
- en: '644: Owner - rw-, Group - r--, and Others - r--'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '644: 所有者 - rw-, 组 - r--, 和其他人 - r--'
- en: '666: Owner - rw-, Group - rw-, and Others - rw-'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '666: 所有者 - rw-, 组 - rw-, 和其他人 - rw-'
- en: '700: Owner - rwx, Group - ---, and Others - ---'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '700: 所有者 - rwx, 组 - ---, 和其他人 - ---'
- en: '755: Owner - rwx, Group - r-x, and Others - r-x'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '755: 所有者 - rwx, 组 - r-x, 和其他人 - r-x'
- en: '775: Owner - rwx, Group - rwx, and Others - r-x'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '775: 所有者 - rwx, 组 - rwx, 和其他人 - r-x'
- en: '777: Owner - rwx, Group - rwx, and Others - rwx'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '777: 所有者 - rwx, 组 - rwx, 和其他人 - rwx'
- en: 'The first (leftmost) bit of an octal digit is a value of 4, the second (center)
    bit is a value of 2, and the third (rightmost) bit is a value of 1, as shown below:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 八进制数字的第一个（最左边的）位是值为4，第二个（中间的）位是值为2，第三个（最右边的）位是值为1，如下所示：
- en: '![Figure 5.1 – File access permissions](img/B18466_05_01.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 文件访问权限](img/B18466_05_01.png)'
- en: Figure 5.1 – File access permissions
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 文件访问权限
- en: If all three bits in a collection are set, then the octal value of that collection
    is 4 + 2 + 1 = 7\. Each row in the above diagram comprises 3 collections for a
    total of 9 bits.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合中的三位数都设置了，则该集合的八进制值为4 + 2 + 1 = 7。上述图表中的每一行包含3个集合，总共有9位。
- en: 'There is a fourth preceding octal digit whose value has special significance:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个第四个前导的八进制数字，其值具有特殊意义：
- en: '**SUID (4)**: If the file is executable, it changes the effective UID of the
    process to that of the file owner when the program is run.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SUID (4)**: 如果文件是可执行的，它会在程序运行时将进程的有效UID更改为文件所有者的UID。'
- en: '**SGID (2)**: Like SUID, this changes the effective GID of the process to that
    of the group of the file.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SGID (2)**：与SUID类似，这会将进程的有效GID更改为文件所属组的GID。'
- en: '**Sticky (1)**: In a directory, this restricts deletion so that one user cannot
    delete files that are owned by another user. This is usually set on `/tmp` and
    `/var/tmp`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sticky (1)**：在一个目录中，它限制删除操作，使得一个用户不能删除另一个用户拥有的文件。通常这会设置在`/tmp`和`/var/tmp`目录下。'
- en: 'The SUID bit is probably used most often. It gives non-root users a temporary
    privilege escalation to superuser to perform a task. The `ping` program is a good
    example: `ping` opens a raw socket, which is a privileged operation. The `ping`
    executable is owned by user `root` and has the SUID bit set so that when you run
    `ping`, it executes with UID 0 regardless of your UID.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: SUID位可能是最常用的。它赋予非root用户临时提升到超级用户的权限来执行任务。`ping`程序是一个很好的例子：`ping`打开一个原始套接字，这是一个特权操作。`ping`可执行文件由`root`用户拥有，并且设置了SUID位，这样当你运行`ping`时，无论你的UID是什么，它都会以UID
    0执行。
- en: 'To set this leading octal digit, use values of either `4`, `2`, and `1` with
    the `chmod` command. For example, to set SUID on `/bin/ping` in your staging root
    directory, you would prepend `4` to a mode of `755` like so:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置这个前导八进制数字，可以使用`chmod`命令的`4`、`2`和`1`值。例如，要在暂存根目录中的`/bin/ping`上设置SUID，可以将`4`加到模式`755`前面，如下所示：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the second `ls` command shows the first three bits of the mode to
    be `rws`, whereas previously, they had been `rwx`. That `s` indicates that the
    SUID bit is set.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第二个`ls`命令显示模式的前三个位为`rws`，而之前是`rwx`。那个`s`表示SUID位已设置。
- en: File ownership permissions in the staging directory
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂存目录中的文件所有权权限
- en: For security and stability reasons, it is important to pay attention to the
    ownership and permissions of the files that will be placed on the target device.
    In general, you want to restrict sensitive resources to be accessible only by
    the `root` user and run as few programs using non-root users as possible. It is
    best to run programs using non-root users so that if they are compromised by an
    outside attack, they offer as few system resources to the attacker as possible.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全性和稳定性的考虑，必须注意将要放置在目标设备上的文件的所有权和权限。通常，你需要将敏感资源的访问限制为只有`root`用户才能访问，并尽可能减少非root用户运行程序的数量。最好是使用非root用户来运行程序，这样如果它们被外部攻击者攻破，它们提供给攻击者的系统资源将尽可能少。
- en: For example, the device node called `/dev/mem` gives access to system memory,
    which is necessary in some programs. But if it is readable and writeable by everyone,
    then there is no security because everyone can access everything in memory. So
    `/dev/mem` should be owned by `root`, belong to the `root` group, and have a mode
    of `600` that denies read and write access to all but the owner.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，名为`/dev/mem`的设备节点提供对系统内存的访问，这是某些程序所必需的。但是，如果它对所有人都可读写，那么就没有安全性，因为任何人都可以访问内存中的所有内容。所以，`/dev/mem`应该由`root`所有，属于`root`组，并且设置模式为`600`，以拒绝除所有者外的所有人读写访问。
- en: 'However, there is a problem with the staging directory. The files you create
    there will be owned by you. But when they are installed on the device, they should
    belong to specific owners and groups, mostly the `root` user. An obvious fix is
    to change the ownership to `root` at this stage, with the commands shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，暂存目录存在一个问题。你在那里创建的文件将属于你。但是，当它们被安装到设备上时，它们应该属于特定的所有者和组，通常是`root`用户。一个明显的解决方法是在此阶段将所有权更改为`root`，可以使用下面的命令：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**IMPORTANT NOTE**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Do not run the preceding `sudo chown -R root:root *` command. You could damage
    your filesystem irreparably.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不要运行前面的`sudo chown -R root:root *`命令。你可能会不可逆转地损坏你的文件系统。
- en: The problem is that you need `root` privileges to run the `chown` command. And
    from that point onward, you will need to be `root` to modify any files in the
    staging directory. Before you know it, you are doing all your development logged
    in as `root`, which is not a good idea. This is a problem that we will revisit
    when creating a standalone `initramfs`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，你需要`root`权限来运行`chown`命令。从那时起，你将需要`root`权限来修改暂存目录中的任何文件。不知不觉中，你可能就以`root`身份登录进行开发，这并不是一个好主意。我们将在创建独立的`initramfs`时重新审视这个问题。
- en: Programs for the root filesystem
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根文件系统程序
- en: Now, it is time to start populating the root filesystem with the essential programs
    and the supporting libraries, configuration, and data files they need to operate.
    I will begin with an overview of the types of programs you will need.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始为根文件系统填充必要的程序以及它们运行所需的支持库、配置文件和数据文件了。我将首先概述你需要的程序类型。
- en: init program
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: init程序
- en: '`init` is the first program to be run, so it is an essential part of the root
    filesystem. In this chapter, we will use the simple `init` program provided by
    BusyBox.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`是第一个运行的程序，因此它是根文件系统的重要组成部分。在本章中，我们将使用BusyBox提供的简单`init`程序。'
- en: Shell
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shell
- en: 'We need a shell to run scripts and to give us a command prompt so that we can
    interact with the system. An interactive shell is probably not necessary in a
    production device, but it is useful for development, debugging, and maintenance.
    There are various shells in common use on embedded systems:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个Shell来运行脚本并提供命令提示符，以便我们与系统进行交互。在生产设备中可能不需要交互式Shell，但在开发、调试和维护中非常有用。嵌入式系统上常用的Shell有几种：
- en: '`bash`: This is the big beast that we all know and love from desktop Linux.
    It is a superset of the Unix Bourne shell with many extensions or bashisms.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bash`：这是我们在桌面Linux中都熟知并喜爱的“大怪兽”。它是Unix Bourne shell的超集，具有许多扩展或bash特性。'
- en: '`ash`: This is also based on the Bourne shell and has a long history with the
    BSD variants of Unix. BusyBox has a version of `ash` that has been extended to
    make it more compatible with `bash`. It is much smaller than `bash`, and hence,
    it is a very popular choice for embedded systems.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ash`：这也是基于Bourne shell的，并且在Unix的BSD变种中有着悠久的历史。BusyBox有一个版本的`ash`，它经过扩展，使其更加兼容`bash`。它比`bash`小得多，因此它是嵌入式系统中非常流行的选择。'
- en: '`hush`: This is a very small shell that we briefly looked at in [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061).
    It is useful on devices with very little memory. There is a version of `hush`
    in BusyBox.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hush`：这是一款非常小的shell，我们在[*第3章*](Chapter_03.xhtml#_idTextAnchor061)中简要地看过它。它在内存非常有限的设备上非常有用。BusyBox中有一个版本的`hush`。'
- en: '**TIP**'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**提示**'
- en: If you are using `ash` or `hush` as the shell on the target, make sure that
    you test your shell scripts on the target. It is very tempting to test them only
    on the host using `bash` and then be surprised that they don’t work when you copy
    them to the target.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在目标设备上使用`ash`或`hush`作为shell，确保在目标设备上测试你的脚本。仅仅在主机上使用`bash`测试它们，而在将它们复制到目标设备后却发现它们无法正常工作，这是很容易犯的错误。
- en: Utilities
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实用工具
- en: The shell is just a way of launching other programs. A shell script is little
    more than a list of programs to run with some flow control and a means of passing
    information between them. To make a shell useful, you need the utility programs
    that the Unix command line is based on. Even a basic root filesystem needs approximately
    50 utilities. This presents two problems. Firstly, tracking down the source code
    for each one and cross-compiling all of it is a big job. Secondly, the resulting
    collection of programs takes up several tens of megabytes. This was a real problem
    in the early days of embedded Linux when a few megabytes were all you had. BusyBox
    was created expressly to solve this problem.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Shell仅仅是启动其他程序的一种方式。Shell脚本不过是一个程序列表，包含一些流程控制和在程序之间传递信息的方式。为了使一个Shell有用，你需要一些Unix命令行所依赖的实用程序。即使是一个基本的根文件系统，也需要大约50个实用程序。这带来了两个问题。首先，找到每个程序的源代码并交叉编译所有这些程序是一项大工程。其次，最终的程序集合会占用几十兆字节的存储空间。这在嵌入式Linux的早期是一个真正的问题，当时设备的存储容量只有几兆字节。BusyBox正是为了应对这个问题而创建的。
- en: BusyBox to the rescue!
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BusyBox来拯救我们了！
- en: The genesis of BusyBox had nothing to do with embedded Linux. Bruce Perens started
    the project in 1996 for the Debian installer so that he could boot Linux from
    a 1.44 MB floppy disk. Coincidentally, this was about the size of the storage
    on contemporary devices so the embedded Linux community quickly took it up. BusyBox
    has been at the heart of embedded Linux ever since.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox的诞生与嵌入式Linux无关。Bruce Perens在1996年启动了这个项目，为了使Debian安装程序能够从1.44 MB的软盘启动Linux。巧合的是，这个存储大小与当时设备的存储容量差不多，因此嵌入式Linux社区迅速接受了它。从那时起，BusyBox就一直是嵌入式Linux的核心。
- en: 'BusyBox was written from scratch to perform the essential functions of those
    essential Linux utilities. The developers took advantage of the 80/20 rule: the
    most useful 80% of a program is implemented in 20% of the code. Hence, BusyBox
    tools implement a subset of the functionality of their desktop equivalents, but
    they do enough to be useful in most cases.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox 从零开始编写，旨在执行那些基本 Linux 工具的基本功能。开发者运用了 80/20 原则：一个程序最有用的 80% 功能是由 20%
    的代码实现的。因此，BusyBox 工具实现了桌面版工具功能的一个子集，但足以在大多数情况下满足需求。
- en: 'Another trick BusyBox employs is to combine all the tools together into a single
    binary, making it easy to share code between them. It works like this: BusyBox
    is a collection of applets, each of which exports its `main` function in the form
    `<applet>_main`. For example, the `cat` command is implemented in `coreutils/cat.c`
    and exports `cat_main`. The `main` function of BusyBox dispatches the call to
    the correct applet, based on the command-line arguments.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 BusyBox 使用的技巧是将所有工具合并到一个单一的二进制文件中，从而方便它们之间共享代码。具体操作如下：BusyBox 是一系列小工具的集合，每个小工具都以
    `<applet>_main` 的形式导出其 `main` 函数。例如，`cat` 命令在 `coreutils/cat.c` 中实现，并导出 `cat_main`。BusyBox
    的 `main` 函数根据命令行参数将调用调度到正确的小工具。
- en: 'To read a file, you can launch BusyBox with the name of the applet you want
    to run, followed by any arguments that the applet expects:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取文件，你可以通过启动 BusyBox 并指定你要运行的小工具的名称，后跟小工具需要的任何参数：
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can also run BusyBox with no arguments to get a list of all the applets
    that have been compiled.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以运行 BusyBox 而不带任何参数，以获取已编译的所有小工具的列表。
- en: 'Using BusyBox in this way is rather clumsy. A better way to get BusyBox to
    run the `cat` applet is to create a symbolic link from `/bin/cat` to `/bin/busybox`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这样使用 BusyBox 有点笨拙。让 BusyBox 运行 `cat` 小工具的更好方法是从 `/bin/cat` 创建一个符号链接到 `/bin/busybox`：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you type `cat` at the command line, BusyBox is the program that actually
    runs. BusyBox only has to check the path to the executable (`/bin/cat`) passed
    in via `argv[0]`, extract the application name (`cat`), and do a table lookup
    to match `cat` with `cat_main`. All this is expressed in this slightly simplified
    section of code from `libbb/appletlib.c`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在命令行输入`cat`时，实际运行的程序是 BusyBox。BusyBox 只需要检查传入的可执行文件路径（`/bin/cat`），提取应用程序名称（`cat`），然后进行表格查找，将`cat`与`cat_main`匹配。所有这些在
    `libbb/appletlib.c` 中的这一段简化代码中有体现：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: BusyBox has over 300 applets, including an `init` program, several shells with
    varying levels of complexity, and utilities for most admin tasks. There is even
    a simple version of the `vi` editor so that you can change text files on your
    device. A typical BusyBox binary will only enable several dozen applets.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox 包含超过 300 个小工具，包括一个 `init` 程序、几个具有不同复杂度的 shell 以及用于大多数管理任务的工具。甚至还有一个简单版本的
    `vi` 编辑器，方便你在设备上修改文本文件。一个典型的 BusyBox 二进制文件将只启用几十个小工具。
- en: In summary, a typical installation of BusyBox consists of a single program,
    with a symbolic link for each applet but which behaves exactly as if it were a
    collection of individual applications.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，典型的 BusyBox 安装由一个单一程序组成，每个小工具都有一个符号链接，但其行为与多个独立应用程序完全一致。
- en: Building BusyBox
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 BusyBox
- en: 'BusyBox uses the same `Kconfig` and `Kbuild` system as the kernel, so cross-compiling
    is straightforward. Get the source by cloning the BusyBox Git repo and checking
    out the version you want (`1_36_1` was the latest in August 2024):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox 使用与内核相同的 `Kconfig` 和 `Kbuild` 系统，因此交叉编译非常简单。通过克隆 BusyBox Git 仓库并检查你想要的版本（2024
    年 8 月时最新版本是 `1_36_1`）来获取源码：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can also download the corresponding TAR file from [https://busybox.net/downloads/](https://busybox.net/downloads/).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从 [https://busybox.net/downloads/](https://busybox.net/downloads/) 下载相应的
    TAR 文件。
- en: 'Configure BusyBox with the default configuration, which enables pretty much
    all of the features:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认配置来配置 BusyBox，这将启用几乎所有功能：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At this point, you probably want to run `make menuconfig` to fine-tune the
    configuration. For example, you almost certainly want to set the install path
    in **Settings | Installation Options (“make install” behavior) | Destination path
    for ‘make install’** to point to the staging directory. Then, you can cross-compile
    in the usual way. If your intended target is the BeaglePlay, use these commands:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你可能需要运行 `make menuconfig` 来微调配置。例如，你几乎肯定需要在 **设置 | 安装选项（“make install”行为）|
    ‘make install’ 的目标路径** 中设置安装路径，指向暂存目录。然后，你就可以按常规方式进行交叉编译。如果你的目标平台是 BeaglePlay，可以使用以下命令：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can cross-compile BusyBox for the 64-bit Arm generic virtual platform emulated
    by QEMU in the same way.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以相同的方式为QEMU模拟的64位Arm通用虚拟平台交叉编译BusyBox。
- en: In either case, the result is the `busybox` executable. For a default configuration
    build like this, the size is about 1,100 KB. If this is too big for you, then
    you can slim it down by changing the configuration to leave out the utilities
    you don’t need.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，结果都是`busybox`可执行文件。对于像这样的默认配置构建，大小约为1,100KB。如果这个文件太大，你可以通过更改配置来删除不需要的工具，从而减小它的体积。
- en: 'To install BusyBox in the staging area, use the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要将BusyBox安装到暂存区，请使用以下命令：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will copy the binary to the directory configured in **Destination path
    for ‘make install’** and create all the symbolic links to it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把二进制文件复制到**“make install”目标路径**中，并为其创建所有的符号链接。
- en: Now, let’s look at an alternative to Busybox, known as ToyBox.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看另一个替代品，ToyBox。
- en: ToyBox – an alternative to BusyBox
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ToyBox——BusyBox的替代品
- en: BusyBox is not the only game in town. There is also ToyBox, which you can find
    at [https://landley.net/toybox/](https://landley.net/toybox/). The project was
    started by Rob Landley, who was previously a maintainer of BusyBox. ToyBox has
    the same aim as BusyBox but with more emphasis on complying with standards (especially
    POSIX-2008 and LSB 4.1) and less on compatibility with GNU extensions to those
    standards. ToyBox is smaller than BusyBox, partly because it implements fewer
    applets.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox并不是唯一的选择。还有ToyBox，你可以在[https://landley.net/toybox/](https://landley.net/toybox/)找到它。该项目由Rob
    Landley发起，他曾是BusyBox的维护者。ToyBox的目标与BusyBox相同，但更加注重遵守标准（尤其是POSIX-2008和LSB 4.1），而不太关注与GNU扩展兼容性。ToyBox比BusyBox小，部分原因是它实现了更少的工具。
- en: The license for ToyBox is BSD rather than GPL v2, making it compatible with
    operating systems that have a BSD-licensed user space such as Android. Hence,
    ToyBox ships with all new Android devices. As of the 0.8.3 release, Toybox’s `Makefile`
    can build a full Linux system that boots to a shell prompt when given just the
    Linux and ToyBox sources.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ToyBox的许可证是BSD，而不是GPL v2，这使得它与那些采用BSD许可证用户空间的操作系统兼容，比如Android。因此，ToyBox与所有新的Android设备一起发布。从0.8.3版本开始，ToyBox的`Makefile`可以构建一个完整的Linux系统，当只提供Linux和ToyBox的源代码时，它可以启动并进入Shell提示符。
- en: Libraries for the root filesystem
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根文件系统的库
- en: Programs are linked with libraries. You can link them all statically so that
    no libraries reside on the target device. This takes up an unnecessarily large
    amount of storage if you have more than two or three programs. To reduce the size
    of your programs, you need to copy shared libraries from the toolchain to the
    staging directory. But how do you know which libraries to copy?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 程序是与库链接的。你可以将它们全部静态链接，这样就不会在目标设备上驻留任何库。如果你有超过两到三个程序，这会占用不必要的大量存储空间。为了减小程序的大小，你需要将共享库从工具链复制到暂存目录。但是，你怎么知道该复制哪些库呢？
- en: One option is to copy all the `.so` files from the `sysroot` directory of your
    toolchain. Instead of trying to predict which libraries to include, just assume
    that your image will eventually need them all. This is certainly logical, and
    if you are creating a platform to be used by others for a range of applications,
    it would be the correct approach. However, be aware that a full glibc is quite
    large. In the case of Buildroot’s build of glibc, the libraries, locales, and
    other supporting files come to 22 MB. You can cut that down considerably by using
    musl or uClibc-ng.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是从你的工具链的`sysroot`目录复制所有的`.so`文件。与其试图预测要包含哪些库，不如假设你的镜像最终会需要它们所有。这种做法无疑是合理的，如果你正在创建一个供他人使用的多种应用平台，那么这种方法是正确的。然而，要注意，完整的glibc是相当庞大的。在Buildroot构建的glibc的情况下，库、区域设置和其他支持文件总共达到了22MB。通过使用musl或uClibc-ng，你可以大大减少这个大小。
- en: 'Another option is to cherry-pick only those libraries that you require. To
    do that, you need a means of discovering library dependencies. Let’s use the `readelf`
    command from [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028) for this task:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是只挑选你需要的那些库。为此，你需要一种发现库依赖关系的方法。让我们使用来自[*第2章*](Chapter_01.xhtml#_idTextAnchor028)的`readelf`命令来完成这项任务：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first `readelf` command searches the `busybox` binary for lines containing
    `program interpreter`. The second `readelf` command searches the `busybox` binary
    for lines containing `Shared library`. Now, you need to find these files in the
    toolchain `sysroot` directory and copy them to the staging directory. Remember
    that you can find `sysroot` like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`readelf`命令搜索`busybox`二进制文件中包含`program interpreter`的行。第二个`readelf`命令搜索`busybox`二进制文件中包含`Shared
    library`的行。现在，你需要在工具链的`sysroot`目录中找到这些文件，并将它们复制到暂存目录。记住，你可以这样找到`sysroot`：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To reduce typing, keep a copy of the `sysroot` path in a shell variable:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少输入，可以将`sysroot`路径保存在一个shell变量中：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s look at `/lib/ld-linux-aarch64.so.1` in `sysroot`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一下`sysroot`中的`/lib/ld-linux-aarch64.so.1`：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Repeat the exercise for `libc.so.6`, `libm.so.6` and `libresolv.so.2` so that
    you end up with a list of four files. Now, copy each one to your `rootfs` directory:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对`libc.so.6`、`libm.so.6`和`libresolv.so.2`进行相同的操作，这样你就会得到四个文件的列表。现在，将每个文件复制到`rootfs`目录中：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These are just the shared libraries needed by `busybox`. Repeat this procedure
    for each program you wish to add to your `rootfs` directory.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是`busybox`所需的共享库。对于每个你希望添加到`rootfs`目录中的程序，重复此过程。
- en: '**TIP**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: It is only worth doing this to get the very smallest embedded footprint possible.
    There is a danger that you will miss libraries that are loaded through `dlopen(3)`
    calls–plugins mostly. We will look at an example with the **name service switch**
    (**NSS**) libraries when we come to configure network interfaces later on in this
    chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在需要最小化嵌入式系统占用空间时，做这个操作才有意义。这样做的风险是，你可能会错过通过`dlopen(3)`调用加载的库，主要是插件。我们将在本章稍后讨论配置网络接口时，探讨与**名称服务切换**（**NSS**）库的例子。
- en: Reducing size by stripping
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过去除符号表减少文件大小
- en: 'Libraries and programs are often compiled with some information stored in symbol
    tables to aid with debugging and tracing. You seldom need these in a production
    system. A quick and easy way to save space is to strip the binaries of symbol
    tables. This example shows `libc` before stripping:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 库和程序通常会在符号表中存储一些信息，用于调试和追踪。在生产系统中，你很少需要这些信息。节省空间的一种快速简便的方法是去除二进制文件中的符号表。这个例子展示了去除前的`libc`：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let’s see the result of stripping debug information:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看一下去除调试信息后的结果：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, we saved 532,616 bytes, or about 28% of the size of the file,
    before stripping.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在去除调试信息之前节省了532,616字节，即文件大小的约28%。
- en: '**TIP**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: 'Be careful about stripping kernel modules. Some symbols are required by the
    module loader to relocate the module code, so the module will fail to load if
    they are stripped out. Use this command to remove debug symbols while keeping
    those used for relocation: `strip --strip-unneeded <module name>`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要去除内核模块的调试符号。某些符号是模块加载器在重新定位模块代码时所必需的，如果这些符号被去除，模块将无法加载。使用此命令移除调试符号，同时保留用于重定位的符号：`strip
    --strip-unneeded <模块名>`。
- en: Device nodes
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备节点
- en: Most devices in Linux are represented by device nodes in accordance with the
    Unix philosophy that *everything is a file* (except network interfaces, which
    are sockets). A device node may refer to a block device or a character device.
    Block devices are mass storage devices such as SD cards or hard drives. A character
    device is pretty much anything else (again, except for network interfaces).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，大多数设备通过设备节点来表示，符合Unix哲学中的*一切皆文件*（网络接口除外，网络接口是套接字）。设备节点可以指代块设备或字符设备。块设备是大容量存储设备，如SD卡或硬盘。字符设备几乎包括所有其他设备（同样，网络接口除外）。
- en: The conventional place for device nodes is the `/dev` directory. For example,
    a serial port can be represented by a device node called `/dev/ttyS0`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 设备节点的常规位置是`/dev`目录。例如，串口可以通过名为`/dev/ttyS0`的设备节点来表示。
- en: 'Device nodes are created using the program named `mknod` (short for make node):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 设备节点是通过名为`mknod`（即“创建节点”）的程序创建的：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The parameters for `mknod` are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`mknod`的参数如下：'
- en: '**name** is the name of the device node that you want to create.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**是你要创建的设备节点的名称。'
- en: '**type** is either c for character devices or b for a block device.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**是字符设备（c）或块设备（b）。'
- en: '**major** and **minor** are a pair of numbers that are used by the kernel to
    route file requests to the appropriate device driver code. There is a list of
    standard major and minor numbers in the kernel source file: `Documentation/admin-guide/devices.txt`.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主设备号**和**次设备号**是一对数字，内核通过它们将文件请求路由到相应的设备驱动代码。内核源文件中有一个标准主设备号和次设备号的列表：`Documentation/admin-guide/devices.txt`。'
- en: You will need to create device nodes for all the devices that you want to access
    on your system. You can do so manually using the `mknod` command illustrated here,
    or you can create them automatically at runtime using one of the device managers
    mentioned later.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为系统中要访问的所有设备创建设备节点。你可以手动使用下面示范的 `mknod` 命令来创建，或者可以使用稍后提到的设备管理器在运行时自动创建它们。
- en: 'In a minimal root filesystem, you need just two nodes to boot with BusyBox:
    `console` and `null`. The `console` only needs to be accessible to `root`, the
    owner of the device node, so the access permissions are `600` (`rw-------`). The
    `null` device should be readable and writable by everyone, so the mode is `666`
    (`rw-rw-rw-`). Use the `-m` option for `mknod` to set the `mode` when creating
    the node. You need to be `root` to create device nodes:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小化根文件系统中，你只需要两个节点来使用 BusyBox 启动：`console` 和 `null`。`console` 只需要对设备节点的所有者
    `root` 可访问，因此其访问权限为 `600`（`rw-------`）。`null` 设备应该对所有人都可读可写，所以它的模式为 `666`（`rw-rw-rw-`）。使用
    `-m` 选项设置 `mknod` 创建节点时的 `mode`。你需要是 `root` 用户才能创建设备节点：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can delete device nodes using the standard `rm` command. There is no `rmnod`
    command because, once created, they are just files.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准的 `rm` 命令删除设备节点。没有 `rmnod` 命令，因为一旦创建，它们就只是文件。
- en: Proc and sysfs filesystems
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Proc 和 sysfs 文件系统
- en: '`proc` and `sysfs` are two pseudo filesystems that offer a window into the
    inner workings of the kernel. They both represent kernel data as files in a hierarchy
    of directories. When you read one of these files, the contents you see do not
    come from disk storage. Instead, it is formatted on the fly by a function in the
    kernel. Some files are also writable, meaning that a kernel function is called
    with the new data you have written. If the data is formatted correctly and you
    have sufficient permissions, then the function modifies the value stored in the
    kernel’s memory. In other words, `proc` and `sysfs` provide another way to interact
    with device drivers and other kernel code.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`proc` 和 `sysfs` 是两个伪文件系统，它们提供了一个观察内核内部工作原理的窗口。它们都将内核数据以文件的形式表示在一个目录层次结构中。当你读取这些文件时，看到的内容并不是来自磁盘存储。相反，它是由内核中的一个函数即时格式化的。有些文件也可以写入，这意味着当你写入新的数据时，内核函数会被调用。如果数据格式正确，并且你具有足够的权限，那么该函数将修改内核内存中存储的值。换句话说，`proc`
    和 `sysfs` 提供了与设备驱动程序和其他内核代码交互的另一种方式。'
- en: '**IMPORTANT NOTE**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The following `mount` commands are meant to be run on an embedded target device,
    like the BeaglePlay or Versatile Express (QEMU). Do not run them on your host
    machine.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的 `mount` 命令适用于嵌入式目标设备，如 BeaglePlay 或 Versatile Express（QEMU）。请勿在主机机器上运行这些命令。
- en: 'The `proc` and `sysfs` filesystems should be mounted on the `/proc` and `/sys`
    directories:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`proc` 和 `sysfs` 文件系统应该挂载在 `/proc` 和 `/sys` 目录下：'
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Although very similar in concept, the two perform different functions. `proc`
    has been part of Linux since the early days. Its original purpose was to expose
    information about processes to user space, hence the name. To this end, there
    is a directory for each process named `/proc/<PID>`, which contains information
    about its state. The process list command (`ps`) reads these files to generate
    its output.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个文件系统的概念非常相似，但它们执行的是不同的功能。`proc` 从 Linux 初期就已经存在。它的最初目的是将关于进程的信息暴露给用户空间，因此得名。为了这个目的，系统为每个进程创建了一个名为
    `/proc/<PID>` 的目录，目录中包含该进程的状态信息。进程列表命令（`ps`）通过读取这些文件来生成输出。
- en: There are also files that give information about other parts of the kernel.
    For example, `/proc/cpuinfo` tells you about the CPU, `/proc/interrupts` has information
    about interrupts, and so on. Lastly, `/proc/sys` contains files that display and
    control the state and behavior of kernel subsystems, especially scheduling, memory
    management, and networking. The manual page is the best reference for the files
    found in the `proc` directory. You can see this information by typing `man 5 proc`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些文件提供了关于内核其他部分的信息。例如，`/proc/cpuinfo` 提供关于 CPU 的信息，`/proc/interrupts` 包含中断信息，等等。最后，`/proc/sys`
    目录包含显示和控制内核子系统状态和行为的文件，特别是调度、内存管理和网络。手册页是查看 `proc` 目录中文件的最佳参考。你可以通过输入 `man 5 proc`
    查看这些信息。
- en: The role of `sysfs` is to present the kernel **driver model** to user space.
    It exports a hierarchy of files relating to devices and how they are connected
    to each other. I will go into more detail on the Linux driver model when I describe
    the interaction with device drivers in [*Chapter 11*](Chapter_11.xhtml#_idTextAnchor373).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`sysfs` 的作用是将内核 **驱动模型** 显示给用户空间。它导出一个与设备相关的文件层次结构，表示设备及其连接关系。关于 Linux 驱动模型的更多细节，我将在描述与设备驱动交互时讲解，在
    [*第 11 章*](Chapter_11.xhtml#_idTextAnchor373) 中详细说明。'
- en: Mounting filesystems
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂载文件系统
- en: 'The `mount` command allows us to attach one filesystem to a directory within
    another, forming a hierarchy of filesystems. The one at the top, which was mounted
    by the kernel when it booted, is called the **root filesystem**. The format of
    the `mount` command is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount` 命令允许我们将一个文件系统附加到另一个目录，从而形成文件系统的层次结构。最上层的文件系统是由内核在启动时挂载的，称为 **根文件系统**。`mount`
    命令的格式如下：'
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The parameters to `mount` are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount` 的参数如下：'
- en: '**vfstype** is the type of filesystem.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vfstype** 是文件系统的类型。'
- en: '**options** is a comma-separated list of mount options.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**options** 是以逗号分隔的挂载选项列表。'
- en: '**device** is the block device node that the filesystem resides on.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**device** 是文件系统所在的块设备节点。'
- en: '**directory** is the directory that you want to mount the filesystem to.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**directory** 是你希望将文件系统挂载到的目录。'
- en: There are various options you can give after `-o`. Have a look at the manual
    page `mount(8)` for more information. Type the following if you want to mount
    an SD card containing an ext4 filesystem in the first partition onto the directory
    named `/mnt:`
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `-o` 后有多种选项可供选择。查看 `mount(8)` 的手册页以获取更多信息。如果你想将包含 ext4 文件系统的 SD 卡的第一个分区挂载到名为
    `/mnt` 的目录，请输入以下命令：
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Assuming that the mount succeeds, you will see the files stored on the SD card
    in the `/mnt` directory. In some cases, you can leave out the filesystem type
    and let the kernel probe the device to find out what is stored there. If mounting
    fails, you may first need to unmount the partition if your Linux distro is configured
    to automount all the partitions on an SD card when it is inserted.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 假设挂载成功，你将会在 `/mnt` 目录下看到存储在 SD 卡上的文件。在某些情况下，你可以省略文件系统类型，让内核探测设备，找出存储的内容。如果挂载失败，你可能需要先卸载分区，如果你的
    Linux 发行版配置为在插入 SD 卡时自动挂载所有分区。
- en: 'Notice something odd in the following examples of mounting the `proc` filesystem?
    There is no device node such as `/dev/proc`, since it is a pseudo filesystem and
    not a real one. But the `mount` command requires a device parameter. Consequently,
    we have to provide a string where a device would go, but it does not matter much
    what that string is. These two commands achieve exactly the same result:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到以下挂载 `proc` 文件系统的例子有什么奇怪的吗？没有像 `/dev/proc` 这样的设备节点，因为它是一个伪文件系统，而非真实的文件系统。但
    `mount` 命令需要一个设备参数。因此，我们必须提供一个字符串来代替设备的位置，但这个字符串的内容其实不重要。这两个命令的效果完全相同：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `procfs` and `nodevice` strings are ignored by the `mount` command. It is
    common to use the filesystem type in the place of the device when mounting pseudo
    filesystems.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`procfs` 和 `nodevice` 字符串会被 `mount` 命令忽略。挂载伪文件系统时，通常会使用文件系统类型代替设备。'
- en: Kernel modules
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核模块
- en: If you have kernel modules, they need to be installed into the root filesystem
    using the `modules_install` kernel make target, as we saw in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096).
    This will copy them into the `/lib/modules/<kernel version>` directory, together
    with the configuration files needed by the `modprobe` command.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有内核模块，它们需要使用 `modules_install` 内核构建目标安装到根文件系统中，正如我们在 [*第 4 章*](Chapter_04.xhtml#_idTextAnchor096)
    中所看到的。这会将它们复制到 `/lib/modules/<kernel version>` 目录，并将 `modprobe` 命令所需的配置文件一并复制过去。
- en: Be aware that you have just created a dependency between the kernel and the
    root filesystem. If you update one, then you will have to update the other.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你刚刚在内核和根文件系统之间创建了一个依赖关系。如果你更新其中之一，你将需要更新另一个。
- en: Now that we know how to mount a filesystem from an SD card, let’s look at the
    different options for mounting a root filesystem. The alternatives (a ramdisk
    and NFS) may surprise you, especially if you are new to embedded Linux. A ramdisk
    protects the original source image from corruption and wear. We’ll learn more
    about flash wear in [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor293). A network
    filesystem allows for more rapid development because file changes propagate instantly
    to the target(s).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何从SD卡挂载文件系统，接下来我们来看看挂载根文件系统的不同选项。替代方案（如ramdisk和NFS）可能会让你感到惊讶，尤其是如果你对嵌入式Linux不熟悉的话。Ramdisk可以保护原始源镜像不被损坏或磨损。我们将在[*第9章*](Chapter_09.xhtml#_idTextAnchor293)中了解更多关于闪存磨损的内容。网络文件系统允许更快速的开发，因为文件的更改会立即传播到目标设备。
- en: Transferring the root filesystem to the target
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将根文件系统传输到目标设备
- en: 'After creating a skeleton root filesystem in your staging directory, the next
    step is to transfer it to the target. There are three possibilities:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的暂存目录中创建一个骨架根文件系统后，下一步是将其传输到目标设备。这里有三种可能性：
- en: '**initramfs**: This is a filesystem image that is loaded into RAM by the bootloader.
    Ramdisks are easy to create and have no dependencies on mass storage drivers.
    They can be used in fallback maintenance mode when the main root filesystem needs
    updating. They can even be used as the main root filesystem in smaller embedded
    devices. Ramdisks are also commonly used as the early user space in mainstream
    Linux distributions. Remember that the contents of a root filesystem on ramdisk
    are volatile, so any changes made to the root filesystem at runtime are lost when
    the system reboots. You need another storage type to store permanent data such
    as configuration parameters.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**initramfs**：这是一种由引导加载程序加载到RAM中的文件系统镜像。Ramdisks容易创建，并且不依赖于大容量存储驱动程序。它们可以在主根文件系统需要更新时用作后备维护模式，甚至可以在较小的嵌入式设备中作为主根文件系统。Ramdisks还常常作为主流Linux发行版中的早期用户空间使用。请记住，存储在ramdisk中的根文件系统内容是易失性的，因此在运行时对根文件系统所做的任何更改都会在系统重启时丢失。你需要其他存储类型来存储像配置参数这样的永久数据。'
- en: '**disk image**: A copy of the root filesystem that is formatted and ready to
    be loaded onto a mass storage device on the target. It can be an image in the
    ext4 format, ready to be copied onto an SD card, or it can be in jffs2 format,
    ready to be loaded into flash memory via the bootloader. Creating a disk image
    is probably the most common option. There is more information about the different
    types of mass storage in [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor293).'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘镜像**：这是根文件系统的一个副本，已格式化并准备好加载到目标的存储设备上。它可以是一个ext4格式的镜像，准备复制到SD卡上，或者是jffs2格式，准备通过引导加载程序加载到闪存中。创建磁盘镜像可能是最常见的选择。关于不同类型的大容量存储，有更多的信息可以参考[*第9章*](Chapter_09.xhtml#_idTextAnchor293)。'
- en: '**network filesystem**: This is when the staging directory is exported to the
    network via an NFS server and mounted by the target at boot time. This is often
    done during development as opposed to repeated cycles of creating a disk image
    and reloading it onto the mass storage device, which gets tedious quickly.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络文件系统**：当暂存目录通过NFS服务器导出到网络，并在启动时由目标设备挂载时，就形成了网络文件系统。这通常在开发过程中使用，而不是通过反复创建磁盘镜像并将其重新加载到大容量存储设备上，因为后者会迅速变得繁琐。'
- en: I will start with `intiramfs` and use it to illustrate a few refinements to
    the root filesystem, like adding usernames and a device manager to create device
    nodes automatically. Then, I will show you how to create a disk image and how
    to use NFS to mount the root filesystem over a network.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从`intiramfs`开始，利用它来说明如何对根文件系统进行一些细微调整，比如添加用户名和设备管理器，以便自动创建设备节点。然后，我会展示如何创建磁盘镜像，以及如何使用NFS通过网络挂载根文件系统。
- en: Creating a boot initramfs
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个启动initramfs
- en: An initial RAM filesystem or `initramfs` is a compressed cpio archive. cpio
    is an old Unix archive format like TAR and ZIP, but it is easier to decode and
    so requires less code in the kernel. You need to configure your kernel with `CONFIG_BLK_DEV_INITRD`
    to support `initramfs`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 初始RAM文件系统或`initramfs`是一个压缩的cpio归档文件。cpio是一种古老的Unix归档格式，类似于TAR和ZIP，但它更容易解码，因此内核需要的代码较少。你需要在内核中配置`CONFIG_BLK_DEV_INITRD`以支持`initramfs`。
- en: 'There are three different ways to create a boot ramdisk: as a standalone cpio
    archive, as a cpio archive embedded in the kernel image, and as a device table
    that the kernel build system processes as part of the build. The first option
    gives the most flexibility because we can mix and match kernels and ramdisks to
    our heart’s content. However, it means having to deal with two files instead of
    one, and not all bootloaders have the facility to load a separate ramdisk.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种不同的方式来创建引导ramdisk：作为独立的cpio归档、作为嵌入在内核映像中的cpio归档，以及作为内核构建系统在构建过程中处理的设备表。第一种方式提供了最大的灵活性，因为我们可以随意混合和匹配内核和ramdisk。然而，它意味着需要处理两个文件而不是一个，并且并非所有引导加载程序都有加载独立ramdisk的功能。
- en: Standalone initramfs
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立initramfs
- en: 'The following sequence of instructions creates the archive, compresses it,
    and adds a U-Boot header to load onto the target:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建归档、压缩它并添加一个U-Boot头以便加载到目标上的一系列指令：
- en: '[PRE24]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that we run `cpio` with the option `--owner root:root`. This is a quick
    fix for the file ownership problem mentioned earlier in the *File ownership permissions
    in the staging directory* section. It makes everything in the cpio archive have
    a UID and GID of 0.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们运行`cpio`时使用了`--owner root:root`选项。这是解决前面在*暂存目录中的文件所有权权限*部分提到的文件所有权问题的快速修复。它使得cpio归档中的所有内容都具有UID和GID为0。
- en: 'The final size of the uRamdisk file is about 1.9 MB, with no kernel modules.
    Add to that 9.8 MB for the kernel Image.gz file and 1,061 KB for U-Boot. This
    gives us a total of 13 MB of storage needed to boot this board. We are way off
    from the 1.44 MB floppy that started it all. If size is a real problem, then you
    can use one of these options:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的uRamdisk文件大小约为1.9 MB，没有内核模块。再加上9.8 MB的内核`Image.gz`文件和1,061 KB的U-Boot。这样，我们总共需要13
    MB的存储空间来引导这块板子。这个大小远远超过了最初的1.44 MB软盘。如果大小真的是一个问题，那么你可以使用以下某种方式：
- en: Make the kernel smaller by leaving out drivers and functions you don’t need.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过去掉不需要的驱动程序和功能来使内核更小。
- en: Make BusyBox smaller by leaving out utilities you don’t need.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过去掉不需要的工具来使BusyBox更小。
- en: Use musl libc or uClibc-ng in place of glibc.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用musl libc或uClibc-ng替代glibc。
- en: Compile BusyBox statically.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态编译BusyBox。
- en: Booting an initramfs
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动initramfs
- en: The simplest thing we can do is to run a shell on the console so that we can
    interact with the target. We can do that by adding `rdinit=/bin/sh` to the kernel
    command line. The next two sections demonstrate how to do that for both QEMU and
    the BeaglePlay.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的最简单的事情是通过控制台运行一个shell，以便与目标进行交互。我们可以通过将`rdinit=/bin/sh`添加到内核命令行来实现这一点。接下来的两个部分将演示如何在QEMU和BeaglePlay上进行操作。
- en: Booting with QEMU
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用QEMU启动
- en: 'QEMU has a `-initrd` option to load an `initramfs` into memory. You should
    already have an `Image` file compiled with the `aarch64-buildroot-linux-gnu` toolchain
    from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096). From this chapter, you
    should have created an `initramfs`, which includes BusyBox compiled with the same
    toolchain. Now, you can launch QEMU using the script in `MELD/Chapter05/run-qemu-initramfs.sh`
    or this command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: QEMU有一个`-initrd`选项，可以将`initramfs`加载到内存中。你应该已经使用[*第4章*](Chapter_04.xhtml#_idTextAnchor096)中的`aarch64-buildroot-linux-gnu`工具链编译了一个`Image`文件。从本章开始，你应该已经创建了一个包含用相同工具链编译的BusyBox的`initramfs`。现在，你可以使用`MELD/Chapter05/run-qemu-initramfs.sh`脚本或以下命令启动QEMU：
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You should get a `root` shell with a `#` prompt.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到一个带有`#`提示符的`root` shell。
- en: Booting the BeaglePlay
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动BeaglePlay
- en: 'For the BeaglePlay, we need the microSD card prepared in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096),
    plus a root filesystem built using the `aarch64-buildroot-linux-gnu` toolchain.
    Copy the `uRamdisk` you created earlier in this section to the boot partition
    on the microSD card. Boot the BeaglePlay to the point where you get a U-Boot prompt.
    Then, enter these commands:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于BeaglePlay，我们需要准备在[*第4章*](Chapter_04.xhtml#_idTextAnchor096)中使用的microSD卡，并使用`aarch64-buildroot-linux-gnu`工具链构建根文件系统。将你之前在本节中创建的`uRamdisk`复制到microSD卡的引导分区。启动BeaglePlay并进入U-Boot提示符。然后，输入以下命令：
- en: '[PRE26]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If all goes well, you will get a `root` shell with a `#` prompt on the serial
    console. After this is done, we will need to mount `proc` on both platforms.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你将在串口控制台上看到一个带有`#`提示符的`root` shell。完成此步骤后，我们需要在两个平台上都挂载`proc`。
- en: Mounting proc
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂载proc
- en: 'You will find that the `ps` command does not work on either platform. This
    is because the `proc` filesystem has not been mounted yet. Try mounting it:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现`ps`命令在两个平台上都无法工作。这是因为`proc`文件系统尚未挂载。试着挂载它：
- en: '[PRE27]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run `ps` again, and you will see the process listing.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`ps`，你将看到进程列表。
- en: 'As an improvement, let’s write a shell script that mounts `proc` and anything
    else that needs to be done at bootup. Then, you can run this script instead of
    `/bin/sh` at boot. The following snippet illustrates how this works:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 作为改进，我们可以编写一个Shell脚本来挂载`proc`以及其他启动时需要完成的操作。然后，你可以在启动时运行这个脚本，而不是`/bin/sh`。以下代码片段演示了它是如何工作的：
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `/bin/sh` on the last line launches a new shell that gives you an interactive
    `root` shell prompt. Using a shell as `init` in this way is very handy for quick
    hacks – for example, when you want to rescue a system with a broken `init` program.
    However, in most cases, you would use an `init` program, which we will cover in
    the next section of this chapter. Before that, I want to look at two other ways
    to load `initramfs`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行的`/bin/sh`启动一个新的Shell，提供一个交互式的`root` Shell提示符。以这种方式将Shell作为`init`程序非常方便，适用于快速修补，例如当你想要修复一个损坏的`init`程序的系统时。然而，在大多数情况下，你会使用一个`init`程序，我们将在本章的下一节中讨论。之前，我想先看一下加载`initramfs`的另外两种方式。
- en: Building an initramfs into the kernel image
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将initramfs构建到内核镜像中
- en: So far, we have created a compressed `initramfs` as a separate file and used
    the bootloader to load it into memory. Some bootloaders do not have the ability
    to load an `initramfs` file in this way. To cope with these situations, Linux
    can be configured to incorporate `initramfs` into the kernel image. To do this,
    change the kernel configuration and set `CONFIG_INITRAMFS_SOURCE` to the full
    path of the compressed `initramfs.cpio.gz` archive file you created earlier for
    your standalone `initramfs`. If you are using `menuconfig`, that field can be
    found in **General setup | Initramfs source file(s)**.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将压缩后的`initramfs`作为单独的文件创建，并通过引导加载程序将其加载到内存中。一些引导加载程序可能不具备以这种方式加载`initramfs`文件的能力。为了应对这些情况，Linux可以配置将`initramfs`合并到内核镜像中。为此，请更改内核配置，并将`CONFIG_INITRAMFS_SOURCE`设置为你之前为独立`initramfs`创建的压缩`initramfs.cpio.gz`归档文件的完整路径。如果你使用的是`menuconfig`，可以在**General
    setup | Initramfs source file(s)**中找到该字段。
- en: Once these changes have been made, build the kernel. Booting is the same as
    before, except there is no `-initrd` option and ramdisk file to pass in.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些更改后，构建内核。启动过程与之前相同，不同之处在于没有`-initrd`选项和需要传入的ramdisk文件。
- en: 'Enter this command for QEMU:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于QEMU，输入以下命令：
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For the BeaglePlay, enter these commands at the U-Boot prompt:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于BeaglePlay，在U-Boot提示符下输入以下命令：
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Remember to regenerate the `initramfs.cpio` archive, and recompress the `initramfs.cpio.gz`
    file each time you change the contents of your staging directory and then rebuild
    the kernel:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 每次更改暂存目录的内容并重新构建内核时，请记得重新生成`initramfs.cpio`归档文件，并重新压缩`initramfs.cpio.gz`文件：
- en: '**TIP**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: 'If you experience the following kernel panic on boot:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在启动时遇到以下内核恐慌：
- en: '[PRE31]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Make sure that the `dev/null` and `dev/console` device nodes exist in your staging
    directory.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在你的暂存目录中存在`dev/null`和`dev/console`设备节点。
- en: Building an initramfs using a device table
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用设备表构建initramfs
- en: A **device table** is a text file that lists the files, directories, device
    nodes, and links that go into an archive or filesystem image. The overwhelming
    advantage is that it allows you to create entries in the archive file that are
    owned by the `root` user, or any other UID, without having `root` privileges yourself.
    You can even create device nodes without needing to have `root` privileges. All
    this is possible because the archive is just a data file. It is only when it is
    expanded by Linux at boot time that real files and directories get created using
    the attributes you specified.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备表**是一个文本文件，列出了归档文件或文件系统镜像中包含的文件、目录、设备节点和链接。其显著优势是，它允许你创建由`root`用户或任何其他UID拥有的归档文件条目，而你自己不需要拥有`root`权限。你甚至可以在不需要`root`权限的情况下创建设备节点。所有这一切之所以可行，是因为归档文件只是一个数据文件，只有在Linux启动时展开时，才会使用你指定的属性创建实际的文件和目录。'
- en: The kernel has a feature that allows us to use a device table when creating
    an `initramfs`. You write the device table file and then point `CONFIG_INITRAMFS_SOURCE`
    at it. Then, when you build the kernel, it creates the cpio archive from the instructions
    in the device table. At no point do you need `root` access.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 内核有一个功能，允许我们在创建`initramfs`时使用设备表。你编写设备表文件后，再将`CONFIG_INITRAMFS_SOURCE`指向它。然后，当你构建内核时，它会根据设备表中的指令创建cpio归档文件。整个过程你都不需要`root`访问权限。
- en: 'Here is a device table for our simple root filesystem. To make it manageable,
    it is missing most of the symbolic links to BusyBox:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们简单根文件系统的设备表。为了便于管理，它缺少大部分指向BusyBox的符号链接：
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The syntax is fairly obvious:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 语法非常直观：
- en: '`dir <name> <mode> <uid> <gid>`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir <name> <mode> <uid> <gid>`'
- en: '`file <name> <location> <mode> <uid> <gid>`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file <name> <location> <mode> <uid> <gid>`'
- en: '`nod <name> <mode> <uid> <gid> <dev_type> <maj> <min>`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nod <name> <mode> <uid> <gid> <dev_type> <maj> <min>`'
- en: '`slink <name> <target> <mode> <uid> <gid>`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slink <name> <target> <mode> <uid> <gid>`'
- en: The commands `dir`, `nod`, and `slink` create a filesystem object in the cpio
    archive with the name, mode, user ID, and group ID given. The `file` command copies
    the file from the source location into the archive and sets the mode, user ID,
    and group ID.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`dir`、`nod`和`slink`在cpio归档中创建一个文件系统对象，包含给定的名称、模式、用户ID和组ID。`file`命令将文件从源位置复制到归档中，并设置模式、用户ID和组ID。
- en: The task of creating an `initramfs`.`cpio` archive from scratch is made easier
    by a script found in the kernel source code, named `gen_initramfs.sh`. First,
    this script generates a device table from the contents of the input directory.
    Then, it translates this device table into the finished cpio archive.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 从头创建`initramfs.cpio`归档的任务，通过内核源代码中的一个脚本`gen_initramfs.sh`变得更加简单。首先，这个脚本从输入目录的内容生成一个设备表。然后，它将这个设备表转换成最终的cpio归档。
- en: 'To generate an `initramfs.cpio` archive from your `rootfs` directory and change
    the ownership of all files owned by user ID `1000` and group ID `1000` to user
    ID `0` and group ID `0`, enter these commands:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`rootfs`目录生成`initramfs.cpio`归档，并将所有由用户ID`1000`和组ID`1000`拥有的文件的所有权更改为用户ID`0`和组ID`0`，请输入以下命令：
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Old initrd format
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧版initrd格式
- en: There is an older format for a Linux ramdisk known as `initrd`. It was the only
    format available before Linux 2.6 and is still needed if you are using uClinux,
    the MMU-less variant of Linux. It is pretty obscure, so I will not cover it here.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种较旧的Linux ramdisk格式，称为`initrd`。它是Linux 2.6之前唯一可用的格式，如果你使用的是uClinux（没有MMU的Linux变种），仍然需要这种格式。它相当晦涩，因此我不会在这里介绍。
- en: Once our `initramfs` boots, the system then needs to start running programs.
    The first program that runs is the `init` program.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的`initramfs`启动，系统需要开始运行程序。首先运行的程序是`init`程序。
- en: init program
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: init程序
- en: Running a shell or even a shell script at boot time is fine for simple cases,
    but really, you need something more flexible. Normally, Unix systems run a program
    called `init` that starts up and monitors other programs. Over the years, there
    have been many `init` programs, some of which I will describe in [*Chapter 13*](Chapter_13.xhtml#_idTextAnchor431).
    For now, I will briefly introduce BusyBox `init`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时运行一个shell或甚至是一个shell脚本对于简单的情况是可以的，但实际上，你需要更灵活的东西。通常，Unix系统运行一个叫做`init`的程序，它负责启动和监控其他程序。多年来，有许多`init`程序，其中一些我将在[*第13章*](Chapter_13.xhtml#_idTextAnchor431)中描述。目前，我将简要介绍BusyBox的`init`。
- en: 'The `init` program begins by reading the `/etc/inittab` configuration file.
    Here is a simple example, which is adequate for our needs:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`程序首先读取`/etc/inittab`配置文件。这里是一个简单的例子，足以满足我们的需求：'
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first line runs a shell script named `rcS` when `init` is started. The second
    line prints the message **Please press Enter to activate this console** to the
    console and starts a shell when you press *Enter*. The leading `-` before `/bin/ash`
    means that it will become a login shell, which sources `/etc/profile` and `$HOME/.profile`
    before displaying the shell prompt.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行在`init`启动时运行一个名为`rcS`的shell脚本。第二行将消息**Please press Enter to activate this
    console**打印到控制台，并在按下*Enter*后启动一个shell。`/bin/ash`前的连字符`-`意味着它将成为一个登录shell，在显示shell提示符之前，首先会读取`/etc/profile`和`$HOME/.profile`。
- en: One of the advantages of launching the shell like this is that job control is
    enabled. The most immediate effect is that you can use *Ctrl + C* to terminate
    the current program. Maybe you didn’t notice it before, but wait until you run
    the `ping` program and find you can’t stop it!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式启动shell的一个优势是启用了作业控制。最直接的效果是，你可以使用*Ctrl + C*终止当前程序。也许你之前没注意到这一点，但等你运行`ping`程序时，你会发现你无法停止它！
- en: BusyBox `init` provides a default `inittab` if none is present in the root filesystem.
    It is a little more extensive than the preceding one.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果根文件系统中没有`inittab`，BusyBox的`init`会提供一个默认的`inittab`。它比前面的那个稍微复杂一些。
- en: 'The script called `/etc/init.d/rcS` is the place to put initialization commands
    that need to be performed at boot, like mounting the `proc` and `sysfs` filesystems:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本`/etc/init.d/rcS`是放置需要在启动时执行的初始化命令的地方，例如挂载`proc`和`sysfs`文件系统：
- en: '[PRE35]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Make sure that you make the preceding `rcS` script executable like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你像这样使前面的`rcS`脚本可执行：
- en: '[PRE36]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can try `init` out on QEMU by changing the `-append` parameter like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过更改`-append`参数来尝试在QEMU上运行`init`，像这样：
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For the BeaglePlay, you need to set the `bootargs` variable in U-Boot as shown
    here:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于BeaglePlay，你需要在U-Boot中设置`bootargs`变量，如下所示：
- en: '[PRE38]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, let’s take a closer look at the `inittab` read by `init` during startup.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们仔细看看`init`在启动时读取的`inittab`。
- en: Starting a daemon process
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动守护进程
- en: Typically, you want to run certain background processes at startup. Take `syslogd`
    (the log daemon), for example. The purpose of `syslogd` is to accumulate log messages
    from other programs, mostly other daemons. Naturally, BusyBox has an applet for
    that!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你希望在启动时运行某些后台进程。例如，`syslogd`（日志守护进程）。`syslogd`的目的是收集来自其他程序，主要是其他守护进程的日志信息。自然，BusyBox为此提供了一个小程序！
- en: 'Starting the daemon is as simple as adding a line like this to `etc/inittab`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 启动守护进程的方法很简单，只需在`etc/inittab`中添加一行，如下所示：
- en: '[PRE39]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`respawn` means that if the program terminates, it will be automatically restarted.
    `-n` means that it should run as a foreground process. The log is written to `/var/log/messages`.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`respawn`意味着如果程序终止，它将被自动重启。`-n`表示它应作为前台进程运行。日志写入`/var/log/messages`。'
- en: '**IMPORTANT NOTE**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: You may also want to start `klogd` in the same way. `klogd` sends kernel log
    messages to `syslogd` so that they can be logged to permanent storage.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想以相同的方式启动`klogd`。`klogd`将内核日志信息发送到`syslogd`，以便它们能够被记录到永久存储中。
- en: So far, all the processes I have mentioned run as `root`, but that is less than
    ideal.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我提到的所有进程都以`root`身份运行，但这并不是理想的做法。
- en: Configuring user accounts
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置用户账户
- en: As I already said, it is bad practice to run all programs as `root` because
    if one program is compromised by an outside attack then the whole system is at
    risk. It is better to create unprivileged user accounts and use them where full
    `root` is not necessary.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，将所有程序都以`root`身份运行并不是一个好习惯，因为如果其中一个程序被外部攻击破坏，那么整个系统都会面临风险。最好创建没有特权的用户账户，并在不需要完整`root`权限的地方使用它们。
- en: 'Usernames are configured in `/etc/passwd`. There is one line per user with
    seven fields of information separated by colons. These are, in order:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名配置在`/etc/passwd`中。每个用户有一行，其中包含七个由冒号分隔的信息字段。它们的顺序是：
- en: The login name
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录名
- en: The hash code used to verify the password or, more usually, an `x` to indicate
    that the password is stored in `/etc/shadow`
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于验证密码的哈希码，或更常见的是`x`，表示密码存储在`/etc/shadow`中
- en: The UID or user ID
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UID或用户ID
- en: The GID or group ID
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GID或组ID
- en: The comment field (often left blank)
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释字段（通常留空）
- en: The user’s home directory
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的主目录
- en: The shell this user will use (optional)
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将使用的shell（可选）
- en: 'Here is a simple example in which we have the user `root` with UID 0 and the
    user `daemon` with UID 1:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的示例，其中我们有`root`用户，UID为0，以及`daemon`用户，UID为1：
- en: '[PRE40]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Setting the shell for the user `daemon` as `/bin/false` ensures that any attempt
    to log on with that name will fail.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户`daemon`的shell设置为`/bin/false`，确保任何尝试使用该用户名登录的行为都会失败。
- en: Various programs have to read `/etc/passwd` to look up usernames and UIDs, so
    the file has to be world-readable. This is a problem if the password hashes are
    stored in there as well because a malicious program can take a copy and discover
    the actual passwords, using a variety of cracker programs. To reduce the exposure
    of this sensitive information, the passwords are stored in `/etc/shadow`, and
    `x` is placed in the password field to indicate that this is the case. The `/etc/shadow`
    file only needs to be accessed by `root`, so as long as the `root` user is not
    compromised, the passwords are safe.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 各种程序需要读取`/etc/passwd`以查找用户名和UID，因此该文件必须是全局可读的。如果密码哈希也存储在其中，就会产生问题，因为恶意程序可以复制该文件并通过各种破解程序发现实际的密码。为了减少敏感信息的暴露，密码存储在`/etc/shadow`中，并在密码字段中放置`x`，以表示这是情况。`/etc/shadow`文件只需要`root`访问，因此只要`root`用户没有被破坏，密码就会是安全的。
- en: 'The shadow password file consists of one entry per user, made up of nine fields.
    Here is an example that mirrors the password file shown in the preceding paragraph:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: shadow密码文件包含每个用户的一个条目，由九个字段组成。以下是一个示例，镜像了前面提到的密码文件：
- en: '[PRE41]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first two fields are the username and the password hash. The remaining seven
    fields are related to password aging, which is usually not a concern on embedded
    devices. If you are curious about the full details, refer to the manual page for
    `shadow(5)`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个字段是用户名和密码哈希。其余的七个字段与密码老化有关，这在嵌入式设备上通常不需要关注。如果你对详细信息感兴趣，可以参考`shadow(5)`的手册页。
- en: In the example, the password for `root` is empty meaning that `root` can log
    on without providing a password. Having an empty password for `root` is useful
    during development but not for production. You can generate or change a password
    hash by running the `passwd` command on the target, which will write a new hash
    to `/etc/shadow`. If you want all subsequent root filesystems to have this same
    password, you could copy this file back to the staging directory.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`root` 的密码为空，意味着 `root` 可以在不输入密码的情况下登录。为 `root` 设置空密码在开发过程中非常有用，但不适合生产环境。你可以通过在目标设备上运行
    `passwd` 命令来生成或更改密码哈希，它将把新的哈希写入 `/etc/shadow`。如果你希望所有后续的根文件系统使用相同的密码，你可以将这个文件复制回暂存目录。
- en: 'Group names are stored similarly in `/etc/group`. There is one line per group,
    consisting of four fields separated by colons. The fields are:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 组名类似地存储在 `/etc/group` 中。每个组占一行，由四个字段组成，字段之间用冒号分隔。字段包括：
- en: The name of the group
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组名
- en: The group password or, more usually, an `x` to indicate that there is no group
    password
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组密码，或者通常是一个 `x`，表示没有组密码
- en: The GID or group ID
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GID 或者组 ID
- en: A comma-separated list of users who belong to this group (optional)
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属于该组的用户的逗号分隔列表（可选）
- en: 'Here is an example:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE42]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Adding user accounts to the root filesystem
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向根文件系统添加用户帐户
- en: 'First, add the files `etc/passwd`, `etc/shadow`, and `etc/group` to your staging
    directory, as shown in the preceding section. Make sure that the permissions of
    `etc/shadow` are `0600`. Next, initiate the login procedure by starting a program
    called `getty`. There is a version of `getty` in BusyBox. You launch it from your
    `inittab` using the keyword `respawn`, which restarts `getty` when a login shell
    is terminated. Your `inittab` should read like this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `etc/passwd`、`etc/shadow` 和 `etc/group` 文件添加到你的暂存目录，如前面部分所示。确保 `etc/shadow`
    的权限是 `0600`。接下来，通过启动名为 `getty` 的程序来启动登录过程。BusyBox 中有一个 `getty` 版本，你可以通过在 `inittab`
    文件中使用 `respawn` 关键字来启动它，`getty` 会在登录 shell 终止时重新启动。你的 `inittab` 文件应如下所示：
- en: '[PRE43]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Then, rebuild the ramdisk, and try it out using QEMU or the BeaglePlay, as before.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新构建 ramdisk，并像之前一样使用 QEMU 或 BeaglePlay 进行测试。
- en: Earlier in this chapter, we learned how to create device nodes using the `mknod`
    command. Now, let’s look at some easier ways to create device nodes.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们学习了如何使用 `mknod` 命令创建设备节点。现在，让我们来看一些更简单的创建设备节点的方法。
- en: A better way of managing device nodes
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的设备节点管理方式
- en: 'Creating device nodes statically with `mknod` is hard work and inflexible.
    However, there are other ways to create device nodes automatically on demand:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `mknod` 静态地创建设备节点既困难又不灵活。然而，还有其他方法可以根据需求自动创建设备节点：
- en: '`devtmpfs`: This is a pseudo filesystem that you mount over `/dev` at boot
    time. The kernel populates it with device nodes for all the devices that the kernel
    currently knows about. The kernel also creates nodes for new devices as they are
    detected at runtime. The nodes are owned by `root` and have default permissions
    of `0600`. Some well-known device nodes, such as `/dev/null` and `/dev/random`,
    override the default to `0666`. To see exactly how this is done, look at the `drivers/char/mem.c`
    file in the Linux source tree and observe how `struct memdev` is initialized.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devtmpfs`：这是一种伪文件系统，你在启动时将其挂载到 `/dev` 上。内核会将其填充为内核当前已知的所有设备的设备节点。内核还会为运行时检测到的新设备创建节点。这些节点由
    `root` 拥有，默认权限为 `0600`。一些知名的设备节点，如 `/dev/null` 和 `/dev/random`，会将默认权限覆盖为 `0666`。要查看如何做到这一点，可以查看
    Linux 源码树中的 `drivers/char/mem.c` 文件，观察 `struct memdev` 如何被初始化。'
- en: '`mdev`: This is a BusyBox applet that is used to populate a directory with
    device nodes and create new nodes as needed. There is an `/etc/mdev.conf` configuration
    file that contains rules for the ownership and mode of the nodes.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mdev`：这是一个 BusyBox 小程序，用于填充目录并根据需要创建设备节点。它有一个 `/etc/mdev.conf` 配置文件，其中包含有关节点的所有权和模式的规则。'
- en: '`udev`: This is the mainstream equivalent of `mdev`. You will find it on desktop
    Linux and in some embedded devices. It is very flexible and a good choice for
    higher-end embedded devices. It is now part of `systemd`.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`udev`：这是 `mdev` 的主流等效版本。你会在桌面 Linux 和一些嵌入式设备上找到它。它非常灵活，并且适用于高端嵌入式设备。它现在是 `systemd`
    的一部分。'
- en: '**IMPORTANT NOTE**'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Although both `mdev` and `udev` create the device nodes themselves, it is easier
    to just let `devtmpfs` do the job and use `mdev/udev` as a layer on top to implement
    the policy for setting ownership and permissions. The `devtmpfs` approach is the
    only maintainable way to generate device nodes prior to user space startup.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管`mdev`和`udev`都会创建设备节点，但让`devtmpfs`来做这项工作，并使用`mdev/udev`作为上层实现设置所有权和权限的策略会更简单。`devtmpfs`的方法是生成用户空间启动前设备节点的唯一可维护方式。
- en: After introducing `devtmpfs`, I will describe how `mdev` is used to assign ownership
    and permissions to device nodes on startup.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍`devtmpfs`之后，我将描述如何使用`mdev`在启动时分配设备节点的所有权和权限。
- en: Using devtmpfs
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用devtmpfs
- en: Support for the `devtmpfs` filesystem is controlled by the `CONFIG_DEVTMPFS`
    kernel configuration variable. It is not enabled in the default configuration
    of the 64-bit Arm generic virtual platform, so if you want to try `devtmpfs` out
    on QEMU, you will have to go back to your kernel configuration and enable this
    option.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`devtmpfs`文件系统的支持由`CONFIG_DEVTMPFS`内核配置变量控制。它在64位Arm通用虚拟平台的默认配置中没有启用，因此如果你想在QEMU上尝试`devtmpfs`，你需要返回内核配置并启用此选项。'
- en: 'Enter this command to mount `devtmpfs`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 输入此命令以挂载`devtmpfs`：
- en: '[PRE44]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You will notice that there are many more device nodes in `/dev` afterward.
    To mount `devtmpfs` on startup, add the preceding command to `/etc/init.d/rcS`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到之后`/dev`中有更多的设备节点。要在启动时挂载`devtmpfs`，将上述命令添加到`/etc/init.d/rcS`：
- en: '[PRE45]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you enable `CONFIG_DEVTMPFS_MOUNT` in your kernel configuration, the kernel
    will automatically mount `devtmpfs` just after mounting the root filesystem. However,
    this option has no effect when booting `initramfs`, as we are doing here.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在内核配置中启用了`CONFIG_DEVTMPFS_MOUNT`，内核将在挂载根文件系统之后自动挂载`devtmpfs`。然而，当启动`initramfs`时，这个选项不起作用，就像我们在这里所做的那样。
- en: Using mdev
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用mdev
- en: While `mdev` is a bit more complex to set up, it does allow you to modify the
    permissions of device nodes as they are created. You begin by running `mdev` with
    the `-s` option, which causes it to scan the `/sys` directory looking for information
    about current devices. From this information, it populates the `/dev` directory
    with the corresponding nodes.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`mdev`的设置稍微复杂一些，但它确实允许你在设备节点创建时修改它们的权限。你可以通过运行带有`-s`选项的`mdev`来开始，这将导致它扫描`/sys`目录，查找当前设备的信息。根据这些信息，它会将相应的节点填充到`/dev`目录中。
- en: 'If you want to keep track of new devices coming online and create nodes for
    them as well, you need to make `mdev` a hot plug client by writing to `/proc/sys/kernel/hotplug`.
    Add two more lines to `/etc/init.d/rcS`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟踪新设备的上线并为它们创建节点，你需要通过写入`/proc/sys/kernel/hotplug`来使`mdev`成为一个热插拔客户端。将以下两行添加到`/etc/init.d/rcS`：
- en: '[PRE46]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The default mode is `660` and the ownership is `root:root`. You can change
    this by adding rules in `/etc/mdev.conf`. For example, to give the `null`, `random`,
    and `urandom` devices their correct modes, you would add this to `/etc/mdev.conf`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模式是`660`，所有权是`root:root`。你可以通过在`/etc/mdev.conf`中添加规则来更改此设置。例如，为了给`null`、`random`和`urandom`设备设置正确的模式，你可以将以下内容添加到`/etc/mdev.conf`：
- en: '[PRE47]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The format is documented in the BusyBox source code in `docs/mdev.txt`, and
    there are more examples in the directory named `examples`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 格式在BusyBox源代码中的`docs/mdev.txt`中有文档说明，`examples`目录中还有更多示例。
- en: Are static device nodes so bad after all?
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态设备节点到底有那么糟糕吗？
- en: 'Statically created device nodes have one advantage over running a device manager:
    they don’t take any time to create during boot. If minimizing boot time is a priority,
    then using statically created device nodes will save a measurable amount of time.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 静态创建的设备节点相比于运行设备管理器有一个优势：它们在启动时不需要任何时间来创建。如果最小化启动时间是一个优先考虑的目标，那么使用静态创建的设备节点将节省可测量的时间。
- en: Configuring the network
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置网络
- en: Next, let’s look at some basic network configurations so that we can communicate
    with the outside world. I assume that there is an Ethernet interface (`eth0`)
    and that we only need a simple IPv4 configuration.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一些基本的网络配置，以便我们能够与外界通信。我假设有一个以太网接口（`eth0`），并且我们只需要一个简单的IPv4配置。
- en: 'These examples use the network utilities that are part of BusyBox, which are
    sufficient for our simple use case. All we need are the old-but-reliable `ifup`
    and `ifdown` programs. You can read the manual pages for both to get the details.
    The main network configuration is stored in `/etc/network/interfaces`. You will
    need to create these directories in the staging directory:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例使用了 BusyBox 中的网络工具，这些工具足以满足我们的简单用例。我们需要的只是那些老旧但可靠的`ifup`和`ifdown`程序。你可以查看这两个程序的手册页以获取详细信息。主要的网络配置存储在`/etc/network/interfaces`中。你需要在临时目录中创建这些目录：
- en: '[PRE48]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here is `/etc/network/interfaces` for a static IP address:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于静态 IP 地址的`/etc/network/interfaces`：
- en: '[PRE49]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here is `/etc/network/interfaces` for a dynamic IP address, allocated using
    DHCP:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于动态 IP 地址的`/etc/network/interfaces`，通过 DHCP 分配：
- en: '[PRE50]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You also need to configure a DHCP client program. BusyBox has one named `udchpcd`.
    It requires a shell script that goes in `/usr/share/udhcpc/default.script`. There
    is a suitable default at `examples/udhcp/simple.script` within the BusyBox source
    code.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要配置一个 DHCP 客户端程序。BusyBox 提供了一个名为`udchpcd`的程序。它需要一个 shell 脚本，该脚本位于`/usr/share/udhcpc/default.script`。在
    BusyBox 源代码的`examples/udhcp/simple.script`中有一个适当的默认脚本。
- en: Network components for glibc
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: glibc 的网络组件
- en: 'glibc uses a mechanism known as the **name service switch** (**NSS**) to control
    the way that names are resolved to numbers for networking and users. Usernames
    can be resolved to UIDs via the `/etc/passwd` file, and network services such
    as HTTP can be resolved to service port numbers via `/etc/services`. All this
    is configured by `/etc/nsswitch.conf`; see the `nss(5)` manual page for full details.
    Here is a simple example that will suffice for most embedded Linux implementations:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: glibc 使用一种称为**名称服务切换**（**NSS**）的机制来控制名称解析为数字的方式，以便进行网络和用户管理。用户名可以通过`/etc/passwd`文件解析为
    UID，网络服务（如 HTTP）可以通过`/etc/services`解析为服务端口号。所有这些都由`/etc/nsswitch.conf`配置；详细信息请参见`nss(5)`手册页。以下是一个适用于大多数嵌入式
    Linux 实现的简单示例：
- en: '[PRE51]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Everything is resolved by the correspondingly named file in `/etc`, except for
    host names, which can be resolved by a DNS lookup if they are not in `/etc/hosts`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都由`/etc`中相应命名的文件解析，除了主机名，如果它们不在`/etc/hosts`中，则可以通过 DNS 查找解析。
- en: 'To make this work, you need to populate `/etc` with those files. Networks,
    protocols, and services are the same across all Linux systems, so they can be
    copied from `/etc` on your development machine. At the very least, `/etc/hosts`
    should contain the loopback address:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其正常工作，你需要将这些文件填充到`/etc`目录中。网络、协议和服务在所有 Linux 系统中都是相同的，因此它们可以从开发机上的`/etc`复制过来。至少，`/etc/hosts`应包含回环地址：
- en: '[PRE52]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The other files (`passwd`, `group`, and `shadow`) were described in the *Configuring
    user accounts* section earlier.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 其他文件（`passwd`、`group`和`shadow`）在之前的*配置用户账户*部分中已有描述。
- en: 'The last piece of the puzzle is the libraries that perform the name resolution.
    They are plugins that are loaded as needed, based on the contents of `nsswitch.conf`.
    That means they do not show up as dependencies when you use `readelf` or `ldd`.
    You will simply have to copy them from the toolchain’s `sysroot`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 拼图的最后一块是执行名称解析的库。它们是按需加载的插件，基于`nsswitch.conf`的内容。这意味着当你使用`readelf`或`ldd`时，它们不会显示为依赖项。你只需要从工具链的`sysroot`中复制它们：
- en: '[PRE53]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: At last, our staging directory is complete. Let’s generate a filesystem from
    it.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的临时目录已经完成。让我们从中生成文件系统。
- en: Creating filesystem images with device tables
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设备表创建文件系统映像
- en: 'We saw in the earlier *Creating a boot initramfs* section that the kernel has
    the option to create `initramfs`, using a device table. Device tables are really
    useful because they allow a non-root user to create device nodes and allocate
    arbitrary UID and GID values to any file or directory. The same concept has been
    applied to tools that create other filesystem image formats, as shown in this
    mapping from the filesystem format to tool:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的*创建引导 initramfs*部分中看到，内核可以选择使用设备表来创建`initramfs`。设备表非常有用，因为它允许非 root 用户创建设备节点，并为任何文件或目录分配任意的
    UID 和 GID 值。相同的概念已经应用于创建其他文件系统映像格式的工具，如下所示，映射从文件系统格式到工具：
- en: '**jffs2**: `mkfs.jffs2`'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jffs2**: `mkfs.jffs2`'
- en: '**ubifs**: `mkfs:ubifs`'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ubifs**: `mkfs:ubifs`'
- en: '**ext2**: `genext2fs`'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ext2**: `genext2fs`'
- en: We will cover jffs2 and ubifs in [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor293),
    when we look at filesystems for flash memory. ext2 is a format commonly used for
    managed flash memory, including SD cards. The example that follows uses ext2 to
    create a disk image that can be copied to an SD card.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 9 章*](Chapter_09.xhtml#_idTextAnchor293) 中介绍 jffs2 和 ubifs，届时我们将讨论用于闪存的文件系统。ext2
    是一种常用于托管闪存的格式，包括 SD 卡。以下示例使用 ext2 创建一个可以复制到 SD 卡的磁盘镜像。
- en: 'To begin with, you need to install the `genext2fs` tool on your host. On Ubuntu,
    the package to install is named `genext2fs`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在主机上安装 `genext2fs` 工具。在 Ubuntu 上，安装的软件包名为 `genext2fs`：
- en: '[PRE54]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`genext2fs` takes a device table file with the format `<name> <type> <mode>
    <uid> <gid> <major> <minor> <start> <inc> <count>`. The meanings of the fields
    are as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`genext2fs` 使用设备表文件，格式为 `<name> <type> <mode> <uid> <gid> <major> <minor> <start>
    <inc> <count>`。各字段的含义如下：'
- en: '**name**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name**'
- en: '**type**: one of the following:'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**type**: 下面的某个类型：'
- en: '`f`: regular file'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`: 常规文件'
- en: '`d`: directory'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`: 目录'
- en: '`c`: character device file'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`: 字符设备文件'
- en: '`b`: block device file'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`: 块设备文件'
- en: '`p`: FIFO (named pipe)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p`: FIFO（命名管道）'
- en: '**uid**: UID of the file'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**uid**: 文件的 UID'
- en: '**gid**: GID of the file'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gid**: 文件的 GID'
- en: '**major** and **minor**: device numbers (device nodes only)'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**major** 和 **minor**: 设备编号（仅适用于设备节点）'
- en: '**start**, **inc**, and **count**: allows you to create a group of device nodes
    starting from the minor number in start (device nodes only)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**start**, **inc** 和 **count**: 允许你从 start 中的次要编号开始创建一组设备节点（仅适用于设备节点）'
- en: You do not have to specify these for every file as you do with the kernel `initramfs`
    table. You just need to point at a directory—the staging directory—and list the
    changes and exceptions you need to make in the final filesystem image.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像处理内核 `initramfs` 表那样为每个文件指定这些，只需要指向一个目录——暂存目录——并列出你需要在最终文件系统镜像中做出的更改和例外。
- en: 'Here is a simple example that populates static device nodes for us:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的示例，它为我们填充了静态设备节点：
- en: '[PRE55]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, you can use `genext2fs` to generate a filesystem image of 8 MB (8,192
    blocks of the default size, 1,024 bytes):'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 `genext2fs` 生成一个 8 MB 的文件系统镜像（默认大小为 1,024 字节的 8,192 块）：
- en: '[PRE56]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, you can copy the resulting `rootfs.ext2` image to an SD card or similar,
    as we will do next.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将生成的 `rootfs.ext2` 镜像复制到 SD 卡或类似设备上，正如我们接下来的操作一样。
- en: Booting the BeaglePlay
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动 BeaglePlay
- en: 'The script named `MELD/format-sdcard.sh` creates two partitions on the microSD
    card: one for the boot files and one for the root filesystem. Assuming you have
    created the root filesystem image, as shown in the previous section, you can use
    the `dd` command to write it to the second partition.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 名为 `MELD/format-sdcard.sh` 的脚本在 microSD 卡上创建了两个分区：一个用于启动文件，另一个用于根文件系统。假设你已经按照上一节所示创建了根文件系统镜像，你可以使用
    `dd` 命令将其写入第二个分区。
- en: '**IMPORTANT NOTE**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: As always, when copying files directly to storage devices like this, make absolutely
    sure that you know which device is the microSD card.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，当像这样将文件直接复制到存储设备时，务必确认你知道哪个设备是 microSD 卡。
- en: 'In this case, I am using a built-in card reader, which is the device called
    `/dev/mmcblk0`, so the command is:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我使用的是内建的读卡器，该设备名为 `/dev/mmcblk0`，因此命令是：
- en: '[PRE57]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that the card reader on your host system may have a different name.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，主机系统上的读卡器可能有不同的名称。
- en: 'Insert the microSD card into the BeaglePlay and set the kernel command line
    to `root=/dev/mmcblk1p2`. Unlike previous Beagles, the eMMC is the `mmcblk0` device
    and the microSD is the `mmcblk1` device on the BeaglePlay. Here is the complete
    sequence of U-Boot commands:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 将 microSD 卡插入 BeaglePlay，并设置内核命令行为 `root=/dev/mmcblk1p2`。与之前的 Beagle 不同，BeaglePlay
    上的 eMMC 是 `mmcblk0` 设备，而 microSD 是 `mmcblk1` 设备。以下是完整的 U-Boot 命令序列：
- en: '[PRE58]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is an example of mounting an ext2 filesystem from a normal block device,
    such as an SD card. The same principles apply to other filesystem types. We will
    look at these in more detail when we get to [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor293).
    Now, let’s switch gears and look at how to mount a filesystem over a network.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从普通块设备（如 SD 卡）挂载 ext2 文件系统的示例。相同的原则也适用于其他类型的文件系统。我们将在 [*第 9 章*](Chapter_09.xhtml#_idTextAnchor293)中更详细地讨论这些内容。现在，让我们转变思路，看看如何通过网络挂载文件系统。
- en: Mounting the root filesystem using NFS
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NFS 挂载根文件系统
- en: If your device has a network interface, you can mount the root filesystem over
    the network for rapid development using **Network File System** (**NFS**). This
    gives you access to almost unlimited storage on your host machine, so you can
    add debug tools and executables with large symbol tables. As a bonus, updates
    made to the root filesystem on your development machine are available on the target
    instantly. You can also access all the target’s log files from the host.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的设备有网络接口，您可以通过**网络文件系统**（**NFS**）通过网络挂载根文件系统，以加速开发。这使您可以访问主机机器几乎无限的存储空间，因此您可以添加调试工具和具有大型符号表的可执行文件。作为附加福利，开发机器上对根文件系统的更新会立即反映在目标上。您还可以从主机访问目标的所有日志文件。
- en: 'To start, you need to install and configure an NFS server on your host machine.
    The package to install on Ubuntu is named `nfs-kernel-server`:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要在主机机器上安装并配置 NFS 服务器。在 Ubuntu 上安装的包名为 `nfs-kernel-server`：
- en: '[PRE59]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The NFS server needs to be told which directories are being exported to the
    network. This is controlled by `/etc/exports`. There is one line for each export.
    The format is described in the `exports(5)` manual page. To export the root filesystem,
    the `exports` file on my host contains this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: NFS 服务器需要知道哪些目录被导出到网络。这由 `/etc/exports` 文件控制。每个导出都有一行，格式在 `exports(5)` 手册页中描述。要导出根文件系统，我主机上的
    `exports` 文件包含以下内容：
- en: '[PRE60]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`*` exports the directory to any address on my local network. If you wish,
    you can specify a single IP address or a range at this point. A list of options
    enclosed in parentheses follows. There must not be any spaces between `*` and
    the opening parenthesis. The options are:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 将目录导出到我的本地网络上的任何地址。如果需要，您可以在此时指定一个单一的 IP 地址或一个地址范围。后面跟着一系列括号内的选项。`*` 和开括号之间不能有任何空格。选项如下：'
- en: '`rw`: Exports the directory as read-write.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw`: 将目录导出为读写模式。'
- en: '`sync`: Selects the synchronous version of the NFS protocol, which is more
    robust but a little slower than the async option.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync`: 选择 NFS 协议的同步版本，它比异步版本更稳健，但速度稍慢。'
- en: '`no_subtree_check`: Disables subtree checking, which has mild security implications
    but can improve reliability in some circumstances.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no_subtree_check`: 禁用子树检查，这对安全性有轻微影响，但在某些情况下可以提高可靠性。'
- en: '`no_root_squash`: Allows requests from user ID 0 to be processed without squashing
    to a different user ID. It is necessary for the target to correctly access the
    files owned by `root`.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no_root_squash`: 允许来自用户 ID 0 的请求在不压缩为其他用户 ID 的情况下处理。这对于目标正确访问 `root` 拥有的文件是必要的。'
- en: 'Having made changes to `/etc/exports`, restart the NFS server to pick them
    up:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `/etc/exports` 后，重启 NFS 服务器以使更改生效：
- en: '[PRE61]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, set up the target to mount the root filesystem over NFS. For this to work,
    configure your kernel with `CONFIG_ROOT_NFS`. Then, configure Linux to do the
    mount at boot time by adding the following to the kernel command line:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，设置目标以通过 NFS 挂载根文件系统。为了使其生效，请在配置内核时启用 `CONFIG_ROOT_NFS`。然后，通过将以下内容添加到内核命令行来配置
    Linux 在启动时进行挂载：
- en: '[PRE62]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The options are:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 选项如下：
- en: '`rw`: Mounts the root filesystem read-write.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw`: 以读写模式挂载根文件系统。'
- en: '`nfsroot`: Specifies the IP address of the host, followed by the path to the
    exported root filesystem.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nfsroot`: 指定主机的 IP 地址，后跟导出根文件系统的路径。'
- en: '`ip`: This is the IP address to be assigned to the target. Usually, network
    addresses are assigned at runtime, as we saw in the *Configuring the network*
    section. However, in this case, the interface has to be configured before the
    root filesystem is mounted and `init` has started. Hence, it is configured on
    the kernel command line.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ip`: 这是将分配给目标的 IP 地址。通常，网络地址在运行时分配，就像我们在*配置网络*部分看到的那样。然而，在这种情况下，接口必须在根文件系统挂载并且
    `init` 启动之前进行配置。因此，它是在内核命令行中进行配置的。'
- en: '**IMPORTANT NOTE**'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: There is more information about NFS root mounts in the kernel source in `Documentation/admin-guide/nfs/nfsroot.rst`.
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关 NFS 根挂载的更多信息，请参阅内核源代码中的 `Documentation/admin-guide/nfs/nfsroot.rst`。
- en: Testing with the BeaglePlay
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 BeaglePlay 进行测试
- en: 'Boot your BeaglePlay from the microSD card and enter these commands at the
    U-Boot prompt:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 从 microSD 卡启动 BeaglePlay，并在 U-Boot 提示符下输入以下命令：
- en: '[PRE63]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Replace `<path to staging directory>` with the full path to your staging directory,
    and change the `serverip` and `ipaddr` values to match the IP addresses of your
    Linux host and BeaglePlay. Make sure that the BeaglePlay can ping the `serverip`
    before attempting this exercise.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `<path to staging directory>` 替换为你的临时目录的完整路径，并将 `serverip` 和 `ipaddr` 值修改为与
    Linux 主机和 BeaglePlay 的 IP 地址相匹配。确保 BeaglePlay 在进行此操作之前能够 ping 通 `serverip`。
- en: Problems with file permissions
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件权限问题
- en: The files that you copied into the staging directory will be owned by the UID
    of the user you are logged on as (typically `1000`). However, the target has no
    knowledge of this user. What’s more, any files created by the target will be owned
    by users configured by the target (often the root user). The whole thing is a
    mess. Unfortunately, there is no simple way out.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 你复制到临时目录中的文件将由你当前登录用户的 UID 所拥有（通常是 `1000`）。然而，目标设备并不知道这个用户。而且，目标创建的任何文件都将由目标设备配置的用户（通常是
    root 用户）拥有。整个情况非常混乱。不幸的是，这没有简单的解决办法。
- en: The best solution is to make a copy of the staging directory and change ownership
    to UID and GID to `0`, using the command `sudo chown -R 0:0 *`. Then, export this
    directory as the NFS mount. This removes the convenience of having just one copy
    of the root filesystem shared between development and target systems, but at least
    the file ownership will be correct.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳解决方案是创建临时目录的副本，并将所有权更改为 UID 和 GID 为 `0`，使用命令 `sudo chown -R 0:0 *`。然后，将该目录作为
    NFS 挂载进行导出。这虽然取消了在开发和目标系统之间共享根文件系统单一副本的便利性，但至少文件所有权将是正确的。
- en: It’s not uncommon in embedded Linux to link device drivers statically to the
    kernel, rather than load them dynamically from the root filesystem as modules
    at runtime. So how do we reap the same benefits of rapid iteration provided by
    NFS when modifying kernel source code or DTBs? The answer is TFTP.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式 Linux 中，通常将设备驱动程序静态链接到内核，而不是像模块一样在运行时从根文件系统动态加载它们。那么，如何在修改内核源代码或设备树二进制文件（DTBs）时获得
    NFS 提供的快速迭代好处呢？答案是 TFTP。
- en: Using TFTP to load the kernel
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TFTP 加载内核
- en: Now that we know how to mount the root filesystem over a network using NFS,
    you may be wondering if there is a way to load the kernel, device tree, and `initramfs`
    over the network as well. If we can do this, then the only component that needs
    to be written to storage on the target is the bootloader. Everything else could
    be loaded from the host machine. This would save time, since you would not need
    to keep reflashing the target. You could even get work done while the flash storage
    drivers are still being developed (it happens).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何通过网络使用 NFS 挂载根文件系统，你可能会想是否有办法通过网络加载内核、设备树和 `initramfs`。如果可以做到这一点，那么唯一需要写入目标存储的组件就是引导加载程序。其他一切都可以从主机加载。这将节省时间，因为你不需要反复刷新目标。即使在闪存存储驱动程序仍在开发中时，你也可以继续工作（这种情况发生过）。
- en: The **Trivial File Transfer Protocol** (**TFTP**) is the answer. TFTP is a very
    simple file transfer protocol that is designed for easy implementation with bootloaders
    such as U-Boot.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单文件传输协议**（**TFTP**）是解决方案。TFTP 是一种非常简单的文件传输协议，旨在与像 U-Boot 这样的引导加载程序易于实现。'
- en: 'To start, you need to install a TFTP daemon on your host machine. The package
    to install on Ubuntu is named `tftpd-hpa`:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在主机上安装 TFTP 守护进程。在 Ubuntu 上安装的包名为 `tftpd-hpa`：
- en: '[PRE64]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Modify the contents of `/etc/default/tftpd-hpa` as shown:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 按照如下所示修改 `/etc/default/tftpd-hpa` 的内容：
- en: '[PRE65]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create the `/var/lib/tftpboot` directory with the necessary ownership and permissions:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `/var/lib/tftpboot` 目录，并设置必要的所有权和权限：
- en: '[PRE66]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Having made changes to `/etc/default/tftpd-hpa`, restart the TFTP server to
    pick them up:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改了 `/etc/default/tftpd-hpa` 后，重启 TFTP 服务器以使其生效：
- en: '[PRE67]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'With `tftpd-hpa` installed and running, copy the files you want loaded on the
    target to `/var/lib/tftpboot`. For the BeaglePlay, these would be `Image` and
    `k3-am625-beagleplay.dtb`:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并运行 `tftpd-hpa` 后，将你希望加载到目标上的文件复制到 `/var/lib/tftpboot`。对于 BeaglePlay，这些文件将是
    `Image` 和 `k3-am625-beagleplay.dtb`：
- en: '[PRE68]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, enter these commands at the U-Boot prompt:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 U-Boot 提示符下输入以下命令：
- en: '[PRE69]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Replace `<path to staging directory>` with the full path to your staging directory,
    and change the `serverip` and `ipaddr` values to match the IP addresses of your
    Linux host and BeaglePlay. You may find that the `tftp` command hangs endlessly,
    printing out the letter `T`, which means that the TFTP requests time out. There
    are a number of reasons why this happens. The most common ones are:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 将`<path to staging directory>`替换为你的临时目录的完整路径，并将`serverip`和`ipaddr`值更改为与你的Linux主机和BeaglePlay的IP地址匹配。你可能会发现`
    tftp`命令会无限期挂起，打印字母`T`，这意味着TFTP请求超时。这种情况发生的原因有很多，最常见的原因是：
- en: An incorrect IP address for `serverip`
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serverip`的IP地址不正确'
- en: The TFTP daemon is not running on the server.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TFTP守护进程没有在服务器上运行。
- en: The firewall on the server is blocking the TFTP protocol. Most firewalls block
    TFTP port 69 by default.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器上的防火墙阻止了TFTP协议。大多数防火墙默认会阻止TFTP端口69。
- en: Once you have resolved the connectivity problem, U-Boot loads the files from
    the host machine and boots in the usual way.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你解决了连接问题，U-Boot将从主机加载文件并以常规方式启动。
- en: Summary
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: One of the strengths of Linux is that it supports a variety of root filesystems,
    so it can be tailored for a wide range of needs. We have seen how it is possible
    to construct a simple root filesystem manually with just a small number of components.
    BusyBox is especially useful in this regard.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的一个优点是它支持多种根文件系统，因此可以根据广泛的需求进行定制。我们已经看到，如何仅使用少量组件手动构建一个简单的根文件系统。BusyBox在这方面特别有用。
- en: By going through the process one step at a time, we gained insight into some
    of the basic workings of Linux systems, including network configuration and user
    accounts. However, the task rapidly becomes unmanageable as devices get more complex.
    Plus, there is the ever-present worry that there may be a security hole in the
    implementation that we did not notice.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一步步地执行这个过程，我们对Linux系统的一些基本工作原理有了了解，包括网络配置和用户账户。然而，随着设备变得越来越复杂，任务很快就变得难以管理。而且，始终存在一个担忧，那就是我们可能没有注意到实现中存在的安全漏洞。
- en: In the next chapter, I will show you how using an embedded build system can
    make the process of creating an embedded Linux system much easier and more reliable.
    I will start by looking at Buildroot and then go on to look at the more complex,
    yet powerful, Yocto Project.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将向你展示如何使用嵌入式构建系统使创建嵌入式Linux系统的过程变得更加简单和可靠。我将从Buildroot开始，然后再介绍更复杂但更强大的Yocto项目。
- en: Further study
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步学习
- en: '*Filesystem Hierarchy Standard, Version 3.0*: [https://refspecs.linuxfoundation.org/fhs.shtml](https://refspecs.linuxfoundation.org/fhs.shtml)'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件系统层次标准，版本3.0*：[https://refspecs.linuxfoundation.org/fhs.shtml](https://refspecs.linuxfoundation.org/fhs.shtml)'
- en: '*Ramfs, rootfs and initramfs*, by Rob Landley, part of the Linux source at
    [Documentation/filesystems/ramfs-rootfs-initramfs.rst](https://Documentation/filesystems/ramfs-rootfs-initramfs.rst)'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ramfs、rootfs和initramfs*，由Rob Landley编写，Linux源代码的一部分：[Documentation/filesystems/ramfs-rootfs-initramfs.rst](https://Documentation/filesystems/ramfs-rootfs-initramfs.rst)'
- en: Join our community on Discord
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们在Discord上的社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers: https://packt.link/embeddedsystems'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)
- en: '![](img/QR_Code12308107448340296.png)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code12308107448340296.png)'
