<html><head></head><body>
		<div id="_idContainer023">
			<h1 id="_idParaDest-14" class="chapter-number"><a id="_idTextAnchor013"/>1</h1>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Introduction to PowerShell 7 – What It Is and How to Get It</h1>
			<p>Quite simply, PowerShell is a time machine. Not a science-fiction time machine where you get to go back in time and meet your own grandfather, but a real, practical one. If you put in a small amount of time, then PowerShell, like any simple machine, will act as a force multiplier; it will produce very much more time for you. To use a metaphor, it’s a time hammer, and the hours you put into learning PowerShell will save you tens or hundreds of times as many hours once you start putting the knowledge <span class="No-Break">to use.</span></p>
			<p>This chapter is a general introduction to PowerShell 7. It’s going to give you some context about PowerShell and get you up and running. You’re going to learn what you can do with it and some typical use cases. We’ll be installing PowerShell, and you’ll get to choose one or more ways of doing that. Once we’ve got it installed, we’ll go through how you run commands (called <strong class="bold">cmdlets</strong>), and how you can find cmdlets to run. Finally, and quite importantly, we’ll work through how to get help, both with cmdlets and with PowerShell topics <span class="No-Break">and concepts.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>What is <span class="No-Break">PowerShell 7?</span></li>
				<li>What is PowerShell 7 <span class="No-Break">used for?</span></li>
				<li>Getting <span class="No-Break">PowerShell 7</span></li>
				<li>Running <span class="No-Break">PowerShell 7</span></li>
				<li><span class="No-Break">Getting help</span></li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Technical requirements</h1>
			<p>To follow along with this chapter, you will need an internet connection and an operating system. If you’re using Linux or macOS, the installation instructions can be found in <a href="B17600_14.xhtml#_idTextAnchor280"><span class="No-Break"><em class="italic">Chapter 14</em></span></a><em class="italic">,</em> <em class="italic">PowerShell 7 for Linux and macOS</em>, so skip the detailed installation instructions in the <em class="italic">How to get PowerShell 7 section</em>, in this chapter. </p>
			<p>This chapter assumes that you will be using Windows 10 (version 1709 or later) running on standard 64-bit x86 architecture. If you’re not sure whether that’s what you have, don’t worry, it probably is. If you are one of life’s worriers, go to the Windows search bar and type <strong class="source-inline">msinfo32</strong>, then press <em class="italic">Enter</em>. The <strong class="bold">System Information</strong> application will open, and under <strong class="bold">System Summary,</strong> there will be three <span class="No-Break">relevant lines:</span></p>
			<ul>
				<li><strong class="bold">OS Name</strong>: Hopefully <strong class="bold">Microsoft Windows 10</strong> of some flavor; PowerShell 7.3 is available on all currently supported versions <span class="No-Break">of Windows.</span></li>
				<li><strong class="bold">Version</strong>: You want a build number higher <span class="No-Break">than 16299.</span></li>
				<li><strong class="bold">System Type</strong>: Probably <span class="No-Break"><strong class="bold">x64-based PC</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>The following screenshot shows how it should look under <span class="No-Break"><strong class="bold">System Summary</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B17600_01_001.jpg" alt="Figure 1.1 – Typical information from the System Information application (msinfo32)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Typical information from the System Information application (msinfo32)</p>
			<p>If you’re using Windows 11, then good for you; you won’t need to do some of the things we’ll be talking about as Windows 11 comes with <span class="No-Break">some extras.</span></p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>What is PowerShell 7?</h1>
			<p><strong class="bold">PowerShell</strong> is a scripting language and an alternative<a id="_idIndexMarker000"/> to the command-line interface. PowerShell is an automation tool consisting of (at least) <span class="No-Break">three parts:</span></p>
			<ul>
				<li>A shell, like the Command Prompt in Windows or the Terminal in Linux <span class="No-Break">or macOS</span></li>
				<li>A <span class="No-Break">scripting language</span></li>
				<li>A configuration<a id="_idIndexMarker001"/> management framework called <strong class="bold">Desired State </strong><span class="No-Break"><strong class="bold">Configuration</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">DSC</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>In practice, when we talk about PowerShell, we’re usually talking about the scripting language. Usage of the shell is largely intuitive to the user, as we’ll see, and while we’ll talk about DSC later, in my experience, most people don’t use it as much as <span class="No-Break">they should.</span></p>
			<p>The first version<a id="_idIndexMarker002"/> of PowerShell grew out of a project called <strong class="bold">Monad</strong>, which was an attempt by Jeffrey Snover to replicate Unix tools on Windows. He realized that one of the fundamental drawbacks of Unix tools is that they output a bytestream (usually text), and so a lot of effort is wasted on searching, formatting, and extracting the output of commands before you can act on that output. Monad was written to output objects that could be input straight into another command. We’ll cover this in more detail when we get to <a href="B17600_04.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">PowerShell Variables and Data Structures</em>. PowerShell 1.0 was released in 2006, but in my opinion, it didn’t really take off until PowerShell 2.0 was released in 2009, and Microsoft started re-engineering the administrative interfaces of major pieces of software such as Exchange Server 2010 to make use of it. Other opinions <span class="No-Break">are available.</span></p>
			<p>At the time of writing, there<a id="_idIndexMarker003"/> are two main <em class="italic">flavors</em> of PowerShell: <strong class="bold">Windows PowerShell</strong>, which comes bundled with both server<a id="_idIndexMarker004"/> and desktop versions of Windows, and <strong class="bold">PowerShell 7</strong>, which must be downloaded and installed. The latest (and allegedly final) version of Windows PowerShell, v5.1, is built on .NET Framework 4.5, the proprietary software framework that is bundled with Windows and underpins many of Microsoft’s products. PowerShell 7.0 was built on .NET Core 3.1, a simplified, open source implementation of .NET. However, since version 7.2, PowerShell has been built on .NET 6.0. This unified version of .NET is a replacement for both .NET Framework and .NET Core, and was released in <span class="No-Break">November 2020.</span></p>
			<p>Because of the fundamental differences<a id="_idIndexMarker005"/> between Windows PowerShell 5.1 and PowerShell 7.x, there can be some differences in how they work on the Windows platform. These will be discussed in <a href="B17600_13.xhtml#_idTextAnchor267"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">Working With PowerShell 7 </em><span class="No-Break"><em class="italic">and Windows</em></span><span class="No-Break">.</span></p>
			<p>We’ll find it useful<a id="_idIndexMarker006"/> to summarize some of the key differences<a id="_idIndexMarker007"/> in the <span class="No-Break">following table:</span></p>
			<table id="table001-1" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">Parameters</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Windows PowerShell</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">PowerShell 7.2</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">Platform</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>x64, <span class="No-Break">x86 only</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>x64, x86, <span class="No-Break">arm32, arm64</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">OS</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Windows</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Windows, <span class="No-Break">Linux, </span><span class="No-Break">macOS</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">.</strong><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">NET Version</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>.NET <span class="No-Break">Framework 4.5</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>.<span class="No-Break">NET 6.0</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">License Type</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Proprietary</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Open source</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">No. of </strong><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">Native Commands</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>1588 (in vanilla <span class="No-Break">Windows 10)</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>1574 (in vanilla <span class="No-Break">Windows 10)</span></p>
							<p>290 (in <span class="No-Break">Ubuntu 20.04)</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Figure">Table 1.1 – Some differences between Windows PowerShell and PowerShell 7</p>
			<p>In this section, we have covered what PowerShell is, and how it differs from Windows PowerShell. In the next section, we’ll look at why PowerShell 7 exists and see what makes <span class="No-Break">it special.</span></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>What is PowerShell 7 used for?</h1>
			<p>PowerShell is for getting things<a id="_idIndexMarker008"/> done quickly. It’s for when you need a relatively short piece of code for something that you can reuse and repurpose easily to do something else. It’s for when you don’t want to spend months learning a language, then more months writing thousands of lines of code. The language can be used in at least <span class="No-Break">four ways:</span></p>
			<ul>
				<li>You can input single lines of code in the shell, as you would at the Windows Command Prompt or the Linux Terminal. This is great if you need to check a value, accomplish a single task such as rebooting a remote computer, or grab a <span class="No-Break">log file.</span></li>
				<li>You can write a script, such as a Bash script in Linux or a batch file for Windows, that accomplishes multiple subtasks, such as gathering event logs and performance information from several machines and compiling them into a single <span class="No-Break">HTML report.</span></li>
				<li>If you write a lot of scripts or need to accomplish something more complex, you can use PowerShell as a procedural programming language with multiple packaged scripts that each describe a single function and are called by a <span class="No-Break">master script.</span></li>
				<li>You can use it as an object-oriented programming language and package a whole application that can be redistributed and run by anyone with <span class="No-Break">PowerShell installed.</span></li>
			</ul>
			<p>We’ll be focusing on scripts and procedural programming<a id="_idIndexMarker009"/> in this book, as that is how most people use PowerShell. These are very similar; the difference is that in a script, you are using cmdlets that have been written for you, but in procedural programming, you are creating your own cmdlets, either from pre-existing cmdlets or by using the system programming <span class="No-Break">language C#.</span></p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Scripting languages versus system programming languages</h2>
			<p>The PowerShell language<a id="_idIndexMarker010"/> is a scripting language. It’s for gluing<a id="_idIndexMarker011"/> other applications together quickly and easily – sort of a coding version<a id="_idIndexMarker012"/> of Lego. It relies on an underlying interpreter: the PowerShell program. Without PowerShell installed, a PowerShell script can’t run. This is quite similar to other interpreted languages, such as Python, and sits in contrast to system programming languages, such as C or C++, which are compiled into executable files. When you compile a C++ program, it can theoretically run on any compatible machine. There are other differences as well – here are some of the <span class="No-Break">main ones:</span></p>
			<ul>
				<li>Interpreted languages are less efficient than compiled languages because each line has to be interpreted before it can run. This means they are slower than compiled programs. There are programming tricks you can use to speed things up, but performing a task in an interpreted language will pretty much always be slower than doing it in a <span class="No-Break">compiled language.</span></li>
				<li>Interpreted languages are more efficient than compiled languages in development. They accomplish the same tasks with far fewer lines of code. This means that writing them, debugging them, and reusing them is much quicker. They are also much easier <span class="No-Break">to learn.</span></li>
				<li>Interpreted languages can run on multiple architectures. As we’ll see in this book, code written in PowerShell can run on Windows, Linux, or macOS, with minimal tweaking. A program written in C++ for Windows can only run on Windows, or a machine with Windows emulation. It would need to be rewritten and recompiled for a <span class="No-Break">different platform.</span></li>
				<li>Interpreted languages produce collaborative reusable programs. With PowerShell (or Python), you produce code that is readable and editable by humans. With a compiled language, you produce a binary file that cannot easily be decompiled into source code for reuse. This means other people can reuse your code for their own purposes. Platforms such as GitHub can be used to distribute your code, other people can contribute to it, improve it, reuse it for their programs, and act in a generally <span class="No-Break">communitarian fashion.</span></li>
			</ul>
			<p>It boils down to this: if you want<a id="_idIndexMarker013"/> to write a super-fast first-person<a id="_idIndexMarker014"/> shooter game with spectacular graphics, then PowerShell is probably<a id="_idIndexMarker015"/> not the language for you. If you want to automate some tasks, simple or complex, then PowerShell is a <span class="No-Break">good choice.</span></p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Getting PowerShell 7</h1>
			<p>In this section, we’ll look at some<a id="_idIndexMarker016"/> of the ways to get PowerShell onto your machine, where it goes and why, and how you can control aspects of your installation. This chapter will only cover installation on Windows; for detailed installation on Linux, macOS, and ARM systems, please have a read of <a href="B17600_14.xhtml#_idTextAnchor280"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, <em class="italic">PowerShell 7 for Linux and macOS</em>, or <a href="B17600_15.xhtml#_idTextAnchor302"><span class="No-Break"><em class="italic">Chapter 15</em></span></a>, <em class="italic">PowerShell 7 and the Raspberry Pi</em>, and come back for the next two sections of <span class="No-Break">this chapter.</span></p>
			<p>It’s possible to have more than one version<a id="_idIndexMarker017"/> of PowerShell running simultaneously on your machine – I usually have three at once: Windows PowerShell, PowerShell 7 (current version), and PowerShell 7 Preview. This is not just for when I’m writing a book – we need to know that the scripts we write will run in different environments and rewrite them if necessary. It’s also useful to be able to control the installation when you’re intending to run PowerShell on a remote machine that may not have it installed yet. Windows PowerShell is included in the Windows operating system and is installed in the <strong class="source-inline">\Windows\system32</strong> folder; that’s where it lives, and you can’t move it anywhere else. In contrast, PowerShell 7 can be installed wherever you like, within reason. We’re going to cover the three most common methods <span class="No-Break">of installation:</span></p>
			<ul>
				<li>Installation from an <strong class="source-inline">.msi</strong> file with <span class="No-Break">Windows installer</span></li>
				<li>Installation from a <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">zip</strong></span><span class="No-Break"> file</span></li>
				<li>Installation <span class="No-Break">with winget</span></li>
			</ul>
			<p>There are two other methods that we will cover briefly: installing from the Microsoft Store, and installing as a .NET <span class="No-Break">Global tool.</span></p>
			<p>If you want to experiment a little, and you have Windows 10 Pro or Enterprise, then you can enable the <strong class="bold">Windows Sandbox</strong> feature in <strong class="bold">Control Panel</strong> | <strong class="bold">Programs and Features</strong> | <strong class="bold">Turn Windows features on or off</strong>. </p>
			<p>This will give you a completely blank, secure Windows environment to play around in. Be careful – when you turn it off, it’s gone for good. The next time you turn it on, all your changes will <span class="No-Break">be lost:</span></p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B17600_01_002.jpg" alt="Figure 1.2 – Turning on Windows Sandbox"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Turning on Windows Sandbox</p>
			<p>Full details of the requirements for running<a id="_idIndexMarker018"/> Windows Sandbox can be found <span class="No-Break">here: </span><a href="https://docs.microsoft.com/en-us/Windows/security/threat-protection/Windows-sandbox/Windows-sandbox-overview"><span class="No-Break">https://docs.microsoft.com/en-us/Windows/security/threat-protection/Windows-sandbox/Windows-sandbox-overview</span></a><span class="No-Break">.</span></p>
			<p>Let’s get started. Make sure<a id="_idIndexMarker019"/> you have met the technical requirements listed at the beginning of <span class="No-Break">the chapter.</span></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Installation from an .msi file</h2>
			<p>All of the official PowerShell distributions<a id="_idIndexMarker020"/> can be found<a id="_idIndexMarker021"/> on the PowerShell GitHub page <span class="No-Break">at </span><a href="https://github.com/PowerShell/PowerShell"><span class="No-Break">https://github.com/PowerShell/PowerShell</span></a><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B17600_01_003.jpg" alt="Figure 1.3 – Get PowerShell from the GitHub page"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Get PowerShell from the GitHub page</p>
			<p>As you can see, for most operating systems<a id="_idIndexMarker022"/> and platforms, there<a id="_idIndexMarker023"/> are three types of release: <strong class="bold">LTS</strong>, <strong class="bold">stable</strong>, and <strong class="bold">preview</strong>. <strong class="bold">LTS</strong> stands for <strong class="bold">Long Term Support</strong>. LTS releases come<a id="_idIndexMarker024"/> out on a slow cadence, to ensure stability in environments that are risk-averse, and they usually only contain critical security updates and software fixes, not new features. The PowerShell LTS releases are based on the underlying LTS version of .NET. The preview release is the next version of PowerShell. It may have exciting new features, but it will also likely be unstable and have some flaws. Stable releases are updated every month or so and may include new functionality, as well as software fixes and security updates. Each release is supported for six months after the <span class="No-Break">next release.</span></p>
			<p>Let’s go ahead and install the most common release, the stable release for <span class="No-Break">Windows x64:</span></p>
			<ol>
				<li>Browse to the GitHub Releases page for PowerShell <span class="No-Break">here: </span><a href="https://github.com/PowerShell/PowerShell"><span class="No-Break">https://github.com/PowerShell/PowerShell</span></a><span class="No-Break">.</span></li>
				<li>Click to download the stable <strong class="source-inline">.msi</strong> package for <span class="No-Break">Windows x64.</span></li>
				<li>Locate the <strong class="source-inline">.msi</strong> file in your <strong class="source-inline">Downloads</strong> folder and run it. This will start the <span class="No-Break">setup wizard.</span></li>
				<li>The first choice you must make is the install location. By default, it will install into a numbered folder under <strong class="source-inline">C:\Program Files\PowerShell</strong>, where the number matches the major version – in our case, <strong class="source-inline">7</strong>. If you are installing a preview version, then the folder will have a <strong class="source-inline">-preview</strong> suffix. This is a pretty good location, but you may want<a id="_idIndexMarker025"/> to put it somewhere else, for example<a id="_idIndexMarker026"/>, if you are running multiple versions of PowerShell side by side. Go ahead and accept the default <span class="No-Break">this time:</span></li>
			</ol>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B17600_01_004.jpg" alt="Figure 1.4 – The default install location"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – The default install location</p>
			<ol>
				<li value="5">Now we get to the <strong class="bold">Optional </strong><span class="No-Break"><strong class="bold">Actions</strong></span><span class="No-Break"> menu:</span></li>
			</ol>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B17600_01_005.jpg" alt="Figure 1.5 ﻿– Optional Actions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Optional Actions</p>
			<p>There are five <span class="No-Break">options here:</span></p>
			<ul>
				<li><strong class="bold">Add PowerShell to Path Environment Variable</strong>: You will almost certainly want to choose<a id="_idIndexMarker027"/> this. With this option enabled, you can start PowerShell<a id="_idIndexMarker028"/> from any location. Be aware that if you install a different version side by side, it will overwrite the installation path variable and you will need to manually navigate to the location of <strong class="source-inline">pwsh.exe</strong> to run <span class="No-Break">this one.</span></li>
				<li><strong class="bold">Register Windows Event Logging Manifest</strong>: You will want to enable this as<a id="_idIndexMarker029"/> well. This will create a new Windows Event log called <strong class="bold">PowerShell Core</strong> and start logging PowerShell events <span class="No-Break">to it.</span></li>
				<li><strong class="bold">Enable PowerShell remoting</strong>: Enabling PowerShell remoting will make the machine listen for incoming connections from PowerShell sessions. This is obviously a bit of a security vulnerability, so you should only enable it if you need it and your machine is on a private network. You don’t need to enable it to connect to remote sessions on <span class="No-Break">other machines.</span></li>
				<li><strong class="bold">Add ‘Open here’ context menus to Explorer</strong>: This will allow you to open a PowerShell session in a folder in File Explorer – the PowerShell session will open with the path set to the folder <span class="No-Break">you selected.</span></li>
				<li><strong class="bold">Add ‘Run with PowerShell 7’ context menu for PowerShell files</strong>: This will allow you to right-click a file and open it with PowerShell 7. For reasons we will see later, this might not always <span class="No-Break">be desirable.</span></li>
			</ul>
			<ol>
				<li value="6">After <strong class="bold">Optional Actions</strong>, we come to the <strong class="bold">Microsoft Update</strong> option. You can use Microsoft Update to keep PowerShell updated; this is highly recommended as it can automatically download security patches for you and apply them according to your existing update schedule. Be aware that this setting can be overridden by group policy if you are working in a domain-joined environment. There are two checkboxes; the first enables updates for PowerShell, while the second enables Microsoft Update on the system. Note that unchecking this box only disables Microsoft<a id="_idIndexMarker030"/> Update; if your environment<a id="_idIndexMarker031"/> uses a configuration manager such as <strong class="bold">Windows Software Update Services</strong> (<strong class="bold">WSUS</strong>) or <strong class="bold">System Center Configuration Manager</strong> (<strong class="bold">SCCM</strong>), then they will <span class="No-Break">still work.</span></li>
				<li>Finally, we’re ready to install by pressing the <strong class="bold">Install</strong> button. This is a short process and should be done in a minute or two. Click <strong class="bold">Finish</strong>, and we’re <span class="No-Break">all set.</span></li>
			</ol>
			<p>There is an alternative to using the<a id="_idIndexMarker032"/> GUI. You can run the <strong class="source-inline">.msi</strong> file from the command line with <strong class="source-inline">msiexec.exe</strong>, as documented <span class="No-Break">here: </span><a href="https://docs.microsoft.com/en-gb/powershell/scripting/install/installing-powershell-on-Windows?view=powershell-7.2#install-the-msi-package-from-the-command-line"><span class="No-Break">https://docs.microsoft.com/en-gb/powershell/scripting/install/installing-powershell-on-Windows?view=powershell-7.2#install-the-msi-package-from-the-command-line</span></a><span class="No-Break">.</span></p>
			<p>To silently install PowerShell on Windows Sandbox as you’ve just been shown, you can run <span class="No-Break">the following:</span></p>
			<pre class="console">
msiexec.exe /package c:\Users\WDAGUtilityAccount\Downloads\PowerShell-7.2.1-win-x64.msi /quiet REGISTER_MANIFEST=1 USE_MU=1 ENABLE_MU=1</pre>			<p>Notice that there is no property<a id="_idIndexMarker033"/> for enabling or disabling <strong class="bold">Add PowerShell to Path Environment Variable</strong>. If you run the <strong class="source-inline">.msi</strong> file from the command line, then<a id="_idIndexMarker034"/> PowerShell will automatically get added. Because we’ve used the <strong class="source-inline">/quiet</strong> switch, there is no output to this command, but if it is successful, then you will see PowerShell in your <span class="No-Break">Start menu.</span></p>
			<p class="callout-heading">Activity 1</p>
			<p class="callout">How might you enable the file context menu when installing PowerShell from an <strong class="source-inline">.msi</strong> file using the command line? (Hint: Check the link in the earlier paragraph to <span class="No-Break">find out.)</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Installation from the .zip file</h2>
			<p>Another popular way<a id="_idIndexMarker035"/> to install PowerShell is from the <strong class="source-inline">.zip</strong> file. With this method, we simply<a id="_idIndexMarker036"/> extract the binaries and associated files to a suitable folder. The disadvantage is that the prerequisite checking and options that are available with the <strong class="source-inline">.msi</strong> install are lost; for instance, you can’t automatically add PowerShell to the <strong class="source-inline">PATH</strong> environment variable or enable PowerShell remoting. The advantage is that it is much easier to script the installation of PowerShell as part of a DevOps or Infrastructure as Code pipeline, and you can enable other features as part of <span class="No-Break">the script.</span></p>
			<p>In Windows, there’s no native way to install a file from the internet via scripting. You need to either already have PowerShell (which you automatically do in the form of Windows PowerShell on a Windows machine), or<a id="_idIndexMarker037"/> install a tool such <span class="No-Break">as </span><span class="No-Break"><strong class="bold">curl</strong></span><span class="No-Break">.</span></p>
			<p>Here’s how you<a id="_idIndexMarker038"/> do it with <span class="No-Break">Windows</span><span class="No-Break"><a id="_idIndexMarker039"/></span><span class="No-Break"> PowerShell:</span></p>
			<pre class="console">
Invoke-WebRequest https://github.com/PowerShell/PowerShell/releases/download/v7.2.1/PowerShell-7.2.1-win-x64.zip</pre>			<p>If you run the preceding cmdlet, then you should see output like this. Notice that it’s an HTTP response, and so a <strong class="source-inline">StatusCode</strong> result of <strong class="source-inline">200</strong> <span class="No-Break">is good:</span></p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B17600_01_006.jpg" alt="Figure 1.6 – Downloading PowerShell 7 with Windows PowerShell"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Downloading PowerShell 7 with Windows PowerShell</p>
			<p>You can run the entire process like this with four lines <span class="No-Break">of code:</span></p>
			<pre class="console">
New-Item -Path c:\scratch\myPowershell\7.2 -ItemType Directory
Invoke-WebRequest https://github.com/PowerShell/PowerShell/releases/download/v7.2.1/PowerShell-7.2.1-win-x64.zip -OutFile C:\scratch\myPowershell\7.2\PowerShell-7.2.1-win-x64.zip
Expand-Archive C:\scratch\myPowershell\7.2\PowerShell-7.2.1-win-x64.zip -DestinationPath C:\scratch\myPowershell\7.2\
Remove-Item C:\scratch\myPowershell\7.2\PowerShell-7.2.1-win-x64.zip</pre>			<p>Don’t worry too much<a id="_idIndexMarker040"/> about the preceding commands – we’ll be covering all <a id="_idIndexMarker041"/>of them in due course. In summary, the first line creates a new folder. The second line downloads the <strong class="source-inline">.zip</strong> package from GitHub to your new folder. The third line unzips everything, making it ready for you to run, and the fourth line removes the <span class="No-Break">downloaded package.</span></p>
			<p>There are two errors you may experience with this. Firstly, you may see a red <span class="No-Break">error message:</span></p>
			<pre class="console">
Invoke-WebRequest : The request was aborted: Could not create SSL/TLS secure channel"</pre>			<p>This is because, by default, Windows PowerShell will use TLS v1.0, and many websites no longer accept this protocol. If you do see this, run the following .NET code and <span class="No-Break">try again:</span></p>
			<pre class="console">
[Net.ServicePointManager]::SecurityProtocol = "Tls, Tls11, Tls12, Ssl3"</pre>			<p>The other error you may see is a message <span class="No-Break">saying this:</span></p>
			<pre class="console">
Invoke-WebRequest : The response content cannot be parsed because the Internet Explorer engine is not available, or Internet Explorer's first-launch configuration is not complete. Specify the UseBasicParsing parameter and try again</pre>			<p>In this case, run the <strong class="source-inline">Invoke-WebRequest</strong> cmdlet with the <strong class="source-inline">–</strong><span class="No-Break"><strong class="source-inline">UseBasicParsing</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="console">
Invoke-WebRequest https://github.com/PowerShell/PowerShell/releases/download/v7.2.1/PowerShell-7.2.1-win-x64.zip -UseBasicParsing</pre>			<p>Replace the second line of the script<a id="_idIndexMarker042"/> with this line. It’s exactly the same<a id="_idIndexMarker043"/> but adds the <strong class="source-inline">–</strong><span class="No-Break"><strong class="source-inline">UseBasicParsing</strong></span><span class="No-Break"> parameter.</span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Installation with winget</h2>
			<p><strong class="bold">winget</strong>, also known as the <strong class="bold">Windows Package Manager</strong>, is a free, open source package<a id="_idIndexMarker044"/> manager <a id="_idIndexMarker045"/>from Microsoft for Windows Clients. It is bundled<a id="_idIndexMarker046"/> with Windows 11 and<a id="_idIndexMarker047"/> may be downloaded for Windows 10 via the Microsoft Store. It is similar in functionality to Linux package managers such as APT, YUM, and DNF. It supports <strong class="source-inline">.exe</strong>, <strong class="source-inline">.msi</strong>, and <strong class="source-inline">.msix</strong> packages – you can’t use it to install the <strong class="source-inline">.zip</strong> release. When you run winget, it searches for, downloads, and installs the PowerShell <strong class="source-inline">.msi</strong> release of your choice. You do it <span class="No-Break">like this:</span></p>
			<ol>
				<li>First, run a search for PowerShell packages. From the Windows PowerShell Command Prompt, run <span class="No-Break">this line:</span><pre class="source-code">
<strong class="bold">winget search microsoft.powershell</strong></pre></li>			</ol>
			<p>This will return the versions of PowerShell available <span class="No-Break">to winget.</span></p>
			<ol>
				<li value="2">You then need to install a package. I’m choosing to install the preview by running <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">winget install --id microsoft.powershell.preview --source winget</strong></pre></li>			</ol>
			<p>And that’s it. There are a few things to note here. Firstly, you’re installing the <strong class="source-inline">.msi</strong> file, so unless you suppress them, you will see several GUI messages. You can do this with the <strong class="source-inline">--silent</strong> switch. Unless you are happy with the default choices, you will also need a way to pass parameters to the <strong class="source-inline">.msi</strong> file you are calling. You can do this with the <strong class="source-inline">–-override</strong> switch, and then by passing the command-line switches for the <strong class="source-inline">.msi</strong> package that we looked at before. Secondly, if you have User Access Control enabled, you will need to give permission for PowerShell to be installed. If you’re using the <strong class="source-inline">--silent</strong> switch, then you won’t see this prompt. If you want to do a silent install, you’ll need to run Windows PowerShell with <span class="No-Break">administrator privileges.</span></p>
			<p>Here’s how the whole install looks if you run it from a Windows PowerShell command line with <span class="No-Break">administrator privileges:</span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B17600_01_007.jpg" alt="Figure 1.7 – Silently installing PowerShell with winget"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Silently installing PowerShell with winget</p>
			<p>The main advantage of winget is that it has its own repository for community-created packages; anyone can bundle an app by writing a manifest and uploading it. The repository is secured with Microsoft SmartScreen to stop malicious code from finding its way into the repository. There’s<a id="_idIndexMarker048"/> a lot more on <span class="No-Break">winget here:</span></p>
			<p><a href="https://docs.microsoft.com/en-us/Windows/package-manager/winget/ "><span class="No-Break">https://docs.microsoft.com/en-us/Windows/package-manager/winget/.</span></a></p>
			<p>In summary, you’re not really doing<a id="_idIndexMarker049"/> anything with winget that you didn’t do by <a id="_idIndexMarker050"/>running <strong class="source-inline">msiexec.exe</strong> previously, but it’s a bit newer and cooler, has a useful repository, and is slightly easier to use. In a couple of years, we’ll wonder how we ever did without it, especially if they make it available on <span class="No-Break">Windows servers.</span></p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Other ways to install</h2>
			<p>There are two other ways<a id="_idIndexMarker051"/> to install PowerShell that we should discuss. Neither is likely to be applicable<a id="_idIndexMarker052"/> to us. Firstly, if you have the .NET <strong class="bold">Software Development Kit</strong> (<strong class="bold">SDK</strong>) installed, then we can use that to install PowerShell as a global tool. This is only really useful for software developers, and it doesn’t make much sense to install the SDK just <span class="No-Break">for PowerShell.</span></p>
			<p>The other way you can install PowerShell on Windows<a id="_idIndexMarker053"/> is through the Microsoft Store as an app. The big drawback to this method is that Store apps run in a sandbox environment that restricts access to the application’s root folder. This means that several PowerShell features just won’t <span class="No-Break">work properly.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">A <strong class="bold">sandbox</strong> is not necessarily the same as <strong class="bold">Windows Sandbox</strong>. The generic term “sandbox” refers<a id="_idIndexMarker054"/> to a secure computing environment<a id="_idIndexMarker055"/> with separate resources, meaning that whatever is running in there cannot interfere with anything outside the sandbox. Windows Sandbox is a specific example of a <span class="No-Break">generic sandbox.</span></p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Running PowerShell 7</h1>
			<p>The first way everyone runs PowerShell<a id="_idIndexMarker056"/> is through the bundled console (remember, PowerShell is not just a language, it’s a shell and a configuration management framework as well). Let’s assume that you installed using the <strong class="source-inline">.msi</strong> method from before, and you added PowerShell to the <strong class="source-inline">PATH</strong> environment variable. If you’ve done this, then all you need to do to start PowerShell is type <strong class="source-inline">pwsh</strong> into the Windows search bar and click on the application. Alternatively, you can right-click the <em class="italic">Start</em> menu and type <strong class="source-inline">pwsh</strong> in the <strong class="bold">Run</strong> box. Or, you could just hold down the <em class="italic">Windows</em> key and press <em class="italic">R</em>, which would call up the <strong class="bold">Run</strong> box <span class="No-Break">as well.</span></p>
			<p>If you didn’t add PowerShell to the path, you will need to type the full path to the executable <strong class="source-inline">pwsh</strong>, as in <span class="No-Break"><strong class="source-inline">C:\program files\PowerShell\7\pwsh</strong></span><span class="No-Break">.</span></p>
			<p>The first thing you will notice if you’ve been paying attention to the preceding screenshots or you’ve followed along is that the console window that comes up has a black background. This differentiates it from <span class="No-Break">Windows PowerShell:</span></p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B17600_01_008.jpg" alt="Figure 1.8 – Two different versions of PowerShell"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – Two different versions of PowerShell</p>
			<p>If you have installed PowerShell<a id="_idIndexMarker057"/> on Linux or macOS, then open a Terminal and type <strong class="source-inline">pwsh</strong> – the Terminal will switch to a <span class="No-Break">PowerShell prompt.</span></p>
			<p>It is traditional in most programming books that the first thing you do is coax your application to produce the words <strong class="source-inline">"Hello World"</strong> onscreen, and there’s no reason we should be any different. Type the following into the console and <span class="No-Break">press </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">:</span></p>
			<pre class="console">
Write-Host "Hello World"</pre>			<p>You should get something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B17600_01_009.jpg" alt="Figure 1.9 – Hello yourself"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – Hello yourself</p>
			<p>If you did it, congratulations! You’ve just run your first PowerShell command, or cmdlet, as they <span class="No-Break">are called.</span></p>
			<p>Notice that the console<a id="_idIndexMarker058"/> automatically colors things that it recognizes or expects; cmdlets are yellow, strings are blue. It’s also very forgiving – if you had forgotten the inverted commas, then <strong class="source-inline">"Hello World"</strong> would not have been blue, but PowerShell would have interpreted it <span class="No-Break">correctly anyway.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Be careful with this; while PowerShell is quite clever, it won’t always interpret input the way you hope. It’s best to tell it explicitly what type of input you are giving it. More on <span class="No-Break">this later.</span></p>
			<p>The most likely cause of an error is that you misspelled the cmdlet or didn’t close the inverted commas, as illustrated in the next figure. You’ll see a helpful red error message telling you what you’ve done wrong and suggesting ways to fix it. I have come to cherish these <span class="No-Break">error messages:</span></p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B17600_01_010.jpg" alt="Figure 1.10 – Three ways to be wrong"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10 – Three ways to be wrong</p>
			<p>In the third attempt, I didn’t close the inverted commas, so PowerShell was expecting more input. It told us this with <strong class="source-inline">&gt;&gt;</strong> on the line below. It also told us that it didn’t think the cmdlet would run as you have written it by coloring the <strong class="source-inline">&gt;</strong> in the Command Prompt <span class="No-Break">in red.</span></p>
			<p>Note that unlike in some<a id="_idIndexMarker059"/> environments, capitalization here doesn’t matter; <strong class="source-inline">write-host</strong> is functionally the same <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">Write-Host</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Running PowerShell with administrator privileges</h2>
			<p>By default, PowerShell<a id="_idIndexMarker060"/> will run under the account that launches<a id="_idIndexMarker061"/> it, but it will only have standard user privileges. If you need access to your local machine that would normally require<a id="_idIndexMarker062"/> administrator privileges, then PowerShell will either fail to run some cmdlets or give you a <strong class="bold">User Account Control</strong> (<strong class="bold">UAC</strong>) prompt. To prevent this, you need to start PowerShell with administrator privileges. There are many ways to do this, but here are two of the <span class="No-Break">most common.</span></p>
			<p>Firstly, you can open the search bar, type <strong class="source-inline">pwsh</strong>, and then right-click on the PowerShell 7 icon and select <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">as administrator</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B17600_01_011.jpg" alt="Figure 1.11 – Starting PowerShell as an administrator"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11 – Starting PowerShell as an administrator</p>
			<p>The second, slightly more impressive method<a id="_idIndexMarker063"/> is to hit the <em class="italic">Windows</em> key + <em class="italic">R</em> to bring<a id="_idIndexMarker064"/> up the <strong class="bold">Run</strong> box, type <strong class="source-inline">pwsh</strong>, and then hold down <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">Enter</em>. This will start PowerShell as an admin. </p>
			<p>PowerShell clearly shows whether it is running with admin privileges in the window title. Here are two PowerShell sessions running the same cmdlet. The lower window is running with <span class="No-Break">admin privileges:</span></p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B17600_01_012.jpg" alt="Figure 1.12 – Sometimes you have to be an admin"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12 – Sometimes you have to be an admin</p>
			<p>If administrator mode<a id="_idIndexMarker065"/> is something you are likely to use a lot, then it’s easiest<a id="_idIndexMarker066"/> to just right-click the PowerShell icon when it’s running and select <strong class="bold">Pin to taskbar</strong>. Then you can right-click the pinned icon whenever you need it and select <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">as administrator</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Autocomplete</h2>
			<p>By now, you’re probably<a id="_idIndexMarker067"/> getting a little tired of having to type a lot of long and unfamiliar cmdlets in. Let me show you a great feature of the shell: autocomplete. Try this – in your shell, type the following without <span class="No-Break">pressing </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">:</span></p>
			<pre class="console">
Stop-s</pre>			<p>Now press the <em class="italic">Tab </em>key. Cool, isn’t it? But it’s not the cmdlet we want. Press the <em class="italic">Tab</em> key again. You should now have the <strong class="source-inline">Stop-Service</strong> cmdlet fully typed. Now, add a space, type <strong class="source-inline">-</strong>, and press the <em class="italic">Tab</em> key again. Keep pressing the <em class="italic">Tab</em> key until you’ve gone through all the possible parameters for the <strong class="source-inline">Stop-Service</strong> cmdlet. Press <em class="italic">Esc</em> when you’ve <span class="No-Break">done that.</span></p>
			<p>This is a great way to avoid typing out loads of letters, but it’s also a really good way of checking that what you are doing will work. If autocomplete doesn’t work, then the chances are that the cmdlet, parameter, or option you want isn’t available on <span class="No-Break">this machine.</span></p>
			<p>In the next chapter, we’ll look at some other ways of starting and using PowerShell, but for now, you’re all set with what <span class="No-Break">you need.</span></p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Getting help</h1>
			<p>Now that you’ve installed PowerShell <a id="_idIndexMarker068"/>and can start it, you need to do stuff with it. You’re going to need help with that. Happily, PowerShell<a id="_idIndexMarker069"/> comes with three useful cmdlets built in: <strong class="source-inline">Get-Command</strong>, <strong class="source-inline">Get-Help</strong>, and <strong class="source-inline">Get-Member</strong>. Each of these cmdlets will tell you useful things and give you guidance. Let’s start <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Get-Command</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Get-Command</h2>
			<p><strong class="source-inline">Get-Command</strong> will give you a list of cmdlets. If you type it in just like that, it will give you<a id="_idIndexMarker070"/> a list of around 1,500 cmdlets. When you start installing and writing modules, that list will grow significantly. Scrolling through a list of thousands looking for a likely cmdlet is not that efficient. What you need to do is search <span class="No-Break">the list.</span></p>
			<p>Imagine you need to interrogate a particular process that is running on your client. It is likely that a cmdlet for doing that would include the word <strong class="source-inline">process</strong> somewhere. Go ahead and try typing the following into <span class="No-Break">your shell:</span></p>
			<pre class="console">
Get-Command *process</pre>			<p>You should see something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B17600_01_013.jpg" alt="Figure 1.13 – Searching for relevant cmdlets"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13 – Searching for relevant cmdlets</p>
			<p>The cmdlet interprets <strong class="source-inline">*process</strong> as a string and searches for cmdlets that end in <strong class="source-inline">process</strong>. The <strong class="source-inline">*</strong> is a wildcard character. Try running it <span class="No-Break">like this:</span></p>
			<pre class="console">
Get-Command process</pre>			<p>You’ll probably get an error <span class="No-Break">in red.</span></p>
			<p>Some of those cmdlets look a bit cryptic, but there are a few that really stand out – <strong class="source-inline">Get-Process</strong> especially. Try running that. You should see quite a long list of processes and some information about them. Let’s look at a process I know you’re currently running: <strong class="source-inline">pwsh</strong>. Type <span class="No-Break">the following:</span></p>
			<pre class="console">
Get-Process pwsh</pre>			<p>You should see information for your <span class="No-Break">PowerShell processes:</span></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B17600_01_014.jpg" alt="Figure 1.14 – My PowerShell processes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.14 – My PowerShell processes</p>
			<p>That’s very nice, but what does it all <a id="_idIndexMarker071"/>mean? Let’s look at the next of our three helpful <span class="No-Break">cmdlets: </span><span class="No-Break"><strong class="source-inline">Get-Help</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Get-Help</h2>
			<p>Running the <strong class="source-inline">Get-Help</strong> cmdlet is easy; type <strong class="source-inline">Get-Help</strong> followed by the name of the cmdlet you would<a id="_idIndexMarker072"/> like <span class="No-Break">help with:</span></p>
			<pre class="console">
Get-Help Get-Process</pre>			<p>You should then see something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B17600_01_015.jpg" alt="Figure 1.15 – Running Get-Help for the first time"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.15 – Running Get-Help for the first time</p>
			<p>That doesn’t look very helpful. However, if you read the <strong class="source-inline">REMARKS</strong> section, there’s an explanation. PowerShell doesn’t ship with full help; you need to download and update it. To update the help files, run <span class="No-Break">the following:</span></p>
			<pre class="console">
Update-Help</pre>			<p>It will take a little while to run, and if you have installed some modules, help files may not be available<a id="_idIndexMarker073"/> online for all of them, so you will see red error messages, but after a minute or two, it should finish, and you can then try getting help for <span class="No-Break"><strong class="source-inline">Get-Process</strong></span><span class="No-Break"> again.</span></p>
			<h3>Get-Help Get-Process</h3>
			<p>PowerShell is quite<a id="_idIndexMarker074"/> biased toward the <em class="italic">en-US</em> culture. Culture<a id="_idIndexMarker075"/> here refers to a specific meaning within .NET and associated programs<a id="_idIndexMarker076"/> such as PowerShell; it’s equivalent to <strong class="bold">locale</strong> in other systems and refers to the settings specific to a language, number format, and date-time format. If your environment is not set to <strong class="source-inline">en-US</strong>, then it may not download all of the relevant help files. If you find you’re not getting everything, try running <span class="No-Break">this line:</span></p>
			<pre class="console">
Update-Help -UICulture en-US</pre>			<p>Then, try again. This is something that particularly affects <span class="No-Break">Linux installations.</span></p>
			<p>You should see a lot more information, including a one-line synopsis and a detailed description. If that’s not enough, then in the <strong class="source-inline">REMARKS</strong> section, there will be some other ways of getting even more information about the cmdlet. Try <span class="No-Break">running this:</span></p>
			<pre class="console">
Get-Help Get-Process -Detailed</pre>			<p>You will see more detailed information, including examples of how to use the cmdlet. To see all the information available, <span class="No-Break">use this:</span></p>
			<pre class="console">
Get-Help Get-Process -Full</pre>			<p>You will see everything in the help file, including the extremely useful <strong class="source-inline">NOTES</strong> section, which, for this cmdlet, will tell you how to interpret some of the values in <span class="No-Break">the output.</span></p>
			<p>There is one other useful way to run <strong class="source-inline">Get-Help</strong> for a cmdlet, using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">online</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="console">
Get-Help Get-Process -Online</pre>			<p>This will produce the web page<a id="_idIndexMarker077"/> for the cmdlet in your default browser; it gives the same information as when you use the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Full</strong></span><span class="No-Break"> parameter.</span></p>
			<h3>About files</h3>
			<p><strong class="source-inline">Get-Help</strong> doesn’t just help you with<a id="_idIndexMarker078"/> cmdlets; you can also get lots of useful information about PowerShell concepts in a special set of files called <strong class="source-inline">ABOUT TOPICS</strong>. At the time of writing, there are over 140 of them. There’s lots of information in these files about programming concepts, constructs, and common queries such as logging for both Windows and non-Windows environments. Have a look yourself by running <span class="No-Break">the following:</span></p>
			<pre class="console">
Get-Help about*</pre>			<p>Let’s have a look at one of <span class="No-Break">the files:</span></p>
			<pre class="console">
Get-Help about_Variables</pre>			<p>You should see lots of interesting information about how variables are used <span class="No-Break">in PowerShell.</span></p>
			<p>You can also use full-text search with <strong class="source-inline">Get-Help</strong>. If the word you are looking for is not in the help file’s name, then the text of the files will be searched. This takes a little longer but can often be worth it. Try entering <span class="No-Break">the following:</span></p>
			<pre class="console">
Get-Help *certificate*</pre>			<p>Make a mental note of the results you get. Now, try entering <span class="No-Break"><strong class="source-inline">certificates</strong></span><span class="No-Break">, plural:</span></p>
			<pre class="console">
Get-Help *certificates*</pre>			<p>You’ll get a different set of results. The first set finds help files with <strong class="source-inline">certificate</strong> in the filename. When <strong class="source-inline">Get-Help</strong> produces the second set, it can’t find any files with <strong class="source-inline">certificates</strong> in the name, so it does a full text search. Note that if the search term does occur in a filename, then the full text search won’t be <span class="No-Break">carried out.</span></p>
			<p>The only downside I find with these files<a id="_idIndexMarker079"/> is that there is some expectation for you to be knowledgeable about everything in PowerShell except the topic in question. For example, <strong class="source-inline">ABOUT_VARIABLES</strong> mentions the <strong class="source-inline">scope</strong> variable in the first few paragraphs. Nonetheless, if you need to know how something works quickly, then these files are a <span class="No-Break">great resource.</span></p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Get-Member</h2>
			<p>The final helpful cmdlet we’re going to look at<a id="_idIndexMarker080"/> in this chapter is <strong class="source-inline">Get-Member</strong>. Earlier in the chapter, we discussed how PowerShell produces objects rather than text output like some shells and scripting languages. <strong class="source-inline">Get-Member</strong> allows you to see the members of those objects, their properties, and the methods that may be used on them. It’s easier to show rather than tell, so go ahead and type the following into <span class="No-Break">your shell:</span></p>
			<pre class="console">
Get-Process | Get-Member</pre>			<p class="callout-heading">Note</p>
			<p class="callout">The vertical line between<a id="_idIndexMarker081"/> the two cmdlets is called the pipeline character, |. It’s not a lower case L – on my en-GB standard PC keyboard, it’s on the lower left, next to the <em class="italic">Z</em> key, and on a standard en-US keyboard, it’s between the <em class="italic">Enter</em> and <em class="italic">Backspace</em> keys. If your keyboard doesn’t have a solid vertical bar (<em class="italic">|</em>), then the broken vertical bar (<em class="italic">¦</em>) <span class="No-Break">will work.</span></p>
			<p>What you’re doing here is piping the output of the <strong class="source-inline">Get-Process</strong> cmdlet into the next<a id="_idIndexMarker082"/> cmdlet as input, which in this case is <strong class="source-inline">Get-Member</strong>. We’ll be doing plenty of work on the pipeline in later chapters. <strong class="source-inline">Get-Member</strong> will tell you the type of object you’ve given it, in this case a <strong class="source-inline">System.Diagnostics.Process</strong> object, and the methods, properties, alias properties, and events associated with that object, <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B17600_01_016.jpg" alt="Figure 1.16 – Some of the members of System.Diagnostics.Process"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.16 – Some of the members of System.Diagnostics.Process</p>
			<p>A few pages earlier, in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.14</em>, we looked at the properties of the <strong class="source-inline">pwsh</strong> processes running on your machine. These are the properties that were listed: <strong class="source-inline">NPM(K)</strong>, <strong class="source-inline">PM(M)</strong>, <strong class="source-inline">WS(M)</strong>, <strong class="source-inline">CPU(s)</strong>, <strong class="source-inline">ID</strong>, <strong class="source-inline">SI</strong>, and <strong class="source-inline">ProcessName</strong>. As you can now see, that’s <strong class="source-inline">Non-Paged Memory (K)</strong>, <strong class="source-inline">Paged Memory (M)</strong>, <strong class="source-inline">Working Set (M)</strong>, and <strong class="source-inline">Session ID</strong>, which are all aliases, so that they can fit nicely into a table on the screen. The <strong class="source-inline">CPU(s)</strong> alias is derived in a slightly different way – it’s not set on the object. The ID and the process name are not aliases. M and K are abbreviations for <strong class="bold">Megabytes</strong> and <strong class="bold">Kilobytes</strong>, respectively. That’s a really small subset of all the properties available on the object. As you can see, there are also methods available that can be used to perform operations on <span class="No-Break">the object.</span></p>
			<p class="callout-heading">Activity 2</p>
			<p class="callout">Have a look at the methods. What method<a id="_idIndexMarker083"/> might you use to forcibly and immediately stop a process? If you get stuck, have a look at the methods <span class="No-Break">here: </span><a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process"><span class="No-Break">https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process</span></a><span class="No-Break">.</span></p>
			<p>We’ll be returning to <strong class="source-inline">Get-Member</strong> more than once in the rest of the book, as it’s such<a id="_idIndexMarker084"/> a <span class="No-Break">useful cmdlet.</span></p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Summary</h1>
			<p>We’ve done a lot in this chapter. We’ve discussed what PowerShell is and what it’s suited for, such as producing short pieces of automation code quickly and easily. We’ve downloaded and installed it in a few different ways, specifically by installing it from an <strong class="source-inline">.msi</strong> file and extracting it from a <strong class="source-inline">.zip</strong> file. </p>
			<p>We’ve tried some different ways of starting it using the built-in shell, and finally, we’ve looked at three useful cmdlets: <strong class="source-inline">Get-Command</strong>, for finding cmdlets that we might use, <strong class="source-inline">Get-Help</strong>, for understanding how to use them, and <strong class="source-inline">Get-Member</strong>, to understand what output those <span class="No-Break">cmdlets produce.</span></p>
			<p>In the next chapter, we will explore how cmdlets work, explore parameters and syntax, and look at a useful application for working interactively with PowerShell: <span class="No-Break">Windows Terminal.</span></p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Exercises</h1>
			<ol>
				<li>What cmdlet would you use to generate a <span class="No-Break">random number?</span></li>
				<li>How would you generate a random number between 1 <span class="No-Break">and 10?</span></li>
				<li>What cmdlet would you use to list the contents of <span class="No-Break">a folder?</span></li>
				<li>How would you also get the contents of <span class="No-Break">the subfolders?</span></li>
				<li>What cmdlet would you use to create a <span class="No-Break">new folder?</span></li>
				<li>What cmdlet will tell you how long your computer has been <span class="No-Break">switched on?</span></li>
				<li>What cmdlet might redirect output to <span class="No-Break">a file?</span></li>
				<li>What could you use the <strong class="source-inline">Get-Credential</strong> <span class="No-Break">cmdlet for?</span></li>
				<li>How might you use the <span class="No-Break"><strong class="source-inline">ConvertTo-HTML</strong></span><span class="No-Break"> cmdlet?</span></li>
			</ol>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Further reading</h1>
			<ul>
				<li>The <em class="italic">Monad Manifesto</em> by Jeffrey Snover is a great read on the background and philosophy of <span class="No-Break">PowerShell: </span><a href="https://www.jsnover.com/Docs/MonadManifesto.pdf"><span class="No-Break">https://www.jsnover.com/Docs/MonadManifesto.pdf</span></a><span class="No-Break">.</span></li>
				<li>John Ousterhout wrote an influential article on the difference between scripting and system programming, and why scripting is important and <span class="No-Break">useful: </span><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/scripting.pdf"><span class="No-Break">https://web.stanford.edu/~ouster/cgi-bin/papers/scripting.pdf</span></a><span class="No-Break">.</span></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer024" class="IMG---Figure">
			</div>
		</div>
	</body></html>