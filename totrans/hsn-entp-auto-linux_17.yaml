- en: Using CIS Benchmarks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CIS 基准
- en: When implementing Linux in the Enterprise, security is paramount. There is no
    one step that can be taken to achieve the nirvana of a truly *secure* environment—rather,
    the approach is an amalgamation of disparate steps that come together to build
    an environment that is as safe and secure as it can be. Indeed, this statement
    brings us to another important point—security is a moving target. As just one
    example, SSLv2 was considered to be secure and was used to secure websites across
    the internet for many years. Then came the DROWN attack in 2016, which rendered
    it insecure. Thus, a server secured for internet traffic (perhaps a frontend web
    server) in 2015 would have, at the time, been considered secure. However, in 2017,
    it would have been considered highly vulnerable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业中实施 Linux 时，安全性至关重要。没有一步可以达到真正安全环境的极乐境界 —— 而是一系列不同步骤的融合，共同构建尽可能安全的环境。事实上，这种说法带出了另一个重要观点
    —— 安全性是一个移动的目标。举个例子，SSLv2 曾被认为是安全的，并用于保护互联网上的网站多年。然后在 2016 年发生了 DROWN 攻击，使其不安全。因此，2015
    年为互联网流量（也许是前端 Web 服务器）保护的服务器，在当时被认为是安全的。然而，在 2017 年，它被认为是极易受攻击的。
- en: Linux itself has always been considered a secure operating system, though its
    high and increasing levels of adoption has seen attacks on the rise. Throughout
    this book, we have advocated, at a high level, good security practices in the
    design of your Linux estate, for example, not installing unnecessary services
    on your base operating system image. Nonetheless, there is much more we can do
    to make our Linux environment more secure and, in this chapter, we will explore
    the ways in which standards have been developed to ensure the security of Linux
    environments. Specifically, we will consider the use of the CIS Benchmarks, along
    with some practical examples of how to apply them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 本身一直被认为是安全的操作系统，尽管其高水平和日益增长的采用率导致攻击不断增加。在本书中，我们在设计 Linux 系统时，高层次上提倡良好的安全实践，例如，在基础操作系统镜像上不安装不必要的服务。尽管如此，我们可以做更多工作，使我们的
    Linux 环境更安全，在本章中，我们将探讨已开发的标准以确保 Linux 环境的安全性。具体来说，我们将考虑使用 CIS 基准，并举一些实际示例来应用它们。
- en: 'Specifically, the following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，本章将涵盖以下主题：
- en: Understanding CIS Benchmarks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 CIS 基准
- en: Applying security policy wisely
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明智地应用安全策略
- en: Scripted deployment of server hardening
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化部署服务器加固脚本
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter includes examples based on the following technologies:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括基于以下技术的示例：
- en: CentOS 7.6
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CentOS 7.6
- en: Ansible 2.8
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.8
- en: To run through these examples, you will need access to two servers or virtual
    machines running the operating system listed previously, along with Ansible. Note
    that the examples given in this chapter may be destructive in nature (for example,
    they delete files and make changes to server configuration) and, if run as shown,
    are only intended to be run in an isolated test environment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些示例，您需要访问两台运行前述操作系统的服务器或虚拟机，以及 Ansible。请注意，本章中给出的示例可能具有破坏性（例如，它们会删除文件并对服务器配置进行更改），如果按照示例运行，则仅应在隔离的测试环境中运行。
- en: Once you are satisfied that you have a safe environment to operate in, let's
    get started with routine system maintenance with Ansible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确信您有一个安全的操作环境可以操作，请开始使用 Ansible 进行日常系统维护。
- en: All example code discussed in this chapter is available from GitHub at the following
    URL: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter13](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter13).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中讨论的所有示例代码都可以从 GitHub 获取，网址如下：[https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter13](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter13)。
- en: Understanding CIS Benchmarks
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 CIS 基准
- en: Before we delve into what a CIS Benchmark actually consists of, let's take a
    look at why they exist and, conceptually, what they are.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解 CIS 基准实际包含什么之前，让我们看看它们为何存在，以及它们在概念上是什么。
- en: What is a CIS Benchmark?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 CIS 基准？
- en: Securing servers, regardless of their operating system, is a big task. It requires
    being constantly up to date with new attack vectors and vulnerabilities as they
    are discovered (see the mention of the DROWN attack and SSLv2 in the introduction
    to this chapter). Some things are well-known and considered *normal*. For example,
    on Linux, it is generally frowned upon to ever log in as root—instead, it is almost
    universally recognized that each individual user should have their own user account
    and should perform all commands requiring elevated permissions using the `sudo`
    command. Thus, some Linux distributions such as Ubuntu come with remote root access
    disabled by default. Others, such as CentOS, do not. Even between these two key
    distributions commonly found in the enterprise, you know that, for one, you need
    to actively turn off remote root SSH access and, for the other, you just need
    to check that it is turned off.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 无论操作系统如何，保护服务器都是一项重大任务。它要求随时跟踪发现的新攻击向量和漏洞（请参阅本章介绍中关于DROWN攻击和SSLv2的提及）。有些事情是众所周知并被认为是*正常*的。例如，在Linux上，作为root登录通常是不被认可的——相反，几乎普遍认为每个用户应该有自己的用户账户，并且应该使用`sudo`命令执行所有需要提升权限的命令。因此，一些Linux发行版如Ubuntu默认情况下禁用了远程root访问。而其他一些，如CentOS，则没有。即使在企业中广泛使用的这两个关键发行版之间，您也知道，对于其中一个，您需要积极关闭远程root
    SSH访问，而对于另一个，则只需检查是否已关闭。
- en: Of course, defining a security policy goes far deeper than whether root access
    is allowed over SSH. Over the years, individuals build up a wealth of knowledge
    about what works and, perhaps by learning the hard way, what doesn't. However,
    the security of your environment should not be defined by how experienced your
    system administrators are. Rather, there should be some defined standard for how
    to best secure a server to prevent most of the common attacks, and also to ensure
    that a suitable level of information is logged in the case that an audit is ever
    required to find the root cause of an event.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定义安全策略远不止于是否允许通过SSH获取root访问权限。多年来，个人积累了关于什么有效的知识，也许是通过艰难的方式，了解了什么是无效的。然而，您的环境安全性不应由系统管理员的经验决定。相反，应该制定一些定义良好的标准，以最佳方式保护服务器，以防止大多数常见攻击，并确保在需要审计以查找事件根本原因时记录适当级别的信息。
- en: 'This is where the concept of the CIS Benchmark comes in. Many people are familiar
    with the concept of a benchmark as a performance test (that is, speed). However,
    whether your server is secure or not is something that can be tested by looking
    for certain criteria, and thus the CIS Benchmark exists. Quoting directly from
    the **Community for Internet Security** (**CIS** for short) website:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是CIS基准概念的所在。许多人熟悉基准的概念作为性能测试（即速度）。然而，您的服务器是否安全可以通过查找特定标准进行测试，因此CIS基准存在。直接引用来自**互联网安全社区**（**CIS**简称）网站的内容：
- en: '"CIS Benchmarks are developed through a unique consensus-based process comprised
    of cybersecurity professionals and subject matter experts around the world."'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '"CIS基准是通过一个由全球网络安全专业人士和主题专家组成的独特共识过程来开发的。"'
- en: Thus, these benchmarks can be considered an amalgamation of best practices from
    industry professionals. Further, they are regularly updated and so can be used
    by engineers and administrators to keep abreast of best practices when it comes
    to securing a server.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些基准可以被视为行业专业人员最佳实践的综合。此外，它们定期更新，因此可以被工程师和管理员用来了解保护服务器的最佳实践。
- en: It should, of course, be noted that there are other security standards out there
    that go to even greater depths than the CIS Benchmark, for example, FedRAMP and
    NSA security requirements. It would be impossible to go into detail of all the
    different profiles available within this book, and so we will focus on the CIS
    Benchmark, which is freely available (in exchange for some personal information)
    and is also well regarded.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，需要注意的是，存在比CIS基准更深入的其他安全标准，例如FedRAMP和NSA安全要求。在本书中，不可能详细讨论所有不同的配置文件，因此我们将重点放在CIS基准上，该基准是免费提供的（交换一些个人信息）并且也备受推崇。
- en: That this book focuses on the CIS Benchmarks should not be taken as an implicit
    statement that you should implement these on your server estate in order for it
    to be secure. It is the duty of each and every reader to ensure they understand
    their own security requirements and to implement the correct ones accordingly.
    In this chapter, we work through the use of CIS Benchmarks as a worked example
    of server hardening to a given standard.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本书专注于 CIS 基准规范，并不意味着您应该在服务器基础设施上实施这些规范以确保其安全。每位读者都有责任确保他们理解自己的安全需求，并相应地实施正确的安全措施。在本章中，我们通过
    CIS 基准规范作为服务器硬化的工作示例来进行讨论。
- en: Also of note is that the CIS Benchmarks are divided by technology. For example,
    there is a CIS Benchmark for both Red Hat Enterprise Linux 7 and Ubuntu Server,
    which you can apply to your Enterprise Linux estate. However, these focus on securing
    the base operating system, and if you install an application layer on top of it,
    then you must apply the appropriate security policy for that as well.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，CIS 基准规范是按技术分割的。例如，有适用于 Red Hat Enterprise Linux 7 和 Ubuntu Server 的
    CIS 基准规范，您可以将其应用于您的企业 Linux 系统。然而，这些规范侧重于保护基本操作系统，如果在其上安装了应用层，则必须同样应用适当的安全策略。
- en: There are CIS Benchmarks for more than 140 technologies, including common Linux
    services such as nginx, Apache, and PostgreSQL. Thus, if you are building an internet-facing
    web server, it would make sense to apply both the operating system benchmark and
    then the appropriate one for the chosen web server.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: CIS 基准规范涵盖了超过 140 种技术，包括常见的 Linux 服务，如 nginx、Apache 和 PostgreSQL。因此，如果您正在构建一个面向互联网的
    Web 服务器，应用操作系统基准规范和所选 Web 服务器的适当规范是有意义的。
- en: If you have a bespoke application layer, or indeed are simply using a technology
    not listed on the CIS website, do not despair—secure the underlying operating
    system using the appropriate benchmark and then apply security practices in the
    best way you can. Often, there is good advice on the internet, but figuring this
    out is beyond the scope of this book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个定制的应用层，或者只是在使用 CIS 网站未列出的技术，请不要绝望——请使用适当的基准规范保护底层操作系统，然后尽可能以最佳方式应用安全实践。互联网上通常会有很好的建议，但弄清楚这一点超出了本书的范围。
- en: A full list of the technologies for which there are CIS Benchmarks can be found
    here: [https://www.cisecurity.org/cis-benchmarks/](https://www.cisecurity.org/cis-benchmarks/).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可在此处找到所有有关 CIS 基准规范的技术的完整列表：[https://www.cisecurity.org/cis-benchmarks/](https://www.cisecurity.org/cis-benchmarks/)。
- en: Once you have obtained the security benchmark for your chosen operating system,
    it is time to consider the application of it. Before we get this far, though,
    in the next section of this chapter, we will explore in greater detail the contents
    of a CIS Benchmark for the Linux operating system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得了所选操作系统的安全基准规范，就该考虑其应用了。然而，在这一步之前，在本章的下一节中，我们将更详细地探讨 Linux 操作系统的 CIS 基准规范的内容。
- en: Exploring CIS Benchmarks in detail
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨 CIS 基准规范
- en: Let's take a practical example to explore CIS Benchmarks in greater detail by
    looking at the one for RHEL 7\. At the time of writing, this is on release version
    2.2.0 and consists of 386 pages! Thus, immediately we can see that implementing
    this benchmark is unlikely to be a trivial activity.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看 RHEL 7 的 CIS 基准规范来深入探讨 CIS 基准规范的实际示例。在撰写本文时，此版本为 2.2.0 版本，共有 386 页！因此，我们立即可以看出，实施此基准规范不太可能是一个简单的活动。
- en: As you explore the document, you will find that the section of most interest
    to us—the *Recommendations* section—is divided into subsections. Each of these
    focuses on a specific area of security within the operating system. At the time
    of writing, *section 1* is all about the initial setup of the operating system;
    parameters and configuration likely to be applied at build time. S*ection 2* is
    all about securing common services that might be installed by default on a RHEL
    7 server. *Section 3* deals with network configuration, while s*ection 4* goes
    into detail on your logging and audit logging setup to ensure you are capturing
    the requisite amount of data during daily use. This is to ensure you can audit
    your servers and find out what happened if you are unfortunate enough to suffer
    a breach or an outage. *Section 5* considers access to your server and authentication
    (this is where you will find SSH server security mentioned—in fact, you will see
    that our example of disabling remote root logins is benchmark 5.2.8 in version
    2.2.0 of the document). Finally, *section 6* is entitled *System Maintenance* and
    is intended to be run not once, but regularly, to ensure the integrity of the
    system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你浏览文档时，你会发现我们最感兴趣的部分——*建议*部分——被划分为几个子部分。每个部分都专注于操作系统中的特定安全领域。写作时，*第一部分*完全是关于操作系统的初始设置；在构建时可能会应用的参数和配置。*第二部分*则完全是关于保护可能默认安装在RHEL
    7服务器上的常见服务。*第三部分*处理网络配置，而*第四部分*详细讲解了日志记录和审计日志设置，确保你在日常使用中捕捉到足够的数据。这是为了确保你可以审计服务器，并在不幸遭遇安全漏洞或故障时查明发生了什么。*第五部分*考虑了对服务器的访问和认证（这里你会找到提到SSH服务器安全的内容——实际上，你会看到禁用远程root登录的示例在文档版本2.2.0的基准5.2.8中）。最后，*第六部分*标题为*系统维护*，旨在定期运行，而不是仅运行一次，以确保系统的完整性。
- en: Of course, we have discussed previously in this book that it is possible for
    anyone with root privileges to change core system configuration, and thus it is
    recommended that all of the benchmarks be run (or at least checked) on a regular
    basis to ensure compliance with the original policy.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们在本书中之前讨论过，任何拥有root权限的人都可以更改核心系统配置，因此建议定期运行（或至少检查）所有基准，以确保符合原始政策。
- en: We will explore this across the next two chapters of this book; however, for
    now, let's return to furthering our understanding of the CIS Benchmark itself.
    As you look into each recommendation, you will notice that each has a level associated
    with it and is either *Scored* or *Not Scored* (this is stated in the title of
    each benchmark).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书接下来的两章中探讨这个话题；然而，目前让我们先回到对CIS基准本身的进一步理解。当你查看每个建议时，你会注意到每个建议都有一个关联的等级，并且它们要么是*已评分*，要么是*未评分*（这一点会在每个基准的标题中说明）。
- en: Each of these benchmarks are intended to contribute to a final report or scoring
    of a system as part of a compliance check—and recommendations that are scored
    quite literally contribute to the final score. Thus, if your system meets the
    check, then the final score is increased—however, if it is not met, the final
    score is decreased. Those marked as *Not Scored* have no bearing on the final
    score at all. In other words, you are not marked down for failing to implement
    them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基准旨在作为合规检查的一部分，贡献于系统的最终报告或评分——而已评分的建议实际上会影响最终得分。因此，如果你的系统符合检查要求，最终得分会提高——然而，如果未符合要求，最终得分则会下降。那些标记为*未评分*的建议对最终得分没有任何影响。换句话说，未实施它们不会导致扣分。
- en: 'This, of course, does not mean they are any less important to consider. By
    way of example, let''s consider benchmark 3.7 of the version 2.2.0 RHEL 7 benchmark,
    which is entitled *Ensure wireless interfaces are disabled*. The rationale between
    each benchmark is given in the details of the benchmark, and this one states the
    following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不意味着它们在考虑时不重要。举个例子，考虑一下版本2.2.0 RHEL 7基准的3.7条，它的标题是*确保禁用无线接口*。每个基准的背后都有一个理由，这个基准的理由如下：
- en: '"If wireless is not to be used, wireless devices can be disabled to reduce
    the potential attack surface."'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: “如果无线不打算使用，可以禁用无线设备，以减少潜在的攻击面。”
- en: This is a logical approach—we know that if your device has a wireless interface,
    it should be disabled unless it is in use. In addition, wireless security protocols
    have been historically broken, just as SSLv2 was, and thus, in the long term,
    wireless network communication might not be considered to be truly secure. Nonetheless,
    on a corporate laptop running RHEL 7, you cannot guarantee that it will be connected
    to a wired network connection. Wireless networking might be the only option and,
    in this instance, you would need to leave it turned on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个逻辑上的方法 — 我们知道如果您的设备有无线接口，则应禁用它，除非在使用中。此外，无线安全协议在历史上一直存在漏洞，就像 SSLv2 一样，因此从长远来看，无线网络通信可能不被认为是真正安全的。尽管如此，在运行
    RHEL 7 的企业笔记本电脑上，您不能保证它将连接到有线网络连接。无线网络可能是唯一的选择，在这种情况下，您需要将其保持打开。
- en: Of course, the CIS Benchmark cannot make this decision for you—only you can
    know whether your system needs to have its wireless network adapters enabled (if
    present), and so it is reasonable that this is a non-scorable item.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，CIS Benchmark 不能替你做出这个决定 — 只有你才知道你的系统是否需要启用其无线网络适配器（如果有的话），因此这是一个非计分项目是合理的。
- en: By contrast, our old friend benchmark 5.2.8 (disabling remote root SSH access)
    is scored as there should be no rational reason for enabling this in an enterprise
    environment. Thus, we would expect our system to be scored down if this benchmark
    could not be met.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们的老朋友 Benchmark 5.2.8（禁用远程 root SSH 访问）被评分，因为在企业环境中启用此项没有合理理由。因此，如果不能达到这个
    Benchmark，我们期望我们的系统评分会降低。
- en: Each benchmark has details on how to test for the presence of the condition
    or configuration mentioned, along with the details on how to apply the desired
    configuration.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Benchmark 都详细说明了如何测试所述条件或配置的存在，以及如何应用所需的配置。
- en: In addition to these details, you will also note that each benchmark has a level
    associated with it that can be either 1 or 2\. In each case, for RHEL 7, you will
    see that these levels are applied to two different scenarios—the use of RHEL 7
    as a server and as a workstation. Again, this makes sense when we delve into the
    meaning of these levels.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还会注意到每个 Benchmark 都与一个级别相关联，可以是 1 或 2。在每种情况下，对于 RHEL 7，您将看到这些级别适用于两种不同的情景
    — RHEL 7 作为服务器和工作站的使用。再次深入探讨这些级别的含义时，这是有道理的。
- en: Level 1 is intended to be a sensible security baseline for you to apply to your
    environment to reduce the attack surface. It is not intended to have an extensive
    impact on the day-to-day business usage of your Linux environment, and so level
    1 benchmarks are the less intrusive ones to implement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一级别旨在成为您应用于环境中的合理安全基线，以减少攻击面。它不打算对您的 Linux 环境的日常业务使用产生广泛影响，因此第一级别的 Benchmarks
    是较不侵入性的实施方式。
- en: By contrast, level 2 benchmarks are offered to provide a much more rigorous
    level of security, and are highly likely to have an impact on the day-to-day usage
    of your environment.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，第二级别的 Benchmarks 提供了更严格的安全级别，极有可能对您环境的日常使用产生影响。
- en: If we look again at benchmark 3.7, we will see that it is categorized as level
    1 for servers and level 2 for workstations. This makes sense—a server is unlikely
    to have a wireless network adapter, and even less likely to be using it, even
    if present, thus disabling it has little or no impact on the day-to-day usage
    of the server. However, a RHEL 7 laptop would become a lot less portable if benchmark
    3.7 was implemented on it, and so the level 2 categorization warns us of this.
    Imagine having a laptop and not being able to use it on a wireless network—this
    is a concept that, to many, is unfeasible in this day and age!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次看 Benchmark 3.7，我们会看到它被分类为服务器的第一级别和工作站的第二级别。这是有道理的 — 服务器不太可能有无线网络适配器，即使有，也很少使用，因此禁用它对服务器的日常使用几乎没有影响。然而，如果在
    RHEL 7 笔记本电脑上实施 Benchmark 3.7，那么它的移动性就会大大降低，因此第二级别的分类提醒了我们这一点。想象一下拥有一台笔记本电脑却无法在无线网络上使用
    — 对许多人来说，这在今天的时代是不可行的概念！
- en: Benchmark 5.2.8 is considered level 1 for both server and workstation because
    it is already considered good practice not to use the root account for day-to-day
    operations—thus, disabling access to it over SSH should not have any impact on
    a day-to-day basis.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Benchmark 5.2.8 被认为是服务器和工作站的第一级别，因为通常情况下不建议在日常操作中使用 **root 账户** — 因此，在 SSH 上禁用对其的访问不应对日常运行产生任何影响。
- en: In an ideal world, you should read and understand all benchmarks before you
    apply them in case they have an impact on your way of doing things—for example,
    I still come across systems that make use of the root account over SSH for scripted
    operations, and while my first task is normally to rectify this, if I were to
    blindly apply the CIS Benchmark to these systems, I would break an otherwise working
    setup.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的情况下，你应该在应用基准之前阅读并理解所有基准，以免其影响你的操作方式 —— 例如，我仍然发现一些系统在脚本操作时使用root帐户进行SSH访问，虽然我的第一任务通常是纠正这一点，但如果我盲目地将CIS基准应用到这些系统上，我将破坏一个原本工作正常的设置。
- en: However, accepting that anyone who manages an Enterprise Linux environment is
    incredibly busy, you could be forgiven for thinking that you could just apply
    the scored level 1 benchmarks to your systems. Indeed, this would give you a reasonable
    security baseline while incurring a relatively low risk—yet there is no substitute
    for being thorough. In the next section of this chapter, we will look in greater
    detail at how to wisely select benchmarks without causing issues in your environment!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，承认管理企业Linux环境的任何人都非常忙，你可能会原谅认为可以简单地将得分级别1的基准应用到你的系统上。确实，这会给你一个合理的安全基线，同时带来相对较低的风险
    —— 但是彻底细致起见是无法替代的。在本章的下一节中，我们将更详细地探讨如何明智地选择基准，而不会在你的环境中引发问题！
- en: Applying security policy wisely
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 明智地应用安全策略
- en: 'As we had begun to explore in the previous section, each CIS Benchmark has
    a level and scoring associated with it. The level is of particular concern to
    us as, while we wish to secure our systems as effectively as possible, we would
    not wish to break any running systems. For this reason, it is highly advisable
    to apply the benchmarks in an isolated test environment and test your applications
    before deploying them to a production environment. Indeed, if the application
    of a benchmark breaks a given system, the following process should be executed
    in the enterprise to resolve it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中开始探讨的，每个CIS基准都有与之相关的级别和评分。级别对我们特别关注，因为虽然我们希望尽可能有效地保护我们的系统，但我们不希望破坏任何正在运行的系统。因此，强烈建议在隔离的测试环境中应用基准并测试你的应用程序，然后再将其部署到生产环境中。确实，如果应用某个基准导致某个系统出现故障，企业应执行以下流程来解决问题：
- en: Establish which benchmark caused the issue.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定哪个基准引起了问题。
- en: Determine which internal systems were affected by the benchmark.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定哪些内部系统受基准影响。
- en: Decide whether the internal systems can be changed to work with the benchmarks
    (for example, use an unprivileged account over SSH rather than root).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定是否可以修改内部系统以与基准配合工作（例如，使用SSH的非特权帐户而不是root）。
- en: Implement the changes to the internal systems and apply the benchmark universally
    or (only if there is a good reason to) make an exception for that benchmark and
    record it.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施内部系统的更改，并普遍应用基准，或者（只有在有充分理由时）为该基准提出例外并记录下来。
- en: The CIS Benchmarks could even break your Ansible automation—the simplest example
    being that you are using the root account to perform your automation tasks over,
    and you disable this as part of your CIS Benchmark deployment. In this instance,
    you would find Ansible locked out of all of your systems and, in the worst case,
    you would have to manually modify each server to reinstate Ansible access.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: CIS基准甚至可能破坏你的Ansible自动化 —— 最简单的例子是，你正在使用root帐户执行你的自动化任务，并在CIS基准部署过程中禁用此帐户。在这种情况下，你会发现Ansible无法访问你的所有系统，甚至最糟糕的情况是，你将不得不手动修改每台服务器以恢复Ansible的访问。
- en: Although we can't go through the benchmarks one by one in this chapter, in the
    following subsections, we will explore some of the relevant examples to look out
    for. It is hoped this will give you enough information to review the benchmark
    for your chosen version of Linux, and then make informed decisions on what security
    policies are in the best interests of your environment.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不能在本章逐个审查基准，但在以下小节中，我们将探讨一些相关示例以供注意。希望这能为你提供足够的信息，以审查适合你选择的Linux版本的基准，然后就你环境中安全策略的最佳利益做出知情决策。
- en: We will continue with our example of using the RHEL 7 benchmark version 2.2.0\.
    However, most of what we describe here will be applicable to other Linux platforms
    too. Configuration file paths and even log file paths might vary, but these will
    be detailed in the relevant CIS Benchmark for your operating system, so be sure
    to download the benchmark that is most relevant to you.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用RHEL 7基准版本2.2.0的示例。然而，这里描述的大部分内容也适用于其他Linux平台。配置文件路径甚至日志文件路径可能会有所不同，但这些将在适合您操作系统的相关CIS基准中详细说明，请务必下载最适合您的基准。
- en: Now that we have considered the overall principles of security policy application,
    we will dive into some specific examples, starting with the SELinux policy in
    the next section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经考虑了安全策略应用的总体原则，我们将在下一节从SELinux策略的具体示例开始深入讨论。
- en: Applying the SELinux security policy
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用SELinux安全策略
- en: Section 1.6.1 of the RHEL 7 benchmark concerns the implementation of SELinux
    and consists of checks to ensure SELinux is in enforcing mode rather than disabled
    at some level. You will note that these checks are all level 2 benchmarks, meaning
    they could break existing systems.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: RHEL 7基准的1.6.1节涉及SELinux的实施，并包括检查以确保SELinux处于强制模式，而不是在某个级别上被禁用。您将注意到，这些检查都是2级基准，这意味着它们可能会破坏现有系统。
- en: Enabling and applying SELinux is a very good idea on operating systems that
    support it, yet even at the time of writing there are many Linux applications
    that do not work with it and whose installation instructions state that SELinux
    must be disabled for the application to function. This, of course, is not ideal
    and instead you should create an SELinux policy that allows your application stack
    to work without the need to disable it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持的操作系统上启用和应用SELinux是一个非常好的主意，但即使在撰写本文时，仍有许多Linux应用程序不支持它，并且其安装说明中指出必须禁用SELinux才能使应用程序正常工作。这显然并不理想，相反，您应该创建一个SELinux策略，允许您的应用堆栈在不需要禁用SELinux的情况下工作。
- en: Not all enterprises will have the skill set of time to allow this to be completed,
    though, and so some careful consideration needs to be given to this set of benchmarks—in
    short, it should be applied if at all possible, but exceptions may be required.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有企业都有完成这项工作所需的技能和时间，因此对这一组基准需要仔细考虑 —— 简而言之，如果可能的话应用它，但可能需要做一些例外。
- en: If you are working with Ubuntu, the same logic should be applied to AppArmor,
    which is enabled by default on Ubuntu Server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Ubuntu，则应该将相同的逻辑应用于默认情况下在Ubuntu Server上启用的AppArmor。
- en: In the next section of this chapter, we will take a look at how the CIS Benchmarks
    affect the way filesystems are mounted on Linux.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一节中，我们将看一下CIS基准如何影响Linux上文件系统的挂载方式。
- en: Mounting of filesystems
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统的挂载
- en: All filesystems in Linux must be mounted before they can be used—this is quite
    simply the mapping of block devices such as a partition on a disk to a path. To
    most users, this is transparent and happens at boot time, but to those responsible
    for configuring systems, it needs some attention. For example, the `/tmp` filesystem
    is usually writable to all users, and so it is desirable to not let people execute
    files from this directory as they could put any arbitrary binary in there to be
    run by themselves or someone else. Thus, this filesystem is often mounted with
    the `noexec` flag to achieve exactly this.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，所有文件系统在使用之前必须被挂载 —— 这简单来说是将诸如磁盘分区之类的块设备映射到路径上。对于大多数用户来说，这是透明的，并且发生在启动时，但对于那些负责配置系统的人来说，这需要一些注意。例如，`/tmp`
    文件系统通常对所有用户可写，因此不希望让人们在此目录中执行文件，因为他们可以将任意二进制文件放在那里，自己或他人都可以运行。因此，通常使用 `noexec`
    标志挂载此文件系统来达到这个目的。
- en: Changing mount options for partitions (and indeed partition structure) can be
    problematic on machines that have already been deployed. In addition, many cloud
    platforms feature a flat filesystem structure and, as such, the preceding example
    of `/tmp` may not be achievable as it cannot be mounted separately from the `root`
    partition. As a result, I recommend that you factor this part of the CIS Benchmark
    into your server (or image) build process and create exclusions for public cloud
    platforms where required.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在已部署的机器上更改分区的挂载选项（甚至分区结构）可能会有问题。此外，许多云平台具有平坦的文件系统结构，因此 `/tmp` 的前述示例可能无法实现，因为它无法与
    `root` 分区分开挂载。因此，建议您将此部分CIS基准纳入到您的服务器（或映像）构建过程中，并根据需要为公共云平台创建排除项。
- en: The benchmarks in *section 1.1 *of the CIS Benchmark (entitled *Filesystem Configuration*)
    concern exactly these kinds of details and, again, these will need to be tailored
    to your environment. For example, benchmark 1.1.1.8 recommends disabling the ability
    to mount FAT filesystems, and *section 1.1.5* recommends disabling binary execution
    on `/tmp`, as discussed previously. These are both scored benchmarks and, at the
    time of writing, there should be little need to use or mount FAT volumes or execute
    files from `/tmp`. However, in some legacy environments, this could still be required
    and so this should be applied with some care.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: CIS基准测试中*第1.1节*（标题为*文件系统配置*）中的基准正是关注这些细节，且这些基准需要根据你的环境进行调整。例如，基准1.1.1.8建议禁用挂载FAT文件系统的能力，*第1.1.5节*则建议禁用在`/tmp`目录下执行二进制文件，如前所述。这些都是评分基准，目前，几乎不需要在`/tmp`目录下使用或挂载FAT卷或执行文件。然而，在某些遗留环境中，这仍然可能是必要的，因此在应用这些设置时需要小心。
- en: Similarly, there are many recommendations around having separate filesystems
    for important paths such as `/tmp` and `/var`, and also special mount options.
    All of these will work in a large number of cases but, again, it would be too
    bold to state that this will work for everyone, especially in preexisting environments,
    and so these should be applied but with an understanding of the environmental
    requirements.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，关于为重要路径（如`/tmp`和`/var`）设置独立的文件系统，以及特别的挂载选项，也有很多建议。这些方法在很多情况下是有效的，但再次强调，直接声明这些方法对所有环境都有效是过于冒险的，尤其是在已有环境中，因此这些方法应该在了解环境要求的基础上应用。
- en: Having looked at the implications of the CIS Benchmarks on how filesystems are
    mounted, we will proceed to look at the recommendations around intrusion detection
    using file checksumming.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解CIS基准对文件系统挂载的影响之后，我们将继续讨论使用文件校验和进行入侵检测的建议。
- en: Installing Advanced Intrusion Detection Environment (AIDE)
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装高级入侵检测环境（AIDE）
- en: Benchmark 1.3.1 concerns the installation of **Advanced Intrusion Detection
    Environment** (**AIDE**)—a modern replacement for the venerable **Tripwire** utility
    that can scan the filesystem and checksum all the files, thus providing a reliable
    way of detecting modifications to the filesystem.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 基准1.3.1涉及安装**高级入侵检测环境**（**AIDE**）——这是一个现代化的替代工具，取代了久负盛名的**Tripwire**，可以扫描文件系统并校验所有文件，从而提供一种可靠的方法来检测文件系统的修改。
- en: On the face of it, installing and using AIDE is a very good idea—however, if
    you have an environment with 100 machines in it and you update all of them, you
    will get 100 reports, each containing details of a large number of file changes.
    There are other solutions to this problem, including the open source OSSEC project
    ([https://www.ossec.net/](https://www.ossec.net/)), but this is not checked for
    as part of the CIS Benchmark and so it is left for you to decide what the right
    solution is for your enterprise.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，安装和使用AIDE是个非常好的主意——然而，如果你有一个包含100台机器的环境，并且对所有机器进行更新，你将收到100份报告，每份报告中都包含大量的文件变更细节。对此问题有其他解决方案，包括开源的OSSEC项目（[https://www.ossec.net/](https://www.ossec.net/)），但这并不是CIS基准测试的一部分，因此需要你决定哪种解决方案最适合你的企业。
- en: This, of course, is not to say that AIDE should not be used—far from it. Rather,
    it is to say that, if you choose to use AIDE, make sure you have processes in
    place to process and understand the reports, and to ensure that you can distinguish
    false positives (for example, a change in the checksum of a binary due to a package
    update) from genuinely malicious and unexpected modifications (for example, `/bin/ls`
    changes even though no package update has been performed).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是说AIDE不应该使用——恰恰相反。更准确地说，是如果你选择使用AIDE，确保你有相应的流程来处理和理解报告，并确保你能区分误报（例如，由于软件包更新而导致的二进制文件校验和变化）与真正恶意且意外的修改（例如，即使没有进行软件包更新，`/bin/ls`却发生了变化）。
- en: Having looked at whether AIDE is a viable tool to install on your Linux infrastructure,
    we will proceed to look at how the CIS Benchmarks impact the default configuration
    of services at boot time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看AIDE是否适合安装在你的Linux基础设施上之后，我们将继续讨论CIS基准对服务启动时默认配置的影响。
- en: Understanding CIS Service benchmarks
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解CIS服务基准
- en: Section 2.2 of the benchmark details a number of scored level 1 benchmarks around
    services that are to be disabled. Again, the rationale behind this is that the
    attack surface should be minimized, and so, for example, `httpd` should not be
    running unless a server is intended to be a web server.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 基准的第2.2节详细列出了围绕需禁用服务的若干评分为1级的基准。再次强调，背后的理由是攻击面应该最小化，因此，例如，除非服务器是作为网站服务器使用的，否则`httpd`不应运行。
- en: While logical in itself, a review of this section turns up a large number of
    services that could be vital for your environment, including `squid`, `httpd`,
    and `snmpd`. For all of these benchmarks, they should only be applied if it makes
    sense to do so. You would not turn off Apache on a web server, and neither would
    you disable `squid` on a proxy server.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一点本身合乎逻辑，但回顾这一部分时，会发现许多服务可能对你的环境至关重要，包括`squid`、`httpd`和`snmpd`。对于所有这些基准，只有在有意义的情况下才能应用。你不会在网站服务器上关闭Apache，也不会在代理服务器上禁用`squid`。
- en: However, good guidance is given with regard to these benchmarks about when they
    should be applied and, in the case of `snmpd`, there is even guidance on securing
    the service if your environment relies on this for monitoring purposes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于这些基准，在应用时有很好的指导，特别是对于`snmpd`，如果你的环境依赖于此进行监控，甚至有关于如何保护该服务的指导。
- en: X Windows
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: X Windows
- en: Benchmark 2.2.2 goes as far as ensuring that the X Windows server is actually
    uninstalled from your systems. Most servers are headless and it would be possible
    to do this—however, you would not do this for a workstation or for a system that
    performs remote desktop functions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 基准2.2.2进一步确保X Windows服务器从你的系统中实际卸载。大多数服务器都是无头的，因此可以做到这一点——但是，你不会对工作站或执行远程桌面功能的系统进行此操作。
- en: Be sure to apply this benchmark to your servers, but only when you know it is
    safe to apply it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要将这个基准应用到你的服务器上，但只有在你确认应用它是安全的情况下才进行。
- en: Allowing hosts by network
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按网络允许主机
- en: Benchmarks 3.4.2 and 3.4.3 ensure that `/etc/hosts.allow` and `/etc/hosts.deny`
    are configured—this means that, for all services that process these two files,
    only connections from networks that are allowed are actually processed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 基准3.4.2和3.4.3确保`/etc/hosts.allow`和`/etc/hosts.deny`已正确配置——这意味着，对于所有处理这两个文件的服务，只有来自允许网络的连接会被处理。
- en: This is generally a good idea—however, many organizations have good firewalls
    and some actually have policies of not allowing local firewalls on their servers
    because it complicates the process of debugging. If a connection is denied, the
    more firewalls you have, the more you have to check to find out where it was denied.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是个好主意——然而，许多组织拥有良好的防火墙，甚至有些组织的政策是不允许在服务器上使用本地防火墙，因为这会使调试过程更加复杂。如果连接被拒绝，防火墙越多，你就越需要检查，才能找出被拒绝的地方。
- en: Thus, it is recommended you apply these two benchmarks in accordance with your
    corporate security policy.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，建议你根据公司的安全政策来应用这两个基准。
- en: Local firewalls
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地防火墙
- en: The same applies for the benchmarks in *section 3.6* that concern the installation
    and configuration of iptables. Although this local firewall increases your level
    of server security, it is in contrast to many corporate security policies of having
    fewer, more centralized, firewalls rather than many localized ones. Apply these
    benchmarks in accordance with corporate policy.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第3.6节中有关安装和配置iptables的基准也适用同样的原则。尽管这个本地防火墙增加了服务器的安全性，但它与许多公司安全政策相冲突，后者倾向于使用更少、更集中化的防火墙，而不是多个本地防火墙。请根据公司政策应用这些基准。
- en: Overall guidance on scoring
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评分的总体指导
- en: You will note that many of the benchmarks I have advised you to exercise caution
    over applying are actually scored. This brings us to a wider point regarding scoring—the
    aim of applying CIS Benchmarks is not to achieve a 100% score. Rather, it is to
    achieve the highest possible score that is right for your environment and enables
    your enterprise to function correctly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我建议你在应用时要小心的许多基准实际上都有评分。这引出了关于评分的更广泛的观点——应用CIS基准的目的不是为了获得100%的分数。相反，它是为了获得最适合你环境的最高分数，从而使你的企业能够正常运行。
- en: Scoring should instead be used to establish your own baseline—once you have
    worked through all benchmarks in the manner discussed in this chapter, you will
    know which are right for your enterprise and, hence, what your target score is.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 评分应当用来建立你自己的基准——一旦你按照本章讨论的方式完成了所有基准的工作，你将知道哪些适合你的企业，从而确定你的目标分数。
- en: Through a process of auditing the results of repeated applications of the benchmark,
    repeated scoring exercises can be performed to track overall environment compliance
    and drift over time. For example, if repeated audits show an ever-decreasing score,
    then you know you have a problem with regards to compliance, for the root cause
    must be established—whether that is users making unauthorized changes to systems,
    or even rolling out new servers that have not been correctly secured.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对基准反复应用的结果进行审计，可以进行多次评分练习，以跟踪环境的整体合规性和随时间推移的偏离情况。例如，如果反复审计显示分数逐渐下降，那么你就知道在合规性方面存在问题，必须找出根本原因——无论是用户对系统进行未经授权的更改，还是推出了未正确加固的新服务器。
- en: Either way, your CIS Benchmark score will become a useful tool in monitoring
    the compliance of your Linux estate with your security policy. In the next section
    of this chapter, we will explore scripted approaches to CIS Benchmark application
    and compliance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，你的 CIS 基准分数将成为监控你的 Linux 系统与安全策略合规性的重要工具。在本章的下一部分，我们将探讨如何使用脚本化的方法来应用和确保
    CIS 基准的合规性。
- en: Scripted deployment of server hardening
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器加固的脚本化部署
- en: We have spent some time exploring the CIS Benchmarks and how they are intended
    to be worked with. Now, let us turn our attention to more practical matters—how
    to audit them and how to implement them. In this book, we have focused on Ansible
    as our chosen tool for automating such tasks, and indeed Ansible is an excellent
    solution for this purpose. With that said, of course, you will have noticed that
    the examples in the CIS Benchmark document itself are often shell commands or,
    in some cases, are simply statements regarding configuration lines that should
    exist (or not exist) in a given file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了一些时间探索 CIS 基准及其预期的工作方式。现在，让我们将注意力转向更实际的问题——如何审计它们以及如何实施它们。在本书中，我们重点关注 Ansible
    作为自动化这些任务的工具，事实上，Ansible 是一个非常适合这个目的的优秀解决方案。话虽如此，当然你已经注意到，CIS 基准文档中的示例通常是 shell
    命令，或者在某些情况下，仅仅是关于应当存在（或不存在）于某个文件中的配置行的说明。
- en: In order to clearly explain the auditing and implementation of the CIS Benchmark
    on a Linux system, I have split the examples into two. In this part of this chapter,
    we will develop traditional shell scripts for checking for CIS Benchmark compliance,
    and then for implementing the recommendations if required. This will look very
    similar to the CIS Benchmark document itself and thus will help with generating
    an understanding of how to implement them. Then, in the next chapter, we will
    develop these shell script-based examples into Ansible roles so that we can use
    our favorite automation tool to manage our CIS Benchmark compliance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰地解释如何在 Linux 系统上审计和实施 CIS 基准，我将示例分为两部分。在本章的这一部分，我们将开发传统的 shell 脚本，用于检查是否符合
    CIS 基准，并在需要时实施相关建议。这将与 CIS 基准文档本身非常相似，从而有助于我们理解如何实施它们。接下来，在下一章，我们将把这些基于 shell
    脚本的示例发展成 Ansible 角色，以便我们可以使用自己喜欢的自动化工具来管理 CIS 基准的合规性。
- en: Let's work through some examples to demonstrate how to develop such scripts,
    starting with our root login over SSH example.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些示例来演示如何开发这些脚本，从我们的 SSH 根登录示例开始。
- en: Ensuring SSH root login is disabled
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保禁用 SSH 根登录
- en: CIS recommendation 5.2.8 in version 2.2.0 of the RHEL 7 benchmark is that we
    should disable remote root logins. We have visited this example already in other
    guises, and here we will look specifically at the recommendations in the CIS Benchmark
    document to help us understand how this should be implemented.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: RHEL 7 基准版本 2.2.0 中的 CIS 建议 5.2.8 指出，我们应当禁用远程 root 登录。我们在其他情境中已经讨论过这个例子，下面我们将特别查看
    CIS 基准文档中的建议，以帮助我们理解应该如何实施这一建议。
- en: 'The document states that, to audit for this requirement (and thus score this
    item), the following test result should be observed:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 文档中指出，为了审计这一要求（并因此对这一项进行评分），应观察以下测试结果：
- en: '[PRE0]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note that the command is intended for a human being to interpret the output
    of it—this command will return the `PermitRootLogin` line from this file, regardless
    of whether it is enabled or disabled. The text shows the desired output, but assumes
    that the person running the test will read the output and check whether it is
    enabled or not—workable on a small scale, but not viable for automation purposes.
    The remediation suggested is to edit `/etc/ssh/sshd_config` to set the following
    parameter:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，命令是供人类解释其输出的——该命令将返回该文件中的`PermitRootLogin`行，无论它是启用还是禁用。文本显示了所需的输出，但假设运行测试的人会读取输出并检查是否启用——这种方式在小规模上是可行的，但不适合自动化使用。建议的修复方法是编辑`/etc/ssh/sshd_config`，设置以下参数：
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So far, so good—the CIS Benchmark document is quite descriptive, and even gives
    us a head start with our coding. However, as stated previously, these snippets
    don't really help us to either check or implement this recommendation in an automated
    manner.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利——CIS基准文档描述得相当清晰，甚至为我们的编码提供了一个良好的开端。然而，正如之前所述，这些代码片段实际上并没有帮助我们以自动化的方式检查或实施该推荐。
- en: 'Suppose we want to audit for this condition using a shell script. In this instance,
    we would want to run the `grep` command mentioned in the benchmark document, but
    use a more precise pattern to ensure we only match the `PermitRootLogin` line
    when it is set to `no`. We would then check for the desired output and `echo`
    a suitable message to the console, depending on the result of the check. This
    script might look like this (noting that there are multiple ways to achieve the
    same end result in shell scripting!):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想使用shell脚本进行此条件的审核。在这种情况下，我们需要运行基准文档中提到的`grep`命令，但使用更精确的模式，以确保我们仅在`PermitRootLogin`行被设置为`no`时才匹配该行。然后我们会检查所需的输出，并根据检查结果通过`echo`输出适当的消息到控制台。这个脚本可能看起来是这样的（请注意，在shell脚本中有多种方式可以实现相同的最终结果！）：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The script is fairly straightforward for anyone familiar with shell scripts,
    but in brief, here are the steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉shell脚本的人来说，脚本相当简单，但简而言之，步骤如下：
- en: We put some useful documentation in the comments at the top of the file so that
    we know which recommendation we are testing for. Note that recommendation numbers
    might change between document versions and so it is important to record both.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在文件顶部加入了一些有用的文档注释，以便我们知道正在测试哪个推荐。请注意，推荐编号可能会在文档版本之间发生变化，因此记录这两个编号非常重要。
- en: We `echo` a line of informative text about the test we are running.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过`echo`输出一行关于正在运行的测试的说明文本。
- en: Then, the suggested audit command from the CIS Benchmark is run, only this time
    we are checking for the presence of the `PermitRootLogin no` line. The output
    is captured in an `OUTPUT` variable.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行CIS基准中建议的审核命令，不过这次我们要检查是否存在`PermitRootLogin no`行。输出将被捕获到`OUTPUT`变量中。
- en: If the contents of `OUTPUT` are blank, then we know the line we are checking
    for does not exist in the file and the test is assumed to have failed. We can
    safely assume this because root logins are enabled by default in the OpenSSH server,
    and so if this line is absent from the configuration file, then provided there
    were no issues with our `grep` pattern, root logins are enabled. We `echo` this
    to the Terminal so that the user knows to take action.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`OUTPUT`的内容为空，则说明我们检查的行在文件中不存在，测试被认为是失败的。我们可以放心地假设这一点，因为默认情况下OpenSSH服务器启用了root登录，因此如果配置文件中缺少此行，且假设我们的`grep`模式没有问题，那么root登录已启用。我们会将这个信息通过`echo`输出到终端，让用户知道需要采取行动。
- en: The only condition under which the `OUTPUT` variable should contain text is
    when the `grep` command finds the desired pattern. If this condition is achieved,
    then we echo a different message for the user so that they know that this test
    has passed and no further action is required.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OUTPUT`变量应该包含文本的唯一条件是`grep`命令找到了所需的模式。如果满足这一条件，那么我们会输出一条不同的消息，告知用户测试通过，并且不需要进一步的操作。'
- en: 'Let''s see this script in action, along with an attempt to fix the problem
    by hand:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个脚本的实际操作，以及手动尝试修复问题：
- en: '![](img/9a53551f-7c99-4e7d-9fdd-0969f7a0caa2.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a53551f-7c99-4e7d-9fdd-0969f7a0caa2.png)'
- en: Here, we can see a prime example of the manual process, which many system administrators
    and engineers will be familiar with when managing their estates. We ran the check
    script defined previously and it yielded the response `FAILED!`. Thus, our first
    step was to take a look at the config file to see why the test failed. There were
    one of two possibilities that would have caused this result—either the line containing
    `PermitRootLogin` was not present at all, or it was commented out. In this case,
    the former proved to be true.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个典型的手动过程，许多系统管理员和工程师在管理其系统时都会遇到这个过程。我们运行了之前定义的检查脚本，结果返回了`FAILED!`。因此，我们的第一步是查看配置文件，看看为什么测试失败。造成这种结果的原因可能有两种——要么是包含`PermitRootLogin`的行根本不存在，要么是该行被注释掉了。在这种情况下，前者被证明是正确的。
- en: If the line had been present, but commented out, we could have used `sed` (or
    another inline editing tool) to uncomment the line and set the parameter to `no`.
    However, as the line was not present, we needed to append the line to the file,
    which we have done in the previous screenshot using the `tee -a` command. Note
    that this was needed in conjunction with `sudo` because only `root` can write
    to this file. We then run the test a second time and it passes. Of course, you
    will note that it would have been entirely possible to simply open this file with
    `vim` (or your favorite editor) and correct the issue manually; however, the previous
    example could lend itself to a scripted solution.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该行已经存在，但被注释掉了，我们可以使用`sed`（或其他内联编辑工具）取消注释该行，并将参数设置为`no`。然而，由于该行并不存在，我们需要将该行添加到文件中，这在前一个截图中已经使用`tee
    -a`命令完成。请注意，这需要与`sudo`一起使用，因为只有`root`用户才能写入此文件。然后我们再次运行测试，测试通过了。当然，你会注意到，也完全可以直接用`vim`（或你喜欢的编辑器）打开这个文件，手动修复问题；然而，前面的示例可以为脚本化解决方案提供支持。
- en: As shown from the preceding example, this is an incredibly slow and manual process.
    This would be bad enough to perform on a single server (for example, the template
    image), but imagine scaling this up across an entire estate of Linux servers,
    and then to all the recommendations in the CIS Benchmark document. The task would
    be a full-time (and very tedious) job for someone.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子来看，这是一个极其缓慢且手动的过程。如果在单一服务器（例如模板镜像）上执行这个过程已经够糟糕了，想象一下要在整个Linux服务器系统中扩展这个过程，再加上所有CIS基准文档中的推荐项。这项任务将成为某个人的全职（且非常繁琐）的工作。
- en: 'It''s better to automate the process and you will note that, in the CIS Benchmark
    document, there is not only a test case for auditing the recommendation on a server,
    but also a recommended alteration. In most cases, this is simply a statement of
    the line(s) that should be present in the given configuration file(s). In this
    case, we want to assert the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的做法是自动化这个过程，你会注意到，在CIS基准文档中，不仅有审计服务器上推荐设置的测试用例，还有推荐的修改内容。在大多数情况下，这只是说明在给定的配置文件中应该存在哪些行。
    在这种情况下，我们要确保以下内容：
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we were to try and remedy this issue by developing our shell script further,
    we would need to perform the following steps when the test results are in a `FAILED!`
    state (on an `OK` result, no further action is necessary):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试通过进一步开发Shell脚本来解决这个问题，当测试结果为`FAILED!`时，我们需要执行以下步骤（对于`OK`结果，不需要进一步操作）：
- en: 'As we have failed to match the desired pattern in the file, we know that the
    line is either present, but has the wrong setting, or is not present at all (either
    absent or commented out). We can ignore the difference between the last two possibilities
    as it will do no harm to leave the commented out line in place and add the correct
    line in. Thus, our first task is to test for the presence of the `PermitRootLogin`
    line, regardless of its setting:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们未能在文件中匹配到所需的模式，我们知道该行要么存在，但设置错误，要么根本不存在（可能是缺失或被注释掉）。我们可以忽略后两种可能性之间的区别，因为保留被注释掉的行并添加正确的行是不会造成任何问题的。因此，我们的第一项任务是测试`PermitRootLogin`行是否存在，无论它的设置是什么：
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the previous screenshot, we are looking for any line in the configuration
    file that begins with `PermitRootLogin`. If we get nothing back (our positive
    test case), then we know we must add the line to the file by adding the following
    directly under the `if` statement:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前一个截图中，我们正在寻找配置文件中以`PermitRootLogin`开头的任何一行。如果没有返回任何内容（我们的正面测试案例），那么我们就知道必须通过在`if`语句下方直接添加以下内容来将该行添加到文件中：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So far, so good. However, if our `grep` command did return some output, we
    know the line is present and the value is incorrect, and so we can use a tool
    such as `sed` to modify the line in place:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。然而，如果我们的`grep`命令确实返回了一些输出，我们就知道该行存在且值不正确，因此我们可以使用像`sed`这样的工具来就地修改该行：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we have modified the file (regardless of the route taken), we know we
    must restart `sshd` for the changes to be picked up. Thus, under the closing `fi`
    statement of the inner `if` construct, we add the following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们修改了文件（无论采用哪种方式）后，我们知道必须重启`sshd`才能使更改生效。因此，在内层`if`结构的`fi`语句结束处，我们添加如下内容：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we run this with an SSH configuration where this setting is not present,
    we see the following behavior—note that a second run of the script shows that
    the modifications were successful:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在SSH配置中运行此命令且该设置不存在时，我们会看到以下行为——请注意，第二次运行脚本时，显示修改已成功：
- en: '![](img/151d712f-2ab1-46e3-86d0-cc03e393c074.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/151d712f-2ab1-46e3-86d0-cc03e393c074.png)'
- en: 'Similarly, if we run it and the line is present and not correct according to
    the CIS Benchmark, we see the following:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，如果我们运行它，且该行存在但不符合CIS基准，我们会看到以下情况：
- en: '![](img/d988510e-b2a2-4b9a-ba37-3a5e11fe7783.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d988510e-b2a2-4b9a-ba37-3a5e11fe7783.png)'
- en: This is excellent—we have just used shell scripts to automate one of the recommendations
    in the CIS Benchmark document. However, you will note that the shell script we
    developed contains a lot of repetition and would not be easy to pick up by someone
    else.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常棒——我们刚刚使用了shell脚本来自动化CIS基准文档中的一项建议。然而，你会注意到我们开发的shell脚本包含了很多重复的部分，其他人要理解起来会有一定难度。
- en: Further, this recommendation is one of the more simple ones—there is only one
    line to modify in one file in this case. What if the recommendation is more in
    depth? Let's take a look at that in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这项建议是比较简单的——在这种情况下，只有一个文件中的一行需要修改。如果建议内容更为复杂呢？我们在下一节中看看这个问题。
- en: Ensuring packet redirect sending is disabled
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保禁用数据包重定向发送
- en: Recommendation 3.1.2 of the version 2.2.0 RHEL benchmark is somewhat more detailed—this
    is a scored level 1 benchmark that ensures that your servers do not send routing
    information to other hosts. Unless they have been configured as a router, there
    should be no good reason for them to do this.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 版本2.2.0的RHEL基准中的推荐3.1.2稍微详细一些——这是一个评分为级别1的基准，确保你的服务器不会向其他主机发送路由信息。除非它们被配置为路由器，否则没有合理的理由这么做。
- en: 'From the documentation itself, we can see that the recommended audit commands
    (and results) are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从文档本身可以看到，推荐的审计命令（及其结果）如下：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The commands to be run begin with the `$` character, while the desired results
    are shown on the following line. We can already see that developing this into
    a shell script is going to take some work—we need to validate the output of the
    two `sysctl` commands, and then also check the configuration files to ensure that
    the parameters will persist across reboots and kernel parameter reloads.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行的命令以`$`字符开始，而期望的结果显示在下一行。我们已经可以看到，将其开发成一个shell脚本需要一些工作——我们需要验证两个`sysctl`命令的输出，然后还需要检查配置文件，以确保这些参数在重启和内核参数重新加载时能保持不变。
- en: 'We can check for the current kernel parameter setting quite easily using some
    shell code such as this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一些shell代码轻松检查当前的内核参数设置，例如：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will note that the code structure is almost identical to that which we used
    to check the `PermitRootLogin` parameter for SSH—hence, although the code to automate
    our auditing process is getting easier, it is also getting highly repetitious
    and inefficient. A similar block of code would then be used to check the value
    of the `net.ipv4.conf.default.send_redirects` parameter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，代码结构几乎与我们用于检查SSH中`PermitRootLogin`参数的代码相同——因此，尽管自动化审计过程的代码变得更容易，但它也变得高度重复且低效。类似的代码块将用于检查`net.ipv4.conf.default.send_redirects`参数的值。
- en: 'We can also check the persistent configuration of these parameters, again,
    by building the audit commands from the CIS Benchmark document into a conditional
    structure similar to what we did previously:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查这些参数的持久性配置，同样通过将CIS基准文档中的审计命令构建成类似我们之前做的条件结构：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once again, we would replicate this block for the `net.ipv4.conf.default.send_redirects`
    parameter. Thus, once again, we have successfully built up a script to audit this
    benchmark—running it on our system looks something like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f2098e0-5ec0-4253-837d-66769c2d0ffd.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: That's 35 lines of shell script (albeit with a few comments at the top of the
    file), much of it repetitious, and all just to know that we have completely failed
    to meet this requirement! Once again, if we are to expand this example to resolve
    the issues, we need to expand our script.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the active kernel parameters is quite easy—we just need to add a series
    of commands such as the following into the `FAILED!` branch of our first two `if`
    constructs:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We could add something similar for `net.ipv4.conf.default.send_redirects` in
    the appropriate place.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: For our persistent parameters, however, things are a bit more tricky—we need
    to deal with the two possible configuration file scenarios as with the `PermitRootLogin`
    example, but now we have a configuration that is built up of a series of files
    and we must choose which file to modify if the parameter isn't present.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, once again, we must build up a block of code to handle these two differing
    scenarios:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That''s a pretty ugly and difficult-to-read piece of code. What it does is
    as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: It runs a second `grep` against the known configuration files to see whether
    the parameter is in there, regardless of its value.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the parameter is not set, then we choose to append it to `/etc/sysctl.conf`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the parameter is set, we instead use `sed` to modify the parameter, forcing
    it to our desired value of `0`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now when we run this script as before, we get the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/615e1ba1-da69-44f4-8663-071f9342850e.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: As we can see, this works nicely; however, we are now up to 57 lines of shell
    code and much of it starting to get quite unreadable. All of this is for setting
    just two kernel parameters, and although we have now built up a fairly solid code
    base for taking the CIS Benchmarks (along with their recommended audit and remediation
    steps), it is not scaling at all well.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Further, these scripts are all being run locally in the preceding example—what
    if we wanted to run them from a central place? In the next section, we will take
    a look at exactly that.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Running CIS Benchmark scripts from a remote location
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The challenge with shell scripting is that, while it is easy to run on the machine
    where the scripts exist, it is a little more difficult to do on a remote machine.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The scripts we developed previously are designed to be run from an unprivileged
    account—thus, we have used `sudo` on the steps that specifically require root
    access to be run. This is fine when you have passwordless sudo access set up,
    but when a password is required for elevated access using `sudo`, this further
    complicates the task of running the scripts remotely.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the entire script could be run as root and, depending on your use
    case and security requirements, this may or may not be desirable. Let''s take
    a look at the task of running our send redirect example on a remote system called
    `centos-testhost`. To achieve this, we need to do the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，整个脚本也可以作为root用户运行，根据你的使用场景和安全需求，这可能是可取的，也可能不是。让我们看看如何在名为`centos-testhost`的远程系统上运行我们的重定向发送示例。为此，我们需要做以下几步：
- en: SSH into the remote system and authenticate—this could be with a password or
    SSH keys that were set up previously.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过SSH登录远程系统并进行身份验证——这可以通过密码或先前设置的SSH密钥来完成。
- en: Invoke the shell required to run the script we have developed—in our examples,
    this is `/bin/bash`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用执行我们开发的脚本所需的shell——在我们的示例中，这是`/bin/bash`。
- en: We add the `-s` flag to the `bash` command—this causes the shell to read its
    command from the standard input (that is, the commands can be piped to it).
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向`bash`命令添加了`-s`标志——这会导致shell从标准输入读取其命令（即，命令可以通过管道传输给它）。
- en: Finally, we pipe our script across to `bash`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将脚本传输给`bash`。
- en: There is one further caveat to this approach—in our script, we have boldly assumed
    that the commands we rely on (such as `sysctl`) exist within one of the directories
    defined in the PATH variable. It could be argued that this is flawed—however,
    it can also make script development easier, especially when building up scripts
    that might be used in a cross-platform environment.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法还有一个附加的警告——在我们的脚本中，我们大胆地假设我们依赖的命令（如`sysctl`）存在于PATH变量定义的某个目录中。有人可能会认为这种做法有缺陷——然而，这也可以使脚本开发更加便捷，特别是当编写的脚本可能在跨平台环境中使用时。
- en: For example, although we have been exclusively working with the RHEL 7 CIS Benchmark
    in this chapter, it is fair to assume that Ubuntu Server would also want to have
    SSH root logins disabled, and not send packet redirect information unless it is
    explicitly configured as a router. Hence, we might reasonably expect the scripts
    we have developed so far to work on both systems and save us some development
    effort.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尽管我们在本章中一直专注于RHEL 7 CIS基准，但可以合理推测，Ubuntu Server也希望禁用SSH根登录，并且除非显式配置为路由器，否则不会发送数据包重定向信息。因此，我们可以合理地期望到目前为止开发的脚本能够在这两种系统上运行，并为我们节省一些开发工作。
- en: 'However, on RHEL 7 (and CentOS 7), the `sysctl` command is found in `/usr/sbin/sysctl`,
    whereas on Ubuntu it is in `/sbin/sysctl`. This difference in itself could be
    handled by defining the path to `sysctl` in a variable at the top of the script,
    and then calling it via this—however, even so, it would mean modifying many scripts
    related to CIS hardening, like so:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在RHEL 7（和CentOS 7）中，`sysctl`命令位于`/usr/sbin/sysctl`，而在Ubuntu中则位于`/sbin/sysctl`。这种差异本身可以通过在脚本顶部定义`sysctl`的路径变量来处理，然后通过此变量调用它——但是，即便如此，这也意味着需要修改许多与CIS强化相关的脚本，像这样：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In short, this is better than our original approach, but still highly manual
    and messy. Returning to the task of running our existing script remotely, putting
    all our requirements together, we might run it using the following command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这比我们最初的方法更好，但仍然非常手动且杂乱。回到远程运行现有脚本的任务，结合我们所有的需求，我们可能会使用以下命令来运行它：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding command assumes we are running the script as the current user
    on the local system—we could explicitly set the user by adding it before the hostname:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令假设我们以当前用户身份在本地系统上运行脚本——我们可以通过在主机名之前明确指定用户来实现：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running this against our remote system (including a second run to ensure the
    modifications took place effectively) will look something like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的远程系统上运行此命令（包括第二次运行以确保修改生效）看起来可能像这样：
- en: '![](img/987f3c66-8e88-4810-ae4e-d6cbd4dbe130.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/987f3c66-8e88-4810-ae4e-d6cbd4dbe130.png)'
- en: We can see that this has been effective against our remote system and that no
    modification to our original script was required. All of this, while very effective,
    is somewhat inefficient and cumbersome, especially when compared to our experience
    with Ansible. In fact, it is fair to say that these examples demonstrate the value
    that Ansible brings to automating fundamental system administration tasks. To
    develop this, in the next chapter, we will look at how to build upon our foundation
    in CIS Benchmarks by developing Ansible playbooks to carry out the tasks required.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's highly connected world, system security is paramount, and while Linux
    has long been regarded as a secure operating system, there is much that can be
    done to enhance its security. CIS Benchmarks provided one such standardized approach
    by bringing together a consensus on security best practices from across the technology
    industry. CIS Benchmarks, however, are extensive and, if applied by hand, would
    take many hours for an engineer to implement on a single system. Thus, automating
    their deployment is of vital importance.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you have learned about CIS Benchmarks, what they are for, and
    the benefits they bring. You then learned about the balance between security and
    application support, and how to make informed decisions when applying a server
    hardening policy. You also learned how to make use of shell scripts to apply some
    example security policies on a Linux server.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will develop this concept further by demonstrating effective
    methods for automating the deployment of CIS Benchmark recommendations using Ansible.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why are CIS Benchmarks relevant to securing Linux servers?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you secure Ubuntu Server with the appropriate benchmark and then install
    nginx on that server, does that also need hardening?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a level 1 and a level 2 benchmark?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are some benchmarks scored and others not?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you check using a shell script that a given audit requirement has been
    met?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: State three possible issues relating to automated modification of configuration
    files using a shell script.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do shell scripts not scale well for the automated rollout of CIS Benchmarks?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you run a CIS Benchmark shell script on a remote server using SSH?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you want to make use of a variable to specify the path to a binary
    used to implement a CIS recommendation?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why might you use sudo for individual commands within a script rather than needing
    the whole script to run as root?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To review common questions about the CIS Benchmarks, please refer to [https://www.cisecurity.org/cis-benchmarks/cis-benchmarks-faq/](https://www.cisecurity.org/cis-benchmarks/cis-benchmarks-faq/).
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full list of CIS Benchmarks is available at [https://www.cisecurity.org/cis-benchmarks/](https://www.cisecurity.org/cis-benchmarks/).
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a greater understanding of Linux shell scripting, please refer to *Mastering
    Linux Shell Scripting, Second Edition, Andrew Mallett* and *Mokhtar Ebrahim* ([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-linux-shell-scripting-second-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-linux-shell-scripting-second-edition)).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要深入了解 Linux Shell 脚本编程，请参考 *Mastering Linux Shell Scripting, Second Edition,
    Andrew Mallett* 和 *Mokhtar Ebrahim* ([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-linux-shell-scripting-second-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-linux-shell-scripting-second-edition))。
- en: To understand more about SELinux and how to create your own policies, please
    refer to *SELinux System Administration, Second Edition, Sven Vermeulen* ([https://www.packtpub.com/gb/networking-and-servers/selinux-system-administration-second-edition](https://www.packtpub.com/gb/networking-and-servers/selinux-system-administration-second-edition)).
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于 SELinux 及如何创建自定义策略的内容，请参考 *SELinux System Administration, Second Edition,
    Sven Vermeulen* ([https://www.packtpub.com/gb/networking-and-servers/selinux-system-administration-second-edition](https://www.packtpub.com/gb/networking-and-servers/selinux-system-administration-second-edition))。
