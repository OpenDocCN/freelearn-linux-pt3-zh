<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Managing Users on Linux</h1>
                </header>
            
            <article>
                
<p>No Linux server is complete without a method for users to access it. Whether administrators or end users, and whether using local or centralized credentials, Linux servers need a mechanism for users (and even tools such as Ansible!) to access them.</p>
<p>User management is, like all good server configuration and maintenance activities, an ongoing job. Credentials need rotating on a regular basis, to ensure the security and integrity of systems. Employees come and go, meaning access details must be updated accordingly. Indeed, access management can, in a busy organization, be a full-time job in itself!</p>
<p>In this chapter, we will explore, through hands-on examples, how to automate your user and access management through Ansible, in a way that is consistent with our <strong>Standard Operating Environment</strong> (<strong>SOE</strong>) model.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Performing user account management tasks</li>
<li>Centralizing user account management with <strong>Lightweight Directory Access Protocol</strong> (<strong>LDAP</strong>)</li>
<li>Enforcing and auditing configuration</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p><span>This chapter includes examples, based on the following technologies:</span></p>
<ul>
<li class="mce-root">Ubuntu Server 18.04 LTS</li>
<li class="mce-root">CentOS 7.6</li>
<li class="mce-root">Ansible 2.8</li>
</ul>
<p>To run through these examples, you will need access to two servers or virtual machines running one each of the operating systems just listed, and also, Ansible. Note that the examples given in this chapter may be destructive in nature (for example, they add and remove user accounts, and make changes to server configuration) and, if run as is, are only intended to be run in an isolated test environment.</p>
<p class="mce-root">Once you are satisfied that you have a safe environment in which to operate, let's get started on looking at the installation of new software packages with Ansible.</p>
<p class="mce-root"><span>All example code discussed in this chapter is available from GitHub, at the following URL:</span><span> <a href="https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter10">https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter10</a>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performing user account management tasks</h1>
                </header>
            
            <article>
                
<p>At the most fundamental level, every Linux server in your environment will require some degree of access for users. In an enterprise setting where there could be hundreds, if not thousands, of servers, a centralized user management system such as LDAP or Active Directory would be an ideal solution as, taking the examples of a user leaving or changing their password, they can do this in one place, and it is applied across all servers. We will explore this aspect of Enterprise Linux management and automation in the next section, <em>Centralizing user account management with LDAP</em>.</p>
<p>For now, though, let us concern ourselves with local account management—that is, accounts that are created on each and every Linux server where access is required. Even when a centralized solution such as LDAP is present, local accounts are still a requirement—if for no other purpose than to serve as an emergency access solution, should the directory service fail.</p>
<div class="packt_infobox">Note that, as with all Ansible examples in this book, they can be run equally well on 1, 100, or even 1,000 servers. In fact, the use of Ansible reduces the need for a centralized user management system, as user account changes can be pushed out across the entire estate of servers with ease. However, there are good reasons not to rely solely on this—for example, one server being down for maintenance during an Ansible playbook run means it will not receive the account changes being made. In the worst-case scenario, this server could then pose a security risk once it is brought back into service. </div>
<p>Starting in the next section, we will explore the ways in which Ansible can assist with your local account management. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding and modifying users with Ansible</h1>
                </header>
            
            <article>
                
<p>Whether you are configuring a brand new server for the first time after it has been built or making changes when a new employee joins the company, adding user accounts to a server is a commonly required task. Thankfully, Ansible has a module called <kbd>user</kbd>, which is designed to perform user account management tasks, and we shall proceed to use exactly this.</p>
<p>Throughout our previous examples, we have been very careful to highlight the differences between platforms such as Ubuntu and CentOS, and user account management requires a little consideration here too.</p>
<p>Take, for example, the following shell command (which we will later automate in Ansible):</p>
<pre><strong>$ useradd -c "John Doe" -s /bin/bash johndoe</strong> </pre>
<p>This command could be run on either CentOS 7 or Ubuntu Server 18.04, and would yield the same results, namely:</p>
<ul>
<li>The user account <kbd>johndoe</kbd> would be added with the next free <strong>user identification number</strong> (<strong>UID</strong>) for users.</li>
<li>The account comment would be set to <kbd><span>John Doe</span></kbd>. </li>
<li>The shell would be set to <kbd><span>/</span><span>bin/bash</span></kbd> . </li>
</ul>
<p>Indeed, you could run this command on just about any Linux system, and it would work. The differences start, however, when you consider groups, especially built-in ones. For example, if you wanted this account to be able to use sudo for root access (that is, <kbd>johndoe</kbd> is a system administrator), you would want to put this account into the <kbd>wheel</kbd> group on CentOS 7. On Ubuntu Server, however, there is no wheel group, and attempting to put the user into such a group would result in an error. Instead, on Ubuntu, this user would go into the <kbd>sudo</kbd> group.</p>
<p>It is subtle differences like this that could trip you up when it comes to automated user account management across different Linux distributions—however, as long as you remain mindful of such things, you can easily create Ansible playbooks or roles, to manage your Linux users with ease.</p>
<p>Let's build on this example, to instead create the <kbd>johndoe</kbd> user in an Ansible role, such that access for them can be rolled out on all Linux servers. The code for <kbd>roles/addusers/tasks/main.yml</kbd> to perform the same function as the shell of the preceding command should look something like the following:</p>
<pre>---<br/>- name: Add required users to Linux servers<br/>  user:<br/>    name: johndoe<br/>    comment: John Doe<br/>    shell: /bin/bash</pre>
<p>If we run this role in the usual way, we can see that the user account gets created on the first run, and that no action is taken if we run the playbook a second time. This is denoted in the following screenshot, which shows the preceding role being run twice—the <kbd>changed</kbd> and <kbd>ok</kbd> statuses show when a user account is added, and when no action is taken because it already exists respectively:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/427e80b7-f5c6-4dbc-bd88-65995df713c9.png" style="width:46.25em;height:32.00em;"/></p>
<p>So far, so good—however, this example is rather skeletal in nature—our user has no password set, no group membership, and no authorized SSH keys. We demonstrated previously that we can run an Ansible role containing the user module more than once and changes will only be made if required, and we can leverage this to our advantage. Let's now expand our example role, to add these things.</p>
<p>Before we get into our next example, we will demonstrate how to generate a password hash, using Ansible. Here, we will choose the word <kbd>secure123</kbd>. The <kbd>user</kbd> module of Ansible is capable of setting and modifying user account passwords, but it does not (for very good reasons) allow you to specify the password in plaintext. Instead, you must create a password hash, to send to the machine being configured. In <a href="0c3b40ef-5f31-4fd1-b05f-d549444db163.xhtml" target="_blank">Chapter 6</a>, <em>Custom Builds with PXE Booting</em>, we looked at a way to do this with a small amount of Python code, and you are welcome to reuse this method here. However, you can also make use of Ansible's vast array of filters, to generate a password hash from a string. Run the following command from the shell:</p>
<pre><strong>$ ansible localhost -i localhost, -m debug -a "msg={{ 'secure123' | password_hash('sha512') }}"</strong></pre>
<p>Running this produces a password hash that you can copy and paste into your role, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e3ce49b6-a39d-4dac-aabc-1cd62186d762.png" style="width:46.25em;height:9.25em;"/></p>
<p>This is very useful in itself—however, let's bear something in mind: no password hash is completely secure. Remember that once, MD5 hashes were considered secure, but are now not. Ideally, you should not be storing the hash in plaintext either, and should regenerate it on every system as it contains a unique salt. Luckily, we can use the <kbd>password_hash</kbd> filter in a role directly to achieve this. </p>
<p>In the following example, we demonstrate how to store the password string in a variable, and then, how to use the <kbd>password_hash</kbd> filter to generate the hash for the remote system. In a real-world use case, you would replace the plaintext variable file with an Ansible vault file so that at no point is either the original password or hash stored unencrypted. </p>
<ol>
<li>First of all, let's create <kbd>roles/addusers/vars/main.yml</kbd>, and store John Doe's password in a variable, as follows:</li>
</ol>
<pre style="padding-left: 60px">---<br/>johndoepw: secure123</pre>
<ol start="2">
<li>Next, let's create an SSH key pair for this user, in the directory <kbd>roles/addusers/files/</kbd>, by running the following command in that directory:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ ssh-keygen -b 2048 -t rsa -f ./johndoe_id_rsa -q -N ''</strong></pre>
<p style="padding-left: 60px">Of course, it is likely in an enterprise setting that the user would generate their own key pair and provide an administrator with the public key for distribution to the systems they will use—however, for our example here, it is easier to demonstrate with a newly generated key pair.</p>
<ol start="3">
<li>Finally, let's say that <kbd>johndoe</kbd> is going to administer Ubuntu systems, and so, should be in the <kbd>sudo</kbd> group. Our resulting role should now look like this:</li>
</ol>
<pre style="padding-left: 60px">---<br/>- name: Add required users to Linux servers<br/>  user:<br/>    name: johndoe<br/>    comment: John Doe<br/>    shell: /bin/bash<br/>    groups: sudo<br/>    append: yes<br/>    password: "{{ johndoepw | password_hash('sha512') }}"<br/><br/>- name: Add user's SSH public key<br/>  authorized_key:<br/>    user: johndoe<br/>    state: present<br/>    key: "{{ lookup('file', 'files/johndoe_id_rsa.pub') }}"</pre>
<ol start="4">
<li>Running the code yields <kbd>changed</kbd> results, as we would expect, and the following screenshot shows the successful addition of the user and their corresponding SSH public key:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bcaecbf1-eaf7-4cbd-a592-6d20aab28cc3.png" style="width:38.92em;height:17.42em;"/></p>
<p>Note that we have successfully modified the <kbd>johndoe</kbd> account here, as we created it earlier in this section—however, we could also have run this most recent role before the account creation, and the end result would have been the same. That is the beauty of Ansible—you don't need to write different code for modifications and additions. There are many other modifications possible with the <kbd>user</kbd> module, and it should serve most of your needs.</p>
<p>Returning briefly to the <kbd>vars/main.yml</kbd> file we created earlier, we left this in plaintext for simplicity in this example. However, we can very easily encrypt our existing file, using the following command:</p>
<pre><strong>$ ansible-vault encrypt main.yml</strong></pre>
<p>The following screenshot shows this encryption process in action:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/75836cdd-818f-404d-9391-c9b353ec1667.png" style="width:39.58em;height:16.17em;"/></p>
<p>The data is now encrypted at rest! We can still run the playbook without decrypting it—simply add the <kbd>--ask-vault-pass</kbd> parameter to the <kbd>ansible-playbook</kbd> command, and enter your chosen vault password when prompted. </p>
<p>Before concluding this section, it is worth noting that we can also leverage <kbd>loops</kbd>, to create multiple accounts at once. The following example creates two new users with differing group membership, and with distinct username and matching comments on their accounts. Expanding this example to address initial passwords and/or SSH keys is left as an exercise for you, but you should have enough information to build upon to achieve this. The code can be seen below:</p>
<pre>---<br/>- name: Add required users to Linux servers<br/>  user:<br/>    name: "{{ item.name }}"<br/>    comment: "{{ item.comment }}"<br/>    shell: /bin/bash<br/>    groups: "{{ item.groups }}"<br/>    append: yes<br/>    state: present<br/>  loop:<br/>    - { name: 'johndoe', comment: 'John Doe', groups: 'sudo'}<br/>    - { name: 'janedoe', comment: 'Jane Doe', groups: 'docker'}</pre>
<p>Noting that we created <kbd>johndoe</kbd> earlier in this chapter, we can see that if we run this role, the <kbd>janedoe</kbd> user is the only account created as they did not already exist—the following screenshot shows exactly this. <kbd>janedoe</kbd> shows a <kbd>changed</kbd> status, informing us that a change was made—in this case, the account was created. The <kbd>ok</kbd> status against the <kbd>johndoe</kbd> user account tells us that no action was performed, as can be seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e45a3d06-0bf6-4cfc-8e1a-83d531829a8b.png" style="width:36.00em;height:17.50em;"/></p>
<p>In this way, user accounts can be created and managed at scale, across a wide number of Linux servers. As we can see in the preceding screenshot, in the usual Ansible manner, only the required changes are made, with existing accounts left unchanged. While adding accounts is straightforward, we must also consider that employees also leave enterprises from time to time, and so, account cleanup is also required in this instance.</p>
<p>We will explore the ways in which Ansible can assist with removing user accounts and tidying up after them, in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing users with Ansible</h1>
                </header>
            
            <article>
                
<p>Although we have shown that it is easy to add and modify user accounts with Ansible, we must consider removal as a separate case. The reason for this is simple—Ansible assumes that, if we use the <kbd>user</kbd> module in conjunction with a <kbd>loop</kbd> to add both <kbd>johndoe</kbd> and <kbd>janedoe</kbd>, it will add them if they do not exist; otherwise, it will modify them. If, of course, they match the state described by the role or playbook, then it will do nothing at all. </p>
<p class="mce-root">However, Ansible assumes nothing about the state prior to it being run. Thus, if we delete <kbd>johndoe</kbd> from the loop described previously and run the playbook again, this account is not removed. As a direct result of this, we must handle account removal separately.</p>
<p>The following code will remove this user account:</p>
<pre>---<br/>- name: Add required users to Linux servers<br/>  user:<br/>    name: johndoe<br/>    state: absent</pre>
<p>Now, if we run this command, the output should look something like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b4f2b703-028d-4ed1-bb20-4dca89fe2d5c.png" style="width:38.75em;height:14.42em;"/></p>
<p>Running this role is the equivalent of using the <kbd>userdel</kbd> command in the shell—the user account is removed, along with all group memberships. However, the <kbd>home</kbd> directory is left intact. This is normally the safest route, as users might have stored important code or other data in their <kbd>home</kbd> directory, and often, it is best for someone to sanity-check that the directory is safe to remove, before it is actually removed. If you are sure that you want to remove the directory (which is best practice, for both security reasons and to free up disk space), then add the following code to the role we just created:</p>
<pre>- name: Clean up user home directory<br/>  file:<br/>    path: /home/johndoe<br/>    state: absent</pre>
<p>This performs a recursive delete of the <kbd>path</kbd> specified, so use this with care!</p>
<p>With these practical examples and a little additional detail from the documentation, you should be in a good position to automate your local account tasks with Ansible. In the next section, we will explore the use of centralized user account management with LDAP.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Centralizing user account management with LDAP</h1>
                </header>
            
            <article>
                
<p>Although Ansible performs a fine job when it comes to managing user accounts across an estate of servers, the best practice in an enterprise is to make use of a centralized directory system. A centralized directory is able to perform a number of tasks that Ansible can not—for example, enforcing password security criteria, such as length and character types, password expiry, and account lockout when too many incorrect passwords are tried. As such, it is highly recommended that such a system be used in the enterprise.</p>
<p>Indeed, many enterprises already have such a system in place, two common ones being FreeIPA and Microsoft <strong>Active Directory</strong> (<strong>AD</strong>). In the following sections, we will explore the integration of these two systems with your Linux servers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microsoft AD</h1>
                </header>
            
            <article>
                
<p>As this is a book on Linux automation, an in-depth discussion of Microsoft AD and its setup and configuration is well beyond its scope. Suffice to say that in the context of Linux, AD is best suited to centralized user account management, although, of course, its capabilities are far greater than this. Most organizations that need an AD server will already have one set up, and so, our concern is not with this aspect, but with getting our Linux servers to authenticate against it.</p>
<p>On most modern Linux distributions, the <kbd>realmd</kbd> tool is used to join the Linux server in question to AD. Next, we consider a hypothetical example of joining a CentOS 7 server to AD—however, every organization, their AD setup, organizational units, and so on will be different, and so, there is no one-size-fits-all solution here. </p>
<div class="packt_tip">As you will no doubt be aware by now, performing this process on Ubuntu will be very similar, except that you will use the <kbd>apt</kbd> module in place of <kbd>yum</kbd>, and the package names could differ. Once <kbd>realmd</kbd> and its required packages are installed, the process is identical.</div>
<p><span>It is hoped, though, that the following code given provides you with a good basis on which to develop your own Ansible role to join AD.</span></p>
<ol>
<li>Before beginning the process of joining the directory, it is vital that the Linux server is using the correct DNS servers that contain the appropriate <strong>Service</strong> (<strong>SRV</strong>) records for the domain. Often, these DNS servers will be the AD servers themselves, but that again will vary from organization to organization.</li>
<li>The <kbd>realmd</kbd> tool must be installed, along with a number of supporting packages. Let's create a role called <kbd>realmd</kbd>, using our familiar <kbd>roles</kbd> directory structure. The <kbd>roles/realmd/tasks/main.yml</kbd> should begin with the following code, to install the required packages:</li>
</ol>
<pre style="padding-left: 60px">---  <br/>- name: Install realmd packages<br/>  yum:<br/>    name: "{{ item }}"<br/>    state: present<br/>  loop:<br/>    - realmd<br/>    - oddjob<br/>    - oddjob-mkhomedir<br/>    - sssd<br/>    - samba-common<br/>    - samba-common-tools<br/>    - adcli<br/>    - krb5-workstation<br/>    - openldap-clients<br/>    - policycoreutils-python</pre>
<p style="padding-left: 60px">Some of these packages offer supporting functions—for example, <kbd>openldap-clients</kbd> is not directly required, but can be very useful in debugging directory issues.</p>
<ol start="3">
<li>Once our prerequisite packages are installed, our next task is to join the Active Directory itself. Here, we are assuming the presence of <kbd>roles/realmd/vars/main.yml</kbd> with the <kbd>realm_join_password</kbd>, <kbd>realm_join_user</kbd>, and <kbd>realm_domain</kbd> variables set. As this file might well contain a password with sufficient privileges to join the AD domain, it is recommended that this variables file be encrypted with <kbd>ansible-vault</kbd>. Run the following code:</li>
</ol>
<pre style="padding-left: 60px">- name: Join the domain<br/>    shell: echo '{{ realm_join_password }}' | realm join --user={{ realm_join_user }} {{ realm_domain }}<br/>    register: command_result<br/>    ignore_errors: True<br/>    notify:<br/>      - Restart sssd</pre>
<p style="padding-left: 60px">The use of the <kbd>shell</kbd> module to perform the <kbd>realm join</kbd> requires special consideration, as running this task twice will not yield the normal clean behavior of Ansible. Indeed, performing a second <kbd>realm join</kbd> when the server is already a domain member results in an error. As a result, we set <kbd>ignore_errors: True</kbd>, and <kbd>register</kbd> the result of the command so that we can later evaluate if it ran successfully. We also notify a handler that we will define later, to restart the <kbd>sssd</kbd> service. The aforementioned <kbd>vars</kbd> file should look something like this:</p>
<pre style="padding-left: 60px">---<br/>realm_join_password: securepassword<br/>realm_join_user: administrator@example.com<br/>realm_domain: example.com</pre>
<p style="padding-left: 60px">Be sure to substitute the variable values with ones appropriate to your own environment.</p>
<ol start="4">
<li>We immediately follow this task with a check, to see if the <kbd>realm join</kbd> was successful. If it was successful, we should either get a return code of <kbd>0</kbd> or an error, informing us that the server is <kbd>Already joined to this domain</kbd>. If we don't get these expected results, then we will fail the entire play to ensure that the issue can be rectified, as follows:</li>
</ol>
<pre style="padding-left: 60px">- name: Fail the play when the realm join fails<br/>    fail: <br/>      msg="Realm join failed with this error: {{ command_result.stderr }}"<br/>    when: "'Already joined to this domain' not in command_result.stderr and command_result.rc != 0"</pre>
<ol start="5">
<li>Finally, we create the handler, to restart <kbd>sssd</kbd> in <kbd>roles/realmd/handlers/main.yml</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px">---<br/>- name: Restart sssd<br/>  service:<br/>    name: sssd<br/>    state: restarted<br/>    enabled: yes</pre>
<p>These steps are all sufficient to perform the basic addition of a Linux server to an AD domain. Although the example is given for CentOS 7, the process should be broadly similar for operating systems like Ubuntu, as long as you take account of the different package manager and package names.</p>
<p>There are, of course, a vast number of enhancements that can be made to the preceding procedure, most of which will be performed with the <kbd>realm</kbd> command. Sadly, at the time of writing, there is no <kbd>realm</kbd> module for Ansible, so, all <kbd>realm</kbd> commands must be issued with the <kbd>shell</kbd> module—though this still enables automated rollouts of AD membership to Linux servers using Ansible.</p>
<p>Possible enhancements for you to consider to the<span> preceding</span><span> process (all of which can easily be automated by extending the example playbook we have previously suggested) are as follows:</span></p>
<ul>
<li>Specify the <strong>organizational unit</strong> (<strong>OU</strong>) that the Linux server is to go into when the join is complete. Without specifying this, it will go into the default <kbd>Computers</kbd> OU. You can change this, by specifying something like <kbd>--computer-ou=OU=Linux,OU=Servers,OU=example,DC=example,DC=com</kbd> within your <kbd>realm join</kbd> command. Be sure the OU has been created first, and adjust the preceding parameter to match your environment.</li>
<li>By default, all valid domain user accounts will be able to log in to the Linux server. This may not be desirable and, if not, you will need to first of all deny all access, using the command <kbd>realm deny --all</kbd>. Then, to say you wish to allow all users in the <kbd>LinuxAdmins</kbd> AD group, you would then issue the following command: <kbd>realm permit -g LinuxAdmins</kbd>.</li>
<li>It is unlikely you will have a group in your AD called <kbd>wheel</kbd> or <kbd>sudo</kbd>, and as a result, AD users may find themselves unable to execute privileged commands. This can be rectified by adding the appropriate users or groups into <kbd>/etc/sudoers</kbd> or, better still, a unique file under <kbd>/etc/sudoers.d</kbd> that Ansible can manage. For example, creating <kbd>/etc/sudoers.d/LinuxAdmins</kbd> with the following content would enable all members of the <kbd>LinuxAdmins</kbd> AD group to perform sudo commands without re-entering their passwords:</li>
</ul>
<pre style="padding-left: 60px">%LinuxAdmins ALL=(ALL) NOPASSWD: ALL</pre>
<p>All of these tasks are left as an exercise for you, though it is expected that the information given in this chapter is sufficient for you to build up your own playbook suited to your AD infrastructure.</p>
<p>In the next section, we will look at the use of the FreeIPA directory service that is native to Linux, and how to integrate this into your environment with Ansible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">FreeIPA</h1>
                </header>
            
            <article>
                
<p>FreeIPA is a freely available open source directory service that is simple to install and manage. It runs on Linux and runs primarily on CentOS or <strong>Red Hat Enterprise Linux</strong> (<strong>RHEL</strong>), though client support is readily available on Ubuntu and other Linux platforms. Integration with Windows AD is even possible, though is in no way required.</p>
<p>If you are building a purely Linux environment, it makes sense to look at FreeIPA, as opposed to putting in a proprietary solution such as Microsoft AD. </p>
<div class="packt_infobox">FreeIPA and Microsoft AD are by no means the only two options on the market for directory services, and a number of cloud-based alternatives are now available, including JumpCloud, AWS Directory Service, and many others. Always make your own independent decisions regarding the best option for you as the field is fast evolving, especially when it comes to cloud-based directory services.</div>
<p>As with the previous section on Microsoft AD, the design and deployment of a FreeIPA infrastructure are beyond the scope of this book. Directory services are core services on your network—imagine if you only built a single directory server, and then had to shut it down for maintenance. Even a simple reboot would leave users unable to log in to all machines joined to it for the duration the services were down. For these reasons, it is vitally important that you design your directory service infrastructure to take account of redundancy and disaster recovery. It is also important that you have well-secured local accounts in case your directory infrastructure does fail, as discussed earlier in this chapter, in the section entitled <em>Performing user account management tasks</em>.</p>
<p>Once you have designed a suitably redundant infrastructure for your FreeIPA installation, there are a series of playbooks and roles available on GitHub, created by the FreeIPA team, to install your server and clients, and you can explore these further here: <a href="https://github.com/freeipa/ansible-freeipa">https://github.com/freeipa/ansible-freeipa</a></p>
<p>This book leaves the task of installing your FreeIPA infrastructure to you—however, let's take a look at the use of the freely available FreeIPA roles, to install clients on your infrastructure. After all, this is one of the key benefits of open source software—the sharing of knowledge, information, and code.</p>
<ol>
<li>First of all, we clone the <kbd>ansible-freeipa</kbd> repository to our local machine, and change into the directory to make use of it, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd ~<br/>$ git clone https://github.com/freeipa/ansible-freeipa</strong><br/><strong>$ cd ansible-freeipa</strong></pre>
<ol start="2">
<li>Next, create symbolic links to <kbd>roles</kbd> and <kbd>modules</kbd> we just cloned into our local Ansible environment, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ ln -s ~/ansible-freeipa/roles/ ~/.ansible/</strong><br/><strong>$ mkdir ~/.ansible/plugins</strong><br/><strong>$ ln -s ~/ansible-freeipa/plugins/modules ~/.ansible/plugins/</strong><br/><strong>$ ln -s ~/ansible-freeipa/plugins/module_utils/ ~/.ansible/plugins/</strong></pre>
<ol start="3">
<li>Once that is done, we must create a simple inventory file that includes appropriate variables, to define the FreeIPA realm and domain, and also, the password of the <kbd>admin</kbd> user (which is required to join a new server to the IPA realm). The following example is shown, but be sure to customize it to your requirements:</li>
</ol>
<pre style="padding-left: 60px">[ipaclients]<br/>centos-testhost<br/><br/>[ipaclients:vars]<br/>ipaadmin_password=password<br/>ipaserver_domain=example.com<br/>ipaserver_realm=EXAMPLE.COM</pre>
<ol start="4">
<li>With the appropriate variables set and the inventory compiled, we can then run the playbooks provided, with the code downloaded from GitHub. An example of this FreeIPA client installation playbook running is shown, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1c9292a6-e540-45ff-8b5f-3a30be99d98b.png" style="width:43.92em;height:29.83em;"/></p>
<p>The preceding output shown is truncated but shows the FreeIPA client installation in process. As usual for examples in this book, we have kept it simple, but this could just as easily be run against 100, or even 1,000, servers.</p>
<p>As these playbooks and roles are provided by the official FreeIPA project, they are a trustworthy source for installing both servers and clients, and although it is highly recommended to test and review any code you download, these should serve well for building up your FreeIPA-based infrastructure.</p>
<p>In the next section, we will take a look at the ways in which Ansible can help with enforcing and auditing user accounts and configuration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enforcing and auditing configuration</h1>
                </header>
            
            <article>
                
<p>When it comes to user account management, security is important. As we discussed in the section entitled <em>Centralizing user account management with LDAP</em>, Ansible is not designed specifically for enforcement or auditing— however, it can help us greatly. Let's consider a few of the security risks around user management that Ansible can help to mitigate, starting with the <kbd>sudoers</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing sudoers with Ansible</h1>
                </header>
            
            <article>
                
<p>The <kbd>/etc/sudoers</kbd> file is one of the most sensitive on most Linux systems, as it defines which user accounts can run commands as the superuser. Needless to say, this file being compromised or modified in an unauthorized way could pose a huge security risk to not just the Linux server in question, but to the network at large.</p>
<p>Thankfully, Ansible templates can help us to manage this file effectively. Like other modern Linux configurations, the <kbd>sudoers</kbd> configuration is broken up into several files, to make it more manageable. The files are, typically, as follows:</p>
<ul>
<li><kbd>/etc/sudoers</kbd>: This is the master file, and references all other files that might be considered.</li>
<li><kbd>/etc/sudoers.d/*</kbd>: These files are normally included by a reference in the <kbd>/etc/sudoers</kbd> file.</li>
</ul>
<p>As we discussed in the chapter entitled <em>Configuration Management with Ansible</em>, someone could potentially edit <kbd>/etc/sudoers</kbd> and tell it to include a completely different path in addition to, or instead of, <kbd>/etc/sudoers.d/*</kbd>, meaning that it is vital we deploy this file through a template. This ensures we maintain control of which files provide <kbd>sudo</kbd> configuration.</p>
<p>We will not repeat our discussion on templates and their deployment with Ansible, as the techniques discussed in <a href="200bea26-7066-4feb-a571-481a5f047ae4.xhtml" target="_blank">Chapter 7</a>, <em>Configuration Management with Ansible</em> apply equally well here. However, we will add an important caveat. If you break the <kbd>sudo</kbd> configuration by deploying a file with (for example) a syntax error in it, you risk locking all users out of privileged access. This would mean the only way to fix the problem would be to log in to the server using the root account, and if this is disabled (as it is by default on Ubuntu, and is recommended in many environments), then your path to recovery becomes quite tricky.</p>
<p>As with so many scenarios, prevention is better than cure, and the <kbd>template</kbd> module we used earlier has a trick up its sleeve, to help us out here. When you edit the <kbd>sudoers</kbd> file using <kbd>visudo</kbd> on a Linux system, the file you have created is checked automatically before it is written to disk. If there is an error, you are warned and given the option to rectify it. Ansible can make use of this utility through the addition of the <kbd>validate</kbd> parameter to the <kbd>template</kbd> module. Thus, a very simple role, to deploy a new version of the <kbd>sudoers</kbd> file with Ansible, might look like this:</p>
<pre>---<br/>- name: Copy a new sudoers file on if visudo validation is passed<br/>  template:<br/>    src: templates/sudoers.j2<br/>    dest: /etc/sudoers<br/>    validate: /usr/sbin/visudo -cf %s</pre>
<p>In the preceding example, the <kbd>template</kbd> module passes the name of the file specified by <kbd>dest</kbd> to the command in the <kbd>validate</kbd> parameter—this is the significance of the <kbd>%s</kbd>. If the validation is passed, the new file is written into place. If the validation fails, then the new file is not written and the old one remains. In addition, when validation fails, the task results in a <kbd>failed</kbd> status, thus ending the play and alerting the user to rectify the condition.</p>
<div class="packt_tip">This isn't the only task that the <kbd>validate</kbd> parameter can be used to complete—it can be used to check the results of any template operation, provided you can define a shell command that will perform a suitable check on the template operation. This might be as simple as using <kbd>grep</kbd> to check for a line in a file, or a check to see that a service restarts.</div>
<p>In the next section, we will take a look at how Ansible can assist with enforcing and auditing user accounts across a large number of servers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Auditing user accounts with Ansible</h1>
                </header>
            
            <article>
                
<p>Say your enterprise has 1,000 Linux servers, all using directory services for authentication, as we have discussed so far. Now, suppose an errant user, wishing to bypass this privilege management, manages to create a local account called <kbd>john</kbd> on a single server. This might happen when privileges are temporarily granted for a change request but then revoked—unscrupulous individuals can easily create their own access methods, to bypass the security provided by your directory service.</p>
<p>How would you find this had happened? Although Ansible is not technically a tool for auditing, it has the benefit of being able to run a command (or set of commands) on 1,000 servers at once and returning the results to you for processing. </p>
<p>As all your server builds should be to a given standard (see <a href="c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml" target="_blank">Chapter 1</a>, <em>Building a Standard Operating Environment on Linux</em>), then you should know which accounts are supposed to be on each Linux server. It is possible that there will be some variance—for example, if you install the PostgreSQL database server, this normally creates a local user account called <kbd>postgres</kbd>. However, these cases are well understood, and can quickly and easily be filtered out.</p>
<p>We don't even need to write a complete playbook for Ansible to help us out here—once you have an inventory file with your Linux server (or servers) in, you can run what is called an ad hoc command. This is simply a single-line command that can run any single Ansible module with a set of arguments—much like a playbook with just one task in it.</p>
<p>Thus, to obtain a list of all user accounts on all my servers, I could run the following command:</p>
<pre><strong>$ ansible -i hosts -m shell -a 'cat /etc/passwd' all</strong></pre>
<p>That's all there is to it—Ansible will faithfully connect to all servers in the inventory file specified by the <kbd>-i</kbd> parameter, and dump the <kbd>/etc/passwd</kbd> file contents to the screen. You could pipe this output to a file for further processing and analysis, rather than having to log on to each box. Although Ansible is not actually doing any analysis, it makes for a very powerful and easy tool to perform the data gathering for the purposes of auditing, and, as is the beauty of Ansible, no agent is required on the remote machines.</p>
<p>The following screenshot shows an example of Ansible obtaining the local user accounts from one of our test systems, using a simple <kbd>grep</kbd> command to filter out two commonly present accounts. Naturally, you can expand this example as you wish, to improve the data processing and hence make your task easier:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/489357b7-290b-414f-98ce-e73458b19955.png" style="width:44.17em;height:30.58em;"/></p>
<p>In this manner, you can make good use of Ansible, to gather useful information from a large number of systems for further processing—as the results are returned directly to the Terminal, it is easy to pipe them to a file and then process them with your favorite tools (for example, AWK) to establish whether there are any systems queried that violate enterprise policies. While this example has been performed with the local user account list, it could just as effectively be performed on any given text file on the remote systems.</p>
<p>This, as you can see, is a very simple example, but it is a fundamental building block, on top of which you can build other playbooks. Here are some ideas for you to explore further by yourself:</p>
<ul>
<li>Change the ad hoc command we ran previously, and run it as a playbook instead.</li>
<li>Schedule the preceding playbook to run on a regular basis in AWX.</li>
<li>Modify the playbook to check for certain key user accounts.</li>
</ul>
<p>Your ability to audit users doesn't stop there, though—although centralized logging should (and probably will) be part of your infrastructure, you can also interrogate log files with Ansible. Using the ad hoc command structure previously shown, you could run the following command against a group of Ubuntu servers:</p>
<pre><strong>$ ansible -i hosts -m shell -a 'grep "authentication failure | cat" /var/log/auth.log' all</strong></pre>
<p>On CentOS, these log messages would appear in <kbd>/var/log/secure</kbd> instead, so you would alter the path accordingly for these systems.</p>
<div class="packt_tip">The <kbd>grep</kbd> command returns code <kbd>1</kbd> if the string you specify is not found, and Ansible, in turn, interprets this as a failure, reporting the task as failed. As a result, we pipe the output of <kbd>grep</kbd> into the <kbd>cat</kbd> command, which always returns zero, and hence, the task does not fail, even if the string we are searching for is not found.</div>
<p>As I'm sure you have realized by now, these commands would be far better run as a playbook, with some detection for the operating system and the appropriate paths used in each case—however, the goal of this section is not to provide you with an exhaustive set of solutions, but rather, to inspire you to go and build your own code based on these examples, to help you audit your infrastructure with Ansible.</p>
<p>The fact that Ansible can perform such a wide variety of commands, and that it has agentless access across your infrastructure, means that it can be an effective solution in your toolbox, both for configuring your Linux servers and for maintaining the integrity of the configuration, and, even, auditing them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>User account and access management is an integral part of any Enterprise Linux environment, and Ansible can be a key component in both configuring this and rolling it out across a wide number of servers. Indeed, in the case of FreeIPA, there are already freely available Ansible roles and playbooks that can set up not only the Linux clients, but even your server architecture as well. Thus, automation of all key components within your Linux infrastructure can be achieved.</p>
<p>In this chapter, you learned how to effectively manage user accounts with Ansible across a large number of Linux servers. You then learned how to integrate logins with common directory servers such as FreeIPA and Microsoft AD using Ansible, and finally, you learned how Ansible can be used to enforce configuration and audit its state.</p>
<p>In the next chapter, we will explore the use of Ansible in database management.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the benefits of local user accounts, even when a directory service is employed?</li>
<li>Which module is used to create and manipulate user accounts in Ansible?</li>
<li>How would you generate an encrypted password hash, using just Ansible?</li>
<li>Which package is used to integrate Linux servers with AD?</li>
<li>How can you use Ansible to audit configuration from a group of servers?</li>
<li>What is the purpose of validating the <kbd>sudoers</kbd> file when deploying it from a template?</li>
<li>What additional benefits does a directory service bring that Ansible could not provide, even though it can deploy user accounts across all your servers?</li>
<li>How would you make the choice between FreeIPA and AD?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>For an in-depth understanding of Ansible, please refer to <em>Mastering Ansible, Third Edition—James Freeman</em> and <em>Jesse Keating</em> (<a href="https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition">https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition</a><a href="https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition">).<br/></a></li>
<li>To explore the setup and use of AD in greater depth, readers may refer to <em>Mastering Active Directory, Second Edition—Dishan Francis</em> (<a href="https://www.packtpub.com/cloud-networking/mastering-active-directory-second-edition">https://www.packtpub.com/cloud-networking/mastering-active-directory-second-edition</a>).</li>
</ul>


            </article>

            
        </section>
    </body></html>