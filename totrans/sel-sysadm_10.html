<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div id="_idContainer027" class="calibre2">
			<h1 id="_idParaDest-233" class="calibre5"><em class="italic"><a id="_idTextAnchor237" class="pcalibre calibre6 pcalibre1"/>Chapter 8</em>: SEPostgreSQL – Extending PostgreSQL with SELinux</h1>
			<p class="calibre3">In the previous chapter, we covered a few example SELinux-aware applications: applications that know and interact with the SELinux subsystem to further enhance security within the application context. Some of these use existing policy constructs, such as Apache's <strong class="source-inline">mod_selinux</strong>, whereas others enhance the policy with custom classes to further fine-tune their behavior (as with D-Bus and the <strong class="source-inline">acquire_svc</strong> permission).</p>
			<p class="calibre3">With <strong class="bold">Security-Enhanced PostgreSQL</strong> (<strong class="bold">SEPostgreSQL</strong>), we get a more elaborate example of an SELinux-aware application, which uses multiple additional classes within SELinux, as well as labeling its internal database objects to further enforce security rules. In this chapter, we will learn how to apply labels within PostgreSQL, debug its enforcement rules, associate the right labels with the PostgreSQL resources, and show how this label-based security method can be used to augment specific security practices within a relational database.</p>
			<p class="calibre3">In this chapter, we're going to cover the following main topics:</p>
			<ul class="calibre8">
				<li class="calibre9">Introducing PostgreSQL and <strong class="source-inline">sepgsql</strong></li>
				<li class="calibre9">Understanding SELinux's database-specific object classes and permissions</li>
				<li class="calibre9">Using MCS and MLS</li>
				<li class="calibre9">Integrating SEPostgreSQL into a network</li>
			</ul>
			<h1 id="_idParaDest-234" class="calibre5"><a id="_idTextAnchor238" class="pcalibre calibre6 pcalibre1"/>Technical requirements</h1>
			<p class="calibre3">Check out the following video to see the Code in Action: <a href="https://bit.ly/3dDcg4Z" class="pcalibre calibre6 pcalibre1">https://bit.ly/3dDcg4Z</a></p>
			<h1 id="_idParaDest-235" class="calibre5"><a id="_idTextAnchor239" class="pcalibre calibre6 pcalibre1"/>Introducing PostgreSQL and sepgsql</h1>
			<p class="calibre3">PostgreSQL <a id="_idIndexMarker607" class="pcalibre calibre6 pcalibre1"/>is a popular, featureful, and mature <a id="_idIndexMarker608" class="pcalibre calibre6 pcalibre1"/>relational database management system. Like Apache, it also enables a modular extension of its functionalities through loadable modules. The module we will investigate is called <strong class="bold">sepgsql</strong>, shorthand for <strong class="bold">Security Enhanced PostgreSQL</strong> or <strong class="bold">SEPostgreSQL</strong>. Through <strong class="source-inline">sepgsql</strong>, PostgreSQL enhances itself with SELinux support for additional access controls, offering fine-grained data flow controls based on SELinux policy rules.</p>
			<p class="calibre3">Please be aware though that <strong class="source-inline">sepgsql</strong> does not implement a full mandatory access control system within PostgreSQL, as not all PostgreSQL statements will result in a policy check. While it <a id="_idIndexMarker609" class="pcalibre calibre6 pcalibre1"/>augments the security posture of the PostgreSQL database, the module <a id="_idIndexMarker610" class="pcalibre calibre6 pcalibre1"/>has a few limitations listed in its <a id="_idIndexMarker611" class="pcalibre calibre6 pcalibre1"/>online documentation, available at <a href="https://www.postgresql.org/docs/10/sepgsql.html" class="pcalibre calibre6 pcalibre1">https://www.postgresql.org/docs/10/sepgsql.html</a> (adjust the version number in the URL as needed; the referenced document at this URL is for PostgreSQL 10, which is the version currently used within CentOS 8 and used throughout this chapter).</p>
			<h2 id="_idParaDest-236" class="calibre10"><a id="_idTextAnchor240" class="pcalibre calibre6 pcalibre1"/>Reconfiguring PostgreSQL with sepgsql</h2>
			<p class="calibre3">Before we <a id="_idIndexMarker612" class="pcalibre calibre6 pcalibre1"/>can install <strong class="source-inline">sepgsql</strong>, we need <a id="_idIndexMarker613" class="pcalibre calibre6 pcalibre1"/>to have a working PostgreSQL system at our disposal. Most Linux distributions have readily available tutorials on how to deploy PostgreSQL, which often involves creating the databases associated with it.</p>
			<p class="calibre3">In this chapter, we will assume that the database itself is available inside <strong class="source-inline">/var/lib/pgsql/data</strong>, the default location for a CentOS-based PostgreSQL installation. The PostgreSQL configuration files are also located inside this location.</p>
			<p class="calibre3">To install <strong class="source-inline">sepgsql</strong>, the following steps should be executed:</p>
			<ol class="calibre18">
				<li class="calibre9">Let's first see whether the database is functioning properly by logging in as the (default) <strong class="source-inline">postgres</strong> superuser, and listing the currently available databases:<p class="source-code"><strong class="bold"># su postgres -</strong></p><p class="source-code"><strong class="bold">$ psql postgres</strong></p><p class="source-code"><strong class="bold">psql (10.6)</strong></p><p class="source-code"><strong class="bold">Type "help" for help.</strong></p><p class="source-code"><strong class="bold">postgres=# \l</strong></p><p class="source-code"><strong class="bold">                List of databases</strong></p><p class="source-code"><strong class="bold">  Name     |  Owner   |  Encoding   | ...</strong></p><p class="source-code"><strong class="bold">-----------+----------+-------------+ ...</strong></p><p class="source-code"><strong class="bold"> postgres  | postgres | UTF8        | ...</strong></p><p class="source-code"><strong class="bold"> template0 | postgres | UTF8        | ...</strong></p><p class="source-code"><strong class="bold"> template1 | postgres | UTF8        | ...</strong></p><p class="calibre3">If at any point a failure occurs, check the log file inside <strong class="source-inline">/var/lib/pgsql/data/log</strong> to get more information. This log file is the default log file for all PostgreSQL-related activities, as we will see when troubleshooting its SELinux support in the <em class="italic">Troubleshooting sepgsql</em> section.</p></li>
				<li class="calibre9">Assuming PostgreSQL is working properly, let's configure it to use the <strong class="source-inline">sepgsql</strong> module. This module is part of the contributed modules within PostgreSQL, and is maintained by the PostgreSQL community. In CentOS, the <strong class="source-inline">sepgsql</strong> module is part of the <strong class="source-inline">postgresql-contrib</strong> package, which can be easily added to the system using <strong class="source-inline">yum install postgresql-contrib</strong> if it is not present yet.</li>
				<li class="calibre9">Edit <a id="_idIndexMarker614" class="pcalibre calibre6 pcalibre1"/>the <strong class="source-inline">postgresql.conf</strong> file inside <strong class="source-inline">/var/lib/pgsql/data</strong> and search for the <strong class="source-inline">shared_preload_libraries</strong> statement. By default, it will be commented out, so uncomment it and add <strong class="source-inline">sepgsql</strong> inside:<p class="source-code">shared_preload_libraries = 'sepgsql' # (change requires restart)</p></li>
				<li class="calibre9">As <a id="_idIndexMarker615" class="pcalibre calibre6 pcalibre1"/>mentioned, changing this parameter requires restarting the database. We will do that later, but first, we will shut down the database as our next steps will require an offline database:<p class="source-code"><strong class="bold"># systemctl stop postgresql</strong></p></li>
				<li class="calibre9">Next, we need to reconfigure all databases and enable the <strong class="source-inline">sepgsql</strong>-related functions. We will cover these functions in the <em class="italic">Using sepgsql specific functions</em> section. To enable the functions, we have to become the <strong class="source-inline">postgres</strong> superuser again, and for each database available, we load a specific SQL file:<p class="source-code"><strong class="bold"># su postgres -</strong></p><p class="source-code"><strong class="bold">$ export PGDATA=/var/lib/pgsql/data</strong></p><p class="source-code"><strong class="bold">$ for DBNAME in template0 template1 postgres; do </strong></p><p class="source-code"><strong class="bold">    postgres --single -F -c exit_on_error=true $DBNAME &lt; </strong><strong class="bold">/usr/share/pgsql/contrib/sepgsql.sql &gt; /dev/null;</strong></p><p class="source-code"><strong class="bold">  done</strong></p><p class="calibre3">The databases listed in the example are the three default databases available in a brand-new installation. You can obtain the actual list of databases on the system through PostgreSQL's shorthand <strong class="source-inline">\l</strong> command, which we used earlier to check whether the database is functioning properly.</p></li>
				<li class="calibre9">Let's validate whether <strong class="source-inline">sepgsql</strong> is working by starting the PostgreSQL database, logging in to PostgreSQL, and asking for our current context:<p class="source-code"><strong class="bold"># systemctl start postgresql</strong></p><p class="source-code"><strong class="bold"># su postgres -</strong></p><p class="source-code"><strong class="bold">$ psql postgres</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">postgres# SELECT sepgsql_getcon();</strong></p><p class="source-code"><strong class="bold">        sepgsql_getcon()</strong></p><p class="source-code"><strong class="bold">-----------------------------------------------------</strong></p><p class="source-code"><strong class="bold">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</strong></p><p class="calibre3">What <a id="_idIndexMarker616" class="pcalibre calibre6 pcalibre1"/>we did here was to execute <a id="_idIndexMarker617" class="pcalibre calibre6 pcalibre1"/>the freshly installed <strong class="source-inline">sepgsql</strong> function <strong class="source-inline">sepgsql_getcon()</strong>, which retrieves the current context for the session.</p></li>
			</ol>
			<p class="calibre3">Let's further configure the database with a test account that we can use to validate the <strong class="source-inline">sepgsql</strong> controls.</p>
			<h2 id="_idParaDest-237" class="calibre10"><a id="_idTextAnchor241" class="pcalibre calibre6 pcalibre1"/>Creating a test account</h2>
			<p class="calibre3">To validate <a id="_idIndexMarker618" class="pcalibre calibre6 pcalibre1"/>whether the <strong class="source-inline">sepgsql</strong> controls are working, we should have a test account outside of the <strong class="source-inline">postgres</strong> superuser, and a local user that we can map to different SELinux contexts. As the SELinux context will heavily decide which privileges are associated with a session, we want to be able to show the impact of one context compared to the others.</p>
			<p class="calibre3">First, inside PostgreSQL (with the <strong class="source-inline">postgres</strong> superuser), create a test account called <strong class="source-inline">testuser</strong>, and allow the account to authenticate with a given password:</p>
			<p class="source-code">postgres=# CREATE USER testuser PASSWORD 'somepassword';</p>
			<p class="calibre3">We also need to configure the database to allow password-based authentication (as the default PostgreSQL setup will use system trust or another means of authentication). To accomplish that, edit the <strong class="source-inline">pg_hba.conf</strong> file inside <strong class="source-inline">/var/lib/pgsql/data</strong> with the following settings:</p>
			<p class="source-code">local		all	postgres					peer</p>
			<p class="source-code">local		all	testuser					md5</p>
			<p class="source-code">host		all	testuser		127.0.0.1/32	md5</p>
			<p class="source-code">host		all	testuser		192.168.100.0/24	md5</p>
			<p class="calibre3">The <strong class="source-inline">pg_hba.conf</strong> file manages the host-based authentication rules for PostgreSQL. We update it to allow password-based authentication for the <strong class="source-inline">testuser</strong> account (which uses <strong class="source-inline">md5</strong> as an identifier) while allowing the <strong class="source-inline">postgres</strong> superuser to continue to authenticate using peer trust.</p>
			<p class="calibre3">With these changes in place, PostgreSQL allows password-based authentication of the <strong class="source-inline">testuser</strong> account both when the user initiates the communication over a local, socket-based interaction, as well as when a network-based communication is used.</p>
			<p class="calibre3">We also need to tell the SELinux policy that regular users will be allowed to connect to the PostgreSQL service:</p>
			<p class="source-code"># setsebool -P selinuxuser_postgresql_connect_enabled on</p>
			<p class="calibre3">While this would be sufficient for accessing the PostgreSQL service, it is not adequate to allow the regular user domain (<strong class="source-inline">user_t</strong>) to interact with <strong class="source-inline">sepgsql</strong>. To accomplish that, we need to <a id="_idIndexMarker619" class="pcalibre calibre6 pcalibre1"/>adjust the SELinux policy so that the <strong class="source-inline">user_t</strong> domain is also associated with the <strong class="source-inline">sepgsql_client_type</strong> attribute, and that the <strong class="source-inline">user_r</strong> role can have the <strong class="source-inline">sepgsql</strong>-related types active.</p>
			<p class="calibre3">We do this through a small CIL policy, as follows:</p>
			<p class="source-code">(typeattributeset cil_gen_require sepgsql_client_type)</p>
			<p class="source-code">(typeattributeset cil_gen_require user_t)</p>
			<p class="source-code">(typeattributeset cil_gen_require sepgsql_trusted_proc_t)</p>
			<p class="source-code">(typeattributeset cil_gen_require sepgsql_ranged_proc_t)</p>
			<p class="source-code">(typeattributeset sepgsql_client_type (user_t))</p>
			<p class="source-code">(roleattributeset cil_gen_require user_r)</p>
			<p class="source-code">(roletype user_r sepgsql_trusted_proc_t)</p>
			<p class="source-code">(roletype user_r sepgsql_ranged_proc_t)</p>
			<p class="calibre3">It is also possible to accomplish this with a reference policy style module, as follows:</p>
			<p class="source-code">policy_module(local_sepgsql, 1.0)</p>
			<p class="source-code">gen_require(`</p>
			<p class="source-code">	role user_r;</p>
			<p class="source-code">	type user_t;</p>
			<p class="source-code">')</p>
			<p class="source-code">postgresql_role(user_r, user_t)</p>
			<p class="calibre3">Assuming we stick with the CIL-based policy, let's load the file (that is, <strong class="source-inline">local_sepgsql.cil</strong>) as an SELinux policy module:</p>
			<p class="source-code"># semodule -i local_sepgsql.cil</p>
			<p class="calibre3">Don't forget to restart the PostgreSQL service after changing the <strong class="source-inline">pg_hba.conf</strong> file.</p>
			<h2 id="_idParaDest-238" class="calibre10"><a id="_idTextAnchor242" class="pcalibre calibre6 pcalibre1"/>Tuning sepgsql inside PostgreSQL</h2>
			<p class="calibre3">The <strong class="source-inline">sepgsql</strong> module <a id="_idIndexMarker620" class="pcalibre calibre6 pcalibre1"/>introduces two configuration parameters <a id="_idIndexMarker621" class="pcalibre calibre6 pcalibre1"/>that can be used to tweak <strong class="source-inline">sepgsql</strong> inside PostgreSQL:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">sepgsql.permissive</strong> parameter tells PostgreSQL not to enforce the SELinux policy rules inside PostgreSQL. This is similar to the permissive state of SELinux on the system, but covers the <strong class="source-inline">sepgsql</strong>-related functionality inside PostgreSQL alone. </li>
				<li class="calibre9">The <strong class="source-inline">sepgsql.debug_audit</strong> parameter tells PostgreSQL to always log the SELinux-related decisions, even when they are to allow a statement to be processed. This is similar to the <strong class="source-inline">auditallow</strong> statements for SELinux on the system.</li>
			</ul>
			<p class="calibre3">It is very important however to understand that <strong class="source-inline">sepgsql</strong> is a user-space object manager, as explained in <a href="B16276_07_Final_VK.xhtml#_idTextAnchor216" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 7</em></a>, <em class="italic">Configuring Application-Specific SELinux Controls</em>: the SELinux subsystem in the Linux kernel is not used for enforcing the access controls, only <strong class="source-inline">sepgsql</strong> is. The only purpose that the SELinux subsystem has is to allow PostgreSQL to query the active SELinux policy or obtain current SELinux context information.</p>
			<p class="calibre3">Hence, the previous configuration parameters work mostly independently of the configuration of the system. While SELinux must be active on the system, it does not need to be in enforcing mode to have <strong class="source-inline">sepgsql</strong> enforce the rules inside PostgreSQL, nor does a permissive SELinux system make the enforcement of <strong class="source-inline">sepgsql</strong> permissive as well.</p>
			<p class="calibre3">The <strong class="source-inline">sepgsql.debug_audit</strong> parameter does have some relationship with the system policy. We can add <strong class="source-inline">auditallow</strong> statements to the SELinux policy to force the logging of events even when they are allowed. What the <strong class="source-inline">sepgsql.debug_audit</strong> parameter does is force all events to be logged, something useful for troubleshooting <strong class="source-inline">sepgsql</strong>, as we will see next.</p>
			<h2 id="_idParaDest-239" class="calibre10"><a id="_idTextAnchor243" class="pcalibre calibre6 pcalibre1"/>Troubleshooting sepgsql</h2>
			<p class="calibre3">Let's enable <a id="_idIndexMarker622" class="pcalibre calibre6 pcalibre1"/>the debug statements for an individual session and reinvoke the <strong class="source-inline">sepgsql_getcon</strong> function again:</p>
			<p class="source-code"># su postgres -c "/usr/bin/psql postgres"</p>
			<p class="source-code">postgres=# SET sepgsql.debug_audit = true;</p>
			<p class="source-code">SET</p>
			<p class="source-code">postgres=# SELECT sepgsql_getcon();</p>
			<p class="source-code">...</p>
			<p class="calibre3">If you want to enable the configuration for the entire system, you can place the configuration inside the <strong class="source-inline">postgresql.conf</strong> file:</p>
			<p class="source-code">sepgsql.debug_audit = true</p>
			<p class="calibre3">Inside the PostgreSQL logs, we will notice the following information:</p>
			<p class="source-code">STATEMENT:  SET sepgsql.debug_audit = true</p>
			<p class="source-code">STATEMENT:  SELECT sepgsql_getcon();</p>
			<p class="source-code">LOG:  SELinux: allowed { execute } \</p>
			<p class="source-code">  scontext=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 \</p>
			<p class="source-code">  tcontext=system_u:object_r:sepgsql_proc_exec_t:s0 \</p>
			<p class="source-code">  tclass=db_procedure name="pg_catalog.sepgsql_getcon()"</p>
			<p class="calibre3">The first <a id="_idIndexMarker623" class="pcalibre calibre6 pcalibre1"/>two lines log the statements that we have executed within the session, whereas the third line is the SELinux log event related to the execution of <strong class="source-inline">sepgsql_getcon</strong>.</p>
			<p class="calibre3">The event tells us that the <strong class="source-inline">unconfined_t</strong> domain (source context) has attempted (and succeeded) to execute the database procedure (as indicated by the <strong class="source-inline">db_procedure</strong> class) labeled with the <strong class="source-inline">sepgsql_proc_exec_t</strong> type. The in-database function is the <strong class="source-inline">sepgsql_getcon</strong> function within the <strong class="source-inline">pg_catalog</strong> schema.</p>
			<p class="calibre3">If a denial occurs, this will result in a similar event in the logs, but will also be made visible to the end user that triggered the denial, as PostgreSQL will show an error message like so:</p>
			<p class="source-code">ERROR:  SELinux: security policy violation</p>
			<p class="calibre3">Unlike the audit logging executed by, for instance, D-Bus (which results in <strong class="source-inline">USER_AVC</strong> events in the regular audit log), <strong class="source-inline">sepgsql</strong> will follow the log configuration of the PostgreSQL database itself, so keep a close eye out on this log file (or other log targets configured in PostgreSQL) when trying to troubleshoot <strong class="source-inline">sepgsql</strong>.</p>
			<p class="calibre3">In this simple example, you might already have noticed that the event references a database-specific class (<strong class="source-inline">db_procedure</strong>). In the next section, we will look into the various classes, permissions, and types associated with <strong class="source-inline">sepgsql</strong> and thus supported by the SELinux policy.</p>
			<h1 id="_idParaDest-240" class="calibre5"><a id="_idTextAnchor244" class="pcalibre calibre6 pcalibre1"/>Understanding SELinux's database-specific object classes and permissions</h1>
			<p class="calibre3">The <strong class="source-inline">sepgsql</strong> module <a id="_idIndexMarker624" class="pcalibre calibre6 pcalibre1"/>uses several database-specific SELinux <a id="_idIndexMarker625" class="pcalibre calibre6 pcalibre1"/>classes to fine-tune the policies and access controls. The supported classes can be listed through <strong class="source-inline">/sys/fs/selinux/class</strong> or the <strong class="source-inline">seinfo</strong> command:</p>
			<p class="source-code"># seinfo --class | grep db_</p>
			<p class="source-code">db_blob</p>
			<p class="source-code">db_column</p>
			<p class="source-code">db_database</p>
			<p class="source-code">db_language</p>
			<p class="source-code">db_procedure</p>
			<p class="source-code">db_schema</p>
			<p class="source-code">db_sequence</p>
			<p class="source-code">db_table</p>
			<p class="source-code">db_tuple</p>
			<p class="source-code">db_view</p>
			<p class="calibre3">These classes have an obvious relational database meaning: <strong class="source-inline">db_database</strong> is for database-related permissions, <strong class="source-inline">db_table</strong> for table permissions, <strong class="source-inline">db_procedure</strong> for database procedures, and so on. While not all classes are still supported by <strong class="source-inline">sepgsql</strong> (the <strong class="source-inline">db_database</strong> class has no immediate support anymore), most do have their usual mapping within <a id="_idIndexMarker626" class="pcalibre calibre6 pcalibre1"/>the PostgreSQL database.</p>
			<p class="calibre3">Let's see <a id="_idIndexMarker627" class="pcalibre calibre6 pcalibre1"/>what permissions are supported by <strong class="source-inline">sepgsql</strong> and how this can be used to fine-tune access controls within the database.</p>
			<h2 id="_idParaDest-241" class="calibre10"><a id="_idTextAnchor245" class="pcalibre calibre6 pcalibre1"/>Understanding sepgsql permissions</h2>
			<p class="calibre3">The access <a id="_idIndexMarker628" class="pcalibre calibre6 pcalibre1"/>controls that <strong class="source-inline">sepgsql</strong> enforces are on top of the discretionary access controls already supported by PostgreSQL. Rather than using the privileges of the role or user currently acting within the database, the <strong class="source-inline">sepgsql</strong> module will use the context associated with the session.</p>
			<p class="calibre3">As we can use different SELinux contexts for sessions that are authenticated using the same database role, we can create distinct access controls within the database without associating this with the user account itself. We can, for instance, differentiate based on the initialization of the database session: a remote session might have a separate context compared to a locally launched session, or the authorizations might be unique across different Linux users even when they share the same account within the database.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">As remote connections require the peer context to be accessible, <strong class="source-inline">sepgsql</strong> requires either the use of labeled IPSec, or we need to introduce fallback labeling using NetLabel and CIPSO, as seen in <a href="B16276_05_Final_VK.xhtml#_idTextAnchor138" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 5</em></a>, <em class="italic">Controlling Network Communications</em>. We will establish such a mapping in the <em class="italic">Integrating SEPostgreSQL in the network</em> section, after explaining the various permission mappings.</p>
			<p class="calibre3">Once logged in, a query on a table will trigger a few checks against the SELinux policy:</p>
			<ul class="calibre8">
				<li class="calibre9">Any <strong class="source-inline">SELECT</strong>, <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, or <strong class="source-inline">DELETE</strong> statement on a table results in a permission check against the <strong class="source-inline">select</strong>, <strong class="source-inline">insert</strong>, <strong class="source-inline">update</strong>, or <strong class="source-inline">delete</strong> permissions within the <strong class="source-inline">db_table</strong> class.</li>
				<li class="calibre9">When the <strong class="source-inline">WHERE</strong> clause lists one or more different tables, then the <strong class="source-inline">select</strong> privilege for those different tables is checked as well.</li>
				<li class="calibre9">Furthermore, column-level permissions are checked for each referenced column, and this is <a id="_idIndexMarker629" class="pcalibre calibre6 pcalibre1"/>checked against the permissions within the <strong class="source-inline">db_column</strong> class. Again, permission checks against the <strong class="source-inline">select</strong> permission validate the read access, whereas the <strong class="source-inline">update</strong> or <strong class="source-inline">insert</strong> permissions reflect the controls to check when the values are changed.</li>
			</ul>
			<p class="calibre3">A more elaborate overview of the supported permissions is available in the PostgreSQL <strong class="source-inline">sepgsql</strong> documentation.</p>
			<h2 id="_idParaDest-242" class="calibre10"><a id="_idTextAnchor246" class="pcalibre calibre6 pcalibre1"/>Using the default supported types</h2>
			<p class="calibre3">The default <a id="_idIndexMarker630" class="pcalibre calibre6 pcalibre1"/>SELinux policy has several types readily available for use within a <strong class="source-inline">sepgsql</strong> setup. Most of the SEPostgreSQL configurations will not deviate from these default types, and instead rely on the category- and sensitivity-oriented controls that we touched upon in <a href="B16276_03_Final_VK.xhtml#_idTextAnchor071" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing User Logins</em>.</p>
			<p class="calibre3">To see what these default types are, what they are used for, and how to assign these labels within PostgreSQL, let's start with creating a new database called <strong class="source-inline">db_test</strong>:</p>
			<p class="source-code"># su postgres -c "/usr/bin/psql postgres"</p>
			<p class="source-code">postgres=# CREATE DATABASE db_test;</p>
			<p class="source-code">CREATE DATABASE</p>
			<p class="calibre3">Next, we connect to this newly created database and create a simple table, called <strong class="source-inline">tb_users</strong>, which has the following columns: </p>
			<ul class="calibre8">
				<li class="calibre9">The user's ID, named <strong class="source-inline">uid</strong></li>
				<li class="calibre9">The user's name, named <strong class="source-inline">name</strong></li>
				<li class="calibre9">The user's email address, named <strong class="source-inline">mail</strong></li>
				<li class="calibre9">The user's mailing address, named <strong class="source-inline">address</strong></li>
				<li class="calibre9">The user's password salt and hash, named <strong class="source-inline">salt</strong> and <strong class="source-inline">phash</strong><p class="callout-heading">Important note</p><p class="callout">The example used is merely an example, meant to show how to approach SELinux labels and <strong class="source-inline">sepgsql</strong>. Proper database design and best practices for addressing password hashes and other sensitive data are well beyond the scope of this book!</p></li>
			</ul>
			<p class="calibre3">As you can imagine, we will be securing some of these columns further: while the password hash should obviously be considered very sensitive, we should also make sure to properly protect <a id="_idIndexMarker631" class="pcalibre calibre6 pcalibre1"/>the mail and address fields as this is <strong class="bold">Personally Identifiable Information</strong> (<strong class="bold">PII</strong>), which in many areas of the world is governed by specific privacy laws:</p>
			<p class="source-code">postgres=# \c db_test;</p>
			<p class="source-code">db_test=# CREATE TABLE tb_users(uid int primary key, name text, mail text, address text, salt text, phash text);</p>
			<p class="calibre3">What is <a id="_idIndexMarker632" class="pcalibre calibre6 pcalibre1"/>now the label associated with this table? For that, we need to query the PostgreSQL internal tables/views, more specifically the <strong class="source-inline">pg_seclabels</strong> one:</p>
			<p class="source-code">db_test=# SELECT objname,provider,label FROM pg_seclabels WHERE objname='tb_users';</p>
			<p class="source-code"> objname  | provider | label</p>
			<p class="source-code">----------+----------+----------------------------------------</p>
			<p class="source-code"> tb_users | selinux  | unconfined_u:object_r:sepgsql_table_t:s0</p>
			<p class="calibre3">As you can see, the table has received the <strong class="source-inline">sepgsql_table_t</strong> type and default sensitivity (<strong class="source-inline">s0</strong>).</p>
			<p class="calibre3"><strong class="source-inline">sepgsql_table_t</strong> is the default type for tables. We usually find this type used for general table support and columns. Alongside the <strong class="source-inline">sepgsql_table_t</strong> type, the policy has a few other table- and column-oriented types that administrators can use to differentiate the controls that <strong class="source-inline">sepgsql</strong> enforces:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">sepgsql_fixed_table_t</strong> type can be used for tables or columns that can only be appended to (inserted into) but not updated. This could be for log-related tables or audit events where we want to use the <strong class="source-inline">sepgsql</strong> controls to further enforce this (beyond the in-database controls that could be used for this as well).</li>
				<li class="calibre9">The <strong class="source-inline">sepgsql_ro_table_t</strong> type can be used for tables or columns that should only be read from (read-only).</li>
				<li class="calibre9">The <strong class="source-inline">sepgsql_secret_table_t</strong> type can be used for tables or columns that cannot be accessed by regular users or sessions, and only by administrative ones. This is generally used for tables or columns that are only used through protected and/or privileged procedures.</li>
				<li class="calibre9">The <strong class="source-inline">unpriv_sepgsql_table_t</strong> type is like the <strong class="source-inline">sepgsql_table_t</strong> type, but specific to tables or columns managed by admins or unconfined users that cannot be accessed by confined users.</li>
				<li class="calibre9">The <strong class="source-inline">user_sepgsql_table_t</strong> type on the other hand is specifically constructed for tables or columns managed by confined users. This allows administrators to differentiate between user-specific tables and general tables.</li>
			</ul>
			<p class="calibre3">Let's grant <a id="_idIndexMarker633" class="pcalibre calibre6 pcalibre1"/>the <strong class="source-inline">testuser</strong> account (full) access to this table and database, and add some data to the table:</p>
			<p class="source-code">db_test=# GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO testuser;</p>
			<p class="source-code">db_test=# INSERT INTO tb_users VALUES (1, 'Sven Vermeulen', 'some@example.com', 'Some Place 10001, Somewhere', 'abc123', 'f5ba94...3');</p>
			<p class="source-code">db_test=# INSERT INTO tb_users VALUES (2, 'Lisa McCarthy', 'lisa@example.com', 'Lisa Place 15, Someplace', 'def456', 'ba53f2...0');</p>
			<p class="calibre3">If we query the data through our test user, we can see all data added to the table:</p>
			<p class="source-code">db_test=&gt; SELECT * FROM tb_users;</p>
			<p class="calibre3">Let's change the type of the <strong class="source-inline">phash</strong> column to <strong class="source-inline">sepgsql_secret_table_t</strong>:</p>
			<p class="source-code">db_test# SECURITY LABEL ON COLUMN tb_users.phash IS 'system_u:object_r:sepgsql_secret_table_t:s0';</p>
			<p class="calibre3">This alone however will not prevent the <strong class="source-inline">testuser</strong> user from accessing the data. It will depend on how the <strong class="source-inline">testuser</strong> logs in to the database—from which context the session will be initiated. If we launch the session from an unconfined domain, then the session will still allow access to the data. Let's instead log in from a regular user session (<strong class="source-inline">user_t</strong>), and try to access the data again:</p>
			<p class="source-code">db_test=&gt; SELECT * FROM tb_users;</p>
			<p class="source-code">ERROR:  SELinux: security policy violation</p>
			<p class="calibre3">Even though the user has all the privileges within the database, we notice that the policy has prevented access. We can, however, query the columns not marked as <strong class="source-inline">sepgsql_secret_table_t</strong>:</p>
			<p class="source-code">db_test=&gt; SELECT uid, name, mail, address, salt from tb_users;</p>
			<p class="calibre3">As the <strong class="source-inline">phash</strong> column is now marked as <strong class="source-inline">sepgsql_secret_table_t</strong>, we would still want the regular <a id="_idIndexMarker634" class="pcalibre calibre6 pcalibre1"/>database user to be able to query if a hash matches the hash in the database, or set a new hash. This allows the database user to manage the accounts without easily leaking the password hashes. We do this through functions, which we will describe next.</p>
			<h2 id="_idParaDest-243" class="calibre10"><a id="_idTextAnchor247" class="pcalibre calibre6 pcalibre1"/>Creating trusted procedures</h2>
			<p class="calibre3">PostgreSQL <a id="_idIndexMarker635" class="pcalibre calibre6 pcalibre1"/>supports functions and procedures to facilitate isolating or combining actions within the database or on the data in a more structured and managed way. Procedures are allowed to do transactional updates in the database, but do not return a value by themselves. Functions return a value, but are not allowed to do transactional updates. In our example, we will create two functions, one to compare a hash with the stored hash (but without showing the stored hash to the database user) and another to update the stored hash.</p>
			<p class="callout-heading">Informational note</p>
			<p class="callout">While we should be using procedures for the second function, not all PostgreSQL versions in use today support them. Support for procedures has only been included from PostgreSQL version 11 onward, whereas our examples use PostgreSQL 10.6, as that is the current version supported by CentOS 8.</p>
			<p class="calibre3">Let's first create the two functions:</p>
			<p class="source-code">postgres=# CREATE FUNCTION compare_hash(fuid int, fphash text) RETURNS boolean AS 'SELECT phash = regexp_replace(fphash, ''[^a-f0-9]*'', '''', ''g'') FROM tb_users WHERE uid = fuid' LANGUAGE sql;</p>
			<p class="source-code">postgres=# CREATE FUNCTION set_hash(fuid int, fphash text) RETURNS int AS 'UPDATE tb_users SET phash = regexp_replace(fphash, ''[^a-f0-9]*'', '''', ''g'') WHERE uid = fuid RETURNING uid' LANGUAGE sql;</p>
			<p class="calibre3">We introduce a regular expression in the function to sanitize the input as we will be marking these functions as trusted later, and we do not want the functions to be a jumping ground for activities such as SQL injection.</p>
			<p class="calibre3">Once the functions are defined, authorized users can use them to access the more protected data. Of course, we need to properly label these functions. In the default SELinux policy, the following types are available to deal with procedures and functions:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="source-inline">sepgsql_proc_exec_t</strong> is the type to assign to regular functions or procedures. Once executed, the procedure will run within the current context of the user, so no transition will occur.</li>
				<li class="calibre9"><strong class="source-inline">sepgsql_trusted_proc_exec_t</strong> is the type to assign to trusted procedures or functions. Once executed, these functions will run in the <strong class="source-inline">sepgsql_trusted_proc_t</strong> domain, which has access to more privileged types such as <strong class="source-inline">sepgsql_secret_table_t</strong>.</li>
				<li class="calibre9"><strong class="source-inline">sepgsql_ranged_proc_exec_t</strong> is the type to assign to a trusted procedure or function, but with an additional privilege: ranged procedures are allowed to change the current sensitivity. Ranged procedure privileges are useful to assign to a function or procedure that can access columns labeled with a category that the current context would not be able to access otherwise. Once executed, these functions and procedures will run in the <strong class="source-inline">sepgsql_ranged_proc_t</strong> domain.</li>
				<li class="calibre9">User-managed procedures can be labeled with <strong class="source-inline">unpriv_sepgsql_proc_exec_t</strong> (for unconfined users) and <strong class="source-inline">user_sepgsql_proc_t</strong> (for confined users). These procedures and functions will continue to run in the user domain itself.</li>
			</ul>
			<p class="calibre3">To get the <a id="_idIndexMarker636" class="pcalibre calibre6 pcalibre1"/>currently assigned label for the function, use the <strong class="source-inline">LIKE</strong> statement as the functions are defined (in the <strong class="source-inline">objname</strong> column) with variables in their name. As such, they are not always that obvious to immediately select:</p>
			<p class="source-code">db_test=# SELECT objname,provider,label FROM pb_seclabels WHERE objname LIKE 'compare_hash%';</p>
			<p class="calibre3">Let's mark these functions as trusted:</p>
			<p class="source-code">db_test=# SECURITY LABEL ON FUNCTION compare_hash(fuid integer, fphash text) IS 'system_u:object_r:sepgsql_trusted_proc_exec_t:s0';</p>
			<p class="source-code">db_test=# SECURITY LABEL ON FUNCTION set_hash(fuid integer, fphash text) IS 'system_u:object_r:sepgsql_trusted_proc_exec_t:s0';</p>
			<p class="calibre3">With these labels in place, the database user can execute the appropriate checks and changes even though the user has no access to the <strong class="source-inline">phash</strong> column itself:</p>
			<p class="source-code">db_test=&gt; SELECT compare_hash(1, 'abc123');</p>
			<p class="source-code">f</p>
			<p class="source-code">db_test=&gt; SELECT set_hash(1, 'abc123');</p>
			<p class="source-code">1</p>
			<p class="source-code">db_test=&gt; SELECT compare_hash(1, 'abc123');</p>
			<p class="source-code">t</p>
			<p class="calibre3">Of course, preventing unauthorized users from accessing sensitive data is not something that PostgreSQL cannot do without <strong class="source-inline">sepgsql</strong>. PostgreSQL can have procedures and functions marked as running with the privileges of the owner of the function or procedure, rather than the executing session. What <strong class="source-inline">sepgsql</strong> provides is another means to accomplish this, or offer data <a id="_idIndexMarker637" class="pcalibre calibre6 pcalibre1"/>protection through other security models.</p>
			<p class="calibre3">For instance, in our example, the in-database permissions of the <strong class="source-inline">testuser</strong> account are still applicable, we are not granting the <strong class="source-inline">testuser</strong> account other privileges or escalating its privileges to a higher set – instead, we are using the SELinux labels and context information to additionally filter privileges.</p>
			<h2 id="_idParaDest-244" class="calibre10"><a id="_idTextAnchor248" class="pcalibre calibre6 pcalibre1"/>Using sepgsql-specific functions</h2>
			<p class="calibre3">The <strong class="source-inline">sepgsql</strong> PostgreSQL module adds a handful of functions that we can use to interact with <a id="_idIndexMarker638" class="pcalibre calibre6 pcalibre1"/>the labeling within the database:</p>
			<ul class="calibre8">
				<li class="calibre9">With <strong class="source-inline">sepgsql_getcon()</strong>, we can obtain the current context for the session.</li>
				<li class="calibre9">With <strong class="source-inline">sepgsql_setcon()</strong>, we can change the context of the current session, provided that the current context has the permissions to do so, of course.</li>
				<li class="calibre9">With <strong class="source-inline">sepgsql_restorecon()</strong>, all objects within the current database are relabeled back to the default setup. The function supports a single argument, which can be <strong class="source-inline">NULL</strong>, or be a reference to a file that defines the new defaults.</li>
				<li class="calibre9">With <strong class="source-inline">sepgsql_mcstrans_in()</strong> and <strong class="source-inline">sepgsql_mcstrans_out()</strong>, we can interact with the <strong class="source-inline">mcstrans</strong> daemon (if it is running), translating from a human-readable sensitivity range to raw (<strong class="source-inline">_in()</strong>) or vice versa (<strong class="source-inline">_out()</strong>).</li>
			</ul>
			<p class="calibre3">These functions are useful when maintaining labels or defining functions that have logic included that depends on the context information.</p>
			<h1 id="_idParaDest-245" class="calibre5"><a id="_idTextAnchor249" class="pcalibre calibre6 pcalibre1"/>Using MCS and MLS</h1>
			<p class="calibre3">The most <a id="_idIndexMarker639" class="pcalibre calibre6 pcalibre1"/>common <a id="_idIndexMarker640" class="pcalibre calibre6 pcalibre1"/>use case for enabling the <strong class="source-inline">sepgsql</strong> module <a id="_idIndexMarker641" class="pcalibre calibre6 pcalibre1"/>is to use <strong class="bold">Multi-Category Support</strong> (<strong class="bold">MCS</strong>) and <strong class="bold">Multi-Level Security</strong> (<strong class="bold">MLS</strong>) support <a id="_idIndexMarker642" class="pcalibre calibre6 pcalibre1"/>within SELinux to fine-tune access to resources.</p>
			<h2 id="_idParaDest-246" class="calibre10"><a id="_idTextAnchor250" class="pcalibre calibre6 pcalibre1"/>Limiting access to columns based on categories</h2>
			<p class="calibre3">Suppose <a id="_idIndexMarker643" class="pcalibre calibre6 pcalibre1"/>we use the range of category numbers from <strong class="source-inline">c900</strong> to <strong class="source-inline">c909</strong> to address specific PII datasets, and grant users access to these categories either by granting them direct access, or by using specific SELinux contexts to consult this data.</p>
			<p class="calibre3">Within <a id="_idIndexMarker644" class="pcalibre calibre6 pcalibre1"/>the database, we could mark the PII-sensitive data with a category number within that range:</p>
			<p class="source-code">db_test=# SECURITY LABEL ON COLUMN tb_users.mail IS 'system_u:object_r:sepgsql_table_t:s0:c903';</p>
			<p class="source-code">db_test=# SECURITY LABEL ON COLUMN tb_users.address IS 'system_u:object_r:sepgsql_table_t:s0:c903';</p>
			<p class="calibre3">With the labels applied, a user that does not have access to this category will not be able to access the data:</p>
			<p class="source-code">db_test=&gt; SELECT sepgsql_getcon();</p>
			<p class="source-code">user_u:user_r:user_t:s0-s0:c0.c100</p>
			<p class="source-code">db_test=&gt; SELECT uid,name,mail,address FROM tb_users;</p>
			<p class="source-code">ERROR:  SELinux: security policy violation;</p>
			<p class="calibre3">With the category range for the user set correctly, access to the data is granted:</p>
			<p class="source-code">db_test=&gt; SELECT sepgsql_getcon();</p>
			<p class="source-code">user_u:user_r:user_t:s0-s0:c0.c100,c900.c904</p>
			<p class="source-code">db_test=&gt; SELECT uid,name,mail,address FROM tb_users;</p>
			<p class="calibre3">It is important to understand though that most domains will be allowed to switch their category set, as long as it remains within the allowed range:</p>
			<p class="source-code"># semanage login -l</p>
			<p class="source-code">Login Name     SELinux User    MLS/MCS Range    ...</p>
			<p class="source-code">...</p>
			<p class="source-code">taylor         user_u          s0-s0:c0.c100,c900.c903 ...</p>
			<p class="calibre3">This means that, even when a user session for this user launches with a more limited category set (for instance, using the <strong class="source-inline">runcon</strong> command), the user will still be able to call <strong class="source-inline">runcon</strong> again to extend the category range, or use the <strong class="source-inline">sepgsql_setcon()</strong> function:</p>
			<p class="source-code">db_test=&gt; SELECT sepgsql_getcon();</p>
			<p class="source-code">user_u:user_r:user_t:s0-s0:c0.c100;</p>
			<p class="source-code">db_test=&gt; SELECT sepgsql_setcon('user_u:user_r:user_t:s0-s0:c0.c100,c900.c903');</p>
			<p class="source-code">db_test=&gt; SELECT sepgsql_getcon();</p>
			<p class="source-code">user_u:user_r:user_t:s0-s0:c0.c100,c900.c903</p>
			<p class="calibre3">To <a id="_idIndexMarker645" class="pcalibre calibre6 pcalibre1"/>remediate this, we <a id="_idIndexMarker646" class="pcalibre calibre6 pcalibre1"/>need to have the target domain be MCS-constrained.</p>
			<h2 id="_idParaDest-247" class="calibre10"><a id="_idTextAnchor251" class="pcalibre calibre6 pcalibre1"/>Constraining the user domain for sensitivity range manipulation</h2>
			<p class="calibre3">The SELinux <a id="_idIndexMarker647" class="pcalibre calibre6 pcalibre1"/>policy always allows reducing the category range, so a range that initially includes the <strong class="source-inline">c900</strong> category can always switch to a category range that excludes this category. The rules within SELinux that grant domains the privilege to reduce their category range use dominance rules, which are basically algorithms running mathematical set expressions on the source and target set: if the target set is fully enclosed within the source set, then SELinux will allow the range transition to occur.</p>
			<p class="calibre3">The policy however also allows for extending the category range (if the range remains within the allowed range as defined by the SELinux configuration for the user), unless the domain <a id="_idIndexMarker648" class="pcalibre calibre6 pcalibre1"/>itself is marked as <strong class="bold">MCS-constrained</strong>. The default MCS-constrained domains are generally those domains used for sandbox usage or virtualization, as we will see in <a href="B16276_09_Final_VK.xhtml#_idTextAnchor257" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 9</em></a>, <em class="italic">Secure Virtualization</em>.</p>
			<p class="calibre3">However, we can easily add more domains. For instance, to mark the user domain as MCS-constrained, load the following CIL policy:</p>
			<p class="source-code">(typeattributeset cil_gen_require mcs_constrained_type)</p>
			<p class="source-code">(typeattributeset cil_gen_require user_t)</p>
			<p class="source-code">(typeattributeset mcs_constrained_type (user_t))</p>
			<p class="calibre3">This will prevent the <strong class="source-inline">user_t</strong> domain from growing its category range again.</p>
			<h1 id="_idParaDest-248" class="calibre5"><a id="_idTextAnchor252" class="pcalibre calibre6 pcalibre1"/>Integrating SEPostgreSQL into the network</h1>
			<p class="calibre3">When <a id="_idIndexMarker649" class="pcalibre calibre6 pcalibre1"/>we use the <strong class="source-inline">sepgsql</strong> module in PostgreSQL, all database sessions need to have a security context associated with them. While for local communications (which use Unix domain sockets) this context is readily available, networked sessions (which are the most common) do not automatically have a context set.</p>
			<p class="calibre3">If the system does not participate in a labeled networking setup, as we saw in <a href="B16276_05_Final_VK.xhtml#_idTextAnchor138" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 5</em></a>, <em class="italic">Controlling Network Communications</em>, interaction with the database will fail:</p>
			<p class="source-code">$ psql -U testuser -h ppubssa3ed db_test</p>
			<p class="source-code">psql: FATAL:  SELinux: unable to get peer label: Protocol not available</p>
			<p class="calibre3">To <a id="_idIndexMarker650" class="pcalibre calibre6 pcalibre1"/>resolve this, the recommended approach is to start using labeled IPSec. However, we can also use NetLabel to introduce fallback labeling where needed.</p>
			<h2 id="_idParaDest-249" class="calibre10"><a id="_idTextAnchor253" class="pcalibre calibre6 pcalibre1"/>Creating a fallback label for remote sessions</h2>
			<p class="calibre3">With Linux's NetLabel and CIPSO support (as seen in <a href="B16276_05_Final_VK.xhtml#_idTextAnchor138" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 5</em></a>, <em class="italic">Controlling Network Communications</em>) we can introduce both fallback labeling (associating a label based on the source address), as well as use full labeling for localhost communication.</p>
			<p class="calibre3">With <a id="_idIndexMarker651" class="pcalibre calibre6 pcalibre1"/>full, local label support, NetLabel can pass the source context to the target if all this communication solely traverses over the loopback device (as such communication does not leave the system, allowing NetLabel to trace and support the flow from end to end and provide context information to the receiving service).</p>
			<p class="calibre3">Let's create the CIPSO definition for local labeling:</p>
			<p class="source-code"># netlabelctl cipsov4 add local doi:2</p>
			<p class="calibre3">We now create a default context for communication coming from the network (over the <strong class="source-inline">eth0</strong> interface and the <strong class="source-inline">192.168.100.1/24</strong> network). It is this context that we will see when connecting to the PostgreSQL server over the network:</p>
			<p class="source-code"># netlabelctl unlbl add interface:eth0 address:192.168.100.0/24 label:user_u:user_r:user_t:s0</p>
			<p class="calibre3">We can now remove the default mapping rules, and add mapping rules for the different communication types:</p>
			<p class="source-code"># netlabelctl map del default</p>
			<p class="source-code"># netlabelctl map add default address:0.0.0.0/0 protocol:unlbl</p>
			<p class="source-code"># netlabelctl map add default address:::/0 protocol:unlbl</p>
			<p class="source-code"># netlabelctl map add default address:127.0.0.1 protocol:cipsov4,2</p>
			<p class="calibre3">The mappings we created will allow unlabeled communication for everything (but keep in mind that we have a specific label defined for communication coming from <strong class="source-inline">192.168.100.0/24</strong>) and loopback-based full labeling on the localhost.</p>
			<h2 id="_idParaDest-250" class="calibre10"><a id="_idTextAnchor254" class="pcalibre calibre6 pcalibre1"/>Tuning the SELinux policy</h2>
			<p class="calibre3">Next to <a id="_idIndexMarker652" class="pcalibre calibre6 pcalibre1"/>the labeling configuration, we might also need to further fine-tune the SELinux policy for PostgreSQL. A couple of SELinux booleans are worth mentioning here:</p>
			<ul class="calibre8">
				<li class="calibre9">The <strong class="source-inline">postgresql_selinux_transmit_client_label</strong> SELinux boolean (disabled by default) allows the <strong class="source-inline">postgresql_t</strong> domain to set its own session contexts. The PostgreSQL server might want to set its own session context when the server itself has database connections to other, remote databases (for instance, using PostgreSQL's <strong class="bold">Foreign Data Wrapper</strong> (<strong class="bold">FDW</strong>) support). When enabled, the client context <a id="_idIndexMarker653" class="pcalibre calibre6 pcalibre1"/>will be passed on to the remote databases as well.</li>
				<li class="calibre9">The <strong class="source-inline">postgresql_selinux_unconfined_dbadm</strong> SELinux boolean (enabled by default) grants administrative database privileges in <strong class="source-inline">sepgsql</strong> to any unconfined user domain.</li>
				<li class="calibre9">The <strong class="source-inline">postgresql_selinux_users_ddl</strong> SELinux boolean (enabled by default) allows unprivileged <a id="_idIndexMarker654" class="pcalibre calibre6 pcalibre1"/>users to run <strong class="bold">Data Definition Language</strong> (<strong class="bold">DDL</strong>) statements. There are database statements that create new tables, views, and so on, and will result in user-oriented types such as <strong class="source-inline">user_sepgsql_table_t</strong> being used.</li>
				<li class="calibre9">The <strong class="source-inline">selinuxuser_postgresql_connect_enabled</strong> SELinux boolean (disabled by default) allows user domains to connect to the PostgreSQL daemon over the Unix domain sockets.</li>
			</ul>
			<p class="calibre3">Don't forget to persist the boolean changes (using <strong class="source-inline">setsebool -P</strong>) as otherwise, a system reboot will revert the settings back to their default values.</p>
			<h1 id="_idParaDest-251" class="calibre5"><a id="_idTextAnchor255" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
			<p class="calibre3">The PostgreSQL database can be extended with SELinux support using the <strong class="source-inline">sepgsql</strong> module. The module adds label support to the various objects within a database, and checks access permissions between the session context and the target label. To obtain the session context, <strong class="source-inline">sepgsql</strong> relies either on purely socket-based communication, or labeled networking.</p>
			<p class="calibre3">In this chapter, we learned how to enable the <strong class="source-inline">sepgsql</strong> module and how to troubleshoot possible policy issues. We then used the various default types within an example database and used these types to show how the access controls in <strong class="source-inline">sepgsql</strong> work. We then used SELinux's MCS support to further handle category-based access controls. Finally, we integrated PostgreSQL in a network using fallback labeling support.</p>
			<p class="calibre3">In the next chapter, we will examine secure virtualization within Linux and see how SELinux contributes to the isolation of virtual guests.</p>
			<h1 id="_idParaDest-252" class="calibre5"><a id="_idTextAnchor256" class="pcalibre calibre6 pcalibre1"/>Questions</h1>
			<ol class="calibre18">
				<li value="1" class="calibre9">Is SEPostgreSQL part of the default PostgreSQL technology?</li>
				<li class="calibre9">What else needs to be additionally enabled before <strong class="source-inline">sepgsql</strong> can be used properly?</li>
				<li class="calibre9">How do you set or query the labels on database objects?</li>
				<li class="calibre9">Why are the <strong class="source-inline">sepgsql</strong> decision events not available in the system audit log?</li>
			</ol>
		</div>
	</div></body></html>