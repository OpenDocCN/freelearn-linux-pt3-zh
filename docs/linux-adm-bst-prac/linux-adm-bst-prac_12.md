# 第八章：通过脚本编写和 DevOps 提升自动化以改进管理成熟度

我认为，对于我们大多数系统管理员来说，脚本编写和自动化是我们自然倾向于思考如何改善整体系统的最佳机会。这可能会被视为一种重要的工作方式，自动化毫无疑问非常重要，但它也并不是系统管理的终极目标。可以说，随着我们不断学习脚本编写和自动化，我们将拥有更多的自由时间，集中精力去处理只有人类才能完成的任务，同时也能更深入地理解开发人员的工作，这对于我们 IT 领域的从业者总是非常有帮助的。

系统自动化是一个领域，在这里我们更容易获得炫耀的资本，展示我们每天的任务清单。当我们坐在比喻的系统管理员鸡尾酒酒吧里，向同伴们讲述我们如何编写了一些非常清晰且易于阅读的文档时，我们并不会感到满足。但当我们解释如何编写一个复杂的脚本，将我们每周工作量中需要几小时的任务，转化为计算机调度器自动运行的任务时，我们会获得称赞、关注、彩带、报纸横幅游行、同事们为我们买来一杯杯最爱的饮品，如果非常幸运的话，还有一个打击乐器。

自动化通常是我们大多数人在系统管理中既感到兴奋又感到害怕的领域。与系统管理的其他领域相比，自动化涉及更多的构建模块和需要理解的概念。大部分情况下，系统管理很像上历史课，确实，了解更多历史片段有助于你在学习新内容时拥有更大的背景，但通常你可以单独学习任何特定事件，而不需要全面了解与之相关的所有事件和导致这些事件发生的背景，依然能够从中学到有价值的东西，并且本质上理解它。当你学习罗马历史时，即便你没有先学希腊历史，也不会感到迷失。然而，脚本编写和自动化更像数学课，如果你没有学会加法，那么学会如何求平方根将是完全不可能的。脚本编写是一项累积的技能，要真正发挥作用，你需要学一些基础内容。

我们将首先通过对比未编写脚本的命令行管理与使用图形用户界面（GUI）来作为基础，进一步学习如何进入自动化领域。

在本章中，我们将学习以下内容：

+   图形用户界面与命令行界面：管理最佳实践

+   自动化成熟度

+   **基础设施即代码**（**IaC**）

+   **文档优先管理**（**DFA**）

+   现代自动化工具

## 图形用户界面与命令行界面：管理最佳实践

如果你是从 Windows 环境转向 Linux，你可能没有意识到几乎所有操作都应该通过命令行完成，而不是图形用户界面。但实际上，即便在 Windows 上，微软早就明确表示，桌面体验主要是为最终用户设计的，而不是为系统管理员设计的，并且他们推荐在直接操作本地系统时，使用 PowerShell 作为首选管理工具，或者使用通过 API 连接的远程管理工具。微软强烈建议过去几代安装其操作系统的人，在安装操作系统和虚拟机管理程序时完全不使用图形用户界面。

图形用户界面，或者现在我们简称为 GUI，给系统管理员带来了许多问题。

GUI 的第一个问题是膨胀。在安装企业操作系统时，如果有 GUI 可用，它往往占据了系统中一半以上的代码。每增加一行代码，就意味着我们需要存储更多的数据，存储的数据越多，我们就需要备份更多；更多的代码意味着更多的 bug、缺陷或故意的后门要担心；更多的代码需要打补丁和维护，等等。

接下来是性能。GUI（图形用户界面）在运行时需要的计算能力和内存消耗要比非 GUI 系统大得多。GUI 通常需要额外 2GB 或更多的系统内存，这比系统工作负载所需的内存还要多。这听起来可能微不足道，但特别是在多个系统合并到一台硬件上时，这个问题可能会迅速加重。如果我们有二十台虚拟服务器运行在同一物理服务器上，那么在 Linux 环境下，平均工作负载可能仅为 2 到 4GB 的内存。每个系统再增加 2GB 内存，不仅意味着接近 50%的增长，而且在所有机器上将增加 40GB 的内存。

## 系统整合与压缩系统的时代

在 1990 年代和 2000 年代，虚拟化普及之前，我们处于一个服务器性能快速增长的时代，但每台系统只能运行一个操作系统，无论该系统的工作负载有多小。随着系统性能的增强，远远超过了软件使用资源的速度，系统膨胀的趋势越来越强烈，因为至少在硬件方面，膨胀并不那么重要。

CPU 和内存资源通常是以离散块的形式提供的，要拥有足够的资源，我们通常需要购买更多。过去，系统很少会接近其极限运行，因为那个时候扩展系统非常困难。因此，系统通常设计得有很多备用资源，以便留有大幅度的误差空间，当然也为将来的增长留有余地。由于这些原因，在服务器上运行 GUI 几乎是微不足道的。

自那时以来，许多因素发生了变化。我们或许可以写一本书，专门讨论为何在使用命令行数十年后，行业短暂地从命令行转向图形用户界面（GUI），尤其是从 1990 年代中期到 2000 年代初，GUI 似乎一度成为服务器管理的主流方式，直到 2005 年左右又重新回到命令行。忽略社会趋势推动的变化，我们在这里关注的是容量问题。

一旦虚拟化成为主流，尤其是随着云计算开始成为一个重大趋势，操作系统的空闲资源几乎在一夜之间变得不再常见。这看起来似乎与直觉相反，因为虚拟化本身为我们提供了更多的灵活性和计算能力。但它也赋予了我们非常有效地缩减规模的能力，这是我们之前所没有的。通过虚拟化，我们很少会处于拥有大量过剩系统资源的情况，特别是那些可以预测的过剩资源，因此保持每个虚拟机尽可能精简就显得尤为重要，这意味着不运行一个庞大且大多无用的 GUI 进程。仍然无法将工作负载合并到单一服务器的有效下限的小型企业是这一规则的例外，它们仍然有足够的开销来实现 GUI，除非它们是云计算的良好候选者。

在传统的企业环境中，多个服务器是常见的，虚拟化的一个主要优势是整合，避免安装 GUI 意味着可以在一台物理服务器上安装 50 或 60 个工作负载，而不是在相同硬件上安装 30 或 40 个。这相当于减少了购买服务器的需求，从而节省了成本，不仅降低了采购成本，还减少了电力消耗、制冷费用、数据中心房地产费用、软件许可费用，甚至 IT 人员成本。

如果我们以公共云计算为例，我们可以更容易地看到没有 GUI 的优势。小型工作负载，比如邮件服务器、Web 服务器、代理服务器、电话交换机等，每月运行成本可能仅为 5 到 10 美元。如果加上 GUI，云托管虚拟机的成本可能轻松翻倍，从 5 美元涨到 10 美元，或从 10 美元涨到 20 美元等等，因为 GUI 需要更多的 CPU、存储，最重要的是更多的内存。很容易看出，从每月 10 美元到 20 美元的工作负载成本上涨会迅速积累。由于大多数基于云的工作负载都非常小，给每个工作负载添加 GUI 可能会对容量产生巨大的影响，甚至可能使公司的基础设施计算成本翻倍！

GUI 不适用的程度如此之大，以至于许多供应商传统上甚至没有为云空间提供连接 GUI 的机制。亚马逊以其不允许在标准云实例上使用 GUI 而闻名，这实际上迫使组织学习命令行，甚至是更先进的管理技术，而不需要登录。但几乎所有云用户都会选择通过如 SSH 之类的技术进行远程登录。云计算比任何其他方式都更能证明 GUI 的风险和成本。

在虚拟化和云计算普及之前，系统管理员，尤其是那些在 Windows 环境中的管理员，会争辩说 GUI 根本不会增加太多开销，如果它们能让某人的工作变得更轻松，那它们就是值得的。这个神话已经被揭穿，今天没有人能诚实地再做这种声明。GUI 在任何广泛意义上都是不合逻辑的。

对于管理层来说，命令行管理的最大卖点通常是关于安全性的。GUI 为恶意攻击者提供了更大的攻击面，增加了突破系统的可能性。仅仅是多出的那些代码，就让潜在攻击者的工作变得更加容易。而且，当然，GUI 的功能本身就需要更多的访问手段，这自然形成了非常诱人的攻击面。更多的代码行、更多的访问方式、更多的管理路径、更低的性能等，都共同增加了整体的安全风险。综合来看，虽然这可能不是非常严重，但风险的增加是真实的，也是可以衡量的，或者至少可以估算的。

命令行管理成为*事实上的*标准的最终主要原因是效率。是的，正是许多人选择保持图形用户界面（GUI）的理由。现实是，系统管理不是一项轻松的任务，也不是你可以轻松地四处摸索并猜测应该使用什么设置的工作。要做好这项工作，甚至做到安全，你必须对大量的项目有相当扎实的理解，从操作细节到一般的计算和网络知识。

管理中的 GUI 传统上被宣传为一种工具，旨在帮助那些不习惯环境的人能够更快地高效工作，减少培训和知识要求。如果你谈论的是清洁工，这个概念是很不错的。在系统管理中，我们最不希望看到的就是没有深厚知识和经验的人能够表现得像是他们知道自己在做什么。这在多个层面上都是危险的。遗憾的是，GUI 实际上让许多组织更难评估哪些候选人至少符合技术职位的基本资格。

图形用户界面（GUI）不仅存在着未经授权的人员可能会随意操作的风险，对于那些知道自己在做什么的人来说，命令行的速度要快得多。它在执行简单任务、执行大多数复杂任务时更快，而且更容易编写脚本或自动化。命令行管理与脚本编写如此契合，以至于人们常常分不清两者的区别。如果你真正对比任务，你会发现命令行工作完成相同任务所需的时间通常不到使用 GUI 的百分之十！

命令行不仅对系统更高效，它还使多系统管理变得更加容易，因为命令可以在不同的系统间复制，这些是 GUI 操作所无法做到的。命令行管理还可以轻松录制、归档、搜索等等。虽然在 GUI 中做同样的事也是可能的，但需要长时间的视频录制，这会导致大量存储需求，而且没有简单的方法来解析或转化为文档等。

在现代时代，我们开始面临需要远程执行大部分或所有系统管理任务的问题。这无意中恰好迎合了命令行的优势。命令行需要传输的数据量和对网络延迟的敏感度远小于 GUI。远程 GUI 会话通常会消耗显著的网络流量。远程 GUI 会话是视频流，通常具有相当高的分辨率。在某些情况下，即使是一个用户也能引发网络问题，尤其是当服务器位于网络连接较差的地区时。远程命令行管理的标准方法是 SSH。

即使通过古老的拨号上网连接，SSH 远程会话也能正常工作。即使是最慢的现代互联网服务，也足以处理数十甚至数百个同时在线的 SSH 用户。这是一般远程 GUI 会话做不到的。命令行在全球另一端通过微弱的网络连接几乎同样有效，而 GUI 远程管理则容易受到网络波动、限制或距离的明显影响。

命令行将持续存在，但理解其存在的真正原因非常重要。我们容易忽视它远不止依赖于一两个小因素。实际上，有很多充分的理由说明为什么在可能的情况下你应该使用命令行。来回切换并不利于提高这两种方法的效率。从个人角度来看，理应尽可能避免使用 GUI，以便专注于学习命令行技能。持续使用命令行是提高效率的必要条件。

现在我们必须承认，Linux 有许多不同的命令行选项。我们可以使用`BASH`、`Fish`、`zsh`、`tcsh`、PowerShell 等。正如我们所知道的，Linux 是关于选项和灵活性的。这是一个“少即是多”的情况。有些 Shell 非常好用且有用，但我们必须记住，我们是系统管理员，我们需要确保对在紧急情况下可能接触到的工具非常熟悉。在 Shell 之间切换并不特别难，特别是在 Linux 环境下，但我们仍然应该警惕花时间学习像`Fish`或`zsh`这样的 Shell 中的便捷键、自动补全和其他特性，因为我们可能在下一个工作中无法使用这些技能，这始终是一个需要考虑的因素。而且，如果在紧急情况下你被叫去处理一个你之前没有机会设置的系统，你可能唯一的选择就是 BASH。对我来说，这意味着 BASH 是我唯一想学习的工具。

就是这样。所有的逻辑和推理都在这里，这样你就可以回到管理层，解释为什么你需要从命令行工作，为什么你需要那些能从命令行工作的员工，为什么你的系统应该很少安装任何 GUI 环境。在下一节中，我们将讨论系统自动化的成熟度等级。

# 自动化成熟度

虽然没有正式的系统来衡量自动化成熟度，但我们可以讨论一些自动化成熟度的基本概念。这里的观点是，组织在自动化程度上大致处于一个连续体中，从没有自动化到完全自动化，大多数组织处于中间位置，但更可能趋向于没有自动化，而不是完全自动化。

不是每个组织都需要，甚至应该，完全实现自动化。但一般来说，当自动化实施成本足够低时，更多的自动化是更好的。自动化并不是免费的，实际上，组织可能会发现，投入自动化一个流程的成本要高于手动执行这个任务的成本，尤其是在系统的生命周期内。我们不希望仅仅为了自动化而盲目自动化。

然而，通常情况下，我们发现组织几乎在所有情况下都会跳过自动化，而选择使用人工劳动，承受所有成本和风险。这是一种自然倾向，因为在当下，任何任务如果手动做都会更简单。如果我们不着眼未来并进行投资，我们根本就不会去自动化，而这也是许多公司看待 IT 需求的方式。如果一个任务手动完成需要一小时，自动化需要三小时，那就相当于三个任务的时间，忽略这个事实是很难证明合理的，因为同样的任务每个月都会发生，四个月后，自动化不仅会减少工作量，而且自动化还能让任务更可靠和一致。

几乎任何组织都将从比今天更多的自动化中受益。没有必要把自动化看作是非做不可的全有或全无的选择。可以做的就自动化，做不了的就跳过。要务实。首先做最容易实现的部分。你自动化的越多，未来你就能有更多的时间去自动化其他事情。随着实践的积累，你的自动化技能也会提升，使得每一次新的自动化都比上一次更容易。自动化正是一个典型的例子，第一次做起来确实很难，但随着时间的推移，它会变得越来越容易，直到它成为处理事情的显而易见的方法，并且变成第二天性。

自动化的成熟度并不完全是一个直接的连续体，每一步都比上一步*更加成熟*。例如，如果我们看看调度任务和脚本任务，这两者可以独立于对方执行。每个任务单独完成都有其用处。我们可以编写复杂的操作脚本并手动运行它们，或者可以调度简单的独立命令来触发事情的发生，无需人工干预。然后，我们可以将两者结合起来，自动启动执行多项任务的复杂脚本。我们首先考虑哪个，第二考虑哪个其实是随意的。

## 本地与远程自动化

如果这不够明显的话，我们有两个选择：要么在本地实现自动化，通过调度任务或触发任务在目标服务器上运行，要么我们可以从外部来源推动自动化，从而实现某种形式的自动化集中化。还有一种混合方法，本地调度器或代理向中央服务器请求自动化信息，虽然从技术上讲仍然是本地的，只不过是有一个集中存储来模拟控制。

常常被忽视的是本地自动化的优势，即即使远程系统不可用，甚至本地系统完全失去网络连接，本地任务仍然能够运行。我最喜欢保留为本地自动化的任务之一就是系统重启。虽然将重启集中管理会更方便，且我见过一些组织选择这么做，但我非常欣赏有一个本地的、强制性的重启任务，它每周至少会执行一次，有时甚至是每天。这让我非常安心，即使服务器出现完全崩溃的情况，只要它以任何形式仍能运行，最终重启过程都会尝试重新启动机器，并希望能够让它重新上线。这是一个非常小众的需求，可能对你来说永远不重要，但我见过有些系统即使远程管理无法访问，仍能继续提供工作负载，而一个自动化、本地调度的重启任务将它们重新带回线上，并使其再次可访问。

一种越来越流行的中庸之道是拥有一个中央控制库，包含所有所需的自动化内容，然后由终端的代理拉取进行自动化。这些库既包含自动化本身，如脚本，也包含调度信息或触发器。然后，信息通过本地脚本得以实现，即使远程库出现故障或不可用，本地脚本仍能独立运行。通过这种方式，你真正面临的风险只是无法更新调度任务列表、对它们或调度进行更改。只要不需要发布新的自动化更新，就不必担心库会离线。

## 命令行

这不仅仅是一个合法的成熟度级别，更像是一个基本的起点，因此我们可以把它看作是零级，指的是进入命令行并使用一个适当的 Shell 环境进行交互式操作（即：非自动化）。正如我们刚刚讨论的，处于命令行并学习命令行语法和工具是所有后续自动化构建的基础。理解如何在命令行上执行任务、如何操作文本文件、如何过滤日志以及其他常见的命令行任务，会迅速发展成显而易见的自动化能力。

## 定时任务

开始自动化的最佳且最简单的地方就是任务调度。这听起来可能是最简单、最显而易见的一步，但令人惊讶的是，许多组织甚至没有做到这一点。Linux 长期以来一直是可靠且易于管理的本地调度的堡垒，`cron`不仅内建于 Linux 中，几乎所有的 UNIX 系统都可以使用它，已经有近半个世纪历史（自 1975 年发布以来）。Cron 快速高效、无处不在且广为人知。任何有经验的 UNIX 管理员都应该能够在需要时至少调度一个基本任务。Cron 甚至能处理启动时的任务。

各种简单任务都可以通过 `cron` 执行。在大多数环境中，常见的任务可能包括系统更新、数据收集、重启、文件清理、系统复制和备份。你当然可以安排任何任务，但这些对于第一次进行自动化的用户来说，都是一些非常适合的建议，特别是对于那些显然是周期性系统需求的任务。

另一个常见的简单计划任务领域是通过像 `git` 这样的代码库进行代码更新。当我们拉取新代码时，代码更新及随后的数据库迁移都可以轻松地安排定时执行。

## 脚本编写

当我们谈到自动化时，每个人总是立刻想到脚本编写。归根结底，自动化中几乎所有的内容都或直接，或在幕后以某种方式是脚本编写。脚本编写提供了动力，当我们想要超越最简单的任务或只是调用别人写的脚本时，脚本编写就显得至关重要。

我们不可能在这里教授脚本编写本身，因为那是一个完整的主题。脚本编写是 IT 与软件开发领域交集的最接近的地方。将 IT 命令行任务结合起来在哪一点变成了编程呢？从技术上讲，这一切都是编程，但它是以纯粹专注于系统管理任务的极简编程形式出现的。

通常在 Linux 上，我们会使用 BASH shell 编写脚本。BASH 是一种非常简单的语言，设计上主要用于交互式操作作为一个实时 shell，BASH 是我们假定所有 Linux 命令行交互都会通过的方式。BASH 相对强大且功能丰富，几乎可以用它编写任何脚本。至少在开始时，大多数 Linux 管理员会使用他们在命令行环境中已经在用的 BASH shell，并有机地将脚本元素添加进来，从单一命令、一组基本命令串联到逐步进入完整的脚本编写。

任何 shell，如 `tcsh`、`ksh`、`fish` 和 `zsh`，都允许你进行脚本编写，并且在许多情况下，比 BASH 提供了更多的功能和灵活性。传统的 shell，如 `tcsh`、`ksh` 和 BASH，可能非常有限且笨拙，尝试用它们进行高级脚本编写可能会有困难。Apple 在其 macOS UNIX 操作系统上最近转向使用 `zsh`，以便与其他 UNIX 系统相比进行现代化。通常情况下，Linux 系统默认不会安装更现代、更先进的 shell，尽管它们几乎可以在任何基于 Linux 的操作系统上轻松获得。

你可能在一个始终提供或提供了其他 shell 的环境中工作，或者你可能有机会自己添加它。如果是这样，尤其是在你需要进行跨平台脚本编写时，特别是与 macOS 一起工作时，你可以考虑使用 `zsh` 而不是 BASH；或者如果你做了大量 Windows 脚本编写，PowerShell 作为 Windows 的本地 shell 也可以在 Linux 上使用。

## Linux 上的 PowerShell

你可能遇到的最奇怪的事情之一，就是在 Linux 上运行微软的 PowerShell。很多人感到困惑，认为它根本无法运行。实际上，PowerShell 在 Linux 上运行得很好。PowerShell 在 Linux 上的问题在于，Windows 上的 PowerShell 用户实际上几乎没有时间学习 PowerShell，而是把大部分时间用来学习各种 CommandLet 或小程序，这些程序可以通过 PowerShell 调用，并与其他小程序轻松结合，赋予系统强大的功能。

在 Linux 上，当然也会发生类似的事情。如果你在 Linux 上进行脚本编写，肯定会使用像 sed、awk、cut、head、tail、grep 等工具。这些工具类似于 CommandLet，但实际上只是日常的系统可执行文件。如果你将 `BASH` 或 `zsh` 移植到 Windows 上，你会发现你习惯在 Linux 上使用的工具仍然不可用。那是因为它们是你从 BASH 调用的小程序，而不是 BASH 本身的一部分。BASH 只是编程语言。

反过来也一样。如果你在 Linux 上运行 PowerShell，你仍然需要使用 sed、awk、cut、grep、head、tail 等工具。改变的是语言，而不是操作系统的工具和组件。

所以，尽管学习一种脚本语言并尝试在不同操作系统之间反复使用它是有价值的，但其价值并不像人们想象的那样大。你可能会花费更多时间去解决集成怪癖、误解和糟糕的文档，而这些时间远远超过了语言学习效率所能带来的回报。如果你尝试在 Linux 上使用 PowerShell，书籍、在线指南、示例代码等都不会对你有帮助。它们会假设你正在尝试用 Windows 工具来做 Windows 任务。PowerShell 从本质上来说，是一个真正现代的 Shell，利用操作系统对象来完成繁重的工作。而 BASH 则专注于文本处理和操作，因为 Linux 传统上是建立在文本文件上的，需要一个能够轻松处理这些文件的脚本引擎。

在 Linux 上使用如此陌生的 PowerShell 是一个很好的工具，可以揭示我们通常只视为 *命令行* 或 *Shell* 的不同组件的本质。如果我们在 Linux 上使用 `zsh`，几乎所有 BASH 内建的功能都可以在 `zsh` 中找到，并且它们都惯常使用相同的操作系统工具。而 PowerShell 几乎没有任何内建的命令可以复制，也没有共享的惯例，这使得它非常明显地区分了来自 Shell 的部分和操作系统中属于 Shell 之外的部分。

然而，一般来说，最推荐在你所在环境中得到良好支持的语言中进行所有脚本编写。就像我们在其他系统管理领域所说的那样，使用那些无处不在、被广泛理解并且适合该环境的工具非常重要。对于大多数人来说，这意味着仅使用 BASH。BASH 是唯一一个在你遇到的每个 Linux 系统上都可以绝对使用的脚本环境。其他的 shell 或脚本语言可能很常见，但没有哪个能像 BASH 那样普及。

当 BASH 对于更高级的脚本编写显得过于局限时，转向另一种 shell（例如`zsh`）并不常见，因为其他 shell 非常罕见，且通常缺乏在放弃 BASH 后你可能需要的强大功能。传统上，作为 BASH 替代品的高级脚本编写语言通常是非 shell 脚本语言，如**Python**、**Perl**、**Tcl**、**PHP**和**Ruby**。Ruby 一直未能获得太多青睐。PHP 虽然在某些任务中非常常见，但作为通用的系统自动化语言却比较少见。Perl 和 Tcl 的受欢迎程度急剧下降，但曾几何时，Perl 是系统自动化语言中的领头羊。这使得 Python 成为了高级脚本需求的一个非常明确的领先者。

Python 总体上有许多优势。它的运行速度相当快。它几乎可以在任何平台或操作系统上使用（包括所有 Linux、其他 UNIX、macOS 和 Windows）。它相当容易学习（通常被用作新程序员的第一门语言）。它非常常见，很多 Linux 上的应用和工具都依赖于 Python，因此即使它不是作为标准安装，也经常会发现它已经预装好了。由于它在这些任务中如此常用，Python 在这方面的文档逐渐增多，围绕它编写的其他工具也应运而生，使得它越来越适合承担这一角色。

目前，几乎所有 Linux 系统的脚本编写都尽可能使用 BASH，而在需要更多功能或灵活性时则使用 Python。其他语言基本上都是小众应用。这意味着 BASH 和 Python 也有额外的理由让我们在选择自己的脚本语言时应该重点考虑它们：标准化。

系统自动化不同于一般的编程。广泛的编程开发人员花费多年时间学习多种语言、语言家族、构造，并且将所有时间都投入到编程环境中。在不同语言之间切换、学习新语言、适应语言变化等，都是开发者日常生活的一部分，而在语言之间切换的开销非常小。对于系统管理员来说，这有些不同。从理论上讲，我们花在学习编程上的时间非常少，而且很少接触到真正的语言多样性。因此，对于管理员来说，拥有一两种常用的语言是非常重要的，这样有助于我们在未来找到资源、示例、同行评审等，支持我们的自动化工作。当然，这些语言并不是唯一可接受的选择，但它们相较于大多数其他选项，确实有着相当大的优势。

当然，脚本编写是一个非常广泛的话题，脚本的内容从几行简单的按顺序执行的命令到包含复杂代码的大型程序都有。提升脚本编写技能是一个值得专门投入大量时间的话题。好的脚本通常会包括自己的日志机制、错误检测、函数、可重用组件等。你可以在系统自动化脚本上不断地投资更多的编程技能。

### 开发人员的脚本编写工具

无论你是在编写一个非常简单的脚本，还是在为你的组织中代代相传的自动化杰作而努力，你都值得迈出额外的一步，学习一些软件开发中使用的工具，以帮助脚本编写过程。

最简单的一方是像集成开发环境（IDE）这样的工具，它们能让编写代码变得更快、更容易，并帮助你避免错误。开发人员几乎总是使用这些工具，但系统管理员往往会忽视它们，因为他们认为自己编写脚本的时间很少，学习另一个工具可能不值得。而也许确实不值得，但你学会的工具越多，你就越可能使用它们，进而编写更多的脚本。一款好的 IDE 可以是免费的并且非常易于使用，因此它是一个很好的起点，你可以将它整合到你的工作流程中，而不需要花费太多时间或金钱，下载并安装一个也不过几分钟的事。

另一个开发人员几乎普遍使用、而系统管理员很少使用的真正庞大工具集是代码仓库和版本控制工具，如 Git 和 Mercurial。借助这些工具，尤其是将代码托管在这些工具所关联的中央服务器上，我们可以在编写和管理脚本方面实现飞跃。这些工具对于管理我们环境中其他形式的文本数据也非常有用。尤其是 Linux 使用基于文本的配置文件，可以像脚本一样处理，并将其纳入版本控制系统进行管理。这是跨领域技能共享的一个优秀应用。

版本控制无疑是软件开发世界中最必须掌握的技术，对于我们自己的脚本编写至关重要。版本控制让我们可以跟踪随时间变化的代码，测试代码并轻松回滚，它允许多个团队成员共同管理同一份脚本，按用户跟踪变更，支持代码审查和审核，简化数据保护和部署等等。如果你只采用一种开发技术，那就选这个。刚开始时可能会觉得有些繁琐，但很快它会变成第二天性，让你做的许多事情变得更加轻松。

开发世界中有许多我们可能会用到的其他工具，如持续集成、自动化部署和代码测试，这些工具根据我们编写的脚本可能会非常有用，但几乎所有这些工具都是小众的，即使在高度自动化的环境中，它们也是完全可选的。了解这些工具可以让你接触到可能对你的工作流程有意义也可能没有意义的选项，同时还能让你深入了解你的潜在开发团队可能的工作方式。

将软件工程作为获取如何更好编写脚本的灵感来源，但不要觉得你必须或者应该采用每一个工具和技术。自动化和产品开发的脚本编写确实有交集，但它们最终是不同的活动。

编写脚本并没有什么秘密，唯一的秘诀就是不断实践。市面上有许多优秀的书籍和在线资源可供参考。可以从最简单的项目开始，寻找过去可能手动完成的工作中可以通过脚本实现的机会。系统任务，如部署或系统设置检查清单，可能是一个很好的起点，或者编写用于部署一组标准工具的脚本，或许是编写一个收集多台机器特定数据的脚本。我经常发现自己在编写数据处理脚本。一旦你开始寻找，你可能会发现许多新的脚本技能可以派上用场的地方。

使用非计划脚本的最佳起点之一是基本的构建和安装任务。使用脚本来执行初始系统设置和配置，包括安装软件包、添加用户、下载文件、设置监控等等。这些任务通常在相对较小的努力下提供了大量的收益，并且可以作为一种文档形式，列出系统所需的任何软件包和配置更改。以这种方式完成的文档具有很高的权威性，因为它真正记录了实际使用的过程，而不是预期或假设的过程。

### 文档优先

在软件工程领域，有一个概念是编写测试来验证代码。虽然并不完美，但运行测试使得软件出现 bug 的可能性大大降低，因为测试会检查预期的行为并确保其发生。我们仍然可能遇到 bug，这绝非百分之百的保证，但它是一个很好的步骤。在经历了几十年的代码测试后，提出了在编写代码之前编写测试的可行性这一想法，研究发现这样做不仅能够减少 bug，还能提高代码编写的效率，仅仅因为编写测试促使我们以更好的方式思考问题解决方法。测试优先编程被认为是软件开发方法的一次突破。

这个概念可以在系统管理领域中以某种方式延续下来，我称之为文档优先工程。在这个概念中，我们首先编写文档，然后使用这些文档来构建系统。如果没有文档，我们就不构建它。就像测试驱动编程一样，这种方法迫使我们提前思考系统应该如何工作，这给了我们另一个机会，确保我们正在做的事情是经过良好规划和合理的。而且它还让我们有机会验证我们的文档是否完整且合理。当我们事后编写文档时，往往更容易制作出无法真正执行任务的文档。

在某些情况下，比如自动化程度较低的情况，这可能意味着仅仅在 Wiki 或文字处理软件中记录我们能记录的内容，并在部署系统时依赖这些文档。如果我们有更高的自动化水平，那么我们实际上可以将代码作为文档来编写，这些代码会为我们构建系统。由于代码本身就充当了文档，它不仅仅是文档优先，而是文档实际上完成了工作，这完全可以保证文档的完整性和准确性！

自动化的内在特性是鼓励更好的文档编制，并将文档从事后记录转向事前记录，进一步转变为将文档本身作为构建机制。这也意味着我们有可能看到效率上的双重提升，因为我们希望用于文档和脚本的版本控制、备份以及其他机制可以自动应用于两者。

使用高级工具进行脚本编写在某种程度上也可以被视为自动化成熟度的更高阶段。

## 脚本与任务调度的结合

希望显而易见的下一步是将任务调度和我们新获得的脚本知识结合起来，以获得更强大的功能。让复杂的任务能够自动运行，而无需任何人工干预。

以这种方式自动化的常见任务通常包括软件更新。拥有一个脚本，能够查找最新的更新，下载它们，准备环境，并在预定时间自动部署，十分方便。几乎任何应当一起执行的复杂任务都可以以这种方式进行调度，无论是每分钟一次，还是每月的第三个星期二。脚本也非常适用于处理条件性情形，在这些情形下，只有在特定条件下才执行某些操作，例如，只有当存储超过某个水平，或者某些特定人员登录时才执行。

几乎是一个特殊情况，因此我认为非常值得提及的是使用定时脚本来管理备份或复制。

## 状态管理

我们在系统自动化中经历的最令人惊叹的变化之一是引入了状态机和系统的状态管理。状态是一个难以解释的概念，因为这远离了 IT 和系统管理中的常规思维方式。然而，状态通常被视为系统的未来。

在传统的系统管理和工程中，我们谈论和思考任务：我们如何让系统从 A 点到 B 点。在状态理论中，我们不讨论如何管理系统的*方式*。相反，我们只关注预期的结果或*结果状态*。

*换个角度思考：我们开始关注结果，而不是关注过程。我们从以过程为导向转向以目标为导向。*

这种方法迫使我们真正改变几乎所有我们关于系统的思考方式和认知。它在各个方面都是一个游戏规则的改变，让我们这些人能够更好地专注于我们擅长的领域，同时让计算机在它擅长的领域做得更好。

所有这些魔法都是由所谓的*状态机*完成的。在系统管理的背景下，状态机是一个代理或代码片段，它接收一份或一系列文档，这些文档规定了系统所期望的状态。状态可以指系统的几乎任何方面，例如已安装的包、当前的补丁级别、配置文件的内容、防火墙中打开的端口以及应当运行的服务列表。

状态机会根据这些描述目标状态的文档，确保（或至少尝试）系统处于期望的状态。如果缺少某个包，它会安装该包。如果某个服务没有运行，它会启动该服务。如果配置文件不正确，它会进行修正。相反，如果某个不该安装的程序出现在系统中，它会被删除。如果某个不该运行的服务被启动，它会被关闭。

状态机通常每隔几分钟或几秒钟运行一次，扫描其状态文件并确定系统应该是什么样子，然后扫描系统以验证其已知的状态与预期的状态是否匹配。如果发现不一致，状态机会采取必要的纠正措施。当然，在背后，这一切都是通过复杂的脚本和系统工具完成的，这些脚本和工具组合在一起提供了强大的能力来强制执行状态。状态机能够采取纠正措施的程度取决于它可以访问的脚本的能力。这并不是无限的，但通常在 Linux 系统上，状态机具有足够的能力来应对现实世界中非攻击场景中的实际需求，并且在缓慢或阻止许多低强度攻击方面仍然非常有效。

从理论上讲，状态机通过保持系统处于我们所期望的几乎恒定的状态来实现这一目标。使用状态机时，我们花时间编写文档，描述我们希望系统具备的特性，然后让状态机本身负责如何使系统按预期方式运行。这包括机器的初始设置，将一个基本的、原始的操作系统安装转变为特定工作负载的功能组件。状态机也可以在虚拟化管理程序和云级别运行，从而使我们不仅能在单个系统内维护标准化的概念方法，还能在提供系统的平台级别保持这一标准。

### 登录的终结

状态管理的本质是鼓励（如果不是强制的话）彻底取消为了管理目的而登录服务器的概念。然而，在我们考虑消除登录之前，状态管理系统的作用是通过状态来改善传统的远程管理方式。

传统上，远程管理中最大的风险是需要开放端口，并且必须灵活地保持这些端口开放，以便在任何必要的时刻从任意位置进行管理。虽然将端口数量减少到最少，并将其限制为单一的 IP 地址在理论上看起来是一种很好的安全措施，但在实际应用中几乎没有用处。为了让管理员能够在紧急情况下从任何位置快速登录，要么需要暴露太多，要么需要过多的步骤来限制访问。

进入状态管理。通过状态管理，系统可以通过存储在集中式仓库中的状态定义文件指示开启 SSH 服务，开放一个用于 SSH 服务的随机端口，并将其锁定为管理员或管理员组的当前 IP 地址。版本控制系统将轻松追踪变更请求的时间、请求人以及变更的内容。在理论上，机制中还可以包含一个审批步骤。变更记录后，系统将授权指定管理员的访问权限。一旦他们完成操作，或者按照预定计划，状态管理系统将在完成所有文档记录后恢复变更，并完全关闭所有访问通道。增强安全性的潜力是巨大的。

但这仅仅是一个过渡步骤。通过完整的状态管理，我们理论上应该不再需要登录到系统。我们应该能够通过状态系统本身执行任何必要的管理步骤，或者更合适地，这些步骤应该由状态引擎自动执行，以确保保持适当的系统状态。

要完全实现这种无需登录的机制，我们必须将状态管理与上一章中提到的一些概念结合起来，例如远程日志收集和告警系统，这样即使是像容量规划这样的任务，也无需登录到单个系统。对于传统的系统管理员来说，这听起来通常像是亵渎神明，几乎不可能实现，但今天许多公司正是如此运作，并且通过事先做好的工作，这完全是可行的。

对于运行在办公室内物理硬件上的系统来说，这听起来可能像是过度防护，也许确实是。但对于运行在云服务器上的系统来说，这在许多情况下非常实用。对于一个经过充分测试、文档化且正常运行的系统来说，不应需要人工干预。手动管理既难以文档化，又很难重复操作，并且极容易出错。当然，人工干预可以作为最后的手段，但今天完全可以通过完全依赖重新部署来避免人工干预。

自动化成熟度模型为我们提供了一种从当前状态到希望达到的状态的路线图。当然，并不是每个组织都必须达到管理所有需求的状态管理水平。并不是每个环境都需要脚本化！大多数组织将继续受益于我们所处的任何成熟度水平。

我们将为成熟度模型的最终级别留出独立的部分。将我们所学到的内容应用到实际中，我们最终会得到…

# 基础设施即代码

从我们在这里讨论的概念出发，从另一个角度看，我们发现了*基础设施即代码*的概念。意味着我们可以编写代码或配置文件来表示我们的基础设施的整体。这是强大且解放性的。

很容易将基础设施即代码的概念与状态机的概念混淆，因为它们在许多情况下会有相当广泛的重叠。然而，它们之间存在着关键的区别。

基础设施即代码可以与状态机并行使用，但状态机不允许命令式的系统定义。基础设施即代码可以用来定义状态，也就是基础设施即代码的声明性方法，或者通过命令式的方法定义操作，而不是最终状态，使其更像传统的系统管理，关注的是手段而非结果，*即关注* *如何* 而非*目标*。

## 平台与系统

基础设施既指我们运行的系统，即操作系统容器，也指承载这些系统运行的平台，即虚拟机管理程序和物理机器。对于我们在本节讨论的内容，特别是像基础设施即代码这样的概念，其适用性是针对基础设施的两个方面的。

我们在系统级别应用的工具和技术可以与我们的平台级别一起工作，反之亦然。这意味着我们不仅可以依赖这些优秀的工具和技术来配置操作系统和应用程序，还可以利用它们来实际部署和构建虚拟机容器（包括完整虚拟化和容器化），无论是在云环境还是传统的非云环境中。

在这两个领域应用相同或相似的工具，意味着通过概念整合获得更大的整体能力，并呈现我们基础设施的更完整的图景。现代计算的一个关键好处是，从单纯将操作系统视为工作负载构建块，到将虚拟机管理程序也视为直接参与工作负载的角色。虚拟机管理程序不仅仅为操作系统提供一个容纳工作负载的空间，而是作为一个了解工作负载的工具，能够分配资源并作为工作负载组件的一部分。

例如，虚拟机监控程序或甚至虚拟机监控集群级别的管理将意识到它正在为应用服务器、代理、处理节点、存储、备份、数据库等提供工作负载容器。由于平台级别对工作负载有感知，它可以做出智能的资源配置决策，不仅知道需要什么样的资源，还知道将工作负载部署到哪些节点。如果我们有一个三节点的虚拟机监控集群并且我们配置了三个应用虚拟机，那么配置应该知道将这些虚拟机分布在不同节点上，每个节点一个虚拟机，以增加冗余；而且它还应该知道，对应的数据库也应该这样配置，确保数据库与应用服务器分布在相同节点上，并且配置这些应用服务器连接本地数据库实例，而不是随机的非本地数据库实例。从应用程序通过操作系统一直到平台都具备工作负载感知，这意味着更好的性能、更少的工作量和更强的数据保护。

通常，当我们进入基础设施即代码时，我们自然会开始合并系统和平台管理团队，因为将它们视为更大、更整体的基础设施愿景的两个部分是合乎逻辑的。

命令式基础设施即代码设计为我们带来了许多与状态机相似的前期好处，但初期设置工作量较小，而长期维护则需要更多的工作。因此，当基础设施即代码首次推出时，命令式系统被认为是常见的，但随着市场的发展，声明式（有状态）工具集和预构建的命令式结构的出现，转向声明式基础设施即代码是不可避免的。

当然，在底层，所有这样的系统最终都会是命令式的。任何声明式系统最终都会使用预定义的命令式步骤来达到所需的状态。因此，为了拥有一个供我们使用的声明式系统，我们或其他人必须编写命令式脚本和工具，这些脚本和工具可以将我们从多个不同的起点引导到同一个终点。即便设计了基础状态引擎，构建这些组件仍然需要大量的时间和测试。

这些脚本必须为每个任务存在。如果你想定义一个文件必须存在，那么我们需要在后台有工具来检查文件是否存在、判断如果文件不存在该怎么做、如何查找文件、如何复制文件、将文件放在哪里、文件复制失败时该怎么处理等等。这可能是最简单的使用案例，你可以轻松地想象，处理任何其他任务时它将变得多么复杂。即使是一个简单的声明式系统，也将由无数管理员可能永远不会知道的命令式脚本构成。或者它可能是管理员为了特定的需求而为特定系统构建的。这个概念是灵活的，但也很复杂。

理论上，我们可以拥有声明式的状态管理，而不需要像基础设施即代码那样深入。尽管这听起来有些奇怪，但实际上，那些刚开始使用状态系统的人常常几乎是手动进行的，尝试以接近命令式的方式发出有状态的指令，以通知系统所需的状态，而在此之前并没有将所有方面记录在代码中。

这些技术的工具通常会被部署，甚至被使用，但往往是非常不完整的。这可能是由于挫败感、缺乏规划、公司内部政治等等原因。因为完全在这种模式下工作非常密集，并且需要前期的充分规划，所以很难获得足够的时间和来自上层的支持来进行完整的实施。因此，我们经常看到这些工具被用来推出基本的、众所周知的功能，使用预构建的第三方脚本，但复杂的、通常是组织特有的配置仍然以传统方式进行。急于部署系统的压力通常会驱动这种行为。

这引出了关于基础设施即代码的真正关键最佳实践。最重要的是获得广泛的组织支持，并在工作负载投入生产之前，投资于适当的文档编写和代码的完整性。

就像我们在软件工程领域讨论的任何代码一样，我们的基础设施即代码也需要在使用之前进行测试。然而，测试系统管理代码通常比其他类型的应用程序更为简单。为新工作负载创建代码，然后从零开始部署该工作负载是相当直接的，直到结果完美为止，可以一遍又一遍地尝试。然后可以测试系统修改、故障和其他潜在场景，以确保系统能够在潜在的实际问题下良好响应。

这种测试的一个重要好处是，我们代码的功能就是从大致“什么都没有”的状态中创建基础设施。所以我们所要做的就是从一张白纸开始，如果一切正常工作，我们的基础设施就会自我创建，我们可以从那里进行测试。

即使我们无法像希望的那样创建一个完全自我创建、自我修复、自我配置和销毁的基础设施，我们至少可以使用这些工具和技术走一部分的路。从简单地从零开始构建基础设施，并不维护或退役它，这是一个很好的第一步。

### 基础设施即代码作为灾难恢复

我们在其他地方已经提到过这个概念，并将在下一章关于备份和灾难恢复中深入探讨，但它非常重要，以至于我们在讨论现代系统中灾难恢复的组成部分时，必须始终提及它。我们谈论基础设施即代码时，实际上是在讨论自动化创建以前不存在的系统。

这正是灾难恢复场景中所需要的。当我们的系统消失时，我们需要将其恢复。将我们的系统、它们的标准文件、它们的配置等，作为代码存储在一个能够轻松恢复的地方，或者更好的是，在正常的灾难期间完全不会丢失，这意味着我们已经准备好在任何我们想要的地方，以极短的时间建立一个新的系统。

因为这些类型的构建系统大部分时间用于为测试和生产部署构建工作负载，它们通常具有快速、高效、易用、易懂并且经过大量测试的优点。以这种方式构建的系统在测试中构建时与生产中的构建完全相同，在紧急灾难恢复时也是如此。我们在前期就做好了所有艰苦的工作，确保系统快速且可重复构建，这样当发生可怕的事情时，我们就不需要偏离既定的流程。

传统的灾后系统恢复需要通过一个独特的过程来构建系统，而这个过程与最初构建系统的过程完全不同。这种做法容易出错，原因有很多。这是一个很少经过良好测试或文档化的过程。通常是在没有充分规划、且承受很大压力的情况下进行的。这是经历这种情况的最糟糕时机，因为此时是对一切做到完美要求最大的时刻。

通过创建一个每次第一次、第二次、每次几乎瞬间并完全相同地自动构建自己的系统来避免这些问题，的确是一件大事。如果有什么能够证明自动化和基础设施即代码的好处，那就是这个。拥有系统能够快速且正确地恢复的信心是今天大多数公司所没有的。担心备份无法恢复，缺少正确配置工作负载的系统启动知识，许可证或系统细节没有文档记录，或是所需的软件包不容易获得，都是非常严重的问题。我们有一种现代的方法，能够让这些问题迎刃而解，而不是忽视它们并希望问题自行解决。

将我们的组织带到真正实现基础设施即代码的水平是一个巨大的步伐，但这就是未来。做到这一点的公司拥有更快的构建速度、更快速的灾难恢复、更好的安全性、更强的灵活性、更快的扩展速度，所有这些意味着它们有更大的机会赚取更多的利润。归根结底，作为系统管理员，我们的唯一工作就是以一种方式来做我们的工作，借此通过我们的努力，无论这种努力多么间接和难以衡量，都能提高组织的盈利能力。

现在我们知道了这些技术是什么，是时候谈谈那些实际存在的、已经准备好进行测试的工具，它们使得状态机和基础设施即代码成为可能。

# 现代自动化工具

所有这些强大的功能主要来自于过去十五到二十年内引入系统管理领域的现代工具。Linux 世界非常幸运，从一开始就处于这一运动的前沿。这自然源于 Linux 社区倾向于在创新上蓬勃发展并专注于创新，也因为基于命令行接口和简单文本文件进行配置和软件仓库的系统本质，使得自动化变得更加简单。Linux 的设计可能并非有意鼓励自动化，但几乎每一个主要方面，无论是系统实现还是生态系统的行为，都使它具备了理想的组合因素，几乎总是成为新的自动化工具和策略的领导者。

## 配置管理系统

新的工具不断涌现，技术也会随着时间而变化，因此在此列出一个权威的工具清单并不可能，但有一些重要工具已经成功地在行业中树立了自己的名声，值得作为调查适合你环境的工具的起点。目前，最流行的基础设施自动化工具（基础设施即代码）包括**Chef**、**Puppet**、**SaltStack**、**CFEngine**、**Ansible**和**Terraform**。其中最古老的工具**CFEngine**，早在 Linux 内核发布不到两年时就首次推出！

所有这些工具，通常被称为配置管理系统，共享一种共同的方式，即允许你编写代码和配置文件来定义你的基础设施环境，并且它们基于这些代码管理基础设施的自动化。它们中的大多数提供多种功能行为，比如可以选择以命令式或声明式的方式工作。大多数还提供从被管理系统拉取配置或从中央管理位置推送配置的选项。因此，你可以获得各种功能选项以及多种产品选项。

这些产品之间的最大区别实际上是用于记录你基础设施的编码风格，以及产品的成本、支持或授权方式。大多数这一领域的产品最初都是开放源代码，或者后来转为开放源代码。开放源代码是有道理的，因为这个领域发展得非常迅速，而管理工具也自然倾向于开源，因为它们主要是由最终用户或来自开源社区的人开发的，并且主要用于技术圈子里。封闭源代码的产品则更适合面向客户的产品，其中经理而非工程师在选择这些工具。大多数基础设施即代码工具的一个关键优势是它们是免费的、开源的，并且通常包含在 Linux 发行版中，因此工程和管理团队通常可以选择测试并将其部署到生产环境中，而无需管理层的批准，甚至管理层可能并不知道它们正在这样做。由于授权和使用场景，这与部署 OpenSSH 或其他日常系统管理中使用的标准组件没有太大区别。

当然，这里最简单的方法就是简单地了解一些工具，下载并安装一些，看看你喜欢什么。同时使用多个工具并不是一件坏事，大多数概念都可以从一个工具转移到另一个工具，即使脚本编写和文档编制的风格有所不同。许多这些工具都是跨平台的，虽然它们通常以 Linux 作为主要平台进行部署和管理，但其他平台，尤其是 BSD，以及 Windows、macOS 和其他平台，也可能被管理。考虑选择一个能够扩展以满足您组织未来所有需求的平台。如果您是一个异构商店，您可能希望投资您的技术知识到一个平台上，该平台可以跨领域管理所有内容，而不仅仅是管理 Linux，即使 Linux 是您的起点。

### 桌面就是服务器

把桌面视为服务器的一种形式可能会有点令人困惑，但从某种意义上说，它们确实是如此。它们只是一对一终端用户图形用户界面服务器，通常部署在桌面或家庭而不是数据中心。这只是一个微不足道的语义问题，直到我们开始试图理解桌面如何或不如何适应我们更大的支持战略。

但是，当我们考虑到桌面实际上只是服务器的一种特殊类别时，很快就会意识到，将它们归为通用管理也是有道理的。当然，例如，如果我们在桌面上使用 Linux 发行版，这一点比在使用 Windows 时更为明显，但事实仍然如此。如果我们可能会支持同时使用相同工具的 Linux 和 Windows 服务器，那么无论部署在哪种操作系统上，为桌面也采用同样的方法并不存在实际障碍。

传统上，但出于我所知的原因，服务器和桌面通常使用完全不同的工具集进行管理。我可以假设为什么会是这样。通常情况下，两个不同的团队提供此管理，并且每个团队都独立选择其自己的工具。服务器在一个世界中发展，而桌面支持在另一个世界中发展。供应商希望销售更多工具，并且迎合傲慢总是使销售变得容易。最有可能的因素是：服务器通常从命令行进行管理，而大多数桌面支持团队希望纯粹从 GUI 操作。

当我们退后一步看待桌面（和其他终端用户设备）就像它们是服务器时，很容易看出，管理、文档化和监控服务器的同样工具同样适用于桌面。没有真正的理由对待它们有所不同。当然，桌面支持团队始终需要能够远程查看，并可能与终端用户的图形桌面进行交互，以直接帮助解决终端用户的问题，但这与管理职责完全不同。

桌面计算机可以，甚至应该，使用与任何其他服务器相同的高级工具和技术进行管理，例如基础设施即代码和状态机。没错，当我们理解它们实际上是服务器时，适用于所有服务器的规则同样适用于桌面计算机。良好的语义使一切更容易理解。

事实上，甚至有充分的理由认为，终端用户设备是应用这些技术的最有价值领域，因为它们最可能需要重建、修改、共享配置文件、经历变化、被攻击或需要在没有与中央服务通信时进行管理。最后这一点尤其重要，因为那些保持现有状态并继续运行的状态机，可以为脱离网络的设备提供安全性和自我修复的特性，并能够独立执行策略。传统方式虽然也可以做到这一点，但实现起来更困难，且实现的可能性较小。

由于基础设施即代码系统的部署方式，这些系统更有可能在桌面或笔记本电脑脱离公司局域网时仍能继续运行，而传统的管理工具通常完全围绕局域网概念构建。由于终端用户设备传统上具有较高频率的在局域网中上下线或根本不连接局域网的情况，因此使用非局域网中心的工具，在终端用户空间通常比在数据中心空间更为重要。

在某种程度上，移动设备管理（MDM）通常被看作是尝试使工具更倾向于基础设施即代码和状态机的尝试，但这些工具呈现得更像传统工具，并通过更传统的渠道销售，专注于终端用户管理。我觉得这些工具之所以成功，是因为它们在很大程度上复制了该领域的技术和常见做法，一旦我们使用这些工具，我们通常会发现，除非我们在组织中缺乏这些能力，否则移动设备管理工具是没有意义的。

当然，任何新系统的许多优势都来自于约定，而非严格定义。基础设施即代码领域的最大约定之一，就是从以局域网为中心的管理转向网络无关的系统管理部署。通常，基础设施即代码系统的工具都会以某种公共形式托管，无论是在云、VPS，还是在机房托管，并且与可能存在的任何局域网隔离开来。

将托管管理基础设施置于局域网（LAN）之外，意味着我们可能会意外或随意建立的任何局域网中心的连接将不再可能，除非我们部署类似 VPN 这样的局域网扩展技术。这一做法自然促使我们远离部署仅在局域网内有效或利用局域网边界作为安全功能的技术。消除局域网边界使我们能够从一个平台透明地管理多个站点、移动用户甚至多个组织，只要这些系统使用互联网。传统系统在许多情况下会崩溃，并且有共同的安全漏洞，既因为它们容易崩溃或在利用上存在漏洞，也因为局域网中心的思维并不是良好的安全做法。

## 版本控制系统

我们在自动化主题中真正需要解决的另一个工具类别是代码仓库和版本控制系统。它们在技术上是两个独立的东西，但几乎总是密切相关。

从本质上讲，版本控制系统只是跟踪我们已拥有文档所做的更改，以便我们跟踪一些重要数据，例如谁做了更改，何时做了更改，以及在更改之前、当时和之后文档的样子。仅此一项就非常强大，但今天大多数实现此功能的系统还会用于分发代码和版本控制，使其可以被多人在多个地方使用。在能够做到这一点的同时，它也可以用来填充一个中央存储库，该存储库可以作为主存储位置，以便不需要将任何人的终端视为数据保护的关键位置。这个中央位置还可以作为备份和恢复的地方！

版本控制系统影响了许多现代文档系统，我们在早期的文档章节中介绍了两者，但在这个背景下，我们可以看看现实世界中的产品，例如 Google Docs、Microsoft Office Online 和 Zoho Docs，它们都呈现传统的文档文件类型或界面，但都提供文档的版本控制。为了编码和代码管理，这些系统的使用非常笨拙，但如果你只想迅速开始使用你已经部署的工具，它们也能应急。这些系统本质上是在复制传统代码版本控制系统的机制，并将其应用于电子表格和文字处理。

由于这些办公文档类型非常知名，因此几乎可以将它们视为标准（但它们并非如此），并认为代码版本控制系统是这些文档工具的代码特定修改版（事实上并非如此，它们早于文档工具）。这些系统通常（在我知道的每种情况中）处理标准文本文件，因此无论你使用的是像*vi*或*nano*这样的简单文本编辑器，还是使用像*Atom*或*MS Visual Studio Code*这样提供全面图形化编程环境并具有深度编辑功能的强大工具，都可以使用版本控制系统。一些高级环境实际上会将版本控制直接集成到应用程序中，以便你从一个地方自动化整个过程，让它看起来和感觉上更接近办公风格的工具！

在实际应用中，目前为止，两个版本控制协议已经崭露头角，几乎感觉市场上只剩下两个选择：*git*和*mercurial*。实际上，还有许多其他协议，但只有这两个值得一提。你可以自由地研究其他工具和协议，但请确保这两个协议出现在你可能有的任何研究简短名单中。它们都是免费的，功能类似，支持你今天通常期望的所有功能，包括中央仓库、用户机器上的副本、自动化部署、版本元数据等。

除了所使用的协议，今天版本控制系统的强大功能还来源于支持它们的在线仓库服务。这里有更多选择，而且你也可以自己运行本地服务。两大关键参与者是微软的 GitHub 和开源的 GitLab。两者都是托管服务，提供广泛的免费服务，GitLab 还提供免费的软件，可以让你在自己环境中托管（如果这是你的业务或技术需求）。这两项服务及类似的其他服务提供了中央 git 和 Mercurial 仓库位置、备份的集中位置、用于代码操作和管理的简单 Web 图形界面，以及围绕代码自动化的一系列流程、工具和服务。很多功能在系统管理环境中可能是多余的或无用的，但其中许多功能确实具有潜在用途。你当然可以在没有这些类型服务的情况下获得所需的好处，但这会更困难，几乎所有成功的环境都依赖于它们多年。这些服务对于系统管理的需求几乎总是免费的，别避免它们。作为托管服务，它们的使用也是*突破局限*，摆脱局域网思维的另一种方式。

在讨论工具时，并没有太多最佳实践或经验法则可以探讨。测试多种工具，跟踪市场上现有和即将推出的工具，评估适合你组织的工具，并深入学习所选择的工具，都是标准的良好做法。

一些经验法则：

+   管理工具几乎应该始终是开源的。这是一个安全至关重要的领域，而许可限制本身就可能带来安全风险。因此，在这个领域，开源比大多数领域更加重要。

+   以与网络无关的方式部署管理工具。这意味着将它们部署到互联网上，选择一个任何位于任何地方的机器都能合理访问的地方。除非绝对必要，避免依赖传统局域网网络连接或安全性。

**最佳实践**：将所有类型的代码进行版本控制，并保存在代码仓库中。

现在我们已经介绍了这些技术，并简要讨论了一些你可以用来启动调查的实际工具，这些工具可以帮助你在自己的环境中尝试部署并学习。

# 总结

在本章中，我们探讨了自动化为何如此重要。我们研究了应如何接近自动化并从哪里开始。我们讨论了成熟度建模。我们深入探讨了相当复杂的状态机和基础设施即代码等话题。最后，我们讨论了你今天就能下载并学习的实际工具，这些工具可以将你的编程水平提升到一个全新的高度。

在下一章中，我们将讨论系统管理中最重要且最常被回避的主题之一：备份与灾难恢复。如果有一件事是我们在管理中必须做对的，那就是我们的灾难避免或恢复能力，请不要跳过接下来的章节。
