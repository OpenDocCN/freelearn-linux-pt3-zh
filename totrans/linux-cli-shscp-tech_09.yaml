- en: '*Chapter 9*: An Introduction to Shell Scripting'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have come to the part that defines one of the things that Unix (or Linux)
    is known for – its scripting. When it comes to the so-called *Unix philosophy*,
    being able not only to use tools that the command line offers to you but also
    being able to create your own is an amazing ability, using shell tools that do
    one thing really well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Scripting is exactly that – the ability to create simple (and complex) tools
    that, at their core, are a set of commands performing a certain task. We need
    to clear one thing up before everything else – there is a distinction that some
    people make between programming and scripting. Strictly speaking, all scripting
    is programming, but not all programming is scripting. We are talking about disciplines
    that follow the exact same premises, logic, and ways of thinking, but at the same
    time, there are major differences between the two. When we talk about scripting,
    we are in reality creating files that are going to get *interpreted* when running,
    and that means that the shell (or some other *interpreter*) is going to read the
    file line by line and then run the commands. There is another option, and that
    is to create text files that are *compiled* before being run. Usually, this is
    faster than interpreting them, but at the same time, it both requires a few extra
    steps and is not as flexible as scripting.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to waste our time on anything connected to compiled applications;
    in this book, we'll be strictly dealing with scripts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first Bash shell script
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing basic commands – from simple to complex
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating shell script input, output, and errors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell script hygiene
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we''re going to use a Linux machine. We are using the same
    setup as in other chapters:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: A virtual machine with Linux installed, any distribution (in our case, it's
    going to be *Ubuntu 20.04*)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash – the default shell for every major distribution out there
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripts in this chapter, and in all the other chapters covering scripting, will
    probably run in any distribution using Bash. The power of scripting is exactly
    in this compatibility; if a machine runs Linux, it will run almost any script,
    and the only problems are going to come from what the script itself expects on
    the server.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first Bash shell script
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we do a simple `Hello World!` shell script, let's quickly talk about
    the shell itself and what does it do on a normal Linux machine. The simplest way
    of describing it is that the shell is the connection between the user (us) and
    the kernel (the part of the operating system in charge of everything). We have
    already talked about that before, but we need to make some points here to make
    it easier to explain some concepts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The shell is an application that usually displays a prompt and finds and runs
    whatever command we give it. This is called the **interactive shell** and is the
    most-used way of working in Linux. This is what all the **Command-Line Interface**
    (**CLI**) business is about – having an interface that enables us to execute whatever
    we need:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – A typical root shell'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B16269.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – A typical root shell
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, another mode of operation for a shell called **non-interactive
    mode**. This covers all the instances of the shell when it is not acting based
    on our commands from the command line but instead by reading a file (our script)
    line by line and executing the commands. Obviously, we cannot interact with the
    commands directly, so the mode is aptly called non-interactive.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that we can interact with the script during execution if we wish
    (and plan) to; the name refers only to the lack of direct interaction with the
    shell or having no CLI available. At the same time, this interaction limit means
    that we get to see our script run as fast as possible, at any time that we need
    it. Pair that with a myriad of tools at our disposal in a normal Linux system,
    and we have an extremely powerful feature available to finish our tasks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s quickly run a few commands and find out about our current shell:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What happened here? The first command we used was `ps`, and it gave us information
    about which shell is currently running or, to be precise, which shell is responsible
    for the current execution of commands that we issue. Using `$$` as the process
    number, we are asking the `ps` command to give us the number of the process assigned
    to our current shell. We performed a small trick here – `$$` is a Bash internal
    variable that gives us the running PID of a process.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The other command that we used is `echo`, and we used its `$SHELL` variable
    that automatically resolves to whatever the user's current shell is.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a big difference between these two commands. Depending on
    the circumstances, they can give us completely different results, since they are
    referring to completely different things. Let's explain – each user has their
    *assigned* shell, which is going to be executed when the user logs in. The result
    of the `echo` command is going to give you that, and the shell itself is defined
    in the `/etc/passwd` file, in the line that describes a particular user. So basically,
    the output of the command is going to provide the name of your default shell.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, every user can run any shell available on the system as a
    command, and automatically get this shell as their *current* shell. By that, we
    mean that this shell is going to process whatever the user is typing into the
    command line. This is important, since your script can be run from the command
    line using a different shell than the one you are supposed to be using, based
    on information in the `/etc/passwd` file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Your shell doesn't have to be `bash`. You can also choose any shell that is
    available on your system, or you can even install shells that are not currently
    available on the system you are using but are available as packages.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, when it comes to scripting, `bash` is the shell of choice,
    even for users running other shells, since `bash` will run on most, if not all,
    Linux machines.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's talk a little bit about the editors used for scripting.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: For chapters dealing with scripting in this book, we are going to use `vim`
    or `vi`; however, the script examples are going to be displayed as text without
    any color. We already covered a lot of editors in a separate chapter. Since the
    topic of text editors tends to be pretty divisive, and we are a bit pragmatic
    on this, our suggestion is to use whatever works for you.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Vim, JOE, nano, vi, Emacs, gedit, Sublime Text, Atom, Notepadqq, Visual Studio
    Code, and so on are what's available, but it's up to you to choose. For simple
    scripts, any editor will work, and more often than not, you will choose something
    that already exists on the system you are working on, just because you need to
    make a small change in a script.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing scripts on your own machine, you are probably going to go with
    something more complicated, simply because it makes working much easier. Vim is
    a good example, since it provides syntax highlighting and formatting for `bash`.
    Advanced editors are going to provide you with more functions, but our opinion
    is that you shouldn''t rely on too many bells and whistles, since this will make
    you dependent on a certain application that may or may not be available to you
    at all times:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – A script opened in Vim – note the color highlights and indentation'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_B16269.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – A script opened in Vim – note the color highlights and indentation
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: In the end, you will end up using two editors, one for developing your scripts
    and one on servers you are deploying your scripts to. Remember that you will inevitably
    have to do some debugging on the systems you are deploying your scripts to, so
    be prepared that some of your normal tools will be missing. Don't become dependent
    on them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create our first script and see what it is about the shell that we are
    so concerned with:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, what does the script actually do? It simply writes `Hello World!` to
    the standard output and exits. Although we have three lines in the script itself,
    only one of them does something, while the other two have different purposes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: What we are going to do is first unpack the meaning behind the first two lines
    and then pay attention to the `echo` command.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are not counting empty lines in the script, although your editor
    might. In scripting, empty lines are meaningless to the interpreter, so we are
    using them to make the script more human-readable and ignoring them when talking
    about the script – Bash does the same thing when executing the script.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: As a rule, if we use the `#` character anywhere in the script, an interpreter
    is going to treat everything that comes after that character *in the same* line
    as a comment. Our first two lines are comments, but the first line in the script
    is special – it defines the shell that is going to run commands in the scripts
    while also being a comment. This sequence is called a *shebang*. We need to explain
    that.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个规则，如果我们在脚本中使用`#`字符，解释器将把该字符之后的内容视为注释（*在同一行*）。我们的前两行是注释，但脚本的第一行是特殊的——它定义了执行脚本命令的
    shell，同时也是一行注释。这个序列被称为*shebang*。我们需要对此进行解释。
- en: Under Linux, scripting is not confined to using `bash` only or even using any
    other Bash-compatible shell. In your script, you can actually use whatever scripting
    language you want. Other than being Bash, it can be Python or Perl – you can use
    whatever language is available on the system and that you know how to write scripts
    in.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 下，脚本编写并不局限于使用`bash`或任何其他 Bash 兼容的 shell。在你的脚本中，实际上可以使用任何你想要的脚本语言。除了
    Bash，它还可以是 Python 或 Perl——你可以使用系统上可用的任何语言，只要你知道如何编写该语言的脚本。
- en: Normally a script is run by an interpreter. The interpreter is basically an
    application that is able to understand what's inside the file and then is able
    to run the commands that are inside the file, one by one. All the interpreters
    that we mentioned (Python, Bash, and Perl) use simple plaintext files as inputs,
    so there needs to be a way of telling what kind of script is in a particular file
    to let the system know how to run it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，脚本是由解释器执行的。解释器基本上是一个能够理解文件内容的应用程序，然后逐行执行文件中的命令。我们提到的所有解释器（Python、Bash 和 Perl）都使用简单的文本文件作为输入，因此需要一种方法来告诉系统该文件中是什么类型的脚本，从而让系统知道如何执行它。
- en: 'This can be done in two different ways – one way is to actually call the script
    directly using the right interpreter, such as the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过两种不同的方式来实现——一种方式是通过使用正确的解释器直接调用脚本，例如以下方式：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This simply makes sure we are using the right interpreter for the script; it
    doesn't make our script any more readable to the system or another user.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是确保我们为脚本使用了正确的解释器；它不会让系统或其他用户更容易理解我们的脚本。
- en: 'Now, consider another way of doing this. Let''s make the script executable,
    and then run it directly:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑另一种做法。让我们使脚本可执行，然后直接运行它：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The difference between these two is subtle but important, although the end result
    is going to be the same, since we are running the same script.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者之间的区别微妙但重要，尽管最终结果是相同的，因为我们运行的是相同的脚本。
- en: In the first example, we are explicitly telling the system to use a particular
    interpreter and run our script. In the second example, we are telling the system
    to run the script using whatever interpreter it needs, and this is when the first
    line of the script plays its crucial role. What the current shell is going to
    do is take the first line (the shebang) and try and find the interpreter that
    this line points to. If it finds it, the system is going to use this interpreter
    to run whatever is in the rest of the file. The end result is simple – if we follow
    the convention and put our interpreter as the first-line comment, the system is
    going to be able to run our script even if we don't mention it explicitly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们明确告诉系统使用特定的解释器来运行脚本。在第二个示例中，我们告诉系统使用它需要的解释器来运行脚本，这时脚本的第一行发挥了至关重要的作用。当前的
    shell 会拿到第一行（shebang），并尝试找到该行指向的解释器。如果找到了，系统将使用这个解释器来运行文件中的其余内容。最终结果很简单——如果我们遵循约定并将解释器放在第一行的注释中，系统就能运行我们的脚本，即使我们没有明确提到它。
- en: If the first line is something other than the name of the interpreter, our script
    will work only if we call it by explicitly using the name of the interpreter –
    if we try to run it directly, the system is going to throw an error.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一行是解释器的名称以外的内容，我们的脚本只有在明确使用解释器名称调用时才能运行——如果我们直接运行它，系统将抛出错误。
- en: How it works…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Linux does not use extensions as a way of identifying files, so a script can
    have any name that is possible on the filesystem; the extension does not have
    to be `.sh`. All this means is that in order to have our script work universally,
    we need to think about the right formatting for the first line.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 不使用扩展名来标识文件，因此脚本可以有任何符合文件系统规定的名称；扩展名不一定是`.sh`。这意味着，为了让我们的脚本能够普遍运行，我们需要考虑第一行的正确格式。
- en: The next line in the script is our comment, which identifies the name of the
    script and the version. Of course, any script will function without comments such
    as these or, in general, without any comments at all, but comments are extremely
    important in scripting. We will pay much more attention to the comments later
    in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的下一行是我们的注释，它标识了脚本的名称和版本。当然，任何脚本都可以没有这样的注释，或者一般来说，没有任何注释，但在脚本编写中，注释非常重要。我们稍后在本章中会更加关注注释。
- en: The third line is the one actually doing the work, and it simply displays the
    string to the standard output that is assigned to the script. Standard input,
    output, and error handling are things that we will also deal with a little bit
    later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行实际上是在工作的那一行，它简单地将分配给脚本的字符串显示到标准输出。标准输入、输出和错误处理是我们稍后也会稍微涉及的内容。
- en: This is our first script. We explained a lot in this part of the chapter, and
    we focused on everything other than the actual command that performs the script
    task, but we had to deal with a lot of other things.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个脚本。在这一章的这部分中，我们解释了很多内容，重点是除了执行脚本任务的实际命令之外的一切，但我们必须处理很多其他事情。
- en: There's more…
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'We are going to be dealing with scripts a lot more in this chapter and the
    next few, but we have links to get you started:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将会大量处理脚本，但我们有链接可以让您开始：
- en: 'The Bash manual – containing everything about the Bash shell: [https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash 手册 - 包含有关 Bash Shell 的所有信息：[https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html)
- en: 'Bash scripting cheat sheets: [https://devhints.io/bash](https://devhints.io/bash)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash 脚本速查表：[https://devhints.io/bash](https://devhints.io/bash)
- en: 'How to get a shell script to actually work: [https://linuxcommand.org/lc3_wss0010.php](https://linuxcommand.org/lc3_wss0010.php)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使一个 shell 脚本真正起作用：[https://linuxcommand.org/lc3_wss0010.php](https://linuxcommand.org/lc3_wss0010.php)
- en: Serializing basic commands – from simple to complex
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化基本命令 - 从简单到复杂
- en: Scripts are nothing more than a list of commands that are executed in a particular
    order. In its most basic structure, the order is completely linear without any
    decision making, loops, or conditional branching.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本只不过是按特定顺序执行的命令列表。在其最基本的结构中，顺序完全是线性的，没有任何决策、循环或条件分支。
- en: Commands are executed from first to last, from top to bottom, and from the start
    of the line to its end. Even if it sounds simple and not very useful, this way
    of creating scripts can have its uses, since it enables us to quickly run a predefined
    set of commands instead of repeating them from the command line. In other words,
    there are problems that require more than a single one-line command but are not
    complicated enough to require complex logic. This is not to devalue complex Bash
    scripting logic, as there's a lot of automation in IT that can be implemented
    by using Bash scripting.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 命令按照从上到下，从行首到行尾的顺序执行。即使听起来很简单并且不是很有用，但通过这种方式创建脚本也可以有其用处，因为它使我们能够快速运行一组预定义的命令，而不是从命令行重复输入它们。换句话说，有些问题需要超过一行命令，但不复杂到需要复杂的逻辑。这并不是贬低复杂的
    Bash 脚本逻辑，因为 IT 中有许多自动化任务可以通过使用 Bash 脚本来实现。
- en: 'Let''s now imagine a simple task like that, something that we will be using
    as a recurring example. We are going to create a simple backup script. Our task
    is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在想象一个简单的任务，比如我们将用作经常性示例的任务。我们将创建一个简单的备份脚本。我们的任务如下：
- en: Create a directory under `/opt/backup` that has today's date in its name.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/opt/backup`下创建一个以今天日期命名的目录。
- en: Copy all the files from the `/root` folder to this directory.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有文件从`/root`文件夹复制到此目录。
- en: Send an empty email to the `root` user that will simply say that a backup was
    done.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`root`用户发送一封空邮件，只说备份已完成。
- en: Add a line to a file named `donebackups.lst` in the `/root` folder that will
    have today's date in it.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`/root`文件夹中名为`donebackups.lst`的文件添加一行，其中包含今天的日期。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before we start – a disclaimer. This is a simple script that does not make too
    much sense for a number of reasons. The most important is that it is oblivious
    to the context it is running in. We quickly need to talk about this and the other
    problems first, and then we'll compose a script that solves this task.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: What do we mean by *context*? No matter which way we choose to run them, scripts
    are run by a user, in so-called user space, and they have some things that define
    their environment that we usually call context.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Context is the entire environment that is running the script and offers the
    following questions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Which user is running the script?
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What permissions does this script have?
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the script run from the command line as a tool or as a background task?
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What directory is the script running from?
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than these, there are usually several other things that can be relevant
    for the running script, and we will talk about those as we progress through this
    book.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Right now, we need to make clear that context is extremely important and that
    our scripts should never in any way or form take for granted any element of it.
    If we want our scripts to run correctly, we should presume nothing, and instead,
    we should check everything that we expect to be in a certain state.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: A script that is able to check and decide what the possible problems are in
    the environment that started it requires two things that we haven't yet talked
    about – controlling the flow of the script and interacting with the system. Right
    now, it is obvious that we still don't know how to do that.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Not being able to test things in a script means that, after all, we are going
    to presume a lot when creating this particular script. Be warned – this is usually
    the first thing that will lead us into problems.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Not thinking things through before we even type a single letter is usually the
    source of all problems; scripts are rarely so simple that they can be created
    without planning in advance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The main reason we are talking about this now is to try and put you in the right
    mindset when creating your scripts.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, how do you create a script? Before you even begin, you should do the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Define your tasks.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Research commands that you are going to use.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check permissions and things required for the individual commands to succeed.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try individual commands before using them in the script.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Think about things that you are presuming:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: If you are reading from or writing to any files, do you expect the files to
    be there, or do you need to create them?
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are referencing some file or directory, does it even exist, and do you
    have the right permissions?
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are you using some command that needs to be installed or configured beforehand?
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are you referencing files by an absolute or relative path?
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is only the tip of the iceberg that is usually called **sanity checks**,
    and the term *sanity*, in this case, refers to the state your script operates
    in. **Sane state** is what we say when we mean that everything is okay. Any deviation
    from this, or any error or problem that makes your script behave in an unexpected
    way, is a problem. This is why we need to think in advance. And that's also the
    reason why sanity-checked code can take much more effort than regular code that
    just does the basics.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: But believe us – these kinds of checks will help keep not only the sanity of
    the environment but also your own sanity intact when dealing with complex tasks.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Right now, we are bravely ignoring all this and dealing with the basics. For
    our backup script, we are going to presume that both the `/root` and `/opt` directories
    exist and are accessible to whatever user is running the script. In our particular
    case, this means that our script is going to work ONLY if run by a superuser,
    since this user is required to be able to access files under `/root`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Also, we are going to presume that an email system of some kind exists and is
    running on the local computer. We will also presume that the log file mentioned
    in the last step is writeable to our script.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: When running a script, you are making a lot of presumptions like these, and
    if any of them is not correct, your script is going to fail in some way. Your
    main job as a script creator is to prevent this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: What commands are we going to use?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Our first task is going to be to create a directory using today's date in its
    name. Here, we are going to presume that this directory does not exist, and we
    are going to create it no matter what. This is a significant deviation from the
    logic that we are going to use later – a command like this would usually check
    at least if the directory existed, and if the command itself succeeded. A script
    should fail in some graceful way if any of these are not `true`, or it should
    create directories that it needs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Before you say, *But wait – I can already do that; I know how to do testing
    in a single command line,* let's go back and talk again about how a script is
    run.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, we are trying to create something that has no logic to control
    the flow of the script so that commands are run one line at a time. We could try
    to cheat and do some checks in each individual line, but since we are not controlling
    the flow of the entire script, this can be even more dangerous than doing no checks
    at all.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: An interpreter is going to run all the commands no matter what, and even if
    we are checking for problems and spot them, we will end up running all the commands
    in the script. The right thing to do if something is not right is to control how
    the *script* behaves, not how a *single command* behaves. No matter how simple
    or complex a scripting task is, you should always think about the aforementioned
    context and what your script is doing to it. If something fails, your script needs
    to decide – is the failure something that can be dealt with, or do you need to
    abort the execution of the entire script?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: If you are aborting execution in the middle of the script, is there something
    you need to do before your script ends? Usually, when something that forces you
    to abort a task happens, you will have some way of notifying the system and the
    user that there was a problem. Sometimes, that will not be enough – your script
    will have to clean up after itself.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: It could be a matter of deleting some files, but it could be that you need to
    revert a change or even hundreds of changes that you made to the system. Every
    failure should be evaluated not only on its severity but also on how it affects
    the system and the state that your script created on that system.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After creating what is probably the world's largest disclaimer on why our script
    is so basic, let's get down to work.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Task by task, how are we going to solve this?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Creating a directory is simple; we are going to avoid using Bash shell expansion,
    and we will use the `date` system command. We are cheating a little bit here,
    since we are referencing the system environment, but the task is simply impossible
    to accomplish without it, and we are not relying on something that is inherent
    to Bash itself. Note here that this also demonstrates that there are usually multiple
    ways to do any one thing in scripting. The only difference is your creativity.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command will be something like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Please note that we are running this as the `root` user. Let''s quickly check
    what happened:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see that our directory has been created. Now, let''s deal with the copy
    operation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We were able to create a test file and copy it to our directory. Pay attention
    to the way we are referencing the directory that we are copying to – since we
    don't know *when* this script is going to run, there is no way for us to know
    what the current directory we need to copy to is.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: To avoid the hassle of having to read and parse directories, we are simply recreating
    the directory name the same way we did when we created the directory itself. There
    is a possible bug here – if, by some freak chance, your script is run exactly
    at midnight, it is possible that the part where the directory is created is run
    before midnight and the part we are using to copy the files is run after midnight.
    This can create an error, since the names will not match. The chance of this happening
    is slim, and we are not going to plan for it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: In a large script, things like this can and will create big problems if not
    addressed correctly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s do mail functionality:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The error here is important. We did it to show the importance of testing commands.
    In this case, we tried sending mail, and it made us realize that the command we
    are expecting to use is not installed by default.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: In order to run this script, we actually need to have the `mail` command installed.
    It is going to be there on servers that have mail service configured but is going
    to be absent on normal workstations. Since our backup script should work on any
    server, we need to solve that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Blindly installing a package using a package manager is usually safe; the system
    will either install the package or update it if it was already installed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to try that command again, and once again, it is going to
    fail:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We didn't actually fail, but when we invoked the first command, it required
    us to input some data. It was asking us for the `Cc` address, and we had to press
    *Ctrl* + *D* to finish the body of the email.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: This is another reason to test commands before using them in a script.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: After realizing that we need to do something to make this command run unattended
    and reading the manual, we can see it is a matter of simply providing no inputs
    by redirecting `/dev/null` into the command.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for the last command that we need to do, we implement the actual reporting
    of the backup:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember, we need to append to a file. Additionally, what we want to do is reference
    the file directly using an absolute path; after all, we have no idea where we
    will be when running this script.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, we have tried and tested all the commands. How does our script actually
    look? It''s not complicated:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let's run it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are a few things that need our attention. First, note that we have some
    output from the script that we didn't expect. This is normal and is a direct result
    of what we saw when we tested our command – some commands threw errors. The reason
    we are seeing this error is going to be explained in the next part of this chapter.
    Another thing that we need to note is that other than the errors, we have no other
    output. The only way we have to tell whether our script was successful or not
    will be by having the script itself report it – we need to check the mail and
    the file mentioned in the script to check whether everything is correct. That
    points us to another thing we are going to need – the logging. We are going to
    deal with logs and debugging in later chapters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's elaborate a little on how your script communicates with the environment.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Different operators for chaining in Bash: [https://www.thegeekdiary.com/6-bash-shell-command-line-chaining-operators-in-linux/](https://www.thegeekdiary.com/6-bash-shell-command-line-chaining-operators-in-linux/%0D)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Formatting dates in Bash: [https://www.cyberciti.biz/faq/linux-unix-formatting-dates-for-display/](https://www.cyberciti.biz/faq/linux-unix-formatting-dates-for-display/)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating shell script input, output, and errors
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are only a few things that are as pragmatic as the idea behind the concept
    of standard input and standard output on Linux.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Since the start of Unix, the idea of interoperability between different applications
    and tools installed on a system was one of the primary prerequisites that every
    script, tool, and application had to follow.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, if you wrote any tool on a system, you could count on three separate
    channels of communication to your surroundings. Based on the concept of ANSI C
    input/output streams called **standard output** and **standard input**, everything
    that runs in a shell can communicate in three ways – it can receive inputs from
    standard input, it can output results and information to standard output, and
    it can report errors to a separate output that is marked just for this task as
    **error output**.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Pair this idea with the concept that every tool should output text-only information
    with minimal formatting, and should be ready to accept text input if it is required,
    and you have a framework that is simple but amazingly robust and portable.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we create scripts, we are going to use these concepts a lot, in a myriad
    of different ways. Before we can do that, we need to make sure that we understand
    what inputs and outputs actually exist and are available to us, and what is the
    usual way of using them when scripting. After that, we will deal with some recommendations
    and how to conform to certain well-established best practices when it comes to
    user interaction.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Even before that, we need to define some things. Standard input, output, and
    error are just special cases of something called **file descriptors**. To simplify
    things a bit, we will not be spending too much time on what a file descriptor
    actually is; for the sake of this chapter, let's just say that it is a way of
    referencing an open file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Since in Linux everything is considered to be a file, we are basically just
    assigning a number to something we can write to, read from, or both read and write
    to, depending on the context. Obviously, our options on reading and writing depend
    on what the actual device referenced is.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: By default, your script will *open* communication with three *files* that it
    can use. Standard input is going to be connected to a keyboard; your script is
    going to accept information from the keyboard unless you change it to something
    else, such as some other file or output of another script or application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Standard output is, by default, set to the *console* or the screen you are running
    your script from. In some circumstances, we will also call a screen connected
    physically to your server a **console**, but that is not part of what we are dealing
    with right now. The reason we are mentioning this is to avoid unnecessary confusion.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: We cannot read from a screen or write to a keyboard, and this is why we are
    usually referring to them as *consoles*, which is a common name that more or less
    describes both the keyboard and the screen. There is a lot more to learn here,
    but for now, we are going to leave it at this.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To better explain these two things, you can do something simple – run a command
    called `cat` without any arguments. When executed like this, any command including
    `cat` will accept standard input and then output the result to the standard output.
    In this particular case, `cat` is going to do it one line at a time, since it
    waits for a line separator before it outputs information.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: In reality, this means that `cat` is going to echo whatever you type in, line
    by line, until you use *Ctrl* + *D* to signal a special character called **End
    of Transmission** (**EOT**), which tells the system that you decided to end typing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'This will end the execution of the application. In the screenshot, it looks
    like we typed each line twice; in fact, one is our input, and the other one is
    the output from the command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – cat – the simplest command to demonstrate standard input and
    output'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.3_B16269.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – cat – the simplest command to demonstrate standard input and output
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: There is also standard error, which also defaults to the screen but is a separate
    stream of data; if we output something to standard error, it will be displayed
    in a way that looks exactly the same as standard output, but that can be redirected
    if we need to.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The reason why there are two separate streams handling output is simple – we
    usually want to have some data as the result of our script, but we do not want
    errors to be part of it. In this case, we can redirect data into some file and
    redirect errors to the screen, or even to another file, and then deal with them
    later.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, remember when we mentioned that standard input, output, and error are
    special instances of a file descriptor? Bash can actually have nine file descriptors
    open at the same time, so there are many more things we can do when writing out
    something in our scripts. This is, however, rarely done, since almost everything
    can be accomplished by using only the default ones. For now, just remember the
    following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Standard input is file descriptor number `0`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard output is file descriptor number `1`.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard error is file descriptor number `2`.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do these numbers matter? By using some special characters in the command
    line and in our scripts, we can do a lot if we know only these three numbers.
    First, how do we stop a script displaying something on the screen, and how do
    we output it to a file instead? By simple use of the `>` character.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you will see a command line containing `1>` instead of just `>`.
    This is exactly the same as using a single `>` character, but it is sometimes
    written like this to make sure you understand that you are redirecting standard
    output.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: You are probably familiar with this form of redirection, since this is one of
    the first things you learn when dealing with the command line. An important thing
    to note is that we can redirect to a file in two different ways, depending on
    what do we want to do with the file if it already exists.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: By using `> filename`, we are going to redirect whatever the script outputted
    to the standard output to the file named `filename`. If the file does not exist,
    it will be created, and if the file exists, it will be *overwritten*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: By using just one more bracket, the `>> filename` redirection will be different
    in the way it treats files that already exist. If we redirect using this symbol,
    we are going to *append* data into an already existing file; data is going to
    go to the end of the file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Having mentioned `1>`, we need to deal with the way more popular `2>` symbol
    that represents standard error. When something wrong happens in our script, it
    is going to output it as an error. Usually, you will notice it if you just redirect
    the script output to a file; if you fail to mention `2>`, you will see that only
    errors are going to appear on the screen, while everything else is going to end
    up in the file.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: If we actually want to output the result of errors in a particular file, we
    can do that by using `2> errorfilename`, and the script will write its errors
    into a file called `errorfilename`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: There is also the possibility that we want to output everything into a single
    file, and there are two ways to do this. One is to do both redirections in one
    command line separately, using the same filename for both redirects. This has
    its own advantage of being easy to read when we are trying to understand where
    the outputs are going.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'The main disadvantage is that this redirection is probably the most used one
    when it comes to dealing with scripts, especially when we run them unattended,
    and this makes it *harder* to read in most environments. Of course, there is a
    simple solution to this – instead of using two separate redirects, we can use
    a single one by using the `&> filename`. In the Bash environment, this means that
    we want to redirect both standard error and output to the same file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Please note that this trick works only if redirecting both the output and errors
    to one file; if the output files are different, we need to specify them explicitly
    one by one.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: When we started discussing outputs, we said that there can be more than just
    the three predefined ones, and the way to handle them is logical. If we decide
    to redirect something outputted to file descriptor number `5`, the way to handle
    it in the command line would be to just redirect `5> filename`. This is something
    you will not see every day, but it can be extremely useful if you need to create
    more than one log file or need to create different outputs to different destinations
    from the same script. This approach is seldom used, since it is much easier to
    handle redirection directly from the script, and by using variables in the script,
    anyone debugging your scripts is going to have a much easier job.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we were dealing with redirection from *outside* of our scripts.
    It is time to move on to how to use this in our everyday work.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'The main thing that we are going to do using redirection is to log things.
    There are a couple of approaches here. One is to simply use the `echo` command
    in the script and then do the redirection for the whole script – for example,
    we can create a simple script that just prints four lines of text:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s name it `simpleecho.sh` and run it using Bash:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we are going to redirect it to a file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Okay, we can see that our file now contains output for the `echo` commands.
    For the sake of showing how errors work, we are going to insert an intentional
    error into our script:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we are going to do the same procedure again, first starting the script
    and then redirecting it to see what happened:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The main thing to take away here is that error output is always separate from
    standard output, so we are not going to see errors in our file unless we specifically
    redirect them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Everything up to this point was simple, since our script was using just standard
    output. Often, communicating with users is not so simple because we want to have
    our script to be able to provide some information on screen and to a special log
    file. Things are similar when working with unattended scripts; having the ability
    to redirect script output to a certain file is nice, but more often, we are going
    to make our script use a particular log file by itself, without the need for the
    user or the administrator to do any redirection when executing the script.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The process required to do this is remarkably simple – we can use the redirection
    at the command level to redirect our output to a file. There is only one thing
    you have to remember here. Redirection into a file is limited to a single command;
    if you redirect anything, the file is going to be closed as soon as the command
    finishes. This is important primarily because you will always need to append to
    a file; if you forget to do so, that file is going to get rewritten with new data,
    making it useless as a log. Since a log is usually used to track multiple executions
    of a script or service, you will almost universally append to files.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s now expand our initial script, adding a little bit of logging. What
    we are going to do is write separate logs that will contain information about
    the actions that the script took while running. We are going to write this information
    to a log file located in the directory that the script was invoked from. This
    means that our script will at any one time be able to use three separate channels
    for output; in addition to standard output and standard error, we are also using
    our log file. The big difference between log files and standard output is that
    our log is hardcoded, and there is no way of redirecting it to another file. Of
    course, a solution for this problem exists, but we are not going to spend too
    much time on it; we already said it is possible to use one of the other file descriptors
    and map output to it, forwarding the output to whatever stream we need later.
    This is seldom used, since it requires additional attention when running a script:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This approach gives us additional flexibility, since we do not have to forward
    standard output in order to have logs; our script already does that. This means
    that we can start the script either from the command line or as an unattended
    task and get the same results in the logs. Of course, we can always use redirection
    and make sure that every output is written and saved.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Standard input and output (in C): https://www.technologyuk.net/computing/software-development/computer-programming/c-programming/basic-io.shtml'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Standard input and output (in Bash, with examples): [https://tldp.org/LDP/abs/html/io-redirection.html](https://tldp.org/LDP/abs/html/io-redirection.html%0D)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell script hygiene
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Commenting is not just something you can do; it's an art by itself. In this
    part of the chapter, we are going to deal with comments in order to make your
    life easier when writing scripts, but the advice and best practices that are given
    here are easily used in any programming language that we can think of. Really
    understanding how to comment in a useful way is something that you're going to
    need to learn, since it will help anybody going to use your scripts after you
    are done writing them.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: So, what are comments? Possibly the easiest way to describe them is to say that
    they are documentation on what the script is intended to do, how the script works,
    and who has created the script, and they provide more information on technical
    details of the script, such as when it was created.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Commenting is something that you should automatically want to do. Nobody is
    perfect and nobody has a perfect memory. Comments are there to help you remember
    what you did inside some script and to provide anybody else with guidance on how
    the script works and what the different things are that they need to know if they
    need to change anything in the script.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: One more important point is that commenting is not the same as providing documentation.
    Sometimes, people are going to say that they don't need documentation because
    they already have comments in their code, but this is completely wrong. Unless
    you're talking about a script that has only 10 lines of code or so, comments are
    going to help you to understand what the script is doing without looking up the
    whole documentation, which saves you a lot of time.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, let's now talk about different types of comments. When writing code, there
    is always a part that involves commenting on individual procedures or parts of
    the script, expected input and output, data types, and data in general.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: In Bash, comments are universally started by the `#` sign. Bash does not recognize
    multiline comments, unlike some other programming languages. What this means is
    that we need to pay attention so that every line that contains a comment starts
    with `#`. The only exception of sorts is the first line in the script, which contains
    the interpreter that is going to run the script, but the interpreter continues
    working after that line, so we can say that every line that starts with `#` is
    actually a comment. The shell is going to ignore everything inside the comment
    or, to be more precise, it is going to completely ignore the lines that contain
    the comment. So, understand that the comments are written for you and for other
    people that are going to be dealing with your scripts. Try to make them easy to
    understand, precise, and avoid repeating what can actually be deduced from the
    command itself. For example, if you have a command that is echoing something,
    try not saying, *Okay, this command is going to echo…* whatever text you're trying
    to output to a user, but try to explain why. This is especially useful when commenting
    on cryptic output that contains a lot of variables.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: You can and should write comments in front of every block of code in your script,
    but you should also comment at the start and the end of the script.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with the beginning of the script. What should be the first comment?
    The first line should, of course, be the name of the interpreter, and after that,
    we usually give information about the script itself. Generally, the script should
    start with a comment that gives information on who wrote it, when, and if it is
    part of the project that is responsible for the script itself.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: This part should also state technical things such as licensing distribution,
    limitation on warranties, and who is and is not allowed to use the script.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Having done the header, we should also deal with the arguments and information
    on how a script should be run and what to expect in terms of input. If there is
    something special about the input, such as expected types, the number of arguments,
    or some prerequisites that need to exist or run before the script is running,
    they should be stated somewhere at the beginning of the script.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Now, we come to the functions. We are going to deal with the concept of functions
    later, but we do need to talk about how to comment on them, since this also applies
    to any other block of code. This is because functions are, by themselves, modular
    and written as a separate block of code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Sharing something separated inside a function gives us the opportunity to comment.
    We should use this part of the comments to describe what the function or the module
    does, what variables we are going to change and need, the arguments that your
    function is going to take, what the function is going to do, and what the output
    to the function is going to be. If we are dealing with some sort of nonstandard
    output – for example, if we are dealing with logging to a separate file – we should
    state that in the function header. We should also note all the return codes that
    the function outputs if it changes the exit status of the script.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: There are useful ways of using comments to create reminders for yourself and
    for others to inform what still needs to be done in a script, which are called
    **to do comments**. They are usually written in capital letters – **TODO**.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: We should also note that there is something called a `heredoc` notation that
    is sometimes used when we need to create large blocks of comments. This notation
    uses shell redirection in a very specific way so that it can provide the header
    and the footer for the comment block without using common signs. We're going to
    provide you with an example of this notation, since you will run into it when
    you analyze other people's scripts, but we're not going to use it in our scripts.
    The main reason for that is that it tends to make scripts less readable.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is a perfectly valid way of creating a comment:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, what do we actually comment?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with some general things:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: State clearly who wrote the script and when was it created.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version your script – if there are any changes, update the version so that you
    can track which script you are using on different computers.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain any complicated part of the code – things such as regular expressions,
    calling outside sources, and general references to anything outside of your script
    should be commented.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment on individual blocks of code.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly note all the old parts of code that you commented out and left in your
    script.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll talk a bit about all these points.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Clearly marking the script author and creation date is crucial. Your scripts
    are probably going to end up being maintained by people other than you. The worst
    thing that can happen to you when you open a script with a couple of hundred lines
    of code is not knowing who to talk to when something goes wrong. Some people think
    that they are going to avoid being constantly pestered by other admins by not
    signing the script, but this is simply wrong. You wrote that script; be proud
    of it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: After you mention the author, always note when the script was created. This
    helps people prioritize possible changes, especially to some outside resources
    that you may be using in the script itself. Also, write when the last change was
    made, since it is relevant information for everybody maintaining the script, including
    you.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: After mentioning changes, learn to version. Versioning is a way of keeping track
    of different changes that you make in a script and making sure you know which
    version you are using at any given moment. Versioning itself is a simple concept
    of using a scheme that enables you to track how your script progresses and what
    has changed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of ways this can be done, since there is no official standard
    on how to write down versions, although a lot of people tend to use semantic versioning
    (`https://semver.org/`). Usually, versions more or less strictly follow either
    changes in the source code or the time when a particular version was created.
    Both schemes have their merits, but when writing scripts, we think that tracking
    changes is a much better idea, since we can deduce very little from versions using
    dates as a reference.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Before we commit to any versioning scheme, we will quickly go over some examples.
    The way we handle versions in different software is directly related to the type
    of software we are dealing with and the number of changes between versions.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: General-purpose applications usually stick to a *normal* versioning scheme that
    has a structure using two numbers representing major and minor versions of the
    application. For example, we can have App v1.0, then App v1.1, then App v2.0,
    and so on. The first number represents major changes made to the applications;
    the second number usually represents minor changes or bug fixes. This is practically
    the norm for large applications on the market today.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In our scripts, we are going to use the same scheme, but we are going to implement
    semantic versioning, so a version will be `1.0.0` or `3.2.4`. The third number
    represents small changes and makes sense when the number of changes is small,
    but changes are significant. Note that some applications take this approach to
    the extreme, so you will inevitably run into things such as Version `2.1.2.1-33.PL2`.
    When dealing with scripts, this will just complicate your work, so don't do it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Another way of dealing with versions is by referencing time, as most operating
    systems do now. So, for example, there is Ubuntu 20.04 and 20.10, representing
    releases that came out in April and October of 2020 respectively. The reason for
    this is the enormous number of changes. Releasing a new version of an entire operating
    system each time something changes is simply impossible; you would need to release
    a new version practically every few hours.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: There is also a sequential numbering scheme that is usually paired with one
    of the two approaches we mentioned. Microsoft uses this versioning style, having
    major releases with names such as *Windows 10*, update releases named something
    such as 20.04 or 21H1 that represent the time of the release, and then using build
    versions to denote minor changes in the operating systems.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: All of these schemes have their good and bad sides, but whatever you choose,
    we have only one recommendation – stick to it. Don't mix different versioning
    schemes, since it will confuse people.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: While talking about versioning, we should also talk about change tracking. When
    creating *a new version* of a script, most of the time, you will make many changes
    to the script itself. It can be that you will fix bugs, or make your code quicker
    or more reliable. Some of these changes will have to be documented in some way
    other than by increasing the version number. This is important in order to remember
    what you did to the script. There are a couple of ways to do that. One is to keep
    track of all the changes in a separate file (usually, we use a `ChangeLog` file
    for that purpose). This makes your comments and the script itself much more legible,
    but now you have another file whose updates you need to care about. It also makes
    it easier for everyone else to read the code, as it gets developed and changed
    with each new version. Another way is to keep a list of all the changes in the
    script itself. A benefit of that is that you can quickly check what has changed,
    but your script now has extra text that you need to skip through. There is also
    a version that keeps the changes in line with the place where they were created,
    usually before the line of code that contains the changes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how all this looks in practice:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We are going to stop here, since we will cover this and a lot more in further
    chapters, learning as we go along.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Commenting in Bash – examples: https://git.savannah.gnu.org/cgit/bash.git/tree/examples'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Identifying files in Linux: [https://man7.org/linux/man-pages/man4/magic.4.html](https://man7.org/linux/man-pages/man4/magic.4.html)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
