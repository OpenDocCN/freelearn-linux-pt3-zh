- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Managing Storage Volumes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理存储卷
- en: When it comes to storage on our servers, it seems as though we can never get
    enough. While hard disks are growing in capacity every year, and high-capacity
    disks are cheaper than ever, our servers gobble up available space quickly. As
    administrators of servers, we always do our best to order servers with ample storage,
    but business needs evolve over time, and no matter how well we plan, a successful
    business will always need more. While managing your servers, you’ll likely find
    yourself adding additional storage at some point. But managing storage is more
    than just adding new disks every time your current one gets full. Planning ahead
    is also important, and technologies such as **Logical Volume Manager** (**LVM**)
    will make your job much easier as long as you start using it as early as you possibly
    can.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们服务器的存储管理中，似乎永远也不够用。虽然硬盘的容量每年都在增长，而且大容量硬盘比以往更便宜，但我们的服务器很快就会消耗掉所有可用空间。作为服务器管理员，我们总是尽力为服务器选择充足的存储空间，但随着业务需求的变化，无论我们如何规划，一个成功的企业始终会需要更多的存储空间。在管理服务器的过程中，你很可能会遇到需要增加额外存储的情况。但存储管理不仅仅是每次磁盘满了就添加新磁盘。提前规划同样重要，像**逻辑卷管理器**（**LVM**）这样的技术，只要尽早使用，就能极大简化你的工作。
- en: 'LVM itself is just one of the concepts we’ll go over in this chapter that will
    give you more flexibility with how you handle servers. I’ll also walk you through
    additional concepts that will no doubt come in handy as you manage storage and
    volumes on your server. More specifically, this discussion will include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: LVM本身就是本章将要讨论的一个概念，它能为你提供更多的灵活性来管理服务器。我还将带你了解其他一些概念，这些概念在你管理服务器存储和卷时无疑会派上用场。具体来说，本讨论将包括：
- en: Adding additional storage volumes to the filesystem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将额外的存储卷添加到文件系统
- en: Formatting and partitioning storage devices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化和分区存储设备
- en: Mounting and unmounting volumes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载和卸载存储卷
- en: Understanding the `/etc/fstab` file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`/etc/fstab`文件
- en: Backing up and restoring volumes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份和恢复存储卷
- en: Utilizing LVM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LVM
- en: One possible solution when your server is running out of disk space is to add
    an additional storage volume. So the first order of business for us, in this chapter,
    will be to look into how we can do exactly that.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的服务器磁盘空间不足时，一个可能的解决方案是添加一个额外的存储卷。因此，本章的首要任务是探讨我们如何实现这一目标。
- en: Adding additional storage volumes
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加额外的存储卷
- en: At some point or another, you’ll reach a situation where you’ll need to add
    additional storage to your server. On physical servers, we can add additional
    hard disks, and on virtual or cloud servers, we can add additional virtual disks.
    Either way, in order to take advantage of the extra storage, we’ll need to determine
    the name of the device, format it, and mount it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，你可能会遇到需要为服务器增加额外存储的情况。在物理服务器上，我们可以添加额外的硬盘；而在虚拟或云服务器上，我们可以添加额外的虚拟磁盘。无论是哪种情况，为了充分利用额外的存储，我们需要确定设备名称、格式化它并挂载。
- en: 'In the case of LVM (which we’ll discuss later in this chapter), we’ll have
    the opportunity to expand an existing volume, often without a server reboot being
    necessary. There’s an overall process to follow when adding a new device, though.
    When adding additional storage to your system, you should ask yourself the following
    questions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在LVM的案例中（我们将在本章后面讨论），我们有机会扩展现有的卷，通常不需要重新启动服务器。但在添加新设备时，仍然有一个整体流程需要遵循。当你向系统添加额外存储时，应该问自己以下问题：
- en: '**How much storage do you need?** If you’re adding a virtual disk, you can
    usually make it any size you want, as long as you have enough space remaining
    in the pool of your hypervisor.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**你需要多少存储空间？** 如果你要添加一个虚拟磁盘，通常可以根据需要设定其大小，只要你在虚拟化平台的存储池中有足够的剩余空间。'
- en: '**After you attached it, what device name did it receive?** When a new disk
    is attached to our server, it will be detected by the system and given a device
    name. In most cases, the naming convention of `/dev/sda`, `/dev/sdb`, and so on
    will be used. In other cases (such as virtual disks), this will be different,
    such as `/dev/vda`, `/dev/xda`, and possibly others. The naming scheme usually
    ends with a letter, incrementing to the next letter with each additional disk.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**它连接后，设备名称是什么？** 当新磁盘连接到服务器时，系统会检测到并分配一个设备名称。在大多数情况下，会使用 `/dev/sda`、`/dev/sdb`
    等命名方式。在其他情况下（如虚拟磁盘），命名可能不同，如 `/dev/vda`、`/dev/xda`，甚至其他名称。命名方案通常以字母结尾，每增加一个磁盘，字母就会递增。'
- en: '**How do you want the storage device formatted?** At the time of writing, the
    ext4 filesystem is the most common. However, for different workloads, you may
    consider other options (such as XFS). When in doubt, use ext4, but definitely
    read up on the other options to see if they may benefit your use case. ZFS is
    another option that you can consider, though compared to the other choices, it’s
    relatively new. We’ll discuss formatting in the next section, *Formatting and
    partitioning storage devices*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**你希望如何格式化存储设备？** 在撰写本文时，ext4 文件系统是最常见的选择。然而，对于不同的工作负载，你可能需要考虑其他选项（例如 XFS）。如果不确定，使用
    ext4 是比较稳妥的选择，但一定要了解其他选项，看看它们是否能带来对你使用案例的好处。ZFS 也是一个可以考虑的选项，尽管与其他选择相比，它相对较新。我们将在下一节中讨论格式化内容，*格式化和分区存储设备*。'
- en: It may be common knowledge to you by now, but the word filesystem is a term
    that can have multiple meanings on a Linux system depending on its context and
    may confuse newcomers. Linux administrators like us will most often use the term
    filesystem to discuss the file and directory structure of a typical Linux system.
    However, the term is also used to describe how a disk is formatted for use with
    the distribution (for example, the ext4 filesystem). In this chapter, we’ll be
    primarily focusing on the latter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对你来说这可能是常识，但文件系统这个词在 Linux 系统中有多重含义，具体取决于其上下文，这可能会让新手感到困惑。像我们这样的 Linux 管理员通常会用文件系统一词来讨论典型
    Linux 系统中的文件和目录结构。然而，这个词也被用来描述如何格式化硬盘以供该发行版使用（例如，ext4 文件系统）。在本章中，我们将主要关注后者。
- en: '**Where do you want it mounted?** The new disk needs to be accessible to the
    system and possibly users, so you would want to mount (attach) it to a directory
    on your filesystem where your users or your application will be able to use it.
    In the case of LVM, which we also discuss in this chapter, you’re probably going
    to want to attach it to an existing storage group. You can come up with your own
    directory for use with the new volume, but I’ll discuss a few common locations
    later on in this chapter. We’ll go over the process of mounting and unmounting
    in the *Mounting and unmounting volumes* section.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**你希望它挂载在哪里？** 新硬盘需要对系统和可能的用户可访问，因此你需要将其挂载（附加）到文件系统中的某个目录，以便你的用户或应用程序能够使用它。在本章中我们还将讨论的
    LVM（逻辑卷管理），你可能希望将它附加到现有的存储组。你可以为新卷创建自己的目录，但我将在本章稍后讨论一些常见的位置。我们将在 *挂载和卸载卷* 部分中介绍挂载和卸载的过程。'
- en: Let’s consider the answers to the first two questions. With regard to how much
    space you should add, you would want to research the needs of your application
    or organization and find a reasonable amount. In the case of physical disks, you
    don’t really get a choice beyond deciding which disk to purchase. In the case
    of virtual disks, you’re able to be more frugal, as you can add a small disk to
    meet your needs (you can always add more later).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下前两个问题的答案。关于你应该增加多少空间，你需要研究你的应用程序或组织的需求，并找到一个合理的数量。对于物理硬盘，你基本上没有选择，除了决定购买哪种硬盘。对于虚拟硬盘，你可以更加节省，因为你可以添加一个小的硬盘来满足你的需求（以后可以随时增加更多）。
- en: The main benefit of LVM with virtual disks is being able to grow a filesystem
    without a server reboot. For example, you can start with a 30 GB volume and then
    expand it in increments of 10 GB by adding additional 10 GB virtual disks. This
    method is certainly better than adding a 200 GB volume all at once when you’re
    not completely sure all that space will ever be used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: LVM 在虚拟硬盘上的主要优势是能够在不重启服务器的情况下扩展文件系统。例如，你可以从一个 30 GB 的卷开始，然后通过增加额外的 10 GB 虚拟硬盘来按
    10 GB 的增量进行扩展。这种方法显然比一次性添加一个 200 GB 的卷要好，尤其是当你不确定这些空间是否都会被用到时。
- en: LVM can also be used on physical servers as well, but would most likely require
    a reboot anyway since you’d have to open the case and physically attach a hard
    drive. Some servers allow for hot-plugging, which gives you the ability to add/remove
    physical hard drives without powering off the server first, which is a great benefit
    to have.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: LVM 也可以在物理服务器上使用，但通常还是需要重启，因为你需要打开机箱并物理连接硬盘。一些服务器支持热插拔，可以让你在不关闭服务器的情况下添加或移除物理硬盘，这是一个很大的优势。
- en: 'Next, the device name can be found with the `fdisk -l` command. The `fdisk`
    command is normally used for creating and deleting partitions, but it will also
    allow us to determine which device name our new disk received. Using the `fdisk
    -l` command will give you the info, but you’ll need to run it as `root` or with
    `sudo`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，可以使用`fdisk -l`命令找到设备名称。`fdisk`命令通常用于创建和删除分区，但它也能帮助我们确定新磁盘获得的设备名称。使用`fdisk
    -l`命令将显示相关信息，但你需要以`root`身份运行，或者使用`sudo`：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Executing this command produces output similar to the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令会产生类似于以下的输出：
- en: '![](img/B18425_09_01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_09_01.png)'
- en: 'Figure 9.1: Output of the fdisk -l command'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：`fdisk -l`命令的输出
- en: I always recommend running `fdisk -l` *before and after* attaching a new device.
    That way, it will be more obvious which device name represents the new device.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是建议在连接新设备之前和之后都运行`fdisk -l`。这样，哪个设备名称代表新设备就会更加明显。
- en: 'Another trick is to use the following command, with which the output will update
    automatically as you add the disk:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个技巧是使用以下命令，该命令会随着你添加磁盘而自动更新输出：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Just start the command, attach the disk, and watch the output. When done, press
    *Ctrl* + *c* on your keyboard to return to the prompt.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 只需启动命令，连接磁盘，观察输出。当完成时，按*Ctrl* + *c*键返回命令提示符。
- en: 'You can also find the device name of your new disk with the `lsblk` command.
    The benefit of `lsblk` is that you don’t need `root` privileges, and the information
    it returns is simplified:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过`lsblk`命令找到新磁盘的设备名称。`lsblk`的好处是你不需要`root`权限，且它返回的信息是简化版的：
- en: '![](img/B18425_09_02.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_09_02.png)'
- en: 'Figure 9.2: Output of the lsblk command'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：`lsblk`命令的输出
- en: On a typical server, the first disk (basically, the one that you installed Ubuntu
    Server on) will be given a device name of `/dev/sda` while additional disks will
    be given the next available name, such as `/dev/sdb`, `/dev/sdc`, and so on (depending
    on the type of hard disk you have). Nowadays, **Non-Volatile Memory Express**
    (**NVMe**) hard drives are becoming increasingly common, so you may see a device
    name similar to `/dev/nvme0n1`. You’ll also need to know the partition number.
    Device names for disks will also have numbers at the end, representing individual
    partitions. For example, the first partition of `/dev/sda` will be given `/dev/sda1`,
    while the second partition of `/dev/sdc` will be given `/dev/sdc2`. These numbers
    increment and are often easy to predict. As I mentioned before, your device naming
    convention may vary from server to server, especially if you’re using a **Redundant
    Array of Independent Disks** (**RAID**) controller or a virtualization host such
    as VMware or XenServer. If you haven’t created a partition on your new disk yet,
    you will not see any partition numbers at the end of their names.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在一台典型的服务器上，第一个磁盘（基本上就是你安装了Ubuntu Server的磁盘）将被命名为`/dev/sda`，而额外的磁盘将被分配下一个可用的名称，例如`/dev/sdb`、`/dev/sdc`，以此类推（具体取决于你使用的硬盘类型）。如今，**非易失性内存快速接口**（**NVMe**）硬盘越来越常见，因此你可能会看到类似`/dev/nvme0n1`的设备名称。你还需要知道分区编号。磁盘的设备名称后面会有数字，表示单独的分区。例如，`/dev/sda`的第一个分区将被命名为`/dev/sda1`，而`/dev/sdc`的第二个分区将被命名为`/dev/sdc2`。这些数字是递增的，通常很容易预测。正如我之前提到的，你的设备命名规则可能会因服务器而异，尤其是当你使用**独立磁盘冗余阵列**（**RAID**）控制器或虚拟化主机（如VMware或XenServer）时。如果你尚未在新磁盘上创建分区，你将不会看到名称末尾的任何分区编号。
- en: Now that you’ve added and named an additional storage volume, we can proceed
    through the process of setting it up. We need to decide where we’re going to mount
    it, and what purpose it will serve. But before we can even mount the storage device
    in the first place, we need to create at least one partition on it and then format
    it. We’ll take care of both in the next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经添加并命名了一个额外的存储卷，我们可以继续进行设置过程。我们需要决定将其挂载到哪里，以及它的用途是什么。但在我们能够挂载存储设备之前，我们需要先在它上面创建至少一个分区，然后再对其进行格式化。我们将在下一节中处理这两个步骤。
- en: Formatting and partitioning storage devices
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化和分区存储设备
- en: 'Once you’ve installed a physical or virtual disk, you’re well on your way to
    benefiting from additional storage. But in order to utilize a disk, it must first
    be formatted. In order to ensure we’re formatting the correct disk, we need to
    find the name the device was given. As you already know from the previous section,
    there’s a specific naming scheme that is used in Linux distributions to name disks.
    So you should already know the device name of the new disk. As explained earlier,
    you can use the `sudo fdisk -l` command to see details regarding the storage devices
    attached to your server:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了物理磁盘或虚拟磁盘，你就能充分利用额外的存储空间。但为了使用磁盘，必须先对其进行格式化。为了确保我们格式化的是正确的磁盘，我们需要找到该设备的名称。正如你从上一节中了解到的，Linux
    发行版使用特定的命名规则来命名磁盘。所以你应该已经知道新磁盘的设备名称。正如前面所解释的，你可以使用 `sudo fdisk -l` 命令来查看服务器上连接的存储设备的详细信息：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will produce an output that looks similar to the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似以下内容的输出：
- en: '![](img/B18425_09_03.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_09_03.png)'
- en: 'Figure 9.3: Using fdisk -l to view a list of storage devices on the server'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：使用 fdisk -l 查看服务器上的存储设备列表
- en: In my case, the device `/dev/sdb` is brand-new—I just added it to the server.
    Since I’m using a virtual machine for the examples in this chapter, the new disk
    shows a model of `QEMU HARDDISK`. It doesn’t have any partitions currently; notice
    how we see a few lines above it referring to a different hard disk and partitions,
    such as `/dev/sda3`. We don’t have any lines like that in the description underneath
    for `/dev/sdb`. If we did have one or more partitions on that device, they would
    show up in the output.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，设备 `/dev/sdb` 是全新的——我刚刚将其添加到服务器中。由于我在本章中使用的是虚拟机示例，新的磁盘显示为 `QEMU HARDDISK`
    型号。目前它没有任何分区；注意我们在它上方看到了一些与不同硬盘和分区相关的行，比如 `/dev/sda3`。而在 `/dev/sdb` 的描述下方没有类似的行。如果我们在该设备上有一个或多个分区，它们将会显示在输出中。
- en: At this point, we know which storage device is new—there’s no doubt that in
    the preceding example, it’s `/dev/sdb`. We always need to make sure we don’t attempt
    to format or repartition the wrong device, or we may lose data. In this case,
    we can see `/dev/sdb` has no partitions (and this volume wasn’t present before
    I added it), so it’s obvious which disk we’ll want to work with. Now we can create
    one or more partitions on it, to continue preparing it for use.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经知道哪个存储设备是新的——毫无疑问，在上一个示例中，它是 `/dev/sdb`。我们始终需要确保不要尝试格式化或重新分区错误的设备，否则可能会丢失数据。在这种情况下，我们可以看到
    `/dev/sdb` 没有分区（而且在我添加它之前，这个卷并不存在），所以很明显我们要操作的磁盘是哪一个。现在我们可以在其上创建一个或多个分区，继续准备它以供使用。
- en: Creating a partition
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建分区
- en: 'To create an actual partition on this device, we’ll use the `fdisk` command
    with `sudo`, using the device’s name as an option. In my case, I would execute
    the following to work with disk `/dev/sdb`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要在该设备上创建实际的分区，我们将使用带 `sudo` 的 `fdisk` 命令，并将设备的名称作为选项。在我的例子中，我将执行以下操作来处理磁盘 `/dev/sdb`：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that I didn’t include a partition number here, as `fdisk` works with the
    disk directly (and we also have yet to create any partitions). In this section,
    I’m assuming you have a disk that has yet to be partitioned or one you won’t mind
    wiping. When executed correctly, `fdisk` will show you an introductory message
    and give you a prompt:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在这里没有包括分区编号，因为 `fdisk` 是直接与磁盘交互的（而且我们还没有创建任何分区）。在本节中，我假设你有一个尚未分区的磁盘，或者你愿意清除的磁盘。当正确执行时，`fdisk`
    会显示一条介绍信息并给出一个提示符：
- en: '![](img/B18425_09_04.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_09_04.png)'
- en: 'Figure 9.4: Main prompt of fdisk'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：fdisk 的主提示符
- en: At this point, you can press *m* on your keyboard for a menu of possible commands
    you can execute. In this example, I’ll walk you through the commands required
    to set up a new disk for the first time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可以按下键盘上的 *m* 键来查看可以执行的命令菜单。在这个示例中，我将带你完成第一次设置新磁盘所需的命令。
- en: I’m sure it goes without saying, but be aware of the destructive possibilities
    of `fdisk`. If you run `fdisk` against the wrong drive, irrecoverable data loss
    may result. It’s common for an administrator to memorize utilities such as `fdisk`
    to the point where using it becomes muscle memory. But always take the time to
    ensure that you’re running such commands against the appropriate disk.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信这不言而喻，但请注意 `fdisk` 可能带来的破坏性后果。如果你在错误的磁盘上运行 `fdisk`，可能会导致无法恢复的数据丢失。管理员通常会将像
    `fdisk` 这样的工具熟记到一定程度，以至于它们的使用变成了肌肉记忆。但总是要花时间确保你正在对正确的磁盘运行这些命令。
- en: Before we continue with creating a new partition, some discussion is required
    with regard to the **Master Boot Record** (**MBR**) and **GUID Partition Table**
    (**GPT**) partition tables. When creating a partition table on a new disk, you’ll
    have the option to set it up to use an MBR or GPT partition table. GPT is the
    newer standard, while MBR has been around for quite some time and is probably
    what you’ve been using if you’ve been working with servers for a long time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续创建新分区之前，需要对**主引导记录**（**MBR**）和**GUID分区表**（**GPT**）分区表进行一些讨论。在新硬盘上创建分区表时，你可以选择使用MBR或GPT分区表。GPT是较新的标准，而MBR已经存在很长时间了，如果你长时间从事服务器工作，可能一直在使用MBR。
- en: You may see MBR referred to as DOS when referring to the older partition structure.
    As you may already know, **DOS** is short for **Disk Operating System**, but we’re
    not referencing that operating system here in this chapter; we’re referencing
    the partitioning structure that IBM came up with decades ago. For example, while
    using `fdisk`, it will refer to the MBR partition structure as DOS. In this chapter,
    we’ll use MBR to refer to the older style whenever possible to avoid confusion.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到MBR被称为DOS，这是指较旧的分区结构。正如你可能已经知道的，**DOS**是**磁盘操作系统**（**Disk Operating System**）的缩写，但在本章节中我们并不是在指这个操作系统，而是指IBM几十年前提出的分区结构。例如，在使用`fdisk`时，它会将MBR分区结构称为DOS。在本章节中，我们会尽可能使用MBR来指代较旧的分区样式，以避免混淆。
- en: With MBR partition tables, you have some limitations to consider. First, MBR
    only allows you to create up to four primary partitions. In addition, it also
    limits you to using somewhere around 2 TB of a disk. If the capacity of your disk
    is 2 TB or less, this won’t be an issue. However, disks larger than 2 TB are becoming
    more and more common.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MBR分区表时，你需要考虑一些限制。首先，MBR只允许你创建最多四个主分区。此外，它还将你限制在大约2 TB的磁盘容量内。如果你的磁盘容量是2 TB或更小，这不会成为问题。然而，大于2
    TB的硬盘越来越常见。
- en: On the other hand, GPT doesn’t have a 2 TB restriction, so if you have a very
    large disk, the decision between MBR and GPT has pretty much been made for you.
    In addition, GPT doesn’t have a restriction of up to four primary partitions,
    as `fdisk` with a GPT partition table will allow you to create up to 128 of them.
    It’s certainly no wonder GPT is fast becoming the new standard! It’s only a matter
    of time before GPT becomes the default, so unless you have a good reason not to,
    I recommend using it if you have a choice.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，GPT没有2 TB的限制，所以如果你有一个非常大的硬盘，那么MBR和GPT之间的选择几乎已经为你决定好了。此外，GPT没有最多四个主分区的限制，因为使用GPT分区表的`fdisk`可以创建最多128个主分区。毫无疑问，GPT正迅速成为新的标准！GPT成为默认分区表只是时间问题，所以除非你有充分的理由，否则我推荐如果有选择的话使用GPT。
- en: When you first enter the `fdisk` prompt, you can press *o* to create an MBR-style
    partition layout, or you can press *g* to create the partition layout with the
    newer GPT style. As I’ve mentioned before, this is a potentially destructive process,
    so make sure you’re using this utility against the correct drive! Make sure you
    press the associated key for your chosen partition style and then press *Enter*,
    and then we can proceed. Once you press *g* or *o*, you should see a confirmation
    that you have created a new partition table.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次进入`fdisk`提示符时，你可以按*o*来创建MBR风格的分区布局，或者按*g*来创建更新的GPT风格的分区布局。正如我之前提到的，这是一个可能破坏性很大的过程，所以请确保你正在对正确的硬盘使用这个工具！确保按下与你选择的分区风格相对应的键，然后按*Enter*，这样我们就可以继续了。一旦你按下*g*或*o*，你应该会看到一条确认信息，表示你已创建了一个新的分区表。
- en: Continuing on, after you’ve made your choice and created either an MBR or GPT
    partition table, we’re ready to proceed. Next, at the `fdisk` prompt, type *n*
    to tell `fdisk` that you would like to create a new partition. Then, you’ll be
    asked if you would like to create a primary or extended partition (if you’ve opted
    for MBR). With MBR, you would want to choose primary for the first partition,
    and then you can use extended for creating additional partitions. If you’ve opted
    for GPT, this prompt won’t appear, as it will create your partition as primary
    no matter what.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在你做出选择并创建了MBR或GPT分区表之后，我们就可以继续了。然后，在`fdisk`提示符下，输入*n*，告诉`fdisk`你想要创建一个新分区。接着，你会被问到是否想要创建主分区或扩展分区（如果你选择了MBR）。使用MBR时，你会想选择主分区作为第一个分区，然后可以使用扩展分区来创建更多的分区。如果你选择了GPT，这个提示不会出现，因为它会将你的分区创建为主分区。
- en: The next prompt that will come up will ask you for the partition number, defaulting
    to the next available number. Press *Enter* to accept the default. Afterward,
    you’ll be asked for the first sector of the partition to use (press *Enter* to
    accept the default of `2,048`), and then the next prompt will ask you for the
    last sector to use. If you press *Enter* to accept the default last sector, your
    partition will consist of all the free space that was remaining on the device.
    If you’d like to create multiple partitions, don’t accept the default at the last
    sector prompt. Instead, you can clarify the size of your new partition by typing
    the *+* symbol followed by the number of mebibytes or gibibytes to use, and then
    `M` for mebibytes or `G` for gibibytes. For example, you can enter `+20G` here
    to create a partition of 20 GiB. Note that there is no space after the `+` symbol,
    nor is there a space between `20` and `G`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来出现的提示会要求你输入分区号，默认选择下一个可用的编号。按*Enter*接受默认值。随后，你将被要求输入分区的第一个扇区（按*Enter*接受默认值`2,048`），然后下一个提示会询问你要使用的最后一个扇区。如果你按*Enter*接受默认的最后一个扇区，分区将包含设备上剩余的所有空闲空间。如果你希望创建多个分区，可以在最后一个扇区提示时不接受默认值。你可以通过输入*+*符号后跟要使用的兆字节或吉比字节的数字，并且在数字后加上`M`表示兆字节，或者加上`G`表示吉比字节，来明确新分区的大小。例如，你可以输入`+20G`来创建一个20
    GiB的分区。注意，`+`符号后面没有空格，`20`和`G`之间也没有空格。
- en: 'At this point, you’ll be returned to the `fdisk` prompt. To save your changes
    and exit `fdisk`, press *w* and then *Enter*. Now if you run the `fdisk -l` command
    as `root`, you should see the new partition you created. Here is some example
    output from the `fdisk` command from one of my servers, to give you an idea of
    what the entire process looks like:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你将返回到`fdisk`提示符。要保存更改并退出`fdisk`，按下*w*然后按*Enter*。现在，如果你以`root`身份运行`fdisk -l`命令，你应该会看到你创建的新分区。以下是我某台服务器上`fdisk`命令的示例输出，给你一个完整过程的概念：
- en: '![](img/B18425_09_05.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_09_05.png)'
- en: 'Figure 9.5: Example run of the fdisk command'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：`fdisk`命令的示例运行
- en: If you’ve made a mistake or you want to redo your partition layout, you can
    do so by entering the `fdisk` prompt again and then pressing *g* to create a new
    GPT layout or *o* to create a new MBR layout. Then, continue through the steps
    again to partition your disk. Feel free to practice this a few times until you
    get the hang of the process.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你犯了错误或者想要重新调整分区布局，你可以再次进入`fdisk`提示符，然后按*g*创建一个新的GPT布局，或者按*o*创建一个新的MBR布局。然后，重新按照步骤分区你的磁盘。可以多次练习，直到熟练掌握这个过程。
- en: Formatting partitions
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化分区
- en: 'After you create your partition layout for your new disk and you’re satisfied
    with it, you’re ready to format it. Now that I’ve created a partition layout on
    the new disk, the output of `sudo fdisk -l` will be different:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在你为新磁盘创建好分区布局并且满意后，你就可以开始格式化它了。现在我已经在新磁盘上创建了一个分区布局，运行`sudo fdisk -l`的输出将有所不同：
- en: '![](img/B18425_09_06.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_09_06.png)'
- en: 'Figure 9.6: Another example of sudo fdisk -l after creating a partition'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：创建分区后运行`sudo fdisk -l`的另一个示例
- en: 'Notice that now, we have the partition `/dev/sdb1` added, which is visible
    in the output. Now, we can go ahead and format it. To do so, we take care of that
    with the `mkfs` command. This command is run with a specific syntax that entails
    typing `mkfs` along with a period (`.`), followed by the type of filesystem you
    would like to format the target as. The following example will format `/dev/sdb1`
    as ext4:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在我们添加了分区`/dev/sdb1`，它可以在输出中看到。接下来，我们可以继续格式化它。为此，我们使用`mkfs`命令。此命令需要特定的语法，输入`mkfs`后跟一个句点（`.`），然后输入你希望将目标格式化为的文件系统类型。以下示例将`/dev/sdb1`格式化为ext4：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Your output will look similar to mine in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将与以下截图中的内容类似：
- en: '![](img/B18425_09_07.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_09_07.png)'
- en: 'Figure 9.7: Formatting a volume using the ext4 filesystem'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：使用ext4文件系统格式化卷
- en: 'If you’ve opted for a filesystem type other than ext4, you can use that in
    place of ext4 when using `mkfs`. The following example creates an XFS filesystem
    instead:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了其他文件系统类型而不是ext4，你可以在使用`mkfs`时替换为所选文件系统类型。以下示例将创建一个XFS文件系统：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Some filesystems, such as XFS, are not supported by default and may need an
    additional package installed in order for them to be used. In the case of XFS,
    it requires the `xfsprogs` package to be installed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文件系统，例如XFS，默认不被支持，可能需要安装额外的软件包才能使用它们。以XFS为例，需要安装`xfsprogs`软件包。
- en: So, now that we’ve created one or more partitions and formatted them, we’re
    ready to mount the newly created partition(s) on our server. In the next section,
    I’ll walk you through mounting and unmounting storage volumes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了一个或多个分区并格式化了它们，我们准备在服务器上挂载新创建的分区。在接下来的部分中，我将带你逐步了解如何挂载和卸载存储卷。
- en: Mounting and unmounting volumes
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂载与卸载卷
- en: Now that you’ve added a new storage volume to your server and formatted it,
    you can mount the new device so that you can start using it. To do this, we use
    the `mount` command. This command allows you to attach a storage device (or even
    a network share) to a local directory on your server. Before mounting, the directory
    must be empty. The `mount` command, which we’ll get to practice with an example
    very shortly, basically just requires you to designate a place (directory) for
    the device to be mounted to. But where should you mount the volume?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为服务器添加了一个新的存储卷并格式化了它，你可以挂载这个新设备，以便开始使用它。为此，我们使用`mount`命令。这个命令允许你将一个存储设备（甚至是一个网络共享）附加到服务器上的本地目录。在挂载之前，目录必须是空的。`mount`命令，稍后我们将通过一个示例进行实践，基本上只需要你指定一个位置（目录）来挂载设备。但我们该将卷挂载到哪里呢？
- en: 'Normally, there are two directories, created by default, in your Ubuntu Server
    installation that exist for the purposes of mounting volumes: `/mnt` and `/media`.
    While there is no hard rule as far as where media needs to be mounted, these two
    directories exist as part of the **Filesystem Hierarchy Standard** (**FHS**) that
    was mentioned in *Chapter 4*, *Navigating and Essential Commands*. The purposes
    of the `/mnt` and `/media` directories are defined within this specification.
    The FHS defines `/mnt` as a mount point for a temporarily mounted filesystem,
    and `/media` as a mount point for removable media.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在你的 Ubuntu Server 安装中，默认会创建两个目录，用于挂载卷：`/mnt` 和 `/media`。虽然没有硬性规定媒体必须挂载到哪里，但这两个目录是**文件系统层次结构标准**（**FHS**）的一部分，FHS
    在《第4章，导航和基本命令》中已经提到过。`/mnt` 和 `/media` 目录的目的在这个规范中已有定义。FHS 定义 `/mnt` 为暂时挂载文件系统的挂载点，而
    `/media` 则是可移动媒体的挂载点。
- en: In plain English, this means that the intended purpose of `/mnt` is for storage
    volumes you generally keep mounted most of the time, such as additional hard drives,
    virtual hard disks, and network-attached storage. The FHS document uses the term
    *temporary* when describing `/mnt`, but in practice, this is typically where things
    are mounted that you generally expect to be around for a while. In regard to `/media`,
    the FHS is basically indicating that removable media (flash drives, CD-ROM media,
    external hard drives, and so on) are intended to be mounted there.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这意味着 `/mnt` 的预定用途是存放你通常大部分时间都挂载的存储卷，例如额外的硬盘、虚拟硬盘和网络附加存储。FHS 文档在描述 `/mnt`
    时使用了“暂时”的术语，但实际上，这通常是你期望会存在一段时间的挂载位置。至于 `/media`，FHS 基本上是在指示可移动媒体（如闪存驱动器、CD-ROM
    媒体、外部硬盘等）应当挂载在这里。
- en: However, it’s important to point out that where the FHS indicates you should
    mount your extra volumes is only a suggestion. (Perhaps a strong suggestion, but
    a suggestion nonetheless.) No one is going to force you to follow it, and the
    fate of the world isn’t dependent on your choice. With the `mount` command, you
    can literally mount your extra storage anywhere that isn’t already mounted or
    full of files. You could even create the directory `/kittens` and mount your disks
    there and you won’t suffer any consequences other than a few chuckles from your
    colleagues.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要指出，FHS 所指示的挂载额外卷的位置只是一个建议。（也许是一个强烈的建议，但毕竟只是建议。）没有人会强迫你遵循它，世界的命运也不取决于你的选择。使用`mount`命令，你可以将额外的存储挂载到任何没有挂载或没有文件的地方。你甚至可以创建一个目录
    `/kittens` 并在那里挂载你的磁盘，除了同事们的几声笑声，你不会遭遇任何后果。
- en: Often, organizations will come up with their own scheme for where to mount extra
    disks. Although I personally follow the FHS designation, one example of a custom
    layout was with a company I worked with in the past. They used the `/store` directory
    for mounting storage on their servers, a directory they created themselves on
    each server. Whatever scheme you use is up to you; the only suggestion I can make
    is to be as consistent as you can from one server to another, if only for the
    sake of sanity.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，组织会自行制定额外磁盘挂载的位置方案。尽管我个人遵循 FHS 标准，但我曾在过去与一家公司合作时，遇到过一个自定义布局的例子。该公司在其服务器上使用了`/store`目录来挂载存储，这是他们在每台服务器上自行创建的目录。你使用什么样的方案由你决定；我唯一的建议是尽可能在不同服务器之间保持一致，至少为了保持理智。
- en: 'The `mount` command generally needs to be run as `root`. While there is a way
    around that (you can allow normal users to mount volumes, but we won’t get into
    that just yet), it’s usually the case that only `root` can or should be mounting
    volumes. As I mentioned, you’ll need a place to mount these volumes, so to facilitate
    that, we can create a directory called `/mnt/vol1` with the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount`命令通常需要以`root`身份执行。虽然有办法绕过这一点（你可以允许普通用户挂载卷，但我们暂时不讨论这个问题），通常情况下，只有`root`用户才能或应该挂载卷。正如我所提到的，你需要一个地方来挂载这些卷，因此，为了方便操作，我们可以使用以下命令创建一个名为`/mnt/vol1`的目录：'
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you’ve created a directory, like I have, or decided on an existing one,
    you can mount a volume with a command similar to the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建了一个目录（就像我这样做的）或决定使用一个现有目录后，你可以使用类似下面的命令来挂载一个卷：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In that example, I’m mounting device `/dev/sdb1` to directory `/mnt/vol1`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将设备`/dev/sdb1`挂载到目录`/mnt/vol1`。
- en: Of course, you’ll need to adjust the command to reference the device you want
    to mount and where you want to mount it. As a reminder, if you don’t remember
    which devices exist on your server, you can list them with `fdisk –l`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要调整命令，以引用你想要挂载的设备和你想要挂载的位置。提醒一下，如果你不记得服务器上有哪些设备，可以使用`fdisk –l`列出它们。
- en: 'Normally, the `mount` command wants you to issue the `-t` option with a given
    type. In my case, the `mount` command would’ve been the following had I used the
    `-t` option, considering my disk is formatted with `ext4`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`mount`命令要求你指定一个`-t`选项，后面跟着指定的类型。在我的情况下，如果我使用了`-t`选项，那么`mount`命令应该是以下内容，因为我的磁盘格式化为`ext4`：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A useful trick when mounting devices is to execute the `df –h` command before
    and after mounting.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的技巧是在挂载设备之前和之后执行`df –h`命令。
- en: While that command is generally used to check how much free space you have on
    various mounts, it does show you a list of mounted devices, so you can simply
    compare the results after mounting the device to confirm that it is present.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个命令通常用于检查不同挂载点的可用空间，但它会显示挂载的设备列表，因此你可以在挂载设备后对比结果，确认设备是否已挂载。
- en: In that example, I used the `-t` option along with the type of filesystem I
    formatted the device with. In the first example, I didn’t. This is because, in
    most cases, the `mount` command is able to determine which type of filesystem
    the device uses and adjust itself accordingly. Thus, most of the time, you won’t
    need the `-t` option. In the past, you almost always needed it, but it’s easier
    nowadays. The reason I bring this up is that if you ever see an error when trying
    to mount a filesystem that indicates an invalid filesystem type, you may have
    to specify this. Feel free to check the man pages for the `mount` command for
    more information regarding the different types of options you can use.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我使用了`-t`选项，并指定了我格式化该设备时使用的文件系统类型。在第一个例子中，我没有使用这个选项。这是因为，在大多数情况下，`mount`命令能够自动识别设备使用的文件系统类型并相应调整。因此，大多数情况下，你不需要使用`-t`选项。过去，你几乎总是需要它，但现在操作起来更简单了。我之所以提到这一点，是因为如果你在尝试挂载文件系统时遇到错误，提示无效的文件系统类型，你可能需要指定这个选项。可以查看`mount`命令的手册页，了解更多关于不同选项的信息。
- en: 'When you are finished using a volume, you can unmount it with the `umount`
    command (the missing *n* in the word *unmount* is intentional):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用完一个卷后，可以使用`umount`命令卸载它（单词*unmount*中缺失的*n*是故意的）：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `umount` command, which also needs to be run as `root` or with `sudo`, allows
    you to disconnect a storage device from your filesystem. In order for this command
    to be successful, the volume should not be in use. If it is, you may receive a
    device- or resource-busy error message. If you execute `df -h` after unmounting,
    you should see that the filesystem is missing from the output and, thus, isn’t
    mounted anymore.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`umount`命令也需要以`root`身份或通过`sudo`运行，它可以让你将存储设备从文件系统中断开。为了确保此命令成功执行，卷不能正在被使用。如果正在使用，你可能会收到设备或资源忙碌的错误消息。如果你在卸载后执行`df
    -h`，你应该会看到文件系统不再出现在输出中，意味着它已经不再挂载。'
- en: The downside to manually mounting devices is that they will not automatically
    remount themselves the next time your server boots. In order to ensure the mount
    is available anytime your server boots up, you’ll need to edit the `/etc/fstab`
    file, which I’ll walk you through in the next section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 手动挂载设备的缺点是，它们在下次服务器启动时不会自动重新挂载。为了确保挂载点在每次服务器启动时都可用，你需要编辑`/etc/fstab`文件，接下来我会引导你完成这个步骤。
- en: Understanding the /etc/fstab file
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解/etc/fstab文件
- en: The `/etc/fstab` file is a very critical file on your Linux system. You can
    edit this file to call out additional volumes you would like to automatically
    mount at boot time. However, the main purpose of this file is to also mount your
    main filesystem, so if you make a mistake while editing it, your server will not
    boot (at all). Definitely be careful here.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/fstab`文件是你Linux系统中的一个非常关键的文件。你可以编辑此文件，列出你希望在启动时自动挂载的其他卷。然而，这个文件的主要作用也是挂载你的主文件系统，所以如果在编辑时出错，可能会导致服务器无法启动（完全无法启动）。一定要小心。'
- en: Analyzing the contents of /etc/fstab
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析/etc/fstab文件的内容
- en: When your system boots, it looks at the `/etc/fstab` file to determine where
    the root filesystem is. In addition, the location of your `swap` area is read
    from this file and mounted at boot time as well. Your system will also read any
    other mount points listed in this file, one per line, and mount them. Basically,
    just about any kind of storage you can think of can be added to this file and
    automatically mounted. Even network shares from Windows servers can be added here.
    It won’t judge you (unless you make a typo).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的系统启动时，它会查看`/etc/fstab`文件以确定根文件系统的位置。此外，`swap`区域的位置也会从这个文件中读取，并在启动时挂载。系统还会读取此文件中列出的其他挂载点，一行一个，并进行挂载。基本上，几乎所有你能想到的存储都可以添加到这个文件中并自动挂载。即使是来自Windows服务器的网络共享也可以在这里添加。它不会对你评判（除非你打错字）。
- en: 'As an example, here are the contents of `/etc/fstab` on one of my machines:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，以下是我某台机器上`/etc/fstab`文件的内容：
- en: '![](img/B18425_09_08.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_09_08.png)'
- en: 'Figure 9.8: Viewing the contents of the /etc/fstab file'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8：查看/etc/fstab文件的内容
- en: When you install Ubuntu Server, the `/etc/fstab` file is created for you and
    populated with a line for each of the partitions the installer created during
    installation. On the server I used to grab the example `fstab` content, I have
    a single partition for the root filesystem, and you can also see where the swap
    file is mentioned.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装Ubuntu Server时，`/etc/fstab`文件会为你创建，并为安装过程中创建的每个分区添加一行。在我用于获取示例`fstab`内容的服务器上，只有一个根文件系统分区，你还可以看到swap文件的位置。
- en: Each partition is typically designated with a **Universally Unique Identifier**
    (**UUID**) instead of the `/dev/sdaX` naming convention you might be more accustomed
    to if you’ve worked with storage devices in the past. In my output, you can see
    UUID `dm-uuid-LVM-H8VEs7qDbMgv...`, which refers to my root filesystem, and you
    can also see that I have a `swap` file located at `/swap.img`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分区通常使用**通用唯一标识符**（**UUID**）来标识，而不是你可能更习惯的`/dev/sdaX`命名约定，尤其是当你以前处理过存储设备时。在我的输出中，你可以看到UUID
    `dm-uuid-LVM-H8VEs7qDbMgv...`，它指的是我的根文件系统，你还可以看到我有一个位于`/swap.img`的`swap`文件。
- en: The concept of a UUID has been around for a while, but there’s nothing stopping
    you from replacing the UUID with the actual partition names (such as `/dev/sda1`
    or similar). If you were to do that, the server would still boot, and you probably
    wouldn’t notice a difference (assuming you didn’t make a typo).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: UUID的概念已经存在了一段时间，但并没有任何限制阻止你用实际的分区名称（例如`/dev/sda1`或类似的名称）替换UUID。如果你这么做，服务器依然会启动，你可能不会注意到什么不同（前提是没有打错字）。
- en: Nowadays, UUIDs are preferred over common device names due to the fact that
    the names of devices can change depending on where you place them physically (such
    as which particular **Serial Advanced Technology Attachment** (**SATA**) port
    a hard disk is plugged into, which of your USB ports an external drive is connected
    to, and so on) or how you order them (in the case of virtual disks).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于设备的名称可能会根据设备的物理位置（例如硬盘插入了哪个**串行高级技术附件**（**SATA**）端口，外部硬盘连接到哪个USB端口，等等）或它们的排序（虚拟磁盘的情况）而发生变化，因此UUID比常见的设备名称更受青睐。
- en: 'Add to this the fact that removable media can be inserted or removed at any
    time, and you have a situation where you don’t really know what name each device
    is going to have at any one time. For example, your external hard drive may be
    named `/dev/sdb1` on your system now, but it may not be the next time you mount
    it if something else you connect claims the name of `/dev/sdb1`. This is one situation
    in which the concept of UUIDs comes in handy. The UUID of a device will not change
    if you reorder your disks (but it will change if you reformat the volume). As
    stated in *Figure 9.8*, you can easily list the UUIDs of your volumes with the
    `blkid` command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 再加上可移动媒体可以随时插入或移除的事实，你会遇到一种情况：你无法确定每个设备在任何时刻会被分配什么名称。例如，现在你的外部硬盘可能被命名为`/dev/sdb1`，但下次挂载时，如果你连接的其他设备占用了`/dev/sdb1`这个名称，它可能就不再是这个名字。这时UUID的概念就非常有用了。设备的UUID不会因为你重新排列硬盘顺序而改变（但如果重新格式化卷，它会改变）。如*图9.8*所示，你可以使用`blkid`命令轻松列出卷的UUID：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output will show you the UUID of each device attached to your system, and
    you can use this command any time you add new volumes to your server to list your
    UUIDs. This is also the first step in adding a new volume to your `/etc/fstab`
    file. While I did say that using UUIDs is not required, it’s definitely recommended
    and can save you from trouble later on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示附加到你系统上的每个设备的UUID，你可以在每次向服务器添加新卷时使用此命令列出UUID。这也是将新卷添加到`/etc/fstab`文件的第一步。虽然我之前说过使用UUID不是必须的，但强烈推荐使用，因为它可以避免你以后遇到麻烦。
- en: Each line of an `fstab` entry is broken down into several columns, each separated
    by spaces or tabs. There isn’t a set number of spaces necessary to separate each
    column; in most cases, spaces are only used to line up each column to make them
    easier to read. However, at least one space is required.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每行`fstab`条目都被分为几列，每列由空格或制表符分隔。没有规定需要多少个空格来分隔每列；在大多数情况下，空格仅用于对齐每列，使其更易读。但至少需要一个空格。
- en: In the first column of the example `fstab` file, we have the device identifier,
    which can be the UUID or label of each device that differentiates it from the
    others. (You can add a label to a device while formatting it with the `-L` argument
    with `mkfs` commands.) In the second column, we have the location we want the
    device to be mounted to. In the case of the root filesystem, this is `/`, which
    (as you know) is the beginning of the Linux filesystem. The third entry in the
    screenshot (for `swap`) has a mount point of `none`, which means that a mount
    point is not necessary for this device. In the third column, we have the filesystem
    type, the first two being `ext4`, and the third having a type of `swap`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的`fstab`文件的第一列中，我们有设备标识符，它可以是每个设备的UUID或标签，用来区分其他设备。（你可以在使用`mkfs`命令格式化设备时，使用`-L`参数为设备添加标签。）在第二列中，我们有设备挂载位置。对于根文件系统，挂载点是`/`，这是Linux文件系统的起点，正如你所知。截图中的第三项（`swap`）的挂载点是`none`，这意味着这个设备不需要挂载点。第三列中，我们有文件系统类型，前两项是`ext4`，第三项是`swap`类型。
- en: In the fourth column, we have a list of options for each mount separated by
    a comma. In this case, we only have one option for each of the example lines.
    With the root filesystem, we have an option of `errors=remount-ro`, which tells
    the system to remount the filesystem as read-only if an error occurs. Such an
    issue is rare but will keep your system running in read-only mode as best it can
    if something goes wrong. The `swap` partition has a single option of `sw`. There
    are many other options that can be used here, so feel free to consult the man
    pages for a list. We will go over some of these options in this section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四列中，我们列出了每个挂载点的选项，并用逗号分隔。在这个例子中，每一行的选项只有一个。对于根文件系统，我们有一个选项`errors=remount-ro`，表示如果发生错误，系统会将文件系统重新挂载为只读模式。此类问题虽然罕见，但在出现故障时，能让系统尽量以只读模式继续运行。`swap`分区只有一个选项`sw`。这里可以使用许多其他选项，因此可以参考手册页获取完整的选项列表。在这一节中，我们会介绍一些常见的选项。
- en: The fifth and sixth columns refer to `dump` and `pass` respectively, which on
    my system are `0` and `0` for each line. The `dump` partition is almost always
    `0` and can be used with a backup utility to determine whether the filesystem
    should be backed up (`0` for no, and `1` for yes). In most cases, just leave this
    at `0` since this is rarely ever used by anything nowadays. The `pass` field refers
    to the order in which `fsck` will check the filesystems. The `fsck` utility scans
    hard disks for filesystem errors in the case of a system failure or a scheduled
    scan. The possible options for `pass` are `0`, `1`, or `2`. With `0`, the partition
    is never checked with `fsck`. If set to `1`, the partition is checked first. Partitions
    with a `pass` of `2` are considered a second priority and checked last. As a general
    rule of thumb, consider using `1` for your main filesystem and `2` for all others.
    It’s not uncommon for cloud server providers to use `0` for both fields. This
    may be because if a disk does undergo a routine check, it would take considerably
    longer to boot up. In a cloud environment, you can’t always wait very long to
    get a server up and running.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第五列和第六列分别指的是`dump`和`pass`，在我的系统中，每一行的值为`0`和`0`。`dump`分区几乎总是`0`，可以与备份工具一起使用来确定是否需要备份文件系统（`0`表示不备份，`1`表示备份）。在大多数情况下，只需将其保持为`0`，因为现在很少有工具会使用这个选项。`pass`字段指的是`fsck`检查文件系统的顺序。`fsck`工具用于扫描硬盘中的文件系统错误，尤其是在系统故障或计划扫描时。`pass`的可能值是`0`、`1`或`2`。如果是`0`，则文件系统不会用`fsck`检查。如果设置为`1`，则首先检查该分区。`pass`为`2`的分区优先级较低，最后被检查。一般来说，建议将主文件系统设置为`1`，其他分区设置为`2`。云服务器提供商使用`0`作为两个字段的值并不少见，这可能是因为如果磁盘确实要进行例行检查，启动时间会显著增加。而在云环境中，无法等待很长时间来启动服务器。
- en: Now that we understand all the columns of a typical `fstab` entry, we can work
    through adding another volume to the `fstab` file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了典型`fstab`条目的所有列，可以开始将另一个卷添加到`fstab`文件中了。
- en: Adding to the /etc/fstab file
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加到/etc/fstab文件
- en: 'To add another volume to the `fstab` file, we first need to know the `UUID`
    of the volume we would like to add (assuming it’s a hard disk or virtual disk).
    Again, we do that with the `blkid` command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要将另一个卷添加到`fstab`文件中，我们首先需要知道我们要添加的卷的`UUID`（假设它是硬盘或虚拟磁盘）。同样，我们可以使用`blkid`命令来完成这项操作：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice that I used the device name of `/dev/sdb1` as an argument. This is because
    I want to specifically fetch the UUID of the new device we added. The output of
    that command will give us the UUID of that device, so it can be added to the `/etc/fstab`
    file. Copy that down somewhere, as we’ll need it shortly. Next, we need to know
    where we want to mount the volume. Go ahead and create the directory now, or use
    an existing directory if you wish. For example, you could create the directory
    `/mnt/extra_storage` for this purpose:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我使用了`/dev/sdb1`设备名称作为参数。这是因为我想专门获取我们添加的新设备的UUID。该命令的输出将返回该设备的UUID，然后我们可以将其添加到`/etc/fstab`文件中。记下这个UUID，因为我们稍后会用到它。接下来，我们需要确定将卷挂载到哪里。现在可以创建一个目录，或者使用现有的目录。例如，可以创建目录`/mnt/extra_storage`来用于挂载：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At this point, we should have all we need in order to add a new entry to `fstab`.
    To do so, we’ll need to open the file in a text editor and then create a new line
    after all the others. If you don’t have a preferred editor, you can use the `nano`
    editor:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，我们应该已经拥有了所有信息，可以向`fstab`文件添加新的条目。为此，我们需要在文本编辑器中打开文件，然后在所有其他条目之后创建新的一行。如果没有偏好的编辑器，可以使用`nano`编辑器：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For example, the `/etc/fstab` file after adding an entry for `/dev/sdb` would
    look similar to the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，向 `/etc/fstab` 文件添加 `/dev/sdb` 条目后的内容如下所示：
- en: '![](img/B18425_09_09.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_09_09.png)'
- en: 'Figure 9.9: The /etc/fstab file after adding a new entry to it'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9：向 /etc/fstab 文件添加新条目后的内容
- en: In my example, I created a comment line with a little note about what the extra
    volume will be used for (`Extra storage`). It’s always a good idea to leave comments,
    so other administrators will have a clue regarding the purpose of the extra storage.
    Then, I created a new line with the UUID of the volume, the mount point for the
    volume, the filesystem type, `defaults` option, and a `dump`/`pass` of `0` and
    `0`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的示例中，我创建了一行注释，简要说明了额外卷的用途（`额外存储`）。留下注释总是个好主意，这样其他管理员就能了解额外存储的目的。接着，我创建了一行，包含卷的
    UUID、卷的挂载点、文件系统类型、`defaults` 选项，以及 `dump`/`pass` 的值 `0` 和 `0`。
- en: 'The `defaults` option is one I’ve not mentioned before. By using `defaults`
    as your mount option in `fstab`, your mount will be given several useful options
    in one shot, without having to list them individually. Among the options included
    with `defaults` are the following, which are worth an explanation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaults` 选项是我之前未提及的。通过在 `fstab` 中使用 `defaults` 作为挂载选项，你的挂载将会一次性获得几个有用的选项，而无需单独列出它们。`defaults`
    包含的选项有以下几项，值得解释：'
- en: '`rw`: Device will be mounted read/write'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw`：设备将被挂载为读写模式'
- en: '`exec`: Allow files within this volume to be executed as programs'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec`：允许在此卷中的文件作为程序执行'
- en: '`auto`: Automatically mount the device at boot time'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto`：在启动时自动挂载设备'
- en: '`nouser`: Only `root` is able to mount the filesystem'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nouser`：只有 `root` 用户能够挂载文件系统'
- en: '`async`: Output to the device should be asynchronous'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`：输出到设备应为异步'
- en: Depending on your needs, the options included with defaults may or may not be
    ideal. Instead, you can call the options out individually, separated by commas,
    choosing only the ones you need. For example, with regard to `rw`, you may not
    want users to be allowed to change the content. In fact, I strongly recommend
    that you use `ro` (read-only) instead unless your users have a very strong use
    case for needing to make changes to files. I’ve actually learned this the hard
    way, where I’ve experienced an entire volume getting completely wiped out (and
    no one admitted to clearing the contents). This volume included some very important
    company data. From that point on, I mandated `ro` being used for everything, with
    a separate `rw` mount created, with only a select few (very responsible) people
    having access to it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的需求，`defaults` 包含的选项可能适合，也可能不适合。你可以单独调用这些选项，以逗号分隔，选择你需要的选项。例如，对于 `rw`，你可能不希望用户能够更改内容。实际上，除非用户有非常强烈的需求来修改文件，否则我强烈建议你使用
    `ro`（只读）选项。我就是在经历了一次整个卷完全被清空的事件后学到的这一点（而且没有人承认清空了内容）。这个卷中包含了非常重要的公司数据。从那时起，我要求所有内容都使用
    `ro`，并创建了一个单独的 `rw` 挂载点，只有极少数（非常负责任的）人员才能访问。
- en: The `exec` option may also not be ideal. For example, if your volume is intended
    for storing files and backups, you may not want scripts to be run from that location.
    By using the inverse of `exec` (`noexec`), you can prevent scripts from running
    to create a situation where users are able to store files on the volume but not
    execute programs that are stored there.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec` 选项也可能不是最理想的。例如，如果你的磁盘卷是用于存储文件和备份的，你可能不希望在该位置运行脚本。通过使用 `exec` 的反向选项（`noexec`），你可以防止脚本运行，从而创建一个用户可以在该卷上存储文件，但无法执行存储在其中的程序的情况。'
- en: 'Another option worth explaining is `auto`. The `auto` option basically tells
    your system to automatically mount that volume whenever the system boots or when
    you enter the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得解释的选项是 `auto`。`auto` 选项基本上告诉系统每次启动时自动挂载该卷，或者当你输入以下命令时自动挂载：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When executed, `sudo mount -a` will mount any entry in your `/etc/fstab` file
    that has the `auto` option set. If you’ve used `defaults` as an option for the
    mount, those will be mounted as well since `defaults` implies `auto`. This way,
    you can mount all filesystems that are supposed to be mounted without rebooting
    your server (this command is safe to run whenever, as it will not disrupt anything
    that is already mounted).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `sudo mount -a` 时，会挂载 `/etc/fstab` 文件中所有设置了 `auto` 选项的条目。如果你为挂载使用了 `defaults`
    选项，那么这些条目也会被挂载，因为 `defaults` 隐含了 `auto`。这样，你就可以在不重启服务器的情况下挂载所有应该挂载的文件系统（该命令可以随时安全执行，因为它不会中断任何已经挂载的内容）。
- en: The opposite of the `auto` option is `noauto`, which can be used instead. As
    you can probably guess by the name, an entry in `fstab` with the `noauto` option
    will not be automatically mounted and will not be mounted when you run `mount
    -a`. Instead, entries with this option will need to be mounted manually.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`选项的反义词是`noauto`，可以替代使用。如你所猜测，带有`noauto`选项的`fstab`条目不会自动挂载，也不会在运行`mount
    -a`时被挂载。相反，带有此选项的条目需要手动挂载。'
- en: 'You may be wondering, then, what the point is of including an entry in `/etc/fstab`
    just to use `noauto`, which kind of seems to defeat the purpose. To explain this
    better, here is an example `fstab` entry with `noauto` being used:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会疑惑，既然使用`noauto`会使挂载失效，那么在`/etc/fstab`中包含这样的条目有什么意义呢？为了更好地解释这一点，下面是一个使用了`noauto`的`fstab`条目示例：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, let’s say that I have an external disk that I only mount when I’m performing
    a backup. I wouldn’t want this device mounted automatically at boot time (I may
    not always have it connected to the server), so I use the `noauto` option. But
    since I do have an entry for it in `/etc/fstab`, I can easily mount it any time
    after I connect it with the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有一个外部磁盘，只有在进行备份时才会挂载。我不希望这个设备在启动时自动挂载（因为我可能并不总是把它连接到服务器），所以我使用了`noauto`选项。但由于我在`/etc/fstab`中确实有这个设备的条目，一旦连接了它，我可以随时通过以下命令轻松挂载：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that I didn’t have to include the device name or options; only the destination
    path for the mount. The `mount` command knows what device I’m referring to since
    I have an entry in the `/etc/fstab` file for a device to be mounted at `/mnt/ext_disk`.
    This saves me from having to type the device name and options each time I want
    to mount the device. So, in addition to mounting devices at boot time, the `/etc/fstab`
    file also becomes a convenient place to declare devices that may be used on an
    on-demand basis but aren’t always attached.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我不需要包括设备名称或选项；只需提供挂载的目标路径即可。由于我在`/etc/fstab`文件中为一个设备添加了挂载路径`/mnt/ext_disk`，因此`mount`命令知道我指的是哪个设备。这避免了每次挂载设备时都需要输入设备名称和选项。因此，除了在启动时挂载设备外，`/etc/fstab`文件还成为了一个方便的地方，用来声明可能按需使用但并非总是连接的设备。
- en: One final option I would like to cover before we move on is `users`. When used
    with a mount in `/etc/fstab`, this allows regular users (users other than `root`)
    to mount and unmount the filesystem. This way, `root` or `sudo` will not be necessary
    at all for a mount used with this option. Use this with care, but it can be useful
    if you have a device with non-critical data that you don’t mind your users having
    full control over when mounting and unmounting.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想讲解最后一个选项`users`。当在`/etc/fstab`中与挂载一起使用时，它允许普通用户（非`root`用户）挂载和卸载文件系统。这样，使用此选项的挂载就不再需要`root`或`sudo`权限。请谨慎使用此选项，但如果你的设备存储的是非关键数据，且你不介意用户在挂载和卸载时拥有完全控制权限，它会非常有用。
- en: While the concept of a text file controlling which devices are mounted on the
    system may seem odd at first, I think you’ll appreciate being able to view a single
    file in order to find out everything that should be mounted and where it should
    be mounted. As long as administrators add all on-demand devices to this file,
    it can be a convenient place to get an overview of the filesystems that are in
    use on the server. As a bonus, you can also use the `mount` command (with no options)
    to have the system provide you with a list of everything that’s mounted. Go ahead
    and try that, and I’ll meet you in the next section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始可能会觉得通过文本文件来控制哪些设备挂载到系统上有些奇怪，但我想你会发现，能够查看一个文件以找出所有需要挂载的内容以及挂载位置，是非常方便的。只要管理员将所有按需设备添加到此文件中，它就可以成为一个方便的地方，用于概览服务器上正在使用的文件系统。作为额外的好处，你还可以使用`mount`命令（不加选项）来查看系统列出的所有挂载内容。试试看，然后我们在下一部分再见。
- en: Backing up and restoring volumes
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份和恢复卷
- en: Since we’re dealing with servers, the data that’s being stored on our storage
    devices is no doubt going to be extremely important. While it’s normal to have
    a few test servers for use as test subjects in a typical environment, our servers
    usually exist to carry out a very important task. I can tell you from first-hand
    experience, never put too much trust in storage devices. In fact, I recommend
    not trusting them at all. I consider all storage to be temporary, as hard drives
    can and do break. If your important data is only stored on one device, it’s not
    safe. In this section, I’m going to discuss some very important topics around
    backups.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理服务器，存储在存储设备上的数据无疑非常重要。虽然在典型的环境中拥有一些用于测试的服务器是正常的，但我们的服务器通常承担着非常重要的任务。我可以根据亲身经历告诉你，永远不要对存储设备过于信任。事实上，我建议你根本不要信任它们。我认为所有存储设备都是临时的，因为硬盘是会坏的。如果你的重要数据仅仅存储在一个设备上，那是非常不安全的。在这一节中，我将讨论一些与备份相关的非常重要的话题。
- en: First, consider RAID volumes. We haven’t discussed them in this chapter because
    while the technology can still be beneficial, it’s not as popular as it once was.
    Don’t get me wrong, there’s still a place for RAID, but it’s just not as popular
    as it used to be. RAID allows you to join multiple disks in various configurations,
    which can result in a lower chance of losing data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑一下RAID卷。在本章中我们没有讨论它，因为虽然这项技术仍然有其优势，但它已不再像以前那样流行。别误会，我并不是说RAID已经过时，它依然有其应用场景，只是它不再像过去那样普及。RAID允许你将多个磁盘以不同的配置组合在一起，这样可以降低丢失数据的风险。
- en: For example, RAID level 1 ensures that two hard disks always have the same data.
    If one of the disks physically fails, then you haven’t actually lost anything.
    When you replace a failed disk in RAID, it will rebuild the array with the new
    disk and then you’ll again benefit from having some expandability. RAID 5 allows
    you to have multiple disks to benefit from more space, and RAID 6 is the same
    but it allows you to have two disks fail before you lose data, rather than just
    one. Generally, that’s the difference between one level of RAID and another; how
    many disks are allowed to fail before it becomes a problem.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，RAID 1级别确保两块硬盘始终保持相同的数据。如果其中一块硬盘发生物理故障，那么你实际上并没有丢失任何数据。当你在RAID中更换故障磁盘时，系统会使用新磁盘重建阵列，然后你将再次从可扩展性中获益。RAID
    5允许你使用多块硬盘，能够获得更多的存储空间，而RAID 6则与RAID 5类似，不过它允许两块磁盘在丢失数据之前故障，而不是只有一块。通常，RAID的不同级别之间的区别就是允许多少块磁盘故障，超过这个数就会导致问题。
- en: However, RAID suffers from some serious problems. The worst is that it’s *not*
    a backup solution. It doesn’t advertise itself to be that, but many administrators
    mistakenly assume that their data is safe when utilizing RAID. The truth is, the
    level of protection RAID offers you is minimal. If there’s a lightning storm and
    a power surge gets past your surge protector and fries a hard disk, chances are
    the other one will fry too. Generally, the environmental factors that cause one
    hard disk to fail will likely cause other disks to fail too. Worse yet, if a criminal
    breaks into your server room, grabs your server, and runs away with it, then the
    crook got away with your server *and* all the disks in your RAID anyway, so there
    are various scenarios where it won’t save you. RAID can definitely be good to
    have, but it’s more of a convenience than anything else.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，RAID存在一些严重的问题。最糟糕的是，它*并不是*备份解决方案。虽然它没有宣传自己是备份工具，但许多管理员错误地认为在使用RAID时他们的数据是安全的。事实上，RAID提供的保护级别是非常有限的。如果发生雷暴天气，电源浪涌突破了你的浪涌保护器并烧坏了一块硬盘，那么很可能另一块硬盘也会被烧坏。一般来说，导致一块硬盘故障的环境因素很可能会导致其他硬盘故障。更糟的是，如果一个罪犯闯入你的服务器房，抢走了你的服务器并带走了它，那么小偷不光拿走了服务器，还带走了RAID中的所有磁盘，所以在各种情况下，RAID可能并不能救你。RAID确实有一定的好处，但更多的是一种便利，而非解决方案。
- en: Backups that are actually good exist off of the server somewhere else. The further
    away the backup is from the source server, the better. If you store your backups
    in a drawer outside of your server room, then that’s certainly better than leaving
    an external backup disk connected all the time (which can also be susceptible
    to power surges just the same as an internal disk). But if a terrible storm takes
    out your entire building, then having the backup disk stored in the same physical
    location will work against you.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的备份应该存储在服务器以外的地方。备份距离源服务器越远越好。如果你把备份存放在服务器室外的抽屉里，那肯定比一直连接外部硬盘更好（外部硬盘和内部硬盘一样，也可能会受到电力波动的影响）。但如果一个可怕的风暴摧毁了你的整个建筑，那么把备份硬盘存放在同一物理位置就会适得其反。
- en: It may seem as though I’m being a bit overly dramatic here. But actually, I’m
    not. These situations can and do happen. Successful backups are resilient, and
    allow you to get your servers up and running quickly. Backups of your data are
    on a more important level than that, as some companies can go out of business
    if they lose their important files, which can include things like schematics that
    enable the company to be in business in the first place. As a system administrator,
    you’ll need to develop a backup scheme that will account for as many scenarios
    as possible.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有些夸张。但实际上，我并不是这样。这些情况确实会发生。成功的备份方案具有韧性，并且能够让你迅速恢复服务器运行。备份你的数据更为重要，因为有些公司如果丢失了重要文件，甚至可能会倒闭，而这些文件可能包括那些能让公司维持运营的设计图纸。作为系统管理员，你需要制定一个备份方案，以应对尽可能多的情境。
- en: An effective backup routine will include several layers. Having an external
    disk is a useful backup, but why not have more than one, just in case one of them
    fails? Perhaps you can store one off-site, and swap the off-site and on-site backup
    disks weekly. In addition, perhaps you may use a command such as `rsync` to copy
    the files on your server to a remote server in another location periodically.
    You may even consider cloud backup solutions, which are another great addition.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的备份常规应包括多个层次。拥有外部硬盘作为备份是一个有用的方案，但为什么不准备多个呢，以防其中一个硬盘故障？也许你可以将其中一个备份存放在远离本地的地方，并每周交换本地和远程备份硬盘。此外，你还可以使用类似`rsync`的命令定期将服务器上的文件复制到远程服务器。你甚至可以考虑云备份方案，这也是一个很好的补充。
- en: 'In this section, I can’t give you a backup scheme for your organization because
    the layout of your backup system will depend on the needs of the organization,
    which are different from one company to the next. But what I can leave you with
    are some tips:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我无法为你的组织提供具体的备份方案，因为你的备份系统的布局将取决于组织的需求，而这些需求在不同公司之间是不同的。但我可以给你一些建议：
- en: Make sure to test your backups regularly. Simply having a backup isn’t enough—they
    have to actually work! Try to restore data from a backup periodically to test
    the effectiveness.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保定期测试你的备份。仅仅有备份是不够的——备份必须有效！定期尝试从备份中恢复数据，以测试其有效性。
- en: Have at least three layers in your backup scheme, with at least one being off-site.
    This can be a combination of external hard disks, network-attached storage, cloud
    storage, mirroring data to another server in another location, or whatever makes
    the most sense for your organization.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的备份方案中至少应有三层备份，其中至少有一层是离线的。这可以是外部硬盘、网络附加存储、云存储、将数据镜像到另一个位置的服务器，或者任何最符合你组织需求的方式。
- en: Consider encryption. Although it’s beyond the scope of this chapter, if your
    backups fall into the wrong hands, then protected data may leak and be readable
    by people you don’t want to have the information.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑加密。尽管这超出了本章的范围，但如果你的备份落入错误的人手中，受到保护的数据可能会泄漏，并且被不希望看到这些信息的人读取。
- en: Check the policies of your organization, and ensure that your backup scheme
    is compliant. Not all companies have such a scheme, but if yours does, this is
    critical. Consider retention (how long backups must be kept for) and how frequently
    backups must be updated. If you don’t have organizational policies, consult a
    lawyer to determine whether there are legal retention requirements for the industry
    of your organization.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查你组织的政策，并确保你的备份方案符合相关要求。并非所有公司都有这样的方案，但如果你的公司有，这非常关键。考虑备份保留期（备份需要保存多长时间）以及备份更新的频率。如果你没有相关政策，可以咨询律师，了解你所在行业是否有法律要求的保留期限。
- en: Above all else, the point is to keep your data safe. So far in this book, we’ve
    looked at creating additional volumes and mounting them, and we even took a quick
    look at `rsync` earlier on. You’ve already learned some of the tools that can
    be made a part of a backup scheme, and you’ll learn about more methods before
    the book comes to a close. For now, keep these points in mind as you proceed through
    the book, and consider how each new skill you learn can be implemented as part
    of a backup scheme, if applicable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，关键在于确保数据安全。到目前为止，在本书中，我们已经看过如何创建和挂载额外的卷，甚至在前面快速介绍过`rsync`。你已经学习了一些可以作为备份方案一部分的工具，在本书结束之前，你还将学习更多的方法。目前，在继续阅读本书时，请牢记这些要点，并考虑你学到的每一项新技能，看看是否可以将其作为备份方案的一部分应用，当然，如果适用的话。
- en: '**LVM** is one of my favorite technologies, giving us additional flexibility
    with our storage. In fact, let’s take a look at that now.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**LVM**是我最喜欢的技术之一，它为我们的存储提供了额外的灵活性。事实上，我们现在就来看看它。'
- en: Utilizing LVM
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LVM
- en: The needs of your organization will change with time. While we as server administrators
    always do our best to configure resources with long-term growth in mind, budgets
    and changes in policy always seem to get in our way. LVM is something that I’m
    sure you’ll come to appreciate. In fact, technologies such as LVM are those things
    that make Linux the champion when it comes to scalability and cloud deployments.
    With LVM, you are able to resize your filesystems online, without needing to reboot
    your server.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你的组织需求会随着时间变化。虽然作为服务器管理员，我们总是尽力在配置资源时考虑长期增长，但预算和政策的变化似乎总是会给我们带来障碍。LVM是我相信你会逐渐感激的技术。事实上，像LVM这样的技术正是让Linux在可扩展性和云部署方面成为赢家的原因。有了LVM，你可以在线调整文件系统的大小，而无需重启服务器。
- en: Take the following scenario for example. Say you have an application running
    on a virtualized production server—a server that’s so important that downtime
    would cost your organization serious money. When the server was first set up,
    perhaps you gave the application’s storage directory a 100 GB partition, thinking
    it would never need more than that. Now, with your business growing, it’s not
    only using a lot of space, but you’re about to run out! What do you do? If the
    server was initially set up with LVM, you could add an additional storage volume,
    add it to your LVM pool, and grow your partition, all without rebooting your server!
    On the other hand, if you didn’t use LVM, you’re forced to find a maintenance
    window for your server and add more storage the old-fashioned way, which would
    include having it be inaccessible for a time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下场景为例。假设你在虚拟化的生产服务器上运行一个应用程序——这个服务器如此重要，以至于停机会给你的组织带来严重的经济损失。当服务器最初设置时，也许你为应用程序的存储目录分配了一个100GB的分区，认为它永远不会需要更多空间。现在，随着业务的增长，存储空间不仅用得非常多，而且即将用完！你该怎么办？如果服务器最初配置了LVM，你可以添加一个额外的存储卷，将它添加到LVM池中，并扩展你的分区，所有这一切都无需重启服务器！另一方面，如果你没有使用LVM，你就不得不找到一个服务器的维护窗口，使用传统方式添加更多存储，这意味着服务器会暂时无法访问。
- en: With physical servers, you can install additional hard drives and keep them
    on standby without utilizing them to still gain the benefit of growing your filesystem
    online, even though your server isn’t virtual. In addition, if your server supports
    hot-plugging, you can still add additional volumes without powering the server
    down.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于物理服务器，你可以安装额外的硬盘并保持备用，尽管服务器不是虚拟化的，但仍然可以通过在线扩展文件系统来获益。此外，如果你的服务器支持热插拔，你仍然可以在不停机的情况下添加额外的存储卷。
- en: 'It’s for this reason that I must stress that you should always use LVM on storage
    volumes in virtual servers whenever possible. Let me repeat myself: you should
    *always* use LVM on storage volumes when you are setting up a virtual server!
    If you don’t, this will eventually catch up with you when your available space
    starts to run out and you find yourself working over the weekend to add new disks.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我必须强调，在虚拟服务器上的存储卷中，尽可能始终使用LVM。让我再重复一遍：当你设置虚拟服务器时，*一定*要在存储卷上使用LVM！如果你不这么做，最终当你可用空间开始耗尽，且不得不在周末工作以添加新磁盘时，你会后悔的。
- en: This process might involve manually syncing data from one disk to another and
    then migrating your users to the new disk. This is not a fun experience, believe
    me. You might not think you’ll be needing LVM right now, but you never know.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可能涉及手动将数据从一个磁盘同步到另一个磁盘，然后将用户迁移到新的磁盘。相信我，这可不是一个愉快的经历。你可能现在觉得不需要使用LVM，但你永远不知道。
- en: Getting started with LVM
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When setting up a new server via Ubuntu’s installer, you’re given the option
    to use LVM during installation. But it’s much more important for your storage
    volumes to use LVM, and by those, I mean the volumes where your users and applications
    will store their data. LVM is a good choice for your Ubuntu Server’s root filesystem
    if you’d like the root filesystem to also benefit from the features of LVM. In
    order to get started with LVM, there are a few concepts that we’ll need to understand,
    specifically **volume groups**, **physical volumes**, and **logical volumes**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: A volume group is a namespace given to all the physical and logical volumes
    that you wish to use with that implementation of LVM. Basically, a volume group
    is the highest name that encompasses your entire implementation of an LVM setup.
    Think of it as a kind of container that is able to contain disks. An example of
    this might be a volume group named `vg-accounting`. This volume group would be
    used as a location for the accounting department to store their files. It will
    encompass the physical volumes and logical volumes that will be in use by these
    users. It’s important to note that you aren’t limited to just a single volume
    group; you can have several, each with its own disks and volumes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: A physical volume is a physical or virtual hard disk that is a member of a volume
    group. For example, the hypothetical `vg-accounting` volume group may consist
    of three 100 GB hard disks, and each would be considered a physical volume. Keep
    in mind that these disks are still referred to as physical volumes in the context
    of LVM, even when the disks are virtual. Basically, any block device that is owned
    by a volume group is a physical volume.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Finally, logical volumes are similar in concept to partitions. Logical volumes
    can take up a portion, or the whole, of a disk, but unlike standard partitions,
    they may also span multiple disks. For example, a logical volume can include three
    100 GB disks and be configured such that you would receive a cumulative total
    of 300 GB. When mounted, users will be able to store files there just as they
    would a single partition on a standard disk. When the volume gets full, you can
    add an additional disk and then grow the partition to increase its size. Your
    users would see it as a single storage area, even though it may consist of multiple
    disks.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The volume group can be named anything you’d like, but I always give mine names
    that begin with `vg-` and end with a name detailing its purpose. As I mentioned,
    you can have multiple volume groups. Therefore, you can have `vg-accounting`,
    `vg-sales`, and `vg-techsupport` (and so on) all on the same server. Then, you
    assign physical volumes to each. For example, you can add a 500 GB disk to your
    server and assign it to `vg-sales`. From that point on, the `vg-sales` volume
    group owns that disk. You’re able to split up your physical volumes in any way
    that makes sense to you. Then, you can create logical volumes utilizing these
    physical volumes, which is what your users will use.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: I think it’s always best to work through an example when it comes to learning
    a new concept, so I’ll walk you through such a scenario. In my case, I just created
    a local Ubuntu Server VM on my machine via VirtualBox, and then I added four additional
    20 GB disks after I installed the distribution.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization is a good way to play around with learning LVM if you don’t have
    a server available with multiple free physical disks.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with LVM on a server that isn’t already using it, you’ll first
    need to have at least one additional (unused) volume, and install the required
    packages, which may or may not be present on your server. To find out if the required
    `lvm2` package is installed on your server, execute the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If it’s not present (the output of the previous command doesn’t include `[installed,automatic]`),
    the following command will install the `lvm2` package and its dependencies:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, we’ll need to take an inventory of the disks we have available to work
    with. You can list them with the `fdisk -l` command as we’ve done several times
    now. In my case, I’ve added a few new volumes to my server, so now I have `/dev/sdb`,
    `/dev/sdc`, `/dev/sdd`, and `/dev/sde` to work with. The names of your disks will
    be different depending on your hardware or virtualization platform, so make sure
    to adjust all of the following commands accordingly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we’ll need to configure each disk to be used with LVM, by setting
    up each one as a physical volume. Note that we don’t need to format a storage
    device, or even use `fdisk` to set it up before beginning the process of setting
    up LVM. Formatting actually comes later in this particular process. The `pvcreate`
    command is the first command we run to configure our disks for use with LVM. Therefore,
    we’ll need to run the `pvcreate` command against all of the drives we wish to
    use for this purpose. For example, if I had four disks I wanted to use with LVM,
    I would run the following to set them up:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And so on, for however many disks you plan on using.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm that you have followed the steps correctly, you can use the `pvdisplay`
    command as `root` to display the physical volumes you have available on your server:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_09_10.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: Output of the pvdisplay command on a sample server'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot shows only one volume, as it had to be formatted to fit this
    page. The `pvdisplay` command will show more output if you scroll up. Although
    we have some physical volumes to work with, none of them are assigned to a volume
    group. In fact, we haven’t even created a volume group yet. We can now create
    our volume group with the `vgcreate` command, where we’ll give our volume group
    a name and assign our first disk to it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, I’m creating a volume group named `vg-test` and I’m assigning it one
    of the physical volumes I prepared earlier `(/dev/sdb`). Now that our volume group
    is created, we can use the `vgdisplay` command with `sudo` to view details about
    it, including the number of assigned disks (which should now be `1`):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_09_11.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: Output of the vgdisplay command on a sample server'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if you created four virtual disks as I have, you have three more
    disks left that are not part of the volume group. Don’t worry, we’ll come back
    to them later. Let’s forget about them for now as there are other concepts to
    work on at the moment.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do at this point is to create a logical volume and format it.
    Our volume group can contain all of, or a portion of, the disk we’ve assigned
    to it. With the following command, I’ll create a logical volume of 5 GB from the
    virtual disk I added to the volume group:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The command may look complicated, but it’s not. In this example, I’m giving
    my logical volume the name `myvol1` with the `-n` option. Since I only want to
    give it 5 GB of space, I use the `-L` option and then `5g` to represent 5 GB.
    Finally, I give the name of the volume group that this logical volume will be
    assigned to. You can run `lvdisplay` with `sudo` to see information regarding
    this volume:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_09_12.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: Output of the lvdisplay command on a sample server'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should have everything we need as far as setting up LVM is
    concerned. But we still need to format a volume before we can use it, similar
    to a non-LVM disk.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Formatting logical volumes
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we need to format our logical volume so that it can be used. However,
    as always, we need to know the name of the device so that we know what it is we’re
    formatting. With LVM this is easy. The `lvdisplay` command gave us this already;
    you can see it in the output (it’s the third line down in *Figure 9.12*, under
    `LV Path`). Let’s format it with the `ext4` filesystem:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And now this device can be mounted as any other hard disk. I’ll mount mine
    at `/mnt/lvm/myvol1`, but you can use any directory name you wish:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To check our work, execute `df -h` to ensure that our volume is mounted and
    shows the correct size. We now have an LVM configuration containing just a single
    disk, so this isn’t very useful. The 5 GB I’ve given it will not likely last very
    long, but there is some remaining space we can use that we haven’t utilized yet.
    With the following `lvextend` command, I can resize my logical volume to take
    up the remainder of the physical volume:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this case, `+100%FREE` is the argument that clarified that we are wanting
    to use the entirety of the remaining space for the logical volume. If done correctly,
    you should see output similar to the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now my logical volume is using the entire physical volume I assigned to it.
    Be careful, though, because if I had multiple physical volumes assigned, that
    command would’ve claimed all the space on those as well, giving the logical volume
    a size that is the total of all the space it has available, across all its disks.
    You may not always want to do this, but since I only had one physical volume anyway,
    I don’t mind. Go ahead and check your free space again with the `df -h` command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Unfortunately, it’s not showing the extra space we’ve given the volume. The
    output of `df` is still showing the size the volume was before. That’s because
    although we have a larger logical volume, and it has all the space assigned to
    it, we didn’t actually resize the `ext4` filesystem that resides on this logical
    volume. To do that, we will use the `resize2fs` command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The double-hyphen in the previous command is intentional, so make sure you’re
    typing the command correctly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'If run correctly, you should see output similar to the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now you should see the added space as usable when you execute `df -h`. The coolest
    part is that we resized an entire filesystem without having to restart the server.
    In this scenario, if our users have got to the point where they have utilized
    the majority of their free space, we will be able to give them more space without
    disrupting their work.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you may have additional physical volumes that have yet to be assigned
    to a volume group. In my example, I created four and have only used one in the
    LVM configuration so far. We can add additional physical volumes to our volume
    group with the `vgextend` command. In my case, I’ll run this against the three
    remaining drives. If you have additional physical volumes, feel free to add yours
    with the same commands I use, but substitute my device names with yours:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should see a confirmation similar to the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When you run `pvdisplay` now, you should see the additional physical volumes
    attached that weren’t showing there before. Now that we have extra disks in our
    LVM configuration, we have some additional options.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: We could give all the extra space to our logical volume right away and extend
    it as we did before. However, I think it’s better to withhold some of the space
    from our users. That way, if our users do use up all our available space again,
    we have an emergency reserve of space we could use at a pinch if we needed to
    while we figure out the long-term solution. In addition, LVM snapshots (which
    we will discuss soon) require you to have unallocated space in your LVM setup.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example command will add an additional 10 GB to the logical volume:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And finally, make the free space available to the filesystem:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With very large volumes, the resizing may take some time to complete. If you
    don’t see the additional space right away, you may see it gradually increase every
    few seconds until all the new space is completely allocated.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Removing volumes with LVM
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, you may be curious about how to remove a logical volume or volume
    group. For these purposes, you would use the `lvremove` or `vgremove` commands.
    It goes without saying that these commands are destructive, but they are useful
    in situations where you want to delete a logical volume or volume group. To remove
    a logical volume, the following syntax will do the trick:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Basically, all you’re doing is giving the `lvremove` command the name of your
    volume group, a forward slash, and then the name of the logical volume within
    that group that you would like to remove. To remove the entire volume group, the
    following command and syntax should be fairly self-explanatory:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can only remove a logical volume if it’s not in use, and this may not be
    something you’ll do very often, but if you ever do need to decommission an LVM
    component, then there are commands that will enable you to do so.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you’re convinced by now how awesome LVM is. It allows you flexibility
    over your server’s storage that other platforms can only dream of. The flexibility
    of LVM is one of the many reasons why Linux excels in the cloud market. These
    concepts can be difficult to grasp at first if you haven’t worked with LVM before.
    But thanks to virtualization, playing around with LVM is easy. I recommend you
    practice creating, modifying, and destroying volume groups and logical volumes
    until you get the hang of it. If the concepts aren’t clear now, they will be with
    practice.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you saw some ways in which LVM can benefit you; it allows you
    to take the storage of your server to the next level, even expanding it and growing
    it on demand. However, LVM also has additional tricks up its sleeve. It even allows
    you to create snapshots as well. We’ll cover this useful ability next.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Understanding LVM snapshots
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**LVM snapshots** allow you to capture a logical volume at a certain point
    in time and preserve it. After you create a snapshot, you can mount it as you
    would any other logical volume and even revert your volume group to the snapshot
    if something fails. In practice, this is useful if you want to test some potentially
    risky changes to files stored within a volume, but want the insurance that if
    something goes wrong, you can always undo your changes and go back to how things
    were. LVM snapshots allow you to do just that. LVM snapshots require you to have
    some unallocated space in your volume group.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: However, LVM snapshots are definitely *not* a viable form of backup. For the
    most part, these snapshots are best when used as a temporary holding area when
    running tests or testing out experimental software before rolling out changes
    to production systems. During Ubuntu’s installation process, you were offered
    the option to create an LVM configuration. Therefore, you can use snapshots to
    test how security updates will affect your server if you used LVM for your root
    filesystem. If the new updates start to cause problems, you can always revert
    back. When you’re done testing, you should merge or remove your snapshot.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: So, why did I refer to LVM snapshots as a temporary solution and not a backup?
    First, similar to our discussion earlier, backups aren’t secure if they are stored
    on the same server that’s being backed up. It’s always important to save backups
    of the server at least, preferably off-site. But what’s worse is that if your
    snapshot starts to use up all available space in your volume group, it can get
    corrupted and stop working. Therefore, this is a feature you would use with caution,
    just as a means of testing something, and then revert back or delete the snapshot
    when you’re done experimenting. Don’t leave an LVM snapshot hanging around for
    too long.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: When you create a snapshot with LVM, what happens is a new logical volume is
    created that is a clone of the original. Initially, no space is consumed by this
    snapshot. But as you run your server and manipulate files in your volume group,
    the original blocks are copied to the snapshot as you change them, to preserve
    the original logical volume. If you don’t keep an eye on usage, you may lose data
    if you aren’t careful and the logical volume will fill up.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'To show this in an example, the following command will create a snapshot (called
    `mysnapshot`) of the `myvol1` logical volume:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should see the following output:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With that example, we’re using the `lvcreate` command, with the `-s` option
    (snapshot) and the `-n` option (which allows us to name the snapshot), where we
    declare a name of `mysnapshot`. We’re also using the `-L` option to designate
    a maximum size for the snapshot, which I set to 4 GB in this case. Finally, I
    give it the volume group and logical volume name, separated by a forward slash
    (`/`). From here, we can use the `lvs` command to monitor its size.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re creating a new logical volume when we create a snapshot, we can
    mount it as we would a normal logical volume. This is extremely useful if we want
    to pull a single file without having to restore the entire thing.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about restoring the snapshot? One of the major benefits of snapshots
    is the ability to “roll back” to when the snapshot was taken. Essentially, this
    allows you to test changes to the server and then undo those changes. To roll
    back to a snapshot, we can do so with the `lvconvert` command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output will look similar to the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: However, it’s important to note, that, unlike being able to resize a logical
    volume online, we cannot merge a snapshot while it is in use. If you do, the changes
    will take effect the next time it is mounted. Therefore, you can either unmount
    the logical volume before merging or unmount and remount after merging. Afterward,
    you’ll see that the snapshot is removed the next time you run the `lvs` command.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Since you cannot merge (roll back) a snapshot that is in use, if the snapshot
    is of the root filesystem, you’ll have to reboot the server for the rollback to
    finalize.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’d like to make the snapshot permanent, which finalizes all of the changes
    you’ve made since the snapshot was first taken, we can use the `lvremove` command.
    For our example snapshot in this section, we can use the following command to
    make the snapshot permanent:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can probably conclude based on the name of the command, `lvremove` deletes
    the snapshot. The act of deleting the snapshot is actually what makes its changes
    final, while the `lvconvert` command mentioned earlier rolls back to when the
    snapshot was taken.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: LVM snapshots are definitely a useful feature, even if it’s not supposed to
    be considered a backup solution. My favorite use case for these snapshots is to
    take a snapshot of the root filesystem before installing all available updates.
    After I reboot, and the updates take effect, I can either delete the snapshot
    (if everything seems to be fine) or revert back to the snapshot if the updates
    seem to be causing a problem. If nothing else, LVM snapshots are yet another trick
    you can use when and if the need for it comes up.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Efficiently managing the storage of your servers will ensure that things continue
    to run smoothly, as a full filesystem can definitely cause your server to grind
    to a halt. Thankfully, Linux servers feature a very expansive toolset for managing
    your storage, some of which are a source of envy for other platforms. As Linux
    server administrators, we benefit from technologies such as LVM and utilities
    such as `ncdu`, as well as many others. In this chapter, we explored these tools
    and how to manage our storage. We covered how to format, partition, mount, and
    unmount volumes, as well as manage the `fstab` file, LVM, monitor disk usage,
    and more.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: In the next episode of our Ubuntu Server saga, we’ll work through connecting
    to networks. We’ll configure our server’s hostname, work through examples of connecting
    to other servers via OpenSSH, and take a look at IP addressing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Relevant videos
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux Crash Course – fstab: [https://linux.video/fstab](https://linux.video/fstab)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux EssentialsCrash Course – Formatting and mounting storage volumes: [https://linux.video/format-mount](https://linux.video/format-mount)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LVM deep dive: [https://linux.video/lvm](https://linux.video/lvm)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ubuntu LVM documentation: [https://learnlinux.link/u-lvm](https://learnlinux.link/u-lvm)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
