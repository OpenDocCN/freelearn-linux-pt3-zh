- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Variables and Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you saw how the shell interprets users’ commands, and
    you saw various examples of how to craft your commands. In this chapter, I’ll
    tell you about variables and pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to create variables and assign values to them is an important part
    of any programming environment. As you would expect, both `bash` and `zsh` have
    this capability. In the first part of this chapter, we’ll cover the basics about
    environmental variables and programming variables.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of the chapter, we’ll cover how to use pipelines. Pipelines
    are very simple, and you might have already used them at some point. So, I promise
    to make this write-up both short and sweet. (Actually, there’s not a lot to say
    just yet about either of these topics, which is why I’m combining both of them
    into one chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics in the chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding environmental variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding programming variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re ready, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Environmental Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Environmental variables** control the configuration and functioning of the
    operating system shell. When you install either a Linux or Unix/Unix-like operating
    system such as FreeBSD or OpenIndiana, you’ll find that a default set of environmental
    variables has already been defined at both the global and user levels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the list of environmental variables and their settings, use the `env`
    command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The complete list of environmental variables is very extensive. Fortunately,
    you don’t need to memorize what each and every item does for you. Most of the
    ones that you do need to know are self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of viewing the entire list, you can also view the value of a specific
    item. Just use the `echo` command, and precede the variable name with a `$`, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here we see that I (`donnie`) am the current logged-in user, what my path setting
    is, and what my default editor is. You would view the value of any other environmental
    variable the same way.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to note is that the names of all environmental variables
    always consist of all upper-case letters. Nothing in either the operating system
    or the shell prevents the use of lower-case letters, but there is a very good
    reason for not using them. It’s just that variable names are case-sensitive. Best
    practice dictates using nothing but upper-case letters for environmental variable
    names and either all lower-case letters or a mix of upper and lower-case letters
    for programming variable names. This will prevent you from accidentally overwriting
    the value of an environmental variable. (I’ll show you more about that in the
    next section.)
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned before, environmental variables are configured at both the global
    and user levels. Variable settings at the global level affect all users of `bash`
    and `zsh`. For `bash`, you’ll find most of these global settings in the `/etc/profile`
    file, the `/etc/bashrc` file, and various files in the `/etc/profile.d/` directory.
    For `zsh`, you’ll find these settings in the `/etc/zprofile`, `/etc/zshrc`, and
    `/etc/zshenv` files. (Note that `zsh` also references the same `/etc/profile`
    file that `bash` references.) If you were to open one of these files at this point,
    you likely won’t understand much of what’s going on in them. That’s okay, because
    for now that doesn’t matter. But, you’ll easily be able to find where the environmental
    variables are set, because the variable names are all in upper-case letters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s say you don’t like a particular setting. For example, let’s say
    that you want to customize your command-line prompt to your own liking. Here on
    my Fedora workstation, my `bash` prompt looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The format of the prompt is determined by the `PS1` environmental variable.
    We can see the `PS1` settings like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the breakdown of what you’ve just seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[`: This is a literal character, which is the first thing we see in the prompt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\u`: This causes the current user’s username to appear.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@`: This is another literal character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\h`: This causes the first component of the machine’s hostname to appear.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\W`: This causes the name of the current working directory to appear. Note
    that the upper-case W doesn’t cause the entire pathname to appear.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`]`: This is another literal character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\$`: This causes the `$` to show for all normal users, and the `#` to appear
    for the root user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A while ago, I said that we can use the `\` to force the shell to interpret
    a metacharacter as a literal character. Here though, we see another use for the
    `\`. When configuring the `PS1` parameters, the `\` indicates that we’re about
    to use a **macro** command. (Think of a macro as a command that runs when you
    perform some simple action, such as hitting a specific key or clicking on a specific
    button.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s say that we want the entire path of the current working directory
    to appear, along with the current date and time. To do that, we’ll replace the
    `\W` with `\w`, and add the `\d` and `\t` macros, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that I had to surround the new parameter within a pair of quotes so that
    the shell would interpret the metacharacters properly. Also, note what happens
    when I `cd` into a down-level directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Substituting the `/w` for the `/W` causes the entire path of the current working
    directory to show up.
  prefs: []
  type: TYPE_NORMAL
- en: When you configure the `PS1` parameter from the command-line, the new settings
    will disappear as soon as you either log out from the machine or close the terminal
    window. To make the setting permanent, just edit the `.bashrc` file that’s in
    your home directory. Add the `export PS1="[\d \t \u@\h \w]$ "` line to the end
    of the file, and you’ll see the new prompt the next time you either log into the
    machine or open a new terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: There are still a lot more ways to customize the command prompt that I haven’t
    shown you. For a more complete list, see the reference that I provided in the
    *Further Reading* section. Also, note that I’ve only covered how to do this with
    `bash`, because `zsh` uses different command prompt parameters. (I’ll show you
    all about that in *Chapter 22, Using the Z Shell*.)
  prefs: []
  type: TYPE_NORMAL
- en: I can read your mind, and can see that you’re wondering what environmental variables
    have to do with shell scripting. Well, it’s just that sometimes you’ll need to
    have your script perform a specific action that depends upon the value of a specific
    environmental variable. For example, let’s say that you only want the script to
    run for the root user, and not for any unprivileged user. Since we know that the
    user identification number for the root user is `0`, we can write code that allows
    the script to run if the `UID` variable is set to `0`, and to prevent the script
    from running if the `UID` is set to anything other than `0`.
  prefs: []
  type: TYPE_NORMAL
- en: And by the way, I apologize if it seems a bit creepy that I can read your mind.
  prefs: []
  type: TYPE_NORMAL
- en: That does it for our introduction to environmental variables. Let’s now take
    a quick look at programming variables.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Programming Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it’s necessary to define variables to use in your scripts. You can
    define, view, and unset these variables as needed for your programming needs.
    Note that although the system will allow you to create programming variable names
    with all upper-case letters, it’s considered bad form to do so. Best practice
    is to always name your programming variables with lower-case letters, so that
    you won’t risk accidentally overwriting the value of an environmental variable
    with the same name. (Of course, you won’t cause any long-term damage by overwriting
    an environmental variable. But, why risk overwriting an environmental variable
    that you might need to use later in your script?)
  prefs: []
  type: TYPE_NORMAL
- en: 'To show how this all works, let’s create some programming variables from the
    command-line, and view the assigned values. First, we’ll create the `car` variable
    and assign to it the value `Ford`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the value of a variable, use `echo`, and precede the name of the variable
    with a `$`, just as we did with the environmental variables. Now, let’s open a
    child shell with the `bash` command, to see if we can still view the value of
    this `car` variable, and then exit back to the parent shell, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can’t see the value of `car` this time, because we didn’t **export** the
    variable. Exporting the variable will permit a child shell to access the variable.
    As you might have guessed, we’ll use the `export` command to do this, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This time, we see that the value of `car` now shows up in the child shell.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be working with variables throughout the rest of this book, so you’ll
    be learning a lot more about how to use them. For now though, this quick introduction
    is enough.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s do some plumbing.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **pipe** will take the output of one command and use it as the input for another
    command. It’s represented by the `|` symbol, which is on the same key as the backslash.
    You’ll often invoke a simple **pipeline** from the command-line for various purposes.
    But, you can also create very complex, multi-stage pipelines for your shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21693_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Creating a pipeline. Note that stdout is short for Standard Output,
    and stdin is short for Standard Input.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this can be useful, let’s say that you want to look at a listing
    of all files in a certain directory. But, there are so many files that the output
    would scroll off of the screen where you’d never be able to see it. You can solve
    the problem by taking the output of the `ls` command and using it as the input
    for the `less` command. It would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `ls -l` listing will open in the `less` pager, so that you can scroll through
    the output or perform searches for particular text strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s say that I only want to see files with the text string `alma` in
    their filenames. That’s easy enough. I’ll just pipe the `ls -l` output into `grep`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s say that I don’t want to see the filenames, but I do want to know
    how many files there are. I’ll just add another pipe stage, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `wc -l` command counts the number of lines in the output, which in this
    case tells us how many files I have that contain the text string `alma` in their
    filenames.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not familiar with `grep`, just understand for now that it’s a utility
    that can search for either specific text strings or for text patterns. It can
    search through text files without you having to open them, or it can search for
    text strings or patterns in the output that you would pipe into it from another
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, I’ve shown you some simple examples of how to create pipelines from the
    command-line. Now, I want to show you something that I hope you’ll *never* do.
    This involves using the `cat` utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that you can do with `cat` is to dump the contents of a text file
    to your screen. It’s mainly useful for viewing small files, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use `cat` to view a large file, the output will scroll off of the screen
    where you might not be able to view it. I have seen cases where somebody would
    still use `cat` to dump the file, and then pipe the output into `less`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve also seen people pipe `cat` output into `grep` to search for a text string,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these examples work, but it requires less typing to just use either
    `less` or `grep` without `cat`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In other words, although piping `cat` output into other utilities does work,
    it’s less efficient than just directly using the other utilities, and can make
    your scripts a bit less efficient and a bit harder to read. And, as a real-life
    lover of cats, it always bothers me to see someone engaging in `cat` abuse.
  prefs: []
  type: TYPE_NORMAL
- en: What I’ve shown you here is just scratching the surface of what you can do with
    pipelines. A major reason why Linux and Unix administrators need to create shell
    scripts is to automate the extraction and formatting of information from either
    text files or the output of certain programs. Doing that often requires very long,
    complex, multi-stage pipelines with a different extraction or formatting utility
    at each stage. Before you can start doing that, you’ll need to learn how to use
    these utilities, which you’ll begin doing in *Chapter 6, Text Stream Filters –
    Part 1*. And, before we can get to that, we need to cover a few more basic functions
    of `bash` and `zsh`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this chapter has been rather short, we covered a good bit of important
    information. We began by looking at environmental variables, showing how to modify
    one of them, and explaining why you might need to use environmental variables
    in your shell scripts. Next, we covered programming variables, explaining how
    to create and export them. Finally, we did a bit of plumbing work by creating
    some pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll cover the concept of input/output redirection. I’ll
    see you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following metacharacters allows you to view the assigned value
    of a variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`*`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`%`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`^`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following statements is true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s perfectly correct to use either all upper-case or all lower-case letters
    to create your programming variable names.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Variable names are not case-sensitive.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You should always use upper-case letters to create the names of programming
    variables.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You should always use lower-case letters to create the names of programming
    variables.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you cause a child shell to recognize a variable that you created in
    the parent shell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the child shell, import the variable from the parent shell.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the parent shell, use the `export` keyword when creating the variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You can’t, because the parent shell and child shell are isolated from each other.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The child shell and the parent shell always share variables by default.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of these metacharacters would you use to take the output of one command
    and use it at the input of another command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`|`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`&`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`%`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How to Change/Set up bash custom prompt (PS1) in Linux: [https://www.cyberciti.biz/tips/howto-linux-unix-bash-shell-setup-prompt.html](https://www.cyberciti.biz/tips/howto-linux-unix-bash-shell-setup-prompt.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Count Files in a Directory in Linux?: [https://www.linuxjournal.com/content/how-count-files-directory-linux](https://www.linuxjournal.com/content/how-count-files-directory-linux)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Linux experts, and the author himself.
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10596186092701843.png)'
  prefs: []
  type: TYPE_IMG
- en: Leave a Review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoy it!
    Your feedback is invaluable and helps us improve and grow. Once you've completed
    reading it, please take a moment to leave an Amazon review; it will only take
    a minute, but it makes a big difference for readers like you.
  prefs: []
  type: TYPE_NORMAL
- en: Scan the QR code below to receive a free ebook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/review.png)'
  prefs: []
  type: TYPE_IMG
