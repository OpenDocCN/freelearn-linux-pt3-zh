- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Learning about Toolchains
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解工具链
- en: The toolchain is the first element of embedded Linux and the starting point
    of your project. You will use it to compile all the code that will run on your
    device. The choices you make at this early stage will have a profound impact on
    the final outcome.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链是嵌入式 Linux 的第一个元素，也是你项目的起点。你将使用它来编译将在设备上运行的所有代码。你在这个早期阶段做出的选择将对最终结果产生深远的影响。
- en: Your toolchain should be capable of making effective use of your hardware by
    using the optimum instruction set for your processor. It should support the languages
    that you require and have a solid implementation of the **Portable Operating System
    Interface** (**POSIX**) and other system interfaces.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你的工具链应能够通过使用适合你处理器的最佳指令集，充分发挥硬件的效能。它应支持你所需的语言，并且具备**可移植操作系统接口**（**POSIX**）和其他系统接口的稳固实现。
- en: Your toolchain should remain constant throughout the project. In other words,
    once you have chosen your toolchain, it is important to stick with it. Changing
    compilers and development libraries inconsistently during a project will lead
    to subtle bugs. That being said, it is still best to update your toolchain when
    security flaws or bugs are found.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你的工具链在整个项目中应该保持不变。换句话说，一旦选择了工具链，重要的是要坚持使用它。在项目中不一致地更改编译器和开发库将导致微妙的错误。尽管如此，还是建议在发现安全漏洞或错误时更新工具链。
- en: Obtaining a toolchain can be as simple as downloading and installing a TAR file
    or it can be as complex as building the whole thing from source code. In this
    chapter, we take the first approach. Later on, in [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110),we
    will switch to using the toolchain generated by the build system. This is the
    more usual means of obtaining a toolchain.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 获取工具链可以像下载并安装一个 TAR 文件那么简单，或者像从源代码构建整个工具链那样复杂。在本章中，我们采用第一种方法。稍后，在[*第六章*](Chapter_04.xhtml#_idTextAnchor110)中，我们将切换到使用构建系统生成的工具链。这是获取工具链的更常见方法。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing toolchains
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍工具链
- en: Finding a toolchain
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找工具链
- en: Anatomy of a toolchain
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具链的构成
- en: Linking with libraries ‒ static and dynamic linking
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与库的链接 ‒ 静态和动态链接
- en: Art of cross-compiling
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉编译的艺术
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: I recommend using Ubuntu 24.04 or a later LTS release since the exercises in
    this chapter were all tested against that Linux distro at the time of writing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐使用 Ubuntu 24.04 或更高版本的 LTS 版本，因为本章中的练习是在撰写时对该 Linux 发行版进行过测试的。
- en: 'Here is the command to install all the packages required for this chapter on
    Ubuntu 24.04 LTS:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 Ubuntu 24.04 LTS 上安装本章所需的所有软件包的命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter02](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter02).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在本书的 GitHub 仓库的章节文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter02](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter02)。
- en: Introducing toolchains
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍工具链
- en: 'A toolchain is a set of tools that compiles source code into executables that
    can run on your target device. It includes a compiler, a linker, and runtime libraries.
    You need a toolchain to build the other three elements of an embedded Linux system:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链是一组将源代码编译成可在目标设备上运行的可执行文件的工具。它包括一个编译器、一个链接器和运行时库。你需要一个工具链来构建嵌入式 Linux 系统的其他三个元素：
- en: Bootloader
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动加载程序
- en: Kernel
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核
- en: Root filesystem
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件系统
- en: It has to be able to compile code written in C, C++, and an assembly language
    since these are the languages used in the base open source packages.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须能够编译用 C、C++ 和汇编语言编写的代码，因为这些是基础开源包中使用的语言。
- en: Usually, toolchains for Linux are based on components from the GNU project and
    that is still true at the time of writing. However, over the past few years, the
    **Clang** compiler and the associated **Low-Level Virtual Machine** (**LLVM**)
    project have progressed to the point that LLVM is now a viable alternative to
    a GNU toolchain. One major distinction between LLVM and GNU-based toolchains is
    the licensing; LLVM has the Apache License v2.0 with LLVM Exceptions while GNU
    has the GPL.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Linux 的工具链是基于 GNU 项目中的组件的，到目前为止仍然如此。然而，在过去几年里，**Clang** 编译器和相关的 **低级虚拟机**（**LLVM**）项目已经取得了长足的进展，LLVM
    现在已成为 GNU 工具链的可行替代方案。LLVM 和基于 GNU 的工具链之间的一个主要区别在于许可证；LLVM 采用的是带有 LLVM 异常条款的 Apache
    2.0 许可证，而 GNU 则使用 GPL。
- en: There are some technical advantages to Clang as well, such as faster compilation,
    better diagnostics, and more support for the latest C and C++ standards. But **GCC**
    (**GNU C Compiler**) has the advantage of compatibility with the existing code
    base and support for a wider range of architectures and **Operating** **Systems**
    (**OS**). While it took some years to get there, Clang can now compile all the
    components needed for embedded Linux and is a viable alternative to GCC. To learn
    more, see [https://docs.kernel.org/kbuild/llvm.html](https://docs.kernel.org/kbuild/llvm.html).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 也有一些技术优势，比如更快的编译速度、更好的诊断信息以及对最新 C 和 C++ 标准的更好支持。但**GCC**（**GNU C 编译器**）在与现有代码库的兼容性以及对更广泛架构和**操作系统**（**OS**）的支持方面具有优势。虽然
    Clang 花费了几年时间才发展到现在的水平，但它现在可以编译嵌入式 Linux 所需的所有组件，并且是 GCC 的可行替代方案。欲了解更多信息，请参见[https://docs.kernel.org/kbuild/llvm.html](https://docs.kernel.org/kbuild/llvm.html)。
- en: There is a good description of how to use Clang for cross-compilation at [https://clang.llvm.org/docs/CrossCompilation.html](https://clang.llvm.org/docs/CrossCompilation.html).
    If you would like to use it as part of an embedded Linux build system, various
    people are working on using Clang with Buildroot and The Yocto Project. I will
    cover embedded build systems in [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110).
    Meanwhile, this chapter focuses on the GNU toolchain as it is still the most popular
    and mature toolchain for Linux.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用 Clang 进行交叉编译的详细说明可以在[https://clang.llvm.org/docs/CrossCompilation.html](https://clang.llvm.org/docs/CrossCompilation.html)找到。如果你希望将其作为嵌入式
    Linux 构建系统的一部分，很多人正在研究如何将 Clang 与 Buildroot 和 Yocto 项目结合使用。我将在[*第 6 章*](Chapter_04.xhtml#_idTextAnchor110)中介绍嵌入式构建系统。与此同时，本章专注于
    GNU 工具链，因为它仍然是 Linux 中最流行和成熟的工具链。
- en: 'A standard GNU toolchain consists of three main components:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 GNU 工具链包含三个主要组件：
- en: '**Binutils**: A set of binary utilities including the assembler and the linker.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Binutils**：一组二进制工具，包括汇编器和连接器。'
- en: '**GCC**: Compilers for C and other languages, which include C++, Objective-C,
    Objective-C++, Java, Fortran, Ada, Go, and D. They all use a common backend that
    produces assembler code that is fed to the GNU assembler.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GCC**：用于 C 和其他语言的编译器，包括 C++、Objective-C、Objective-C++、Java、Fortran、Ada、Go
    和 D。它们都使用一个通用的后端生成汇编代码，并将其交给 GNU 汇编器处理。'
- en: '**C library**: A standardized **Application Program Interface** (**API**) based
    on the POSIX specification, which is the main interface to the OS kernel for applications.
    There are several C libraries to consider, as we shall see later in this chapter.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C 库**：基于 POSIX 规范的标准化 **应用程序接口**（**API**），它是应用程序访问操作系统内核的主要接口。我们将在本章稍后讨论几种需要考虑的
    C 库。'
- en: Along with these, you will also need a copy of the Linux kernel headers. The
    kernel headers contain definitions and constants that are needed when accessing
    the kernel directly. You need the kernel headers to compile the C library, programs,
    and libraries. This **user space** code interacts indirectly with Linux devices,
    for example, to display graphics via the Linux frame buffer driver. This is in
    stark contrast to kernel modules/drivers inside **kernel space** with direct access
    to peripheral hardware.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，你还需要一份 Linux 内核头文件。内核头文件包含了访问内核时所需的定义和常量。你需要这些内核头文件来编译 C 库、程序和库。这些**用户空间**代码通过
    Linux 帧缓冲驱动与 Linux 设备间接交互，例如用来显示图形。这与直接访问外设硬件的**内核空间**中的内核模块/驱动程序形成鲜明对比。
- en: This is not simply a question of making a copy of the header files in the include
    directory of your kernel source code. Those headers are intended for use in the
    kernel only and contain definitions that will cause conflicts if used in their
    raw state to compile regular Linux applications. Instead, you will need to generate
    a set of sanitized kernel headers, which I have illustrated in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是将内核源代码的 include 目录中的头文件复制一遍的问题。这些头文件仅用于内核，它们包含的定义如果直接用于编译常规的 Linux 应用程序，会导致冲突。因此，你需要生成一组经过清理的内核头文件，我在[*第
    5 章*](Chapter_05.xhtml#_idTextAnchor138)中做了说明。
- en: When compiling for user space, the kernel headers do not need to be generated
    from the exact version of Linux you are going to be running on. Since the kernel
    interfaces are always backward compatible, it is only necessary that the headers
    are from a kernel that is the same as or older than the one you are using on the
    target.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在为用户空间编译时，内核头文件不需要来自你将要运行的 Linux 的确切版本。由于内核接口始终向后兼容，只要头文件来自与目标上运行的内核版本相同或更早的内核版本，就足够了。
- en: Most people consider the **GNU Debugger** (**GDB**) to be part of the toolchain
    as well since it is also normally built at this point. When building a cross compiler,
    you also need to build a corresponding cross debugger to debug code on the target
    remotely from your host machine. I will talk about GDB in [*Chapter 19*](Chapter_19.xhtml#_idTextAnchor611).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人认为**GNU 调试器**（**GDB**）也是工具链的一部分，因为它通常也是在这一点上构建的。当构建交叉编译器时，你还需要构建一个相应的交叉调试器，以便从主机机器远程调试目标上的代码。我将在[*第
    19 章*](Chapter_19.xhtml#_idTextAnchor611)中讲解 GDB。
- en: Now that we’ve talked about kernel headers and seen what the components of a
    toolchain are, let’s look at the different types of toolchains.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了内核头文件并了解了工具链的组成部分，让我们来看一下不同类型的工具链。
- en: Types of toolchains
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具链的类型
- en: 'For our purposes, there are two types of toolchains:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，工具链有两种类型：
- en: '**Native**: A toolchain that runs on the same type of system (or even the actual
    system) as the programs it generates. This is usually the case for desktops and
    servers, and it is becoming popular on certain classes of embedded devices. For
    example, the Raspberry Pi 4 running Debian for ARM has self-hosted native compilers.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地**：一种在与其生成的程序相同类型的系统（甚至是实际系统）上运行的工具链。这通常适用于桌面和服务器，并且在某些类型的嵌入式设备上越来越受欢迎。例如，运行
    Debian ARM 版本的 Raspberry Pi 4 就有自托管的本地编译器。'
- en: '**Cross**: A toolchain that runs on a different type of system than the target
    allowing development to be done on a fast desktop PC and then loaded onto the
    embedded target for execution.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉**：一种在不同类型的系统上运行的工具链，它允许在快速的桌面 PC 上进行开发，然后将代码加载到嵌入式目标上执行。'
- en: Almost all embedded Linux development is done using a cross-development toolchain.
    This is partly because most embedded devices are not well suited for development
    since they lack computing power, memory, and storage, but also because it keeps
    the host and target environments separate. The latter point is especially important
    when the host and the target are using the same architecture, x86_64, for example.
    In this case, it is tempting to compile natively on the host and simply copy the
    binaries to the target.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有嵌入式 Linux 开发都是使用交叉开发工具链完成的。这部分是因为大多数嵌入式设备不适合开发，因为它们缺乏计算能力、内存和存储空间，但也因为它可以保持主机和目标环境的分离。当主机和目标使用相同的架构时（例如，x86_64），这一点尤其重要。在这种情况下，很容易在主机上本地编译并直接将二进制文件复制到目标上。
- en: This works up to a point. However, it is likely that the host distribution will
    receive updates more often than the target or that different engineers building
    code for the target will have slightly different versions of the host development
    libraries. Over time, the development and target systems will diverge. You can
    upgrade the toolchain if you ensure that the host and the target build environments
    are in lockstep with each other. However, a much better approach is to keep the
    host and the target separate, and a cross toolchain is the way to do that.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一定的效果。然而，主机操作系统的分发版可能会比目标系统更频繁地收到更新，或者为目标系统构建代码的不同工程师可能会使用稍微不同版本的主机开发库。随着时间的推移，开发系统和目标系统将会出现分歧。如果你确保主机和目标的构建环境保持一致，你可以升级工具链。然而，更好的方法是将主机和目标分开，并使用交叉工具链来实现这一点。
- en: There is a counterargument in favor of native development. Cross-development
    creates the burden of having to cross-compile all the libraries and tools that
    you need for your target. We will see later, in the section titled *Art of cross-compiling*,
    that cross-development is not always simple because many open source packages
    are not designed to be built in this way.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种反对本地开发的观点。交叉开发需要跨平台编译所有你需要的库和工具。这一点我们将在稍后的章节中讨论，名为*交叉编译艺术*，交叉开发并不总是简单的，因为许多开源包并不是为这种方式的构建而设计的。
- en: Integrated build tools like Buildroot and The Yocto Project help by encapsulating
    the rules for cross-compiling a range of packages needed by most embedded systems.
    But if you want to compile lots of additional packages, then it is better to compile
    them natively. For example, building a Debian distribution for the Raspberry Pi
    4 or BeaglePlay using a cross compiler is very hard. Instead, they are natively
    compiled.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 像Buildroot和Yocto项目这样的集成构建工具通过封装交叉编译大多数嵌入式系统所需的软件包规则来提供帮助。但是，如果你想编译大量的附加包，那么最好是本地编译它们。例如，使用交叉编译器为Raspberry
    Pi 4或BeaglePlay构建Debian发行版非常困难。相反，它们是本地编译的。
- en: Creating a native build environment from scratch is not easy. You still need
    a cross compiler at first to create the native build environment on the target,
    which you then use to build the packages. Then, to perform the native build in
    a reasonable amount of time, you need a build farm of well-provisioned target
    boards or **Quick Emulator** (**QEMU**) to emulate the target.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始创建本地构建环境并不容易。你仍然需要首先使用交叉编译器在目标上创建本地构建环境，然后用它来构建软件包。接着，为了在合理的时间内完成本地构建，你需要一组配置良好的目标板或**快速模拟器**（**QEMU**）来模拟目标。
- en: In this chapter, we will focus on a pre-built cross-compiler environment that
    is relatively easy to set up and administer. We will start by looking at what
    distinguishes one target CPU architecture from another.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注一个相对容易设置和管理的预构建交叉编译器环境。我们将首先看看是什么区分了不同的目标CPU架构。
- en: CPU architectures
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU架构
- en: 'The toolchain must be built according to the capabilities of the target CPU,
    which includes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链必须根据目标CPU的能力进行构建，这包括：
- en: '**CPU architecture**: ARM, RISC-V, PowerPC, **Microprocessor without Interlocked
    Pipelined Stages** (**MIPS**), or x86_64.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU架构**：ARM、RISC-V、PowerPC、**无互锁流水线阶段的微处理器**（**MIPS**）或x86_64。'
- en: '**Big- or little-endian operation**: Some CPUs can operate in both modes, but
    the machine code is different for each.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大端或小端操作**：一些CPU可以在两种模式下操作，但机器代码对于每种模式是不同的。'
- en: '**Floating point support**: Not all versions of embedded processors implement
    a hardware floating point unit. In these cases, the toolchain must be configured
    to call a software floating point library instead.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点支持**：并不是所有版本的嵌入式处理器都实现了硬件浮点单元。在这些情况下，工具链必须配置为调用软件浮点库。'
- en: '**Application Binary Interface (ABI)**: The calling convention used for passing
    parameters between function calls.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用二进制接口（ABI）**：用于在函数调用之间传递参数的调用约定。'
- en: 'With many architectures, the ABI is constant across the family of processors.
    One notable exception is ARM. The ARM architecture transitioned to the **Extended
    Application Binary Interface** (**EABI**) in the late 2000s resulting in the previous
    ABI being named the **Old Application Binary Interface** (**OABI**). While the
    OABI is now obsolete, you continue to see references to EABI. Since then, the
    EABI has split into three based on the way floating point parameters are passed:
    softfloat, softfp, and hardfp.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多架构，ABI在处理器家族中是常见的。一个显著的例外是ARM。ARM架构在2000年代后期过渡到**扩展应用二进制接口**（**EABI**），这导致了之前的ABI被称为**旧应用二进制接口**（**OABI**）。尽管OABI现在已经过时，但你仍然会看到对EABI的引用。从那时起，EABI根据浮点参数的传递方式分为三种：softfloat、softfp和hardfp。
- en: The original EABI uses software emulation (softfloat) or general-purpose integer
    registers (softfp), while the newer **Extended Application Binary Interface Hard-Float**
    (**EABIHF**) uses floating point registers (hardfp). The original EABI’s softfloat
    and softfp modes are ABI-compatible. In **softfloat** mode, the compiler does
    not generate **Floating Point Unit** (**FPU**) instructions. All floating point
    operations are done in software, resulting in suboptimal performance. In **softfp**
    mode, float values are passed via the stack or integer registers for better performance.
    EABIHF is significantly faster at floating point operations since **hardfp** mode
    removes the need for copying between integer and floating point registers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 EABI 使用软件仿真（softfloat）或通用整数寄存器（softfp），而较新的 **扩展应用程序二进制接口硬浮点**（**EABIHF**）使用浮点寄存器（hardfp）。原始的
    EABI 的 softfloat 和 softfp 模式是 ABI 兼容的。在 **softfloat** 模式下，编译器不会生成 **浮点单元**（**FPU**）指令。所有浮点运算都在软件中完成，这会导致性能不佳。在
    **softfp** 模式下，浮动值通过栈或整数寄存器传递，以提高性能。由于 **hardfp** 模式省去了整数和浮点寄存器之间的拷贝，EABIHF 在浮点运算方面明显更快。
- en: The downside of EABIHF is that hardfp mode is incompatible with CPUs that do
    not have a floating point unit. The choice then is between two incompatible ABIs.
    You cannot mix and match the two, so you must decide at this stage.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: EABIHF 的缺点是 hardfp 模式与没有浮点单元的 CPU 不兼容。此时，你只能在两个不兼容的 ABI 之间进行选择。不能混合使用这两种模式，所以你必须在此时做出决定。
- en: 'GNU adds a prefix to the name of each tool in the toolchain that identifies
    the various combinations that can be generated. This prefix consists of a tuple
    of three or four components separated by dashes, as described here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: GNU 为工具链中每个工具的名称添加一个前缀，用于标识可以生成的各种组合。这个前缀由三到四个由短横线分隔的组件组成，如下所示：
- en: '**CPU**: The CPU architecture such as ARM, RISC-V, PowerPC, MIPS, or x86_64\.
    If the CPU has both endian modes, they may be differentiated by adding `el` for
    little-endian or `eb` for big-endian. Good examples are little-endian MIPS (`mipsel`)
    and big-endian ARM (`armeb`).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**：例如 ARM、RISC-V、PowerPC、MIPS 或 x86_64 等 CPU 架构。如果 CPU 支持两种字节序模式，它们可能通过添加
    `el` 来表示小端（little-endian）或 `eb` 来表示大端（big-endian）。例如小端 MIPS（`mipsel`）和大端 ARM（`armeb`）就是很好的例子。'
- en: '**Vendor**: Identifies the provider of the toolchain. Examples include `buildroot`,
    `poky`, and just `unknown`. Sometimes, it is left out altogether.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**厂商**：标识工具链的提供者。例如，`buildroot`、`poky` 或者简单的 `unknown`。有时，它可能完全不显示。'
- en: '**OS**: For our purposes, it is always `linux`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**：就我们而言，它总是 `linux`。'
- en: '**User space**: A name for the user space component, which might be `gnu` or
    `musl`. The ABI may be appended here as well. So, for ARM toolchains, you may
    see `gnueabi`, `gnueabihf`, `musleabi`, or `musleabihf`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户空间**：用户空间组件的名称，可能是 `gnu` 或 `musl`。这里也可以附加 ABI。所以，对于 ARM 工具链，你可能会看到 `gnueabi`、`gnueabihf`、`musleabi`
    或 `musleabihf`。'
- en: 'You can find the tuple used when building the toolchain by using the `-dumpmachine`
    option of `gcc`. For example, you may see the following on the host computer:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `gcc` 的 `-dumpmachine` 选项来找到构建工具链时使用的元组。例如，在主机计算机上，你可能会看到以下内容：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This tuple indicates a CPU of `x86_64`, a kernel of `linux`, and a user space
    of `gnu`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元组表示的是一个 `x86_64` CPU，一个 `linux` 内核和一个 `gnu` 用户空间。
- en: '**IMPORTANT NOTE**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: When a native compiler is installed on a machine it is normal to create links
    to each of the tools in the toolchain with no prefixes so that you can call the
    C compiler with the `gcc` command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当在机器上安装了本地编译器时，通常会创建工具链中每个工具的链接，且不带前缀，这样你就可以通过 `gcc` 命令调用 C 编译器。
- en: 'Here is an example using a cross compiler:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用交叉编译器的一个示例：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This tuple indicates a CPU of little-endian MIPS, an `unknown` vendor, a kernel
    of `linux`, and a user space of `gnu`. Your choice of user space (`gnu` or `musl`)
    determines which C library (glibc or musl) your programs are linked with.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元组表示的是一个小端 MIPS CPU，`unknown` 的厂商，一个 `linux` 内核和 `gnu` 用户空间。你选择的用户空间（`gnu`
    或 `musl`）决定了程序链接的 C 库（glibc 或 musl）。
- en: Choosing the C library
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择 C 库
- en: 'The programming interface to the Unix OS is defined in the C language in adherence
    to POSIX standards. The **C library** is the implementation of that interface.
    It is the gateway to the kernel for Linux programs. Even if you are writing programs
    in another language like Go or Python, the respective runtime support libraries
    will eventually have to call the C library, as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 操作系统的编程接口是用 C 语言定义的，遵循 POSIX 标准。**C 库** 就是该接口的实现。它是 Linux 程序通向内核的门道。即使你用
    Go 或 Python 等其他语言编写程序，相应的运行时支持库最终也会调用 C 库，如下所示：
- en: '![Figure 2.1 – C library](img/B18466_02_01.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – C 库](img/B18466_02_01.png)'
- en: Figure 2.1 – C library
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – C 库
- en: Whenever the C library needs the services of the kernel, it will use the kernel
    system call interface to transition between user space and kernel space. It is
    possible to bypass the C library by making the kernel system calls directly but
    that is a lot of trouble and almost never necessary.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 C 库需要内核服务时，它将使用内核系统调用接口在用户空间和内核空间之间进行切换。虽然可以通过直接进行内核系统调用来绕过 C 库，但那样做既麻烦又几乎没有必要。
- en: 'There are several C libraries to choose from. The main options are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种 C 库可供选择。主要选项如下：
- en: '**glibc**: This is the standard GNU C library available at [https://gnu.org/software/libc/](https://gnu.org/software/libc/).
    It is big and, until recently, not very configurable, but it is the most complete
    implementation of the POSIX API. The license is LGPL 2.1.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**glibc**：这是标准的 GNU C 库，网址是 [https://gnu.org/software/libc/](https://gnu.org/software/libc/)。它较大，直到最近才变得更加可配置，但它是
    POSIX API 最完整的实现。许可证是 LGPL 2.1。'
- en: '**musl libc**: This is comparatively new but has been gaining a lot of attention
    as a small and standards-compliant alternative to glibc. It is a good choice for
    systems with a limited amount of RAM and storage. It has an MIT license and is
    available at [https://musl.libc.org](https://musl.libc.org).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**musl libc**：这是一个相对较新的库，但作为一个小巧且符合标准的 glibc 替代品，它已经获得了很多关注。它是内存和存储有限的系统的好选择。它采用
    MIT 许可证，并且可以在 [https://musl.libc.org](https://musl.libc.org) 获得。'
- en: '**uClibc-ng**: *u* is really the Greek *mu* character, indicating that this
    is the microcontroller C library. uClibc-ng is available at [https://uclibc-ng.org](https://uclibc-ng.org).
    It was first developed to work with uClinux (Linux for microcontrollers without
    a memory management unit) but has since been adapted to be used with full Linux.
    The uClibc-ng library is a fork of the original uClibc project, which has fallen
    into disrepair. Both are licensed with LGPL 2.1.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**uClibc-ng**：*u* 实际上是希腊字母 *mu*，表示这是微控制器 C 库。uClibc-ng 可在 [https://uclibc-ng.org](https://uclibc-ng.org)
    获取。它最初是为 uClinux（没有内存管理单元的微控制器上的 Linux）开发的，但后来已被改编为可以与完整的 Linux 一起使用。uClibc-ng
    库是原 uClibc 项目的一个分支，而原项目已经停止维护。两者的许可证都是 LGPL 2.1。'
- en: 'So, which to choose? My advice is to use uClibc-ng only if you are using uClinux.
    If you have a very limited amount of storage or RAM, then musl libc is a good
    choice. Otherwise, use glibc, as shown in this flow chart:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，选择哪个呢？我的建议是，只有在使用 uClinux 时才使用 uClibc-ng。如果你的存储或内存非常有限，那么 musl libc 是一个不错的选择。否则，请使用
    glibc，如下图所示：
- en: '![Figure 2.2 – Choosing a C library](img/B18466_02_02.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 选择 C 库](img/B18466_02_02.png)'
- en: Figure 2.2 – Choosing a C library
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 选择 C 库
- en: Your choice of C library could limit your choice of toolchain since not all
    pre-built toolchains support all C libraries. Once you know what you need in a
    toolchain, where do you find one?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的 C 库可能会限制你选择的工具链，因为并非所有预构建的工具链都支持所有 C 库。一旦你确定了工具链的需求，你该去哪里找呢？
- en: Finding a toolchain
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找工具链
- en: 'You have three choices for your cross-development toolchain: you may find a
    ready-built toolchain that matches your needs, you can use the one generated by
    an embedded build tool (which is covered in [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110)),
    or you can create one yourself.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你有三个选择来获得交叉开发工具链：你可以找到一个已经构建好的工具链，与你的需求匹配；你可以使用一个由嵌入式构建工具生成的工具链（这部分内容在 [*第六章*](Chapter_04.xhtml#_idTextAnchor110)
    中介绍）；或者你可以自己创建一个。
- en: 'A pre-built cross toolchain is an attractive option in that you only have to
    download and install it. But you are limited to the configuration of that particular
    toolchain, and you are dependent on the person or organization you got it from.
    Most likely, it will be one of these:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预构建的交叉工具链是一个有吸引力的选择，因为你只需要下载并安装它。但你会受到该工具链配置的限制，并且依赖于提供该工具链的人或组织。它很可能是以下之一：
- en: An SoC or board vendor. Most vendors offer a Linux toolchain.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个SoC或板卡供应商。大多数供应商提供Linux工具链。
- en: A consortium dedicated to providing system-level support for a given architecture.
    For example, Linaro ([https://www.linaro.org](https://www.linaro.org)) has pre-built
    toolchains for the ARM architecture.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个致力于为特定架构提供系统级支持的联盟。例如，Linaro（[https://www.linaro.org](https://www.linaro.org)）为ARM架构提供了预构建的工具链。
- en: A third-party Linux tool vendor such as Siemens, Timesys, or Wind River.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个第三方Linux工具供应商，如西门子、Timesys或Wind River。
- en: The cross-tool packages for your desktop Linux distribution. For example, Debian-based
    distributions have packages for cross-compiling for ARM, PowerPC, and MIPS targets.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的桌面Linux发行版的交叉工具包。例如，基于Debian的发行版提供用于交叉编译ARM、PowerPC和MIPS目标的工具包。
- en: A binary SDK produced by one of the integrated embedded build tools. The Yocto
    Project has some available for download at [https://downloads.yoctoproject.org/releases/yocto/yocto-<version>/toolchain/](https://downloads.yoctoproject.org/releases/yocto/yocto-version/toolchain/).
    (replace `<version>` with a valid Yocto Project version such as `5.0` in the preceding
    URL).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由集成嵌入式构建工具生成的二进制SDK。Yocto项目提供了可以下载的工具链，下载链接为[https://downloads.yoctoproject.org/releases/yocto/yocto-<version>/toolchain/](https://downloads.yoctoproject.org/releases/yocto/yocto-version/toolchain/)。
    （请将`<version>`替换为有效的Yocto项目版本，如`5.0`）。
- en: A link from a forum that you can’t find anymore.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自一个论坛的链接，您现在已经找不到了。
- en: '**IMPORTANT NOTE**'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: In all these cases, you must decide whether the pre-built toolchain on offer
    meets your requirements. Does it use the C library you prefer? Will the provider
    give you updates for security fixes and bugs? Bear in mind my comments on support
    and updates from [*Chapter 1*](Chapter_01.xhtml#_idTextAnchor016). If your answer
    is no to any of these, then you should consider creating your own.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在所有这些情况下，您必须决定所提供的预构建工具链是否符合您的要求。它是否使用您偏好的C库？供应商是否会为您提供安全修复和错误修复的更新？请记住我在[*第1章*](Chapter_01.xhtml#_idTextAnchor016)中的评论，关于支持和更新。如果您的回答是否定的，那么您应该考虑自己构建工具链。
- en: Unfortunately, building a toolchain is no easy task. If you truly want to do
    the whole thing yourself, take a look at Cross Linux From Scratch ([https://trac.clfs.org](https://trac.clfs.org)).
    There, you will find step-by-step instructions on how to create each component.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，构建一个工具链并不是一件容易的事。如果您真的想自己做所有事情，可以查看Cross Linux From Scratch（[https://trac.clfs.org](https://trac.clfs.org)）。在这里，您将找到逐步指导，教您如何创建每个组件。
- en: A simpler alternative is to use crosstool-NG, which encapsulates the process
    into a set of scripts and has a menu-driven frontend. You still need a fair degree
    of knowledge though just to make the right choices.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简单的替代方法是使用crosstool-NG，它将构建过程封装成一组脚本，并具有菜单驱动的前端界面。然而，仅仅做出正确选择，您仍然需要一定程度的知识。
- en: It is simpler still to use a build system such as Buildroot or The Yocto Project
    since they generate a toolchain as part of the build process. This is my preferred
    solution, as we shall see in [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Buildroot或Yocto项目这样的构建系统会更简单，因为它们在构建过程中生成工具链。这是我首选的解决方案，正如我们将在[*第6章*](Chapter_04.xhtml#_idTextAnchor110)中看到的那样。
- en: You will need a working cross toolchain to complete the exercises in the next
    section. We will employ a pre-built toolchain from Bootlin. Bootlin’s toolchains
    are built using Buildroot.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要一个可用的交叉工具链才能完成下一节中的练习。我们将使用来自Bootlin的预构建工具链。Bootlin的工具链是使用Buildroot构建的。
- en: 'To download the pre-built cross toolchain needed for *Chapters 2* through *5*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下载预构建的交叉工具链，以便用于*第2章*至*第5章*：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To download the latest version of this toolchain, visit [https://toolchains.bootlin.com](https://toolchains.bootlin.com).
    Select *aarch64* for architecture and *glibc* for libc. Once these choices have
    been made, download the stable version of the toolchain.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载此工具链的最新版本，请访问[https://toolchains.bootlin.com](https://toolchains.bootlin.com)。选择架构为*aarch64*，选择libc为*glibc*。完成这些选择后，下载工具链的稳定版本。
- en: 'Install the pre-built toolchain on your Linux host machine by extracting and
    decompressing it to your home directory:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将预构建的工具链提取并解压到您的主目录中，在您的Linux主机上安装工具链：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You will use this toolchain for the remainder of this chapter. Let’s start by
    looking at its internals.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用此工具链完成本章的其余部分。让我们首先看看它的内部结构。
- en: Anatomy of a toolchain
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具链的结构
- en: To get an idea of what is in a typical toolchain, let’s examine the toolchain
    you downloaded from Bootlin. The examples use the aarch64 toolchain, which has
    the prefix `aarch64-buildroot-linux-gnu`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解一个典型的工具链中包含了什么，让我们看看你从Bootlin下载的工具链。示例中使用的是aarch64工具链，它的前缀是`aarch64-buildroot-linux-gnu`。
- en: 'The aarch64 toolchain is in the directory `~/aarch64--glibc--stable-2024.02-1/bin`.
    In there, you will find the cross compiler `aarch64-buildroot-linux-gnu-gcc`.
    To make use of it, you need to add the directory to your path using the following
    command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: aarch64工具链位于`~/aarch64--glibc--stable-2024.02-1/bin`目录下。在这个目录中，你会找到交叉编译器`aarch64-buildroot-linux-gnu-gcc`。要使用它，你需要通过以下命令将该目录添加到你的路径中：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you downloaded a different version, make sure to replace `2024.02-1` with
    the actual version of the stable toolchain.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你下载了不同的版本，请确保将`2024.02-1`替换为稳定工具链的实际版本。
- en: 'Now you can take a simple `helloworld` program, which, in the C language, looks
    like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以编写一个简单的`helloworld`程序，在C语言中，它是这样的：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And compile it like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后像这样编译：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Confirm that it has been cross-compiled by using the `file` command to print
    the type of the file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`file`命令打印文件类型，确认它是否已被交叉编译：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that you’ve verified that your cross compiler works, let’s take a closer
    look at it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经验证了交叉编译器的工作情况，让我们更仔细地看一下它。
- en: Finding out about your cross compiler
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解你的交叉编译器
- en: 'Imagine that you have just received a toolchain and that you would like to
    know more about how it was configured. You can find out a lot by querying `gcc`.
    For example, to find the version, you use `--version`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你刚刚收到了一个工具链，并且你想了解它是如何配置的。你可以通过查询`gcc`来获取很多信息。例如，要查看版本，可以使用`--version`：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To find how it was configured, use `-v`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看它是如何配置的，请使用`-v`：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is a lot of output there but the interesting things to note are:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 输出内容很多，但需要注意的有以下几点：
- en: '`--with-sysroot`=`/builds/buildroot.org/toolchains-builder/build/aarch64--glibc--stable-2024.02-1/aarch64-buildroot-linux-gnu/sysroot`:
    The location of the `sysroot` directory at build time. See the following section
    for an explanation.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--with-sysroot`=`/builds/buildroot.org/toolchains-builder/build/aarch64--glibc--stable-2024.02-1/aarch64-buildroot-linux-gnu/sysroot`：构建时`sysroot`目录的位置。请参阅以下部分以了解详细说明。'
- en: '`--enable-languages=c,c++,fortran`: Both the C and C++ languages are enabled.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--enable-languages=c,c++,fortran`：启用C语言、C++语言和Fortran语言。'
- en: '`--with-cpu=cortex-a53`: Generates code for an ARM Cortex-A53 core.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--with-cpu=cortex-a53`：为ARM Cortex-A53核心生成代码。'
- en: '`--enable-threads`: Enables POSIX threads.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--enable-threads`：启用POSIX线程。'
- en: 'These are the default settings for the compiler. You can override most of them
    on the `gcc` command line. For example, if you want to compile for a different
    CPU, you can override the configured setting `--with-cpu` by adding `-mcpu=cortex-a72`
    to the command line, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是编译器的默认设置。你可以在`gcc`命令行上覆盖其中的大部分。例如，如果你想为不同的CPU进行编译，可以通过在命令行添加`-mcpu=cortex-a72`来覆盖已配置的`--with-cpu`设置，如下所示：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can print out the range of architecture-specific options available using
    `--target-help`, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`--target-help`打印出可用的架构特定选项，方法如下：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You may be wondering if it matters that you get the configuration exactly right
    at this point since you can always change it. The answer depends on the way you
    anticipate using it. If you plan to create a new toolchain for each target, then
    it makes sense to set everything up at the beginning because it will reduce the
    risks of getting it wrong later.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，是否在此时完全正确地配置它很重要，因为你总是可以稍后更改它。答案取决于你预计如何使用它。如果你计划为每个目标创建一个新的工具链，那么一开始就设置好所有内容是有意义的，因为这样可以减少以后出错的风险。
- en: I call this the Buildroot philosophy, which we will revisit in [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110).
    If, on the other hand, you want to build a toolchain that is generic, and you
    are prepared to provide the correct settings when you build for a particular target,
    then you should make the base toolchain generic, which is the way The Yocto Project
    handles things.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我称之为Buildroot哲学，我们将在[*第6章*](Chapter_04.xhtml#_idTextAnchor110)中再次讨论。如果你想构建一个通用的工具链，并且准备在为特定目标构建时提供正确的设置，那么你应该使基础工具链通用，这也是Yocto项目处理事务的方式。
- en: Now that we’ve seen the location of the `sysroot` directory at build time, let’s
    look inside the default `sysroot` directory installed on your host machine.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到在构建时`sysroot`目录的位置，让我们来看一下安装在主机上的默认`sysroot`目录的内容。
- en: sysroot, library, and header files
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sysroot、库和头文件
- en: 'The toolchain `sysroot` directory contains subdirectories for libraries, header
    files, and other configuration files. It can be set when the toolchain is configured
    through `--with-sysroot=` or it can be set on the command line using `--sysroot=`.
    You can see the location of the default `sysroot` by using `-print-sysroot`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链的`sysroot`目录包含库、头文件和其他配置文件的子目录。它可以在配置工具链时通过`--with-sysroot=`设置，或者可以在命令行中使用`--sysroot=`设置。你可以通过使用`-print-sysroot`查看默认`sysroot`的位置：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will find the following subdirectories in `sysroot`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在`sysroot`中找到以下子目录：
- en: '`lib`: Contains the shared objects for the C library and the dynamic linker/loader
    `ld-linux`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib`：包含C库的共享对象和动态链接器/加载器`ld-linux`。'
- en: '`usr/lib`: Contains the static library archive files for the C library and
    any other libraries that may be subsequently installed'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usr/lib`：包含C库的静态库归档文件以及可能随后安装的其他库。'
- en: '`usr/include`: Contains the headers for all the libraries'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usr/include`：包含所有库的头文件。'
- en: '`usr/bin`: Contains the utility programs that run on the target such as the
    `ldd` command'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usr/bin`：包含在目标设备上运行的实用程序，如`ldd`命令。'
- en: '`usr/share`: Used for localization and internationalization'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usr/share`：用于本地化和国际化。'
- en: '`sbin`: Provides the `ldconfig` utility that is used to optimize library loading
    paths'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sbin`：提供用于优化库加载路径的`ldconfig`工具。'
- en: Some of these are needed on the development host to compile programs and others,
    like the shared libraries and `ld-linux`, are needed on the target at runtime.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具中，有些在开发主机上用于编译程序，而其他工具，如共享库和`ld-linux`，在目标设备运行时需要。
- en: Other tools in the toolchain
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具链中的其他工具
- en: 'Below is a list of commands to invoke the various other components of a GNU
    toolchain. Like `aarch64-buildroot-linux-gnu-gcc`, these tools are all located
    inside the `~/aarch64--glibc--stable-2024.02-1/bin/` directory that you added
    to your `PATH`. Here are brief descriptions of these tools:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是调用GNU工具链中各个其他组件的命令列表。像`aarch64-buildroot-linux-gnu-gcc`，这些工具都位于你添加到`PATH`中的`~/aarch64--glibc--stable-2024.02-1/bin/`目录中。以下是这些工具的简短描述：
- en: '`addr2line`: Converts program addresses into source code filenames and line
    numbers by reading the debug symbol tables in an executable file. It is very useful
    when decoding addresses printed out in a system crash report.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addr2line`：通过读取可执行文件中的调试符号表，将程序地址转换为源代码文件名和行号。在解码系统崩溃报告中打印的地址时非常有用。'
- en: '`ar`: An archive utility used to create static libraries.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ar`：用于创建静态库的归档工具。'
- en: '`as`: GNU assembler.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`as`：GNU汇编器。'
- en: '`c++filt`: Demangles C++ and Java symbols.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c++filt`：解码C++和Java符号。'
- en: '`cpp`: C preprocessor used to expand `#define`, `#include`, and other similar
    directives. You seldom need to use this by itself.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpp`：C预处理器，用于展开`#define`、`#include`和其他类似指令。你很少需要单独使用它。'
- en: '`elfedit`: Updates the ELF header of the ELF files.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elfedit`：更新ELF文件的ELF头。'
- en: '`g++`: GNU C++ frontend, which assumes that source files contain C++ code.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g++`：GNU C++前端，假设源文件包含C++代码。'
- en: '`gcc`: GNU C frontend, which assumes that source files contain C code.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcc`：GNU C前端，假设源文件包含C代码。'
- en: '`gcov`: Code coverage tool.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcov`：代码覆盖工具。'
- en: '`gdb`: GNU debugger.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gdb`：GNU调试器。'
- en: '`gprof`: Program profiling tool.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gprof`：程序分析工具。'
- en: '`ld`: GNU linker.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ld`：GNU链接器。'
- en: '`nm`: Lists symbols from object files.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nm`：列出目标文件中的符号。'
- en: '`objcopy`: Copies and translates object files.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objcopy`：复制和转换目标文件。'
- en: '`objdump`: Displays information from object files.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objdump`：显示目标文件中的信息。'
- en: '`ranlib`: Creates or modifies an index in a static library making the linking
    stage faster.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranlib`：在静态库中创建或修改索引，使链接阶段更快。'
- en: '`readelf`: Displays information about files in ELF object format.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readelf`：显示ELF对象格式文件的信息。'
- en: '`size`: Lists section sizes and the total size.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`：列出各个段的大小以及总大小。'
- en: '`strings`: Displays strings of printable characters in files.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strings`：显示文件中可打印字符的字符串。'
- en: '`strip`: Strips an object file of debug symbol tables, making it smaller. Typically,
    you would strip all the executable code that is put onto the target.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strip`：去除目标文件中的调试符号表，使其更小。通常，你会去除所有放置到目标上的可执行代码。'
- en: We will now switch gears from command-line tools and return to the topic of
    the C library.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将从命令行工具切换话题，回到C库的主题。
- en: Looking at the components of the C library
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看C库的组件
- en: 'The C library is not a single library file. It is composed of four main parts
    that together implement the POSIX API:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: C库不是单一的库文件。它由四个主要部分组成，这些部分共同实现了POSIX API：
- en: '`libc`: The main C library that contains the well-known POSIX functions such
    as `printf`, `open`, `close`, `read`, `write`, and so on'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libc`：主要的C库，包含众所周知的POSIX函数，如`printf`、`open`、`close`、`read`、`write`等'
- en: '`libm`: Contains math functions such as `cos`, `exp`, and `log`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libm`：包含数学函数，如`cos`、`exp`、`log`'
- en: '`libpthread`: Contains all the POSIX thread functions with names beginning
    with `pthread_`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libpthread`：包含所有以`pthread_`开头的POSIX线程函数'
- en: '`librt`: Has real-time extensions to POSIX including shared memory and asynchronous
    I/O'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`librt`：具有POSIX的实时扩展，包括共享内存和异步I/O'
- en: 'The first one, `libc`, is always linked in but the others must be explicitly
    linked with the `-l` option. The parameter to `-l` is the library name with `lib`
    stripped off. For example, a program that calculates a sine function by calling
    `sin()` would be linked with `libm` using `-lm`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个库`libc`总是被链接的，但其他库必须显式地使用`-l`选项进行链接。`-l`的参数是库名称，去掉`lib`前缀。例如，一个通过调用`sin()`来计算正弦函数的程序将使用`-lm`链接`libm`：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can verify which libraries have been linked in this or any other program
    by using the `readelf` command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`readelf`命令来验证该程序或任何其他程序已链接的库：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Shared libraries need a runtime linker, which you can expose using:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库需要一个运行时链接器，你可以通过以下方式暴露它：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is so useful that I have a script file named `list-libs`, which you will
    find in the book code archive in `MELD/list-libs`. It contains the following commands:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有用，以至于我有一个名为`list-libs`的脚本文件，你可以在书籍代码档案中的`MELD/list-libs`找到它。它包含以下命令：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There are other library files we can link to other than the four components
    of the C library. We will look at how to do that in the next section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除了C库的四个组成部分外，我们还可以链接其他库文件。我们将在下一节中讨论如何做到这一点。
- en: Linking with libraries – static and dynamic linking
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与库链接——静态链接和动态链接
- en: Any application you write for Linux, whether it be in C or C++, will be linked
    with the C library `libc`. This is so fundamental that you don’t even have to
    tell `gcc` or `g++` to do it because it always links `libc`. Other libraries that
    you may want to link with have to be explicitly named through the `-l` option.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你为Linux编写的任何应用程序，无论是C语言还是C++，都会与C库`libc`链接。这是如此基本，以至于你甚至不需要告诉`gcc`或`g++`去做，因为它总是会链接`libc`。而你可能希望链接的其他库，则需要通过`-l`选项显式指定。
- en: 'Library code can be linked in two different ways:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 库代码可以通过两种不同的方式进行链接：
- en: '**Statically**: This means that all the library functions your application
    calls and their dependencies are pulled from the library archive and bound into
    your executable.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态链接**：这意味着所有应用程序调用的库函数及其依赖项都从库文件中提取，并绑定到你的可执行文件中。'
- en: '**Dynamically**: This means that references to the library files and functions
    in those files are generated in the code but the actual linking is done dynamically
    at load time.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态链接**：这意味着代码中会生成对库文件和其中函数的引用，但实际的链接是在加载时动态完成的。'
- en: You will find the code for the examples that follow in the book code archive
    in `MELD/Chapter02/library`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书籍代码档案中的`MELD/Chapter02/library`找到接下来示例的代码。
- en: Static libraries
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态库
- en: Static linking is useful in a few circumstances. For example, if you are building
    a small system that consists of only BusyBox and some script files, it is simpler
    to link BusyBox statically and avoid having to copy the runtime library files
    and linker. The footprint will also be smaller because you only link in the code
    that your application uses rather than supplying the entire C library. Static
    linking is also useful if you need to run a program before the filesystem that
    holds the runtime libraries is available.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 静态链接在某些情况下非常有用。例如，如果你正在构建一个仅包含BusyBox和一些脚本文件的小型系统，将BusyBox静态链接会更简单，这样就避免了复制运行时库文件和链接器。由于你只链接应用程序使用的代码，而不是提供整个C库，二进制文件的体积也会更小。如果你需要在文件系统尚未可用时运行程序，静态链接也非常有用。
- en: 'You can link all the libraries statically by adding `-static` to the command
    line:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在命令行中添加`-static`来静态链接所有的库：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will note that the size of the binary increases dramatically:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，二进制文件的大小显著增加：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Static linking pulls code from a library archive usually named lib<name>.a.
    In the preceding case, it is libc.a, which is in <sysroot>/usr/lib:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 静态链接会从一个通常命名为lib<name>.a的库文件中提取代码。在前面的例子中，它是libc.a，位于<sysroot>/usr/lib目录下：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that the syntax `export SYSROOT=$(aarch64-buildroot-linux-gnu-gcc -print-sysroot)`
    places the path to the `sysroot` in the shell variable `SYSROOT`, which makes
    the example a little clearer.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，语法`export SYSROOT=$(aarch64-buildroot-linux-gnu-gcc -print-sysroot)`将`sysroot`的路径放入shell变量`SYSROOT`，这使得示例更加清晰。
- en: 'Creating a static library is as simple as creating an archive of object files
    using the `ar` command. If I have two source files named `test1.c` and `test2.c`
    (this exercise has no Git examples – you are expected to generate your own `test1.c`
    and `test2.c` files) and I want to create a static library named `libtest.a`,
    then I would do the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 创建静态库就像使用`ar`命令创建目标文件的归档一样简单。如果我有两个源文件`test1.c`和`test2.c`（此练习没有Git示例——你需要自己生成`test1.c`和`test2.c`文件），并且我想创建一个名为`libtest.a`的静态库，那么我会做以下操作：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The book’s Git repository contains source and makefiles to assist with the
    linking exercises that follow:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的Git仓库包含源代码和makefile，帮助进行后续的链接练习：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Compile the static `libtest.a` library:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 编译静态`libtest.a`库：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Compile `hello-arm.c` and link it with `libtest.a` to produce a hello-arm-static
    executable:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 编译`hello-arm.c`并将其与`libtest.a`链接，生成`hello-arm-static`可执行文件：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now let’s rebuild the same program using dynamic linking.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用动态链接重新构建相同的程序。
- en: Shared libraries
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享库
- en: A more common way to deploy libraries is as shared objects that are linked at
    runtime, which makes more efficient use of storage and system memory since only
    one copy of the code needs to be loaded. It also makes it easy to update the library
    files without having to relink all the programs that use them.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 部署库的更常见方法是将其作为共享对象在运行时链接，这样可以更高效地利用存储和系统内存，因为只需要加载一份代码副本。它还使得更新库文件变得更加容易，无需重新链接所有使用这些库的程序。
- en: 'The object code for a shared library must be position independent so that the
    runtime linker is free to locate it in memory at the next free address. To do
    this, add the `-fPIC` parameter to `gcc` and then link it using the `-shared`
    option:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库的目标代码必须是位置无关的，以便运行时链接器可以在内存中的下一个空闲地址处找到它。为此，向`gcc`添加`-fPIC`参数，然后使用`-shared`选项进行链接：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This creates the shared library `libtest.so`. To link an application with this
    library, you add `-ltest` just like you did for the static case, but this time,
    the code is not included in the executable. Instead, there is a reference to the
    library that the runtime linker will have to resolve.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成共享库`libtest.so`。要将应用程序与此库链接，你需要像静态链接一样添加`-ltest`，但这次代码不会被包含在可执行文件中。相反，会有一个对库的引用，运行时链接器需要解析该引用。
- en: 'Compile the shared `libtest.so` library:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 编译共享的`libtest.so`库：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Compile `hello-arm.c` and link it with `libtest.so` to produce a `hello-arm-shared`
    executable:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 编译`hello-arm.c`并将其与`libtest.so`链接，生成`hello-arm-shared`可执行文件：
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The runtime linker for this program is `/lib/ld-linux-aarch64.so.1`, which
    must be present in the target’s filesystem. The linker will look for `libtest.so`
    in the default search path: `/lib` and `/usr/lib`. If you want it to look for
    libraries in other directories as well, you can place a colon-separated list of
    paths in the shell variable `LD_LIBRARY_PATH`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本程序的运行时链接器是`/lib/ld-linux-aarch64.so.1`，必须在目标系统的文件系统中存在。链接器将在默认的搜索路径`/lib`和`/usr/lib`中查找`libtest.so`。如果你希望它在其他目录中查找库，可以将一个以冒号分隔的路径列表放入shell变量`LD_LIBRARY_PATH`中：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Because shared libraries are separate from executables, you need to ensure the
    correct versions of shared libraries are installed on the target so that you don’t
    encounter runtime errors.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于共享库与可执行文件分开，你需要确保目标系统上安装了正确版本的共享库，以免遇到运行时错误。
- en: Understanding shared library version numbers
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解共享库版本号
- en: 'One of the benefits of shared libraries is that they can be updated independently
    of the programs that use them. Library updates are of two types:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库的一个优点是它们可以独立于使用它们的程序进行更新。库更新有两种类型：
- en: Those that fix bugs or add new functions in a backward-compatible way
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复错误或以向后兼容的方式添加新功能的更新
- en: Those that break compatibility with existing applications
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏与现有应用程序兼容性的更新
- en: GNU/Linux has a versioning scheme to handle both these cases.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: GNU/Linux有一个版本管理方案来处理这两种情况。
- en: Each library has a release version and an interface number. The release version
    is simply a string that is appended to the library name. For example, the JPEG
    image library `libjpeg` is currently at release 8.2.2 and so the library is named
    `libjpeg.so.8.2.2`. There is a symbolic link named `libjpeg.so` to `libjpeg.so.8.2.2`
    so that when you compile a program with `-ljpeg`, you link with the current version.
    If you install version 8.2.3, the link is updated, and you will link with that
    one instead.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每个库都有一个发布版本和一个接口编号。发布版本仅仅是附加在库名称后的字符串。例如，JPEG图像库`libjpeg`目前的版本是8.2.2，因此库文件名为`libjpeg.so.8.2.2`。同时有一个名为`libjpeg.so`的符号链接指向`libjpeg.so.8.2.2`，这样在用`-ljpeg`编译程序时，链接的是当前版本。如果你安装了8.2.3版本，链接会被更新，你将链接到那个版本。
- en: Now suppose that version 9.0.0 comes along and that breaks the backward compatibility.
    The link from `libjpeg.so` now points to `libjpeg.so.9.0.0` so that any new programs
    are linked with the new version. When the interface to `libjpeg` changes, the
    result is compilation errors that a developer can fix.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在有了9.0.0版本，并且它破坏了向后兼容性。此时，`libjpeg.so`的链接指向`libjpeg.so.9.0.0`，这样所有新的程序都会链接到新版本。当`libjpeg`的接口发生变化时，结果将是编译错误，开发者可以修复这些错误。
- en: 'Any programs on the target that are not recompiled are going to fail in some
    way because they are still using the old interface. This is where an object known
    as the **soname** helps. The soname encodes the interface number from when the
    library was built and is used by the runtime linker when it loads the library.
    It is formatted as `<library name>.so.<interface number>`. For `libjpeg.so.8.2.2`,
    the soname is `libjpeg.so.8` because the interface number when that `libjpeg`
    shared library was built is 8:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标系统上没有重新编译的程序会以某种方式失败，因为它们仍然使用旧的接口。这时，名为**soname**的对象就派上用场了。soname编码了库构建时的接口编号，运行时链接器在加载库时会用到它。它的格式为`<库名称>.so.<接口编号>`。对于`libjpeg.so.8.2.2`，soname为`libjpeg.so.8`，因为在构建该`libjpeg`共享库时的接口编号是8：
- en: '[PRE29]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Any program compiled with it will request `libjpeg.so.8` at runtime, which will
    be a symbolic link on the target to `libjpeg.so.8.2.2`. When version 9.0.0 of
    `libjpeg` is installed, it will have a soname of `libjpeg.so.9` and so it is possible
    to have two incompatible versions of the same library installed on the same system.
    Programs that were linked with `libjpeg.so.8.*.*` will load `libjpeg.so.8` and
    those linked with `libjpeg.so.9.*.*` will load `libjpeg.so.9`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 用它编译的任何程序都会在运行时请求`libjpeg.so.8`，而这将是目标上的一个符号链接，指向`libjpeg.so.8.2.2`。当安装了`libjpeg`的9.0.0版本时，它的soname是`libjpeg.so.9`，因此同一个系统上可以安装两个不兼容的版本。用`libjpeg.so.8.*.*`链接的程序会加载`libjpeg.so.8`，而用`libjpeg.so.9.*.*`链接的程序会加载`libjpeg.so.9`。
- en: 'This is why, when you look at the directory listing of `/usr/lib/x86_64-linux-gnu/libjpeg*`,
    you find these four files:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么当你查看`/usr/lib/x86_64-linux-gnu/libjpeg*`目录时，会看到这四个文件：
- en: '`libjpeg.a`: The library archive used for static linking'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libjpeg.a`：用于静态链接的库文件'
- en: '`libjpeg.so -> libjpeg.so.8.2.2`: A symbolic link used for dynamic linking'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libjpeg.so -> libjpeg.so.8.2.2`：用于动态链接的符号链接'
- en: '`libjpeg.so.8 -> libjpeg.so.8.2.2`: A symbolic link used when loading the library
    at runtime'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libjpeg.so.8 -> libjpeg.so.8.2.2`：在运行时加载库时使用的符号链接'
- en: '`libjpeg.so.8.2.2`: The actual shared library used at both compile time and
    runtime'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libjpeg.so.8.2.2`：在编译和运行时使用的实际共享库'
- en: The first two are only needed on the host computer for building and the last
    two are needed on the target at runtime.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个仅在主机计算机上用于构建，而最后两个则在目标计算机上用于运行时。
- en: While you can invoke the various GNU cross-compilation tools directly from the
    command line, this technique does not scale beyond toy examples like `helloworld`.
    To really be effective at cross-compiling, we need to combine a cross toolchain
    with a build system.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以直接从命令行调用各种GNU跨编译工具，但这种方法在像`helloworld`这样的小示例之外无法扩展。要真正有效地进行跨编译，我们需要将跨工具链与构建系统结合使用。
- en: Art of cross-compiling
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨编译的艺术
- en: Having a working cross toolchain is the starting point of a journey not the
    end of it. At some point, you will want to begin cross-compiling the various tools,
    applications, and libraries that you need for your target. Many of them will be
    open source packages, each of which has its own method of compiling and its own
    peculiarities.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个有效的跨工具链是开始这段旅程的起点，而不是终点。在某个时刻，你会希望开始为目标进行跨编译，编译你需要的各种工具、应用程序和库。其中许多将是开源软件包，每个包都有自己独特的编译方法和特殊性。
- en: 'Some common build systems include:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的构建系统包括：
- en: Pure makefiles where the toolchain is usually controlled by the `make` variable
    `CROSS_COMPILE`
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯 makefile，其中工具链通常由 `make` 变量 `CROSS_COMPILE` 控制
- en: GNU **Autotools** build system
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU **Autotools** 构建系统
- en: '**CMake**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMake**'
- en: Both Autotools and makefiles are needed to build even a basic embedded Linux
    system. CMake is cross-platform and has seen increased adoption over the years,
    especially among the C++ community. In this section, we will cover all three build
    tools.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是 Autotools 还是 makefile，都需要构建即使是一个基础的嵌入式 Linux 系统。CMake 是跨平台的，且在过去几年里得到了更多的采用，尤其在
    C++ 社区中。在本节中，我们将介绍这三种构建工具。
- en: Simple makefiles
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的 makefile
- en: Some important packages are very simple to cross-compile, including the Linux
    kernel, the U-Boot bootloader, and BusyBox. For each of these, you only need to
    put the toolchain prefix in the make variable `CROSS_COMPILE`, for example, `aarch64-buildroot-linux-gnu-`.
    Note the trailing hyphen.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的包非常容易进行交叉编译，包括 Linux 内核、U-Boot 启动加载程序和 BusyBox。对于这些，您只需将工具链前缀放入 `CROSS_COMPILE`
    变量中，例如 `aarch64-buildroot-linux-gnu-`。注意末尾的连字符。
- en: 'To compile BusyBox, you type:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译 BusyBox，您需要输入：
- en: '[PRE30]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Or you can set it as a shell variable:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以将其设置为 shell 变量：
- en: '[PRE31]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the case of U-Boot and Linux, you also need to set the `make` variable `ARCH`
    to one of the machine architectures they support, which I will cover in *Chapters
    3* and *4*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 U-Boot 和 Linux 的情况下，您还需要将 `make` 变量 `ARCH` 设置为它们支持的某个机器架构，我将在 *第 3 章* 和 *第
    4 章* 中详细讲解。
- en: Both Autotools and CMake can generate makefiles. Autotools only generates makefiles,
    whereas CMake supports other ways of building projects depending on which platform(s)
    you are targeting (strictly Linux in our case). Let’s look at cross-compiling
    with Autotools first.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Autotools 和 CMake 都可以生成 makefile。Autotools 仅生成 makefile，而 CMake 根据您要针对的目标平台（在我们的例子中严格是
    Linux）支持其他构建项目的方式。我们先来看看使用 Autotools 进行交叉编译。
- en: Autotools
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Autotools
- en: 'The name Autotools refers to a group of tools that are used as the build system
    in many open source projects. The components, together with the appropriate project
    pages, are:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Autotools 这个名字指的是一组用于许多开源项目构建系统的工具。这些组件及其对应的项目页面如下：
- en: GNU autoconf ([https://www.gnu.org/software/autoconf/](https://www.gnu.org/software/autoconf/)
    )
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU autoconf ([https://www.gnu.org/software/autoconf/](https://www.gnu.org/software/autoconf/)
    )
- en: GNU automake (https://www.gnu.org/software/automake/)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU automake (https://www.gnu.org/software/automake/)
- en: GNU libtool ([https://www.gnu.org/software/libtool/)](https://www.gnu.org/software/libtool/))
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU libtool ([https://www.gnu.org/software/libtool/)](https://www.gnu.org/software/libtool/))
- en: gnulib ([https://www.gnu.org/software/gnulib/)](https://www.gnu.org/software/gnulib/))
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gnulib ([https://www.gnu.org/software/gnulib/)](https://www.gnu.org/software/gnulib/))
- en: The role of Autotools is to smooth over the differences between the different
    types of systems that the package may be compiled for, accounting for different
    versions of compilers, different versions of libraries, different locations of
    header files, and dependencies with other packages.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Autotools 的作用是弥合包可能需要编译的不同类型系统之间的差异，考虑到不同版本的编译器、不同版本的库、头文件的位置差异以及与其他包的依赖关系。
- en: Packages that use Autotools come with a script named `configure` that checks
    dependencies and generates makefiles according to what it finds. The `configure`
    script may also give you the opportunity to enable or disable certain features.
    You can find the options on offer by running `./configure --help`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Autotools 的包附带一个名为 `configure` 的脚本，该脚本检查依赖关系并根据其查找的内容生成 makefile。`configure`
    脚本还可能让您有机会启用或禁用某些功能。您可以通过运行 `./configure --help` 查找可用的选项。
- en: 'To configure, build, and install a package for the native OS, you would typically
    run the following three commands:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置、构建并安装适用于本地操作系统的包，您通常需要运行以下三个命令：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Autotools can handle cross-development as well. You can influence the behavior
    of the configured script by setting these shell variables:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Autotools 也可以处理交叉开发。您可以通过设置这些 shell 变量来影响配置脚本的行为：
- en: '`CC`: C compiler command'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CC`：C 编译器命令'
- en: '`CFLAGS`: Additional C compiler flags'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CFLAGS`：额外的 C 编译器标志'
- en: '`CXX`: C++ compiler command'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CXX`：C++ 编译器命令'
- en: '`CXXFLAGS`: Additional C++ compiler flags'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CXXFLAGS`：额外的 C++ 编译器标志'
- en: '`LDFLAGS`: Additional linker flags; for example, if you have libraries in a
    non-standard directory, `<lib dir>`, you would add it to the library search path
    by adding `-L<lib dir>`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LDFLAGS`：附加的链接器标志；例如，如果您的库位于非标准目录 `<lib dir>` 中，您可以通过添加 `-L<lib dir>` 将其加入库搜索路径。'
- en: '`LIBS`: A list of additional libraries to pass to the linker; for instance,
    `-lm` for the math library'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIBS`：传递给链接器的附加库列表；例如，`-lm` 用于数学库'
- en: '`CPPFLAGS`: C/C++ preprocessor flags; for example, you would add `-I<include
    dir>` to search for headers in a non-standard directory, `<include dir>`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPPFLAGS`：C/C++ 预处理器标志；例如，你可以添加 `-I<include dir>` 来搜索非标准目录 `<include dir>`
    中的头文件。'
- en: '`CPP`: C preprocessor to use'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPP`：使用的 C 预处理器'
- en: 'Sometimes, it is sufficient to set only the `CC` variable, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，仅设置 `CC` 变量就足够了，如下所示：
- en: '[PRE33]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Other times, that will result in an error like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 其他时候，可能会导致如下错误：
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The reason for the failure is that `configure` often tries to discover the capabilities
    of the toolchain by compiling snippets of code and running them to see what happens,
    which cannot work if the program has been cross-compiled.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的原因是，`configure` 通常会尝试通过编译代码片段并运行它们来发现工具链的能力，而如果程序是交叉编译的，这种方式无法正常工作。
- en: '**IMPORTANT NOTE**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Pass `--host=<host>` to `configure` when you are cross-compiling so that `configure`
    searches your system for the cross-compiling toolchain targeting the specified
    `<host>` platform. That way, `configure` does not try to run snippets of non-native
    code as part of the configuration step.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在交叉编译时，传递 `--host=<host>` 给 `configure`，以便 `configure` 搜索你的系统，找到目标 `<host>`
    平台的交叉编译工具链。这样，`configure` 就不会尝试将非本地代码片段作为配置步骤的一部分来执行。
- en: 'Autotools understands three different types of machines that may be involved
    when compiling a package:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Autotools 理解在编译包时可能涉及的三种不同类型的机器：
- en: '**build**: The computer that builds the package, which defaults to the current
    machine.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**build**：构建包的计算机，默认为当前机器。'
- en: '**host**: The computer the program will run on. For a native compile, this
    is left blank and defaults to the same computer as build. When you are cross-compiling,
    set it to be the tuple of your toolchain.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**host**：程序运行的计算机。对于本地编译，这一项留空，默认为与 build 相同的计算机。当你进行交叉编译时，设置为工具链的元组。'
- en: '**target**: The computer the program will generate code for. You would set
    this when building a cross compiler.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**target**：程序生成代码的计算机。在构建交叉编译器时，你需要设置此项。'
- en: 'To cross-compile, you just need to override the host as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行交叉编译，你只需要按如下方式覆盖 host：
- en: '[PRE35]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: One final thing to note is that the default install directory is `<sysroot>/usr/local`.
    You would usually install it in `<sysroot>/usr` so that the header files and libraries
    would be picked up from their default locations.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是，默认的安装目录是 `<sysroot>/usr/local`。你通常会将其安装到 `<sysroot>/usr`，这样头文件和库就能从默认位置被提取。
- en: 'The complete command to configure a typical Autotools package is as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 配置典型 Autotools 包的完整命令如下：
- en: '[PRE36]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let’s dive deeper into Autotools and use it to cross-compile a popular library.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解 Autotools，并使用它交叉编译一个流行的库。
- en: 'An example: SQLite'
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个例子：SQLite
- en: The SQLite library implements a simple relational database and is quite popular
    on embedded devices.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 库实现了一个简单的关系型数据库，并且在嵌入式设备上非常流行。
- en: 'First, begin by getting a copy of SQLite:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，开始获取 SQLite 的副本：
- en: '[PRE37]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Version 3.44.0 of SQLite may no longer be available. If so, then download a
    more up-to-date version of the source code from the SQLite Download page at [https://www.sqlite.org/download.html.](https://www.sqlite.org/download.html.)
    Modify the preceding `tar` and `cd` commands to match the filename of the new
    tarball.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 版本 3.44.0 可能不再可用。如果是这样，请从 SQLite 下载页面下载一个更新版本的源代码：[https://www.sqlite.org/download.html.](https://www.sqlite.org/download.html.)
    修改前面的 `tar` 和 `cd` 命令，以匹配新 tarball 的文件名。
- en: 'Next, run the `configure` script:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行 `configure` 脚本：
- en: '[PRE38]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'That seems to work! If it had failed, there would have been error messages
    printed to the terminal and recorded in `config.log`. Note that several makefiles
    have been created so now you can build it:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎可行！如果失败，终端会打印错误信息，并记录在 `config.log` 文件中。注意，已经创建了多个 makefile，现在你可以进行编译：
- en: '[PRE39]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, you install it into the toolchain directory by setting the make variable,
    `DESTDIR`. If you don’t, it will try to install it into the host computer’s `/usr`
    directory, which is not what you want:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过设置 make 变量 `DESTDIR`，你将其安装到工具链目录。如果不这样做，它会尝试将其安装到主机计算机的 `/usr` 目录中，而这不是你想要的：
- en: '[PRE40]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You may find that the final command fails with a file permissions error because
    the toolchain is installed in a system directory such as `/opt` or `/usr/local`.
    In that case, you will need root permissions when running the installation.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现最终命令因为文件权限错误而失败，因为工具链安装在像 `/opt` 或 `/usr/local` 这样的系统目录中。在这种情况下，运行安装时你需要
    root 权限。
- en: 'After installing, you should find that various files have been added to your
    toolchain:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，你应该会发现各种文件已经被添加到你的工具链中：
- en: '`<sysroot>/usr/bin`: `sqlite3`: A command-line interface for SQLite that you
    can install and run on the target'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sysroot>/usr/bin`：`sqlite3`：一个可以在目标上安装并运行的 SQLite 命令行界面'
- en: '`<sysroot>/usr/lib`: `libsqlite3.so.0.8.6`, `libsqlite3.so.0`, `libsqlite3.so`,
    `libsqlite3.la`, `libsqlite3.a`: The shared and static libraries'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sysroot>/usr/lib`：`libsqlite3.so.0.8.6`，`libsqlite3.so.0`，`libsqlite3.so`，`libsqlite3.la`，`libsqlite3.a`：共享库和静态库'
- en: '`<sysroot>/usr/lib/pkgconfig`: `sqlite3.pc`: The package configuration file,
    as described in the following section'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sysroot>/usr/lib/pkgconfig`：`sqlite3.pc`：如下一节所述的包配置文件'
- en: '`<sysroot>/usr/include`: `sqlite3.h`, `sqlite3ext.h`: The header files'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sysroot>/usr/include`：`sqlite3.h`，`sqlite3ext.h`：头文件'
- en: '`<sysroot>/usr/share/man/man1`: `sqlite3.1`: The manual page'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sysroot>/usr/share/man/man1`：`sqlite3.1`：手册页'
- en: 'Now you can compile programs that use sqlite3 by adding `-lsqlite3` at the
    link stage:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过在链接阶段添加 `-lsqlite3` 来编译使用 sqlite3 的程序：
- en: '[PRE41]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, `sqlite-test.c` is a hypothetical program that calls SQLite functions.
    Since `sqlite3` has been installed into the `sysroot`, the compiler will find
    the header and library files without any problem. If they had been installed elsewhere,
    you would have had to add `-L<lib dir>` and `-I<include dir>`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sqlite-test.c` 是一个假设的程序，它调用了 SQLite 函数。由于 `sqlite3` 已经安装到 `sysroot` 中，编译器将毫不费力地找到头文件和库文件。如果它们安装在其他位置，你需要添加
    `-L<lib dir>` 和 `-I<include dir>`。
- en: Naturally, there will be runtime dependencies as well and you will have to install
    the appropriate files into the target directory, as described in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，也会有运行时依赖项，你需要将适当的文件安装到目标目录，具体请参考 [*第 5 章*](Chapter_05.xhtml#_idTextAnchor138)。
- en: To cross-compile a library or package, you first need to cross-compile its dependencies.
    Autotools relies on a utility called `pkg-config` to gather vital information
    about packages cross-compiled by Autotools.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要交叉编译一个库或包，首先需要交叉编译它的依赖项。Autotools 依赖于一个名为 `pkg-config` 的工具来收集 Autotools 交叉编译的包的关键信息。
- en: Package configuration
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包配置
- en: 'Tracking package dependencies is quite complex. The package configuration utility
    `pkg-config` helps track which packages are installed and which compile flags
    each package needs by keeping a database of Autotools packages in `<sysroot>/usr/lib/pkgconfig`.
    For instance, the one for SQLite3 is named `sqlite3.pc` and contains essential
    information needed by other packages that depend on it:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪包依赖关系相当复杂。包配置工具 `pkg-config` 帮助跟踪哪些包已安装以及每个包需要的编译标志，它通过在 `<sysroot>/usr/lib/pkgconfig`
    中保持 Autotools 包的数据库来实现。例如，SQLite3 的配置文件名为 `sqlite3.pc`，其中包含其他依赖于它的包所需的关键信息：
- en: '[PRE42]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can use `pkg-config` to extract information in a form that you can feed
    straight to `gcc`. In the case of a library like `libsqlite3`, you want to know
    the library name (`--libs`) and any special C flags `(--cflags`):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `pkg-config` 提取你可以直接传递给 `gcc` 的信息。对于像 `libsqlite3` 这样的库，你需要知道库名（`--libs`）和任何特殊的
    C 标志（`--cflags`）：
- en: '[PRE43]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Oops! That failed because it was looking in the host’s `sysroot`, and the development
    package for `libsqlite3` has not been installed on the host. You need to point
    it at the `sysroot` of the target toolchain by setting the shell variable `PKG_CONFIG_LIBDIR`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！失败了，因为它在查找主机的 `sysroot`，并且主机上没有安装 `libsqlite3` 的开发包。你需要通过设置 shell 变量 `PKG_CONFIG_LIBDIR`
    来将其指向目标工具链的 `sysroot`：
- en: '[PRE44]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now the output is `-lsqlite3`. In this case, you knew that already, but generally,
    you wouldn’t, so this is a valuable technique. The final commands to compile are:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出是 `-lsqlite3`。在这种情况下，你已经知道了这一点，但通常来说你并不知道，所以这是一个非常有价值的技巧。最终的编译命令是：
- en: '[PRE45]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Many `configure` scripts read the information generated by `pkg-config`. This
    can lead to errors when cross-compiling, as we shall see next.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 `configure` 脚本会读取 `pkg-config` 生成的信息。正如我们接下来会看到的，这可能会导致交叉编译时出现错误。
- en: Problems with cross-compiling
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交叉编译问题
- en: '`sqlite3` is a well-behaved package that cross-compiles nicely, but not all
    packages are the same. Typical pain points include:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite3` 是一个表现良好的包，能够顺利进行交叉编译，但并非所有包都是如此。典型的痛点包括：'
- en: Home-grown build systems for libraries like `zlib` that have a `configure` script
    that does not behave like the Autotools `configure` described in the previous
    section
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自制的构建系统，例如 `zlib`，它有一个 `configure` 脚本，行为与前面所述的 Autotools `configure` 不同
- en: '`configure` scripts that read `pkg-config` information, headers, and other
    files from the host disregarding the `--host` override'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configure` 脚本读取 `pkg-config` 信息、头文件和来自主机的其他文件，而忽略 `--host` 覆盖选项'
- en: Scripts that insist on trying to run cross-compiled code
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本强制尝试运行交叉编译的代码
- en: Each case requires careful analysis of the error. We can either pass additional
    parameters to the `configure` script to provide the correct information or apply
    patches to the code to avoid the problem altogether. Bear in mind that a single
    package can have many dependencies. This is especially true for programs that
    have a graphical interface or that handle multimedia content. As an example, MPlayer
    has dependencies on over 100 libraries. It would take weeks of effort to build
    them all.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 每种情况都需要仔细分析错误。我们可以通过向 `configure` 脚本传递额外的参数来提供正确的信息，或者对代码应用补丁以完全避免该问题。请记住，一个软件包可能有许多依赖关系。对于有图形界面或处理多媒体内容的程序尤其如此。例如，MPlayer
    有超过 100 个库的依赖关系。编译它们所有需要几周的时间。
- en: Therefore, I would not recommend manually cross-compiling components for the
    target in this way, except when there is no alternative or the number of packages
    to build is small.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除非没有其他选择或要构建的软件包数量较少，否则我不推荐以这种方式手动为目标进行交叉编译。
- en: A much better approach is to use a build tool such as Buildroot or The Yocto
    Project or avoid the problem altogether by setting up a native build environment
    for your target architecture. Now you can see why distributions like Debian are
    always compiled natively.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用像 Buildroot 或 The Yocto Project 这样的构建工具，或者通过为目标架构设置本地构建环境来完全避免这个问题。现在你可以明白为什么像
    Debian 这样的发行版总是进行本地编译。
- en: CMake
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMake
- en: CMake is more of a meta build system in the sense that it relies on an underlying
    platform’s native tools to build software. On Windows, CMake can generate project
    files for Microsoft Visual Studio, and on macOS, it can generate project files
    for Xcode. Integrating with the principal IDEs for each of the major platforms
    is no simple task and explains the success of CMake as the leading cross-platform
    build system solution. CMake also runs on Linux where it can be used in conjunction
    with a cross-compiling toolchain of your choice.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 更像是一个元构建系统，因为它依赖于底层平台的本地工具来构建软件。在 Windows 上，CMake 可以为 Microsoft Visual
    Studio 生成项目文件，在 macOS 上，它可以为 Xcode 生成项目文件。与各大平台的主要集成开发环境（IDE）整合不是一项简单的任务，这也解释了
    CMake 作为领先的跨平台构建系统解决方案的成功。CMake 也可以在 Linux 上运行，在这里它可以与您选择的交叉编译工具链一起使用。
- en: 'To configure, build, and install a package for a native Linux OS, run the following
    commands:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要为本地 Linux 操作系统配置、构建和安装包，请运行以下命令：
- en: '[PRE46]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: On Linux, the native build tool is GNU `make` so CMake generates makefiles by
    default for us to build with. Often, we want to perform out-of-source builds so
    that object files and other build artifacts remain separate from source files.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，本地构建工具是 GNU `make`，因此 CMake 默认为我们生成 makefile 来进行构建。通常，我们希望执行外部构建，以便对象文件和其他构建产物与源文件分开。
- en: 'To configure an out-of-source build in a subdirectory named `build`, run the
    following commands:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要在名为`build`的子目录中配置一个外部构建，请运行以下命令：
- en: '[PRE47]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will generate the makefiles inside a `build` subdirectory within the project
    directory where the `CMakeLists.txt` is located. The `CMakeLists.txt` file is
    the CMake equivalent of the `configure` script for Autotools-based projects.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在项目目录中生成一个名为 `build` 的子目录，其中包含 `CMakeLists.txt` 文件。`CMakeLists.txt` 文件是 CMake
    等价于 Autotools 项目的 `configure` 脚本。
- en: 'We can then build the project out of source from inside the `build` directory
    and install the package just as before:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以从 `build` 目录内在源外构建项目，并像以前一样安装该包：
- en: '[PRE48]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: CMake uses absolute paths so the `build` subdirectory cannot be copied or moved
    once the makefiles have been generated or any subsequent `make` step will likely
    fail. Note that CMake defaults to installing packages into system directories
    like `/usr/bin`, even for out-of-source builds.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 使用绝对路径，因此一旦生成了 makefile，`build` 子目录就无法被复制或移动，否则任何后续的 `make` 步骤可能会失败。请注意，即使是外部构建，CMake
    也默认将包安装到像 `/usr/bin` 这样的系统目录中。
- en: 'To generate the makefiles so that CMake installs the package in the `build`
    subdirectory, replace the previous `cmake` command with the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成 makefile，以便 CMake 将包安装到 `build` 子目录中，请将之前的 `cmake` 命令替换为以下命令：
- en: '[PRE49]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We no longer need to preface `make install` with `sudo` because we do not need
    elevated permissions to copy the package files into the `build` directory.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要在`make install`前加上`sudo`，因为我们不需要提升权限就可以将包文件复制到`build`目录。
- en: 'Similarly, we can use another CMake command-line option to generate makefiles
    for cross-compilation:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用另一个CMake命令行选项来为交叉编译生成makefile：
- en: '[PRE50]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: But the best practice for cross-compiling with CMake is to create a toolchain
    file that sets `CMAKE_C_COMPILER` and `CMAKE_CXX_COMPILER` in addition to other
    relevant variables for targeting embedded Linux.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，交叉编译时使用CMake的最佳实践是创建一个工具链文件，除了设置`CMAKE_C_COMPILER`和`CMAKE_CXX_COMPILER`外，还要为嵌入式Linux目标设置其他相关变量。
- en: CMake works best when we design our software in a modular way by enforcing well-defined
    API boundaries between libraries and components.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以模块化的方式设计软件，并在库和组件之间强制定义良好的API边界时，CMake效果最好。
- en: 'Here are some key terms that come up time and time again in CMake:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了一些在CMake中反复出现的关键术语：
- en: '`target`: A software component such as a library or executable.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`：一个软件组件，如库或可执行文件。'
- en: '`properties`: The source files, compiler options, and linked libraries needed
    to build a target.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`properties`：构建目标所需的源文件、编译器选项和链接库。'
- en: '`package`: A CMake file that configures an external target for building just
    as if it was defined within your `CMakeLists.txt` itself.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package`：一个CMake文件，用于配置外部目标的构建，就像它在你的`CMakeLists.txt`中定义一样。'
- en: 'For example, if we had a CMake-based executable named `dummy` that needed to
    take a dependency on SQLite, we could define the following `CMakeLists.txt`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个基于CMake的可执行文件`dummy`，并且它需要依赖SQLite，我们可以定义以下的`CMakeLists.txt`：
- en: '[PRE51]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `find_package` command searches for a package (SQLite3, in this case) and
    imports it so that the external target can be added as a dependency to the `dummy`
    executable’s list of `target_link_libraries` for linking.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_package`命令查找一个包（在此例中为SQLite3）并将其导入，这样外部目标就可以作为依赖项添加到`dummy`可执行文件的`target_link_libraries`链接列表中。'
- en: CMake comes with numerous finders for popular C and C++ packages, including
    OpenSSL, Boost, and protobuf, making native development much more productive than
    if we were to use just pure makefiles.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了许多用于流行C和C++包的查找器，包括OpenSSL、Boost和protobuf，使得本地开发比单纯使用makefile要高效得多。
- en: The `PRIVATE` qualifier prevents details like headers and flags from leaking
    outside of the `dummy` target. Using `PRIVATE` makes more sense when the target
    being built is a library instead of an executable. Think of targets as modules
    and attempt to minimize their exposed surface areas when using CMake to define
    your own targets. Only employ the `PUBLIC` qualifier when absolutely necessary
    and utilize the `INTERFACE` qualifier for header-only libraries.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`PRIVATE`限定符可以防止诸如头文件和标志等细节泄漏到`dummy`目标之外。当构建的目标是库而非可执行文件时，使用`PRIVATE`更有意义。把目标视作模块，并在使用CMake定义自己目标时尽量减少暴露的表面区域。只有在绝对必要时才使用`PUBLIC`限定符，并对仅包含头文件的库使用`INTERFACE`限定符。'
- en: Model your application as a dependency graph with edges between targets. This
    graph should not only include the libraries that your application links to directly
    but any transitive dependencies as well. For best results, remove any cycles or
    other unnecessary independencies seen in the graph. It is often best to perform
    this exercise before you start coding. A little planning can make the difference
    between a clean, easily maintainable `CMakeLists.txt` and an inscrutable mess
    that nobody wants to touch.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的应用程序建模为一个依赖关系图，图中的边连接目标。这个图不仅应包含你的应用程序直接链接的库，还应包括任何传递依赖项。为了获得最佳效果，移除图中的任何循环或其他不必要的独立性。通常最好在开始编码之前执行这个步骤。适当的规划可以让你拥有一个干净、易于维护的`CMakeLists.txt`，而不是一个没人愿意触碰的复杂混乱的文件。
- en: Summary
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The toolchain is always your starting point. Everything that follows from that
    is dependent on having a working, reliable toolchain.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链始终是你的起点。之后的一切都依赖于有一个工作正常且可靠的工具链。
- en: You may start with nothing but a toolchain downloaded from Bootlin or Linaro
    and use it to compile all the packages that you need on your target. Or you may
    obtain the toolchain as part of a distribution generated from source code using
    a build system such as Buildroot or The Yocto Project.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从Bootlin或Linaro下载一个工具链，开始时什么都没有，并用它来编译目标上所需的所有包。或者，你也可以将工具链作为从源代码生成的发行版的一部分，使用Buildroot或Yocto项目等构建系统获取。
- en: Beware of toolchains or distributions that are offered to you for free as part
    of a hardware package. They are often poorly configured and not maintained.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 小心那些作为硬件包的一部分免费提供给你的工具链或发行版。它们通常配置不当且没有得到维护。
- en: Once you have a toolchain, you can use it to build the other components of your
    embedded Linux system. In the next chapter, you will learn about the bootloader,
    which brings your device to life and begins the boot process. We will use the
    toolchain we built in this chapter to build a working bootloader for the BeaglePlay.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拥有了工具链，你就可以用它来构建嵌入式 Linux 系统的其他组件。在下一章中，你将了解引导加载程序，它将激活你的设备并开始启动过程。我们将在本章中构建的工具链上，构建一个适用于
    BeaglePlay 的工作引导加载程序。
- en: Further study
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入学习
- en: '*Toolchain Options in 2023: What’s new in compilers and libcs?* by Bernhard
    “Bero” Rosenkränzer – [https://www.youtube.com/watch?v=Vgm3GJ2ItDA](https://www.youtube.com/watch?v=Vgm3GJ2ItDA)'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*2023 年的工具链选项：编译器和库的新变化*，由 Bernhard “Bero” Rosenkränzer 主讲 – [https://www.youtube.com/watch?v=Vgm3GJ2ItDA](https://www.youtube.com/watch?v=Vgm3GJ2ItDA)'
- en: '*Modern CMake for modular design*, by Mathieu Ropert – [https://www.youtube.com/watch?v=eC9-iRN2b04](https://www.youtube.com/watch?v=eC9-iRN2b04)'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*现代 CMake 与模块化设计*，由 Mathieu Ropert 主讲 – [https://www.youtube.com/watch?v=eC9-iRN2b04](https://www.youtube.com/watch?v=eC9-iRN2b04)'
