<html><head></head><body>
		<div id="_idContainer154">
			<h1 id="_idParaDest-137" class="chapter-number"><a id="_idTextAnchor140"/>7</h1>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor141"/>PowerShell and the Web – HTTP, REST, and JSON</h1>
			<p>Up until now, we’ve worked in a very small space – our client machine. It’s nice, but the world doesn’t work like that. Pretty much every device we use is connected to other machines and also, usually, the internet. Devices need to be able to interact with services provided over the web to download data, interact with cloud applications, and play games. In this, chapter we’re going to look at ways we can use PowerShell to work with objects in the world outside <span class="No-Break">our box.</span></p>
			<p>We’ll start out with a brief chat about web services and then look at the basic PowerShell tool for interacting with them; <strong class="source-inline">Invoke-WebRequest</strong>. We’ll go on to look at <strong class="bold">Application Programming Interfaces</strong> (<strong class="bold">APIs</strong>). We’ll talk about the dominant type of API in use today – <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>). Once we’ve got a good grip on that and the tool we can use to work with it, <strong class="source-inline">Invoke-RestMethod</strong>, we’ll look at some of the ways of exchanging information with web services using <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>), and the tools we use to convert JSON data into PowerShell objects, and vice versa. Finally, we’ll tackle a <span class="No-Break">short exercise.</span></p>
			<p>This chapter will give us the basic techniques we’ll need for some of the work we’ll do in later chapters of the book and build on some of the work we did in the last chapter. We’ll see that those techniques apply to data on the web <span class="No-Break">as well.</span></p>
			<p>In this chapter we are going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Working <span class="No-Break">with HTTP</span></li>
				<li>Getting to grips <span class="No-Break">with APIs</span></li>
				<li>Working <span class="No-Break">with REST</span></li>
				<li>Working <span class="No-Break">with JSON</span></li>
			</ul>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor142"/>Working with HTTP</h1>
			<p>The world we live<a id="_idIndexMarker494"/> in has a dominant philosophy, a set of concepts and practices that has largely defined information technology for the last 30 years; the client/server paradigm. There are alternatives; centralized computing with dumb terminals, such as mainframe computing, thin client computing with applications such as Citrix, or peer-to-peer computing such as we might see in BitTorrent or blockchain applications. Tim Berners-Lee envisaged the World Wide Web as a peer-to-peer network, but it hasn’t really stayed that way. The client/server model is prevalent. In general, the device on our desk or in our hands is the client, and it is connected to a remote server to receive or manipulate information. It differs from a dumb terminal in that some of the processing is carried out on the client, and some of it on <span class="No-Break">the server.</span></p>
			<p>In this chapter, we’re going to look at how information is exchanged between clients and servers on the internet using the foundational protocol of the World Wide Web; <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>). This is the protocol we use to <span class="No-Break">browse websites.</span></p>
			<p>The basic cmdlet for working with HTTP in PowerShell is <strong class="source-inline">Invoke-WebRequest</strong>, so let’s have a look at how we can use the <strong class="source-inline">Invoke-WebRequest</strong> cmdlet to work with data on <span class="No-Break">the web.</span></p>
			<p>The <strong class="source-inline">Invoke-WebRequest</strong> cmdlet is an incredibly versatile tool that allows us to create an HTTP request and submit it to a web service. Because the range of requests we might make is huge, the cmdlet is pretty complicated, with over thirty parameters. Let’s start with the simple stuff. Let’s get a list of hyperlinks to relevant news topics. In a web browser, go to this address: <a href="https://neuters.de">https://neuters.de</a>. This is a text-based website that aggregates the most recent Reuters news articles. It’s nice <span class="No-Break">and simple.</span></p>
			<p>Now, open PowerShell and type <span class="No-Break">the following:</span></p>
			<pre class="console">
$News = Invoke-WebRequest <strong class="source-inline">https://neuters.de</strong></pre>			<p>This will send a <strong class="source-inline">GET</strong> request to the address and store the response in the <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">News</strong></span><span class="No-Break"> variable.</span></p>
			<p>Now let’s see what we’ve got by calling the contents of <strong class="source-inline">$News</strong>. <span class="No-Break">Type this:</span></p>
			<pre class="console">
$News</pre>			<p>You should see something that looks like the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B17600_07_001.jpg" alt="Figure 7.1 – Invoke-WebRequest gets the HTTP response"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Invoke-WebRequest gets the HTTP response</p>
			<p>That’s great, but it’s not pretty. If we look a little closer at our output, we can see that one of the sections is called <strong class="source-inline">Links</strong>. We can use that to just get the hyperlinks from the page by calling it <span class="No-Break">like this:</span></p>
			<pre class="console">
$News.Links</pre>			<p>Unfortunately, they <a id="_idIndexMarker495"/>are all relative links, but we should turn them into absolute links by adding the root location, which we can do quite easily. If we pipe the output of <strong class="source-inline">$News.Links</strong> to <strong class="source-inline">Get-Member</strong>, we can see that it has a property called <strong class="source-inline">href</strong>, which just contains the link, <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B17600_07_002.jpg" alt="Figure 7.2 – href property"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – href property</p>
			<p>We can concatenate that with the root domain. Type the <span class="No-Break">following code:</span></p>
			<pre class="console">
$News.Links | Foreach {"https://neuters.de" + $_.href}</pre>			<p>And you should see a list of absolute links, like in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B17600_07_003.jpg" alt="Figure 7.3 – Scraping the neuters.de site for links"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Scraping the neuters.de site for links</p>
			<p>If you got something like that, congratulations, you have just <strong class="bold">scraped</strong> your first website with PowerShell. Scraping is the process of automating the retrieval of data from <span class="No-Break">a website.</span></p>
			<p><strong class="source-inline">Invoke-WebRequest</strong> has only one mandatory parameter; <strong class="source-inline">-Uri</strong>. It is positional, so any string following the cmdlet will be treated as an input for this parameter. The <strong class="source-inline">–Uri</strong> parameter accepts<a id="_idIndexMarker496"/> the URL of <span class="No-Break">the source.</span></p>
			<p class="callout-heading">URI versus URL</p>
			<p class="callout">We are probably all familiar with <a id="_idIndexMarker497"/>the acronym <strong class="bold">URL</strong>, which is short for <strong class="bold">Uniform Resource Locator</strong>. We may be less familiar with <strong class="bold">URI</strong>, which is short<a id="_idIndexMarker498"/> for <strong class="bold">Uniform Resource Identifier</strong>. URI is an umbrella term that consists of two different ways to identify a resource; it may be either a <a id="_idIndexMarker499"/>name (<strong class="bold">Uniform Resource Name</strong> (<strong class="bold">URN</strong>)) or a location (URL). A URL always provides the location of the resource. URLs are a subset of URIs, consist of a scheme and a path, and may include other elements. The schemes we are probably most familiar with are <strong class="source-inline">http:</strong> and <strong class="source-inline">https:</strong>, so an absolute URL would be <a href="https://neuters.de">https://neuters.de</a>, containing both the scheme (<strong class="source-inline">https:</strong>) and the address (<strong class="source-inline">neuters.de</strong>) separated by a double <span class="No-Break">slash (</span><span class="No-Break"><strong class="source-inline">//</strong></span><span class="No-Break">).</span></p>
			<p class="callout">What about URNs, though? A URN <a id="_idIndexMarker500"/>consists of the scheme (<strong class="source-inline">urn:</strong>), one or more <strong class="bold">namespace identifiers</strong> (<strong class="bold">NIDs</strong>), and a <strong class="bold">namespace-specific string</strong> (<strong class="bold">NSS</strong>). An <a id="_idIndexMarker501"/>example would be <strong class="source-inline">urn:ietf:rfc:1149</strong>, which identifies my favorite <span class="No-Break">protocol definition.</span></p>
			<p class="callout">The twist is that the <strong class="source-inline">-Uri</strong> parameter only supports the <strong class="source-inline">http:</strong> and <strong class="source-inline">https:</strong> schemes, so can only accept URLs. However, according to the World Wide Web Consortium, the international standards authority for the web, URI is a more precise and technically correct term <span class="No-Break">than URL.</span></p>
			<p>Let’s take a closer look at some of the parameters that we can use <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Invoke-WebRequest</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">-Method</strong> will accept any of the standard HTTP methods: <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">DELETE</strong>, and a few others. If we omit it, then the default method is <strong class="source-inline">GET</strong>. If we need to use a custom method, then we can use the <strong class="source-inline">-CustomMethod</strong> parameter. We can’t use both <strong class="source-inline">-Method</strong> and <strong class="source-inline">-CustomMethod</strong> in the same cmdlet. This parameter allows us to send information to a <span class="No-Break">web address.</span></li>
				<li><strong class="source-inline">-OutFile</strong> specifies a path and name to write the output to a file. Note this only writes the response HTML to the file, not things such as the response code. This parameter prevents the output from being placed in the pipeline. If we want the <a id="_idIndexMarker502"/>output to be available to the pipeline and to be written to a file, then we need to use the <strong class="source-inline">-PassThru</strong> parameter <span class="No-Break">as well.</span></li>
				<li><strong class="source-inline">-Headers</strong> can be used to submit specific header information as part of the web request. The information must take the form of a hashtable <span class="No-Break">or dictionary.</span></li>
				<li><strong class="source-inline">-Body</strong> can submit specific body content, such as a query. We can’t use <strong class="source-inline">-Body</strong> and <strong class="source-inline">-Form</strong> in the <span class="No-Break">same cmdlet.</span></li>
				<li><strong class="source-inline">-Form</strong>. The <strong class="source-inline">-Form</strong> parameter is used to submit information to an HTML form at the target address. We can find lots of information on the web about how to use the <strong class="source-inline">-Form</strong> parameter to quickly and easily log in to websites using Windows PowerShell. Unfortunately, most of them don’t work with PowerShell 7 because the HTML is parsed differently. We’ll discover <span class="No-Break">why shortly.</span></li>
				<li><strong class="source-inline">-Proxy</strong> allows us to specify an alternative proxy server to the one set on our client. It is normally used with either the <strong class="source-inline">-ProxyUseDefaultCredentials</strong> parameter, which passes the current user credentials to the proxy, or with the <strong class="source-inline">-ProxyCredentials</strong> parameter, which allows us to specify <span class="No-Break">alternative credentials.</span></li>
				<li><strong class="source-inline">-NoProxy</strong> lets us bypass the client proxy altogether. We can’t use it in the same cmdlet <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">-Proxy</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-SessionVariable</strong> can be used when connecting to a stateful web service; we can use the <strong class="source-inline">-SessionVariable</strong> the first time we run <strong class="source-inline">Invoke-WebRequest</strong>, and then use the <strong class="source-inline">-WebSession</strong> parameter with the same value for each subsequent connection to ensure we persist the session state. This is useful if we need to log in to a web service before using it. Note that we supply a string to <strong class="source-inline">-SessionVariable</strong>, but then supply the string as a variable to <strong class="source-inline">-Websession</strong>, <span class="No-Break">like so:</span><pre class="source-code">
<strong class="bold">Invoke-WebRequest -Uri https://reddit.com -SessionVariable sv</strong>
<strong class="bold">Invoke-WebRequest -Uri https://reddit.com/settings -WebSession $sv</strong></pre></li>				<li><strong class="source-inline">-SkipCertificateCheck</strong> will ignore SSL/TLS certificate problems. For obvious reasons, we shouldn’t use this parameter unless we are sure that the site we are<a id="_idIndexMarker503"/> connecting to is secure, and any certificate problems we see are not a sign of a problem. Sometimes, a certificate problem is fairly innocuous and may be down to a harried admin who hasn’t renewed their certificate, and sometimes <span class="No-Break">it’s malicious.</span></li>
				<li><strong class="source-inline">-SkipHttpErrorCheck</strong>: By default, if <strong class="source-inline">Invoke-WebRequest</strong> gets a HTTP error code as a response, it will report it as an error, in red, rather than as an output. If we want to capture the error response and process it, then we can use this parameter. For an example, see the <span class="No-Break">following figure:</span></li>
			</ul>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B17600_07_004.jpg" alt="Figure 7.4 – Using -SkipHttpErrorCheck"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Using -SkipHttpErrorCheck</p>
			<p>In the figure here, the first cmdlet, in the red box, doesn’t use the <strong class="source-inline">-SkipHttpErrorCheck</strong> parameter, so PowerShell treats the response as an error. In the second cmdlet, in the green box, we’ve used the parameter and we can see the actual HTTP response that the <span class="No-Break">server sent.</span></p>
			<p>There are another <a id="_idIndexMarker504"/>thirty parameters we can use with <strong class="source-inline">Invoke-WebRequest</strong> but these are the most commonly used ones. Let’s take a look at why the <strong class="source-inline">-Form</strong> parameter isn’t as useful in <span class="No-Break">PowerShell 7.</span></p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor143"/>Why don’t we see Forms information in PowerShell 7?</h2>
			<p>As we <a id="_idIndexMarker505"/>mentioned, the <strong class="source-inline">-Form</strong> parameter<a id="_idIndexMarker506"/> doesn’t work as well in PowerShell 7 as it does in Windows PowerShell. If we examine the objects returned by <strong class="source-inline">Invoke-WebRequest</strong> with <strong class="source-inline">Get-Member</strong>, we can’t see the <strong class="source-inline">Forms</strong> property in PowerShell 7 but we can in Windows PowerShell. It’s worth taking a closer look and understanding why. The <strong class="source-inline">Invoke-WebRequest</strong> cmdlet produces different types of objects in PowerShell 7 and Windows PowerShell. We can see in the following figure the difference in output. In the upper blue frame, we can see that Windows PowerShell produces objects with a <strong class="source-inline">TypeName</strong> of <strong class="source-inline">HtmlWebResponseObject</strong>, and we can see the properties of this type <span class="No-Break">include </span><span class="No-Break"><strong class="source-inline">Forms</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B17600_07_005.jpg" alt="Figure 7.5 – Invoke-WebRequest in Windows PowerShell"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Invoke-WebRequest in Windows PowerShell</p>
			<p>In PowerShell 7, next, we <a id="_idIndexMarker507"/>can see <a id="_idIndexMarker508"/>that we get a <strong class="source-inline">BasicHtmlWebResponseObject</strong>, which doesn’t have a <span class="No-Break"><strong class="source-inline">Forms</strong></span><span class="No-Break"> property:</span></p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B17600_07_006.jpg" alt="Figure 7.6 – Invoke-WebRequest in PowerShell 7"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Invoke-WebRequest in PowerShell 7</p>
			<p>This is because PowerShell 7 uses basic parsing <span class="No-Break">by default.</span></p>
			<p>In Windows PowerShell, we can use the information held in the <strong class="source-inline">Forms</strong> property of the web page to create a variable with properties that match the fields on the form, and then submit the variable as part of our cmdlet, using the <strong class="source-inline">-Form</strong> parameter. Because the objects returned by <strong class="source-inline">Invoke-WebRequest</strong> don’t have a property called <strong class="source-inline">Forms</strong>, many of the instructions found on the internet for using the cmdlet this way won’t work in <span class="No-Break">PowerShell 7.</span></p>
			<p>That doesn’t mean we can’t use <strong class="source-inline">Invoke-WebRequest</strong> to fill in forms, however. We just need to understand what the form fields are beforehand; we will struggle to work it out with PowerShell 7<a id="_idIndexMarker509"/> alone. We <a id="_idIndexMarker510"/>also need to be aware that many of the examples we see on the internet are written for the Windows PowerShell version of the <span class="No-Break"><strong class="source-inline">Invoke-WebRequest</strong></span><span class="No-Break"> cmdlet.</span></p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor144"/>Authentication</h2>
			<p>Many websites use <a id="_idIndexMarker511"/>some form of authentication, so authentication is a big part of <strong class="source-inline">Invoke-WebRequest</strong>. The first thing to do is to set the type of authentication in use. We can use the <strong class="source-inline">-UseDefaultCredentials </strong>parameter to try and authenticate with the current environment login, but if we’re using an external address, rather than something inside our organization, then we will probably need to supply site-specific information. The <strong class="source-inline">-Authentication</strong> parameter accepts <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">None</strong>: This is the default. If the <strong class="source-inline">-Authentication</strong> parameter is not filled, then <strong class="source-inline">Invoke-WebRequest</strong> will not use <span class="No-Break">any authentication.</span></li>
				<li><strong class="source-inline">Basic</strong>: This will send a Base64-encoded set of credentials. Hopefully, we’re connecting to an HTTPS URL, because Base64 encoding is not the same as encryption. This is not a very secure way of sending credentials. We will also need to use the <strong class="source-inline">-Credential</strong> parameter to supply the username <span class="No-Break">and password.</span></li>
				<li><strong class="source-inline">Bearer</strong>: This will require a Bearer token to be supplied as a secure string using the <strong class="source-inline">-Token</strong> parameter. A token is basically a long string that can be used to identify the sender of the request. Bearer authentication is an HTTP authentication scheme that was developed as part of OAuth 2.0 – the Open Authorization standard. Not all bearer authentication is OAuth, however. Because we are passing a token assigned by the remote server, it should only be used over HTTPS so that it <span class="No-Break">is encrypted.</span></li>
				<li><strong class="source-inline">Oauth</strong>: This is an open standard for access delegation. It’s used by many big internet companies such as Amazon, Google, and Microsoft to provide authorization and authentication. Usually, it takes a bearer token, as <span class="No-Break">mentioned previously.</span></li>
			</ul>
			<p>Let’s have a look at how this works. On my client, I’ve installed PowerShell Universal, a module from the good people at Ironman Software (https://blog.ironmansoftware.com/). This lets me run a lightweight server on my client and <span class="No-Break">create endpoints.</span></p>
			<p class="callout-heading">Don’t try to do this on your client</p>
			<p class="callout">It takes quite a lot of configuration that we’re not going to cover in this book and requires a subscription to use the authentication functions. I’m including it here so that we can see how the <span class="No-Break">process works.</span></p>
			<p>I’ve created an <a id="_idIndexMarker512"/>endpoint at <strong class="source-inline">http://localhost:5000/me</strong> that requires an authentication token to access. I’ve created the token on the server, and stored it as a secure string <span class="No-Break">as follows:</span></p>
			<pre class="console">
$apptoken = ConvertTo-SecureString -String &lt;mytoken&gt; -AsPlainText</pre>			<p>The token isn’t really <strong class="source-inline">&lt;mytoken&gt;</strong>; it’s a very much longer random string. Now I can access the endpoint by providing the token using the <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">apptoken</strong></span><span class="No-Break"> variable:</span></p>
			<pre class="console">
Invoke-WebRequest -Uri http://localhost:5000/me -Authentication Bearer -Token $apptoken</pre>			<p>As we can see in the following figure, without supplying authentication, I get a <strong class="source-inline">401</strong> error; I’m unauthorized. When I supply authentication in the second cmdlet, I get the content of the page, <span class="No-Break"><strong class="source-inline">Hello World</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B17600_07_007.jpg" alt="Figure 7.7 – Providing authentication using the -Authentication and -Token parameters"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Providing authentication using the -Authentication and -Token parameters</p>
			<p>Quite often, however, we will need to provide authentication via the <strong class="source-inline">-Headers</strong> parameter. This is a little more involved than using <strong class="source-inline">-Authentication</strong>. We need to provide the token as part of the web request but point it to the correct header. In the case of my local test endpoint, I can do it<a id="_idTextAnchor145"/> <span class="No-Break">like this:</span></p>
			<pre class="console">
Invoke-WebRequest -Uri http://localhost:5000/me -Headers @{Authorization = "Bearer $admtoken"}</pre>			<p>Note that if we <a id="_idIndexMarker513"/>supply the token in the header, we must <em class="italic">not</em> encode it using the <strong class="source-inline">ConvertTo-SecureString</strong> cmdlet. I’ve saved the unencoded token as <strong class="source-inline">$admtoken</strong>, (not <strong class="source-inline">$apptoken</strong>) as we can <span class="No-Break">see here:</span></p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B17600_07_008.jpg" alt="Figure 7.8 – Passing authentication data using the -Headers parameter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Passing authentication data using the -Headers parameter</p>
			<p>In the first line, I’m trying to pass the encoded token, stored in the <strong class="source-inline">$apptoken</strong> variable. In the second line, I’m passing the unencoded token store in the <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">admtoken</strong></span><span class="No-Break"> variable.</span></p>
			<p>Note that the <strong class="source-inline">SecureString</strong> object type provides a <em class="italic">measure of security</em>, according to Microsoft. It’s not truly secure. Read more <span class="No-Break">here: </span><a href="https://learn.microsoft.com/en-us/dotnet/api/system.security.securestring"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/api/system.security.securestring</span></a><span class="No-Break">.</span></p>
			<p>Now we’ve covered making basic requests, let’s take a look at how we can interact with websites <span class="No-Break">more</span><span class="No-Break"><a id="_idIndexMarker514"/></span><span class="No-Break"> programmatically.</span></p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor146"/>Getting to grips with APIs</h1>
			<p>Most modern <a id="_idIndexMarker515"/>systems communicate between client and server using an API. This is a list of agreed requests and responses between the two components. This sounds complicated, but it is quite simple. If we put the <a href="https://random.dog/woof.json">https://random.dog/woof.json</a> URL into a browser, we get back the URL of a random dog, from a database of dog images. We also get the size of the file, <span class="No-Break">in bytes.</span></p>
			<p>Our browser is the client, and it sends an HTTP <strong class="source-inline">GET</strong> request to an API endpoint (<strong class="source-inline">/woof.json</strong>) on the server at the <a href="https://random.dog">https://random.dog</a> URL. In response to this request, the server sends a message containing a URL back to us, in the first frame in the following figure. We can look at the headers in the second frame below and see that the content type <a id="_idIndexMarker516"/>is <strong class="bold">JSON</strong>. We can then display the URL in a browser to see a picture of an adorable dog, below. Note that I’m using Firefox, here, which allows us to see the headers as well as the content. Other browsers will only show the <span class="No-Break">JSON content.</span></p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/B17600_07_009.jpg" alt="Figure 7.9 – Dog via API"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Dog via API</p>
			<p>The server isn’t sending a web page for the browser to display; it’s just sending data that contains a URL, and every time we request the page, it sends a different URL. We’ll take a good look at this data in the later section of this chapter entitled <em class="italic">Working with JSON</em>, so don’t worry about it too <span class="No-Break">much now.</span></p>
			<p>There are four<a id="_idIndexMarker517"/> common types of APIs in <span class="No-Break">general use:</span></p>
			<ul>
				<li><strong class="bold">Remote Procedure Call</strong> (<span class="No-Break"><strong class="bold">RPC</strong></span><span class="No-Break">) APIs</span></li>
				<li><span class="No-Break">SOAP APIs</span></li>
				<li><span class="No-Break">REST APIs</span></li>
				<li><span class="No-Break">WebSocket APIs</span></li>
			</ul>
			<p>They fall into two categories – <strong class="bold">stateful</strong>, where<a id="_idIndexMarker518"/> the connection between client and server is <a id="_idIndexMarker519"/>maintained over a number of <a id="_idIndexMarker520"/>requests, and <strong class="bold">stateless</strong>, where each request from a client is treated as a unique event and doesn’t persist any information over to the next request. Let’s take a <span class="No-Break">closer look.</span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor147"/>RPC APIs</h2>
			<p>RPC APIs call a <a id="_idIndexMarker521"/>function in software on a server – they tell a server to do<a id="_idIndexMarker522"/> something using a specific piece of code, and the server will return an output that may or may not contain data. They may not do this over HTTP; there is a separate protocol called, appropriately enough, RPC, which is often used over local networks. We are not going to concern ourselves with RPC APIs in this chapter, but they are undergoing a bit of a resurgence on the internet, particularly for blockchain applications. RPC APIs were historically stateful, but more modern implementations of this model are <span class="No-Break">usually not.</span></p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor148"/>SOAP APIs</h2>
			<p><strong class="bold">SOAP</strong> APIs use<a id="_idIndexMarker523"/> the <strong class="bold">Simple Object Access Protocol</strong> to exchange <a id="_idIndexMarker524"/>messages using XML. We see these APIs most usually when working with Windows servers running Microsoft <strong class="bold">Internet Information Server</strong> (<strong class="bold">IIS</strong>) rather <a id="_idIndexMarker525"/>than Linux servers, which usually run Apache or NGINX software. As we have seen in <a href="B17600_06.xhtml#_idTextAnchor117"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">PowerShell and Files – Reading, Writing, and Manipulating Data</em>, XML is not the easiest language to work with and Windows is a less common operating system than Linux for web servers, so SOAP APIs are not the most popular. SOAP is most <span class="No-Break">commonly stateless.</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor149"/>REST APIs</h2>
			<p><strong class="bold">REST</strong> is a style of<a id="_idIndexMarker526"/> software architecture for client-server, machine-to-machine<a id="_idIndexMarker527"/> communication. A REST API conforms to this style. They are flexible and lightweight, most often based on the HTTP protocol. REST APIs are stateless and can receive output in many forms, including HTML and XML. JSON is the most common form of output, however. REST APIs are generally the simplest APIs to work with and certainly the most common on <span class="No-Break">the internet.</span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor150"/>WebSocket APIs</h2>
			<p>WebSocket APIs <a id="_idIndexMarker528"/>use JSON to move data between clients and<a id="_idIndexMarker529"/> servers. Like REST APIs, they are based on HTTP, but unlike REST APIs, WebSocket APIs also use their own protocol, called the WebSocket protocol, an extension of HTTP, which allows for a wider range of operations. They are stateful and bi-directional; the server may initiate communication with a connected client. This makes them extremely powerful, but also harder <span class="No-Break">to use.</span></p>
			<p>Let’s take a closer look at how we can work with the most common API type – the <span class="No-Break">REST API.</span></p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor151"/>Working with REST</h1>
			<p>The most common <a id="_idIndexMarker530"/>API we will work with is the REST API. We most frequently encounter REST APIs when we<a id="_idIndexMarker531"/> use <strong class="bold">web applications</strong>. A web application is usually a tiered client/server application. A typical application would consist of three<a id="_idIndexMarker532"/> tiers <span class="No-Break">or layers:</span></p>
			<ul>
				<li><strong class="bold">A presentation layer</strong> – the web browser<a id="_idIndexMarker533"/> or app on the <span class="No-Break">client device</span></li>
				<li><strong class="bold">An application layer</strong> – the <span class="No-Break">web server</span></li>
				<li><strong class="bold">A storage layer</strong> – usually a database running on the web server or a <span class="No-Break">separate server</span></li>
			</ul>
			<p>We use REST APIs to communicate between the presentation layer (the browser) and the application layer (the web server); how the application layer communicates with the storage layer (the database) is up to the application developer, but it will often be Python <span class="No-Break">or PHP.</span></p>
			<p>REST APIs are usually implemented using HTTP, which means they use a familiar set of HTTP commands such as <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">POST</strong>. Because of the way web applications are usually designed, REST APIs are frequently associated with database operations; <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>). The<a id="_idIndexMarker534"/> following table summarizes how the commands map <span class="No-Break">to operations.</span></p>
			<table id="table001-4" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">Database operation</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">REST </strong><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">API request</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">Example</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Create</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">POST</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Create a </span><span class="No-Break" lang="en-US" xml:lang="en-US">new user</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Read</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">GET</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Get a picture of </span><span class="No-Break" lang="en-US" xml:lang="en-US">a dog</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Update</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">PUT</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Change </span><span class="No-Break" lang="en-US" xml:lang="en-US">an address</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break" lang="en-US" xml:lang="en-US">Delete</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">DELETE</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Delete a </span><span class="No-Break" lang="en-US" xml:lang="en-US">chatroom post</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.1 – How REST relates to CRUD</p>
			<p>The websites we’ve<a id="_idIndexMarker535"/> looked at so far utilize APIs, and we’ve worked with them using <strong class="source-inline">Invoke-WebRequest</strong>. Let’s take a look at a different cmdlet we <span class="No-Break">can use.</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor152"/>Invoke-RestMethod</h2>
			<p>The <strong class="source-inline">Invoke-RestMethod</strong> cmdlet can<a id="_idIndexMarker536"/> be used to query a REST API <a id="_idIndexMarker537"/>endpoint, such as <strong class="source-inline">http://random.dog/woof.json</strong>. How does <strong class="source-inline">Invoke-RestMethod</strong> differ from <strong class="source-inline">Invoke-WebRequest</strong>? Let’s look at the <strong class="source-inline">random.dog/woof.json</strong> API endpoint with both to compare <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B17600_07_010.jpg" alt="Figure 7.10 – Comparing Invoke-WebRequest and Invoke-RestMethod"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Comparing Invoke-WebRequest and Invoke-RestMethod</p>
			<p>In the first example, in the red box, I’ve used <strong class="source-inline">Invoke-WebRequest</strong>. In the second example, in the green box, I’ve used <strong class="source-inline">Invoke-RestMethod</strong>. Both cmdlets parse the response correctly, but they are doing different things. <strong class="source-inline">Invoke-WebRequest</strong> is displaying the HTTP response from the endpoint, including the headers and content. <strong class="source-inline">Invoke-RestMethod</strong> is only looking at the content and is displaying it as a custom object with a set of properties corresponding to names in the dictionary included in the content. Wait, what? Where <a id="_idIndexMarker538"/>did the dictionary come from? Remember, <strong class="source-inline">Invoke-RestMethod</strong> works with REST API endpoints. A REST API provides<a id="_idIndexMarker539"/> output in JSON, or less frequently in XML. JSON and XML outputs usually consist of a collection of name-value pairs; a dictionary. If we use <strong class="source-inline">Invoke-RestMethod</strong> to interrogate an HTML page that doesn’t output in JSON or XML, then we get a single object, consisting of the raw HTML from the page. We will cover JSON in more detail in the next section of this chapter, <em class="italic">Working with JSON</em>. Let’s take a closer look at the output we get when we access an <span class="No-Break">API endpoint.</span></p>
			<p>If we pipe <strong class="source-inline">Invoke-RestMethod</strong> to <strong class="source-inline">Get-Member</strong>, we can see that we have a <strong class="source-inline">System.Management.Automation.PSCustomObject</strong> with two properties; <strong class="source-inline">fileSizeBytes</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">url</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
Invoke-RestMethod -Uri https://random.dog/woof.json | Get-Member</pre>			<p>The parameters for <strong class="source-inline">Invoke-RestMethod</strong> are quite similar to <strong class="source-inline">Invoke-WebRequest</strong>. We can summarize them in <em class="italic">Table 7.2</em>. As we can see, <strong class="source-inline">Invoke-WebRequest</strong> has the <strong class="source-inline">-HttpVersion</strong> parameter, which was introduced in PowerShell 7.3, while <strong class="source-inline">Invoke-RestMethod</strong> does not, and <strong class="source-inline">Invoke-RestMethod</strong> has parameters that deal with relative links (<strong class="source-inline">-FollowRelLink</strong> and <strong class="source-inline">-MaximumFollowRelLink</strong>) and <strong class="source-inline">-StatusCodeVariable</strong>, which can assign the HTTP response status code to a separate <a id="_idIndexMarker540"/>variable. This is useful when<a id="_idIndexMarker541"/> combined with the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">SkipHttpErrorCheck</strong></span><span class="No-Break"> parameter:</span></p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/Table_02_A.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/Table_02_B.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p class="IMG---Figure">Table 7.2 – The parameters of Invoke-WebRequest and Invoke-RestMethod, compared</p>
			<p>There are some minor differences in a couple of the parameters, for example, the <strong class="source-inline">Invoke-RestMethod -Uri</strong> parameter can also accept <strong class="source-inline">file:</strong> and <strong class="source-inline">ftp:</strong> schemes, as well as <strong class="source-inline">http:</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">https:</strong></span><span class="No-Break">.</span></p>
			<p>To really get to <a id="_idIndexMarker542"/>grips with <strong class="source-inline">Invoke-RestMethod</strong> though, we need to<a id="_idIndexMarker543"/> understand the content that we are retrieving when we use it. To do that, let’s take a closer look at the most common data <span class="No-Break">format, JSON.</span></p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor153"/>Working with JSON</h1>
			<p>What is JSON? First <a id="_idIndexMarker544"/>of all, it’s <em class="italic">not</em> a language; it’s a data format. While it has JavaScript in the name, it is used by many modern languages to generate, parse, and exchange data. It is also intended to be human-readable; we just have to know how to read it. JSON stores data in a dictionary-like format of key-value pairs. The first term is the key, and the second term is the value. The key is a string, and the value may be another string, a Boolean, a number, an array, or a JSON object. A JSON object consists of one or more key-value pairs, so because the value can be another object, JSON objects can be nested. Let’s type <span class="No-Break">the cmdlet:</span></p>
			<pre class="console">
PS C:\Users\nickp&gt; (Invoke-WebRequest random.dog/woof.json).content</pre>			<p>Then, we get something like the following <span class="No-Break">JSON response.</span></p>
			<pre class="console">
{"fileSizeBytes":176601,"url":"https://random.dog/6b41dccd-90ca-4ce8-a0e2-800e9ab92aa7.jpg"}</pre>			<p>This consists of two <span class="No-Break">key-value pairs:</span></p>
			<pre class="source-code">
"fileSizeBytes":176601
"url":"https://random.dog/6b41dccd-90ca-4ce8-a0e2-800e9ab92aa7.jpg"</pre>			<p>In the first pair, <strong class="source-inline">fileSizeBytes</strong> is the key, and the value is <strong class="source-inline">176601</strong>, which is fairly obviously the file size, in bytes. The second pair has a key of <strong class="source-inline">url</strong>, and the value is the URL that follows. The key and the value are separated by a <span class="No-Break">colon (</span><span class="No-Break"><strong class="source-inline">:</strong></span><span class="No-Break">).</span></p>
			<p>Both pairs are enclosed in a single set of braces (<strong class="source-inline">{}</strong>). The braces tell us that this is a single object consisting of the enclosed pairs. The pairs in an object are separated by a comma (<strong class="source-inline">,</strong>). There is no comma after the last pair in an object. If we wanted to include an array, we would enclose it in square brackets. Let’s write one that describes a well-known television character. Open VS Code, create a new file, and save it as something appropriate, such<a id="_idIndexMarker545"/> as <strong class="source-inline">C:\temp\poshbook\ch7\enterprise.json</strong>. Then, type <span class="No-Break">the following:</span></p>
			<pre class="source-code">
{
"Name": "Enterprise",
"Designation": "NCC-1701",
"Captain": {
    "FirstName": "James",
    "Initial": "T",
    "LastName": "Kirk"
    },
"BridgeCrew": ["Uhura", "Spock", "Sulu", "Chekhov", "Riley"],
"PhotonTorpedoes": 240000000,
"JediName": null,
"IsAwesome": true
}</pre>			<p>The following figure shows how it should look in VS Code. It’s a valid JSON file and demonstrates the valid JSON data types <span class="No-Break">and syntax.</span></p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/B17600_07_011.jpg" alt="Figure 7.11 – To boldly demonstrate JSON"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – To boldly demonstrate JSON</p>
			<p><strong class="source-inline">Name</strong> and <strong class="source-inline">Designation</strong> contain string values, <strong class="source-inline">Captain</strong> contains another JSON object, and <strong class="source-inline">BridgeCrew</strong> contains an array of strings (but it could be an array of other valid data types, or even of more JSON objects). Obviously, it has no <strong class="source-inline">JediName</strong>, and it is <span class="No-Break">definitely awesome.</span></p>
			<p>As we can see, VS Code can parse JSON and help us ensure our syntax is correct through <span class="No-Break">color coding.</span></p>
			<p>There are a few other <a id="_idIndexMarker546"/>points to remember. First of all, whitespace between elements is ignored; <strong class="source-inline">"Initial": "T"</strong> is as valid as <strong class="source-inline">"Initial": "T"</strong>. Do everyone a favor by being consistent with how you use whitespace, though. Secondly, there is no particular number format. <strong class="source-inline">240000000</strong> is not an integer or a floating-point value; it’s just a number. Finally, there is no provision for comments within JSON; this should encourage us to write clear and <span class="No-Break">descriptive code.</span></p>
			<p>Now we have a reasonable understanding of what JSON is, how can we use it in PowerShell? PowerShell doesn’t work with JSON the way it does with XML, so we need to be able to convert our JSON data into a custom PowerShell object and convert PowerShell objects into JSON. There are a pair of cmdlets that can do this for us, <strong class="source-inline">ConvertFrom-Json</strong> and <strong class="source-inline">ConvertTo-Json</strong>. Let’s look at <span class="No-Break"><strong class="source-inline">ConvertFrom-Json</strong></span><span class="No-Break"> first.</span></p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor154"/>ConvertFrom-Json</h2>
			<p><strong class="source-inline">ConvertFrom-Json</strong> will parse<a id="_idIndexMarker547"/> JSON content from a location and turn it into a<a id="_idIndexMarker548"/> custom PSObject. Let’s see how <span class="No-Break">it works.</span></p>
			<p>Open a PowerShell console and try getting the content using <span class="No-Break">the following:</span></p>
			<pre class="console">
$starship = Get-Content 'C:\temp\poshbook\ch7\enterprise.json'</pre>			<p>As we can see from the following figure, we can import the content fine, but if we use <strong class="source-inline">Get-Member</strong>, we can see we have imported that content as <span class="No-Break">a string:</span></p>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/B17600_07_012.jpg" alt="Figure 7.12 – Importing JSON with Get-Content alone"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Importing JSON with Get-Content alone</p>
			<p>Turning the data held in the JSON file into a string is going to make it difficult to use and manipulate. Now, let’s try <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">ConvertFrom-Json</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$starship = (Get-Content 'C:\temp\poshbook\ch7\enterprise.json' | ConvertFrom-Json)</pre>			<p>This time, we’ve imported it as a custom PSObject, which is much more useful. Doing it this way creates an object with properties corresponding to the key-value pairs contained in the JSON, which we can then access the same way as we can with the properties of any other PowerShell object, as in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/B17600_07_013.jpg" alt="Figure 7.13 – Importing JSON with ConvertFrom-Json"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Importing JSON with ConvertFrom-Json</p>
			<p>Let’s take a closer look at the <span class="No-Break"><strong class="source-inline">ConvertFrom-Json</strong></span><span class="No-Break"> cmdlet.</span></p>
			<p><strong class="source-inline">ConvertFrom-Json</strong> is a simple cmdlet that hides a lot of complicated work. As we’ve seen, we can use it to convert a JSON string into a custom PSObject. We can also use it to create an<a id="_idIndexMarker549"/> ordered hashtable from a JSON string; this is necessary<a id="_idIndexMarker550"/> because JSON allows duplicate key names, where only the case of the string may be different. Because PowerShell is case-insensitive, only the last key-value pair would be converted; instead, <strong class="source-inline">ConvertFrom-Json</strong> throws an error. The other reason is that JSON allows keys that are empty strings; this would lead to a PSObject with a property name that is an empty string, which isn’t allowed. See the following figure for examples of <span class="No-Break">these errors:</span></p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/B17600_07_014.jpg" alt="Figure 7.14 – Reasons to use the -AsHashtable parameter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14 – Reasons to use the -AsHashtable parameter</p>
			<p>Let’s look at <span class="No-Break">the parameters:</span></p>
			<ul>
				<li><strong class="source-inline">-AsHashtable</strong> will convert the JSON string into an ordered hashtable, which preserves the ordering of the JSON keys. We looked at ordered hashtables in <a href="B17600_04.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">PowerShell Variables and Data Structures</em>. While not as useful as a PSObject, ordered hashtables are easier to work with than strings, and in some circumstances are faster to process than <span class="No-Break">a PSObject.</span></li>
				<li><strong class="source-inline">-Depth</strong> allows us to set the maximum depth of nesting that we will process; as we saw at the start of this section, JSON key-value pairs can contain JSON objects, which in turn can contain further JSON objects. The default value of <strong class="source-inline">-Depth</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">1024</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">-InputObject</strong> only accepts strings; either the string itself, a variable that contains a string, or an expression that generates a string, as we saw in the <strong class="source-inline">enterprise.json</strong> example previously. We can’t pass a file to it directly; we need to get the file content first using <strong class="source-inline">Get-Content</strong>. Obviously, it accepts <span class="No-Break">pipeline input.</span></li>
				<li><strong class="source-inline">-NoEnumerate</strong> will read an array of strings as a single string, resulting in a single output object. Consider the example in the <span class="No-Break">following figure:</span></li>
			</ul>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/B17600_07_015.jpg" alt="Figure 7.15 – Using the -NoEnumerate parameter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15 – Using the -NoEnumerate parameter</p>
			<p>In the first cmdlet, we get three separate objects. When we include the <strong class="source-inline">-NoEnumerate</strong> parameter, we get a single object, <strong class="source-inline">fish </strong><span class="No-Break"><strong class="source-inline">cat dog</strong></span><span class="No-Break">.</span></p>
			<p>Now we’ve<a id="_idIndexMarker551"/> seen<a id="_idIndexMarker552"/> how to convert JSON into a format that PowerShell can easily work with, let’s look at how we can convert PowerShell objects <span class="No-Break">into JSON.</span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor155"/>ConvertTo-Json</h2>
			<p><strong class="source-inline">ConvertTo-Json</strong> will take any <a id="_idIndexMarker553"/>PowerShell object and convert it into a JSON-formatted <a id="_idIndexMarker554"/>string. It does this by converting the properties of the object into key-value pairs, where the property name is the key, and discarding any methods the object has. Let’s see it working. If you didn’t create the <strong class="source-inline">$starship</strong> variable as a PSObject previously, do <span class="No-Break">so now:</span></p>
			<pre class="console">
$starship = (Get-Content 'C:\temp\poshbook\ch7\enterprise.json' | ConvertFrom-Json)</pre>			<p>Now, let’s say we’ve been in a battle, and need to update our photon torpedo count. We can type <span class="No-Break">the following:</span></p>
			<pre class="console">
$starship.PhotonTorpedoes = 1900000000</pre>			<p>This will update it on the PSObject, and then we use <strong class="source-inline">ConvertTo-Json</strong> to produce a JSON-formatted object to replace the original that <span class="No-Break">we imported:</span></p>
			<pre class="console">
$starship | ConvertTo-Json | Out-File "C:\temp\poshbook\ch7\klingonattack.json"</pre>			<p>If we open that in VS Code, we <a id="_idIndexMarker555"/>can see that it is a correctly formatted JSON file with<a id="_idIndexMarker556"/> the updated <span class="No-Break">torpedo count:</span></p>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/B17600_07_016.jpg" alt="Figure 7.16 – After a Klingon attack"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.16 – After a Klingon attack</p>
			<p>We can see in line 16 that the torpedo count has changed. VS Code still sees this as valid JSON with no errors. We can see the formatting has changed from the original file; each element of the <strong class="source-inline">BridgeCrew</strong> array is on its own line because of the formatting rules that <strong class="source-inline">ConvertTo-Json</strong> uses, but other than that it’s the same as the original <strong class="source-inline">enterprise.json</strong> file. We could then feed this JSON string to an API to update the information on <span class="No-Break">a server.</span></p>
			<p>Like <strong class="source-inline">ConvertFrom-Json</strong>, <strong class="source-inline">ConvertTo-Json</strong> is a deceptively simple cmdlet that hides a lot of work behind a short list of parameters. Let’s take a look <span class="No-Break">at them:</span></p>
			<ul>
				<li><strong class="source-inline">-AsArray</strong> will convert a PSObject into a JSON array unconditionally. Consider the following examples in the <span class="No-Break">following figure.</span></li>
			</ul>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/B17600_07_017.jpg" alt="Figure 7.17 – The -AsArray parameter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.17 – The -AsArray parameter</p>
			<ul>
				<li>In the first<a id="_idIndexMarker557"/> line, I’m<a id="_idIndexMarker558"/> converting two strings into JSON. <strong class="source-inline">ConvertTo-Json</strong> automatically treats them as an array and puts them in square brackets because they are two separate objects. In the second line, I’m only feeding a single string into the pipeline, and <strong class="source-inline">ConvertTo-Json</strong> treats it as a single string. But what if I want it to be formatted as a single-member array? Then, I use the <strong class="source-inline">-AsArray</strong> parameter, and I get my <span class="No-Break">square brackets.</span></li>
				<li><strong class="source-inline">-Compress</strong> removes whitespace and indented formatting from the JSON output. The output will be on a <span class="No-Break">single line.</span></li>
				<li><strong class="source-inline">-Depth</strong> specifies how many levels of nested objects can be included in the JSON output. We can have between zero and one hundred levels of nesting, but the default is a miserly two levels, which can catch people out. We get a warning if our output has more than this level. Consider the JSON in the <span class="No-Break">following figure:</span></li>
			</ul>
			<div>
				<div id="_idContainer148" class="IMG---Figure">
					<img src="image/B17600_07_018.jpg" alt="Figure 7.18 – nesting.json"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.18 – nesting.json</p>
			<p class="list-inset">If we ingest <a id="_idIndexMarker559"/>it into<a id="_idIndexMarker560"/> a variable, then convert it back into JSON, and then we get the warning in the following figure. Notice that the third level of nesting, on the line beginning with <strong class="source-inline">"really?"</strong>, is not converted into a JSON object, but into a string representing <span class="No-Break">a hashtable:</span></p>
			<div>
				<div id="_idContainer149" class="IMG---Figure">
					<img src="image/B17600_07_019.jpg" alt="Figure 7.19 – We need to increase -Depth"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.19 – We need to increase -Depth</p>
			<ul>
				<li><strong class="source-inline">-EnumsAsStrings</strong> will convert all the values <a id="_idIndexMarker561"/>of the <strong class="bold">enum</strong> type in the input object into their equivalent strings. What does that mean? An enum type enumerates a value as one of a set of predefined constants. An example is the <strong class="source-inline">DayOfWeek</strong> property of a <strong class="source-inline">DateTime</strong> object. When we type <strong class="source-inline">(Get-Date).DayOfWeek</strong>, it returns a string, <strong class="source-inline">Saturday</strong>, but the value is actually held as an integer between 1 and 7. Have a look at the example in the <span class="No-Break">following figure:</span></li>
			</ul>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/B17600_07_020.jpg" alt="Figure 7.20 - Using the -EnumAsStrings parameter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.20 - Using the -EnumAsStrings parameter</p>
			<ul>
				<li><strong class="source-inline">-EscapeHandling</strong> controls how certain characters are escaped, such as the newline character (<strong class="source-inline">`n</strong>). There are three possible settings – <strong class="source-inline">Default</strong>, where only control characters are escaped, <strong class="source-inline">EscapeNonAscii</strong>, where all non-ASCII and control characters are escaped, and <strong class="source-inline">EscapeHtml</strong>, where special HTML characters such as <strong class="source-inline">&lt;</strong>, <strong class="source-inline">&gt;</strong>, <strong class="source-inline">?</strong>, <strong class="source-inline">&amp;</strong>, <strong class="source-inline">'</strong>, and <strong class="source-inline">"</strong> <span class="No-Break">are escaped.</span></li>
				<li><strong class="source-inline">-InputObject</strong> accepts any type of PowerShell object explicitly or via the pipeline, as an expression, or as <span class="No-Break">a variable.</span></li>
			</ul>
			<p>Most of these parameters are formatting controls intended to make it easier to work with APIs, which <a id="_idIndexMarker562"/>may have different expectations of the input we give <a id="_idIndexMarker563"/>them. There is one more command that helps us get our data into a format that can be consumed by an <span class="No-Break">API; </span><span class="No-Break"><strong class="source-inline">Test-Json</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor156"/>Test-Json</h2>
			<p>The <strong class="source-inline">Test-Json</strong> cmdlet<a id="_idIndexMarker564"/> will test the validity of a string as a JSON object. This is<a id="_idIndexMarker565"/> extremely useful when writing scripts to work with APIs to make sure our data can be consumed correctly. It is especially useful when we consider that not everything we produce with <strong class="source-inline">ConvertTo-Json</strong> is necessarily good JSON. Consider the examples in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/B17600_07_021.jpg" alt="Figure 7.21 – Getting things wrong with ConvertTo-Json"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.21 – Getting things wrong with ConvertTo-Json</p>
			<p>In the first line, we create a variable called <strong class="source-inline">$date</strong> and put the current date in it. This is an object of the <strong class="source-inline">DateTime</strong> type. Unsurprisingly, when we try the cmdlet in line 2, <strong class="source-inline">Test-Json</strong> is unhappy. In line 3, we convert the expression into JSON using <strong class="source-inline">ConvertTo-Json</strong>, and then test it again in line 4. Horror! Although it has been converted successfully, it’s still not compliant JSON. In line 5, we can try testing just the string output from line 3, and we can see what the problem is. While <strong class="source-inline">ConvertTo-Json</strong> has taken the value from the <strong class="source-inline">$date</strong> variable, it hasn’t formatted it correctly as a string. When we correct the formatting in line 6, we can see that <strong class="source-inline">Test-Json</strong> is now happy. The clever<a id="_idIndexMarker566"/> way<a id="_idIndexMarker567"/> to do it, of course, is <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer152" class="IMG---Figure">
					<img src="image/B17600_07_022.jpg" alt="Figure 7.22 – The right way to do it"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.22 – The right way to do it</p>
			<p>There are a couple of parameters with <strong class="source-inline">Test-Json</strong> that allow us to define custom JSON schemas if we need to produce specialized or custom JSON for particular systems, but we don’t need to go <a id="_idIndexMarker568"/>into them here. One interesting quirk of the cmdlet is<a id="_idIndexMarker569"/> that the <strong class="source-inline">-InputObject</strong> parameter found on almost all cmdlets is called <strong class="source-inline">-Json</strong> here, but functionally it is the same; it takes a string, either explicitly or via <span class="No-Break">the pipeline.</span></p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor157"/>Let’s have some fun – who is on the International Space Station?</h1>
			<p>Since I was small, I have <a id="_idIndexMarker570"/>been fascinated by space. One of my earliest memories is sitting up with my mam and dad to watch an Apollo moon landing on a creaky old black and white television. It wasn’t Apollo 11. I’m not quite that old. As an exercise, let’s see whether we can find out who is on the ISS, and present that data on a web page. We’ll need to refer to some of the stuff we learned about in the last chapter to accomplish this; <a href="B17600_06.xhtml#_idTextAnchor117"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">PowerShell and Files – Reading, Writing, and Manipulating Data</em>, as well as what we’ve learned in this chapter. We’re not going to walk through it – try and accomplish this on your own. There are lots of ways to do this, and I’ve put my solution in the answers. Here are some <span class="No-Break">hints though.</span></p>
			<p class="callout-heading">Activity</p>
			<p class="callout">We can break this down into <span class="No-Break">two tasks:</span></p>
			<p class="callout">Task 1 – use an API to find out who is on the ISS, <span class="No-Break">right now</span></p>
			<p class="callout">Task 2 – display this data in an <span class="No-Break">HTML file</span></p>
			<p>There is an API with the data we require <span class="No-Break">at </span><a href="http://api.open-notify.org/astros.json"><span class="No-Break">http://api.open-notify.org/astros.json</span></a></p>
			<p>You could use <strong class="source-inline">Invoke-WebRequest</strong>, but it’s probably easier to <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">Invoke-RestMethod</strong></span></p>
			<p>You will probably want to use <strong class="source-inline">ConvertTo-Html</strong> to produce the web page. You may need to study the help file for this cmdlet to understand some of the <span class="No-Break">formatting options.</span></p>
			<p>Here’s my <span class="No-Break">finished attempt:</span></p>
			<div>
				<div id="_idContainer153" class="IMG---Figure">
					<img src="image/B17600_07_023.jpg" alt="Figure 7.23 – Just beautiful"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.23 – Just beautiful</p>
			<p>This should stretch us a <a id="_idIndexMarker571"/>little bit, but we’ve got all the knowledge we need to get this done and have some fun along <span class="No-Break">the way.</span></p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor158"/>Summary</h1>
			<p>We’ve come on a bit of a journey in this chapter and started to interact with the world outside our local machines. The techniques we covered will be used throughout the book, so we will get plenty of opportunity to become properly familiar <span class="No-Break">with them.</span></p>
			<p>We started out by looking at how we can work with HTML data over HTTP using the <strong class="source-inline">Invoke-WebRequest</strong> cmdlet. We saw that this is a complex cmdlet with many options, and we covered the parameters frequently used with it. We focused on authentication, as this will be a key technique required for retrieving and posting data. We also saw that it is difficult to manipulate the data we ingest using this cmdlet, as it <span class="No-Break">is text-based.</span></p>
			<p>We then talked about an easier way to ingest data from servers over a network, using an API. We discussed the common types of API, in particular the most common, <span class="No-Break">REST APIs.</span></p>
			<p>We then looked at the PowerShell cmdlet for working with REST – <strong class="source-inline">Invoke-RestMethod</strong>. We saw how similar this cmdlet is to <strong class="source-inline">Invoke-WebRequest</strong>, but that instead of producing a page of HTML, it outputs data in a <span class="No-Break">structured format.</span></p>
			<p>We went on to explore the most common format for this data, JSON. We looked at the three cmdlets in PowerShell for working with JSON data; <strong class="source-inline">ConvertFrom-Json</strong>, <strong class="source-inline">ConvertTo-Json</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Test-Json</strong></span><span class="No-Break">.</span></p>
			<p>Finally, we used our new knowledge to produce an HTML web page displaying the names of the astronauts currently on board <span class="No-Break">the ISS.</span></p>
			<p>This chapter marks the end of the coding fundamentals section of this book; we’ve covered data structures, flow control, file manipulation, and connecting to the internet. In the next chapter, we are going to start looking at turning our lines of scruffy code into scripts and tools that we can share with other people. It’ll <span class="No-Break">be fun.</span></p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor159"/>Exercises</h1>
			<ol>
				<li>How would we send a delete request to the following <span class="No-Break">URL: </span><span class="No-Break"><strong class="source-inline">https://httpbin.org/delete</strong></span><span class="No-Break">?</span></li>
				<li>What parameters would we need to use <strong class="source-inline">Invoke-WebRequest</strong> with a <span class="No-Break">stateful endpoint?</span></li>
				<li>We try to connect to a website and see the <span class="No-Break">following error:</span><pre class="source-code">
<strong class="bold">Invoke-WebRequest: The remote certificate is invalid because of errors in the certificate chain: NotTimeValid</strong></pre><p class="list-inset">How can we continue to the site <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Invoke-WebRequest</strong></span><span class="No-Break">?</span></p></li>				<li>Which type of API is stateful? What does <span class="No-Break">this mean?</span></li>
				<li>We sign up to a web service and get an authentication token. We encode the token using <strong class="source-inline">ConvertTo-SecureString</strong>, store it in a variable called <strong class="source-inline">$token</strong>, and then use the variable to create a web request <span class="No-Break">like this:</span><pre class="source-code">
<strong class="bold">Invoke-WebRequest -Uri 'https://webservice.com/endpoint' -Headers @{Authorization = "Bearer $token"}</strong></pre><p class="list-inset">We get an authentication error. Have we done something wrong, or is the <span class="No-Break">token bad?</span></p></li>				<li>Get the latitude and longitude of the ISS right now. You can <span class="No-Break">use </span><a href="http://api.open-notify.org/iss-now.json"><span class="No-Break">http://api.open-notify.org/iss-now.json</span></a><span class="No-Break">.</span></li>
				<li>How many universities in the UK have the letter ‘<em class="italic">x</em>’ in their name? Use the API at <a href="http://universities.hipolabs.com/search?country=United+Kingdom">http://universities.hipolabs.com/search?country=United+Kingdom</a> to <span class="No-Break">find out.</span></li>
				<li>How can we use <strong class="source-inline">Test-Json</strong> to validate our generated JSON against a <span class="No-Break">custom schema?</span></li>
			</ol>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor160"/>Further reading</h1>
			<ul>
				<li>More on <span class="No-Break">APIs here:</span><p class="list-inset"><a href="https://www.packtpub.com/product/understanding-apis-and-restful-apis-crash-course-video/9781800564121"><span class="No-Break">https://www.packtpub.com/product/understanding-apis-and-restful-apis-crash-course-video/9781800564121</span></a></p><p class="list-inset"><a href="https://www.digitalfluency.guide/apis/introduction-to-apis"><span class="No-Break">https://www.digitalfluency.guide/apis/introduction-to-apis</span></a></p></li>
				<li>Lots more on <span class="No-Break">REST here:</span><p class="list-inset"><a href="https://restfulapi.net/"><span class="No-Break">https://restfulapi.net/</span></a></p></li>
				<li>A good JSON tutorial, but with <span class="No-Break">some JavaScript:</span><p class="list-inset"><a href="https://www.w3schools.com/js/js_json_intro.asp"><span class="No-Break">https://www.w3schools.com/js/js_json_intro.asp</span></a></p></li>
				<li>How to use <span class="No-Break">JSON schemas:</span><p class="list-inset"><a href="https://json-schema.org/understanding-json-schema"><span class="No-Break">https://json-schema.org/understanding-json-schema</span></a></p></li>
			</ul>
		</div>
	

		<div id="_idContainer155" class="Content">
			<h1 id="_idParaDest-157" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor161"/>Part 2: Scripting and Toolmaking</h1>
			<p>This part walks you through turning a set of cmdlets into a script, introduces functional programming, shows you how to turn scripts into modules, and how to share those modules with colleagues and others using GitHub and GitLab. It also includes a chapter on PowerShell security, so that you don’t inadvertently distribute code that is less secure than it <span class="No-Break">could be.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B17600_08.xhtml#_idTextAnchor162"><em class="italic">Chapter 8</em></a>, <em class="italic">Writing Our First Script – Turning Simple Cmdlets into Reusable Code</em></li>
				<li><a href="B17600_09.xhtml#_idTextAnchor184"><em class="italic">Chapter 9</em></a>, <em class="italic">Don’t Repeat Yourself – Functions and Scriptblocks</em></li>
				<li><a href="B17600_10.xhtml#_idTextAnchor201"><em class="italic">Chapter 10</em></a>, <em class="italic">Error Handling – Oh No! It’s Gone Wrong!</em></li>
				<li><a href="B17600_11.xhtml#_idTextAnchor218"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating Our First Module</em></li>
				<li><a href="B17600_12.xhtml#_idTextAnchor236"><em class="italic">Chapter 12</em></a>, <em class="italic">Securing PowerShell</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer156">
			</div>
		</div>
	</body></html>